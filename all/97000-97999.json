[{"original_method":"private void annotateExternally(@NotNull final PsiModifierListOwner listOwner,\n                                  @NotNull final String annotationFQName,\n                                  @Nullable final XmlFile xmlFile,\n                                  @NotNull final PsiFile codeUsageFile,\n                                  @Nullable final PsiNameValuePair[] values) {\n    if (xmlFile == null) {\n      notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n      return;\n    }\n    CommandProcessor.getInstance().executeCommand(myPsiManager.getProject(), new Runnable() {\n      @Override\n      public void run() {\n        try {\n          final XmlDocument document = xmlFile.getDocument();\n          if (document != null) {\n            final XmlTag rootTag = document.getRootTag();\n            final String externalName = getExternalName(listOwner, false);\n            if (rootTag != null) {\n              for (XmlTag tag : rootTag.getSubTags()) {\n                if (Comparing.strEqual(StringUtil.unescapeXml(tag.getAttributeValue(\"name\")), externalName)) {\n                  for (XmlTag annTag : tag.getSubTags()) {\n                    if (Comparing.strEqual(annTag.getAttributeValue(\"name\"), annotationFQName)) {\n                      annTag.delete();\n                      break;\n                    }\n                  }\n                  tag.add(XmlElementFactory.getInstance(myPsiManager.getProject()).createTagFromText(\n                    createAnnotationTag(annotationFQName, values)));\n                  commitChanges(xmlFile);\n                  notifyAfterAnnotationChanging(listOwner, annotationFQName, true);\n                  return;\n                }\n              }\n              @NonNls String text =\n                \"<item name=\\'\" + StringUtil.escapeXml(externalName) + \"\\'>\\n\";\n              text += createAnnotationTag(annotationFQName, values);\n              text += \"<\/item>\";\n              rootTag.add(XmlElementFactory.getInstance(myPsiManager.getProject()).createTagFromText(text));\n            }\n          }\n          commitChanges(xmlFile);\n          notifyAfterAnnotationChanging(listOwner, annotationFQName, true);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n          notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n        }\n        finally {\n          dropCache();\n          if (codeUsageFile.getVirtualFile().isInLocalFileSystem()) {\n            UndoUtil.markPsiFileForUndo(codeUsageFile);\n          }\n        }\n      }\n    }, ExternalAnnotationsManagerImpl.class.getName(), null);\n  }","id":97000,"modified_method":"private void annotateExternally(@NotNull final PsiModifierListOwner listOwner,\n                                  @NotNull final String annotationFQName,\n                                  @Nullable final XmlFile xmlFile,\n                                  @NotNull final PsiFile codeUsageFile,\n                                  @Nullable final PsiNameValuePair[] values) {\n    if (xmlFile == null) {\n      notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n      return;\n    }\n    CommandProcessor.getInstance().executeCommand(myPsiManager.getProject(), new Runnable() {\n      @Override\n      public void run() {\n        try {\n          final XmlDocument document = xmlFile.getDocument();\n          if (document != null) {\n            final XmlTag rootTag = document.getRootTag();\n            final String externalName = getExternalName(listOwner, false);\n            if (rootTag != null) {\n              for (XmlTag item : rootTag.getSubTags()) {\n                if (Comparing.strEqual(StringUtil.unescapeXml(item.getAttributeValue(\"name\")), externalName)) {\n                  for (XmlTag annotation : item.getSubTags()) {\n                    if (Comparing.strEqual(annotation.getAttributeValue(\"name\"), annotationFQName)) {\n                      annotation.delete();\n                      break;\n                    }\n                  }\n                  XmlTag newTag = XmlElementFactory.getInstance(myPsiManager.getProject()).createTagFromText(\n                    createAnnotationTag(annotationFQName, values));\n                  item.add(newTag);\n                  commitChanges(xmlFile);\n                  notifyAfterAnnotationChanging(listOwner, annotationFQName, true);\n                  return;\n                }\n              }\n              @NonNls String text =\n                \"<item name=\\'\" + StringUtil.escapeXml(externalName) + \"\\'>\\n\";\n              text += createAnnotationTag(annotationFQName, values);\n              text += \"<\/item>\";\n              rootTag.add(XmlElementFactory.getInstance(myPsiManager.getProject()).createTagFromText(text));\n            }\n          }\n          commitChanges(xmlFile);\n          notifyAfterAnnotationChanging(listOwner, annotationFQName, true);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n          notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n        }\n        finally {\n          dropCache();\n          if (codeUsageFile.getVirtualFile().isInLocalFileSystem()) {\n            UndoUtil.markPsiFileForUndo(codeUsageFile);\n          }\n        }\n      }\n    }, ExternalAnnotationsManagerImpl.class.getName(), null);\n  }","commit_id":"ead4e15edd493bc815795c0a10809a2db6fad49a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void annotateExternally(@NotNull final VirtualFile root,\n                                  @NotNull final PsiModifierListOwner listOwner,\n                                  @NotNull final Project project,\n                                  @NotNull final String packageName,\n                                  @NotNull final String annotationFQName,\n                                  @NotNull final PsiFile fromFile,\n                                  @Nullable final PsiNameValuePair[] value) {\n    List<XmlFile> xmlFiles = findExternalAnnotationsXmlFiles(listOwner);\n\n    final XmlFile existingXml = findXmlFileInRoot(xmlFiles, root);\n    if (existingXml != null && !CodeInsightUtilBase.preparePsiElementForWrite(existingXml)) {\n      notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n      return;\n    }\n\n    final List<PsiFile> annotationFiles = xmlFiles == null ? new ArrayList<PsiFile>() : new ArrayList<PsiFile>(xmlFiles);\n\n    new WriteCommandAction(project) {\n      @Override\n      protected void run(final Result result) throws Throwable {\n        if (existingXml != null) {\n          annotateExternally(listOwner, annotationFQName, existingXml, fromFile, value);\n        }\n        else {\n          XmlFile newXml = createAnnotationsXml(root, packageName);\n          if (newXml == null) {\n            notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n          }\n          else {\n            annotationFiles.add(newXml);\n            myExternalAnnotations.put(getFQN(packageName, fromFile), annotationFiles);\n            annotateExternally(listOwner, annotationFQName, newXml, fromFile, value);\n          }\n        }\n\n        UndoManager.getInstance(project).undoableActionPerformed(new BasicUndoableAction() {\n          @Override\n          public void undo() {\n            dropCache();\n            notifyChangedExternally();\n          }\n\n          @Override\n          public void redo() {\n            dropCache();\n            notifyChangedExternally();\n          }\n        });\n      }\n    }.execute();\n  }","id":97001,"modified_method":"private void annotateExternally(@NotNull final VirtualFile root,\n                                  @NotNull final PsiModifierListOwner listOwner,\n                                  @NotNull final Project project,\n                                  @NotNull final String packageName,\n                                  @NotNull final String annotationFQName,\n                                  @NotNull final PsiFile fromFile,\n                                  @Nullable final PsiNameValuePair[] value) {\n    List<XmlFile> xmlFiles = findExternalAnnotationsXmlFiles(listOwner);\n\n    final XmlFile existingXml = findXmlFileInRoot(xmlFiles, root);\n    if (existingXml != null && !CodeInsightUtilBase.preparePsiElementForWrite(existingXml)) {\n      notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n      return;\n    }\n\n    final Set<PsiFile> annotationFiles = xmlFiles == null ? new THashSet<PsiFile>() : new THashSet<PsiFile>(xmlFiles);\n\n    new WriteCommandAction(project) {\n      @Override\n      protected void run(final Result result) throws Throwable {\n        if (existingXml != null) {\n          annotateExternally(listOwner, annotationFQName, existingXml, fromFile, value);\n        }\n        else {\n          XmlFile newXml = createAnnotationsXml(root, packageName);\n          if (newXml == null) {\n            notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n          }\n          else {\n            annotationFiles.add(newXml);\n            cacheExternalAnnotations(packageName, fromFile, new SmartList<PsiFile>(annotationFiles));\n            annotateExternally(listOwner, annotationFQName, newXml, fromFile, value);\n          }\n        }\n\n        UndoManager.getInstance(project).undoableActionPerformed(new BasicUndoableAction() {\n          @Override\n          public void undo() {\n            dropCache();\n            notifyChangedExternally();\n          }\n\n          @Override\n          public void redo() {\n            dropCache();\n            notifyChangedExternally();\n          }\n        });\n      }\n    }.execute();\n  }","commit_id":"ead4e15edd493bc815795c0a10809a2db6fad49a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setupRootAndAnnotateExternally(@NotNull final OrderEntry entry,\n                                              @NotNull final Project project,\n                                              @NotNull final PsiModifierListOwner listOwner,\n                                              @NotNull final String annotationFQName,\n                                              @NotNull final PsiFile fromFile,\n                                              @NotNull final String packageName,\n                                              @Nullable final PsiNameValuePair[] value) {\n    final FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleFolderDescriptor();\n    descriptor.setTitle(ProjectBundle.message(\"external.annotations.root.chooser.title\", entry.getPresentableName()));\n    descriptor.setDescription(ProjectBundle.message(\"external.annotations.root.chooser.description\"));\n    final VirtualFile newRoot = FileChooser.chooseFile(descriptor, project, null);\n    if (newRoot == null) {\n      notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n      return;\n    }\n    new WriteCommandAction(project) {\n      @Override\n      protected void run(final Result result) throws Throwable {\n        appendChosenAnnotationsRoot(entry, newRoot);\n        XmlFile xmlFileInRoot = findXmlFileInRoot(findExternalAnnotationsXmlFiles(listOwner), newRoot);\n        if (xmlFileInRoot != null) { //file already exists under appeared content root\n          if (!CodeInsightUtilBase.preparePsiElementForWrite(xmlFileInRoot)) {\n            notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n            return;\n          }\n          annotateExternally(listOwner, annotationFQName, xmlFileInRoot, fromFile, value);\n        }\n        else {\n          final XmlFile annotationsXml = createAnnotationsXml(newRoot, packageName);\n          if (annotationsXml != null) {\n            final List<PsiFile> createdFiles = new ArrayList<PsiFile>();\n            createdFiles.add(annotationsXml);\n            String fqn = getFQN(packageName, fromFile);\n            if (fqn != null) {\n              myExternalAnnotations.put(fqn, createdFiles);\n            }\n          }\n          annotateExternally(listOwner, annotationFQName, annotationsXml, fromFile, value);\n        }\n      }\n    }.execute();\n  }","id":97002,"modified_method":"private void setupRootAndAnnotateExternally(@NotNull final OrderEntry entry,\n                                              @NotNull final Project project,\n                                              @NotNull final PsiModifierListOwner listOwner,\n                                              @NotNull final String annotationFQName,\n                                              @NotNull final PsiFile fromFile,\n                                              @NotNull final String packageName,\n                                              @Nullable final PsiNameValuePair[] value) {\n    final FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleFolderDescriptor();\n    descriptor.setTitle(ProjectBundle.message(\"external.annotations.root.chooser.title\", entry.getPresentableName()));\n    descriptor.setDescription(ProjectBundle.message(\"external.annotations.root.chooser.description\"));\n    final VirtualFile newRoot = FileChooser.chooseFile(descriptor, project, null);\n    if (newRoot == null) {\n      notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n      return;\n    }\n    new WriteCommandAction(project) {\n      @Override\n      protected void run(final Result result) throws Throwable {\n        appendChosenAnnotationsRoot(entry, newRoot);\n        XmlFile xmlFileInRoot = findXmlFileInRoot(findExternalAnnotationsXmlFiles(listOwner), newRoot);\n        if (xmlFileInRoot != null) { //file already exists under appeared content root\n          if (!CodeInsightUtilBase.preparePsiElementForWrite(xmlFileInRoot)) {\n            notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n            return;\n          }\n          annotateExternally(listOwner, annotationFQName, xmlFileInRoot, fromFile, value);\n        }\n        else {\n          final XmlFile annotationsXml = createAnnotationsXml(newRoot, packageName);\n          if (annotationsXml != null) {\n            List<PsiFile> createdFiles = new SmartList<PsiFile>(annotationsXml);\n            cacheExternalAnnotations(packageName, fromFile, createdFiles);\n          }\n          annotateExternally(listOwner, annotationFQName, annotationsXml, fromFile, value);\n        }\n      }\n    }.execute();\n  }","commit_id":"ead4e15edd493bc815795c0a10809a2db6fad49a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void annotateExternally(@NotNull final PsiModifierListOwner listOwner,\n                                 @NotNull final String annotationFQName,\n                                 @NotNull final PsiFile fromFile,\n                                 @Nullable final PsiNameValuePair[] value) {\n    final Project project = myPsiManager.getProject();\n    final PsiFile containingFile = listOwner.getContainingFile();\n    if (!(containingFile instanceof PsiJavaFile)) {\n      notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n      return;\n    }\n    final String packageName = ((PsiJavaFile)containingFile).getPackageName();\n    final VirtualFile containingVirtualFile = containingFile.getVirtualFile();\n    LOG.assertTrue(containingVirtualFile != null);\n    final List<OrderEntry> entries = ProjectRootManager.getInstance(project).getFileIndex().getOrderEntriesForFile(containingVirtualFile);\n    if (entries.isEmpty()) {\n      notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n      return;\n    }\n    for (final OrderEntry entry : entries) {\n      if (entry instanceof ModuleOrderEntry) continue;\n      VirtualFile[] roots = AnnotationOrderRootType.getFiles(entry);\n      roots = filterByReadOnliness(roots);\n\n      if (roots.length > 0) {\n        chooseRootAndAnnotateExternally(listOwner, annotationFQName, fromFile, project, packageName, roots, value);\n      }\n      else {\n        if (ApplicationManager.getApplication().isUnitTestMode() || ApplicationManager.getApplication().isHeadlessEnvironment()) {\n          notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n          return;\n        }\n        SwingUtilities.invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            setupRootAndAnnotateExternally(entry, project, listOwner, annotationFQName, fromFile, packageName, value);\n          }\n        });\n      }\n      break;\n    }\n  }","id":97003,"modified_method":"@Override\n  public void annotateExternally(@NotNull final PsiModifierListOwner listOwner,\n                                 @NotNull final String annotationFQName,\n                                 @NotNull final PsiFile fromFile,\n                                 @Nullable final PsiNameValuePair[] value) {\n    final Project project = myPsiManager.getProject();\n    final PsiFile containingFile = listOwner.getContainingFile();\n    if (!(containingFile instanceof PsiJavaFile)) {\n      notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n      return;\n    }\n    final String packageName = ((PsiJavaFile)containingFile).getPackageName();\n    final VirtualFile containingVirtualFile = containingFile.getVirtualFile();\n    LOG.assertTrue(containingVirtualFile != null);\n    final List<OrderEntry> entries = ProjectRootManager.getInstance(project).getFileIndex().getOrderEntriesForFile(containingVirtualFile);\n    if (entries.isEmpty()) {\n      notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n      return;\n    }\n    for (final OrderEntry entry : entries) {\n      if (entry instanceof ModuleOrderEntry) continue;\n      VirtualFile[] roots = AnnotationOrderRootType.getFiles(entry);\n      roots = filterByReadOnliness(roots);\n\n      if (roots.length > 0) {\n        chooseRootAndAnnotateExternally(listOwner, annotationFQName, fromFile, project, packageName, roots, value);\n      }\n      else {\n        Application application = ApplicationManager.getApplication();\n        if (application.isUnitTestMode() || application.isHeadlessEnvironment()) {\n          notifyAfterAnnotationChanging(listOwner, annotationFQName, false);\n          return;\n        }\n        application.invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            setupRootAndAnnotateExternally(entry, project, listOwner, annotationFQName, fromFile, packageName, value);\n          }\n        }, project.getDisposed());\n      }\n      break;\n    }\n  }","commit_id":"ead4e15edd493bc815795c0a10809a2db6fad49a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void appendChosenAnnotationsRoot(@NotNull final OrderEntry entry, @NotNull final VirtualFile vFile) {\n    if (entry instanceof LibraryOrderEntry) {\n      Library library = ((LibraryOrderEntry)entry).getLibrary();\n      LOG.assertTrue(library != null);\n      final ModifiableRootModel rootModel = ModuleRootManager.getInstance(entry.getOwnerModule()).getModifiableModel();\n      final Library.ModifiableModel model = library.getModifiableModel();\n      model.addRoot(vFile, AnnotationOrderRootType.getInstance());\n      model.commit();\n      rootModel.commit();\n    }\n    else if (entry instanceof ModuleSourceOrderEntry) {\n      final ModifiableRootModel model = ModuleRootManager.getInstance(entry.getOwnerModule()).getModifiableModel();\n      final JavaModuleExternalPaths extension = model.getModuleExtension(JavaModuleExternalPaths.class);\n      extension.setExternalAnnotationUrls(ArrayUtil.mergeArrays(extension.getExternalAnnotationsUrls(), vFile.getUrl()));\n      model.commit();\n    }\n    else if (entry instanceof JdkOrderEntry) {\n      final SdkModificator sdkModificator = ((JdkOrderEntry)entry).getJdk().getSdkModificator();\n      sdkModificator.addRoot(vFile, AnnotationOrderRootType.getInstance());\n      sdkModificator.commitChanges();\n    }\n    myExternalAnnotations.clear();\n  }","id":97004,"modified_method":"private void appendChosenAnnotationsRoot(@NotNull final OrderEntry entry, @NotNull final VirtualFile vFile) {\n    if (entry instanceof LibraryOrderEntry) {\n      Library library = ((LibraryOrderEntry)entry).getLibrary();\n      LOG.assertTrue(library != null);\n      final ModifiableRootModel rootModel = ModuleRootManager.getInstance(entry.getOwnerModule()).getModifiableModel();\n      final Library.ModifiableModel model = library.getModifiableModel();\n      model.addRoot(vFile, AnnotationOrderRootType.getInstance());\n      model.commit();\n      rootModel.commit();\n    }\n    else if (entry instanceof ModuleSourceOrderEntry) {\n      final ModifiableRootModel model = ModuleRootManager.getInstance(entry.getOwnerModule()).getModifiableModel();\n      final JavaModuleExternalPaths extension = model.getModuleExtension(JavaModuleExternalPaths.class);\n      extension.setExternalAnnotationUrls(ArrayUtil.mergeArrays(extension.getExternalAnnotationsUrls(), vFile.getUrl()));\n      model.commit();\n    }\n    else if (entry instanceof JdkOrderEntry) {\n      final SdkModificator sdkModificator = ((JdkOrderEntry)entry).getJdk().getSdkModificator();\n      sdkModificator.addRoot(vFile, AnnotationOrderRootType.getInstance());\n      sdkModificator.commitChanges();\n    }\n    dropCache();\n  }","commit_id":"ead4e15edd493bc815795c0a10809a2db6fad49a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void compact() {\n    myMap.compact();\n  }","id":97005,"modified_method":"public void compact() {\n    ((THashMap)myMap).compact();\n  }","commit_id":"ead4e15edd493bc815795c0a10809a2db6fad49a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Iterable<V> get(K name) {\n    final Object value = myMap.get(name);\n    if (value == null) return Collections.emptyList();\n\n    if (value instanceof Object[]) {\n      return (Iterable<V>)Arrays.asList((Object[])value);\n    }\n\n    return Collections.singleton((V)value);\n  }","id":97006,"modified_method":"@NotNull\n  public Iterable<V> get(@NotNull K name) {\n    final Object value = myMap.get(name);\n    return rawValueToCollection(value);\n  }","commit_id":"ead4e15edd493bc815795c0a10809a2db6fad49a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected List<VirtualFile> getExternalAnnotationsRoots(@NotNull VirtualFile libraryFile) {\n    final List<OrderEntry> entries = ProjectRootManager.getInstance(myPsiManager.getProject()).getFileIndex().getOrderEntriesForFile(\n      libraryFile);\n    List<VirtualFile> result = new ArrayList<VirtualFile>();\n    for (OrderEntry entry : entries) {\n      if (entry instanceof ModuleOrderEntry) {\n        continue;\n      }\n      final String[] externalUrls = AnnotationOrderRootType.getUrls(entry);\n      for (String url : externalUrls) {\n        VirtualFile root = VirtualFileManager.getInstance().findFileByUrl(url);\n        if (root != null) {\n          result.add(root);\n        }\n      }\n    }\n    return result;\n  }","id":97007,"modified_method":"@Override\n  @NotNull\n  protected List<VirtualFile> getExternalAnnotationsRoots(@NotNull VirtualFile libraryFile) {\n    ProjectFileIndex fileIndex = ProjectRootManager.getInstance(myPsiManager.getProject()).getFileIndex();\n    List<OrderEntry> entries = fileIndex.getOrderEntriesForFile(libraryFile);\n    List<VirtualFile> result = new ArrayList<VirtualFile>();\n    VirtualFileManager vfManager = VirtualFileManager.getInstance();\n    for (OrderEntry entry : entries) {\n      if (entry instanceof ModuleOrderEntry) {\n        continue;\n      }\n      final String[] externalUrls = AnnotationOrderRootType.getUrls(entry);\n      for (String url : externalUrls) {\n        VirtualFile root = vfManager.findFileByUrl(url);\n        if (root != null) {\n          result.add(root);\n        }\n      }\n    }\n    return result;\n  }","commit_id":"ead4e15edd493bc815795c0a10809a2db6fad49a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public E remove(final int index) {\n    if (index < 0 || index >= mySize) {\n      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + mySize);\n    }\n\n    final E oldValue;\n    if (mySize == 1) {\n      oldValue = (E)myElem;\n      myElem = null;\n    }\n    else {\n      final Object[] array = (Object[])myElem;\n      oldValue = (E)array[index];\n\n      if (mySize == 2) {\n        myElem = array[1 - index];\n      }\n      else {\n        int numMoved = mySize - index - 1;\n        if (numMoved > 0) {\n          System.arraycopy(array, index + 1, array, index, numMoved);\n        }\n        array[mySize - 1] = null;\n      }\n    }\n    mySize--;\n    modCount++;\n    return oldValue;\n  }","id":97008,"modified_method":"@Override\n  public E remove(final int index) {\n    if (index < 0 || index >= mySize) {\n      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + mySize);\n    }\n\n    final E oldValue;\n    if (mySize == 1) {\n      oldValue = (E)myElem;\n      myElem = null;\n    }\n    else {\n      Object[] array = (Object[])myElem;\n      oldValue = (E)array[index];\n\n      if (mySize == 2) {\n        myElem = array[1 - index];\n      }\n      else {\n        int numMoved = mySize - index - 1;\n        if (numMoved > 0) {\n          System.arraycopy(array, index + 1, array, index, numMoved);\n        }\n        array[mySize - 1] = null;\n      }\n    }\n    mySize--;\n    modCount++;\n    return oldValue;\n  }","commit_id":"ead4e15edd493bc815795c0a10809a2db6fad49a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String intern(@NotNull String name) {\n    int idx = mySet.index(name);\n    if (idx >= 0) {\n      return mySet.get(idx);\n    }\n\n    boolean added = mySet.add(name);\n    assert added;\n\n    return name;\n  }","id":97009,"modified_method":"@NotNull\n  public String intern(@NotNull String name) {\n    String interned = mySet.get(name);\n    if (interned != null) {\n      return interned;\n    }\n\n    boolean added = mySet.add(name);\n    assert added;\n\n    return name;\n  }","commit_id":"ead4e15edd493bc815795c0a10809a2db6fad49a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Cycle-safe computation of an attribute value with resolving properties.\n   *\n   * @param value\n   * @param elementStack\n   * @return\n   */\n  protected String computeAttributeValue(String value, Set<PsiElement> elementStack) {\n    elementStack.add(this);\n    int startProp = 0;\n    while ((startProp = value.indexOf(\"${\", startProp)) >= 0) {\n      final int endProp = value.indexOf('}', startProp + 2);\n      if (endProp <= startProp + 2) {\n        startProp += 2;\n        continue;\n      }\n      final String prop = value.substring(startProp + 2, endProp);\n      final PsiElement propElement = resolveProperty(this, prop);\n      if (elementStack.contains(propElement)) {\n        return value;\n      }\n      String resolvedValue = null;\n      if (propElement instanceof AntProperty) {\n        final AntProperty antProperty = (AntProperty)propElement;\n        resolvedValue = antProperty.getValue(prop);\n        if (resolvedValue != null) {\n          resolvedValue = ((AntStructuredElementImpl)antProperty).computeAttributeValue(resolvedValue, elementStack);\n        }\n      }\n      else if (propElement instanceof Property) {\n        resolvedValue = ((Property)propElement).getValue();\n      }\n      if (resolvedValue == null) {\n        startProp += 2;\n      }\n      else {\n        if (endProp < value.length() - 1) {\n          value = value.substring(0, startProp) + resolvedValue + value.substring(endProp + 1);\n        }\n        else {\n          value = value.substring(0, startProp) + resolvedValue;\n        }\n      }\n    }\n    return value;\n  }","id":97010,"modified_method":"/**\n   * Cycle-safe computation of an attribute value with resolving properties.\n   *\n   * @param value\n   * @param elementStack\n   * @return\n   */\n  protected String computeAttributeValue(String value, Set<PsiElement> elementStack) {\n    elementStack.add(this);\n    int startProp = 0;\n    while ((startProp = value.indexOf(\"${\", startProp)) >= 0) {\n      final int endProp = value.indexOf('}', startProp + 2);\n      if (endProp <= startProp + 2) {\n        startProp += 2;\n        continue;\n      }\n      final String prop = value.substring(startProp + 2, endProp);\n      final PsiElement propElement = resolveProperty(this, prop);\n      if (elementStack.contains(propElement)) {\n        return value;\n      }\n      String resolvedValue = null;\n      if (propElement instanceof AntProperty) {\n        final AntProperty antProperty = (AntProperty)propElement;\n        resolvedValue = antProperty.getValue(prop);\n        if (resolvedValue != null) {\n          resolvedValue = ((AntStructuredElementImpl)antProperty).computeAttributeValue(resolvedValue, elementStack);\n        }\n      }\n      else if (propElement instanceof Property) {\n        resolvedValue = ((Property)propElement).getValue();\n      }\n      if (resolvedValue == null) {\n        startProp += 2;\n      }\n      else {\n        final StringBuilder builder = StringBuilderSpinAllocator.alloc();\n        try {\n          builder.append(value, 0, startProp);\n          builder.append(resolvedValue);\n          if (endProp < value.length() - 1) {\n            builder.append(value, endProp + 1, value.length());\n          }\n          value = builder.toString();\n        }\n        finally {\n          StringBuilderSpinAllocator.dispose(builder);\n        }\n      }\n    }\n    return value;\n  }","commit_id":"baf3ad844c19fa3d195de05dae3ec49c68182059","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getAccessLevel() {\n    return PsiUtil.getAccessLevel(((PsiModifierListOwner)getElement()).getModifierList());\n  }","id":97011,"modified_method":"public int getAccessLevel() {\n    final PsiModifierList modifierList = ((PsiModifierListOwner)getElement()).getModifierList();\n    if (modifierList == null) {\n      return PsiUtil.ACCESS_LEVEL_PUBLIC;\n    }\n    return PsiUtil.getAccessLevel(modifierList);\n  }","commit_id":"46cc45cdee13c5c095f8ba2e50532a1a0b7716ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiElement findModifierStatic(GrMember grMember) {\n    final PsiElement[] modifiers = grMember.getModifierList().getModifiers();\n    for (PsiElement modifier : modifiers) {\n      if (PsiModifier.STATIC.equals(modifier.getText())) {\n        return modifier;\n      }\n    }\n    return null;\n  }","id":97012,"modified_method":"private static PsiElement findModifierStatic(GrMember grMember) {\n    final GrModifierList list = grMember.getModifierList();\n    if (list == null) {\n      return null;\n    }\n\n    for (PsiElement modifier : list.getModifiers()) {\n      if (PsiModifier.STATIC.equals(modifier.getText())) {\n        return modifier;\n      }\n    }\n    return null;\n  }","commit_id":"828cd52b64067e8b8d291433d0957752a805047f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void generateAnnotations (StringBuffer buffer, PsiDocCommentOwner owner) {\n    final PsiAnnotation[] annotations = owner.getModifierList().getAnnotations();\n    PsiManager manager = owner.getManager();\n    for (PsiAnnotation annotation : annotations) {\n      final PsiElement resolved = annotation.getNameReferenceElement().resolve();\n      if (resolved instanceof PsiClass) {\n        final PsiClass annotationType = (PsiClass)resolved;\n        final PsiModifierList modifierList = annotationType.getModifierList();\n        if (modifierList.findAnnotation(\"java.lang.annotation.Documented\") != null) {\n          final PsiClassType type = manager.getElementFactory().createType(annotationType, PsiSubstitutor.EMPTY);\n          buffer.append(\"@\");\n          generateType(buffer, type, owner);\n          final PsiNameValuePair[] attributes = annotation.getParameterList().getAttributes();\n          if (attributes.length > 0) {\n            boolean first = true;\n            buffer.append(\"(\");\n            for (PsiNameValuePair pair : attributes) {\n              if (!first) buffer.append(\"&nbsp;\");\n              final String name = pair.getName();\n              if (name != null) {\n                buffer.append(name);\n                buffer.append(\" = \");\n              }\n              final PsiAnnotationMemberValue value = pair.getValue();\n              if (value != null) {\n                buffer.append(value.getText());\n              }\n            }\n            buffer.append(\")\");\n          }\n          buffer.append(\"\\n\");\n        }\n      }\n    }\n  }","id":97013,"modified_method":"private void generateAnnotations (StringBuffer buffer, PsiDocCommentOwner owner) {\n    final PsiModifierList ownerModifierList = owner.getModifierList();\n    if (ownerModifierList == null) return;\n    final PsiAnnotation[] annotations = ownerModifierList.getAnnotations();\n    PsiManager manager = owner.getManager();\n    for (PsiAnnotation annotation : annotations) {\n      final PsiJavaCodeReferenceElement nameReferenceElement = annotation.getNameReferenceElement();\n      if (nameReferenceElement == null) continue;\n      final PsiElement resolved = nameReferenceElement.resolve();\n      if (resolved instanceof PsiClass) {\n        final PsiClass annotationType = (PsiClass)resolved;\n        final PsiModifierList modifierList = annotationType.getModifierList();\n        if (modifierList.findAnnotation(\"java.lang.annotation.Documented\") != null) {\n          final PsiClassType type = manager.getElementFactory().createType(annotationType, PsiSubstitutor.EMPTY);\n          buffer.append(\"@\");\n          generateType(buffer, type, owner);\n          final PsiNameValuePair[] attributes = annotation.getParameterList().getAttributes();\n          if (attributes.length > 0) {\n            boolean first = true;\n            buffer.append(\"(\");\n            for (PsiNameValuePair pair : attributes) {\n              if (!first) buffer.append(\"&nbsp;\");\n              first = false;\n              final String name = pair.getName();\n              if (name != null) {\n                buffer.append(name);\n                buffer.append(\" = \");\n              }\n              final PsiAnnotationMemberValue value = pair.getValue();\n              if (value != null) {\n                buffer.append(value.getText());\n              }\n            }\n            buffer.append(\")\");\n          }\n          buffer.append(\"\\n\");\n        }\n      }\n    }\n  }","commit_id":"ad03f4cd4521b57ed5c7192688df4b608c7eafff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitIfStatement(@NotNull PsiIfStatement statement) {\n            super.visitIfStatement(statement);\n            final PsiExpression outerCondition = statement.getCondition();\n            if (outerCondition == null) {\n                return;\n            }\n            if (SideEffectChecker.mayHaveSideEffects(outerCondition)) {\n                return;\n            }\n            PsiStatement thenBranch = statement.getThenBranch();\n            if (thenBranch == null) {\n                return;\n            }\n            thenBranch = ControlFlowUtils.stripBraces(thenBranch);\n            if (!(thenBranch instanceof PsiSynchronizedStatement)) {\n                return;\n            }\n            final PsiSynchronizedStatement syncStatement =\n                    (PsiSynchronizedStatement)thenBranch;\n            final PsiCodeBlock body = syncStatement.getBody();\n            if (body == null) {\n                return;\n            }\n            final PsiStatement[] statements = body.getStatements();\n            if (statements.length != 1) {\n                return;\n            }\n            if (!(statements[0] instanceof PsiIfStatement)) {\n                return;\n            }\n            final PsiIfStatement innerIf = (PsiIfStatement)statements[0];\n            final PsiExpression innerCondition = innerIf.getCondition();\n            if (!EquivalenceChecker.expressionsAreEquivalent(innerCondition,\n                    outerCondition)) {\n                return;\n            }\n            registerStatementError(statement);\n        }","id":97014,"modified_method":"public void visitIfStatement(@NotNull PsiIfStatement statement) {\n            super.visitIfStatement(statement);\n            final PsiExpression outerCondition = statement.getCondition();\n            if (outerCondition == null) {\n                return;\n            }\n            if (SideEffectChecker.mayHaveSideEffects(outerCondition)) {\n                return;\n            }\n            PsiStatement thenBranch = statement.getThenBranch();\n            thenBranch = ControlFlowUtils.stripBraces(thenBranch);\n            if (!(thenBranch instanceof PsiSynchronizedStatement)) {\n                return;\n            }\n            final PsiSynchronizedStatement syncStatement =\n                    (PsiSynchronizedStatement)thenBranch;\n            final PsiCodeBlock body = syncStatement.getBody();\n            if (body == null) {\n                return;\n            }\n            final PsiStatement[] statements = body.getStatements();\n            if (statements.length != 1) {\n                return;\n            }\n            if (!(statements[0] instanceof PsiIfStatement)) {\n                return;\n            }\n            final PsiIfStatement innerIf = (PsiIfStatement)statements[0];\n            final PsiExpression innerCondition = innerIf.getCondition();\n            if (!EquivalenceChecker.expressionsAreEquivalent(innerCondition,\n                    outerCondition)) {\n                return;\n            }\n            registerStatementError(statement);\n        }","commit_id":"ba869fa89cd401f4b4630029a63b3b7e475eb7ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethodCallExpression(\n                @NotNull PsiMethodCallExpression expression) {\n            super.visitMethodCallExpression(expression);\n            final PsiReferenceExpression methodExpression = expression.getMethodExpression();\n            final String methodName = methodExpression.getReferenceName();\n            if (!\"isAnnotationPresent\".equals(methodName) && !\"getAnnotation\".equals(methodName)) {\n                return;\n            }\n\n            final PsiExpressionList argumentList = expression.getArgumentList();\n            final PsiExpression[] args = argumentList.getExpressions();\n            if (args.length != 1) {\n                return;\n            }\n            final PsiExpression arg = args[0];\n            if (arg == null) {\n                return;\n            }\n            if (!(arg instanceof PsiClassObjectAccessExpression)) {\n                return;\n            }\n            final PsiMethod calledMethod = expression.resolveMethod();\n            if (calledMethod == null) {\n                return;\n            }\n            final PsiClass containingClass = calledMethod.getContainingClass();\n            if (containingClass == null) {\n                return;\n            }\n            if (!\"java.lang.Class\".equals(containingClass.getQualifiedName())) {\n                return;\n            }\n            final PsiTypeElement operand = ((PsiClassObjectAccessExpression) arg).getOperand();\n\n            final PsiClassType annotationClassType = (PsiClassType) operand.getType();\n            final PsiClass annotationClass = annotationClassType.resolve();\n            if (annotationClass == null) {\n                return;\n            }\n\n            final PsiAnnotation retentionAnnotation =\n                    annotationClass.getModifierList().findAnnotation(\"java.lang.annotation.Retention\");\n            if (retentionAnnotation == null) {\n                registerError(arg);\n                return;\n            }\n            final PsiAnnotationParameterList parameters = retentionAnnotation.getParameterList();\n            final PsiNameValuePair[] attributes = parameters.getAttributes();\n            for (PsiNameValuePair attribute : attributes) {\n                final String name = attribute.getName();\n                if (name == null ||\"value\".equals(name)) {\n                    final PsiAnnotationMemberValue value = attribute.getValue();\n                    final String text = value.getText();\n                    if (!text.contains(\"RUNTIME\")) {\n                        registerError(arg);\n                        return;\n                    }\n                }\n            }\n\n        }","id":97015,"modified_method":"public void visitMethodCallExpression(\n                @NotNull PsiMethodCallExpression expression) {\n            super.visitMethodCallExpression(expression);\n            final PsiReferenceExpression methodExpression =\n                    expression.getMethodExpression();\n            @NonNls final String methodName =\n                    methodExpression.getReferenceName();\n            if (!\"isAnnotationPresent\".equals(methodName) &&\n                    !\"getAnnotation\".equals(methodName)) {\n                return;\n            }\n            final PsiExpressionList argumentList = expression.getArgumentList();\n            final PsiExpression[] args = argumentList.getExpressions();\n            if (args.length != 1) {\n                return;\n            }\n            final PsiExpression arg = args[0];\n            if (arg == null) {\n                return;\n            }\n            if (!(arg instanceof PsiClassObjectAccessExpression)) {\n                return;\n            }\n            final PsiMethod calledMethod = expression.resolveMethod();\n            if (calledMethod == null) {\n                return;\n            }\n            final PsiClass containingClass = calledMethod.getContainingClass();\n            if (containingClass == null) {\n                return;\n            }\n            if (!\"java.lang.Class\".equals(containingClass.getQualifiedName())) {\n                return;\n            }\n            final PsiClassObjectAccessExpression classObjectAccessExpression =\n                    (PsiClassObjectAccessExpression)arg;\n            final PsiTypeElement operand =\n                    classObjectAccessExpression.getOperand();\n\n            final PsiClassType annotationClassType =\n                    (PsiClassType) operand.getType();\n            final PsiClass annotationClass = annotationClassType.resolve();\n            if (annotationClass == null) {\n                return;\n            }\n            final PsiModifierList modifierList =\n                    annotationClass.getModifierList();\n            if (modifierList == null) {\n                return;\n            }\n            final PsiAnnotation retentionAnnotation =\n                    modifierList.findAnnotation(\"java.lang.annotation.Retention\");\n            if (retentionAnnotation == null) {\n                registerError(arg);\n                return;\n            }\n            final PsiAnnotationParameterList parameters =\n                    retentionAnnotation.getParameterList();\n            final PsiNameValuePair[] attributes = parameters.getAttributes();\n            for (PsiNameValuePair attribute : attributes) {\n                @NonNls final String name = attribute.getName();\n                if (name == null || \"value\".equals(name)) {\n                    final PsiAnnotationMemberValue value = attribute.getValue();\n                    @NonNls final String text = value.getText();\n                    if (!text.contains(\"RUNTIME\")) {\n                        registerError(arg);\n                        return;\n                    }\n                }\n            }\n        }","commit_id":"ba869fa89cd401f4b4630029a63b3b7e475eb7ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethodCallExpression(\n                @NotNull PsiMethodCallExpression expression) {\n            super.visitMethodCallExpression(expression);\n            final PsiReferenceExpression methodExpression =\n                    expression.getMethodExpression();\n            @NonNls final String methodName = methodExpression.getReferenceName();\n            if (!\"replaceAll\".equals(methodName)) {\n                return;\n            }\n            final PsiExpressionList argList = expression.getArgumentList();\n            final PsiExpression[] args = argList.getExpressions();\n            if (args.length != 2) {\n                return;\n            }\n            final PsiExpression arg = args[0];\n            if (!PsiUtil.isConstantExpression(arg)) {\n                return;\n            }\n\n            final PsiType argType = arg.getType();\n            if (argType == null) {\n                return;\n            }\n            if (!\"java.lang.String\".equals(argType.getCanonicalText())) {\n                return;\n            }\n            final String argValue = (String) ConstantExpressionUtil.computeCastTo(arg, argType);\n            if (!\".\".equals(argValue)) {\n                return;\n            }\n            final PsiMethod method = expression.resolveMethod();\n            if (method == null) {\n                return;\n            }\n            final PsiClass containingClass = method.getContainingClass();\n            if (containingClass == null) {\n                return;\n            }\n            if (!\"java.lang.String\".equals(containingClass.getQualifiedName())) {\n                return;\n            }\n\n            registerMethodCallError(expression);\n        }","id":97016,"modified_method":"public void visitMethodCallExpression(\n                @NotNull PsiMethodCallExpression expression) {\n            super.visitMethodCallExpression(expression);\n            final PsiReferenceExpression methodExpression =\n                    expression.getMethodExpression();\n            @NonNls final String methodName =\n                    methodExpression.getReferenceName();\n            if (!\"replaceAll\".equals(methodName)) {\n                return;\n            }\n            final PsiExpressionList argList = expression.getArgumentList();\n            final PsiExpression[] args = argList.getExpressions();\n            if (args.length != 2) {\n                return;\n            }\n            final PsiExpression arg = args[0];\n            if (!PsiUtil.isConstantExpression(arg)) {\n                return;\n            }\n            final PsiType argType = arg.getType();\n            if (argType == null) {\n                return;\n            }\n            if (!\"java.lang.String\".equals(argType.getCanonicalText())) {\n                return;\n            }\n            final String argValue =\n                    (String) ConstantExpressionUtil.computeCastTo(arg, argType);\n            if (!\".\".equals(argValue)) {\n                return;\n            }\n            final PsiMethod method = expression.resolveMethod();\n            if (method == null) {\n                return;\n            }\n            final PsiClass containingClass = method.getContainingClass();\n            if (containingClass == null) {\n                return;\n            }\n            final String qualifiedName = containingClass.getQualifiedName();\n            if (!\"java.lang.String\".equals(qualifiedName)) {\n                return;\n            }\n            registerMethodCallError(expression);\n        }","commit_id":"ba869fa89cd401f4b4630029a63b3b7e475eb7ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isTestClass(final PsiClass psiClass) {\n    if (!ExecutionUtil.isRunnableClass(psiClass)) return false;\n    if (isTestCaseInheritor(psiClass)) return true;\n    if (psiClass.getModifierList().findAnnotation(\"org.junit.runner.RunWith\") != null) return true;\n\n    for (final PsiMethod method : psiClass.getMethods()) {\n      if (isSuiteMethod(method)) return true;\n      if (isTestAnnotated(method)) return true;\n    }\n    return false;\n  }","id":97017,"modified_method":"public static boolean isTestClass(final PsiClass psiClass) {\n    if (!ExecutionUtil.isRunnableClass(psiClass)) return false;\n    if (isTestCaseInheritor(psiClass)) return true;\n    final PsiModifierList modifierList = psiClass.getModifierList();\n    if (modifierList == null) return false;\n    if (modifierList.findAnnotation(\"org.junit.runner.RunWith\") != null) return true;\n\n    for (final PsiMethod method : psiClass.getMethods()) {\n      if (isSuiteMethod(method)) return true;\n      if (isTestAnnotated(method)) return true;\n    }\n    return false;\n  }","commit_id":"8c4cbf1eadf558eb4d3a389b75c0783c5985b289","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isJUnit4TestClass(final PsiClass psiClass) {\n    if (!ExecutionUtil.isRunnableClass(psiClass)) return false;\n\n    if (psiClass.getModifierList().findAnnotation(\"org.junit.runner.RunWith\") != null) return true;\n    for (final PsiMethod method : psiClass.getMethods()) {\n      if (isTestAnnotated(method)) return true;\n    }\n    return false;\n  }","id":97018,"modified_method":"public static boolean isJUnit4TestClass(final PsiClass psiClass) {\n    if (!ExecutionUtil.isRunnableClass(psiClass)) return false;\n\n    final PsiModifierList modifierList = psiClass.getModifierList();\n    if (modifierList == null) return false;\n    if (modifierList.findAnnotation(\"org.junit.runner.RunWith\") != null) return true;\n    for (final PsiMethod method : psiClass.getMethods()) {\n      if (isTestAnnotated(method)) return true;\n    }\n    return false;\n  }","commit_id":"8c4cbf1eadf558eb4d3a389b75c0783c5985b289","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Inject\n   public CodeSearch(Display display, \n                     final Session session, \n                     final FileTypeRegistry fileTypeRegistry,\n                     final EventBus eventBus)\n   {\n      display_ = display;\n      \n      SearchDisplay searchDisplay = display_.getSearchDisplay();\n      searchDisplay.setAutoSelectEnabled(true);\n      \n      searchDisplay.addSelectionHandler(new SelectionHandler<Suggestion>() {\n\n         @Override\n         public void onSelection(SelectionEvent<Suggestion> event)\n         {\n            // map back to a code search result\n            CodeNavigationTarget target = \n               display_.getSearchOracle().navigationTargetFromSuggestion(\n                                                event.getSelectedItem());\n            \n            // get the active project directory\n            SessionInfo sessionInfo = session.getSessionInfo();\n            FileSystemItem projDir = sessionInfo.getActiveProjectDir(); \n            \n            // calculate full file path and position\n            String srcFile = projDir.completePath(target.getProjectFile());\n            final FileSystemItem srcItem = FileSystemItem.createFile(srcFile);\n            final FilePosition pos = target.getPosition();  \n            \n            // fire editing event (delayed so the Enter keystroke \n            // doesn't get routed into the source editor)\n            Scheduler.get().scheduleDeferred(new ScheduledCommand() {\n               @Override\n               public void execute()\n               {\n                  display_.getSearchDisplay().clear();\n                  display_.getSearchOracle().clear();\n\n                  if (observer_ != null)\n                     observer_.onCompleted();\n                  \n                  fileTypeRegistry.editFile(srcItem, pos);\n               }\n            });\n         }\n      });\n     \n     searchDisplay.addBlurHandler(new BlurHandler() {\n         @Override\n         public void onBlur(BlurEvent event)\n         { \n            display_.getSearchOracle().clear();\n         }\n     });\n\n     \n     searchDisplay.addFocusHandler(new FocusHandler() {\n        @Override\n        public void onFocus(FocusEvent event)\n        { \n           display_.getSearchOracle().clear();\n        }\n     });\n     \n     searchDisplay.addValueChangeHandler(new ValueChangeHandler<String>() {\n        @Override\n        public void onValueChange(ValueChangeEvent<String> event)\n        {\n           boolean hasSearch = event.getValue().length() != 0;\n           if (!hasSearch)\n           {\n              display_.getSearchOracle().invalidateSearches();\n              display_.getSuggestionDisplay().hideSuggestions();\n           }\n        }     \n     });\n     \n     searchDisplay.addKeyDownHandler(new KeyDownHandler() {\n\n        @Override\n        public void onKeyDown(KeyDownEvent event)\n        {\n           // eat key-up if the suggestions are showing (since the \n           // suggestions menu is taking these and if we take it\n           // the cursor will go to the beginning of the selection)\n           if (display_.getSuggestionDisplay().isSuggestionListShowing() &&\n               (event.getNativeKeyCode() == KeyCodes.KEY_UP))\n           {\n              event.preventDefault();\n              event.stopPropagation();\n           }\n        }\n        \n     });\n   }","id":97019,"modified_method":"@Inject\n   public CodeSearch(Display display, \n                     final Session session, \n                     final FileTypeRegistry fileTypeRegistry,\n                     final EventBus eventBus)\n   {\n      display_ = display;\n      \n      SearchDisplay searchDisplay = display_.getSearchDisplay();\n      searchDisplay.setAutoSelectEnabled(true);\n      \n      searchDisplay.addSelectionHandler(new SelectionHandler<Suggestion>() {\n\n         @Override\n         public void onSelection(SelectionEvent<Suggestion> event)\n         {\n            // map back to a code search result\n            CodeNavigationTarget target = \n               display_.getSearchOracle().navigationTargetFromSuggestion(\n                                                event.getSelectedItem());\n            \n            // get the active project directory\n            SessionInfo sessionInfo = session.getSessionInfo();\n            FileSystemItem projDir = sessionInfo.getActiveProjectDir(); \n            \n            // calculate full file path and position\n            String srcFile = projDir.completePath(target.getProjectFile());\n            final FileSystemItem srcItem = FileSystemItem.createFile(srcFile);\n            final FilePosition pos = target.getPosition();  \n            \n            // fire editing event (delayed so the Enter keystroke \n            // doesn't get routed into the source editor)\n            Scheduler.get().scheduleDeferred(new ScheduledCommand() {\n               @Override\n               public void execute()\n               {\n                  display_.getSearchDisplay().clear();\n                  display_.getSearchOracle().clear();\n\n                  if (observer_ != null)\n                     observer_.onCompleted();\n                  \n                  fileTypeRegistry.editFile(srcItem, pos);\n               }\n            });\n         }\n      });\n     \n     // various conditions invalidate the search oracle's cache\n      \n     searchDisplay.addBlurHandler(new BlurHandler() {\n         @Override\n         public void onBlur(BlurEvent event)\n         { \n            display_.getSearchOracle().clear();\n         }\n     });\n\n     \n     searchDisplay.addFocusHandler(new FocusHandler() {\n        @Override\n        public void onFocus(FocusEvent event)\n        { \n           display_.getSearchOracle().clear();\n        }\n     });\n     \n     eventBus.addHandler(CodeIndexingStatusChangedEvent.TYPE,\n                         new CodeIndexingStatusChangedHandler() {\n\n         @Override\n         public void onCodeIndexingStatusChanged(\n                                       CodeIndexingStatusChangedEvent event)\n         {\n            display_.getSearchOracle().clear();  \n         }    \n     });\n     \n     eventBus.addHandler(FileChangeEvent.TYPE, new FileChangeHandler() {\n        @Override\n        public void onFileChange(FileChangeEvent event)\n        {           \n           // if this was an R file then invalide the cache\n           CodeSearchOracle oracle = display_.getSearchOracle();\n           if (oracle.hasCachedResults())\n           {\n              FileSystemItem fsi = event.getFileChange().getFile();\n              if (fsi.getExtension().toLowerCase().equals(\".r\"))\n                 oracle.clear();\n           }\n        } \n     });\n     \n     searchDisplay.addValueChangeHandler(new ValueChangeHandler<String>() {\n        @Override\n        public void onValueChange(ValueChangeEvent<String> event)\n        {\n           boolean hasSearch = event.getValue().length() != 0;\n           if (!hasSearch)\n           {\n              display_.getSearchOracle().invalidateSearches();\n              display_.getSuggestionDisplay().hideSuggestions();\n           }\n        }     \n     });\n     \n     searchDisplay.addKeyDownHandler(new KeyDownHandler() {\n\n        @Override\n        public void onKeyDown(KeyDownEvent event)\n        {\n           // eat key-up if the suggestions are showing (since the \n           // suggestions menu is taking these and if we take it\n           // the cursor will go to the beginning of the selection)\n           if (display_.getSuggestionDisplay().isSuggestionListShowing() &&\n               (event.getNativeKeyCode() == KeyCodes.KEY_UP))\n           {\n              event.preventDefault();\n              event.stopPropagation();\n           }\n        }\n        \n     });\n   }","commit_id":"31cee5687046e549d20ed8f833ed8a6a030c3fdf","url":"https://github.com/rstudio/rstudio"},{"original_method":"public GlobalToolbar(Commands commands, \n                        FileTypeCommands fileTypeCommands,\n                        EventBus eventBus,\n                        Provider<CodeSearch> pCodeSearch)\n   {\n      super();\n      commands_ = commands;\n      pCodeSearch_ = pCodeSearch;\n      searchWidget_ = null;\n      ThemeResources res = ThemeResources.INSTANCE;\n      addStyleName(res.themeStyles().globalToolbar());\n      \n      \n      // add newSourceDoc command\n      ToolbarPopupMenu newMenu = new ToolbarPopupMenu();\n      newMenu.addItem(commands.newSourceDoc().createMenuItem(false));\n      \n      // dynamically add other commands\n      ArrayList<FileTypeCommands.CommandWithId> fileNewCommands = \n         fileTypeCommands.commandsWithIds(FileTypeRegistry.R);\n      for (FileTypeCommands.CommandWithId cmd : fileNewCommands)\n         newMenu.addItem(cmd.command.createMenuItem(false));\n      \n      // create and add new menu\n      StandardIcons icons = StandardIcons.INSTANCE;\n      ToolbarButton newButton = new ToolbarButton(\"\",\n                                                  icons.stock_new(),\n                                                  newMenu);\n      addLeftWidget(newButton);\n      addLeftSeparator();\n      \n      // open button + mru\n      addLeftWidget(commands.openSourceDoc().createToolbarButton());\n      \n      ToolbarPopupMenu mruMenu = new ToolbarPopupMenu();\n      mruMenu.addItem(commands.mru0().createMenuItem(false));\n      mruMenu.addItem(commands.mru1().createMenuItem(false));\n      mruMenu.addItem(commands.mru2().createMenuItem(false));\n      mruMenu.addItem(commands.mru3().createMenuItem(false));\n      mruMenu.addItem(commands.mru4().createMenuItem(false));\n      mruMenu.addItem(commands.mru5().createMenuItem(false));\n      mruMenu.addItem(commands.mru6().createMenuItem(false));\n      mruMenu.addItem(commands.mru7().createMenuItem(false));\n      mruMenu.addItem(commands.mru8().createMenuItem(false));\n      mruMenu.addItem(commands.mru9().createMenuItem(false));\n      mruMenu.addSeparator();\n      mruMenu.addItem(commands.clearRecentFiles().createMenuItem(false));\n      \n      ToolbarButton mruButton = new ToolbarButton(mruMenu, false);\n      mruButton.setTitle(\"Open recent files\");\n      addLeftWidget(mruButton);\n      addLeftSeparator();\n      \n      \n      addLeftWidget(commands.saveSourceDoc().createToolbarButton());\n      addLeftWidget(commands.saveAllSourceDocs().createToolbarButton());\n      addLeftSeparator();\n      \n      addLeftWidget(commands.printSourceDoc().createToolbarButton());\n      \n      eventBus.addHandler(CodeIndexingDisabledEvent.TYPE,\n                          new CodeIndexingDisabledHandler() {\n         @Override\n         public void onCodeSearchDisabled(CodeIndexingDisabledEvent event)\n         {\n            commands_.goToFileFunction().setVisible(false);\n            if (searchWidget_ != null)\n            {\n               removeLeftWidget(searchWidget_);\n               searchWidget_ = null;\n            }\n         }\n      });\n   }","id":97020,"modified_method":"public GlobalToolbar(Commands commands, \n                        FileTypeCommands fileTypeCommands,\n                        EventBus eventBus,\n                        Provider<CodeSearch> pCodeSearch)\n   {\n      super();\n      commands_ = commands;\n      pCodeSearch_ = pCodeSearch;\n      searchWidget_ = null;\n      ThemeResources res = ThemeResources.INSTANCE;\n      addStyleName(res.themeStyles().globalToolbar());\n      \n      \n      // add newSourceDoc command\n      ToolbarPopupMenu newMenu = new ToolbarPopupMenu();\n      newMenu.addItem(commands.newSourceDoc().createMenuItem(false));\n      \n      // dynamically add other commands\n      ArrayList<FileTypeCommands.CommandWithId> fileNewCommands = \n         fileTypeCommands.commandsWithIds(FileTypeRegistry.R);\n      for (FileTypeCommands.CommandWithId cmd : fileNewCommands)\n         newMenu.addItem(cmd.command.createMenuItem(false));\n      \n      // create and add new menu\n      StandardIcons icons = StandardIcons.INSTANCE;\n      ToolbarButton newButton = new ToolbarButton(\"\",\n                                                  icons.stock_new(),\n                                                  newMenu);\n      addLeftWidget(newButton);\n      addLeftSeparator();\n      \n      // open button + mru\n      addLeftWidget(commands.openSourceDoc().createToolbarButton());\n      \n      ToolbarPopupMenu mruMenu = new ToolbarPopupMenu();\n      mruMenu.addItem(commands.mru0().createMenuItem(false));\n      mruMenu.addItem(commands.mru1().createMenuItem(false));\n      mruMenu.addItem(commands.mru2().createMenuItem(false));\n      mruMenu.addItem(commands.mru3().createMenuItem(false));\n      mruMenu.addItem(commands.mru4().createMenuItem(false));\n      mruMenu.addItem(commands.mru5().createMenuItem(false));\n      mruMenu.addItem(commands.mru6().createMenuItem(false));\n      mruMenu.addItem(commands.mru7().createMenuItem(false));\n      mruMenu.addItem(commands.mru8().createMenuItem(false));\n      mruMenu.addItem(commands.mru9().createMenuItem(false));\n      mruMenu.addSeparator();\n      mruMenu.addItem(commands.clearRecentFiles().createMenuItem(false));\n      \n      ToolbarButton mruButton = new ToolbarButton(mruMenu, false);\n      mruButton.setTitle(\"Open recent files\");\n      addLeftWidget(mruButton);\n      addLeftSeparator();\n      \n      \n      addLeftWidget(commands.saveSourceDoc().createToolbarButton());\n      addLeftWidget(commands.saveAllSourceDocs().createToolbarButton());\n      addLeftSeparator();\n      \n      addLeftWidget(commands.printSourceDoc().createToolbarButton());\n      \n      eventBus.addHandler(CodeIndexingStatusChangedEvent.TYPE,\n                          new CodeIndexingStatusChangedHandler() {\n         @Override\n         public void onCodeIndexingStatusChanged(\n                                    CodeIndexingStatusChangedEvent event)\n         {\n            manageCodeSearch(event.getEnabled());\n         }\n      });\n   }","commit_id":"31cee5687046e549d20ed8f833ed8a6a030c3fdf","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void addProjectTools(SessionInfo sessionInfo)\n   {\n      if (sessionInfo.isIndexingEnabled())\n      {\n         addLeftSeparator();\n         \n         CodeSearch codeSearch = pCodeSearch_.get();\n         searchWidget_ = codeSearch.getSearchWidget();\n         addLeftWidget(searchWidget_);\n      }\n      else\n      {\n         commands_.goToFileFunction().setVisible(false);\n      }\n      \n      // project popup menu\n      ProjectPopupMenu projectMenu = new ProjectPopupMenu(sessionInfo,\n                                                          commands_);\n      addRightWidget(projectMenu.getToolbarButton());\n   }","id":97021,"modified_method":"public void addProjectTools(SessionInfo sessionInfo)\n   {\n      // code search\n      manageCodeSearch(sessionInfo.isIndexingEnabled());\n      \n      // project popup menu\n      ProjectPopupMenu projectMenu = new ProjectPopupMenu(sessionInfo,\n                                                          commands_);\n      addRightWidget(projectMenu.getToolbarButton());\n   }","commit_id":"31cee5687046e549d20ed8f833ed8a6a030c3fdf","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void dispatchEvent(ClientEvent event) \n   { \n      String type = event.getType();\n      EventBus eventBus = server_.getEventBus();\n      try\n      {\n         if (type.equals(ClientEvent.Busy))\n         {\n            boolean busy = event.<Bool>getData().getValue();\n            eventBus.fireEvent(new BusyEvent(busy));\n         }\n         else if (type.equals(ClientEvent.ConsoleOutput))\n         {\n            String output = event.getData();\n            eventBus.fireEvent(new ConsoleWriteOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.ConsoleError))\n         {\n            String error = event.getData();\n            eventBus.fireEvent(new ConsoleWriteErrorEvent(error));\n         }\n         else if (type.equals(ClientEvent.ConsoleWritePrompt))\n         {\n            String prompt = event.getData();\n            eventBus.fireEvent(new ConsoleWritePromptEvent(prompt));\n         }\n         else if (type.equals(ClientEvent.ConsoleWriteInput))\n         {\n            String input = event.getData();\n            eventBus.fireEvent(new ConsoleWriteInputEvent(input));\n         }\n         else if (type.equals(ClientEvent.ConsolePrompt))\n         {\n            ConsolePrompt prompt = event.getData();\n            eventBus.fireEvent(new ConsolePromptEvent(prompt));\n         }\n         else if (type.equals(ClientEvent.ShowEditor))\n         {\n            String content = event.getData();\n            eventBus.fireEvent(new ShowEditorEvent(content));\n         }\n         else if (type.equals(ClientEvent.FileChanged))\n         {\n            FileChange fileChange = event.getData();\n            eventBus.fireEvent(new FileChangeEvent(fileChange));\n         }\n         else if (type.equals(ClientEvent.WorkingDirChanged))\n         {\n            String path = event.getData();\n            eventBus.fireEvent(new WorkingDirChangedEvent(path));\n         }\n         else if (type.equals(ClientEvent.WorkspaceRefresh))\n         {\n            eventBus.fireEvent(new WorkspaceRefreshEvent());\n         }\n         else if (type.equals(ClientEvent.WorkspaceAssign))\n         {\n            WorkspaceObjectInfo objectInfo = event.getData();\n            eventBus.fireEvent(new WorkspaceObjectAssignedEvent(objectInfo));\n         }\n         else if (type.equals(ClientEvent.WorkspaceRemove))\n         {\n            String objectName = event.getData();\n            eventBus.fireEvent(new WorkspaceObjectRemovedEvent(objectName));\n         }\n         else if (type.equals(ClientEvent.ShowHelp))\n         {\n            String helpUrl = event.getData();\n            eventBus.fireEvent(new ShowHelpEvent(helpUrl));\n         }\n         else if (type.equals(ClientEvent.ShowErrorMessage))\n         {\n            ErrorMessage errorMessage = event.getData();\n            eventBus.fireEvent(new ShowErrorMessageEvent(errorMessage));\n         }\n         else if (type.equals(ClientEvent.ChooseFile))\n         {\n            boolean newFile = event.<Bool>getData().getValue();\n            eventBus.fireEvent(new ChooseFileEvent(newFile));\n         }\n         else if (type.equals(ClientEvent.BrowseUrl))\n         {\n            BrowseUrlInfo urlInfo = event.getData();\n            eventBus.fireEvent(new BrowseUrlEvent(urlInfo));\n         }\n         else if (type.equals(ClientEvent.PlotsStateChanged))\n         {\n            PlotsState plotsState = event.getData();\n            eventBus.fireEvent(new PlotsChangedEvent(plotsState));\n         }\n         else if (type.equals(ClientEvent.ViewData))\n         {\n            DataView dataView = event.getData();\n            eventBus.fireEvent(new ViewDataEvent(dataView));\n         }\n         else if (type.equals(ClientEvent.InstalledPackagesChanged))\n         {\n            eventBus.fireEvent(new InstalledPackagesChangedEvent());\n         }\n         else if (type.equals(ClientEvent.PackageStatusChanged))\n         {\n            PackageStatus status = event.getData();\n            eventBus.fireEvent(new PackageStatusChangedEvent(status));\n         }\n         else if (type.equals(ClientEvent.Locator))\n         {\n            eventBus.fireEvent(new LocatorEvent());\n         }\n         else if (type.equals(ClientEvent.ConsoleResetHistory))\n         {\n            ConsoleResetHistory reset = event.getData();\n            eventBus.fireEvent(new ConsoleResetHistoryEvent(reset));\n         }\n         else if (type.equals(ClientEvent.SessionSerialization))\n         {\n            SessionSerializationAction action = event.getData();\n            eventBus.fireEvent(new SessionSerializationEvent(action));\n         }\n         else if (type.equals(ClientEvent.HistoryEntriesAdded))\n         {\n            RpcObjectList<HistoryEntry> entries = event.getData();\n            eventBus.fireEvent(new HistoryEntriesAddedEvent(entries));\n         }\n         else if (type.equals(ClientEvent.QuotaStatus))\n         {\n            QuotaStatus quotaStatus = event.getData();\n            eventBus.fireEvent(new QuotaStatusEvent(quotaStatus));\n         }\n         else if (type.equals(ClientEvent.OAuthApproval))\n         {\n            OAuthApproval oauthApproval = event.getData();\n            eventBus.fireEvent(new OAuthApprovalEvent(oauthApproval));\n         }\n         else if (type.equals(ClientEvent.PublishPdf))\n         {\n            String path = event.getData();\n            eventBus.fireEvent(new PublishPdfEvent(path));\n         }\n         else if (type.equals(ClientEvent.FileEdit))\n         {\n            FileSystemItem file = event.getData();\n            eventBus.fireEvent(new FileEditEvent(file));\n         }\n         else if (type.equals(ClientEvent.ShowContent))\n         {\n            ContentItem content = event.getData();\n            eventBus.fireEvent(new ShowContentEvent(content));\n         }\n         else if (type.equals(ClientEvent.ShowData))\n         {\n            DataItem data = event.getData();\n            eventBus.fireEvent(new ShowDataEvent(data));\n         }\n         else if (type.equals(ClientEvent.AbendWarning))\n         {            \n            eventBus.fireEvent(new SessionAbendWarningEvent());\n         }\n         else if (type.equals(ClientEvent.ShowWarningBar))\n         {\n            WarningBarMessage message = event.getData();\n            eventBus.fireEvent(new ShowWarningBarEvent(message));\n         }\n         else if (type.equals(ClientEvent.OpenProjectError))\n         {\n            OpenProjectError error = event.getData();\n            eventBus.fireEvent(new OpenProjectErrorEvent(error));\n         }\n         else if (type.equals(ClientEvent.VcsRefresh))\n         {\n            eventBus.fireEvent(new VcsRefreshEvent());\n         }\n         else if (type.equals(ClientEvent.AskPass))\n         {\n            AskPassEvent.Data data = event.getData();\n            eventBus.fireEvent(new AskPassEvent(data.getHandle(),\n                                                data.getPrompt()));\n         }\n         else if (type.equals(ClientEvent.CodeIndexingDisabled))\n         {\n            eventBus.fireEvent(new CodeIndexingDisabledEvent());\n         }\n         else if (type.equals(ClientEvent.Quit))\n         {\n            // NOTE: we don't explicily stop listending for events here \n            // for two reasons:\n            //\n            //   1) There could be additional console output events which\n            //      occur after Quit\n            //\n            //   2) We will automatically stop listening as a result of \n            //      receiving ServiceUnavailable on the next listen()\n            //\n            \n            // set flag to avoid ensureListening/ensureEvents calls trying\n            // to spark the event stream back up after the user has quit\n            sessionWasQuit_ = true;\n        \n            // fire event\n            boolean switchProjects = event.<Bool>getData().getValue();\n            eventBus.fireEvent(new QuitEvent(switchProjects));\n         }\n         else if (type.equals(ClientEvent.Suicide))\n         {\n            // NOTE: we don't explicitly stop listening for events here\n            // for the reasons cited above in ClientEvent.Quit\n            \n            // fire event\n            String message = event.getData();\n            eventBus.fireEvent(new SuicideEvent(message));\n         }\n         else if (type.equals(ClientEvent.AsyncCompletion))\n         {\n            AsyncCompletion completion = event.getData();\n            String handle = completion.getHandle();\n            AsyncRequestInfo req = asyncRequests_.remove(handle);\n            if (req != null)\n            {\n               req.callback.onResponseReceived(req.request,\n                                               completion.getResponse());\n            }\n            else\n            {\n               // We haven't seen this request yet. Store it for later,\n               // maybe it's just taking a long time for the request\n               // to complete.\n               asyncResponses_.put(handle, completion.getResponse());\n            }\n         }\n         else if (type.equals(ClientEvent.SaveActionChanged))\n         {\n            SaveAction action = event.getData();\n            eventBus.fireEvent(new SaveActionChangedEvent(action));\n         }\n         else\n         {\n            GWT.log(\"WARNING: Server event not dispatched: \" + type, null);\n         }\n      }\n      catch(Throwable e)\n      {\n         GWT.log(\"WARNING: Exception occured dispatching event: \" + type, e);\n      }\n   }","id":97022,"modified_method":"private void dispatchEvent(ClientEvent event) \n   { \n      String type = event.getType();\n      EventBus eventBus = server_.getEventBus();\n      try\n      {\n         if (type.equals(ClientEvent.Busy))\n         {\n            boolean busy = event.<Bool>getData().getValue();\n            eventBus.fireEvent(new BusyEvent(busy));\n         }\n         else if (type.equals(ClientEvent.ConsoleOutput))\n         {\n            String output = event.getData();\n            eventBus.fireEvent(new ConsoleWriteOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.ConsoleError))\n         {\n            String error = event.getData();\n            eventBus.fireEvent(new ConsoleWriteErrorEvent(error));\n         }\n         else if (type.equals(ClientEvent.ConsoleWritePrompt))\n         {\n            String prompt = event.getData();\n            eventBus.fireEvent(new ConsoleWritePromptEvent(prompt));\n         }\n         else if (type.equals(ClientEvent.ConsoleWriteInput))\n         {\n            String input = event.getData();\n            eventBus.fireEvent(new ConsoleWriteInputEvent(input));\n         }\n         else if (type.equals(ClientEvent.ConsolePrompt))\n         {\n            ConsolePrompt prompt = event.getData();\n            eventBus.fireEvent(new ConsolePromptEvent(prompt));\n         }\n         else if (type.equals(ClientEvent.ShowEditor))\n         {\n            String content = event.getData();\n            eventBus.fireEvent(new ShowEditorEvent(content));\n         }\n         else if (type.equals(ClientEvent.FileChanged))\n         {\n            FileChange fileChange = event.getData();\n            eventBus.fireEvent(new FileChangeEvent(fileChange));\n         }\n         else if (type.equals(ClientEvent.WorkingDirChanged))\n         {\n            String path = event.getData();\n            eventBus.fireEvent(new WorkingDirChangedEvent(path));\n         }\n         else if (type.equals(ClientEvent.WorkspaceRefresh))\n         {\n            eventBus.fireEvent(new WorkspaceRefreshEvent());\n         }\n         else if (type.equals(ClientEvent.WorkspaceAssign))\n         {\n            WorkspaceObjectInfo objectInfo = event.getData();\n            eventBus.fireEvent(new WorkspaceObjectAssignedEvent(objectInfo));\n         }\n         else if (type.equals(ClientEvent.WorkspaceRemove))\n         {\n            String objectName = event.getData();\n            eventBus.fireEvent(new WorkspaceObjectRemovedEvent(objectName));\n         }\n         else if (type.equals(ClientEvent.ShowHelp))\n         {\n            String helpUrl = event.getData();\n            eventBus.fireEvent(new ShowHelpEvent(helpUrl));\n         }\n         else if (type.equals(ClientEvent.ShowErrorMessage))\n         {\n            ErrorMessage errorMessage = event.getData();\n            eventBus.fireEvent(new ShowErrorMessageEvent(errorMessage));\n         }\n         else if (type.equals(ClientEvent.ChooseFile))\n         {\n            boolean newFile = event.<Bool>getData().getValue();\n            eventBus.fireEvent(new ChooseFileEvent(newFile));\n         }\n         else if (type.equals(ClientEvent.BrowseUrl))\n         {\n            BrowseUrlInfo urlInfo = event.getData();\n            eventBus.fireEvent(new BrowseUrlEvent(urlInfo));\n         }\n         else if (type.equals(ClientEvent.PlotsStateChanged))\n         {\n            PlotsState plotsState = event.getData();\n            eventBus.fireEvent(new PlotsChangedEvent(plotsState));\n         }\n         else if (type.equals(ClientEvent.ViewData))\n         {\n            DataView dataView = event.getData();\n            eventBus.fireEvent(new ViewDataEvent(dataView));\n         }\n         else if (type.equals(ClientEvent.InstalledPackagesChanged))\n         {\n            eventBus.fireEvent(new InstalledPackagesChangedEvent());\n         }\n         else if (type.equals(ClientEvent.PackageStatusChanged))\n         {\n            PackageStatus status = event.getData();\n            eventBus.fireEvent(new PackageStatusChangedEvent(status));\n         }\n         else if (type.equals(ClientEvent.Locator))\n         {\n            eventBus.fireEvent(new LocatorEvent());\n         }\n         else if (type.equals(ClientEvent.ConsoleResetHistory))\n         {\n            ConsoleResetHistory reset = event.getData();\n            eventBus.fireEvent(new ConsoleResetHistoryEvent(reset));\n         }\n         else if (type.equals(ClientEvent.SessionSerialization))\n         {\n            SessionSerializationAction action = event.getData();\n            eventBus.fireEvent(new SessionSerializationEvent(action));\n         }\n         else if (type.equals(ClientEvent.HistoryEntriesAdded))\n         {\n            RpcObjectList<HistoryEntry> entries = event.getData();\n            eventBus.fireEvent(new HistoryEntriesAddedEvent(entries));\n         }\n         else if (type.equals(ClientEvent.QuotaStatus))\n         {\n            QuotaStatus quotaStatus = event.getData();\n            eventBus.fireEvent(new QuotaStatusEvent(quotaStatus));\n         }\n         else if (type.equals(ClientEvent.OAuthApproval))\n         {\n            OAuthApproval oauthApproval = event.getData();\n            eventBus.fireEvent(new OAuthApprovalEvent(oauthApproval));\n         }\n         else if (type.equals(ClientEvent.PublishPdf))\n         {\n            String path = event.getData();\n            eventBus.fireEvent(new PublishPdfEvent(path));\n         }\n         else if (type.equals(ClientEvent.FileEdit))\n         {\n            FileSystemItem file = event.getData();\n            eventBus.fireEvent(new FileEditEvent(file));\n         }\n         else if (type.equals(ClientEvent.ShowContent))\n         {\n            ContentItem content = event.getData();\n            eventBus.fireEvent(new ShowContentEvent(content));\n         }\n         else if (type.equals(ClientEvent.ShowData))\n         {\n            DataItem data = event.getData();\n            eventBus.fireEvent(new ShowDataEvent(data));\n         }\n         else if (type.equals(ClientEvent.AbendWarning))\n         {            \n            eventBus.fireEvent(new SessionAbendWarningEvent());\n         }\n         else if (type.equals(ClientEvent.ShowWarningBar))\n         {\n            WarningBarMessage message = event.getData();\n            eventBus.fireEvent(new ShowWarningBarEvent(message));\n         }\n         else if (type.equals(ClientEvent.OpenProjectError))\n         {\n            OpenProjectError error = event.getData();\n            eventBus.fireEvent(new OpenProjectErrorEvent(error));\n         }\n         else if (type.equals(ClientEvent.VcsRefresh))\n         {\n            eventBus.fireEvent(new VcsRefreshEvent());\n         }\n         else if (type.equals(ClientEvent.AskPass))\n         {\n            AskPassEvent.Data data = event.getData();\n            eventBus.fireEvent(new AskPassEvent(data.getHandle(),\n                                                data.getPrompt()));\n         }\n         else if (type.equals(ClientEvent.CodeIndexingStatusChanged))\n         {\n            boolean enabled = event.<Bool>getData().getValue(); \n            eventBus.fireEvent(new CodeIndexingStatusChangedEvent(enabled));\n         }\n         else if (type.equals(ClientEvent.Quit))\n         {\n            // NOTE: we don't explicily stop listending for events here \n            // for two reasons:\n            //\n            //   1) There could be additional console output events which\n            //      occur after Quit\n            //\n            //   2) We will automatically stop listening as a result of \n            //      receiving ServiceUnavailable on the next listen()\n            //\n            \n            // set flag to avoid ensureListening/ensureEvents calls trying\n            // to spark the event stream back up after the user has quit\n            sessionWasQuit_ = true;\n        \n            // fire event\n            boolean switchProjects = event.<Bool>getData().getValue();\n            eventBus.fireEvent(new QuitEvent(switchProjects));\n         }\n         else if (type.equals(ClientEvent.Suicide))\n         {\n            // NOTE: we don't explicitly stop listening for events here\n            // for the reasons cited above in ClientEvent.Quit\n            \n            // fire event\n            String message = event.getData();\n            eventBus.fireEvent(new SuicideEvent(message));\n         }\n         else if (type.equals(ClientEvent.AsyncCompletion))\n         {\n            AsyncCompletion completion = event.getData();\n            String handle = completion.getHandle();\n            AsyncRequestInfo req = asyncRequests_.remove(handle);\n            if (req != null)\n            {\n               req.callback.onResponseReceived(req.request,\n                                               completion.getResponse());\n            }\n            else\n            {\n               // We haven't seen this request yet. Store it for later,\n               // maybe it's just taking a long time for the request\n               // to complete.\n               asyncResponses_.put(handle, completion.getResponse());\n            }\n         }\n         else if (type.equals(ClientEvent.SaveActionChanged))\n         {\n            SaveAction action = event.getData();\n            eventBus.fireEvent(new SaveActionChangedEvent(action));\n         }\n         else\n         {\n            GWT.log(\"WARNING: Server event not dispatched: \" + type, null);\n         }\n      }\n      catch(Throwable e)\n      {\n         GWT.log(\"WARNING: Exception occured dispatching event: \" + type, e);\n      }\n   }","commit_id":"31cee5687046e549d20ed8f833ed8a6a030c3fdf","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void dispatchEvent(ClientEvent event) \n   { \n      String type = event.getType();\n      try\n      {\n         if (type.equals(ClientEvent.Busy))\n         {\n            boolean busy = event.<Bool>getData().getValue();\n            eventBus_.fireEvent(new BusyEvent(busy));\n         }\n         else if (type.equals(ClientEvent.ConsoleOutput))\n         {\n            String output = event.getData();\n            eventBus_.fireEvent(new ConsoleWriteOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.ConsoleError))\n         {\n            String error = event.getData();\n            eventBus_.fireEvent(new ConsoleWriteErrorEvent(error));\n         }\n         else if (type.equals(ClientEvent.ConsoleWritePrompt))\n         {\n            String prompt = event.getData();\n            eventBus_.fireEvent(new ConsoleWritePromptEvent(prompt));\n         }\n         else if (type.equals(ClientEvent.ConsoleWriteInput))\n         {\n            String input = event.getData();\n            eventBus_.fireEvent(new ConsoleWriteInputEvent(input));\n         }\n         else if (type.equals(ClientEvent.ConsolePrompt))\n         {\n            ConsolePrompt prompt = event.getData();\n            eventBus_.fireEvent(new ConsolePromptEvent(prompt));\n         }\n         else if (type.equals(ClientEvent.ShowEditor))\n         {\n            ShowEditorData data = event.getData();\n            eventBus_.fireEvent(new ShowEditorEvent(data));\n         }\n         else if (type.equals(ClientEvent.FileChanged))\n         {\n            FileChange fileChange = event.getData();\n            eventBus_.fireEvent(new FileChangeEvent(fileChange));\n         }\n         else if (type.equals(ClientEvent.WorkingDirChanged))\n         {\n            String path = event.getData();\n            eventBus_.fireEvent(new WorkingDirChangedEvent(path));\n         }\n         else if (type.equals(ClientEvent.ShowHelp))\n         {\n            String helpUrl = event.getData();\n            eventBus_.fireEvent(new ShowHelpEvent(helpUrl));\n         }\n         else if (type.equals(ClientEvent.ShowErrorMessage))\n         {\n            ErrorMessage errorMessage = event.getData();\n            eventBus_.fireEvent(new ShowErrorMessageEvent(errorMessage));\n         }\n         else if (type.equals(ClientEvent.ChooseFile))\n         {\n            boolean newFile = event.<Bool>getData().getValue();\n            eventBus_.fireEvent(new ChooseFileEvent(newFile));\n         }\n         else if (type.equals(ClientEvent.BrowseUrl))\n         {\n            BrowseUrlInfo urlInfo = event.getData();\n            eventBus_.fireEvent(new BrowseUrlEvent(urlInfo));\n         }\n         else if (type.equals(ClientEvent.PlotsStateChanged))\n         {\n            PlotsState plotsState = event.getData();\n            eventBus_.fireEvent(new PlotsChangedEvent(plotsState));\n         }\n         else if (type.equals(ClientEvent.ViewData))\n         {\n            DataView dataView = event.getData();\n            eventBus_.fireEvent(new ViewDataEvent(dataView));\n         }\n         else if (type.equals(ClientEvent.InstalledPackagesChanged))\n         {\n            eventBus_.fireEvent(new InstalledPackagesChangedEvent());\n         }\n         else if (type.equals(ClientEvent.PackageStatusChanged))\n         {\n            PackageStatus status = event.getData();\n            eventBus_.fireEvent(new PackageStatusChangedEvent(status));\n         }\n         else if (type.equals(ClientEvent.Locator))\n         {\n            eventBus_.fireEvent(new LocatorEvent());\n         }\n         else if (type.equals(ClientEvent.ConsoleResetHistory))\n         {\n            ConsoleResetHistory reset = event.getData();\n            eventBus_.fireEvent(new ConsoleResetHistoryEvent(reset));\n         }\n         else if (type.equals(ClientEvent.SessionSerialization))\n         {\n            SessionSerializationAction action = event.getData();\n            eventBus_.fireEvent(new SessionSerializationEvent(action));\n         }\n         else if (type.equals(ClientEvent.HistoryEntriesAdded))\n         {\n            RpcObjectList<HistoryEntry> entries = event.getData();\n            eventBus_.fireEvent(new HistoryEntriesAddedEvent(entries));\n         }\n         else if (type.equals(ClientEvent.QuotaStatus))\n         {\n            QuotaStatus quotaStatus = event.getData();\n            eventBus_.fireEvent(new QuotaStatusEvent(quotaStatus));\n         }\n         else if (type.equals(ClientEvent.FileEdit))\n         {\n            FileSystemItem file = event.getData();\n            eventBus_.fireEvent(new FileEditEvent(file));\n         }\n         else if (type.equals(ClientEvent.ShowContent))\n         {\n            ContentItem content = event.getData();\n            eventBus_.fireEvent(new ShowContentEvent(content));\n         }\n         else if (type.equals(ClientEvent.ShowData))\n         {\n            DataItem data = event.getData();\n            eventBus_.fireEvent(new ShowDataEvent(data));\n         }\n         else if (type.equals(ClientEvent.AbendWarning))\n         {            \n            eventBus_.fireEvent(new SessionAbendWarningEvent());\n         }\n         else if (type.equals(ClientEvent.ShowWarningBar))\n         {\n            WarningBarMessage message = event.getData();\n            eventBus_.fireEvent(new ShowWarningBarEvent(message));\n         }\n         else if (type.equals(ClientEvent.OpenProjectError))\n         {\n            OpenProjectError error = event.getData();\n            eventBus_.fireEvent(new OpenProjectErrorEvent(error));\n         }\n         else if (type.equals(ClientEvent.VcsRefresh))\n         {\n            JsObject data = event.getData();\n            eventBus_.fireEvent(new VcsRefreshEvent(Reason.NA,\n                                                    data.getInteger(\"delay\")));\n         }\n         else if (type.equals(ClientEvent.AskPass))\n         {\n            AskPassEvent.Data data = event.getData();\n            eventBus_.fireEvent(new AskPassEvent(data));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessOutput))\n         {\n            ServerConsoleOutputEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ServerConsoleOutputEvent(data.getHandle(),\n                                                            data.getOutput(),\n                                                            data.isError()));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessPrompt))\n         {\n            ServerConsolePromptEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ServerConsolePromptEvent(data.getHandle(),\n                                                             data.getPrompt()));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessCreated))\n         {\n            ConsoleProcessCreatedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ConsoleProcessCreatedEvent(data));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessExit))\n         {\n            ServerProcessExitEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ServerProcessExitEvent(data.getHandle(),\n                                                          data.getExitCode()));\n         }\n         else if (type.equals(ClientEvent.HTMLPreviewStartedEvent))\n         {\n            HTMLPreviewStartedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new HTMLPreviewStartedEvent(data));\n         }\n         else if (type.equals(ClientEvent.HTMLPreviewOutputEvent))\n         {\n            String output = event.getData();\n            eventBus_.fireEvent(new HTMLPreviewOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.HTMLPreviewCompletedEvent))\n         {\n            HTMLPreviewResult result = event.getData();\n            eventBus_.fireEvent(new HTMLPreviewCompletedEvent(result));\n         }\n         else if (type.equals(ClientEvent.CompilePdfStartedEvent))\n         {\n            CompilePdfStartedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new CompilePdfStartedEvent(data));\n         }\n         else if (type.equals(ClientEvent.CompilePdfOutputEvent))\n         {\n            CompileOutput output = event.getData();\n            eventBus_.fireEvent(new CompilePdfOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.CompilePdfErrorsEvent))\n         {\n            JsArray<CompileError> data = event.getData();\n            eventBus_.fireEvent(new CompilePdfErrorsEvent(data));\n         }\n         else if (type.equals(ClientEvent.CompilePdfCompletedEvent))\n         {\n            CompilePdfResult result = event.getData();\n            eventBus_.fireEvent(new CompilePdfCompletedEvent(result));\n         }\n         else if (type.equals(ClientEvent.SynctexEditFile))\n         {\n            SourceLocation sourceLocation = event.getData();\n            eventBus_.fireEvent(new SynctexEditFileEvent(sourceLocation));\n         }\n         else if (type.equals(ClientEvent.FindResult))\n         {\n            FindResultEvent.Data data = event.getData();\n            eventBus_.fireEvent(new FindResultEvent(\n                  data.getHandle(), data.getResults().toArrayList()));\n         }\n         else if (type.equals(ClientEvent.FindOperationEnded))\n         {\n            String data = event.getData();\n            eventBus_.fireEvent(new FindOperationEndedEvent(data));\n         }\n         else if (type.equals(ClientEvent.RPubsUploadStatus))\n         {\n            RPubsUploadStatusEvent.Status status = event.getData();\n            eventBus_.fireEvent(new RPubsUploadStatusEvent(status));\n         }\n         else if (type.equals(ClientEvent.BuildStarted))\n         {\n            eventBus_.fireEvent(new BuildStartedEvent());\n         }\n         else if (type.equals(ClientEvent.BuildOutput))\n         {\n            CompileOutput data = event.getData();\n            eventBus_.fireEvent(new BuildOutputEvent(data));\n         }\n         else if (type.equals(ClientEvent.BuildCompleted))\n         {\n            BuildCompletedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new BuildCompletedEvent(data));\n         }\n         else if (type.equals(ClientEvent.BuildErrors))\n         {\n            BuildErrorsEvent.Data data = event.getData();\n            eventBus_.fireEvent(new BuildErrorsEvent(data));\n         }\n         else if (type.equals(ClientEvent.DirectoryNavigate))\n         {\n            DirectoryNavigateEvent.Data data = event.getData();\n            eventBus_.fireEvent(new DirectoryNavigateEvent(data));\n         }\n         else if (type.equals(ClientEvent.DeferredInitCompleted))\n         {\n            eventBus_.fireEvent(new DeferredInitCompletedEvent());\n         }\n         else if (type.equals(ClientEvent.PlotsZoomSizeChanged))\n         {\n            PlotsZoomSizeChangedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new PlotsZoomSizeChangedEvent(data));\n         }\n         else if (type.equals(ClientEvent.SourceCppStarted))\n         {\n            eventBus_.fireEvent(new SourceCppStartedEvent());\n         }\n         else if (type.equals(ClientEvent.SourceCppCompleted))\n         {\n            SourceCppState state = event.getData();\n            eventBus_.fireEvent(new SourceCppCompletedEvent(state));\n         }\n         else if (type.equals(ClientEvent.LoadedPackageUpdates))\n         {\n            String installCmd = event.getData();\n            eventBus_.fireEvent(new LoadedPackageUpdatesEvent(installCmd));\n         }\n         else if (type.equals(ClientEvent.ActivatePane))\n         {\n            String pane = event.getData();\n            eventBus_.fireEvent(new ActivatePaneEvent(pane));\n         }\n         else if (type.equals(ClientEvent.ShowPresentationPane))\n         {\n            PresentationState state = event.getData();\n            eventBus_.fireEvent(new ShowPresentationPaneEvent(state));\n         }\n         else if (type.equals(ClientEvent.EnvironmentRefresh))\n         {\n            eventBus_.fireEvent(new EnvironmentRefreshEvent());\n         }\n         else if (type.equals(ClientEvent.ListChanged))\n         {\n            eventBus_.fireEvent(new ListChangedEvent(event.<JsObject>getData()));\n         }\n         else if (type.equals(ClientEvent.UiPrefsChanged))\n         {\n            UiPrefsChangedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new UiPrefsChangedEvent(data));\n         }\n         else if (type.equals(ClientEvent.ContextDepthChanged)) {\n            EnvironmentContextData data = event.getData();\n            eventBus_.fireEvent(new ContextDepthChangedEvent(data, true));\n         }\n         else if (type.equals(ClientEvent.HandleUnsavedChanges))\n         {\n            eventBus_.fireEvent(new HandleUnsavedChangesEvent());\n         }\n         else if (type.equals(ClientEvent.Quit))\n         {\n            boolean switchProjects = event.<Bool>getData().getValue();\n            eventBus_.fireEvent(new QuitEvent(switchProjects));\n         }\n         else if (type.equals(ClientEvent.Suicide))\n         {\n            // NOTE: we don't explicitly stop listening for events here\n            // for the reasons cited above in ClientEvent.Quit\n            \n            // fire event\n            String message = event.getData();\n            eventBus_.fireEvent(new SuicideEvent(message));\n         }\n         else if (type.equals(ClientEvent.SaveActionChanged))\n         {\n            SaveAction action = event.getData();\n            eventBus_.fireEvent(new SaveActionChangedEvent(action));\n         }\n         else if (type.equals(ClientEvent.EnvironmentAssigned))\n         {\n            RObject objectInfo = event.getData();\n            eventBus_.fireEvent(new EnvironmentObjectAssignedEvent(objectInfo));\n         }\n         else if (type.equals(ClientEvent.EnvironmentRemoved))\n         {\n            String objectName = event.getData();\n            eventBus_.fireEvent(new EnvironmentObjectRemovedEvent(objectName));\n         }\n         else if (type.equals(ClientEvent.BrowserLineChanged))\n         {\n            LineData lineData = event.getData();\n            eventBus_.fireEvent(new BrowserLineChangedEvent(lineData));\n         }\n         else if (type.equals(ClientEvent.PackageLoaded))\n         {\n            eventBus_.fireEvent(new PackageLoadedEvent(\n                  (String)event.getData()));\n         }\n         else if (type.equals(ClientEvent.PackageUnloaded))\n         {\n            eventBus_.fireEvent(new PackageUnloadedEvent(\n                  (String)event.getData()));\n         }\n         else if (type.equals(ClientEvent.PresentationPaneRequestCompleted))\n         {\n            eventBus_.fireEvent(new PresentationPaneRequestCompletedEvent());\n         }\n         else if (type.equals(ClientEvent.UnhandledError))\n         {\n            UnhandledError err = event.getData();\n            eventBus_.fireEvent(new UnhandledErrorEvent(err));\n         }\n         else if (type.equals(ClientEvent.ErrorHandlerChanged))\n         {\n            ErrorHandlerType handlerType = event.getData();\n            eventBus_.fireEvent(new ErrorHandlerChangedEvent(handlerType));\n         }\n         else if (type.equals(ClientEvent.ViewerNavigate))\n         {\n            ViewerNavigateEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ViewerNavigateEvent(data));\n         }\n         else if (type.equals(ClientEvent.SourceExtendedTypeDetected))\n         {\n            SourceExtendedTypeDetectedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new SourceExtendedTypeDetectedEvent(data));\n         }\n         else if (type.equals(ClientEvent.ShinyViewer))\n         {\n            ShinyApplicationParams data = event.getData();\n            eventBus_.fireEvent(new ShinyApplicationStatusEvent(data));\n         }\n         else if (type.equals(ClientEvent.DebugSourceCompleted))\n         {\n            DebugSourceResult result = (DebugSourceResult)event.getData();\n            eventBus_.fireEvent(new DebugSourceCompletedEvent(result));\n         }\n         else if (type.equals(ClientEvent.RmdRenderStarted))\n         {\n            RmdRenderStartedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new RmdRenderStartedEvent(data));\n         }\n         else if (type.equals(ClientEvent.RmdRenderOutput))\n         {\n            CompileOutput data = event.getData();\n            eventBus_.fireEvent(new RmdRenderOutputEvent(data));\n         }\n         else if (type.equals(ClientEvent.RmdRenderCompleted))\n         {\n            RmdRenderResult result = event.getData();\n            eventBus_.fireEvent(new RmdRenderCompletedEvent(result));\n         }\n         else if (type.equals(ClientEvent.RmdTemplateDiscovered))\n         {\n            RmdDiscoveredTemplate template = event.getData();\n            eventBus_.fireEvent(new RmdTemplateDiscoveredEvent(template));\n         }\n         else if (type.equals(ClientEvent.RmdTemplateDiscoveryCompleted))\n         {\n            eventBus_.fireEvent(new RmdTemplateDiscoveryCompletedEvent());\n         }\n         else if (type.equals(ClientEvent.RmdShinyDocStarted))\n         {\n            RmdShinyDocInfo docInfo = event.getData();\n            eventBus_.fireEvent(new RmdShinyDocStartedEvent(docInfo));\n         }\n         else if (type.equals(ClientEvent.ShinyAppsDeploymentOutput))\n         {\n            CompileOutput output = event.getData();\n            eventBus_.fireEvent(new ShinyAppsDeploymentOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.ShinyAppsDeploymentCompleted))\n         {\n            String url = event.getData();\n            eventBus_.fireEvent(new ShinyAppsDeploymentCompletedEvent(url));\n         }\n         else if (type.equals(ClientEvent.UserPrompt))\n         {\n            UserPrompt prompt = event.getData();\n            eventBus_.fireEvent(new UserPromptEvent(prompt));\n         }\n         else if (type.equals(ClientEvent.InstallRtools))\n         {\n            InstallRtoolsEvent.Data data = event.getData();\n            eventBus_.fireEvent(new InstallRtoolsEvent(data));\n         }\n         else if (type.equals(ClientEvent.InstallShiny))\n         {\n            String userAction = event.getData();\n            eventBus_.fireEvent(new InstallShinyEvent(userAction));\n         }\n         else if (type.equals(ClientEvent.SuspendAndRestart))\n         {\n            SuspendAndRestartEvent.Data data = event.getData();\n            eventBus_.fireEvent(new SuspendAndRestartEvent(data));\n         }\n         else\n         {\n            GWT.log(\"WARNING: Server event not dispatched: \" + type, null);\n         }\n      }\n      catch(Throwable e)\n      {\n         GWT.log(\"WARNING: Exception occured dispatching event: \" + type, e);\n      }\n   }","id":97023,"modified_method":"private void dispatchEvent(ClientEvent event) \n   { \n      String type = event.getType();\n      try\n      {\n         if (type.equals(ClientEvent.Busy))\n         {\n            boolean busy = event.<Bool>getData().getValue();\n            eventBus_.fireEvent(new BusyEvent(busy));\n         }\n         else if (type.equals(ClientEvent.ConsoleOutput))\n         {\n            String output = event.getData();\n            eventBus_.fireEvent(new ConsoleWriteOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.ConsoleError))\n         {\n            String error = event.getData();\n            eventBus_.fireEvent(new ConsoleWriteErrorEvent(error));\n         }\n         else if (type.equals(ClientEvent.ConsoleWritePrompt))\n         {\n            String prompt = event.getData();\n            eventBus_.fireEvent(new ConsoleWritePromptEvent(prompt));\n         }\n         else if (type.equals(ClientEvent.ConsoleWriteInput))\n         {\n            String input = event.getData();\n            eventBus_.fireEvent(new ConsoleWriteInputEvent(input));\n         }\n         else if (type.equals(ClientEvent.ConsolePrompt))\n         {\n            ConsolePrompt prompt = event.getData();\n            eventBus_.fireEvent(new ConsolePromptEvent(prompt));\n         }\n         else if (type.equals(ClientEvent.ShowEditor))\n         {\n            ShowEditorData data = event.getData();\n            eventBus_.fireEvent(new ShowEditorEvent(data));\n         }\n         else if (type.equals(ClientEvent.FileChanged))\n         {\n            FileChange fileChange = event.getData();\n            eventBus_.fireEvent(new FileChangeEvent(fileChange));\n         }\n         else if (type.equals(ClientEvent.WorkingDirChanged))\n         {\n            String path = event.getData();\n            eventBus_.fireEvent(new WorkingDirChangedEvent(path));\n         }\n         else if (type.equals(ClientEvent.ShowHelp))\n         {\n            String helpUrl = event.getData();\n            eventBus_.fireEvent(new ShowHelpEvent(helpUrl));\n         }\n         else if (type.equals(ClientEvent.ShowErrorMessage))\n         {\n            ErrorMessage errorMessage = event.getData();\n            eventBus_.fireEvent(new ShowErrorMessageEvent(errorMessage));\n         }\n         else if (type.equals(ClientEvent.ChooseFile))\n         {\n            boolean newFile = event.<Bool>getData().getValue();\n            eventBus_.fireEvent(new ChooseFileEvent(newFile));\n         }\n         else if (type.equals(ClientEvent.BrowseUrl))\n         {\n            BrowseUrlInfo urlInfo = event.getData();\n            eventBus_.fireEvent(new BrowseUrlEvent(urlInfo));\n         }\n         else if (type.equals(ClientEvent.PlotsStateChanged))\n         {\n            PlotsState plotsState = event.getData();\n            eventBus_.fireEvent(new PlotsChangedEvent(plotsState));\n         }\n         else if (type.equals(ClientEvent.ViewData))\n         {\n            DataView dataView = event.getData();\n            eventBus_.fireEvent(new ViewDataEvent(dataView));\n         }\n         else if (type.equals(ClientEvent.PackageStateChanged))\n         {\n            PackageState newState = event.getData();\n            eventBus_.fireEvent(new PackageStateChangedEvent(newState));\n         }\n         else if (type.equals(ClientEvent.PackageStatusChanged))\n         {\n            PackageStatus status = event.getData();\n            eventBus_.fireEvent(new PackageStatusChangedEvent(status));\n         }\n         else if (type.equals(ClientEvent.Locator))\n         {\n            eventBus_.fireEvent(new LocatorEvent());\n         }\n         else if (type.equals(ClientEvent.ConsoleResetHistory))\n         {\n            ConsoleResetHistory reset = event.getData();\n            eventBus_.fireEvent(new ConsoleResetHistoryEvent(reset));\n         }\n         else if (type.equals(ClientEvent.SessionSerialization))\n         {\n            SessionSerializationAction action = event.getData();\n            eventBus_.fireEvent(new SessionSerializationEvent(action));\n         }\n         else if (type.equals(ClientEvent.HistoryEntriesAdded))\n         {\n            RpcObjectList<HistoryEntry> entries = event.getData();\n            eventBus_.fireEvent(new HistoryEntriesAddedEvent(entries));\n         }\n         else if (type.equals(ClientEvent.QuotaStatus))\n         {\n            QuotaStatus quotaStatus = event.getData();\n            eventBus_.fireEvent(new QuotaStatusEvent(quotaStatus));\n         }\n         else if (type.equals(ClientEvent.FileEdit))\n         {\n            FileSystemItem file = event.getData();\n            eventBus_.fireEvent(new FileEditEvent(file));\n         }\n         else if (type.equals(ClientEvent.ShowContent))\n         {\n            ContentItem content = event.getData();\n            eventBus_.fireEvent(new ShowContentEvent(content));\n         }\n         else if (type.equals(ClientEvent.ShowData))\n         {\n            DataItem data = event.getData();\n            eventBus_.fireEvent(new ShowDataEvent(data));\n         }\n         else if (type.equals(ClientEvent.AbendWarning))\n         {            \n            eventBus_.fireEvent(new SessionAbendWarningEvent());\n         }\n         else if (type.equals(ClientEvent.ShowWarningBar))\n         {\n            WarningBarMessage message = event.getData();\n            eventBus_.fireEvent(new ShowWarningBarEvent(message));\n         }\n         else if (type.equals(ClientEvent.OpenProjectError))\n         {\n            OpenProjectError error = event.getData();\n            eventBus_.fireEvent(new OpenProjectErrorEvent(error));\n         }\n         else if (type.equals(ClientEvent.VcsRefresh))\n         {\n            JsObject data = event.getData();\n            eventBus_.fireEvent(new VcsRefreshEvent(Reason.NA,\n                                                    data.getInteger(\"delay\")));\n         }\n         else if (type.equals(ClientEvent.AskPass))\n         {\n            AskPassEvent.Data data = event.getData();\n            eventBus_.fireEvent(new AskPassEvent(data));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessOutput))\n         {\n            ServerConsoleOutputEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ServerConsoleOutputEvent(data.getHandle(),\n                                                            data.getOutput(),\n                                                            data.isError()));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessPrompt))\n         {\n            ServerConsolePromptEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ServerConsolePromptEvent(data.getHandle(),\n                                                             data.getPrompt()));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessCreated))\n         {\n            ConsoleProcessCreatedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ConsoleProcessCreatedEvent(data));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessExit))\n         {\n            ServerProcessExitEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ServerProcessExitEvent(data.getHandle(),\n                                                          data.getExitCode()));\n         }\n         else if (type.equals(ClientEvent.HTMLPreviewStartedEvent))\n         {\n            HTMLPreviewStartedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new HTMLPreviewStartedEvent(data));\n         }\n         else if (type.equals(ClientEvent.HTMLPreviewOutputEvent))\n         {\n            String output = event.getData();\n            eventBus_.fireEvent(new HTMLPreviewOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.HTMLPreviewCompletedEvent))\n         {\n            HTMLPreviewResult result = event.getData();\n            eventBus_.fireEvent(new HTMLPreviewCompletedEvent(result));\n         }\n         else if (type.equals(ClientEvent.CompilePdfStartedEvent))\n         {\n            CompilePdfStartedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new CompilePdfStartedEvent(data));\n         }\n         else if (type.equals(ClientEvent.CompilePdfOutputEvent))\n         {\n            CompileOutput output = event.getData();\n            eventBus_.fireEvent(new CompilePdfOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.CompilePdfErrorsEvent))\n         {\n            JsArray<CompileError> data = event.getData();\n            eventBus_.fireEvent(new CompilePdfErrorsEvent(data));\n         }\n         else if (type.equals(ClientEvent.CompilePdfCompletedEvent))\n         {\n            CompilePdfResult result = event.getData();\n            eventBus_.fireEvent(new CompilePdfCompletedEvent(result));\n         }\n         else if (type.equals(ClientEvent.SynctexEditFile))\n         {\n            SourceLocation sourceLocation = event.getData();\n            eventBus_.fireEvent(new SynctexEditFileEvent(sourceLocation));\n         }\n         else if (type.equals(ClientEvent.FindResult))\n         {\n            FindResultEvent.Data data = event.getData();\n            eventBus_.fireEvent(new FindResultEvent(\n                  data.getHandle(), data.getResults().toArrayList()));\n         }\n         else if (type.equals(ClientEvent.FindOperationEnded))\n         {\n            String data = event.getData();\n            eventBus_.fireEvent(new FindOperationEndedEvent(data));\n         }\n         else if (type.equals(ClientEvent.RPubsUploadStatus))\n         {\n            RPubsUploadStatusEvent.Status status = event.getData();\n            eventBus_.fireEvent(new RPubsUploadStatusEvent(status));\n         }\n         else if (type.equals(ClientEvent.BuildStarted))\n         {\n            eventBus_.fireEvent(new BuildStartedEvent());\n         }\n         else if (type.equals(ClientEvent.BuildOutput))\n         {\n            CompileOutput data = event.getData();\n            eventBus_.fireEvent(new BuildOutputEvent(data));\n         }\n         else if (type.equals(ClientEvent.BuildCompleted))\n         {\n            BuildCompletedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new BuildCompletedEvent(data));\n         }\n         else if (type.equals(ClientEvent.BuildErrors))\n         {\n            BuildErrorsEvent.Data data = event.getData();\n            eventBus_.fireEvent(new BuildErrorsEvent(data));\n         }\n         else if (type.equals(ClientEvent.DirectoryNavigate))\n         {\n            DirectoryNavigateEvent.Data data = event.getData();\n            eventBus_.fireEvent(new DirectoryNavigateEvent(data));\n         }\n         else if (type.equals(ClientEvent.DeferredInitCompleted))\n         {\n            eventBus_.fireEvent(new DeferredInitCompletedEvent());\n         }\n         else if (type.equals(ClientEvent.PlotsZoomSizeChanged))\n         {\n            PlotsZoomSizeChangedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new PlotsZoomSizeChangedEvent(data));\n         }\n         else if (type.equals(ClientEvent.SourceCppStarted))\n         {\n            eventBus_.fireEvent(new SourceCppStartedEvent());\n         }\n         else if (type.equals(ClientEvent.SourceCppCompleted))\n         {\n            SourceCppState state = event.getData();\n            eventBus_.fireEvent(new SourceCppCompletedEvent(state));\n         }\n         else if (type.equals(ClientEvent.LoadedPackageUpdates))\n         {\n            String installCmd = event.getData();\n            eventBus_.fireEvent(new LoadedPackageUpdatesEvent(installCmd));\n         }\n         else if (type.equals(ClientEvent.ActivatePane))\n         {\n            String pane = event.getData();\n            eventBus_.fireEvent(new ActivatePaneEvent(pane));\n         }\n         else if (type.equals(ClientEvent.ShowPresentationPane))\n         {\n            PresentationState state = event.getData();\n            eventBus_.fireEvent(new ShowPresentationPaneEvent(state));\n         }\n         else if (type.equals(ClientEvent.EnvironmentRefresh))\n         {\n            eventBus_.fireEvent(new EnvironmentRefreshEvent());\n         }\n         else if (type.equals(ClientEvent.ListChanged))\n         {\n            eventBus_.fireEvent(new ListChangedEvent(event.<JsObject>getData()));\n         }\n         else if (type.equals(ClientEvent.UiPrefsChanged))\n         {\n            UiPrefsChangedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new UiPrefsChangedEvent(data));\n         }\n         else if (type.equals(ClientEvent.ContextDepthChanged)) {\n            EnvironmentContextData data = event.getData();\n            eventBus_.fireEvent(new ContextDepthChangedEvent(data, true));\n         }\n         else if (type.equals(ClientEvent.HandleUnsavedChanges))\n         {\n            eventBus_.fireEvent(new HandleUnsavedChangesEvent());\n         }\n         else if (type.equals(ClientEvent.Quit))\n         {\n            boolean switchProjects = event.<Bool>getData().getValue();\n            eventBus_.fireEvent(new QuitEvent(switchProjects));\n         }\n         else if (type.equals(ClientEvent.Suicide))\n         {\n            // NOTE: we don't explicitly stop listening for events here\n            // for the reasons cited above in ClientEvent.Quit\n            \n            // fire event\n            String message = event.getData();\n            eventBus_.fireEvent(new SuicideEvent(message));\n         }\n         else if (type.equals(ClientEvent.SaveActionChanged))\n         {\n            SaveAction action = event.getData();\n            eventBus_.fireEvent(new SaveActionChangedEvent(action));\n         }\n         else if (type.equals(ClientEvent.EnvironmentAssigned))\n         {\n            RObject objectInfo = event.getData();\n            eventBus_.fireEvent(new EnvironmentObjectAssignedEvent(objectInfo));\n         }\n         else if (type.equals(ClientEvent.EnvironmentRemoved))\n         {\n            String objectName = event.getData();\n            eventBus_.fireEvent(new EnvironmentObjectRemovedEvent(objectName));\n         }\n         else if (type.equals(ClientEvent.BrowserLineChanged))\n         {\n            LineData lineData = event.getData();\n            eventBus_.fireEvent(new BrowserLineChangedEvent(lineData));\n         }\n         else if (type.equals(ClientEvent.PackageLoaded))\n         {\n            eventBus_.fireEvent(new PackageLoadedEvent(\n                  (String)event.getData()));\n         }\n         else if (type.equals(ClientEvent.PackageUnloaded))\n         {\n            eventBus_.fireEvent(new PackageUnloadedEvent(\n                  (String)event.getData()));\n         }\n         else if (type.equals(ClientEvent.PresentationPaneRequestCompleted))\n         {\n            eventBus_.fireEvent(new PresentationPaneRequestCompletedEvent());\n         }\n         else if (type.equals(ClientEvent.UnhandledError))\n         {\n            UnhandledError err = event.getData();\n            eventBus_.fireEvent(new UnhandledErrorEvent(err));\n         }\n         else if (type.equals(ClientEvent.ErrorHandlerChanged))\n         {\n            ErrorHandlerType handlerType = event.getData();\n            eventBus_.fireEvent(new ErrorHandlerChangedEvent(handlerType));\n         }\n         else if (type.equals(ClientEvent.ViewerNavigate))\n         {\n            ViewerNavigateEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ViewerNavigateEvent(data));\n         }\n         else if (type.equals(ClientEvent.SourceExtendedTypeDetected))\n         {\n            SourceExtendedTypeDetectedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new SourceExtendedTypeDetectedEvent(data));\n         }\n         else if (type.equals(ClientEvent.ShinyViewer))\n         {\n            ShinyApplicationParams data = event.getData();\n            eventBus_.fireEvent(new ShinyApplicationStatusEvent(data));\n         }\n         else if (type.equals(ClientEvent.DebugSourceCompleted))\n         {\n            DebugSourceResult result = (DebugSourceResult)event.getData();\n            eventBus_.fireEvent(new DebugSourceCompletedEvent(result));\n         }\n         else if (type.equals(ClientEvent.RmdRenderStarted))\n         {\n            RmdRenderStartedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new RmdRenderStartedEvent(data));\n         }\n         else if (type.equals(ClientEvent.RmdRenderOutput))\n         {\n            CompileOutput data = event.getData();\n            eventBus_.fireEvent(new RmdRenderOutputEvent(data));\n         }\n         else if (type.equals(ClientEvent.RmdRenderCompleted))\n         {\n            RmdRenderResult result = event.getData();\n            eventBus_.fireEvent(new RmdRenderCompletedEvent(result));\n         }\n         else if (type.equals(ClientEvent.RmdTemplateDiscovered))\n         {\n            RmdDiscoveredTemplate template = event.getData();\n            eventBus_.fireEvent(new RmdTemplateDiscoveredEvent(template));\n         }\n         else if (type.equals(ClientEvent.RmdTemplateDiscoveryCompleted))\n         {\n            eventBus_.fireEvent(new RmdTemplateDiscoveryCompletedEvent());\n         }\n         else if (type.equals(ClientEvent.RmdShinyDocStarted))\n         {\n            RmdShinyDocInfo docInfo = event.getData();\n            eventBus_.fireEvent(new RmdShinyDocStartedEvent(docInfo));\n         }\n         else if (type.equals(ClientEvent.ShinyAppsDeploymentOutput))\n         {\n            CompileOutput output = event.getData();\n            eventBus_.fireEvent(new ShinyAppsDeploymentOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.ShinyAppsDeploymentCompleted))\n         {\n            String url = event.getData();\n            eventBus_.fireEvent(new ShinyAppsDeploymentCompletedEvent(url));\n         }\n         else if (type.equals(ClientEvent.UserPrompt))\n         {\n            UserPrompt prompt = event.getData();\n            eventBus_.fireEvent(new UserPromptEvent(prompt));\n         }\n         else if (type.equals(ClientEvent.InstallRtools))\n         {\n            InstallRtoolsEvent.Data data = event.getData();\n            eventBus_.fireEvent(new InstallRtoolsEvent(data));\n         }\n         else if (type.equals(ClientEvent.InstallShiny))\n         {\n            String userAction = event.getData();\n            eventBus_.fireEvent(new InstallShinyEvent(userAction));\n         }\n         else if (type.equals(ClientEvent.SuspendAndRestart))\n         {\n            SuspendAndRestartEvent.Data data = event.getData();\n            eventBus_.fireEvent(new SuspendAndRestartEvent(data));\n         }\n         else\n         {\n            GWT.log(\"WARNING: Server event not dispatched: \" + type, null);\n         }\n      }\n      catch(Throwable e)\n      {\n         GWT.log(\"WARNING: Exception occured dispatching event: \" + type, e);\n      }\n   }","commit_id":"e095141e25145b620600ae78cc9d97463a04723a","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public FileTypeCommands(Session session,\n                           EventBus eventBus,\n                           final HTMLPreviewServerOperations server)\n   {\n      session_ = session;\n          \n      eventBus.addHandler(InstalledPackagesChangedEvent.TYPE,\n                          new InstalledPackagesChangedHandler() {\n         @Override\n         public void onInstalledPackagesChanged(InstalledPackagesChangedEvent e)\n         {\n            server.getHTMLCapabilities(\n                  new ServerRequestCallback<HTMLCapabilities>() {\n\n                     @Override\n                     public void onResponseReceived(HTMLCapabilities caps)\n                     {\n                        setHTMLCapabilities(caps);\n                     }\n                     @Override\n                     public void onError(ServerError error)\n                     {\n                        Debug.logError(error);\n                     }\n                  });\n         }\n      });\n   }","id":97024,"modified_method":"@Inject\n   public FileTypeCommands(Session session,\n                           EventBus eventBus,\n                           final HTMLPreviewServerOperations server)\n   {\n      session_ = session;\n          \n      eventBus.addHandler(PackageStateChangedEvent.TYPE,\n                          new PackageStateChangedHandler() {\n         @Override\n         public void onPackageStateChanged(PackageStateChangedEvent e)\n         {\n            server.getHTMLCapabilities(\n                  new ServerRequestCallback<HTMLCapabilities>() {\n\n                     @Override\n                     public void onResponseReceived(HTMLCapabilities caps)\n                     {\n                        setHTMLCapabilities(caps);\n                     }\n                     @Override\n                     public void onError(ServerError error)\n                     {\n                        Debug.logError(error);\n                     }\n                  });\n         }\n      });\n   }","commit_id":"e095141e25145b620600ae78cc9d97463a04723a","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void onInstalledPackagesChanged(InstalledPackagesChangedEvent event)\n   {\n      updatePackageState(false) ;\n   }","id":97025,"modified_method":"public void onPackageStateChanged(PackageStateChangedEvent event)\n   {\n      updatePackageState(false) ;\n   }","commit_id":"e095141e25145b620600ae78cc9d97463a04723a","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public Packages(Display view, \n                   final EventBus events,\n                   PackagesServerOperations server,\n                   PackratServerOperations packratServer,\n                   GlobalDisplay globalDisplay,\n                   Session session,\n                   Binder binder,\n                   Commands commands,\n                   WorkbenchContext workbenchContext,\n                   DefaultCRANMirror defaultCRANMirror,\n                   RemoteFileSystemContext fsContext,\n                   PackratUtil packratUtil,\n                   Provider<FileDialogs> pFileDialogs)\n   {\n      super(view);\n      view_ = view;\n      server_ = server;\n      packratServer_ = packratServer;\n      globalDisplay_ = globalDisplay ;\n      view_.setObserver(this) ;\n      events_ = events ;\n      defaultCRANMirror_ = defaultCRANMirror;\n      workbenchContext_ = workbenchContext;\n      fsContext_ = fsContext;\n      packratUtil_ = packratUtil;\n      pFileDialogs_ = pFileDialogs;\n      session_ = session;\n      binder.bind(commands, this);\n      \n      events.addHandler(InstalledPackagesChangedEvent.TYPE, this);\n      events.addHandler(PackageStatusChangedEvent.TYPE, this);\n      \n      // make the install options persistent\n      new JSObjectStateValue(\"packages-pane\", \"installOptions\", ClientState.PROJECT_PERSISTENT,\n            session.getSessionInfo().getClientState(), false)\n      {\n         @Override\n         protected void onInit(JsObject value)\n         {\n            if (value != null)\n               installOptions_ = value.cast();\n            lastKnownState_ = installOptions_;\n         }\n\n         @Override\n         protected JsObject getValue()\n         {\n            return installOptions_.cast();\n         }\n\n         @Override\n         protected boolean hasChanged()\n         {\n            if (!PackageInstallOptions.areEqual(lastKnownState_, installOptions_))\n            {\n               lastKnownState_ = installOptions_;\n               return true;\n            }\n\n            return false;\n         }\n\n         private PackageInstallOptions lastKnownState_;\n      };\n      \n      updatePackageState(true);\n      \n      // after 2 seconds also add the DeferredInitCompleted handler\n      // (we wait because if we don't then on first load in a new \n      // session where the packages tab is showing updatePackageState \n      // will be called twice)\n      new Timer() {\n         @Override\n         public void run()\n         {\n            events.addHandler(DeferredInitCompletedEvent.TYPE, Packages.this); \n         }\n      }.schedule(2000);\n   }","id":97026,"modified_method":"@Inject\n   public Packages(Display view, \n                   final EventBus events,\n                   PackagesServerOperations server,\n                   PackratServerOperations packratServer,\n                   GlobalDisplay globalDisplay,\n                   Session session,\n                   Binder binder,\n                   Commands commands,\n                   WorkbenchContext workbenchContext,\n                   DefaultCRANMirror defaultCRANMirror,\n                   RemoteFileSystemContext fsContext,\n                   PackratUtil packratUtil,\n                   Provider<FileDialogs> pFileDialogs)\n   {\n      super(view);\n      view_ = view;\n      server_ = server;\n      packratServer_ = packratServer;\n      globalDisplay_ = globalDisplay ;\n      view_.setObserver(this) ;\n      events_ = events ;\n      defaultCRANMirror_ = defaultCRANMirror;\n      workbenchContext_ = workbenchContext;\n      fsContext_ = fsContext;\n      packratUtil_ = packratUtil;\n      pFileDialogs_ = pFileDialogs;\n      session_ = session;\n      binder.bind(commands, this);\n      \n      events.addHandler(PackageStateChangedEvent.TYPE, this);\n      events.addHandler(PackageStatusChangedEvent.TYPE, this);\n      \n      // make the install options persistent\n      new JSObjectStateValue(\"packages-pane\", \"installOptions\", ClientState.PROJECT_PERSISTENT,\n            session.getSessionInfo().getClientState(), false)\n      {\n         @Override\n         protected void onInit(JsObject value)\n         {\n            if (value != null)\n               installOptions_ = value.cast();\n            lastKnownState_ = installOptions_;\n         }\n\n         @Override\n         protected JsObject getValue()\n         {\n            return installOptions_.cast();\n         }\n\n         @Override\n         protected boolean hasChanged()\n         {\n            if (!PackageInstallOptions.areEqual(lastKnownState_, installOptions_))\n            {\n               lastKnownState_ = installOptions_;\n               return true;\n            }\n\n            return false;\n         }\n\n         private PackageInstallOptions lastKnownState_;\n      };\n      \n      updatePackageState(true);\n      \n      // after 2 seconds also add the DeferredInitCompleted handler\n      // (we wait because if we don't then on first load in a new \n      // session where the packages tab is showing updatePackageState \n      // will be called twice)\n      new Timer() {\n         @Override\n         public void run()\n         {\n            events.addHandler(DeferredInitCompletedEvent.TYPE, Packages.this); \n         }\n      }.schedule(2000);\n   }","commit_id":"e095141e25145b620600ae78cc9d97463a04723a","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void dispatchEvent(ClientEvent event) \n   { \n      String type = event.getType();\n      try\n      {\n         if (type.equals(ClientEvent.Busy))\n         {\n            boolean busy = event.<Bool>getData().getValue();\n            eventBus_.fireEvent(new BusyEvent(busy));\n         }\n         else if (type.equals(ClientEvent.ConsoleOutput))\n         {\n            String output = event.getData();\n            eventBus_.fireEvent(new ConsoleWriteOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.ConsoleError))\n         {\n            String error = event.getData();\n            eventBus_.fireEvent(new ConsoleWriteErrorEvent(error));\n         }\n         else if (type.equals(ClientEvent.ConsoleWritePrompt))\n         {\n            String prompt = event.getData();\n            eventBus_.fireEvent(new ConsoleWritePromptEvent(prompt));\n         }\n         else if (type.equals(ClientEvent.ConsoleWriteInput))\n         {\n            String input = event.getData();\n            eventBus_.fireEvent(new ConsoleWriteInputEvent(input));\n         }\n         else if (type.equals(ClientEvent.ConsolePrompt))\n         {\n            ConsolePrompt prompt = event.getData();\n            eventBus_.fireEvent(new ConsolePromptEvent(prompt));\n         }\n         else if (type.equals(ClientEvent.ShowEditor))\n         {\n            ShowEditorData data = event.getData();\n            eventBus_.fireEvent(new ShowEditorEvent(data));\n         }\n         else if (type.equals(ClientEvent.FileChanged))\n         {\n            FileChange fileChange = event.getData();\n            eventBus_.fireEvent(new FileChangeEvent(fileChange));\n         }\n         else if (type.equals(ClientEvent.WorkingDirChanged))\n         {\n            String path = event.getData();\n            eventBus_.fireEvent(new WorkingDirChangedEvent(path));\n         }\n         else if (type.equals(ClientEvent.WorkspaceRefresh))\n         {\n            eventBus_.fireEvent(new WorkspaceRefreshEvent());\n         }\n         else if (type.equals(ClientEvent.WorkspaceAssign))\n         {\n            WorkspaceObjectInfo objectInfo = event.getData();\n            eventBus_.fireEvent(new WorkspaceObjectAssignedEvent(objectInfo));\n         }\n         else if (type.equals(ClientEvent.WorkspaceRemove))\n         {\n            String objectName = event.getData();\n            eventBus_.fireEvent(new WorkspaceObjectRemovedEvent(objectName));\n         }\n         else if (type.equals(ClientEvent.ShowHelp))\n         {\n            String helpUrl = event.getData();\n            eventBus_.fireEvent(new ShowHelpEvent(helpUrl));\n         }\n         else if (type.equals(ClientEvent.ShowErrorMessage))\n         {\n            ErrorMessage errorMessage = event.getData();\n            eventBus_.fireEvent(new ShowErrorMessageEvent(errorMessage));\n         }\n         else if (type.equals(ClientEvent.ChooseFile))\n         {\n            boolean newFile = event.<Bool>getData().getValue();\n            eventBus_.fireEvent(new ChooseFileEvent(newFile));\n         }\n         else if (type.equals(ClientEvent.BrowseUrl))\n         {\n            BrowseUrlInfo urlInfo = event.getData();\n            eventBus_.fireEvent(new BrowseUrlEvent(urlInfo));\n         }\n         else if (type.equals(ClientEvent.PlotsStateChanged))\n         {\n            PlotsState plotsState = event.getData();\n            eventBus_.fireEvent(new PlotsChangedEvent(plotsState));\n         }\n         else if (type.equals(ClientEvent.ViewData))\n         {\n            DataView dataView = event.getData();\n            eventBus_.fireEvent(new ViewDataEvent(dataView));\n         }\n         else if (type.equals(ClientEvent.InstalledPackagesChanged))\n         {\n            eventBus_.fireEvent(new InstalledPackagesChangedEvent());\n         }\n         else if (type.equals(ClientEvent.PackageStatusChanged))\n         {\n            PackageStatus status = event.getData();\n            eventBus_.fireEvent(new PackageStatusChangedEvent(status));\n         }\n         else if (type.equals(ClientEvent.Locator))\n         {\n            eventBus_.fireEvent(new LocatorEvent());\n         }\n         else if (type.equals(ClientEvent.ConsoleResetHistory))\n         {\n            ConsoleResetHistory reset = event.getData();\n            eventBus_.fireEvent(new ConsoleResetHistoryEvent(reset));\n         }\n         else if (type.equals(ClientEvent.SessionSerialization))\n         {\n            SessionSerializationAction action = event.getData();\n            eventBus_.fireEvent(new SessionSerializationEvent(action));\n         }\n         else if (type.equals(ClientEvent.HistoryEntriesAdded))\n         {\n            RpcObjectList<HistoryEntry> entries = event.getData();\n            eventBus_.fireEvent(new HistoryEntriesAddedEvent(entries));\n         }\n         else if (type.equals(ClientEvent.QuotaStatus))\n         {\n            QuotaStatus quotaStatus = event.getData();\n            eventBus_.fireEvent(new QuotaStatusEvent(quotaStatus));\n         }\n         else if (type.equals(ClientEvent.FileEdit))\n         {\n            FileSystemItem file = event.getData();\n            eventBus_.fireEvent(new FileEditEvent(file));\n         }\n         else if (type.equals(ClientEvent.ShowContent))\n         {\n            ContentItem content = event.getData();\n            eventBus_.fireEvent(new ShowContentEvent(content));\n         }\n         else if (type.equals(ClientEvent.ShowData))\n         {\n            DataItem data = event.getData();\n            eventBus_.fireEvent(new ShowDataEvent(data));\n         }\n         else if (type.equals(ClientEvent.AbendWarning))\n         {            \n            eventBus_.fireEvent(new SessionAbendWarningEvent());\n         }\n         else if (type.equals(ClientEvent.ShowWarningBar))\n         {\n            WarningBarMessage message = event.getData();\n            eventBus_.fireEvent(new ShowWarningBarEvent(message));\n         }\n         else if (type.equals(ClientEvent.OpenProjectError))\n         {\n            OpenProjectError error = event.getData();\n            eventBus_.fireEvent(new OpenProjectErrorEvent(error));\n         }\n         else if (type.equals(ClientEvent.VcsRefresh))\n         {\n            JsObject data = event.getData();\n            eventBus_.fireEvent(new VcsRefreshEvent(Reason.NA,\n                                                    data.getInteger(\"delay\")));\n         }\n         else if (type.equals(ClientEvent.AskPass))\n         {\n            AskPassEvent.Data data = event.getData();\n            eventBus_.fireEvent(new AskPassEvent(data));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessOutput))\n         {\n            ServerConsoleOutputEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ServerConsoleOutputEvent(data.getHandle(),\n                                                            data.getOutput(),\n                                                            data.isError()));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessPrompt))\n         {\n            ServerConsolePromptEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ServerConsolePromptEvent(data.getHandle(),\n                                                             data.getPrompt()));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessCreated))\n         {\n            ConsoleProcessCreatedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ConsoleProcessCreatedEvent(data));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessExit))\n         {\n            ServerProcessExitEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ServerProcessExitEvent(data.getHandle(),\n                                                          data.getExitCode()));\n         }\n         else if (type.equals(ClientEvent.HTMLPreviewStartedEvent))\n         {\n            HTMLPreviewStartedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new HTMLPreviewStartedEvent(data));\n         }\n         else if (type.equals(ClientEvent.HTMLPreviewOutputEvent))\n         {\n            String output = event.getData();\n            eventBus_.fireEvent(new HTMLPreviewOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.HTMLPreviewCompletedEvent))\n         {\n            HTMLPreviewResult result = event.getData();\n            eventBus_.fireEvent(new HTMLPreviewCompletedEvent(result));\n         }\n         else if (type.equals(ClientEvent.CompilePdfStartedEvent))\n         {\n            CompilePdfStartedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new CompilePdfStartedEvent(data));\n         }\n         else if (type.equals(ClientEvent.CompilePdfOutputEvent))\n         {\n            String output = event.getData();\n            eventBus_.fireEvent(new CompilePdfOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.CompilePdfErrorsEvent))\n         {\n            JsArray<CompileError> data = event.getData();\n            eventBus_.fireEvent(new CompilePdfErrorsEvent(data));\n         }\n         else if (type.equals(ClientEvent.CompilePdfCompletedEvent))\n         {\n            CompilePdfResult result = event.getData();\n            eventBus_.fireEvent(new CompilePdfCompletedEvent(result));\n         }\n         else if (type.equals(ClientEvent.SynctexEditFile))\n         {\n            SourceLocation sourceLocation = event.getData();\n            eventBus_.fireEvent(new SynctexEditFileEvent(sourceLocation));\n         }\n         else if (type.equals(ClientEvent.FindResult))\n         {\n            FindResultEvent.Data data = event.getData();\n            eventBus_.fireEvent(new FindResultEvent(\n                  data.getHandle(), data.getResults().toArrayList()));\n         }\n         else if (type.equals(ClientEvent.FindOperationEnded))\n         {\n            String data = event.getData();\n            eventBus_.fireEvent(new FindOperationEndedEvent(data));\n         }\n         else if (type.equals(ClientEvent.RPubsUploadStatus))\n         {\n            RPubsUploadStatusEvent.Status status = event.getData();\n            eventBus_.fireEvent(new RPubsUploadStatusEvent(status));\n         }\n         else if (type.equals(ClientEvent.BuildStarted))\n         {\n            eventBus_.fireEvent(new BuildStartedEvent());\n         }\n         else if (type.equals(ClientEvent.BuildOutput))\n         {\n            CompileOutput data = event.getData();\n            eventBus_.fireEvent(new BuildOutputEvent(data));\n         }\n         else if (type.equals(ClientEvent.BuildCompleted))\n         {\n            BuildCompletedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new BuildCompletedEvent(data));\n         }\n         else if (type.equals(ClientEvent.BuildErrors))\n         {\n            BuildErrorsEvent.Data data = event.getData();\n            eventBus_.fireEvent(new BuildErrorsEvent(data));\n         }\n         else if (type.equals(ClientEvent.DirectoryNavigate))\n         {\n            DirectoryNavigateEvent.Data data = event.getData();\n            eventBus_.fireEvent(new DirectoryNavigateEvent(data));\n         }\n         else if (type.equals(ClientEvent.DeferredInitCompleted))\n         {\n            eventBus_.fireEvent(new DeferredInitCompletedEvent());\n         }\n         else if (type.equals(ClientEvent.PlotsZoomSizeChanged))\n         {\n            PlotsZoomSizeChangedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new PlotsZoomSizeChangedEvent(data));\n         }\n         else if (type.equals(ClientEvent.SourceCppStarted))\n         {\n            eventBus_.fireEvent(new SourceCppStartedEvent());\n         }\n         else if (type.equals(ClientEvent.SourceCppCompleted))\n         {\n            SourceCppState state = event.getData();\n            eventBus_.fireEvent(new SourceCppCompletedEvent(state));\n         }\n         else if (type.equals(ClientEvent.LoadedPackageUpdates))\n         {\n            String installCmd = event.getData();\n            eventBus_.fireEvent(new LoadedPackageUpdatesEvent(installCmd));\n         }\n         else if (type.equals(ClientEvent.ActivatePane))\n         {\n            String pane = event.getData();\n            eventBus_.fireEvent(new ActivatePaneEvent(pane));\n         }\n         else if (type.equals(ClientEvent.ShowPresentationPane))\n         {\n            PresentationState state = event.getData();\n            eventBus_.fireEvent(new ShowPresentationPaneEvent(state));\n         }\n         else if (type.equals(ClientEvent.EnvironmentRefresh))\n         {\n            eventBus_.fireEvent(new EnvironmentRefreshEvent());\n         }\n         else if (type.equals(ClientEvent.ListChanged))\n         {\n            eventBus_.fireEvent(new ListChangedEvent(event.<JsObject>getData()));\n         }\n         else if (type.equals(ClientEvent.UiPrefsChanged))\n         {\n            UiPrefsChangedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new UiPrefsChangedEvent(data));\n         }\n         else if (type.equals(ClientEvent.BrowseModeChanged)) {\n            eventBus_.fireEvent(new BrowseModeChangedEvent());\n         }\n         else if (type.equals(ClientEvent.HandleUnsavedChanges))\n         {\n            eventBus_.fireEvent(new HandleUnsavedChangesEvent());\n         }\n         else if (type.equals(ClientEvent.Quit))\n         {\n            boolean switchProjects = event.<Bool>getData().getValue();\n            eventBus_.fireEvent(new QuitEvent(switchProjects));\n         }\n         else if (type.equals(ClientEvent.Suicide))\n         {\n            // NOTE: we don't explicitly stop listening for events here\n            // for the reasons cited above in ClientEvent.Quit\n            \n            // fire event\n            String message = event.getData();\n            eventBus_.fireEvent(new SuicideEvent(message));\n         }\n         else if (type.equals(ClientEvent.SaveActionChanged))\n         {\n            SaveAction action = event.getData();\n            eventBus_.fireEvent(new SaveActionChangedEvent(action));\n         }\n         else\n         {\n            GWT.log(\"WARNING: Server event not dispatched: \" + type, null);\n         }\n      }\n      catch(Throwable e)\n      {\n         GWT.log(\"WARNING: Exception occured dispatching event: \" + type, e);\n      }\n   }","id":97027,"modified_method":"private void dispatchEvent(ClientEvent event) \n   { \n      String type = event.getType();\n      try\n      {\n         if (type.equals(ClientEvent.Busy))\n         {\n            boolean busy = event.<Bool>getData().getValue();\n            eventBus_.fireEvent(new BusyEvent(busy));\n         }\n         else if (type.equals(ClientEvent.ConsoleOutput))\n         {\n            String output = event.getData();\n            eventBus_.fireEvent(new ConsoleWriteOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.ConsoleError))\n         {\n            String error = event.getData();\n            eventBus_.fireEvent(new ConsoleWriteErrorEvent(error));\n         }\n         else if (type.equals(ClientEvent.ConsoleWritePrompt))\n         {\n            String prompt = event.getData();\n            eventBus_.fireEvent(new ConsoleWritePromptEvent(prompt));\n         }\n         else if (type.equals(ClientEvent.ConsoleWriteInput))\n         {\n            String input = event.getData();\n            eventBus_.fireEvent(new ConsoleWriteInputEvent(input));\n         }\n         else if (type.equals(ClientEvent.ConsolePrompt))\n         {\n            ConsolePrompt prompt = event.getData();\n            eventBus_.fireEvent(new ConsolePromptEvent(prompt));\n         }\n         else if (type.equals(ClientEvent.ShowEditor))\n         {\n            ShowEditorData data = event.getData();\n            eventBus_.fireEvent(new ShowEditorEvent(data));\n         }\n         else if (type.equals(ClientEvent.FileChanged))\n         {\n            FileChange fileChange = event.getData();\n            eventBus_.fireEvent(new FileChangeEvent(fileChange));\n         }\n         else if (type.equals(ClientEvent.WorkingDirChanged))\n         {\n            String path = event.getData();\n            eventBus_.fireEvent(new WorkingDirChangedEvent(path));\n         }\n         else if (type.equals(ClientEvent.WorkspaceRefresh))\n         {\n            eventBus_.fireEvent(new WorkspaceRefreshEvent());\n         }\n         else if (type.equals(ClientEvent.WorkspaceAssign))\n         {\n            WorkspaceObjectInfo objectInfo = event.getData();\n            eventBus_.fireEvent(new WorkspaceObjectAssignedEvent(objectInfo));\n         }\n         else if (type.equals(ClientEvent.WorkspaceRemove))\n         {\n            String objectName = event.getData();\n            eventBus_.fireEvent(new WorkspaceObjectRemovedEvent(objectName));\n         }\n         else if (type.equals(ClientEvent.ShowHelp))\n         {\n            String helpUrl = event.getData();\n            eventBus_.fireEvent(new ShowHelpEvent(helpUrl));\n         }\n         else if (type.equals(ClientEvent.ShowErrorMessage))\n         {\n            ErrorMessage errorMessage = event.getData();\n            eventBus_.fireEvent(new ShowErrorMessageEvent(errorMessage));\n         }\n         else if (type.equals(ClientEvent.ChooseFile))\n         {\n            boolean newFile = event.<Bool>getData().getValue();\n            eventBus_.fireEvent(new ChooseFileEvent(newFile));\n         }\n         else if (type.equals(ClientEvent.BrowseUrl))\n         {\n            BrowseUrlInfo urlInfo = event.getData();\n            eventBus_.fireEvent(new BrowseUrlEvent(urlInfo));\n         }\n         else if (type.equals(ClientEvent.PlotsStateChanged))\n         {\n            PlotsState plotsState = event.getData();\n            eventBus_.fireEvent(new PlotsChangedEvent(plotsState));\n         }\n         else if (type.equals(ClientEvent.ViewData))\n         {\n            DataView dataView = event.getData();\n            eventBus_.fireEvent(new ViewDataEvent(dataView));\n         }\n         else if (type.equals(ClientEvent.InstalledPackagesChanged))\n         {\n            eventBus_.fireEvent(new InstalledPackagesChangedEvent());\n         }\n         else if (type.equals(ClientEvent.PackageStatusChanged))\n         {\n            PackageStatus status = event.getData();\n            eventBus_.fireEvent(new PackageStatusChangedEvent(status));\n         }\n         else if (type.equals(ClientEvent.Locator))\n         {\n            eventBus_.fireEvent(new LocatorEvent());\n         }\n         else if (type.equals(ClientEvent.ConsoleResetHistory))\n         {\n            ConsoleResetHistory reset = event.getData();\n            eventBus_.fireEvent(new ConsoleResetHistoryEvent(reset));\n         }\n         else if (type.equals(ClientEvent.SessionSerialization))\n         {\n            SessionSerializationAction action = event.getData();\n            eventBus_.fireEvent(new SessionSerializationEvent(action));\n         }\n         else if (type.equals(ClientEvent.HistoryEntriesAdded))\n         {\n            RpcObjectList<HistoryEntry> entries = event.getData();\n            eventBus_.fireEvent(new HistoryEntriesAddedEvent(entries));\n         }\n         else if (type.equals(ClientEvent.QuotaStatus))\n         {\n            QuotaStatus quotaStatus = event.getData();\n            eventBus_.fireEvent(new QuotaStatusEvent(quotaStatus));\n         }\n         else if (type.equals(ClientEvent.FileEdit))\n         {\n            FileSystemItem file = event.getData();\n            eventBus_.fireEvent(new FileEditEvent(file));\n         }\n         else if (type.equals(ClientEvent.ShowContent))\n         {\n            ContentItem content = event.getData();\n            eventBus_.fireEvent(new ShowContentEvent(content));\n         }\n         else if (type.equals(ClientEvent.ShowData))\n         {\n            DataItem data = event.getData();\n            eventBus_.fireEvent(new ShowDataEvent(data));\n         }\n         else if (type.equals(ClientEvent.AbendWarning))\n         {            \n            eventBus_.fireEvent(new SessionAbendWarningEvent());\n         }\n         else if (type.equals(ClientEvent.ShowWarningBar))\n         {\n            WarningBarMessage message = event.getData();\n            eventBus_.fireEvent(new ShowWarningBarEvent(message));\n         }\n         else if (type.equals(ClientEvent.OpenProjectError))\n         {\n            OpenProjectError error = event.getData();\n            eventBus_.fireEvent(new OpenProjectErrorEvent(error));\n         }\n         else if (type.equals(ClientEvent.VcsRefresh))\n         {\n            JsObject data = event.getData();\n            eventBus_.fireEvent(new VcsRefreshEvent(Reason.NA,\n                                                    data.getInteger(\"delay\")));\n         }\n         else if (type.equals(ClientEvent.AskPass))\n         {\n            AskPassEvent.Data data = event.getData();\n            eventBus_.fireEvent(new AskPassEvent(data));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessOutput))\n         {\n            ServerConsoleOutputEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ServerConsoleOutputEvent(data.getHandle(),\n                                                            data.getOutput(),\n                                                            data.isError()));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessPrompt))\n         {\n            ServerConsolePromptEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ServerConsolePromptEvent(data.getHandle(),\n                                                             data.getPrompt()));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessCreated))\n         {\n            ConsoleProcessCreatedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ConsoleProcessCreatedEvent(data));\n         }\n         else if (type.equals(ClientEvent.ConsoleProcessExit))\n         {\n            ServerProcessExitEvent.Data data = event.getData();\n            eventBus_.fireEvent(new ServerProcessExitEvent(data.getHandle(),\n                                                          data.getExitCode()));\n         }\n         else if (type.equals(ClientEvent.HTMLPreviewStartedEvent))\n         {\n            HTMLPreviewStartedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new HTMLPreviewStartedEvent(data));\n         }\n         else if (type.equals(ClientEvent.HTMLPreviewOutputEvent))\n         {\n            String output = event.getData();\n            eventBus_.fireEvent(new HTMLPreviewOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.HTMLPreviewCompletedEvent))\n         {\n            HTMLPreviewResult result = event.getData();\n            eventBus_.fireEvent(new HTMLPreviewCompletedEvent(result));\n         }\n         else if (type.equals(ClientEvent.CompilePdfStartedEvent))\n         {\n            CompilePdfStartedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new CompilePdfStartedEvent(data));\n         }\n         else if (type.equals(ClientEvent.CompilePdfOutputEvent))\n         {\n            String output = event.getData();\n            eventBus_.fireEvent(new CompilePdfOutputEvent(output));\n         }\n         else if (type.equals(ClientEvent.CompilePdfErrorsEvent))\n         {\n            JsArray<CompileError> data = event.getData();\n            eventBus_.fireEvent(new CompilePdfErrorsEvent(data));\n         }\n         else if (type.equals(ClientEvent.CompilePdfCompletedEvent))\n         {\n            CompilePdfResult result = event.getData();\n            eventBus_.fireEvent(new CompilePdfCompletedEvent(result));\n         }\n         else if (type.equals(ClientEvent.SynctexEditFile))\n         {\n            SourceLocation sourceLocation = event.getData();\n            eventBus_.fireEvent(new SynctexEditFileEvent(sourceLocation));\n         }\n         else if (type.equals(ClientEvent.FindResult))\n         {\n            FindResultEvent.Data data = event.getData();\n            eventBus_.fireEvent(new FindResultEvent(\n                  data.getHandle(), data.getResults().toArrayList()));\n         }\n         else if (type.equals(ClientEvent.FindOperationEnded))\n         {\n            String data = event.getData();\n            eventBus_.fireEvent(new FindOperationEndedEvent(data));\n         }\n         else if (type.equals(ClientEvent.RPubsUploadStatus))\n         {\n            RPubsUploadStatusEvent.Status status = event.getData();\n            eventBus_.fireEvent(new RPubsUploadStatusEvent(status));\n         }\n         else if (type.equals(ClientEvent.BuildStarted))\n         {\n            eventBus_.fireEvent(new BuildStartedEvent());\n         }\n         else if (type.equals(ClientEvent.BuildOutput))\n         {\n            CompileOutput data = event.getData();\n            eventBus_.fireEvent(new BuildOutputEvent(data));\n         }\n         else if (type.equals(ClientEvent.BuildCompleted))\n         {\n            BuildCompletedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new BuildCompletedEvent(data));\n         }\n         else if (type.equals(ClientEvent.BuildErrors))\n         {\n            BuildErrorsEvent.Data data = event.getData();\n            eventBus_.fireEvent(new BuildErrorsEvent(data));\n         }\n         else if (type.equals(ClientEvent.DirectoryNavigate))\n         {\n            DirectoryNavigateEvent.Data data = event.getData();\n            eventBus_.fireEvent(new DirectoryNavigateEvent(data));\n         }\n         else if (type.equals(ClientEvent.DeferredInitCompleted))\n         {\n            eventBus_.fireEvent(new DeferredInitCompletedEvent());\n         }\n         else if (type.equals(ClientEvent.PlotsZoomSizeChanged))\n         {\n            PlotsZoomSizeChangedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new PlotsZoomSizeChangedEvent(data));\n         }\n         else if (type.equals(ClientEvent.SourceCppStarted))\n         {\n            eventBus_.fireEvent(new SourceCppStartedEvent());\n         }\n         else if (type.equals(ClientEvent.SourceCppCompleted))\n         {\n            SourceCppState state = event.getData();\n            eventBus_.fireEvent(new SourceCppCompletedEvent(state));\n         }\n         else if (type.equals(ClientEvent.LoadedPackageUpdates))\n         {\n            String installCmd = event.getData();\n            eventBus_.fireEvent(new LoadedPackageUpdatesEvent(installCmd));\n         }\n         else if (type.equals(ClientEvent.ActivatePane))\n         {\n            String pane = event.getData();\n            eventBus_.fireEvent(new ActivatePaneEvent(pane));\n         }\n         else if (type.equals(ClientEvent.ShowPresentationPane))\n         {\n            PresentationState state = event.getData();\n            eventBus_.fireEvent(new ShowPresentationPaneEvent(state));\n         }\n         else if (type.equals(ClientEvent.EnvironmentRefresh))\n         {\n            eventBus_.fireEvent(new EnvironmentRefreshEvent());\n         }\n         else if (type.equals(ClientEvent.ListChanged))\n         {\n            eventBus_.fireEvent(new ListChangedEvent(event.<JsObject>getData()));\n         }\n         else if (type.equals(ClientEvent.UiPrefsChanged))\n         {\n            UiPrefsChangedEvent.Data data = event.getData();\n            eventBus_.fireEvent(new UiPrefsChangedEvent(data));\n         }\n         else if (type.equals(ClientEvent.ContextDepthChanged)) {\n            ContextDepthChangedEvent.ContextData data = event.getData();\n            eventBus_.fireEvent(new ContextDepthChangedEvent(data));\n         }\n         else if (type.equals(ClientEvent.HandleUnsavedChanges))\n         {\n            eventBus_.fireEvent(new HandleUnsavedChangesEvent());\n         }\n         else if (type.equals(ClientEvent.Quit))\n         {\n            boolean switchProjects = event.<Bool>getData().getValue();\n            eventBus_.fireEvent(new QuitEvent(switchProjects));\n         }\n         else if (type.equals(ClientEvent.Suicide))\n         {\n            // NOTE: we don't explicitly stop listening for events here\n            // for the reasons cited above in ClientEvent.Quit\n            \n            // fire event\n            String message = event.getData();\n            eventBus_.fireEvent(new SuicideEvent(message));\n         }\n         else if (type.equals(ClientEvent.SaveActionChanged))\n         {\n            SaveAction action = event.getData();\n            eventBus_.fireEvent(new SaveActionChangedEvent(action));\n         }\n         else if (type.equals(ClientEvent.EnvironmentAssigned))\n         {\n            RObject objectInfo = event.getData();\n            eventBus_.fireEvent(new EnvironmentObjectAssignedEvent(objectInfo));\n         }\n         else if (type.equals(ClientEvent.EnvironmentRemoved))\n         {\n            String objectName = event.getData();\n            eventBus_.fireEvent(new EnvironmentObjectRemovedEvent(objectName));\n         }\n         else\n         {\n            GWT.log(\"WARNING: Server event not dispatched: \" + type, null);\n         }\n      }\n      catch(Throwable e)\n      {\n         GWT.log(\"WARNING: Exception occured dispatching event: \" + type, e);\n      }\n   }","commit_id":"1f3653e5d94ce25f5c1e933f095e13087adc1ed7","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void refreshView()\n   {\n      view_.clearObjects();\n      \n      server_.listEnvironment(new ServerRequestCallback<JsArray<RObject>>() {\n\n         @Override\n         public void onResponseReceived(JsArray<RObject> objects)\n         {\n            for (int i = 0; i<objects.length(); i++)\n               view_.addObject(objects.get(i));\n         }\n         \n         @Override\n         public void onError(ServerError error)\n         {\n            globalDisplay_.showErrorMessage(\"Error Listing Objects\", \n                                            error.getUserMessage());\n         }\n      });\n   }","id":97028,"modified_method":"private void refreshView()\n   {\n      server_.listEnvironment(new ServerRequestCallback<JsArray<RObject>>() {\n\n         @Override\n         public void onResponseReceived(JsArray<RObject> objects)\n         {\n            setViewFromEnvironmentList(objects);\n         }\n         \n         @Override\n         public void onError(ServerError error)\n         {\n            globalDisplay_.showErrorMessage(\"Error Listing Objects\", \n                                            error.getUserMessage());\n         }\n      });\n   }","commit_id":"1f3653e5d94ce25f5c1e933f095e13087adc1ed7","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void initialize(EnvironmentState environmentState)\n   {\n      environmentState_ = environmentState;\n      setBrowseMode(environmentState_.inBrowseMode());\n   }","id":97029,"modified_method":"public void initialize(EnvironmentState environmentState)\n   {\n      environmentState_ = environmentState;\n      setContextDepth(environmentState_.contextDepth());\n   }","commit_id":"1f3653e5d94ce25f5c1e933f095e13087adc1ed7","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public EnvironmentPresenter(Display view,\n                               EnvironmentServerOperations server,\n                               Binder binder,\n                               Commands commands,\n                               GlobalDisplay globalDisplay,\n                               EventBus eventBus)\n   {\n      super(view);\n      binder.bind(commands, this);\n      \n      view_ = view;\n      server_ = server;\n      globalDisplay_ = globalDisplay;\n      \n      refreshView();\n      \n      eventBus.addHandler(EnvironmentRefreshEvent.TYPE, \n                          new EnvironmentRefreshEvent.Handler()\n      {\n         @Override\n         public void onEnvironmentRefresh(EnvironmentRefreshEvent event)\n         {\n            refreshView();\n         }\n      });\n      \n      eventBus.addHandler(BrowseModeChangedEvent.TYPE, \n                          new BrowseModeChangedEvent.Handler()\n      {\n         @Override\n         public void onBrowseModeChanged(BrowseModeChangedEvent event)\n         {\n            inBrowseMode_ = !inBrowseMode_;\n            view_.setBrowseMode(inBrowseMode_);\n         }\n      });\n   }","id":97030,"modified_method":"@Inject\n   public EnvironmentPresenter(Display view,\n                               EnvironmentServerOperations server,\n                               Binder binder,\n                               Commands commands,\n                               GlobalDisplay globalDisplay,\n                               EventBus eventBus)\n   {\n      super(view);\n      binder.bind(commands, this);\n      \n      view_ = view;\n      server_ = server;\n      globalDisplay_ = globalDisplay;\n      \n      refreshView();\n      \n      eventBus.addHandler(EnvironmentRefreshEvent.TYPE, \n                          new EnvironmentRefreshEvent.Handler()\n      {\n         @Override\n         public void onEnvironmentRefresh(EnvironmentRefreshEvent event)\n         {\n            refreshView();\n         }\n      });\n      \n      eventBus.addHandler(ContextDepthChangedEvent.TYPE, \n                          new ContextDepthChangedEvent.Handler()\n      {\n         @Override\n         public void onContextDepthChanged(ContextDepthChangedEvent event)\n         {\n            contextDepth_ = event.getContextDepth();\n            view_.setContextDepth(contextDepth_);\n            setViewFromEnvironmentList(event.getEnvironmentList());\n         }\n      });\n      \n      eventBus.addHandler(EnvironmentObjectAssignedEvent.TYPE,\n                          new EnvironmentObjectAssignedEvent.Handler() \n      {\n         @Override\n         public void onEnvironmentObjectAssigned(EnvironmentObjectAssignedEvent event)\n         {\n            view_.addObject(event.getObjectInfo());\n         }\n      });\n\n      eventBus.addHandler(EnvironmentObjectRemovedEvent.TYPE,\n            new EnvironmentObjectRemovedEvent.Handler() \n      {\n         @Override\n         public void onEnvironmentObjectRemoved(EnvironmentObjectRemovedEvent event)\n         {\n            view_.removeObject(event.getObjectName());\n         }\n      });\n   }","commit_id":"1f3653e5d94ce25f5c1e933f095e13087adc1ed7","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void populateMojoExecutionConfiguration( MavenProject project, MojoExecution mojoExecution,\n                                                     boolean directInvocation )\n    {\n        String g = mojoExecution.getGroupId();\n\n        String a = mojoExecution.getArtifactId();\n\n        Plugin p = project.getPlugin( g + \":\" + a );\n\n        if ( p != null )\n        {\n            for ( PluginExecution e : p.getExecutions() )\n            {\n                if ( mojoExecution.getExecutionId().equals( e.getId() ) )\n                {\n                    Xpp3Dom executionConfiguration = (Xpp3Dom) e.getConfiguration();\n\n                    Xpp3Dom mojoConfiguration =\n                        extractMojoConfiguration( executionConfiguration, mojoExecution.getMojoDescriptor() );\n\n                    mojoExecution.setConfiguration( mojoConfiguration );\n\n                    return;\n                }\n            }\n        }\n\n        if ( directInvocation )\n        {\n            Xpp3Dom defaultDom = convert( mojoExecution.getMojoDescriptor() );\n\n            if ( p != null && p.getConfiguration() != null )\n            {\n                Xpp3Dom projectDom = (Xpp3Dom) p.getConfiguration();\n                projectDom = extractMojoConfiguration( projectDom, mojoExecution.getMojoDescriptor() );\n                mojoExecution.setConfiguration( Xpp3Dom.mergeXpp3Dom( projectDom, defaultDom, Boolean.TRUE ) );\n            }\n            else\n            {\n                mojoExecution.setConfiguration( defaultDom );\n            }\n        }\n    }","id":97031,"modified_method":"private void populateMojoExecutionConfiguration( MavenProject project, MojoExecution mojoExecution, boolean directInvocation )\n    {\n        String g = mojoExecution.getGroupId();\n\n        String a = mojoExecution.getArtifactId();\n\n        Plugin plugin = project.getPlugin( g + \":\" + a );\n\n        if ( plugin != null )\n        {\n            for ( PluginExecution e : plugin.getExecutions() )\n            {\n                if ( mojoExecution.getExecutionId().equals( e.getId() ) )\n                {\n                    Xpp3Dom executionConfiguration = (Xpp3Dom) e.getConfiguration();\n\n                    Xpp3Dom mojoConfiguration = extractMojoConfiguration( executionConfiguration, mojoExecution.getMojoDescriptor() );\n\n                    mojoExecution.setConfiguration( mojoConfiguration );\n\n                    return;\n                }\n            }\n        }\n\n        if ( directInvocation )\n        {\n            Xpp3Dom defaultDom = convert( mojoExecution.getMojoDescriptor() );\n\n            if ( plugin != null && plugin.getConfiguration() != null )\n            {\n                Xpp3Dom projectDom = (Xpp3Dom) plugin.getConfiguration();\n                projectDom = extractMojoConfiguration( projectDom, mojoExecution.getMojoDescriptor() );\n                mojoExecution.setConfiguration( Xpp3Dom.mergeXpp3Dom( projectDom, defaultDom, Boolean.TRUE ) );\n            }\n            else\n            {\n                mojoExecution.setConfiguration( defaultDom );\n            }\n        }\n    }","commit_id":"5b76c2c49543d22cc1bb303264c4f4728aec4731","url":"https://github.com/apache/maven"},{"original_method":"public List<MojoExecution> calculateBuildPlan(  MavenSession session, String... tasks )\n        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, CycleDetectedInPluginGraphException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException\n    {        \n        MavenProject project = session.getCurrentProject();\n                \n        List<MojoExecution> phasesWithMojosToExecute = new ArrayList<MojoExecution>();\n        \n        List<MojoExecution> lifecyclePlan = new ArrayList<MojoExecution>();\n                \n        for ( String task : tasks )\n        {\n\n            if ( task.indexOf( \":\" ) > 0 )\n            {\n                // If this is a goal like \"mvn modello:java\" and the POM looks like the following:\n                \n                // <project>\n                //   <modelVersion>4.0.0<\/modelVersion>\n                //   <groupId>org.apache.maven.plugins<\/groupId>\n                //   <artifactId>project-plugin-level-configuration-only<\/artifactId>\n                //   <version>1.0.1<\/version>\n                //   <build>\n                //     <plugins>\n                //       <plugin>\n                //         <groupId>org.codehaus.modello<\/groupId>\n                //         <artifactId>modello-maven-plugin<\/artifactId>\n                //         <version>1.0.1<\/version>\n                //         <configuration>\n                //           <version>1.1.0<\/version>\n                //           <models>\n                //             <model>src/main/mdo/remote-resources.mdo<\/model>\n                //           <\/models>\n                //         <\/configuration>\n                //       <\/plugin>\n                //     <\/plugins>\n                //   <\/build>\n                // <\/project>                \n                //\n                // We want to \n                //\n                // - take the plugin/configuration in the POM and merge it with the plugin's default configuration found in its plugin.xml\n                // - attach that to the MojoExecution for its configuration\n                // - give the MojoExecution an id of default-<goal>.\n                \n                MojoDescriptor mojoDescriptor = getMojoDescriptor( task, session );\n\n                MojoExecution mojoExecution = new MojoExecution( mojoDescriptor, \"default-\" + mojoDescriptor.getGoal() );\n                \n                populateMojoExecutionConfiguration( project, mojoExecution, true );\n\n                lifecyclePlan.add( mojoExecution );\n            }\n            else\n            {\n                // 1.\n                //\n                // Based on the lifecycle phase we are given, let's find the corresponding lifecycle.\n                //\n                Lifecycle lifecycle = phaseToLifecycleMap.get( task );\n\n                // 2. \n                //\n                // If we are dealing with the \"clean\" or \"site\" lifecycle then there are currently no lifecycle mappings but there are default phases\n                // that need to be run instead.\n                //\n                // Now we need to take into account the packaging type of the project. For a project of type WAR, the lifecycle where mojos are mapped\n                // on to the given phases in the lifecycle are going to be a little different then, say, a project of type JAR.\n                //\n\n                // 3.\n                //\n                // Once we have the lifecycle mapping for the given packaging, we need to know whats phases we need to worry about executing.\n                //\n\n                // Create an ordered Map of the phases in the lifecycle to a list of mojos to execute.\n                Map<String, List<MojoExecution>> phaseToMojoMapping = new LinkedHashMap<String, List<MojoExecution>>();\n\n                // 4.\n\n                //TODO: need to separate the lifecycles\n\n                for ( String phase : lifecycle.getPhases() )\n                {\n                    List<MojoExecution> mojos = new ArrayList<MojoExecution>();\n\n                    //TODO: remove hard coding\n                    if ( phase.equals( \"clean\" ) )\n                    {\n                        mojos.add( new MojoExecution( \"org.apache.maven.plugins\", \"maven-clean-plugin\", \"2.3\", \"clean\", \"default-clean\" ) );\n                    }\n\n                    // This is just just laying out the initial structure of the mojos to run in each phase of the\n                    // lifecycle. Everything is now done in the project builder correctly so this could likely\n                    // go away shortly. We no longer need to pull out bits from the default lifecycle. The MavenProject\n                    // comes to us intact as it should.\n\n                    phaseToMojoMapping.put( phase, mojos );\n                }\n\n                // 5. Just build up the list of mojos that will execute for every phase.\n                //\n                // This will be useful for having the complete build plan and then we can filter/optimize later.\n                //\n                for ( Plugin plugin : project.getBuild().getPlugins() )\n                {\n                    for ( PluginExecution execution : plugin.getExecutions() )\n                    {\n                        // if the phase is specified then I don't have to go fetch the plugin yet and pull it down\n                        // to examine the phase it is associated to.                \n                        if ( execution.getPhase() != null )\n                        {\n                            for ( String goal : execution.getGoals() )\n                            {\n                                if ( phaseToMojoMapping.get( execution.getPhase() ) == null )\n                                {\n                                    // This is happening because executions in the POM are getting mixed into the clean lifecycle\n                                    // So for the lifecycle mapping we need a map with the phases as keys so we can easily check\n                                    // if this phase belongs to the given lifecycle. this shows the system is messed up. this\n                                    // shouldn't happen.\n                                    phaseToMojoMapping.put( execution.getPhase(), new ArrayList<MojoExecution>() );\n                                }\n\n                                MojoExecution mojoExecution = new MojoExecution( plugin.getGroupId(), plugin.getArtifactId(), plugin.getVersion(), goal, execution.getId() );\n                                phaseToMojoMapping.get( execution.getPhase() ).add( mojoExecution );\n                            }\n                        }\n                        // if not then i need to grab the mojo descriptor and look at the phase that is specified\n                        else\n                        {\n                            for ( String goal : execution.getGoals() )\n                            {\n                                MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, session.getLocalRepository(), project.getRemoteArtifactRepositories() );\n\n                                if ( mojoDescriptor.getPhase() != null && phaseToMojoMapping.get( mojoDescriptor.getPhase() ) != null )\n                                {\n                                    MojoExecution mojoExecution = new MojoExecution( plugin.getGroupId(), plugin.getArtifactId(), plugin.getVersion(), goal, execution.getId() );\n                                    phaseToMojoMapping.get( mojoDescriptor.getPhase() ).add( mojoExecution );\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // 6. \n                //\n                // We are only interested in the phases that correspond to the lifecycle we are trying to run. If we are running the \"clean\"\n                // lifecycle we are not interested in goals -- like \"generate-sources -- that belong to the default lifecycle.\n                //        \n                for ( String phase : phaseToMojoMapping.keySet() )\n                {\n                    phasesWithMojosToExecute.addAll( phaseToMojoMapping.get( phase ) );\n\n                    if ( phase.equals( task ) )\n                    {\n                        break;\n                    }\n                }\n\n            }\n        }\n              \n        // 7. Now we create the correct configuration for the mojo to execute.\n        //TODO: this needs to go to the model builder.\n        //TODO: just used a hollowed out MojoExecution\n        for ( MojoExecution mojoExecution : phasesWithMojosToExecute )\n        {\n            // These are bits that look like this:\n            //\n            // org.apache.maven.plugins:maven-remote-resources-plugin:1.0:process\n            //                        \n            MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( \n                mojoExecution.getGroupId(), mojoExecution.getArtifactId(), mojoExecution.getVersion(), mojoExecution.getGoal(), session.getLocalRepository(), project.getRemoteArtifactRepositories() );\n\n            mojoExecution.setMojoDescriptor( mojoDescriptor );\n            \n            populateMojoExecutionConfiguration( project, mojoExecution, false );\n\n            lifecyclePlan.add( mojoExecution );\n        }        \n        \n        return lifecyclePlan;\n    }","id":97032,"modified_method":"public MavenExecutionPlan calculateExecutionPlan( MavenSession session, String... tasks )\n        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, CycleDetectedInPluginGraphException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException\n    {        \n        MavenProject project = session.getCurrentProject();\n                \n        List<MojoExecution> phasesWithMojosToExecute = new ArrayList<MojoExecution>();\n        \n        List<MojoExecution> lifecyclePlan = new ArrayList<MojoExecution>();\n                \n        String requiredDependencyResolutionScope = null;\n        \n        for ( String task : tasks )\n        {\n\n            if ( task.indexOf( \":\" ) > 0 )\n            {\n                // If this is a goal like \"mvn modello:java\" and the POM looks like the following:\n                \n                // <project>\n                //   <modelVersion>4.0.0<\/modelVersion>\n                //   <groupId>org.apache.maven.plugins<\/groupId>\n                //   <artifactId>project-plugin-level-configuration-only<\/artifactId>\n                //   <version>1.0.1<\/version>\n                //   <build>\n                //     <plugins>\n                //       <plugin>\n                //         <groupId>org.codehaus.modello<\/groupId>\n                //         <artifactId>modello-maven-plugin<\/artifactId>\n                //         <version>1.0.1<\/version>\n                //         <configuration>\n                //           <version>1.1.0<\/version>\n                //           <models>\n                //             <model>src/main/mdo/remote-resources.mdo<\/model>\n                //           <\/models>\n                //         <\/configuration>\n                //       <\/plugin>\n                //     <\/plugins>\n                //   <\/build>\n                // <\/project>                \n                //\n                // We want to \n                //\n                // - take the plugin/configuration in the POM and merge it with the plugin's default configuration found in its plugin.xml\n                // - attach that to the MojoExecution for its configuration\n                // - give the MojoExecution an id of default-<goal>.\n                \n                MojoDescriptor mojoDescriptor = getMojoDescriptor( task, session );\n\n                MojoExecution mojoExecution = new MojoExecution( mojoDescriptor, \"default-\" + mojoDescriptor.getGoal() );\n                \n                populateMojoExecutionConfiguration( project, mojoExecution, true );\n\n                lifecyclePlan.add( mojoExecution );\n            }\n            else\n            {\n                // 1.\n                //\n                // Based on the lifecycle phase we are given, let's find the corresponding lifecycle.\n                //\n                Lifecycle lifecycle = phaseToLifecycleMap.get( task );\n\n                // 2. \n                //\n                // If we are dealing with the \"clean\" or \"site\" lifecycle then there are currently no lifecycle mappings but there are default phases\n                // that need to be run instead.\n                //\n                // Now we need to take into account the packaging type of the project. For a project of type WAR, the lifecycle where mojos are mapped\n                // on to the given phases in the lifecycle are going to be a little different then, say, a project of type JAR.\n                //\n\n                // 3.\n                //\n                // Once we have the lifecycle mapping for the given packaging, we need to know whats phases we need to worry about executing.\n                //\n\n                // Create an ordered Map of the phases in the lifecycle to a list of mojos to execute.\n                Map<String, List<MojoExecution>> phaseToMojoMapping = new LinkedHashMap<String, List<MojoExecution>>();\n\n                // 4.\n\n                //TODO: need to separate the lifecycles\n\n                for ( String phase : lifecycle.getPhases() )\n                {\n                    List<MojoExecution> mojos = new ArrayList<MojoExecution>();\n\n                    //TODO: remove hard coding\n                    if ( phase.equals( \"clean\" ) )\n                    {\n                        mojos.add( new MojoExecution( \"org.apache.maven.plugins\", \"maven-clean-plugin\", \"2.3\", \"clean\", \"default-clean\" ) );\n                    }\n\n                    // This is just just laying out the initial structure of the mojos to run in each phase of the\n                    // lifecycle. Everything is now done in the project builder correctly so this could likely\n                    // go away shortly. We no longer need to pull out bits from the default lifecycle. The MavenProject\n                    // comes to us intact as it should.\n\n                    phaseToMojoMapping.put( phase, mojos );\n                }\n\n                // 5. Just build up the list of mojos that will execute for every phase.\n                //\n                // This will be useful for having the complete build plan and then we can filter/optimize later.\n                //\n                for ( Plugin plugin : project.getBuild().getPlugins() )\n                {\n                    for ( PluginExecution execution : plugin.getExecutions() )\n                    {\n                        // if the phase is specified then I don't have to go fetch the plugin yet and pull it down\n                        // to examine the phase it is associated to.                \n                        if ( execution.getPhase() != null )\n                        {\n                            for ( String goal : execution.getGoals() )\n                            {\n                                if ( phaseToMojoMapping.get( execution.getPhase() ) == null )\n                                {\n                                    // This is happening because executions in the POM are getting mixed into the clean lifecycle\n                                    // So for the lifecycle mapping we need a map with the phases as keys so we can easily check\n                                    // if this phase belongs to the given lifecycle. this shows the system is messed up. this\n                                    // shouldn't happen.\n                                    phaseToMojoMapping.put( execution.getPhase(), new ArrayList<MojoExecution>() );\n                                }\n\n                                MojoExecution mojoExecution = new MojoExecution( plugin.getGroupId(), plugin.getArtifactId(), plugin.getVersion(), goal, execution.getId() );\n                                phaseToMojoMapping.get( execution.getPhase() ).add( mojoExecution );\n                            }\n                        }\n                        // if not then i need to grab the mojo descriptor and look at the phase that is specified\n                        else\n                        {\n                            for ( String goal : execution.getGoals() )\n                            {\n                                MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, session.getLocalRepository(), project.getRemoteArtifactRepositories() );\n\n                                if ( mojoDescriptor.getPhase() != null && phaseToMojoMapping.get( mojoDescriptor.getPhase() ) != null )\n                                {\n                                    MojoExecution mojoExecution = new MojoExecution( plugin.getGroupId(), plugin.getArtifactId(), plugin.getVersion(), goal, execution.getId() );\n                                    phaseToMojoMapping.get( mojoDescriptor.getPhase() ).add( mojoExecution );\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // 6. \n                //\n                // We are only interested in the phases that correspond to the lifecycle we are trying to run. If we are running the \"clean\"\n                // lifecycle we are not interested in goals -- like \"generate-sources -- that belong to the default lifecycle.\n                //        \n                for ( String phase : phaseToMojoMapping.keySet() )\n                {\n                    phasesWithMojosToExecute.addAll( phaseToMojoMapping.get( phase ) );\n\n                    if ( phase.equals( task ) )\n                    {\n                        break;\n                    }\n                }\n            }\n        }\n              \n        // 7. Now we create the correct configuration for the mojo to execute.\n        //TODO: this needs to go to the model builder.\n        //TODO: just used a hollowed out MojoExecution\n        for ( MojoExecution mojoExecution : phasesWithMojosToExecute )\n        {\n            // These are bits that look like this:\n            //\n            // org.apache.maven.plugins:maven-remote-resources-plugin:1.0:process\n            //                        \n            MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( \n                mojoExecution.getGroupId(), mojoExecution.getArtifactId(), mojoExecution.getVersion(), mojoExecution.getGoal(), session.getLocalRepository(), project.getRemoteArtifactRepositories() );\n\n            requiredDependencyResolutionScope = calculateRequiredDependencyResolutionScope( requiredDependencyResolutionScope, mojoDescriptor.isDependencyResolutionRequired() );          \n            \n            mojoExecution.setMojoDescriptor( mojoDescriptor );\n            \n            populateMojoExecutionConfiguration( project, mojoExecution, false );\n\n            lifecyclePlan.add( mojoExecution );\n        }        \n        \n        return new MavenExecutionPlan( lifecyclePlan, requiredDependencyResolutionScope );        \n    }","commit_id":"5b76c2c49543d22cc1bb303264c4f4728aec4731","url":"https://github.com/apache/maven"},{"original_method":"public void execute( MavenSession session )\n    {\n        // TODO: Use a listener here instead of loggers\n        \n        logger.info(  \"Build Order:\" );\n        \n        logger.info( \"\" );\n        \n        for( MavenProject project : session.getProjects() )\n        {\n            logger.info( project.getName() );\n        }\n        \n        logger.info( \"\" );\n        \n        MavenProject rootProject = session.getTopLevelProject();\n\n        List<String> goals = session.getGoals();\n\n        if ( goals.isEmpty() && rootProject != null )\n        {\n            String goal = rootProject.getDefaultGoal();\n\n            if ( goal != null )\n            {\n                goals = Collections.singletonList( goal );\n            }\n        }\n                \n        for ( MavenProject currentProject : session.getProjects() )\n        {\n            logger.info( \"Building \" + currentProject.getName() );\n\n            try\n            {\n                session.setCurrentProject( currentProject );\n\n                List<MojoExecution> lifecyclePlan;\n\n                try\n                {\n                    lifecyclePlan = calculateBuildPlan( session, goals.toArray( new String[] {} ) );\n                }\n                catch ( Exception e )\n                {\n                    session.getResult().addException( e );\n                    return;\n                }\n\n                //TODO: once we have calculated the build plan then we should accurately be able to download\n                // the project dependencies. Having it happen in the plugin manager is a tangled mess. We can optimize this\n                // later by looking at the build plan. Would be better to just batch download everything required by the reactor.\n\n                // mojoDescriptor.isDependencyResolutionRequired() is actually the scope of the dependency resolution required, not a boolean ... yah.\n                try\n                {\n                    downloadProjectDependencies( session, Artifact.SCOPE_TEST /** mojoDescriptor.isDependencyResolutionRequired()*/ );\n                }\n                catch ( ArtifactNotFoundException e )\n                {\n                    session.getResult().addException( e );\n                    return;\n                }\n                catch ( ArtifactResolutionException e )\n                {\n                    session.getResult().addException( e );\n                    return;\n                }\n\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.debug( \"=== BUILD PLAN ===\" );\n                    logger.debug( \"Project:       \" + currentProject );\n                    for ( MojoExecution mojoExecution : lifecyclePlan )\n                    {\n                        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();\n                        PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();\n                        logger.debug( \"------------------\" );\n                        logger.debug( \"Goal:          \" + pluginDescriptor.getGroupId() + ':' + pluginDescriptor.getArtifactId() + ':' + pluginDescriptor.getVersion() + ':' + mojoDescriptor.getGoal()\n                            + ':' + mojoExecution.getExecutionId() );\n                        logger.debug( \"Configuration: \" + String.valueOf( mojoExecution.getConfiguration() ) );\n                    }\n                    logger.debug( \"==================\" );\n                }\n\n                for ( MojoExecution mojoExecution : lifecyclePlan )\n                {\n                    try\n                    {\n                        logger.info( executionDescription( mojoExecution, currentProject ) );\n                        pluginManager.executeMojo( session, mojoExecution );\n                    }\n                    catch ( Exception e )\n                    {\n                        session.getResult().addException( e );\n                        return;\n                    }\n                }                         \n                \n            }\n            finally\n            {\n                session.setCurrentProject( null );\n            }\n        }        \n    }","id":97033,"modified_method":"public void execute( MavenSession session )\n    {\n        // TODO: Use a listener here instead of loggers\n        \n        logger.info(  \"Build Order:\" );\n        \n        logger.info( \"\" );\n        \n        for( MavenProject project : session.getProjects() )\n        {\n            logger.info( project.getName() );\n        }\n        \n        logger.info( \"\" );\n        \n        MavenProject rootProject = session.getTopLevelProject();\n\n        List<String> goals = session.getGoals();\n\n        if ( goals.isEmpty() && rootProject != null )\n        {\n            String goal = rootProject.getDefaultGoal();\n\n            if ( goal != null )\n            {\n                goals = Collections.singletonList( goal );\n            }\n        }\n                \n        for ( MavenProject currentProject : session.getProjects() )\n        {\n            logger.info( \"Building \" + currentProject.getName() );\n\n            try\n            {\n                session.setCurrentProject( currentProject );\n\n                MavenExecutionPlan executionPlan;\n\n                try\n                {\n                    executionPlan = calculateExecutionPlan( session, goals.toArray( new String[] {} ) );\n                }\n                catch ( Exception e )\n                {\n                    session.getResult().addException( e );\n                    return;\n                }\n\n                //TODO: once we have calculated the build plan then we should accurately be able to download\n                // the project dependencies. Having it happen in the plugin manager is a tangled mess. We can optimize this\n                // later by looking at the build plan. Would be better to just batch download everything required by the reactor.\n\n                // mojoDescriptor.isDependencyResolutionRequired() is actually the scope of the dependency resolution required, not a boolean ... yah.\n                try\n                {\n                    downloadProjectDependencies( session, executionPlan.getRequiredResolutionScope() );\n                }\n                catch ( ArtifactNotFoundException e )\n                {\n                    session.getResult().addException( e );\n                    return;\n                }\n                catch ( ArtifactResolutionException e )\n                {\n                    session.getResult().addException( e );\n                    return;\n                }\n\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.debug( \"=== BUILD PLAN ===\" );\n                    logger.debug( \"Project:       \" + currentProject );\n                    for ( MojoExecution mojoExecution : executionPlan.getExecutions() )\n                    {\n                        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();\n                        PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();\n                        logger.debug( \"------------------\" );\n                        logger.debug( \"Goal:          \" + pluginDescriptor.getGroupId() + ':' + pluginDescriptor.getArtifactId() + ':' + pluginDescriptor.getVersion() + ':' + mojoDescriptor.getGoal()\n                            + ':' + mojoExecution.getExecutionId() );\n                        logger.debug( \"Configuration: \" + String.valueOf( mojoExecution.getConfiguration() ) );\n                    }\n                    logger.debug( \"==================\" );\n                }\n\n                for ( MojoExecution mojoExecution : executionPlan.getExecutions() )\n                {\n                    try\n                    {\n                        logger.info( executionDescription( mojoExecution, currentProject ) );\n                        pluginManager.executeMojo( session, mojoExecution );\n                    }\n                    catch ( Exception e )\n                    {\n                        session.getResult().addException( e );\n                        return;\n                    }\n                }                         \n                \n            }\n            finally\n            {\n                session.setCurrentProject( null );\n            }\n        }        \n    }","commit_id":"5b76c2c49543d22cc1bb303264c4f4728aec4731","url":"https://github.com/apache/maven"},{"original_method":"public List<MojoExecution> calculateBuildPlan( MavenSession session, String... tasks )\n        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, CycleDetectedInPluginGraphException, MojoNotFoundException\n    {\n        return Collections.emptyList();\n    }","id":97034,"modified_method":"public MavenExecutionPlan calculateExecutionPlan( MavenSession session, String... tasks )\n        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, CycleDetectedInPluginGraphException, MojoNotFoundException\n    {\n        return new MavenExecutionPlan( Collections.<MojoExecution>emptyList(), null );\n    }","commit_id":"5b76c2c49543d22cc1bb303264c4f4728aec4731","url":"https://github.com/apache/maven"},{"original_method":"public void testLifecycleQueryingUsingADefaultLifecyclePhase()\n        throws Exception\n    {   \n        File pom = getProject( \"project-with-additional-lifecycle-elements\" );\n        MavenSession session = createMavenSession( pom );\n        assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() );\n        assertEquals( \"1.0\", session.getCurrentProject().getVersion() );\n        List<MojoExecution> lifecyclePlan = lifecycleExecutor.calculateBuildPlan( session, \"package\" );\n        \n        //[01] resources:resources\n        //[02] compiler:compile\n        //[03] plexus-component-metadata:generate-metadata\n        //[04] resources:testResources\n        //[05] compiler:testCompile\n        //[06] plexus-component-metadata:generate-test-metadata\n        //[07] surefire:test\n        //[08] jar:jar\n        //\n        assertEquals( 8, lifecyclePlan.size() );\n                \n        assertEquals( \"resources:resources\", lifecyclePlan.get( 0 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"compiler:compile\", lifecyclePlan.get( 1 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"plexus-component-metadata:generate-metadata\", lifecyclePlan.get( 2 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"resources:testResources\", lifecyclePlan.get( 3 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"compiler:testCompile\", lifecyclePlan.get( 4 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"plexus-component-metadata:generate-test-metadata\", lifecyclePlan.get( 5 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"surefire:test\", lifecyclePlan.get( 6 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"jar:jar\", lifecyclePlan.get( 7 ).getMojoDescriptor().getFullGoalName() );        \n    }","id":97035,"modified_method":"public void testLifecycleQueryingUsingADefaultLifecyclePhase()\n        throws Exception\n    {   \n        File pom = getProject( \"project-with-additional-lifecycle-elements\" );\n        MavenSession session = createMavenSession( pom );\n        assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() );\n        assertEquals( \"1.0\", session.getCurrentProject().getVersion() );\n        List<MojoExecution> executionPlan = lifecycleExecutor.calculateExecutionPlan( session, \"package\" ).getExecutions();\n        \n        //[01] resources:resources\n        //[02] compiler:compile\n        //[03] plexus-component-metadata:generate-metadata\n        //[04] resources:testResources\n        //[05] compiler:testCompile\n        //[06] plexus-component-metadata:generate-test-metadata\n        //[07] surefire:test\n        //[08] jar:jar\n        //\n        assertEquals( 8, executionPlan.size() );\n                \n        assertEquals( \"resources:resources\", executionPlan.get( 0 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"compiler:compile\", executionPlan.get( 1 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"plexus-component-metadata:generate-metadata\", executionPlan.get( 2 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"resources:testResources\", executionPlan.get( 3 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"compiler:testCompile\", executionPlan.get( 4 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"plexus-component-metadata:generate-test-metadata\", executionPlan.get( 5 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"surefire:test\", executionPlan.get( 6 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"jar:jar\", executionPlan.get( 7 ).getMojoDescriptor().getFullGoalName() );        \n    }","commit_id":"5b76c2c49543d22cc1bb303264c4f4728aec4731","url":"https://github.com/apache/maven"},{"original_method":"public void testCalculationOfBuildPlanTasksOfTheCleanLifecycleAndTheInstallLifecycle()\n        throws Exception\n    {\n        File pom = getProject( \"project-with-additional-lifecycle-elements\" );\n        MavenSession session = createMavenSession( pom );\n        assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() );\n        assertEquals( \"1.0\", session.getCurrentProject().getVersion() );\n        List<MojoExecution> lifecyclePlan = lifecycleExecutor.calculateBuildPlan( session, \"clean\", \"install\" );        \n                        \n        //[01] clean:clean\n        //[02] resources:resources\n        //[03] compiler:compile\n        //[04] plexus-component-metadata:generate-metadata\n        //[05] resources:testResources\n        //[06] compiler:testCompile\n        //[07] plexus-component-metadata:generate-test-metadata\n        //[08] surefire:test\n        //[09] jar:jar\n        //[10] install:install\n        //\n        assertEquals( 10, lifecyclePlan.size() );\n                \n        assertEquals( \"clean:clean\", lifecyclePlan.get( 0 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"resources:resources\", lifecyclePlan.get( 1 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"compiler:compile\", lifecyclePlan.get( 2 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"plexus-component-metadata:generate-metadata\", lifecyclePlan.get( 3 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"resources:testResources\", lifecyclePlan.get( 4 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"compiler:testCompile\", lifecyclePlan.get( 5 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"plexus-component-metadata:generate-test-metadata\", lifecyclePlan.get( 6 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"surefire:test\", lifecyclePlan.get( 7 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"jar:jar\", lifecyclePlan.get( 8 ).getMojoDescriptor().getFullGoalName() );                \n        assertEquals( \"install:install\", lifecyclePlan.get( 9 ).getMojoDescriptor().getFullGoalName() );                \n    }","id":97036,"modified_method":"public void testCalculationOfBuildPlanTasksOfTheCleanLifecycleAndTheInstallLifecycle()\n        throws Exception\n    {\n        File pom = getProject( \"project-with-additional-lifecycle-elements\" );\n        MavenSession session = createMavenSession( pom );\n        assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() );\n        assertEquals( \"1.0\", session.getCurrentProject().getVersion() );\n        List<MojoExecution> executionPlan = lifecycleExecutor.calculateExecutionPlan( session, \"clean\", \"install\" ).getExecutions();        \n                        \n        //[01] clean:clean\n        //[02] resources:resources\n        //[03] compiler:compile\n        //[04] plexus-component-metadata:generate-metadata\n        //[05] resources:testResources\n        //[06] compiler:testCompile\n        //[07] plexus-component-metadata:generate-test-metadata\n        //[08] surefire:test\n        //[09] jar:jar\n        //[10] install:install\n        //\n        assertEquals( 10, executionPlan.size() );\n                \n        assertEquals( \"clean:clean\", executionPlan.get( 0 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"resources:resources\", executionPlan.get( 1 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"compiler:compile\", executionPlan.get( 2 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"plexus-component-metadata:generate-metadata\", executionPlan.get( 3 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"resources:testResources\", executionPlan.get( 4 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"compiler:testCompile\", executionPlan.get( 5 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"plexus-component-metadata:generate-test-metadata\", executionPlan.get( 6 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"surefire:test\", executionPlan.get( 7 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"jar:jar\", executionPlan.get( 8 ).getMojoDescriptor().getFullGoalName() );                \n        assertEquals( \"install:install\", executionPlan.get( 9 ).getMojoDescriptor().getFullGoalName() );                \n    }","commit_id":"5b76c2c49543d22cc1bb303264c4f4728aec4731","url":"https://github.com/apache/maven"},{"original_method":"public void testCalculationOfBuildPlanWithMultipleExecutionsOfModello()\n        throws Exception\n    {\n        File pom = getProject( \"project-with-multiple-executions\" );\n        MavenSession session = createMavenSession( pom );\n        assertEquals( \"project-with-multiple-executions\", session.getCurrentProject().getArtifactId() );\n        assertEquals( \"1.0.1\", session.getCurrentProject().getVersion() );\n        List<MojoExecution> lifecyclePlan = lifecycleExecutor.calculateBuildPlan( session, \"clean\", \"install\" );        \n        \n        //[01] clean:clean\n        //[02] modello:xpp3-writer\n        //[03] modello:java\n        //[04] modello:xpp3-reader\n        //[05] modello:xpp3-writer\n        //[06] modello:java\n        //[07] modello:xpp3-reader\n        //[08] plugin:descriptor        \n        //[09] resources:resources\n        //[10] compiler:compile\n        //[11] resources:testResources\n        //[12] compiler:testCompile\n        //[13] surefire:test\n        //[14] plugin:addPluginArtifactMetadata        \n        //[15] jar:jar\n        //[16] install:install\n        //\n        \n        assertEquals( 16, lifecyclePlan.size() );        \n                \n        assertEquals( \"clean:clean\", lifecyclePlan.get( 0 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"modello:xpp3-writer\", lifecyclePlan.get( 1 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"modello:java\", lifecyclePlan.get( 2 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"modello:xpp3-reader\", lifecyclePlan.get( 3 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"modello:xpp3-writer\", lifecyclePlan.get( 4 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"modello:java\", lifecyclePlan.get( 5 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"modello:xpp3-reader\", lifecyclePlan.get( 6 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"plugin:descriptor\", lifecyclePlan.get( 7 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"resources:resources\", lifecyclePlan.get( 8 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"compiler:compile\", lifecyclePlan.get( 9 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"resources:testResources\", lifecyclePlan.get( 10 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"compiler:testCompile\", lifecyclePlan.get( 11 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"surefire:test\", lifecyclePlan.get( 12 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"plugin:addPluginArtifactMetadata\", lifecyclePlan.get( 13 ).getMojoDescriptor().getFullGoalName() );                \n        assertEquals( \"jar:jar\", lifecyclePlan.get( 14 ).getMojoDescriptor().getFullGoalName() );                \n        assertEquals( \"install:install\", lifecyclePlan.get( 15 ).getMojoDescriptor().getFullGoalName() );\n        \n        assertEquals( \"src/main/mdo/remote-resources.mdo\", new MojoExecutionXPathContainer( lifecyclePlan.get( 1 ) ).getValue( \"configuration/models[1]/model\" ) );\n        assertEquals( \"src/main/mdo/supplemental-model.mdo\", new MojoExecutionXPathContainer( lifecyclePlan.get( 4 ) ).getValue( \"configuration/models[1]/model\" ) );\n    }","id":97037,"modified_method":"public void testCalculationOfBuildPlanWithMultipleExecutionsOfModello()\n        throws Exception\n    {\n        File pom = getProject( \"project-with-multiple-executions\" );\n        MavenSession session = createMavenSession( pom );\n        assertEquals( \"project-with-multiple-executions\", session.getCurrentProject().getArtifactId() );\n        assertEquals( \"1.0.1\", session.getCurrentProject().getVersion() );\n        \n        MavenExecutionPlan plan = lifecycleExecutor.calculateExecutionPlan( session, \"clean\", \"install\" );\n        \n        assertEquals( Artifact.SCOPE_TEST, plan.getRequiredResolutionScope() );\n        \n        List<MojoExecution> executions = plan.getExecutions();        \n        \n        //[01] clean:clean\n        //[02] modello:xpp3-writer\n        //[03] modello:java\n        //[04] modello:xpp3-reader\n        //[05] modello:xpp3-writer\n        //[06] modello:java\n        //[07] modello:xpp3-reader\n        //[08] plugin:descriptor        \n        //[09] resources:resources\n        //[10] compiler:compile\n        //[11] resources:testResources\n        //[12] compiler:testCompile\n        //[13] surefire:test\n        //[14] plugin:addPluginArtifactMetadata        \n        //[15] jar:jar\n        //[16] install:install\n        //\n        \n        assertEquals( 16, executions.size() );        \n                \n        assertEquals( \"clean:clean\", executions.get( 0 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"modello:xpp3-writer\", executions.get( 1 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"modello:java\", executions.get( 2 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"modello:xpp3-reader\", executions.get( 3 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"modello:xpp3-writer\", executions.get( 4 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"modello:java\", executions.get( 5 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"modello:xpp3-reader\", executions.get( 6 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"plugin:descriptor\", executions.get( 7 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"resources:resources\", executions.get( 8 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"compiler:compile\", executions.get( 9 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"resources:testResources\", executions.get( 10 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"compiler:testCompile\", executions.get( 11 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"surefire:test\", executions.get( 12 ).getMojoDescriptor().getFullGoalName() );\n        assertEquals( \"plugin:addPluginArtifactMetadata\", executions.get( 13 ).getMojoDescriptor().getFullGoalName() );                \n        assertEquals( \"jar:jar\", executions.get( 14 ).getMojoDescriptor().getFullGoalName() );                \n        assertEquals( \"install:install\", executions.get( 15 ).getMojoDescriptor().getFullGoalName() );\n        \n        assertEquals( \"src/main/mdo/remote-resources.mdo\", new MojoExecutionXPathContainer( executions.get( 1 ) ).getValue( \"configuration/models[1]/model\" ) );\n        assertEquals( \"src/main/mdo/supplemental-model.mdo\", new MojoExecutionXPathContainer( executions.get( 4 ) ).getValue( \"configuration/models[1]/model\" ) );\n    }","commit_id":"5b76c2c49543d22cc1bb303264c4f4728aec4731","url":"https://github.com/apache/maven"},{"original_method":"public void testCalculationOfBuildPlanWithIndividualTaskWherePluginIsSpecifiedInThePom()\n        throws Exception\n    {\n        // We are doing something like \"mvn resources:resources\" where no version is specified but this\n        // project we are working on has the version specified in the POM so the version should come from there.\n        File pom = getProject( \"project-with-additional-lifecycle-elements\" );\n        MavenSession session = createMavenSession( pom );\n        assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() );\n        assertEquals( \"1.0\", session.getCurrentProject().getVersion() );\n        List<MojoExecution> lifecyclePlan = lifecycleExecutor.calculateBuildPlan( session, \"resources:resources\" );\n        assertEquals( 1, lifecyclePlan.size() );\n        MojoExecution mojoExecution = lifecyclePlan.get( 0 );\n        assertNotNull( mojoExecution );\n        assertEquals( \"org.apache.maven.plugins\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );\n        assertEquals( \"maven-resources-plugin\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );\n        assertEquals( \"2.3\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );\n    }","id":97038,"modified_method":"public void testCalculationOfBuildPlanWithIndividualTaskWherePluginIsSpecifiedInThePom()\n        throws Exception\n    {\n        // We are doing something like \"mvn resources:resources\" where no version is specified but this\n        // project we are working on has the version specified in the POM so the version should come from there.\n        File pom = getProject( \"project-with-additional-lifecycle-elements\" );\n        MavenSession session = createMavenSession( pom );\n        assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() );\n        assertEquals( \"1.0\", session.getCurrentProject().getVersion() );\n        List<MojoExecution> executionPlan = lifecycleExecutor.calculateExecutionPlan( session, \"resources:resources\" ).getExecutions();\n        assertEquals( 1, executionPlan.size() );\n        MojoExecution mojoExecution = executionPlan.get( 0 );\n        assertNotNull( mojoExecution );\n        assertEquals( \"org.apache.maven.plugins\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );\n        assertEquals( \"maven-resources-plugin\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );\n        assertEquals( \"2.3\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );\n    }","commit_id":"5b76c2c49543d22cc1bb303264c4f4728aec4731","url":"https://github.com/apache/maven"},{"original_method":"public void testCalculationOfBuildPlanWithIndividualTaskOfTheCleanCleanGoal()\n        throws Exception\n    {\n        // We are doing something like \"mvn clean:clean\" where no version is specified but this\n        // project we are working on has the version specified in the POM so the version should come from there.\n        File pom = getProject( \"project-with-additional-lifecycle-elements\" );\n        MavenSession session = createMavenSession( pom );\n        assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() );\n        assertEquals( \"1.0\", session.getCurrentProject().getVersion() );\n        List<MojoExecution> lifecyclePlan = lifecycleExecutor.calculateBuildPlan( session, \"clean:clean\" );\n        assertEquals( 1, lifecyclePlan.size() );\n        MojoExecution mojoExecution = lifecyclePlan.get( 0 );\n        assertNotNull( mojoExecution );\n        assertEquals( \"org.apache.maven.plugins\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );\n        assertEquals( \"maven-clean-plugin\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );\n        assertEquals( \"2.2\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );\n    }","id":97039,"modified_method":"public void testCalculationOfBuildPlanWithIndividualTaskOfTheCleanCleanGoal()\n        throws Exception\n    {\n        // We are doing something like \"mvn clean:clean\" where no version is specified but this\n        // project we are working on has the version specified in the POM so the version should come from there.\n        File pom = getProject( \"project-with-additional-lifecycle-elements\" );\n        MavenSession session = createMavenSession( pom );\n        assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() );\n        assertEquals( \"1.0\", session.getCurrentProject().getVersion() );\n        List<MojoExecution> executionPlan = lifecycleExecutor.calculateExecutionPlan( session, \"clean:clean\" ).getExecutions();\n        assertEquals( 1, executionPlan.size() );\n        MojoExecution mojoExecution = executionPlan.get( 0 );\n        assertNotNull( mojoExecution );\n        assertEquals( \"org.apache.maven.plugins\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );\n        assertEquals( \"maven-clean-plugin\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );\n        assertEquals( \"2.2\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );\n    }","commit_id":"5b76c2c49543d22cc1bb303264c4f4728aec4731","url":"https://github.com/apache/maven"},{"original_method":"public void testCalculationOfBuildPlanWithIndividualTaskOfTheCleanLifecycle()\n        throws Exception\n    {\n        // We are doing something like \"mvn clean:clean\" where no version is specified but this\n        // project we are working on has the version specified in the POM so the version should come from there.\n        File pom = getProject( \"project-with-additional-lifecycle-elements\" );\n        MavenSession session = createMavenSession( pom );\n        assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() );\n        assertEquals( \"1.0\", session.getCurrentProject().getVersion() );\n        List<MojoExecution> lifecyclePlan = lifecycleExecutor.calculateBuildPlan( session, \"clean\" );\n        assertEquals( 1, lifecyclePlan.size() );\n        MojoExecution mojoExecution = lifecyclePlan.get( 0 );\n        assertNotNull( mojoExecution );\n        assertEquals( \"org.apache.maven.plugins\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );\n        assertEquals( \"maven-clean-plugin\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );\n        assertEquals( \"2.3\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );\n    }","id":97040,"modified_method":"public void testCalculationOfBuildPlanWithIndividualTaskOfTheCleanLifecycle()\n        throws Exception\n    {\n        // We are doing something like \"mvn clean:clean\" where no version is specified but this\n        // project we are working on has the version specified in the POM so the version should come from there.\n        File pom = getProject( \"project-with-additional-lifecycle-elements\" );\n        MavenSession session = createMavenSession( pom );\n        assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() );\n        assertEquals( \"1.0\", session.getCurrentProject().getVersion() );\n        List<MojoExecution> executionPlan = lifecycleExecutor.calculateExecutionPlan( session, \"clean\" ).getExecutions();\n        assertEquals( 1, executionPlan.size() );\n        MojoExecution mojoExecution = executionPlan.get( 0 );\n        assertNotNull( mojoExecution );\n        assertEquals( \"org.apache.maven.plugins\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );\n        assertEquals( \"maven-clean-plugin\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );\n        assertEquals( \"2.3\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );\n    }","commit_id":"5b76c2c49543d22cc1bb303264c4f4728aec4731","url":"https://github.com/apache/maven"},{"original_method":"/** Output channel content to the portal\n   * @param out a sax document handler\n   */\n  public void renderXML (DocumentHandler out)\n  {\n    try\n    {\n      StringWriter w = new StringWriter ();\n      w.write (\"<?xml version='1.0'?>\\n\");\n      w.write (\"<applet code=\\\"\" + staticData.getParameter (\"code\") + \"\\\"\\n\");\n      w.write (\"        codebase=\\\"\" + staticData.getParameter (\"codeBase\") + \"\\\"\\n\");\n      w.write (\"        width=\\\"\" + staticData.getParameter (\"width\") + \"\\\"\\n\");\n      w.write (\"        height=\\\"\" + staticData.getParameter (\"height\")  + \"\\\"\\n\");\n      w.write (\"        align=\\\"top\\\"\\n\");\n      w.write (\"        border=\\\"0\\\"\\n\");\n      w.write (\"        archive=\\\"\" + staticData.getParameter (\"archive\") + \"\\\">\\n\");\n\n      // Take all parameters whose names start with \"APPLET.\" and pass them\n      // to the applet (after stripping \"APPLET.\")\n      java.util.Enumeration allKeys = staticData.keys ();\n\n      while (allKeys.hasMoreElements ())\n      {\n        String p = (String) allKeys.nextElement();\n\n        if (p.startsWith (\"APPLET.\"))\n        {\n          String name = p.substring (7); // skip \"APPLET.\"\n          String value = (String) staticData.getParameter (p);\n          w.write (\"  <param name=\\\"\" + name + \"\\\" value=\\\"\" + value + \"\\\"/>\\n\");\n        }\n      }\n\n      w.write (\"<\/applet>\\n\");\n\n      XSLT.transform(w.toString(), new URL(sslLocation), out, \"main\", runtimeData.getBrowserInfo());\n    }\n    catch (Exception e)\n    {\n      LogService.instance().log(LogService.ERROR, e);\n    }\n  }","id":97041,"modified_method":"/** Output channel content to the portal\n   * @param out a sax document handler\n   */\n  public void renderXML (DocumentHandler out)\n  {\n    try\n    {\n      StringWriter w = new StringWriter ();\n      w.write (\"<?xml version='1.0'?>\\n\");\n      w.write (\"<applet code=\\\"\" + staticData.getParameter (\"code\") + \"\\\"\\n\");\n      w.write (\"        codebase=\\\"\" + staticData.getParameter (\"codeBase\") + \"\\\"\\n\");\n      w.write (\"        width=\\\"\" + staticData.getParameter (\"width\") + \"\\\"\\n\");\n      w.write (\"        height=\\\"\" + staticData.getParameter (\"height\")  + \"\\\"\\n\");\n      w.write (\"        align=\\\"top\\\"\\n\");\n      w.write (\"        border=\\\"0\\\"\\n\");\n      w.write (\"        archive=\\\"\" + staticData.getParameter (\"archive\") + \"\\\">\\n\");\n\n      // Take all parameters whose names start with \"APPLET.\" and pass them\n      // to the applet (after stripping \"APPLET.\")\n      java.util.Enumeration allKeys = staticData.keys ();\n\n      while (allKeys.hasMoreElements ())\n      {\n        String p = (String) allKeys.nextElement();\n\n        if (p.startsWith (\"APPLET.\"))\n        {\n          String name = p.substring (7); // skip \"APPLET.\"\n          String value = (String) staticData.getParameter (p);\n          w.write (\"  <param name=\\\"\" + name + \"\\\" value=\\\"\" + value + \"\\\"/>\\n\");\n        }\n      }\n\n      w.write (\"<\/applet>\\n\");\n\n      XSLT xslt = new XSLT();\n      xslt.setXML(w.toString());\n      xslt.setSSL(sslLocation, \"main\", runtimeData.getBrowserInfo());\n      xslt.setTarget(out);\n      xslt.transform();\n    }\n    catch (Exception e)\n    {\n      LogService.instance().log(LogService.ERROR, e);\n    }\n  }","commit_id":"91e081e8e6db7da14bbceb5b01bb0429993fa539","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void renderXML(DocumentHandler out,String uid) throws PortalException  \n  {\n    CState state=(CState)stateTable.get(uid);\n\t  \n    if (state == null) \n      LogService.instance().log(LogService.ERROR,\"CGenericXSLT:renderXML() : attempting to access a non-established channel! setStaticData() has never been called on the uid=\\\"\"+uid+\"\\\"\");\n    else \n    {\n      String xml;\n      Document xmlDoc;\n\n      try \n      {\n        org.apache.xerces.parsers.DOMParser domParser = new org.apache.xerces.parsers.DOMParser();\n        org.jasig.portal.utils.DTDResolver dtdResolver = new org.jasig.portal.utils.DTDResolver();\n        domParser.setEntityResolver(dtdResolver);\n        domParser.parse(UtilitiesBean.fixURI(state.xmlUri));\n        xmlDoc = domParser.getDocument();\n      }\n      catch (IOException e) \n      {\n        throw new ResourceMissingException (state.xmlUri, \"\", e.getMessage());\n      }\n      catch (SAXException se) \n      {\n        throw new GeneralRenderingException(\"Problem parsing \" + state.xmlUri + \": \" + se);\n      }\n\n      state.runtimeData.put(\"baseActionURL\", state.runtimeData.getBaseActionURL());\n\t    \n      try \n      {\n        if (state.xslUri != null)\n          XSLT.transform(xmlDoc, new URL(state.xslUri), out, state.runtimeData);\n        else \n        {\n          if (state.xslTitle != null)\n            XSLT.transform(xmlDoc, new URL(state.sslUri), out, state.runtimeData, state.xslTitle, state.runtimeData.getBrowserInfo());\n          else\n            XSLT.transform(xmlDoc, new URL(state.sslUri), out, state.runtimeData, state.runtimeData.getBrowserInfo());\n        }\n      }\n      catch (SAXException se) \n      {\n        throw new GeneralRenderingException(\"Problem performing the transformation:\" + se.toString());\n      }\n      catch (IOException ioe) \n      {\n        StringWriter sw = new StringWriter();\n        ioe.printStackTrace(new PrintWriter(sw));\n        sw.flush();\n        throw new GeneralRenderingException(sw.toString());\n      }\n    }\n  }","id":97042,"modified_method":"public void renderXML(DocumentHandler out,String uid) throws PortalException  \n  {\n    CState state=(CState)stateTable.get(uid);\n\t  \n    if (state == null) \n      LogService.instance().log(LogService.ERROR,\"CGenericXSLT:renderXML() : attempting to access a non-established channel! setStaticData() has never been called on the uid=\\\"\"+uid+\"\\\"\");\n    else \n    {\n      String xml;\n      Document xmlDoc;\n\n      try \n      {\n        org.apache.xerces.parsers.DOMParser domParser = new org.apache.xerces.parsers.DOMParser();\n        org.jasig.portal.utils.DTDResolver dtdResolver = new org.jasig.portal.utils.DTDResolver();\n        domParser.setEntityResolver(dtdResolver);\n        domParser.parse(UtilitiesBean.fixURI(state.xmlUri));\n        xmlDoc = domParser.getDocument();\n      }\n      catch (IOException e) \n      {\n        throw new ResourceMissingException (state.xmlUri, \"\", e.getMessage());\n      }\n      catch (SAXException se) \n      {\n        throw new GeneralRenderingException(\"Problem parsing \" + state.xmlUri + \": \" + se);\n      }\n\n      state.runtimeData.put(\"baseActionURL\", state.runtimeData.getBaseActionURL());\n\t    \n      XSLT xslt = new XSLT();\n      xslt.setXML(xmlDoc);\n      if (state.xslUri != null)\n        xslt.setXSL(state.xslUri);\n      else \n        xslt.setSSL(state.sslUri, state.xslTitle, state.runtimeData.getBrowserInfo());\n      xslt.setTarget(out);\n      xslt.setStylesheetParameters(state.runtimeData);\n      xslt.transform();\n    }\n  }","commit_id":"43eca7eed76c469414f837649afff247bdb3e8ad","url":"https://github.com/Jasig/uPortal"},{"original_method":"/** Output channel content to the portal\n   * @param out a sax document handler\n   */\n  public void renderXML (DocumentHandler out)\n  {\n    String sSuggest = null;\n\n    if (iGuess < iAnswer)\n      sSuggest = \"higher\";\n    else if (iGuess > iAnswer)\n      sSuggest = \"lower\";\n\n    try\t{\n        StringWriter w = new StringWriter ();\n        w.write (\"<?xml version='1.0'?>\\n\");\n        w.write (\"<content>\\n\");\n        w.write (\"  <minNum>\" + iMinNum + \"<\/minNum>\\n\");\n        w.write (\"  <maxNum>\" + iMaxNum + \"<\/maxNum>\\n\");\n        w.write (\"  <guesses>\" + iGuesses + \"<\/guesses>\\n\");\n        w.write (\"  <guess>\" + iGuess + \"<\/guess>\\n\");\n\n        if (bFirstTime)\n          ; // Do nothing\n        else if (iGuess == iAnswer)\n        {\n          w.write (\"  <answer>\" + iAnswer + \"<\/answer>\\n\");\n          bFirstTime = true;\n          iGuesses = 0;\n          iAnswer = getRandomNumber (iMinNum, iMaxNum);\n        }\n        else\n          w.write (\"  <suggest>\" + sSuggest + \"<\/suggest>\\n\");\n\n        w.write (\"<\/content>\\n\");\n\n        Hashtable ssParams = new Hashtable();\n        ssParams.put(\"baseActionURL\", runtimeData.getBaseActionURL());\n        XSLT.transform(w.toString(), new URL(sslLocation), out, ssParams, \"main\", runtimeData.getBrowserInfo());\n    }\n    catch (Exception e)\n    {\n      LogService.instance().log(LogService.ERROR, e);\n    }\n  }","id":97043,"modified_method":"/** Output channel content to the portal\n   * @param out a sax document handler\n   */\n  public void renderXML (DocumentHandler out) throws PortalException\n  {\n    String sSuggest = null;\n\n    if (iGuess < iAnswer)\n      sSuggest = \"higher\";\n    else if (iGuess > iAnswer)\n      sSuggest = \"lower\";\n\n    StringWriter w = new StringWriter ();\n    w.write (\"<?xml version='1.0'?>\\n\");\n    w.write (\"<content>\\n\");\n    w.write (\"  <minNum>\" + iMinNum + \"<\/minNum>\\n\");\n    w.write (\"  <maxNum>\" + iMaxNum + \"<\/maxNum>\\n\");\n    w.write (\"  <guesses>\" + iGuesses + \"<\/guesses>\\n\");\n    w.write (\"  <guess>\" + iGuess + \"<\/guess>\\n\");\n\n    if (bFirstTime)\n      ; // Do nothing\n    else if (iGuess == iAnswer)\n    {\n      w.write (\"  <answer>\" + iAnswer + \"<\/answer>\\n\");\n      bFirstTime = true;\n      iGuesses = 0;\n      iAnswer = getRandomNumber (iMinNum, iMaxNum);\n    }\n    else\n      w.write (\"  <suggest>\" + sSuggest + \"<\/suggest>\\n\");\n\n    w.write (\"<\/content>\\n\");\n\n    XSLT xslt = new XSLT();\n    xslt.setXML(w.toString());\n    xslt.setSSL(sslLocation, \"main\", runtimeData.getBrowserInfo());\n    xslt.setTarget(out);\n    xslt.setStylesheetParameter(\"baseActionURL\", runtimeData.getBaseActionURL());\n    xslt.transform();\n  }","commit_id":"43eca7eed76c469414f837649afff247bdb3e8ad","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * @param servletContext\n     * @param t\n     */\n    public GrailsWrappedRuntimeException(ServletContext servletContext, Throwable t) {\n        super(t.getMessage(), t);\n        this.t = t;\n\n        StringWriter sw  = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        this.t.printStackTrace(pw);\n        this.stackTrace = sw.toString();\n        Pattern extractDetails = Pattern.compile(\"\\\\((\\\\w+)\\\\.groovy:(\\\\d+)\\\\)\");\n        Matcher matcher = extractDetails.matcher(stackTrace);\n        if(matcher.find()) {\n            this.className = matcher.group(1);\n            LineNumberReader reader = null;\n            try {\n                this.lineNumber = Integer.parseInt(matcher.group(2));\n                if(getLineNumber() > -1) {\n                    String fileName = this.className.replace('.', '/') + \".groovy\";\n                    String urlPrefix = URL_PREFIX;\n                    if(GrailsClassUtils.isControllerClass(className) || GrailsClassUtils.isPageFlowClass(className)) {\n                        urlPrefix += \"/controllers/\";\n                    }\n                    else if(GrailsClassUtils.isTagLibClass(className)) {\n                        urlPrefix += \"/taglib/\";\n                    }\n                    else if(GrailsClassUtils.isService(className)) {\n                       urlPrefix += \"/services/\";\n                    }\n                    InputStream in = servletContext.getResourceAsStream(urlPrefix + fileName);\n                    if(in != null) {\n                        reader = new LineNumberReader(new InputStreamReader( in ));\n                        String currentLine = reader.readLine();\n                        StringBuffer buf = new StringBuffer();\n                        while(currentLine != null) {\n\n                            int currentLineNumber = reader.getLineNumber();\n                            if(currentLineNumber == this.lineNumber) {\n                                buf.append(currentLineNumber)\n                                   .append(\": \")\n                                   .append(currentLine)\n                                   .append(\"\\n\");\n                            }\n                            else if(currentLineNumber == this.lineNumber + 1) {\n                                buf.append(currentLineNumber)\n                                   .append(\": \")\n                                   .append(currentLine);\n                                break;\n                            }\n                            currentLine = reader.readLine();\n                        }\n                        this.codeSnippet = buf.toString().split(\"\\n\");\n                    }\n                }\n            }\n            catch(NumberFormatException nfex) {\n                // ignore\n            }\n            catch (IOException e) {\n                LOG.warn(\"[GrailsWrappedRuntimeException] I/O error reading line diagnostics: \" + e.getMessage(), e);\n            }\n            finally {\n                if(reader != null)\n                    try {\n                        reader.close();\n                    } catch (IOException e) {\n                        // ignore\n                    }\n            }\n\n        }\n    }","id":97044,"modified_method":"/**\n     * @param servletContext\n     * @param t\n     */\n    public GrailsWrappedRuntimeException(ServletContext servletContext, Throwable t) {\n        super(t.getMessage(), t);\n        this.t = t;\n\n        StringWriter sw  = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        this.t.printStackTrace(pw);\n        this.stackTrace = sw.toString();\n\n        Matcher m1 = PARSE_DETAILS_STEP1.matcher(stackTrace);\n        Matcher m2 = PARSE_DETAILS_STEP2.matcher(stackTrace);\n        try {\n            if(m1.find()) {\n                this.className = m1.group(1);\n                this.lineNumber = Integer.parseInt(m1.group(2));\n            }\n            else if(m2.find()) {\n                this.className = m2.group(1);\n                this.lineNumber = Integer.parseInt(m2.group(2));\n            }\n        }\n        catch(NumberFormatException nfex) {\n            // ignore\n        }\n\n        LineNumberReader reader = null;\n        try {\n            if(getLineNumber() > -1) {\n                String fileName = this.className.replace('.', '/') + \".groovy\";\n                String urlPrefix = URL_PREFIX;\n                if(GrailsClassUtils.isControllerClass(className) || GrailsClassUtils.isPageFlowClass(className)) {\n                    urlPrefix += \"/controllers/\";\n                }\n                else if(GrailsClassUtils.isTagLibClass(className)) {\n                    urlPrefix += \"/taglib/\";\n                }\n                else if(GrailsClassUtils.isService(className)) {\n                   urlPrefix += \"/services/\";\n                }\n                InputStream in = servletContext.getResourceAsStream(urlPrefix + fileName);\n                if(in != null) {\n                    reader = new LineNumberReader(new InputStreamReader( in ));\n                    String currentLine = reader.readLine();\n                    StringBuffer buf = new StringBuffer();\n                    while(currentLine != null) {\n\n                        int currentLineNumber = reader.getLineNumber();\n                        if(currentLineNumber == this.lineNumber) {\n                            buf.append(currentLineNumber)\n                               .append(\": \")\n                               .append(currentLine)\n                               .append(\"\\n\");\n                        }\n                        else if(currentLineNumber == this.lineNumber + 1) {\n                            buf.append(currentLineNumber)\n                               .append(\": \")\n                               .append(currentLine);\n                            break;\n                        }\n                        currentLine = reader.readLine();\n                    }\n                    this.codeSnippet = buf.toString().split(\"\\n\");\n                }\n            }\n        }\n        catch (IOException e) {\n            LOG.warn(\"[GrailsWrappedRuntimeException] I/O error reading line diagnostics: \" + e.getMessage(), e);\n        }\n        finally {\n            if(reader != null)\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n        }\n    }","commit_id":"8d2868304a167bf09fa52e9fe99aa2849e444000","url":"https://github.com/grails/grails-core"},{"original_method":"/** {@inheritDoc} */\n    public synchronized void onContainersAllocated(List<Container> conts) {\n        for (Container container : conts) {\n            try {\n                ContainerLaunchContext ctx = Records.newRecord(ContainerLaunchContext.class);\n\n                Map<String, String> env = new HashMap<>(System.getenv());\n\n                env.put(\"IGNITE_TCP_DISCOVERY_ADDRESSES\", getAddress(container.getNodeId().getHost()));\n\n                ctx.setEnvironment(env);\n\n                Map<String, LocalResource> resources = new HashMap<>();\n\n                resources.put(\"ignite\", IgniteYarnUtils.setupFile(ignitePath, fs, LocalResourceType.ARCHIVE));\n                resources.put(\"ignite-config.xml\", IgniteYarnUtils.setupFile(cfgPath, fs, LocalResourceType.FILE));\n\n                ctx.setLocalResources(resources);\n\n                ctx.setCommands(\n                    Collections.singletonList(\n                        \"./ignite/*/bin/ignite.sh \"\n                        + \"./ignite-config.xml\"\n                        + \" -J-Xmx\" + container.getResource().getMemory() + \"m\"\n                        + \" -J-Xms\" + container.getResource().getMemory() + \"m\"\n                        + IgniteYarnUtils.YARN_LOG_OUT\n                    ));\n\n                System.out.println(\"[AM] Launching container \" + container.getId());\n\n                nmClient.startContainer(container, ctx);\n\n                containers.put(container.getNodeId().getHost(),\n                    new IgniteContainer(container.getNodeId().getHost(), container.getResource().getVirtualCores(),\n                        container.getResource().getMemory()));\n            }\n            catch (Exception ex) {\n                System.err.println(\"[AM] Error launching container \" + container.getId() + \" \" + ex);\n            }\n        }\n    }","id":97045,"modified_method":"/** {@inheritDoc} */\n    public synchronized void onContainersAllocated(List<Container> conts) {\n        for (Container c : conts) {\n            if (checkContainer(c)) {\n                try {\n                    ContainerLaunchContext ctx = Records.newRecord(ContainerLaunchContext.class);\n\n                    Map<String, String> env = new HashMap<>(System.getenv());\n\n                    //env.put(\"IGNITE_TCP_DISCOVERY_ADDRESSES\", getAddress(c.getNodeId().getHost()));\n\n                    ctx.setEnvironment(env);\n\n                    Map<String, LocalResource> resources = new HashMap<>();\n\n                    resources.put(\"ignite\", IgniteYarnUtils.setupFile(ignitePath, fs, LocalResourceType.ARCHIVE));\n                    resources.put(\"ignite-config.xml\", IgniteYarnUtils.setupFile(cfgPath, fs, LocalResourceType.FILE));\n\n                    ctx.setLocalResources(resources);\n\n                    ctx.setCommands(\n                        Collections.singletonList(\n                            \"./ignite/*/bin/ignite.sh \"\n                            + \"./ignite-config.xml\"\n                            + \" -J-Xmx\" + c.getResource().getMemory() + \"m\"\n                            + \" -J-Xms\" + c.getResource().getMemory() + \"m\"\n                            + IgniteYarnUtils.YARN_LOG_OUT\n                        ));\n\n                    log.log(Level.INFO, \"Launching container: {0}.\", c.getId());\n\n                    nmClient.startContainer(c, ctx);\n\n                    containers.put(c.getId(),\n                        new IgniteContainer(\n                            c.getId(),\n                            c.getNodeId(),\n                            c.getResource().getVirtualCores(),\n                            c.getResource().getMemory()));\n                }\n                catch (Exception ex) {\n                    System.err.println(\"[AM] Error launching container \" + c.getId() + \" \" + ex);\n                }\n            }\n            else\n                rmClient.releaseAssignedContainer(c.getId());\n        }\n    }","commit_id":"858d2a3f757fea2b88ffcb907e0f221699e32420","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    public void onNodesUpdated(List<NodeReport> updated) {\n    }","id":97046,"modified_method":"/** {@inheritDoc} */\n    public synchronized void onNodesUpdated(List<NodeReport> updated) {\n        for (NodeReport node : updated) {\n            // If node unusable.\n            if (node.getNodeState().isUnusable()) {\n                for (IgniteContainer cont : containers.values()) {\n                    if (cont.nodeId().equals(node.getNodeId())) {\n                        containers.remove(cont.id());\n\n                        log.log(Level.WARNING, \"Node is unusable. Node: {0}, state: {1}.\",\n                            new Object[]{node.getNodeId().getHost(), node.getNodeState()});\n                    }\n                }\n\n                log.log(Level.WARNING, \"Node is unusable. Node: {0}, state: {1}.\",\n                    new Object[]{node.getNodeId().getHost(), node.getNodeState()});\n            }\n        }\n    }","commit_id":"858d2a3f757fea2b88ffcb907e0f221699e32420","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    public synchronized void onContainersCompleted(List<ContainerStatus> statuses) {\n        for (ContainerStatus status : statuses) {\n            synchronized (this) {\n            }\n        }\n    }","id":97047,"modified_method":"/** {@inheritDoc} */\n    public synchronized void onContainersCompleted(List<ContainerStatus> statuses) {\n        for (ContainerStatus status : statuses) {\n            containers.remove(status.getContainerId());\n\n            //log.log(Level.FINE, \"Offer not sufficient for slave request: {0}\", offer.getResourcesList());\n        }\n    }","commit_id":"858d2a3f757fea2b88ffcb907e0f221699e32420","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param args Args.\n     * @throws Exception If failed.\n     */\n    public static void main(String[] args) throws Exception {\n        ClusterProperties props = ClusterProperties.from(null);\n\n        ApplicationMaster master = new ApplicationMaster(args[0], props);\n\n        master.init();\n\n        master.run();\n    }","id":97048,"modified_method":"/**\n     * @param args Args.\n     * @throws Exception If failed.\n     */\n    public static void main(String[] args) throws Exception {\n        ClusterProperties props = ClusterProperties.from();\n\n        ApplicationMaster master = new ApplicationMaster(args[0], props);\n\n        master.init();\n\n        master.run();\n    }","commit_id":"858d2a3f757fea2b88ffcb907e0f221699e32420","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws IOException\n     */\n    public void init() throws IOException {\n        if (props.igniteConfigUrl() == null || props.igniteConfigUrl().isEmpty()) {\n            InputStream input = Thread.currentThread().getContextClassLoader()\n                .getResourceAsStream(IgniteYarnUtils.DEFAULT_IGNITE_CONFIG);\n\n            cfgPath = new Path(props.igniteWorkDir() + File.separator + IgniteYarnUtils.DEFAULT_IGNITE_CONFIG);\n\n            // Create file. Override by default.\n            FSDataOutputStream outputStream = fs.create(cfgPath, true);\n\n            IOUtils.copy(input, outputStream);\n\n            IOUtils.closeQuietly(input);\n\n            IOUtils.closeQuietly(outputStream);\n        }\n        else\n            cfgPath = new Path(props.igniteConfigUrl());\n    }","id":97049,"modified_method":"/**\n     * @throws IOException\n     */\n    public void init() throws IOException {\n        // Create async application master.\n        rmClient = AMRMClientAsync.createAMRMClientAsync(300, this);\n\n        if (props.igniteConfigUrl() == null || props.igniteConfigUrl().isEmpty()) {\n            InputStream input = Thread.currentThread().getContextClassLoader()\n                .getResourceAsStream(IgniteYarnUtils.DEFAULT_IGNITE_CONFIG);\n\n            cfgPath = new Path(props.igniteWorkDir() + File.separator + IgniteYarnUtils.DEFAULT_IGNITE_CONFIG);\n\n            // Create file. Override by default.\n            FSDataOutputStream outputStream = fs.create(cfgPath, true);\n\n            IOUtils.copy(input, outputStream);\n\n            IOUtils.closeQuietly(input);\n\n            IOUtils.closeQuietly(outputStream);\n        }\n        else\n            cfgPath = new Path(props.igniteConfigUrl());\n    }","commit_id":"858d2a3f757fea2b88ffcb907e0f221699e32420","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Runs application master.\n     *\n     * @throws Exception If failed.\n     */\n    public void run() throws Exception {\n        // Create asyn application master.\n        AMRMClientAsync<AMRMClient.ContainerRequest> rmClient = AMRMClientAsync.createAMRMClientAsync(300, this);\n\n        rmClient.init(conf);\n        rmClient.start();\n\n        // Register with ResourceManager\n        rmClient.registerApplicationMaster(\"\", 0, \"\");\n\n        System.out.println(\"[AM] registerApplicationMaster 1\");\n\n        // Priority for worker containers - priorities are intra-application\n        Priority priority = Records.newRecord(Priority.class);\n        priority.setPriority(0);\n\n        // Check ignite cluster.\n        while (!nmClient.isInState(Service.STATE.STOPPED)) {\n            Resource availableRes = rmClient.getAvailableResources();\n\n            if (containers.size() < props.instances() || availableRes.getMemory() >= props.cpusPerNode()\n                || availableRes.getVirtualCores() >= props.cpus()) {\n                // Resource requirements for worker containers\n                Resource capability = Records.newRecord(Resource.class);\n                capability.setMemory(1024);\n                capability.setVirtualCores(2);\n\n                for (int i = 0; i < 1; ++i) {\n                    // Make container requests to ResourceManager\n                    AMRMClient.ContainerRequest containerAsk =\n                            new AMRMClient.ContainerRequest(capability, null, null, priority);\n\n                    System.out.println(\"[AM] Making res-req \" + i);\n\n                    rmClient.addContainerRequest(containerAsk);\n                }\n            }\n\n            TimeUnit.SECONDS.sleep(5);\n        }\n\n        System.out.println(\"[AM] waiting for containers to finish\");\n\n        System.out.println(\"[AM] unregisterApplicationMaster 0\");\n\n        // Un-register with ResourceManager\n        rmClient.unregisterApplicationMaster(FinalApplicationStatus.KILLED, \"\", \"\");\n\n        System.out.println(\"[AM] unregisterApplicationMaster 1\");\n    }","id":97050,"modified_method":"/**\n     * Runs application master.\n     *\n     * @throws Exception If failed.\n     */\n    public void run() throws Exception {\n        rmClient.init(conf);\n        rmClient.start();\n\n        // Register with ResourceManager\n        rmClient.registerApplicationMaster(\"\", 0, \"\");\n\n        log.log(Level.INFO, \"Application master registered.\");\n\n        // Priority for worker containers - priorities are intra-application\n        Priority priority = Records.newRecord(Priority.class);\n        priority.setPriority(0);\n\n        try {\n            // Check ignite cluster.\n            while (!nmClient.isInState(Service.STATE.STOPPED)) {\n                int runningCnt = containers.size();\n\n                if (runningCnt < props.instances() && checkAvailableResource(rmClient.getAvailableResources())) {\n                    // Resource requirements for worker containers.\n                    Resource capability = Records.newRecord(Resource.class);\n\n                    capability.setMemory((int)props.memoryPerNode());\n                    capability.setVirtualCores((int)props.cpusPerNode());\n\n                    for (int i = 0; i < props.instances() - runningCnt; ++i) {\n                        // Make container requests to ResourceManager\n                        AMRMClient.ContainerRequest containerAsk =\n                            new AMRMClient.ContainerRequest(capability, null, null, priority);\n\n                        rmClient.addContainerRequest(containerAsk);\n\n                        log.log(Level.INFO, \"Making request. Memory: {0}, cpu {1}.\",\n                            new Object[]{props.memoryPerNode(), props.cpusPerNode()});\n                    }\n                }\n\n                TimeUnit.SECONDS.sleep(5);\n            }\n        }\n        catch (Exception e) {\n            // Un-register with ResourceManager\n            rmClient.unregisterApplicationMaster(FinalApplicationStatus.FAILED, \"\", \"\");\n\n            System.exit(1);\n        }\n\n        // Un-register with ResourceManager\n        rmClient.unregisterApplicationMaster(FinalApplicationStatus.KILLED, \"\", \"\");\n    }","commit_id":"858d2a3f757fea2b88ffcb907e0f221699e32420","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return Address running nodes.\n     */\n    private String getAddress(String address) {\n        if (containers.isEmpty()) {\n            if (address != null && !address.isEmpty())\n                return address + DEFAULT_PORT;\n\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        for (IgniteContainer cont : containers.values())\n            sb.append(cont.host()).append(DEFAULT_PORT).append(DELIM);\n\n        return sb.substring(0, sb.length() - 1);\n    }","id":97051,"modified_method":"/**\n     * @return Address running nodes.\n     */\n    private String getAddress(String address) {\n        if (containers.isEmpty()) {\n            if (address != null && !address.isEmpty())\n                return address + DEFAULT_PORT;\n\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        for (IgniteContainer cont : containers.values())\n            sb.append(cont.nodeId.getHost()).append(DEFAULT_PORT).append(DELIM);\n\n        return sb.substring(0, sb.length() - 1);\n    }","commit_id":"858d2a3f757fea2b88ffcb907e0f221699e32420","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Convert to properties to map.\n     *\n     * @return Key-value map.\n     */\n    public Map<String, String> toEnvs() {\n        Map<String, String> envs = new HashMap<>();\n\n        envs.put(IGNITE_CLUSTER_NAME, toEnvVal(clusterName));\n\n        envs.put(IGNITE_USERS_LIBS_URL, toEnvVal(userLibsUrl));\n        envs.put(IGNITE_CONFIG_XML_URL, toEnvVal(igniteCfgUrl));\n\n        envs.put(IGNITE_TOTAL_CPU, toEnvVal(cpu));\n        envs.put(IGNITE_RUN_CPU_PER_NODE, toEnvVal(cpuPerNode));\n        envs.put(IGNITE_TOTAL_MEMORY, toEnvVal(mem));\n        envs.put(IGNITE_MEMORY_PER_NODE, toEnvVal(memPerNode));\n        envs.put(IGNITE_NODE_COUNT, toEnvVal(nodeCnt));\n        envs.put(IGNITE_MIN_CPU_PER_NODE, toEnvVal(minCpu));\n        envs.put(IGNITE_MIN_MEMORY_PER_NODE, toEnvVal(minMemory));\n\n        envs.put(IGNITE_VERSION, toEnvVal(igniteVer));\n        envs.put(IGNITE_WORKING_DIR, toEnvVal(igniteWorkDir));\n        envs.put(IGNITE_CONFIG_XML, toEnvVal(igniteCfg));\n        envs.put(IGNITE_USERS_LIBS, toEnvVal(userLibs));\n\n        if (hostnameConstraint != null)\n            envs.put(IGNITE_HOSTNAME_CONSTRAINT, toEnvVal(hostnameConstraint.pattern()));\n\n        return envs;\n    }","id":97052,"modified_method":"/**\n     * Convert to properties to map.\n     *\n     * @return Key-value map.\n     */\n    public Map<String, String> toEnvs() {\n        Map<String, String> envs = new HashMap<>();\n\n        envs.put(IGNITE_CLUSTER_NAME, toEnvVal(clusterName));\n\n        envs.put(IGNITE_USERS_LIBS_URL, toEnvVal(userLibsUrl));\n        envs.put(IGNITE_CONFIG_XML_URL, toEnvVal(igniteCfgUrl));\n\n        envs.put(IGNITE_RUN_CPU_PER_NODE, toEnvVal(cpuPerNode));\n        envs.put(IGNITE_MEMORY_PER_NODE, toEnvVal(memPerNode));\n        envs.put(IGNITE_NODE_COUNT, toEnvVal(nodeCnt));\n\n        envs.put(IGNITE_VERSION, toEnvVal(igniteVer));\n        envs.put(IGNITE_WORKING_DIR, toEnvVal(igniteWorkDir));\n        envs.put(IGNITE_CONFIG_XML, toEnvVal(igniteCfg));\n        envs.put(IGNITE_USERS_LIBS, toEnvVal(userLibs));\n\n        if (hostnameConstraint != null)\n            envs.put(IGNITE_HOSTNAME_CONSTRAINT, toEnvVal(hostnameConstraint.pattern()));\n\n        return envs;\n    }","commit_id":"858d2a3f757fea2b88ffcb907e0f221699e32420","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param config path to config file.\n     * @return Cluster configuration.\n     */\n    public static ClusterProperties from(String config) {\n        try {\n            Properties props = null;\n\n            if (config != null) {\n                props = new Properties();\n\n                props.load(new FileInputStream(config));\n            }\n\n            ClusterProperties prop = new ClusterProperties();\n\n            prop.clusterName = getStringProperty(IGNITE_CLUSTER_NAME, props, DEFAULT_CLUSTER_NAME);\n\n            prop.userLibsUrl = getStringProperty(IGNITE_USERS_LIBS_URL, props, null);\n            prop.igniteCfgUrl = getStringProperty(IGNITE_CONFIG_XML_URL, props, null);\n\n            prop.cpu = getDoubleProperty(IGNITE_TOTAL_CPU, props, UNLIMITED);\n            prop.cpuPerNode = getDoubleProperty(IGNITE_RUN_CPU_PER_NODE, props, UNLIMITED);\n            prop.mem = getDoubleProperty(IGNITE_TOTAL_MEMORY, props, UNLIMITED);\n            prop.memPerNode = getDoubleProperty(IGNITE_MEMORY_PER_NODE, props, UNLIMITED);\n            prop.nodeCnt = getDoubleProperty(IGNITE_NODE_COUNT, props, UNLIMITED);\n            prop.minCpu = getDoubleProperty(IGNITE_MIN_CPU_PER_NODE, props, DEFAULT_RESOURCE_MIN_CPU);\n            prop.minMemory = getDoubleProperty(IGNITE_MIN_MEMORY_PER_NODE, props, DEFAULT_RESOURCE_MIN_MEM);\n\n            prop.igniteVer = getStringProperty(IGNITE_VERSION, props, DEFAULT_IGNITE_VERSION);\n            prop.igniteWorkDir = getStringProperty(IGNITE_WORKING_DIR, props, DEFAULT_IGNITE_WORK_DIR);\n            prop.igniteCfg = getStringProperty(IGNITE_CONFIG_XML, props, null);\n            prop.userLibs = getStringProperty(IGNITE_USERS_LIBS, props, null);\n\n            String pattern = getStringProperty(IGNITE_HOSTNAME_CONSTRAINT, props, null);\n\n            if (pattern != null) {\n                try {\n                    prop.hostnameConstraint = Pattern.compile(pattern);\n                }\n                catch (PatternSyntaxException e) {\n                    log.log(Level.WARNING, \"IGNITE_HOSTNAME_CONSTRAINT has invalid pattern. It will be ignore.\", e);\n                }\n            }\n\n            return prop;\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":97053,"modified_method":"/**\n     * @param config path to config file.\n     * @return Cluster configuration.\n     */\n    public static ClusterProperties from(String config) {\n        try {\n            Properties props = null;\n\n            if (config != null) {\n                props = new Properties();\n\n                props.load(new FileInputStream(config));\n            }\n\n            ClusterProperties prop = new ClusterProperties();\n\n            prop.clusterName = getStringProperty(IGNITE_CLUSTER_NAME, props, DEFAULT_CLUSTER_NAME);\n\n            prop.userLibsUrl = getStringProperty(IGNITE_USERS_LIBS_URL, props, null);\n            prop.igniteCfgUrl = getStringProperty(IGNITE_CONFIG_XML_URL, props, null);\n\n            prop.cpuPerNode = getDoubleProperty(IGNITE_RUN_CPU_PER_NODE, props, 1.0);\n            prop.memPerNode = getDoubleProperty(IGNITE_MEMORY_PER_NODE, props, 2048.0);\n            prop.nodeCnt = getDoubleProperty(IGNITE_NODE_COUNT, props, 2.0);\n\n            prop.igniteVer = getStringProperty(IGNITE_VERSION, props, DEFAULT_IGNITE_VERSION);\n            prop.igniteWorkDir = getStringProperty(IGNITE_WORKING_DIR, props, DEFAULT_IGNITE_WORK_DIR);\n            prop.igniteCfg = getStringProperty(IGNITE_CONFIG_XML, props, null);\n            prop.userLibs = getStringProperty(IGNITE_USERS_LIBS, props, null);\n\n            String pattern = getStringProperty(IGNITE_HOSTNAME_CONSTRAINT, props, null);\n\n            if (pattern != null) {\n                try {\n                    prop.hostnameConstraint = Pattern.compile(pattern);\n                }\n                catch (PatternSyntaxException e) {\n                    log.log(Level.WARNING, \"IGNITE_HOSTNAME_CONSTRAINT has invalid pattern. It will be ignore.\", e);\n                }\n            }\n\n            return prop;\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"858d2a3f757fea2b88ffcb907e0f221699e32420","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param val Value.\n     * @return If val is null {@link EMPTY_STRING} else to string.\n     */\n    private String toEnvVal(Object val) {\n        return val == null ? EMPTY_STRING : val.toString();\n    }","id":97054,"modified_method":"/**\n     * @param val Value.\n     * @return If val is null {@code EMPTY_STRING} else to string.\n     */\n    private String toEnvVal(Object val) {\n        return val == null ? EMPTY_STRING : val.toString();\n    }","commit_id":"858d2a3f757fea2b88ffcb907e0f221699e32420","url":"https://github.com/apache/ignite"},{"original_method":"@Override\n    public String toString() {\n        return \"IgniteTask \" +\n            \"host: [\" + host + ']' +\n            \", cpuCores: [\" + cpuCores + \"]\" +\n            \", mem: [\" + mem + \"]\";\n    }","id":97055,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override public String toString() {\n        return \"IgniteTask \" +\n            \"host: [\" + nodeId.getHost() + ']' +\n            \", cpuCores: [\" + cpuCores + \"]\" +\n            \", mem: [\" + mem + \"]\";\n    }","commit_id":"858d2a3f757fea2b88ffcb907e0f221699e32420","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Ignite launched task.\n     *\n     * @param host Host.\n     * @param cpuCores Cpu cores count.\n     * @param mem Memory\n     */\n    public IgniteContainer(String host, double cpuCores, double mem) {\n        this.host = host;\n        this.cpuCores = cpuCores;\n        this.mem = mem;\n    }","id":97056,"modified_method":"/**\n     * Ignite launched task.\n     *\n     * @param nodeId Node id.\n     * @param cpuCores Cpu cores count.\n     * @param mem Memory\n     */\n    public IgniteContainer(ContainerId id, NodeId nodeId, double cpuCores, double mem) {\n        this.id = id;\n        this.nodeId = nodeId;\n        this.cpuCores = cpuCores;\n        this.mem = mem;\n    }","commit_id":"858d2a3f757fea2b88ffcb907e0f221699e32420","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Main methods has only one optional parameter - path to properties file.\n     *\n     * @param args Args.\n     */\n    public static void main(String[] args) throws Exception {\n        checkArguments(args);\n\n        // Set path to app master jar.\n        String pathAppMasterJar = args[0];\n\n        ClusterProperties props = ClusterProperties.from(args.length == 2 ? args[1] : null);\n\n        YarnConfiguration conf = new YarnConfiguration();\n        YarnClient yarnClient = YarnClient.createYarnClient();\n        yarnClient.init(conf);\n        yarnClient.start();\n\n        // Create application via yarnClient\n        YarnClientApplication app = yarnClient.createApplication();\n\n        FileSystem fs = FileSystem.get(conf);\n\n        // Load ignite and jar\n        Path ignite = getIgnite(props, fs);\n\n        Path appJar = IgniteYarnUtils.copyLocalToHdfs(fs, pathAppMasterJar,\n            props.igniteWorkDir() + File.separator + IgniteYarnUtils.JAR_NAME);\n\n        // Set up the container launch context for the application master\n        ContainerLaunchContext amContainer = Records.newRecord(ContainerLaunchContext.class);\n\n        System.out.println(Environment.JAVA_HOME.$() + \"/bin/java -Xmx512m \" + ApplicationMaster.class.getName()\n            + IgniteYarnUtils.SPACE + ignite.toUri());\n\n        amContainer.setCommands(\n            Collections.singletonList(\n                Environment.JAVA_HOME.$() + \"/bin/java -Xmx512m \" + ApplicationMaster.class.getName()\n                + IgniteYarnUtils.SPACE + ignite.toUri()\n                + IgniteYarnUtils.YARN_LOG_OUT\n            )\n        );\n\n        // Setup jar for ApplicationMaster\n        LocalResource appMasterJar = IgniteYarnUtils.setupFile(appJar, fs, LocalResourceType.FILE);\n\n        amContainer.setLocalResources(Collections.singletonMap(IgniteYarnUtils.JAR_NAME, appMasterJar));\n\n        // Setup CLASSPATH for ApplicationMaster\n        Map<String, String> appMasterEnv = props.toEnvs();\n\n        setupAppMasterEnv(appMasterEnv, conf);\n\n        amContainer.setEnvironment(appMasterEnv);\n\n        // Set up resource type requirements for ApplicationMaster\n        Resource capability = Records.newRecord(Resource.class);\n        capability.setMemory(512);\n        capability.setVirtualCores(1);\n\n        // Finally, set-up ApplicationSubmissionContext for the application\n        ApplicationSubmissionContext appContext = app.getApplicationSubmissionContext();\n        appContext.setApplicationName(\"ignition\"); // application name\n        appContext.setAMContainerSpec(amContainer);\n        appContext.setResource(capability);\n        appContext.setQueue(\"default\"); // queue\n\n        // Submit application\n        ApplicationId appId = appContext.getApplicationId();\n        System.out.println(\"Submitting application \" + appId);\n        yarnClient.submitApplication(appContext);\n\n        ApplicationReport appReport = yarnClient.getApplicationReport(appId);\n        YarnApplicationState appState = appReport.getYarnApplicationState();\n\n        while (appState != YarnApplicationState.FINISHED &&\n                appState != YarnApplicationState.KILLED &&\n                appState != YarnApplicationState.FAILED) {\n            Thread.sleep(100);\n\n            appReport = yarnClient.getApplicationReport(appId);\n\n            appState = appReport.getYarnApplicationState();\n        }\n\n        yarnClient.killApplication(appId);\n\n        System.out.println(\"Application \" + appId + \" finished with state \" + appState + \" at \"\n            + appReport.getFinishTime());\n    }","id":97057,"modified_method":"/**\n     * Main methods has only one optional parameter - path to properties file.\n     *\n     * @param args Args.\n     */\n    public static void main(String[] args) throws Exception {\n        checkArguments(args);\n\n        // Set path to app master jar.\n        String pathAppMasterJar = args[0];\n\n        ClusterProperties props = ClusterProperties.from(args.length == 2 ? args[1] : null);\n\n        YarnConfiguration conf = new YarnConfiguration();\n        YarnClient yarnClient = YarnClient.createYarnClient();\n        yarnClient.init(conf);\n        yarnClient.start();\n\n        // Create application via yarnClient\n        YarnClientApplication app = yarnClient.createApplication();\n\n        FileSystem fs = FileSystem.get(conf);\n\n        // Load ignite and jar\n        Path ignite = getIgnite(props, fs);\n\n        Path appJar = IgniteYarnUtils.copyLocalToHdfs(fs, pathAppMasterJar,\n            props.igniteWorkDir() + File.separator + IgniteYarnUtils.JAR_NAME);\n\n        // Set up the container launch context for the application master\n        ContainerLaunchContext amContainer = Records.newRecord(ContainerLaunchContext.class);\n\n        amContainer.setCommands(\n            Collections.singletonList(\n                Environment.JAVA_HOME.$() + \"/bin/java -Xmx512m \" + ApplicationMaster.class.getName()\n                + IgniteYarnUtils.SPACE + ignite.toUri()\n                + IgniteYarnUtils.YARN_LOG_OUT\n            )\n        );\n\n        // Setup jar for ApplicationMaster\n        LocalResource appMasterJar = IgniteYarnUtils.setupFile(appJar, fs, LocalResourceType.FILE);\n\n        amContainer.setLocalResources(Collections.singletonMap(IgniteYarnUtils.JAR_NAME, appMasterJar));\n\n        // Setup CLASSPATH for ApplicationMaster\n        Map<String, String> appMasterEnv = props.toEnvs();\n\n        setupAppMasterEnv(appMasterEnv, conf);\n\n        amContainer.setEnvironment(appMasterEnv);\n\n        // Set up resource type requirements for ApplicationMaster\n        Resource capability = Records.newRecord(Resource.class);\n        capability.setMemory(512);\n        capability.setVirtualCores(1);\n\n        // Finally, set-up ApplicationSubmissionContext for the application\n        ApplicationSubmissionContext appContext = app.getApplicationSubmissionContext();\n        appContext.setApplicationName(\"ignition\"); // application name\n        appContext.setAMContainerSpec(amContainer);\n        appContext.setResource(capability);\n        appContext.setQueue(\"default\"); // queue\n\n        // Submit application\n        ApplicationId appId = appContext.getApplicationId();\n\n        yarnClient.submitApplication(appContext);\n\n        log.log(Level.INFO, \"Submitted application. Application id: [{0}]\", appId);\n\n        ApplicationReport appReport = yarnClient.getApplicationReport(appId);\n        YarnApplicationState appState = appReport.getYarnApplicationState();\n\n        while (appState != YarnApplicationState.FINISHED &&\n                appState != YarnApplicationState.KILLED &&\n                appState != YarnApplicationState.FAILED) {\n            TimeUnit.SECONDS.sleep(1L);\n\n            appReport = yarnClient.getApplicationReport(appId);\n\n            appState = appReport.getYarnApplicationState();\n        }\n\n        yarnClient.killApplication(appId);\n\n        log.log(Level.INFO, \"Application [{0}] finished with state [{1}]\", new Object[]{appId, appState});\n    }","commit_id":"858d2a3f757fea2b88ffcb907e0f221699e32420","url":"https://github.com/apache/ignite"},{"original_method":"@Override\n    public void visitClosureExpression(final ClosureExpression expression) {\n        ClosureExpression oldClosureExpr = closureExpression;\n        List<ClassNode> oldClosureReturnTypes = closureReturnTypes;\n        closureExpression = expression;\n        super.visitClosureExpression(expression);\n        MethodNode node = new MethodNode(\"dummy\", 0, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, expression.getCode());\n        closureReturnAdder.visitMethod(node);\n\n        if (closureReturnTypes!=null) {\n            expression.putNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE, lowestUpperBound(closureReturnTypes));\n        }\n\n        closureExpression = oldClosureExpr;\n        closureReturnTypes = oldClosureReturnTypes;\n    }","id":97058,"modified_method":"@Override\n    public void visitClosureExpression(final ClosureExpression expression) {\n\t\t// first, collect closure shared variables and reinitialize types\n\t\tSharedVariableCollector collector = new SharedVariableCollector(getSourceUnit());\n\t\tcollector.visitClosureExpression(expression);\n\t\tSet<VariableExpression> closureSharedExpressions = collector.getClosureSharedExpressions();\n\t\tMap<VariableExpression, ListHashMap> typesBeforeVisit = null;\n\t\tif (!closureSharedExpressions.isEmpty()) {\n\t\t\ttypesBeforeVisit = new HashMap<VariableExpression, ListHashMap>();\n\t\t\tsaveVariableExpressionMetadata(closureSharedExpressions, typesBeforeVisit);\n\t\t}\n\n\t\t// perform visit\n        ClosureExpression oldClosureExpr = closureExpression;\n        List<ClassNode> oldClosureReturnTypes = closureReturnTypes;\n        closureExpression = expression;\n        super.visitClosureExpression(expression);\n        MethodNode node = new MethodNode(\"dummy\", 0, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, expression.getCode());\n        closureReturnAdder.visitMethod(node);\n\n        if (closureReturnTypes!=null) {\n            expression.putNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE, lowestUpperBound(closureReturnTypes));\n        }\n\n        closureExpression = oldClosureExpr;\n        closureReturnTypes = oldClosureReturnTypes;\n\t\t\n\t\t// restore original metadata\n\t\trestoreVariableExpressionMetadata(typesBeforeVisit);\n\t}","commit_id":"c42d11db89b69db23ce095aef7c4805e06cfdee3","url":"https://github.com/apache/groovy"},{"original_method":"private void storeType(Expression exp, ClassNode cn) {\n        ClassNode oldValue = (ClassNode) exp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, cn);\n        if (oldValue!=null) {\n            // this may happen when a variable declaration type is wider than the subsequent assignment values\n            // for example :\n            // def o = 1 // first, an int\n            // o = 'String' // then a string\n            // o = new Object() // and eventually an object !\n            // in that case, the INFERRED_TYPE corresponds to the current inferred type, while\n            // DECLARATION_INFERRED_TYPE is the type which should be used for the initial type declaration\n            ClassNode oldDIT = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n            if (oldDIT!=null) {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldDIT, cn));\n            } else {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldValue, cn));\n            }\n        }\n        if (exp instanceof VariableExpression) {\n            final Variable accessedVariable = ((VariableExpression) exp).getAccessedVariable();\n            if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {\n                storeType((Expression) accessedVariable, cn);\n            }\n        }\n    }","id":97059,"modified_method":"private void storeType(Expression exp, ClassNode cn) {\n        ClassNode oldValue = (ClassNode) exp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, cn);\n        if (oldValue!=null) {\n            // this may happen when a variable declaration type is wider than the subsequent assignment values\n            // for example :\n            // def o = 1 // first, an int\n            // o = 'String' // then a string\n            // o = new Object() // and eventually an object !\n            // in that case, the INFERRED_TYPE corresponds to the current inferred type, while\n            // DECLARATION_INFERRED_TYPE is the type which should be used for the initial type declaration\n            ClassNode oldDIT = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n            if (oldDIT!=null) {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldDIT, cn));\n            } else {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldValue, cn));\n            }\n        }\n        if (exp instanceof VariableExpression) {\n\t\t\tVariableExpression var = (VariableExpression) exp;\n\t\t\tfinal Variable accessedVariable = var.getAccessedVariable();\n            if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {\n                storeType((Expression) accessedVariable, cn);\n            }\n\t\t\tif (var.isClosureSharedVariable()) {\n\t\t\t\tList<ClassNode> assignedTypes = closureSharedVariablesAssignmentTypes.get(var);\n\t\t\t\tif (assignedTypes==null) {\n\t\t\t\t\tassignedTypes = new LinkedList<ClassNode>();\n\t\t\t\t\tclosureSharedVariablesAssignmentTypes.put(var, assignedTypes);\n\t\t\t\t}\n\t\t\t\tassignedTypes.add(cn);\n\t\t\t}\n\n        }\n    }","commit_id":"c42d11db89b69db23ce095aef7c4805e06cfdee3","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(subcallReturnType)});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            // method call receivers are :\n            //   - possible \"with\" receivers\n            //   - the actual receiver as found in the method call expression\n            //   - any of the potential receivers found in the instanceof temporary table\n            // in that order\n            List<ClassNode> receivers = new LinkedList<ClassNode>();\n            if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n            receivers.add(receiver);\n            if (objectExpression instanceof ClassExpression) {\n                receivers.add(CLASS_Type);\n            }\n            if (!temporaryIfBranchTypeInformation.empty()) {\n                final Map<Object, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                Object key = extractTemporaryTypeInfoKey(objectExpression);\n                List<ClassNode> potentialReceiverType = tempo.get(key);\n                if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n            }\n            List<MethodNode> mn = null;\n            ClassNode chosenReceiver = null;\n            for (ClassNode currentReceiver : receivers) {\n                mn = findMethod(currentReceiver, name, args);\n                if (!mn.isEmpty()) {\n                    typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                    chosenReceiver = currentReceiver;\n                    break;\n                }\n            }\n            if (mn.isEmpty()) {\n                addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n            } else {\n                if (isCallOnClosure) {\n                    // this is a closure.call() call\n                    if (objectExpression instanceof VariableExpression) {\n                        Variable variable = findTargetVariable((VariableExpression)objectExpression);\n                        if (variable instanceof Expression) {\n                            Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                            if (data!=null) {\n                                Parameter[] parameters = (Parameter[]) data;\n                                typeCheckClosureCall(callArguments, args, parameters);\n                            }\n                            Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                            if (type!=null) {\n                                 storeType(call, (ClassNode) type);\n                            }\n                        }\n                    } else if (objectExpression instanceof ClosureExpression) {\n                        // we can get actual parameters directly\n                        Parameter[] parameters = ((ClosureExpression)objectExpression).getParameters();\n                        typeCheckClosureCall(callArguments, args, parameters);\n                        Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (data!=null) {\n                            storeType(call, (ClassNode) data);\n                        }\n                    }\n                } else {\n                    if (mn.size()==1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \"+mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":97060,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(subcallReturnType)});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            // method call receivers are :\n            //   - possible \"with\" receivers\n            //   - the actual receiver as found in the method call expression\n            //   - any of the potential receivers found in the instanceof temporary table\n            // in that order\n            List<ClassNode> receivers = new LinkedList<ClassNode>();\n            if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n            receivers.add(receiver);\n            if (objectExpression instanceof ClassExpression) {\n                receivers.add(CLASS_Type);\n            }\n            if (!temporaryIfBranchTypeInformation.empty()) {\n                final Map<Object, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                Object key = extractTemporaryTypeInfoKey(objectExpression);\n                List<ClassNode> potentialReceiverType = tempo.get(key);\n                if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n            }\n            List<MethodNode> mn = null;\n            ClassNode chosenReceiver = null;\n            for (ClassNode currentReceiver : receivers) {\n                mn = findMethod(currentReceiver, name, args);\n                if (!mn.isEmpty()) {\n                    typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                    chosenReceiver = currentReceiver;\n                    break;\n                }\n            }\n            if (mn.isEmpty()) {\n                addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n            } else {\n                if (isCallOnClosure) {\n                    // this is a closure.call() call\n                    if (objectExpression instanceof VariableExpression) {\n                        Variable variable = findTargetVariable((VariableExpression)objectExpression);\n                        if (variable instanceof Expression) {\n                            Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                            if (data!=null) {\n                                Parameter[] parameters = (Parameter[]) data;\n                                typeCheckClosureCall(callArguments, args, parameters);\n                            }\n                            Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                            if (type!=null) {\n                                 storeType(call, (ClassNode) type);\n                            }\n                        }\n                    } else if (objectExpression instanceof ClosureExpression) {\n                        // we can get actual parameters directly\n                        Parameter[] parameters = ((ClosureExpression)objectExpression).getParameters();\n                        typeCheckClosureCall(callArguments, args, parameters);\n                        Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (data!=null) {\n                            storeType(call, (ClassNode) data);\n                        }\n                    }\n                } else {\n                    if (mn.size()==1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n\t\t\t\t\t\t// if the object expression is a closure shared variable, we will have to perform a second pass\n\t\t\t\t\t\tif (objectExpression instanceof VariableExpression) {\n\t\t\t\t\t\t\tVariableExpression var = (VariableExpression) objectExpression;\n\t\t\t\t\t\t\tif (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n\t\t\t\t\t\t}\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \"+mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"c42d11db89b69db23ce095aef7c4805e06cfdee3","url":"https://github.com/apache/groovy"},{"original_method":"public void visit(ASTNode[] nodes, SourceUnit source) {\n//        AnnotationNode annotationInformation = (AnnotationNode) nodes[0];\n        AnnotatedNode node = (AnnotatedNode) nodes[1];\n        if (node instanceof ClassNode) {\n            ClassNode classNode = (ClassNode) node;\n            StaticTypeCheckingVisitor visitor = newVisitor(source, classNode);\n            visitor.visitClass(classNode);\n        } else if (node instanceof MethodNode) {\n            MethodNode methodNode = (MethodNode)node;\n            StaticTypeCheckingVisitor visitor = newVisitor(source, methodNode.getDeclaringClass());\n            visitor.setMethodsToBeVisited(Collections.singleton(methodNode));\n            visitor.visitMethod(methodNode);\n        } else {\n            source.addError(new SyntaxException(STATIC_ERROR_PREFIX + \"Unimplemented node type\", node.getLineNumber(), node.getColumnNumber()));\n        }\n    }","id":97061,"modified_method":"public void visit(ASTNode[] nodes, SourceUnit source) {\n//        AnnotationNode annotationInformation = (AnnotationNode) nodes[0];\n        AnnotatedNode node = (AnnotatedNode) nodes[1];\n\t\tStaticTypeCheckingVisitor visitor = null;\n        if (node instanceof ClassNode) {\n            ClassNode classNode = (ClassNode) node;\n            visitor = newVisitor(source, classNode);\n            visitor.visitClass(classNode);\n        } else if (node instanceof MethodNode) {\n            MethodNode methodNode = (MethodNode)node;\n            visitor = newVisitor(source, methodNode.getDeclaringClass());\n            visitor.setMethodsToBeVisited(Collections.singleton(methodNode));\n            visitor.visitMethod(methodNode);\n        } else {\n            source.addError(new SyntaxException(STATIC_ERROR_PREFIX + \"Unimplemented node type\", node.getLineNumber(), node.getColumnNumber()));\n        }\n\t\tif (visitor!=null) {\n\t\t\tvisitor.performSecondPass();\n\t\t}\n    }","commit_id":"c42d11db89b69db23ce095aef7c4805e06cfdee3","url":"https://github.com/apache/groovy"},{"original_method":"public LowestUpperBoundClassNode(String name, ClassNode upper, ClassNode... interfaces) {\n            super(name, ACC_PUBLIC|ACC_FINAL, upper, interfaces, null);\n            compileTimeClassNode = upper.equals(OBJECT_TYPE) && interfaces.length>0?interfaces[0]:upper;\n            this.name = name;\n            if (upper.isUsingGenerics()) {\n                setGenericsTypes(upper.getGenericsTypes());\n            }\n        }","id":97062,"modified_method":"public LowestUpperBoundClassNode(String name, ClassNode upper, ClassNode... interfaces) {\n            super(name, ACC_PUBLIC|ACC_FINAL, upper, interfaces, null);\n            compileTimeClassNode = upper.equals(OBJECT_TYPE) && interfaces.length>0?interfaces[0]:upper;\n            this.name = name;\n            if (upper.isUsingGenerics()) {\n                setGenericsTypes(upper.getGenericsTypes());\n            }\n\t\t\tfor (ClassNode anInterface : interfaces) {\n\t\t\t\tfor (MethodNode methodNode : anInterface.getMethods()) {\n\t\t\t\t\taddMethod(methodNode.getName(), methodNode.getModifiers(), methodNode.getReturnType(), methodNode.getParameters(), methodNode.getExceptions(), methodNode.getCode());\n\t\t\t\t}\n\t\t\t}\n        }","commit_id":"c42d11db89b69db23ce095aef7c4805e06cfdee3","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitClosureExpression(final ClosureExpression expression) {\n        ClosureExpression oldClosureExpr = closureExpression;\n        List<ClassNode> oldClosureReturnTypes = closureReturnTypes;\n        closureExpression = expression;\n        super.visitClosureExpression(expression);\n        MethodNode node = new MethodNode(\"dummy\", 0, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, expression.getCode());\n        closureReturnAdder.visitMethod(node);\n\n        if (closureReturnTypes!=null) {\n            expression.putNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE, lowestUpperBound(closureReturnTypes));\n        }\n\n        closureExpression = oldClosureExpr;\n        closureReturnTypes = oldClosureReturnTypes;\n    }","id":97063,"modified_method":"@Override\n    public void visitClosureExpression(final ClosureExpression expression) {\n\t\t// first, collect closure shared variables and reinitialize types\n\t\tSharedVariableCollector collector = new SharedVariableCollector(getSourceUnit());\n\t\tcollector.visitClosureExpression(expression);\n\t\tSet<VariableExpression> closureSharedExpressions = collector.getClosureSharedExpressions();\n\t\tMap<VariableExpression, ListHashMap> typesBeforeVisit = null;\n\t\tif (!closureSharedExpressions.isEmpty()) {\n\t\t\ttypesBeforeVisit = new HashMap<VariableExpression, ListHashMap>();\n\t\t\tsaveVariableExpressionMetadata(closureSharedExpressions, typesBeforeVisit);\n\t\t}\n\n\t\t// perform visit\n        ClosureExpression oldClosureExpr = closureExpression;\n        List<ClassNode> oldClosureReturnTypes = closureReturnTypes;\n        closureExpression = expression;\n        super.visitClosureExpression(expression);\n        MethodNode node = new MethodNode(\"dummy\", 0, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, expression.getCode());\n        closureReturnAdder.visitMethod(node);\n\n        if (closureReturnTypes!=null) {\n            expression.putNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE, lowestUpperBound(closureReturnTypes));\n        }\n\n        closureExpression = oldClosureExpr;\n        closureReturnTypes = oldClosureReturnTypes;\n\t\t\n\t\t// restore original metadata\n\t\trestoreVariableExpressionMetadata(typesBeforeVisit);\n\t}","commit_id":"407a90435c2b2fc0a0c52cf44aa25b4e60e9f6ff","url":"https://github.com/apache/groovy"},{"original_method":"private void storeType(Expression exp, ClassNode cn) {\n        ClassNode oldValue = (ClassNode) exp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, cn);\n        if (oldValue!=null) {\n            // this may happen when a variable declaration type is wider than the subsequent assignment values\n            // for example :\n            // def o = 1 // first, an int\n            // o = 'String' // then a string\n            // o = new Object() // and eventually an object !\n            // in that case, the INFERRED_TYPE corresponds to the current inferred type, while\n            // DECLARATION_INFERRED_TYPE is the type which should be used for the initial type declaration\n            ClassNode oldDIT = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n            if (oldDIT!=null) {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldDIT, cn));\n            } else {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldValue, cn));\n            }\n        }\n        if (exp instanceof VariableExpression) {\n            final Variable accessedVariable = ((VariableExpression) exp).getAccessedVariable();\n            if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {\n                storeType((Expression) accessedVariable, cn);\n            }\n        }\n    }","id":97064,"modified_method":"private void storeType(Expression exp, ClassNode cn) {\n        ClassNode oldValue = (ClassNode) exp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, cn);\n        if (oldValue!=null) {\n            // this may happen when a variable declaration type is wider than the subsequent assignment values\n            // for example :\n            // def o = 1 // first, an int\n            // o = 'String' // then a string\n            // o = new Object() // and eventually an object !\n            // in that case, the INFERRED_TYPE corresponds to the current inferred type, while\n            // DECLARATION_INFERRED_TYPE is the type which should be used for the initial type declaration\n            ClassNode oldDIT = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n            if (oldDIT!=null) {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldDIT, cn));\n            } else {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldValue, cn));\n            }\n        }\n        if (exp instanceof VariableExpression) {\n\t\t\tVariableExpression var = (VariableExpression) exp;\n\t\t\tfinal Variable accessedVariable = var.getAccessedVariable();\n            if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {\n                storeType((Expression) accessedVariable, cn);\n            }\n\t\t\tif (var.isClosureSharedVariable()) {\n\t\t\t\tList<ClassNode> assignedTypes = closureSharedVariablesAssignmentTypes.get(var);\n\t\t\t\tif (assignedTypes==null) {\n\t\t\t\t\tassignedTypes = new LinkedList<ClassNode>();\n\t\t\t\t\tclosureSharedVariablesAssignmentTypes.put(var, assignedTypes);\n\t\t\t\t}\n\t\t\t\tassignedTypes.add(cn);\n\t\t\t}\n\n        }\n    }","commit_id":"407a90435c2b2fc0a0c52cf44aa25b4e60e9f6ff","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(subcallReturnType)});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            // method call receivers are :\n            //   - possible \"with\" receivers\n            //   - the actual receiver as found in the method call expression\n            //   - any of the potential receivers found in the instanceof temporary table\n            // in that order\n            List<ClassNode> receivers = new LinkedList<ClassNode>();\n            if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n            receivers.add(receiver);\n            if (objectExpression instanceof ClassExpression) {\n                receivers.add(CLASS_Type);\n            }\n            if (!temporaryIfBranchTypeInformation.empty()) {\n                final Map<Object, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                Object key = extractTemporaryTypeInfoKey(objectExpression);\n                List<ClassNode> potentialReceiverType = tempo.get(key);\n                if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n            }\n            List<MethodNode> mn = null;\n            ClassNode chosenReceiver = null;\n            for (ClassNode currentReceiver : receivers) {\n                mn = findMethod(currentReceiver, name, args);\n                if (!mn.isEmpty()) {\n                    typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                    chosenReceiver = currentReceiver;\n                    break;\n                }\n            }\n            if (mn.isEmpty()) {\n                addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n            } else {\n                if (isCallOnClosure) {\n                    // this is a closure.call() call\n                    if (objectExpression instanceof VariableExpression) {\n                        Variable variable = findTargetVariable((VariableExpression)objectExpression);\n                        if (variable instanceof Expression) {\n                            Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                            if (data!=null) {\n                                Parameter[] parameters = (Parameter[]) data;\n                                typeCheckClosureCall(callArguments, args, parameters);\n                            }\n                            Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                            if (type!=null) {\n                                 storeType(call, (ClassNode) type);\n                            }\n                        }\n                    } else if (objectExpression instanceof ClosureExpression) {\n                        // we can get actual parameters directly\n                        Parameter[] parameters = ((ClosureExpression)objectExpression).getParameters();\n                        typeCheckClosureCall(callArguments, args, parameters);\n                        Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (data!=null) {\n                            storeType(call, (ClassNode) data);\n                        }\n                    }\n                } else {\n                    if (mn.size()==1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \"+mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":97065,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(subcallReturnType)});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            // method call receivers are :\n            //   - possible \"with\" receivers\n            //   - the actual receiver as found in the method call expression\n            //   - any of the potential receivers found in the instanceof temporary table\n            // in that order\n            List<ClassNode> receivers = new LinkedList<ClassNode>();\n            if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n            receivers.add(receiver);\n            if (objectExpression instanceof ClassExpression) {\n                receivers.add(CLASS_Type);\n            }\n            if (!temporaryIfBranchTypeInformation.empty()) {\n                final Map<Object, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                Object key = extractTemporaryTypeInfoKey(objectExpression);\n                List<ClassNode> potentialReceiverType = tempo.get(key);\n                if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n            }\n            List<MethodNode> mn = null;\n            ClassNode chosenReceiver = null;\n            for (ClassNode currentReceiver : receivers) {\n                mn = findMethod(currentReceiver, name, args);\n                if (!mn.isEmpty()) {\n                    typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                    chosenReceiver = currentReceiver;\n                    break;\n                }\n            }\n            if (mn.isEmpty()) {\n                addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n            } else {\n                if (isCallOnClosure) {\n                    // this is a closure.call() call\n                    if (objectExpression instanceof VariableExpression) {\n                        Variable variable = findTargetVariable((VariableExpression)objectExpression);\n                        if (variable instanceof Expression) {\n                            Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                            if (data!=null) {\n                                Parameter[] parameters = (Parameter[]) data;\n                                typeCheckClosureCall(callArguments, args, parameters);\n                            }\n                            Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                            if (type!=null) {\n                                 storeType(call, (ClassNode) type);\n                            }\n                        }\n                    } else if (objectExpression instanceof ClosureExpression) {\n                        // we can get actual parameters directly\n                        Parameter[] parameters = ((ClosureExpression)objectExpression).getParameters();\n                        typeCheckClosureCall(callArguments, args, parameters);\n                        Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (data!=null) {\n                            storeType(call, (ClassNode) data);\n                        }\n                    }\n                } else {\n                    if (mn.size()==1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n\t\t\t\t\t\t// if the object expression is a closure shared variable, we will have to perform a second pass\n\t\t\t\t\t\tif (objectExpression instanceof VariableExpression) {\n\t\t\t\t\t\t\tVariableExpression var = (VariableExpression) objectExpression;\n\t\t\t\t\t\t\tif (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n\t\t\t\t\t\t}\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \"+mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"407a90435c2b2fc0a0c52cf44aa25b4e60e9f6ff","url":"https://github.com/apache/groovy"},{"original_method":"public void visit(ASTNode[] nodes, SourceUnit source) {\n//        AnnotationNode annotationInformation = (AnnotationNode) nodes[0];\n        AnnotatedNode node = (AnnotatedNode) nodes[1];\n        if (node instanceof ClassNode) {\n            ClassNode classNode = (ClassNode) node;\n            StaticTypeCheckingVisitor visitor = newVisitor(source, classNode);\n            visitor.visitClass(classNode);\n        } else if (node instanceof MethodNode) {\n            MethodNode methodNode = (MethodNode)node;\n            StaticTypeCheckingVisitor visitor = newVisitor(source, methodNode.getDeclaringClass());\n            visitor.setMethodsToBeVisited(Collections.singleton(methodNode));\n            visitor.visitMethod(methodNode);\n        } else {\n            source.addError(new SyntaxException(STATIC_ERROR_PREFIX + \"Unimplemented node type\", node.getLineNumber(), node.getColumnNumber()));\n        }\n    }","id":97066,"modified_method":"public void visit(ASTNode[] nodes, SourceUnit source) {\n//        AnnotationNode annotationInformation = (AnnotationNode) nodes[0];\n        AnnotatedNode node = (AnnotatedNode) nodes[1];\n\t\tStaticTypeCheckingVisitor visitor = null;\n        if (node instanceof ClassNode) {\n            ClassNode classNode = (ClassNode) node;\n            visitor = newVisitor(source, classNode);\n            visitor.visitClass(classNode);\n        } else if (node instanceof MethodNode) {\n            MethodNode methodNode = (MethodNode)node;\n            visitor = newVisitor(source, methodNode.getDeclaringClass());\n            visitor.setMethodsToBeVisited(Collections.singleton(methodNode));\n            visitor.visitMethod(methodNode);\n        } else {\n            source.addError(new SyntaxException(STATIC_ERROR_PREFIX + \"Unimplemented node type\", node.getLineNumber(), node.getColumnNumber()));\n        }\n\t\tif (visitor!=null) {\n\t\t\tvisitor.performSecondPass();\n\t\t}\n    }","commit_id":"407a90435c2b2fc0a0c52cf44aa25b4e60e9f6ff","url":"https://github.com/apache/groovy"},{"original_method":"public LowestUpperBoundClassNode(String name, ClassNode upper, ClassNode... interfaces) {\n            super(name, ACC_PUBLIC|ACC_FINAL, upper, interfaces, null);\n            compileTimeClassNode = upper.equals(OBJECT_TYPE) && interfaces.length>0?interfaces[0]:upper;\n            this.name = name;\n            if (upper.isUsingGenerics()) {\n                setGenericsTypes(upper.getGenericsTypes());\n            }\n        }","id":97067,"modified_method":"public LowestUpperBoundClassNode(String name, ClassNode upper, ClassNode... interfaces) {\n            super(name, ACC_PUBLIC|ACC_FINAL, upper, interfaces, null);\n            compileTimeClassNode = upper.equals(OBJECT_TYPE) && interfaces.length>0?interfaces[0]:upper;\n            this.name = name;\n            if (upper.isUsingGenerics()) {\n                setGenericsTypes(upper.getGenericsTypes());\n            }\n\t\t\tfor (ClassNode anInterface : interfaces) {\n\t\t\t\tfor (MethodNode methodNode : anInterface.getMethods()) {\n\t\t\t\t\taddMethod(methodNode.getName(), methodNode.getModifiers(), methodNode.getReturnType(), methodNode.getParameters(), methodNode.getExceptions(), methodNode.getCode());\n\t\t\t\t}\n\t\t\t}\n        }","commit_id":"407a90435c2b2fc0a0c52cf44aa25b4e60e9f6ff","url":"https://github.com/apache/groovy"},{"original_method":"public void executeReport( Locale locale )\n        throws MavenReportException\n    {\n\n        if ( !xmlPath.exists() )\n        {\n            getLog().warn( \"changes.xml file \" + xmlPath.getAbsolutePath() + \" does not exist.\" );\n            return;\n        }\n        if ( filteringChanges )\n        {\n            if ( !filteredOutputDirectory.exists() )\n            {\n                filteredOutputDirectory.mkdirs();\n            }\n            XmlStreamReader xmlStreamReader = null;\n            try\n            {\n                // so we get encoding from the file itself\n                xmlStreamReader = ReaderFactory.newXmlReader( xmlPath );\n                String encoding = xmlStreamReader.getEncoding();\n                File resultFile = new File( filteredOutputDirectory, \"changes.xml\" );\n                Date now = new Date();\n                SimpleDateFormat simpleDateFormat =\n                    new SimpleDateFormat( publishDateFormat, new Locale( publishDateLocale ) );\n                Properties additionalProperties = new Properties();\n                additionalProperties.put( \"publishDate\", simpleDateFormat.format( now ) );\n                MavenFileFilterRequest mavenFileFilterRequest =\n                    new MavenFileFilterRequest( xmlPath, resultFile, true, project, Collections.EMPTY_LIST, false,\n                                                encoding, session, additionalProperties );\n                mavenFileFilter.copyFile( mavenFileFilterRequest );\n                xmlPath = resultFile;\n            }\n            catch ( IOException e )\n            {\n                throw new MavenReportException( \"Exception during filtering changes file : \" + e.getMessage(), e );\n            }\n            catch ( MavenFilteringException e )\n            {\n                throw new MavenReportException( \"Exception during filtering changes file : \" + e.getMessage(), e );\n            }\n            finally\n            {\n                if ( xmlStreamReader != null )\n                {\n                    IOUtil.close( xmlStreamReader );\n                }\n            }\n\n        }\n\n        ChangesXML changesXml = new ChangesXML( xmlPath, getLog() );\n        ChangesReportGenerator report = new ChangesReportGenerator( changesXml.getReleaseList() );\n\n        report.setAuthor( changesXml.getAuthor() );\n        report.setTitle( changesXml.getTitle() );\n\n        report.setEscapeHTML ( escapeHTML );\n\n        // Create a case insensitive version of issueLinkTemplatePerSystem\n        // We need something case insensitive to maintain backward compatibility\n        if ( issueLinkTemplatePerSystem == null )\n        {\n            caseInsensitiveIssueLinkTemplatePerSystem = new CaseInsensitiveMap();\n        }\n        else\n        {\n            caseInsensitiveIssueLinkTemplatePerSystem = new CaseInsensitiveMap( issueLinkTemplatePerSystem );\n        }\n\n        // Set good default values for issue management systems here, but only\n        // if they have not been configured already by the user\n        addIssueLinkTemplate( ChangesReportGenerator.DEFAULT_ISSUE_SYSTEM_KEY, issueLinkTemplate );\n        addIssueLinkTemplate( \"Bitbucket\", \"%URL%/issue/%ISSUE%\" );\n        addIssueLinkTemplate( \"Bugzilla\", \"%URL%/show_bug.cgi?id=%ISSUE%\" );\n        addIssueLinkTemplate( \"GitHub\", \"%URL%/%ISSUE%\" );\n        addIssueLinkTemplate( \"GoogleCode\", \"%URL%/detail?id=%ISSUE%\" );\n        addIssueLinkTemplate( \"JIRA\", \"%URL%/%ISSUE%\" );\n        addIssueLinkTemplate( \"Mantis\", \"%URL%/view.php?id=%ISSUE%\" );\n        addIssueLinkTemplate( \"MKS\", \"%URL%/viewissue?selection=%ISSUE%\" );\n        addIssueLinkTemplate( \"Redmine\", \"%URL%/issues/show/%ISSUE%\" );\n        addIssueLinkTemplate( \"Scarab\", \"%URL%/issues/id/%ISSUE%\" );\n        addIssueLinkTemplate( \"SourceForge\", \"http://sourceforge.net/support/tracker.php?aid=%ISSUE%\" );\n        addIssueLinkTemplate( \"Trac\", \"%URL%/ticket/%ISSUE%\" );\n        addIssueLinkTemplate( \"Trackplus\", \"%URL%/printItem.action?key=%ISSUE%\" );\n        addIssueLinkTemplate( \"YouTrack\", \"%URL%/issue/%ISSUE%\" );\n        // @todo Add more issue management systems here\n        // Remember to also add documentation in usage.apt.vm\n\n        // Show the current issueLinkTemplatePerSystem configuration\n        logIssueLinkTemplatePerSystem( caseInsensitiveIssueLinkTemplatePerSystem );\n\n        report.setIssueLinksPerSystem( caseInsensitiveIssueLinkTemplatePerSystem );\n\n        report.setSystem( system );\n\n        report.setTeamlist ( teamlist );\n\n        report.setUrl( url );\n\n        report.setAddActionDate( addActionDate );\n\n        if ( StringUtils.isEmpty( url ) )\n        {\n            getLog().warn( \"No issue management URL defined in POM. Links to your issues will not work correctly.\" );\n        }\n\n        report.doGenerateReport( getBundle( locale ), getSink() );\n\n        // Copy the images\n        copyStaticResources();\n    }","id":97068,"modified_method":"public void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        Date now = new Date();\n        SimpleDateFormat simpleDateFormat =\n                new SimpleDateFormat(publishDateFormat, new Locale(publishDateLocale));\n        Properties additionalProperties = new Properties();\n        additionalProperties.put(\"publishDate\", simpleDateFormat.format(now));\n\n        ChangesXML changesXml = getChangesFromFile( xmlPath, project, additionalProperties);\n        if ( changesXml == null ) return;\n\n        if ( aggregated )\n        {\n            final String basePath = project.getBasedir().getAbsolutePath();\n            final String absolutePath = xmlPath.getAbsolutePath();\n            if ( !absolutePath.startsWith( basePath ) )\n            {\n                getLog().warn( \"xmlPath should be within the project dir for aggregated changes report.\" );\n                return;\n            }\n            final String relativePath = absolutePath.substring( basePath.length() );\n\n            List releaseList = changesXml.getReleaseList();\n            for ( Iterator iterator = project.getCollectedProjects().iterator(); iterator.hasNext(); )\n            {\n                final MavenProject childProject = (MavenProject) iterator.next();\n                final File changesFile = new File( childProject.getBasedir(), relativePath );\n                final ChangesXML childXml = getChangesFromFile( changesFile, childProject, additionalProperties );\n                if ( childXml != null )\n                {\n                    releaseList = releaseUtils.mergeReleases( releaseList, childProject.getName(), childXml.getReleaseList() );\n                }\n            }\n            changesXml.setReleaseList( releaseList );\n        }\n\n        ChangesReportGenerator report = new ChangesReportGenerator( changesXml.getReleaseList() );\n\n        report.setAuthor( changesXml.getAuthor() );\n        report.setTitle( changesXml.getTitle() );\n\n        report.setEscapeHTML ( escapeHTML );\n\n        // Create a case insensitive version of issueLinkTemplatePerSystem\n        // We need something case insensitive to maintain backward compatibility\n        if ( issueLinkTemplatePerSystem == null )\n        {\n            caseInsensitiveIssueLinkTemplatePerSystem = new CaseInsensitiveMap();\n        }\n        else\n        {\n            caseInsensitiveIssueLinkTemplatePerSystem = new CaseInsensitiveMap( issueLinkTemplatePerSystem );\n        }\n\n        // Set good default values for issue management systems here, but only\n        // if they have not been configured already by the user\n        addIssueLinkTemplate( ChangesReportGenerator.DEFAULT_ISSUE_SYSTEM_KEY, issueLinkTemplate );\n        addIssueLinkTemplate( \"Bitbucket\", \"%URL%/issue/%ISSUE%\" );\n        addIssueLinkTemplate( \"Bugzilla\", \"%URL%/show_bug.cgi?id=%ISSUE%\" );\n        addIssueLinkTemplate( \"GitHub\", \"%URL%/%ISSUE%\" );\n        addIssueLinkTemplate( \"GoogleCode\", \"%URL%/detail?id=%ISSUE%\" );\n        addIssueLinkTemplate( \"JIRA\", \"%URL%/%ISSUE%\" );\n        addIssueLinkTemplate( \"Mantis\", \"%URL%/view.php?id=%ISSUE%\" );\n        addIssueLinkTemplate( \"MKS\", \"%URL%/viewissue?selection=%ISSUE%\" );\n        addIssueLinkTemplate( \"Redmine\", \"%URL%/issues/show/%ISSUE%\" );\n        addIssueLinkTemplate( \"Scarab\", \"%URL%/issues/id/%ISSUE%\" );\n        addIssueLinkTemplate( \"SourceForge\", \"http://sourceforge.net/support/tracker.php?aid=%ISSUE%\" );\n        addIssueLinkTemplate( \"Trac\", \"%URL%/ticket/%ISSUE%\" );\n        addIssueLinkTemplate( \"Trackplus\", \"%URL%/printItem.action?key=%ISSUE%\" );\n        addIssueLinkTemplate( \"YouTrack\", \"%URL%/issue/%ISSUE%\" );\n        // @todo Add more issue management systems here\n        // Remember to also add documentation in usage.apt.vm\n\n        // Show the current issueLinkTemplatePerSystem configuration\n        logIssueLinkTemplatePerSystem( caseInsensitiveIssueLinkTemplatePerSystem );\n\n        report.setIssueLinksPerSystem( caseInsensitiveIssueLinkTemplatePerSystem );\n\n        report.setSystem( system );\n\n        report.setTeamlist ( teamlist );\n\n        report.setUrl( url );\n\n        report.setAddActionDate( addActionDate );\n\n        if ( StringUtils.isEmpty( url ) )\n        {\n            getLog().warn( \"No issue management URL defined in POM. Links to your issues will not work correctly.\" );\n        }\n\n        report.doGenerateReport( getBundle( locale ), getSink() );\n\n        // Copy the images\n        copyStaticResources();\n    }","commit_id":"f065d3c982140bc3353666c324a7c287a2ea304c","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void constructActions( Sink sink, List actionList, ResourceBundle bundle )\n    {\n        if ( actionList.isEmpty() )\n        {\n            sink.paragraph();\n\n            sink.text( bundle.getString( \"report.changes.text.no.changes\" ) );\n\n            sink.paragraph_();\n        }\n        else\n        {\n            sink.table();\n\n            sink.tableRow();\n\n            sinkHeader( sink, bundle.getString( \"report.issues.label.type\" ) );\n\n            sinkHeader( sink, bundle.getString( \"report.issues.label.summary\" ) );\n\n            sinkHeader( sink, bundle.getString( \"report.issues.label.assignee\" ) );\n\n            if ( this.isAddActionDate() )\n            {\n                sinkHeader( sink, bundle.getString( \"report.issues.label.updated\" ) );\n            }\n            sink.tableRow_();\n\n            for ( int idx = 0; idx < actionList.size(); idx++ )\n            {\n                Action action = (Action) actionList.get( idx );\n\n                sink.tableRow();\n\n                sinkShowTypeIcon( sink, action.getType() );\n\n                sink.tableCell();\n\n                if ( escapeHTML )\n                {\n                    sink.text( action.getAction() );\n                }\n                else\n                {\n                    sink.rawText( action.getAction() );\n                }\n\n                // no null check needed classes from modello return a new ArrayList\n                if ( StringUtils.isNotEmpty( action.getIssue() ) || ( !action.getFixedIssues().isEmpty() ) )\n                {\n                    sink.text( \" \" + bundle.getString( \"report.changes.text.fixes\" ) + \" \" );\n\n                    // Try to get the issue management system specified in the changes.xml file\n                    String system = action.getSystem();\n                    // Try to get the issue management system configured in the POM\n                    if ( StringUtils.isEmpty( system ) )\n                    {\n                        system = this.system;\n                    }\n                    // Use the default issue management system\n                    if ( StringUtils.isEmpty( system ) )\n                    {\n                        system = DEFAULT_ISSUE_SYSTEM_KEY;\n                    }\n                    if ( !canGenerateIssueLinks( system ) )\n                    {\n                        constructIssueText( action.getIssue(), sink, action.getFixedIssues() );\n                    }\n                    else\n                    {\n                        constructIssueLink( action.getIssue(), system, sink, action.getFixedIssues() );\n                    }\n                    sink.text( \".\" );\n                }\n\n                if ( StringUtils.isNotEmpty( action.getDueTo() ) || ( !action.getDueTos().isEmpty() ) )\n                {\n                    constructDueTo( sink, action, bundle, action.getDueTos() );\n                }\n\n                sink.tableCell_();\n\n                if ( NO_TEAMLIST.equals( teamlist ) )\n                {\n                    sinkCell( sink, action.getDev() );\n                }\n                else\n                {\n                    sinkCellLink( sink, action.getDev(), teamlist + \"#\" + action.getDev() );\n                }\n\n                if ( this.isAddActionDate() )\n                {\n                    sinkCell( sink, action.getDate() );\n                }\n\n                sink.tableRow_();\n            }\n\n            sink.table_();\n        }\n    }","id":97069,"modified_method":"/**\n     * Constructs table row for specified action with all calculated content (e.g. issue link).\n     *\n     * @param sink Sink\n     * @param bundle Resource bundle\n     * @param action Action to generate content for\n     */\n    private void constructAction( Sink sink, ResourceBundle bundle, Action action )\n    {\n        sink.tableRow();\n\n        sinkShowTypeIcon(sink, action.getType());\n\n        sink.tableCell();\n\n        if ( escapeHTML )\n        {\n            sink.text( action.getAction() );\n        }\n        else\n        {\n            sink.rawText( action.getAction() );\n        }\n\n        // no null check needed classes from modello return a new ArrayList\n        if ( StringUtils.isNotEmpty( action.getIssue() ) || ( !action.getFixedIssues().isEmpty() ) )\n        {\n            sink.text( \" \" + bundle.getString( \"report.changes.text.fixes\" ) + \" \" );\n\n            // Try to get the issue management system specified in the changes.xml file\n            String system = action.getSystem();\n            // Try to get the issue management system configured in the POM\n            if ( StringUtils.isEmpty( system ) )\n            {\n                system = this.system;\n            }\n            // Use the default issue management system\n            if ( StringUtils.isEmpty( system ) )\n            {\n                system = DEFAULT_ISSUE_SYSTEM_KEY;\n            }\n            if ( !canGenerateIssueLinks( system ) )\n            {\n                constructIssueText( action.getIssue(), sink, action.getFixedIssues() );\n            }\n            else\n            {\n                constructIssueLink( action.getIssue(), system, sink, action.getFixedIssues() );\n            }\n            sink.text( \".\" );\n        }\n\n        if ( StringUtils.isNotEmpty( action.getDueTo() ) || ( !action.getDueTos().isEmpty() ) )\n        {\n            constructDueTo( sink, action, bundle, action.getDueTos() );\n        }\n\n        sink.tableCell_();\n\n        if ( NO_TEAMLIST.equals( teamlist ) )\n        {\n            sinkCell( sink, action.getDev() );\n        }\n        else\n        {\n            sinkCellLink( sink, action.getDev(), teamlist + \"#\" + action.getDev() );\n        }\n\n        if ( this.isAddActionDate() )\n        {\n            sinkCell( sink, action.getDate() );\n        }\n\n        sink.tableRow_();\n    }","commit_id":"f065d3c982140bc3353666c324a7c287a2ea304c","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void constructReleases( Sink sink, ResourceBundle bundle, List releaseList )\n    {\n\n        for ( int idx = 0; idx < releaseList.size(); idx++ )\n        {\n            Release release = (Release) releaseList.get( idx );\n\n            sink.section2();\n\n            final String date = ( release.getDateRelease() == null ) ? \"\" : \" - \" + release.getDateRelease();\n\n            sinkSectionTitle2Anchor( sink, bundle.getString( \"report.changes.label.release\" ) + \" \"\n                + release.getVersion() + date, release.getVersion() );\n\n            constructActions( sink, release.getActions(), bundle );\n\n            sink.section2_();\n        }\n    }","id":97070,"modified_method":"/**\n     * Constructs document sections for each of specified releases.\n     *\n     * @param sink Sink\n     * @param bundle Resource bundle\n     * @param releaseList Releases to create content for\n     */\n    private void constructReleases( Sink sink, ResourceBundle bundle, List releaseList )\n    {\n        for ( int idx = 0; idx < releaseList.size(); idx++ )\n        {\n            Release release = (Release) releaseList.get(idx);\n            constructRelease( sink, bundle, release );\n        }\n    }","commit_id":"f065d3c982140bc3353666c324a7c287a2ea304c","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Lists details for all profiles discovered.\n     *\n     * @throws MojoExecutionException if there was a <em>unexpected<\/em> build error.\n     * @throws MojoFailureException if there was an <em>expected<\/em> error leading to build failure.\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        for ( Iterator iter = projects.iterator(); iter.hasNext(); )\n        {\n            MavenProject project = (MavenProject) iter.next();\n            if ( getLog().isInfoEnabled() )\n                getLog().info( \"Listing Profiles for Project: \" + project.getId() );\n            DefaultProfileManager pm = new DefaultProfileManager( session.getContainer() );\n\n            // Obtain Profiles from external profiles.xml\n            try\n            {\n                loadProjectExternalProfiles( pm, project.getBasedir() );\n            }\n            catch ( ProfileActivationException e )\n            {\n                String error = \"Error obtaining external Profiles.\";\n                if ( getLog().isErrorEnabled() )\n                    getLog().error( error, e );\n                throw new MojoExecutionException( error, e );\n            }\n\n            // Attempt to obtain settings profiles\n            loadSettingsProfiles( pm, session.getSettings() );\n\n            // Attempt to obtain profiles from pom.xml\n            loadProjectPomProfiles( pm, project );\n\n            // now display\n            if ( null == pm.getExplicitlyActivatedIds() || pm.getExplicitlyActivatedIds().size() == 0 )\n            {\n                if ( getLog().isWarnEnabled() )\n                    getLog().warn( \"No profiles detected!\" );\n            }\n            else\n            {\n                // This feels more like a hack to filter out inactive profiles, there is no 'direct'\n                // way to query activation status on a Profile instance.\n                Map allProfilesByIds = pm.getProfilesById();\n                // active Profiles will be a subset of *all* profiles\n                List activeProfiles = project.getActiveProfiles();\n                for ( Iterator itr = activeProfiles.iterator(); itr.hasNext(); )\n                {\n                    Profile activeProfile = (Profile) itr.next();\n                    // we already have the active profiles for the project, so remove them from the list of all profiles.\n                    allProfilesByIds.remove( activeProfile.getId() );\n                }\n\n                // display active profiles\n                for ( Iterator it = activeProfiles.iterator(); it.hasNext(); )\n                {\n                    Profile p = (Profile) it.next();\n                    getLog().info( \"\\tProfile Id: \" + p.getId() + \" (Active: true , Source: \" + p.getSource() + \")\" );\n                }\n                // display inactive profiles\n                Iterator it = allProfilesByIds.keySet().iterator();\n                while ( it.hasNext() )\n                {\n                    Profile p = (Profile) allProfilesByIds.get( (String) it.next() );\n                    getLog().info( \"\\tProfile Id: \" + p.getId() + \" (Active: false , Source: \" + p.getSource() + \")\" );\n                }\n            }\n        }\n    }","id":97071,"modified_method":"/**\n     * Lists details for all profiles discovered.\n     *\n     * @throws MojoExecutionException if there was a <em>unexpected<\/em> build error.\n     * @throws MojoFailureException if there was an <em>expected<\/em> error leading to build failure.\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        StringBuffer descriptionBuffer = new StringBuffer();\n\n        for ( Iterator iter = projects.iterator(); iter.hasNext(); )\n        {\n            MavenProject project = (MavenProject) iter.next();\n\n            descriptionBuffer.append( \"Listing Profiles for Project: \" ).append( project.getId() ).append( \"\\n\" );\n\n            DefaultProfileManager pm = new DefaultProfileManager( session.getContainer() );\n\n            // Obtain Profiles from external profiles.xml\n            try\n            {\n                loadProjectExternalProfiles( pm, project.getBasedir() );\n            }\n            catch ( ProfileActivationException e )\n            {\n                String error = \"Error obtaining external Profiles.\";\n                if ( getLog().isErrorEnabled() )\n                    getLog().error( error, e );\n                throw new MojoExecutionException( error, e );\n            }\n\n            // Attempt to obtain settings profiles\n            loadSettingsProfiles( pm, session.getSettings() );\n\n            // Attempt to obtain profiles from pom.xml\n            loadProjectPomProfiles( pm, project );\n\n            // now display\n            if ( null == pm.getExplicitlyActivatedIds() || pm.getExplicitlyActivatedIds().size() == 0 )\n            {\n                if ( getLog().isWarnEnabled() )\n                    getLog().warn( \"No profiles detected!\" );\n            }\n            else\n            {\n                // This feels more like a hack to filter out inactive profiles, there is no 'direct'\n                // way to query activation status on a Profile instance.\n                Map allProfilesByIds = pm.getProfilesById();\n                // active Profiles will be a subset of *all* profiles\n                List activeProfiles = project.getActiveProfiles();\n                for ( Iterator itr = activeProfiles.iterator(); itr.hasNext(); )\n                {\n                    Profile activeProfile = (Profile) itr.next();\n                    // we already have the active profiles for the project, so remove them from the list of all profiles.\n                    allProfilesByIds.remove( activeProfile.getId() );\n                }\n\n                // display active profiles\n                for ( Iterator it = activeProfiles.iterator(); it.hasNext(); )\n                {\n                    Profile p = (Profile) it.next();\n\n                    descriptionBuffer.append( \"\\tProfile Id: \" ).append( p.getId() );\n                    descriptionBuffer.append( \" (Active: true , Source: \" ).append( p.getSource() ).append( \")\\n\" );\n                }\n                // display inactive profiles\n                Iterator it = allProfilesByIds.keySet().iterator();\n                while ( it.hasNext() )\n                {\n                    Profile p = (Profile) allProfilesByIds.get( (String) it.next() );\n\n                    descriptionBuffer.append( \"\\tProfile Id: \" ).append( p.getId() );\n                    descriptionBuffer.append(  \" (Active: false , Source: \" ).append( p.getSource() ).append( \")\\n\" );\n                }\n            }\n        }\n\n        if ( output != null )\n        {\n            try\n            {\n                writeFile( output, descriptionBuffer );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot write profiles description to output: \" + output, e );\n            }\n\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Wrote descriptions to: \" + output );\n            }\n        }\n        else\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( descriptionBuffer.toString() );\n            }\n        }\n    }","commit_id":"0c0c0ed0221778080bccf940b562f03d7acda699","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n\t * Trim the queue of persistent requests until it is just over the limit.\n\t * @param minPrio Only drop from priorities lower than this one.\n\t * @return True unless the queue is under the limit.\n\t */\n\tprivate boolean trimPersistentQueue(short prio, ObjectContainer container) {\n\t\tsynchronized(this) {\n\t\t\tint preQueueSize = 0;\n\t\t\tfor(int i=0;i<prio;i++) {\n\t\t\t\tfor(int x=0;x<persistentKeys[i].size();x++)\n\t\t\t\t\tpreQueueSize += persistentKeys[i].get(x).length;\n\t\t\t}\n\t\t\tif(preQueueSize > MAX_PERSISTENT_KEYS) {\n\t\t\t\t// Dump everything\n\t\t\t\tfor(int i=prio+1;i<persistentKeys.length;i++) {\n\t\t\t\t\twhile(!persistentKeys[i].isEmpty()) {\n\t\t\t\t\t\tint idx = persistentKeys[i].size() - 1;\n\t\t\t\t\t\tDatastoreCheckerItem item = persistentCheckerItems[i].remove(idx);\n\t\t\t\t\t\tpersistentSchedulers[i].remove(idx);\n\t\t\t\t\t\tpersistentDontCache[i].remove(idx);\n\t\t\t\t\t\tpersistentGetters[i].remove(idx);\n\t\t\t\t\t\tpersistentKeys[i].remove(idx);\n\t\t\t\t\t\tpersistentBlockSets[i].remove(idx);\n\t\t\t\t\t\titem.chosenBy = 0;\n\t\t\t\t\t\tcontainer.store(item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tint postQueueSize = 0;\n\t\t\t\tfor(int i=prio+1;i<persistentKeys.length;i++) {\n\t\t\t\t\tfor(int x=0;x<persistentKeys[i].size();x++)\n\t\t\t\t\t\tpostQueueSize += persistentKeys[i].get(x).length;\n\t\t\t\t}\n\t\t\t\tif(postQueueSize + preQueueSize < MAX_PERSISTENT_KEYS)\n\t\t\t\t\treturn false;\n\t\t\t\t// Need to dump some stuff.\n\t\t\t\tfor(int i=persistentKeys.length-1;i>prio;i--) {\n\t\t\t\t\twhile(!persistentKeys[i].isEmpty()) {\n\t\t\t\t\t\tint idx = persistentKeys[i].size() - 1;\n\t\t\t\t\t\tDatastoreCheckerItem item = persistentCheckerItems[i].remove(idx);\n\t\t\t\t\t\tpersistentSchedulers[i].remove(idx);\n\t\t\t\t\t\tpersistentDontCache[i].remove(idx);\n\t\t\t\t\t\tpersistentGetters[i].remove(idx);\n\t\t\t\t\t\tKey[] keys = persistentKeys[i].remove(idx);\n\t\t\t\t\t\tpersistentBlockSets[i].remove(idx);\n\t\t\t\t\t\titem.chosenBy = 0;\n\t\t\t\t\t\tcontainer.store(item);\n\t\t\t\t\t\tif(postQueueSize + preQueueSize - keys.length < MAX_PERSISTENT_KEYS) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Still over the limit.\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}","id":97072,"modified_method":"/**\n\t * Trim the queue of persistent requests until it is just over the limit.\n\t * @param minPrio Only drop from priorities lower than this one.\n\t * @return True unless the queue is under the limit.\n\t */\n\tprivate boolean trimPersistentQueue(short prio, ObjectContainer container) {\n\t\tsynchronized(this) {\n\t\t\tint preQueueSize = 0;\n\t\t\tfor(int i=0;i<prio;i++) {\n\t\t\t\tfor(int x=0;x<persistentKeys[i].size();x++)\n\t\t\t\t\tpreQueueSize += persistentKeys[i].get(x).length;\n\t\t\t}\n\t\t\tif(preQueueSize > MAX_PERSISTENT_KEYS) {\n\t\t\t\t// Dump everything\n\t\t\t\tfor(int i=prio+1;i<persistentKeys.length;i++) {\n\t\t\t\t\tfor(DatastoreCheckerItem item : persistentCheckerItems[i]) {\n\t\t\t\t\t\titem.chosenBy = 0;\n\t\t\t\t\t\tcontainer.store(item);\n\t\t\t\t\t}\n\t\t\t\t\tpersistentSchedulers[i].clear();\n\t\t\t\t\tpersistentDontCache[i].clear();\n\t\t\t\t\tpersistentGetters[i].clear();\n\t\t\t\t\tpersistentKeys[i].clear();\n\t\t\t\t\tpersistentBlockSets[i].clear();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tint postQueueSize = 0;\n\t\t\t\tfor(int i=prio+1;i<persistentKeys.length;i++) {\n\t\t\t\t\tfor(int x=0;x<persistentKeys[i].size();x++)\n\t\t\t\t\t\tpostQueueSize += persistentKeys[i].get(x).length;\n\t\t\t\t}\n\t\t\t\tif(postQueueSize + preQueueSize < MAX_PERSISTENT_KEYS)\n\t\t\t\t\treturn false;\n\t\t\t\t// Need to dump some stuff.\n\t\t\t\tfor(int i=persistentKeys.length-1;i>prio;i--) {\n\t\t\t\t\twhile(!persistentKeys[i].isEmpty()) {\n\t\t\t\t\t\tint idx = persistentKeys[i].size() - 1;\n\t\t\t\t\t\tDatastoreCheckerItem item = persistentCheckerItems[i].remove(idx);\n\t\t\t\t\t\tpersistentSchedulers[i].remove(idx);\n\t\t\t\t\t\tpersistentDontCache[i].remove(idx);\n\t\t\t\t\t\tpersistentGetters[i].remove(idx);\n\t\t\t\t\t\tKey[] keys = persistentKeys[i].remove(idx);\n\t\t\t\t\t\tpersistentBlockSets[i].remove(idx);\n\t\t\t\t\t\titem.chosenBy = 0;\n\t\t\t\t\t\tcontainer.store(item);\n\t\t\t\t\t\tif(postQueueSize + preQueueSize - keys.length < MAX_PERSISTENT_KEYS) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Still over the limit.\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}","commit_id":"7c5ab79d3a8d77f25af892d02c2776d4c0512df1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Will be triggered when starting to undo.<p>\n     */\n    public void onFirstUndo() {\n\n        m_toolbar.getRedoButton().setEnabled(true);\n    }","id":97073,"modified_method":"/**\n     * Will be triggered when starting to undo.<p>\n     */\n    public void onFirstUndo() {\n\n        m_toolbar.getRedoButton().enable();\n    }","commit_id":"294b1aec68c4aa9d61ee99a5c07e490e4d735179","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Will be triggered when the sitemap is changed in anyway for the first time.<p> \n     */\n    public void onStartEdit() {\n\n        m_toolbar.getSaveButton().setEnabled(true);\n        m_toolbar.getResetButton().setEnabled(true);\n        m_toolbar.getUndoButton().setEnabled(true);\n    }","id":97074,"modified_method":"/**\n     * Will be triggered when the sitemap is changed in anyway for the first time.<p> \n     */\n    public void onStartEdit() {\n\n        m_toolbar.getSaveButton().enable();\n        m_toolbar.getResetButton().enable();\n        m_toolbar.getUndoButton().enable();\n    }","commit_id":"294b1aec68c4aa9d61ee99a5c07e490e4d735179","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Will be triggered on reset.<p>\n     */\n    public void onReset() {\n\n        m_toolbar.getSaveButton().setEnabled(false);\n        m_toolbar.getResetButton().setEnabled(false);\n        m_toolbar.getUndoButton().setEnabled(false);\n    }","id":97075,"modified_method":"/**\n     * Will be triggered on reset.<p>\n     */\n    public void onReset() {\n\n        m_toolbar.getSaveButton().disable(Messages.get().key(Messages.GUI_DISABLED_SAVE_0));\n        m_toolbar.getResetButton().disable(Messages.get().key(Messages.GUI_DISABLED_RESET_0));\n        m_toolbar.getUndoButton().disable(Messages.get().key(Messages.GUI_DISABLED_UNDO_0));\n    }","commit_id":"294b1aec68c4aa9d61ee99a5c07e490e4d735179","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Will be triggered when undoing the last possible action.<p>\n     */\n    public void onLastUndo() {\n\n        m_toolbar.getSaveButton().setEnabled(false);\n        m_toolbar.getResetButton().setEnabled(false);\n        m_toolbar.getUndoButton().setEnabled(false);\n    }","id":97076,"modified_method":"/**\n     * Will be triggered when undoing the last possible action.<p>\n     */\n    public void onLastUndo() {\n\n        m_toolbar.getSaveButton().disable(Messages.get().key(Messages.GUI_DISABLED_SAVE_0));\n        m_toolbar.getResetButton().disable(Messages.get().key(Messages.GUI_DISABLED_RESET_0));\n        m_toolbar.getUndoButton().disable(Messages.get().key(Messages.GUI_DISABLED_UNDO_0));\n    }","commit_id":"294b1aec68c4aa9d61ee99a5c07e490e4d735179","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Will be triggered when redoing the last possible action.<p>\n     */\n    public void onLastRedo() {\n\n        m_toolbar.getRedoButton().setEnabled(false);\n    }","id":97077,"modified_method":"/**\n     * Will be triggered when redoing the last possible action.<p>\n     */\n    public void onLastRedo() {\n\n        m_toolbar.getRedoButton().disable(Messages.get().key(Messages.GUI_DISABLED_REDO_0));\n    }","commit_id":"294b1aec68c4aa9d61ee99a5c07e490e4d735179","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Will be triggered when the undo list is cleared.<p> \n     */\n    public void onClearUndo() {\n\n        m_toolbar.getRedoButton().setEnabled(false);\n    }","id":97078,"modified_method":"/**\n     * Will be triggered when the undo list is cleared.<p> \n     */\n    public void onClearUndo() {\n\n        m_toolbar.getRedoButton().disable(Messages.get().key(Messages.GUI_DISABLED_REDO_0));\n    }","commit_id":"294b1aec68c4aa9d61ee99a5c07e490e4d735179","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Deattaches the hoverbar.<p>\n     */\n    protected void deattach() {\n\n        getDeleteButton().setEnabled(true);\n        getMoveButton().setEnabled(true);\n        getSubsitemapButton().setEnabled(true);\n        getEditButton().setEnabled(true);\n        getParentSitemapButton().setVisible(false);\n        getElement().removeFromParent();\n        onDetach();\n    }","id":97079,"modified_method":"/**\n     * Deattaches the hoverbar.<p>\n     */\n    protected void deattach() {\n\n        getDeleteButton().enable();\n        getMoveButton().enable();\n        getSubsitemapButton().enable();\n        getEditButton().enable();\n        getParentSitemapButton().setVisible(false);\n        getElement().removeFromParent();\n        onDetach();\n    }","commit_id":"294b1aec68c4aa9d61ee99a5c07e490e4d735179","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Installs this hoverbar for the given item widget.<p>\n     * \n     * @param controller the controller \n     * @param itemWidget the item widget to hover\n     */\n    public void installOn(final CmsSitemapController controller, final CmsListItemWidget itemWidget) {\n\n        A_CmsHoverHandler handler = new A_CmsHoverHandler() {\n\n            /**\n             * @see org.opencms.gwt.client.ui.A_CmsHoverHandler#onHoverIn(com.google.gwt.event.dom.client.MouseOverEvent)\n             */\n            @SuppressWarnings(\"synthetic-access\")\n            @Override\n            protected void onHoverIn(MouseOverEvent event) {\n\n                itemWidget.getContentPanel().getElement().appendChild(getElement());\n                if (controller.isRoot(getSitePath())) {\n                    getDeleteButton().setEnabled(false);\n                    getMoveButton().setEnabled(false);\n                    getSubsitemapButton().setEnabled(false);\n                    if (CmsSitemapProvider.get().getParent() != null) {\n                        getParentSitemapButton().setVisible(true);\n                        getEditButton().setEnabled(false);\n                    }\n                }\n                onAttach();\n            }\n\n            /**\n             * @see org.opencms.gwt.client.ui.A_CmsHoverHandler#onHoverOut(com.google.gwt.event.dom.client.MouseOutEvent)\n             */\n            @Override\n            protected void onHoverOut(MouseOutEvent event) {\n\n                deattach();\n            }\n\n        };\n        itemWidget.addMouseOutHandler(handler);\n        itemWidget.addMouseOverHandler(handler);\n    }","id":97080,"modified_method":"/**\n     * Installs this hoverbar for the given item widget.<p>\n     * \n     * @param controller the controller \n     * @param itemWidget the item widget to hover\n     */\n    public void installOn(final CmsSitemapController controller, final CmsListItemWidget itemWidget) {\n\n        A_CmsHoverHandler handler = new A_CmsHoverHandler() {\n\n            /**\n             * @see org.opencms.gwt.client.ui.A_CmsHoverHandler#onHoverIn(com.google.gwt.event.dom.client.MouseOverEvent)\n             */\n            @SuppressWarnings(\"synthetic-access\")\n            @Override\n            protected void onHoverIn(MouseOverEvent event) {\n\n                itemWidget.getContentPanel().getElement().appendChild(getElement());\n                if (controller.isRoot(getSitePath())) {\n                    getDeleteButton().disable(Messages.get().key(Messages.GUI_DISABLED_ROOT_ITEM_0));\n                    getMoveButton().disable(Messages.get().key(Messages.GUI_DISABLED_ROOT_ITEM_0));\n                    getSubsitemapButton().disable(Messages.get().key(Messages.GUI_DISABLED_ROOT_ITEM_0));\n                    if (CmsSitemapProvider.get().getParent() != null) {\n                        getParentSitemapButton().setVisible(true);\n                        getEditButton().disable(Messages.get().key(Messages.GUI_DISABLED_PARENT_SITEMAP_0));\n                    }\n                }\n                onAttach();\n            }\n\n            /**\n             * @see org.opencms.gwt.client.ui.A_CmsHoverHandler#onHoverOut(com.google.gwt.event.dom.client.MouseOutEvent)\n             */\n            @Override\n            protected void onHoverOut(MouseOutEvent event) {\n\n                deattach();\n            }\n\n        };\n        itemWidget.addMouseOutHandler(handler);\n        itemWidget.addMouseOverHandler(handler);\n    }","commit_id":"294b1aec68c4aa9d61ee99a5c07e490e4d735179","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void executeShell(Result result, List cmdRows, String[] args)\n    {\n        LogWriter log = LogWriter.getInstance();\n        \n        try\n        {\n            // What's the exact command?\n            String cmd[] = null;\n            String base[] = null;\n            \n            \n            log.logBasic(toString(), \"Running on platform : \"+Const.getOS());\n            \n            if( Const.getOS().equals( \"Windows 95\" ) )\n            {\n                base = new String[] { \"command.com\", \"/C\", getFileName() };\n            }\n            else\n            if( Const.getOS().startsWith( \"Windows\" ) )\n            {\n                base = new String[] { \"cmd.exe\", \"/C\", getFileName() };\n            }\n            else \n            {\n                base = new String[] { getFileName() };\n            }\n    \n            // Construct the arguments...\n            if (argFromPrevious && cmdRows!=null)\n            {\n                ArrayList cmds = new ArrayList();\n                \n                // Add the base command...\n                for (int i=0;i<base.length;i++) cmds.add(base[i]);\n    \n                // Add the arguments from previous results...\n                for (int i=0;i<cmdRows.size();i++) // Normally just one row, but once in a while to remain compatible we have multiple. \n                {\n                    Row r = (Row)cmdRows.get(i);\n                    for (int j=0;j<r.size();j++)\n                    {\n                        cmds.add(r.getValue(j).getString());\n                    }\n                } \n                cmd = (String[]) cmds.toArray(new String[cmds.size()]);\n            }\n            else\n            if (args!=null)\n            {\n                ArrayList cmds = new ArrayList();\n    \n                // Add the base command...\n                for (int i=0;i<base.length;i++) cmds.add(base[i]);\n    \n                for (int i=0;i<args.length;i++) \n                {\n                    cmds.add(args[i]);\n                } \n                cmd = (String[]) cmds.toArray(new String[cmds.size()]);\n            }\n            \n            if (log.isBasic())\n            {\n                StringBuffer command = new StringBuffer();\n                for (int i=0;i<cmd.length;i++)\n                {\n                    if (i>0) command.append(\" \");\n                    command.append(cmd[i]);\n                }\n                log.logBasic(toString(), \"Executing command : \"+command.toString());\n            }\n             \n            // Launch the script!\n            log.logDetailed(toString(), \"Passing \"+(cmd.length-1)+\" arguments to command : [\"+cmd[0]+\"]\");\n\n            // Build the environment variable list...\n            Runtime runtime = java.lang.Runtime.getRuntime();\n            Process proc = runtime.exec(cmd,  \n                    EnvUtil.getEnvironmentVariablesForRuntimeExec());\n            \n            // any error message?\n            StreamLogger errorLogger = new\n                StreamLogger(proc.getErrorStream(), toString()+\" (stderr)\");            \n            \n            // any output?\n            StreamLogger outputLogger = new\n                StreamLogger(proc.getInputStream(), toString()+\" (stdout)\");\n                \n            // kick them off\n            new Thread(errorLogger).start();\n            new Thread(outputLogger).start();\n                                    \n            proc.waitFor();\n            log.logDetailed(toString(), \"command [\"+cmd[0]+\"] has finished\");\n            \n            // What's the exit status?\n            result.setExitStatus( proc.exitValue() );\n            if (result.getExitStatus()!=0) \n            {\n                log.logDetailed(toString(), \"Exit status of shell [\"+getFileName()+\"] was \"+result.getExitStatus());\n                result.setNrErrors(1);\n            } \n        }\n        catch(IOException ioe)\n        {\n            log.logError(toString(), \"Error running shell [\"+getFileName()+\"] : \"+ioe.toString());\n            result.setNrErrors(1);\n        }\n        catch(InterruptedException ie)\n        {\n            log.logError(toString(), \"Shell [\"+getFileName()+\"] was interupted : \"+ie.toString());\n            result.setNrErrors(1);\n        }\n        catch(Exception e)\n        {\n            log.logError(toString(), \"Unexpected error running shell [\"+getFileName()+\"] : \"+e.toString());\n            result.setNrErrors(1);\n        }\n    \n        if (result.getNrErrors() > 0)\n        {\n            result.setResult( false );\n        }\n        else\n        {\n            result.setResult( true );\n        }\n\n    }","id":97081,"modified_method":"private void executeShell(Result result, List cmdRows, String[] args)\n    {\n        LogWriter log = LogWriter.getInstance();\n        \n        try\n        {\n            // What's the exact command?\n            String cmd[] = null;\n            String base[] = null;\n            \n            \n            log.logBasic(toString(), \"Running on platform : \"+Const.getOS());\n            \n            if( Const.getOS().equals( \"Windows 95\" ) )\n            {\n                base = new String[] { \"command.com\", \"/C\", StringUtil.environmentSubstitute(getFileName()) };\n            }\n            else\n            if( Const.getOS().startsWith( \"Windows\" ) )\n            {\n                base = new String[] { \"cmd.exe\", \"/C\", StringUtil.environmentSubstitute(getFileName()) };\n            }\n            else \n            {\n                base = new String[] { StringUtil.environmentSubstitute(getFileName()) };\n            }\n    \n            // Construct the arguments...\n            if (argFromPrevious && cmdRows!=null)\n            {\n                ArrayList cmds = new ArrayList();\n                \n                // Add the base command...\n                for (int i=0;i<base.length;i++) cmds.add(base[i]);\n    \n                // Add the arguments from previous results...\n                for (int i=0;i<cmdRows.size();i++) // Normally just one row, but once in a while to remain compatible we have multiple. \n                {\n                    Row r = (Row)cmdRows.get(i);\n                    for (int j=0;j<r.size();j++)\n                    {\n                        cmds.add(r.getValue(j).getString());\n                    }\n                } \n                cmd = (String[]) cmds.toArray(new String[cmds.size()]);\n            }\n            else\n            if (args!=null)\n            {\n                ArrayList cmds = new ArrayList();\n    \n                // Add the base command...\n                for (int i=0;i<base.length;i++) cmds.add(base[i]);\n    \n                for (int i=0;i<args.length;i++) \n                {\n                    cmds.add(args[i]);\n                } \n                cmd = (String[]) cmds.toArray(new String[cmds.size()]);\n            }\n            \n            if (log.isBasic())\n            {\n                StringBuffer command = new StringBuffer();\n                for (int i=0;i<cmd.length;i++)\n                {\n                    if (i>0) command.append(\" \");\n                    command.append(cmd[i]);\n                }\n                log.logBasic(toString(), \"Executing command : \"+command.toString());\n            }\n             \n            // Launch the script!\n            log.logDetailed(toString(), \"Passing \"+(cmd.length-1)+\" arguments to command : [\"+cmd[0]+\"]\");\n\n            // Build the environment variable list...\n            Runtime runtime = java.lang.Runtime.getRuntime();\n            Process proc = runtime.exec(cmd,  \n                    EnvUtil.getEnvironmentVariablesForRuntimeExec());\n            \n            // any error message?\n            StreamLogger errorLogger = new\n                StreamLogger(proc.getErrorStream(), toString()+\" (stderr)\");            \n            \n            // any output?\n            StreamLogger outputLogger = new\n                StreamLogger(proc.getInputStream(), toString()+\" (stdout)\");\n                \n            // kick them off\n            new Thread(errorLogger).start();\n            new Thread(outputLogger).start();\n                                    \n            proc.waitFor();\n            log.logDetailed(toString(), \"command [\"+cmd[0]+\"] has finished\");\n            \n            // What's the exit status?\n            result.setExitStatus( proc.exitValue() );\n            if (result.getExitStatus()!=0) \n            {\n                log.logDetailed(toString(), \"Exit status of shell [\"+StringUtil.environmentSubstitute(getFileName())+\"] was \"+result.getExitStatus());\n                result.setNrErrors(1);\n            } \n        }\n        catch(IOException ioe)\n        {\n            log.logError(toString(), \"Error running shell [\"+StringUtil.environmentSubstitute(getFileName())+\"] : \"+ioe.toString());\n            result.setNrErrors(1);\n        }\n        catch(InterruptedException ie)\n        {\n            log.logError(toString(), \"Shell [\"+StringUtil.environmentSubstitute(getFileName())+\"] was interupted : \"+ie.toString());\n            result.setNrErrors(1);\n        }\n        catch(Exception e)\n        {\n            log.logError(toString(), \"Unexpected error running shell [\"+StringUtil.environmentSubstitute(getFileName())+\"] : \"+e.toString());\n            result.setNrErrors(1);\n        }\n    \n        if (result.getNrErrors() > 0)\n        {\n            result.setResult( false );\n        }\n        else\n        {\n            result.setResult( true );\n        }\n\n    }","commit_id":"36bfeb5ec06eb1ff87ad06cb264fd7426d540fd8","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * Adds an element node to the storage.\n   *\n   * @param nm tag name\n   * @param att attributes\n   * @throws IOException I/O exception\n   */\n  private void addElem(final byte[] nm, final Atts att) throws IOException {\n    // get tag reference\n    int n = tags.index(nm, null, true);\n\n    path.index(n, Data.ELEM, level);\n\n    // cache pre value\n    final int pre = meta.size;\n    // remember tag id and parent reference\n    tstack.set(level, n);\n    pstack.set(level, pre);\n\n    // get and store element references\n    final int dis = level != 0 ? pre - pstack.get(level - 1) : 1;\n    final int as = att.size();\n    final boolean ne = ns.open();\n    int u = ns.uri(nm, true);\n    addElem(dis, n, Math.min(IO.MAXATTS, as + 1), u, ne);\n\n    // get and store attribute references\n    for(int a = 0; a < as; ++a) {\n      n = atts.index(att.name(a), att.string(a), true);\n      u = ns.uri(att.name(a), false);\n      path.index(n, Data.ATTR, level + 1, att.string(a), meta);\n      addAttr(n, att.string(a), Math.min(IO.MAXATTS, a + 1), u);\n    }\n\n    // set leaf node information in index\n    if(level > 1) tags.stat(tstack.get(level - 1)).setLeaf(false);\n\n    // check if data ranges exceed database limits,\n    // based on the storage details in {@link Data}\n    limit(tags.size(), 0x8000, LIMITTAGS);\n    limit(atts.size(), 0x8000, LIMITATTS);\n    limit(ns.size(), 0x100, LIMITNS);\n    if(meta.size < 0) limit(0, 0, LIMITRANGE);\n  }","id":97082,"modified_method":"/**\n   * Adds an element node to the storage.\n   * @param nm element name\n   * @param att attributes\n   * @throws IOException I/O exception\n   */\n  private void addElem(final byte[] nm, final Atts att) throws IOException {\n    // get tag reference\n    int n = tags.index(nm, null, true);\n\n    path.index(n, Data.ELEM, level);\n\n    // cache pre value\n    final int pre = meta.size;\n    // remember tag id and parent reference\n    tstack.set(level, n);\n    pstack.set(level, pre);\n\n    // get and store element references\n    final int dis = level != 0 ? pre - pstack.get(level - 1) : 1;\n    final int as = att.size();\n    final boolean ne = ns.open();\n    int u = ns.uri(nm, true);\n    addElem(dis, n, Math.min(IO.MAXATTS, as + 1), u, ne);\n\n    // get and store attribute references\n    for(int a = 0; a < as; ++a) {\n      final byte[] av = att.string(a);\n      final byte[] an = att.name(a);\n      n = atts.index(an, av, true);\n      u = ns.uri(an, false);\n      path.index(n, Data.ATTR, level + 1, av, meta);\n      addAttr(n, av, Math.min(IO.MAXATTS, a + 1), u);\n    }\n\n    // set leaf node information in index\n    if(level > 1) tags.stat(tstack.get(level - 1)).setLeaf(false);\n\n    // check if data ranges exceed database limits,\n    // based on the storage details in {@link Data}\n    limit(tags.size(), 0x8000, LIMITTAGS);\n    limit(atts.size(), 0x8000, LIMITATTS);\n    limit(ns.size(), 0x100, LIMITNS);\n    if(meta.size < 0) limit(0, 0, LIMITRANGE);\n  }","commit_id":"bad60c514bcb318d3331b1a868d6913fbd48f63d","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void parse(final Builder builder) throws IOException {\n    builder.startDoc(token(filename));\n\n    final Stack<NodeIterator> stack = new Stack<NodeIterator>();\n    stack.push(new NodeIterator(root));\n\n    while(!stack.empty()) {\n      final NodeIterator ni = stack.peek();\n      if(ni.more()) {\n        final Node n = ni.curr();\n        if(n instanceof Element) {\n          stack.push(new NodeIterator(n));\n\n          atts.reset();\n          final NamedNodeMap at = n.getAttributes();\n          for(int a = 0, as = at.getLength(); a < as; ++a) {\n            final Attr att = (Attr) at.item(a);\n            final byte[] k = token(att.getName()), v = token(att.getValue());\n            if(eq(k, XMLNS)) {\n              builder.startNS(EMPTY, v);\n            } else if(startsWith(k, XMLNSC)) {\n              builder.startNS(local(k), v);\n            } else {\n              atts.add(k, v);\n            }\n          }\n          builder.startElem(token(n.getNodeName()), atts);\n        } else if(n instanceof Text) {\n          final String s = n.getNodeValue();\n          builder.text(token(chop ? s.trim() : s));\n        } else if(n instanceof Comment) {\n          builder.comment(token(n.getNodeValue()));\n        } else if(n instanceof ProcessingInstruction) {\n          builder.pi(token(n.getNodeName() + ' ' + n.getNodeValue()));\n        }\n        ++nodes;\n      } else {\n        stack.pop();\n        if(stack.empty()) break;\n        builder.endElem();\n      }\n    }\n    builder.endDoc();\n  }","id":97083,"modified_method":"@Override\n  public void parse(final Builder builder) throws IOException {\n    builder.startDoc(token(filename));\n\n    final Stack<NodeIterator> stack = new Stack<NodeIterator>();\n    stack.push(new NodeIterator(root));\n\n    while(!stack.empty()) {\n      final NodeIterator ni = stack.peek();\n      if(ni.more()) {\n        final Node n = ni.curr();\n        if(n instanceof Element) {\n          stack.push(new NodeIterator(n));\n\n          atts.reset();\n          final NamedNodeMap at = n.getAttributes();\n          for(int a = 0, as = at.getLength(); a < as; ++a) {\n            final Attr att = (Attr) at.item(a);\n            final byte[] an = token(att.getName());\n            final byte[] av = token(att.getValue());\n            if(eq(an, XMLNS)) {\n              if(!stripNS) builder.startNS(EMPTY, av);\n            } else if(startsWith(an, XMLNSC)) {\n              if(!stripNS) builder.startNS(local(an), av);\n            } else {\n              atts.add(stripNS ? local(an) : an, av);\n            }\n          }\n          final byte[] en = token(n.getNodeName());\n          builder.startElem(stripNS ? local(en) : en, atts);\n        } else if(n instanceof Text) {\n          final String s = n.getNodeValue();\n          builder.text(token(chop ? s.trim() : s));\n        } else if(n instanceof Comment) {\n          builder.comment(token(n.getNodeValue()));\n        } else if(n instanceof ProcessingInstruction) {\n          builder.pi(token(n.getNodeName() + ' ' + n.getNodeValue()));\n        }\n        ++nodes;\n      } else {\n        stack.pop();\n        if(stack.empty()) break;\n        builder.endElem();\n      }\n    }\n    builder.endDoc();\n  }","commit_id":"bad60c514bcb318d3331b1a868d6913fbd48f63d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param doc document instance\n   * @param fn filename\n   * @param pr database properties\n   */\n  public DOMWrapper(final Document doc, final String fn, final Prop pr) {\n    super(fn, pr);\n    root = doc;\n    filename = fn;\n    chop = pr.is(Prop.CHOP);\n  }","id":97084,"modified_method":"/**\n   * Constructor.\n   * @param doc document instance\n   * @param fn filename\n   * @param pr database properties\n   */\n  public DOMWrapper(final Document doc, final String fn, final Prop pr) {\n    super(fn, pr);\n    root = doc;\n    filename = fn;\n    chop = pr.is(Prop.CHOP);\n    stripNS = pr.is(Prop.STRIPNS);\n  }","commit_id":"bad60c514bcb318d3331b1a868d6913fbd48f63d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Default constructor.\n   * @param d dialog reference\n   * @param t tabs\n   */\n  public DialogParsing(final BaseXDialog d, final BaseXTabs t) {\n    main = new BaseXBack(new TableLayout(2, 1)).border(8);\n    gui = d.gui;\n    tabs = t;\n\n    label = new BaseXLabel(\" \").border(0, 0, 12, 0).large();\n\n    final Prop prop = gui.context.prop;\n    try {\n      props = new ParserProp(prop.get(Prop.PARSEROPT));\n    } catch(final IOException ex) {\n      props = new ParserProp();\n    }\n\n    intparse = new BaseXCheckBox(INT_PARSER, prop.is(Prop.INTPARSE), 0, d);\n    dtd = new BaseXCheckBox(PARSE_DTDS, prop.is(Prop.DTD), 0, d);\n    chop = new BaseXCheckBox(CHOP_WS, prop.is(Prop.CHOP), 0, d);\n    cfile = new BaseXTextField(prop.get(Prop.CATFILE), d);\n    browsec = new BaseXButton(BROWSE_D, d);\n    usecat = new BaseXCheckBox(USE_CATALOG_FILE, !prop.get(Prop.CATFILE).isEmpty(), 0, d);\n\n    jsonml = new BaseXCheckBox(PARSE_AS_JSONML, props.is(ParserProp.JSONML), 0, d);\n\n    params = new BaseXTextField(prop.get(Prop.HTMLOPT), d);\n\n    lines = new BaseXCheckBox(SPLIT_INPUT_LINES, props.is(ParserProp.LINES), 0, d);\n    header = new BaseXCheckBox(FIRST_LINE_HEADER, props.is(ParserProp.HEADER), 0, d);\n\n    separator = new BaseXBack().layout(new TableLayout(1, 2, 6, 0));\n    final StringList sl = new StringList();\n    sl.add(CSVParser.SEPARATORS).add(\"\");\n    sepcombo = new BaseXCombo(d, sl.toArray());\n    separator.add(sepcombo);\n\n    String f = \"\";\n    final String s = props.get(ParserProp.SEPARATOR);\n    if(Token.eq(s, CSVParser.SEPARATORS)) {\n      sepcombo.setSelectedItem(s);\n    } else {\n      sepcombo.setSelectedIndex(CSVParser.SEPARATORS.length);\n      final int ch = Token.toInt(s);\n      f = ch > 0 ? String.valueOf((char) ch) : \"\";\n    }\n    sepchar = new BaseXTextField(f, d);\n    separator.add(sepchar);\n    BaseXLayout.setWidth(sepchar, 35);\n\n    format = new BaseXCombo(d, CSVParser.FORMATS);\n    format.setSelectedItem(props.get(ParserProp.FORMAT));\n\n    final String enc = props.get(ParserProp.ENCODING);\n    cencoding = DialogExport.encoding(d, enc);\n    tencoding = DialogExport.encoding(d, enc);\n    jencoding = DialogExport.encoding(d, enc);\n\n    xmlopts  = new BaseXBack(new TableLayout(8, 1));\n    htmlopts = new BaseXBack(new TableLayout(2, 1));\n    jsonopts = new BaseXBack(new TableLayout(2, 1));\n    csvopts  = new BaseXBack(new TableLayout(2, 1));\n    textopts = new BaseXBack(new TableLayout(2, 1));\n    createOptionsPanels();\n\n    setLayout(new TableLayout(1, 1));\n    add(main);\n  }","id":97085,"modified_method":"/**\n   * Default constructor.\n   * @param d dialog reference\n   * @param t tabs\n   */\n  public DialogParsing(final BaseXDialog d, final BaseXTabs t) {\n    main = new BaseXBack(new TableLayout(2, 1)).border(8);\n    gui = d.gui;\n    tabs = t;\n\n    label = new BaseXLabel(\" \").border(0, 0, 12, 0).large();\n\n    final Prop prop = gui.context.prop;\n    try {\n      props = new ParserProp(prop.get(Prop.PARSEROPT));\n    } catch(final IOException ex) {\n      props = new ParserProp();\n    }\n\n    intparse = new BaseXCheckBox(INT_PARSER, prop.is(Prop.INTPARSE), 0, d);\n    dtd = new BaseXCheckBox(PARSE_DTDS, prop.is(Prop.DTD), 0, d);\n    chopWS = new BaseXCheckBox(CHOP_WS, prop.is(Prop.CHOP), 0, d);\n    stripNS = new BaseXCheckBox(STRIP_NS, prop.is(Prop.STRIPNS), 0, d);\n    cfile = new BaseXTextField(prop.get(Prop.CATFILE), d);\n    browsec = new BaseXButton(BROWSE_D, d);\n    usecat = new BaseXCheckBox(USE_CATALOG_FILE, !prop.get(Prop.CATFILE).isEmpty(), 0, d);\n\n    jsonml = new BaseXCheckBox(PARSE_AS_JSONML, props.is(ParserProp.JSONML), 0, d);\n\n    params = new BaseXTextField(prop.get(Prop.HTMLOPT), d);\n\n    lines = new BaseXCheckBox(SPLIT_INPUT_LINES, props.is(ParserProp.LINES), 0, d);\n    header = new BaseXCheckBox(FIRST_LINE_HEADER, props.is(ParserProp.HEADER), 0, d);\n\n    separator = new BaseXBack().layout(new TableLayout(1, 2, 6, 0));\n    final StringList sl = new StringList();\n    sl.add(CSVParser.SEPARATORS).add(\"\");\n    sepcombo = new BaseXCombo(d, sl.toArray());\n    separator.add(sepcombo);\n\n    String f = \"\";\n    final String s = props.get(ParserProp.SEPARATOR);\n    if(Token.eq(s, CSVParser.SEPARATORS)) {\n      sepcombo.setSelectedItem(s);\n    } else {\n      sepcombo.setSelectedIndex(CSVParser.SEPARATORS.length);\n      final int ch = Token.toInt(s);\n      f = ch > 0 ? String.valueOf((char) ch) : \"\";\n    }\n    sepchar = new BaseXTextField(f, d);\n    separator.add(sepchar);\n    BaseXLayout.setWidth(sepchar, 35);\n\n    format = new BaseXCombo(d, CSVParser.FORMATS);\n    format.setSelectedItem(props.get(ParserProp.FORMAT));\n\n    final String enc = props.get(ParserProp.ENCODING);\n    cencoding = DialogExport.encoding(d, enc);\n    tencoding = DialogExport.encoding(d, enc);\n    jencoding = DialogExport.encoding(d, enc);\n\n    xmlopts  = new BaseXBack(new TableLayout(9, 1));\n    htmlopts = new BaseXBack(new TableLayout(2, 1));\n    jsonopts = new BaseXBack(new TableLayout(2, 1));\n    csvopts  = new BaseXBack(new TableLayout(2, 1));\n    textopts = new BaseXBack(new TableLayout(2, 1));\n    createOptionsPanels();\n\n    setLayout(new TableLayout(1, 1));\n    add(main);\n  }","commit_id":"bad60c514bcb318d3331b1a868d6913fbd48f63d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Sets the parsing options.\n   * @param type parsing type\n   */\n  public void setOptions(final String type) {\n    final BaseXCombo cb = type.equals(DataText.M_TEXT) ? tencoding :\n      type.equals(DataText.M_JSON) ? jencoding : cencoding;\n    props.set(ParserProp.ENCODING, cb.getSelectedItem().toString());\n    props.set(ParserProp.FORMAT, format.getSelectedItem().toString());\n    props.set(ParserProp.HEADER, header.isSelected());\n    props.set(ParserProp.LINES, lines.isSelected());\n    props.set(ParserProp.JSONML, jsonml.isSelected());\n    props.set(ParserProp.SEPARATOR, sepcombo.getSelectedIndex() <\n      CSVParser.SEPARATORS.length ? sepcombo.getSelectedItem().toString() :\n      String.valueOf((int) sepchar.getText().charAt(0)));\n\n    gui.set(Prop.PARSER, type);\n    gui.set(Prop.PARSEROPT, props.toString());\n    gui.set(Prop.CHOP, chop.isSelected());\n    gui.set(Prop.DTD, dtd.isSelected());\n    gui.set(Prop.INTPARSE, intparse.isSelected());\n    gui.set(Prop.CATFILE, usecat.isSelected() ? cfile.getText() : \"\");\n    gui.set(Prop.HTMLOPT, params.getText());\n  }","id":97086,"modified_method":"/**\n   * Sets the parsing options.\n   * @param type parsing type\n   */\n  public void setOptions(final String type) {\n    final BaseXCombo cb = type.equals(DataText.M_TEXT) ? tencoding :\n      type.equals(DataText.M_JSON) ? jencoding : cencoding;\n    props.set(ParserProp.ENCODING, cb.getSelectedItem().toString());\n    props.set(ParserProp.FORMAT, format.getSelectedItem().toString());\n    props.set(ParserProp.HEADER, header.isSelected());\n    props.set(ParserProp.LINES, lines.isSelected());\n    props.set(ParserProp.JSONML, jsonml.isSelected());\n    props.set(ParserProp.SEPARATOR, sepcombo.getSelectedIndex() <\n      CSVParser.SEPARATORS.length ? sepcombo.getSelectedItem().toString() :\n      String.valueOf((int) sepchar.getText().charAt(0)));\n\n    gui.set(Prop.PARSER, type);\n    gui.set(Prop.PARSEROPT, props.toString());\n    gui.set(Prop.CHOP, chopWS.isSelected());\n    gui.set(Prop.STRIPNS, stripNS.isSelected());\n    gui.set(Prop.DTD, dtd.isSelected());\n    gui.set(Prop.INTPARSE, intparse.isSelected());\n    gui.set(Prop.CATFILE, usecat.isSelected() ? cfile.getText() : \"\");\n    gui.set(Prop.HTMLOPT, params.getText());\n  }","commit_id":"bad60c514bcb318d3331b1a868d6913fbd48f63d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Options panels.\n   */\n  private void createOptionsPanels() {\n    xmlopts.add(intparse);\n    xmlopts.add(new BaseXLabel(H_INT_PARSER, true, false));\n    xmlopts.add(dtd);\n    xmlopts.add(chop);\n    xmlopts.add(new BaseXLabel(H_CHOP_WS, false, false).border(0, 0, 8, 0));\n    xmlopts.add(new BaseXLabel());\n\n    // catalog resolver\n    final boolean rsen = CatalogWrapper.available();\n    final BaseXBack fl = new BaseXBack(new TableLayout(2, 2, 8, 0));\n    usecat.setEnabled(rsen);\n    fl.add(usecat);\n    fl.add(new BaseXLabel());\n    cfile.setEnabled(rsen);\n    fl.add(cfile);\n    browsec.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(final ActionEvent e) { catchoose(); }\n    });\n    browsec.setEnabled(rsen);\n    fl.add(browsec);\n    xmlopts.add(fl);\n    if(!rsen) {\n      final BaseXBack rs = new BaseXBack(new TableLayout(2, 1));\n      rs.add(new BaseXLabel(HELP1_USE_CATALOG).color(GUIConstants.DGRAY));\n      rs.add(new BaseXLabel(HELP2_USE_CATALOG).color(GUIConstants.DGRAY));\n      xmlopts.add(rs);\n    }\n\n    final boolean avl = HTMLParser.available();\n    htmlopts.add(new BaseXLabel(avl ? H_HTML_PARSER : H_NO_HTML_PARSER).\n        border(0, 0, 12, 0));\n\n    if(avl) {\n      final BaseXBack p = new BaseXBack(new TableLayout(1, 2, 8, 0));\n      p.add(new BaseXLabel(PARAMETERS + COL, true, true));\n      p.add(params);\n      htmlopts.add(p);\n    }\n\n    BaseXBack p = new BaseXBack(new TableLayout(1, 2, 8, 4));\n    p.add(new BaseXLabel(ENCODING + COL, true, true));\n    p.add(jencoding);\n    jsonopts.add(p);\n    jsonopts.add(jsonml);\n\n    p = new BaseXBack(new TableLayout(3, 2, 8, 4));\n    p.add(new BaseXLabel(ENCODING + COL, true, true));\n    p.add(cencoding);\n    p.add(new BaseXLabel(SEPARATOR, true, true));\n    p.add(separator);\n    p.add(new BaseXLabel(XML_FORMAT, true, true));\n    p.add(format);\n    csvopts.add(p);\n    csvopts.add(header);\n\n    p = new BaseXBack(new TableLayout(1, 2, 8, 4));\n    p.add(new BaseXLabel(ENCODING + COL, true, true));\n    p.add(tencoding);\n    textopts.add(p);\n    textopts.add(lines);\n\n    final boolean ip = intparse.isSelected();\n    final boolean uc = usecat.isSelected();\n    intparse.setEnabled(!uc);\n    usecat.setEnabled(!ip && CatalogWrapper.available());\n    cfile.setEnabled(uc);\n    browsec.setEnabled(uc);\n  }","id":97087,"modified_method":"/**\n   * Options panels.\n   */\n  private void createOptionsPanels() {\n    xmlopts.add(intparse);\n    xmlopts.add(new BaseXLabel(H_INT_PARSER, true, false));\n    xmlopts.add(dtd);\n    xmlopts.add(stripNS);\n    xmlopts.add(chopWS);\n    xmlopts.add(new BaseXLabel(H_CHOP_WS, false, false).border(0, 0, 8, 0));\n    xmlopts.add(new BaseXLabel());\n\n    // catalog resolver\n    final boolean rsen = CatalogWrapper.available();\n    final BaseXBack fl = new BaseXBack(new TableLayout(2, 2, 8, 0));\n    usecat.setEnabled(rsen);\n    fl.add(usecat);\n    fl.add(new BaseXLabel());\n    cfile.setEnabled(rsen);\n    fl.add(cfile);\n    browsec.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(final ActionEvent e) { catchoose(); }\n    });\n    browsec.setEnabled(rsen);\n    fl.add(browsec);\n    xmlopts.add(fl);\n    if(!rsen) {\n      final BaseXBack rs = new BaseXBack(new TableLayout(2, 1));\n      rs.add(new BaseXLabel(HELP1_USE_CATALOG).color(GUIConstants.DGRAY));\n      rs.add(new BaseXLabel(HELP2_USE_CATALOG).color(GUIConstants.DGRAY));\n      xmlopts.add(rs);\n    }\n\n    final boolean avl = HTMLParser.available();\n    htmlopts.add(new BaseXLabel(avl ? H_HTML_PARSER : H_NO_HTML_PARSER).\n        border(0, 0, 12, 0));\n\n    if(avl) {\n      final BaseXBack p = new BaseXBack(new TableLayout(1, 2, 8, 0));\n      p.add(new BaseXLabel(PARAMETERS + COL, true, true));\n      p.add(params);\n      htmlopts.add(p);\n    }\n\n    BaseXBack p = new BaseXBack(new TableLayout(1, 2, 8, 4));\n    p.add(new BaseXLabel(ENCODING + COL, true, true));\n    p.add(jencoding);\n    jsonopts.add(p);\n    jsonopts.add(jsonml);\n\n    p = new BaseXBack(new TableLayout(3, 2, 8, 4));\n    p.add(new BaseXLabel(ENCODING + COL, true, true));\n    p.add(cencoding);\n    p.add(new BaseXLabel(SEPARATOR, true, true));\n    p.add(separator);\n    p.add(new BaseXLabel(XML_FORMAT, true, true));\n    p.add(format);\n    csvopts.add(p);\n    csvopts.add(header);\n\n    p = new BaseXBack(new TableLayout(1, 2, 8, 4));\n    p.add(new BaseXLabel(ENCODING + COL, true, true));\n    p.add(tencoding);\n    textopts.add(p);\n    textopts.add(lines);\n\n    final boolean ip = intparse.isSelected();\n    final boolean uc = usecat.isSelected();\n    intparse.setEnabled(!uc);\n    usecat.setEnabled(!ip && CatalogWrapper.available());\n    cfile.setEnabled(uc);\n    browsec.setEnabled(uc);\n  }","commit_id":"bad60c514bcb318d3331b1a868d6913fbd48f63d","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void startElement(final String uri, final String ln, final String qn,\n      final Attributes at) throws SAXException {\n\n    try {\n      finishText();\n      final int as = at.getLength();\n      atts.reset();\n      for(int a = 0; a < as; ++a) {\n        atts.add(token(at.getQName(a)), token(at.getValue(a)));\n      }\n      builder.startElem(token(qn), atts);\n      ++nodes;\n    } catch(final IOException ex) {\n      error(ex);\n    }\n  }","id":97088,"modified_method":"@Override\n  public void startElement(final String uri, final String ln, final String qn,\n      final Attributes at) throws SAXException {\n\n    try {\n      finishText();\n      final int as = at.getLength();\n      atts.reset();\n      for(int a = 0; a < as; ++a) {\n        final byte[] an = token(at.getQName(a));\n        final byte[] av = token(at.getValue(a));\n        atts.add(stripNS ? local(an) : an, av);\n      }\n      final byte[] en = token(qn);\n      builder.startElem(stripNS ? local(en) : en, atts);\n      ++nodes;\n    } catch(final IOException ex) {\n      error(ex);\n    }\n  }","commit_id":"bad60c514bcb318d3331b1a868d6913fbd48f63d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param build builder reference\n   * @param ch chopping flag\n   */\n  public SAXHandler(final Builder build, final boolean ch) {\n    builder = build;\n    chop = ch;\n  }","id":97089,"modified_method":"/**\n   * Constructor.\n   * @param build builder reference\n   * @param ch chopping flag\n   * @param sn strip namespaces\n   */\n  public SAXHandler(final Builder build, final boolean ch, final boolean sn) {\n    builder = build;\n    chop = ch;\n    stripNS = sn;\n  }","commit_id":"bad60c514bcb318d3331b1a868d6913fbd48f63d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Checks if a text node has to be written.\n   * @throws IOException I/O exception\n   */\n  private void finishText() throws IOException {\n    if(sb.length() != 0) {\n      final String s = sb.toString();\n      builder.text(token(chop ? s.trim() : s));\n      sb.setLength(0);\n    }\n    for(int i = 0; i < ns.size(); ++i) {\n      builder.startNS(ns.name(i), ns.string(i));\n    }\n    ns.reset();\n  }","id":97090,"modified_method":"/**\n   * Checks if a text node has to be written.\n   * @throws IOException I/O exception\n   */\n  private void finishText() throws IOException {\n    if(sb.length() != 0) {\n      final String s = sb.toString();\n      builder.text(token(chop ? s.trim() : s));\n      sb.setLength(0);\n    }\n    if(!stripNS) {\n      for(int i = 0; i < ns.size(); ++i) {\n        builder.startNS(ns.name(i), ns.string(i));\n      }\n    }\n    ns.reset();\n  }","commit_id":"bad60c514bcb318d3331b1a868d6913fbd48f63d","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void parse() throws IOException {\r\n    final InputSource is = wrap(saxs.getInputSource());\r\n    final String in = saxs.getSystemId() == null ? DOTS : saxs.getSystemId();\r\n\r\n    try {\r\n      XMLReader r = saxs.getXMLReader();\r\n      if(r == null) {\r\n        final SAXParserFactory f = SAXParserFactory.newInstance();\r\n        f.setFeature(EXTDTD, prop.is(Prop.DTD));\r\n        f.setFeature(\"http://xml.org/sax/features/use-entity-resolver2\", false);\r\n        f.setNamespaceAware(true);\r\n        f.setValidating(false);\r\n        f.setXIncludeAware(true);\r\n        r = f.newSAXParser().getXMLReader();\r\n      }\r\n\r\n      saxh = new SAXHandler(builder, prop.is(Prop.CHOP));\r\n      final String cat = prop.get(Prop.CATFILE);\r\n      if(!cat.isEmpty()) CatalogWrapper.set(r, cat);\r\n\r\n      r.setDTDHandler(saxh);\r\n      r.setContentHandler(saxh);\r\n      r.setProperty(LEXHANDLER, saxh);\r\n      r.setErrorHandler(saxh);\r\n\r\n      if(is != null) r.parse(is);\r\n      else r.parse(saxs.getSystemId());\r\n    } catch(final SAXParseException ex) {\r\n      final String msg = Util.info(SCANPOS_X_X, in, ex.getLineNumber(),\r\n          ex.getColumnNumber()) + COLS + ex.getMessage();\r\n      final IOException ioe = new IOException(msg);\r\n      ioe.setStackTrace(ex.getStackTrace());\r\n      throw ioe;\r\n    } catch(final ProgressException ex) {\r\n      throw ex;\r\n    } catch(final Exception ex) {\r\n      // occurs, e.g. if document encoding is invalid:\r\n      // prefix message with source id\r\n      String msg = ex.getMessage();\r\n      if(in != null) msg = '\"' + in + '\"' + COLS + msg;\r\n      // wrap and return original message\r\n      final IOException ioe = new IOException(msg);\r\n      ioe.setStackTrace(ex.getStackTrace());\r\n      throw ioe;\r\n    } finally {\r\n      if(is == null) return;\r\n      try {\r\n        final Reader r = is.getCharacterStream();\r\n        if(r != null) r.close();\r\n        final InputStream ist = is.getByteStream();\r\n        if(ist != null) ist.close();\r\n      } catch(final IOException ex) {\r\n        Util.debug(ex);\r\n      }\r\n    }\r\n  }","id":97091,"modified_method":"@Override\r\n  public void parse() throws IOException {\r\n    final InputSource is = wrap(saxs.getInputSource());\r\n    final String in = saxs.getSystemId() == null ? DOTS : saxs.getSystemId();\r\n\r\n    try {\r\n      XMLReader r = saxs.getXMLReader();\r\n      if(r == null) {\r\n        final SAXParserFactory f = SAXParserFactory.newInstance();\r\n        f.setFeature(EXTDTD, prop.is(Prop.DTD));\r\n        f.setFeature(\"http://xml.org/sax/features/use-entity-resolver2\", false);\r\n        f.setNamespaceAware(true);\r\n        f.setValidating(false);\r\n        f.setXIncludeAware(true);\r\n        r = f.newSAXParser().getXMLReader();\r\n      }\r\n\r\n      saxh = new SAXHandler(builder, prop.is(Prop.CHOP), prop.is(Prop.STRIPNS));\r\n      final String cat = prop.get(Prop.CATFILE);\r\n      if(!cat.isEmpty()) CatalogWrapper.set(r, cat);\r\n\r\n      r.setDTDHandler(saxh);\r\n      r.setContentHandler(saxh);\r\n      r.setProperty(LEXHANDLER, saxh);\r\n      r.setErrorHandler(saxh);\r\n\r\n      if(is != null) r.parse(is);\r\n      else r.parse(saxs.getSystemId());\r\n    } catch(final SAXParseException ex) {\r\n      final String msg = Util.info(SCANPOS_X_X, in, ex.getLineNumber(),\r\n          ex.getColumnNumber()) + COLS + ex.getMessage();\r\n      final IOException ioe = new IOException(msg);\r\n      ioe.setStackTrace(ex.getStackTrace());\r\n      throw ioe;\r\n    } catch(final ProgressException ex) {\r\n      throw ex;\r\n    } catch(final Exception ex) {\r\n      // occurs, e.g. if document encoding is invalid:\r\n      // prefix message with source id\r\n      String msg = ex.getMessage();\r\n      if(in != null) msg = '\"' + in + '\"' + COLS + msg;\r\n      // wrap and return original message\r\n      final IOException ioe = new IOException(msg);\r\n      ioe.setStackTrace(ex.getStackTrace());\r\n      throw ioe;\r\n    } finally {\r\n      if(is == null) return;\r\n      try {\r\n        final Reader r = is.getCharacterStream();\r\n        if(r != null) r.close();\r\n        final InputStream ist = is.getByteStream();\r\n        if(ist != null) ist.close();\r\n      } catch(final IOException ex) {\r\n        Util.debug(ex);\r\n      }\r\n    }\r\n  }","commit_id":"bad60c514bcb318d3331b1a868d6913fbd48f63d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param source document source\n   * @param pr database properties\n   * @throws IOException I/O exception\n   */\n  public XMLParser(final IO source, final Prop pr) throws IOException {\n    super(source, pr);\n    scanner = new XMLScanner(source, pr);\n  }","id":97092,"modified_method":"/**\n   * Constructor.\n   * @param source document source\n   * @param pr database properties\n   * @throws IOException I/O exception\n   */\n  public XMLParser(final IO source, final Prop pr) throws IOException {\n    super(source, pr);\n    scanner = new XMLScanner(source, pr);\n    stripNS = pr.is(Prop.STRIPNS);\n  }","commit_id":"bad60c514bcb318d3331b1a868d6913fbd48f63d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Parses an XML tag.\n   * @throws IOException I/O exception\n   * @return result of scanner step\n   */\n  private boolean parseTag() throws IOException {\n    // close element\n    if(scanner.type == Type.L_BR_CLOSE) {\n      scanner.more();\n\n      // get tag name\n      final byte[] tag = consumeToken(Type.TAGNAME);\n      skipSpace();\n\n      final byte[] open = tags.pop();\n      if(!eq(open, tag)) throw new BuildException(CLOSINGTAG, det(), tag, open);\n\n      builder.endElem();\n      if(tags.isEmpty()) closed = true;\n      return consume(Type.R_BR);\n    }\n\n    consume(Type.L_BR);\n    atts.reset();\n\n    // get tag name\n    final byte[] tag = consumeToken(Type.TAGNAME);\n    skipSpace();\n\n    // parse optional attributes\n    while(scanner.type != Type.R_BR && scanner.type != Type.CLOSE_R_BR) {\n      final byte[] attName = consumeToken(Type.ATTNAME);\n      skipSpace();\n      consume(Type.EQ);\n      skipSpace();\n      consume(Type.QUOTE);\n      byte[] attValue = EMPTY;\n      if(scanner.type == Type.ATTVALUE) {\n        attValue = scanner.token.finish();\n        scanner.more();\n      }\n      consume(Type.QUOTE);\n\n      if(startsWith(attName, XMLNSC)) {\n        // open namespace...\n        builder.startNS(local(attName), attValue);\n      } else if(eq(attName, XMLNS)) {\n        // open namespace...\n        builder.startNS(EMPTY, attValue);\n      } else {\n        // add attribute\n        atts.add(attName, attValue);\n      }\n\n      if(scanner.type != Type.R_BR && scanner.type != Type.CLOSE_R_BR) {\n        consume(Type.WS);\n      }\n    }\n\n    // send empty element to builder\n    if(scanner.type == Type.CLOSE_R_BR) {\n      builder.emptyElem(tag, atts);\n      if(tags.isEmpty()) closed = true;\n      return scanner.more();\n    }\n\n    // send start element\n    builder.startElem(tag, atts);\n    tags.add(tag);\n    return consume(Type.R_BR);\n  }","id":97093,"modified_method":"/**\n   * Parses an XML tag.\n   * @throws IOException I/O exception\n   * @return result of scanner step\n   */\n  private boolean parseTag() throws IOException {\n    // close element\n    if(scanner.type == Type.L_BR_CLOSE) {\n      scanner.more();\n\n      // get tag name\n      final byte[] tag = consumeToken(Type.TAGNAME);\n      skipSpace();\n\n      final byte[] open = tags.pop();\n      if(!eq(open, tag)) throw new BuildException(CLOSINGTAG, det(), tag, open);\n\n      builder.endElem();\n      if(tags.isEmpty()) closed = true;\n      return consume(Type.R_BR);\n    }\n\n    consume(Type.L_BR);\n    atts.reset();\n\n    // get element name\n    byte[] en = consumeToken(Type.TAGNAME);\n    if(stripNS) en = local(en);\n    skipSpace();\n\n    // parse optional attributes\n    while(scanner.type != Type.R_BR && scanner.type != Type.CLOSE_R_BR) {\n      final byte[] an = consumeToken(Type.ATTNAME);\n      skipSpace();\n      consume(Type.EQ);\n      skipSpace();\n      consume(Type.QUOTE);\n      byte[] av = EMPTY;\n      if(scanner.type == Type.ATTVALUE) {\n        av = scanner.token.finish();\n        scanner.more();\n      }\n      consume(Type.QUOTE);\n\n      if(startsWith(an, XMLNSC)) {\n        // open namespace...\n        if(!stripNS) builder.startNS(local(an), av);\n      } else if(eq(an, XMLNS)) {\n        // open namespace...\n        if(!stripNS) builder.startNS(EMPTY, av);\n      } else {\n        // add attribute\n        atts.add(stripNS ? local(an) : an, av);\n      }\n\n      if(scanner.type != Type.R_BR && scanner.type != Type.CLOSE_R_BR) {\n        consume(Type.WS);\n      }\n    }\n\n    // send empty element to builder\n    if(scanner.type == Type.CLOSE_R_BR) {\n      builder.emptyElem(en, atts);\n      if(tags.isEmpty()) closed = true;\n      return scanner.more();\n    }\n\n    // send start element\n    builder.startElem(en, atts);\n    tags.add(en);\n    return consume(Type.R_BR);\n  }","commit_id":"bad60c514bcb318d3331b1a868d6913fbd48f63d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/** Parse documents. */\n  @Test\n  public void parse() {\n    context.prop.set(Prop.MAINMEM, true);\n    context.prop.set(Prop.CHOP, false);\n\n    final StringBuilder sb = new StringBuilder();\n\n    final String[] docs = {\n        \"<x/>\", \" <x/> \", \"<x><\/x>\", \"<x>A<\/x>\", \"<x><x>\", \"<x/><x/>\", \"<x><\/x><x/>\",\n        \"<x>\", \"<\/x>\", \"<x><\/x><\/x>\", \"x<x>\", \"<x>x\", \"<x><![CDATA[ ]]><\/x>\",\n    };\n    for(final String doc : docs) {\n      // parse document with default parser (expected to yield correct result)\n      context.prop.set(Prop.INTPARSE, false);\n      boolean def = true;\n      try {\n        new CreateDB(NAME, doc).execute(context);\n      } catch(final BaseXException ex) {\n        def = false;\n      }\n\n      // parse document with internal parser\n      context.prop.set(Prop.INTPARSE, true);\n      boolean cust = true;\n      try {\n        new CreateDB(NAME, doc).execute(context);\n      } catch(final BaseXException ex) {\n        cust = false;\n      }\n\n      // compare results\n      if(def != cust) {\n        sb.append(\"\\n\").append(def ? \"- not accepted: \" : \"- not rejected: \").append(doc);\n      }\n    }\n\n    // list all errors\n    if(sb.length() != 0) fail(sb.toString());\n  }","id":97094,"modified_method":"/**\n   * Tests the namespace stripping option (Option {@link Prop#STRIPNS}).\n   * @throws Exception exceptions\n   */\n  @Test\n  public void parse() throws Exception {\n    context.prop.set(Prop.STRIPNS, true);\n    final String doc = \"<e xmlns='A'><b:f xmlns:b='B'/><\/e>\";\n    for(final boolean b : new boolean[] { false, true }) {\n      context.prop.set(Prop.INTPARSE, b);\n      new CreateDB(NAME, doc).execute(context);\n      String result = new XQuery(\".\").execute(context).replaceAll(\"[\\\\r\\\\n]+ *\", \"\");\n      assertEquals(\"<e><f/><\/e>\", result);\n      result = new XQuery(\"e/f\").execute(context).replaceAll(\"[\\\\r\\\\n]+ *\", \"\");\n      assertEquals(\"<f/>\", result);\n    }\n  }","commit_id":"bad60c514bcb318d3331b1a868d6913fbd48f63d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n\t * @param toolSession\n\t * @param state\n\t */\n\tprotected void initMessage(ToolSession toolSession, SessionState state)\n\t{\n\t\tString message = (String) toolSession.getAttribute(FilePickerHelper.FILE_PICKER_TITLE_TEXT);\n\t\ttoolSession.removeAttribute(FilePickerHelper.FILE_PICKER_TITLE_TEXT);\n\t\tif (message == null)\n\t\t{\n\t\t\tmessage = rb.getString(FilePickerHelper.FILE_PICKER_TITLE_TEXT);\n\t\t}\n\t\ttoolSession.setAttribute(STATE_ATTACH_TITLE, message);\n\n\t\tmessage = (String) toolSession.getAttribute(FilePickerHelper.FILE_PICKER_INSTRUCTION_TEXT);\n\t\ttoolSession.removeAttribute(FilePickerHelper.FILE_PICKER_INSTRUCTION_TEXT);\n\t\tif (message == null)\n\t\t{\n\t\t\tmessage = rb.getString(FilePickerHelper.FILE_PICKER_INSTRUCTION_TEXT);\n\t\t}\n\t\ttoolSession.setAttribute(STATE_ATTACH_INSTRUCTION, message);\n\t}","id":97095,"modified_method":"/**\n\t * @param toolSession\n\t * @param state\n\t */\n\tprotected void initMessage(ToolSession toolSession, SessionState state)\n\t{\n\t\tString title = (String) toolSession.getAttribute(FilePickerHelper.FILE_PICKER_TITLE_TEXT);\n\t\ttoolSession.removeAttribute(FilePickerHelper.FILE_PICKER_TITLE_TEXT);\n\t\tif (title == null)\n\t\t{\n\t\t\ttoolSession.removeAttribute(STATE_ATTACH_TITLE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttoolSession.setAttribute(STATE_ATTACH_TITLE, title);\n\t\t}\n\n\t\tString instruction = (String) toolSession.getAttribute(FilePickerHelper.FILE_PICKER_INSTRUCTION_TEXT);\n\t\ttoolSession.removeAttribute(FilePickerHelper.FILE_PICKER_INSTRUCTION_TEXT);\n\t\tif (instruction == null)\n\t\t{\n\t\t\ttoolSession.removeAttribute(STATE_ATTACH_INSTRUCTION);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttoolSession.setAttribute(STATE_ATTACH_INSTRUCTION, instruction);\n\t\t}\n\t\t\n\t\tString subtitle = (String) toolSession.getAttribute(FilePickerHelper.FILE_PICKER_SUBTITLE_TEXT);\n\t\ttoolSession.removeAttribute(FilePickerHelper.FILE_PICKER_SUBTITLE_TEXT);\n\t\tif (subtitle == null)\n\t\t{\n\t\t\ttoolSession.removeAttribute(STATE_ATTACH_SUBTITLE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttoolSession.setAttribute(STATE_ATTACH_SUBTITLE, subtitle);\n\t\t}\n\t\t\n\t}","commit_id":"269301e139d85d6f91433ad31979d854f2a9fcab","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/** Process a portlet request.\n\t * @return false if the page is not found.\n\t * @since 3.0.0\n\t */\n\tprotected boolean process(Session sess, RenderRequest request,\n\tRenderResponse response, String path, boolean bRichlet)\n\tthrows PortletException, IOException {\n//\t\tif (log.debugable()) log.debug(\"Creates from \"+path);\n\t\tfinal WebManager webman = getWebManager();\n\t\tfinal WebApp wapp = webman.getWebApp();\n\t\tfinal WebAppCtrl wappc = (WebAppCtrl)wapp;\n\n\t\tfinal HttpServletRequest httpreq = RenderHttpServletRequest.getInstance(request);\n\t\tfinal HttpServletResponse httpres = RenderHttpServletResponse.getInstance(response);\n\t\tfinal ServletContext svlctx = wapp.getServletContext();\n\n\t\tfinal DesktopRecycle dtrc = wapp.getConfiguration().getDesktopRecycle();\n\t\tDesktop desktop = dtrc != null ?\n\t\t\tDesktopRecycles.beforeService(dtrc, svlctx, sess, httpreq, httpres, path): null;\n\n\t\ttry {\n\t\t\tif (desktop != null) { //recycle\n\t\t\t\tfinal Page page = Utils.getMainPage(desktop);\n\t\t\t\tif (page != null) {\n\t\t\t\t\tfinal Execution exec =\n\t\t\t\t\t\tnew ExecutionImpl(svlctx, httpreq, httpres, desktop, page);\n\t\t\t\t\tfixContentType(response);\n\t\t\t\t\twappc.getUiEngine()\n\t\t\t\t\t\t.recycleDesktop(exec, page, response.getWriter());\n\t\t\t\t} else\n\t\t\t\t\tdesktop = null; //something wrong (not possible; just in case)\n\t\t\t}\n\n\t\t\tif (desktop == null) {\n\t\t\t\tdesktop = webman.getDesktop(sess, httpreq, httpres, path, true);\n\t\t\t\tif (desktop == null) //forward or redirect\n\t\t\t\t\treturn true;\n\n\t\t\t\tfinal RequestInfo ri = new RequestInfoImpl(\n\t\t\t\t\twapp, sess, desktop, httpreq,\n\t\t\t\t\tPageDefinitions.getLocator(wapp, path));\n\t\t\t\t((SessionCtrl)sess).notifyClientRequest(true);\n\n\t\t\t\tfinal Page page;\n\t\t\t\tfinal PageRenderPatch patch = getRenderPatch();\n\t\t\t\tfinal Writer out = patch.beforeRender(ri);\n\t\t\t\tfinal UiFactory uf = wappc.getUiFactory();\n\t\t\t\tif (uf.isRichlet(ri, bRichlet)) {\n\t\t\t\t\tfinal Richlet richlet = uf.getRichlet(ri, path);\n\t\t\t\t\tif (richlet == null)\n\t\t\t\t\t\treturn false; //not found\n\n\t\t\t\t\tpage = WebManager.newPage(uf, ri, richlet, httpres, path);\n\t\t\t\t\tfinal Execution exec =\n\t\t\t\t\t\tnew ExecutionImpl(svlctx, httpreq, httpres, desktop, page);\n\t\t\t\t\tfixContentType(response);\n\t\t\t\t\tif (isJSR286) {\n\t\t\t\t\t\tResourceURL url = response.createResourceURL();\n\t\t\t\t\t\tpage.setAttribute(\"org.zkoss.portlet2.resourceURL\", response.encodeURL(url.toString()), Page.PAGE_SCOPE);\n\t\t\t\t\t}\n\t\t\t\t\twappc.getUiEngine().execNewPage(exec, richlet, page,\n\t\t\t\t\t\tout != null ? out: response.getWriter());\n\t\t\t\t} else if (path != null) {\n\t\t\t\t\tfinal PageDefinition pagedef = uf.getPageDefinition(ri, path);\n\t\t\t\t\tif (pagedef == null)\n\t\t\t\t\t\treturn false; //not found\n\n\t\t\t\t\tpage = WebManager.newPage(uf, ri, pagedef, httpres, path);\n\t\t\t\t\tfinal Execution exec =\n\t\t\t\t\t\tnew ExecutionImpl(svlctx, httpreq, httpres, desktop, page);\n\t\t\t\t\tfixContentType(response);\n\t\t\t\t\tif (isJSR286) {\n\t\t\t\t\t\tResourceURL url = response.createResourceURL();\n\t\t\t\t\t\tpage.setAttribute(\"org.zkoss.portlet2.resourceURL\", response.encodeURL(url.toString()), Page.PAGE_SCOPE);\n\t\t\t\t\t}\n\t\t\t\t\twappc.getUiEngine().execNewPage(exec, pagedef, page,\n\t\t\t\t\t\tout != null ? out: response.getWriter());\n\t\t\t\t} else\n\t\t\t\t\treturn true; //nothing to do\n\n\t\t\t\tif (out != null)\n\t\t\t\t\tpatch.patchRender(ri, page, out, response.getWriter());\n\t\t\t}\n\t\t} finally {\n\t\t\tif (dtrc != null)\n\t\t\t\tDesktopRecycles.afterService(dtrc, desktop);\n\t\t}\n\t\treturn true; //success\n\t}","id":97096,"modified_method":"/** Process a portlet request.\n\t * @return false if the page is not found.\n\t * @since 3.0.0\n\t */\n\tprotected boolean process(Session sess, RenderRequest request,\n\tRenderResponse response, String path, boolean bRichlet)\n\tthrows PortletException, IOException {\n//\t\tif (log.debugable()) log.debug(\"Creates from \"+path);\n\t\tfinal WebManager webman = getWebManager();\n\t\tfinal WebApp wapp = webman.getWebApp();\n\t\tfinal WebAppCtrl wappc = (WebAppCtrl)wapp;\n\n\t\tfinal HttpServletRequest httpreq = RenderHttpServletRequest.getInstance(request);\n\t\tfinal HttpServletResponse httpres = RenderHttpServletResponse.getInstance(response);\n\t\tfinal ServletContext svlctx = wapp.getServletContext();\n\n\t\tfinal DesktopRecycle dtrc = wapp.getConfiguration().getDesktopRecycle();\n\t\tDesktop desktop = dtrc != null ?\n\t\t\tDesktopRecycles.beforeService(dtrc, svlctx, sess, httpreq, httpres, path): null;\n\n\t\ttry {\n\t\t\tif (desktop != null) { //recycle\n\t\t\t\tfinal Page page = Utils.getMainPage(desktop);\n\t\t\t\tif (page != null) {\n\t\t\t\t\tfinal Execution exec =\n\t\t\t\t\t\tnew ExecutionImpl(svlctx, httpreq, httpres, desktop, page);\n\t\t\t\t\tfixContentType(response);\n\t\t\t\t\twappc.getUiEngine()\n\t\t\t\t\t\t.recycleDesktop(exec, page, response.getWriter());\n\t\t\t\t} else\n\t\t\t\t\tdesktop = null; //something wrong (not possible; just in case)\n\t\t\t}\n\n\t\t\tif (desktop == null) {\n\t\t\t\tdesktop = webman.getDesktop(sess, httpreq, httpres, path, true);\n\t\t\t\tif (desktop == null) //forward or redirect\n\t\t\t\t\treturn true;\n\n\t\t\t\tfinal RequestInfo ri = new RequestInfoImpl(\n\t\t\t\t\twapp, sess, desktop, httpreq,\n\t\t\t\t\tPageDefinitions.getLocator(wapp, path));\n\t\t\t\t((SessionCtrl)sess).notifyClientRequest(true);\n\n\t\t\t\tfinal Page page;\n\t\t\t\tfinal PageRenderPatch patch = getRenderPatch();\n\t\t\t\tfinal Writer out = patch.beforeRender(ri);\n\t\t\t\tfinal UiFactory uf = wappc.getUiFactory();\n\t\t\t\tif (uf.isRichlet(ri, bRichlet)) {\n\t\t\t\t\tfinal Richlet richlet = uf.getRichlet(ri, path);\n\t\t\t\t\tif (richlet == null)\n\t\t\t\t\t\treturn false; //not found\n\n\t\t\t\t\tpage = WebManager.newPage(uf, ri, richlet, httpres, path);\n\t\t\t\t\tfinal Execution exec =\n\t\t\t\t\t\tnew ExecutionImpl(svlctx, httpreq, httpres, desktop, page);\n\t\t\t\t\tfixContentType(response);\n\t\t\t\t\tif (isJSR286) {\n\t\t\t\t\t\tResourceURL url = response.createResourceURL();\n\t\t\t\t\t\tpage.setAttribute(\"org.zkoss.portlet2.resourceURL\", response.encodeURL(url.toString()), Page.PAGE_SCOPE);\n\t\t\t\t\t\tpage.setAttribute(\"org.zkoss.portlet2.namespace\", response.getNamespace(), Page.PAGE_SCOPE);\n\t\t\t\t\t}\n\t\t\t\t\twappc.getUiEngine().execNewPage(exec, richlet, page,\n\t\t\t\t\t\tout != null ? out: response.getWriter());\n\t\t\t\t} else if (path != null) {\n\t\t\t\t\tfinal PageDefinition pagedef = uf.getPageDefinition(ri, path);\n\t\t\t\t\tif (pagedef == null)\n\t\t\t\t\t\treturn false; //not found\n\n\t\t\t\t\tpage = WebManager.newPage(uf, ri, pagedef, httpres, path);\n\t\t\t\t\tfinal Execution exec =\n\t\t\t\t\t\tnew ExecutionImpl(svlctx, httpreq, httpres, desktop, page);\n\t\t\t\t\tfixContentType(response);\n\t\t\t\t\tif (isJSR286) {\n\t\t\t\t\t\tResourceURL url = response.createResourceURL();\n\t\t\t\t\t\tpage.setAttribute(\"org.zkoss.portlet2.resourceURL\", response.encodeURL(url.toString()), Page.PAGE_SCOPE);\n\t\t\t\t\t\tpage.setAttribute(\"org.zkoss.portlet2.namespace\", response.getNamespace(), Page.PAGE_SCOPE);\n\t\t\t\t\t}\n\t\t\t\t\twappc.getUiEngine().execNewPage(exec, pagedef, page,\n\t\t\t\t\t\tout != null ? out: response.getWriter());\n\t\t\t\t} else\n\t\t\t\t\treturn true; //nothing to do\n\n\t\t\t\tif (out != null)\n\t\t\t\t\tpatch.patchRender(ri, page, out, response.getWriter());\n\t\t\t}\n\t\t} finally {\n\t\t\tif (dtrc != null)\n\t\t\t\tDesktopRecycles.afterService(dtrc, desktop);\n\t\t}\n\t\treturn true; //success\n\t}","commit_id":"7d81fdf5c33ac69b7021b84de7d33a442e60ca6d","url":"https://github.com/zkoss/zk"},{"original_method":"private static void outDivTemplateEnd(Page page, Writer out)\n\tthrows IOException {\n\t\tfinal Desktop dt;\n\t\tif (page != null && (dt = page.getDesktop()) != null) {\n\t\t\tif (dt.getAttribute(ATTR_DESKTOP_CLIENTINFO) != null) {\n\t\t\t\tdt.removeAttribute(ATTR_DESKTOP_CLIENTINFO);\n\t\t\t\tif (!\"CE\".equals(WebApps.getEdition()))\n\t\t\t\t\tout.write(\"<script type=\\\"text/javascript\\\">if(zk.clientinfo === undefined)zk.clientinfo = true;<\/script>\");\n\t\t\t}\n\t\t\tif (dt.getAttribute(ATTR_DESKTOP_VISIBILITYCHANGE) != null) {\n\t\t\t\tdt.removeAttribute(ATTR_DESKTOP_VISIBILITYCHANGE);\n\t\t\t\tout.write(\"<script type=\\\"text/javascript\\\">if(zk.visibilitychange === undefined)zk.visibilitychange = true;<\/script>\");\n\t\t\t}\n\t\t\tString resourceURL = (String) page.getAttribute(ATTR_PORTLET2_RESOURCEURL, Page.PAGE_SCOPE);\n\t\t\tif(resourceURL != null) {\n\t\t\t\tpage.removeAttribute(ATTR_PORTLET2_RESOURCEURL, Page.PAGE_SCOPE);\n\t\t\t\tout.write(\"<script type=\\\"text/javascript\\\">zk.portlet2AjaxURI = '\");\n\t\t\t\tout.write(resourceURL);\n\t\t\t\tout.write(\"';<\/script>\");\n\t\t\t}\n\t\t}\n\t\toutSEOContent(page, out);\n\t\tout.write(\"<\/div>\");\n\t}","id":97097,"modified_method":"private static void outDivTemplateEnd(Page page, Writer out)\n\tthrows IOException {\n\t\tfinal Desktop dt;\n\t\tif (page != null && (dt = page.getDesktop()) != null) {\n\t\t\tif (dt.getAttribute(ATTR_DESKTOP_CLIENTINFO) != null) {\n\t\t\t\tdt.removeAttribute(ATTR_DESKTOP_CLIENTINFO);\n\t\t\t\tif (!\"CE\".equals(WebApps.getEdition()))\n\t\t\t\t\tout.write(\"<script type=\\\"text/javascript\\\">if(zk.clientinfo === undefined)zk.clientinfo = true;<\/script>\");\n\t\t\t}\n\t\t\tif (dt.getAttribute(ATTR_DESKTOP_VISIBILITYCHANGE) != null) {\n\t\t\t\tdt.removeAttribute(ATTR_DESKTOP_VISIBILITYCHANGE);\n\t\t\t\tout.write(\"<script type=\\\"text/javascript\\\">if(zk.visibilitychange === undefined)zk.visibilitychange = true;<\/script>\");\n\t\t\t}\n\t\t\tString resourceURL = (String) page.getAttribute(ATTR_PORTLET2_RESOURCEURL, Page.PAGE_SCOPE),\n\t\t\t\t\tnamespace = (String) page.getAttribute(ATTR_PORTLET2_NAMESPACE, Page.PAGE_SCOPE);\n\t\t\tif(resourceURL != null) {\n\t\t\t\tpage.removeAttribute(ATTR_PORTLET2_RESOURCEURL, Page.PAGE_SCOPE);\n\t\t\t\tpage.removeAttribute(ATTR_PORTLET2_NAMESPACE, Page.PAGE_SCOPE);\n\t\t\t\t// B65-ZK-2210: store url and namespace per desktop.\n\t\t\t\tout.write(\"<script type=\\\"text/javascript\\\">if(!zk.portlet2Data) zk.portlet2Data = {};\\n\" +\n\t\t\t\t\t\t\"zk.portlet2Data['\" + dt.getId() + \"'] = {\" +\n\t\t\t\t\t\t\"resourceURL: '\" + resourceURL + \"', \" +\n\t\t\t\t\t\t\"namespace: '\" + namespace + \"'};<\/script>\");\n\t\t\t}\n\t\t}\n\t\toutSEOContent(page, out);\n\t\tout.write(\"<\/div>\");\n\t}","commit_id":"7d81fdf5c33ac69b7021b84de7d33a442e60ca6d","url":"https://github.com/zkoss/zk"},{"original_method":"private static void fillPageSummary(PageSummary pageSummary, ObjectFactory objectFactory, URI baseUri,\n        Document doc, boolean useVersion, XWiki xwikiApi, Boolean withPrettyNames) throws XWikiException\n    {\n        pageSummary.setWiki(doc.getWiki());\n        pageSummary.setFullName(doc.getFullName());\n        pageSummary.setId(doc.getPrefixedFullName());\n        pageSummary.setSpace(doc.getSpace());\n        pageSummary.setName(doc.getName());\n        pageSummary.setTitle(doc.getDisplayTitle());\n        pageSummary.setXwikiRelativeUrl(doc.getURL(\"view\"));\n        pageSummary.setXwikiAbsoluteUrl(doc.getExternalURL(\"view\"));\n        pageSummary.setTranslations(createTranslations(objectFactory, baseUri, doc));\n        pageSummary.setSyntax(doc.getSyntax().toIdString());\n        pageSummary.setVersion(doc.getVersion());\n        pageSummary.setAuthor(doc.getAuthor());\n        if (withPrettyNames) {\n            pageSummary.setAuthorName(xwikiApi.getUserName(doc.getAuthor(), false));\n        }\n\n        Document parent = Utils.getParentDocument(doc, xwikiApi);\n        pageSummary.setParent(doc.getParent());\n        // parentId must not be set if the parent document does not exist.\n        if (parent != null && !parent.isNew()) {\n            pageSummary.setParentId(parent.getPrefixedFullName());\n        } else {\n            pageSummary.setParentId(\"\");\n        }\n        \n        List<String> spaces = Utils.getSpacesFromSpaceId(doc.getSpace());\n        List<String> parentSpaces = new ArrayList<>();\n        int i = 0;\n        for (String space : spaces) {\n            if (i < spaces.size() - 1) {\n                parentSpaces.add(space);\n            }\n            i++;\n        }\n\n        String spaceUri = uri(baseUri, SpaceResource.class, doc.getWiki(), parentSpaces, spaces.get(spaces.size()-1));\n        Link spaceLink = objectFactory.createLink();\n        spaceLink.setHref(spaceUri);\n        spaceLink.setRel(Relations.SPACE);\n        pageSummary.getLinks().add(spaceLink);\n\n        if (parent != null) {\n            String parentUri = uri(baseUri, PageResource.class, parent.getWiki(), spaces, parent.getName());\n            Link parentLink = objectFactory.createLink();\n            parentLink.setHref(parentUri);\n            parentLink.setRel(Relations.PARENT);\n            pageSummary.getLinks().add(parentLink);\n        }\n\n        String historyUri = uri(baseUri, PageHistoryResource.class, doc.getWiki(), \n                Utils.getSpacesFromSpaceId(doc.getSpace()), doc.getName());\n        Link historyLink = objectFactory.createLink();\n        historyLink.setHref(historyUri);\n        historyLink.setRel(Relations.HISTORY);\n        pageSummary.getLinks().add(historyLink);\n\n        if (!doc.getChildren().isEmpty()) {\n            String pageChildrenUri =\n                uri(baseUri, PageChildrenResource.class, doc.getWiki(), spaces, doc.getName());\n            Link pageChildrenLink = objectFactory.createLink();\n            pageChildrenLink.setHref(pageChildrenUri);\n            pageChildrenLink.setRel(Relations.CHILDREN);\n            pageSummary.getLinks().add(pageChildrenLink);\n        }\n\n        if (!doc.getComments().isEmpty()) {\n            String commentsUri;\n            if (useVersion) {\n                commentsUri =\n                    uri(baseUri, CommentsVersionResource.class, doc.getWiki(), spaces, doc.getName(),\n                        doc.getVersion());\n            } else {\n                commentsUri = uri(baseUri, CommentsResource.class, doc.getWiki(), spaces, doc.getName());\n            }\n\n            Link commentsLink = objectFactory.createLink();\n            commentsLink.setHref(commentsUri);\n            commentsLink.setRel(Relations.COMMENTS);\n            pageSummary.getLinks().add(commentsLink);\n        }\n\n        if (!doc.getAttachmentList().isEmpty()) {\n            String attachmentsUri;\n            if (useVersion) {\n                attachmentsUri =\n                    uri(baseUri, AttachmentsAtPageVersionResource.class, doc.getWiki(), spaces, doc.getName(),\n                        doc.getVersion());\n            } else {\n                attachmentsUri = uri(baseUri, AttachmentsResource.class, doc.getWiki(), spaces, doc.getName());\n            }\n\n            Link attachmentsLink = objectFactory.createLink();\n            attachmentsLink.setHref(attachmentsUri);\n            attachmentsLink.setRel(Relations.ATTACHMENTS);\n            pageSummary.getLinks().add(attachmentsLink);\n        }\n\n        if (!doc.getxWikiObjects().keySet().isEmpty()) {\n            String objectsUri;\n\n            if (useVersion) {\n                objectsUri =\n                    uri(baseUri, ObjectsAtPageVersionResource.class, doc.getWiki(), spaces, doc.getName(),\n                        doc.getVersion());\n            } else {\n                objectsUri = uri(baseUri, ObjectsResource.class, doc.getWiki(), spaces, doc.getName());\n            }\n            Link objectsLink = objectFactory.createLink();\n            objectsLink.setHref(objectsUri);\n            objectsLink.setRel(Relations.OBJECTS);\n            pageSummary.getLinks().add(objectsLink);\n        }\n\n        com.xpn.xwiki.api.Object tagsObject = doc.getObject(\"XWiki.TagClass\", 0);\n        if (tagsObject != null) {\n            if (tagsObject.getProperty(\"tags\") != null) {\n                String tagsUri = uri(baseUri, PageTagsResource.class, doc.getWiki(), spaces, doc.getName());\n                Link tagsLink = objectFactory.createLink();\n                tagsLink.setHref(tagsUri);\n                tagsLink.setRel(Relations.TAGS);\n                pageSummary.getLinks().add(tagsLink);\n            }\n        }\n\n        String syntaxesUri = uri(baseUri, SyntaxesResource.class);\n        Link syntaxesLink = objectFactory.createLink();\n        syntaxesLink.setHref(syntaxesUri);\n        syntaxesLink.setRel(Relations.SYNTAXES);\n        pageSummary.getLinks().add(syntaxesLink);\n    }","id":97098,"modified_method":"private static void fillPageSummary(PageSummary pageSummary, ObjectFactory objectFactory, URI baseUri,\n        Document doc, boolean useVersion, XWiki xwikiApi, Boolean withPrettyNames) throws XWikiException\n    {\n        pageSummary.setWiki(doc.getWiki());\n        pageSummary.setFullName(doc.getFullName());\n        pageSummary.setId(doc.getPrefixedFullName());\n        pageSummary.setSpace(doc.getSpace());\n        pageSummary.setName(doc.getName());\n        pageSummary.setTitle(doc.getDisplayTitle());\n        pageSummary.setXwikiRelativeUrl(doc.getURL(\"view\"));\n        pageSummary.setXwikiAbsoluteUrl(doc.getExternalURL(\"view\"));\n        pageSummary.setTranslations(createTranslations(objectFactory, baseUri, doc));\n        pageSummary.setSyntax(doc.getSyntax().toIdString());\n        pageSummary.setVersion(doc.getVersion());\n        pageSummary.setAuthor(doc.getAuthor());\n        if (withPrettyNames) {\n            pageSummary.setAuthorName(xwikiApi.getUserName(doc.getAuthor(), false));\n        }\n\n        Document parent = Utils.getParentDocument(doc, xwikiApi);\n        pageSummary.setParent(doc.getParent());\n        // parentId must not be set if the parent document does not exist.\n        if (parent != null && !parent.isNew()) {\n            pageSummary.setParentId(parent.getPrefixedFullName());\n        } else {\n            pageSummary.setParentId(\"\");\n        }\n        \n        List<String> spaces = Utils.getSpacesFromSpaceId(doc.getSpace());\n        String spaceUri = uri(baseUri, SpaceResource.class, doc.getWiki(), spaces);\n        Link spaceLink = objectFactory.createLink();\n        spaceLink.setHref(spaceUri);\n        spaceLink.setRel(Relations.SPACE);\n        pageSummary.getLinks().add(spaceLink);\n\n        if (parent != null) {\n            String parentUri = uri(baseUri, PageResource.class, parent.getWiki(), spaces, parent.getName());\n            Link parentLink = objectFactory.createLink();\n            parentLink.setHref(parentUri);\n            parentLink.setRel(Relations.PARENT);\n            pageSummary.getLinks().add(parentLink);\n        }\n\n        String historyUri = uri(baseUri, PageHistoryResource.class, doc.getWiki(), \n                Utils.getSpacesFromSpaceId(doc.getSpace()), doc.getName());\n        Link historyLink = objectFactory.createLink();\n        historyLink.setHref(historyUri);\n        historyLink.setRel(Relations.HISTORY);\n        pageSummary.getLinks().add(historyLink);\n\n        if (!doc.getChildren().isEmpty()) {\n            String pageChildrenUri =\n                uri(baseUri, PageChildrenResource.class, doc.getWiki(), spaces, doc.getName());\n            Link pageChildrenLink = objectFactory.createLink();\n            pageChildrenLink.setHref(pageChildrenUri);\n            pageChildrenLink.setRel(Relations.CHILDREN);\n            pageSummary.getLinks().add(pageChildrenLink);\n        }\n\n        if (!doc.getComments().isEmpty()) {\n            String commentsUri;\n            if (useVersion) {\n                commentsUri =\n                    uri(baseUri, CommentsVersionResource.class, doc.getWiki(), spaces, doc.getName(),\n                        doc.getVersion());\n            } else {\n                commentsUri = uri(baseUri, CommentsResource.class, doc.getWiki(), spaces, doc.getName());\n            }\n\n            Link commentsLink = objectFactory.createLink();\n            commentsLink.setHref(commentsUri);\n            commentsLink.setRel(Relations.COMMENTS);\n            pageSummary.getLinks().add(commentsLink);\n        }\n\n        if (!doc.getAttachmentList().isEmpty()) {\n            String attachmentsUri;\n            if (useVersion) {\n                attachmentsUri =\n                    uri(baseUri, AttachmentsAtPageVersionResource.class, doc.getWiki(), spaces, doc.getName(),\n                        doc.getVersion());\n            } else {\n                attachmentsUri = uri(baseUri, AttachmentsResource.class, doc.getWiki(), spaces, doc.getName());\n            }\n\n            Link attachmentsLink = objectFactory.createLink();\n            attachmentsLink.setHref(attachmentsUri);\n            attachmentsLink.setRel(Relations.ATTACHMENTS);\n            pageSummary.getLinks().add(attachmentsLink);\n        }\n\n        if (!doc.getxWikiObjects().keySet().isEmpty()) {\n            String objectsUri;\n\n            if (useVersion) {\n                objectsUri =\n                    uri(baseUri, ObjectsAtPageVersionResource.class, doc.getWiki(), spaces, doc.getName(),\n                        doc.getVersion());\n            } else {\n                objectsUri = uri(baseUri, ObjectsResource.class, doc.getWiki(), spaces, doc.getName());\n            }\n            Link objectsLink = objectFactory.createLink();\n            objectsLink.setHref(objectsUri);\n            objectsLink.setRel(Relations.OBJECTS);\n            pageSummary.getLinks().add(objectsLink);\n        }\n\n        com.xpn.xwiki.api.Object tagsObject = doc.getObject(\"XWiki.TagClass\", 0);\n        if (tagsObject != null) {\n            if (tagsObject.getProperty(\"tags\") != null) {\n                String tagsUri = uri(baseUri, PageTagsResource.class, doc.getWiki(), spaces, doc.getName());\n                Link tagsLink = objectFactory.createLink();\n                tagsLink.setHref(tagsUri);\n                tagsLink.setRel(Relations.TAGS);\n                pageSummary.getLinks().add(tagsLink);\n            }\n        }\n\n        String syntaxesUri = uri(baseUri, SyntaxesResource.class);\n        Link syntaxesLink = objectFactory.createLink();\n        syntaxesLink.setHref(syntaxesUri);\n        syntaxesLink.setRel(Relations.SYNTAXES);\n        pageSummary.getLinks().add(syntaxesLink);\n    }","commit_id":"e741fe1eede0d929417ff9ef064d5c06d51379a9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static PageSummary createPageSummary(ObjectFactory objectFactory, URI baseUri, Document doc, XWiki xwikiApi,\n        Boolean withPrettyNames) throws XWikiException\n    {\n        PageSummary pageSummary = objectFactory.createPageSummary();\n        fillPageSummary(pageSummary, objectFactory, baseUri, doc, false, xwikiApi, withPrettyNames);\n\n        String pageUri = uri(baseUri, PageResource.class, doc.getWiki(), doc.getSpace(), doc.getName());\n        Link pageLink = objectFactory.createLink();\n        pageLink.setHref(pageUri);\n        pageLink.setRel(Relations.PAGE);\n        pageSummary.getLinks().add(pageLink);\n\n        return pageSummary;\n    }","id":97099,"modified_method":"public static PageSummary createPageSummary(ObjectFactory objectFactory, URI baseUri, Document doc, XWiki xwikiApi,\n        Boolean withPrettyNames) throws XWikiException\n    {\n        PageSummary pageSummary = objectFactory.createPageSummary();\n        fillPageSummary(pageSummary, objectFactory, baseUri, doc, false, xwikiApi, withPrettyNames);\n\n        String pageUri = uri(baseUri, PageResource.class, doc.getWiki(), Utils.getSpacesFromSpaceId(doc.getSpace()),\n            doc.getName());\n        Link pageLink = objectFactory.createLink();\n        pageLink.setHref(pageUri);\n        pageLink.setRel(Relations.PAGE);\n        pageSummary.getLinks().add(pageLink);\n\n        return pageSummary;\n    }","commit_id":"e741fe1eede0d929417ff9ef064d5c06d51379a9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static Attachment createAttachment(ObjectFactory objectFactory, URI baseUri,\n        com.xpn.xwiki.api.Attachment xwikiAttachment, String xwikiRelativeUrl, String xwikiAbsoluteUrl, XWiki xwikiApi,\n        Boolean withPrettyNames)\n    {\n        Attachment attachment = objectFactory.createAttachment();\n\n        fillAttachment(attachment, objectFactory, baseUri, xwikiAttachment, xwikiRelativeUrl, xwikiAbsoluteUrl,\n            xwikiApi, withPrettyNames);\n\n        Document doc = xwikiAttachment.getDocument();\n        String attachmentUri =\n            uri(baseUri, AttachmentResource.class, doc.getWiki(), doc.getSpace(), doc.getName(),\n                xwikiAttachment.getFilename());\n\n        Link attachmentLink = objectFactory.createLink();\n        attachmentLink.setHref(attachmentUri);\n        attachmentLink.setRel(Relations.ATTACHMENT_DATA);\n        attachment.getLinks().add(attachmentLink);\n\n        return attachment;\n    }","id":97100,"modified_method":"public static Attachment createAttachment(ObjectFactory objectFactory, URI baseUri,\n        com.xpn.xwiki.api.Attachment xwikiAttachment, String xwikiRelativeUrl, String xwikiAbsoluteUrl, XWiki xwikiApi,\n        Boolean withPrettyNames)\n    {\n        Attachment attachment = objectFactory.createAttachment();\n\n        fillAttachment(attachment, objectFactory, baseUri, xwikiAttachment, xwikiRelativeUrl, xwikiAbsoluteUrl,\n            xwikiApi, withPrettyNames);\n\n        Document doc = xwikiAttachment.getDocument();\n        String attachmentUri =\n            uri(baseUri, AttachmentResource.class, doc.getWiki(), Utils.getSpacesFromSpaceId(doc.getSpace()),\n                doc.getName(), xwikiAttachment.getFilename());\n\n        Link attachmentLink = objectFactory.createLink();\n        attachmentLink.setHref(attachmentUri);\n        attachmentLink.setRel(Relations.ATTACHMENT_DATA);\n        attachment.getLinks().add(attachmentLink);\n\n        return attachment;\n    }","commit_id":"e741fe1eede0d929417ff9ef064d5c06d51379a9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private static Link getObjectLink(ObjectFactory objectFactory, URI baseUri, Document doc, BaseObject xwikiObject,\n        boolean useVersion, String relation)\n    {\n        String objectUri;\n\n        if (useVersion) {\n            objectUri =\n                uri(baseUri, ObjectAtPageVersionResource.class, doc.getWiki(), doc.getSpace(), doc.getName(),\n                    doc.getVersion(), xwikiObject.getClassName(), xwikiObject.getNumber());\n        } else {\n            objectUri =\n                uri(baseUri, ObjectResource.class, doc.getWiki(), doc.getSpace(), doc.getName(),\n                    xwikiObject.getClassName(), xwikiObject.getNumber());\n        }\n        Link objectLink = objectFactory.createLink();\n        objectLink.setHref(objectUri);\n        objectLink.setRel(relation);\n\n        return objectLink;\n    }","id":97101,"modified_method":"private static Link getObjectLink(ObjectFactory objectFactory, URI baseUri, Document doc, BaseObject xwikiObject,\n        boolean useVersion, String relation)\n    {\n        String objectUri;\n\n        if (useVersion) {\n            objectUri =\n                uri(baseUri, ObjectAtPageVersionResource.class, doc.getWiki(),\n                    Utils.getSpacesFromSpaceId(doc.getSpace()), doc.getName(), doc.getVersion(),\n                        xwikiObject.getClassName(), xwikiObject.getNumber());\n        } else {\n            objectUri =\n                uri(baseUri, ObjectResource.class, doc.getWiki(), Utils.getSpacesFromSpaceId(doc.getSpace()),\n                        doc.getName(), xwikiObject.getClassName(), xwikiObject.getNumber());\n        }\n        Link objectLink = objectFactory.createLink();\n        objectLink.setHref(objectUri);\n        objectLink.setRel(relation);\n\n        return objectLink;\n    }","commit_id":"e741fe1eede0d929417ff9ef064d5c06d51379a9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static Attachment createAttachmentAtVersion(ObjectFactory objectFactory, URI baseUri,\n        com.xpn.xwiki.api.Attachment xwikiAttachment, String xwikiRelativeUrl, String xwikiAbsoluteUrl, XWiki xwikiApi,\n        Boolean withPrettyNames)\n    {\n        Attachment attachment = new Attachment();\n\n        fillAttachment(attachment, objectFactory, baseUri, xwikiAttachment, xwikiRelativeUrl, xwikiAbsoluteUrl,\n            xwikiApi, withPrettyNames);\n\n        Document doc = xwikiAttachment.getDocument();\n        String attachmentUri =\n            uri(baseUri, AttachmentVersionResource.class, doc.getWiki(), doc.getSpace(), doc.getName(),\n                xwikiAttachment.getFilename(), xwikiAttachment.getVersion());\n\n        Link attachmentLink = objectFactory.createLink();\n        attachmentLink.setHref(attachmentUri);\n        attachmentLink.setRel(Relations.ATTACHMENT_DATA);\n        attachment.getLinks().add(attachmentLink);\n\n        return attachment;\n    }","id":97102,"modified_method":"public static Attachment createAttachmentAtVersion(ObjectFactory objectFactory, URI baseUri,\n        com.xpn.xwiki.api.Attachment xwikiAttachment, String xwikiRelativeUrl, String xwikiAbsoluteUrl, XWiki xwikiApi,\n        Boolean withPrettyNames)\n    {\n        Attachment attachment = new Attachment();\n\n        fillAttachment(attachment, objectFactory, baseUri, xwikiAttachment, xwikiRelativeUrl, xwikiAbsoluteUrl,\n            xwikiApi, withPrettyNames);\n\n        Document doc = xwikiAttachment.getDocument();\n        String attachmentUri =\n            uri(baseUri, AttachmentVersionResource.class, doc.getWiki(), Utils.getSpacesFromSpaceId(doc.getSpace()),\n                doc.getName(), xwikiAttachment.getFilename(), xwikiAttachment.getVersion());\n\n        Link attachmentLink = objectFactory.createLink();\n        attachmentLink.setHref(attachmentUri);\n        attachmentLink.setRel(Relations.ATTACHMENT_DATA);\n        attachment.getLinks().add(attachmentLink);\n\n        return attachment;\n    }","commit_id":"e741fe1eede0d929417ff9ef064d5c06d51379a9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private static void fillAttachment(Attachment attachment, ObjectFactory objectFactory, URI baseUri,\n        com.xpn.xwiki.api.Attachment xwikiAttachment, String xwikiRelativeUrl, String xwikiAbsoluteUrl, XWiki xwikiApi,\n        Boolean withPrettyNames)\n    {\n        Document doc = xwikiAttachment.getDocument();\n\n        attachment.setId(String.format(\"%s@%s\", doc.getPrefixedFullName(), xwikiAttachment.getFilename()));\n        attachment.setName(xwikiAttachment.getFilename());\n        attachment.setSize(xwikiAttachment.getFilesize());\n        attachment.setVersion(xwikiAttachment.getVersion());\n        attachment.setPageId(doc.getPrefixedFullName());\n        attachment.setPageVersion(doc.getVersion());\n        attachment.setMimeType(xwikiAttachment.getMimeType());\n        attachment.setAuthor(xwikiAttachment.getAuthor());\n        if (withPrettyNames) {\n            attachment.setAuthorName(xwikiApi.getUserName(xwikiAttachment.getAuthor(), false));\n        }\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(xwikiAttachment.getDate());\n        attachment.setDate(calendar);\n\n        attachment.setXwikiRelativeUrl(xwikiRelativeUrl);\n        attachment.setXwikiAbsoluteUrl(xwikiAbsoluteUrl);\n\n        String pageUri = uri(baseUri, PageResource.class, doc.getWiki(), doc.getSpace(), doc.getName());\n        Link pageLink = objectFactory.createLink();\n        pageLink.setHref(pageUri);\n        pageLink.setRel(Relations.PAGE);\n        attachment.getLinks().add(pageLink);\n    }","id":97103,"modified_method":"private static void fillAttachment(Attachment attachment, ObjectFactory objectFactory, URI baseUri,\n        com.xpn.xwiki.api.Attachment xwikiAttachment, String xwikiRelativeUrl, String xwikiAbsoluteUrl, XWiki xwikiApi,\n        Boolean withPrettyNames)\n    {\n        Document doc = xwikiAttachment.getDocument();\n\n        attachment.setId(String.format(\"%s@%s\", doc.getPrefixedFullName(), xwikiAttachment.getFilename()));\n        attachment.setName(xwikiAttachment.getFilename());\n        attachment.setSize(xwikiAttachment.getFilesize());\n        attachment.setVersion(xwikiAttachment.getVersion());\n        attachment.setPageId(doc.getPrefixedFullName());\n        attachment.setPageVersion(doc.getVersion());\n        attachment.setMimeType(xwikiAttachment.getMimeType());\n        attachment.setAuthor(xwikiAttachment.getAuthor());\n        if (withPrettyNames) {\n            attachment.setAuthorName(xwikiApi.getUserName(xwikiAttachment.getAuthor(), false));\n        }\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(xwikiAttachment.getDate());\n        attachment.setDate(calendar);\n\n        attachment.setXwikiRelativeUrl(xwikiRelativeUrl);\n        attachment.setXwikiAbsoluteUrl(xwikiAbsoluteUrl);\n\n        String pageUri = uri(baseUri, PageResource.class, doc.getWiki(), Utils.getSpacesFromSpaceId(doc.getSpace()),\n            doc.getName());\n        Link pageLink = objectFactory.createLink();\n        pageLink.setHref(pageUri);\n        pageLink.setRel(Relations.PAGE);\n        attachment.getLinks().add(pageLink);\n    }","commit_id":"e741fe1eede0d929417ff9ef064d5c06d51379a9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static Comment createComment(ObjectFactory objectFactory, URI baseUri, Document doc,\n        com.xpn.xwiki.api.Object xwikiComment, XWiki xwikiApi, Boolean withPrettyNames)\n    {\n        Comment comment = objectFactory.createComment();\n        comment.setId(xwikiComment.getNumber());\n\n        com.xpn.xwiki.api.Property property = xwikiComment.getProperty(\"author\");\n        if (property != null) {\n            comment.setAuthor((String) property.getValue());\n            if (withPrettyNames) {\n                comment.setAuthorName(xwikiApi.getUserName((String) property.getValue(), false));\n            }\n        }\n\n        property = xwikiComment.getProperty(\"date\");\n        if (property != null) {\n            Calendar calendar = Calendar.getInstance();\n            calendar.setTime((Date) property.getValue());\n            comment.setDate(calendar);\n        }\n\n        property = xwikiComment.getProperty(\"highlight\");\n        if (property != null) {\n            comment.setHighlight((String) property.getValue());\n        }\n\n        property = xwikiComment.getProperty(\"comment\");\n        if (property != null) {\n            comment.setText((String) property.getValue());\n        }\n\n        property = xwikiComment.getProperty(\"replyto\");\n        if (property != null) {\n            comment.setReplyTo((Integer) property.getValue());\n        }\n\n        String pageUri = uri(baseUri, PageResource.class, doc.getWiki(), doc.getSpace(), doc.getName());\n        Link pageLink = objectFactory.createLink();\n        pageLink.setHref(pageUri);\n        pageLink.setRel(Relations.PAGE);\n        comment.getLinks().add(pageLink);\n\n        return comment;\n    }","id":97104,"modified_method":"public static Comment createComment(ObjectFactory objectFactory, URI baseUri, Document doc,\n        com.xpn.xwiki.api.Object xwikiComment, XWiki xwikiApi, Boolean withPrettyNames)\n    {\n        Comment comment = objectFactory.createComment();\n        comment.setId(xwikiComment.getNumber());\n\n        com.xpn.xwiki.api.Property property = xwikiComment.getProperty(\"author\");\n        if (property != null) {\n            comment.setAuthor((String) property.getValue());\n            if (withPrettyNames) {\n                comment.setAuthorName(xwikiApi.getUserName((String) property.getValue(), false));\n            }\n        }\n\n        property = xwikiComment.getProperty(\"date\");\n        if (property != null) {\n            Calendar calendar = Calendar.getInstance();\n            calendar.setTime((Date) property.getValue());\n            comment.setDate(calendar);\n        }\n\n        property = xwikiComment.getProperty(\"highlight\");\n        if (property != null) {\n            comment.setHighlight((String) property.getValue());\n        }\n\n        property = xwikiComment.getProperty(\"comment\");\n        if (property != null) {\n            comment.setText((String) property.getValue());\n        }\n\n        property = xwikiComment.getProperty(\"replyto\");\n        if (property != null) {\n            comment.setReplyTo((Integer) property.getValue());\n        }\n\n        String pageUri = uri(baseUri, PageResource.class, doc.getWiki(), Utils.getSpacesFromSpaceId(doc.getSpace()),\n            doc.getName());\n        Link pageLink = objectFactory.createLink();\n        pageLink.setHref(pageUri);\n        pageLink.setRel(Relations.PAGE);\n        comment.getLinks().add(pageLink);\n\n        return comment;\n    }","commit_id":"e741fe1eede0d929417ff9ef064d5c06d51379a9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static ObjectSummary createObjectSummary(ObjectFactory objectFactory, URI baseUri,\n        XWikiContext xwikiContext, Document doc, BaseObject xwikiObject, boolean useVersion, XWiki xwikiApi,\n        Boolean withPrettyNames) throws XWikiException\n    {\n        ObjectSummary objectSummary = objectFactory.createObjectSummary();\n        fillObjectSummary(objectSummary, objectFactory, baseUri, doc, xwikiObject, xwikiApi, withPrettyNames);\n\n        Link objectLink = getObjectLink(objectFactory, baseUri, doc, xwikiObject, useVersion, Relations.OBJECT);\n        objectSummary.getLinks().add(objectLink);\n\n        String propertiesUri;\n\n        if (useVersion) {\n            propertiesUri =\n                uri(baseUri, ObjectPropertiesAtPageVersionResource.class, doc.getWiki(), doc.getSpace(), doc.getName(),\n                    doc.getVersion(), xwikiObject.getClassName(), xwikiObject.getNumber());\n        } else {\n            propertiesUri =\n                uri(baseUri, ObjectPropertiesResource.class, doc.getWiki(), doc.getSpace(), doc.getName(),\n                    xwikiObject.getClassName(), xwikiObject.getNumber());\n        }\n\n        Link propertyLink = objectFactory.createLink();\n        propertyLink.setHref(propertiesUri);\n        propertyLink.setRel(Relations.PROPERTIES);\n        objectSummary.getLinks().add(propertyLink);\n\n        return objectSummary;\n    }","id":97105,"modified_method":"public static ObjectSummary createObjectSummary(ObjectFactory objectFactory, URI baseUri,\n        XWikiContext xwikiContext, Document doc, BaseObject xwikiObject, boolean useVersion, XWiki xwikiApi,\n        Boolean withPrettyNames) throws XWikiException\n    {\n        ObjectSummary objectSummary = objectFactory.createObjectSummary();\n        fillObjectSummary(objectSummary, objectFactory, baseUri, doc, xwikiObject, xwikiApi, withPrettyNames);\n\n        Link objectLink = getObjectLink(objectFactory, baseUri, doc, xwikiObject, useVersion, Relations.OBJECT);\n        objectSummary.getLinks().add(objectLink);\n\n        String propertiesUri;\n\n        if (useVersion) {\n            propertiesUri =\n                uri(baseUri, ObjectPropertiesAtPageVersionResource.class, doc.getWiki(),\n                    Utils.getSpacesFromSpaceId(doc.getSpace()), doc.getName(), doc.getVersion(), \n                        xwikiObject.getClassName(), xwikiObject.getNumber());\n        } else {\n            propertiesUri =\n                uri(baseUri, ObjectPropertiesResource.class, doc.getWiki(), Utils.getSpacesFromSpaceId(doc.getSpace()),\n                    doc.getName(), xwikiObject.getClassName(), xwikiObject.getNumber());\n        }\n\n        Link propertyLink = objectFactory.createLink();\n        propertyLink.setHref(propertiesUri);\n        propertyLink.setRel(Relations.PROPERTIES);\n        objectSummary.getLinks().add(propertyLink);\n\n        return objectSummary;\n    }","commit_id":"e741fe1eede0d929417ff9ef064d5c06d51379a9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static Translations createTranslations(ObjectFactory objectFactory, URI baseUri, Document doc)\n        throws XWikiException\n    {\n        Translations translations = objectFactory.createTranslations();\n\n        List<String> languages = doc.getTranslationList();\n\n        if (!languages.isEmpty()) {\n            if (!doc.getDefaultLanguage().equals(\"\")) {\n                translations.setDefault(doc.getDefaultLanguage());\n\n                Translation translation = objectFactory.createTranslation();\n                translation.setLanguage(doc.getDefaultLanguage());\n\n                /* Add the default page with the default translation explicitely */\n                String pageTranslationUri =\n                    uri(baseUri, PageResource.class, doc.getWiki(), doc.getSpace(), doc.getName());\n                Link pageTranslationLink = objectFactory.createLink();\n                pageTranslationLink.setHref(pageTranslationUri);\n                pageTranslationLink.setRel(Relations.PAGE);\n                translation.getLinks().add(pageTranslationLink);\n\n                String historyUri =\n                    uri(baseUri, PageHistoryResource.class, doc.getWiki(), doc.getSpace(), doc.getName());\n                Link historyLink = objectFactory.createLink();\n                historyLink.setHref(historyUri);\n                historyLink.setRel(Relations.HISTORY);\n                translation.getLinks().add(historyLink);\n\n                translations.getTranslations().add(translation);\n            }\n        }\n\n        for (String language : languages) {\n            Translation translation = objectFactory.createTranslation();\n            translation.setLanguage(language);\n\n            String pageTranslationUri =\n                uri(baseUri, PageTranslationResource.class, doc.getWiki(), doc.getSpace(), doc.getName(), language);\n            Link pageTranslationLink = objectFactory.createLink();\n            pageTranslationLink.setHref(pageTranslationUri);\n            pageTranslationLink.setRel(Relations.PAGE);\n            translation.getLinks().add(pageTranslationLink);\n\n            String historyUri =\n                uri(baseUri, PageTranslationHistoryResource.class, doc.getWiki(), doc.getSpace(), doc.getName(),\n                    language);\n            Link historyLink = objectFactory.createLink();\n            historyLink.setHref(historyUri);\n            historyLink.setRel(Relations.HISTORY);\n            translation.getLinks().add(historyLink);\n\n            translations.getTranslations().add(translation);\n        }\n\n        return translations;\n    }","id":97106,"modified_method":"public static Translations createTranslations(ObjectFactory objectFactory, URI baseUri, Document doc)\n        throws XWikiException\n    {\n        Translations translations = objectFactory.createTranslations();\n\n        List<String> languages = doc.getTranslationList();\n        \n        List<String> spaces = Utils.getSpacesFromSpaceId(doc.getSpace());\n\n        if (!languages.isEmpty()) {\n            if (!doc.getDefaultLanguage().equals(\"\")) {\n                translations.setDefault(doc.getDefaultLanguage());\n\n                Translation translation = objectFactory.createTranslation();\n                translation.setLanguage(doc.getDefaultLanguage());\n\n                /* Add the default page with the default translation explicitely */\n                String pageTranslationUri =\n                    uri(baseUri, PageResource.class, doc.getWiki(), spaces, doc.getName());\n                Link pageTranslationLink = objectFactory.createLink();\n                pageTranslationLink.setHref(pageTranslationUri);\n                pageTranslationLink.setRel(Relations.PAGE);\n                translation.getLinks().add(pageTranslationLink);\n\n                String historyUri =\n                    uri(baseUri, PageHistoryResource.class, doc.getWiki(), spaces, doc.getName());\n                Link historyLink = objectFactory.createLink();\n                historyLink.setHref(historyUri);\n                historyLink.setRel(Relations.HISTORY);\n                translation.getLinks().add(historyLink);\n\n                translations.getTranslations().add(translation);\n            }\n        }\n\n        for (String language : languages) {\n            Translation translation = objectFactory.createTranslation();\n            translation.setLanguage(language);\n\n            String pageTranslationUri =\n                uri(baseUri, PageTranslationResource.class, doc.getWiki(), spaces, doc.getName(), language);\n            Link pageTranslationLink = objectFactory.createLink();\n            pageTranslationLink.setHref(pageTranslationUri);\n            pageTranslationLink.setRel(Relations.PAGE);\n            translation.getLinks().add(pageTranslationLink);\n\n            String historyUri =\n                uri(baseUri, PageTranslationHistoryResource.class, doc.getWiki(), spaces, doc.getName(), language);\n            Link historyLink = objectFactory.createLink();\n            historyLink.setHref(historyUri);\n            historyLink.setRel(Relations.HISTORY);\n            translation.getLinks().add(historyLink);\n\n            translations.getTranslations().add(translation);\n        }\n\n        return translations;\n    }","commit_id":"e741fe1eede0d929417ff9ef064d5c06d51379a9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static Object createObject(ObjectFactory objectFactory, URI baseUri, XWikiContext xwikiContext,\n        Document doc, BaseObject xwikiObject, boolean useVersion, XWiki xwikiApi, Boolean withPrettyNames)\n        throws XWikiException\n    {\n        Object object = objectFactory.createObject();\n        fillObjectSummary(object, objectFactory, baseUri, doc, xwikiObject, xwikiApi, withPrettyNames);\n\n        BaseClass xwikiClass = xwikiObject.getXClass(xwikiContext);\n\n        for (java.lang.Object propertyClassObject : xwikiClass.getProperties()) {\n            com.xpn.xwiki.objects.classes.PropertyClass propertyClass =\n                (com.xpn.xwiki.objects.classes.PropertyClass) propertyClassObject;\n\n            Property property = objectFactory.createProperty();\n\n            for (java.lang.Object o : propertyClass.getProperties()) {\n                BaseProperty baseProperty = (BaseProperty) o;\n                Attribute attribute = objectFactory.createAttribute();\n                attribute.setName(baseProperty.getName());\n\n                /* Check for null values in order to prevent NPEs */\n                if (baseProperty.getValue() != null) {\n                    attribute.setValue(baseProperty.getValue().toString());\n                } else {\n                    attribute.setValue(\"\");\n                }\n\n                property.getAttributes().add(attribute);\n            }\n\n            if (propertyClass instanceof ListClass) {\n                ListClass listClass = (ListClass) propertyClass;\n\n                List allowedValueList = listClass.getList(xwikiContext);\n\n                if (!allowedValueList.isEmpty()) {\n                    Formatter f = new Formatter();\n                    for (int i = 0; i < allowedValueList.size(); i++) {\n                        if (i != allowedValueList.size() - 1) {\n                            f.format(\"%s,\", allowedValueList.get(i).toString());\n                        } else {\n                            f.format(\"%s\", allowedValueList.get(i).toString());\n                        }\n                    }\n\n                    Attribute attribute = objectFactory.createAttribute();\n                    attribute.setName(Constants.ALLOWED_VALUES_ATTRIBUTE_NAME);\n                    attribute.setValue(f.toString());\n                    property.getAttributes().add(attribute);\n                }\n            }\n\n            property.setName(propertyClass.getName());\n            property.setType(propertyClass.getClassType());\n            property.setValue(serializePropertyValue(xwikiObject.get(propertyClass.getName())));\n\n            String propertyUri;\n\n            if (useVersion) {\n                propertyUri =\n                    uri(baseUri, ObjectPropertyAtPageVersionResource.class, doc.getWiki(), doc.getSpace(),\n                        doc.getName(), doc.getVersion(), xwikiObject.getClassName(), xwikiObject.getNumber(),\n                        propertyClass.getName());\n            } else {\n                propertyUri =\n                    uri(baseUri, ObjectPropertyResource.class, doc.getWiki(), doc.getSpace(), doc.getName(),\n                        xwikiObject.getClassName(), xwikiObject.getNumber(), propertyClass.getName());\n            }\n            Link propertyLink = objectFactory.createLink();\n            propertyLink.setHref(propertyUri);\n            propertyLink.setRel(Relations.SELF);\n            property.getLinks().add(propertyLink);\n\n            object.getProperties().add(property);\n        }\n\n        Link objectLink = getObjectLink(objectFactory, baseUri, doc, xwikiObject, useVersion, Relations.SELF);\n        object.getLinks().add(objectLink);\n\n        return object;\n    }","id":97107,"modified_method":"public static Object createObject(ObjectFactory objectFactory, URI baseUri, XWikiContext xwikiContext,\n        Document doc, BaseObject xwikiObject, boolean useVersion, XWiki xwikiApi, Boolean withPrettyNames)\n        throws XWikiException\n    {\n        Object object = objectFactory.createObject();\n        fillObjectSummary(object, objectFactory, baseUri, doc, xwikiObject, xwikiApi, withPrettyNames);\n\n        BaseClass xwikiClass = xwikiObject.getXClass(xwikiContext);\n\n        for (java.lang.Object propertyClassObject : xwikiClass.getProperties()) {\n            com.xpn.xwiki.objects.classes.PropertyClass propertyClass =\n                (com.xpn.xwiki.objects.classes.PropertyClass) propertyClassObject;\n\n            Property property = objectFactory.createProperty();\n\n            for (java.lang.Object o : propertyClass.getProperties()) {\n                BaseProperty baseProperty = (BaseProperty) o;\n                Attribute attribute = objectFactory.createAttribute();\n                attribute.setName(baseProperty.getName());\n\n                /* Check for null values in order to prevent NPEs */\n                if (baseProperty.getValue() != null) {\n                    attribute.setValue(baseProperty.getValue().toString());\n                } else {\n                    attribute.setValue(\"\");\n                }\n\n                property.getAttributes().add(attribute);\n            }\n\n            if (propertyClass instanceof ListClass) {\n                ListClass listClass = (ListClass) propertyClass;\n\n                List allowedValueList = listClass.getList(xwikiContext);\n\n                if (!allowedValueList.isEmpty()) {\n                    Formatter f = new Formatter();\n                    for (int i = 0; i < allowedValueList.size(); i++) {\n                        if (i != allowedValueList.size() - 1) {\n                            f.format(\"%s,\", allowedValueList.get(i).toString());\n                        } else {\n                            f.format(\"%s\", allowedValueList.get(i).toString());\n                        }\n                    }\n\n                    Attribute attribute = objectFactory.createAttribute();\n                    attribute.setName(Constants.ALLOWED_VALUES_ATTRIBUTE_NAME);\n                    attribute.setValue(f.toString());\n                    property.getAttributes().add(attribute);\n                }\n            }\n\n            property.setName(propertyClass.getName());\n            property.setType(propertyClass.getClassType());\n            property.setValue(serializePropertyValue(xwikiObject.get(propertyClass.getName())));\n\n            String propertyUri;\n\n            if (useVersion) {\n                propertyUri =\n                    uri(baseUri, ObjectPropertyAtPageVersionResource.class, doc.getWiki(), \n                        Utils.getSpacesFromSpaceId(doc.getSpace()), doc.getName(), doc.getVersion(),\n                            xwikiObject.getClassName(), xwikiObject.getNumber(), propertyClass.getName());\n            } else {\n                propertyUri =\n                    uri(baseUri, ObjectPropertyResource.class, doc.getWiki(), \n                        Utils.getSpacesFromSpaceId(doc.getSpace()), doc.getName(), xwikiObject.getClassName(),\n                            xwikiObject.getNumber(), propertyClass.getName());\n            }\n            Link propertyLink = objectFactory.createLink();\n            propertyLink.setHref(propertyUri);\n            propertyLink.setRel(Relations.SELF);\n            property.getLinks().add(propertyLink);\n\n            object.getProperties().add(property);\n        }\n\n        Link objectLink = getObjectLink(objectFactory, baseUri, doc, xwikiObject, useVersion, Relations.SELF);\n        object.getLinks().add(objectLink);\n\n        return object;\n    }","commit_id":"e741fe1eede0d929417ff9ef064d5c06d51379a9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public Space getSpace(String wikiName, String spaceName) throws XWikiRestException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n        // TODO: explain why do this weird thing\n        List<String> spaces = parseSpaceSegments(\"spaces/\" + spaceName);\n        \n        //spaces.add(lastSpaceName);\n\n        try {\n            Utils.getXWikiContext(componentManager).setWikiId(wikiName);\n\n            String homeId = Utils.getPageId(wikiName, spaces, \"WebHome\");\n            Document home = null;\n\n            if (Utils.getXWikiApi(componentManager).exists(homeId)) {\n                home = Utils.getXWikiApi(componentManager).getDocument(homeId);\n            }\n\n            return DomainObjectFactory.createSpace(objectFactory, uriInfo.getBaseUri(), wikiName, spaces, home);\n        } catch (XWikiException e) {\n            throw new XWikiRestException(e);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }","id":97108,"modified_method":"@Override\n    public Space getSpace(String wikiName, String spaceName) throws XWikiRestException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n        List<String> spaces = parseSpaceSegments(spaceName);\n\n        try {\n            Utils.getXWikiContext(componentManager).setWikiId(wikiName);\n\n            String homeId = Utils.getPageId(wikiName, spaces, \"WebHome\");\n            Document home = null;\n\n            if (Utils.getXWikiApi(componentManager).exists(homeId)) {\n                home = Utils.getXWikiApi(componentManager).getDocument(homeId);\n            }\n\n            return DomainObjectFactory.createSpace(objectFactory, uriInfo.getBaseUri(), wikiName, spaces, home);\n        } catch (XWikiException e) {\n            throw new XWikiRestException(e);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }","commit_id":"e741fe1eede0d929417ff9ef064d5c06d51379a9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Creates an URI to access the specified resource. The given path elements are encoded before being inserted into\n     * the resource path.\n     * <p>\n     * NOTE: We added this method because {@link UriBuilder#build(Object...)} doesn't encode all special characters. See\n     * https://github.com/restlet/restlet-framework-java/issues/601 .\n     * \n     * @param baseURI the base URI\n     * @param resourceClass the resource class, used to get the URI path\n     * @param pathElements the path elements to insert in the resource path\n     * @return an URI that can be used to access the specified resource\n     */\n    public static URI createURI(URI baseURI, java.lang.Class< ? > resourceClass, java.lang.Object... pathElements)\n    {\n        Object[] encodedPathElements = new String[pathElements.length];\n        for (int i = 0; i < pathElements.length; i++) {\n            if (pathElements[i] != null) {\n                try {\n                    encodedPathElements[i] = URIUtil.encodePath(pathElements[i].toString());\n                } catch (URIException e) {\n                    throw new RuntimeException(\"Failed to encode path element: \" + pathElements[i], e);\n                }\n            } else {\n                encodedPathElements[i] = null;\n            }\n        }\n        return UriBuilder.fromUri(baseURI).path(resourceClass).buildFromEncoded(encodedPathElements);\n    }","id":97109,"modified_method":"/**\n     * Creates an URI to access the specified resource. The given path elements are encoded before being inserted into\n     * the resource path.\n     * <p>\n     * NOTE: We added this method because {@link UriBuilder#build(Object...)} doesn't encode all special characters. See\n     * https://github.com/restlet/restlet-framework-java/issues/601 .\n     * \n     * @param baseURI the base URI\n     * @param resourceClass the resource class, used to get the URI path\n     * @param pathElements the path elements to insert in the resource path\n     * @return an URI that can be used to access the specified resource\n     */\n    public static URI createURI(URI baseURI, java.lang.Class< ? > resourceClass, java.lang.Object... pathElements)\n    {\n        UriBuilder uriBuilder = UriBuilder.fromUri(baseURI).path(resourceClass);\n\n        // uriBuilder.toString() returns the path (see AbstractUriBuilder#toString())\n        // but it means UriBuilder must use AbstractUriBuilder from restlet.\n        // TODO: find a more generic way to not depend heavily on restlet.\n        List<String> pathVariableNames = getVariableNamesFromPathTemplate(uriBuilder.toString());\n          \n        Object[] encodedPathElements = new String[pathElements.length];\n        for (int i = 0; i < pathElements.length; i++) {\n            if (pathElements[i] != null) {\n                try {\n                    // see generateEncodedSpacesURISegment() to understand why we manually handle \"spaceName\"\n                    if (\"spaceName\".equals(pathVariableNames.get(i))) {\n                        if (!(pathElements[i] instanceof List)) {\n                            throw new RuntimeException(\"The 'spaceName' parameter must be a list!\");\n                        }\n                        encodedPathElements[i] = generateEncodedSpacesURISegment((List) pathElements[i]);\n                    } else {\n                        encodedPathElements[i] = URIUtil.encodePath(pathElements[i].toString());\n                    }\n                } catch (URIException e) {\n                    throw new RuntimeException(\"Failed to encode path element: \" + pathElements[i], e);\n                }\n            } else {\n                encodedPathElements[i] = null;\n            }\n        }\n        return uriBuilder.buildFromEncoded(encodedPathElements);\n    }","commit_id":"e741fe1eede0d929417ff9ef064d5c06d51379a9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param spaceSegments the space segments of the URL\n     * @return the list of parent spaces\n     * @throws XWikiRestException if the URL is malformed\n     */\n    public List<String> parseSpaceSegments(String spaceSegments) throws XWikiRestException\n    {\n        // The URL format is: \"spaces/A/spaces/B/spaces/C\" to actually point to the space \"A.B.C\".\n        List<String> spaces = new ArrayList<>();\n        int i = 0;\n        for (String space : spaceSegments.split(\"/\")) {\n            if (i % 2 == 0) {\n                // Every 2 segments, we should have \"spaces\". If not, the URL is malformed\n                if (!\"spaces\".equals(space)) {\n                    throw new XWikiRestException(\"Malformed URL: the spaces section is invalid.\");\n                }\n            } else {\n                spaces.add(space);\n            }\n            i++;\n        }\n        if (i == 0) {\n            throw new XWikiRestException(\"Malformed URL: the spaces section is empty.\");\n        }\n        return spaces;\n    }","id":97110,"modified_method":"/**\n     * @param spaceSegments the space segments of the URL\n     * @return the list of parent spaces\n     * @throws XWikiRestException if the URL is malformed\n     */\n    public List<String> parseSpaceSegments(String spaceSegments) throws XWikiRestException\n    {\n        // The URL format is: \"spaces/A/spaces/B/spaces/C\" to actually point to the space \"A.B.C\".\n        List<String> spaces = new ArrayList<>();\n        // We actually don't get the first \"spaces/\" segment so we start from the first space\n        int i = 1;\n        for (String space : spaceSegments.split(\"/\")) {\n            if (i % 2 == 0) {\n                // Every 2 segments, we should have \"spaces\". If not, the URL is malformed\n                if (!\"spaces\".equals(space)) {\n                    throw new XWikiRestException(\"Malformed URL: the spaces section is invalid.\");\n                }\n            } else {\n                spaces.add(space);\n            }\n            i++;\n        }\n        if (spaces.isEmpty()) {\n            throw new XWikiRestException(\"Malformed URL: the spaces section is empty.\");\n        }\n        return spaces;\n    }","commit_id":"e741fe1eede0d929417ff9ef064d5c06d51379a9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n  protected boolean canUninstallPackage(InstalledPackage pkg) {\n    if (!myHasManagement) return false;\n\n    if (PythonSdkType.isDocker(getSelectedSdk())) {\n      return false;\n    }\n\n    if (PythonSdkType.isVirtualEnv(getSelectedSdk()) && pkg instanceof PyPackage) {\n      final String location = ((PyPackage)pkg).getLocation();\n      if (location != null && location.startsWith(PySdkUtil.getUserSite())) {\n        return false;\n      }\n    }\n    final String name = pkg.getName();\n    if (PyPackageManager.PIP.equals(name) ||\n        PyPackageManager.SETUPTOOLS.equals(name) ||\n        PyPackageManager.DISTRIBUTE.equals(name) ||\n        PyCondaPackageManagerImpl.PYTHON.equals(name)) {\n      return false;\n    }\n    return true;\n  }","id":97111,"modified_method":"@Override\n  protected boolean canUninstallPackage(InstalledPackage pkg) {\n    if (!myHasManagement) return false;\n\n    if (!PyPackageUtil.packageManagementEnabled(getSelectedSdk())) return false;\n\n    if (PythonSdkType.isVirtualEnv(getSelectedSdk()) && pkg instanceof PyPackage) {\n      final String location = ((PyPackage)pkg).getLocation();\n      if (location != null && location.startsWith(PySdkUtil.getUserSite())) {\n        return false;\n      }\n    }\n    final String name = pkg.getName();\n    if (PyPackageManager.PIP.equals(name) ||\n        PyPackageManager.SETUPTOOLS.equals(name) ||\n        PyPackageManager.DISTRIBUTE.equals(name) ||\n        PyCondaPackageManagerImpl.PYTHON.equals(name)) {\n      return false;\n    }\n    return true;\n  }","commit_id":"8ca96eac675b083c91936ad9688f83afb0f39476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean installEnabled() {\n    if (PythonSdkType.isDocker(getSelectedSdk())) {\n      return false;\n    }\n\n    return myHasManagement;\n  }","id":97112,"modified_method":"@Override\n  protected boolean installEnabled() {\n    if (!PyPackageUtil.packageManagementEnabled(getSelectedSdk())) return false;\n\n    return myHasManagement;\n  }","commit_id":"8ca96eac675b083c91936ad9688f83afb0f39476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean canUpgradePackage(InstalledPackage pyPackage) {\n    if (PythonSdkType.isDocker(getSelectedSdk())) {\n      return false;\n    }\n\n    return myHasManagement && !PyCondaPackageManagerImpl.PYTHON.equals(pyPackage.getName());\n  }","id":97113,"modified_method":"@Override\n  protected boolean canUpgradePackage(InstalledPackage pyPackage) {\n    if (!PyPackageUtil.packageManagementEnabled(getSelectedSdk())) return false;\n\n    return myHasManagement && !PyCondaPackageManagerImpl.PYTHON.equals(pyPackage.getName());\n  }","commit_id":"8ca96eac675b083c91936ad9688f83afb0f39476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference,\n                                                    @NotNull HighlightSeverity severity) {\n      if (reference instanceof DocStringTypeReference) {\n        return;\n      }\n      String description = null;\n      PsiElement element = reference.getElement();\n      final String text = element.getText();\n      TextRange rangeInElement = reference.getRangeInElement();\n      String refText = text;  // text of the part we're working with\n      if (rangeInElement.getStartOffset() > 0 && rangeInElement.getEndOffset() > 0) {\n        refText = rangeInElement.substring(text);\n      }\n\n      final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2);\n      final String refName = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression)element).getReferencedName() : refText;\n      // Empty text, nothing to highlight\n      if (refName == null || refName.length() <= 0) {\n        return;\n      }\n\n      final List<QualifiedName> qualifiedNames = getCanonicalNames(reference, myTypeEvalContext);\n      for (QualifiedName name: qualifiedNames) {\n        final String canonicalName = name.toString();\n        for (String ignored : myIgnoredIdentifiers) {\n          if (ignored.endsWith(END_WILDCARD)) {\n            final String prefix = ignored.substring(0, ignored.length() - END_WILDCARD.length());\n            if (canonicalName.startsWith(prefix)) {\n              return;\n            }\n          }\n          else if (canonicalName.equals(ignored)) {\n            return;\n          }\n        }\n      }\n      // Legacy non-qualified ignore patterns\n      if (myIgnoredIdentifiers.contains(refName)) {\n        return;\n      }\n\n      if (element instanceof PyReferenceExpression) {\n        PyReferenceExpression expr = (PyReferenceExpression)element;\n        if (PyNames.COMPARISON_OPERATORS.contains(refName)) {\n          return;\n        }\n        if (expr.isQualified()) {\n          final PyClassTypeImpl object_type = (PyClassTypeImpl)PyBuiltinCache.getInstance(node).getObjectType();\n          if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refName)) {\n            return;\n          }\n        }\n        else {\n          if (PyUnreachableCodeInspection.hasAnyInterruptedControlFlowPaths(expr)) {\n            return;\n          }\n          if (LanguageLevel.forElement(node).isOlderThan(LanguageLevel.PYTHON26)) {\n            if (\"with\".equals(refName)) {\n              actions.add(new UnresolvedRefAddFutureImportQuickFix());\n            }\n          }\n          if (refText.equals(\"true\") || refText.equals(\"false\")) {\n            actions.add(new UnresolvedRefTrueFalseQuickFix(element));\n          }\n          addAddSelfFix(node, expr, actions);\n          PyCallExpression callExpression = PsiTreeUtil.getParentOfType(element, PyCallExpression.class);\n          if (callExpression != null && (!(callExpression.getCallee() instanceof PyQualifiedExpression) ||\n                                         ((PyQualifiedExpression)callExpression.getCallee()).getQualifier() == null)) {\n            actions.add(new UnresolvedRefCreateFunctionQuickFix(callExpression, expr));\n          }\n          final PyFunction parentFunction = PsiTreeUtil.getParentOfType(element, PyFunction.class);\n          final PyDecorator decorator = PsiTreeUtil.getParentOfType(element, PyDecorator.class);\n          final PyAnnotation annotation = PsiTreeUtil.getParentOfType(element, PyAnnotation.class);\n          final PyImportStatement importStatement = PsiTreeUtil.getParentOfType(element, PyImportStatement.class);\n          if (parentFunction != null && decorator == null && annotation == null && importStatement == null) {\n            actions.add(new UnresolvedReferenceAddParameterQuickFix(refName));\n          }\n          actions.add(new PyRenameUnresolvedRefQuickFix());\n        }\n        // unqualified:\n        // may be module's\n        if (PyModuleType.getPossibleInstanceMembers().contains(refName)) {\n          return;\n        }\n        // may be a \"try: import ...\"; not an error not to resolve\n        if ((\n          PsiTreeUtil.getParentOfType(\n            PsiTreeUtil.getParentOfType(node, PyImportElement.class), PyTryExceptStatement.class, PyIfStatement.class\n          ) != null\n        )) {\n          severity = HighlightSeverity.WEAK_WARNING;\n          description = PyBundle.message(\"INSP.module.$0.not.found\", refText);\n          // TODO: mark the node so that future references pointing to it won't result in a error, but in a warning\n        }\n      }\n      if (reference instanceof PsiReferenceEx && description == null) {\n        description = ((PsiReferenceEx)reference).getUnresolvedDescription();\n      }\n      if (description == null) {\n        boolean markedQualified = false;\n        if (element instanceof PyQualifiedExpression) {\n          // TODO: Add __qualname__ for Python 3.3 to the skeleton of <class 'object'>, introduce a pseudo-class skeleton for\n          // <class 'function'>\n          if (\"__qualname__\".equals(refText) && LanguageLevel.forElement(element).isAtLeast(LanguageLevel.PYTHON33)) {\n            return;\n          }\n          final PyQualifiedExpression expr = (PyQualifiedExpression)element;\n          if (PyNames.COMPARISON_OPERATORS.contains(expr.getReferencedName())) {\n            return;\n          }\n          final PyExpression qualifier = expr.getQualifier();\n          if (qualifier != null) {\n            PyType type = myTypeEvalContext.getType(qualifier);\n            if (type != null) {\n              if (ignoreUnresolvedMemberForType(type, reference, refName)) {\n                return;\n              }\n              addCreateMemberFromUsageFixes(type, reference, refText, actions);\n              if (type instanceof PyClassType) {\n                if (reference instanceof PyOperatorReference) {\n                  String className = type.getName();\n                  final PyClassType classType = (PyClassType)type;\n                  if (classType.isDefinition()) {\n                    final PyClassLikeType metaClassType = classType.getMetaClassType(myTypeEvalContext, true);\n                    if (metaClassType != null) {\n                      className = metaClassType.getName();\n                    }\n                  }\n                  description = PyBundle.message(\"INSP.unresolved.operator.ref\",\n                                                 className, refName,\n                                                 ((PyOperatorReference)reference).getReadableOperatorName());\n                }\n                else {\n                  description = PyBundle.message(\"INSP.unresolved.ref.$0.for.class.$1\", refText, type.getName());\n                }\n                markedQualified = true;\n              }\n              else if (isHasCustomMember(refName, type)) {\n                // We have dynamic members\n                return;\n              }\n              else {\n                description = PyBundle.message(\"INSP.cannot.find.$0.in.$1\", refText, type.getName());\n                markedQualified = true;\n              }\n            }\n          }\n        }\n        if (!markedQualified) {\n          description = PyBundle.message(\"INSP.unresolved.ref.$0\", refText);\n\n          // look in other imported modules for this whole name\n          if (PythonReferenceImporter.isImportable(element)) {\n            addAutoImportFix(node, reference, actions);\n          }\n\n          addCreateClassFix(refText, element, actions);\n        }\n      }\n      ProblemHighlightType hl_type;\n      if (severity == HighlightSeverity.WARNING) {\n        hl_type = ProblemHighlightType.GENERIC_ERROR_OR_WARNING;\n      }\n      else if (severity == HighlightSeverity.ERROR) {\n        hl_type = ProblemHighlightType.GENERIC_ERROR;\n      }\n      else {\n        hl_type = ProblemHighlightType.LIKE_UNKNOWN_SYMBOL;\n      }\n\n      PyImportStatementBase importStatementBase = PsiTreeUtil.getParentOfType(element, PyImportStatementBase.class);\n      if ((importStatementBase != null) && GenerateBinaryStubsFix.isApplicable(importStatementBase)) {\n        actions.addAll(GenerateBinaryStubsFix.generateFixes(importStatementBase));\n      }\n      if (qualifiedNames.size() == 1) {\n        final QualifiedName qualifiedName = qualifiedNames.get(0);\n        actions.add(new AddIgnoredIdentifierQuickFix(qualifiedName, false));\n        if (qualifiedName.getComponentCount() > 1) {\n          actions.add(new AddIgnoredIdentifierQuickFix(qualifiedName.removeLastComponent(), true));\n        }\n      }\n      addPluginQuickFixes(reference, actions);\n\n      if (reference instanceof PyImportReference) {\n        // TODO: Ignore references in the second part of the 'from ... import ...' expression\n        final QualifiedName qname = QualifiedName.fromDottedString(refName);\n        final List<String> components = qname.getComponents();\n        if (!components.isEmpty()) {\n          final String packageName = components.get(0);\n          final Module module = ModuleUtilCore.findModuleForPsiElement(node);\n          final Sdk sdk = PythonSdkType.findPythonSdk(module);\n          if (module != null && sdk != null) {\n            if (PyPIPackageUtil.INSTANCE.isInPyPI(packageName)) {\n              addInstallPackageAction(actions, packageName, module, sdk);\n            }\n            else {\n              if (PyPIPackageUtil.PACKAGES_TOPLEVEL.containsKey(packageName)) {\n                final String suggestedPackage = PyPIPackageUtil.PACKAGES_TOPLEVEL.get(packageName);\n                addInstallPackageAction(actions, suggestedPackage, module, sdk);\n              }\n            }\n          }\n        }\n      }\n      registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]));\n    }","id":97114,"modified_method":"private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference,\n                                                    @NotNull HighlightSeverity severity) {\n      if (reference instanceof DocStringTypeReference) {\n        return;\n      }\n      String description = null;\n      PsiElement element = reference.getElement();\n      final String text = element.getText();\n      TextRange rangeInElement = reference.getRangeInElement();\n      String refText = text;  // text of the part we're working with\n      if (rangeInElement.getStartOffset() > 0 && rangeInElement.getEndOffset() > 0) {\n        refText = rangeInElement.substring(text);\n      }\n\n      final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2);\n      final String refName = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression)element).getReferencedName() : refText;\n      // Empty text, nothing to highlight\n      if (refName == null || refName.length() <= 0) {\n        return;\n      }\n\n      final List<QualifiedName> qualifiedNames = getCanonicalNames(reference, myTypeEvalContext);\n      for (QualifiedName name: qualifiedNames) {\n        final String canonicalName = name.toString();\n        for (String ignored : myIgnoredIdentifiers) {\n          if (ignored.endsWith(END_WILDCARD)) {\n            final String prefix = ignored.substring(0, ignored.length() - END_WILDCARD.length());\n            if (canonicalName.startsWith(prefix)) {\n              return;\n            }\n          }\n          else if (canonicalName.equals(ignored)) {\n            return;\n          }\n        }\n      }\n      // Legacy non-qualified ignore patterns\n      if (myIgnoredIdentifiers.contains(refName)) {\n        return;\n      }\n\n      if (element instanceof PyReferenceExpression) {\n        PyReferenceExpression expr = (PyReferenceExpression)element;\n        if (PyNames.COMPARISON_OPERATORS.contains(refName)) {\n          return;\n        }\n        if (expr.isQualified()) {\n          final PyClassTypeImpl object_type = (PyClassTypeImpl)PyBuiltinCache.getInstance(node).getObjectType();\n          if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refName)) {\n            return;\n          }\n        }\n        else {\n          if (PyUnreachableCodeInspection.hasAnyInterruptedControlFlowPaths(expr)) {\n            return;\n          }\n          if (LanguageLevel.forElement(node).isOlderThan(LanguageLevel.PYTHON26)) {\n            if (\"with\".equals(refName)) {\n              actions.add(new UnresolvedRefAddFutureImportQuickFix());\n            }\n          }\n          if (refText.equals(\"true\") || refText.equals(\"false\")) {\n            actions.add(new UnresolvedRefTrueFalseQuickFix(element));\n          }\n          addAddSelfFix(node, expr, actions);\n          PyCallExpression callExpression = PsiTreeUtil.getParentOfType(element, PyCallExpression.class);\n          if (callExpression != null && (!(callExpression.getCallee() instanceof PyQualifiedExpression) ||\n                                         ((PyQualifiedExpression)callExpression.getCallee()).getQualifier() == null)) {\n            actions.add(new UnresolvedRefCreateFunctionQuickFix(callExpression, expr));\n          }\n          final PyFunction parentFunction = PsiTreeUtil.getParentOfType(element, PyFunction.class);\n          final PyDecorator decorator = PsiTreeUtil.getParentOfType(element, PyDecorator.class);\n          final PyAnnotation annotation = PsiTreeUtil.getParentOfType(element, PyAnnotation.class);\n          final PyImportStatement importStatement = PsiTreeUtil.getParentOfType(element, PyImportStatement.class);\n          if (parentFunction != null && decorator == null && annotation == null && importStatement == null) {\n            actions.add(new UnresolvedReferenceAddParameterQuickFix(refName));\n          }\n          actions.add(new PyRenameUnresolvedRefQuickFix());\n        }\n        // unqualified:\n        // may be module's\n        if (PyModuleType.getPossibleInstanceMembers().contains(refName)) {\n          return;\n        }\n        // may be a \"try: import ...\"; not an error not to resolve\n        if ((\n          PsiTreeUtil.getParentOfType(\n            PsiTreeUtil.getParentOfType(node, PyImportElement.class), PyTryExceptStatement.class, PyIfStatement.class\n          ) != null\n        )) {\n          severity = HighlightSeverity.WEAK_WARNING;\n          description = PyBundle.message(\"INSP.module.$0.not.found\", refText);\n          // TODO: mark the node so that future references pointing to it won't result in a error, but in a warning\n        }\n      }\n      if (reference instanceof PsiReferenceEx && description == null) {\n        description = ((PsiReferenceEx)reference).getUnresolvedDescription();\n      }\n      if (description == null) {\n        boolean markedQualified = false;\n        if (element instanceof PyQualifiedExpression) {\n          // TODO: Add __qualname__ for Python 3.3 to the skeleton of <class 'object'>, introduce a pseudo-class skeleton for\n          // <class 'function'>\n          if (\"__qualname__\".equals(refText) && LanguageLevel.forElement(element).isAtLeast(LanguageLevel.PYTHON33)) {\n            return;\n          }\n          final PyQualifiedExpression expr = (PyQualifiedExpression)element;\n          if (PyNames.COMPARISON_OPERATORS.contains(expr.getReferencedName())) {\n            return;\n          }\n          final PyExpression qualifier = expr.getQualifier();\n          if (qualifier != null) {\n            PyType type = myTypeEvalContext.getType(qualifier);\n            if (type != null) {\n              if (ignoreUnresolvedMemberForType(type, reference, refName)) {\n                return;\n              }\n              addCreateMemberFromUsageFixes(type, reference, refText, actions);\n              if (type instanceof PyClassType) {\n                if (reference instanceof PyOperatorReference) {\n                  String className = type.getName();\n                  final PyClassType classType = (PyClassType)type;\n                  if (classType.isDefinition()) {\n                    final PyClassLikeType metaClassType = classType.getMetaClassType(myTypeEvalContext, true);\n                    if (metaClassType != null) {\n                      className = metaClassType.getName();\n                    }\n                  }\n                  description = PyBundle.message(\"INSP.unresolved.operator.ref\",\n                                                 className, refName,\n                                                 ((PyOperatorReference)reference).getReadableOperatorName());\n                }\n                else {\n                  description = PyBundle.message(\"INSP.unresolved.ref.$0.for.class.$1\", refText, type.getName());\n                }\n                markedQualified = true;\n              }\n              else if (isHasCustomMember(refName, type)) {\n                // We have dynamic members\n                return;\n              }\n              else {\n                description = PyBundle.message(\"INSP.cannot.find.$0.in.$1\", refText, type.getName());\n                markedQualified = true;\n              }\n            }\n          }\n        }\n        if (!markedQualified) {\n          description = PyBundle.message(\"INSP.unresolved.ref.$0\", refText);\n\n          // look in other imported modules for this whole name\n          if (PythonReferenceImporter.isImportable(element)) {\n            addAutoImportFix(node, reference, actions);\n          }\n\n          addCreateClassFix(refText, element, actions);\n        }\n      }\n      ProblemHighlightType hl_type;\n      if (severity == HighlightSeverity.WARNING) {\n        hl_type = ProblemHighlightType.GENERIC_ERROR_OR_WARNING;\n      }\n      else if (severity == HighlightSeverity.ERROR) {\n        hl_type = ProblemHighlightType.GENERIC_ERROR;\n      }\n      else {\n        hl_type = ProblemHighlightType.LIKE_UNKNOWN_SYMBOL;\n      }\n\n      PyImportStatementBase importStatementBase = PsiTreeUtil.getParentOfType(element, PyImportStatementBase.class);\n      if ((importStatementBase != null) && GenerateBinaryStubsFix.isApplicable(importStatementBase)) {\n        actions.addAll(GenerateBinaryStubsFix.generateFixes(importStatementBase));\n      }\n      if (qualifiedNames.size() == 1) {\n        final QualifiedName qualifiedName = qualifiedNames.get(0);\n        actions.add(new AddIgnoredIdentifierQuickFix(qualifiedName, false));\n        if (qualifiedName.getComponentCount() > 1) {\n          actions.add(new AddIgnoredIdentifierQuickFix(qualifiedName.removeLastComponent(), true));\n        }\n      }\n      addPluginQuickFixes(reference, actions);\n\n      if (reference instanceof PyImportReference) {\n        // TODO: Ignore references in the second part of the 'from ... import ...' expression\n        final QualifiedName qname = QualifiedName.fromDottedString(refName);\n        final List<String> components = qname.getComponents();\n        if (!components.isEmpty()) {\n          final String packageName = components.get(0);\n          final Module module = ModuleUtilCore.findModuleForPsiElement(node);\n          final Sdk sdk = PythonSdkType.findPythonSdk(module);\n          if (module != null && sdk != null && PyPackageUtil.packageManagementEnabled(sdk)) {\n            if (PyPIPackageUtil.INSTANCE.isInPyPI(packageName)) {\n              addInstallPackageAction(actions, packageName, module, sdk);\n            }\n            else {\n              if (PyPIPackageUtil.PACKAGES_TOPLEVEL.containsKey(packageName)) {\n                final String suggestedPackage = PyPIPackageUtil.PACKAGES_TOPLEVEL.get(packageName);\n                addInstallPackageAction(actions, suggestedPackage, module, sdk);\n              }\n            }\n          }\n        }\n      }\n      registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]));\n    }","commit_id":"8ca96eac675b083c91936ad9688f83afb0f39476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ClientResponse sendDeleteRequestToServer( long id ) throws Exception\n    {\n        return Client.create().resource( new URI( server.restApiUri() + \"node/\" + id ) ).delete( ClientResponse.class );\n    }","id":97115,"modified_method":"private ClientResponse sendDeleteRequestToServer( long id ) throws Exception\n    {\n        return Client.\n                create().\n                resource( new URI( server.restApiUri() + \"node/\" + id ) ).\n                type( MediaType.APPLICATION_JSON_TYPE ).\n                accept( MediaType.APPLICATION_JSON_TYPE ).\n                delete( ClientResponse.class );\n    }","commit_id":"451dba031803fadaaf03e7a54972c92405764b22","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 400, response.getStatus() );\n\n    }","id":97116,"modified_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.type( MediaType.APPLICATION_JSON_TYPE ).accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 201, response.getStatus() );\n\n    }","commit_id":"451dba031803fadaaf03e7a54972c92405764b22","url":"https://github.com/neo4j/neo4j"},{"original_method":"private ClientResponse sendDeleteRequestToServer( long id ) throws Exception\n    {\n        return Client.create().resource( new URI( server.restApiUri() + \"node/\" + id ) ).delete( ClientResponse.class );\n    }","id":97117,"modified_method":"private ClientResponse sendDeleteRequestToServer( long id ) throws Exception\n    {\n        return Client.\n                create().\n                resource( new URI( server.restApiUri() + \"node/\" + id ) ).\n                type( MediaType.APPLICATION_JSON_TYPE ).\n                accept( MediaType.APPLICATION_JSON_TYPE ).\n                delete( ClientResponse.class );\n    }","commit_id":"6f6ab4e252efd6fc3a48b00dba761e8c0e5a9fb0","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 400, response.getStatus() );\n\n    }","id":97118,"modified_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.type( MediaType.APPLICATION_JSON_TYPE ).accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 201, response.getStatus() );\n\n    }","commit_id":"6f6ab4e252efd6fc3a48b00dba761e8c0e5a9fb0","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 400, response.getStatus() );\n\n    }","id":97119,"modified_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.type( MediaType.APPLICATION_JSON_TYPE ).accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 201, response.getStatus() );\n\n    }","commit_id":"9772dcce515844edfc9111829898a943b018a803","url":"https://github.com/neo4j/neo4j"},{"original_method":"private ClientResponse sendDeleteRequestToServer( long id ) throws Exception\n    {\n        return Client.create().resource( new URI( server.restApiUri() + \"node/\" + id ) ).delete( ClientResponse.class );\n    }","id":97120,"modified_method":"private ClientResponse sendDeleteRequestToServer( long id ) throws Exception\n    {\n        return Client.\n                create().\n                resource( new URI( server.restApiUri() + \"node/\" + id ) ).\n                type( MediaType.APPLICATION_JSON_TYPE ).\n                accept( MediaType.APPLICATION_JSON_TYPE ).\n                delete( ClientResponse.class );\n    }","commit_id":"9772dcce515844edfc9111829898a943b018a803","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 400, response.getStatus() );\n\n    }","id":97121,"modified_method":"@Test\n    public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n    {\n        Client client = Client.create();\n        WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n        ClientResponse response = resource.type( MediaType.APPLICATION_JSON_TYPE ).accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n        assertEquals( 201, response.getStatus() );\n\n    }","commit_id":"988c165fd6521312497640600c8a799a682e6a13","url":"https://github.com/neo4j/neo4j"},{"original_method":"private ClientResponse sendDeleteRequestToServer( long id ) throws Exception\n    {\n        return Client.create().resource( new URI( server.restApiUri() + \"node/\" + id ) ).delete( ClientResponse.class );\n    }","id":97122,"modified_method":"private ClientResponse sendDeleteRequestToServer( long id ) throws Exception\n    {\n        return Client.\n                create().\n                resource( new URI( server.restApiUri() + \"node/\" + id ) ).\n                type( MediaType.APPLICATION_JSON_TYPE ).\n                accept( MediaType.APPLICATION_JSON_TYPE ).\n                delete( ClientResponse.class );\n    }","commit_id":"988c165fd6521312497640600c8a799a682e6a13","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static Object[] getVariants(GrReferenceExpressionImpl refExpr) {\n    Object[] propertyVariants = getVariantsImpl(refExpr, GrReferenceExpressionImpl.getMethodOrPropertyResolveProcessor(refExpr, null, true, false));\n    PsiType type = null;\n    final GrExpression qualifier = refExpr.getQualifierExpression();\n    if (qualifier == null) {\n      PsiElement parent = refExpr.getParent();\n      if (parent instanceof GrArgumentList) {\n        final PsiElement pparent = parent.getParent();\n        if (pparent instanceof GrExpression) {\n          GrExpression call = (GrExpression) pparent; //add named argument label variants\n          type = call.getType();\n        }\n      }\n    } else {\n      type = qualifier.getType();\n    }\n\n    if (type instanceof PsiClassType) {\n      PsiClass clazz = ((PsiClassType) type).resolve();\n      if (clazz != null) {\n        List<LookupElement> props = getPropertyVariants(refExpr, clazz);\n\n        if (props.size() > 0) {\n          propertyVariants = ArrayUtil.mergeArrays(propertyVariants, props.toArray(new Object[props.size()]), Object.class);\n        }\n\n        propertyVariants = ArrayUtil.mergeArrays(propertyVariants, clazz.getFields(), Object.class);\n      }\n    }\n\n    if (refExpr.getKind() == GrReferenceExpressionImpl.Kind.TYPE_OR_PROPERTY) {\n      ResolverProcessor classVariantsCollector = new ResolverProcessor(null, EnumSet.of(ClassHint.ResolveKind.CLASS_OR_PACKAGE), refExpr, true, PsiType.EMPTY_ARRAY);\n      final Object[] classVariants = getVariantsImpl(refExpr, classVariantsCollector);\n      return ArrayUtil.mergeArrays(propertyVariants, classVariants, Object.class);\n    } else {\n      Object[] specificVariants = GroovyCompletionUtil.getContextSpecificVariants(refExpr);\n      return ArrayUtil.mergeArrays(propertyVariants, specificVariants, Object.class);\n    }\n\n  }","id":97123,"modified_method":"public static Object[] getVariants(GrReferenceExpressionImpl refExpr) {\n    Object[] propertyVariants = getVariantsImpl(refExpr, GrReferenceExpressionImpl.getMethodOrPropertyResolveProcessor(refExpr, null, true, false));\n    PsiType type = null;\n    final GrExpression qualifier = refExpr.getQualifierExpression();\n    if (qualifier == null) {\n      PsiElement parent = refExpr.getParent();\n      if (parent instanceof GrArgumentList) {\n        final PsiElement pparent = parent.getParent();\n        if (pparent instanceof GrExpression) {\n          GrExpression call = (GrExpression) pparent; //add named argument label variants\n          type = call.getType();\n        }\n      }\n    } else {\n      type = qualifier.getType();\n    }\n\n    if (type instanceof PsiClassType) {\n      PsiClass clazz = ((PsiClassType) type).resolve();\n      if (clazz != null) {\n        List<LookupElement> props = getPropertyVariants(refExpr, clazz);\n\n        if (props.size() > 0) {\n          propertyVariants = ArrayUtil.mergeArrays(propertyVariants, props.toArray(new Object[props.size()]), Object.class);\n        }\n\n        propertyVariants = ArrayUtil.mergeArrays(propertyVariants, clazz.getFields(), Object.class);\n      }\n    }\n\n    Object[] specificVariants = GroovyCompletionUtil.getContextSpecificVariants(refExpr);\n    if (refExpr.getKind() == GrReferenceExpressionImpl.Kind.TYPE_OR_PROPERTY) {\n      ResolverProcessor classVariantsCollector = new ResolverProcessor(null, EnumSet.of(ClassHint.ResolveKind.CLASS_OR_PACKAGE), refExpr, true, PsiType.EMPTY_ARRAY);\n      final Object[] classVariants = getVariantsImpl(refExpr, classVariantsCollector);\n      if (specificVariants.length > 0) {\n        return ArrayUtil.mergeArrays(ArrayUtil.mergeArrays(propertyVariants, classVariants, Object.class), specificVariants, Object.class);\n      } else {\n        return ArrayUtil.mergeArrays(propertyVariants, classVariants, Object.class);\n      }\n    } else {\n      return ArrayUtil.mergeArrays(propertyVariants, specificVariants, Object.class);\n    }\n\n  }","commit_id":"905f25bed6fa4ffad2bd20b583af4b11414ba321","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static ResolverProcessor getMethodOrPropertyResolveProcessor(GrReferenceExpression refExpr, String name, boolean forCompletion, boolean checkArguments) {\n    Kind kind = ((GrReferenceExpressionImpl) refExpr).getKind();\n    ResolverProcessor processor;\n    if (kind == Kind.METHOD_OR_PROPERTY) {\n      final PsiType[] argTypes = checkArguments ? PsiUtil.getArgumentTypes(refExpr, false) : null;\n      processor = new MethodResolverProcessor(name, refExpr, forCompletion, false, argTypes);\n    } else {\n      processor = new PropertyResolverProcessor(name, refExpr, forCompletion);\n    }\n\n    return processor;\n  }","id":97124,"modified_method":"static ResolverProcessor getMethodOrPropertyResolveProcessor(GrReferenceExpression refExpr, String name, boolean forCompletion, boolean checkArguments) {\n    Kind kind = ((GrReferenceExpressionImpl) refExpr).getKind();\n    ResolverProcessor processor;\n    if (kind == Kind.METHOD_OR_PROPERTY) {\n      final PsiType[] argTypes = checkArguments ? PsiUtil.getArgumentTypes(refExpr, false) : null;\n      if (refExpr.getContainingFile() instanceof GspGroovyFile) {\n        processor = new MethodOrGspTagResolverProcessor(name, refExpr, forCompletion, false, argTypes);\n      } else {\n        processor = new MethodResolverProcessor(name, refExpr, forCompletion, false, argTypes);\n      }\n    } else {\n      processor = new PropertyResolverProcessor(name, refExpr, forCompletion);\n    }\n\n    return processor;\n  }","commit_id":"905f25bed6fa4ffad2bd20b583af4b11414ba321","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AddSupportForFrameworksPanel(final List<FrameworkSupportProvider> providers, final @NotNull LibrariesContainer librariesContainer,\n                                      Computable<String> baseDirForLibrariesGetter) {\n    myLibrariesContainer = librariesContainer;\n    myBaseDirForLibrariesGetter = baseDirForLibrariesGetter;\n    myProviders = providers;\n    createNodes();\n    myMirrorsMap = creatMirrorsMap();\n\n    final JPanel treePanel = new JPanel(new GridBagLayout());\n    addSettingsComponents(myRoots, treePanel, 0);\n    myFrameworksTreePanel.add(treePanel, BorderLayout.WEST);\n    myChangeButton.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        HashSet<RemoteRepositoryInfo> repositories = new HashSet<RemoteRepositoryInfo>(getRemoteRepositories(true));\n        final List<LibraryCompositionSettings> compositionSettingsList = getLibrariesCompositionSettingsList();\n        new LibraryCompositionSettingsDialog(myMainPanel, myLibrariesContainer, compositionSettingsList, myMirrorsMap, repositories).show();\n        updateDownloadingOptionsPanel();\n      }\n    });\n    updateDownloadingOptionsPanel();\n  }","id":97125,"modified_method":"public AddSupportForFrameworksPanel(final List<FrameworkSupportProvider> providers, final @NotNull LibrariesContainer librariesContainer,\n                                      Computable<String> baseDirForLibrariesGetter) {\n    myLibrariesContainer = librariesContainer;\n    myBaseDirForLibrariesGetter = baseDirForLibrariesGetter;\n    myProviders = providers;\n    createNodes();\n    myMirrorsMap = creatMirrorsMap();\n\n    final JPanel treePanel = new JPanel(new GridBagLayout());\n    addSettingsComponents(myRoots, treePanel, 0);\n    myFrameworksTreePanel.add(treePanel, BorderLayout.WEST);\n    myChangeButton.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        final List<LibraryCompositionSettings> compositionSettingsList = getLibrariesCompositionSettingsList();\n        new LibrariesCompositionDialog(myMainPanel, myLibrariesContainer, compositionSettingsList, myMirrorsMap).show();\n        updateDownloadingOptionsPanel();\n      }\n    });\n    updateDownloadingOptionsPanel();\n  }","commit_id":"363691dfcf239c4cf9f04b51d453cc97493a6f51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addSupport(final Module module, final ModifiableRootModel rootModel) {\n    List<Library> addedLibraries = new ArrayList<Library>();\n    List<FrameworkSupportSettings> selectedFrameworks = getFrameworksSettingsList(true);\n    for (FrameworkSupportSettings settings : selectedFrameworks) {\n      FrameworkSupportConfigurable configurable = settings.getConfigurable();\n\n      LibraryCompositionSettings compositionSettings = settings.getLibraryCompositionSettings();\n      Library library = compositionSettings.createLibrary(rootModel);\n\n      if (library != null) {\n        addedLibraries.add(library);\n        if (compositionSettings.getLibraryLevel() != LibrariesContainer.LibraryLevel.MODULE) {\n          rootModel.addLibraryEntry(library);\n        }\n      }\n      for (Library addedLibrary : compositionSettings.getAddedLibraries()) {\n        addedLibraries.add(addedLibrary);\n        rootModel.addLibraryEntry(addedLibrary);\n      }\n\n      configurable.addSupport(module, rootModel, library);\n    }\n    for (FrameworkSupportSettings settings : selectedFrameworks) {\n      FrameworkSupportProvider provider = settings.myProvider;\n      if (provider instanceof FacetTypeFrameworkSupportProvider) {\n        ((FacetTypeFrameworkSupportProvider)provider).processAddedLibraries(module, addedLibraries);\n      }\n    }\n  }","id":97126,"modified_method":"public void addSupport(final Module module, final ModifiableRootModel rootModel) {\n    List<Library> addedLibraries = new ArrayList<Library>();\n    List<FrameworkSupportSettings> selectedFrameworks = getFrameworksSettingsList(true);\n    for (FrameworkSupportSettings settings : selectedFrameworks) {\n      FrameworkSupportConfigurable configurable = settings.getConfigurable();\n\n      LibraryCompositionSettings compositionSettings = settings.getLibraryCompositionSettings();\n      Library library = compositionSettings.createLibrary(rootModel);\n\n      if (library != null) {\n        addedLibraries.add(library);\n        if (compositionSettings.getLibraryLevel() != LibrariesContainer.LibraryLevel.MODULE) {\n          rootModel.addLibraryEntry(library);\n        }\n      }\n      for (Library usedLibrary : compositionSettings.getUsedLibraries()) {\n        addedLibraries.add(usedLibrary);\n        rootModel.addLibraryEntry(usedLibrary);\n      }\n\n      configurable.addSupport(module, rootModel, library);\n    }\n    for (FrameworkSupportSettings settings : selectedFrameworks) {\n      FrameworkSupportProvider provider = settings.myProvider;\n      if (provider instanceof FacetTypeFrameworkSupportProvider) {\n        ((FacetTypeFrameworkSupportProvider)provider).processAddedLibraries(module, addedLibraries);\n      }\n    }\n  }","commit_id":"363691dfcf239c4cf9f04b51d453cc97493a6f51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private LibraryDownloadingMirrorsMap creatMirrorsMap() {\n    List<RemoteRepositoryInfo> repositoryInfos = getRemoteRepositories(false);\n    return new LibraryDownloadingMirrorsMap(repositoryInfos.toArray(new RemoteRepositoryInfo[repositoryInfos.size()]));\n  }","id":97127,"modified_method":"private LibraryDownloadingMirrorsMap creatMirrorsMap() {\n    List<RemoteRepositoryInfo> repositoryInfos = getRemoteRepositories();\n    return new LibraryDownloadingMirrorsMap(repositoryInfos.toArray(new RemoteRepositoryInfo[repositoryInfos.size()]));\n  }","commit_id":"363691dfcf239c4cf9f04b51d453cc97493a6f51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<RemoteRepositoryInfo> getRemoteRepositories(final boolean fromSelectedOnly) {\n    List<RemoteRepositoryInfo> repositoryInfos = new ArrayList<RemoteRepositoryInfo>();\n    List<FrameworkSupportSettings> frameworksSettingsList = getFrameworksSettingsList(fromSelectedOnly);\n    for (FrameworkSupportSettings settings : frameworksSettingsList) {\n      LibraryInfo[] libraries = settings.getConfigurable().getLibraries();\n      for (LibraryInfo library : libraries) {\n        LibraryDownloadInfo downloadInfo = library.getDownloadingInfo();\n        if (downloadInfo != null) {\n          RemoteRepositoryInfo repository = downloadInfo.getRemoteRepository();\n          if (repository != null) {\n            repositoryInfos.add(repository);\n          }\n        }\n      }\n    }\n    return repositoryInfos;\n  }","id":97128,"modified_method":"private List<RemoteRepositoryInfo> getRemoteRepositories() {\n    List<RemoteRepositoryInfo> repositoryInfos = new ArrayList<RemoteRepositoryInfo>();\n    List<FrameworkSupportSettings> frameworksSettingsList = getFrameworksSettingsList(false);\n    for (FrameworkSupportSettings settings : frameworksSettingsList) {\n      LibraryInfo[] libraries = settings.getConfigurable().getLibraries();\n      for (LibraryInfo library : libraries) {\n        LibraryDownloadInfo downloadInfo = library.getDownloadingInfo();\n        if (downloadInfo != null) {\n          RemoteRepositoryInfo repository = downloadInfo.getRemoteRepository();\n          if (repository != null) {\n            repositoryInfos.add(repository);\n          }\n        }\n      }\n    }\n    return repositoryInfos;\n  }","commit_id":"363691dfcf239c4cf9f04b51d453cc97493a6f51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LibraryCompositionSettings getLibraryCompositionSettings() {\n      if (myLibraryCompositionSettings == null || isObsolete(myLibraryCompositionSettings)) {\n        final String title = StringUtil.replace(myProvider.getTitle(), String.valueOf(UIUtil.MNEMONIC), \"\");\n        myLibraryCompositionSettings = new LibraryCompositionSettings(myConfigurable.getLibraries(), myConfigurable.getLibraryName(), getBaseModuleDirectoryPath(),\n                                                                      title);\n      }\n      return myLibraryCompositionSettings;\n    }","id":97129,"modified_method":"public LibraryCompositionSettings getLibraryCompositionSettings() {\n      if (myLibraryCompositionSettings == null || isObsolete(myLibraryCompositionSettings)) {\n        final String title = StringUtil.replace(myProvider.getTitle(), String.valueOf(UIUtil.MNEMONIC), \"\");\n        myLibraryCompositionSettings = new LibraryCompositionSettings(myConfigurable.getLibraries(), myConfigurable.getLibraryName(), getBaseModuleDirectoryPath(),\n                                                                      title, myProvider.getIcon());\n      }\n      return myLibraryCompositionSettings;\n    }","commit_id":"363691dfcf239c4cf9f04b51d453cc97493a6f51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static LibrariesContainer createContainer(@Nullable Project project) {\n    return new LibraryContainerImpl(project, null, null);\n  }","id":97130,"modified_method":"@NotNull\n  public static LibrariesContainer createContainer(@Nullable Project project) {\n    return new LibrariesContainerImpl(project, null, null);\n  }","commit_id":"363691dfcf239c4cf9f04b51d453cc97493a6f51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static LibrariesContainer createContainer() {\n    return new LibraryContainerImpl(null, null, null);\n  }","id":97131,"modified_method":"@NotNull\n  public static LibrariesContainer createContainer() {\n    return new LibrariesContainerImpl(null, null, null);\n  }","commit_id":"363691dfcf239c4cf9f04b51d453cc97493a6f51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static LibrariesContainer createContainer(@NotNull ModifiableRootModel rootModel) {\n    Module module = rootModel.getModule();\n    return new LibraryContainerImpl(module.getProject(), module, rootModel);\n  }","id":97132,"modified_method":"@NotNull\n  public static LibrariesContainer createContainer(@NotNull ModifiableRootModel rootModel) {\n    Module module = rootModel.getModule();\n    return new LibrariesContainerImpl(module.getProject(), module, rootModel);\n  }","commit_id":"363691dfcf239c4cf9f04b51d453cc97493a6f51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static LibrariesContainer createContainer(@NotNull Module module) {\n    return new LibraryContainerImpl(module.getProject(), module, null);\n  }","id":97133,"modified_method":"@NotNull\n  public static LibrariesContainer createContainer(@NotNull Module module) {\n    return new LibrariesContainerImpl(module.getProject(), module, null);\n  }","commit_id":"363691dfcf239c4cf9f04b51d453cc97493a6f51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LibraryCompositionSettings(final @NotNull LibraryInfo[] libraryInfos,\n                                    final @NotNull String defaultLibraryName,\n                                    final @NotNull String baseDirectoryForDownloadedFiles, final String title) {\n    myLibraryInfos = libraryInfos;\n    myBaseDirectoryForDownloadedFiles = baseDirectoryForDownloadedFiles;\n    myTitle = title;\n    myLibraryName = defaultLibraryName;\n  }","id":97134,"modified_method":"public LibraryCompositionSettings(final @NotNull LibraryInfo[] libraryInfos,\n                                    final @NotNull String defaultLibraryName,\n                                    final @NotNull String baseDirectoryForDownloadedFiles,\n                                    final String title, @Nullable Icon icon) {\n    myLibraryInfos = libraryInfos;\n    myBaseDirectoryForDownloadedFiles = baseDirectoryForDownloadedFiles;\n    myTitle = title;\n    myLibraryName = defaultLibraryName;\n    myIcon = icon;\n  }","commit_id":"363691dfcf239c4cf9f04b51d453cc97493a6f51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Collection<Library> getAddedLibraries() {\n    return myAddedLibraries;\n  }","id":97135,"modified_method":"public Collection<Library> getUsedLibraries() {\n    return myUsedLibraries;\n  }","commit_id":"363691dfcf239c4cf9f04b51d453cc97493a6f51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setAddedLibraries(List<Library> addedLibraries) {\n    myAddedLibraries.clear();\n    myAddedLibraries.addAll(addedLibraries);\n  }","id":97136,"modified_method":"public void setUsedLibraries(List<Library> addedLibraries) {\n    myUsedLibraries.clear();\n    myUsedLibraries.addAll(addedLibraries);\n  }","commit_id":"363691dfcf239c4cf9f04b51d453cc97493a6f51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RemoteRepositoryMirrorPanel(final RemoteRepositoryInfo remoteRepository, final LibraryDownloadingMirrorsMap mirrorsMap) {\n    myRemoteRepository = remoteRepository;\n    String title = ProjectBundle.message(\"group.title.select.repository.0\", remoteRepository.getPresentableName());\n    TitledBorder titledBorder = IdeBorderFactory.createTitledBorder(title);\n    myPanel.setBorder(BorderFactory.createCompoundBorder(titledBorder, IdeBorderFactory.createEmptyBorder(5, 5, 5, 5)));\n    for (String mirror : remoteRepository.getMirrors()) {\n      myMirrorComboBox.addItem(mirror);\n    }\n    myMirrorComboBox.setSelectedItem(mirrorsMap.getSelectedMirror(remoteRepository));\n  }","id":97137,"modified_method":"public RemoteRepositoryMirrorPanel(final RemoteRepositoryInfo remoteRepository, final LibraryDownloadingMirrorsMap mirrorsMap) {\n    myRemoteRepository = remoteRepository;\n    myFromLabel.setText(ProjectBundle.message(\"composing.library.from.repository.label\", remoteRepository.getPresentableName()));\n    updateComboBox(mirrorsMap);\n  }","commit_id":"363691dfcf239c4cf9f04b51d453cc97493a6f51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@BeforeClass(groups = \"Integration\")\n    public void setUp() throws Exception {\n        WebAppContext context;\n\n        // running in source mode; need to use special classpath        \n        context = new WebAppContext(\"src/test/webapp\", \"/\");\n        context.setExtraClasspath(\"./target/test-rest-server/\");\n        context.setAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT, getManagementContext());\n\n        Server server = startServer(manager, context, \"from WAR at \" + context.getWar());\n\n        api = new BrooklynApi(\"http://localhost:\" + server.getConnectors()[0].getPort() + \"/\");\n    }","id":97138,"modified_method":"@BeforeClass(groups = \"Integration\")\n    public void setUp() throws Exception {\n        WebAppContext context;\n\n        // running in source mode; need to use special classpath        \n        context = new WebAppContext(\"src/test/webapp\", \"/\");\n        context.setExtraClasspath(\"./target/test-rest-server/\");\n        context.setAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT, getManagementContext());\n\n        Server server = BrooklynRestApiLauncher.launcher()\n                .managementContext(manager)\n                .customContext(context)\n                .start();\n\n        api = new BrooklynApi(\"http://localhost:\" + server.getConnectors()[0].getPort() + \"/\");\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@BeforeClass\n    public void setUp() throws Exception {\n        WebAppContext context;\n\n        // running in source mode; need to use special classpath        \n        context = new WebAppContext(\"src/test/webapp\", \"/\");\n        context.setExtraClasspath(\"./target/test-rest-server/\");\n        context.setAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT, getManagementContext());\n\n        Server server = startServer(manager, context, \"from WAR at \" + context.getWar());\n\n        api = new BrooklynApi(\"http://localhost:\" + server.getConnectors()[0].getPort() + \"/\");\n    }","id":97139,"modified_method":"@BeforeClass\n    public void setUp() throws Exception {\n        WebAppContext context;\n\n        // running in source mode; need to use special classpath        \n        context = new WebAppContext(\"src/test/webapp\", \"/\");\n        context.setExtraClasspath(\"./target/test-rest-server/\");\n        context.setAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT, getManagementContext());\n\n        Server server = BrooklynRestApiLauncher.launcher()\n                .managementContext(manager)\n                .customContext(context)\n                .start();\n\n        api = new BrooklynApi(\"http://localhost:\" + server.getConnectors()[0].getPort() + \"/\");\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** look for the REST WAR file in common places, returning path to it if found, or null */\n    public static String findRestApiWar() {\n        String result = null;\n        // don't look at src/main/webapp here -- because classes won't be there!\n        result = findMatchingFile(\"../rest/target/*.war\");  if (result!=null) return result;\n        // could also look in maven repo ?\n        return null;\n    }","id":97140,"modified_method":"/** look for the REST WAR file in common places, returning path to it if found, or null */\n    private static String findRestApiWar() {\n        // don't look at src/main/webapp here -- because classes won't be there!\n        // could also look in maven repo ?\n        return findMatchingFile(\"../rest/target/*.war\").orNull();\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static Server startRestResourcesViaFilter() throws Exception {\n        BrooklynCampPlatformLauncherAbstract platform = new BrooklynCampPlatformLauncherNoServer()\n            .useManagementContext(new LocalManagementContext())\n            .launch();\n        \n        return startRestResourcesViaFilter(platform.getBrooklynMgmt());\n    }","id":97141,"modified_method":"public static Server startRestResourcesViaFilter() {\n        return new BrooklynRestApiLauncher()\n                .mode(StartMode.FILTER)\n                .start();\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** returns the supplied filename if it exists (absolute or relative to the current directory);\n     * supports globs in the filename portion only, in which case it returns the _newest_ matching file.\n     * <p>\n     * otherwise returns null */\n    public static String findMatchingFile(String filename) {\n        final File f = new File(filename);\n        if (f.exists()) return filename;\n        File dir = f.getParentFile();\n        File result = null;\n        if (dir.exists()) {\n            File[] matchingFiles = dir.listFiles(new FilenameFilter() {\n                @Override\n                public boolean accept(File dir, String name) {\n                    return WildcardGlobs.isGlobMatched(f.getName(), name);\n                }\n            });\n            for (File mf: matchingFiles) {\n                if (result==null || mf.lastModified() > result.lastModified()) result = mf;\n            }\n        }\n        if (result==null) return null;\n        return result.getAbsolutePath();\n    }","id":97142,"modified_method":"/** returns the supplied filename if it exists (absolute or relative to the current directory);\n     * supports globs in the filename portion only, in which case it returns the _newest_ matching file.\n     * <p>\n     * otherwise returns null */\n    private static Optional<String> findMatchingFile(String filename) {\n        final File f = new File(filename);\n        if (f.exists()) return Optional.of(filename);\n        File dir = f.getParentFile();\n        File result = null;\n        if (dir.exists()) {\n            File[] matchingFiles = dir.listFiles(new FilenameFilter() {\n                @Override\n                public boolean accept(File dir, String name) {\n                    return WildcardGlobs.isGlobMatched(f.getName(), name);\n                }\n            });\n            for (File mf: matchingFiles) {\n                if (result==null || mf.lastModified() > result.lastModified()) result = mf;\n            }\n        }\n        if (result==null) return Optional.absent();\n        return Optional.of(result.getAbsolutePath());\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static Server startRestResourcesViaServlet() throws Exception {\n        BrooklynCampPlatformLauncherAbstract platform = new BrooklynCampPlatformLauncherNoServer()\n            .useManagementContext(new LocalManagementContext())\n            .launch();\n        \n        return startRestResourcesViaServlet(platform.getBrooklynMgmt());\n    }","id":97143,"modified_method":"public static Server startRestResourcesViaServlet() throws Exception {\n        return new BrooklynRestApiLauncher()\n                .mode(StartMode.SERVLET)\n                .start();\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** look for the JS GUI webapp in common places, returning path to it if found, or null */\n    public static String findJsguiWebapp() {\n        String result = null;\n        result = findMatchingFile(\"../jsgui/src/main/webapp\");  if (result!=null) return result;\n        result = findMatchingFile(\"../jsgui/target/*.war\");  if (result!=null) return result;\n        // could also look in maven repo ?\n        return null;\n    }","id":97144,"modified_method":"/** look for the JS GUI webapp in common places, returning path to it if found, or null */\n    private static String findJsguiWebapp() {\n        // could also look in maven repo ?\n        return Optional\n                .fromNullable(findMatchingFile(\"../jsgui/src/main/webapp\"))\n                .or(findMatchingFile(\"../jsgui/target/*.war\"))\n                .orNull();\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static Server startRestResourcesViaWebXml(ManagementContext managementContext) throws Exception {\n        // TODO add security to web.xml\n        WebAppContext context;\n        if (findMatchingFile(\"src/main/webapp\")!=null) {\n            // running in source mode; need to use special classpath\n            context = new WebAppContext(\"src/main/webapp\", \"/\");\n            context.setExtraClasspath(\"./target/classes\");\n        } else if (findRestApiWar()!=null) {\n            context = new WebAppContext(findRestApiWar(), \"/\");\n        } else {\n            throw new IllegalStateException(\"Cannot find WAR for REST API. Expected in target/*.war, Maven repo, or in source directories.\");\n        }\n        context.setAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT, managementContext);\n        \n        return startServer(context, \"from WAR at \"+context.getWar());\n    }","id":97145,"modified_method":"private ContextHandler webXmlContextHandler(ManagementContext mgmt) {\n        // TODO add security to web.xml\n        WebAppContext context;\n        if (findMatchingFile(\"src/main/webapp\")!=null) {\n            // running in source mode; need to use special classpath\n            context = new WebAppContext(\"src/main/webapp\", \"/\");\n            context.setExtraClasspath(\"./target/classes\");\n        } else if (findRestApiWar()!=null) {\n            context = new WebAppContext(findRestApiWar(), \"/\");\n        } else {\n            throw new IllegalStateException(\"Cannot find WAR for REST API. Expected in target/*.war, Maven repo, or in source directories.\");\n        }\n        context.setAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT, mgmt);\n\n        return context;\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** create a directory with a simple index.html so we have some content being served up */\n    public static String createTempWebDirWithIndexHtml(String indexHtmlContent) {\n        File dir = Files.createTempDir();\n        dir.deleteOnExit();\n        try {\n            Files.write(indexHtmlContent, new File(dir, \"index.html\"), Charsets.UTF_8);\n        } catch (IOException e) {\n            Exceptions.propagate(e);\n        }\n        return dir.getAbsolutePath();\n    }","id":97146,"modified_method":"/** create a directory with a simple index.html so we have some content being served up */\n    private static String createTempWebDirWithIndexHtml(String indexHtmlContent) {\n        File dir = Files.createTempDir();\n        dir.deleteOnExit();\n        try {\n            Files.write(indexHtmlContent, new File(dir, \"index.html\"), Charsets.UTF_8);\n        } catch (IOException e) {\n            Exceptions.propagate(e);\n        }\n        return dir.getAbsolutePath();\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** starts a server, on all NICs if security is configured,\n     * otherwise (no security) only on loopback interface */\n    public static Server startServer(ManagementContext mgmt, ContextHandler context, String summary) {\n        // TODO this repeats code in BrooklynLauncher / WebServer. should merge the two paths.\n        boolean secure = mgmt!=null && !BrooklynWebConfig.hasNoSecurityOptions(mgmt.getConfig()) ? true : false;\n        if (secure) {\n            log.debug(\"Detected security configured, launching server on all network interfaces\");\n        } else {\n            log.debug(\"Detected no security configured, launching server on loopback (localhost) network interface only\");\n            if (mgmt!=null) {\n                log.debug(\"Detected no security configured, running on loopback; disabling authentication\");\n                ((BrooklynProperties)mgmt.getConfig()).put(BrooklynWebConfig.SECURITY_PROVIDER_CLASSNAME, AnyoneSecurityProvider.class.getName());\n            }\n        }\n        if (mgmt != null)\n            mgmt.getHighAvailabilityManager().disabled();\n        InetSocketAddress bindLocation = new InetSocketAddress(\n                secure ? Networking.ANY_NIC : Networking.LOOPBACK, \n                        Networking.nextAvailablePort(FAVOURITE_PORT));\n        return startServer(context, summary, bindLocation);\n    }","id":97147,"modified_method":"/** starts a server, on all NICs if security is configured,\n     * otherwise (no security) only on loopback interface */\n    private Server startServer(ManagementContext mgmt, ContextHandler context, String summary) {\n        // TODO this repeats code in BrooklynLauncher / WebServer. should merge the two paths.\n        boolean secure = mgmt!=null && !BrooklynWebConfig.hasNoSecurityOptions(mgmt.getConfig()) ? true : false;\n        if (secure) {\n            log.debug(\"Detected security configured, launching server on all network interfaces\");\n        } else {\n            log.debug(\"Detected no security configured, launching server on loopback (localhost) network interface only\");\n            if (mgmt!=null) {\n                log.debug(\"Detected no security configured, running on loopback; disabling authentication\");\n                ((BrooklynProperties)mgmt.getConfig()).put(BrooklynWebConfig.SECURITY_PROVIDER_CLASSNAME, AnyoneSecurityProvider.class.getName());\n            }\n        }\n        if (mgmt != null)\n            mgmt.getHighAvailabilityManager().disabled();\n        InetSocketAddress bindLocation = new InetSocketAddress(\n                secure ? Networking.ANY_NIC : Networking.LOOPBACK,\n                        Networking.nextAvailablePort(FAVOURITE_PORT));\n        return startServer(context, summary, bindLocation);\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static Server startRestResourcesViaFilter(ManagementContext managementContext) throws Exception {\n        WebAppContext context = new WebAppContext();\n        context.setAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT, managementContext);\n        context.setContextPath(\"/\");\n        // here we run with the JS GUI, for convenience, if we can find it, else set up an empty dir\n        // TODO pretty sure there is an option to monitor this dir and load changes to static content\n        context.setWar(findJsguiWebapp()!=null ? findJsguiWebapp() : createTempWebDirWithIndexHtml(\"Brooklyn REST API <p> (gui not available)\"));\n        \n        installAsServletFilter(context);\n        \n        return startServer(managementContext, context, \"programmatic Jersey ServletContainer filter on webapp at \"+context.getWar());\n    }","id":97148,"modified_method":"private ContextHandler filterContextHandler(ManagementContext mgmt) {\n        WebAppContext context = new WebAppContext();\n        context.setAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT, mgmt);\n        context.setContextPath(\"/\");\n        // here we run with the JS GUI, for convenience, if we can find it, else set up an empty dir\n        // TODO pretty sure there is an option to monitor this dir and load changes to static content\n        context.setWar(this.deployJsgui && findJsguiWebapp() != null\n                       ? findJsguiWebapp()\n                       : createTempWebDirWithIndexHtml(\"Brooklyn REST API <p> (gui not available)\"));\n        installAsServletFilter(context);\n        return context;\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static Server startServer(ContextHandler context, String summary, InetSocketAddress bindLocation) {\n        Server server = new Server(bindLocation);\n        server.setHandler(context);\n        try {\n            server.start();\n        } catch (Exception e) {\n            throw Exceptions.propagate(e);\n        } \n        log.info(\"Brooklyn REST server started (\"+summary+\") on\");\n        log.info(\"  http://localhost:\"+server.getConnectors()[0].getLocalPort()+\"/\");\n        \n        return server;\n    }","id":97149,"modified_method":"private Server startServer(ContextHandler context, String summary, InetSocketAddress bindLocation) {\n        Server server = new Server(bindLocation);\n        server.setHandler(context);\n        try {\n            server.start();\n        } catch (Exception e) {\n            throw Exceptions.propagate(e);\n        }\n        log.info(\"Brooklyn REST server started (\"+summary+\") on\");\n        log.info(\"  http://localhost:\"+server.getConnectors()[0].getLocalPort()+\"/\");\n\n        return server;\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static Server startRestResourcesViaServlet(ManagementContext managementContext) throws Exception {\n        ResourceConfig config = new DefaultResourceConfig();\n        for (Object r: BrooklynRestApi.getAllResources())\n            config.getSingletons().add(r);\n        \n        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n        context.setAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT, managementContext);\n        ServletHolder servletHolder = new ServletHolder(new ServletContainer(config));\n        context.addServlet(servletHolder, \"/*\");\n        context.setContextPath(\"/\");\n\n        installBrooklynFilters(context);\n\n        return startServer(managementContext, context, \"programmatic Jersey ServletContainer servlet\");\n    }","id":97150,"modified_method":"private ContextHandler servletContextHandler(ManagementContext managementContext) {\n        ResourceConfig config = new DefaultResourceConfig();\n        for (Object r: BrooklynRestApi.getAllResources())\n            config.getSingletons().add(r);\n\n        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n        context.setAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT, managementContext);\n        ServletHolder servletHolder = new ServletHolder(new ServletContainer(config));\n        context.addServlet(servletHolder, \"/*\");\n        context.setContextPath(\"/\");\n\n        installBrooklynFilters(context);\n\n        return context;\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static Server startRestResourcesViaWebXml() throws Exception {\n        return startRestResourcesViaWebXml(new LocalManagementContext());\n    }","id":97151,"modified_method":"public static Server startRestResourcesViaWebXml() throws Exception {\n        return new BrooklynRestApiLauncher()\n                .mode(StartMode.WEB_XML)\n                .start();\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** starts server on all nics (even if security not enabled).\n     * @deprecated since 0.6.0; use {@link #startServer(ManagementContext, ContextHandler, String)} or\n     * {@link #startServer(ContextHandler, String, InetSocketAddress)} */\n    @Deprecated\n    public static Server startServer(ContextHandler context, String summary) {\n        return startServer(context, summary, \n                new InetSocketAddress(Networking.ANY_NIC, Networking.nextAvailablePort(FAVOURITE_PORT)));\n    }","id":97152,"modified_method":"/**\n     * Starts the server on all nics (even if security not enabled).\n     * @deprecated since 0.6.0; use {@link #launcher()} and set a custom context\n     */\n    @Deprecated\n    public static Server startServer(ContextHandler context, String summary) {\n        return launcher()\n                .customContext(context)\n                .startServer(context, summary,\n                new InetSocketAddress(Networking.ANY_NIC, Networking.nextAvailablePort(FAVOURITE_PORT)));\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private static void checkRestCatalogApplications(Server server) {\n        enableAnyoneLogin(server);\n        forceUseOfDefaultCatalogWithJavaClassPath(server);\n        String rootUrl = \"http://localhost:\"+server.getConnectors()[0].getLocalPort();\n        HttpTestUtils.assertContentContainsText(rootUrl+\"/v1/catalog/applications\", SampleNoOpApplication.class.getSimpleName());\n    }","id":97153,"modified_method":"private static void checkRestCatalogApplications(Server server) throws Exception {\n        String rootUrl = \"http://localhost:\"+server.getConnectors()[0].getLocalPort();\n        HttpTestUtils.assertHealthyStatusCode(\n                HttpTestUtils.getHttpStatusCode(rootUrl+\"/v1/catalog/applications\"));\n        HttpTestUtils.assertContentContainsText(rootUrl+\"/v1/catalog/applications\", SampleNoOpApplication.class.getSimpleName());\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testServletStart() throws Exception {\n        checkRestCatalogApplications(useServerForTest(BrooklynRestApiLauncher.startRestResourcesViaServlet()));\n    }","id":97154,"modified_method":"@Test\n    public void testServletStart() throws Exception {\n        checkRestCatalogApplications(useServerForTest(baseLauncher().mode(SERVLET).start()));\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testWebAppStart() throws Exception {\n        checkRestCatalogApplications(useServerForTest(BrooklynRestApiLauncher.startRestResourcesViaWebXml()));\n    }","id":97155,"modified_method":"@Test\n    public void testWebAppStart() throws Exception {\n        checkRestCatalogApplications(useServerForTest(baseLauncher().mode(WEB_XML).start()));\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testFilterStart() throws Exception {\n        checkRestCatalogApplications(useServerForTest(BrooklynRestApiLauncher.startRestResourcesViaFilter()));\n    }","id":97156,"modified_method":"@Test\n    public void testFilterStart() throws Exception {\n        checkRestCatalogApplications(useServerForTest(baseLauncher().mode(FILTER).start()));\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static ManagementContext getManagementContextFromJettyServerAttributes(Server server) {\n        ManagementContext mgmt = (ManagementContext) ((ContextHandler)server.getHandler()).getAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT);\n        return mgmt;\n    }","id":97157,"modified_method":"public static ManagementContext getManagementContextFromJettyServerAttributes(Server server) {\n        return (ManagementContext) ((ContextHandler) server.getHandler()).getAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT);\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected Server useServerForTest(Server server) {\n        if (this.server!=null) {\n            Assert.fail(\"Test only meant for single server; already have \"+server+\" when checking \"+server);\n        } else {\n            this.server = server;\n        }\n        return server;\n    }","id":97158,"modified_method":"protected Server useServerForTest(Server server) {\n        if (this.server!=null) {\n            Assert.fail(\"Test only meant for single server; already have \"+this.server+\" when checking \"+server);\n        } else {\n            this.server = server;\n        }\n        return server;\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected Server newServer() {\n        try {\n            Server server = BrooklynRestApiLauncher.startRestResourcesViaFilter();\n            enableAnyoneLogin(server);\n            forceUseOfDefaultCatalogWithJavaClassPath(server);\n            return server;\n        } catch (Exception e) {\n            throw Exceptions.propagate(e);\n        }\n    }","id":97159,"modified_method":"protected Server newServer() {\n        try {\n            Server server = BrooklynRestApiLauncher.launcher()\n                    .forceUseOfDefaultCatalogWithJavaClassPath(true)\n                    .securityProvider(AnyoneSecurityProvider.class)\n                    .start();\n            return server;\n        } catch (Exception e) {\n            throw Exceptions.propagate(e);\n        }\n    }","commit_id":"1bcb92962ef7f15acdbf96e0273db1fde485100e","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public Interceptor create(final InterceptorFactoryContext context) {\n\n        final SessionBeanComponent component = (SessionBeanComponent) context.getContextData().get(Component.class);\n\n        return new Interceptor() {\n            @Override\n            public Object processInvocation(final InterceptorContext context) throws Exception {\n                final InterceptorContext asyncInterceptorContext = context.clone();\n                final CancellationFlag flag = new CancellationFlag();\n                final Task task = new Task(asyncInterceptorContext, flag);\n                asyncInterceptorContext.putPrivateData(CancellationFlag.class, flag);\n                component.getAsynchronousExecutor().execute(task);\n                return task;\n            }\n        };\n    }","id":97160,"modified_method":"@Override\n    public Interceptor create(final InterceptorFactoryContext context) {\n\n        final SessionBeanComponent component = (SessionBeanComponent) context.getContextData().get(Component.class);\n\n        return new Interceptor() {\n            @Override\n            public Object processInvocation(final InterceptorContext context) throws Exception {\n                final InterceptorContext asyncInterceptorContext = context.clone();\n                final CancellationFlag flag = new CancellationFlag();\n                final AsyncInvocationTask task = new AsyncInvocationTask( flag) {\n\n                    @Override\n                    protected Object runInvocation() throws Exception {\n                        return asyncInterceptorContext.proceed();\n                    }\n                };\n                asyncInterceptorContext.putPrivateData(CancellationFlag.class, flag);\n                component.getAsynchronousExecutor().execute(task);\n                return task;\n            }\n        };\n    }","commit_id":"c3e8c65b49790789c2a610e2f905e82b0573de70","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void handleDeploymentDescriptor(final DeploymentUnit deploymentUnit, final DeploymentReflectionIndex deploymentReflectionIndex, final Class<?> componentClass, final SessionBeanComponentDescription description) throws DeploymentUnitProcessingException {\n        final SessionBeanMetaData data = description.getDescriptorData();\n        if (data != null) {\n            if (data instanceof SessionBean31MetaData) {\n                final SessionBean31MetaData sessionBeanData = (SessionBean31MetaData) data;\n                final AsyncMethodsMetaData asyn = sessionBeanData.getAsyncMethods();\n                if (asyn != null) {\n                    for (AsyncMethodMetaData method : asyn) {\n                        final Method m = MethodResolutionUtils.resolveMethod(method.getMethodName(), method.getMethodParams(), componentClass, deploymentReflectionIndex);\n                        description.addAsynchronousMethod(MethodIdentifier.getIdentifierForMethod(m));\n                    }\n                }\n            }\n        }\n        if (!description.getAsynchronousClasses().isEmpty() ||\n                !description.getAsynchronousMethods().isEmpty() ||\n                !description.getAsynchronousViews().isEmpty()) {\n\n            //setup a dependency on the executor service\n            description.getConfigurators().add(new ComponentConfigurator() {\n                @Override\n                public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n                    configuration.getCreateDependencies().add(new DependencyConfigurator<SessionBeanComponentCreateService>() {\n                        @Override\n                        public void configureDependency(final ServiceBuilder<?> serviceBuilder, final SessionBeanComponentCreateService service) throws DeploymentUnitProcessingException {\n                            serviceBuilder.addDependency(SessionBeanComponent.ASYNC_EXECUTOR_SERVICE_NAME, ExecutorService.class, service.getAsyncExecutorService());\n                        }\n                    });\n                }\n            });\n            for (final ViewDescription view : description.getViews()) {\n                final EJBViewDescription ejbView = (EJBViewDescription) view;\n\n                //TODO: This is not the way to handle remove async invocations\n                //this will need to be looked at once we have remote in place\n                ejbView.getConfigurators().add(new ViewConfigurator() {\n                    @Override\n                    public void configure(final DeploymentPhaseContext context, final ComponentConfiguration componentConfiguration, final ViewDescription description, final ViewConfiguration configuration) throws DeploymentUnitProcessingException {\n                        final SessionBeanComponentDescription componentDescription = (SessionBeanComponentDescription) componentConfiguration.getComponentDescription();\n                        final boolean asyncView = componentDescription.getAsynchronousViews().contains(view.getViewClassName());\n                        for (final Method method : configuration.getProxyFactory().getCachedMethods()) {\n\n                            //we need the component method to get the correct declaring class\n                            final Method componentMethod = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, deploymentReflectionIndex.getClassIndex(componentClass), method);\n\n                            if (componentMethod != null) {\n                                boolean methodFromAsyncView = asyncView && method.getDeclaringClass() != Object.class;\n                                if (methodFromAsyncView || componentDescription.getAsynchronousClasses().contains(componentMethod.getDeclaringClass().getName())) {\n                                    addAsyncInterceptor(configuration, method);\n                                } else {\n                                    MethodIdentifier id = MethodIdentifier.getIdentifierForMethod(method);\n                                    if (componentDescription.getAsynchronousMethods().contains(id)) {\n                                        addAsyncInterceptor(configuration, method);\n                                    }\n                                }\n                            }\n\n                        }\n                    }\n                });\n            }\n\n        }\n\n    }","id":97161,"modified_method":"@Override\n    protected void handleDeploymentDescriptor(final DeploymentUnit deploymentUnit, final DeploymentReflectionIndex deploymentReflectionIndex, final Class<?> componentClass, final SessionBeanComponentDescription description) throws DeploymentUnitProcessingException {\n        final SessionBeanMetaData data = description.getDescriptorData();\n        if (data != null) {\n            if (data instanceof SessionBean31MetaData) {\n                final SessionBean31MetaData sessionBeanData = (SessionBean31MetaData) data;\n                final AsyncMethodsMetaData asyn = sessionBeanData.getAsyncMethods();\n                if (asyn != null) {\n                    for (AsyncMethodMetaData method : asyn) {\n                        final Method m = MethodResolutionUtils.resolveMethod(method.getMethodName(), method.getMethodParams(), componentClass, deploymentReflectionIndex);\n                        description.addAsynchronousMethod(MethodIdentifier.getIdentifierForMethod(m));\n                    }\n                }\n            }\n        }\n        if (!description.getAsynchronousClasses().isEmpty() ||\n                !description.getAsynchronousMethods().isEmpty() ||\n                !description.getAsynchronousViews().isEmpty()) {\n\n            //setup a dependency on the executor service\n            description.getConfigurators().add(new ComponentConfigurator() {\n                @Override\n                public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n                    configuration.getCreateDependencies().add(new DependencyConfigurator<SessionBeanComponentCreateService>() {\n                        @Override\n                        public void configureDependency(final ServiceBuilder<?> serviceBuilder, final SessionBeanComponentCreateService service) throws DeploymentUnitProcessingException {\n                            serviceBuilder.addDependency(SessionBeanComponent.ASYNC_EXECUTOR_SERVICE_NAME, ExecutorService.class, service.getAsyncExecutorService());\n                        }\n                    });\n                }\n            });\n            for (final ViewDescription view : description.getViews()) {\n                final EJBViewDescription ejbView = (EJBViewDescription) view;\n\n                //TODO: This is not the way to handle remove async invocations\n                //this will need to be looked at once we have remote in place\n                ejbView.getConfigurators().add(new ViewConfigurator() {\n                    @Override\n                    public void configure(final DeploymentPhaseContext context, final ComponentConfiguration componentConfiguration, final ViewDescription description, final ViewConfiguration configuration) throws DeploymentUnitProcessingException {\n                        final SessionBeanComponentDescription componentDescription = (SessionBeanComponentDescription) componentConfiguration.getComponentDescription();\n                        final boolean asyncView = componentDescription.getAsynchronousViews().contains(view.getViewClassName());\n                        for (final Method method : configuration.getProxyFactory().getCachedMethods()) {\n\n                            //we need the component method to get the correct declaring class\n                            final Method componentMethod = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, deploymentReflectionIndex.getClassIndex(componentClass), method);\n\n                            if (componentMethod != null) {\n                                boolean methodFromAsyncView = asyncView && method.getDeclaringClass() != Object.class;\n                                if (methodFromAsyncView || componentDescription.getAsynchronousClasses().contains(componentMethod.getDeclaringClass().getName())) {\n                                    addAsyncInterceptor(configuration, method);\n                                } else {\n                                    MethodIdentifier id = MethodIdentifier.getIdentifierForMethod(method);\n                                    if (componentDescription.getAsynchronousMethods().contains(id)) {\n                                        addAsyncInterceptor(configuration, method);\n                                        configuration.addAsyncMethod(method);\n                                    }\n                                }\n                            }\n\n                        }\n                    }\n                });\n            }\n\n        }\n\n    }","commit_id":"c3e8c65b49790789c2a610e2f905e82b0573de70","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected Future<?> processInvocation(final EJBClientInvocationContext<Void> invocation, final EJBReceiverContext receiverContext) throws Exception {\n        final EjbDeploymentInformation ejb = findBean(invocation.getAppName(), invocation.getModuleName(), invocation.getDistinctName(), invocation.getBeanName());\n        //TODO: we need a better way to get the correct view\n        final Class<?> viewClass = invocation.getViewClass();\n        final ComponentView view = ejb.getView(viewClass.getName());\n        if (view == null) {\n            throw new RuntimeException(\"Could not find view \" + viewClass + \" for ejb \" + ejb.getEjbName());\n        }\n\n        //TODO: this needs to be pass by value\n        //we really need to setup client interceptors to handle this somehow\n\n        final Method invokedMethod = invocation.getInvokedMethod();\n        //TODO: this is not very efficent\n        final Method method = view.getMethod(invokedMethod.getName(), DescriptorUtils.methodDescriptor(invokedMethod));\n\n        final Object[] parameters;\n        if (invocation.getParameters() == null) {\n            parameters = EMPTY_OBJECT_ARRAY;\n        } else {\n            parameters = new Object[invocation.getParameters().length];\n            for (int i = 0; i < parameters.length; ++i) {\n                parameters[i] = clone(method.getParameterTypes()[i], invocation.getParameters()[i],allowPassByReference);\n            }\n        }\n\n\n        final InterceptorContext context = new InterceptorContext();\n        context.setParameters(parameters);\n        context.setMethod(method);\n        context.setTarget(invocation.getInvokedProxy());\n        context.setContextData(new HashMap<String, Object>());\n        context.putPrivateData(Component.class, ejb.getEjbComponent());\n        context.putPrivateData(ComponentView.class, view);\n        final Object result = view.invoke(context);\n        if (result instanceof AsyncResult) {\n            final Object futureResult = ((Future) result).get();\n            //this will always be cloned, as we cannot reliably determine the target type\n            return new AsyncResult<Object>(new AsyncResult<Object>(clone(futureResult.getClass(), futureResult, false)));\n        }\n\n        //we do not marshal the return type unless we have to, the spec only says we have to\n        //pass parameters by reference\n        //TODO: investigate the implications of this further\n        final Object clonedResult = clone(method.getReturnType(), result, true);\n        return new AsyncResult<Object>(clonedResult);\n    }","id":97162,"modified_method":"@Override\n    protected Future<?> processInvocation(final EJBClientInvocationContext<Void> invocation, final EJBReceiverContext receiverContext) throws Exception {\n\n        final EjbDeploymentInformation ejb = findBean(invocation.getAppName(), invocation.getModuleName(), invocation.getDistinctName(), invocation.getBeanName());\n        final EJBComponent ejbComponent = ejb.getEjbComponent();\n\n        final Class<?> viewClass = invocation.getViewClass();\n        final ComponentView view = ejb.getView(viewClass.getName());\n        if (view == null) {\n            throw new RuntimeException(\"Could not find view \" + viewClass + \" for ejb \" + ejb.getEjbName());\n        }\n\n        //TODO: this is not very efficent\n        final Method method = view.getMethod(invocation.getInvokedMethod().getName(), DescriptorUtils.methodDescriptor(invocation.getInvokedMethod()));\n\n        final boolean async = view.isAsynchronous(method);\n\n        final Object[] parameters;\n        if (invocation.getParameters() == null) {\n            parameters = EMPTY_OBJECT_ARRAY;\n        } else {\n            parameters = new Object[invocation.getParameters().length];\n            for (int i = 0; i < parameters.length; ++i) {\n                parameters[i] = clone(method.getParameterTypes()[i], invocation.getParameters()[i], allowPassByReference);\n            }\n        }\n\n\n        final InterceptorContext context = new InterceptorContext();\n        context.setParameters(parameters);\n        context.setMethod(method);\n        context.setTarget(invocation.getInvokedProxy());\n        context.setContextData(new HashMap<String, Object>());\n        context.putPrivateData(Component.class, ejbComponent);\n        context.putPrivateData(ComponentView.class, view);\n\n        if (async) {\n            if (ejbComponent instanceof SessionBeanComponent) {\n                final SessionBeanComponent component = (SessionBeanComponent) ejbComponent;\n                final CancellationFlag flag = new CancellationFlag();\n                final AsyncInvocationTask task = new AsyncInvocationTask(flag) {\n\n                    @Override\n                    protected Object runInvocation() throws Exception {\n                        return view.invoke(context);\n                    }\n                };\n                context.putPrivateData(CancellationFlag.class, flag);\n                component.getAsynchronousExecutor().submit(task);\n                //TODO: we do not clone the result of an async task\n                return new AsyncResult<Object>(task);\n            } else {\n                throw new RuntimeException(\"Cannot perform asynchronous local invocation for component that is not a session bean\");\n            }\n        } else {\n            final Object result = view.invoke(context);\n            //we do not marshal the return type unless we have to, the spec only says we have to\n            //pass parameters by reference\n            //TODO: investigate the implications of this further\n            final Object clonedResult = clone(method.getReturnType(), result, true);\n            return new AsyncResult<Object>(clonedResult);\n        }\n    }","commit_id":"c3e8c65b49790789c2a610e2f905e82b0573de70","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testRemoteAsyncInvocationByValue() throws Exception {\n        StatelessRemoteBean.reset();\n        String[] array = {\"hello\"};\n        RemoteInterface remote = lookup(StatelessRemoteBean.class.getSimpleName(), RemoteInterface.class);\n        remote.modifyArray(array);\n        StatelessRemoteBean.startLatch.countDown();\n        StatelessRemoteBean.doneLatch.await(5, TimeUnit.SECONDS);\n        Assert.assertEquals(\"hello\", array[0]);\n    }","id":97163,"modified_method":"@Test\n    public void testRemoteAsyncInvocationByValue() throws Exception {\n        StatelessRemoteBean.reset();\n        String[] array = {\"hello\"};\n        RemoteInterface remote = lookup(StatelessRemoteBean.class.getSimpleName(), RemoteInterface.class);\n        remote.modifyArray(array);\n        StatelessRemoteBean.startLatch.countDown();\n        if (!StatelessRemoteBean.doneLatch.await(5, TimeUnit.SECONDS)) {\n            throw new RuntimeException(\"Invocation was not asynchronous\");\n        }\n        Assert.assertEquals(\"hello\", array[0]);\n    }","commit_id":"c3e8c65b49790789c2a610e2f905e82b0573de70","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testRemoteAsyncInvocationByValueFromEjbInjcation() throws Exception {\n        StatelessRemoteBean.reset();\n        String[] array = {\"hello\"};\n        StatelessRunningBean remote = lookup(StatelessRunningBean.class.getSimpleName(), StatelessRunningBean.class);\n        remote.modifyArray(array);\n        StatelessRemoteBean.startLatch.countDown();\n        StatelessRemoteBean.doneLatch.await(5, TimeUnit.SECONDS);\n        Assert.assertEquals(\"hello\", array[0]);\n    }","id":97164,"modified_method":"@Test\n    public void testRemoteAsyncInvocationByValueFromEjbInjcation() throws Exception {\n        StatelessRemoteBean.reset();\n        String[] array = {\"hello\"};\n        StatelessRunningBean remote = lookup(StatelessRunningBean.class.getSimpleName(), StatelessRunningBean.class);\n        remote.modifyArray(array);\n        StatelessRemoteBean.startLatch.countDown();\n\n        if (!StatelessRemoteBean.doneLatch.await(5, TimeUnit.SECONDS)) {\n            throw new RuntimeException(\"Invocation was not asynchronous\");\n        }\n        Assert.assertEquals(\"hello\", array[0]);\n    }","commit_id":"c3e8c65b49790789c2a610e2f905e82b0573de70","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testLocalAsyncInvocationByValue() throws Exception {\n        StatelessRemoteBean.reset();\n        String[] array = {\"hello\"};\n        LocalInterface remote = lookup(StatelessRemoteBean.class.getSimpleName(), LocalInterface.class);\n        remote.passByReference(array);\n        StatelessRemoteBean.startLatch.countDown();\n        StatelessRemoteBean.doneLatch.await(5, TimeUnit.SECONDS);\n        Assert.assertEquals(\"goodbye\", array[0]);\n    }","id":97165,"modified_method":"@Test\n    public void testLocalAsyncInvocationByValue() throws Exception {\n        StatelessRemoteBean.reset();\n        String[] array = {\"hello\"};\n        LocalInterface remote = lookup(StatelessRemoteBean.class.getSimpleName(), LocalInterface.class);\n        remote.passByReference(array);\n        StatelessRemoteBean.startLatch.countDown();\n\n        if (!StatelessRemoteBean.doneLatch.await(5, TimeUnit.SECONDS)) {\n            throw new RuntimeException(\"Invocation was not asynchronous\");\n        }\n        Assert.assertEquals(\"goodbye\", array[0]);\n    }","commit_id":"c3e8c65b49790789c2a610e2f905e82b0573de70","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Asynchronous\n    public void modifyArray(final String[] array) {\n        try {\n            startLatch.await(5, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        array[0] = \"goodbye\";\n        doneLatch.countDown();\n    }","id":97166,"modified_method":"@Asynchronous\n    public void modifyArray(final String[] array) {\n        try {\n            if(!startLatch.await(5, TimeUnit.SECONDS)) {\n                throw new RuntimeException(\"Invocation was not asynchronous\");\n            }\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        array[0] = \"goodbye\";\n        doneLatch.countDown();\n    }","commit_id":"c3e8c65b49790789c2a610e2f905e82b0573de70","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void passByReference(final String[] array) {\n        try {\n            startLatch.await(5, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        array[0] = \"goodbye\";\n        doneLatch.countDown();\n    }","id":97167,"modified_method":"@Override\n    @Asynchronous\n    public void passByReference(final String[] array) {\n        try {\n            if(!startLatch.await(5, TimeUnit.SECONDS)) {\n                throw new RuntimeException(\"Invocation was not asynchronous\");\n            }\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        array[0] = \"goodbye\";\n        doneLatch.countDown();\n    }","commit_id":"c3e8c65b49790789c2a610e2f905e82b0573de70","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ViewService(final ViewConfiguration viewConfiguration) {\n        viewClass = viewConfiguration.getViewClass();\n        final ProxyFactory<?> proxyFactory = viewConfiguration.getProxyFactory();\n        this.proxyFactory = proxyFactory;\n        final List<Method> methods = proxyFactory.getCachedMethods();\n        final int methodCount = methods.size();\n        viewPostConstruct = Interceptors.getChainedInterceptorFactory(viewConfiguration.getViewPostConstructInterceptors());\n        viewPreDestroy = Interceptors.getChainedInterceptorFactory(viewConfiguration.getViewPreDestroyInterceptors());\n        clientPostConstruct = Interceptors.getChainedInterceptorFactory(viewConfiguration.getClientPostConstructInterceptors());\n        clientPreDestroy = Interceptors.getChainedInterceptorFactory(viewConfiguration.getClientPreDestroyInterceptors());\n        final IdentityHashMap<Method, InterceptorFactory> viewInterceptorFactories = new IdentityHashMap<Method, InterceptorFactory>(methodCount);\n        final IdentityHashMap<Method, InterceptorFactory> clientInterceptorFactories = new IdentityHashMap<Method, InterceptorFactory>(methodCount);\n        for (Method method : methods) {\n            if (method.getName().equals(\"finalize\") && method.getParameterTypes().length == 0) {\n                viewInterceptorFactories.put(method, DESTROY_INTERCEPTOR);\n            } else {\n                viewInterceptorFactories.put(method, Interceptors.getChainedInterceptorFactory(viewConfiguration.getViewInterceptors(method)));\n                clientInterceptorFactories.put(method, Interceptors.getChainedInterceptorFactory(viewConfiguration.getClientInterceptors(method)));\n            }\n        }\n        this.viewInterceptorFactories = viewInterceptorFactories;\n        this.clientInterceptorFactories = clientInterceptorFactories;\n        allowedMethods = Collections.unmodifiableSet(viewInterceptorFactories.keySet());\n    }","id":97168,"modified_method":"public ViewService(final ViewConfiguration viewConfiguration) {\n        viewClass = viewConfiguration.getViewClass();\n        final ProxyFactory<?> proxyFactory = viewConfiguration.getProxyFactory();\n        this.proxyFactory = proxyFactory;\n        final List<Method> methods = proxyFactory.getCachedMethods();\n        final int methodCount = methods.size();\n        viewPostConstruct = Interceptors.getChainedInterceptorFactory(viewConfiguration.getViewPostConstructInterceptors());\n        viewPreDestroy = Interceptors.getChainedInterceptorFactory(viewConfiguration.getViewPreDestroyInterceptors());\n        clientPostConstruct = Interceptors.getChainedInterceptorFactory(viewConfiguration.getClientPostConstructInterceptors());\n        clientPreDestroy = Interceptors.getChainedInterceptorFactory(viewConfiguration.getClientPreDestroyInterceptors());\n        final IdentityHashMap<Method, InterceptorFactory> viewInterceptorFactories = new IdentityHashMap<Method, InterceptorFactory>(methodCount);\n        final IdentityHashMap<Method, InterceptorFactory> clientInterceptorFactories = new IdentityHashMap<Method, InterceptorFactory>(methodCount);\n        for (Method method : methods) {\n            if (method.getName().equals(\"finalize\") && method.getParameterTypes().length == 0) {\n                viewInterceptorFactories.put(method, DESTROY_INTERCEPTOR);\n            } else {\n                viewInterceptorFactories.put(method, Interceptors.getChainedInterceptorFactory(viewConfiguration.getViewInterceptors(method)));\n                clientInterceptorFactories.put(method, Interceptors.getChainedInterceptorFactory(viewConfiguration.getClientInterceptors(method)));\n            }\n        }\n        this.viewInterceptorFactories = viewInterceptorFactories;\n        this.clientInterceptorFactories = clientInterceptorFactories;\n        allowedMethods = Collections.unmodifiableSet(viewInterceptorFactories.keySet());\n        this.asyncMethods = viewConfiguration.getAsyncMethods();\n    }","commit_id":"c3e8c65b49790789c2a610e2f905e82b0573de70","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected ReplyToHandler createReplyToHandler(final MuleEvent event)\n    {\n        final ReplyToHandler originalReplyToHandler = event.getReplyToHandler();\n        return new ReplyToHandler()\n        {\n            @Override\n            public void processReplyTo(MuleEvent event, MuleMessage returnMessage, Object replyTo) throws MuleException\n            {\n                MuleEvent response = processResponse(new DefaultMuleEvent(event, originalReplyToHandler));\n                // Update RequestContext ThreadLocal for backwards compatibility\n                OptimizedRequestContext.unsafeSetEvent(response);\n                if (!NonBlockingVoidMuleEvent.getInstance().equals(response))\n                {\n                    originalReplyToHandler.processReplyTo(response, null, null);\n                }\n                processFinally(event, null);\n            }\n\n            @Override\n            public void processExceptionReplyTo(MessagingException exception, Object replyTo)\n            {\n                originalReplyToHandler.processExceptionReplyTo(exception, replyTo);\n                processFinally(exception.getEvent(), exception);\n            }\n        };\n    }","id":97169,"modified_method":"protected ReplyToHandler createReplyToHandler(final MuleEvent event)\n    {\n        final ReplyToHandler originalReplyToHandler = event.getReplyToHandler();\n        return new ReplyToHandler()\n        {\n            @Override\n            public void processReplyTo(MuleEvent event, MuleMessage returnMessage, Object replyTo) throws MuleException\n            {\n                MuleEvent response = processResponse(recreateEventWithOriginalReplyToHandler(event, originalReplyToHandler));\n                if (!NonBlockingVoidMuleEvent.getInstance().equals(response))\n                {\n                    originalReplyToHandler.processReplyTo(response, null, null);\n                }\n                processFinally(event, null);\n            }\n\n            @Override\n            public void processExceptionReplyTo(MessagingException exception, Object replyTo)\n            {\n                originalReplyToHandler.processExceptionReplyTo(exception, replyTo);\n                processFinally(exception.getEvent(), exception);\n            }\n        };\n    }","commit_id":"2eb3770eaeedd904bc9e338baf7863a223385d60","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void executeRequestResponseNonBlocking() throws MuleException, InterruptedException\n    {\n        when(event.getExchangePattern()).thenReturn(MessageExchangePattern.REQUEST_RESPONSE);\n        when(event.isSynchronous()).thenReturn(false);\n        when(event.isAllowNonBlocking()).thenReturn(true);\n        assertBlockingExecution(processors);\n    }","id":97170,"modified_method":"@Test\n    public void executeRequestResponseNullResponse() throws MuleException\n    {\n        processors.add(new MessageProcessor()\n        {\n            @Override\n            public MuleEvent process(MuleEvent event) throws MuleException\n            {\n                return null;\n            }\n        });\n        setupRequestResponseEvent();\n        assertThat(createProcessorExecutor(processors).execute(), is(nullValue()));\n    }","commit_id":"2eb3770eaeedd904bc9e338baf7863a223385d60","url":"https://github.com/mulesoft/mule"},{"original_method":"@Before\n    public void before() throws MessagingException\n    {\n        processors.add(processor1);\n        processors.add(processor2);\n        processors.add(processor3);\n\n        when(event.getExchangePattern()).thenReturn(MessageExchangePattern.REQUEST_RESPONSE);\n        MuleMessage message = new DefaultMuleMessage(\"\", muleContext);\n        when(event.getId()).thenReturn(RandomStringUtils.randomNumeric(3));\n        when(event.getMessage()).thenReturn(message);\n        when(event.getMuleContext()).thenReturn(muleContext);\n        when(executionTemplate.execute(any(MessageProcessor.class), any(MuleEvent.class)))\n                .thenAnswer(new Answer<MuleEvent>()\n                {\n                    @Override\n                    public MuleEvent answer(InvocationOnMock invocation) throws Throwable\n                    {\n                        return ((MessageProcessor) invocation.getArguments()[0]).process((MuleEvent) invocation\n                                .getArguments()[1]);\n                    }\n                });\n    }","id":97171,"modified_method":"@Before\n    public void before() throws MessagingException\n    {\n        processors.add(processor1);\n        processors.add(processor2);\n        processors.add(processor3);\n\n        when(event.getFlowConstruct()).thenReturn(mock(Flow.class));\n        MuleMessage message = new DefaultMuleMessage(\"\", muleContext);\n        when(event.getId()).thenReturn(RandomStringUtils.randomNumeric(3));\n        when(event.getMessage()).thenReturn(message);\n        when(event.getMuleContext()).thenReturn(muleContext);\n        when(executionTemplate.execute(any(MessageProcessor.class), any(MuleEvent.class)))\n                .thenAnswer(new Answer<MuleEvent>()\n                {\n                    @Override\n                    public MuleEvent answer(InvocationOnMock invocation) throws Throwable\n                    {\n                        return ((MessageProcessor) invocation.getArguments()[0]).process((MuleEvent) invocation\n                                .getArguments()[1]);\n                    }\n                });\n    }","commit_id":"2eb3770eaeedd904bc9e338baf7863a223385d60","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void executeRequestResponse() throws MuleException\n    {\n        when(event.getExchangePattern()).thenReturn(MessageExchangePattern.REQUEST_RESPONSE);\n        when(event.isSynchronous()).thenReturn(true);\n        assertBlockingExecution(processors);\n    }","id":97172,"modified_method":"@Test\n    public void executeRequestResponse() throws MuleException\n    {\n        setupRequestResponseEvent();\n        assertBlockingExecution(processors);\n    }","commit_id":"2eb3770eaeedd904bc9e338baf7863a223385d60","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void executeOneWay() throws MuleException\n    {\n        when(event.getExchangePattern()).thenReturn(MessageExchangePattern.ONE_WAY);\n        when(event.isSynchronous()).thenReturn(false);\n        assertBlockingExecution(processors);\n    }","id":97173,"modified_method":"@Test\n    public void executeOneWay() throws MuleException\n    {\n        setupOneWayEvent();\n        assertBlockingExecution(processors);\n    }","commit_id":"2eb3770eaeedd904bc9e338baf7863a223385d60","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Runs the given non blocking flow with a default event\n     *\n     * @param flowName the name of the flow to be executed\n     * @return the resulting <code>MuleEvent<\/code>\n     * @throws Exception\n     */\n    protected MuleEvent runFlowNonBlocking(String flowName, MuleEvent event) throws Exception\n    {\n        Flow flow = this.lookupFlowConstruct(flowName);\n        SensingNullReplyToHandler nullReplyToHandler = new SensingNullReplyToHandler();\n        event = new DefaultMuleEvent(event, event.getFlowConstruct(), nullReplyToHandler, null, false);\n        MuleEvent result = flow.process(event);\n        if (NonBlockingVoidMuleEvent.getInstance() == result)\n        {\n            nullReplyToHandler.latch.await(RECEIVE_TIMEOUT, TimeUnit.MILLISECONDS);\n            if (nullReplyToHandler.exception != null)\n            {\n                throw nullReplyToHandler.exception;\n            }\n        }\n        return nullReplyToHandler.event;\n    }","id":97174,"modified_method":"/**\n     * Runs the given non blocking flow with a default event\n     *\n     * @param flowName the name of the flow to be executed\n     * @return the resulting <code>MuleEvent<\/code>\n     * @throws Exception\n     */\n    protected MuleEvent runFlowNonBlocking(String flowName, MuleEvent event) throws Exception\n    {\n        Flow flow = this.lookupFlowConstruct(flowName);\n        SensingNullReplyToHandler nullReplyToHandler = new SensingNullReplyToHandler();\n        event = new DefaultMuleEvent(event, event.getFlowConstruct(), nullReplyToHandler, null, false);\n        MuleEvent result = flow.process(event);\n        if (NonBlockingVoidMuleEvent.getInstance() == result)\n        {\n            if (!nullReplyToHandler.latch.await(RECEIVE_TIMEOUT, TimeUnit.MILLISECONDS))\n            {\n                throw new RuntimeException(\"No Non-Blocking Response\");\n            }\n            if (nullReplyToHandler.exception != null)\n            {\n                throw nullReplyToHandler.exception;\n            }\n        }\n        return nullReplyToHandler.event;\n    }","commit_id":"2eb3770eaeedd904bc9e338baf7863a223385d60","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n        public void processReplyTo(MuleEvent event, MuleMessage returnMessage, Object replyTo) throws MuleException\n        {\n            NonBlockingProcessorExecutor.this.event = new DefaultMuleEvent(event, replyToHandler);\n            // Update RequestContext ThreadLocal for backwards compatibility\n            OptimizedRequestContext.unsafeSetEvent(event);\n            try\n            {\n                resume();\n            }\n            catch (MessagingException e)\n            {\n                processExceptionReplyTo(e, replyTo);\n            }\n        }","id":97175,"modified_method":"@Override\n        public void processReplyTo(final MuleEvent event, MuleMessage returnMessage, Object replyTo) throws MuleException\n        {\n            try\n            {\n                resume(event);\n            }\n            catch (MessagingException e)\n            {\n                processExceptionReplyTo(e, replyTo);\n            }\n        }","commit_id":"2eb3770eaeedd904bc9e338baf7863a223385d60","url":"https://github.com/mulesoft/mule"},{"original_method":"private void setupNonBlockingMockEvent()\n    {\n        when(event.getExchangePattern()).thenReturn(MessageExchangePattern.REQUEST_RESPONSE);\n        when(event.isSynchronous()).thenReturn(false);\n        when(event.isAllowNonBlocking()).thenReturn(true);\n        when(event.getFlowConstruct()).thenReturn(mock(Flow.class));\n    }","id":97176,"modified_method":"private void setupNonBlockingRequestResponseEvent()\n    {\n        when(event.getExchangePattern()).thenReturn(MessageExchangePattern.REQUEST_RESPONSE);\n        when(event.isSynchronous()).thenReturn(false);\n        when(event.isAllowNonBlocking()).thenReturn(true);\n        when(event.getReplyToHandler()).thenReturn(nullReplyToHandler);\n    }","commit_id":"2eb3770eaeedd904bc9e338baf7863a223385d60","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public void before() throws MessagingException\n    {\n        super.before();\n        when(event.getReplyToHandler()).thenReturn(nullReplyToHandler);\n    }","id":97177,"modified_method":"@Override\n    public void before() throws MessagingException\n    {\n        super.before();\n        when(event.getReplyToHandler()).thenReturn(nullReplyToHandler);\n        when(event.getExchangePattern()).thenReturn(MessageExchangePattern.REQUEST_RESPONSE);\n        when(event.isSynchronous()).thenReturn(false);\n        when(event.isAllowNonBlocking()).thenReturn(true);\n    }","commit_id":"2eb3770eaeedd904bc9e338baf7863a223385d60","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void executeRequestResponseWithMPContainerBlocking() throws MuleException, InterruptedException\n    {\n        setupNonBlockingMockEvent();\n        processors.clear();\n        processors.add(new TestContainerMessageProcessor());\n        processors.add(processor2);\n        processors.add(processor3);\n        assertBlockingExecution(processors);\n    }","id":97178,"modified_method":"@Test\n    public void executeRequestResponseWithMPContainerBlocking() throws MuleException, InterruptedException\n    {\n        processors.clear();\n        processors.add(new TestContainerMessageProcessor());\n        processors.add(processor2);\n        processors.add(processor3);\n        assertBlockingExecution(processors);\n    }","commit_id":"2eb3770eaeedd904bc9e338baf7863a223385d60","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void executeRequestResponseWithInterceptingMPBlocking() throws MuleException, InterruptedException\n    {\n        setupNonBlockingMockEvent();\n        processors.clear();\n        processors.add(new AbstractInterceptingMessageProcessor()\n        {\n            @Override\n            public MuleEvent process(MuleEvent event) throws MuleException\n            {\n                return processNext(event);\n            }\n        });\n        processors.add(processor1);\n        processors.add(processor2);\n        processors.add(processor3);\n        assertBlockingExecution(processors);\n    }","id":97179,"modified_method":"@Test\n    public void executeRequestResponseWithInterceptingMPBlocking() throws MuleException, InterruptedException\n    {\n        processors.clear();\n        processors.add(new AbstractInterceptingMessageProcessor()\n        {\n            @Override\n            public MuleEvent process(MuleEvent event) throws MuleException\n            {\n                return processNext(event);\n            }\n        });\n        processors.add(processor1);\n        processors.add(processor2);\n        processors.add(processor3);\n        assertBlockingExecution(processors);\n    }","commit_id":"2eb3770eaeedd904bc9e338baf7863a223385d60","url":"https://github.com/mulesoft/mule"},{"original_method":"private void assertNonBlockingExecution(List<MessageProcessor> processors) throws MuleException, InterruptedException\n    {\n        ProcessorExecutor executor = createProcessorExecutor(processors);\n\n        if (event.getExchangePattern() == MessageExchangePattern.REQUEST_RESPONSE)\n        {\n            assertThat(executor.execute(), CoreMatchers.<MuleEvent>equalTo(NonBlockingVoidMuleEvent.getInstance()));\n        }\n        else\n        {\n            assertThat(executor.execute(), equalTo(event));\n        }\n\n        nullReplyToHandler.latch.await(LATCH_TIMEOUT, TimeUnit.MILLISECONDS);\n\n        assertThat(processor1.event, is(notNullValue()));\n        assertThat(processor1.thread, equalTo(Thread.currentThread()));\n\n        assertThat(processor2.event, is(notNullValue()));\n        assertThat(processor2.thread, not(equalTo(processor1.thread)));\n\n        assertThat(processor3.event, is(notNullValue()));\n        assertThat(processor3.thread, not(equalTo(processor2.thread)));\n\n        assertThat(nullReplyToHandler.event.getMessageAsString(), equalTo(RESULT));\n    }","id":97180,"modified_method":"private void assertNonBlockingExecution(List<MessageProcessor> processors) throws MuleException, InterruptedException\n    {\n        ProcessorExecutor executor = createProcessorExecutor(processors);\n\n        if (event.getExchangePattern() == MessageExchangePattern.REQUEST_RESPONSE)\n        {\n            assertThat(executor.execute(), CoreMatchers.<MuleEvent>equalTo(NonBlockingVoidMuleEvent.getInstance()));\n        }\n        else\n        {\n            assertThat(executor.execute(), equalTo(event));\n        }\n\n        assertThat(nullReplyToHandler.latch.await(LATCH_TIMEOUT, TimeUnit.MILLISECONDS), is(true));\n\n        assertThat(processor1.event, is(notNullValue()));\n        assertThat(processor1.thread, equalTo(Thread.currentThread()));\n\n        assertThat(processor2.event, is(notNullValue()));\n        assertThat(processor2.thread, not(equalTo(processor1.thread)));\n\n        assertThat(processor3.event, is(notNullValue()));\n        assertThat(processor3.thread, not(equalTo(processor2.thread)));\n\n        assertThat(nullReplyToHandler.event.getMessageAsString(), equalTo(RESULT));\n    }","commit_id":"2eb3770eaeedd904bc9e338baf7863a223385d60","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    @Override\n    public void executeRequestResponseNonBlocking() throws MuleException, InterruptedException\n    {\n        setupNonBlockingMockEvent();\n        assertNonBlockingExecution(processors);\n    }","id":97181,"modified_method":"@Test\n    public void executeRequestResponseNonBlocking() throws MuleException, InterruptedException\n    {\n        setupNonBlockingRequestResponseEvent();\n        assertNonBlockingExecution(processors);\n    }","commit_id":"2eb3770eaeedd904bc9e338baf7863a223385d60","url":"https://github.com/mulesoft/mule"},{"original_method":"public void bindComputeService(ComputeService computeService) {\n        String name = computeService.getContext().unwrap().getName();\n        if (!Strings.isEmpty(name)) {\n            map.putIfAbsent(name, new DynamicReference<ComputeService>(COMPUTE_SERVICE_WAIT, TimeUnit.MILLISECONDS));\n            map.get(name).bind(computeService);\n        }\n    }","id":97182,"modified_method":"public void bindComputeService(ComputeService computeService) {\n        String name = computeService.getContext().unwrap().getName();\n        if (!Strings.isEmpty(name)) {\n            map.putIfAbsent(name, new DynamicReference<ComputeService>(name, COMPUTE_SERVICE_WAIT, TimeUnit.MILLISECONDS));\n            map.get(name).bind(computeService);\n        }\n    }","commit_id":"7cf6d68acd673b22beb9c9f92d3e987a6764ebbf","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public ComputeService getIfPresent(String name) {\n        map.putIfAbsent(name, new DynamicReference<ComputeService>(COMPUTE_SERVICE_WAIT, TimeUnit.MILLISECONDS));\n        return map.get(name).getIfPresent();\n    }","id":97183,"modified_method":"@Override\n    public ComputeService getIfPresent(String name) {\n        map.putIfAbsent(name, new DynamicReference<ComputeService>(name, COMPUTE_SERVICE_WAIT, TimeUnit.MILLISECONDS));\n        return map.get(name).getIfPresent();\n    }","commit_id":"7cf6d68acd673b22beb9c9f92d3e987a6764ebbf","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Finds or waits for the {@link org.jclouds.compute.ComputeService} that matches the specified name.\n     * @param name\n     * @return\n     */\n    public ComputeService getOrWait(String name) {\n        map.putIfAbsent(name, new DynamicReference<ComputeService>(COMPUTE_SERVICE_WAIT, TimeUnit.MILLISECONDS));\n        return map.get(name).get();\n    }","id":97184,"modified_method":"/**\n     * Finds or waits for the {@link org.jclouds.compute.ComputeService} that matches the specified name.\n     * @param name\n     * @return\n     */\n    public ComputeService getOrWait(String name) {\n        map.putIfAbsent(name, new DynamicReference<ComputeService>(name, COMPUTE_SERVICE_WAIT, TimeUnit.MILLISECONDS));\n        return map.get(name).get();\n    }","commit_id":"7cf6d68acd673b22beb9c9f92d3e987a6764ebbf","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public Set<CreateJCloudsContainerMetadata> create(CreateJCloudsContainerOptions input) throws MalformedURLException, RunNodesException, URISyntaxException, InterruptedException {\n        CreateJCloudsContainerOptions options = input.updateComputeService(getOrCreateComputeService(input));\n        int number = Math.max(options.getNumber(), 1);\n\n        final Set<CreateJCloudsContainerMetadata> result = new LinkedHashSet<CreateJCloudsContainerMetadata>();\n        StringBuilder overview = new StringBuilder();\n\n        try {\n            options.getCreationStateListener().onStateChange(\"Looking up for compute service.\");\n            ComputeService computeService = getOrCreateComputeService(options);\n\n            if (computeService == null) {\n                throw new IllegalStateException(\"Compute service could not be found or created.\");\n            }\n            overview.append(String.format(\"Creating %s nodes in the cloud.\", number));\n\n            Template template = ToTemplate.apply(options);\n            Set<? extends NodeMetadata> metadatas = null;\n            overview.append(\" It may take a while ...\");\n            options.getCreationStateListener().onStateChange(overview.toString());\n            metadatas = computeService.createNodesInGroup(options.getGroup(), number, template);\n\n            if (metadatas != null) {\n                for (NodeMetadata metadata : metadatas) {\n                    options.getCreationStateListener().onStateChange(String.format(\"Node %s has been created.\", metadata.getName()));\n                }\n            }\n\n            Thread.sleep(5000);\n\n            int suffix = 1;\n            if (metadatas != null) {\n                String originalName = new String(options.getName());\n                CountDownLatch countDownLatch = new CountDownLatch(number);\n\n                for (NodeMetadata nodeMetadata : metadatas) {\n                    String containerName;\n                    if (options.getNumber() >= 1) {\n                        containerName = originalName + (suffix++);\n                    } else {\n                        containerName = originalName;\n                    }\n                    CloudContainerInstallationTask installationTask = new CloudContainerInstallationTask(containerName,\n                            nodeMetadata, options, computeService, firewallManagerFactory, template.getOptions(), result,\n                            countDownLatch);\n                    executorService.execute(installationTask);\n                }\n                countDownLatch.await(10, TimeUnit.MINUTES);\n            }\n        } catch (Throwable t) {\n                for (int i = result.size(); i < number; i++) {\n                    CreateJCloudsContainerMetadata failureMetdata = new CreateJCloudsContainerMetadata();\n                    failureMetdata.setCreateOptions(options);\n                    failureMetdata.setFailure(t);\n                    result.add(failureMetdata);\n                }\n        }\n        return result;\n    }","id":97185,"modified_method":"public Set<CreateJCloudsContainerMetadata> create(CreateJCloudsContainerOptions input) throws MalformedURLException, RunNodesException, URISyntaxException, InterruptedException {\n        Set<? extends NodeMetadata> metadata = null;\n        CreateJCloudsContainerOptions options = input.updateComputeService(getOrCreateComputeService(input));\n        int number = Math.max(options.getNumber(), 1);\n        int suffix = 1;\n\n        final Set<CreateJCloudsContainerMetadata> result = new LinkedHashSet<CreateJCloudsContainerMetadata>();\n\n        try {\n            options.getCreationStateListener().onStateChange(\"Looking up for compute service.\");\n            ComputeService computeService = getOrCreateComputeService(options);\n\n            if (computeService == null) {\n                throw new IllegalStateException(\"Compute service could not be found or created.\");\n            }\n\n            Template template = ToTemplate.apply(options);\n\n            options.getCreationStateListener().onStateChange(String.format(OVERVIEW_FORMAT, number, options.getContextName()));\n\n            try {\n                metadata = computeService.createNodesInGroup(options.getGroup(), number, template);\n                for (NodeMetadata nodeMetadata : metadata) {\n                    switch (nodeMetadata.getStatus()) {\n                        case RUNNING:\n                            options.getCreationStateListener().onStateChange(String.format(NODE_CREATED_FORMAT, nodeMetadata.getName()));\n                            break;\n                        default:\n                            options.getCreationStateListener().onStateChange(String.format(NODE_ERROR_FORMAT, nodeMetadata.getStatus()));\n                    }\n                }\n            } catch (RunNodesException ex) {\n                CreateJCloudsContainerMetadata failureMetdata = new CreateJCloudsContainerMetadata();\n                failureMetdata.setCreateOptions(options);\n                failureMetdata.setFailure(ex);\n                result.add(failureMetdata);\n                return result;\n            }\n\n            String originalName = new String(options.getName());\n            CountDownLatch countDownLatch = new CountDownLatch(number);\n\n            for (NodeMetadata nodeMetadata : metadata) {\n                String containerName;\n                if (options.getNumber() >= 1) {\n                    containerName = originalName + (suffix++);\n                } else {\n                    containerName = originalName;\n                }\n                CloudContainerInstallationTask installationTask = new CloudContainerInstallationTask(containerName,\n                        nodeMetadata, options, computeService, firewallManagerFactory, template.getOptions(), result,\n                        countDownLatch);\n                executorService.execute(installationTask);\n            }\n\n            if (!countDownLatch.await(15, TimeUnit.MINUTES)) {\n                throw new FabricException(\"Error waiting for container installation.\");\n            }\n\n        } catch (Throwable t) {\n                for (int i = result.size(); i < number; i++) {\n                    CreateJCloudsContainerMetadata failureMetdata = new CreateJCloudsContainerMetadata();\n                    failureMetdata.setCreateOptions(options);\n                    failureMetdata.setFailure(t);\n                    result.add(failureMetdata);\n                }\n        }\n        return result;\n    }","commit_id":"7cf6d68acd673b22beb9c9f92d3e987a6764ebbf","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public OChannel(final Socket iSocket, final OContextConfiguration iConfig) throws IOException {\n    super(true);\n    socket = iSocket;\n    socketBufferSize = iConfig.getValueAsInteger(OGlobalConfiguration.NETWORK_SOCKET_BUFFER_SIZE);\n    socket.setTcpNoDelay(true);\n    timeout = iConfig.getValueAsLong(OGlobalConfiguration.NETWORK_REQUEST_TIMEOUT);\n  }","id":97186,"modified_method":"public OChannel(final Socket iSocket, final OContextConfiguration iConfig) throws IOException {\n    super(true);\n    socket = iSocket;\n    socketBufferSize = iConfig.getValueAsInteger(OGlobalConfiguration.NETWORK_SOCKET_BUFFER_SIZE);\n    socket.setTcpNoDelay(true);\n    //THIS TIMEOUT IS CORRECT BUT CREATE SOME PROBLEM ON REMOTE, NEED CHECK BEFORE BE ENABLED\n    //timeout = iConfig.getValueAsLong(OGlobalConfiguration.NETWORK_REQUEST_TIMEOUT);\n  }","commit_id":"5e6416e833429c73edb046c2a78a32e886f9ee50","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public byte[] beginResponse(final int iRequesterId, final long iTimeout, final boolean token) throws IOException {\n    try {\n      int unreadResponse = 0;\n      final long startClock = iTimeout > 0 ? System.currentTimeMillis() : 0;\n\n      // WAIT FOR THE RESPONSE\n      do {\n        if (iTimeout <= 0)\n          acquireReadLock();\n        else if (!getLockRead().tryAcquireLock(iTimeout, TimeUnit.MILLISECONDS))\n          throw new OTimeoutException(\"Cannot acquire read lock against channel: \" + this);\n\n        boolean readLock = true;\n\n        if (!isConnected()) {\n          releaseReadLock();\n          throw new IOException(\"Channel is closed\");\n        }\n\n        if (!channelRead) {\n          channelRead = true;\n\n          try {\n            setWaitResponseTimeout();\n            currentStatus = readByte();\n            currentSessionId = readInt();\n\n            if (debug)\n              OLogManager.instance().debug(this, \"%s - Read response: %d-%d\", socket.getLocalAddress(), (int) currentStatus,\n                  currentSessionId);\n\n          } catch (IOException e) {\n            // UNLOCK THE RESOURCE AND PROPAGATES THE EXCEPTION\n            channelRead = false;\n            readCondition.signalAll();\n            releaseReadLock();\n            readLock = false;\n\n            throw e;\n          } finally {\n            setReadResponseTimeout();\n          }\n        }\n\n        if (currentSessionId == iRequesterId)\n          // IT'S FOR ME\n          break;\n\n        try {\n          if (debug)\n            OLogManager.instance().debug(this, \"%s - Session %d skip response, it is for %d\", socket.getLocalAddress(),\n                iRequesterId, currentSessionId);\n\n          if (iTimeout > 0 && (System.currentTimeMillis() - startClock) > iTimeout) {\n            // CLOSE THE SOCKET TO CHANNEL TO AVOID FURTHER DIRTY DATA\n            close();\n            readLock = false;\n\n            throw new OTimeoutException(\"Timeout on reading response from the server \"\n                + (socket != null ? socket.getRemoteSocketAddress() : \"\") + \" for the request \" + iRequesterId);\n          }\n\n          // IN CASE OF TOO MUCH TIME FOR READ A MESSAGE, ASYNC THREAD SHOULD NOT BE INCLUDE IN THIS CHECK\n          if (unreadResponse > maxUnreadResponses && iRequesterId != Integer.MIN_VALUE) {\n            if (debug)\n              OLogManager.instance().info(this, \"Unread responses %d > %d, consider the buffer as dirty: clean it\", unreadResponse,\n                  maxUnreadResponses);\n\n            close();\n            readLock = false;\n\n            throw new IOException(\"Timeout on reading response\");\n          }\n\n          readCondition.signalAll();\n\n          if (debug)\n            OLogManager.instance().debug(this, \"Session %d is going to sleep...\", iRequesterId);\n\n          final long start = System.currentTimeMillis();\n\n          if (iTimeout > 0)\n            readCondition.await(iTimeout, TimeUnit.MILLISECONDS);\n          else\n            // WAIT MAX 3 SECOND AND RETRY, THIS IS UNBLOCKED BY ANOTHER THREAD IN CASE THE RESPONSE FOR THIS IS ARRIVED\n            readCondition.await(3000, TimeUnit.MILLISECONDS);\n\n          if (debug) {\n            final long now = System.currentTimeMillis();\n            OLogManager.instance().debug(this, \"Waked up: slept %dms, checking again from %s for session %d\", (now - start),\n                socket.getLocalAddress(), iRequesterId);\n          }\n\n          unreadResponse++;\n\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n\n        } finally {\n          if (readLock)\n            releaseReadLock();\n        }\n      } while (true);\n\n      if (debug)\n        OLogManager.instance().debug(this, \"%s - Session %d handle response\", socket.getLocalAddress(), iRequesterId);\n      byte[] tokenBytes;\n      if (token)\n        tokenBytes = this.readBytes();\n      else\n        tokenBytes = null;\n      handleStatus(currentStatus, currentSessionId);\n      return tokenBytes;\n    } catch (OLockException e) {\n      Thread.currentThread().interrupt();\n      // NEVER HAPPENS?\n      OLogManager.instance().error(this, \"Unexpected error on reading response from channel\", e);\n    }\n    return null;\n  }","id":97187,"modified_method":"public byte[] beginResponse(final int iRequesterId, final long iTimeout, final boolean token) throws IOException {\n    try {\n      int unreadResponse = 0;\n      final long startClock = iTimeout > 0 ? System.currentTimeMillis() : 0;\n\n      // WAIT FOR THE RESPONSE\n      do {\n        if (iTimeout <= 0)\n          acquireReadLock();\n        else if (!getLockRead().tryAcquireLock(iTimeout, TimeUnit.MILLISECONDS))\n          throw new OTimeoutException(\"Cannot acquire read lock against channel: \" + this);\n\n        boolean readLock = true;\n\n        if (!isConnected()) {\n          releaseReadLock();\n          throw new IOException(\"Channel is closed\");\n        }\n\n        if (!channelRead) {\n          channelRead = true;\n\n          try {\n            setWaitResponseTimeout();\n            currentStatus = readByte();\n            currentSessionId = readInt();\n\n            if (debug)\n              OLogManager.instance().debug(this, \"%s - Read response: %d-%d\", socket.getLocalAddress(), (int) currentStatus,\n                  currentSessionId);\n\n          } catch (IOException e) {\n            // UNLOCK THE RESOURCE AND PROPAGATES THE EXCEPTION\n            channelRead = false;\n            readCondition.signalAll();\n            releaseReadLock();\n            readLock = false;\n\n            throw e;\n          } finally {\n            setReadResponseTimeout();\n          }\n        }\n\n        if (currentSessionId == iRequesterId)\n          // IT'S FOR ME\n          break;\n\n        try {\n          if (debug)\n            OLogManager.instance().debug(this, \"%s - Session %d skip response, it is for %d\", socket.getLocalAddress(),\n                iRequesterId, currentSessionId);\n\n          if (iTimeout > 0 && (System.currentTimeMillis() - startClock) > iTimeout) {\n            // CLOSE THE SOCKET TO CHANNEL TO AVOID FURTHER DIRTY DATA\n            close();\n            readLock = false;\n\n            throw new OTimeoutException(\"Timeout on reading response from the server \"\n                + (socket != null ? socket.getRemoteSocketAddress() : \"\") + \" for the request \" + iRequesterId);\n          }\n\n          // IN CASE OF TOO MUCH TIME FOR READ A MESSAGE, ASYNC THREAD SHOULD NOT BE INCLUDE IN THIS CHECK\n          if (unreadResponse > maxUnreadResponses && iRequesterId != Integer.MIN_VALUE) {\n            if (debug)\n              OLogManager.instance().info(this, \"Unread responses %d > %d, consider the buffer as dirty: clean it\", unreadResponse,\n                  maxUnreadResponses);\n\n            close();\n            readLock = false;\n\n            throw new IOException(\"Timeout on reading response\");\n          }\n\n          readCondition.signalAll();\n\n          if (debug)\n            OLogManager.instance().debug(this, \"Session %d is going to sleep...\", iRequesterId);\n\n          final long start = System.currentTimeMillis();\n\n          if (this.serviceThread == null || iRequesterId != Integer.MIN_VALUE && this.currentSessionId != Integer.MIN_VALUE) {\n            throw new OIOException(\"Found a session id \" + this.currentSessionId + \" not expected, possible wrong data on socket\");\n          } else\n            // WAIT MAX 30  SEC FOR THE ASYNC THREAD TO READ THE RESPONSE\n          if (!readCondition.await(30000, TimeUnit.MILLISECONDS)) {\n            //SOMETHING WENT WRONG IN THE ASYNC THREAD\n            throw new OIOException(\"Timeout on push messaged reading by async thread\");\n          }\n\n          if (debug) {\n            final long now = System.currentTimeMillis();\n            OLogManager.instance().debug(this, \"Waked up: slept %dms, checking again from %s for session %d\", (now - start),\n                socket.getLocalAddress(), iRequesterId);\n          }\n\n          unreadResponse++;\n\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n\n        } finally {\n          if (readLock)\n            releaseReadLock();\n        }\n      } while (true);\n\n      if (debug)\n        OLogManager.instance().debug(this, \"%s - Session %d handle response\", socket.getLocalAddress(), iRequesterId);\n      byte[] tokenBytes;\n      if (token)\n        tokenBytes = this.readBytes();\n      else\n        tokenBytes = null;\n      handleStatus(currentStatus, currentSessionId);\n      return tokenBytes;\n    } catch (OLockException e) {\n      Thread.currentThread().interrupt();\n      // NEVER HAPPENS?\n      OLogManager.instance().error(this, \"Unexpected error on reading response from channel\", e);\n    }\n    return null;\n  }","commit_id":"5e6416e833429c73edb046c2a78a32e886f9ee50","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private static GridServiceAgent waitForGridServiceAgent(final Admin admin, final String hostAddress,\r\n\t\t\tfinal long timeout, final TimeUnit unit)\r\n\t\t\tthrows InterruptedException, TimeoutException {\r\n\r\n\t\tif (timeout < 0) {\r\n\t\t\tthrow new TimeoutException(\"Timeout waiting for grid service agent.\");\r\n\t\t}\r\n\t\t\r\n\t\tfinal AtomicReference<GridServiceAgent> gsaRef = new AtomicReference<GridServiceAgent>(null);\r\n\t\tfinal CountDownLatch gridServiceAgentAddedLatch = new CountDownLatch(1);\r\n\r\n\t\tadmin.getGridServiceAgents().getGridServiceAgentAdded().add(new GridServiceAgentAddedEventListener() {\r\n\r\n\t\t\tpublic void gridServiceAgentAdded(final GridServiceAgent gridServiceAgent) {\r\n\t\t\t\tif (gridServiceAgent.getMachine().getHostAddress().equals(hostAddress)) {\r\n\t\t\t\t\tgsaRef.set(gridServiceAgent);\r\n\t\t\t\t\tgridServiceAgentAddedLatch.countDown();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tgridServiceAgentAddedLatch.await(unit.toMillis(timeout), TimeUnit.MILLISECONDS);\r\n\t\tfinal GridServiceAgent gsa = gsaRef.get();\r\n\r\n\t\tif (gsa == null) {\r\n\t\t\tthrow new TimeoutException(\"Timeout waiting for grid service agent.\");\r\n\t\t}\r\n\r\n\t\treturn gsa;\r\n\t}","id":97188,"modified_method":"private static GridServiceAgent waitForGridServiceAgent(final Admin admin, final String hostAddress,\r\n\t\t\tfinal long timeout, final TimeUnit unit)\r\n\t\t\tthrows InterruptedException, TimeoutException {\r\n\r\n\t\tif (timeout < 0) {\r\n\t\t\tthrow new TimeoutException(\"Timeout waiting for grid service agent.\");\r\n\t\t}\r\n\t\t\r\n\t\tfinal AtomicReference<GridServiceAgent> gsaRef = new AtomicReference<GridServiceAgent>(null);\r\n\t\tfinal CountDownLatch gridServiceAgentAddedLatch = new CountDownLatch(1);\r\n\r\n\t\tadmin.getGridServiceAgents().getGridServiceAgentAdded().add(new GridServiceAgentAddedEventListener() {\r\n\r\n\t\t\tpublic void gridServiceAgentAdded(final GridServiceAgent gridServiceAgent) {\r\n\t\t\t\tif (gridServiceAgent.getMachine().getHostAddress().equals(hostAddress)) {\r\n\t\t\t\t\tgsaRef.set(gridServiceAgent);\r\n\t\t\t\t\tgridServiceAgentAddedLatch.countDown();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tfinal boolean result = gridServiceAgentAddedLatch.await(unit.toMillis(timeout), TimeUnit.MILLISECONDS);\n\t\tif(!result) {\n\t\t\tthrow new TimeoutException(\"Timeout waiting for grid service agent.\");\n\t\t}\n\t\t\r\n\t\tfinal GridServiceAgent gsa = gsaRef.get();\r\n\r\n\t\tif (gsa == null) {\r\n\t\t\tthrow new TimeoutException(\"Timeout waiting for grid service agent.\");\r\n\t\t}\r\n\r\n\t\treturn gsa;\r\n\t}","commit_id":"bf7a769d9e0343e995d67eb38f7abbcd25f8416b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private MachineDetails[] getExistingManagementServers(final String managementMachinePrefix) {\n\t\tSet<? extends NodeMetadata> existingManagementServers = this.deployer\n\t\t\t\t.getServers(new Predicate<ComputeMetadata>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean apply(ComputeMetadata input) {\n\t\t\t\t\t\tfinal NodeMetadata node = (NodeMetadata) input;\n\t\t\t\t\t\tif (node.getGroup() == null) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// only running or pending nodes are interesting\n\t\t\t\t\t\tif (!(node.getState() == NodeState.RUNNING || node.getState() == NodeState.PENDING)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn node.getGroup().startsWith(managementMachinePrefix);\n\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tMachineDetails[] result = new MachineDetails[existingManagementServers.size()];\n\t\tint i = 0;\n\t\tfor (NodeMetadata node : existingManagementServers) {\n\t\t\tresult[i] = createMachineDetailsFromNode(node);\n\t\t\tresult[i].setAgentRunning(true);\n\t\t\tresult[i].setCloudifyInstalled(true);\n\t\t\ti++;\n\n\t\t}\n\t\treturn result;\n\n\t}","id":97189,"modified_method":"private MachineDetails[] getExistingManagementServers(final String managementMachinePrefix) {\n\t\tfinal Set<? extends NodeMetadata> existingManagementServers = this.deployer\n\t\t\t\t.getServers(new Predicate<ComputeMetadata>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean apply(final ComputeMetadata input) {\n\t\t\t\t\t\tfinal NodeMetadata node = (NodeMetadata) input;\n\t\t\t\t\t\tif (node.getGroup() == null) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// only running or pending nodes are interesting\n\t\t\t\t\t\tif (!(node.getState() == NodeState.RUNNING || node.getState() == NodeState.PENDING)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn node.getGroup().startsWith(managementMachinePrefix);\n\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tfinal MachineDetails[] result = new MachineDetails[existingManagementServers.size()];\n\t\tint i = 0;\n\t\tfor (final NodeMetadata node : existingManagementServers) {\n\t\t\tresult[i] = createMachineDetailsFromNode(node);\n\t\t\tresult[i].setAgentRunning(true);\n\t\t\tresult[i].setCloudifyInstalled(true);\n\t\t\ti++;\n\n\t\t}\n\t\treturn result;\n\n\t}","commit_id":"bf7a769d9e0343e995d67eb38f7abbcd25f8416b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic MachineDetails startMachine(long timeout, TimeUnit unit) throws TimeoutException, CloudProvisioningException {\n\n\t\tlogger.fine(\"DefaultCloudProvisioning: startMachine - management == \" + management);\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(timeout);\n\n\t\tinitDeployer(cloud);\n\n\t\t// initializing the jclouds context can take a while on some clouds, so\n\t\t// check for timeout\n\t\tif (System.currentTimeMillis() > end) {\n\t\t\tthrow new TimeoutException(\"Starting a new machine timed out\");\n\t\t}\n\n\t\ttry {\n\t\t\tMachineDetails md = doStartMachine(end);\n\t\t\treturn md;\n\t\t} catch (Exception e) {\n\t\t\tthrow new CloudProvisioningException(\"Failed to start cloud machine\", e);\n\t\t}\n\n\t}","id":97190,"modified_method":"@Override\n\tpublic MachineDetails startMachine(final long timeout, final TimeUnit unit) throws TimeoutException,\n\t\t\tCloudProvisioningException {\n\n\t\tlogger.fine(\"DefaultCloudProvisioning: startMachine - management == \" + management);\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(timeout);\n\n\t\tinitDeployer(cloud);\n\n\t\t// initializing the jclouds context can take a while on some clouds, so\n\t\t// check for timeout\n\t\tif (System.currentTimeMillis() > end) {\n\t\t\tthrow new TimeoutException(\"Starting a new machine timed out\");\n\t\t}\n\n\t\ttry {\n\t\t\tfinal MachineDetails md = doStartMachine(end);\n\t\t\treturn md;\n\t\t} catch (final Exception e) {\n\t\t\tthrow new CloudProvisioningException(\"Failed to start cloud machine\", e);\n\t\t}\n\n\t}","commit_id":"bf7a769d9e0343e995d67eb38f7abbcd25f8416b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private MachineDetails createMachineDetailsFromNode(NodeMetadata node) {\n\t\tMachineDetails md = new MachineDetails();\n\t\tmd.setAgentRunning(false);\n\t\tmd.setCloudifyInstalled(false);\n\t\tmd.setInstallationDirectory(null);\n\t\tmd.setMachineId(node.getId());\n\t\tif (node.getPrivateAddresses().size() > 0) {\n\t\t\tmd.setPrivateAddress(node.getPrivateAddresses().iterator().next());\n\t\t}\n\t\tif (node.getPublicAddresses().size() > 0) {\n\t\t\tmd.setPublicAddress(node.getPublicAddresses().iterator().next());\n\t\t}\n\n\t\tif (node.getCredentials() == null) {\n\t\t\tmd.setRemoteUsername(cloud.getConfiguration().getRemoteUsername());\n\t\t} else {\n\t\t\tfinal String serverIdentity = node.getCredentials().identity;\n\t\t\tif (serverIdentity != null) {\n\t\t\t\tmd.setRemoteUsername(serverIdentity);\n\t\t\t} else {\n\t\t\t\tmd.setRemoteUsername(cloud.getConfiguration().getRemoteUsername());\n\t\t\t}\n\t\t}\n\n\t\t// By default, cloud nodes connect to each other using their private\n\t\t// address.\n\t\tmd.setUsePrivateAddress(true);\n\t\treturn md;\n\t}","id":97191,"modified_method":"private MachineDetails createMachineDetailsFromNode(final NodeMetadata node) {\n\t\tfinal MachineDetails md = new MachineDetails();\n\t\tmd.setAgentRunning(false);\n\t\tmd.setCloudifyInstalled(false);\n\t\tmd.setInstallationDirectory(null);\n\t\tmd.setMachineId(node.getId());\n\t\tif (node.getPrivateAddresses().size() > 0) {\n\t\t\tmd.setPrivateAddress(node.getPrivateAddresses().iterator().next());\n\t\t}\n\t\tif (node.getPublicAddresses().size() > 0) {\n\t\t\tmd.setPublicAddress(node.getPublicAddresses().iterator().next());\n\t\t}\n\n\t\tif (node.getCredentials() == null) {\n\t\t\tmd.setRemoteUsername(cloud.getConfiguration().getRemoteUsername());\n\t\t} else {\n\t\t\tfinal String serverIdentity = node.getCredentials().identity;\n\t\t\tif (serverIdentity != null) {\n\t\t\t\tmd.setRemoteUsername(serverIdentity);\n\t\t\t} else {\n\t\t\t\tmd.setRemoteUsername(cloud.getConfiguration().getRemoteUsername());\n\t\t\t}\n\t\t}\n\n\t\t// By default, cloud nodes connect to each other using their private\n\t\t// address.\n\t\tmd.setUsePrivateAddress(true);\n\t\treturn md;\n\t}","commit_id":"bf7a769d9e0343e995d67eb38f7abbcd25f8416b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic MachineDetails[] startManagementMachines(final long duration, final TimeUnit unit) throws TimeoutException,\n\t\t\tCloudProvisioningException {\n\t\tif (duration < 0) {\n\t\t\tthrow new TimeoutException(\"Starting a new machine timed out\");\n\t\t}\n\t\tfinal long endTime = System.currentTimeMillis() + unit.toMillis(duration);\n\n\t\tlogger.fine(\"DefaultCloudProvisioning: startMachine - management == \" + management);\n\n\t\tpublishEvent(\"try_to_connect_to_cloud_api\", cloud.getProvider().getProvider());\n\t\tinitDeployer(cloud);\n\t\tpublishEvent(\"connection_to_cloud_api_succeeded\", cloud.getProvider().getProvider());\n\t\t\n\t\t\n\t\t// force the creation of the jclouds template - otherwise, it may be\n\t\t// created multiple times, once for each management machine\n\t\tthis.deployer.getTemplate();\n\n\t\tfinal String managementMachinePrefix = this.machineNamePrefix;\n\n\t\t// first check if management already exists\n\t\tMachineDetails[] existingManagementServers = getExistingManagementServers(managementMachinePrefix);\n\t\tif (existingManagementServers.length > 0) {\n\t\t\tlogger.fine(\"Found existing servers matching the name: \" + managementMachinePrefix);\n\t\t\treturn existingManagementServers;\n\t\t}\n\n\t\t// launch the management machines\n\t\tpublishEvent(\"attempting_to_create_management_vms\");\n\t\tint numberOfManagementMachines = this.cloud.getProvider().getNumberOfManagementMachines();\n\t\tMachineDetails[] createdMachines = doStartManagementMachines(endTime, numberOfManagementMachines);\n\t\tpublishEvent(\"management_started_successfully\");\n\t\treturn createdMachines;\n\n\t}","id":97192,"modified_method":"@Override\n\tpublic MachineDetails[] startManagementMachines(final long duration, final TimeUnit unit) throws TimeoutException,\n\t\t\tCloudProvisioningException {\n\t\tif (duration < 0) {\n\t\t\tthrow new TimeoutException(\"Starting a new machine timed out\");\n\t\t}\n\t\tfinal long endTime = System.currentTimeMillis() + unit.toMillis(duration);\n\n\t\tlogger.fine(\"DefaultCloudProvisioning: startMachine - management == \" + management);\n\n\t\tpublishEvent(\"try_to_connect_to_cloud_api\", cloud.getProvider().getProvider());\n\t\tinitDeployer(cloud);\n\t\tpublishEvent(\"connection_to_cloud_api_succeeded\", cloud.getProvider().getProvider());\n\n\t\t// force the creation of the jclouds template - otherwise, it may be\n\t\t// created multiple times, once for each management machine\n\t\tthis.deployer.getTemplate();\n\n\t\tfinal String managementMachinePrefix = this.machineNamePrefix;\n\n\t\t// first check if management already exists\n\t\tfinal MachineDetails[] existingManagementServers = getExistingManagementServers(managementMachinePrefix);\n\t\tif (existingManagementServers.length > 0) {\n\t\t\tlogger.fine(\"Found existing servers matching the name: \" + managementMachinePrefix);\n\t\t\treturn existingManagementServers;\n\t\t}\n\n\t\t// launch the management machines\n\t\tpublishEvent(\"attempting_to_create_management_vms\");\n\t\tfinal int numberOfManagementMachines = this.cloud.getProvider().getNumberOfManagementMachines();\n\t\tfinal MachineDetails[] createdMachines = doStartManagementMachines(endTime, numberOfManagementMachines);\n\t\tpublishEvent(\"management_started_successfully\");\n\t\treturn createdMachines;\n\n\t}","commit_id":"bf7a769d9e0343e995d67eb38f7abbcd25f8416b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private MachineDetails createServer(final long end, final String machineName) throws CloudProvisioningException,\n\t\t\tException {\n\t\tNodeMetadata node;\n\t\ttry {\n\t\t\tnode = deployer.createServer(machineName);\n\t\t} catch (InstallerException e) {\n\t\t\tthrow new CloudProvisioningException(\"Failed to create cloud machine\", e);\n\t\t}\n\n\t\tlogger.fine(\"New machine is starting\");\n\n\t\t// At this point the machine is starting. Any error beyond this point\n\t\t// must clean up the machine\n\t\ttry {\n\t\t\tMachineDetails md = createMachineDetailsFromNode(node);\n\n\t\t\thandleServerCredentials(node, md);\n\n\t\t\twaitUntilServerIsActive(node.getId(), Utils.millisUntil(end), TimeUnit.MILLISECONDS);\n\t\t\treturn md;\n\t\t} catch (Exception e) {\n\t\t\t// catch any exception - to prevent a cloud machine leaking.\n\t\t\tlogger.log(Level.SEVERE,\n\t\t\t\t\t\"Cloud machine was started but an error occured during initialization. Shutting down machine\", e);\n\t\t\tthis.deployer.shutdownMachine(node.getId());\n\t\t\tthrow e;\n\t\t}\n\t}","id":97193,"modified_method":"private MachineDetails createServer(final long end, final String machineName) throws CloudProvisioningException,\n\t\t\tException {\n\t\tNodeMetadata node;\n\t\ttry {\n\t\t\tnode = deployer.createServer(machineName);\n\t\t} catch (final InstallerException e) {\n\t\t\tthrow new CloudProvisioningException(\"Failed to create cloud machine\", e);\n\t\t}\n\n\t\tlogger.fine(\"New machine is starting\");\n\n\t\t// At this point the machine is starting. Any error beyond this point\n\t\t// must clean up the machine\n\t\ttry {\n\t\t\tfinal MachineDetails md = createMachineDetailsFromNode(node);\n\n\t\t\thandleServerCredentials(node, md);\n\n\t\t\twaitUntilServerIsActive(node.getId(), Utils.millisUntil(end), TimeUnit.MILLISECONDS);\n\t\t\treturn md;\n\t\t} catch (final Exception e) {\n\t\t\t// catch any exception - to prevent a cloud machine leaking.\n\t\t\tlogger.log(Level.SEVERE,\n\t\t\t\t\t\"Cloud machine was started but an error occured during initialization. Shutting down machine\", e);\n\t\t\tthis.deployer.shutdownMachine(node.getId());\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"bf7a769d9e0343e995d67eb38f7abbcd25f8416b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/*********\n\t * Looks for a free machine name by appending a counter to the precalculated\n\t * machine name prefix. If the max counter value is reached, code will loop\n\t * back to 0, so that previously used machine names will be reused.\n\t * \n\t * @return the machine name.\n\t * @throws CloudProvisioningException\n\t *             if no free machine name could be found.\n\t */\n\tprivate String createNewMachineName() throws CloudProvisioningException {\n\t\tint attempts = 0;\n\t\twhile (attempts < MAX_MACHINE_LIMIT) {\n\t\t\tcounter = (counter + 1) % MAX_MACHINE_LIMIT;\n\t\t\t++attempts;\n\t\t\tfinal String machineName = this.machineNamePrefix + this.counter;\n\t\t\tNodeMetadata existingNode = deployer.getServerByID(machineName);\n\t\t\tif (existingNode == null) {\n\t\t\t\treturn machineName;\n\t\t\t}\n\t\t}\n\t\tthrow new CloudProvisioningException(\"Number of machines has exceeded allowed machine limit (\"\n\t\t\t\t+ MAX_MACHINE_LIMIT + \")\");\n\n\t}","id":97194,"modified_method":"/*********\n\t * Looks for a free machine name by appending a counter to the precalculated machine name prefix. If the max counter\n\t * value is reached, code will loop back to 0, so that previously used machine names will be reused.\n\t * \n\t * @return the machine name.\n\t * @throws CloudProvisioningException\n\t *             if no free machine name could be found.\n\t */\n\tprivate String createNewMachineName() throws CloudProvisioningException {\n\t\tint attempts = 0;\n\t\twhile (attempts < MAX_MACHINE_LIMIT) {\n\t\t\tcounter = (counter + 1) % MAX_MACHINE_LIMIT;\n\t\t\t++attempts;\n\t\t\tfinal String machineName = this.machineNamePrefix + this.counter;\n\t\t\tfinal NodeMetadata existingNode = deployer.getServerByID(machineName);\n\t\t\tif (existingNode == null) {\n\t\t\t\treturn machineName;\n\t\t\t}\n\t\t}\n\t\tthrow new CloudProvisioningException(\"Number of machines has exceeded allowed machine limit (\"\n\t\t\t\t+ MAX_MACHINE_LIMIT + \")\");\n\n\t}","commit_id":"bf7a769d9e0343e995d67eb38f7abbcd25f8416b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void stopManagementMachines() throws TimeoutException, CloudProvisioningException {\n\n\t\tinitDeployer(this.cloud);\n\t\tMachineDetails[] managementServers = getExistingManagementServers(this.machineNamePrefix);\n\n\t\tif (managementServers.length == 0) {\n\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\"Could not find any management machines for this cloud (management machine prefix is: \"\n\t\t\t\t\t\t\t+ this.machineNamePrefix + \")\");\n\t\t}\n\n\t\tSet<String> machineIps = new HashSet<String>();\n\t\tfor (MachineDetails machineDetails : managementServers) {\n\t\t\tmachineIps.add(machineDetails.getPrivateAddress());\n\t\t}\n\n\t\tthis.deployer.shutdownMachinesWithIPs(machineIps);\n\n\t}","id":97195,"modified_method":"@Override\n\tpublic void stopManagementMachines() throws TimeoutException, CloudProvisioningException {\n\n\t\tinitDeployer(this.cloud);\n\t\tfinal MachineDetails[] managementServers = getExistingManagementServers(this.machineNamePrefix);\n\n\t\tif (managementServers.length == 0) {\n\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\"Could not find any management machines for this cloud (management machine prefix is: \"\n\t\t\t\t\t\t\t+ this.machineNamePrefix + \")\");\n\t\t}\n\n\t\tfinal Set<String> machineIps = new HashSet<String>();\n\t\tfor (final MachineDetails machineDetails : managementServers) {\n\t\t\tmachineIps.add(machineDetails.getPrivateAddress());\n\t\t}\n\n\t\tthis.deployer.shutdownMachinesWithIPs(machineIps);\n\n\t}","commit_id":"bf7a769d9e0343e995d67eb38f7abbcd25f8416b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private MachineDetails[] doStartManagementMachines(final long endTime, int numberOfManagementMachines)\n\t\t\tthrows TimeoutException, CloudProvisioningException {\n\t\tExecutorService executors = Executors.newFixedThreadPool(numberOfManagementMachines);\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tFuture<MachineDetails>[] futures = (Future<MachineDetails>[]) new Future<?>[numberOfManagementMachines];\n\n\t\ttry {\n\t\t\t// Call startMachine asynchronously once for each management\n\t\t\t// machine\n\t\t\tfor (int i = 0; i < numberOfManagementMachines; i++) {\n\t\t\t\tfinal int index = i + 1;\n\t\t\t\tfutures[i] = executors.submit(new Callable<MachineDetails>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic MachineDetails call() throws Exception {\n\t\t\t\t\t\treturn createServer(endTime, machineNamePrefix + index);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t\t// Wait for each of the async calls to terminate.\n\t\t\tint numberOfErrors = 0;\n\t\t\tException firstCreationException = null;\n\t\t\tMachineDetails[] createdManagementMachines = new MachineDetails[numberOfManagementMachines];\n\t\t\tfor (int i = 0; i < createdManagementMachines.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tcreatedManagementMachines[i] = futures[i].get(endTime - System.currentTimeMillis(),\n\t\t\t\t\t\t\tTimeUnit.MILLISECONDS);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t++numberOfErrors;\n\t\t\t\t\tpublishEvent(\"failed_to_create_management_vm\", e.getMessage());\n\t\t\t\t\tlogger.log(Level.SEVERE, \"Failed to start a management machine\", e);\n\t\t\t\t\tif (firstCreationException == null) {\n\t\t\t\t\t\tfirstCreationException = e;\n\t\t\t\t\t}\n\n\t\t\t\t} catch (ExecutionException e) {\n\t\t\t\t\t++numberOfErrors;\n\t\t\t\t\tpublishEvent(\"failed_to_create_management_vm\", e.getMessage());\n\t\t\t\t\tlogger.log(Level.SEVERE, \"Failed to start a management machine\", e);\n\t\t\t\t\tif (firstCreationException == null) {\n\t\t\t\t\t\tfirstCreationException = e;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// In case of a partial error, shutdown all servers that did start\n\t\t\t// up\n\t\t\tif (numberOfErrors > 0) {\n\t\t\t\thandleProvisioningFailure(numberOfManagementMachines, numberOfErrors, firstCreationException,\n\t\t\t\t\t\tcreatedManagementMachines);\n\t\t\t}\n\n\t\t\treturn createdManagementMachines;\n\t\t} finally {\n\t\t\tif (executors != null) {\n\t\t\t\texecutors.shutdownNow();\n\t\t\t}\n\t\t}\n\t}","id":97196,"modified_method":"private MachineDetails[] doStartManagementMachines(final long endTime, final int numberOfManagementMachines)\n\t\t\tthrows TimeoutException, CloudProvisioningException {\n\t\tfinal ExecutorService executors = Executors.newFixedThreadPool(numberOfManagementMachines);\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tfinal Future<MachineDetails>[] futures = (Future<MachineDetails>[]) new Future<?>[numberOfManagementMachines];\n\n\t\ttry {\n\t\t\t// Call startMachine asynchronously once for each management\n\t\t\t// machine\n\t\t\tfor (int i = 0; i < numberOfManagementMachines; i++) {\n\t\t\t\tfinal int index = i + 1;\n\t\t\t\tfutures[i] = executors.submit(new Callable<MachineDetails>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic MachineDetails call() throws Exception {\n\t\t\t\t\t\treturn createServer(endTime, machineNamePrefix + index);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t\t// Wait for each of the async calls to terminate.\n\t\t\tint numberOfErrors = 0;\n\t\t\tException firstCreationException = null;\n\t\t\tfinal MachineDetails[] createdManagementMachines = new MachineDetails[numberOfManagementMachines];\n\t\t\tfor (int i = 0; i < createdManagementMachines.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tcreatedManagementMachines[i] = futures[i].get(endTime - System.currentTimeMillis(),\n\t\t\t\t\t\t\tTimeUnit.MILLISECONDS);\n\t\t\t\t} catch (final InterruptedException e) {\n\t\t\t\t\t++numberOfErrors;\n\t\t\t\t\tpublishEvent(\"failed_to_create_management_vm\", e.getMessage());\n\t\t\t\t\tlogger.log(Level.SEVERE, \"Failed to start a management machine\", e);\n\t\t\t\t\tif (firstCreationException == null) {\n\t\t\t\t\t\tfirstCreationException = e;\n\t\t\t\t\t}\n\n\t\t\t\t} catch (final ExecutionException e) {\n\t\t\t\t\t++numberOfErrors;\n\t\t\t\t\tpublishEvent(\"failed_to_create_management_vm\", e.getMessage());\n\t\t\t\t\tlogger.log(Level.SEVERE, \"Failed to start a management machine\", e);\n\t\t\t\t\tif (firstCreationException == null) {\n\t\t\t\t\t\tfirstCreationException = e;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// In case of a partial error, shutdown all servers that did start\n\t\t\t// up\n\t\t\tif (numberOfErrors > 0) {\n\t\t\t\thandleProvisioningFailure(numberOfManagementMachines, numberOfErrors, firstCreationException,\n\t\t\t\t\t\tcreatedManagementMachines);\n\t\t\t}\n\n\t\t\treturn createdManagementMachines;\n\t\t} finally {\n\t\t\tif (executors != null) {\n\t\t\t\texecutors.shutdownNow();\n\t\t\t}\n\t\t}\n\t}","commit_id":"bf7a769d9e0343e995d67eb38f7abbcd25f8416b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void initDeployer(Cloud cloud) {\n\t\tif (this.deployer != null) {\n\t\t\treturn;\n\t\t}\n\t\tlogger.fine(\"Creating jclouds context deployer with user: \" + cloud.getUser().getUser());\n\n\t\tCloudTemplate cloudTemplate = cloud.getTemplates().get(cloudTemplateName);\n\n\t\ttry {\n\t\t\tProperties props = new Properties();\n\t\t\tprops.putAll(cloudTemplate.getOverrides());\n\n\t\t\tthis.deployer = new JCloudsDeployer(cloud.getProvider().getProvider(), cloud.getUser().getUser(), cloud\n\t\t\t\t\t.getUser().getApiKey(), props);\n\n\t\t\tthis.deployer.setImageId(cloudTemplate.getImageId());\n\t\t\tthis.deployer.setMinRamMegabytes(cloudTemplate.getMachineMemoryMB());\n\t\t\tthis.deployer.setHardwareId(cloudTemplate.getHardwareId());\n\t\t\tthis.deployer.setLocationId(cloudTemplate.getLocationId());\n\t\t\tthis.deployer.setExtraOptions(cloudTemplate.getOptions());\n\n\t\t} catch (final IOException e) {\n\t\t\tpublishEvent(\"connection_to_cloud_api_failed\", cloud.getProvider().getProvider());\n\t\t\tthrow new IllegalStateException(\"Failed to create cloud Deployer\", e);\n\t\t}\n\t}","id":97197,"modified_method":"private void initDeployer(final Cloud cloud) {\n\t\tif (this.deployer != null) {\n\t\t\treturn;\n\t\t}\n\t\tlogger.fine(\"Creating jclouds context deployer with user: \" + cloud.getUser().getUser());\n\n\t\tfinal CloudTemplate cloudTemplate = cloud.getTemplates().get(cloudTemplateName);\n\n\t\ttry {\n\t\t\tfinal Properties props = new Properties();\n\t\t\tprops.putAll(cloudTemplate.getOverrides());\n\n\t\t\tthis.deployer = new JCloudsDeployer(cloud.getProvider().getProvider(), cloud.getUser().getUser(), cloud\n\t\t\t\t\t.getUser().getApiKey(), props);\n\n\t\t\tthis.deployer.setImageId(cloudTemplate.getImageId());\n\t\t\tthis.deployer.setMinRamMegabytes(cloudTemplate.getMachineMemoryMB());\n\t\t\tthis.deployer.setHardwareId(cloudTemplate.getHardwareId());\n\t\t\tthis.deployer.setLocationId(cloudTemplate.getLocationId());\n\t\t\tthis.deployer.setExtraOptions(cloudTemplate.getOptions());\n\n\t\t} catch (final IOException e) {\n\t\t\tpublishEvent(\"connection_to_cloud_api_failed\", cloud.getProvider().getProvider());\n\t\t\tthrow new IllegalStateException(\"Failed to create cloud Deployer\", e);\n\t\t}\n\t}","commit_id":"bf7a769d9e0343e995d67eb38f7abbcd25f8416b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void handleProvisioningFailure(int numberOfManagementMachines, int numberOfErrors,\n\t\t\tException firstCreationException, MachineDetails[] createdManagementMachines)\n\t\t\tthrows CloudProvisioningException {\n\t\tlogger.severe(\"Of the required \" + numberOfManagementMachines + \" management machines, \" + numberOfErrors\n\t\t\t\t+ \" failed to start.\");\n\t\tif (numberOfManagementMachines > numberOfErrors) {\n\t\t\tlogger.severe(\"Shutting down the other managememnt machines\");\n\t\t\tfor (MachineDetails machineDetails : createdManagementMachines) {\n\t\t\t\tif (machineDetails != null) {\n\t\t\t\t\tlogger.severe(\"Shutting down machine: \" + machineDetails);\n\t\t\t\t\tthis.deployer.shutdownMachine(machineDetails.getMachineId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new CloudProvisioningException(\n\t\t\t\t\"One or more managememnt machines failed. The first encountered error was: \"\n\t\t\t\t\t\t+ firstCreationException.getMessage(), firstCreationException);\n\t}","id":97198,"modified_method":"private void handleProvisioningFailure(final int numberOfManagementMachines, final int numberOfErrors,\n\t\t\tfinal Exception firstCreationException, final MachineDetails[] createdManagementMachines)\n\t\t\tthrows CloudProvisioningException {\n\t\tlogger.severe(\"Of the required \" + numberOfManagementMachines + \" management machines, \" + numberOfErrors\n\t\t\t\t+ \" failed to start.\");\n\t\tif (numberOfManagementMachines > numberOfErrors) {\n\t\t\tlogger.severe(\"Shutting down the other managememnt machines\");\n\t\t\tfor (final MachineDetails machineDetails : createdManagementMachines) {\n\t\t\t\tif (machineDetails != null) {\n\t\t\t\t\tlogger.severe(\"Shutting down machine: \" + machineDetails);\n\t\t\t\t\tthis.deployer.shutdownMachine(machineDetails.getMachineId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new CloudProvisioningException(\n\t\t\t\t\"One or more managememnt machines failed. The first encountered error was: \"\n\t\t\t\t\t\t+ firstCreationException.getMessage(), firstCreationException);\n\t}","commit_id":"bf7a769d9e0343e995d67eb38f7abbcd25f8416b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"protected void publishEvent(String eventName, Object... args){\n\t\tfor (ProvisioningDriverListener listner : this.eventsListenersList) {\n\t\t\tlistner.onProvisioningEvent(eventName, args);\n\t\t}\n\t}","id":97199,"modified_method":"protected void publishEvent(final String eventName, final Object... args) {\n\t\tfor (final ProvisioningDriverListener listner : this.eventsListenersList) {\n\t\t\tlistner.onProvisioningEvent(eventName, args);\n\t\t}\n\t}","commit_id":"bf7a769d9e0343e995d67eb38f7abbcd25f8416b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n    protected org.neo4j.graphdb.Transaction beginTx( ForceMode forceMode )\n    {\n        // TODO first startup ever we don't have a proper db, so don't even serve read requests\n        // if this is a startup for where we have been a member of this cluster before we\n        // can server (possibly quite outdated) read requests.\n        accessGuard.await( stateSwitchTimeoutMillis );\n        return super.beginTx( forceMode );\n    }","id":97200,"modified_method":"@Override\n    protected org.neo4j.graphdb.Transaction beginTx( ForceMode forceMode )\n    {\n        // TODO first startup ever we don't have a proper db, so don't even serve read requests\n        // if this is a startup for where we have been a member of this cluster before we\n        // can server (possibly quite outdated) read requests.\n        if (!accessGuard.await( stateSwitchTimeoutMillis ))\n        {\n            throw new TransactionFailureException( \"Timeout waiting for cluster to elect master\" );\n        }\n\n        return super.beginTx( forceMode );\n    }","commit_id":"1c3c8502b69a8801daa4126d33be282dfaf1ae66","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n  public void keyPressed(final KeyEvent e) {\n    if(modifier(e)) return;\n\n    // operations that change the focus are put first..\n    if(PREVTAB.is(e)) {\n      transferFocusBackward();\n      return;\n    }\n    if(NEXTTAB.is(e)) {\n      transferFocus();\n      return;\n    }\n    if(FIND.is(e)) {\n      if(find != null) find.requestFocusInWindow();\n      return;\n    }\n\n    // re-animate cursor\n    cursor(true);\n\n    // operations without cursor movement...\n    final int fh = rend.fontH();\n    if(SCROLLDOWN.is(e)) {\n      scroll.pos(scroll.pos() + fh);\n      return;\n    }\n    if(SCROLLUP.is(e)) {\n      scroll.pos(scroll.pos() - fh);\n      return;\n    }\n    if(COPY.is(e)) {\n      copy();\n      return;\n    }\n\n    // set cursor position and reset last column\n    text.pos(text.cursor());\n    if(!PREVLINE.is(e) && !NEXTLINE.is(e)) lastCol = -1;\n\n    if(FINDNEXT.is(e) || FINDPREV.is(e)) {\n      find(rend.find(FINDPREV.is(e), true));\n      return;\n    }\n    if(SELECTALL.is(e)) {\n      selectAll();\n      text.setCaret();\n      return;\n    }\n\n    final boolean marking = e.isShiftDown();\n    final boolean nomark = text.start() == -1;\n    if(marking && nomark) text.startMark();\n    boolean down = true;\n    boolean consumed = true;\n\n    // operations that consider the last text mark..\n    if(NEXTWORD.is(e)) {\n      text.nextToken(marking);\n    } else if(PREVWORD.is(e)) {\n      text.prevToken(marking);\n      down = false;\n    } else if(TEXTSTART.is(e)) {\n      if(!marking) text.noMark();\n      text.pos(0);\n      down = false;\n    } else if(TEXTEND.is(e)) {\n      if(!marking) text.noMark();\n      text.pos(text.size());\n    } else if(LINESTART.is(e)) {\n      text.bol(marking);\n      down = false;\n    } else if(LINEEND.is(e)) {\n      text.forward(Integer.MAX_VALUE, marking);\n    } else if(NEXTPAGE.is(e)) {\n      down(getHeight() / fh, marking);\n    } else if(PREVPAGE.is(e)) {\n      up(getHeight() / fh, marking);\n      down = false;\n    } else if(NEXT.is(e)) {\n      text.next(marking);\n    } else if(PREV.is(e)) {\n      text.prev(marking);\n      down = false;\n    } else if(PREVLINE.is(e)) {\n      up(1, marking);\n      down = false;\n    } else if(NEXTLINE.is(e)) {\n      down(1, marking);\n    } else {\n      consumed = false;\n    }\n\n    final byte[] txt = text.text;\n    if(marking && !DELNEXT.is(e) && !DELPREV.is(e)) {\n      // refresh scroll position\n      text.endMark();\n      text.checkMark();\n    } else if(undo != null) {\n      // edit operations...\n      if(CUT.is(e)) {\n        cut();\n      } else if(PASTE.is(e)) {\n        paste();\n      } else if(UNDO.is(e)) {\n        undo();\n      } else if(REDO.is(e)) {\n        redo();\n      } else if(DELLINEEND.is(e) || DELNEXTWORD.is(e) || DELNEXT.is(e)) {\n        if(nomark) {\n          if(text.pos() == text.size()) return;\n          text.startMark();\n          if(DELNEXTWORD.is(e)) {\n            text.nextToken(true);\n          } else if(DELLINEEND.is(e)) {\n            text.forward(Integer.MAX_VALUE, true);\n          } else {\n            text.next(true);\n          }\n          text.endMark();\n        }\n        if(undo != null) undo.cursor(text.cursor());\n        text.delete();\n      } else if(DELLINESTART.is(e) || DELPREVWORD.is(e) || DELPREV.is(e)) {\n        if(nomark) {\n          if(text.pos() == 0) return;\n          text.startMark();\n          if(DELPREVWORD.is(e)) {\n            text.prevToken(true);\n          } else if(DELLINESTART.is(e)) {\n            text.bol(true);\n          } else {\n            text.prev();\n          }\n          text.endMark();\n        }\n        if(undo != null) undo.cursor(text.cursor());\n        text.delete();\n        down = false;\n      } else {\n        consumed = false;\n      }\n    }\n    if(consumed) e.consume();\n\n    text.setCaret();\n    if(txt != text.text) rend.calc();\n    showCursor(down ? 2 : 0);\n  }","id":97201,"modified_method":"@Override\n  public void keyPressed(final KeyEvent e) {\n    if(modifier(e)) return;\n\n    // operations that change the focus are put first..\n    if(PREVTAB.is(e)) {\n      transferFocusBackward();\n      return;\n    }\n    if(NEXTTAB.is(e)) {\n      transferFocus();\n      return;\n    }\n    if(FIND.is(e)) {\n      if(find != null) find.requestFocusInWindow();\n      return;\n    }\n\n    // re-animate cursor\n    cursor(true);\n\n    // operations without cursor movement...\n    final int fh = rend.fontH();\n    if(SCROLLDOWN.is(e)) {\n      scroll.pos(scroll.pos() + fh);\n      return;\n    }\n    if(SCROLLUP.is(e)) {\n      scroll.pos(scroll.pos() - fh);\n      return;\n    }\n    if(COPY.is(e)) {\n      copy();\n      return;\n    }\n\n    // set cursor position and reset last column\n    text.pos(text.cursor());\n    if(!PREVLINE.is(e) && !NEXTLINE.is(e)) lastCol = -1;\n\n    if(FINDNEXT.is(e) || FINDPREV.is(e) || FINDNEXT2.is(e) || FINDPREV2.is(e)) {\n      find(rend.find(FINDPREV.is(e) || FINDPREV2.is(e), true));\n      return;\n    }\n    if(SELECTALL.is(e)) {\n      selectAll();\n      text.setCaret();\n      return;\n    }\n\n    final boolean marking = e.isShiftDown();\n    final boolean nomark = text.start() == -1;\n    if(marking && nomark) text.startMark();\n    boolean down = true;\n    boolean consumed = true;\n\n    // operations that consider the last text mark..\n    if(NEXTWORD.is(e)) {\n      text.nextToken(marking);\n    } else if(PREVWORD.is(e)) {\n      text.prevToken(marking);\n      down = false;\n    } else if(TEXTSTART.is(e)) {\n      if(!marking) text.noMark();\n      text.pos(0);\n      down = false;\n    } else if(TEXTEND.is(e)) {\n      if(!marking) text.noMark();\n      text.pos(text.size());\n    } else if(LINESTART.is(e)) {\n      text.bol(marking);\n      down = false;\n    } else if(LINEEND.is(e)) {\n      text.forward(Integer.MAX_VALUE, marking);\n    } else if(NEXTPAGE.is(e)) {\n      down(getHeight() / fh, marking);\n    } else if(PREVPAGE.is(e)) {\n      up(getHeight() / fh, marking);\n      down = false;\n    } else if(NEXT.is(e)) {\n      text.next(marking);\n    } else if(PREV.is(e)) {\n      text.prev(marking);\n      down = false;\n    } else if(PREVLINE.is(e)) {\n      up(1, marking);\n      down = false;\n    } else if(NEXTLINE.is(e)) {\n      down(1, marking);\n    } else {\n      consumed = false;\n    }\n\n    final byte[] txt = text.text;\n    if(marking && !DELNEXT.is(e) && !DELPREV.is(e)) {\n      // refresh scroll position\n      text.endMark();\n      text.checkMark();\n    } else if(undo != null) {\n      // edit operations...\n      if(CUT.is(e)) {\n        cut();\n      } else if(PASTE.is(e)) {\n        paste();\n      } else if(UNDO.is(e)) {\n        undo();\n      } else if(REDO.is(e)) {\n        redo();\n      } else if(DELLINEEND.is(e) || DELNEXTWORD.is(e) || DELNEXT.is(e)) {\n        if(nomark) {\n          if(text.pos() == text.size()) return;\n          text.startMark();\n          if(DELNEXTWORD.is(e)) {\n            text.nextToken(true);\n          } else if(DELLINEEND.is(e)) {\n            text.forward(Integer.MAX_VALUE, true);\n          } else {\n            text.next(true);\n          }\n          text.endMark();\n        }\n        if(undo != null) undo.cursor(text.cursor());\n        text.delete();\n      } else if(DELLINESTART.is(e) || DELPREVWORD.is(e) || DELPREV.is(e)) {\n        if(nomark) {\n          if(text.pos() == 0) return;\n          text.startMark();\n          if(DELPREVWORD.is(e)) {\n            text.prevToken(true);\n          } else if(DELLINESTART.is(e)) {\n            text.bol(true);\n          } else {\n            text.prev();\n          }\n          text.endMark();\n        }\n        if(undo != null) undo.cursor(text.cursor());\n        text.delete();\n        down = false;\n      } else {\n        consumed = false;\n      }\n    }\n    if(consumed) e.consume();\n\n    text.setCaret();\n    if(txt != text.text) rend.calc();\n    showCursor(down ? 2 : 0);\n  }","commit_id":"dd745544176088edc9f6cf8f800805b0a60b11ef","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Adds search functionality to the text field.\r\n   * @param area text area to search\r\n   */\r\n  final void addSearch(final BaseXText area) {\r\n    final Font f = getFont();\r\n    setFont(f.deriveFont((float) f.getSize() + 2));\r\n    BaseXLayout.setWidth(this, 80);\r\n\r\n    addKeyListener(new KeyAdapter() {\r\n      @Override\r\n      public void keyPressed(final KeyEvent e) {\r\n        final String text = getText();\r\n        final boolean enter = ENTER.is(e);\r\n        if(ESCAPE.is(e) || enter && text.isEmpty()) {\r\n          area.requestFocusInWindow();\r\n        } else if(enter || FINDNEXT.is(e) || FINDPREV.is(e)) {\r\n          area.find(text, FINDPREV.is(e) || e.isShiftDown());\r\n        }\r\n      }\r\n      @Override\r\n      public void keyReleased(final KeyEvent e) {\r\n        final String text = getText();\r\n        final char ch = e.getKeyChar();\r\n        if(!control(e) && Character.isDefined(ch) && !ENTER.is(e))\r\n          area.find(text, false);\r\n        repaint();\r\n      }\r\n    });\r\n    repaint();\r\n  }","id":97202,"modified_method":"/**\r\n   * Adds search functionality to the text field.\r\n   * @param area text area to search\r\n   */\r\n  final void addSearch(final BaseXText area) {\r\n    final Font f = getFont();\r\n    setFont(f.deriveFont((float) f.getSize() + 2));\r\n    BaseXLayout.setWidth(this, 80);\r\n\r\n    addFocusListener(new FocusAdapter() {\r\n      @Override\r\n      public void focusGained(final FocusEvent e) {\r\n        selectAll();\r\n      }\r\n    }\r\n    );\r\n    \r\n    addKeyListener(new KeyAdapter() {\r\n      @Override\r\n      public void keyPressed(final KeyEvent e) {\r\n        final String text = getText();\r\n        final boolean enter = ENTER.is(e);\r\n        if(ESCAPE.is(e) || enter && text.isEmpty()) {\r\n          area.requestFocusInWindow();\r\n        } else if(enter || FINDNEXT.is(e) || FINDPREV.is(e) ||\r\n            FINDNEXT2.is(e) || FINDPREV2.is(e)) {\r\n          area.find(text, FINDPREV.is(e) || FINDPREV2.is(e) || e.isShiftDown());\r\n        }\r\n      }\r\n      @Override\r\n      public void keyReleased(final KeyEvent e) {\r\n        final String text = getText();\r\n        final char ch = e.getKeyChar();\r\n        if(!control(e) && Character.isDefined(ch) && !ENTER.is(e))\r\n          area.find(text, false);\r\n        repaint();\r\n      }\r\n    });\r\n    repaint();\r\n  }","commit_id":"dd745544176088edc9f6cf8f800805b0a60b11ef","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Default constructor.\n   * @param edit editable flag\n   * @param win parent window\n   * @param txt initial text\n   */\n  public Editor(final boolean edit, final Window win, final byte[] txt) {\n    super(win);\n    setFocusable(true);\n    setFocusTraversalKeysEnabled(!edit);\n    editable = edit;\n\n    addMouseMotionListener(this);\n    addMouseWheelListener(this);\n    addComponentListener(this);\n    addMouseListener(this);\n    addKeyListener(this);\n\n    addFocusListener(new FocusAdapter() {\n      @Override\n      public void focusGained(final FocusEvent e) {\n        if(isEnabled()) cursor(true);\n      }\n      @Override\n      public void focusLost(final FocusEvent e) {\n        cursor(false);\n        rend.cursor(false, false);\n        rend.repaint();\n      }\n    });\n\n    layout(new BorderLayout(4, 0));\n    scroll = new BaseXBar(this);\n    rend = new Renderer(text, scroll);\n    setFont(GUIConstants.dmfont);\n\n    add(rend, BorderLayout.CENTER);\n    add(scroll, BorderLayout.EAST);\n\n    setText(txt);\n    hist = new History(edit ? text.text() : null);\n\n    if(edit) {\n      setBackground(Color.white);\n      setBorder(new MatteBorder(1, 1, 0, 0, GUIConstants.color(6)));\n    } else {\n      mode(Fill.NONE);\n    }\n\n    new BaseXPopup(this, edit ?\n      new GUICommand[] { new UndoCmd(), new RedoCmd(), null, new CutCmd(),\n        new CopyCmd(), new PasteCmd(), new DelCmd(), null, new AllCmd() } :\n      new GUICommand[] { new CopyCmd(), null, new AllCmd() });\n  }","id":97203,"modified_method":"/**\n   * Default constructor.\n   * @param edit editable flag\n   * @param win parent window\n   * @param txt initial text\n   */\n  public Editor(final boolean edit, final Window win, final byte[] txt) {\n    super(win);\n    setFocusable(true);\n    setFocusTraversalKeysEnabled(!edit);\n    editable = edit;\n\n    addMouseMotionListener(this);\n    addMouseWheelListener(this);\n    addComponentListener(this);\n    addMouseListener(this);\n    addKeyListener(this);\n\n    addFocusListener(new FocusAdapter() {\n      @Override\n      public void focusGained(final FocusEvent e) {\n        if(isEnabled()) cursor(true);\n      }\n      @Override\n      public void focusLost(final FocusEvent e) {\n        cursor(false);\n        rend.cursor(false);\n      }\n    });\n\n    layout(new BorderLayout(4, 0));\n    scroll = new BaseXBar(this);\n    rend = new Renderer(text, scroll);\n    setFont(GUIConstants.dmfont);\n\n    add(rend, BorderLayout.CENTER);\n    add(scroll, BorderLayout.EAST);\n\n    setText(txt);\n    hist = new History(edit ? text.text() : null);\n\n    if(edit) {\n      setBackground(Color.white);\n      setBorder(new MatteBorder(1, 1, 0, 0, GUIConstants.color(6)));\n    } else {\n      mode(Fill.NONE);\n    }\n\n    new BaseXPopup(this, edit ?\n      new GUICommand[] { new UndoCmd(), new RedoCmd(), null, new CutCmd(),\n        new CopyCmd(), new PasteCmd(), new DelCmd(), null, new AllCmd() } :\n      new GUICommand[] { new CopyCmd(), null, new AllCmd() });\n  }","commit_id":"a09c03129dcf355200ea7d1111a480c45c60fd82","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void keyPressed(final KeyEvent e) {\n    // handle search operations\n    if(search != null) {\n      if(ESCAPE.is(e)) {\n        search.deactivate(true);\n        return;\n      }\n      if(FIND.is(e)) {\n        search.activate(null);\n        return;\n      }\n      if(FINDNEXT.is(e) || FINDNEXT2.is(e) || FINDPREV.is(e) || FINDPREV2.is(e)) {\n        final boolean vis = search.isVisible();\n        search.activate(text.copy());\n        jump(vis ? FINDNEXT.is(e) || FINDNEXT2.is(e) ?\n          SearchDir.FORWARD : SearchDir.BACKWARD : SearchDir.CURRENT, true);\n        return;\n      }\n    }\n    // ignore modifier keys\n    if(modifier(e)) return;\n\n    // operations that change the focus are put first..\n    if(PREVTAB.is(e)) {\n      transferFocusBackward();\n      return;\n    }\n    if(NEXTTAB.is(e)) {\n      transferFocus();\n      return;\n    }\n\n    // re-animate cursor\n    cursor(true);\n\n    // operations without cursor movement...\n    final int fh = rend.fontH();\n    if(SCROLLDOWN.is(e)) {\n      scroll.pos(scroll.pos() + fh);\n      return;\n    }\n    if(SCROLLUP.is(e)) {\n      scroll.pos(scroll.pos() - fh);\n      return;\n    }\n    if(COPY1.is(e) || COPY2.is(e)) {\n      copy();\n      return;\n    }\n\n    // set cursor position and reset last column\n    final int pc = text.getCaret();\n    text.pos(pc);\n    if(!PREVLINE.is(e) && !NEXTLINE.is(e)) lastCol = -1;\n\n    if(SELECTALL.is(e)) {\n      selectAll();\n      return;\n    }\n\n    // necessary on Macs as the shift button is pressed for REDO\n    final boolean marking = e.isShiftDown() &&\n      !DELNEXT.is(e) && !DELPREV.is(e) && !PASTE2.is(e) && !COMMENT.is(e) &&\n      !DELLINE.is(e) && !REDOSTEP.is(e);\n    final boolean nomark = !text.selecting();\n    if(marking && nomark) text.startSelect();\n    boolean down = true;\n    boolean consumed = true;\n\n    // operations that consider the last text mark..\n    final byte[] txt = text.text();\n    if(NEXTWORD.is(e)) {\n      text.nextToken(marking);\n    } else if(PREVWORD.is(e)) {\n      text.prevToken(marking);\n      down = false;\n    } else if(TEXTSTART.is(e)) {\n      if(!marking) text.noSelect();\n      text.pos(0);\n      down = false;\n    } else if(TEXTEND.is(e)) {\n      if(!marking) text.noSelect();\n      text.pos(text.size());\n    } else if(LINESTART.is(e)) {\n      text.home(marking);\n      down = false;\n    } else if(LINEEND.is(e)) {\n      text.eol(marking);\n    } else if(NEXTPAGE.is(e)) {\n      down(getHeight() / fh, marking);\n    } else if(PREVPAGE.is(e)) {\n      up(getHeight() / fh, marking);\n      down = false;\n    } else if(NEXT.is(e)) {\n      text.next(marking);\n    } else if(PREV.is(e)) {\n      text.prev(marking);\n      down = false;\n    } else if(PREVLINE.is(e)) {\n      up(1, marking);\n      down = false;\n    } else if(NEXTLINE.is(e)) {\n      down(1, marking);\n    } else if(FINDERROR.is(e)) {\n      final int p = text.error();\n      if(p != -1) setCaret(p);\n    } else {\n      consumed = false;\n    }\n\n    if(marking) {\n      // refresh scroll position\n      text.finishSelect();\n    } else if(hist.active()) {\n      // edit operations...\n      if(CUT1.is(e) || CUT2.is(e)) {\n        if(copy()) text.delete();\n      } else if(PASTE1.is(e) || PASTE2.is(e)) {\n        final String clip = clip();\n        if(clip != null) {\n          if(text.selected()) text.delete();\n          text.add(clip);\n        }\n      } else if(UNDOSTEP.is(e)) {\n        final byte[] t = hist.prev();\n        if(t != null) {\n          text.text(t);\n          text.pos(hist.cursor());\n        }\n      } else if(REDOSTEP.is(e)) {\n        final byte[] t = hist.next();\n        if(t != null) {\n          text.text(t);\n          text.pos(hist.cursor());\n        }\n      } else if(COMMENT.is(e)) {\n        text.comment(rend.getSyntax());\n      } else if(DELLINE.is(e)) {\n        text.deleteLine();\n      } else if(DELLINEEND.is(e) || DELNEXTWORD.is(e) || DELNEXT.is(e)) {\n        if(nomark) {\n          if(text.pos() == text.size()) return;\n          text.startSelect();\n          if(DELNEXTWORD.is(e)) {\n            text.nextToken(true);\n          } else if(DELLINEEND.is(e)) {\n            text.eol(true);\n          } else {\n            text.next(true);\n          }\n          text.finishSelect();\n        }\n        text.delete();\n      } else if(DELLINESTART.is(e) || DELPREVWORD.is(e) || DELPREV.is(e)) {\n        if(nomark) {\n          if(text.pos() == 0) return;\n          text.startSelect();\n          if(DELPREVWORD.is(e)) {\n            text.prevToken(true);\n          } else if(DELLINESTART.is(e)) {\n            text.bol(true);\n          } else {\n            text.prev();\n          }\n          text.finishSelect();\n        }\n        text.delete();\n        down = false;\n      } else {\n        consumed = false;\n      }\n    }\n    if(consumed) e.consume();\n\n    text.setCaret();\n    final byte[] tmp = text.text();\n    if(txt != tmp) {\n      hist.store(tmp, pc, text.getCaret());\n      calcCode.invokeLater(down);\n    } else {\n      showCursor(down ? 2 : 0);\n    }\n  }","id":97204,"modified_method":"@Override\n  public void keyPressed(final KeyEvent e) {\n    // handle search operations\n    if(search != null) {\n      if(ESCAPE.is(e)) {\n        search.deactivate(true);\n        return;\n      }\n      if(FIND.is(e)) {\n        search.activate(null);\n        return;\n      }\n      if(FINDNEXT.is(e) || FINDNEXT2.is(e) || FINDPREV.is(e) || FINDPREV2.is(e)) {\n        final boolean vis = search.isVisible();\n        search.activate(text.copy());\n        jump(vis ? FINDNEXT.is(e) || FINDNEXT2.is(e) ?\n          SearchDir.FORWARD : SearchDir.BACKWARD : SearchDir.CURRENT, true);\n        return;\n      }\n    }\n    // ignore modifier keys\n    if(modifier(e)) return;\n\n    // operations that change the focus are put first..\n    if(PREVTAB.is(e)) {\n      transferFocusBackward();\n      return;\n    }\n    if(NEXTTAB.is(e)) {\n      transferFocus();\n      return;\n    }\n\n    // re-animate cursor\n    cursor(true);\n\n    // operations without cursor movement...\n    final int fh = rend.fontH();\n    if(SCROLLDOWN.is(e)) {\n      scroll.pos(scroll.pos() + fh);\n      return;\n    }\n    if(SCROLLUP.is(e)) {\n      scroll.pos(scroll.pos() - fh);\n      return;\n    }\n    if(COPY1.is(e) || COPY2.is(e)) {\n      copy();\n      return;\n    }\n\n    // set cursor position and reset last column\n    final int pc = text.getCaret();\n    text.pos(pc);\n    if(!PREVLINE.is(e) && !NEXTLINE.is(e)) lastCol = -1;\n\n    if(SELECTALL.is(e)) {\n      selectAll();\n      return;\n    }\n\n    // necessary on Macs as the shift button is pressed for REDO\n    final boolean marking = e.isShiftDown() &&\n      !DELNEXT.is(e) && !DELPREV.is(e) && !PASTE2.is(e) && !COMMENT.is(e) &&\n      !DELLINE.is(e) && !REDOSTEP.is(e) && !PREVPAGE_RO.is(e);\n    final boolean nomark = !text.selecting();\n    if(marking && nomark) text.startSelect();\n    boolean down = true;\n    boolean consumed = true;\n\n    // operations that consider the last text mark..\n    final byte[] txt = text.text();\n    if(NEXTWORD.is(e)) {\n      text.nextToken(marking);\n    } else if(PREVWORD.is(e)) {\n      text.prevToken(marking);\n      down = false;\n    } else if(TEXTSTART.is(e)) {\n      if(!marking) text.noSelect();\n      text.pos(0);\n      down = false;\n    } else if(TEXTEND.is(e)) {\n      if(!marking) text.noSelect();\n      text.pos(text.size());\n    } else if(LINESTART.is(e)) {\n      text.home(marking);\n      down = false;\n    } else if(LINEEND.is(e)) {\n      text.eol(marking);\n    } else if(PREVPAGE.is(e) || !hist.active() && PREVPAGE_RO.is(e)) {\n      up(getHeight() / fh, marking);\n      down = false;\n    } else if(NEXTPAGE.is(e) || !hist.active() && NEXTPAGE_RO.is(e)) {\n      down(getHeight() / fh, marking);\n    } else if(NEXT.is(e)) {\n      text.next(marking);\n    } else if(PREV.is(e)) {\n      text.prev(marking);\n      down = false;\n    } else if(PREVLINE.is(e)) {\n      up(1, marking);\n      down = false;\n    } else if(NEXTLINE.is(e)) {\n      down(1, marking);\n    } else if(FINDERROR.is(e)) {\n      final int p = text.error();\n      if(p != -1) setCaret(p);\n    } else {\n      consumed = false;\n    }\n\n    if(marking) {\n      // refresh scroll position\n      text.finishSelect();\n    } else if(hist.active()) {\n      // edit operations...\n      if(CUT1.is(e) || CUT2.is(e)) {\n        if(copy()) text.delete();\n      } else if(PASTE1.is(e) || PASTE2.is(e)) {\n        final String clip = clip();\n        if(clip != null) {\n          if(text.selected()) text.delete();\n          text.add(clip);\n        }\n      } else if(UNDOSTEP.is(e)) {\n        final byte[] t = hist.prev();\n        if(t != null) {\n          text.text(t);\n          text.pos(hist.cursor());\n        }\n      } else if(REDOSTEP.is(e)) {\n        final byte[] t = hist.next();\n        if(t != null) {\n          text.text(t);\n          text.pos(hist.cursor());\n        }\n      } else if(COMMENT.is(e)) {\n        text.comment(rend.getSyntax());\n      } else if(DELLINE.is(e)) {\n        text.deleteLine();\n      } else if(DELLINEEND.is(e) || DELNEXTWORD.is(e) || DELNEXT.is(e)) {\n        if(nomark) {\n          if(text.pos() == text.size()) return;\n          text.startSelect();\n          if(DELNEXTWORD.is(e)) {\n            text.nextToken(true);\n          } else if(DELLINEEND.is(e)) {\n            text.eol(true);\n          } else {\n            text.next(true);\n          }\n          text.finishSelect();\n        }\n        text.delete();\n      } else if(DELLINESTART.is(e) || DELPREVWORD.is(e) || DELPREV.is(e)) {\n        if(nomark) {\n          if(text.pos() == 0) return;\n          text.startSelect();\n          if(DELPREVWORD.is(e)) {\n            text.prevToken(true);\n          } else if(DELLINESTART.is(e)) {\n            text.bol(true);\n          } else {\n            text.prev();\n          }\n          text.finishSelect();\n        }\n        text.delete();\n        down = false;\n      } else {\n        consumed = false;\n      }\n    }\n    if(consumed) e.consume();\n\n    text.setCaret();\n    final byte[] tmp = text.text();\n    if(txt != tmp) {\n      hist.store(tmp, pc, text.getCaret());\n      calcCode.invokeLater(down);\n    } else {\n      showCursor(down ? 2 : 0);\n    }\n  }","commit_id":"a09c03129dcf355200ea7d1111a480c45c60fd82","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Stops an old cursor thread and, if requested, starts a new one.\n   * @param start start/stop flag\n   */\n  final void cursor(final boolean start) {\n    cursor.stop();\n    if(start) cursor.start();\n    rend.cursor(start, true);\n    rend.repaint();\n  }","id":97205,"modified_method":"/**\n   * Stops an old cursor thread and, if requested, starts a new one.\n   * @param start start/stop flag\n   */\n  final void cursor(final boolean start) {\n    cursor.stop();\n    if(start) cursor.start();\n    rend.cursor(start);\n  }","commit_id":"a09c03129dcf355200ea7d1111a480c45c60fd82","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Writes the current string to the graphics reference.\r\n   * @param g graphics reference\r\n   */\r\n  private void write(final Graphics g) {\r\n    if(high) {\r\n      high = false;\r\n    } else {\r\n      color = isEnabled() ? syntax.getColor(text) : Color.gray;\r\n    }\r\n\r\n    final int ch = text.curr();\r\n    final int cp = text.pos();\r\n    final int cc = text.getCaret();\r\n    if(y > 0 && y < h) {\r\n      if(ch == TokenBuilder.MARK) {\r\n        color = GUIConstants.GREEN;\r\n        high = true;\r\n      }\r\n\r\n      // mark selected text\r\n      if(text.selectStart()) {\r\n        int xx = x, cw = 0;\r\n        while(!text.inSelect() && text.more()) xx += charW(g, text.next());\r\n        while(text.inSelect() && text.more()) cw += charW(g, text.next());\r\n        g.setColor(GUIConstants.color(3));\r\n        g.fillRect(xx, y - fontH * 4 / 5, cw, fontH);\r\n        text.pos(cp);\r\n      }\r\n\r\n      // mark found text\r\n      int xx = x;\r\n      while(text.more() && text.searchStart()) {\r\n        int cw = 0;\r\n        while(!text.inSearch() && text.more()) xx += charW(g, text.next());\r\n        while(text.inSearch() && text.more()) cw += charW(g, text.next());\r\n        g.setColor(GUIConstants.color2A);\r\n        g.fillRect(xx, y - fontH * 4 / 5, cw, fontH);\r\n        xx += cw;\r\n      }\r\n      text.pos(cp);\r\n\r\n      if(text.erroneous()) drawError(g);\r\n\r\n      // don't write whitespaces\r\n      if(ch > ' ') {\r\n        g.setColor(color);\r\n        String n = text.nextString();\r\n        int ww = w - x;\r\n        if(x + wordW > ww) {\r\n          // shorten string if it cannot be completely shown (saves memory)\r\n          int c = 0;\r\n          for(final int nl = n.length(); c < nl && ww > 0; c++) {\r\n            ww -= charW(g, n.charAt(c));\r\n          }\r\n          n = n.substring(0, c);\r\n        }\r\n        g.drawString(n, x, y);\r\n      } else if(ch <= TokenBuilder.MARK) {\r\n        g.setFont(font);\r\n      }\r\n\r\n      // show cursor\r\n      if(cursor && text.edited()) {\r\n        xx = x;\r\n        while(text.more()) {\r\n          if(cc == text.pos()) {\r\n            drawCursor(g, xx);\r\n            break;\r\n          }\r\n          xx += charW(g, text.next());\r\n        }\r\n        text.pos(cp);\r\n      }\r\n    }\r\n\r\n    // handle matching parentheses\r\n    if(focused) {\r\n      if(ch == '(' || ch == '[' || ch == '{' || ch == '<') {\r\n        pars.add(x);\r\n        pars.add(y);\r\n        pars.add(cp);\r\n        pars.add(ch);\r\n      }\r\n      if((ch == ')' || ch == ']' || ch == '}' || ch == '>') && !pars.isEmpty()) {\r\n        final int open = ch == ')' ? '(' : ch == ']' ? '[' : ch == '}' ? '{' : '<';\r\n        if(pars.peek() == open) {\r\n          pars.pop();\r\n          final int cr = pars.pop();\r\n          final int yy = pars.pop();\r\n          final int xx = pars.pop();\r\n          if(cc == cp || cc == cr) {\r\n            g.setColor(GUIConstants.color3);\r\n            g.drawRect(xx, yy - fontH * 4 / 5, charW(g, open), fontH);\r\n            g.drawRect(x, y - fontH * 4 / 5, charW(g, ch), fontH);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    next();\r\n  }","id":97206,"modified_method":"/**\r\n   * Writes the current string to the graphics reference.\r\n   * @param g graphics reference\r\n   */\r\n  private void write(final Graphics g) {\r\n    if(high) {\r\n      high = false;\r\n    } else {\r\n      color = isEnabled() ? syntax.getColor(text) : Color.gray;\r\n    }\r\n\r\n    final int ch = text.curr();\r\n    final int cp = text.pos();\r\n    final int cc = text.getCaret();\r\n    if(y > 0 && y < h) {\r\n      if(ch == TokenBuilder.MARK) {\r\n        color = GUIConstants.GREEN;\r\n        high = true;\r\n      }\r\n\r\n      // mark selected text\r\n      if(text.selectStart()) {\r\n        int xx = x, cw = 0;\r\n        while(!text.inSelect() && text.more()) xx += charW(g, text.next());\r\n        while(text.inSelect() && text.more()) cw += charW(g, text.next());\r\n        g.setColor(GUIConstants.color(3));\r\n        g.fillRect(xx, y - fontH * 4 / 5, cw, fontH);\r\n        text.pos(cp);\r\n      }\r\n\r\n      // mark found text\r\n      int xx = x;\r\n      while(text.more() && text.searchStart()) {\r\n        int cw = 0;\r\n        while(!text.inSearch() && text.more()) xx += charW(g, text.next());\r\n        while(text.inSearch() && text.more()) cw += charW(g, text.next());\r\n        g.setColor(GUIConstants.color2A);\r\n        g.fillRect(xx, y - fontH * 4 / 5, cw, fontH);\r\n        xx += cw;\r\n      }\r\n      text.pos(cp);\r\n\r\n      if(text.erroneous()) drawError(g);\r\n\r\n      // don't write whitespaces\r\n      if(ch > ' ') {\r\n        g.setColor(color);\r\n        String n = text.nextString();\r\n        int ww = w - x;\r\n        if(x + wordW > ww) {\r\n          // shorten string if it cannot be completely shown (saves memory)\r\n          int c = 0;\r\n          for(final int nl = n.length(); c < nl && ww > 0; c++) {\r\n            ww -= charW(g, n.charAt(c));\r\n          }\r\n          n = n.substring(0, c);\r\n        }\r\n        g.drawString(n, x, y);\r\n      } else if(ch <= TokenBuilder.MARK) {\r\n        g.setFont(font);\r\n      }\r\n\r\n      // show cursor\r\n      if(cursor && text.edited()) {\r\n        xx = x;\r\n        while(text.more()) {\r\n          if(cc == text.pos()) {\r\n            drawCursor(g, xx);\r\n            break;\r\n          }\r\n          xx += charW(g, text.next());\r\n        }\r\n        text.pos(cp);\r\n      }\r\n    }\r\n\r\n    // handle matching parentheses\r\n    if(ch == '(' || ch == '[' || ch == '{') {\r\n      pars.add(x);\r\n      pars.add(y);\r\n      pars.add(cp);\r\n      pars.add(ch);\r\n    } else if((ch == ')' || ch == ']' || ch == '}') && !pars.isEmpty()) {\r\n      final int open = ch == ')' ? '(' : ch == ']' ? '[' : '{';\r\n      if(pars.peek() == open) {\r\n        pars.pop();\r\n        final int cr = pars.pop();\r\n        final int yy = pars.pop();\r\n        final int xx = pars.pop();\r\n        if(cc == cp || cc == cr) {\r\n          g.setColor(GUIConstants.color3);\r\n          g.drawRect(xx, yy - fontH * 4 / 5, charW(g, open), fontH);\r\n          g.drawRect(x, y - fontH * 4 / 5, charW(g, ch), fontH);\r\n        }\r\n      }\r\n    }\r\n    next();\r\n  }","commit_id":"a09c03129dcf355200ea7d1111a480c45c60fd82","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Sets the cursor flag.\r\n   * @param c cursor flag\r\n   * @param f focused flag\r\n   */\r\n  void cursor(final boolean c, final boolean f) {\r\n    cursor = c;\r\n    focused = f;\r\n  }","id":97207,"modified_method":"/**\r\n   * Sets the cursor flag and repaints the panel.\r\n   * @param c cursor flag\r\n   */\r\n  void cursor(final boolean c) {\r\n    cursor = c;\r\n    repaint();\r\n  }","commit_id":"a09c03129dcf355200ea7d1111a480c45c60fd82","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param args command-line arguments\n   */\n  public BaseXServer(final String... args) {\n    super(args);\n    if(!success) return;\n\n    final int port = context.prop.num(Prop.SERVERPORT);\n    if(service) {\n      Util.outln(start(port));\n      return;\n    }\n\n    log = new Log(context, quiet);\n    stop = stopFile(port);\n\n    // guarantee correct shutdown...\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      public void run() {\n        log.write(SERVERSTOPPED);\n        log.close();\n        Util.outln(SERVERSTOPPED);\n      }\n    });\n\n    try {\n      server = new ServerSocket(port);\n      new Thread(this).start();\n      do Performance.sleep(100); while(!running);\n\n      Util.outln(CONSOLE, SERVERMODE, console ? CONSOLE2 : SERVERSTART);\n\n      // execute command-line arguments\n      if(commands != null) execute(commands);\n\n      if(console) quit(console());\n    } catch(final Exception ex) {\n      log.write(ex.getMessage());\n      Util.errln(Util.server(ex));\n    }\n  }","id":97208,"modified_method":"/**\n   * Constructor.\n   * @param args command-line arguments\n   */\n  public BaseXServer(final String... args) {\n    super(args);\n    if(!success) return;\n\n    final int port = context.prop.num(Prop.SERVERPORT);\n    if(service) {\n      Util.outln(start(port));\n      return;\n    }\n\n    log = new Log(context, quiet);\n    stop = stopFile(port);\n\n    try {\n      server = new ServerSocket(port);\n\n      // guarantee correct shutdown...\n      Runtime.getRuntime().addShutdownHook(new Thread() {\n        @Override\n        public void run() {\n          log.write(SERVERSTOPPED);\n          log.close();\n          Util.outln(SERVERSTOPPED);\n        }\n      });\n\n      new Thread(this).start();\n      do Performance.sleep(100); while(!running);\n\n      Util.outln(CONSOLE, SERVERMODE, console ? CONSOLE2 : SERVERSTART);\n\n      // execute command-line arguments\n      if(commands != null) execute(commands);\n\n      if(console) quit(console());\n    } catch(final Exception ex) {\n      log.write(ex.getMessage());\n      Util.errln(Util.server(ex));\n    }\n  }","commit_id":"030e40943c14df3ea2d3e4024e2adf8ae02ac7a0","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void keyPressed(final KeyEvent e) {\n    if(modifier(e)) return;\n\n    // operations that change the focus are put first..\n    if(PREVTAB.is(e)) {\n      transferFocusBackward();\n      return;\n    }\n    if(NEXTTAB.is(e)) {\n      transferFocus();\n      return;\n    }\n    if(FIND.is(e)) {\n      if(find != null) find.requestFocusInWindow();\n      return;\n    }\n\n    // re-animate cursor\n    cursor(true);\n\n    // operations without cursor movement...\n    final int fh = rend.fontH();\n    if(SCROLLDOWN.is(e)) {\n      scroll.pos(scroll.pos() + fh);\n      return;\n    }\n    if(SCROLLUP.is(e)) {\n      scroll.pos(scroll.pos() - fh);\n      return;\n    }\n    if(COPY.is(e)) {\n      copy();\n      return;\n    }\n\n    // set cursor position and reset last column\n    text.pos(text.cursor());\n    if(!PREVLINE.is(e) && !NEXTLINE.is(e)) lastCol = -1;\n\n    if(FINDNEXT.is(e) || FINDPREV.is(e) || FINDNEXT2.is(e) || FINDPREV2.is(e)) {\n      find(rend.find(FINDPREV.is(e) || FINDPREV2.is(e), true));\n      return;\n    }\n    if(SELECTALL.is(e)) {\n      selectAll();\n      text.setCaret();\n      return;\n    }\n\n    final boolean marking = e.isShiftDown();\n    final boolean nomark = text.start() == -1;\n    if(marking && nomark) text.startMark();\n    boolean down = true;\n    boolean consumed = true;\n\n    // operations that consider the last text mark..\n    if(NEXTWORD.is(e)) {\n      text.nextToken(marking);\n    } else if(PREVWORD.is(e)) {\n      text.prevToken(marking);\n      down = false;\n    } else if(TEXTSTART.is(e)) {\n      if(!marking) text.noMark();\n      text.pos(0);\n      down = false;\n    } else if(TEXTEND.is(e)) {\n      if(!marking) text.noMark();\n      text.pos(text.size());\n    } else if(LINESTART.is(e)) {\n      text.bol(marking);\n      down = false;\n    } else if(LINEEND.is(e)) {\n      text.forward(Integer.MAX_VALUE, marking);\n    } else if(NEXTPAGE.is(e)) {\n      down(getHeight() / fh, marking);\n    } else if(PREVPAGE.is(e)) {\n      up(getHeight() / fh, marking);\n      down = false;\n    } else if(NEXT.is(e)) {\n      text.next(marking);\n    } else if(PREV.is(e)) {\n      text.prev(marking);\n      down = false;\n    } else if(PREVLINE.is(e)) {\n      up(1, marking);\n      down = false;\n    } else if(NEXTLINE.is(e)) {\n      down(1, marking);\n    } else {\n      consumed = false;\n    }\n\n    final byte[] txt = text.text;\n    if(marking && !DELNEXT.is(e) && !DELPREV.is(e)) {\n      // refresh scroll position\n      text.endMark();\n      text.checkMark();\n    } else if(undo != null) {\n      // edit operations...\n      if(CUT.is(e)) {\n        cut();\n      } else if(PASTE.is(e)) {\n        paste();\n      } else if(UNDO.is(e)) {\n        undo();\n      } else if(REDO.is(e)) {\n        redo();\n      } else if(DELLINEEND.is(e) || DELNEXTWORD.is(e) || DELNEXT.is(e)) {\n        if(nomark) {\n          if(text.pos() == text.size()) return;\n          text.startMark();\n          if(DELNEXTWORD.is(e)) {\n            text.nextToken(true);\n          } else if(DELLINEEND.is(e)) {\n            text.forward(Integer.MAX_VALUE, true);\n          } else {\n            text.next(true);\n          }\n          text.endMark();\n        }\n        if(undo != null) undo.cursor(text.cursor());\n        text.delete();\n      } else if(DELLINESTART.is(e) || DELPREVWORD.is(e) || DELPREV.is(e)) {\n        if(nomark) {\n          if(text.pos() == 0) return;\n          text.startMark();\n          if(DELPREVWORD.is(e)) {\n            text.prevToken(true);\n          } else if(DELLINESTART.is(e)) {\n            text.bol(true);\n          } else {\n            text.prev();\n          }\n          text.endMark();\n        }\n        if(undo != null) undo.cursor(text.cursor());\n        text.delete();\n        down = false;\n      } else {\n        consumed = false;\n      }\n    }\n    if(consumed) e.consume();\n\n    text.setCaret();\n    if(txt != text.text) rend.calc();\n    showCursor(down ? 2 : 0);\n  }","id":97209,"modified_method":"@Override\n  public void keyPressed(final KeyEvent e) {\n    if(modifier(e)) return;\n\n    // operations that change the focus are put first..\n    if(PREVTAB.is(e)) {\n      transferFocusBackward();\n      return;\n    }\n    if(NEXTTAB.is(e)) {\n      transferFocus();\n      return;\n    }\n    if(FIND.is(e)) {\n      if(find != null) find.requestFocusInWindow();\n      return;\n    }\n\n    // re-animate cursor\n    cursor(true);\n\n    // operations without cursor movement...\n    final int fh = rend.fontH();\n    if(SCROLLDOWN.is(e)) {\n      scroll.pos(scroll.pos() + fh);\n      return;\n    }\n    if(SCROLLUP.is(e)) {\n      scroll.pos(scroll.pos() - fh);\n      return;\n    }\n    if(COPY1.is(e) || COPY2.is(e)) {\n      copy();\n      return;\n    }\n\n    // set cursor position and reset last column\n    text.pos(text.cursor());\n    if(!PREVLINE.is(e) && !NEXTLINE.is(e)) lastCol = -1;\n\n    if(FINDNEXT.is(e) || FINDPREV.is(e) || FINDNEXT2.is(e) || FINDPREV2.is(e)) {\n      find(rend.find(FINDPREV.is(e) || FINDPREV2.is(e), true));\n      return;\n    }\n    if(SELECTALL.is(e)) {\n      selectAll();\n      text.setCaret();\n      return;\n    }\n\n    final boolean marking = e.isShiftDown() &&\n      !DELNEXT.is(e) && !DELPREV.is(e) &&  !PASTE2.is(e);\n    final boolean nomark = text.start() == -1;\n    if(!PASTE2.is(e) && marking && nomark) text.startMark();\n    boolean down = true;\n    boolean consumed = true;\n\n    // operations that consider the last text mark..\n    if(NEXTWORD.is(e)) {\n      text.nextToken(marking);\n    } else if(PREVWORD.is(e)) {\n      text.prevToken(marking);\n      down = false;\n    } else if(TEXTSTART.is(e)) {\n      if(!marking) text.noMark();\n      text.pos(0);\n      down = false;\n    } else if(TEXTEND.is(e)) {\n      if(!marking) text.noMark();\n      text.pos(text.size());\n    } else if(LINESTART.is(e)) {\n      text.bol(marking);\n      down = false;\n    } else if(LINEEND.is(e)) {\n      text.forward(Integer.MAX_VALUE, marking);\n    } else if(NEXTPAGE.is(e)) {\n      down(getHeight() / fh, marking);\n    } else if(PREVPAGE.is(e)) {\n      up(getHeight() / fh, marking);\n      down = false;\n    } else if(NEXT.is(e)) {\n      text.next(marking);\n    } else if(PREV.is(e)) {\n      text.prev(marking);\n      down = false;\n    } else if(PREVLINE.is(e)) {\n      up(1, marking);\n      down = false;\n    } else if(NEXTLINE.is(e)) {\n      down(1, marking);\n    } else {\n      consumed = false;\n    }\n\n    final byte[] txt = text.text;\n    if(marking) {\n      // refresh scroll position\n      text.endMark();\n      text.checkMark();\n    } else if(undo != null) {\n      // edit operations...\n      if(CUT1.is(e) || CUT2.is(e)) {\n        cut();\n      } else if(PASTE1.is(e) || PASTE2.is(e)) {\n        paste();\n      } else if(UNDO.is(e)) {\n        undo();\n      } else if(REDO.is(e)) {\n        redo();\n      } else if(DELLINEEND.is(e) || DELNEXTWORD.is(e) || DELNEXT.is(e)) {\n        if(nomark) {\n          if(text.pos() == text.size()) return;\n          text.startMark();\n          if(DELNEXTWORD.is(e)) {\n            text.nextToken(true);\n          } else if(DELLINEEND.is(e)) {\n            text.forward(Integer.MAX_VALUE, true);\n          } else {\n            text.next(true);\n          }\n          text.endMark();\n        }\n        if(undo != null) undo.cursor(text.cursor());\n        text.delete();\n      } else if(DELLINESTART.is(e) || DELPREVWORD.is(e) || DELPREV.is(e)) {\n        if(nomark) {\n          if(text.pos() == 0) return;\n          text.startMark();\n          if(DELPREVWORD.is(e)) {\n            text.prevToken(true);\n          } else if(DELLINESTART.is(e)) {\n            text.bol(true);\n          } else {\n            text.prev();\n          }\n          text.endMark();\n        }\n        if(undo != null) undo.cursor(text.cursor());\n        text.delete();\n        down = false;\n      } else {\n        consumed = false;\n      }\n    }\n    if(consumed) e.consume();\n\n    text.setCaret();\n    if(txt != text.text) rend.calc();\n    showCursor(down ? 2 : 0);\n  }","commit_id":"030e40943c14df3ea2d3e4024e2adf8ae02ac7a0","url":"https://github.com/BaseXdb/basex"},{"original_method":"protected void showEditor() {\n    if (myReplace != null) {\n      myEditorPanel.remove(myReplace);\n      myReplace = null;\n    }\n    myEditorComponent = new NodeEditorComponent(myContext.getProject().getRepository());\n    myEditorPanel.add(myEditorComponent.getExternalComponent(), BorderLayout.CENTER);\n    myComponent.validate();\n  }","id":97210,"modified_method":"protected void showEditor() {\n    if (myReplace != null) {\n      myEditorPanel.remove(myReplace);\n      myReplace = null;\n    }\n    myEditorComponent = new NodeEditorComponent(myContext.getProject().getRepository());\n    JComponent externalComponent = myEditorComponent.getExternalComponent();\n    //HACK to avoid strange gray border in ScrollPane after empty aspect tab\n    if(externalComponent.getComponent(0) instanceof JBScrollPane) {\n      ((JBScrollPane) externalComponent.getComponent(0)).setBorder(new EmptyBorder(JBInsets.NONE));\n      ((JBScrollPane) externalComponent.getComponent(0)).getInsets().set(0, 0, 0, 0);\n    }\n    myEditorPanel.add(externalComponent, BorderLayout.CENTER);\n    myComponent.validate();\n  }","commit_id":"2353a840e98aab6ca975300650a5903142b9af69","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected synchronized void updateTabs() {\n    if (myDisposed) return;\n\n    SNodeReference selNode = null;\n    RelationDescriptor selRel = null;\n\n    int selected = myJbTabs.getTabCount() > 0 ? myJbTabs.getSelectedIndex() : -1;\n    if (selected != -1) {\n      selNode = myRealTabs.get(selected).getNode();\n      if (selNode == null) {\n        selRel = myRealTabs.get(selected).getTab();\n      }\n    }\n\n    boolean oldRebuilding = myRebuilding;\n    myRebuilding = true;\n    try {\n      myJbTabs.removeAll();\n      myRealTabs.clear();\n\n      ArrayList<RelationDescriptor> tabs = new ArrayList<RelationDescriptor>(myPossibleTabs);\n      Collections.sort(tabs, new RelationComparator());\n\n      TabEditorLayout newContent = updateDocumentsAndNodes();\n\n      //todo sort nodes inside aspect\n      for (RelationDescriptor tab : tabs) {\n        if (newContent.covers(tab)) {\n          for (Entry tabDescriptor : newContent.get(tab)) {\n            final PlainEditorTab pet = new PlainEditorTab(tabDescriptor);\n            myRealTabs.add(pet);\n            SNode node = pet.getNode().resolve(MPSModuleRepository.getInstance());\n            myJbTabs.addTab(node.getPresentation(), IconManager.getIconFor(node), new JLabel(\"\"), \"\");\n            myJbTabs.getTabs().getTabAt(myJbTabs.getTabs().getTabCount() - 1).setPreferredFocusableComponent(myEditor);\n          }\n        } else if (myShowGrayed) {\n          myRealTabs.add(new PlainEditorTab(tab));\n          myJbTabs.addTab(tab.getTitle(), new JLabel(\"\"));\n          myJbTabs.getTabs().getTabAt(myJbTabs.getTabs().getTabCount() - 1).setPreferredFocusableComponent(myEditor);\n          myJbTabs.setForegroundAt(myJbTabs.getTabCount() - 1, Color.GRAY);\n        }\n      }\n      updateTabColors();\n    } finally {\n      myRebuilding = oldRebuilding;\n    }\n\n    if (selNode != null && selNode.resolve(MPSModuleRepository.getInstance()) != null) {\n      for (PlainEditorTab tab : myRealTabs) {\n        if (EqualUtil.equals(tab.getNode(), selNode)) {\n          myJbTabs.setSelectedIndex(myRealTabs.indexOf(tab));\n          break;\n        }\n      }\n    } else if (selRel != null) {\n      for (PlainEditorTab tab : myRealTabs) {\n        if (tab.getTab() == selRel) {\n          myJbTabs.setSelectedIndex(myRealTabs.indexOf(tab));\n          break;\n        }\n      }\n    } else {\n      if (myJbTabs.getTabCount() > 0) {\n        myJbTabs.setSelectedIndex(0);\n\n        if (selNode != null) {\n          //this is needed as Idea component sends no events if we've just removed all tabs and added one new and then are trying to select it\n          //see http://youtrack.jetbrains.com/issue/MPS-17943\n          onTabIndexChange();\n        }\n      }\n    }\n  }","id":97211,"modified_method":"@Override\n  protected synchronized void updateTabs() {\n    if (myDisposed) return;\n\n    SNodeReference selNode = null;\n    RelationDescriptor selRel = null;\n\n    int selected = myTabs.getTabCount() > 0 ? myTabs.getIndexOf(myTabs.getSelectedInfo()) : -1;\n    if (selected != -1) {\n      selNode = myRealTabs.get(selected).getNode();\n      if (selNode == null) {\n        selRel = myRealTabs.get(selected).getTab();\n      }\n    }\n\n    boolean oldRebuilding = myRebuilding;\n    myRebuilding = true;\n    try {\n      myTabs.removeAllTabs();\n      myRealTabs.clear();\n\n      ArrayList<RelationDescriptor> tabs = new ArrayList<RelationDescriptor>(myPossibleTabs);\n      Collections.sort(tabs, new RelationComparator());\n\n      TabEditorLayout newContent = updateDocumentsAndNodes();\n\n      //todo sort nodes inside aspect\n      for (RelationDescriptor tab : tabs) {\n        if (newContent.covers(tab)) {\n          for (Entry tabDescriptor : newContent.get(tab)) {\n            final PlainEditorTab pet = new PlainEditorTab(tabDescriptor);\n            myRealTabs.add(pet);\n            SNode node = pet.getNode().resolve(MPSModuleRepository.getInstance());\n\n            TabInfo info = new TabInfo(new JLabel(\"\"))\n                .setIcon(IconManager.getIconFor(node))\n                .setText(node.getPresentation())\n                .setPreferredFocusableComponent(myEditor);\n            myTabs.addTab(info);\n          }\n        } else if (myShowGrayed) {\n          myRealTabs.add(new PlainEditorTab(tab));\n\n          TabInfo info = new TabInfo(new JLabel(\"\"))\n              .setText(tab.getTitle()).setDefaultForeground(Color.GRAY)\n              .setPreferredFocusableComponent(myEditor);\n          myTabs.addTab(info);\n        }\n      }\n      updateTabColors();\n    } finally {\n      myRebuilding = oldRebuilding;\n    }\n\n    if (selNode != null && selNode.resolve(MPSModuleRepository.getInstance()) != null) {\n      for (PlainEditorTab tab : myRealTabs) {\n        if (EqualUtil.equals(tab.getNode(), selNode)) {\n          myTabs.select(myTabs.getTabAt(myRealTabs.indexOf(tab)), true);\n          break;\n        }\n      }\n    } else if (selRel != null) {\n      for (PlainEditorTab tab : myRealTabs) {\n        if (tab.getTab() == selRel) {\n          myTabs.select(myTabs.getTabAt(myRealTabs.indexOf(tab)), true);\n          break;\n        }\n      }\n    } else {\n      if (myTabs.getTabCount() > 0) {\n        myTabs.select(myTabs.getTabAt(0), true);\n\n        if (selNode != null) {\n          //this is needed as Idea component sends no events if we've just removed all tabs and added one new and then are trying to select it\n          //see http://youtrack.jetbrains.com/issue/MPS-17943\n          onTabIndexChange();\n        }\n      }\n    }\n  }","commit_id":"2353a840e98aab6ca975300650a5903142b9af69","url":"https://github.com/JetBrains/MPS"},{"original_method":"private synchronized void selectNodeTab() {\n    if (myDisposed) return;\n\n    for (PlainEditorTab t : myRealTabs) {\n      if (t.getNode() != null && t.getNode().equals(getLastNode())) {\n        myJbTabs.setSelectedIndex(myRealTabs.indexOf(t));\n        return;\n      }\n    }\n    for (PlainEditorTab t : myRealTabs) {\n      if (t.getNode() == null && t.getTab().equals(myLastEmptyTab)) {\n        myJbTabs.setSelectedIndex(myRealTabs.indexOf(t));\n        return;\n      }\n    }\n  }","id":97212,"modified_method":"private synchronized void selectNodeTab() {\n    if (myDisposed) return;\n\n    for (PlainEditorTab t : myRealTabs) {\n      if (t.getNode() != null && t.getNode().equals(getLastNode())) {\n        myTabs.select(myTabs.getTabAt(myRealTabs.indexOf(t)), true);\n        return;\n      }\n    }\n    for (PlainEditorTab t : myRealTabs) {\n      if (t.getNode() == null && t.getTab().equals(myLastEmptyTab)) {\n        myTabs.select(myTabs.getTabAt(myRealTabs.indexOf(t)), true);\n        return;\n      }\n    }\n  }","commit_id":"2353a840e98aab6ca975300650a5903142b9af69","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected synchronized void updateTabColors() {\n    if (myDisposed) return;\n\n    for (int i = 0; i < myRealTabs.size(); i++) {\n      SNodeReference nodePtr = myRealTabs.get(i).getNode();\n      TabColorProvider colorProvider = getColorProvider();\n      SNode node = nodePtr != null ? nodePtr.resolve(MPSModuleRepository.getInstance()) : null;\n      if (node != null && colorProvider != null) {\n        Color color = colorProvider.getNodeColor(node);\n        if (color != null) {\n          myJbTabs.setForegroundAt(i, color);\n          continue;\n        }\n      }\n      myJbTabs.setForegroundAt(i, null);\n    }\n  }","id":97213,"modified_method":"@Override\n  protected synchronized void updateTabColors() {\n    if (myDisposed) return;\n\n    for (int i = 0; i < myRealTabs.size(); i++) {\n      SNodeReference nodePtr = myRealTabs.get(i).getNode();\n      TabColorProvider colorProvider = getColorProvider();\n      SNode node = nodePtr != null ? nodePtr.resolve(MPSModuleRepository.getInstance()) : null;\n      if (node != null && colorProvider != null) {\n        Color color = colorProvider.getNodeColor(node);\n        if (color != null) {\n          myTabs.getTabAt(i).setDefaultForeground(color);\n          continue;\n        }\n      }\n      myTabs.getTabAt(i).setDefaultForeground(null);\n    }\n  }","commit_id":"2353a840e98aab6ca975300650a5903142b9af69","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public synchronized void nextTab() {\n    if (myDisposed) return;\n\n    int i = myJbTabs.getSelectedIndex();\n    if (i < myJbTabs.getTabCount() - 1) {\n      myJbTabs.setSelectedIndex(i + 1);\n    }\n  }","id":97214,"modified_method":"@Override\n  public synchronized void nextTab() {\n    if (myDisposed) return;\n\n    int i = myTabs.getIndexOf(myTabs.getSelectedInfo());\n    if (i < myTabs.getTabCount() - 1) {\n      myTabs.select(myTabs.getTabAt(i + 1), true);\n    }\n  }","commit_id":"2353a840e98aab6ca975300650a5903142b9af69","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PlainTabsComponent(SNodeReference baseNode, Set<RelationDescriptor> possibleTabs, JComponent editor, NodeChangeCallback callback, boolean showGrayed,\n      CreateModeCallback createModeCallback, Project project) {\n    super(baseNode, possibleTabs, editor, callback, showGrayed, createModeCallback, project);\n\n    PrevNextActionsDescriptor navigation = new PrevNextActionsDescriptor(IdeActions.ACTION_NEXT_EDITOR_TAB, IdeActions.ACTION_PREVIOUS_EDITOR_TAB);\n    myJbTabs = new TabbedPaneWrapper.AsJBTabs(project, SwingConstants.BOTTOM, navigation, myJbTabsDisposable);\n    myJbTabs.getTabs().getPresentation().setPaintBorder(0, 0, 0, 0).setTabSidePaintBorder(1).setGhostsAlwaysVisible(true).setUiDecorator(new UiDecorator() {\n      @Override\n      @NotNull\n      public UiDecoration getDecoration() {\n        return new UiDecoration(null, new Insets(0, 8, 0, 8));\n      }\n    });\n    myJbTabs.getTabs().getComponent().setBorder(new EmptyBorder(0, 0, 1, 0));\n\n    getComponent().add(myJbTabs.getTabs().getComponent(), BorderLayout.CENTER);\n\n    updateTabs();\n\n    myJbTabs.addChangeListener(new ChangeListener() {\n      @Override\n      public void stateChanged(ChangeEvent e) {\n        if (myDisposed) return;\n        if (myRebuilding) return;\n\n        ModelAccess.instance().runReadAction(new Runnable() {\n          @Override\n          public void run() {\n            onTabIndexChange();\n          }\n        });\n      }\n    });\n\n    addListeners();\n  }","id":97215,"modified_method":"public PlainTabsComponent(SNodeReference baseNode, Set<RelationDescriptor> possibleTabs, JComponent editor, NodeChangeCallback callback, boolean showGrayed,\n      CreateModeCallback createModeCallback, Project project) {\n    super(baseNode, possibleTabs, editor, callback, showGrayed, createModeCallback, project);\n\n    myTabs = new JBTabsImpl(project, null, myJbTabsDisposable);\n    myTabs.setTabsPosition(JBTabsPosition.bottom)\n        .setPaintBorder(0,0,0,0)\n        .setTabSidePaintBorder(1)\n        .setGhostsAlwaysVisible(false)\n        .setUiDecorator(new UiDecorator() {\n          @NotNull\n          @Override\n          public UiDecoration getDecoration() {\n            return new UiDecoration(null, new Insets(0, 8, 0, 8));\n          }\n        });\n    myTabs.setBorder(new EmptyBorder(0, 0, 1, 0));\n\n    getComponent().add(myTabs, BorderLayout.CENTER);\n\n    updateTabs();\n\n    myTabs.addListener(new TabsListener() {\n      @Override\n      public void selectionChanged(TabInfo oldSelection, TabInfo newSelection) {\n        if (myDisposed) return;\n        if (myRebuilding) return;\n\n        ModelAccess.instance().runReadAction(new Runnable() {\n          @Override\n          public void run() {\n            onTabIndexChange();\n          }\n        });\n      }\n\n      @Override\n      public void beforeSelectionChanged(TabInfo oldSelection, TabInfo newSelection) {}\n      @Override\n      public void tabRemoved(TabInfo tabToRemove) {}\n      @Override\n      public void tabsMoved() {}\n    });\n\n    addListeners();\n  }","commit_id":"2353a840e98aab6ca975300650a5903142b9af69","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public synchronized void prevTab() {\n    if (myDisposed) return;\n\n    int i = myJbTabs.getSelectedIndex();\n    if (i > 0) {\n      myJbTabs.setSelectedIndex(i - 1);\n    }\n  }","id":97216,"modified_method":"@Override\n  public synchronized void prevTab() {\n    if (myDisposed) return;\n\n    int i = myTabs.getIndexOf(myTabs.getSelectedInfo());\n    if (i > 0) {\n      myTabs.select(myTabs.getTabAt(i - 1), true);\n    }\n  }","commit_id":"2353a840e98aab6ca975300650a5903142b9af69","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public synchronized RelationDescriptor getCurrentTabAspect() {\n    if (myDisposed) return null;\n\n    if (myLastEmptyTab != null) return myLastEmptyTab;\n    return myRealTabs.get(myJbTabs.getSelectedIndex()).getTab();\n  }","id":97217,"modified_method":"@Override\n  public synchronized RelationDescriptor getCurrentTabAspect() {\n    if (myDisposed) return null;\n\n    if (myLastEmptyTab != null) return myLastEmptyTab;\n    return myRealTabs.get(myTabs.getIndexOf(myTabs.getSelectedInfo())).getTab();\n  }","commit_id":"2353a840e98aab6ca975300650a5903142b9af69","url":"https://github.com/JetBrains/MPS"},{"original_method":"private synchronized void onTabIndexChange() {\n    if (myDisposed) return;\n\n    if (myJbTabs.getTabCount() == 0) return;\n\n    int index = myJbTabs.getSelectedIndex();\n    PlainEditorTab tab = myRealTabs.get(index);\n    SNodeReference np = tab.getNode();\n    if (np != null && EqualUtil.equals(np, getLastNode())) return;\n\n    SNode node = np == null ? null : np.resolve(MPSModuleRepository.getInstance());\n\n    if (node != null) {\n      myLastEmptyTab = null;\n      onNodeChange(node);\n    } else {\n      myLastEmptyTab = tab.getTab();\n      enterCreateMode(myLastEmptyTab);\n    }\n  }","id":97218,"modified_method":"private synchronized void onTabIndexChange() {\n    if (myDisposed) return;\n\n    if (myTabs.getTabCount() == 0) return;\n\n    int index = myTabs.getIndexOf(myTabs.getSelectedInfo());\n    PlainEditorTab tab = myRealTabs.get(index);\n    SNodeReference np = tab.getNode();\n    if (np != null && EqualUtil.equals(np, getLastNode())) return;\n\n    SNode node = np == null ? null : np.resolve(MPSModuleRepository.getInstance());\n\n    if (node != null) {\n      myLastEmptyTab = null;\n      onNodeChange(node);\n    } else {\n      myLastEmptyTab = tab.getTab();\n      enterCreateMode(myLastEmptyTab);\n    }\n  }","commit_id":"2353a840e98aab6ca975300650a5903142b9af69","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Extracts the body for logging purpose.\n     * <p/>\n     * Will clip the body if its too big for logging.\n     *\n     * @see org.apache.camel.Exchange#LOG_DEBUG_BODY_STREAMS\n     * @see org.apache.camel.Exchange#LOG_DEBUG_BODY_MAX_CHARS\n     * @param message the message\n     * @param prepend a message to prepend\n     * @return the logging message\n     */\n    public static String extractBodyForLogging(Message message, String prepend) {\n        boolean streams = false;\n        if (message.getExchange() != null) {\n            String property = message.getExchange().getContext().getProperty(Exchange.LOG_DEBUG_BODY_STREAMS);\n            if (property != null) {\n                streams = message.getExchange().getContext().getTypeConverter().convertTo(Boolean.class, message.getExchange(), property);\n            }\n        }\n\n        // default to 1000 chars\n        int maxChars = 1000;\n\n        if (message.getExchange() != null) {\n            String property = message.getExchange().getContext().getProperty(Exchange.LOG_DEBUG_BODY_MAX_CHARS);\n            if (property != null) {\n                maxChars = message.getExchange().getContext().getTypeConverter().convertTo(Integer.class, property);\n            }\n        }\n\n        return extractBodyForLogging(message, prepend, streams, false, maxChars);\n    }","id":97219,"modified_method":"/**\n     * Extracts the body for logging purpose.\n     * <p/>\n     * Will clip the body if its too big for logging.\n     *\n     * @see org.apache.camel.Exchange#LOG_DEBUG_BODY_STREAMS\n     * @see org.apache.camel.Exchange#LOG_DEBUG_BODY_MAX_CHARS\n     * @param message the message\n     * @param prepend a message to prepend\n     * @return the logging message\n     */\n    public static String extractBodyForLogging(Message message, String prepend) {\n        boolean streams = false;\n        if (message.getExchange() != null) {\n            String property = message.getExchange().getContext().getProperty(Exchange.LOG_DEBUG_BODY_STREAMS);\n            if (property != null) {\n                streams = message.getExchange().getContext().getTypeConverter().convertTo(Boolean.class, message.getExchange(), property);\n            }\n        }\n        return extractBodyForLogging(message, prepend, streams, false);\n    }","commit_id":"75b424d0d8c49fd6d7daccd6c67e66e4eff129d4","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Collection<KeyValueAnnotation> requestAnnotations() {\n        KeyValueAnnotation key1 = KeyValueAnnotation.create(\"camel.client.endpoint.url\", url);\n        KeyValueAnnotation key2 = KeyValueAnnotation.create(\"camel.client.exchange.id\", exchange.getExchangeId());\n        KeyValueAnnotation key3 = KeyValueAnnotation.create(\"camel.client.exchange.pattern\", exchange.getPattern().name());\n\n        KeyValueAnnotation key4 = null;\n        if (eventNotifier.isIncludeMessageBody()) {\n            String body = MessageHelper.extractBodyForLogging(exchange.hasOut() ? exchange.getOut() : exchange.getIn(), \"\");\n            key4 = KeyValueAnnotation.create(\"camel.client.exchange.message.request.body\", body);\n        }\n\n        List<KeyValueAnnotation> list = new ArrayList<>();\n        list.add(key1);\n        list.add(key2);\n        list.add(key3);\n        if (key4 != null) {\n            list.add(key4);\n        }\n        return list;\n    }","id":97220,"modified_method":"@Override\n    public Collection<KeyValueAnnotation> requestAnnotations() {\n        KeyValueAnnotation key1 = KeyValueAnnotation.create(\"camel.client.endpoint.url\", url);\n        KeyValueAnnotation key2 = KeyValueAnnotation.create(\"camel.client.exchange.id\", exchange.getExchangeId());\n        KeyValueAnnotation key3 = KeyValueAnnotation.create(\"camel.client.exchange.pattern\", exchange.getPattern().name());\n\n        KeyValueAnnotation key4 = null;\n        if (eventNotifier.isIncludeMessageBody() || eventNotifier.isIncludeMessageBodyStreams()) {\n            boolean streams = eventNotifier.isIncludeMessageBodyStreams();\n            String body = MessageHelper.extractBodyForLogging(exchange.hasOut() ? exchange.getOut() : exchange.getIn(), \"\", streams, streams);\n            key4 = KeyValueAnnotation.create(\"camel.client.exchange.message.request.body\", body);\n        }\n\n        List<KeyValueAnnotation> list = new ArrayList<>();\n        list.add(key1);\n        list.add(key2);\n        list.add(key3);\n        if (key4 != null) {\n            list.add(key4);\n        }\n        return list;\n    }","commit_id":"75b424d0d8c49fd6d7daccd6c67e66e4eff129d4","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Collection<KeyValueAnnotation> responseAnnotations() {\n        KeyValueAnnotation key1 = KeyValueAnnotation.create(\"camel.client.endpoint.url\", url);\n        KeyValueAnnotation key2 = KeyValueAnnotation.create(\"camel.client.exchange.id\", exchange.getExchangeId());\n        KeyValueAnnotation key3 = KeyValueAnnotation.create(\"camel.client.exchange.pattern\", exchange.getPattern().name());\n\n        KeyValueAnnotation key4 = null;\n        if (eventNotifier.isIncludeMessageBody()) {\n            String body = MessageHelper.extractBodyForLogging(exchange.hasOut() ? exchange.getOut() : exchange.getIn(), \"\");\n            key4 = KeyValueAnnotation.create(\"camel.client.exchange.message.response.body\", body);\n        }\n\n        KeyValueAnnotation key5 = null;\n        // lets capture http response code for http based components\n        String responseCode = exchange.hasOut() ? exchange.getOut().getHeader(Exchange.HTTP_RESPONSE_CODE, String.class) : exchange.getIn().getHeader(Exchange.HTTP_RESPONSE_CODE, String.class);\n        if (responseCode != null) {\n            key5 = KeyValueAnnotation.create(\"camel.client.exchange.message.response.code\", responseCode);\n        }\n\n        List<KeyValueAnnotation> list = new ArrayList<>();\n        list.add(key1);\n        list.add(key2);\n        list.add(key3);\n        if (key4 != null) {\n            list.add(key4);\n        }\n        if (key5 != null) {\n            list.add(key5);\n        }\n        return list;\n    }","id":97221,"modified_method":"@Override\n    public Collection<KeyValueAnnotation> responseAnnotations() {\n        KeyValueAnnotation key1 = KeyValueAnnotation.create(\"camel.client.endpoint.url\", url);\n        KeyValueAnnotation key2 = KeyValueAnnotation.create(\"camel.client.exchange.id\", exchange.getExchangeId());\n        KeyValueAnnotation key3 = KeyValueAnnotation.create(\"camel.client.exchange.pattern\", exchange.getPattern().name());\n\n        KeyValueAnnotation key4 = null;\n        if (eventNotifier.isIncludeMessageBody() || eventNotifier.isIncludeMessageBodyStreams()) {\n            boolean streams = eventNotifier.isIncludeMessageBodyStreams();\n            String body = MessageHelper.extractBodyForLogging(exchange.hasOut() ? exchange.getOut() : exchange.getIn(), \"\", streams, streams);\n            key4 = KeyValueAnnotation.create(\"camel.client.exchange.message.response.body\", body);\n        }\n\n        KeyValueAnnotation key5 = null;\n        // lets capture http response code for http based components\n        String responseCode = exchange.hasOut() ? exchange.getOut().getHeader(Exchange.HTTP_RESPONSE_CODE, String.class) : exchange.getIn().getHeader(Exchange.HTTP_RESPONSE_CODE, String.class);\n        if (responseCode != null) {\n            key5 = KeyValueAnnotation.create(\"camel.client.exchange.message.response.code\", responseCode);\n        }\n\n        List<KeyValueAnnotation> list = new ArrayList<>();\n        list.add(key1);\n        list.add(key2);\n        list.add(key3);\n        if (key4 != null) {\n            list.add(key4);\n        }\n        if (key5 != null) {\n            list.add(key5);\n        }\n        return list;\n    }","commit_id":"75b424d0d8c49fd6d7daccd6c67e66e4eff129d4","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Collection<KeyValueAnnotation> requestAnnotations() {\n        KeyValueAnnotation key1 = KeyValueAnnotation.create(\"camel.server.endpoint.url\", url);\n        KeyValueAnnotation key2 = KeyValueAnnotation.create(\"camel.server.exchange.id\", exchange.getExchangeId());\n        KeyValueAnnotation key3 = KeyValueAnnotation.create(\"camel.server.exchange.pattern\", exchange.getPattern().name());\n\n        KeyValueAnnotation key4 = null;\n        if (eventNotifier.isIncludeMessageBody()) {\n            String body = MessageHelper.extractBodyForLogging(exchange.hasOut() ? exchange.getOut() : exchange.getIn(), \"\");\n            key4 = KeyValueAnnotation.create(\"camel.server.exchange.message.request.body\", body);\n        }\n\n        List<KeyValueAnnotation> list = new ArrayList<>();\n        list.add(key1);\n        list.add(key2);\n        list.add(key3);\n        if (key4 != null) {\n            list.add(key4);\n        }\n        return list;\n    }","id":97222,"modified_method":"@Override\n    public Collection<KeyValueAnnotation> requestAnnotations() {\n        KeyValueAnnotation key1 = KeyValueAnnotation.create(\"camel.server.endpoint.url\", url);\n        KeyValueAnnotation key2 = KeyValueAnnotation.create(\"camel.server.exchange.id\", exchange.getExchangeId());\n        KeyValueAnnotation key3 = KeyValueAnnotation.create(\"camel.server.exchange.pattern\", exchange.getPattern().name());\n\n        KeyValueAnnotation key4 = null;\n        if (eventNotifier.isIncludeMessageBody() || eventNotifier.isIncludeMessageBodyStreams()) {\n            boolean streams = eventNotifier.isIncludeMessageBodyStreams();\n            String body = MessageHelper.extractBodyForLogging(exchange.hasOut() ? exchange.getOut() : exchange.getIn(), \"\", streams, streams);\n            key4 = KeyValueAnnotation.create(\"camel.server.exchange.message.request.body\", body);\n        }\n\n        List<KeyValueAnnotation> list = new ArrayList<>();\n        list.add(key1);\n        list.add(key2);\n        list.add(key3);\n        if (key4 != null) {\n            list.add(key4);\n        }\n        return list;\n    }","commit_id":"75b424d0d8c49fd6d7daccd6c67e66e4eff129d4","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Collection<KeyValueAnnotation> responseAnnotations() {\n        String id = exchange.getExchangeId();\n        String mep = exchange.getPattern().name();\n\n        KeyValueAnnotation key1 = KeyValueAnnotation.create(\"camel.server.endpoint.url\", url);\n        KeyValueAnnotation key2 = KeyValueAnnotation.create(\"camel.server.exchange.id\", id);\n        KeyValueAnnotation key3 = KeyValueAnnotation.create(\"camel.server.exchange.pattern\", mep);\n\n        KeyValueAnnotation key4 = null;\n        if (exchange.getException() != null) {\n            String message = exchange.getException().getMessage();\n            key4 = KeyValueAnnotation.create(\"camel.server.exchange.failure\", message);\n        } else if (eventNotifier.isIncludeMessageBody()) {\n            String body = MessageHelper.extractBodyForLogging(exchange.hasOut() ? exchange.getOut() : exchange.getIn(), \"\");\n            key4 = KeyValueAnnotation.create(\"camel.server.exchange.message.response.body\", body);\n        }\n\n        KeyValueAnnotation key5 = null;\n        // lets capture http response code for http based components\n        String responseCode = exchange.hasOut() ? exchange.getOut().getHeader(Exchange.HTTP_RESPONSE_CODE, String.class) : exchange.getIn().getHeader(Exchange.HTTP_RESPONSE_CODE, String.class);\n        if (responseCode != null) {\n            key5 = KeyValueAnnotation.create(\"camel.server.exchange.message.response.code\", responseCode);\n        }\n\n        List<KeyValueAnnotation> list = new ArrayList<>();\n        list.add(key1);\n        list.add(key2);\n        list.add(key3);\n        if (key4 != null) {\n            list.add(key4);\n        }\n        if (key5 != null) {\n            list.add(key5);\n        }\n        return list;\n    }","id":97223,"modified_method":"@Override\n    public Collection<KeyValueAnnotation> responseAnnotations() {\n        String id = exchange.getExchangeId();\n        String mep = exchange.getPattern().name();\n\n        KeyValueAnnotation key1 = KeyValueAnnotation.create(\"camel.server.endpoint.url\", url);\n        KeyValueAnnotation key2 = KeyValueAnnotation.create(\"camel.server.exchange.id\", id);\n        KeyValueAnnotation key3 = KeyValueAnnotation.create(\"camel.server.exchange.pattern\", mep);\n\n        KeyValueAnnotation key4 = null;\n        if (exchange.getException() != null) {\n            String message = exchange.getException().getMessage();\n            key4 = KeyValueAnnotation.create(\"camel.server.exchange.failure\", message);\n        } else if (eventNotifier.isIncludeMessageBody() || eventNotifier.isIncludeMessageBodyStreams()) {\n            boolean streams = eventNotifier.isIncludeMessageBodyStreams();\n            String body = MessageHelper.extractBodyForLogging(exchange.hasOut() ? exchange.getOut() : exchange.getIn(), \"\", streams, streams);\n            key4 = KeyValueAnnotation.create(\"camel.server.exchange.message.response.body\", body);\n        }\n\n        KeyValueAnnotation key5 = null;\n        // lets capture http response code for http based components\n        String responseCode = exchange.hasOut() ? exchange.getOut().getHeader(Exchange.HTTP_RESPONSE_CODE, String.class) : exchange.getIn().getHeader(Exchange.HTTP_RESPONSE_CODE, String.class);\n        if (responseCode != null) {\n            key5 = KeyValueAnnotation.create(\"camel.server.exchange.message.response.code\", responseCode);\n        }\n\n        List<KeyValueAnnotation> list = new ArrayList<>();\n        list.add(key1);\n        list.add(key2);\n        list.add(key3);\n        if (key4 != null) {\n            list.add(key4);\n        }\n        if (key5 != null) {\n            list.add(key5);\n        }\n        return list;\n    }","commit_id":"75b424d0d8c49fd6d7daccd6c67e66e4eff129d4","url":"https://github.com/apache/camel"},{"original_method":"public void init(CamelContext camelContext) {\n        if (!camelContext.getManagementStrategy().getEventNotifiers().contains(this)) {\n            camelContext.getManagementStrategy().addEventNotifier(this);\n        }\n        if (!camelContext.getRoutePolicyFactories().contains(this)) {\n            camelContext.addRoutePolicyFactory(this);\n        }\n    }","id":97224,"modified_method":"/**\n     * Registers this {@link ZipkinTracer} on the {@link CamelContext}.\n     */\n    public void init(CamelContext camelContext) {\n        if (!camelContext.getManagementStrategy().getEventNotifiers().contains(this)) {\n            camelContext.getManagementStrategy().addEventNotifier(this);\n        }\n        if (!camelContext.getRoutePolicyFactories().contains(this)) {\n            camelContext.addRoutePolicyFactory(this);\n        }\n    }","commit_id":"75b424d0d8c49fd6d7daccd6c67e66e4eff129d4","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        ObjectHelper.notNull(camelContext, \"CamelContext\", this);\n\n        if (spanCollector == null) {\n            if (hostName != null && port > 0) {\n                log.info(\"Configuring Zipkin ScribeSpanCollector using host: {} and port: {}\", hostName, port);\n                spanCollector = new ScribeSpanCollector(hostName, port);\n            } else {\n                // is there a zipkin service setup as ENV variable to auto register a scribe span collector\n                String host = new ServiceHostPropertiesFunction().apply(\"zipkin-collector\");\n                String port = new ServicePortPropertiesFunction().apply(\"zipkin-collector\");\n                if (ObjectHelper.isNotEmpty(host) && ObjectHelper.isNotEmpty(port)) {\n                    log.info(\"Auto-configuring Zipkin ScribeSpanCollector using host: {} and port: {}\", host, port);\n                    int num = camelContext.getTypeConverter().mandatoryConvertTo(Integer.class, port);\n                    spanCollector = new ScribeSpanCollector(host, num);\n                }\n            }\n        }\n\n        ObjectHelper.notNull(spanCollector, \"SpanCollector\", this);\n\n        if (clientServiceMappings.isEmpty()) {\n            log.warn(\"No service name(s) has been configured. Camel will fallback and use endpoint uris as service names.\");\n            useFallbackServiceNames = true;\n        }\n\n        // create braves mapped per service name\n        for (Map.Entry<String, String> entry : clientServiceMappings.entrySet()) {\n            String pattern = entry.getKey();\n            String serviceName = entry.getValue();\n            createBraveForService(pattern, serviceName);\n        }\n        for (Map.Entry<String, String> entry : serverServiceMappings.entrySet()) {\n            String pattern = entry.getKey();\n            String serviceName = entry.getValue();\n            createBraveForService(pattern, serviceName);\n        }\n\n        ServiceHelper.startService(spanCollector);\n    }","id":97225,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n\n        ObjectHelper.notNull(camelContext, \"CamelContext\", this);\n\n        if (spanCollector == null) {\n            if (hostName != null && port > 0) {\n                log.info(\"Configuring Zipkin ScribeSpanCollector using host: {} and port: {}\", hostName, port);\n                spanCollector = new ScribeSpanCollector(hostName, port);\n            } else {\n                // is there a zipkin service setup as ENV variable to auto register a scribe span collector\n                String host = new ServiceHostPropertiesFunction().apply(\"zipkin-collector\");\n                String port = new ServicePortPropertiesFunction().apply(\"zipkin-collector\");\n                if (ObjectHelper.isNotEmpty(host) && ObjectHelper.isNotEmpty(port)) {\n                    log.info(\"Auto-configuring Zipkin ScribeSpanCollector using host: {} and port: {}\", host, port);\n                    int num = camelContext.getTypeConverter().mandatoryConvertTo(Integer.class, port);\n                    spanCollector = new ScribeSpanCollector(host, num);\n                }\n            }\n        }\n\n        ObjectHelper.notNull(spanCollector, \"SpanCollector\", this);\n\n        if (clientServiceMappings.isEmpty() && serverServiceMappings.isEmpty()) {\n            log.warn(\"No service name(s) has been mapped in clientServiceMappings or serverServiceMappings. Camel will fallback and use endpoint uris as service names.\");\n            useFallbackServiceNames = true;\n        }\n\n        // create braves mapped per service name\n        for (Map.Entry<String, String> entry : clientServiceMappings.entrySet()) {\n            String pattern = entry.getKey();\n            String serviceName = entry.getValue();\n            createBraveForService(pattern, serviceName);\n        }\n        for (Map.Entry<String, String> entry : serverServiceMappings.entrySet()) {\n            String pattern = entry.getKey();\n            String serviceName = entry.getValue();\n            createBraveForService(pattern, serviceName);\n        }\n\n        ServiceHelper.startService(spanCollector);\n    }","commit_id":"75b424d0d8c49fd6d7daccd6c67e66e4eff129d4","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Whether to include the Camel message body in the zipkin traces.\n     * <p/>\n     * This is not recommended for production usage, or when having big payloads. You can limit the size by\n     * configuring the <a href=\"http://camel.apache.org/how-do-i-set-the-max-chars-when-debug-logging-messages-in-camel.html\">max debug log size<\/a>.\n     */\n    @ManagedAttribute(description = \"Whether to include the Camel message body in the zipkin traces\")\n    public void setIncludeMessageBody(boolean includeMessageBody) {\n        this.includeMessageBody = includeMessageBody;\n    }","id":97226,"modified_method":"/**\n     * Whether to include the Camel message body in the zipkin traces.\n     * <p/>\n     * This is not recommended for production usage, or when having big payloads. You can limit the size by\n     * configuring the <a href=\"http://camel.apache.org/how-do-i-set-the-max-chars-when-debug-logging-messages-in-camel.html\">max debug log size<\/a>.\n     * <p/>\n     * By default message bodies that are stream based are <b>not<\/b> included. You can use the option {@link #setIncludeMessageBodyStreams(boolean)} to\n     * turn that on.\n     */\n    @ManagedAttribute(description = \"Whether to include the Camel message body in the zipkin traces\")\n    public void setIncludeMessageBody(boolean includeMessageBody) {\n        this.includeMessageBody = includeMessageBody;\n    }","commit_id":"75b424d0d8c49fd6d7daccd6c67e66e4eff129d4","url":"https://github.com/apache/camel"},{"original_method":"/** Calls {@link #act(float)} with {@link Graphics#getDeltaTime()}. */\r\n\tpublic void act () {\r\n\t\tact(Gdx.graphics.getDeltaTime());\r\n\t}","id":97227,"modified_method":"/** Calls {@link #act(float)} with {@link Graphics#getDeltaTime()}. */\r\n\tpublic void act () {\r\n\t\tact(Math.min(Gdx.graphics.getDeltaTime(), 1 / 30f));\r\n\t}","commit_id":"594662cc9d754ba5e344160420e30e51e9bde712","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void create() {\r\n\t\tstage = new Stage(480, 320, true);\r\n\t\tTexture texture = new Texture(Gdx.files.internal(\"data/badlogic.jpg\"),\r\n\t\t\t\tfalse);\r\n\t\ttexture.setFilter(TextureFilter.Linear, TextureFilter.Linear);\r\n\t\tImage img = new Image(\"actor\", texture);\r\n\t\timg.width = img.height = 100;\r\n\t\timg.originX = 50;\r\n\t\timg.originY = 50;\r\n\t\timg.x = img.y = 100;\r\n\t\t// img.action(Forever.$(Sequence.$(ScaleTo.$(1.1f,\r\n\t\t// 1.1f,0.3f),ScaleTo.$(1f, 1f, 0.3f))));\r\n\t\t// img.action(Forever.$(Parallel.$(RotateTo.$(1, 1))));\r\n\t\t// img.action(Delay.$(RotateBy.$(45, 2),\r\n\t\t// 1).setCompletionListener(this));\r\n\t\tAction actionMoveBy = MoveBy.$(30, 0, 0.5f).setCompletionListener(\r\n\t\t\t\tnew OnActionCompleted() {\r\n\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void completed(Action action) {\r\n\t\t\t\t\t\tSystem.out.println(\"move by complete\");\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\tAction actionDelay = Delay.$(actionMoveBy, 1).setCompletionListener(\r\n\t\t\t\tnew OnActionCompleted() {\r\n\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void completed(Action action) {\r\n\t\t\t\t\t\tSystem.out.println(\"delay complete\");\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\timg.action(actionDelay);\r\n\r\n\t\tstage.addActor(img);\r\n\t}","id":97228,"modified_method":"@Override\r\n\tpublic void create() {\r\n\t\tstage = new Stage(480, 320, true);\r\n\t\tTexture texture = new Texture(Gdx.files.internal(\"data/badlogic.jpg\"),\r\n\t\t\t\tfalse);\r\n\t\ttexture.setFilter(TextureFilter.Linear, TextureFilter.Linear);\r\n\t\tImage img = new Image(\"actor\", texture);\r\n\t\timg.width = img.height = 100;\r\n\t\timg.originX = 50;\r\n\t\timg.originY = 50;\r\n\t\timg.x = img.y = 100;\r\n\t\t// img.action(Forever.$(Sequence.$(ScaleTo.$(1.1f,\r\n\t\t// 1.1f,0.3f),ScaleTo.$(1f, 1f, 0.3f))));\r\n\t\t// img.action(Forever.$(Parallel.$(RotateTo.$(1, 1))));\r\n\t\t// img.action(Delay.$(RotateBy.$(45, 2),\r\n\t\t// 1).setCompletionListener(this));\r\n//\t\tAction actionMoveBy = MoveBy.$(30, 0, 0.5f).setCompletionListener(\r\n//\t\t\t\tnew OnActionCompleted() {\r\n//\r\n//\t\t\t\t\t@Override\r\n//\t\t\t\t\tpublic void completed(Action action) {\r\n//\t\t\t\t\t\tSystem.out.println(\"move by complete\");\r\n//\t\t\t\t\t}\r\n//\t\t\t\t});\r\n//\r\n//\t\tAction actionDelay = Delay.$(actionMoveBy, 1).setCompletionListener(\r\n//\t\t\t\tnew OnActionCompleted() {\r\n//\r\n//\t\t\t\t\t@Override\r\n//\t\t\t\t\tpublic void completed(Action action) {\r\n//\t\t\t\t\t\tSystem.out.println(\"delay complete\");\r\n//\t\t\t\t\t}\r\n//\t\t\t\t});\r\n//\r\n//\t\timg.action(actionDelay);\r\n\r\n\t\timg.action(Repeat.$(Sequence.$(MoveBy.$(50, 0, 1), MoveBy.$(0, 50, 1), MoveBy.$(-50, 0, 1), MoveBy.$(0, -50, 1)), 3));\r\n\t\t\r\n\t\tstage.addActor(img);\r\n\t}","commit_id":"5e73dec99fec096c12efdfec94f76a6a937d9511","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void render() {\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);\r\n\t\tstage.act(Gdx.graphics.getDeltaTime());\r\n\t\tstage.draw();\r\n\t}","id":97229,"modified_method":"@Override\r\n\tpublic void render() {\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);\r\n\t\tstage.act(Math.min(Gdx.graphics.getDeltaTime(), 1 / 30f));\r\n\t\tstage.draw();\r\n\t}","commit_id":"5e73dec99fec096c12efdfec94f76a6a937d9511","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void create() {\r\n\t\tstage = new Stage(480, 320, true);\r\n\t\tTexture texture = new Texture(Gdx.files.internal(\"data/badlogic.jpg\"),\r\n\t\t\t\tfalse);\r\n\t\ttexture.setFilter(TextureFilter.Linear, TextureFilter.Linear);\r\n\t\tImage img = new Image(\"actor\", texture);\r\n\t\timg.width = img.height = 100;\r\n\t\timg.originX = 50;\r\n\t\timg.originY = 50;\r\n\t\timg.x = img.y = 100;\r\n\t\t// img.action(Forever.$(Sequence.$(ScaleTo.$(1.1f,\r\n\t\t// 1.1f,0.3f),ScaleTo.$(1f, 1f, 0.3f))));\r\n\t\t// img.action(Forever.$(Parallel.$(RotateTo.$(1, 1))));\r\n\t\t// img.action(Delay.$(RotateBy.$(45, 2),\r\n\t\t// 1).setCompletionListener(this));\r\n//\t\tAction actionMoveBy = MoveBy.$(30, 0, 0.5f).setCompletionListener(\r\n//\t\t\t\tnew OnActionCompleted() {\r\n//\r\n//\t\t\t\t\t@Override\r\n//\t\t\t\t\tpublic void completed(Action action) {\r\n//\t\t\t\t\t\tSystem.out.println(\"move by complete\");\r\n//\t\t\t\t\t}\r\n//\t\t\t\t});\r\n//\r\n//\t\tAction actionDelay = Delay.$(actionMoveBy, 1).setCompletionListener(\r\n//\t\t\t\tnew OnActionCompleted() {\r\n//\r\n//\t\t\t\t\t@Override\r\n//\t\t\t\t\tpublic void completed(Action action) {\r\n//\t\t\t\t\t\tSystem.out.println(\"delay complete\");\r\n//\t\t\t\t\t}\r\n//\t\t\t\t});\r\n//\r\n//\t\timg.action(actionDelay);\r\n\r\n\t\timg.action(Repeat.$(Sequence.$(MoveBy.$(50, 0, 1), MoveBy.$(0, 50, 1), MoveBy.$(-50, 0, 1), MoveBy.$(0, -50, 1)), 3));\r\n\t\t\r\n\t\tstage.addActor(img);\r\n\t}","id":97230,"modified_method":"@Override\r\n\tpublic void create() {\r\n\t\tstage = new Stage(480, 320, true);\r\n\t\tTexture texture = new Texture(Gdx.files.internal(\"data/badlogic.jpg\"),\r\n\t\t\t\tfalse);\r\n\t\ttexture.setFilter(TextureFilter.Linear, TextureFilter.Linear);\r\n\t\tImage img = new Image(\"actor\", texture);\r\n\t\timg.width = img.height = 100;\r\n\t\timg.originX = 50;\r\n\t\timg.originY = 50;\r\n\t\timg.x = img.y = 100;\r\n\t\t// img.action(Forever.$(Sequence.$(ScaleTo.$(1.1f,\r\n\t\t// 1.1f,0.3f),ScaleTo.$(1f, 1f, 0.3f))));\r\n\t\t// img.action(Forever.$(Parallel.$(RotateTo.$(1, 1))));\r\n\t\t// img.action(Delay.$(RotateBy.$(45, 2),\r\n\t\t// 1).setCompletionListener(this));\r\n//\t\tAction actionMoveBy = MoveBy.$(30, 0, 0.5f).setCompletionListener(\r\n//\t\t\t\tnew OnActionCompleted() {\r\n//\r\n//\t\t\t\t\t@Override\r\n//\t\t\t\t\tpublic void completed(Action action) {\r\n//\t\t\t\t\t\tSystem.out.println(\"move by complete\");\r\n//\t\t\t\t\t}\r\n//\t\t\t\t});\r\n//\r\n//\t\tAction actionDelay = Delay.$(actionMoveBy, 1).setCompletionListener(\r\n//\t\t\t\tnew OnActionCompleted() {\r\n//\r\n//\t\t\t\t\t@Override\r\n//\t\t\t\t\tpublic void completed(Action action) {\r\n//\t\t\t\t\t\tSystem.out.println(\"delay complete\");\r\n//\t\t\t\t\t}\r\n//\t\t\t\t});\r\n//\r\n//\t\timg.action(actionDelay);\r\n\r\n//\t\timg.action(Repeat.$(Sequence.$(MoveBy.$(50, 0, 1), MoveBy.$(0, 50, 1), MoveBy.$(-50, 0, 1), MoveBy.$(0, -50, 1)), 3));\r\n\t\timg.action(Sequence.$(FadeOut.$(1), \r\n\t\t\t\t\t\t\t\t\t FadeIn.$(1), \r\n\t\t\t\t\t\t\t\t\t Delay.$(MoveTo.$(100, 100, 1), 2), \r\n\t\t\t\t\t\t\t\t\t ScaleTo.$(0.5f, 0.5f, 1),\r\n\t\t\t                   FadeOut.$(0.5f), \r\n\t\t\t                   Delay.$(Parallel.$( RotateTo.$(360, 1), \r\n\t\t\t                  \t \t\t\t\t\t\tFadeIn.$(1), \r\n\t\t\t                  \t \t\t\t\t\t\tScaleTo.$(1, 1, 1)), 1)));\r\n\t\t\r\n\t\tstage.addActor(img);\r\n\t}","commit_id":"8acc495173f331d13730415858eef17c4a82af56","url":"https://github.com/libgdx/libgdx"},{"original_method":"public static void main (String[] argv) {\r\n\t\tnew JoglApplication(new com.badlogic.gdx.tests.PickingTest(), \"Debug Test\", 480, 320, false);\r\n\t}","id":97231,"modified_method":"public static void main (String[] argv) {\r\n\t\tnew JoglApplication(new com.badlogic.gdx.tests.UITest(), \"Debug Test\", 480, 320, false);\r\n\t}","commit_id":"8acc495173f331d13730415858eef17c4a82af56","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override public void render () {\r\n\t\tGL10 gl = Gdx.graphics.getGL10();\r\n\t\tgl.glClear(GL10.GL_COLOR_BUFFER_BIT);\r\n\t\tui.act(Gdx.graphics.getDeltaTime());\r\n\t\tui.draw();\r\n\t}","id":97232,"modified_method":"@Override public void render () {\r\n\t\tGL10 gl = Gdx.graphics.getGL10();\r\n\t\tgl.glClear(GL10.GL_COLOR_BUFFER_BIT);\r\n\t\tui.act(Math.min(Gdx.graphics.getDeltaTime(), 1 / 30.0f));\r\n\t\tui.draw();\r\n\t}","commit_id":"8acc495173f331d13730415858eef17c4a82af56","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void bindFactoryToJndi(LazyValidatorFactory factory, DeploymentUnit deploymentUnit, DeploymentPhaseContext phaseContext,EEModuleDescription moduleDescription) {\n\n        if(moduleDescription == null) {\n            return;\n        }\n\n        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n        //if this is a war we need to bind to the modules comp namespace\n        if(DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            final ServiceName moduleContextServiceName = ContextNames.contextServiceNameOfModule(moduleDescription.getApplicationName(), moduleDescription.getModuleName());\n            bindServices(factory, serviceTarget, moduleDescription, moduleDescription.getModuleName(), moduleContextServiceName);\n        }\n\n        for(ComponentDescription component : moduleDescription.getComponentDescriptions()) {\n            if(component.getNamingMode() == ComponentNamingMode.CREATE) {\n                final ServiceName compContextServiceName = ContextNames.contextServiceNameOfComponent(moduleDescription.getApplicationName(),moduleDescription.getModuleName(),component.getComponentName());\n                bindServices(factory, serviceTarget, moduleDescription, component.getComponentName(), compContextServiceName);\n            }\n        }\n\n    }","id":97233,"modified_method":"private void bindFactoryToJndi(LazyValidatorFactory factory, DeploymentUnit deploymentUnit, DeploymentPhaseContext phaseContext,EEModuleDescription moduleDescription) {\n\n        if(moduleDescription == null) {\n            return;\n        }\n\n        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n        //if this is a war we need to bind to the modules comp namespace\n        if(DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit) || DeploymentTypeMarker.isType(DeploymentType.APPLICATION_CLIENT, deploymentUnit)) {\n            final ServiceName moduleContextServiceName = ContextNames.contextServiceNameOfModule(moduleDescription.getApplicationName(), moduleDescription.getModuleName());\n            bindServices(factory, serviceTarget, moduleDescription, moduleDescription.getModuleName(), moduleContextServiceName);\n        }\n\n        for(ComponentDescription component : moduleDescription.getComponentDescriptions()) {\n            if(component.getNamingMode() == ComponentNamingMode.CREATE) {\n                final ServiceName compContextServiceName = ContextNames.contextServiceNameOfComponent(moduleDescription.getApplicationName(),moduleDescription.getModuleName(),component.getComponentName());\n                bindServices(factory, serviceTarget, moduleDescription, component.getComponentName(), compContextServiceName);\n            }\n        }\n\n    }","commit_id":"329acf45a4248d1c5496f4c8c9de9150f95dd5b3","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performBoottime(final OperationContext context, ModelNode operation, final ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        //setup ejb: namespace\n        EjbNamingContextSetup.setupEjbNamespace();\n        //TODO: this is a bit of a hack\n        InitialContext.addUrlContextFactory(\"ejb\", new ejbURLContextFactory());\n        final boolean appclient = model.hasDefined(APPCLIENT) && model.get(APPCLIENT).asBoolean();\n\n        final DefaultAccessTimeoutService statefulTimeout = new DefaultAccessTimeoutService(EJB3SubsystemRootResourceDefinition.DEFAULT_STATEFUL_ACCESS_TIMEOUT.validateResolvedOperation(model).asLong());\n        newControllers.add(context.getServiceTarget().addService(DefaultAccessTimeoutService.STATEFUL_SERVICE_NAME, statefulTimeout).install());\n        final DefaultAccessTimeoutService singletonTimeout = new DefaultAccessTimeoutService(EJB3SubsystemRootResourceDefinition.DEFAULT_SINGLETON_ACCESS_TIMEOUT.validateResolvedOperation(model).asLong());\n        newControllers.add(context.getServiceTarget().addService(DefaultAccessTimeoutService.SINGLETON_SERVICE_NAME, singletonTimeout).install());\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n\n                //DUP's that are used even for app client deployments\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_DEPLOYMENT, new EjbJarParsingDeploymentUnitProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_SESSION_BEAN_CREATE_COMPONENT_DESCRIPTIONS, new SessionBeanComponentDescriptionFactory(appclient));\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_SESSION_BEAN_DD, new SessionBeanXmlDescriptorProcessor(appclient));\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_ANNOTATION_EJB, new EjbAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_INJECTION_ANNOTATION, new EjbResourceInjectionAnnotationProcessor());\n\n                processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_EJB, new EjbDependencyDeploymentUnitProcessor());\n                processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_HOME_MERGE, new HomeViewMergingProcessor(appclient));\n                processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_REF, new EjbRefProcessor());\n                processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_CLIENT_CONTEXT_SETUP, new EjbClientContextSetupProcessor());\n                processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_BUSINESS_VIEW_ANNOTATION, new BusinessViewAnnotationProcessor(appclient));\n\n                processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_RESOLVE_EJB_INJECTIONS, new EjbInjectionResolutionProcessor());\n\n                processorTarget.addDeploymentProcessor(Phase.CLEANUP, Phase.CLEANUP_EJB, new EjbCleanUpProcessor());\n\n                if (!appclient) {\n                    // add the metadata parser deployment processor\n\n                    // Process @DependsOn after the @Singletons have been registered.\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_CONTEXT_BINDING, new EjbContextJndiBindingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_TIMERSERVICE_BINDING, new TimerServiceJndiBindingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_APPLICATION_EXCEPTION_ANNOTATION, new ApplicationExceptionAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_DD_INTERCEPTORS, new InterceptorClassDeploymentDescriptorProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_ASSEMBLY_DESC_DD, new AssemblyDescriptorProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_SECURITY_ROLE_REF_DD, new SecurityRoleRefDDProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_REMOTE_CLIENT_CONTEXT, new EjbClientContextParsingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_MDB_CREATE_COMPONENT_DESCRIPTIONS, new MessageDrivenComponentDescriptionFactory());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_ENTITY_BEAN_CREATE_COMPONENT_DESCRIPTIONS, new EntityBeanComponentDescriptionFactory());\n\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_IMPLICIT_NO_INTERFACE_VIEW, new ImplicitLocalViewProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_JNDI_BINDINGS, new EjbJndiBindingsDeploymentUnitProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_MODULE_CONFIGURATION, new EjbJarConfigurationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_INTERCEPTORS, new DeploymentDescriptorInterceptorBindingsProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_METHOD_RESOLUTION, new DeploymentDescriptorMethodProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_TRANSACTION_MANAGEMENT, new TransactionManagementMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_CONCURRENCY_MANAGEMENT_MERGE, new ConcurrencyManagementMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_CONCURRENCY_MERGE, new EjbConcurrencyMergingProcessor(singletonTimeout, statefulTimeout));\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_TX_ATTR_MERGE, new TransactionAttributeMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_RUN_AS_MERGE, new RunAsMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_RESOURCE_ADAPTER_MERGE, new ResourceAdaptorMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_REMOVE_METHOD, new RemoveMethodMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_STARTUP_MERGE, new StartupMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_SECURITY_DOMAIN, new SecurityDomainMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_ROLES, new DeclareRolesMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_METHOD_PERMISSIONS, new MethodPermissionsMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_STATEFUL_TIMEOUT, new StatefulTimeoutMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_SESSION_SYNCHRONIZATION, new SessionSynchronizationMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_INIT_METHOD, new InitMethodMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_LOCAL_HOME, new SessionBeanHomeProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_ORB_BIND, new ORBJndiBindingProcessor());\n\n                    processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_DEPENDS_ON_ANNOTATION, new EjbDependsOnMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_DEPLOYMENT_REPOSITORY, new DeploymentRepositoryProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_EJB_MANAGEMENT_RESOURCES, new EjbManagementDeploymentUnitProcessor());\n\n                }\n\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        if (model.hasDefined(DEFAULT_MDB_INSTANCE_POOL)) {\n            EJB3SubsystemDefaultPoolWriteHandler.MDB_POOL.updatePoolService(context, model, newControllers);\n        }\n\n        if (model.hasDefined(DEFAULT_SLSB_INSTANCE_POOL)) {\n            EJB3SubsystemDefaultPoolWriteHandler.SLSB_POOL.updatePoolService(context, model, newControllers);\n        }\n\n        if (model.hasDefined(DEFAULT_RESOURCE_ADAPTER_NAME)) {\n            DefaultResourceAdapterWriteHandler.INSTANCE.updateDefaultAdapterService(context, model, newControllers);\n        }\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        newControllers.add(context.getServiceTarget().addService(DeploymentRepository.SERVICE_NAME, new DeploymentRepository()).install());\n\n        addRemoteInvocationServices(context, newControllers, appclient);\n\n        if (!appclient) {\n            final EJBUtilities utilities = new EJBUtilities();\n            newControllers.add(serviceTarget.addService(EJBUtilities.SERVICE_NAME, utilities)\n                    .addDependency(ConnectorServices.RA_REPOSISTORY_SERVICE, ResourceAdapterRepository.class, utilities.getResourceAdapterRepositoryInjector())\n                    .addDependency(ConnectorServices.IRONJACAMAR_MDR, MetadataRepository.class, utilities.getMdrInjector())\n                    .addDependency(SimpleSecurityManagerService.SERVICE_NAME, SimpleSecurityManager.class, utilities.getSecurityManagerInjector())\n                    .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, TransactionManager.class, utilities.getTransactionManagerInjector())\n                    .addDependency(TxnServices.JBOSS_TXN_SYNCHRONIZATION_REGISTRY, TransactionSynchronizationRegistry.class, utilities.getTransactionSynchronizationRegistryInjector())\n                    .addDependency(TxnServices.JBOSS_TXN_USER_TRANSACTION, UserTransaction.class, utilities.getUserTransactionInjector())\n                    .addListener(verificationHandler)\n                    .setInitialMode(ServiceController.Mode.ACTIVE)\n                    .install());\n        }\n    }","id":97234,"modified_method":"protected void performBoottime(final OperationContext context, ModelNode operation, final ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        //setup ejb: namespace\n        EjbNamingContextSetup.setupEjbNamespace();\n        //TODO: this is a bit of a hack\n        InitialContext.addUrlContextFactory(\"ejb\", new ejbURLContextFactory());\n        final boolean appclient = model.hasDefined(APPCLIENT) && model.get(APPCLIENT).asBoolean();\n\n        final DefaultAccessTimeoutService statefulTimeout = new DefaultAccessTimeoutService(EJB3SubsystemRootResourceDefinition.DEFAULT_STATEFUL_ACCESS_TIMEOUT.validateResolvedOperation(model).asLong());\n        newControllers.add(context.getServiceTarget().addService(DefaultAccessTimeoutService.STATEFUL_SERVICE_NAME, statefulTimeout).install());\n        final DefaultAccessTimeoutService singletonTimeout = new DefaultAccessTimeoutService(EJB3SubsystemRootResourceDefinition.DEFAULT_SINGLETON_ACCESS_TIMEOUT.validateResolvedOperation(model).asLong());\n        newControllers.add(context.getServiceTarget().addService(DefaultAccessTimeoutService.SINGLETON_SERVICE_NAME, singletonTimeout).install());\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n\n                //DUP's that are used even for app client deployments\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_DEPLOYMENT, new EjbJarParsingDeploymentUnitProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_SESSION_BEAN_CREATE_COMPONENT_DESCRIPTIONS, new SessionBeanComponentDescriptionFactory(appclient));\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_SESSION_BEAN_DD, new SessionBeanXmlDescriptorProcessor(appclient));\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_ANNOTATION_EJB, new EjbAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_INJECTION_ANNOTATION, new EjbResourceInjectionAnnotationProcessor());\n\n                processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_EJB, new EjbDependencyDeploymentUnitProcessor());\n                processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_HOME_MERGE, new HomeViewMergingProcessor(appclient));\n                processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_REF, new EjbRefProcessor());\n                processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_CLIENT_CONTEXT_SETUP, new EjbClientContextSetupProcessor());\n                processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_BUSINESS_VIEW_ANNOTATION, new BusinessViewAnnotationProcessor(appclient));\n                processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_ORB_BIND, new ORBJndiBindingProcessor());\n\n                processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_RESOLVE_EJB_INJECTIONS, new EjbInjectionResolutionProcessor());\n\n                processorTarget.addDeploymentProcessor(Phase.CLEANUP, Phase.CLEANUP_EJB, new EjbCleanUpProcessor());\n\n                if (!appclient) {\n                    // add the metadata parser deployment processor\n\n                    // Process @DependsOn after the @Singletons have been registered.\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_CONTEXT_BINDING, new EjbContextJndiBindingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_TIMERSERVICE_BINDING, new TimerServiceJndiBindingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_APPLICATION_EXCEPTION_ANNOTATION, new ApplicationExceptionAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_DD_INTERCEPTORS, new InterceptorClassDeploymentDescriptorProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_ASSEMBLY_DESC_DD, new AssemblyDescriptorProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_SECURITY_ROLE_REF_DD, new SecurityRoleRefDDProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_REMOTE_CLIENT_CONTEXT, new EjbClientContextParsingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_MDB_CREATE_COMPONENT_DESCRIPTIONS, new MessageDrivenComponentDescriptionFactory());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_ENTITY_BEAN_CREATE_COMPONENT_DESCRIPTIONS, new EntityBeanComponentDescriptionFactory());\n\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_IMPLICIT_NO_INTERFACE_VIEW, new ImplicitLocalViewProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_JNDI_BINDINGS, new EjbJndiBindingsDeploymentUnitProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_MODULE_CONFIGURATION, new EjbJarConfigurationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_INTERCEPTORS, new DeploymentDescriptorInterceptorBindingsProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_METHOD_RESOLUTION, new DeploymentDescriptorMethodProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_TRANSACTION_MANAGEMENT, new TransactionManagementMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_CONCURRENCY_MANAGEMENT_MERGE, new ConcurrencyManagementMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_CONCURRENCY_MERGE, new EjbConcurrencyMergingProcessor(singletonTimeout, statefulTimeout));\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_TX_ATTR_MERGE, new TransactionAttributeMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_RUN_AS_MERGE, new RunAsMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_RESOURCE_ADAPTER_MERGE, new ResourceAdaptorMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_REMOVE_METHOD, new RemoveMethodMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_STARTUP_MERGE, new StartupMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_SECURITY_DOMAIN, new SecurityDomainMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_ROLES, new DeclareRolesMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_METHOD_PERMISSIONS, new MethodPermissionsMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_STATEFUL_TIMEOUT, new StatefulTimeoutMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_SESSION_SYNCHRONIZATION, new SessionSynchronizationMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_INIT_METHOD, new InitMethodMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_LOCAL_HOME, new SessionBeanHomeProcessor());\n\n                    processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_DEPENDS_ON_ANNOTATION, new EjbDependsOnMergingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_DEPLOYMENT_REPOSITORY, new DeploymentRepositoryProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_EJB_MANAGEMENT_RESOURCES, new EjbManagementDeploymentUnitProcessor());\n\n                }\n\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        if (model.hasDefined(DEFAULT_MDB_INSTANCE_POOL)) {\n            EJB3SubsystemDefaultPoolWriteHandler.MDB_POOL.updatePoolService(context, model, newControllers);\n        }\n\n        if (model.hasDefined(DEFAULT_SLSB_INSTANCE_POOL)) {\n            EJB3SubsystemDefaultPoolWriteHandler.SLSB_POOL.updatePoolService(context, model, newControllers);\n        }\n\n        if (model.hasDefined(DEFAULT_RESOURCE_ADAPTER_NAME)) {\n            DefaultResourceAdapterWriteHandler.INSTANCE.updateDefaultAdapterService(context, model, newControllers);\n        }\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        newControllers.add(context.getServiceTarget().addService(DeploymentRepository.SERVICE_NAME, new DeploymentRepository()).install());\n\n        addRemoteInvocationServices(context, newControllers, appclient);\n\n        if (!appclient) {\n            final EJBUtilities utilities = new EJBUtilities();\n            newControllers.add(serviceTarget.addService(EJBUtilities.SERVICE_NAME, utilities)\n                    .addDependency(ConnectorServices.RA_REPOSISTORY_SERVICE, ResourceAdapterRepository.class, utilities.getResourceAdapterRepositoryInjector())\n                    .addDependency(ConnectorServices.IRONJACAMAR_MDR, MetadataRepository.class, utilities.getMdrInjector())\n                    .addDependency(SimpleSecurityManagerService.SERVICE_NAME, SimpleSecurityManager.class, utilities.getSecurityManagerInjector())\n                    .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, TransactionManager.class, utilities.getTransactionManagerInjector())\n                    .addDependency(TxnServices.JBOSS_TXN_SYNCHRONIZATION_REGISTRY, TransactionSynchronizationRegistry.class, utilities.getTransactionSynchronizationRegistryInjector())\n                    .addDependency(TxnServices.JBOSS_TXN_USER_TRANSACTION, UserTransaction.class, utilities.getUserTransactionInjector())\n                    .addListener(verificationHandler)\n                    .setInitialMode(ServiceController.Mode.ACTIVE)\n                    .install());\n        }\n    }","commit_id":"d4995c19a948e7953007752793ea60c9b1adea2f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);\n\n        if(moduleDescription == null) {\n            return;\n        }\n\n        //do not bind if jacORB not present\n        if(!JacORBDeploymentMarker.isJacORBDeployment(deploymentUnit)) {\n            return;\n        }\n\n        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n        //if this is a war we need to bind to the modules comp namespace\n        if(DeploymentTypeMarker.isType(DeploymentType.WAR,deploymentUnit)) {\n            final ServiceName moduleContextServiceName = ContextNames.contextServiceNameOfModule(moduleDescription.getApplicationName(),moduleDescription.getModuleName());\n            bindService(serviceTarget, moduleContextServiceName);\n        }\n\n        for(ComponentDescription component : moduleDescription.getComponentDescriptions()) {\n            if(component.getNamingMode() == ComponentNamingMode.CREATE) {\n                final ServiceName compContextServiceName = ContextNames.contextServiceNameOfComponent(moduleDescription.getApplicationName(),moduleDescription.getModuleName(),component.getComponentName());\n                bindService(serviceTarget, compContextServiceName);\n            }\n        }\n\n    }","id":97235,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);\n\n        if (moduleDescription == null) {\n            return;\n        }\n\n        //do not bind if jacORB not present\n        if (!JacORBDeploymentMarker.isJacORBDeployment(deploymentUnit)) {\n            return;\n        }\n\n        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n        //if this is a war we need to bind to the modules comp namespace\n\n        if (DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit) || DeploymentTypeMarker.isType(DeploymentType.APPLICATION_CLIENT, deploymentUnit)) {\n            final ServiceName moduleContextServiceName = ContextNames.contextServiceNameOfModule(moduleDescription.getApplicationName(), moduleDescription.getModuleName());\n            bindService(serviceTarget, moduleContextServiceName);\n        }\n\n        for (ComponentDescription component : moduleDescription.getComponentDescriptions()) {\n            if (component.getNamingMode() == ComponentNamingMode.CREATE) {\n                final ServiceName compContextServiceName = ContextNames.contextServiceNameOfComponent(moduleDescription.getApplicationName(), moduleDescription.getModuleName(), component.getComponentName());\n                bindService(serviceTarget, compContextServiceName);\n            }\n        }\n\n    }","commit_id":"d4995c19a948e7953007752793ea60c9b1adea2f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Don't register EAR deployments\n        final DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        if (DeploymentTypeMarker.isType(DeploymentType.EAR, depUnit))\n            return;\n\n        // Don't register Bundle deployments\n        if (depUnit.hasAttachment(OSGiConstants.BUNDLE_KEY))\n            return;\n\n        // Don't register private module deployments\n        final Module module = depUnit.getAttachment(Attachments.MODULE);\n        final ModuleSpecification moduleSpecification = depUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        if (module == null || moduleSpecification.isPrivateModule())\n            return;\n\n        OSGiMetaData metadata = depUnit.getAttachment(OSGiConstants.OSGI_METADATA_KEY);\n        registrationTracker.registerModule(module, metadata);\n    }","id":97236,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Don't register EAR nor WAR deployments\n        final DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        if (DeploymentTypeMarker.isType(DeploymentType.EAR, depUnit) || DeploymentTypeMarker.isType(DeploymentType.WAR, depUnit))\n            return;\n\n        // Don't register Bundle deployments\n        if (depUnit.hasAttachment(OSGiConstants.BUNDLE_KEY))\n            return;\n\n        // Don't register private module deployments\n        final Module module = depUnit.getAttachment(Attachments.MODULE);\n        final ModuleSpecification moduleSpecification = depUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        if (module == null || moduleSpecification.isPrivateModule())\n            return;\n\n        OSGiMetaData metadata = depUnit.getAttachment(OSGiConstants.OSGI_METADATA_KEY);\n        registrationTracker.registerModule(module, metadata);\n    }","commit_id":"460b9caf3b5af28a635bcb9b15b822cd49b9b2e6","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void collectDependencies(ResolvedModuleVersionResult node, Set<ResolvedDependencyResult> out, Set<ResolvedModuleVersionResult> visited) {\n        if (!visited.add(node)) {\n            return;\n        }\n        for (ResolvedDependencyResult d : node.getDependencies()) {\n            collectDependencies(d.getSelected(), out, visited);\n            out.add(d);\n        }\n    }","id":97237,"modified_method":"private void collectDependencies(ResolvedModuleVersionResult node, Set<DependencyResult> out, Set<ResolvedModuleVersionResult> visited) {\n        if (!visited.add(node)) {\n            return;\n        }\n        for (DependencyResult d : node.getDependencies()) {\n            if (d instanceof ResolvedDependencyResult) {\n                collectDependencies(((ResolvedDependencyResult) d).getSelected(), out, visited);\n            }\n            out.add(d);\n        }\n    }","commit_id":"f39eeaf7444bbbb0013db613140082817e282736","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<? extends ResolvedDependencyResult> getAllDependencies() {\n        //TODO SF api change: void allDependencies(Action<ResolvedDependencyResult> action) / void allDependencies(Closure cl)\n        Set<ResolvedDependencyResult> out = new LinkedHashSet<ResolvedDependencyResult>();\n        Set<ResolvedModuleVersionResult> visited = new LinkedHashSet<ResolvedModuleVersionResult>();\n        collectDependencies(root, out, visited);\n        return out;\n    }","id":97238,"modified_method":"public Set<? extends DependencyResult> getAllDependencies() {\n        //TODO SF api change: void allDependencies(Action<ResolvedDependencyResult> action) / void allDependencies(Closure cl)\n        Set<DependencyResult> out = new LinkedHashSet<DependencyResult>();\n        Set<ResolvedModuleVersionResult> visited = new LinkedHashSet<ResolvedModuleVersionResult>();\n        collectDependencies(root, out, visited);\n        return out;\n    }","commit_id":"f39eeaf7444bbbb0013db613140082817e282736","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<ResolvedDependencyResult> getDependencies() {\n        return CollectionUtils.filter((Set) dependencies, new LinkedHashSet<ResolvedDependencyResult>(), new Spec<DependencyResult>() {\n            public boolean isSatisfiedBy(DependencyResult element) {\n                return element instanceof ResolvedDependencyResult;\n            }\n        });\n    }","id":97239,"modified_method":"public Set<DependencyResult> getDependencies() {\n        return new LinkedHashSet<DependencyResult>(dependencies);\n    }","commit_id":"f39eeaf7444bbbb0013db613140082817e282736","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<ResolvedDependencyResult> getDependents() {\n        return dependents;\n    }","id":97240,"modified_method":"public Set<ResolvedDependencyResult> getDependents() {\n        return new LinkedHashSet<ResolvedDependencyResult>(dependents);\n    }","commit_id":"f39eeaf7444bbbb0013db613140082817e282736","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<RenderableDependency> getChildren() {\n        return new LinkedHashSet(Collections2.transform(dependency.getSelected().getDependencies(), new Function<ResolvedDependencyResult, RenderableDependency>() {\n            public RenderableDependency apply(ResolvedDependencyResult input) {\n                return new RenderableDependencyResult(input);\n            }\n        }));\n    }","id":97241,"modified_method":"public Set<RenderableDependency> getChildren() {\n        Set<RenderableDependency> out = new LinkedHashSet<RenderableDependency>();\n        for (DependencyResult d : dependency.getSelected().getDependencies()) {\n            //TODO SF revisit when implementing the 'unresolved dependencies' story\n            if (d instanceof ResolvedDependencyResult) {\n                out.add(new RenderableDependencyResult((ResolvedDependencyResult) d));\n            }\n        }\n        return out;\n    }","commit_id":"f39eeaf7444bbbb0013db613140082817e282736","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<RenderableDependency> getChildren() {\n        return new LinkedHashSet(Collections2.transform(module.getDependencies(), new Function<ResolvedDependencyResult, RenderableDependency>() {\n            public RenderableDependency apply(ResolvedDependencyResult input) {\n                return new RenderableDependencyResult(input);\n            }\n        }));\n    }","id":97242,"modified_method":"public Set<RenderableDependency> getChildren() {\n        Set<RenderableDependency> out = new LinkedHashSet<RenderableDependency>();\n        for (DependencyResult d : module.getDependencies()) {\n            //TODO SF revisit when implementing the 'unresolved dependencies' story\n            if (d instanceof ResolvedDependencyResult) {\n                out.add(new RenderableDependencyResult((ResolvedDependencyResult) d));\n            }\n        }\n        return out;\n    }","commit_id":"f39eeaf7444bbbb0013db613140082817e282736","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected MavenDomDependency doGenerate(@NotNull final MavenDomProjectModel mavenModel, final Editor editor) {\n      Set<MavenDomDependency> managingDependencies = collectManagingDependencies(mavenModel);\n\n      final List<MavenDomDependency> dependenciesToOverride =\n        GenerateDependencyUtil.chooseDependencies(managingDependencies, mavenModel.getManager().getProject());\n\n      if (!dependenciesToOverride.isEmpty()) {\n        return new WriteCommandAction<MavenDomDependency>(editor.getProject(), mavenModel.getXmlTag().getContainingFile()) {\n          @Override\n          protected void run(Result result) throws Throwable {\n            for (MavenDomDependency parentDependency : dependenciesToOverride) {\n              String groupId = parentDependency.getGroupId().getStringValue();\n              String artifactId = parentDependency.getArtifactId().getStringValue();\n\n              if (!StringUtil.isEmptyOrSpaces(groupId) && !StringUtil.isEmptyOrSpaces(artifactId)) {\n                MavenDomDependency dependency = MavenDomUtil.createDomDependency(mavenModel, editor);\n\n                dependency.getGroupId().setStringValue(groupId);\n                dependency.getArtifactId().setStringValue(artifactId);\n                String typeValue = parentDependency.getType().getStringValue();\n\n                if (!StringUtil.isEmptyOrSpaces(typeValue)) {\n                  dependency.getType().setStringValue(typeValue);\n                }\n                dependency.getVersion().undefine();\n              }\n            }\n          }\n        }.execute().getResultObject();\n      }\n\n      return null;\n    }","id":97243,"modified_method":"@Override\n    protected MavenDomDependency doGenerate(@NotNull final MavenDomProjectModel mavenModel, final Editor editor) {\n      Collection<MavenDomDependency> managingDependencies = collectManagingDependencies(mavenModel);\n\n      final List<MavenDomDependency> dependenciesToOverride =\n        GenerateDependencyUtil.chooseDependencies(managingDependencies, mavenModel.getManager().getProject());\n\n      if (!dependenciesToOverride.isEmpty()) {\n        return new WriteCommandAction<MavenDomDependency>(editor.getProject(), mavenModel.getXmlTag().getContainingFile()) {\n          @Override\n          protected void run(Result result) throws Throwable {\n            for (MavenDomDependency parentDependency : dependenciesToOverride) {\n              String groupId = parentDependency.getGroupId().getStringValue();\n              String artifactId = parentDependency.getArtifactId().getStringValue();\n\n              if (!StringUtil.isEmptyOrSpaces(groupId) && !StringUtil.isEmptyOrSpaces(artifactId)) {\n                MavenDomDependency dependency = MavenDomUtil.createDomDependency(mavenModel, editor);\n\n                dependency.getGroupId().setStringValue(groupId);\n                dependency.getArtifactId().setStringValue(artifactId);\n                String typeValue = parentDependency.getType().getStringValue();\n\n                if (!StringUtil.isEmptyOrSpaces(typeValue)) {\n                  dependency.getType().setStringValue(typeValue);\n                }\n                dependency.getVersion().undefine();\n              }\n            }\n          }\n        }.execute().getResultObject();\n      }\n\n      return null;\n    }","commit_id":"ffffba8eb1fc68d8d3c1141e252af0cb20105577","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static Set<MavenDomDependency> collectManagingDependencies(@NotNull final MavenDomProjectModel model) {\n    final Set<MavenDomDependency> dependencies = new HashSet<MavenDomDependency>();\n\n    final List<MavenDomDependency> existingDependencies = model.getDependencies().getDependencies();\n\n    Processor<MavenDomDependencies> collectProcessor = new Processor<MavenDomDependencies>() {\n      public boolean process(MavenDomDependencies mavenDomDependencies) {\n        if (!model.equals(mavenDomDependencies.getParentOfType(MavenDomProjectModel.class, true))) {\n          for (MavenDomDependency dependency : mavenDomDependencies.getDependencies()) {\n            String groupId = dependency.getGroupId().getStringValue();\n            String artifactId = dependency.getArtifactId().getStringValue();\n            if (StringUtil.isEmptyOrSpaces(groupId) || StringUtil.isEmptyOrSpaces(artifactId)) continue;\n\n            if (!isDependencyExist(groupId, artifactId, existingDependencies)) {\n              dependencies.add(dependency);\n            }\n          }\n        }\n        return false;\n      }\n    };\n\n    MavenDomProjectProcessorUtils.processDependenciesInDependencyManagement(model, collectProcessor, model.getManager().getProject());\n\n    return dependencies;\n  }","id":97244,"modified_method":"@NotNull\n  public static Collection<MavenDomDependency> collectManagingDependencies(@NotNull final MavenDomProjectModel model) {\n    final Map<DependencyConflictId, MavenDomDependency> dependencies = new HashMap<DependencyConflictId, MavenDomDependency>();\n\n    final Set<DependencyConflictId> existingDependencies = new HashSet<DependencyConflictId>();\n    for (MavenDomDependency dependency : model.getDependencies().getDependencies()) {\n      DependencyConflictId id = DependencyConflictId.create(dependency);\n      if (id != null) {\n        existingDependencies.add(id);\n      }\n    }\n\n    Processor<MavenDomDependency> collectProcessor = new Processor<MavenDomDependency>() {\n      public boolean process(MavenDomDependency dependency) {\n        if (!model.equals(dependency.getParentOfType(MavenDomProjectModel.class, true))) {\n          DependencyConflictId id = DependencyConflictId.create(dependency);\n          if (id != null && !existingDependencies.contains(id) && !dependencies.containsKey(id)) {\n            dependencies.put(id, dependency);\n          }\n        }\n        return false;\n      }\n    };\n\n    MavenDomProjectProcessorUtils.processDependenciesInDependencyManagement(model, collectProcessor, model.getManager().getProject());\n\n    return dependencies.values();\n  }","commit_id":"ffffba8eb1fc68d8d3c1141e252af0cb20105577","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean processDependenciesInDependencyManagement(@NotNull MavenDomProjectModel projectDom,\n                                                                  @NotNull final Processor<MavenDomDependencies> processor,\n                                                                  @NotNull final Project project) {\n\n    Function<MavenDomProjectModelBase, MavenDomDependencies> domFunction = new Function<MavenDomProjectModelBase, MavenDomDependencies>() {\n      public MavenDomDependencies fun(MavenDomProjectModelBase mavenDomProfile) {\n        return mavenDomProfile.getDependencyManagement().getDependencies();\n      }\n    };\n\n    return process(projectDom, processor, project, domFunction, domFunction);\n  }","id":97245,"modified_method":"public static boolean processDependenciesInDependencyManagement(@NotNull MavenDomProjectModel projectDom,\n                                                                  @NotNull final Processor<MavenDomDependency> processor,\n                                                                  @NotNull final Project project) {\n\n    Processor<MavenDomDependencies> managedDependenciesListProcessor = new Processor<MavenDomDependencies>() {\n      @Override\n      public boolean process(MavenDomDependencies dependencies) {\n        SmartList<MavenDomDependency> importDependencies = null;\n\n        for (MavenDomDependency domDependency : dependencies.getDependencies()) {\n          if (\"import\".equals(domDependency.getScope().getRawText())) {\n            if (importDependencies == null) {\n              importDependencies = new SmartList<MavenDomDependency>();\n            }\n\n            importDependencies.add(domDependency);\n          }\n          else {\n            if (processor.process(domDependency)) return true;\n          }\n        }\n\n        if (importDependencies != null) {\n          for (MavenDomDependency domDependency : importDependencies) {\n            GenericDomValue<String> version = domDependency.getVersion();\n            if (version.getXmlElement() != null) {\n              GenericDomValueReference reference = new GenericDomValueReference(version);\n              PsiElement resolve = reference.resolve();\n\n              if (resolve instanceof XmlFile) {\n                MavenDomProjectModel dependModel = MavenDomUtil.getMavenDomModel((PsiFile)resolve, MavenDomProjectModel.class);\n                if (dependModel != null) {\n                  for (MavenDomDependency dep : dependModel.getDependencyManagement().getDependencies().getDependencies()) {\n                    if (processor.process(dep)) return true;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        return false;\n      }\n    };\n\n    Function<MavenDomProjectModelBase, MavenDomDependencies> domFunction = new Function<MavenDomProjectModelBase, MavenDomDependencies>() {\n      public MavenDomDependencies fun(MavenDomProjectModelBase mavenDomProfile) {\n        return mavenDomProfile.getDependencyManagement().getDependencies();\n      }\n    };\n\n    return process(projectDom, managedDependenciesListProcessor, project, domFunction, domFunction);\n  }","commit_id":"ffffba8eb1fc68d8d3c1141e252af0cb20105577","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static MavenDomDependency searchManagingDependency(@NotNull final MavenDomDependency dependency, @NotNull final Project project) {\n    final DependencyConflictId depId = DependencyConflictId.create(dependency);\n    if (depId == null) return null;\n\n    final MavenDomProjectModel model = dependency.getParentOfType(MavenDomProjectModel.class, false);\n    if (model == null) return null;\n\n    SearchProcessor<MavenDomDependency, MavenDomDependencies> processor = new SearchProcessor<MavenDomDependency, MavenDomDependencies>() {\n      @Override\n      protected MavenDomDependency find(MavenDomDependencies mavenDomDependencies) {\n        for (MavenDomDependency domDependency : mavenDomDependencies.getDependencies()) {\n          if (depId.equals(DependencyConflictId.create(domDependency))) {\n            return domDependency;\n          }\n\n          if (\"import\".equals(domDependency.getScope().getRawText())) {\n            GenericDomValue<String> version = domDependency.getVersion();\n            if (version.getXmlElement() != null) {\n              GenericDomValueReference reference = new GenericDomValueReference(version);\n              PsiElement resolve = reference.resolve();\n\n              if (resolve instanceof XmlFile) {\n                MavenDomProjectModel dependModel = MavenDomUtil.getMavenDomModel((PsiFile)resolve, MavenDomProjectModel.class);\n                if (dependModel != null) {\n                  for (MavenDomDependency dep : dependModel.getDependencyManagement().getDependencies().getDependencies()) {\n                    if (depId.equals(DependencyConflictId.create(dep))) {\n                      return domDependency;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        return null;\n      }\n    };\n\n    processDependenciesInDependencyManagement(model, processor, project);\n\n    return processor.myResult;\n  }","id":97246,"modified_method":"@Nullable\n  public static MavenDomDependency searchManagingDependency(@NotNull final MavenDomDependency dependency, @NotNull final Project project) {\n    final DependencyConflictId depId = DependencyConflictId.create(dependency);\n    if (depId == null) return null;\n\n    final MavenDomProjectModel model = dependency.getParentOfType(MavenDomProjectModel.class, false);\n    if (model == null) return null;\n\n    final Ref<MavenDomDependency> res = new Ref<MavenDomDependency>();\n\n    Processor<MavenDomDependency> processor = new Processor<MavenDomDependency>() {\n      @Override\n      public boolean process(MavenDomDependency dependency) {\n        if (depId.equals(DependencyConflictId.create(dependency))) {\n          res.set(dependency);\n          return true;\n        }\n\n        return false;\n      }\n    };\n\n    processDependenciesInDependencyManagement(model, processor, project);\n\n    return res.get();\n  }","commit_id":"ffffba8eb1fc68d8d3c1141e252af0cb20105577","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tpublic void render(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows IOException, PortletException {\n\n\t\ttry {\n\t\t\tint status = getStatus(renderRequest);\n\n\t\t\trenderRequest.setAttribute(WebKeys.KNOWLEDGE_BASE_STATUS, status);\n\n\t\t\tKBArticle kbArticle = null;\n\n\t\t\tlong resourcePrimKey = getResourcePrimKey(renderRequest);\n\n\t\t\tif (resourcePrimKey > 0) {\n\t\t\t\tkbArticle = KBArticleServiceUtil.getLatestKBArticle(\n\t\t\t\t\tresourcePrimKey, status);\n\t\t\t}\n\n\t\t\trenderRequest.setAttribute(\n\t\t\t\tWebKeys.KNOWLEDGE_BASE_KB_ARTICLE, kbArticle);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchArticleException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(renderRequest, e.getClass());\n\n\t\t\t\tPortletConfig portletConfig = getPortletConfig();\n\n\t\t\t\tSessionMessages.add(\n\t\t\t\t\trenderRequest,\n\t\t\t\t\tportletConfig.getPortletName() +\n\t\t\t\t\t\tSessionMessages.KEY_SUFFIX_HIDE_DEFAULT_ERROR_MESSAGE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new PortletException(e);\n\t\t\t}\n\t\t}\n\n\t\tsuper.render(renderRequest, renderResponse);\n\t}","id":97247,"modified_method":"@Override\n\tpublic void render(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows IOException, PortletException {\n\n\t\ttry {\n\t\t\tint status = getStatus(renderRequest);\n\n\t\t\trenderRequest.setAttribute(WebKeys.KNOWLEDGE_BASE_STATUS, status);\n\n\t\t\tKBArticle kbArticle = null;\n\n\t\t\tlong resourcePrimKey = getResourcePrimKey(renderRequest);\n\n\t\t\tif (resourcePrimKey > 0) {\n\t\t\t\tkbArticle = KBArticleServiceUtil.getLatestKBArticle(\n\t\t\t\t\tresourcePrimKey, status);\n\t\t\t}\n\n\t\t\trenderRequest.setAttribute(\n\t\t\t\tWebKeys.KNOWLEDGE_BASE_KB_ARTICLE, kbArticle);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchArticleException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(renderRequest, e.getClass());\n\n\t\t\t\tLiferayPortletConfig liferayPortletConfig =\n\t\t\t\t\t(LiferayPortletConfig)getPortletConfig();\n\n\t\t\t\tSessionMessages.add(\n\t\t\t\t\trenderRequest,\n\t\t\t\t\tliferayPortletConfig.getPortletId() +\n\t\t\t\t\t\tSessionMessages.KEY_SUFFIX_HIDE_DEFAULT_ERROR_MESSAGE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new PortletException(e);\n\t\t\t}\n\t\t}\n\n\t\tsuper.render(renderRequest, renderResponse);\n\t}","commit_id":"736997e98011501dd325c9bbb9600e90066a71df","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void doProcessAction(\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tLayout layout = themeDisplay.getLayout();\n\n\t\tJSONObject userPrefsJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\tMap<String, UserPref> userPrefs = getUserPrefs(\n\t\t\tportletConfig, actionRequest);\n\n\t\tfor (UserPref userPref : userPrefs.values()) {\n\t\t\tString name = userPref.getName();\n\n\t\t\tString value = ParamUtil.getString(actionRequest, name);\n\n\t\t\tuserPrefsJSONObject.put(name, value);\n\t\t}\n\n\t\tString namespace = ShindigUtil.getPortletResourceNamespace(\n\t\t\tactionRequest, themeDisplay);\n\n\t\tString columnName = ShindigUtil.getColumnUserPrefs(\n\t\t\tnamespace, themeDisplay);\n\n\t\tExpandoValueServiceUtil.addValue(\n\t\t\tthemeDisplay.getCompanyId(), Layout.class.getName(),\n\t\t\tShindigUtil.getTableOpenSocial(), columnName, layout.getPlid(),\n\t\t\tuserPrefsJSONObject.toString());\n\n\t\tString portletResource = ParamUtil.getString(\n\t\t\tactionRequest, \"portletResource\");\n\n\t\tSessionMessages.add(\n\t\t\tactionRequest,\n\t\t\tportletConfig.getPortletName() +\n\t\t\t\tSessionMessages.KEY_SUFFIX_REFRESH_PORTLET,\n\t\t\tportletResource);\n\n\t\tSessionMessages.add(\n\t\t\tactionRequest,\n\t\t\tportletConfig.getPortletName() +\n\t\t\t\tSessionMessages.KEY_SUFFIX_UPDATED_CONFIGURATION);\n\t}","id":97248,"modified_method":"protected void doProcessAction(\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tLayout layout = themeDisplay.getLayout();\n\n\t\tJSONObject userPrefsJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\tMap<String, UserPref> userPrefs = getUserPrefs(\n\t\t\tportletConfig, actionRequest);\n\n\t\tfor (UserPref userPref : userPrefs.values()) {\n\t\t\tString name = userPref.getName();\n\n\t\t\tString value = ParamUtil.getString(actionRequest, name);\n\n\t\t\tuserPrefsJSONObject.put(name, value);\n\t\t}\n\n\t\tString namespace = ShindigUtil.getPortletResourceNamespace(\n\t\t\tactionRequest, themeDisplay);\n\n\t\tString columnName = ShindigUtil.getColumnUserPrefs(\n\t\t\tnamespace, themeDisplay);\n\n\t\tExpandoValueServiceUtil.addValue(\n\t\t\tthemeDisplay.getCompanyId(), Layout.class.getName(),\n\t\t\tShindigUtil.getTableOpenSocial(), columnName, layout.getPlid(),\n\t\t\tuserPrefsJSONObject.toString());\n\n\t\tLiferayPortletConfig liferayPortletConfig =\n\t\t\t(LiferayPortletConfig)portletConfig;\n\n\t\tString portletResource = ParamUtil.getString(\n\t\t\tactionRequest, \"portletResource\");\n\n\t\tSessionMessages.add(\n\t\t\tactionRequest,\n\t\t\tliferayPortletConfig.getPortletId() +\n\t\t\t\tSessionMessages.KEY_SUFFIX_REFRESH_PORTLET,\n\t\t\tportletResource);\n\n\t\tSessionMessages.add(\n\t\t\tactionRequest,\n\t\t\tliferayPortletConfig.getPortletId() +\n\t\t\t\tSessionMessages.KEY_SUFFIX_UPDATED_CONFIGURATION);\n\t}","commit_id":"736997e98011501dd325c9bbb9600e90066a71df","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString tabs2 = ParamUtil.get(actionRequest, \"tabs2\", \"gadget\");\n\n\t\tif (tabs2.equals(\"manage-oauth\")) {\n\t\t\tShindigUtil.updateOAuthConsumers(actionRequest, actionResponse);\n\n\t\t\tString portletResource = ParamUtil.getString(\n\t\t\t\tactionRequest, \"portletResource\");\n\n\t\t\tSessionMessages.add(\n\t\t\t\tactionRequest,\n\t\t\t\tportletConfig.getPortletName() +\n\t\t\t\t\tSessionMessages.KEY_SUFFIX_REFRESH_PORTLET,\n\t\t\t\tportletResource);\n\n\t\t\tSessionMessages.add(\n\t\t\t\tactionRequest,\n\t\t\t\tportletConfig.getPortletName() +\n\t\t\t\t\tSessionMessages.KEY_SUFFIX_UPDATED_CONFIGURATION);\n\t\t}\n\t\telse if (tabs2.equals(\"preferences\")) {\n\t\t\tdoProcessAction(portletConfig, actionRequest, actionResponse);\n\t\t}\n\t\telse {\n\t\t\tString url = getParameter(actionRequest, \"url\");\n\n\t\t\ttry {\n\t\t\t\tShindigUtil.getGadgetSpec(url, false, true);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\n\t\t\tsetPreference(actionRequest, \"url\", url);\n\n\t\t\tsuper.processAction(portletConfig, actionRequest, actionResponse);\n\t\t}\n\t}","id":97249,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tPortletConfig portletConfig, ActionRequest actionRequest,\n\t\t\tActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString tabs2 = ParamUtil.get(actionRequest, \"tabs2\", \"gadget\");\n\n\t\tif (tabs2.equals(\"manage-oauth\")) {\n\t\t\tShindigUtil.updateOAuthConsumers(actionRequest, actionResponse);\n\n\t\t\tLiferayPortletConfig liferayPortletConfig =\n\t\t\t\t(LiferayPortletConfig)portletConfig;\n\n\t\t\tString portletResource = ParamUtil.getString(\n\t\t\t\tactionRequest, \"portletResource\");\n\n\t\t\tSessionMessages.add(\n\t\t\t\tactionRequest,\n\t\t\t\tliferayPortletConfig.getPortletId() +\n\t\t\t\t\tSessionMessages.KEY_SUFFIX_REFRESH_PORTLET,\n\t\t\t\tportletResource);\n\n\t\t\tSessionMessages.add(\n\t\t\t\tactionRequest,\n\t\t\t\tliferayPortletConfig.getPortletId() +\n\t\t\t\t\tSessionMessages.KEY_SUFFIX_UPDATED_CONFIGURATION);\n\t\t}\n\t\telse if (tabs2.equals(\"preferences\")) {\n\t\t\tdoProcessAction(portletConfig, actionRequest, actionResponse);\n\t\t}\n\t\telse {\n\t\t\tString url = getParameter(actionRequest, \"url\");\n\n\t\t\ttry {\n\t\t\t\tShindigUtil.getGadgetSpec(url, false, true);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\n\t\t\tsetPreference(actionRequest, \"url\", url);\n\n\t\t\tsuper.processAction(portletConfig, actionRequest, actionResponse);\n\t\t}\n\t}","commit_id":"736997e98011501dd325c9bbb9600e90066a71df","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tPortletMode portletMode = actionRequest.getPortletMode();\n\n\t\tif (!portletMode.equals(PortletMode.EDIT)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString language = ParamUtil.getString(actionRequest, \"language\");\n\n\t\tPortletPreferences preferences = actionRequest.getPreferences();\n\n\t\tpreferences.setValue(\"language\", language);\n\n\t\tpreferences.store();\n\n\t\tPortletConfig portletConfig = getPortletConfig();\n\n\t\tSessionMessages.add(\n\t\t\tactionRequest,\n\t\t\tportletConfig.getPortletName() +\n\t\t\t\tSessionMessages.KEY_SUFFIX_UPDATED_PREFERENCES);\n\t}","id":97250,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tPortletMode portletMode = actionRequest.getPortletMode();\n\n\t\tif (!portletMode.equals(PortletMode.EDIT)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString language = ParamUtil.getString(actionRequest, \"language\");\n\n\t\tPortletPreferences preferences = actionRequest.getPreferences();\n\n\t\tpreferences.setValue(\"language\", language);\n\n\t\tpreferences.store();\n\n\t\tLiferayPortletConfig liferayPortletConfig =\n\t\t\t(LiferayPortletConfig)getPortletConfig();\n\n\t\tSessionMessages.add(\n\t\t\tactionRequest,\n\t\t\tliferayPortletConfig.getPortletId() +\n\t\t\t\tSessionMessages.KEY_SUFFIX_UPDATED_PREFERENCES);\n\t}","commit_id":"736997e98011501dd325c9bbb9600e90066a71df","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void updatePreferences(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences = actionRequest.getPreferences();\n\n\t\tString[] symbols = StringUtil.split(\n\t\t\tParamUtil.getString(actionRequest, \"symbols\").toUpperCase(),\n\t\t\tStringPool.SPACE);\n\n\t\tArrays.sort(symbols);\n\n\t\tpreferences.setValues(\"symbols\", symbols);\n\n\t\ttry {\n\t\t\tpreferences.store();\n\t\t}\n\t\tcatch (ValidatorException ve) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, ValidatorException.class.getName(), ve);\n\n\t\t\treturn;\n\t\t}\n\n\t\tPortletConfig portletConfig = getPortletConfig();\n\n\t\tSessionMessages.add(\n\t\t\tactionRequest,\n\t\t\tportletConfig.getPortletName() +\n\t\t\t\tSessionMessages.KEY_SUFFIX_UPDATED_PREFERENCES);\n\t}","id":97251,"modified_method":"protected void updatePreferences(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences = actionRequest.getPreferences();\n\n\t\tString[] symbols = StringUtil.split(\n\t\t\tParamUtil.getString(actionRequest, \"symbols\").toUpperCase(),\n\t\t\tStringPool.SPACE);\n\n\t\tArrays.sort(symbols);\n\n\t\tpreferences.setValues(\"symbols\", symbols);\n\n\t\ttry {\n\t\t\tpreferences.store();\n\t\t}\n\t\tcatch (ValidatorException ve) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, ValidatorException.class.getName(), ve);\n\n\t\t\treturn;\n\t\t}\n\n\t\tLiferayPortletConfig liferayPortletConfig =\n\t\t\t(LiferayPortletConfig)getPortletConfig();\n\n\t\tSessionMessages.add(\n\t\t\tactionRequest,\n\t\t\tliferayPortletConfig.getPortletId() +\n\t\t\t\tSessionMessages.KEY_SUFFIX_UPDATED_PREFERENCES);\n\t}","commit_id":"736997e98011501dd325c9bbb9600e90066a71df","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void updatePreferences(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences = actionRequest.getPreferences();\n\n\t\tString[] zips = StringUtil.split(\n\t\t\tParamUtil.getString(actionRequest, \"zips\"), \"\\n\");\n\n\t\tboolean fahrenheit = ParamUtil.get(actionRequest, \"fahrenheit\", true);\n\n\t\tpreferences.setValues(\"zips\", zips);\n\t\tpreferences.setValue(\"fahrenheit\", String.valueOf(fahrenheit));\n\n\t\ttry {\n\t\t\tpreferences.store();\n\t\t}\n\t\tcatch (ValidatorException ve) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, ValidatorException.class.getName(), ve);\n\n\t\t\treturn;\n\t\t}\n\n\t\tPortletConfig portletConfig = getPortletConfig();\n\n\t\tSessionMessages.add(\n\t\t\tactionRequest,\n\t\t\tportletConfig.getPortletName() +\n\t\t\t\tSessionMessages.KEY_SUFFIX_UPDATED_PREFERENCES);\n\t}","id":97252,"modified_method":"protected void updatePreferences(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences = actionRequest.getPreferences();\n\n\t\tString[] zips = StringUtil.split(\n\t\t\tParamUtil.getString(actionRequest, \"zips\"), \"\\n\");\n\n\t\tboolean fahrenheit = ParamUtil.get(actionRequest, \"fahrenheit\", true);\n\n\t\tpreferences.setValues(\"zips\", zips);\n\t\tpreferences.setValue(\"fahrenheit\", String.valueOf(fahrenheit));\n\n\t\ttry {\n\t\t\tpreferences.store();\n\t\t}\n\t\tcatch (ValidatorException ve) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, ValidatorException.class.getName(), ve);\n\n\t\t\treturn;\n\t\t}\n\n\t\tLiferayPortletConfig liferayPortletConfig =\n\t\t\t(LiferayPortletConfig)getPortletConfig();\n\n\t\tSessionMessages.add(\n\t\t\tactionRequest,\n\t\t\tliferayPortletConfig.getPortletId() +\n\t\t\t\tSessionMessages.KEY_SUFFIX_UPDATED_PREFERENCES);\n\t}","commit_id":"736997e98011501dd325c9bbb9600e90066a71df","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Transient\n\tpublic OnmsIpInterface getPrimaryInterface() {\n\t\tfor(OnmsIpInterface iface : getIpInterfaces()) {\n\t\t\tif (iface.getIsSnmpPrimary() == PrimaryType.PRIMARY) {\n\t\t\t\treturn iface;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":97253,"modified_method":"@Transient\n\tpublic OnmsIpInterface getPrimaryInterface() {\n\t\tfor(OnmsIpInterface iface : getIpInterfaces()) {\n\t\t    PrimaryType type = iface.getIsSnmpPrimary();\n//\t\t    if (iface.getIsSnmpPrimary() == PrimaryType.PRIMARY) {\n\t\t\tif (PrimaryType.PRIMARY.equals(iface.getIsSnmpPrimary())) {\n\t\t\t\treturn iface;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"b371bcec7992d95e64f55746bdef20bf938574ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Transient\n\tpublic OnmsIpInterface getPrimaryInterface() {\n\t\tfor(OnmsIpInterface iface : getIpInterfaces()) {\n\t\t\tif (iface.getIsSnmpPrimary() == PrimaryType.PRIMARY) {\n\t\t\t\treturn iface;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":97254,"modified_method":"@Transient\n\tpublic OnmsIpInterface getPrimaryInterface() {\n\t\tfor(OnmsIpInterface iface : getIpInterfaces()) {\n\t\t    PrimaryType type = iface.getIsSnmpPrimary();\n//\t\t    if (iface.getIsSnmpPrimary() == PrimaryType.PRIMARY) {\n\t\t\tif (PrimaryType.PRIMARY.equals(iface.getIsSnmpPrimary())) {\n\t\t\t\treturn iface;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"42f75cf093fbc571467b5ea1a5a20a6378291638","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Transient\n\tpublic OnmsIpInterface getPrimaryInterface() {\n\t\tfor(OnmsIpInterface iface : getIpInterfaces()) {\n\t\t\tif (iface.getIsSnmpPrimary() == PrimaryType.PRIMARY) {\n\t\t\t\treturn iface;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":97255,"modified_method":"@Transient\n\tpublic OnmsIpInterface getPrimaryInterface() {\n\t\tfor(OnmsIpInterface iface : getIpInterfaces()) {\n\t\t    PrimaryType type = iface.getIsSnmpPrimary();\n//\t\t    if (iface.getIsSnmpPrimary() == PrimaryType.PRIMARY) {\n\t\t\tif (PrimaryType.PRIMARY.equals(iface.getIsSnmpPrimary())) {\n\t\t\t\treturn iface;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"2780f9536d1e864510fc03e65ddd9268d6f4a1ec","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public AjanisChosen(UUID ownerId) {\r\n        super(ownerId, 2, \"Ajani's Chosen\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{2}{W}{W}\");\r\n        this.expansionSetCode = \"M14\";\r\n        this.subtype.add(\"Cat\");\r\n        this.subtype.add(\"Soldier\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(3);\r\n        this.toughness = new MageInt(3);\r\n\r\n        // Whenever an enchantment enters the battlefield under your control, put a 2/2 white Cat creature token onto the battlefield. If that enchantment is an Aura, you may attach it to the token.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD, new AjanisChosenEffect(), filter, false, true, \"Whenever an enchantment enters the battlefield under your control, put a 2/2 white Cat creature token onto the battlefield. If that enchantment is an Aura, you may attach it to the token\"));\r\n    }","id":97256,"modified_method":"public AjanisChosen(UUID ownerId) {\r\n        super(ownerId, 2, \"Ajani's Chosen\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{2}{W}{W}\");\r\n        this.expansionSetCode = \"M14\";\r\n        this.subtype.add(\"Cat\");\r\n        this.subtype.add(\"Soldier\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(3);\r\n        this.toughness = new MageInt(3);\r\n\r\n        // Whenever an enchantment enters the battlefield under your control, put a 2/2 white Cat creature token onto the battlefield. If that enchantment is an Aura, you may attach it to the token.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new AjanisChosenEffect(), filter, false, SetTargetPointer.PERMANENT,\r\n                \"Whenever an enchantment enters the battlefield under your control, put a 2/2 white Cat creature token onto the battlefield. If that enchantment is an Aura, you may attach it to the token\"));\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public CloakAndDagger(UUID ownerId) {\r\n        super(ownerId, 141, \"Cloak and Dagger\", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.ARTIFACT}, \"{2}\");\r\n        this.expansionSetCode = \"MOR\";\r\n        this.subtype.add(\"Rogue\");\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature gets +2/+0 and has shroud.\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 0));\r\n        ability.addEffect(new GainAbilityAttachedEffect(ShroudAbility.getInstance(), AttachmentType.EQUIPMENT));\r\n        this.addAbility(ability);\r\n        // Whenever a Rogue creature enters the battlefield, you may attach Cloak and Dagger to it.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new AttachEffect(Outcome.Detriment, \"attach {source} to it\"),\r\n                filter, true, true, null));\r\n        // Equip {3}\r\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));\r\n    }","id":97257,"modified_method":"public CloakAndDagger(UUID ownerId) {\r\n        super(ownerId, 141, \"Cloak and Dagger\", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.ARTIFACT}, \"{2}\");\r\n        this.expansionSetCode = \"MOR\";\r\n        this.subtype.add(\"Rogue\");\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature gets +2/+0 and has shroud.\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 0));\r\n        ability.addEffect(new GainAbilityAttachedEffect(ShroudAbility.getInstance(), AttachmentType.EQUIPMENT));\r\n        this.addAbility(ability);\r\n        // Whenever a Rogue creature enters the battlefield, you may attach Cloak and Dagger to it.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new AttachEffect(Outcome.Detriment, \"attach {source} to it\"),\r\n                filter, true, SetTargetPointer.PERMANENT, null));\r\n        // Equip {3}\r\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public CloudstoneCurio(UUID ownerId) {\r\n        super(ownerId, 257, \"Cloudstone Curio\", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, \"{3}\");\r\n        this.expansionSetCode = \"RAV\";\r\n\r\n        // Whenever a nonartifact permanent enters the battlefield under your control, you may return another permanent you control that shares a card type with it to its owner's hand.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD, new CloudstoneCurioEffect(), filter, true, true, \"\", true));\r\n\r\n\r\n    }","id":97258,"modified_method":"public CloudstoneCurio(UUID ownerId) {\r\n        super(ownerId, 257, \"Cloudstone Curio\", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, \"{3}\");\r\n        this.expansionSetCode = \"RAV\";\r\n\r\n        // Whenever a nonartifact permanent enters the battlefield under your control, you may return another permanent you control that shares a card type with it to its owner's hand.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD, new CloudstoneCurioEffect(), filter, true, SetTargetPointer.PERMANENT, \"\", true));\r\n\r\n\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent triggeringCreature = game.getPermanent(getTargetPointer().getFirst(game, source));\r\n        if (triggeringCreature == null) {\r\n            triggeringCreature = (Permanent) game.getLastKnownInformation(getTargetPointer().getFirst(game, source), Zone.BATTLEFIELD);\r\n        }\r\n        if (triggeringCreature != null) {\r\n            FilterPermanent filter = new FilterPermanent(\"another permanent you control that shares a card type with \" + triggeringCreature.getName());\r\n            filter.add(Predicates.not(new PermanentIdPredicate(triggeringCreature.getId())));\r\n            filter.add(new ControllerPredicate(TargetController.YOU));\r\n            Set<CardTypePredicate> cardTypes = new HashSet<CardTypePredicate>();\r\n            for (CardType cardType :triggeringCreature.getCardType()) {\r\n                cardTypes.add(new CardTypePredicate(cardType));\r\n            }\r\n            filter.add(Predicates.or(cardTypes));\r\n            TargetPermanent target = new TargetPermanent(1,1,filter, true);\r\n            Player controller = game.getPlayer(source.getControllerId());\r\n            if (controller != null) {\r\n                if (target.canChoose(controller.getId(), game) && controller.chooseTarget(outcome, target, source, game)) {\r\n                    Permanent returningCreature = game.getPermanent(target.getFirstTarget());\r\n                    if (returningCreature != null) {\r\n                        if (returningCreature.moveToZone(Zone.HAND, source.getSourceId(), game, true)) {\r\n                            game.informPlayers(new StringBuilder(\"Cloudstone Curio: Returning \").append(returningCreature.getName()).append(\" to owner's hand\").toString());\r\n                            return true;\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n        return false;\r\n    }","id":97259,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            Permanent triggeringCreature = game.getPermanent(getTargetPointer().getFirst(game, source));\r\n            if (triggeringCreature == null) {\r\n                triggeringCreature = (Permanent) game.getLastKnownInformation(getTargetPointer().getFirst(game, source), Zone.BATTLEFIELD);\r\n            }\r\n            if (triggeringCreature != null) {\r\n                FilterPermanent filter = new FilterPermanent(\"another permanent you control that shares a card type with \" + triggeringCreature.getName());\r\n                filter.add(Predicates.not(new PermanentIdPredicate(triggeringCreature.getId())));\r\n                filter.add(new ControllerPredicate(TargetController.YOU));\r\n                Set<CardTypePredicate> cardTypes = new HashSet<>();\r\n                for (CardType cardType : triggeringCreature.getCardType()) {\r\n                    cardTypes.add(new CardTypePredicate(cardType));\r\n                }\r\n                filter.add(Predicates.or(cardTypes));\r\n                TargetPermanent target = new TargetPermanent(1, 1, filter, true);\r\n\r\n                if (target.canChoose(controller.getId(), game) && controller.chooseTarget(outcome, target, source, game)) {\r\n                    Permanent returningCreature = game.getPermanent(target.getFirstTarget());\r\n                    if (returningCreature != null) {\r\n                        controller.moveCardToHandWithInfo(returningCreature, source.getSourceId(), game, Zone.BATTLEFIELD);\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public DivinersWand(UUID ownerId) {\r\n        super(ownerId, 142, \"Diviner's Wand\", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.ARTIFACT}, \"{3}\");\r\n        this.expansionSetCode = \"MOR\";\r\n        this.subtype.add(\"Wizard\");\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature has \"Whenever you draw a card, this creature gets +1/+1 and gains flying until end of turn\" and \"{4}: Draw a card.\"\r\n        Ability gainedAbility = new DrawCardControllerTriggeredAbility(new BoostSourceEffect(1,1, Duration.EndOfTurn), false);\r\n        gainedAbility.addEffect(new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn));\r\n        Effect effect = new GainAbilityAttachedEffect(gainedAbility, AttachmentType.EQUIPMENT);\r\n        effect.setText(\"Equipped creature has \\\"Whenever you draw a card, this creature gets +1/+1 and gains flying until end of turn\\\"\");\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);\r\n        effect = new GainAbilityAttachedEffect(\r\n                new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new GenericManaCost(4)), AttachmentType.EQUIPMENT);\r\n        effect.setText(\"and \\\"{4}: Draw a card.\\\"\");\r\n        ability.addEffect(effect);\r\n        this.addAbility(ability);\r\n\r\n        // Whenever a Wizard creature enters the battlefield, you may attach Diviner's Wand to it.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new AttachEffect(Outcome.Detriment, \"attach {source} to it\"),\r\n                filter, true, true, null));\r\n        // Equip {3}\r\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));\r\n    }","id":97260,"modified_method":"public DivinersWand(UUID ownerId) {\r\n        super(ownerId, 142, \"Diviner's Wand\", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.ARTIFACT}, \"{3}\");\r\n        this.expansionSetCode = \"MOR\";\r\n        this.subtype.add(\"Wizard\");\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature has \"Whenever you draw a card, this creature gets +1/+1 and gains flying until end of turn\" and \"{4}: Draw a card.\"\r\n        Ability gainedAbility = new DrawCardControllerTriggeredAbility(new BoostSourceEffect(1,1, Duration.EndOfTurn), false);\r\n        gainedAbility.addEffect(new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn));\r\n        Effect effect = new GainAbilityAttachedEffect(gainedAbility, AttachmentType.EQUIPMENT);\r\n        effect.setText(\"Equipped creature has \\\"Whenever you draw a card, this creature gets +1/+1 and gains flying until end of turn\\\"\");\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);\r\n        effect = new GainAbilityAttachedEffect(\r\n                new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new GenericManaCost(4)), AttachmentType.EQUIPMENT);\r\n        effect.setText(\"and \\\"{4}: Draw a card.\\\"\");\r\n        ability.addEffect(effect);\r\n        this.addAbility(ability);\r\n\r\n        // Whenever a Wizard creature enters the battlefield, you may attach Diviner's Wand to it.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new AttachEffect(Outcome.Detriment, \"attach {source} to it\"),\r\n                filter, true, SetTargetPointer.PERMANENT, null));\r\n        // Equip {3}\r\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public EntersBattlefieldAllTriggeredAbility(Zone zone, Effect effect, FilterPermanent filter, boolean optional, String rule, boolean controlled) {\r\n        this(zone, effect, filter, optional, false, rule, controlled);\r\n    }","id":97261,"modified_method":"public EntersBattlefieldAllTriggeredAbility(Zone zone, Effect effect, FilterPermanent filter, boolean optional, String rule, boolean controlled) {\r\n        this(zone, effect, filter, optional, SetTargetPointer.NONE, rule, controlled);\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        if (event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD) {\r\n            UUID targetId = event.getTargetId();\r\n            Permanent permanent = game.getPermanent(targetId);\r\n            if (permanent != null && filter.match(permanent, getSourceId(), getControllerId(), game)) {\r\n                if (setTargetPointer) {\r\n                    for (Effect effect : this.getEffects()) {\r\n                        effect.setTargetPointer(new FixedTarget(event.getTargetId()));\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","id":97262,"modified_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        if (event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD) {\r\n            UUID targetId = event.getTargetId();\r\n            Permanent permanent = game.getPermanent(targetId);\r\n            if (permanent != null && filter.match(permanent, getSourceId(), getControllerId(), game)) {\r\n                if (!setTargetPointer.equals(SetTargetPointer.NONE)) {\r\n                    for (Effect effect : this.getEffects()) {\r\n                        switch(setTargetPointer) {\r\n                            case PERMANENT:\r\n                                effect.setTargetPointer(new FixedTarget(event.getTargetId()));\r\n                                break;\r\n                            case PLAYER:\r\n                                effect.setTargetPointer(new FixedTarget(permanent.getControllerId()));\r\n                                break;\r\n                        }\r\n                        \r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public EntersBattlefieldAllTriggeredAbility(Zone zone, Effect effect, FilterPermanent filter, boolean optional, boolean setTargetPointer, String rule) {\r\n        this(zone, effect, filter, optional, setTargetPointer, rule, false);\r\n    }","id":97263,"modified_method":"public EntersBattlefieldAllTriggeredAbility(Zone zone, Effect effect, FilterPermanent filter, boolean optional, SetTargetPointer setTargetPointer, String rule) {\r\n        this(zone, effect, filter, optional, setTargetPointer, rule, false);\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public EntersBattlefieldAllTriggeredAbility(Zone zone, Effect effect, FilterPermanent filter, boolean optional) {\r\n        this(zone, effect, filter, optional, false, null, false);\r\n    }","id":97264,"modified_method":"public EntersBattlefieldAllTriggeredAbility(Zone zone, Effect effect, FilterPermanent filter, boolean optional) {\r\n        this(zone, effect, filter, optional, SetTargetPointer.NONE, null, false);\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public EntersBattlefieldAllTriggeredAbility(Zone zone, Effect effect, FilterPermanent filter, boolean optional, boolean setTargetPointer, String rule, boolean controlled) {\r\n        super(zone, effect, optional);\r\n        this.filter = filter;\r\n        this.rule = rule;\r\n        this.controlled = controlled;\r\n        this.setTargetPointer = setTargetPointer;\r\n    }","id":97265,"modified_method":"public EntersBattlefieldAllTriggeredAbility(Zone zone, Effect effect, FilterPermanent filter, boolean optional, SetTargetPointer setTargetPointer, String rule, boolean controlled) {\r\n        super(zone, effect, optional);\r\n        this.filter = filter;\r\n        this.rule = rule;\r\n        this.controlled = controlled;\r\n        this.setTargetPointer = setTargetPointer;\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public EntersBattlefieldControlledTriggeredAbility(Zone zone, Effect effect, FilterPermanent filter, boolean optional, String rule) {\r\n        this(zone, effect, filter, optional, false, rule);\r\n    }","id":97266,"modified_method":"public EntersBattlefieldControlledTriggeredAbility(Zone zone, Effect effect, FilterPermanent filter, boolean optional, String rule) {\r\n        this(zone, effect, filter, optional, SetTargetPointer.NONE, rule);\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public EntersBattlefieldControlledTriggeredAbility(Zone zone, Effect effect, FilterPermanent filter, boolean optional, boolean setTargetPointer, String rule) {\r\n        super(zone, effect, filter, optional, setTargetPointer, rule, true);\r\n    }","id":97267,"modified_method":"public EntersBattlefieldControlledTriggeredAbility(Zone zone, Effect effect, FilterPermanent filter, boolean optional, SetTargetPointer setTargetPointer, String rule) {\r\n        super(zone, effect, filter, optional, setTargetPointer, rule, true);\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public GenesisChamberTriggeredAbility(Effect effect, FilterPermanent filter)\r\n    {\r\n        super(Zone.BATTLEFIELD, effect, filter, false, true, rule);\r\n    }","id":97268,"modified_method":"public GenesisChamberTriggeredAbility(Effect effect, FilterPermanent filter)\r\n    {\r\n        super(Zone.BATTLEFIELD, effect, filter, false, SetTargetPointer.PERMANENT, rule);\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public OathOfTheAncientWood(UUID ownerId) {\r\n        super(ownerId, 187, \"Oath of the Ancient Wood\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{2}{G}\");\r\n        this.expansionSetCode = \"M14\";\r\n\r\n        this.color.setGreen(true);\r\n\r\n        // Whenever Oath of the Ancient Wood or another enchantment enters the battlefield under your control, you may put a +1/+1 counter on target creature.\r\n        Effect effect = new AddCountersTargetEffect(CounterType.P1P1.createInstance());\r\n        Ability ability = new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD, effect, filter, true, false, null, true);\r\n        ability.addTarget(new TargetCreaturePermanent());\r\n        this.addAbility(ability);\r\n    }","id":97269,"modified_method":"public OathOfTheAncientWood(UUID ownerId) {\r\n        super(ownerId, 187, \"Oath of the Ancient Wood\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{2}{G}\");\r\n        this.expansionSetCode = \"M14\";\r\n\r\n        this.color.setGreen(true);\r\n\r\n        // Whenever Oath of the Ancient Wood or another enchantment enters the battlefield under your control, you may put a +1/+1 counter on target creature.\r\n        Effect effect = new AddCountersTargetEffect(CounterType.P1P1.createInstance());\r\n        Ability ability = new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD, effect, filter, true, SetTargetPointer.PERMANENT, null, true);\r\n        ability.addTarget(new TargetCreaturePermanent());\r\n        this.addAbility(ability);\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public ObsidianBattleAxe(UUID ownerId) {\r\n        super(ownerId, 144, \"Obsidian Battle-Axe\", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.ARTIFACT}, \"{3}\");\r\n        this.expansionSetCode = \"MOR\";\r\n        this.subtype.add(\"Warrior\");\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature gets +2/+1 and has haste.\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 1));\r\n        ability.addEffect(new GainAbilityAttachedEffect(HasteAbility.getInstance(), AttachmentType.EQUIPMENT));\r\n        this.addAbility(ability);\r\n        // Whenever a Warrior creature enters the battlefield, you may attach Obsidian Battle-Axe to it.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new AttachEffect(Outcome.Detriment, \"attach {source} to it\"),\r\n                filter, true, true, null));\r\n        // Equip {3}\r\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));\r\n    }","id":97270,"modified_method":"public ObsidianBattleAxe(UUID ownerId) {\r\n        super(ownerId, 144, \"Obsidian Battle-Axe\", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.ARTIFACT}, \"{3}\");\r\n        this.expansionSetCode = \"MOR\";\r\n        this.subtype.add(\"Warrior\");\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature gets +2/+1 and has haste.\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 1));\r\n        ability.addEffect(new GainAbilityAttachedEffect(HasteAbility.getInstance(), AttachmentType.EQUIPMENT));\r\n        this.addAbility(ability);\r\n        // Whenever a Warrior creature enters the battlefield, you may attach Obsidian Battle-Axe to it.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new AttachEffect(Outcome.Detriment, \"attach {source} to it\"),\r\n                filter, true, SetTargetPointer.PERMANENT, null));\r\n        // Equip {3}\r\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public OgreBattledriver(UUID ownerId) {\r\n        super(ownerId, 148, \"Ogre Battledriver\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{2}{R}{R}\");\r\n        this.expansionSetCode = \"M14\";\r\n        this.subtype.add(\"Ogre\");\r\n        this.subtype.add(\"Warrior\");\r\n\r\n        this.color.setRed(true);\r\n        this.power = new MageInt(3);\r\n        this.toughness = new MageInt(3);\r\n\r\n        // Whenever another creature enters the battlefield under your control, that creature gets +2/+0 and gains haste until end of turn.\r\n        Ability ability = new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD, new BoostTargetEffect(2, 0, Duration.EndOfTurn), filter, false, true, rule, true);\r\n        ability.addEffect(new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn));\r\n        this.addAbility(ability);\r\n        \r\n    }","id":97271,"modified_method":"public OgreBattledriver(UUID ownerId) {\r\n        super(ownerId, 148, \"Ogre Battledriver\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{2}{R}{R}\");\r\n        this.expansionSetCode = \"M14\";\r\n        this.subtype.add(\"Ogre\");\r\n        this.subtype.add(\"Warrior\");\r\n\r\n        this.color.setRed(true);\r\n        this.power = new MageInt(3);\r\n        this.toughness = new MageInt(3);\r\n\r\n        // Whenever another creature enters the battlefield under your control, that creature gets +2/+0 and gains haste until end of turn.\r\n        Ability ability = new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD, new BoostTargetEffect(2, 0, Duration.EndOfTurn), filter, false, SetTargetPointer.PERMANENT, rule, true);\r\n        ability.addEffect(new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn));\r\n        this.addAbility(ability);\r\n        \r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public PollutedBonds(UUID ownerId) {\r\n        super(ownerId, 74, \"Polluted Bonds\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{3}{B}{B}\");\r\n        this.expansionSetCode = \"SHM\";\r\n\r\n        this.color.setBlack(true);\r\n\r\n        // Whenever a land enters the battlefield under an opponent's control, that player loses 2 life and you gain 2 life.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD, new PollutedBondsEffect(), filter, false, true, rule, true));\r\n        \r\n    }","id":97272,"modified_method":"public PollutedBonds(UUID ownerId) {\r\n        super(ownerId, 74, \"Polluted Bonds\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{3}{B}{B}\");\r\n        this.expansionSetCode = \"SHM\";\r\n\r\n        this.color.setBlack(true);\r\n\r\n        // Whenever a land enters the battlefield under an opponent's control, that player loses 2 life and you gain 2 life.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD, new PollutedBondsEffect(), filter, false, SetTargetPointer.PLAYER, rule, true));\r\n        \r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player you = game.getPlayer(source.getControllerId());\r\n        Player opponent = null;\r\n        Permanent land = game.getPermanent(targetPointer.getFirst(game, source));\r\n        if (land != null) {\r\n            opponent = game.getPlayer(land.getControllerId());\r\n        }\r\n        if (opponent != null) {\r\n            opponent.loseLife(2, game);\r\n        }\r\n        if (you != null) {\r\n            you.gainLife(2, game);\r\n        }\r\n        return true;\r\n    }","id":97273,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            Player opponent = game.getPlayer(getTargetPointer().getFirst(game, source));\r\n            if (opponent != null) {\r\n                opponent.loseLife(2, game);\r\n            }\r\n            controller.gainLife(2, game);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public PrisonTerm(UUID ownerId) {\r\n        super(ownerId, 18, \"Prison Term\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{1}{W}{W}\");\r\n        this.expansionSetCode = \"SHM\";\r\n        this.subtype.add(\"Aura\");\r\n\r\n        this.color.setWhite(true);\r\n\r\n        // Enchant creature\r\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\r\n        this.getSpellAbility().addTarget(auraTarget);\r\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));\r\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\r\n        this.addAbility(ability);\r\n\r\n        // Enchanted creature can't attack or block, and its activated abilities can't be activated.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBlockAttackActivateAttachedEffect()));\r\n\r\n        // Whenever a creature enters the battlefield under an opponent's control, you may attach Prison Term to that creature.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new PrisonTermEffect(), filter, true, true, \"Whenever a creature enters the battlefield under an opponent's control, you may attach Prison Term to that creature.\"));\r\n    }","id":97274,"modified_method":"public PrisonTerm(UUID ownerId) {\r\n        super(ownerId, 18, \"Prison Term\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{1}{W}{W}\");\r\n        this.expansionSetCode = \"SHM\";\r\n        this.subtype.add(\"Aura\");\r\n\r\n        this.color.setWhite(true);\r\n\r\n        // Enchant creature\r\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\r\n        this.getSpellAbility().addTarget(auraTarget);\r\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));\r\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\r\n        this.addAbility(ability);\r\n\r\n        // Enchanted creature can't attack or block, and its activated abilities can't be activated.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBlockAttackActivateAttachedEffect()));\r\n\r\n        // Whenever a creature enters the battlefield under an opponent's control, you may attach Prison Term to that creature.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new PrisonTermEffect(), filter, true, SetTargetPointer.PERMANENT, \"Whenever a creature enters the battlefield under an opponent's control, you may attach Prison Term to that creature.\"));\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public RikuOfTwoReflections(UUID ownerId) {\r\n        super(ownerId, 220, \"Riku of Two Reflections\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{2}{U}{R}{G}\");\r\n        this.expansionSetCode = \"CMD\";\r\n        this.supertype.add(\"Legendary\");\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Wizard\");\r\n\r\n        this.color.setRed(true);\r\n        this.color.setBlue(true);\r\n        this.color.setGreen(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // Whenever you cast an instant or sorcery spell, you may pay {U}{R}. If you do, copy that spell. You may choose new targets for the copy.\r\n        this.addAbility(new SpellCastControllerTriggeredAbility(new DoIfCostPaid(new RikuOfTwoReflectionsCopyEffect(), new ManaCostsImpl(\"{U}{R}\")), filter, false, true));\r\n\r\n        // Whenever another nontoken creature enters the battlefield under your control, you may pay {G}{U}. If you do, put a token that's a copy of that creature onto the battlefield.\r\n        Ability ability = new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new RikuOfTwoReflectionsCopyTokenEffect(),filterPermanent, false, true,\r\n                \"Whenever another nontoken creature enters the battlefield under your control, you may pay {G}{U}. If you do, put a token that's a copy of that creature onto the battlefield.\",\r\n                true);\r\n        ability.addCost(new ManaCostsImpl(\"{G}{U}\"));\r\n        this.addAbility(ability);\r\n    }","id":97275,"modified_method":"public RikuOfTwoReflections(UUID ownerId) {\r\n        super(ownerId, 220, \"Riku of Two Reflections\", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, \"{2}{U}{R}{G}\");\r\n        this.expansionSetCode = \"CMD\";\r\n        this.supertype.add(\"Legendary\");\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Wizard\");\r\n\r\n        this.color.setRed(true);\r\n        this.color.setBlue(true);\r\n        this.color.setGreen(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // Whenever you cast an instant or sorcery spell, you may pay {U}{R}. If you do, copy that spell. You may choose new targets for the copy.\r\n        this.addAbility(new SpellCastControllerTriggeredAbility(new DoIfCostPaid(new RikuOfTwoReflectionsCopyEffect(), new ManaCostsImpl(\"{U}{R}\")), filter, false, true));\r\n\r\n        // Whenever another nontoken creature enters the battlefield under your control, you may pay {G}{U}. If you do, put a token that's a copy of that creature onto the battlefield.\r\n        Ability ability = new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new RikuOfTwoReflectionsCopyTokenEffect(),filterPermanent, false, SetTargetPointer.PERMANENT,\r\n                \"Whenever another nontoken creature enters the battlefield under your control, you may pay {G}{U}. If you do, put a token that's a copy of that creature onto the battlefield.\",\r\n                true);\r\n        ability.addCost(new ManaCostsImpl(\"{G}{U}\"));\r\n        this.addAbility(ability);\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public SaiOfTheShinobi(UUID ownerId) {\r\n        super(ownerId, 113, \"Sai of the Shinobi\", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, \"{1}\");\r\n        this.expansionSetCode = \"PC2\";\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature gets +1/+1.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(1, 1)));\r\n        // Whenever a creature enters the battlefield under your control, you may attach Sai of the Shinobi to it.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new AttachEffect(Outcome.Detriment, \"attach {source} to it\"),\r\n                filter, true, true, \r\n                null, true));\r\n        // Equip {2}\r\n        this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(2)));\r\n    }","id":97276,"modified_method":"public SaiOfTheShinobi(UUID ownerId) {\r\n        super(ownerId, 113, \"Sai of the Shinobi\", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, \"{1}\");\r\n        this.expansionSetCode = \"PC2\";\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature gets +1/+1.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(1, 1)));\r\n        // Whenever a creature enters the battlefield under your control, you may attach Sai of the Shinobi to it.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new AttachEffect(Outcome.Detriment, \"attach {source} to it\"),\r\n                filter, true, SetTargetPointer.PERMANENT, null, true));\r\n        // Equip {2}\r\n        this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(2)));\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public ThornbiteStaff(UUID ownerId) {\r\n        super(ownerId, 145, \"Thornbite Staff\", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.ARTIFACT}, \"{2}\");\r\n        this.expansionSetCode = \"MOR\";\r\n        this.subtype.add(\"Shaman\");\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature has \"{2}, {T}: This creature deals 1 damage to target creature or player\" and \"Whenever a creature dies, untap this creature.\"\r\n        Ability gainedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new GenericManaCost(2));\r\n        gainedAbility.addCost(new TapSourceCost());\r\n        gainedAbility.addTarget(new TargetCreatureOrPlayer());\r\n        Effect effect = new GainAbilityAttachedEffect(gainedAbility, AttachmentType.EQUIPMENT);\r\n        effect.setText(\"Equipped creature has \\\"{2}, {T}: This creature deals 1 damage to target creature or player\\\"\");\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);\r\n        effect = new GainAbilityAttachedEffect(new DiesCreatureTriggeredAbility(new UntapSourceEffect(),false), AttachmentType.EQUIPMENT);\r\n        effect.setText(\"and \\\"Whenever a creature dies, untap this creature.\\\"\");\r\n        ability.addEffect(effect);\r\n        this.addAbility(ability);\r\n        // Whenever a Shaman creature enters the battlefield, you may attach Thornbite Staff to it.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new AttachEffect(Outcome.Detriment, \"attach {source} to it\"),\r\n                filter, true, true, null));\r\n        // Equip {4}\r\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(4)));\r\n    }","id":97277,"modified_method":"public ThornbiteStaff(UUID ownerId) {\r\n        super(ownerId, 145, \"Thornbite Staff\", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.ARTIFACT}, \"{2}\");\r\n        this.expansionSetCode = \"MOR\";\r\n        this.subtype.add(\"Shaman\");\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature has \"{2}, {T}: This creature deals 1 damage to target creature or player\" and \"Whenever a creature dies, untap this creature.\"\r\n        Ability gainedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new GenericManaCost(2));\r\n        gainedAbility.addCost(new TapSourceCost());\r\n        gainedAbility.addTarget(new TargetCreatureOrPlayer());\r\n        Effect effect = new GainAbilityAttachedEffect(gainedAbility, AttachmentType.EQUIPMENT);\r\n        effect.setText(\"Equipped creature has \\\"{2}, {T}: This creature deals 1 damage to target creature or player\\\"\");\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);\r\n        effect = new GainAbilityAttachedEffect(new DiesCreatureTriggeredAbility(new UntapSourceEffect(),false), AttachmentType.EQUIPMENT);\r\n        effect.setText(\"and \\\"Whenever a creature dies, untap this creature.\\\"\");\r\n        ability.addEffect(effect);\r\n        this.addAbility(ability);\r\n        // Whenever a Shaman creature enters the battlefield, you may attach Thornbite Staff to it.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new AttachEffect(Outcome.Detriment, \"attach {source} to it\"),\r\n                filter, true, SetTargetPointer.PERMANENT, null));\r\n        // Equip {4}\r\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(4)));\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"public VeteransArmaments(UUID ownerId) {\r\n        super(ownerId, 146, \"Veteran's Armaments\", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.ARTIFACT}, \"{2}\");\r\n        this.expansionSetCode = \"MOR\";\r\n        this.subtype.add(\"Soldier\");\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature has \"Whenever this creature attacks or blocks, it gets +1/+1 until end of turn for each attacking creature.\"\r\n        DynamicValue attackingCreatures = new AttackingCreatureCount(\"attacking creature\");\r\n        Ability gainedAbility = new AttacksOrBlocksTriggeredAbility(new BoostSourceEffect(attackingCreatures,attackingCreatures, Duration.EndOfTurn),false);\r\n        Effect effect = new GainAbilityAttachedEffect(gainedAbility, AttachmentType.EQUIPMENT);\r\n        effect.setText(\"Equipped creature has \\\"Whenever this creature attacks or blocks, it gets +1/+1 until end of turn for each attacking creature.\\\"\");\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);\r\n        this.addAbility(ability);\r\n\r\n        // Whenever a Soldier creature enters the battlefield, you may attach Veteran's Armaments to it.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new AttachEffect(Outcome.Detriment, \"attach {source} to it\"),\r\n                filter, true, true, null));\r\n        // Equip {2}\r\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2)));\r\n    }","id":97278,"modified_method":"public VeteransArmaments(UUID ownerId) {\r\n        super(ownerId, 146, \"Veteran's Armaments\", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.ARTIFACT}, \"{2}\");\r\n        this.expansionSetCode = \"MOR\";\r\n        this.subtype.add(\"Soldier\");\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature has \"Whenever this creature attacks or blocks, it gets +1/+1 until end of turn for each attacking creature.\"\r\n        DynamicValue attackingCreatures = new AttackingCreatureCount(\"attacking creature\");\r\n        Ability gainedAbility = new AttacksOrBlocksTriggeredAbility(new BoostSourceEffect(attackingCreatures,attackingCreatures, Duration.EndOfTurn),false);\r\n        Effect effect = new GainAbilityAttachedEffect(gainedAbility, AttachmentType.EQUIPMENT);\r\n        effect.setText(\"Equipped creature has \\\"Whenever this creature attacks or blocks, it gets +1/+1 until end of turn for each attacking creature.\\\"\");\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);\r\n        this.addAbility(ability);\r\n\r\n        // Whenever a Soldier creature enters the battlefield, you may attach Veteran's Armaments to it.\r\n        this.addAbility(new EntersBattlefieldAllTriggeredAbility(\r\n                Zone.BATTLEFIELD, new AttachEffect(Outcome.Detriment, \"attach {source} to it\"),\r\n                filter, true, SetTargetPointer.PERMANENT, null));\r\n\r\n        // Equip {2}\r\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2)));\r\n    }","commit_id":"00281f0b1082718650ec1a7642a7a6ca08b2818e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        if (player != null) {\r\n            Cards cards = new CardsImpl(Zone.PICK);\r\n\r\n            boolean properCardFound = false;\r\n            int count = Math.min(player.getLibrary().size(), 5);\r\n            for (int i = 0; i < count; i++) {\r\n                Card card = player.getLibrary().removeFromTop(game);\r\n                if (card != null) {\r\n                    cards.add(card);\r\n                    if (filterPutInHand.match(card, source.getSourceId(), source.getControllerId(), game)) {\r\n                        properCardFound = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!cards.isEmpty()) {\r\n                player.revealCards(\"Grisly Salvage\", cards, game);\r\n                TargetCard target = new TargetCard(Zone.PICK, filterPutInHand);\r\n                if (properCardFound && player.choose(Outcome.DrawCard, cards, target, game)) {\r\n                    Card card = game.getCard(target.getFirstTarget());\r\n                    if (card != null) {\r\n                        cards.remove(card);\r\n                        card.moveToZone(Zone.HAND, source.getSourceId(), game, false);\r\n                    }\r\n\r\n                }\r\n\r\n                for (UUID cardId : cards) {\r\n                    Card card = game.getCard(cardId);\r\n                    if (card != null) {\r\n                        card.moveToZone(Zone.GRAVEYARD, source.getSourceId(), game, true);\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":97279,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = game.getObject(source.getSourceId());\r\n        if (sourceObject != null && controller != null) {\r\n            Cards cards = new CardsImpl();\r\n            cards.addAll(controller.getLibrary().getTopCards(game, 5));\r\n            boolean properCardFound = false;\r\n            for (Card card: cards.getCards(game)) {\r\n                if (filterPutInHand.match(card, source.getSourceId(), source.getControllerId(), game)) {\r\n                    properCardFound = true;\r\n                }\r\n            }\r\n\r\n            if (!cards.isEmpty()) {\r\n                controller.revealCards(sourceObject.getLogName(), cards, game);\r\n                TargetCard target = new TargetCard(Zone.LIBRARY, filterPutInHand);\r\n                if (properCardFound && controller.choose(Outcome.DrawCard, cards, target, game)) {\r\n                    Card card = game.getCard(target.getFirstTarget());\r\n                    if (card != null) {\r\n                        controller.moveCardToHandWithInfo(card, source.getSourceId(), game, Zone.LIBRARY);\r\n                        cards.remove(card);\r\n                    }\r\n                }\r\n                for (Card card : cards.getCards(game)) {\r\n                    controller.moveCardToGraveyardWithInfo(card, source.getSourceId(), game, Zone.LIBRARY);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"47ca2bdc65be46b0d27f8d755d941820473c26ca","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    protected Serializable performSaveOrReplicate(Object entity, EntityKey key, EntityPersister persister, boolean useIdentityColumn, Object anything, EventSource source, boolean requiresImmediateIdAccess) {\n        validate(entity, persister, source);\n\n        Serializable id = key == null ? null : key.getIdentifier();\n\n        boolean inTxn = source.getJDBCContext().isTransactionInProgress();\n        boolean shouldDelayIdentityInserts = !inTxn && !requiresImmediateIdAccess;\n\n        // Put a placeholder in entries, so we don't recurse back and try to save() the\n        // same object again. QUESTION: should this be done before onSave() is called?\n        // likewise, should it be done before onUpdate()?\n        source.getPersistenceContext().addEntry(\n                entity,\n                Status.SAVING,\n                null,\n                null,\n                id,\n                null,\n                LockMode.WRITE,\n                useIdentityColumn,\n                persister,\n                false,\n                false);\n\n        cascadeBeforeSave(source, persister, entity, anything);\n\n        if (useIdentityColumn && !shouldDelayIdentityInserts) {\n            log.trace(\"executing insertions\");\n            source.getActionQueue().executeInserts();\n        }\n\n        Object[] values = persister.getPropertyValuesToInsert(entity, getMergeMap(anything), source);\n        Type[] types = persister.getPropertyTypes();\n\n        boolean substitute = substituteValuesIfNecessary(entity, id, values, persister, source);\n\n        if (persister.hasCollections()) {\n            substitute = substitute || visitCollectionsBeforeSave(entity, id, values, types, source);\n        }\n\n        if (substitute) {\n            persister.setPropertyValues(entity, values, source.getEntityMode());\n        }\n\n        TypeHelper.deepCopy(\n                values,\n                types,\n                persister.getPropertyUpdateability(),\n                values,\n                source);\n\n        new ForeignKeys.Nullifier(entity, false, useIdentityColumn, source)\n                .nullifyTransientReferences(values, types);\n        \n        if (useIdentityColumn) {\n            isNullabilityCheckerAsLastEventListener(source);\n            EntityIdentityInsertAction insert = new EntityIdentityInsertAction(\n                    values, entity, persister, source, shouldDelayIdentityInserts);\n            if (!shouldDelayIdentityInserts) {\n                log.debug(\"executing identity-insert immediately\");\n                source.getActionQueue().execute(insert);\n                id = insert.getGeneratedId();\n                if (id != null) {\n                    // As of HHH-3904, if the id is null the operation was vetoed so we bail\n                    key = new EntityKey(id, persister, source.getEntityMode());\n                    source.getPersistenceContext().checkUniqueness(key, entity);\n                }\n            }\n            else {\n                log.debug(\"delaying identity-insert due to no transaction in progress\");\n                source.getActionQueue().addAction(insert);\n                key = insert.getDelayedEntityKey();\n            }\n        } else {\n            new Nullability(source).checkNullability(values, persister, false);\n        }\n\n        if (key != null) {\n            Object version = Versioning.getVersion(values, persister);\n            source.getPersistenceContext().addEntity(\n                    entity,\n                    (persister.isMutable() ? Status.MANAGED : Status.READ_ONLY),\n                    values,\n                    key,\n                    version,\n                    LockMode.WRITE,\n                    useIdentityColumn,\n                    persister,\n                    isVersionIncrementDisabled(),\n                    false);\n            //source.getPersistenceContext().removeNonExist(new EntityKey(id, persister, source.getEntityMode()));\n\n            if (!useIdentityColumn) {\n                source.getActionQueue().addAction(\n                        new EntityInsertAction(id, values, entity, version, persister, source));\n            }\n\n            cascadeAfterSave(source, persister, entity, anything);\n            // Very unfortunate code, but markInterceptorDirty is private. Once HHH-3904 is resolved remove this overridden method!\n            if (markInterceptorDirtyMethod != null) {\n                ReflectionUtils.invokeMethod(markInterceptorDirtyMethod, this, entity, persister, source);\n            }\n        }\n\n        return id;\n    }","id":97280,"modified_method":"@Override\n    protected Serializable performSaveOrReplicate(Object entity, EntityKey key, EntityPersister persister, boolean useIdentityColumn, Object anything, EventSource source, boolean requiresImmediateIdAccess) {\n        validate(entity, persister, source);\n\n        Serializable id = key == null ? null : key.getIdentifier();\n\n        // Put a placeholder in entries, so we don't recurse back and try to save() the\n        // same object again. QUESTION: should this be done before onSave() is called?\n        // likewise, should it be done before onUpdate()?\n        source.getPersistenceContext().addEntry(\n                entity,\n                Status.SAVING,\n                null,\n                null,\n                id,\n                null,\n                LockMode.WRITE,\n                useIdentityColumn,\n                persister,\n                false,\n                false);\n\n        cascadeBeforeSave(source, persister, entity, anything);\n\n        log.trace(\"executing insertions\");\n        source.getActionQueue().executeInserts();\n\n        Object[] values = persister.getPropertyValuesToInsert(entity, getMergeMap(anything), source);\n        Type[] types = persister.getPropertyTypes();\n\n        boolean substitute = substituteValuesIfNecessary(entity, id, values, persister, source);\n\n        if (persister.hasCollections()) {\n            substitute = substitute || visitCollectionsBeforeSave(entity, id, values, types, source);\n        }\n\n        if (substitute) {\n            persister.setPropertyValues(entity, values, source.getEntityMode());\n        }\n\n        TypeHelper.deepCopy(\n                values,\n                types,\n                persister.getPropertyUpdateability(),\n                values,\n                source);\n\n        new ForeignKeys.Nullifier(entity, false, useIdentityColumn, source)\n                .nullifyTransientReferences(values, types);\n        \n        boolean insertVetoed = false;\n        \n        if (useIdentityColumn) {\n            EntityIdentityInsertAction insert = new EntityIdentityInsertAction(\n                    values, entity, persister, source, false);\n            log.debug(\"executing identity-insert immediately\");\n            source.getActionQueue().execute(insert);\n            id = insert.getGeneratedId();\n            if (id != null) {\n                // As of HHH-3904, if the id is null the operation was vetoed so we bail\n                key = new EntityKey(id, persister, source.getEntityMode());\n                source.getPersistenceContext().checkUniqueness(key, entity);\n            } else {\n                insertVetoed = true;\n            }\n        }\n\n        if (!insertVetoed) {\n            Object version = Versioning.getVersion(values, persister);\n            source.getPersistenceContext().addEntity(\n                    entity,\n                    (persister.isMutable() ? Status.MANAGED : Status.READ_ONLY),\n                    values,\n                    key,\n                    version,\n                    LockMode.WRITE,\n                    useIdentityColumn,\n                    persister,\n                    isVersionIncrementDisabled(),\n                    false);\n\n            if (!useIdentityColumn) {\n                EntityInsertAction insert = new EntityInsertAction(id, values, entity, version, persister, source); \n                source.getActionQueue().execute(insert);\n                if(!source.getPersistenceContext().wasInsertedDuringTransaction(persister, id)) {\n                    insertVetoed=true;\n                }\n            }\n\n            if(!insertVetoed) {\n                cascadeAfterSave(source, persister, entity, anything);\n                // Very unfortunate code, but markInterceptorDirty is private. Once HHH-3904 is resolved remove this overridden method!\n                if (markInterceptorDirtyMethod != null) {\n                    ReflectionUtils.invokeMethod(markInterceptorDirtyMethod, this, entity, persister, source);\n                }\n            }\n        }\n\n        return id;\n    }","commit_id":"2822e666694cbe4b78922bb2acd5f2937e0ec83f","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    protected Serializable performSaveOrReplicate(Object entity, EntityKey key, EntityPersister persister, boolean useIdentityColumn, Object anything, EventSource source, boolean requiresImmediateIdAccess) {\n        validate(entity, persister, source);\n\n        Serializable id = key == null ? null : key.getIdentifier();\n\n        // Put a placeholder in entries, so we don't recurse back and try to save() the\n        // same object again. QUESTION: should this be done before onSave() is called?\n        // likewise, should it be done before onUpdate()?\n        source.getPersistenceContext().addEntry(\n                entity,\n                Status.SAVING,\n                null,\n                null,\n                id,\n                null,\n                LockMode.WRITE,\n                useIdentityColumn,\n                persister,\n                false,\n                false);\n\n        cascadeBeforeSave(source, persister, entity, anything);\n\n        log.trace(\"executing insertions\");\n        source.getActionQueue().executeInserts();\n\n        Object[] values = persister.getPropertyValuesToInsert(entity, getMergeMap(anything), source);\n        Type[] types = persister.getPropertyTypes();\n\n        boolean substitute = substituteValuesIfNecessary(entity, id, values, persister, source);\n\n        if (persister.hasCollections()) {\n            substitute = substitute || visitCollectionsBeforeSave(entity, id, values, types, source);\n        }\n\n        if (substitute) {\n            persister.setPropertyValues(entity, values, source.getEntityMode());\n        }\n\n        TypeHelper.deepCopy(\n                values,\n                types,\n                persister.getPropertyUpdateability(),\n                values,\n                source);\n\n        new ForeignKeys.Nullifier(entity, false, useIdentityColumn, source)\n                .nullifyTransientReferences(values, types);\n        \n        boolean insertVetoed = false;\n        \n        if (useIdentityColumn) {\n            EntityIdentityInsertAction insert = new EntityIdentityInsertAction(\n                    values, entity, persister, source, false);\n            log.debug(\"executing identity-insert immediately\");\n            source.getActionQueue().execute(insert);\n            id = insert.getGeneratedId();\n            if (id != null) {\n                // As of HHH-3904, if the id is null the operation was vetoed so we bail\n                key = new EntityKey(id, persister, source.getEntityMode());\n                source.getPersistenceContext().checkUniqueness(key, entity);\n            } else {\n                insertVetoed = true;\n            }\n        }\n\n        if (!insertVetoed) {\n            Object version = Versioning.getVersion(values, persister);\n            source.getPersistenceContext().addEntity(\n                    entity,\n                    (persister.isMutable() ? Status.MANAGED : Status.READ_ONLY),\n                    values,\n                    key,\n                    version,\n                    LockMode.WRITE,\n                    useIdentityColumn,\n                    persister,\n                    isVersionIncrementDisabled(),\n                    false);\n\n            if (!useIdentityColumn) {\n                EntityInsertAction insert = new EntityInsertAction(id, values, entity, version, persister, source); \n                source.getActionQueue().execute(insert);\n                if(persister.hasCache() && !source.getPersistenceContext().wasInsertedDuringTransaction(persister, id)) {\n                    insertVetoed=true;\n                }\n            }\n\n            if(!insertVetoed) {\n                cascadeAfterSave(source, persister, entity, anything);\n                // Very unfortunate code, but markInterceptorDirty is private. Once HHH-3904 is resolved remove this overridden method!\n                if (markInterceptorDirtyMethod != null) {\n                    ReflectionUtils.invokeMethod(markInterceptorDirtyMethod, this, entity, persister, source);\n                }\n            }\n        }\n\n        return id;\n    }","id":97281,"modified_method":"@Override\n    protected Serializable performSaveOrReplicate(Object entity, EntityKey key, EntityPersister persister, boolean useIdentityColumn, Object anything, EventSource source, boolean requiresImmediateIdAccess) {\n        validate(entity, persister, source);\n\n        Serializable id = key == null ? null : key.getIdentifier();\n\n        boolean inTxn = source.getJDBCContext().isTransactionInProgress();\n        boolean shouldDelayIdentityInserts = !inTxn && !requiresImmediateIdAccess;\n\n        // Put a placeholder in entries, so we don't recurse back and try to save() the\n        // same object again. QUESTION: should this be done before onSave() is called?\n        // likewise, should it be done before onUpdate()?\n        source.getPersistenceContext().addEntry(\n                entity,\n                Status.SAVING,\n                null,\n                null,\n                id,\n                null,\n                LockMode.WRITE,\n                useIdentityColumn,\n                persister,\n                false,\n                false);\n\n        cascadeBeforeSave(source, persister, entity, anything);\n\n        if (useIdentityColumn && !shouldDelayIdentityInserts) {\n            log.trace(\"executing insertions\");\n            source.getActionQueue().executeInserts();\n        }\n\n        Object[] values = persister.getPropertyValuesToInsert(entity, getMergeMap(anything), source);\n        Type[] types = persister.getPropertyTypes();\n\n        boolean substitute = substituteValuesIfNecessary(entity, id, values, persister, source);\n\n        if (persister.hasCollections()) {\n            substitute = substitute || visitCollectionsBeforeSave(entity, id, values, types, source);\n        }\n\n        if (substitute) {\n            persister.setPropertyValues(entity, values, source.getEntityMode());\n        }\n\n        TypeHelper.deepCopy(\n                values,\n                types,\n                persister.getPropertyUpdateability(),\n                values,\n                source);\n\n        new ForeignKeys.Nullifier(entity, false, useIdentityColumn, source)\n                .nullifyTransientReferences(values, types);\n\n        if (useIdentityColumn) {\n            EntityIdentityInsertAction insert = new EntityIdentityInsertAction(\n                    values, entity, persister, source, shouldDelayIdentityInserts);\n            if (!shouldDelayIdentityInserts) {\n                log.debug(\"executing identity-insert immediately\");\n                source.getActionQueue().execute(insert);\n                id = insert.getGeneratedId();\n                if (id != null) {\n                    // As of HHH-3904, if the id is null the operation was vetoed so we bail\n                    key = new EntityKey(id, persister, source.getEntityMode());\n                    source.getPersistenceContext().checkUniqueness(key, entity);\n                }\n            }\n            else {\n                log.debug(\"delaying identity-insert due to no transaction in progress\");\n                source.getActionQueue().addAction(insert);\n                key = insert.getDelayedEntityKey();\n            }\n        }\n\n        if (key != null) {\n            Object version = Versioning.getVersion(values, persister);\n            source.getPersistenceContext().addEntity(\n                    entity,\n                    (persister.isMutable() ? Status.MANAGED : Status.READ_ONLY),\n                    values,\n                    key,\n                    version,\n                    LockMode.WRITE,\n                    useIdentityColumn,\n                    persister,\n                    isVersionIncrementDisabled(),\n                    false);\n\n            if (!useIdentityColumn) {\n                source.getActionQueue().addAction(\n                        new EntityInsertAction(id, values, entity, version, persister, source));\n            }\n\n            cascadeAfterSave(source, persister, entity, anything);\n            // Very unfortunate code, but markInterceptorDirty is private. Once HHH-3904 is resolved remove this overridden method!\n            if (markInterceptorDirtyMethod != null) {\n                ReflectionUtils.invokeMethod(markInterceptorDirtyMethod, this, entity, persister, source);\n            }\n        }\n\n        return id;\n    }","commit_id":"5c24c2f5228ba1fb0d597cb6dfad0eae1899bfeb","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    protected Serializable performSaveOrReplicate(Object entity, EntityKey key, EntityPersister persister, boolean useIdentityColumn, Object anything, EventSource source, boolean requiresImmediateIdAccess) {\n        validate(entity, persister, source);\n\n        Serializable id = key == null ? null : key.getIdentifier();\n\n        boolean inTxn = source.getJDBCContext().isTransactionInProgress();\n        boolean shouldDelayIdentityInserts = !inTxn && !requiresImmediateIdAccess;\n\n        // Put a placeholder in entries, so we don't recurse back and try to save() the\n        // same object again. QUESTION: should this be done before onSave() is called?\n        // likewise, should it be done before onUpdate()?\n        source.getPersistenceContext().addEntry(\n                entity,\n                Status.SAVING,\n                null,\n                null,\n                id,\n                null,\n                LockMode.WRITE,\n                useIdentityColumn,\n                persister,\n                false,\n                false);\n\n        cascadeBeforeSave(source, persister, entity, anything);\n\n        if (useIdentityColumn && !shouldDelayIdentityInserts) {\n            log.trace(\"executing insertions\");\n            source.getActionQueue().executeInserts();\n        }\n\n        Object[] values = persister.getPropertyValuesToInsert(entity, getMergeMap(anything), source);\n        Type[] types = persister.getPropertyTypes();\n\n        boolean substitute = substituteValuesIfNecessary(entity, id, values, persister, source);\n\n        if (persister.hasCollections()) {\n            substitute = substitute || visitCollectionsBeforeSave(entity, id, values, types, source);\n        }\n\n        if (substitute) {\n            persister.setPropertyValues(entity, values, source.getEntityMode());\n        }\n\n        TypeHelper.deepCopy(\n                values,\n                types,\n                persister.getPropertyUpdateability(),\n                values,\n                source);\n\n        new ForeignKeys.Nullifier(entity, false, useIdentityColumn, source)\n                .nullifyTransientReferences(values, types);\n        \n        if (useIdentityColumn) {\n            isNullabilityCheckerAsLastEventListener(source);\n            EntityIdentityInsertAction insert = new EntityIdentityInsertAction(\n                    values, entity, persister, source, shouldDelayIdentityInserts);\n            if (!shouldDelayIdentityInserts) {\n                log.debug(\"executing identity-insert immediately\");\n                source.getActionQueue().execute(insert);\n                id = insert.getGeneratedId();\n                if (id != null) {\n                    // As of HHH-3904, if the id is null the operation was vetoed so we bail\n                    key = new EntityKey(id, persister, source.getEntityMode());\n                    source.getPersistenceContext().checkUniqueness(key, entity);\n                }\n            }\n            else {\n                log.debug(\"delaying identity-insert due to no transaction in progress\");\n                source.getActionQueue().addAction(insert);\n                key = insert.getDelayedEntityKey();\n            }\n        } else {\n            new Nullability(source).checkNullability(values, persister, false);\n        }\n\n        if (key != null) {\n            Object version = Versioning.getVersion(values, persister);\n            source.getPersistenceContext().addEntity(\n                    entity,\n                    (persister.isMutable() ? Status.MANAGED : Status.READ_ONLY),\n                    values,\n                    key,\n                    version,\n                    LockMode.WRITE,\n                    useIdentityColumn,\n                    persister,\n                    isVersionIncrementDisabled(),\n                    false);\n            //source.getPersistenceContext().removeNonExist(new EntityKey(id, persister, source.getEntityMode()));\n\n            if (!useIdentityColumn) {\n                source.getActionQueue().addAction(\n                        new EntityInsertAction(id, values, entity, version, persister, source));\n            }\n\n            cascadeAfterSave(source, persister, entity, anything);\n            // Very unfortunate code, but markInterceptorDirty is private. Once HHH-3904 is resolved remove this overridden method!\n            if (markInterceptorDirtyMethod != null) {\n                ReflectionUtils.invokeMethod(markInterceptorDirtyMethod, this, entity, persister, source);\n            }\n        }\n\n        return id;\n    }","id":97282,"modified_method":"@Override\n    protected Serializable performSaveOrReplicate(Object entity, EntityKey key, EntityPersister persister, boolean useIdentityColumn, Object anything, EventSource source, boolean requiresImmediateIdAccess) {\n        validate(entity, persister, source);\n\n        Serializable id = key == null ? null : key.getIdentifier();\n\n        // Put a placeholder in entries, so we don't recurse back and try to save() the\n        // same object again. QUESTION: should this be done before onSave() is called?\n        // likewise, should it be done before onUpdate()?\n        source.getPersistenceContext().addEntry(\n                entity,\n                Status.SAVING,\n                null,\n                null,\n                id,\n                null,\n                LockMode.WRITE,\n                useIdentityColumn,\n                persister,\n                false,\n                false);\n\n        cascadeBeforeSave(source, persister, entity, anything);\n\n        log.trace(\"executing insertions\");\n        source.getActionQueue().executeInserts();\n\n        Object[] values = persister.getPropertyValuesToInsert(entity, getMergeMap(anything), source);\n        Type[] types = persister.getPropertyTypes();\n\n        boolean substitute = substituteValuesIfNecessary(entity, id, values, persister, source);\n\n        if (persister.hasCollections()) {\n            substitute = substitute || visitCollectionsBeforeSave(entity, id, values, types, source);\n        }\n\n        if (substitute) {\n            persister.setPropertyValues(entity, values, source.getEntityMode());\n        }\n\n        TypeHelper.deepCopy(\n                values,\n                types,\n                persister.getPropertyUpdateability(),\n                values,\n                source);\n\n        new ForeignKeys.Nullifier(entity, false, useIdentityColumn, source)\n                .nullifyTransientReferences(values, types);\n        \n        boolean insertVetoed = false;\n        \n        if (useIdentityColumn) {\n            EntityIdentityInsertAction insert = new EntityIdentityInsertAction(\n                    values, entity, persister, source, false);\n            log.debug(\"executing identity-insert immediately\");\n            source.getActionQueue().execute(insert);\n            id = insert.getGeneratedId();\n            if (id != null) {\n                // As of HHH-3904, if the id is null the operation was vetoed so we bail\n                key = new EntityKey(id, persister, source.getEntityMode());\n                source.getPersistenceContext().checkUniqueness(key, entity);\n            } else {\n                insertVetoed = true;\n            }\n        }\n\n        if (!insertVetoed) {\n            Object version = Versioning.getVersion(values, persister);\n            source.getPersistenceContext().addEntity(\n                    entity,\n                    (persister.isMutable() ? Status.MANAGED : Status.READ_ONLY),\n                    values,\n                    key,\n                    version,\n                    LockMode.WRITE,\n                    useIdentityColumn,\n                    persister,\n                    isVersionIncrementDisabled(),\n                    false);\n\n            if (!useIdentityColumn) {\n                EntityInsertAction insert = new EntityInsertAction(id, values, entity, version, persister, source); \n                source.getActionQueue().execute(insert);\n                if(!source.getPersistenceContext().wasInsertedDuringTransaction(persister, id)) {\n                    insertVetoed=true;\n                }\n            }\n\n            if(!insertVetoed) {\n                cascadeAfterSave(source, persister, entity, anything);\n                // Very unfortunate code, but markInterceptorDirty is private. Once HHH-3904 is resolved remove this overridden method!\n                if (markInterceptorDirtyMethod != null) {\n                    ReflectionUtils.invokeMethod(markInterceptorDirtyMethod, this, entity, persister, source);\n                }\n            }\n        }\n\n        return id;\n    }","commit_id":"9669e861d7007affdc760f3f32aac6154d36df3b","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    protected Serializable performSaveOrReplicate(Object entity, EntityKey key, EntityPersister persister, boolean useIdentityColumn, Object anything, EventSource source, boolean requiresImmediateIdAccess) {\n        validate(entity, persister, source);\n\n        Serializable id = key == null ? null : key.getIdentifier();\n\n        // Put a placeholder in entries, so we don't recurse back and try to save() the\n        // same object again. QUESTION: should this be done before onSave() is called?\n        // likewise, should it be done before onUpdate()?\n        source.getPersistenceContext().addEntry(\n                entity,\n                Status.SAVING,\n                null,\n                null,\n                id,\n                null,\n                LockMode.WRITE,\n                useIdentityColumn,\n                persister,\n                false,\n                false);\n\n        cascadeBeforeSave(source, persister, entity, anything);\n\n        log.trace(\"executing insertions\");\n        source.getActionQueue().executeInserts();\n\n        Object[] values = persister.getPropertyValuesToInsert(entity, getMergeMap(anything), source);\n        Type[] types = persister.getPropertyTypes();\n\n        boolean substitute = substituteValuesIfNecessary(entity, id, values, persister, source);\n\n        if (persister.hasCollections()) {\n            substitute = substitute || visitCollectionsBeforeSave(entity, id, values, types, source);\n        }\n\n        if (substitute) {\n            persister.setPropertyValues(entity, values, source.getEntityMode());\n        }\n\n        TypeHelper.deepCopy(\n                values,\n                types,\n                persister.getPropertyUpdateability(),\n                values,\n                source);\n\n        new ForeignKeys.Nullifier(entity, false, useIdentityColumn, source)\n                .nullifyTransientReferences(values, types);\n        \n        boolean insertVetoed = false;\n        \n        if (useIdentityColumn) {\n            EntityIdentityInsertAction insert = new EntityIdentityInsertAction(\n                    values, entity, persister, source, false);\n            log.debug(\"executing identity-insert immediately\");\n            source.getActionQueue().execute(insert);\n            id = insert.getGeneratedId();\n            if (id != null) {\n                // As of HHH-3904, if the id is null the operation was vetoed so we bail\n                key = new EntityKey(id, persister, source.getEntityMode());\n                source.getPersistenceContext().checkUniqueness(key, entity);\n            } else {\n                insertVetoed = true;\n            }\n        }\n\n        if (!insertVetoed) {\n            Object version = Versioning.getVersion(values, persister);\n            source.getPersistenceContext().addEntity(\n                    entity,\n                    (persister.isMutable() ? Status.MANAGED : Status.READ_ONLY),\n                    values,\n                    key,\n                    version,\n                    LockMode.WRITE,\n                    useIdentityColumn,\n                    persister,\n                    isVersionIncrementDisabled(),\n                    false);\n\n            if (!useIdentityColumn) {\n                EntityInsertAction insert = new EntityInsertAction(id, values, entity, version, persister, source); \n                source.getActionQueue().execute(insert);\n                if(persister.hasCache() && !source.getPersistenceContext().wasInsertedDuringTransaction(persister, id)) {\n                    insertVetoed=true;\n                }\n            }\n\n            if(!insertVetoed) {\n                cascadeAfterSave(source, persister, entity, anything);\n                // Very unfortunate code, but markInterceptorDirty is private. Once HHH-3904 is resolved remove this overridden method!\n                if (markInterceptorDirtyMethod != null) {\n                    ReflectionUtils.invokeMethod(markInterceptorDirtyMethod, this, entity, persister, source);\n                }\n            }\n        }\n\n        return id;\n    }","id":97283,"modified_method":"@Override\n    protected Serializable performSaveOrReplicate(Object entity, EntityKey key, EntityPersister persister, boolean useIdentityColumn, Object anything, EventSource source, boolean requiresImmediateIdAccess) {\n        validate(entity, persister, source);\n\n        Serializable id = key == null ? null : key.getIdentifier();\n\n        boolean inTxn = source.getJDBCContext().isTransactionInProgress();\n        boolean shouldDelayIdentityInserts = !inTxn && !requiresImmediateIdAccess;\n\n        // Put a placeholder in entries, so we don't recurse back and try to save() the\n        // same object again. QUESTION: should this be done before onSave() is called?\n        // likewise, should it be done before onUpdate()?\n        source.getPersistenceContext().addEntry(\n                entity,\n                Status.SAVING,\n                null,\n                null,\n                id,\n                null,\n                LockMode.WRITE,\n                useIdentityColumn,\n                persister,\n                false,\n                false);\n\n        cascadeBeforeSave(source, persister, entity, anything);\n\n        if (useIdentityColumn && !shouldDelayIdentityInserts) {\n            log.trace(\"executing insertions\");\n            source.getActionQueue().executeInserts();\n        }\n\n        Object[] values = persister.getPropertyValuesToInsert(entity, getMergeMap(anything), source);\n        Type[] types = persister.getPropertyTypes();\n\n        boolean substitute = substituteValuesIfNecessary(entity, id, values, persister, source);\n\n        if (persister.hasCollections()) {\n            substitute = substitute || visitCollectionsBeforeSave(entity, id, values, types, source);\n        }\n\n        if (substitute) {\n            persister.setPropertyValues(entity, values, source.getEntityMode());\n        }\n\n        TypeHelper.deepCopy(\n                values,\n                types,\n                persister.getPropertyUpdateability(),\n                values,\n                source);\n\n        new ForeignKeys.Nullifier(entity, false, useIdentityColumn, source)\n                .nullifyTransientReferences(values, types);\n\n        if (useIdentityColumn) {\n            EntityIdentityInsertAction insert = new EntityIdentityInsertAction(\n                    values, entity, persister, source, shouldDelayIdentityInserts);\n            if (!shouldDelayIdentityInserts) {\n                log.debug(\"executing identity-insert immediately\");\n                source.getActionQueue().execute(insert);\n                id = insert.getGeneratedId();\n                if (id != null) {\n                    // As of HHH-3904, if the id is null the operation was vetoed so we bail\n                    key = new EntityKey(id, persister, source.getEntityMode());\n                    source.getPersistenceContext().checkUniqueness(key, entity);\n                }\n            }\n            else {\n                log.debug(\"delaying identity-insert due to no transaction in progress\");\n                source.getActionQueue().addAction(insert);\n                key = insert.getDelayedEntityKey();\n            }\n        }\n\n        if (key != null) {\n            Object version = Versioning.getVersion(values, persister);\n            source.getPersistenceContext().addEntity(\n                    entity,\n                    (persister.isMutable() ? Status.MANAGED : Status.READ_ONLY),\n                    values,\n                    key,\n                    version,\n                    LockMode.WRITE,\n                    useIdentityColumn,\n                    persister,\n                    isVersionIncrementDisabled(),\n                    false);\n\n            if (!useIdentityColumn) {\n                source.getActionQueue().addAction(\n                        new EntityInsertAction(id, values, entity, version, persister, source));\n            }\n\n            cascadeAfterSave(source, persister, entity, anything);\n            // Very unfortunate code, but markInterceptorDirty is private. Once HHH-3904 is resolved remove this overridden method!\n            if (markInterceptorDirtyMethod != null) {\n                ReflectionUtils.invokeMethod(markInterceptorDirtyMethod, this, entity, persister, source);\n            }\n        }\n\n        return id;\n    }","commit_id":"5a2685dbe03b7059fcb412f58328f2a3cacf85ed","url":"https://github.com/grails/grails-core"},{"original_method":"public PersistentCache open(File cacheDir, CacheUsage usage, Map<String, ?> properties, LockMode lockMode, Action<? super PersistentCache> initializer) {\n            DirCacheReference dirCacheReference = doOpenDir(cacheDir, usage, properties, lockMode, initializer);\n            return dirCacheReference.getCache();\n        }","id":97284,"modified_method":"public PersistentCache open(File cacheDir, CacheUsage usage, Map<String, ?> properties, LockMode lockMode, CrossVersionMode crossVersionMode, Action<? super PersistentCache> initializer) {\n            DirCacheReference dirCacheReference = doOpenDir(cacheDir, usage, properties, lockMode, initializer);\n            return dirCacheReference.getCache();\n        }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"private DirCacheReference doOpenDir(File cacheDir, CacheUsage usage, Map<String, ?> properties, LockMode lockMode, Action<? super PersistentCache> action) {\n            File canonicalDir = GFileUtils.canonicalise(cacheDir);\n            DirCacheReference dirCacheReference = dirCaches.get(canonicalDir);\n            if (dirCacheReference == null) {\n                DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache(canonicalDir, usage, properties, action);\n                dirCacheReference = new DirCacheReference(cache, properties, lockMode);\n                dirCaches.put(canonicalDir, dirCacheReference);\n            } else {\n                if (usage == CacheUsage.REBUILD && dirCacheReference.rebuiltBy != this) {\n                    throw new IllegalStateException(String.format(\"Cannot rebuild cache '%s' as it is already open.\", cacheDir));\n                }\n                if (lockMode != dirCacheReference.lockMode) {\n                    throw new IllegalStateException(String.format(\"Cannot open cache '%s' with %s lock mode as it is already open with %s lock mode.\", cacheDir, lockMode.toString().toLowerCase(), dirCacheReference.lockMode.toString().toLowerCase()));\n                }\n                if (!properties.equals(dirCacheReference.properties)) {\n                    throw new IllegalStateException(String.format(\"Cache '%s' is already open with different state.\", cacheDir));\n                }\n            }\n            if (usage == CacheUsage.REBUILD) {\n                dirCacheReference.rebuiltBy = this;\n            }\n            dirCacheReference.addReference(this);\n            return dirCacheReference;\n        }","id":97285,"modified_method":"private DirCacheReference doOpenDir(File cacheDir, CacheUsage usage, Map<String, ?> properties, LockMode lockMode, Action<? super PersistentCache> action) {\n            File canonicalDir = GFileUtils.canonicalise(cacheDir);\n            DirCacheReference dirCacheReference = dirCaches.get(canonicalDir);\n            if (dirCacheReference == null) {\n                DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache(canonicalDir, usage, properties, lockMode, action);\n                dirCacheReference = new DirCacheReference(cache, properties, lockMode);\n                dirCaches.put(canonicalDir, dirCacheReference);\n            } else {\n                if (usage == CacheUsage.REBUILD && dirCacheReference.rebuiltBy != this) {\n                    throw new IllegalStateException(String.format(\"Cannot rebuild cache '%s' as it is already open.\", cacheDir));\n                }\n                if (lockMode != dirCacheReference.lockMode) {\n                    throw new IllegalStateException(String.format(\"Cannot open cache '%s' with %s lock mode as it is already open with %s lock mode.\", cacheDir, lockMode.toString().toLowerCase(), dirCacheReference.lockMode.toString().toLowerCase()));\n                }\n                if (!properties.equals(dirCacheReference.properties)) {\n                    throw new IllegalStateException(String.format(\"Cache '%s' is already open with different state.\", cacheDir));\n                }\n            }\n            if (usage == CacheUsage.REBUILD) {\n                dirCacheReference.rebuiltBy = this;\n            }\n            dirCacheReference.addReference(this);\n            return dirCacheReference;\n        }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"public <K, V> PersistentIndexedCache<K, V> openIndexedCache(File cacheDir, CacheUsage usage, Map<String, ?> properties, LockMode lockMode, Serializer<V> serializer) {\n            if (lockMode == LockMode.Shared) {\n                throw new UnsupportedOperationException(\"Not shared indexed cache implementation available.\");\n            }\n            IndexedCacheReference<K, V> cacheReference = doOpenDir(cacheDir, usage, properties, LockMode.Exclusive, null).getIndexedCache(serializer);\n            cacheReference.addReference(this);\n            return cacheReference.getCache();\n        }","id":97286,"modified_method":"public <K, V> PersistentIndexedCache<K, V> openIndexedCache(File cacheDir, CacheUsage usage, Map<String, ?> properties, LockMode lockMode, CrossVersionMode crossVersionMode, Serializer<V> serializer) {\n//            if (lockMode == LockMode.Shared) {\n//                throw new UnsupportedOperationException(\"No indexed cache implementation is available that can be shared by multiple processes.\");\n//            }\n            if (crossVersionMode == CrossVersionMode.CrossVersion) {\n                throw new UnsupportedOperationException(\"No indexed cache implementation is available that can be used by multiple Gradle versions.\");\n            }\n            IndexedCacheReference<K, V> cacheReference = doOpenDir(cacheDir, usage, properties, LockMode.Shared, null).getIndexedCache(serializer);\n            cacheReference.addReference(this);\n            return cacheReference.getCache();\n        }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"public <E> PersistentStateCache<E> openStateCache(File cacheDir, CacheUsage usage, Map<String, ?> properties, LockMode lockMode, Serializer<E> serializer) {\n            if (lockMode == LockMode.Shared) {\n                throw new UnsupportedOperationException(\"No shared state cache implementation available.\");\n            }\n            StateCacheReference<E> cacheReference = doOpenDir(cacheDir, usage, properties, LockMode.Exclusive, null).getStateCache(serializer);\n            cacheReference.addReference(this);\n            return cacheReference.getCache();\n        }","id":97287,"modified_method":"public <E> PersistentStateCache<E> openStateCache(File cacheDir, CacheUsage usage, Map<String, ?> properties, LockMode lockMode, CrossVersionMode crossVersionMode, Serializer<E> serializer) {\n//            if (lockMode == LockMode.Shared) {\n//                throw new UnsupportedOperationException(\"No shared state cache implementation available.\");\n//            }\n            StateCacheReference<E> cacheReference = doOpenDir(cacheDir, usage, properties, LockMode.Shared, null).getStateCache(serializer);\n            cacheReference.addReference(this);\n            return cacheReference.getCache();\n        }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"public void close() {\n            dirCaches.values().remove(this);\n        }","id":97288,"modified_method":"public void close() {\n            dirCaches.values().remove(this);\n            getCache().close();\n        }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        protected PersistentIndexedCache<K, V> doOpen(File cacheDir, Map<String, ?> properties) {\n            return factory.openIndexedCache(cacheDir, cacheUsage, properties, LockMode.Exclusive, serializer);\n        }","id":97289,"modified_method":"@Override\n        protected PersistentIndexedCache<K, V> doOpen(File cacheDir, Map<String, ?> properties) {\n            return factory.openIndexedCache(cacheDir, cacheUsage, properties, LockMode.Exclusive, getCrossVersionMode(), serializer);\n        }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        protected PersistentStateCache<E> doOpen(File cacheDir, Map<String, ?> properties) {\n            return factory.openStateCache(cacheDir, cacheUsage, properties, LockMode.Exclusive, serializer);\n        }","id":97290,"modified_method":"@Override\n        protected PersistentStateCache<E> doOpen(File cacheDir, Map<String, ?> properties) {\n            return factory.openStateCache(cacheDir, cacheUsage, properties, LockMode.Exclusive, getCrossVersionMode(), serializer);\n        }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        protected PersistentCache doOpen(File cacheDir, Map<String, ?> properties) {\n            return factory.open(cacheDir, cacheUsage, properties, LockMode.Shared, initializer);\n        }","id":97291,"modified_method":"@Override\n        protected PersistentCache doOpen(File cacheDir, Map<String, ?> properties) {\n            return factory.open(cacheDir, cacheUsage, properties, LockMode.Shared, getCrossVersionMode(), initializer);\n        }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"private FileLock lock(FileChannel lockChannel, LockMode lockMode) throws IOException, InterruptedException {\n        long timeout = System.currentTimeMillis() + 20000;\n        do {\n            FileLock fileLock = lockChannel.tryLock(0, Long.MAX_VALUE, lockMode == LockMode.Shared);\n            if (fileLock != null) {\n                return fileLock;\n            }\n            Thread.sleep(200L);\n        } while (System.currentTimeMillis() < timeout);\n        throw new GradleException(String.format(\"Timeout waiting to acquire %s lock on %s. It is currently in use by another Gradle instance.\", lockMode.toString().toLowerCase(), this));\n    }","id":97292,"modified_method":"private FileLock lock(FileChannel lockChannel, LockMode lockMode) throws IOException, InterruptedException {\n        LOGGER.debug(\"Waiting to acquire {} lock on {}.\", lockMode, this);\n        long timeout = System.currentTimeMillis() + LOCK_TIMEOUT;\n        do {\n            FileLock fileLock = lockChannel.tryLock(0, Long.MAX_VALUE, lockMode == LockMode.Shared);\n            if (fileLock != null) {\n                LOGGER.debug(\"Lock acquired.\");\n                return fileLock;\n            }\n            Thread.sleep(200L);\n        } while (System.currentTimeMillis() < timeout);\n        throw new CacheOpenException(String.format(\"Timeout waiting to lock %s. It is currently in use by another Gradle instance.\", this));\n    }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"private void init(CacheUsage cacheUsage, Map<String, ?> properties, Action<? super PersistentCache> initAction) {\n        if (!dir.isDirectory()) {\n            dir.mkdirs();\n        }\n\n        try {\n            lockFile.createNewFile();\n            RandomAccessFile lockFileAccess = new RandomAccessFile(lockFile, \"rw\");\n            try {\n                // Start with shared lock\n                FileChannel lockChannel = lockFileAccess.getChannel();\n                FileLock sharedLock = lock(lockChannel, LockMode.Shared);\n                boolean valid;\n                try {\n                    valid = determineIfCacheIsValid(cacheUsage, properties);\n                } finally {\n                    sharedLock.release();\n                }\n                // TODO - handle case where another process rebuilds the cache in this window\n                if (!valid) {\n                    // Escalate to exclusive lock and initialise the cache\n                    FileLock exclusiveLock = lock(lockChannel, LockMode.Exclusive);\n                    try {\n                        buildCacheDir(initAction);\n                        // TODO - handle case where initializer fails\n                        // TODO - handle case where this process crashes while initializing or writing properties file\n                    } finally {\n                        exclusiveLock.release();\n                    }\n                }\n            } finally {\n                lockFileAccess.close();\n            }\n            // TODO - need to keep hold of shared or exclusive lock until this cache is closed\n        } catch (Exception e) {\n            throw new UncheckedIOException(String.format(\"Could not open %s.\", this), e);\n        }\n    }","id":97293,"modified_method":"private void init(CacheUsage cacheUsage, Map<String, ?> properties, Action<? super PersistentCache> initAction, LockMode lockMode) {\n        if (!dir.isDirectory()) {\n            dir.mkdirs();\n        }\n\n        try {\n            lockFile.createNewFile();\n            lockFileAccess = new RandomAccessFile(lockFile, \"rw\");\n\n            try {\n                // Start with desired lock mode and check if cache is valid or not\n                FileChannel lockChannel = lockFileAccess.getChannel();\n                FileLock validateLock = lock(lockChannel, lockMode);\n                boolean valid = determineIfCacheIsValid(cacheUsage, properties);\n\n                if (valid) {\n                    this.fileLock = validateLock;\n                    return;\n                }\n\n                // Escalate to exclusive lock and initialise the cache\n                FileLock initialiseLock;\n                if (lockMode == LockMode.Exclusive) {\n                    initialiseLock = validateLock;\n                } else {\n                    LOGGER.debug(\"Releasing lock on {}.\", this);\n                    validateLock.release();\n                    // TODO - handle case where another process rebuilds the cache in this window\n                    initialiseLock = lock(lockChannel, LockMode.Exclusive);\n                }\n\n                buildCacheDir(initAction);\n                // TODO - handle case where initializer fails\n                // TODO - handle case where this process crashes while initializing or writing properties file\n\n                if (lockMode == LockMode.Exclusive) {\n                    this.fileLock = initialiseLock;\n                } else {\n                    LOGGER.debug(\"Releasing lock on {}.\", this);\n                    initialiseLock.release();\n                    // TODO - handle case where another process rebuilds the cache in this window\n                    this.fileLock = lock(lockChannel, lockMode);\n                }\n            } catch (Throwable throwable) {\n                // This also releases the locks, if any\n                lockFileAccess.close();\n                throw throwable;\n            }\n        } catch (CacheOpenException e) {\n            throw e;\n        } catch (Throwable e) {\n            throw new CacheOpenException(String.format(\"Could not open %s.\", this), e);\n        }\n    }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public String toString() {\n        return String.format(\"Cache %s\", dir);\n    }","id":97294,"modified_method":"@Override\n    public String toString() {\n        return String.format(\"cache directory %s\", dir);\n    }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultPersistentDirectoryCache(File dir, CacheUsage cacheUsage, Map<String, ?> properties, Action<? super PersistentCache> initAction) {\n        this.dir = dir;\n        propertiesFile = new File(dir, \"cache.properties\");\n        lockFile = new File(dir, \"cache.lock\");\n        this.properties.putAll(properties);\n        init(cacheUsage, properties, initAction);\n    }","id":97295,"modified_method":"public DefaultPersistentDirectoryCache(File dir, CacheUsage cacheUsage, Map<String, ?> properties, LockMode lockMode, Action<? super PersistentCache> initAction) {\n        this.dir = dir;\n        propertiesFile = new File(dir, \"cache.properties\");\n        lockFile = new File(dir, \"cache.lock\");\n        this.properties.putAll(properties);\n        init(cacheUsage, properties, initAction, lockMode);\n    }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void doesNotInitializeCacheWhenCacheDirExistsAndIsNotInvalid() {\n        TestFile dir = createCacheDir();\n\n        DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache(dir, CacheUsage.ON, properties, action);\n        dir.file(\"cache.properties\").assertIsFile();\n        dir.file(\"some-file\").assertIsFile();\n    }","id":97296,"modified_method":"@Test\n    public void doesNotInitializeCacheWhenCacheDirExistsAndIsNotInvalid() {\n        TestFile dir = createCacheDir();\n\n        DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache(dir, CacheUsage.ON, properties, LockMode.Shared, action);\n        dir.file(\"cache.properties\").assertIsFile();\n        dir.file(\"some-file\").assertIsFile();\n    }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void rebuildsCacheWhenCacheRebuildRequested() {\n        TestFile dir = createCacheDir();\n\n        context.checking(new Expectations() {{\n            one(action).execute(with(notNullValue(PersistentCache.class)));\n        }});\n\n        DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache(dir, CacheUsage.REBUILD, properties, action);\n        assertThat(loadProperties(dir.file(\"cache.properties\")), equalTo(properties));\n    }","id":97297,"modified_method":"@Test\n    public void rebuildsCacheWhenCacheRebuildRequested() {\n        TestFile dir = createCacheDir();\n\n        context.checking(new Expectations() {{\n            one(action).execute(with(notNullValue(PersistentCache.class)));\n        }});\n\n        DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache(dir, CacheUsage.REBUILD, properties, LockMode.Shared, action);\n        assertThat(loadProperties(dir.file(\"cache.properties\")), equalTo(properties));\n    }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void initializesCacheWhenPropertiesFileDoesNotExist() {\n        TestFile dir = tmpDir.getDir().file(\"dir\").createDir();\n\n        context.checking(new Expectations() {{\n            one(action).execute(with(notNullValue(PersistentCache.class)));\n        }});\n\n        DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache(dir, CacheUsage.ON, properties, action);\n        assertThat(loadProperties(dir.file(\"cache.properties\")), equalTo(properties));\n    }","id":97298,"modified_method":"@Test\n    public void initializesCacheWhenPropertiesFileDoesNotExist() {\n        TestFile dir = tmpDir.getDir().file(\"dir\").createDir();\n\n        context.checking(new Expectations() {{\n            one(action).execute(with(notNullValue(PersistentCache.class)));\n        }});\n\n        DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache(dir, CacheUsage.ON, properties, LockMode.Shared, action);\n        assertThat(loadProperties(dir.file(\"cache.properties\")), equalTo(properties));\n    }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void initialisesCacheWhenCacheDirDoesNotExist() {\n        TestFile emptyDir = tmpDir.getDir().file(\"dir\");\n        emptyDir.assertDoesNotExist();\n\n        context.checking(new Expectations() {{\n            one(action).execute(with(notNullValue(PersistentCache.class)));\n        }});\n\n        DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache(emptyDir, CacheUsage.ON, properties, action);\n        assertThat(loadProperties(emptyDir.file(\"cache.properties\")), equalTo(properties));\n    }","id":97299,"modified_method":"@Test\n    public void initialisesCacheWhenCacheDirDoesNotExist() {\n        TestFile emptyDir = tmpDir.getDir().file(\"dir\");\n        emptyDir.assertDoesNotExist();\n\n        context.checking(new Expectations() {{\n            one(action).execute(with(notNullValue(PersistentCache.class)));\n        }});\n\n        DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache(emptyDir, CacheUsage.ON, properties, LockMode.Shared, action);\n        assertThat(loadProperties(emptyDir.file(\"cache.properties\")), equalTo(properties));\n    }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void rebuildsCacheWhenPropertiesHaveChanged() {\n        TestFile dir = createCacheDir(\"prop\", \"other-value\");\n\n        context.checking(new Expectations() {{\n            one(action).execute(with(notNullValue(PersistentCache.class)));\n        }});\n\n        DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache(dir, CacheUsage.ON, properties, action);\n        assertThat(loadProperties(dir.file(\"cache.properties\")), equalTo(properties));\n    }","id":97300,"modified_method":"@Test\n    public void rebuildsCacheWhenPropertiesHaveChanged() {\n        TestFile dir = createCacheDir(\"prop\", \"other-value\");\n\n        context.checking(new Expectations() {{\n            one(action).execute(with(notNullValue(PersistentCache.class)));\n        }});\n\n        DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache(dir, CacheUsage.ON, properties, LockMode.Shared, action);\n        assertThat(loadProperties(dir.file(\"cache.properties\")), equalTo(properties));\n    }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"public PersistentCache open(File cacheDir, CacheUsage usage, Map<String, ?> properties, LockMode lockMode, Action<? super PersistentCache> initializer) {\n        cacheDir.mkdirs();\n        InMemoryCache cache = new InMemoryCache(cacheDir);\n        if (initializer != null) {\n            initializer.execute(cache);\n        }\n        return cache;\n    }","id":97301,"modified_method":"public PersistentCache open(File cacheDir, CacheUsage usage, Map<String, ?> properties, LockMode lockMode, CrossVersionMode crossVersionMode, Action<? super PersistentCache> initializer) {\n        cacheDir.mkdirs();\n        InMemoryCache cache = new InMemoryCache(cacheDir);\n        if (initializer != null) {\n            initializer.execute(cache);\n        }\n        return cache;\n    }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"public <K, V> PersistentIndexedCache<K, V> openIndexedCache(File cacheDir, CacheUsage usage, Map<String, ?> properties, LockMode lockMode, Serializer<V> serializer) {\n        return new InMemoryIndexedCache<K, V>();\n    }","id":97302,"modified_method":"public <K, V> PersistentIndexedCache<K, V> openIndexedCache(File cacheDir, CacheUsage usage, Map<String, ?> properties, LockMode lockMode, CrossVersionMode crossVersionMode, Serializer<V> serializer) {\n        return new InMemoryIndexedCache<K, V>();\n    }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"public <E> PersistentStateCache<E> openStateCache(File cacheDir, CacheUsage usage, Map<String, ?> properties, LockMode lockMode, Serializer<E> serializer) {\n        cacheDir.mkdirs();\n        return new SimpleStateCache<E>(cacheDir, new DefaultSerializer<E>());\n    }","id":97303,"modified_method":"public <E> PersistentStateCache<E> openStateCache(File cacheDir, CacheUsage usage, Map<String, ?> properties, LockMode lockMode, CrossVersionMode crossVersionMode, Serializer<E> serializer) {\n        cacheDir.mkdirs();\n        return new SimpleStateCache<E>(cacheDir, new DefaultSerializer<E>());\n    }","commit_id":"d44e41d5bea95847d615f3fb14073710ec070d8a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\r\n  public void acquire(final Progress pr, final StringList read, final StringList write) {\r\n    final long thread = Thread.currentThread().getId();\r\n    if(writeLocked.containsKey(thread) || readLocked.containsKey(thread))\r\n      throw new IllegalMonitorStateException(\"Thread already holds one or more locks.\");\r\n\r\n    // Wait in queue if necessary\r\n    synchronized(queue) { // Guard queue and transaction, monitor for waiting in queue\r\n      queue.add(thread);\r\n      while(transactions >= Math.max(mprop.num(MainProp.PARALLEL), 1)\r\n          || queue.peek() != thread) {\r\n        try {\r\n          queue.wait();\r\n        } catch(final InterruptedException e) {\r\n          Thread.currentThread().interrupt();\r\n        }\r\n      }\r\n      final int t = transactions++;\r\n      assert t <= Math.max(mprop.num(MainProp.PARALLEL), 1);\r\n      queue.remove(thread);\r\n    }\r\n\r\n    // Global write lock if write StringList is not set\r\n    if(null == write) writeAll.writeLock().lock();\r\n    else writeAll.readLock().lock();\r\n\r\n    synchronized(globalLock) {\r\n      // local write locking\r\n      if(null != write && !write.isEmpty()) {\r\n        while(globalReaders > 0) {\r\n          try {\r\n            globalLock.wait();\r\n          } catch(InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n          }\r\n        }\r\n        localWriters++;\r\n      }\r\n      // global read locking\r\n      if(null == read) {\r\n        while(localWriters > 0) {\r\n          try {\r\n            globalLock.wait();\r\n          } catch(InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n          }\r\n        }\r\n        globalReaders++;\r\n      }\r\n    }\r\n\r\n    // Local write locking\r\n    if (null != write) {\r\n      // Sort entries and remove duplicates to prevent deadlocks\r\n      final String[] writeObjects = write.sort(true, true).unique().toArray();\r\n      // Store for unlocking later\r\n      writeLocked.put(thread, writeObjects);\r\n      // Finally lock objects\r\n      for(final String object : writeObjects) {\r\n        ReentrantReadWriteLock lock;\r\n        synchronized(locks) { // Make sure each object lock is a singleton\r\n          lock = locks.get(object);\r\n          if(null == lock) {\r\n            lock = new ReentrantReadWriteLock();\r\n            locks.put(object, lock);\r\n          }\r\n        }\r\n        lock.writeLock().lock();\r\n      }\r\n    }\r\n\r\n    // Local read locking, same again\r\n    if (null != read) {\r\n      final String[] readObjects = read.sort(true, true).unique().toArray();\r\n      readLocked.put(thread, readObjects);\r\n      for(final String object : readObjects) {\r\n        ReentrantReadWriteLock lock;\r\n        synchronized(locks) {\r\n          lock = locks.get(object);\r\n          if(null == lock) {\r\n            lock = new ReentrantReadWriteLock();\r\n            locks.put(object, lock);\r\n          }\r\n        }\r\n        lock.readLock().lock();\r\n      }\r\n    }\r\n  }","id":97304,"modified_method":"@Override\r\n  public void acquire(final Progress pr, final StringList read, final StringList write) {\r\n    final long thread = Thread.currentThread().getId();\r\n    if(writeLocked.containsKey(thread) || readLocked.containsKey(thread))\r\n      throw new IllegalMonitorStateException(\"Thread already holds one or more locks.\");\r\n\r\n    // Wait in queue if necessary\r\n    synchronized(queue) { // Guard queue and transaction, monitor for waiting in queue\r\n      queue.add(thread);\r\n      while(transactions >= Math.max(mprop.num(MainProp.PARALLEL), 1)\r\n          || queue.peek() != thread) {\r\n        try {\r\n          queue.wait();\r\n        } catch(final InterruptedException e) {\r\n          Thread.currentThread().interrupt();\r\n        }\r\n      }\r\n      final int t = transactions++;\r\n      assert t <= Math.max(mprop.num(MainProp.PARALLEL), 1);\r\n      queue.remove(thread);\r\n    }\r\n\r\n    // Global write lock if write StringList is not set\r\n    if(null == write) writeAll.writeLock().lock();\r\n    else writeAll.readLock().lock();\r\n\r\n    synchronized(globalLock) {\r\n      // local write locking\r\n      if(null != write && !write.isEmpty()) {\r\n        while(globalReaders > 0) {\r\n          try {\r\n            globalLock.wait();\r\n          } catch(InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n          }\r\n        }\r\n        localWriters++;\r\n      }\r\n      // global read locking\r\n      if(null == read) {\r\n        while(localWriters > 0) {\r\n          try {\r\n            globalLock.wait();\r\n          } catch(InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n          }\r\n        }\r\n        globalReaders++;\r\n      }\r\n    }\r\n    String[] writeObjects = new String[0];\r\n    String[] readObjects = new String[0];\r\n\r\n    // Local locking\r\n    if (null != write) {\r\n      writeObjects = write.sort(true, true).unique().toArray();\r\n      writeLocked.put(thread, writeObjects);\r\n    }\r\n    if (null != read) {\r\n      readObjects = read.sort(true, true).unique().toArray();\r\n      readLocked.put(thread, readObjects);\r\n    }\r\n    // Use pattern similar to merge sort\r\n    int w = 0, r = 0;\r\n    while (r < readObjects.length || w < writeObjects.length) {\r\n      // Look what token comes earlier in alphabet, prefer writing against reading\r\n      if(w < writeObjects.length && (r >= readObjects.length\r\n          || writeObjects[w].compareTo(readObjects[r]) <= 0)) {\r\n        ReentrantReadWriteLock lock;\r\n        synchronized(locks) { // Make sure each object lock is a singleton\r\n          lock = locks.get(writeObjects[w]);\r\n          if(null == lock) { // Create lock if needed\r\n            lock = new ReentrantReadWriteLock();\r\n            locks.put(writeObjects[w], lock);\r\n          }\r\n        }\r\n        lock.writeLock().lock();\r\n        w++; // Set pointer to next token\r\n      } else {\r\n        ReentrantReadWriteLock lock;\r\n        synchronized(locks) {\r\n          lock = locks.get(readObjects[r]);\r\n          if(null == lock) {\r\n            lock = new ReentrantReadWriteLock();\r\n            locks.put(readObjects[r], lock);\r\n          }\r\n        }\r\n        lock.readLock().lock();\r\n        r++;\r\n      }\r\n    }\r\n  }","commit_id":"5bdf786604c2c48134b8b58166d4259ed376d191","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Indexable(type = IndexableType.DELETE)\n\t@Override\n\t@SystemEvent(type = SystemEventConstants.TYPE_DELETE)\n\tpublic BlogsEntry deleteEntry(BlogsEntry entry) throws PortalException {\n\n\t\t// Entry\n\n\t\tblogsEntryPersistence.remove(entry);\n\n\t\t// Cover Image\n\n\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\tentry.getCoverImageFileEntryId());\n\n\t\t// Resources\n\n\t\tresourceLocalService.deleteResource(\n\t\t\tentry.getCompanyId(), BlogsEntry.class.getName(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL, entry.getEntryId());\n\n\t\t// Image\n\n\t\timageLocalService.deleteImage(entry.getSmallImageId());\n\n\t\t// Subscriptions\n\n\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\tentry.getCompanyId(), BlogsEntry.class.getName(),\n\t\t\tentry.getEntryId());\n\n\t\t// Statistics\n\n\t\tblogsStatsUserLocalService.updateStatsUser(\n\t\t\tentry.getGroupId(), entry.getUserId(), entry.getDisplayDate());\n\n\t\t// Asset\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\t// Comment\n\n\t\tdeleteDiscussion(entry);\n\n\t\t// Expando\n\n\t\texpandoRowLocalService.deleteRows(entry.getEntryId());\n\n\t\t// Ratings\n\n\t\tratingsStatsLocalService.deleteStats(\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.deleteEntry(\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\t// Workflow\n\n\t\tworkflowInstanceLinkLocalService.deleteWorkflowInstanceLinks(\n\t\t\tentry.getCompanyId(), entry.getGroupId(),\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\treturn entry;\n\t}","id":97305,"modified_method":"@Indexable(type = IndexableType.DELETE)\n\t@Override\n\t@SystemEvent(type = SystemEventConstants.TYPE_DELETE)\n\tpublic BlogsEntry deleteEntry(BlogsEntry entry) throws PortalException {\n\n\t\t// Entry\n\n\t\tblogsEntryPersistence.remove(entry);\n\n\t\t// Cover Image\n\n\t\tlong coverImageFileEntryId = entry.getCoverImageFileEntryId();\n\n\t\tif (coverImageFileEntryId != 0) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tcoverImageFileEntryId);\n\t\t}\n\n\t\t// Resources\n\n\t\tresourceLocalService.deleteResource(\n\t\t\tentry.getCompanyId(), BlogsEntry.class.getName(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL, entry.getEntryId());\n\n\t\t// Image\n\n\t\timageLocalService.deleteImage(entry.getSmallImageId());\n\n\t\t// Subscriptions\n\n\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\tentry.getCompanyId(), BlogsEntry.class.getName(),\n\t\t\tentry.getEntryId());\n\n\t\t// Statistics\n\n\t\tblogsStatsUserLocalService.updateStatsUser(\n\t\t\tentry.getGroupId(), entry.getUserId(), entry.getDisplayDate());\n\n\t\t// Asset\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\t// Comment\n\n\t\tdeleteDiscussion(entry);\n\n\t\t// Expando\n\n\t\texpandoRowLocalService.deleteRows(entry.getEntryId());\n\n\t\t// Ratings\n\n\t\tratingsStatsLocalService.deleteStats(\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.deleteEntry(\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\t// Workflow\n\n\t\tworkflowInstanceLinkLocalService.deleteWorkflowInstanceLinks(\n\t\t\tentry.getCompanyId(), entry.getGroupId(),\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\treturn entry;\n\t}","commit_id":"37e2e6fc6872e60b00c80326f3c807c0dbb69de1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String subtitle,\n\t\t\tString description, String content, Date displayDate,\n\t\t\tboolean allowPingbacks, boolean allowTrackbacks,\n\t\t\tString[] trackbacks, ImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tvalidate(title, content);\n\n\t\tString oldUrlTitle = entry.getUrlTitle();\n\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, oldUrlTitle, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\n\t\tif (entry.isPending() || entry.isDraft()) {\n\t\t}\n\t\telse {\n\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Images\n\n\t\tlong coverImageFileEntryId = entry.getCoverImageFileEntryId();\n\t\tString coverImageURL = entry.getCoverImageURL();\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageFileEntryId = coverImageImageSelector.getImageId();\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\n\t\t\tif (coverImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getCoverImageFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (coverImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getCoverImageFileEntryId()) {\n\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getCoverImageFileEntryId());\n\t\t\t\t}\n\n\t\t\t\tif (coverImageImageSelector.getImageId() != 0) {\n\t\t\t\t\tcoverImageFileEntryId = addCoverImage(\n\t\t\t\t\t\tuserId, entry.getGroupId(), entryId,\n\t\t\t\t\t\tcoverImageImageSelector);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean smallImage = entry.isSmallImage();\n\t\tlong smallImageFileEntryId = entry.getSmallImageFileEntryId();\n\t\tString smallImageURL = entry.getSmallImageURL();\n\n\t\tFileEntry tempSmallImageFileEntry = null;\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImage = !smallImageImageSelector.isRemoveSmallImage();\n\t\t\tsmallImageFileEntryId = smallImageImageSelector.getImageId();\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\n\t\t\tif (smallImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getSmallImageFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (smallImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getSmallImageFileEntryId()) {\n\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getSmallImageFileEntryId());\n\t\t\t\t}\n\n\t\t\t\ttempSmallImageFileEntry =\n\t\t\t\t\tPortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\t\t\t\tsmallImageImageSelector.getImageId());\n\n\t\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\t\tuserId, entry.getGroupId(), entry.getEntryId(),\n\t\t\t\t\ttempSmallImageFileEntry.getMimeType(),\n\t\t\t\t\ttempSmallImageFileEntry.getTitle(),\n\t\t\t\t\ttempSmallImageFileEntry.getContentStream());\n\t\t\t}\n\t\t}\n\n\t\tvalidate(smallImageFileEntryId);\n\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Workflow\n\n\t\tboolean pingOldTrackbacks = false;\n\n\t\tif (!oldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\tpingOldTrackbacks = true;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"pingOldTrackbacks\", String.valueOf(pingOldTrackbacks));\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tentry = startWorkflowInstance(userId, entry, serviceContext);\n\n\t\tif ((coverImageImageSelector != null) &&\n\t\t\t(coverImageImageSelector.getImageId() != 0)) {\n\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tcoverImageImageSelector.getImageId());\n\t\t}\n\n\t\tif (tempSmallImageFileEntry != null) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\ttempSmallImageFileEntry.getFileEntryId());\n\t\t}\n\n\t\treturn entry;\n\t}","id":97306,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String subtitle,\n\t\t\tString description, String content, Date displayDate,\n\t\t\tboolean allowPingbacks, boolean allowTrackbacks,\n\t\t\tString[] trackbacks, ImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tvalidate(title, content);\n\n\t\tString oldUrlTitle = entry.getUrlTitle();\n\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, oldUrlTitle, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\n\t\tif (entry.isPending() || entry.isDraft()) {\n\t\t}\n\t\telse {\n\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Images\n\n\t\tlong coverImageFileEntryId = entry.getCoverImageFileEntryId();\n\t\tString coverImageURL = entry.getCoverImageURL();\n\n\t\tlong deletePreviousCoverImageFileEntryId = 0;\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageFileEntryId = coverImageImageSelector.getImageId();\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\n\t\t\tif (coverImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousCoverImageFileEntryId =\n\t\t\t\t\t\tentry.getCoverImageFileEntryId();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (coverImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getCoverImageFileEntryId()) {\n\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousCoverImageFileEntryId =\n\t\t\t\t\t\tentry.getCoverImageFileEntryId();\n\t\t\t\t}\n\n\t\t\t\tif (coverImageImageSelector.getImageId() != 0) {\n\t\t\t\t\tcoverImageFileEntryId = addCoverImage(\n\t\t\t\t\t\tuserId, entry.getGroupId(), entryId,\n\t\t\t\t\t\tcoverImageImageSelector);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean smallImage = entry.isSmallImage();\n\t\tlong smallImageFileEntryId = entry.getSmallImageFileEntryId();\n\t\tString smallImageURL = entry.getSmallImageURL();\n\n\t\tFileEntry tempSmallImageFileEntry = null;\n\n\t\tlong deletePreviousSmallImageFileEntryId = 0;\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImage = !smallImageImageSelector.isRemoveSmallImage();\n\t\t\tsmallImageFileEntryId = smallImageImageSelector.getImageId();\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\n\t\t\tif (smallImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousSmallImageFileEntryId =\n\t\t\t\t\t\tentry.getSmallImageFileEntryId();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (smallImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getSmallImageFileEntryId()) {\n\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousSmallImageFileEntryId =\n\t\t\t\t\t\tentry.getSmallImageFileEntryId();\n\t\t\t\t}\n\n\t\t\t\ttempSmallImageFileEntry =\n\t\t\t\t\tPortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\t\t\t\tsmallImageImageSelector.getImageId());\n\n\t\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\t\tuserId, entry.getGroupId(), entry.getEntryId(),\n\t\t\t\t\ttempSmallImageFileEntry.getMimeType(),\n\t\t\t\t\ttempSmallImageFileEntry.getTitle(),\n\t\t\t\t\ttempSmallImageFileEntry.getContentStream());\n\t\t\t}\n\t\t}\n\n\t\tvalidate(smallImageFileEntryId);\n\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Workflow\n\n\t\tboolean pingOldTrackbacks = false;\n\n\t\tif (!oldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\tpingOldTrackbacks = true;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"pingOldTrackbacks\", String.valueOf(pingOldTrackbacks));\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tentry = startWorkflowInstance(userId, entry, serviceContext);\n\n\t\tif (deletePreviousCoverImageFileEntryId != 0) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tdeletePreviousCoverImageFileEntryId);\n\t\t}\n\n\t\tif (deletePreviousSmallImageFileEntryId != 0) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tdeletePreviousSmallImageFileEntryId);\n\t\t}\n\n\t\tif ((coverImageImageSelector != null) &&\n\t\t\t(coverImageImageSelector.getImageId() != 0)) {\n\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tcoverImageImageSelector.getImageId());\n\t\t}\n\n\t\tif (tempSmallImageFileEntry != null) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\ttempSmallImageFileEntry.getFileEntryId());\n\t\t}\n\n\t\treturn entry;\n\t}","commit_id":"b32a37d6870cbb88c4008c4451194e93a6a02f56","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Activate the services required for service deployments.\n     * @param updateContext The update context\n     */\n    public void activate(final BootOperationContext updateContext, final ServiceTarget serviceTarget) {\n        // add resources here\n        MdrService mdrService = new MdrService();\n        serviceTarget.addService(ConnectorServices.IRONJACAMAR_MDR, mdrService).install();\n\n        RaRepositoryService raRepositoryService = new RaRepositoryService();\n        serviceTarget.addService(ConnectorServices.RA_REPOSISTORY_SERVICE, raRepositoryService).install();\n\n        ResourceAdapterDeploymentRegistryService registryService = new ResourceAdapterDeploymentRegistryService();\n        serviceTarget.addService(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE, registryService)\n                .addDependency(ConnectorServices.IRONJACAMAR_MDR).install();\n\n        JndiStrategyService jndiStrategyService = new JndiStrategyService();\n        serviceTarget.addService(ConnectorServices.JNDI_STRATEGY_SERVICE, jndiStrategyService).install();\n\n        updateContext.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_RAR_CONFIG, new RarDependencyProcessor());\n        updateContext.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_RA_DEPLOYMENT, new RaDeploymentParsingProcessor());\n        updateContext.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_IRON_JACAMAR_DEPLOYMENT,\n                new IronJacamarDeploymentParsingProcessor());\n        updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_RA_DEPLOYMENT, new ParsedRaDeploymentProcessor());\n        updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_RA_XML_DEPLOYMENT, new RaXmlDeploymentProcessor(\n                mdrService.getValue()));\n        updateContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_RAR, new RaStructureProcessor());\n        updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_JDBC_DRIVER, new DriverProcessor());\n    }","id":97307,"modified_method":"/**\n     * Activate the services required for service deployments.\n     * @param updateContext The update context\n     */\n    public void activate(final BootOperationContext updateContext, final ServiceTarget serviceTarget) {\n        // add resources here\n        MdrService mdrService = new MdrService();\n        serviceTarget.addService(ConnectorServices.IRONJACAMAR_MDR, mdrService).install();\n\n        RaRepositoryService raRepositoryService = new RaRepositoryService();\n        serviceTarget\n                .addService(ConnectorServices.RA_REPOSISTORY_SERVICE, raRepositoryService)\n                .addDependency(ConnectorServices.IRONJACAMAR_MDR, MetadataRepository.class,\n                        raRepositoryService.getMdrInjector()).install();\n\n        ResourceAdapterDeploymentRegistryService registryService = new ResourceAdapterDeploymentRegistryService();\n        serviceTarget.addService(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE, registryService)\n                .addDependency(ConnectorServices.IRONJACAMAR_MDR).install();\n\n        JndiStrategyService jndiStrategyService = new JndiStrategyService();\n        serviceTarget.addService(ConnectorServices.JNDI_STRATEGY_SERVICE, jndiStrategyService).install();\n\n        updateContext.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_RAR_CONFIG, new RarDependencyProcessor());\n        updateContext.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_RA_DEPLOYMENT, new RaDeploymentParsingProcessor());\n        updateContext.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_IRON_JACAMAR_DEPLOYMENT,\n                new IronJacamarDeploymentParsingProcessor());\n        updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_RA_DEPLOYMENT, new ParsedRaDeploymentProcessor());\n        updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_RA_XML_DEPLOYMENT, new RaXmlDeploymentProcessor(\n                mdrService.getValue()));\n        updateContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_RAR, new RaStructureProcessor());\n        updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_JDBC_DRIVER, new DriverProcessor());\n    }","commit_id":"c3fa941dda24d0ed60537f1c15c0468d64efe4ff","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(StartContext context) throws StartException {\n        log.debugf(\"Starting sevice RaRepositoryService\");\n    }","id":97308,"modified_method":"@Override\n    public void start(StartContext context) throws StartException {\n        ((SimpleResourceAdapterRepository) value).setMetadataRepository(mdrValue.getValue());\n        log.debugf(\"Starting sevice RaRepositoryService\");\n    }","commit_id":"c3fa941dda24d0ed60537f1c15c0468d64efe4ff","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Creates an {@code IdentityTrustManager}\n     *\n     * @param securityDomain name of the security domain\n     * @return an instance of {@code IdentityTrustManager}\n     * @throws Exception if creation fails\n     */\n    private IdentityTrustManager createIdentityTrustManager(String securityDomain) throws Exception {\n        int i = identityTrustManagerClassName.lastIndexOf(\":\");\n        if (i == -1)\n            throw SecurityMessages.MESSAGES.missingModuleName(\"identity trust manager class\");\n        String moduleSpec = identityTrustManagerClassName.substring(0, i);\n        String className = identityTrustManagerClassName.substring(i + 1);\n        Class<?> clazz = SecurityActions.getModuleClassLoader(moduleSpec).loadClass(className);\n        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class });\n        return (IdentityTrustManager) ctr.newInstance(new Object[] { securityDomain });\n    }","id":97309,"modified_method":"/**\n     * Creates an {@code IdentityTrustManager}\n     *\n     * @param securityDomain name of the security domain\n     * @return an instance of {@code IdentityTrustManager}\n     * @throws Exception if creation fails\n     */\n    private IdentityTrustManager createIdentityTrustManager(String securityDomain) throws Exception {\n        int i = identityTrustManagerClassName.lastIndexOf(\":\");\n        if (i == -1)\n            throw SecurityMessages.MESSAGES.missingModuleName(\"identity trust manager class\");\n        String moduleSpec = identityTrustManagerClassName.substring(0, i);\n        String className = identityTrustManagerClassName.substring(i + 1);\n        Class<?> clazz = SecurityActions.getModuleClassLoader(loader, moduleSpec).loadClass(className);\n        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class });\n        return (IdentityTrustManager) ctr.newInstance(new Object[] { securityDomain });\n    }","commit_id":"56b557e95b2630acb45585b07bc04f24a1f0c034","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ConcurrentHashMap<String, SecurityDomainContext> getSecurityManagerMap() {\n        return securityMgrMap;\n    }","id":97310,"modified_method":"public JNDIBasedSecurityManagement(ModuleLoader loader) {\n        this.loader = loader;\n    }","commit_id":"56b557e95b2630acb45585b07bc04f24a1f0c034","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Creates an {@code AuthorizationManager}\n     *\n     * @param securityDomain name of the security domain\n     * @return an instance of {@code AuthorizationManager}\n     * @throws Exception if creation fails\n     */\n    private AuthorizationManager createAuthorizationManager(String securityDomain) throws Exception {\n        int i = authorizationManagerClassName.lastIndexOf(\":\");\n        if (i == -1)\n            throw SecurityMessages.MESSAGES.missingModuleName(\"authorization manager class\");\n        String moduleSpec = authorizationManagerClassName.substring(0, i);\n        String className = authorizationManagerClassName.substring(i + 1);\n        Class<?> clazz = SecurityActions.getModuleClassLoader(moduleSpec).loadClass(className);\n        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class });\n        return (AuthorizationManager) ctr.newInstance(new Object[] { securityDomain });\n    }","id":97311,"modified_method":"/**\n     * Creates an {@code AuthorizationManager}\n     *\n     * @param securityDomain name of the security domain\n     * @return an instance of {@code AuthorizationManager}\n     * @throws Exception if creation fails\n     */\n    private AuthorizationManager createAuthorizationManager(String securityDomain) throws Exception {\n        int i = authorizationManagerClassName.lastIndexOf(\":\");\n        if (i == -1)\n            throw SecurityMessages.MESSAGES.missingModuleName(\"authorization manager class\");\n        String moduleSpec = authorizationManagerClassName.substring(0, i);\n        String className = authorizationManagerClassName.substring(i + 1);\n        Class<?> clazz = SecurityActions.getModuleClassLoader(loader, moduleSpec).loadClass(className);\n        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class });\n        return (AuthorizationManager) ctr.newInstance(new Object[] { securityDomain });\n    }","commit_id":"56b557e95b2630acb45585b07bc04f24a1f0c034","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Creates an {@code AuditManager}\n     *\n     * @param securityDomain name of the security domain\n     * @return an instance of {@code AuditManager}\n     * @throws Exception if creation fails\n     */\n    private AuditManager createAuditManager(String securityDomain) throws Exception {\n        int i = auditManagerClassName.lastIndexOf(\":\");\n        if (i == -1)\n            throw SecurityMessages.MESSAGES.missingModuleName(\"audit manager class\");\n        String moduleSpec = auditManagerClassName.substring(0, i);\n        String className = auditManagerClassName.substring(i + 1);\n        Class<?> clazz = SecurityActions.getModuleClassLoader(moduleSpec).loadClass(className);\n        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class });\n        return (AuditManager) ctr.newInstance(new Object[] { securityDomain });\n    }","id":97312,"modified_method":"/**\n     * Creates an {@code AuditManager}\n     *\n     * @param securityDomain name of the security domain\n     * @return an instance of {@code AuditManager}\n     * @throws Exception if creation fails\n     */\n    private AuditManager createAuditManager(String securityDomain) throws Exception {\n        int i = auditManagerClassName.lastIndexOf(\":\");\n        if (i == -1)\n            throw SecurityMessages.MESSAGES.missingModuleName(\"audit manager class\");\n        String moduleSpec = auditManagerClassName.substring(0, i);\n        String className = auditManagerClassName.substring(i + 1);\n        Class<?> clazz = SecurityActions.getModuleClassLoader(loader, moduleSpec).loadClass(className);\n        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class });\n        return (AuditManager) ctr.newInstance(new Object[] { securityDomain });\n    }","commit_id":"56b557e95b2630acb45585b07bc04f24a1f0c034","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Creates an {@code MappingManager}\n     *\n     * @param securityDomain name of the security domain\n     * @return an instance of {@code MappingManager}\n     * @throws Exception if creation fails\n     */\n    private MappingManager createMappingManager(String securityDomain) throws Exception {\n        int i = mappingManagerClassName.lastIndexOf(\":\");\n        if (i == -1)\n            throw SecurityMessages.MESSAGES.missingModuleName(\"mapping manager class\");\n        String moduleSpec = mappingManagerClassName.substring(0, i);\n        String className = mappingManagerClassName.substring(i + 1);\n        Class<?> clazz = SecurityActions.getModuleClassLoader(moduleSpec).loadClass(className);\n        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class });\n        return (MappingManager) ctr.newInstance(new Object[] { securityDomain });\n    }","id":97313,"modified_method":"/**\n     * Creates an {@code MappingManager}\n     *\n     * @param securityDomain name of the security domain\n     * @return an instance of {@code MappingManager}\n     * @throws Exception if creation fails\n     */\n    private MappingManager createMappingManager(String securityDomain) throws Exception {\n        int i = mappingManagerClassName.lastIndexOf(\":\");\n        if (i == -1)\n            throw SecurityMessages.MESSAGES.missingModuleName(\"mapping manager class\");\n        String moduleSpec = mappingManagerClassName.substring(0, i);\n        String className = mappingManagerClassName.substring(i + 1);\n        Class<?> clazz = SecurityActions.getModuleClassLoader(loader, moduleSpec).loadClass(className);\n        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class });\n        return (MappingManager) ctr.newInstance(new Object[] { securityDomain });\n    }","commit_id":"56b557e95b2630acb45585b07bc04f24a1f0c034","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Creates an {@code AuthenticationManager}\n     *\n     * @param securityDomain name of the security domain\n     * @return an instance of {@code AuthenticationManager}\n     * @throws Exception if creation fails\n     */\n    private AuthenticationManager createAuthenticationManager(String securityDomain) throws Exception {\n        int i = callbackHandlerClassName.lastIndexOf(\":\");\n        if (i == -1)\n            throw SecurityMessages.MESSAGES.missingModuleName(\"default-callback-handler-class-name attribute\");\n        String moduleSpec = callbackHandlerClassName.substring(0, i);\n        String className = callbackHandlerClassName.substring(i + 1);\n        Class<?> callbackHandlerClazz = SecurityActions.getModuleClassLoader(moduleSpec).loadClass(className);\n        CallbackHandler ch = (CallbackHandler) callbackHandlerClazz.newInstance();\n\n        i = authenticationManagerClassName.lastIndexOf(\":\");\n        if (i == -1)\n            throw SecurityMessages.MESSAGES.missingModuleName(\"authentication-manager-class-name attribute\");\n        moduleSpec = authenticationManagerClassName.substring(0, i);\n        className = authenticationManagerClassName.substring(i + 1);\n        Class<?> clazz = SecurityActions.getModuleClassLoader(moduleSpec).loadClass(className);\n        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class, CallbackHandler.class });\n        return (AuthenticationManager) ctr.newInstance(new Object[] { securityDomain, ch });\n    }","id":97314,"modified_method":"/**\n     * Creates an {@code AuthenticationManager}\n     *\n     * @param securityDomain name of the security domain\n     * @return an instance of {@code AuthenticationManager}\n     * @throws Exception if creation fails\n     */\n    private AuthenticationManager createAuthenticationManager(String securityDomain) throws Exception {\n        int i = callbackHandlerClassName.lastIndexOf(\":\");\n        if (i == -1)\n            throw SecurityMessages.MESSAGES.missingModuleName(\"default-callback-handler-class-name attribute\");\n        String moduleSpec = callbackHandlerClassName.substring(0, i);\n        String className = callbackHandlerClassName.substring(i + 1);\n        Class<?> callbackHandlerClazz = SecurityActions.getModuleClassLoader(loader, moduleSpec).loadClass(className);\n        CallbackHandler ch = (CallbackHandler) callbackHandlerClazz.newInstance();\n\n        i = authenticationManagerClassName.lastIndexOf(\":\");\n        if (i == -1)\n            throw SecurityMessages.MESSAGES.missingModuleName(\"authentication-manager-class-name attribute\");\n        moduleSpec = authenticationManagerClassName.substring(0, i);\n        className = authenticationManagerClassName.substring(i + 1);\n        Class<?> clazz = SecurityActions.getModuleClassLoader(loader, moduleSpec).loadClass(className);\n        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class, CallbackHandler.class });\n        return (AuthenticationManager) ctr.newInstance(new Object[] { securityDomain, ch });\n    }","commit_id":"56b557e95b2630acb45585b07bc04f24a1f0c034","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ClassLoader get(String key) {\n        try {\n            ClassLoader moduleClassLoader = SecurityActions.getModuleClassLoader(key);\n            ClassLoader tccl = SecurityActions.getContextClassLoader();\n            /**\n             * A Login Module can be in a custom user module.\n             * The local resources (such as users.properties) can be present in a web deployment,\n             * whose CL is available on the TCCL.\n             */\n            return new CombinedClassLoader(moduleClassLoader, tccl);\n        } catch (ModuleLoadException e) {\n            throw SecurityMessages.MESSAGES.runtimeException(e);\n        }\n    }","id":97315,"modified_method":"@Override\n    public ClassLoader get(String key) {\n        try {\n            ClassLoader moduleClassLoader = SecurityActions.getModuleClassLoader(moduleLoader, key);\n            ClassLoader tccl = SecurityActions.getContextClassLoader();\n            /**\n             * A Login Module can be in a custom user module.\n             * The local resources (such as users.properties) can be present in a web deployment,\n             * whose CL is available on the TCCL.\n             */\n            return new CombinedClassLoader(moduleClassLoader, tccl);\n        } catch (ModuleLoadException e) {\n            throw SecurityMessages.MESSAGES.runtimeException(e);\n        }\n    }","commit_id":"56b557e95b2630acb45585b07bc04f24a1f0c034","url":"https://github.com/wildfly/wildfly"},{"original_method":"static ModuleClassLoader getModuleClassLoader(final String moduleSpec) throws ModuleLoadException {\n        if (System.getSecurityManager() != null) {\n            try {\n                return AccessController.doPrivileged(new PrivilegedExceptionAction<ModuleClassLoader>() {\n                    public ModuleClassLoader run() throws ModuleLoadException {\n                        ModuleLoader loader = Module.getCallerModuleLoader();\n                        ModuleIdentifier identifier = ModuleIdentifier.fromString(moduleSpec);\n                        return loader.loadModule(identifier).getClassLoader();\n                    }\n                });\n            } catch (PrivilegedActionException pae) {\n                throw SecurityMessages.MESSAGES.moduleLoadException(pae);\n            }\n        } else {\n            ModuleLoader loader = Module.getCallerModuleLoader();\n            ModuleIdentifier identifier = ModuleIdentifier.fromString(moduleSpec);\n            return loader.loadModule(identifier).getClassLoader();\n        }\n    }","id":97316,"modified_method":"static ModuleClassLoader getModuleClassLoader(final ModuleLoader loader, final String moduleSpec) throws ModuleLoadException {\n        if (System.getSecurityManager() != null) {\n            try {\n                return AccessController.doPrivileged(new PrivilegedExceptionAction<ModuleClassLoader>() {\n                    public ModuleClassLoader run() throws ModuleLoadException {\n                        ModuleIdentifier identifier = ModuleIdentifier.fromString(moduleSpec);\n                        return loader.loadModule(identifier).getClassLoader();\n                    }\n                });\n            } catch (PrivilegedActionException pae) {\n                throw SecurityMessages.MESSAGES.moduleLoadException(pae);\n            }\n        } else {\n            ModuleIdentifier identifier = ModuleIdentifier.fromString(moduleSpec);\n            return loader.loadModule(identifier).getClassLoader();\n        }\n    }","commit_id":"56b557e95b2630acb45585b07bc04f24a1f0c034","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void start(StartContext context) throws StartException {\n        log.debugf(\"Starting SecurityBootstrapService\");\n        try {\n            //Print out the current version of PicketBox\n            SecurityLogger.ROOT_LOGGER.currentVersion(org.picketbox.Version.VERSION);\n\n            // Get the current Policy impl\n            oldPolicy = Policy.getPolicy();\n            String provider = SecurityActions.getSystemProperty(JACC_POLICY_PROVIDER,\n                    \"org.jboss.security.jacc.DelegatingPolicy\");\n            Class<?> providerClass = SecurityActions.loadClass(provider);\n            try {\n                // Look for a ctor(Policy) signature\n                Class<?>[] ctorSig = { Policy.class };\n                Constructor<?> ctor = providerClass.getConstructor(ctorSig);\n                Object[] ctorArgs = { oldPolicy };\n                jaccPolicy = (Policy) ctor.newInstance(ctorArgs);\n            } catch (NoSuchMethodException e) {\n                log.debugf(\"Provider does not support ctor(Policy)\");\n                try {\n                    jaccPolicy = (Policy) providerClass.newInstance();\n                } catch (Exception e1) {\n                    throw SecurityMessages.MESSAGES.unableToStartException(\"SecurityBootstrapService\", e1);\n                }\n            } catch (Exception e) {\n                throw SecurityMessages.MESSAGES.unableToStartException(\"SecurityBootstrapService\", e);\n            }\n\n            // Install the JACC policy provider\n            Policy.setPolicy(jaccPolicy);\n\n            // Have the policy load/update itself\n            jaccPolicy.refresh();\n\n            // Register the default active Subject PolicyContextHandler\n            SubjectPolicyContextHandler handler = new SubjectPolicyContextHandler();\n            PolicyContext.registerHandler(SecurityConstants.SUBJECT_CONTEXT_KEY, handler, true);\n\n            // Register the JAAS CallbackHandler JACC PolicyContextHandlers\n            CallbackHandlerPolicyContextHandler chandler = new CallbackHandlerPolicyContextHandler();\n            PolicyContext.registerHandler(SecurityConstants.CALLBACK_HANDLER_KEY, chandler, true);\n\n            //Register a module classloader locator\n            ClassLoaderLocatorFactory.set(new ModuleClassLoaderLocator());\n        } catch (Exception e) {\n            throw SecurityMessages.MESSAGES.unableToStartException(\"SecurityBootstrapService\", e);\n        }\n    }","id":97317,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void start(StartContext context) throws StartException {\n        log.debugf(\"Starting SecurityBootstrapService\");\n        try {\n            //Print out the current version of PicketBox\n            SecurityLogger.ROOT_LOGGER.currentVersion(org.picketbox.Version.VERSION);\n\n            // Get the current Policy impl\n            oldPolicy = Policy.getPolicy();\n            String provider = SecurityActions.getSystemProperty(JACC_POLICY_PROVIDER,\n                    \"org.jboss.security.jacc.DelegatingPolicy\");\n            Class<?> providerClass = SecurityActions.loadClass(provider);\n            try {\n                // Look for a ctor(Policy) signature\n                Class<?>[] ctorSig = { Policy.class };\n                Constructor<?> ctor = providerClass.getConstructor(ctorSig);\n                Object[] ctorArgs = { oldPolicy };\n                jaccPolicy = (Policy) ctor.newInstance(ctorArgs);\n            } catch (NoSuchMethodException e) {\n                log.debugf(\"Provider does not support ctor(Policy)\");\n                try {\n                    jaccPolicy = (Policy) providerClass.newInstance();\n                } catch (Exception e1) {\n                    throw SecurityMessages.MESSAGES.unableToStartException(\"SecurityBootstrapService\", e1);\n                }\n            } catch (Exception e) {\n                throw SecurityMessages.MESSAGES.unableToStartException(\"SecurityBootstrapService\", e);\n            }\n\n            // Install the JACC policy provider\n            Policy.setPolicy(jaccPolicy);\n\n            // Have the policy load/update itself\n            jaccPolicy.refresh();\n\n            // Register the default active Subject PolicyContextHandler\n            SubjectPolicyContextHandler handler = new SubjectPolicyContextHandler();\n            PolicyContext.registerHandler(SecurityConstants.SUBJECT_CONTEXT_KEY, handler, true);\n\n            // Register the JAAS CallbackHandler JACC PolicyContextHandlers\n            CallbackHandlerPolicyContextHandler chandler = new CallbackHandlerPolicyContextHandler();\n            PolicyContext.registerHandler(SecurityConstants.CALLBACK_HANDLER_KEY, chandler, true);\n\n            //Register a module classloader locator\n            ClassLoaderLocatorFactory.set(new ModuleClassLoaderLocator(moduleLoaderValue.getValue()));\n        } catch (Exception e) {\n            throw SecurityMessages.MESSAGES.unableToStartException(\"SecurityBootstrapService\", e);\n        }\n    }","commit_id":"56b557e95b2630acb45585b07bc04f24a1f0c034","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void start(StartContext context) throws StartException {\n        log.debugf(\"Starting SecurityManagementService\");\n        // set properties of JNDIBasedSecurityManagement\n        JNDIBasedSecurityManagement securityManagement = new JNDIBasedSecurityManagement();\n        securityManagement.setAuthenticationManagerClassName(authenticationManagerClassName);\n        securityManagement.setDeepCopySubjectMode(deepCopySubjectMode);\n        securityManagement.setCallbackHandlerClassName(callbackHandlerClassName);\n        securityManagement.setAuthorizationManagerClassName(authorizationManagerClassName);\n        securityManagement.setAuditManagerClassName(auditManagerClassName);\n        securityManagement.setIdentityTrustManagerClassName(identityTrustManagerClassName);\n        securityManagement.setMappingManagerClassName(mappingManagerClassName);\n        this.securityManagement = securityManagement;\n    }","id":97318,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void start(StartContext context) throws StartException {\n        log.debugf(\"Starting SecurityManagementService\");\n        // set properties of JNDIBasedSecurityManagement\n        JNDIBasedSecurityManagement securityManagement = new JNDIBasedSecurityManagement(serviceModuleLoaderValue.getValue());\n        securityManagement.setAuthenticationManagerClassName(authenticationManagerClassName);\n        securityManagement.setDeepCopySubjectMode(deepCopySubjectMode);\n        securityManagement.setCallbackHandlerClassName(callbackHandlerClassName);\n        securityManagement.setAuthorizationManagerClassName(authorizationManagerClassName);\n        securityManagement.setAuditManagerClassName(auditManagerClassName);\n        securityManagement.setIdentityTrustManagerClassName(identityTrustManagerClassName);\n        securityManagement.setMappingManagerClassName(mappingManagerClassName);\n        this.securityManagement = securityManagement;\n    }","commit_id":"56b557e95b2630acb45585b07bc04f24a1f0c034","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n            SecurityLogger.ROOT_LOGGER.activatingSecuritySubsystem();\n\n            final ServiceTarget target = context.getServiceTarget();\n\n            final SecurityBootstrapService bootstrapService = new SecurityBootstrapService();\n            newControllers.add(target.addService(SecurityBootstrapService.SERVICE_NAME, bootstrapService)\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            context.addStep(new AbstractDeploymentChainStep() {\n                protected void execute(DeploymentProcessorTarget processorTarget) {\n\n                }\n            }, OperationContext.Stage.RUNTIME);\n\n            // add service to bind SecurityDomainJndiInjectable to JNDI\n            final SecurityDomainJndiInjectable securityDomainJndiInjectable = new SecurityDomainJndiInjectable();\n            final BinderService binderService = new BinderService(\"jaas\");\n            newControllers.add(target.addService(ContextNames.JBOSS_CONTEXT_SERVICE_NAME.append(\"jaas\"), binderService)\n                .addInjection(binderService.getManagedObjectInjector(), securityDomainJndiInjectable)\n                .addDependency(ContextNames.JBOSS_CONTEXT_SERVICE_NAME, ServiceBasedNamingStore.class, binderService.getNamingStoreInjector())\n                .addDependency(SecurityManagementService.SERVICE_NAME, ISecurityManagement.class, securityDomainJndiInjectable.getSecurityManagementInjector())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            // add security management service\n            ModelNode modelNode = model.get(Constants.DEEP_COPY_SUBJECT_MODE);\n            final SecurityManagementService securityManagementService = new SecurityManagementService(\n                AUTHENTICATION_MANAGER, modelNode.isDefined() && modelNode.asBoolean(), CALLBACK_HANDLER,\n                AUTHORIZATION_MANAGER, AUDIT_MANAGER, IDENTITY_TRUST_MANAGER, MAPPING_MANAGER);\n            newControllers.add(target.addService(SecurityManagementService.SERVICE_NAME, securityManagementService)\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            // add subject factory service\n            final SubjectFactoryService subjectFactoryService = new SubjectFactoryService(SUBJECT_FACTORY);\n            newControllers.add(target.addService(SubjectFactoryService.SERVICE_NAME, subjectFactoryService)\n                .addDependency(SecurityManagementService.SERVICE_NAME, ISecurityManagement.class,\n                        subjectFactoryService.getSecurityManagementInjector())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            // add jaas configuration service\n            Configuration loginConfig = XMLLoginConfigImpl.getInstance();\n            final JaasConfigurationService jaasConfigurationService = new JaasConfigurationService(loginConfig);\n            newControllers.add(target.addService(JaasConfigurationService.SERVICE_NAME, jaasConfigurationService)\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            newControllers.add(target.addService(SimpleSecurityManagerService.SERVICE_NAME, new SimpleSecurityManagerService())\n                .addListener(verificationHandler).install());\n\n            context.addStep(new AbstractDeploymentChainStep() {\n                protected void execute(DeploymentProcessorTarget processorTarget) {\n                    processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_JACC_POLICY,\n                            new JaccEarDeploymentProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_SECURITY,\n                            new SecurityDependencyProcessor());\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }","id":97319,"modified_method":"@Override\n        protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n            SecurityLogger.ROOT_LOGGER.activatingSecuritySubsystem();\n\n            final ServiceTarget target = context.getServiceTarget();\n\n            final SecurityBootstrapService bootstrapService = new SecurityBootstrapService();\n            newControllers.add(target.addService(SecurityBootstrapService.SERVICE_NAME, bootstrapService)\n                .addDependency(Services.JBOSS_SERVICE_MODULE_LOADER, ServiceModuleLoader.class, bootstrapService.getServiceModuleLoaderInjectedValue())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            context.addStep(new AbstractDeploymentChainStep() {\n                protected void execute(DeploymentProcessorTarget processorTarget) {\n\n                }\n            }, OperationContext.Stage.RUNTIME);\n\n            // add service to bind SecurityDomainJndiInjectable to JNDI\n            final SecurityDomainJndiInjectable securityDomainJndiInjectable = new SecurityDomainJndiInjectable();\n            final BinderService binderService = new BinderService(\"jaas\");\n            newControllers.add(target.addService(ContextNames.JBOSS_CONTEXT_SERVICE_NAME.append(\"jaas\"), binderService)\n                .addInjection(binderService.getManagedObjectInjector(), securityDomainJndiInjectable)\n                .addDependency(ContextNames.JBOSS_CONTEXT_SERVICE_NAME, ServiceBasedNamingStore.class, binderService.getNamingStoreInjector())\n                .addDependency(SecurityManagementService.SERVICE_NAME, ISecurityManagement.class, securityDomainJndiInjectable.getSecurityManagementInjector())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            // add security management service\n            ModelNode modelNode = model.get(Constants.DEEP_COPY_SUBJECT_MODE);\n            final SecurityManagementService securityManagementService = new SecurityManagementService(\n                AUTHENTICATION_MANAGER, modelNode.isDefined() && modelNode.asBoolean(), CALLBACK_HANDLER,\n                AUTHORIZATION_MANAGER, AUDIT_MANAGER, IDENTITY_TRUST_MANAGER, MAPPING_MANAGER);\n            newControllers.add(target.addService(SecurityManagementService.SERVICE_NAME, securityManagementService)\n                 .addDependency(Services.JBOSS_SERVICE_MODULE_LOADER, ServiceModuleLoader.class, securityManagementService.getServiceModuleLoaderInjectedValue())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            // add subject factory service\n            final SubjectFactoryService subjectFactoryService = new SubjectFactoryService(SUBJECT_FACTORY);\n            newControllers.add(target.addService(SubjectFactoryService.SERVICE_NAME, subjectFactoryService)\n                .addDependency(SecurityManagementService.SERVICE_NAME, ISecurityManagement.class,\n                        subjectFactoryService.getSecurityManagementInjector())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            // add jaas configuration service\n            Configuration loginConfig = XMLLoginConfigImpl.getInstance();\n            final JaasConfigurationService jaasConfigurationService = new JaasConfigurationService(loginConfig);\n            newControllers.add(target.addService(JaasConfigurationService.SERVICE_NAME, jaasConfigurationService)\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            newControllers.add(target.addService(SimpleSecurityManagerService.SERVICE_NAME, new SimpleSecurityManagerService())\n                .addListener(verificationHandler).install());\n\n            context.addStep(new AbstractDeploymentChainStep() {\n                protected void execute(DeploymentProcessorTarget processorTarget) {\n                    processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_JACC_POLICY,\n                            new JaccEarDeploymentProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_SECURITY,\n                            new SecurityDependencyProcessor());\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }","commit_id":"56b557e95b2630acb45585b07bc04f24a1f0c034","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n            SecurityLogger.ROOT_LOGGER.activatingSecuritySubsystem();\n\n            final ServiceTarget target = context.getServiceTarget();\n\n            final SecurityBootstrapService bootstrapService = new SecurityBootstrapService();\n            newControllers.add(target.addService(SecurityBootstrapService.SERVICE_NAME, bootstrapService)\n                .addDependency(Services.JBOSS_SERVICE_MODULE_LOADER, ServiceModuleLoader.class, bootstrapService.getServiceModuleLoaderInjectedValue())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            context.addStep(new AbstractDeploymentChainStep() {\n                protected void execute(DeploymentProcessorTarget processorTarget) {\n\n                }\n            }, OperationContext.Stage.RUNTIME);\n\n            // add service to bind SecurityDomainJndiInjectable to JNDI\n            final SecurityDomainJndiInjectable securityDomainJndiInjectable = new SecurityDomainJndiInjectable();\n            final BinderService binderService = new BinderService(\"jaas\");\n            newControllers.add(target.addService(ContextNames.JBOSS_CONTEXT_SERVICE_NAME.append(\"jaas\"), binderService)\n                .addInjection(binderService.getManagedObjectInjector(), securityDomainJndiInjectable)\n                .addDependency(ContextNames.JBOSS_CONTEXT_SERVICE_NAME, ServiceBasedNamingStore.class, binderService.getNamingStoreInjector())\n                .addDependency(SecurityManagementService.SERVICE_NAME, ISecurityManagement.class, securityDomainJndiInjectable.getSecurityManagementInjector())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            // add security management service\n            ModelNode modelNode = model.get(Constants.DEEP_COPY_SUBJECT_MODE);\n            final SecurityManagementService securityManagementService = new SecurityManagementService(\n                AUTHENTICATION_MANAGER, modelNode.isDefined() && modelNode.asBoolean(), CALLBACK_HANDLER,\n                AUTHORIZATION_MANAGER, AUDIT_MANAGER, IDENTITY_TRUST_MANAGER, MAPPING_MANAGER);\n            newControllers.add(target.addService(SecurityManagementService.SERVICE_NAME, securityManagementService)\n                 .addDependency(Services.JBOSS_SERVICE_MODULE_LOADER, ServiceModuleLoader.class, securityManagementService.getServiceModuleLoaderInjectedValue())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            // add subject factory service\n            final SubjectFactoryService subjectFactoryService = new SubjectFactoryService(SUBJECT_FACTORY);\n            newControllers.add(target.addService(SubjectFactoryService.SERVICE_NAME, subjectFactoryService)\n                .addDependency(SecurityManagementService.SERVICE_NAME, ISecurityManagement.class,\n                        subjectFactoryService.getSecurityManagementInjector())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            // add jaas configuration service\n            Configuration loginConfig = XMLLoginConfigImpl.getInstance();\n            final JaasConfigurationService jaasConfigurationService = new JaasConfigurationService(loginConfig);\n            newControllers.add(target.addService(JaasConfigurationService.SERVICE_NAME, jaasConfigurationService)\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            newControllers.add(target.addService(SimpleSecurityManagerService.SERVICE_NAME, new SimpleSecurityManagerService())\n                .addListener(verificationHandler).install());\n\n            context.addStep(new AbstractDeploymentChainStep() {\n                protected void execute(DeploymentProcessorTarget processorTarget) {\n                    processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_JACC_POLICY,\n                            new JaccEarDeploymentProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_SECURITY,\n                            new SecurityDependencyProcessor());\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }","id":97320,"modified_method":"@Override\n        protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n            SecurityLogger.ROOT_LOGGER.activatingSecuritySubsystem();\n\n            final ServiceTarget target = context.getServiceTarget();\n\n            final SecurityBootstrapService bootstrapService = new SecurityBootstrapService();\n            newControllers.add(target.addService(SecurityBootstrapService.SERVICE_NAME, bootstrapService)\n                .addDependency(Services.JBOSS_SERVICE_MODULE_LOADER, ServiceModuleLoader.class, bootstrapService.getServiceModuleLoaderInjectedValue())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            context.addStep(new AbstractDeploymentChainStep() {\n                protected void execute(DeploymentProcessorTarget processorTarget) {\n\n                }\n            }, OperationContext.Stage.RUNTIME);\n\n            // add service to bind SecurityDomainJndiInjectable to JNDI\n            final SecurityDomainJndiInjectable securityDomainJndiInjectable = new SecurityDomainJndiInjectable();\n            final BinderService binderService = new BinderService(\"jaas\");\n            newControllers.add(target.addService(ContextNames.JBOSS_CONTEXT_SERVICE_NAME.append(\"jaas\"), binderService)\n                .addInjection(binderService.getManagedObjectInjector(), securityDomainJndiInjectable)\n                .addDependency(ContextNames.JBOSS_CONTEXT_SERVICE_NAME, ServiceBasedNamingStore.class, binderService.getNamingStoreInjector())\n                .addDependency(SecurityManagementService.SERVICE_NAME, ISecurityManagement.class, securityDomainJndiInjectable.getSecurityManagementInjector())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            // add security management service\n            ModelNode modelNode = model.get(Constants.DEEP_COPY_SUBJECT_MODE);\n            final SecurityManagementService securityManagementService = new SecurityManagementService(\n                AUTHENTICATION_MANAGER, modelNode.isDefined() && modelNode.asBoolean(), CALLBACK_HANDLER,\n                AUTHORIZATION_MANAGER, AUDIT_MANAGER, IDENTITY_TRUST_MANAGER, MAPPING_MANAGER);\n            newControllers.add(target.addService(SecurityManagementService.SERVICE_NAME, securityManagementService)\n                 .addDependency(Services.JBOSS_SERVICE_MODULE_LOADER, ServiceModuleLoader.class, securityManagementService.getServiceModuleLoaderInjectedValue())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            // add subject factory service\n            final SubjectFactoryService subjectFactoryService = new SubjectFactoryService(SUBJECT_FACTORY);\n            newControllers.add(target.addService(SubjectFactoryService.SERVICE_NAME, subjectFactoryService)\n                .addDependency(SecurityManagementService.SERVICE_NAME, ISecurityManagement.class,\n                        subjectFactoryService.getSecurityManagementInjector())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            // add jaas configuration service\n            Configuration loginConfig = XMLLoginConfigImpl.getInstance();\n            final JaasConfigurationService jaasConfigurationService = new JaasConfigurationService(loginConfig);\n            newControllers.add(target.addService(JaasConfigurationService.SERVICE_NAME, jaasConfigurationService)\n                .addListener(verificationHandler).setInitialMode(ServiceController.Mode.ACTIVE).install());\n\n            //add Simple Security Manager Service\n            final SimpleSecurityManagerService simpleSecurityManagerService = new SimpleSecurityManagerService();\n\n            newControllers.add(target.addService(SimpleSecurityManagerService.SERVICE_NAME, simpleSecurityManagerService)\n                .addDependency(SecurityManagementService.SERVICE_NAME, ISecurityManagement.class,\n                            simpleSecurityManagerService.getSecurityManagementInjector())\n                .addListener(verificationHandler).install());\n\n            context.addStep(new AbstractDeploymentChainStep() {\n                protected void execute(DeploymentProcessorTarget processorTarget) {\n                    processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_JACC_POLICY,\n                            new JaccEarDeploymentProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_SECURITY,\n                            new SecurityDependencyProcessor());\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }","commit_id":"d5dc2d894b1317c60a9a523e05413e49034f67f9","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static SecurityContext establishSecurityContext(final String securityDomain) {\n        // Do not use SecurityFactory.establishSecurityContext, its static init is broken.\n        try {\n            final SecurityContext securityContext = SecurityContextFactory.createSecurityContext(securityDomain);\n            SecurityContextAssociation.setSecurityContext(securityContext);\n            return securityContext;\n        } catch (Exception e) {\n            throw SecurityMessages.MESSAGES.securityException(e);\n        }\n    }","id":97321,"modified_method":"private static SecurityContext establishSecurityContext(final String securityDomain) {\n        // Do not use SecurityFactory.establishSecurityContext, its static init is broken.\n        try {\n            final SecurityContext securityContext = SecurityContextFactory.createSecurityContext(securityDomain);\n            securityContext.setSecurityManagement(securityManagement);\n            SecurityContextAssociation.setSecurityContext(securityContext);\n            return securityContext;\n        } catch (Exception e) {\n            throw SecurityMessages.MESSAGES.securityException(e);\n        }\n    }","commit_id":"d5dc2d894b1317c60a9a523e05413e49034f67f9","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(StartContext context) throws StartException {\n    }","id":97322,"modified_method":"@Override\n    public void start(StartContext context) throws StartException {\n        securityManager.setSecurityManagement(securityManagementValue.getValue());\n    }","commit_id":"d5dc2d894b1317c60a9a523e05413e49034f67f9","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Returns all interfaces implemented by a bean that are eligible to be business interfaces\n     *\n     * @param sessionBeanClass The bean class\n     * @return A collection of all potential business interfaces\n     */\n    private static Set<Class<?>> getPotentialBusinessInterfaces(Class<?> sessionBeanClass) {\n        Class<?>[] interfaces = sessionBeanClass.getInterfaces();\n        if (interfaces == null) {\n            return Collections.emptySet();\n        }\n        final Set<Class<?>> potentialBusinessInterfaces = new HashSet<Class<?>>();\n        for (Class<?> klass : interfaces) {\n            // EJB 3.1 FR 4.9.7 bullet 5.3\n            if (klass.equals(Serializable.class) ||\n                    klass.equals(Externalizable.class) ||\n                    klass.getName().startsWith(\"javax.ejb.\")) {\n                continue;\n            }\n            potentialBusinessInterfaces.add(klass);\n        }\n        return potentialBusinessInterfaces;\n    }","id":97323,"modified_method":"/**\n     * Returns all interfaces implemented by a bean that are eligible to be business interfaces\n     *\n     * @param sessionBeanClass The bean class\n     * @return A collection of all potential business interfaces\n     */\n    private static Set<Class<?>> getPotentialBusinessInterfaces(Class<?> sessionBeanClass) {\n        return getPotentialViewInterfaces(sessionBeanClass);\n    }","commit_id":"40d75e45ae34363e5cc630b983eaf0c94b4daceb","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) {\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                    // add the metadata parser deployment processor\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_DEPLOYMENT, new EjbJarParsingDeploymentUnitProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_CREATE_COMPONENT_DESCRIPTIONS, new EJBComponentDescriptionFactory());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_SESSION_BEAN_DD, new SessionBeanXmlDescriptorProcessor());\n                    //processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_ANNOTATION, new EjbAnnotationProcessor());\n                    // Process @DependsOn after the @Singletons have been registered.\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_CONTEXT_BINDING, new EjbContextJndiBindingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_TIMERSERVICE_BINDING, new TimerServiceJndiBindingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_TRANSACTION_MANAGEMENT, new TransactionManagementAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_INJECTION_ANNOTATION, new EjbResourceInjectionAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_STARTUP_ANNOTATION, new StartupAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_CONCURRENCY_MANAGEMENT_ANNOTATION, new ConcurrencyManagementAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_LOCK_ANNOTATION, new LockAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_DECLARE_ROLES_ANNOTATION, new DeclareRolesProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_RUN_AS_ANNOTATION, new RunAsProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_STATEFUL_TIMEOUT_ANNOTATION, new StatefulTimeoutAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_ACCESS_TIMEOUT_ANNOTATION, new AccessTimeoutAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_TRANSACTION_ATTR_ANNOTATION, new TransactionAttributeAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_SESSION_SYNCHRONIZATION, new SessionSynchronizationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_RESOURCE_ADAPTER_ANNOTATION, new ResourceAdapterAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_ASYNCHRONOUS_ANNOTATION, new AsynchronousAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_APPLICATION_EXCEPTION_ANNOTATION, new ApplicationExceptionAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_REMOVE_METHOD_ANNOTAION, new RemoveAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_DD_INTERCEPTORS, new InterceptorClassDeploymentDescriptorProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_ASSEMBLY_DESC_DD, new AssemblyDescriptorProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_SECURITY_ROLE_REF_DD, new SecurityRoleRefDDProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_SECURITY_IDENTITY_DD, new SecurityIdentityDDProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_SECURITY_DOMAIN_ANNOTATION, new SecurityDomainProcessor());\n\n\n                    processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_EJB, new EjbDependencyDeploymentUnitProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_BUSINESS_VIEW_ANNOTATION, new BusinessViewAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_IMPLICIT_NO_INTERFACE_VIEW, new ImplicitLocalViewProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_JNDI_BINDINGS, new EjbJndiBindingsDeploymentUnitProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_MODULE_CONFIGURATION, new EjbJarConfigurationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_INTERCEPTORS, new DeploymentDescriptorInterceptorBindingsProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_CONCURRENCY, new EjbConcurrencyProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_METHOD_RESOLUTION, new DeploymentDescriptorMethodProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_REMOVE_METHOD, new RemoveMethodDeploymentDescriptorProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_DENY_ALL_ANNOTATION, new DenyAllProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_ROLES_ALLOWED_ANNOTATION, new RolesAllowedProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_PERMIT_ALL_ANNOTATION, new PermitAllProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_EXCLUDE_LIST_DD, new ExcludeListDDProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_METHOD_PERMISSION_DD, new MethodPermissionDDProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_REF, new EjbRefProcessor());\n\n                    processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_RESOLVE_EJB_INJECTIONS, new EjbInjectionResolutionProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_DEPENDS_ON_ANNOTATION, new EjbDependsOnAnnotationProcessor());\n\n\n                    // add the real deployment processor\n                    // TODO: add the proper deployment processors\n                    // processorTarget.addDeploymentProcessor(processor, priority);\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final EJBUtilities utilities = new EJBUtilities();\n        newControllers.add(serviceTarget.addService(EJBUtilities.SERVICE_NAME, utilities)\n                .addDependency(SimpleSecurityManagerService.SERVICE_NAME, SimpleSecurityManager.class, utilities.getSecurityManagerInjector())\n                .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, TransactionManager.class, utilities.getTransactionManagerInjector())\n                .addDependency(TxnServices.JBOSS_TXN_SYNCHRONIZATION_REGISTRY, TransactionSynchronizationRegistry.class, utilities.getTransactionSynchronizationRegistryInjector())\n                .addDependency(TxnServices.JBOSS_TXN_USER_TRANSACTION, UserTransaction.class, utilities.getUserTransactionInjector())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install());\n\n    }","id":97324,"modified_method":"protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) {\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                    // add the metadata parser deployment processor\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_DEPLOYMENT, new EjbJarParsingDeploymentUnitProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_CREATE_COMPONENT_DESCRIPTIONS, new EJBComponentDescriptionFactory());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_SESSION_BEAN_DD, new SessionBeanXmlDescriptorProcessor());\n                    //processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_ANNOTATION, new EjbAnnotationProcessor());\n                    // Process @DependsOn after the @Singletons have been registered.\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_CONTEXT_BINDING, new EjbContextJndiBindingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_TIMERSERVICE_BINDING, new TimerServiceJndiBindingProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_TRANSACTION_MANAGEMENT, new TransactionManagementAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_INJECTION_ANNOTATION, new EjbResourceInjectionAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_STARTUP_ANNOTATION, new StartupAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_CONCURRENCY_MANAGEMENT_ANNOTATION, new ConcurrencyManagementAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_LOCK_ANNOTATION, new LockAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_DECLARE_ROLES_ANNOTATION, new DeclareRolesProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_RUN_AS_ANNOTATION, new RunAsProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_STATEFUL_TIMEOUT_ANNOTATION, new StatefulTimeoutAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_ACCESS_TIMEOUT_ANNOTATION, new AccessTimeoutAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_TRANSACTION_ATTR_ANNOTATION, new TransactionAttributeAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_SESSION_SYNCHRONIZATION, new SessionSynchronizationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_RESOURCE_ADAPTER_ANNOTATION, new ResourceAdapterAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_ASYNCHRONOUS_ANNOTATION, new AsynchronousAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_APPLICATION_EXCEPTION_ANNOTATION, new ApplicationExceptionAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_REMOVE_METHOD_ANNOTAION, new RemoveAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_DD_INTERCEPTORS, new InterceptorClassDeploymentDescriptorProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_ASSEMBLY_DESC_DD, new AssemblyDescriptorProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_SECURITY_ROLE_REF_DD, new SecurityRoleRefDDProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_SECURITY_IDENTITY_DD, new SecurityIdentityDDProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EJB_SECURITY_DOMAIN_ANNOTATION, new SecurityDomainProcessor());\n\n\n                    processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_EJB, new EjbDependencyDeploymentUnitProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_BUSINESS_VIEW_ANNOTATION, new BusinessViewAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_IMPLICIT_NO_INTERFACE_VIEW, new ImplicitLocalViewProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_JNDI_BINDINGS, new EjbJndiBindingsDeploymentUnitProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_MODULE_CONFIGURATION, new EjbJarConfigurationProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_INTERCEPTORS, new DeploymentDescriptorInterceptorBindingsProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_CONCURRENCY, new EjbConcurrencyProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_METHOD_RESOLUTION, new DeploymentDescriptorMethodProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_REMOVE_METHOD, new RemoveMethodDeploymentDescriptorProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_DENY_ALL_ANNOTATION, new DenyAllProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_ROLES_ALLOWED_ANNOTATION, new RolesAllowedProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_PERMIT_ALL_ANNOTATION, new PermitAllProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_EXCLUDE_LIST_DD, new ExcludeListDDProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_METHOD_PERMISSION_DD, new MethodPermissionDDProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_EJB_REF, new EjbRefProcessor());\n\n                    processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_RESOLVE_EJB_INJECTIONS, new EjbInjectionResolutionProcessor());\n                    processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_DEPENDS_ON_ANNOTATION, new EjbDependsOnAnnotationProcessor());\n\n\n                    // add the real deployment processor\n                    // TODO: add the proper deployment processors\n                    // processorTarget.addDeploymentProcessor(processor, priority);\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final EJBUtilities utilities = new EJBUtilities();\n        newControllers.add(serviceTarget.addService(EJBUtilities.SERVICE_NAME, utilities)\n                .addDependency(ConnectorServices.RA_REPOSISTORY_SERVICE, ResourceAdapterRepository.class, utilities.getResourceAdapterRepositoryInjector())\n                .addDependency(SimpleSecurityManagerService.SERVICE_NAME, SimpleSecurityManager.class, utilities.getSecurityManagerInjector())\n                .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, TransactionManager.class, utilities.getTransactionManagerInjector())\n                .addDependency(TxnServices.JBOSS_TXN_SYNCHRONIZATION_REGISTRY, TransactionSynchronizationRegistry.class, utilities.getTransactionSynchronizationRegistryInjector())\n                .addDependency(TxnServices.JBOSS_TXN_USER_TRANSACTION, UserTransaction.class, utilities.getUserTransactionInjector())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install());\n\n    }","commit_id":"40d75e45ae34363e5cc630b983eaf0c94b4daceb","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param ejbComponentCreateService the component configuration\n     */\n    protected EJBComponent(final EJBComponentCreateService ejbComponentCreateService) {\n        super(ejbComponentCreateService);\n\n\n        this.applicationExceptions = Collections.unmodifiableMap(ejbComponentCreateService.getEjbJarConfiguration().getApplicationExceptions());\n\n        // constructs\n        final DeploymentUnit deploymentUnit = ejbComponentCreateService.getDeploymentUnitInjector().getValue();\n        final ServiceController<EJBUtilities> serviceController = (ServiceController<EJBUtilities>) deploymentUnit.getServiceRegistry().getRequiredService(EJBUtilities.SERVICE_NAME);\n        this.utilities = serviceController.getValue();\n\n\n        txAttrs = ejbComponentCreateService.getTxAttrs();\n        isBeanManagedTransaction = TransactionManagementType.BEAN.equals(ejbComponentCreateService.getTransactionManagementType());\n\n        // security metadata\n        this.securityMetaData = ejbComponentCreateService.getSecurityMetaData();\n\n        this.viewServices = ejbComponentCreateService.getViewServices();\n    }","id":97325,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param ejbComponentCreateService the component configuration\n     */\n    protected EJBComponent(final EJBComponentCreateService ejbComponentCreateService) {\n        super(ejbComponentCreateService);\n\n\n        this.applicationExceptions = Collections.unmodifiableMap(ejbComponentCreateService.getEjbJarConfiguration().getApplicationExceptions());\n\n        this.utilities = ejbComponentCreateService.getEJBUtilities();\n\n\n        txAttrs = ejbComponentCreateService.getTxAttrs();\n        isBeanManagedTransaction = TransactionManagementType.BEAN.equals(ejbComponentCreateService.getTransactionManagementType());\n\n        // security metadata\n        this.securityMetaData = ejbComponentCreateService.getSecurityMetaData();\n\n        this.viewServices = ejbComponentCreateService.getViewServices();\n    }","commit_id":"40d75e45ae34363e5cc630b983eaf0c94b4daceb","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void processMessageBeans(final DeploymentUnit deploymentUnit, final Collection<AnnotationInstance> messageBeanAnnotations) {\n        if (messageBeanAnnotations.isEmpty())\n            return;\n\n        final EjbJarDescription ejbJarDescription = getEjbJarDescription(deploymentUnit);\n        final ServiceName deploymentUnitServiceName = deploymentUnit.getServiceName();\n\n        for (final AnnotationInstance messageBeanAnnotation : messageBeanAnnotations) {\n            final AnnotationTarget target = messageBeanAnnotation.target();\n            final ClassInfo beanClassInfo = (ClassInfo) target;\n            final String ejbName = beanClassInfo.name().local();\n            final AnnotationValue nameValue = messageBeanAnnotation.value(\"name\");\n            final String beanName = nameValue == null || nameValue.asString().isEmpty() ? ejbName : nameValue.asString();\n            final MessageDrivenBeanMetaData beanMetaData = getEnterpriseBeanMetaData(deploymentUnit, beanName, MessageDrivenBeanMetaData.class);\n            final String beanClassName;\n            if (beanMetaData != null) {\n                beanClassName = override(beanClassInfo.name().toString(), beanMetaData.getEjbClass());\n            } else {\n                beanClassName = beanClassInfo.name().toString();\n            }\n\n            final String messageListenerInterfaceName = messageBeanAnnotation.value(\"messageListenerInterface\").asClass().name().toString();\n            // TODO: if messageListenerInterface is not set use the implemented interface\n\n            final MessageDrivenComponentDescription beanDescription = new MessageDrivenComponentDescription(beanName, beanClassName, ejbJarDescription, deploymentUnitServiceName, messageListenerInterfaceName);\n\n            // Add this component description to module description\n            ejbJarDescription.getEEModuleDescription().addComponent(beanDescription);\n        }\n\n        EjbDeploymentMarker.mark(deploymentUnit);\n    }","id":97326,"modified_method":"private static void processMessageBeans(final DeploymentUnit deploymentUnit, final Collection<AnnotationInstance> messageBeanAnnotations) throws DeploymentUnitProcessingException {\n        if (messageBeanAnnotations.isEmpty())\n            return;\n\n        final EjbJarDescription ejbJarDescription = getEjbJarDescription(deploymentUnit);\n        final ServiceName deploymentUnitServiceName = deploymentUnit.getServiceName();\n\n        for (final AnnotationInstance messageBeanAnnotation : messageBeanAnnotations) {\n            final AnnotationTarget target = messageBeanAnnotation.target();\n            final ClassInfo beanClassInfo = (ClassInfo) target;\n            final String ejbName = beanClassInfo.name().local();\n            final AnnotationValue nameValue = messageBeanAnnotation.value(\"name\");\n            final String beanName = nameValue == null || nameValue.asString().isEmpty() ? ejbName : nameValue.asString();\n            final MessageDrivenBeanMetaData beanMetaData = getEnterpriseBeanMetaData(deploymentUnit, beanName, MessageDrivenBeanMetaData.class);\n            final String beanClassName;\n            final String messageListenerInterfaceName;\n            final Properties activationConfigProperties = getActivationConfigProperties(messageBeanAnnotation);\n            if (beanMetaData != null) {\n                beanClassName = override(beanClassInfo.name().toString(), beanMetaData.getEjbClass());\n                final String messagingType = beanMetaData.getMessagingType();\n                messageListenerInterfaceName = messagingType != null ? messagingType : getMessageListenerInterface(messageBeanAnnotation);\n                final ActivationConfigMetaData activationConfigMetaData = beanMetaData.getActivationConfig();\n                if (activationConfigMetaData != null) {\n                    final ActivationConfigPropertiesMetaData propertiesMetaData = activationConfigMetaData.getActivationConfigProperties();\n                    if (propertiesMetaData != null) {\n                        for (ActivationConfigPropertyMetaData propertyMetaData : propertiesMetaData) {\n                            activationConfigProperties.put(propertyMetaData.getKey(), propertyMetaData.getValue());\n                        }\n                    }\n                }\n            } else {\n                beanClassName = beanClassInfo.name().toString();\n                messageListenerInterfaceName = getMessageListenerInterface(messageBeanAnnotation);\n            }\n\n            final MessageDrivenComponentDescription beanDescription = new MessageDrivenComponentDescription(beanName, beanClassName, ejbJarDescription, deploymentUnitServiceName, messageListenerInterfaceName, activationConfigProperties);\n\n            // Add this component description to module description\n            ejbJarDescription.getEEModuleDescription().addComponent(beanDescription);\n        }\n\n        EjbDeploymentMarker.mark(deploymentUnit);\n    }","commit_id":"40d75e45ae34363e5cc630b983eaf0c94b4daceb","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param ejbComponentCreateService the component configuration\n     */\n    protected MessageDrivenComponent(final MessageDrivenComponentCreateService ejbComponentCreateService, final Class<?> messageListenerInterface) {\n        super(ejbComponentCreateService);\n\n        StatelessObjectFactory<MessageDrivenComponentInstance> factory = new StatelessObjectFactory<MessageDrivenComponentInstance>() {\n            @Override\n            public MessageDrivenComponentInstance create() {\n                return (MessageDrivenComponentInstance) createInstance();\n            }\n\n            @Override\n            public void destroy(MessageDrivenComponentInstance obj) {\n                throw new RuntimeException(\"NYI\");\n                //destroyInstance(obj);\n            }\n        };\n        this.pool = new StrictMaxPool<MessageDrivenComponentInstance>(factory, 20, 5, TimeUnit.MINUTES);\n\n        this.messageListenerInterface = messageListenerInterface;\n        final MessageEndpointService<?> service = new MessageEndpointService<Object>() {\n            @Override\n            public Class<Object> getMessageListenerInterface() {\n                return (Class<Object>) messageListenerInterface;\n            }\n\n            @Override\n            public TransactionManager getTransactionManager() {\n                return getTransactionManager();\n            }\n\n            @Override\n            public boolean isDeliveryTransacted(Method method) throws NoSuchMethodException {\n                // an MDB doesn't expose a real view\n                return getTransactionAttributeType(BEAN, method) == REQUIRED;\n            }\n\n            @Override\n            public Object obtain(long timeout, TimeUnit unit) {\n                // like this it's a disconnected invocation\n//                return getComponentView(messageListenerInterface).getViewForInstance(null);\n                return createViewInstanceProxy(messageListenerInterface, emptyMap());\n            }\n\n            @Override\n            public void release(Object obj) {\n                // do nothing\n            }\n        };\n        this.endpointFactory = new JBossMessageEndpointFactory(service);\n    }","id":97327,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param ejbComponentCreateService the component configuration\n     */\n    protected MessageDrivenComponent(final MessageDrivenComponentCreateService ejbComponentCreateService, final Class<?> messageListenerInterface, final ActivationSpec activationSpec) {\n        super(ejbComponentCreateService);\n\n        StatelessObjectFactory<MessageDrivenComponentInstance> factory = new StatelessObjectFactory<MessageDrivenComponentInstance>() {\n            @Override\n            public MessageDrivenComponentInstance create() {\n                return (MessageDrivenComponentInstance) createInstance();\n            }\n\n            @Override\n            public void destroy(MessageDrivenComponentInstance obj) {\n                throw new RuntimeException(\"NYI\");\n                //destroyInstance(obj);\n            }\n        };\n        this.pool = new StrictMaxPool<MessageDrivenComponentInstance>(factory, 20, 5, TimeUnit.MINUTES);\n\n        this.activationSpec = activationSpec;\n        this.messageListenerInterface = messageListenerInterface;\n        final MessageEndpointService<?> service = new MessageEndpointService<Object>() {\n            @Override\n            public Class<Object> getMessageListenerInterface() {\n                return (Class<Object>) messageListenerInterface;\n            }\n\n            @Override\n            public TransactionManager getTransactionManager() {\n                return getTransactionManager();\n            }\n\n            @Override\n            public boolean isDeliveryTransacted(Method method) throws NoSuchMethodException {\n                // an MDB doesn't expose a real view\n                return getTransactionAttributeType(BEAN, method) == REQUIRED;\n            }\n\n            @Override\n            public Object obtain(long timeout, TimeUnit unit) {\n                // like this it's a disconnected invocation\n//                return getComponentView(messageListenerInterface).getViewForInstance(null);\n                return createViewInstanceProxy(messageListenerInterface, emptyMap());\n            }\n\n            @Override\n            public void release(Object obj) {\n                // do nothing\n            }\n        };\n        this.endpointFactory = new JBossMessageEndpointFactory(service);\n    }","commit_id":"40d75e45ae34363e5cc630b983eaf0c94b4daceb","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param componentConfiguration the component configuration\n     */\n    public MessageDrivenComponentCreateService(final ComponentConfiguration componentConfiguration, final EjbJarConfiguration ejbJarConfiguration) {\n        super(componentConfiguration, ejbJarConfiguration);\n\n        this.raServiceName = ((MessageDrivenComponentDescription) componentConfiguration.getComponentDescription()).getResourceAdapterServiceName();\n\n        // see MessageDrivenComponentDescription.<init>\n        this.messageListenerInterface = componentConfiguration.getViews().get(0).getViewClass();\n    }","id":97328,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param componentConfiguration the component configuration\n     */\n    public MessageDrivenComponentCreateService(final ComponentConfiguration componentConfiguration, final EjbJarConfiguration ejbJarConfiguration) {\n        super(componentConfiguration, ejbJarConfiguration);\n\n        final MessageDrivenComponentDescription componentDescription = (MessageDrivenComponentDescription) componentConfiguration.getComponentDescription();\n        this.resourceAdapterName = componentDescription.getResourceAdapterName();\n        this.raServiceName = componentDescription.getResourceAdapterServiceName();\n\n        // see MessageDrivenComponentDescription.<init>\n        this.messageListenerInterface = componentConfiguration.getViews().get(0).getViewClass();\n\n        this.activationProps = componentDescription.getActivationProps();\n    }","commit_id":"40d75e45ae34363e5cc630b983eaf0c94b4daceb","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected BasicComponent createComponent() {\n        final MessageDrivenComponent component = new MessageDrivenComponent(this, messageListenerInterface);\n        // TODO: should be injected by start service\n        final ResourceAdapter resourceAdapter = getRequiredService(raServiceName, ResourceAdapter.class).getValue();\n        component.setResourceAdapter(resourceAdapter);\n        return component;\n    }","id":97329,"modified_method":"@Override\n    protected BasicComponent createComponent() {\n        final ActivationSpec activationSpec = getEndpointDeployer().createActivationSpecs(resourceAdapterName, messageListenerInterface, activationProps, getDeploymentClassLoader());\n        //final ActivationSpec activationSpec = null;\n        final MessageDrivenComponent component = new MessageDrivenComponent(this, messageListenerInterface, activationSpec);\n        // TODO: should be injected by start service\n        final ResourceAdapter resourceAdapter = getRequiredService(raServiceName, ResourceAdapter.class).getValue();\n        component.setResourceAdapter(resourceAdapter);\n        try {\n            activationSpec.setResourceAdapter(resourceAdapter);\n        } catch (ResourceException e) {\n            throw new RuntimeException(e);\n        }\n        return component;\n    }","commit_id":"40d75e45ae34363e5cc630b983eaf0c94b4daceb","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param componentName      the component name\n     * @param componentClassName the component instance class name\n     * @param ejbJarDescription  the module description\n     */\n    public MessageDrivenComponentDescription(final String componentName, final String componentClassName, final EjbJarDescription ejbJarDescription,\n                                             final ServiceName deploymentUnitServiceName, final String messageListenerInterfaceName) {\n        super(componentName, componentClassName, ejbJarDescription, deploymentUnitServiceName);\n        if (messageListenerInterfaceName == null || messageListenerInterfaceName.isEmpty())\n            throw new IllegalArgumentException(\"Cannot set null or empty string as message listener interface\");\n        registerView(messageListenerInterfaceName, MethodIntf.MESSAGE_ENDPOINT);\n    }","id":97330,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param componentName      the component name\n     * @param componentClassName the component instance class name\n     * @param ejbJarDescription  the module description\n     */\n    public MessageDrivenComponentDescription(final String componentName, final String componentClassName, final EjbJarDescription ejbJarDescription,\n                                             final ServiceName deploymentUnitServiceName, final String messageListenerInterfaceName, final Properties activationProps) {\n        super(componentName, componentClassName, ejbJarDescription, deploymentUnitServiceName);\n        if (messageListenerInterfaceName == null || messageListenerInterfaceName.isEmpty())\n            throw new IllegalArgumentException(\"Cannot set null or empty string as message listener interface\");\n\n        this.activationProps = activationProps;\n\n        registerView(messageListenerInterfaceName, MethodIntf.MESSAGE_ENDPOINT);\n\n        getConfigurators().add(new ComponentConfigurator() {\n            @Override\n            public void configure(DeploymentPhaseContext context, ComponentDescription description, ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n                description.addDependency(getResourceAdapterServiceName(), ServiceBuilder.DependencyType.REQUIRED);\n            }\n        });\n    }","commit_id":"40d75e45ae34363e5cc630b983eaf0c94b4daceb","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void setResourceAdapterName(String resourceAdapterName) {\n        if (resourceAdapterName == null || resourceAdapterName.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Resource adapter name cannot be null or empty\");\n        }\n        this.resourceAdapterName = resourceAdapterName;\n        // setup the dependency\n        String raDeploymentName = resourceAdapterName;\n        // See RaDeploymentParsingProcessor\n        if (this.resourceAdapterName.endsWith(\".rar\")) {\n            raDeploymentName = this.resourceAdapterName.substring(0, resourceAdapterName.indexOf(\".rar\"));\n        }\n        // See ResourceAdapterDeploymentService\n        this.resourceAdapterServiceName = ServiceName.of(raDeploymentName);\n        this.addDependency(resourceAdapterServiceName, ServiceBuilder.DependencyType.REQUIRED);\n    }","id":97331,"modified_method":"public void setResourceAdapterName(String resourceAdapterName) {\n        if (resourceAdapterName == null || resourceAdapterName.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Resource adapter name cannot be null or empty\");\n        }\n        this.resourceAdapterName = resourceAdapterName;\n    }","commit_id":"40d75e45ae34363e5cc630b983eaf0c94b4daceb","url":"https://github.com/wildfly/wildfly"},{"original_method":"ServiceName getResourceAdapterServiceName() {\n        return resourceAdapterServiceName;\n    }","id":97332,"modified_method":"ServiceName getResourceAdapterServiceName() {\n        String raDeploymentName = resourceAdapterName;\n        // See RaDeploymentParsingProcessor\n        if (this.resourceAdapterName.endsWith(\".rar\")) {\n            raDeploymentName = this.resourceAdapterName.substring(0, resourceAdapterName.indexOf(\".rar\"));\n        }\n        // See ResourceAdapterDeploymentService\n        return ServiceName.of(raDeploymentName);\n    }","commit_id":"40d75e45ae34363e5cc630b983eaf0c94b4daceb","url":"https://github.com/wildfly/wildfly"},{"original_method":"public synchronized void start(final StartContext context) throws StartException {\n        // Global configuration.\n\n        // Logging environment config\n        commonPropertyManager.getLoggingEnvironmentBean().setLoggingFactory(\"com.arjuna.common.internal.util.logging.jakarta.JakartaRelevelingLogFactory;com.arjuna.common.internal.util.logging.jakarta.Log4JLogger\");\n\n        // Recovery env bean\n        final RecoveryEnvironmentBean recoveryEnvironmentBean = recoveryPropertyManager.getRecoveryEnvironmentBean();\n        recoveryEnvironmentBean.setRecoveryInetAddress(null); // todo - service binding\n        recoveryEnvironmentBean.setRecoveryPort(0); // todo - service binding\n        recoveryEnvironmentBean.setTransactionStatusManagerInetAddress(null); // todo - service binding\n        recoveryEnvironmentBean.setTransactionStatusManagerPort(0); // todo - service binding\n        final List<String> recoveryExtensions = new ArrayList<String>();\n\n\n        final ORB orb = orbInjector.getValue();\n\n        if (orb != null) {\n            // IIOP is enabled, so fire up JTS mode.\n            final com.arjuna.ats.jbossatx.jts.TransactionManagerService service = new com.arjuna.ats.jbossatx.jts.TransactionManagerService();\n            service.setJbossXATerminator(xaTerminatorInjector.getValue());\n            service.setTransactionSynchronizationRegistry(registryInjector.getValue());\n            recoveryExtensions.add(\"com.arjuna.ats.internal.arjuna.recovery.AtomicActionRecoveryModule\");\n            recoveryExtensions.add(\"com.arjuna.ats.internal.txoj.recovery.TORecoveryModule\");\n            recoveryExtensions.add(\"com.arjuna.ats.internal.jts.recovery.transactions.TopLevelTransactionRecoveryModule\");\n            recoveryExtensions.add(\"com.arjuna.ats.internal.jts.recovery.transactions.ServerTransactionRecoveryModule\");\n            recoveryExtensions.add(\"com.arjuna.ats.internal.jta.recovery.jts.XARecoveryModule\");\n            recoveryEnvironmentBean.setRecoveryExtensions(recoveryExtensions);\n            try {\n                service.create();\n            } catch (Exception e) {\n                throw new StartException(\"Create failed\", e);\n            }\n            try {\n                service.start(orb);\n            } catch (Exception e) {\n                throw new StartException(\"Start failed\", e);\n            }\n            value = service;\n        } else {\n            // No IIOP, stick with JTA mode.\n            final com.arjuna.ats.jbossatx.jta.TransactionManagerService service = new com.arjuna.ats.jbossatx.jta.TransactionManagerService();\n            service.setJbossXATerminator(xaTerminatorInjector.getValue());\n            service.setTransactionSynchronizationRegistry(registryInjector.getValue());\n            recoveryExtensions.add(\"com.arjuna.ats.internal.arjuna.recovery.AtomicActionRecoveryModule\");\n            recoveryExtensions.add(\"com.arjuna.ats.internal.txoj.recovery.TORecoveryModule\");\n            recoveryExtensions.add(\"com.arjuna.ats.internal.jta.recovery.arjunacore.XARecoveryModule\");\n            recoveryEnvironmentBean.setRecoveryExtensions(recoveryExtensions);\n            try {\n                service.create();\n            } catch (Exception e) {\n                throw new StartException(\"Create failed\", e);\n            }\n            service.start();\n            value = service;\n        }\n    }","id":97333,"modified_method":"public synchronized void start(final StartContext context) throws StartException {\n        // Global configuration.\n\n        // Logging environment config\n        final LoggingEnvironmentBean loggingEnvironmentBean = commonPropertyManager.getLoggingEnvironmentBean();\n        loggingEnvironmentBean.setLoggingFactory(JakartaRelevelingLogFactory.class.getName() + \";\" + Log4JLogger.class.getName());\n\n        // Recovery env bean\n        final RecoveryEnvironmentBean recoveryEnvironmentBean = recoveryPropertyManager.getRecoveryEnvironmentBean();\n        recoveryEnvironmentBean.setRecoveryInetAddress(null); // todo - service binding\n        recoveryEnvironmentBean.setRecoveryPort(0); // todo - service binding\n        recoveryEnvironmentBean.setTransactionStatusManagerInetAddress(null); // todo - service binding\n        recoveryEnvironmentBean.setTransactionStatusManagerPort(0); // todo - service binding\n\n        final List<String> recoveryExtensions = new ArrayList<String>();\n        final List<String> expiryScanners = new ArrayList<String>();\n\n        recoveryExtensions.add(AtomicActionRecoveryModule.class.getName());\n        recoveryExtensions.add(TORecoveryModule.class.getName());\n\n        expiryScanners.add(ExpiredTransactionStatusManagerScanner.class.getName());\n\n        final CoreEnvironmentBean coreEnvironmentBean = arjPropertyManager.getCoreEnvironmentBean();\n        coreEnvironmentBean.setSocketProcessIdPort(0); // todo -service binding\n        coreEnvironmentBean.setNodeIdentifier(\"1\"); // todo - configurable?\n        coreEnvironmentBean.setSocketProcessIdMaxPorts(10); // todo - configurable?\n\n        final JTAEnvironmentBean jtaEnvironmentBean = jtaPropertyManager.getJTAEnvironmentBean();\n        jtaEnvironmentBean.setLastResourceOptimisationInterface(LastResource.class.getName());\n        jtaEnvironmentBean.setXaRecoveryNodes(Collections.singletonList(\"1\"));\n        jtaEnvironmentBean.setXaResourceOrphanFilterClassNames(Arrays.asList(JTATransactionLogXAResourceOrphanFilter.class.getName(), JTANodeNameXAResourceOrphanFilter.class.getName()));\n\n        final CoordinatorEnvironmentBean coordinatorEnvironmentBean = arjPropertyManager.getCoordinatorEnvironmentBean();\n        coordinatorEnvironmentBean.setEnableStatistics(false); // todo - configurable?\n        coordinatorEnvironmentBean.setDefaultTimeout(300); // todo - configurable!\n\n        final ObjectStoreEnvironmentBean objectStoreEnvironmentBean = arjPropertyManager.getObjectStoreEnvironmentBean();\n        objectStoreEnvironmentBean.setObjectStoreDir(\"/tmp/tx-object-store\"); // todo - configurable!\n\n        try {\n            ObjStoreBean.getObjectStoreBrowserBean();\n        } catch (Exception e) {\n            throw new StartException(\"Failed to configure object store browser bean\", e);\n        }\n\n        final RecoveryManagerService recoveryManagerService = new RecoveryManagerService();\n\n        final ORB orb = orbInjector.getValue();\n\n        if (orb == null) {\n            // No IIOP, stick with JTA mode.\n            final com.arjuna.ats.jbossatx.jta.TransactionManagerService service = new com.arjuna.ats.jbossatx.jta.TransactionManagerService();\n            service.setJbossXATerminator(xaTerminatorInjector.getValue());\n            service.setTransactionSynchronizationRegistry(new com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple());\n            recoveryExtensions.add(com.arjuna.ats.internal.jta.recovery.arjunacore.XARecoveryModule.class.getName());\n            recoveryEnvironmentBean.setRecoveryExtensions(recoveryExtensions);\n            recoveryEnvironmentBean.setExpiryScanners(expiryScanners);\n            recoveryEnvironmentBean.setRecoveryActivators(null);\n            jtaEnvironmentBean.setTransactionManagerClassName(com.arjuna.ats.jbossatx.jta.TransactionManagerDelegate.class.getName());\n            jtaEnvironmentBean.setUserTransactionClassName(com.arjuna.ats.internal.jta.transaction.arjunacore.UserTransactionImple.class.getName());\n            try {\n                recoveryManagerService.create();\n            } catch (Exception e) {\n                throw new StartException(\"Recovery manager create failed\", e);\n            }\n            recoveryManagerService.start();\n            try {\n                service.create();\n            } catch (Exception e) {\n                throw new StartException(\"Transaction manager create failed\", e);\n            }\n            service.start();\n            value = service;\n        } else {\n            // IIOP is enabled, so fire up JTS mode.\n            final com.arjuna.ats.jbossatx.jts.TransactionManagerService service = new com.arjuna.ats.jbossatx.jts.TransactionManagerService();\n            service.setJbossXATerminator(xaTerminatorInjector.getValue());\n            service.setTransactionSynchronizationRegistry(new com.arjuna.ats.internal.jta.transaction.jts.TransactionSynchronizationRegistryImple());\n            recoveryExtensions.add(TopLevelTransactionRecoveryModule.class.getName());\n            recoveryExtensions.add(ServerTransactionRecoveryModule.class.getName());\n            recoveryExtensions.add(com.arjuna.ats.internal.jta.recovery.jts.XARecoveryModule.class.getName());\n            expiryScanners.add(ExpiredContactScanner.class.getName());\n            expiryScanners.add(ExpiredToplevelScanner.class.getName());\n            expiryScanners.add(ExpiredServerScanner.class.getName());\n            recoveryEnvironmentBean.setRecoveryExtensions(recoveryExtensions);\n            recoveryEnvironmentBean.setExpiryScanners(expiryScanners);\n            recoveryEnvironmentBean.setRecoveryActivators(Collections.singletonList(com.arjuna.ats.internal.jts.orbspecific.recovery.RecoveryEnablement.class.getName()));\n            jtaEnvironmentBean.setTransactionManagerClassName(com.arjuna.ats.jbossatx.jts.TransactionManagerDelegate.class.getName());\n            jtaEnvironmentBean.setUserTransactionClassName(com.arjuna.ats.internal.jta.transaction.jts.UserTransactionImple.class.getName());\n\n            try {\n                recoveryManagerService.create();\n            } catch (Exception e) {\n                throw new StartException(\"Recovery manager create failed\", e);\n            }\n            recoveryManagerService.start();\n\n            try {\n                service.create();\n            } catch (Exception e) {\n                throw new StartException(\"Create failed\", e);\n            }\n            try {\n                service.start(orb);\n            } catch (Exception e) {\n                throw new StartException(\"Start failed\", e);\n            }\n            value = service;\n        }\n        // todo: JNDI bindings\n    }","commit_id":"1804084d9a9fea6809bf5899bc44125d20c3d0c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void activate(final ServiceActivatorContext context) {\n        final BatchBuilder builder = context.getBatchBuilder();\n\n        // XATerminator has no deps, so just add it in there\n        final XATerminatorService xaTerminatorService = new XATerminatorService();\n        builder.addService(TxnServices.JBOSS_TXN_XA_TERMINATOR, xaTerminatorService);\n\n        final TransactionManagerService transactionManagerService = new TransactionManagerService();\n        builder.addService(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, transactionManagerService);\n\n        final TransactionManagerService transactionManagerPrivateService = new TransactionManagerService();\n        final BatchServiceBuilder<com.arjuna.ats.jbossatx.jta.TransactionManagerService> transactionManagerPrivateServiceBuilder = builder.addService(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER_PRIVATE, transactionManagerPrivateService);\n        transactionManagerPrivateServiceBuilder.addOptionalDependency(ServiceName.JBOSS.append(\"iiop\", \"orb\"), new CastingInjector<ORB>(transactionManagerPrivateService.getOrbInjector(), ORB.class));\n    }","id":97334,"modified_method":"public void activate(final ServiceActivatorContext context) {\n        final BatchBuilder builder = context.getBatchBuilder();\n\n        // XATerminator has no deps, so just add it in there\n        final XATerminatorService xaTerminatorService = new XATerminatorService();\n        builder.addService(TxnServices.JBOSS_TXN_XA_TERMINATOR, xaTerminatorService);\n\n        \n\n        final TransactionManagerService transactionManagerService = new TransactionManagerService();\n        final BatchServiceBuilder<TransactionManager> transactionManagerServiceBuilder = builder.addService(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, transactionManagerService);\n        transactionManagerServiceBuilder.addOptionalDependency(ServiceName.JBOSS.append(\"iiop\", \"orb\"), ORB.class, transactionManagerService.getOrbInjector());\n        transactionManagerServiceBuilder.addDependency(TxnServices.JBOSS_TXN_XA_TERMINATOR, JBossXATerminator.class, transactionManagerService.getXaTerminatorInjector());\n        transactionManagerServiceBuilder.addDependency(TxnServices.JBOSS_TXN_TRANSACTION_SYNCHRONIZATION_REGISTRY, TransactionSynchronizationRegistry.class, transactionManagerService.getTransactionSynchronizationRegistryInjector());\n    }","commit_id":"1804084d9a9fea6809bf5899bc44125d20c3d0c4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) {\n        final String shortRunningThreadPool = operation.get(DEFAULT_WORKMANAGER_SHORT_RUNNING_THREAD_POOL).asString();\n        final String longRunningThreadPool = operation.get(DEFAULT_WORKMANAGER_LONG_RUNNING_THREAD_POOL).asString();\n        final boolean beanValidationEnabled = ParamsUtils.parseBooleanParameter(operation, BEAN_VALIDATION_ENABLED, false);\n        final boolean archiveValidationEnabled = ParamsUtils\n                .parseBooleanParameter(operation, ARCHIVE_VALIDATION_ENABLED, false);\n        final boolean failOnError = ParamsUtils.parseBooleanParameter(operation, ARCHIVE_VALIDATION_FAIL_ON_ERROR, true);\n        final boolean failOnWarn = ParamsUtils.parseBooleanParameter(operation, ARCHIVE_VALIDATION_FAIL_ON_WARN, false);\n\n        // Apply to the model\n        final ModelNode model = context.getSubModel();\n\n        if (shortRunningThreadPool != null) {\n            model.get(DEFAULT_WORKMANAGER_SHORT_RUNNING_THREAD_POOL).set(shortRunningThreadPool);\n\n        }\n        if (longRunningThreadPool != null) {\n            model.get(DEFAULT_WORKMANAGER_LONG_RUNNING_THREAD_POOL).set(longRunningThreadPool);\n\n        }\n        if (ParamsUtils.has(operation, BEAN_VALIDATION_ENABLED)) {\n            model.get(BEAN_VALIDATION_ENABLED).set(beanValidationEnabled);\n        }\n        if (ParamsUtils.has(operation, ARCHIVE_VALIDATION_ENABLED)) {\n            model.get(ARCHIVE_VALIDATION_ENABLED).set(archiveValidationEnabled);\n        }\n        if (ParamsUtils.has(operation, ARCHIVE_VALIDATION_FAIL_ON_ERROR)) {\n            model.get(ARCHIVE_VALIDATION_FAIL_ON_ERROR).set(failOnError);\n        }\n        if (ParamsUtils.has(operation, ARCHIVE_VALIDATION_FAIL_ON_WARN)) {\n            model.get(ARCHIVE_VALIDATION_FAIL_ON_WARN).set(failOnWarn);\n        }\n\n        if (context instanceof BootOperationContext) {\n            final BootOperationContext bootContext = BootOperationContext.class.cast(context);\n            context.getRuntimeContext().setRuntimeTask(new RuntimeTask() {\n                public void execute(RuntimeTaskContext context) throws OperationFailedException {\n                    ServiceTarget serviceTarget = context.getServiceTarget();\n\n                    TransactionIntegrationService tiService = new TransactionIntegrationService();\n\n                    serviceTarget\n                            .addService(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, tiService)\n                            .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, TransactionManager.class,\n                                    tiService.getTmInjector())\n                            .addDependency(TxnServices.JBOSS_TXN_SYNCHRONIZATION_REGISTRY,\n                                    TransactionSynchronizationRegistry.class, tiService.getTsrInjector())\n                            .addDependency(TxnServices.JBOSS_TXN_USER_TRANSACTION_REGISTRY,\n                                    org.jboss.tm.usertx.UserTransactionRegistry.class, tiService.getUtrInjector())\n                            .addDependency(TxnServices.JBOSS_TXN_XA_TERMINATOR, JBossXATerminator.class,\n                                    tiService.getTerminatorInjector())\n                            .addDependency(TxnServices.JBOSS_TXN_ARJUNA_RECOVERY_MANAGER, XAResourceRecoveryRegistry.class,\n                                    tiService.getRrInjector())\n\n                            .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, TransactionLocalDelegate.class,\n                                    tiService.getTldInjector()).setInitialMode(Mode.ACTIVE).install();\n                    WorkManager wm = new WorkManagerImpl();\n\n                    final WorkManagerService wmService = new WorkManagerService(wm);\n                    serviceTarget\n                            .addService(ConnectorServices.WORKMANAGER_SERVICE, wmService)\n                            .addDependency(ThreadsServices.EXECUTOR.append(shortRunningThreadPool), Executor.class,\n                                    wmService.getExecutorShortInjector())\n                            .addDependency(ThreadsServices.EXECUTOR.append(longRunningThreadPool), Executor.class,\n                                    wmService.getExecutorLongInjector())\n                            .addDependency(TxnServices.JBOSS_TXN_XA_TERMINATOR, JBossXATerminator.class,\n                                    wmService.getXaTerminatorInjector()).setInitialMode(Mode.ACTIVE).install();\n\n                    CloneableBootstrapContext ctx = new BaseCloneableBootstrapContext();\n                    final DefaultBootStrapContextService defaultBootCtxService = new DefaultBootStrapContextService(ctx);\n                    serviceTarget\n                            .addService(ConnectorServices.DEFAULT_BOOTSTRAP_CONTEXT_SERVICE, defaultBootCtxService)\n                            .addDependency(ConnectorServices.WORKMANAGER_SERVICE, WorkManager.class,\n                                    defaultBootCtxService.getWorkManagerValueInjector())\n                            .addDependency(TxnServices.JBOSS_TXN_XA_TERMINATOR, JBossXATerminator.class,\n                                    defaultBootCtxService.getXaTerminatorInjector())\n                            .addDependency(TxnServices.JBOSS_TXN_ARJUNA_TRANSACTION_MANAGER,\n                                    com.arjuna.ats.jbossatx.jta.TransactionManagerService.class,\n                                    defaultBootCtxService.getTxManagerInjector()).setInitialMode(Mode.ACTIVE).install();\n                    final ConnectorSubsystemConfiguration config = new ConnectorSubsystemConfiguration();\n\n                    config.setArchiveValidation(archiveValidationEnabled);\n                    config.setArchiveValidationFailOnError(failOnError);\n                    config.setArchiveValidationFailOnWarn(failOnWarn);\n\n                    // FIXME Bean validation currently not used\n                    config.setBeanValidation(false);\n\n                    final ConnectorConfigService connectorConfigService = new ConnectorConfigService(config);\n                    serviceTarget\n                            .addService(ConnectorServices.CONNECTOR_CONFIG_SERVICE, connectorConfigService)\n                            .addDependency(ConnectorServices.DEFAULT_BOOTSTRAP_CONTEXT_SERVICE,\n                                    CloneableBootstrapContext.class,\n                                    connectorConfigService.getDefaultBootstrapContextInjector()).setInitialMode(Mode.ACTIVE)\n                            .install();\n\n                    new RaDeploymentActivator().activate(bootContext, serviceTarget);\n                    resultHandler.handleResultComplete(); // TODO: Listener\n                }\n            });\n\n        } else {\n            resultHandler.handleResultComplete();\n        }\n\n        // Compensating is remove\n        final ModelNode compensating = new ModelNode();\n        compensating.get(OP_ADDR).set(operation.require(ADDRESS));\n        compensating.get(OP).set(\"remove\");\n        return new BasicOperationResult(compensating);\n    }","id":97335,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) {\n        final String shortRunningThreadPool = operation.get(DEFAULT_WORKMANAGER_SHORT_RUNNING_THREAD_POOL).asString();\n        final String longRunningThreadPool = operation.get(DEFAULT_WORKMANAGER_LONG_RUNNING_THREAD_POOL).asString();\n        final boolean beanValidationEnabled = ParamsUtils.parseBooleanParameter(operation, BEAN_VALIDATION_ENABLED, false);\n        final boolean archiveValidationEnabled = ParamsUtils\n                .parseBooleanParameter(operation, ARCHIVE_VALIDATION_ENABLED, false);\n        final boolean failOnError = ParamsUtils.parseBooleanParameter(operation, ARCHIVE_VALIDATION_FAIL_ON_ERROR, true);\n        final boolean failOnWarn = ParamsUtils.parseBooleanParameter(operation, ARCHIVE_VALIDATION_FAIL_ON_WARN, false);\n\n        // Apply to the model\n        final ModelNode model = context.getSubModel();\n\n        if (shortRunningThreadPool != null) {\n            model.get(DEFAULT_WORKMANAGER_SHORT_RUNNING_THREAD_POOL).set(shortRunningThreadPool);\n\n        }\n        if (longRunningThreadPool != null) {\n            model.get(DEFAULT_WORKMANAGER_LONG_RUNNING_THREAD_POOL).set(longRunningThreadPool);\n\n        }\n        if (ParamsUtils.has(operation, BEAN_VALIDATION_ENABLED)) {\n            model.get(BEAN_VALIDATION_ENABLED).set(beanValidationEnabled);\n        }\n        if (ParamsUtils.has(operation, ARCHIVE_VALIDATION_ENABLED)) {\n            model.get(ARCHIVE_VALIDATION_ENABLED).set(archiveValidationEnabled);\n        }\n        if (ParamsUtils.has(operation, ARCHIVE_VALIDATION_FAIL_ON_ERROR)) {\n            model.get(ARCHIVE_VALIDATION_FAIL_ON_ERROR).set(failOnError);\n        }\n        if (ParamsUtils.has(operation, ARCHIVE_VALIDATION_FAIL_ON_WARN)) {\n            model.get(ARCHIVE_VALIDATION_FAIL_ON_WARN).set(failOnWarn);\n        }\n\n        if (context instanceof BootOperationContext) {\n            final BootOperationContext bootContext = BootOperationContext.class.cast(context);\n            context.getRuntimeContext().setRuntimeTask(new RuntimeTask() {\n                @Override\n                public void execute(RuntimeTaskContext context) throws OperationFailedException {\n                    ServiceTarget serviceTarget = context.getServiceTarget();\n\n                    TransactionIntegrationService tiService = new TransactionIntegrationService();\n\n                    serviceTarget\n                            .addService(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, tiService)\n                            .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, TransactionManager.class,\n                                    tiService.getTmInjector())\n                            .addDependency(TxnServices.JBOSS_TXN_SYNCHRONIZATION_REGISTRY,\n                                    TransactionSynchronizationRegistry.class, tiService.getTsrInjector())\n                            .addDependency(TxnServices.JBOSS_TXN_USER_TRANSACTION_REGISTRY,\n                                    org.jboss.tm.usertx.UserTransactionRegistry.class, tiService.getUtrInjector())\n                            .addDependency(TxnServices.JBOSS_TXN_XA_TERMINATOR, JBossXATerminator.class,\n                                    tiService.getTerminatorInjector())\n                            .addDependency(TxnServices.JBOSS_TXN_ARJUNA_RECOVERY_MANAGER, XAResourceRecoveryRegistry.class,\n                                    tiService.getRrInjector())\n\n                            .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, TransactionLocalDelegate.class,\n                                    tiService.getTldInjector()).setInitialMode(Mode.ACTIVE).install();\n                    WorkManager wm = new WorkManagerImpl();\n\n                    final WorkManagerService wmService = new WorkManagerService(wm);\n                    serviceTarget\n                            .addService(ConnectorServices.WORKMANAGER_SERVICE, wmService)\n                            .addDependency(ThreadsServices.EXECUTOR.append(shortRunningThreadPool), Executor.class,\n                                    wmService.getExecutorShortInjector())\n                            .addDependency(ThreadsServices.EXECUTOR.append(longRunningThreadPool), Executor.class,\n                                    wmService.getExecutorLongInjector())\n                            .addDependency(TxnServices.JBOSS_TXN_XA_TERMINATOR, JBossXATerminator.class,\n                                    wmService.getXaTerminatorInjector()).setInitialMode(Mode.ACTIVE).install();\n\n                    CloneableBootstrapContext ctx = new BaseCloneableBootstrapContext();\n                    final DefaultBootStrapContextService defaultBootCtxService = new DefaultBootStrapContextService(ctx);\n                    serviceTarget\n                            .addService(ConnectorServices.DEFAULT_BOOTSTRAP_CONTEXT_SERVICE, defaultBootCtxService)\n                            .addDependency(ConnectorServices.WORKMANAGER_SERVICE, WorkManager.class,\n                                    defaultBootCtxService.getWorkManagerValueInjector())\n                            .addDependency(TxnServices.JBOSS_TXN_XA_TERMINATOR, JBossXATerminator.class,\n                                    defaultBootCtxService.getXaTerminatorInjector())\n                            .addDependency(TxnServices.JBOSS_TXN_ARJUNA_TRANSACTION_MANAGER,\n                                    com.arjuna.ats.jbossatx.jta.TransactionManagerService.class,\n                                    defaultBootCtxService.getTxManagerInjector()).setInitialMode(Mode.ACTIVE).install();\n                    final ConnectorSubsystemConfiguration config = new ConnectorSubsystemConfiguration();\n\n                    config.setArchiveValidation(archiveValidationEnabled);\n                    config.setArchiveValidationFailOnError(failOnError);\n                    config.setArchiveValidationFailOnWarn(failOnWarn);\n\n                    // FIXME Bean validation currently not used\n                    config.setBeanValidation(false);\n\n                    final ConnectorConfigService connectorConfigService = new ConnectorConfigService(config);\n                    serviceTarget\n                            .addService(ConnectorServices.CONNECTOR_CONFIG_SERVICE, connectorConfigService)\n                            .addDependency(ConnectorServices.DEFAULT_BOOTSTRAP_CONTEXT_SERVICE,\n                                    CloneableBootstrapContext.class,\n                                    connectorConfigService.getDefaultBootstrapContextInjector()).setInitialMode(Mode.ACTIVE)\n                            .install();\n\n                    // TODO does the install of this and the DriverProcessor belong in DataSourcesSubsystemAdd?\n                    final DriverRegistryService driverRegistryService = new DriverRegistryService();\n                    serviceTarget\n                        .addService(ConnectorServices.JDBC_DRIVER_REGISTRY_SERVICE, driverRegistryService)\n                        .install();\n\n                    new RaDeploymentActivator().activate(bootContext, serviceTarget);\n\n                    resultHandler.handleResultComplete();\n                }\n            });\n\n        } else {\n            resultHandler.handleResultComplete();\n        }\n\n        // Compensating is remove\n        final ModelNode compensating = new ModelNode();\n        compensating.get(OP_ADDR).set(operation.require(ADDRESS));\n        compensating.get(OP).set(\"remove\");\n        return new BasicOperationResult(compensating);\n    }","commit_id":"cdee38a373092c7a0deafcbb99070de53993bf32","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initialize(final ExtensionContext context) {\n        log.debugf(\"Initializing Datasources Extension\");\n\n        // Register the remoting subsystem\n        final SubsystemRegistration registration = context.registerSubsystem(DATASOURCES);\n\n        registration.registerXMLElementWriter(NewDataSourceSubsystemParser.INSTANCE);\n\n        // Remoting subsystem description and operation handlers\n        final ModelNodeRegistration subsystem = registration.registerSubsystemModel(SUBSYSTEM);\n        subsystem.registerOperationHandler(ADD, DataSourcesSubsystemAdd.INSTANCE, SUBSYSTEM_ADD_DESC, false);\n        subsystem.registerOperationHandler(DESCRIBE, DataSourcesSubsystemDescribeHandler.INSTANCE,\n                DataSourcesSubsystemDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n\n        final ModelNodeRegistration jdbcDrivers = subsystem.registerSubModel(PathElement.pathElement(JDBC_DRIVER),\n                JDBC_DRIVER_DESC);\n        jdbcDrivers.registerOperationHandler(ADD, JdbcDriverAdd.INSTANCE, ADD_JDBC_DRIVER_DESC, false);\n        jdbcDrivers.registerOperationHandler(REMOVE, JdbcDriverRemove.INSTANCE, REMOVE_JDBC_DRIVER_DESC, false);\n\n        final ModelNodeRegistration dataSources = subsystem.registerSubModel(PathElement.pathElement(DATA_SOURCE),\n                DATA_SOURCE_DESC);\n        dataSources.registerOperationHandler(ADD, DataSourceAdd.INSTANCE, ADD_DATA_SOURCE_DESC, false);\n        dataSources.registerOperationHandler(REMOVE, DataSourceRemove.INSTANCE, REMOVE_DATA_SOURCE_DESC, false);\n        dataSources.registerOperationHandler(ENABLE, DataSourceEnable.INSTANCE, ENABLE_DATA_SOURCE_DESC, false);\n        dataSources.registerOperationHandler(DISABLE, DataSourceDisable.INSTANCE, DISABLE_DATA_SOURCE_DESC, false);\n\n        for (final String attributeName : DataSourcesMetrics.ATTRIBUTES) {\n            dataSources.registerMetric(attributeName, DataSourcesMetrics.INSTANCE);\n        }\n\n        for (final String attributeName : DataSourcePoolConfigurationRWHandler.ATTRIBUTES) {\n            dataSources.registerReadWriteAttribute(attributeName, DataSourcePoolConfigurationReadHandler.INSTANCE,\n                    DataSourcePoolConfigurationWriteHandler.INSTANCE, Storage.CONFIGURATION);\n        }\n\n        final ModelNodeRegistration xaDataSources = subsystem.registerSubModel(PathElement.pathElement(XA_DATA_SOURCE),\n                XA_DATA_SOURCE_DESC);\n        xaDataSources.registerOperationHandler(ADD, XaDataSourceAdd.INSTANCE, ADD_XA_DATA_SOURCE_DESC, false);\n        xaDataSources.registerOperationHandler(REMOVE, XaDataSourceRemove.INSTANCE, REMOVE_XA_DATA_SOURCE_DESC, false);\n        xaDataSources.registerOperationHandler(ENABLE, DataSourceEnable.INSTANCE, ENABLE_XA_DATA_SOURCE_DESC, false);\n        xaDataSources.registerOperationHandler(DISABLE, DataSourceDisable.INSTANCE, DISABLE_XA_DATA_SOURCE_DESC, false);\n\n        for (final String attributeName : XaDataSourcesMetrics.ATTRIBUTES) {\n            xaDataSources.registerMetric(attributeName, XaDataSourcesMetrics.INSTANCE);\n        }\n\n        for (final String attributeName : XaDataSourcePoolConfigurationRWHandler.ATTRIBUTES) {\n            xaDataSources.registerReadWriteAttribute(attributeName, XaDataSourcePoolConfigurationReadHandler.INSTANCE,\n                    XaDataSourcePoolConfigurationWriteHandler.INSTANCE, Storage.CONFIGURATION);\n        }\n\n    }","id":97336,"modified_method":"@Override\n    public void initialize(final ExtensionContext context) {\n        log.debugf(\"Initializing Datasources Extension\");\n\n        // Register the remoting subsystem\n        final SubsystemRegistration registration = context.registerSubsystem(DATASOURCES);\n\n        registration.registerXMLElementWriter(NewDataSourceSubsystemParser.INSTANCE);\n\n        // Remoting subsystem description and operation handlers\n        final ModelNodeRegistration subsystem = registration.registerSubsystemModel(SUBSYSTEM);\n        subsystem.registerOperationHandler(ADD, DataSourcesSubsystemAdd.INSTANCE, SUBSYSTEM_ADD_DESC, false);\n        subsystem.registerOperationHandler(DESCRIBE, DataSourcesSubsystemDescribeHandler.INSTANCE,\n                DataSourcesSubsystemDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n        subsystem.registerReadOnlyAttribute(\"installed-drivers\", InstalledDriversReadAttributeHandler.INSTANCE, Storage.RUNTIME);\n\n        final ModelNodeRegistration jdbcDrivers = subsystem.registerSubModel(PathElement.pathElement(JDBC_DRIVER),\n                JDBC_DRIVER_DESC);\n        jdbcDrivers.registerOperationHandler(ADD, JdbcDriverAdd.INSTANCE, ADD_JDBC_DRIVER_DESC, false);\n        jdbcDrivers.registerOperationHandler(REMOVE, JdbcDriverRemove.INSTANCE, REMOVE_JDBC_DRIVER_DESC, false);\n\n        final ModelNodeRegistration dataSources = subsystem.registerSubModel(PathElement.pathElement(DATA_SOURCE),\n                DATA_SOURCE_DESC);\n        dataSources.registerOperationHandler(ADD, DataSourceAdd.INSTANCE, ADD_DATA_SOURCE_DESC, false);\n        dataSources.registerOperationHandler(REMOVE, DataSourceRemove.INSTANCE, REMOVE_DATA_SOURCE_DESC, false);\n        dataSources.registerOperationHandler(ENABLE, DataSourceEnable.INSTANCE, ENABLE_DATA_SOURCE_DESC, false);\n        dataSources.registerOperationHandler(DISABLE, DataSourceDisable.INSTANCE, DISABLE_DATA_SOURCE_DESC, false);\n\n        for (final String attributeName : DataSourcesMetrics.ATTRIBUTES) {\n            dataSources.registerMetric(attributeName, DataSourcesMetrics.INSTANCE);\n        }\n\n        for (final String attributeName : DataSourcePoolConfigurationRWHandler.ATTRIBUTES) {\n            dataSources.registerReadWriteAttribute(attributeName, DataSourcePoolConfigurationReadHandler.INSTANCE,\n                    DataSourcePoolConfigurationWriteHandler.INSTANCE, Storage.CONFIGURATION);\n        }\n\n        final ModelNodeRegistration xaDataSources = subsystem.registerSubModel(PathElement.pathElement(XA_DATA_SOURCE),\n                XA_DATA_SOURCE_DESC);\n        xaDataSources.registerOperationHandler(ADD, XaDataSourceAdd.INSTANCE, ADD_XA_DATA_SOURCE_DESC, false);\n        xaDataSources.registerOperationHandler(REMOVE, XaDataSourceRemove.INSTANCE, REMOVE_XA_DATA_SOURCE_DESC, false);\n        xaDataSources.registerOperationHandler(ENABLE, DataSourceEnable.INSTANCE, ENABLE_XA_DATA_SOURCE_DESC, false);\n        xaDataSources.registerOperationHandler(DISABLE, DataSourceDisable.INSTANCE, DISABLE_XA_DATA_SOURCE_DESC, false);\n\n        for (final String attributeName : XaDataSourcesMetrics.ATTRIBUTES) {\n            xaDataSources.registerMetric(attributeName, XaDataSourcesMetrics.INSTANCE);\n        }\n\n        for (final String attributeName : XaDataSourcePoolConfigurationRWHandler.ATTRIBUTES) {\n            xaDataSources.registerReadWriteAttribute(attributeName, XaDataSourcePoolConfigurationReadHandler.INSTANCE,\n                    XaDataSourcePoolConfigurationWriteHandler.INSTANCE, Storage.CONFIGURATION);\n        }\n\n    }","commit_id":"cdee38a373092c7a0deafcbb99070de53993bf32","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        final ServicesAttachment servicesAttachment = deploymentUnit.getAttachment(Attachments.SERVICES);\n        if (module != null && servicesAttachment != null) {\n            final ModuleClassLoader classLoader = module.getClassLoader();\n            final List<String> driverNames = servicesAttachment.getServiceImplementations(Driver.class.getName());\n            for (String driverName : driverNames) {\n                try {\n                    final Class<? extends Driver> driverClass = classLoader.loadClass(driverName).asSubclass(Driver.class);\n                    final Constructor<? extends Driver> constructor = driverClass.getConstructor();\n                    final Driver driver = constructor.newInstance();\n                    final int majorVersion = driver.getMajorVersion();\n                    final int minorVersion = driver.getMinorVersion();\n                    final boolean compliant = driver.jdbcCompliant();\n                    if (compliant) {\n                        log.infof(\"Deploying JDBC-compliant driver %s (version %d.%d)\", driverClass,\n                                Integer.valueOf(majorVersion), Integer.valueOf(minorVersion));\n                    } else {\n                        log.infof(\"Deploying non-JDBC-compliant driver %s (version %d.%d)\", driverClass,\n                                Integer.valueOf(majorVersion), Integer.valueOf(minorVersion));\n                    }\n                    phaseContext\n                            .getServiceTarget()\n                            .addService(\n                                    ServiceName.JBOSS.append(\"jdbc-driver\", driverName, Integer.toString(majorVersion),\n                                            Integer.toString(minorVersion)),\n                                    new ValueService<Driver>(new ImmediateValue<Driver>(driver))).setInitialMode(Mode.ACTIVE)\n                            .install();\n\n                } catch (Exception e) {\n                    log.warnf(\"Unable to instantiate driver class \\\"%s\\\": %s\", driverName, e);\n                }\n            }\n        }\n    }","id":97337,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        final ServicesAttachment servicesAttachment = deploymentUnit.getAttachment(Attachments.SERVICES);\n        if (module != null && servicesAttachment != null) {\n            final ModuleClassLoader classLoader = module.getClassLoader();\n            final List<String> driverNames = servicesAttachment.getServiceImplementations(Driver.class.getName());\n            for (String driverName : driverNames) {\n                try {\n                    final Class<? extends Driver> driverClass = classLoader.loadClass(driverName).asSubclass(Driver.class);\n                    final Constructor<? extends Driver> constructor = driverClass.getConstructor();\n                    final Driver driver = constructor.newInstance();\n                    final int majorVersion = driver.getMajorVersion();\n                    final int minorVersion = driver.getMinorVersion();\n                    final boolean compliant = driver.jdbcCompliant();\n                    if (compliant) {\n                        log.infof(\"Deploying JDBC-compliant driver %s (version %d.%d)\", driverClass,\n                                Integer.valueOf(majorVersion), Integer.valueOf(minorVersion));\n                    } else {\n                        log.infof(\"Deploying non-JDBC-compliant driver %s (version %d.%d)\", driverClass,\n                                Integer.valueOf(majorVersion), Integer.valueOf(minorVersion));\n                    }\n\n                    InstalledDriver driverMetadata = new InstalledDriver(deploymentUnit.getName(), driverName, majorVersion, minorVersion, compliant);\n                    DriverService driverService = new DriverService(driverMetadata, driver);\n                    phaseContext\n                            .getServiceTarget()\n                            .addService(\n                                    ServiceName.JBOSS.append(\"jdbc-driver\", driverName, Integer.toString(majorVersion),\n                                            Integer.toString(minorVersion)),\n                                            driverService)\n                             .addDependency(ConnectorServices.JDBC_DRIVER_REGISTRY_SERVICE, DriverRegistry.class, driverService.getDriverRegistryServiceInjector())\n                             .setInitialMode(Mode.ACTIVE)\n                            .install();\n\n                } catch (Exception e) {\n                    log.warnf(\"Unable to instantiate driver class \\\"%s\\\": %s\", driverName, e);\n                }\n            }\n        }\n    }","commit_id":"cdee38a373092c7a0deafcbb99070de53993bf32","url":"https://github.com/wildfly/wildfly"},{"original_method":"public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) throws OperationFailedException {\n        final ModelNode address = operation.require(OP_ADDR);\n        final PathAddress pathAddress = PathAddress.pathAddress(address);\n\n        final String moduleName = operation.require(DRIVER).asString();\n\n        //Apply to the model\n        final ModelNode model = context.getSubModel();\n        model.get(NAME).set(pathAddress.getLastElement().getValue());\n        model.get(DRIVER).set(moduleName);\n\n        // Compensating is remove\n        final ModelNode compensating = Util.getResourceRemoveOperation(address);\n\n        if (context.getRuntimeContext() != null) {\n            context.getRuntimeContext().setRuntimeTask(new RuntimeTask() {\n                public void execute(RuntimeTaskContext context) throws OperationFailedException {\n                    final ServiceTarget target = context.getServiceTarget();\n\n                    final Module module;\n                    try {\n                        module = Module.getCallerModuleLoader().loadModule(ModuleIdentifier.create(moduleName));\n                    } catch (ModuleLoadException e) {\n                        throw new OperationFailedException(e, new ModelNode().set(\"Failed to load module for driver [\" + moduleName + \"]\"));\n                    }\n                    final ServiceLoader<Driver> serviceLoader = module.loadService(Driver.class);\n                    if (serviceLoader != null) for (Driver driver : serviceLoader) {\n\n                        final int majorVersion = driver.getMajorVersion();\n                        final int minorVersion = driver.getMinorVersion();\n                        final boolean compliant = driver.jdbcCompliant();\n                        if (compliant) {\n                            log.infof(\"Deploying JDBC-compliant driver %s (version %d.%d)\", driver.getClass(),\n                                    Integer.valueOf(majorVersion), Integer.valueOf(minorVersion));\n                        } else {\n                            log.infof(\"Deploying non-JDBC-compliant driver %s (version %d.%d)\", driver.getClass(),\n                                    Integer.valueOf(majorVersion), Integer.valueOf(minorVersion));\n                        }\n                        target.addService(ServiceName.JBOSS.append(\"jdbc-driver\", driver.getClass().getName(), Integer.toString(majorVersion), Integer.toString(minorVersion)),\n                                new ValueService<Driver>(new ImmediateValue<Driver>(driver))).setInitialMode(ServiceController.Mode.ACTIVE)\n                                .install();\n\n                    }\n                    resultHandler.handleResultComplete();\n                }\n            });\n        } else {\n            resultHandler.handleResultComplete();\n        }\n        return new BasicOperationResult(compensating);\n    }","id":97338,"modified_method":"@Override\n    public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) throws OperationFailedException {\n        final ModelNode address = operation.require(OP_ADDR);\n        final PathAddress pathAddress = PathAddress.pathAddress(address);\n\n        final String moduleName = operation.require(DRIVER).asString();\n\n        //Apply to the model\n        final ModelNode model = context.getSubModel();\n        model.get(NAME).set(pathAddress.getLastElement().getValue());\n        model.get(DRIVER).set(moduleName);\n\n        // Compensating is remove\n        final ModelNode compensating = Util.getResourceRemoveOperation(address);\n\n        if (context.getRuntimeContext() != null) {\n            context.getRuntimeContext().setRuntimeTask(new RuntimeTask() {\n                @Override\n                public void execute(RuntimeTaskContext context) throws OperationFailedException {\n                    final ServiceTarget target = context.getServiceTarget();\n\n                    final ModuleIdentifier moduleId;\n                    final Module module;\n                    try {\n                        moduleId = ModuleIdentifier.create(moduleName);\n                        module = Module.getCallerModuleLoader().loadModule(moduleId);\n                    } catch (ModuleLoadException e) {\n                        throw new OperationFailedException(e, new ModelNode().set(\"Failed to load module for driver [\" + moduleName + \"]\"));\n                    }\n                    final ServiceLoader<Driver> serviceLoader = module.loadService(Driver.class);\n                    if (serviceLoader != null) for (Driver driver : serviceLoader) {\n\n                        final int majorVersion = driver.getMajorVersion();\n                        final int minorVersion = driver.getMinorVersion();\n                        final boolean compliant = driver.jdbcCompliant();\n                        if (compliant) {\n                            log.infof(\"Deploying JDBC-compliant driver %s (version %d.%d)\", driver.getClass(),\n                                    Integer.valueOf(majorVersion), Integer.valueOf(minorVersion));\n                        } else {\n                            log.infof(\"Deploying non-JDBC-compliant driver %s (version %d.%d)\", driver.getClass(),\n                                    Integer.valueOf(majorVersion), Integer.valueOf(minorVersion));\n                        }\n                        InstalledDriver driverMetadata = new InstalledDriver(moduleId, driver.getClass().getName(), majorVersion, minorVersion, compliant);\n                        DriverService driverService = new DriverService(driverMetadata, driver);\n                        target.addService(ServiceName.JBOSS.append(\"jdbc-driver\", driver.getClass().getName(), Integer.toString(majorVersion), Integer.toString(minorVersion)),\n                                driverService)\n                                .addDependency(ConnectorServices.JDBC_DRIVER_REGISTRY_SERVICE, DriverRegistry.class, driverService.getDriverRegistryServiceInjector())\n                                .setInitialMode(ServiceController.Mode.ACTIVE)\n                                .install();\n\n                    }\n                    resultHandler.handleResultComplete();\n                }\n            });\n        } else {\n            resultHandler.handleResultComplete();\n        }\n        return new BasicOperationResult(compensating);\n    }","commit_id":"cdee38a373092c7a0deafcbb99070de53993bf32","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void run() {\n            try {\n                controllerClient.execute(deploymentOp);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }","id":97339,"modified_method":"@Override\n        public void run() {\n            try {\n                ModelNode result = controllerClient.execute(deploymentOp);\n                if (!SUCCESS.equals(result.get(OUTCOME).asString())) {\n                    System.exit(1);\n                }\n                deploymentCompleteLatch.countDown();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }","commit_id":"a219aa9f257c9d08fca570b9145feb9e99fc8128","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final DeploymentUnit topLevel = deploymentUnit.getParent() == null ? deploymentUnit : deploymentUnit.getParent();\n\n        final DeploymentReflectionIndex deploymentReflectionIndex = deploymentUnit.getAttachment(Attachments.REFLECTION_INDEX);\n        Boolean activate = deploymentUnit.getAttachment(AppClientAttachments.START_APP_CLIENT);\n        if (activate == null || !activate) {\n            return;\n        }\n        final Class<?> mainClass = deploymentUnit.getAttachment(AppClientAttachments.MAIN_CLASS);\n        if (mainClass == null) {\n            throw new RuntimeException(\"Could not start app client \" + deploymentUnit.getName() + \" as no main class was found\");\n        }\n\n        ClassReflectionIndex<?> index = deploymentReflectionIndex.getClassIndex(mainClass);\n        Method method = index.getMethod(void.class, \"main\", String[].class);\n        if (method == null) {\n            throw new RuntimeException(\"Could not start app client \" + deploymentUnit.getName() + \" as no main main was found on main class \" + mainClass);\n        }\n        final ApplicationClientStartService startService = new ApplicationClientStartService(method, topLevel.getServiceName(), parameters);\n        phaseContext.getServiceTarget()\n                .addService(deploymentUnit.getServiceName().append(ApplicationClientStartService.SERVICE_NAME), startService)\n                .install();\n    }","id":97340,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final DeploymentUnit topLevel = deploymentUnit.getParent() == null ? deploymentUnit : deploymentUnit.getParent();\n\n        final DeploymentReflectionIndex deploymentReflectionIndex = deploymentUnit.getAttachment(Attachments.REFLECTION_INDEX);\n        Boolean activate = deploymentUnit.getAttachment(AppClientAttachments.START_APP_CLIENT);\n        if (activate == null || !activate) {\n            return;\n        }\n        final Class<?> mainClass = deploymentUnit.getAttachment(AppClientAttachments.MAIN_CLASS);\n        if (mainClass == null) {\n            throw new RuntimeException(\"Could not start app client \" + deploymentUnit.getName() + \" as no main class was found\");\n        }\n\n        ClassReflectionIndex<?> index = deploymentReflectionIndex.getClassIndex(mainClass);\n        Method method = index.getMethod(void.class, \"main\", String[].class);\n        if (method == null) {\n            throw new RuntimeException(\"Could not start app client \" + deploymentUnit.getName() + \" as no main main was found on main class \" + mainClass);\n        }\n        final ApplicationClientStartService startService = new ApplicationClientStartService(method, parameters);\n        phaseContext.getServiceTarget()\n                .addService(deploymentUnit.getServiceName().append(ApplicationClientStartService.SERVICE_NAME), startService)\n                .addDependency(ApplicationClientDeploymentService.SERVICE_NAME, ApplicationClientDeploymentService.class,  startService.getApplicationClientDeploymentServiceInjectedValue())\n                .install();\n    }","commit_id":"a219aa9f257c9d08fca570b9145feb9e99fc8128","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ApplicationClientStartService(final Method mainMethod, final ServiceName topLevelDeploymentName, final String[] parameters) {\n        this.mainMethod = mainMethod;\n        this.topLevelDeploymentName = topLevelDeploymentName;\n        this.parameters = parameters;\n    }","id":97341,"modified_method":"public ApplicationClientStartService(final Method mainMethod, final String[] parameters) {\n        this.mainMethod = mainMethod;\n        this.parameters = parameters;\n    }","commit_id":"a219aa9f257c9d08fca570b9145feb9e99fc8128","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public synchronized void start(final StartContext context) throws StartException {\n        final DeploymentCompleteListener listener = new DeploymentCompleteListener();\n        final ServiceController<?> deployment = context.getController().getServiceContainer().getRequiredService(topLevelDeploymentName);\n        deployment.addListener(ServiceListener.Inheritance.ALL, listener);\n\n        thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    listener.waitForDeploymentStart();\n                    mainMethod.invoke(null,new Object[] { parameters});\n                } catch (InvocationTargetException e) {\n                    logger.error(e);\n                } catch (IllegalAccessException e) {\n                    logger.error(e);\n                } finally {\n                    CurrentServiceContainer.getServiceContainer().shutdown();\n                }\n            }\n        });\n        thread.start();\n    }","id":97342,"modified_method":"@Override\n    public synchronized void start(final StartContext context) throws StartException {\n\n        thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    applicationClientDeploymentServiceInjectedValue.getValue().getDeploymentCompleteLatch().await();\n                    mainMethod.invoke(null,new Object[] { parameters});\n                } catch (InvocationTargetException e) {\n                    logger.error(e);\n                } catch (IllegalAccessException e) {\n                    logger.error(e);\n                } catch (InterruptedException e) {\n                    logger.error(e);\n                } finally {\n                    CurrentServiceContainer.getServiceContainer().shutdown();\n                }\n            }\n        });\n        thread.start();\n    }","commit_id":"a219aa9f257c9d08fca570b9145feb9e99fc8128","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ServiceName installSecurityService(ServiceTarget serviceTarget, DeploymentUnit deploymentUnit,\n                                               WeldService weldService, ServiceBuilder<WeldContainer> weldServiceBuilder) {\n        final WeldSecurityServices service = new WeldSecurityServices();\n\n        final ServiceName serviceName = deploymentUnit.getServiceName().append(WeldSecurityServices.SERVICE_NAME);\n\n        serviceTarget.addService(serviceName, service).install();\n\n        weldServiceBuilder.addDependency(serviceName, WeldSecurityServices.class, weldService.getSecurityServices());\n\n        return serviceName;\n    }","id":97343,"modified_method":"private ServiceName installSecurityService(ServiceTarget serviceTarget, DeploymentUnit deploymentUnit,\n                                               WeldService weldService, ServiceBuilder<WeldContainer> weldServiceBuilder) {\n        final WeldSecurityServices service = new WeldSecurityServices();\n\n        final ServiceName serviceName = deploymentUnit.getServiceName().append(WeldSecurityServices.SERVICE_NAME);\n\n        serviceTarget.addService(serviceName, service)\n                .addDependency(ServiceBuilder.DependencyType.OPTIONAL, SimpleSecurityManagerService.SERVICE_NAME, SimpleSecurityManager.class, service.getSecurityManagerValue()).install();\n\n        weldServiceBuilder.addDependency(serviceName, WeldSecurityServices.class, weldService.getSecurityServices());\n\n        return serviceName;\n    }","commit_id":"6326f240f61353000741f93dd1035723c8981ea9","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Principal getPrincipal() {\n        throw new RuntimeException(\"not implemented\");\n    }","id":97344,"modified_method":"@Override\n    public Principal getPrincipal() {\n        final SimpleSecurityManager securityManager = securityManagerValue.getOptionalValue();\n        if (securityManager == null)\n            throw new UnsupportedOperationException(\"Security is not enabled\");\n        return securityManager.getCallerPrincipal();\n    }","commit_id":"6326f240f61353000741f93dd1035723c8981ea9","url":"https://github.com/wildfly/wildfly"},{"original_method":"public BaseQQDialog(String title, String okButtonText, final SNode concept, IOperationContext context, SModule module) {\n    super(ProjectHelper.toIdeaProject(context.getProject()));\n    this.setTitle(title);\n    this.myContext = context;\n    this.myModelAccess = context.getProject().getRepository().getModelAccess();\n    this.setModal(false);\n    this.setOKButtonText(okButtonText);\n    this.setCancelButtonText(\"&Cancel\");\n    myProject = context.getProject();\n\n    myModelAccess.executeCommand(new Runnable() {\n      public void run() {\n        myNode = createQuery(concept);\n        myTempModel = QuickQueryUtils.createTemporaryModelWithQuery(myNode);\n\n        myEditor = new SimpleEmbeddableEditor(myProject, true);\n        myEditor.editNode(myNode);\n      }\n    });\n    this.myPanel.add(this.myEditor, BorderLayout.CENTER);\n\n    this.myScope = new ScopeEditor(new ScopeOptions());\n    this.myPanel.add(this.myScope.getComponent(), BorderLayout.SOUTH);\n    myPanel.setPreferredSize(new Dimension(500, 500));\n    this.setModal(false);\n\n    init();\n  }","id":97345,"modified_method":"public BaseQQDialog(String title, String okButtonText, final SNode concept, IOperationContext context) {\n    super(ProjectHelper.toIdeaProject(context.getProject()));\n    this.setTitle(title);\n    this.myContext = context;\n    this.myModelAccess = context.getProject().getRepository().getModelAccess();\n    this.setModal(false);\n    this.setOKButtonText(okButtonText);\n    this.setCancelButtonText(\"&Cancel\");\n    myProject = context.getProject();\n\n    myModelAccess.executeCommand(new Runnable() {\n      public void run() {\n        myNode = createQuery(concept);\n        myTempModel = QuickQueryUtils.createTemporaryModelWithQuery(myNode);\n\n        myEditor = new SimpleEmbeddableEditor(myProject, true);\n        myEditor.editNode(myNode);\n      }\n    });\n    this.myPanel.add(this.myEditor, BorderLayout.CENTER);\n\n    this.myScope = new ScopeEditor(new ScopeOptions());\n    this.myPanel.add(this.myScope.getComponent(), BorderLayout.SOUTH);\n    myPanel.setPreferredSize(new Dimension(500, 500));\n    this.setModal(false);\n\n    init();\n  }","commit_id":"927e2b3864864a5de7cc208fcfec1d362b446867","url":"https://github.com/JetBrains/MPS"},{"original_method":"public FindByConditionDialog(SNode concept, IOperationContext context, SModule module) {\n    super(\"Find Instances by condition\", \"&Find\", concept, context, module);\n  }","id":97346,"modified_method":"public FindByConditionDialog(SNode concept, IOperationContext context) {\n    super(\"Find Instances by condition\", \"&Find\", concept, context);\n  }","commit_id":"927e2b3864864a5de7cc208fcfec1d362b446867","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      FindByConditionDialog testDialog = new FindByConditionDialog(((SNode) MapSequence.fromMap(_params).get(\"node\")), new FindInstancesContext(((IOperationContext) MapSequence.fromMap(_params).get(\"context\"))), (Language) ((SModule) MapSequence.fromMap(_params).get(\"langModule\")));\n      testDialog.show();\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindByCondition\", t);\n      }\n    }\n  }","id":97347,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      FindByConditionDialog dialog = new FindByConditionDialog(((SNode) MapSequence.fromMap(_params).get(\"node\")), new FindInstancesContext(((IOperationContext) MapSequence.fromMap(_params).get(\"context\"))));\n      dialog.show();\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindByCondition\", t);\n      }\n    }\n  }","commit_id":"927e2b3864864a5de7cc208fcfec1d362b446867","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"context\", event.getData(MPSCommonDataKeys.OPERATION_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"context\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"langModule\", event.getData(MPSCommonDataKeys.CONTEXT_MODULE));\n    if (MapSequence.fromMap(_params).get(\"langModule\") == null) {\n      return false;\n    }\n    {\n      SNode node = event.getData(MPSCommonDataKeys.NODE);\n      if (node != null) {\n        if (!(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) {\n          node = null;\n        }\n      }\n      MapSequence.fromMap(_params).put(\"node\", node);\n    }\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    return true;\n  }","id":97348,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"context\", event.getData(MPSCommonDataKeys.OPERATION_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"context\") == null) {\n      return false;\n    }\n    {\n      SNode node = event.getData(MPSCommonDataKeys.NODE);\n      if (node != null) {\n        if (!(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) {\n          node = null;\n        }\n      }\n      MapSequence.fromMap(_params).put(\"node\", node);\n    }\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"927e2b3864864a5de7cc208fcfec1d362b446867","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ReplaceByConditionDialog(SNode concept, IOperationContext context, SModule module) {\n    super(\"Modify Instances by condition\", \"&Modify\", concept, context, module);\n  }","id":97349,"modified_method":"public ReplaceByConditionDialog(SNode concept, IOperationContext context) {\n    super(\"Modify Instances by condition\", \"&Modify\", concept, context);\n  }","commit_id":"927e2b3864864a5de7cc208fcfec1d362b446867","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"context\", event.getData(MPSCommonDataKeys.OPERATION_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"context\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"langModule\", event.getData(MPSCommonDataKeys.CONTEXT_MODULE));\n    if (MapSequence.fromMap(_params).get(\"langModule\") == null) {\n      return false;\n    }\n    {\n      SNode node = event.getData(MPSCommonDataKeys.NODE);\n      if (node != null) {\n        if (!(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) {\n          node = null;\n        }\n      }\n      MapSequence.fromMap(_params).put(\"node\", node);\n    }\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    return true;\n  }","id":97350,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"context\", event.getData(MPSCommonDataKeys.OPERATION_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"context\") == null) {\n      return false;\n    }\n    {\n      SNode node = event.getData(MPSCommonDataKeys.NODE);\n      if (node != null) {\n        if (!(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) {\n          node = null;\n        }\n      }\n      MapSequence.fromMap(_params).put(\"node\", node);\n    }\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"927e2b3864864a5de7cc208fcfec1d362b446867","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"ReplaceByCondition\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":97351,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"ReplaceByCondition\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"927e2b3864864a5de7cc208fcfec1d362b446867","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ReplaceByConditionDialog dialog = new ReplaceByConditionDialog(((SNode) MapSequence.fromMap(_params).get(\"node\")), new FindInstancesContext(((IOperationContext) MapSequence.fromMap(_params).get(\"context\"))), (Language) ((SModule) MapSequence.fromMap(_params).get(\"langModule\")));\n      dialog.show();\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"ReplaceByCondition\", t);\n      }\n    }\n  }","id":97352,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ReplaceByConditionDialog dialog = new ReplaceByConditionDialog(((SNode) MapSequence.fromMap(_params).get(\"node\")), new FindInstancesContext(((IOperationContext) MapSequence.fromMap(_params).get(\"context\"))));\n      dialog.show();\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"ReplaceByCondition\", t);\n      }\n    }\n  }","commit_id":"927e2b3864864a5de7cc208fcfec1d362b446867","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void collectConflicts() {\n    Map<Tuples._2<SNodeId, String>, List<NodeGroupChange>> mineGroupChanges = arrangeNodeGroupChanges(myMineChangeSet);\n    Map<Tuples._2<SNodeId, String>, List<NodeGroupChange>> repositoryGroupChanges = arrangeNodeGroupChanges(myRepositoryChangeSet);\n    for (Tuples._2<SNodeId, String> nodeRole : SetSequence.fromSet(MapSequence.fromMap(mineGroupChanges).keySet()).intersect(SetSequence.fromSet(MapSequence.fromMap(repositoryGroupChanges).keySet()))) {\n      List<NodeGroupChange> mine = MapSequence.fromMap(mineGroupChanges).get(nodeRole);\n      List<NodeGroupChange> repository = MapSequence.fromMap(repositoryGroupChanges).get(nodeRole);\n      // This is a quadratic algorithm, it can be optimized to linear, \n      // but it is left for simplicity \n      for (NodeGroupChange m : ListSequence.fromList(mine)) {\n        for (NodeGroupChange r : ListSequence.fromList(repository)) {\n          if (m.getEnd() < r.getBegin() || m.getBegin() > r.getEnd()) {\n            // ok \n          } else {\n            if (nodeGroupChangesSymmetric(m, r)) {\n              addSymmetric(m, r);\n            } else {\n              addPossibleConflict(m, r);\n            }\n          }\n        }\n      }\n    }\n\n    collectGroupChangesWithOthersConflicts(mineGroupChanges, myMineChangeSet, myRepositoryChangeSet);\n    collectGroupChangesWithOthersConflicts(repositoryGroupChanges, myRepositoryChangeSet, myMineChangeSet);\n\n    collectPropertyConflicts();\n    collectReferenceConflicts();\n\n    collectSymmetricRootDeletes();\n    collectConflictingRootAdds();\n\n    collectSymmetricImportedModelChanges();\n    collectSymmetricModuleDependencyChanges();\n    collectModelVersionConflicts();\n  }","id":97353,"modified_method":"private void collectConflicts() {\n    Map<Tuples._2<SNodeId, String>, List<NodeGroupChange>> mineGroupChanges = arrangeNodeGroupChanges(myMineChangeSet);\n    Map<Tuples._2<SNodeId, String>, List<NodeGroupChange>> repositoryGroupChanges = arrangeNodeGroupChanges(myRepositoryChangeSet);\n    for (Tuples._2<SNodeId, String> nodeRole : SetSequence.fromSet(MapSequence.fromMap(mineGroupChanges).keySet()).intersect(SetSequence.fromSet(MapSequence.fromMap(repositoryGroupChanges).keySet()))) {\n      List<NodeGroupChange> mine = MapSequence.fromMap(mineGroupChanges).get(nodeRole);\n      List<NodeGroupChange> repository = MapSequence.fromMap(repositoryGroupChanges).get(nodeRole);\n      // This is a quadratic algorithm, it can be optimized to linear, \n      // but it is left for simplicity \n      for (NodeGroupChange m : ListSequence.fromList(mine)) {\n        for (NodeGroupChange r : ListSequence.fromList(repository)) {\n          if (m.getEnd() < r.getBegin() || m.getBegin() > r.getEnd()) {\n            // ok \n          } else {\n            if (nodeGroupChangesSymmetric(m, r)) {\n              addSymmetric(m, r);\n            } else {\n              addPossibleConflict(m, r);\n            }\n          }\n        }\n      }\n    }\n\n    collectGroupChangesWithOthersConflicts(mineGroupChanges, myMineChangeSet, myRepositoryChangeSet);\n    collectGroupChangesWithOthersConflicts(repositoryGroupChanges, myRepositoryChangeSet, myMineChangeSet);\n\n    collectPropertyConflicts();\n    collectReferenceConflicts();\n\n    collectSymmetricRootDeletes();\n    collectConflictingRootAdds();\n\n    collectSymmetricImportedModelChanges();\n    collectSymmetricModuleDependencyChanges();\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createRefNodeList_pyq9q9_u3a(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new Model_Editor.importListHandler_pyq9q9_u3a(node, \"import\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_import\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_CHILDREN_NEWLINE, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_INDENT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","id":97354,"modified_method":"private EditorCell createRefNodeList_pyq9q9_n3a(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new Model_Editor.devkitListHandler_pyq9q9_n3a(node, \"devkit\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_devkit\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_CHILDREN_NEWLINE, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_INDENT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_pyq9q9_s3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"imports\");\n    editorCell.setCellId(\"Constant_pyq9q9_s3a\");\n    Style style = new StyleImpl();\n    ProjectStructure_StyleSheet.apply_KeyWord(style, editorCell);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":97355,"modified_method":"private EditorCell createConstant_pyq9q9_q3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_pyq9q9_q3a\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.PUNCTUATION_LEFT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_pyq9q9_g3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"imported languages\");\n    editorCell.setCellId(\"Constant_pyq9q9_g3a\");\n    Style style = new StyleImpl();\n    ProjectStructure_StyleSheet.apply_KeyWord(style, editorCell);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":97356,"modified_method":"private EditorCell createConstant_pyq9q9_g3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"\");\n    editorCell.setCellId(\"Constant_pyq9q9_g3a\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_pyq9q9_r3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"\");\n    editorCell.setCellId(\"Constant_pyq9q9_r3a\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":97357,"modified_method":"private EditorCell createConstant_pyq9q9_m3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_pyq9q9_m3a\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.PUNCTUATION_LEFT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_pyq9q9_k3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"languages engaged on generation\");\n    editorCell.setCellId(\"Constant_pyq9q9_k3a\");\n    Style style = new StyleImpl();\n    ProjectStructure_StyleSheet.apply_KeyWord(style, editorCell);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":97358,"modified_method":"private EditorCell createConstant_pyq9q9_k3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"\");\n    editorCell.setCellId(\"Constant_pyq9q9_k3a\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createRefNodeList_pyq9q9_i3a(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new Model_Editor.languageListHandler_pyq9q9_i3a(node, \"language\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_language\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_CHILDREN_NEWLINE, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_INDENT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","id":97359,"modified_method":"private EditorCell createRefNodeList_pyq9q9_f3a(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new Model_Editor.languageListHandler_pyq9q9_f3a(node, \"language\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_language\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_CHILDREN_NEWLINE, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_INDENT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createCollection_pyq9q9_d0(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_pyq9q9_d0\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_INDENT, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.addEditorCell(this.createConstant_pyq9q9_a3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_b3a(editorContext, node));\n    editorCell.addEditorCell(this.createProperty_pyq9q9_c3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_d3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_e3a(editorContext, node));\n    editorCell.addEditorCell(this.createProperty_pyq9q9_f3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_g3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_h3a(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_pyq9q9_i3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_j3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_k3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_l3a(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_pyq9q9_m3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_n3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_o3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_p3a(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_pyq9q9_q3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_r3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_s3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_t3a(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_pyq9q9_u3a(editorContext, node));\n    return editorCell;\n  }","id":97360,"modified_method":"private EditorCell createCollection_pyq9q9_d0(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_pyq9q9_d0\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_INDENT, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.addEditorCell(this.createConstant_pyq9q9_a3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_b3a(editorContext, node));\n    editorCell.addEditorCell(this.createProperty_pyq9q9_c3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_d3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_e3a(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_pyq9q9_f3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_g3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_h3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_i3a(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_pyq9q9_j3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_k3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_l3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_m3a(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_pyq9q9_n3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_o3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_p3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_pyq9q9_q3a(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_pyq9q9_r3a(editorContext, node));\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_pyq9q9_l3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_pyq9q9_l3a\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.PUNCTUATION_LEFT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":97361,"modified_method":"private EditorCell createConstant_pyq9q9_l3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"devkits\");\n    editorCell.setCellId(\"Constant_pyq9q9_l3a\");\n    Style style = new StyleImpl();\n    ProjectStructure_StyleSheet.apply_KeyWord(style, editorCell);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createRefNodeList_pyq9q9_m3a(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new Model_Editor.languageEngagedOnGenerationListHandler_pyq9q9_m3a(node, \"languageEngagedOnGeneration\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_languageEngagedOnGeneration\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_CHILDREN_NEWLINE, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_INDENT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","id":97362,"modified_method":"private EditorCell createRefNodeList_pyq9q9_j3a(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new Model_Editor.languageEngagedOnGenerationListHandler_pyq9q9_j3a(node, \"languageEngagedOnGeneration\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_languageEngagedOnGeneration\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_CHILDREN_NEWLINE, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_INDENT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_pyq9q9_o3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"devkits\");\n    editorCell.setCellId(\"Constant_pyq9q9_o3a\");\n    Style style = new StyleImpl();\n    ProjectStructure_StyleSheet.apply_KeyWord(style, editorCell);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":97363,"modified_method":"private EditorCell createConstant_pyq9q9_o3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"\");\n    editorCell.setCellId(\"Constant_pyq9q9_o3a\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_pyq9q9_a3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"version\");\n    editorCell.setCellId(\"Constant_pyq9q9_a3a\");\n    Style style = new StyleImpl();\n    ProjectStructure_StyleSheet.apply_KeyWord(style, editorCell);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":97364,"modified_method":"private EditorCell createConstant_pyq9q9_a3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"doNotGenerate\");\n    editorCell.setCellId(\"Constant_pyq9q9_a3a\");\n    Style style = new StyleImpl();\n    ProjectStructure_StyleSheet.apply_KeyWord(style, editorCell);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_pyq9q9_d3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"doNotGenerate\");\n    editorCell.setCellId(\"Constant_pyq9q9_d3a\");\n    Style style = new StyleImpl();\n    ProjectStructure_StyleSheet.apply_KeyWord(style, editorCell);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":97365,"modified_method":"private EditorCell createConstant_pyq9q9_d3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"imported languages\");\n    editorCell.setCellId(\"Constant_pyq9q9_d3a\");\n    Style style = new StyleImpl();\n    ProjectStructure_StyleSheet.apply_KeyWord(style, editorCell);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createProperty_pyq9q9_c3a(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new PropertyCellProvider(node, editorContext);\n    provider.setRole(\"version\");\n    provider.setNoTargetText(\"<no version>\");\n    provider.setAllowsEmptyTarget(true);\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"property_version\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      EditorManager manager = EditorManager.getInstanceFromContext(editorContext);\n      return manager.createNodeRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","id":97366,"modified_method":"private EditorCell createProperty_pyq9q9_c3a(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new PropertyCellProvider(node, editorContext);\n    provider.setRole(\"donotgenerate\");\n    provider.setNoTargetText(\"<no donotgenerate>\");\n    provider.setAllowsEmptyTarget(true);\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"property_donotgenerate\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      EditorManager manager = EditorManager.getInstanceFromContext(editorContext);\n      return manager.createNodeRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_pyq9q9_p3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_pyq9q9_p3a\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.PUNCTUATION_LEFT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":97367,"modified_method":"private EditorCell createConstant_pyq9q9_p3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"imports\");\n    editorCell.setCellId(\"Constant_pyq9q9_p3a\");\n    Style style = new StyleImpl();\n    ProjectStructure_StyleSheet.apply_KeyWord(style, editorCell);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createRefNodeList_pyq9q9_q3a(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new Model_Editor.devkitListHandler_pyq9q9_q3a(node, \"devkit\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_devkit\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_CHILDREN_NEWLINE, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_INDENT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","id":97368,"modified_method":"private EditorCell createRefNodeList_pyq9q9_r3a(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new Model_Editor.importListHandler_pyq9q9_r3a(node, \"import\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_import\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.INDENT_LAYOUT_CHILDREN_NEWLINE, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_INDENT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_pyq9q9_t3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_pyq9q9_t3a\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.PUNCTUATION_LEFT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":97369,"modified_method":"private EditorCell createConstant_pyq9q9_i3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_pyq9q9_i3a\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.PUNCTUATION_LEFT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_pyq9q9_e3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_pyq9q9_e3a\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.PUNCTUATION_LEFT, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":97370,"modified_method":"private EditorCell createConstant_pyq9q9_e3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_pyq9q9_e3a\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.PUNCTUATION_LEFT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_pyq9q9_h3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_pyq9q9_h3a\");\n    Style style = new StyleImpl();\n    style.set(StyleAttributes.PUNCTUATION_LEFT, 0, true);\n    style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, 0, true);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":97371,"modified_method":"private EditorCell createConstant_pyq9q9_h3a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"languages engaged on generation\");\n    editorCell.setCellId(\"Constant_pyq9q9_h3a\");\n    Style style = new StyleImpl();\n    ProjectStructure_StyleSheet.apply_KeyWord(style, editorCell);\n    editorCell.getStyle().putAll(style);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"MoveConcepts\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":97372,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"MoveConcepts\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      if (!(MoveConcepts_Action.this.init(_params))) {\n        return;\n      }\n      final SModelReference targetModel;\n      List<SModelReference> myModels;\n      myModels = ListSequence.fromList(((List<SModel>) (SModelRepository.getInstance().getModelDescriptors()))).select(new ISelector<SModel, SModelReference>() {\n        public SModelReference select(SModel it) {\n          return it.getReference();\n        }\n      }).where(new IWhereFilter<SModelReference>() {\n        public boolean accept(SModelReference it) {\n          return Language.getModelAspect(SModelRepository.getInstance().getModelDescriptor(it)) == LanguageAspect.STRUCTURE;\n        }\n      }).toListSequence();\n      targetModel = SModelReferenceDialog.getSelectedModel(((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getProject(), myModels);\n      if (targetModel == null) {\n        return;\n      }\n\n\n      ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getRepository().getModelAccess().runReadInEDT(new Runnable() {\n        public void run() {\n          for (SNode node : ListSequence.fromList(((List<SNode>) MapSequence.fromMap(_params).get(\"target\")))) {\n            if (!(SNodeUtil.isAccessible(node, MPSModuleRepository.getInstance()))) {\n              return;\n            }\n          }\n\n          if (targetModel.resolve(MPSModuleRepository.getInstance()) == null) {\n            return;\n          }\n          RefactoringAccess.getInstance().getRefactoringFacade().execute(RefactoringContext.createRefactoringContextByName(\"jetbrains.mps.lang.structure.refactorings.MoveConcepts\", Arrays.asList(\"targetModel\"), Arrays.asList(targetModel), ((List<SNode>) MapSequence.fromMap(_params).get(\"target\")), ((MPSProject) MapSequence.fromMap(_params).get(\"project\"))));\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"MoveConcepts\", t);\n      }\n    }\n  }","id":97373,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      JOptionPane.showMessageDialog(null, \"Not supported yet\");\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"MoveConcepts\", t);\n      }\n    }\n  }","commit_id":"aa111adcbaf56cd688e08bcd105c4f780884a786","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Default_KeymapChanges() {\n    // simple \n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.MoveConcepts_Action\", getShortcut(\" F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.MoveLinkUp_Action\", getShortcut(\" F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.MoveProperyUp_Action\", getShortcut(\" F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.RenameConcept_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.RenameLink_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.RenameProperty_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.SafeDeleteConcept_Action\", getShortcut(\"alt DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.SafeDeleteLink_Action\", getShortcut(\"alt DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.ShowDefaultHelp_Action\", getShortcut(\" F1\"));\n    // simple parameterized \n    // complex \n  }","id":97374,"modified_method":"public Default_KeymapChanges() {\n    // simple \n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.MoveConcepts_Action\", getShortcut(\" F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.MoveLinkUp_Action\", getShortcut(\" F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.MoveProperyUp_Action\", getShortcut(\" F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.RenameConcept_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.RenameLink_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.RenameProperty_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.pluginSolution.plugin.ShowDefaultHelp_Action\", getShortcut(\" F1\"));\n    // simple parameterized \n    // complex \n  }","commit_id":"9432c0a7ce30818f728e45136723bce63473564b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final DeleteNodesHelper helper = new DeleteNodesHelper(((List<SNode>) MapSequence.fromMap(_params).get(\"nodes\")), ((IOperationContext) MapSequence.fromMap(_params).get(\"context\")));\n\n      final Wrappers._boolean dialogNeeded = new Wrappers._boolean(false);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          dialogNeeded.value = helper.hasOptions();\n        }\n      });\n\n      final DeleteDialog.DeleteOption safeOption = new DeleteDialog.DeleteOption(\"Safe Delete\", false, true);\n      final DeleteDialog.DeleteOption aspectsOption = new DeleteDialog.DeleteOption(\"Delete Aspects\", true, true);\n      if (dialogNeeded.value) {\n        DeleteDialog dialog = new DeleteDialog(((Project) MapSequence.fromMap(_params).get(\"project\")), \"Delete Node\", \"Are you sure you want to delete selected node?\", safeOption, aspectsOption);\n        dialog.show();\n        if (!(dialog.isOK())) {\n          return;\n        }\n      }\n      ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n        public void run() {\n          helper.deleteNodes(safeOption.selected, aspectsOption.selected, true);\n        }\n      });\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"DeleteNode\", t);\n      }\n    }\n  }","id":97375,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final DeleteNodesHelper helper = new DeleteNodesHelper(((List<SNode>) MapSequence.fromMap(_params).get(\"nodes\")), ((IOperationContext) MapSequence.fromMap(_params).get(\"context\")));\n\n      final Wrappers._boolean dialogNeeded = new Wrappers._boolean(false);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          dialogNeeded.value = helper.hasOptions();\n        }\n      });\n\n      DeleteDialog.DeleteOption safeOption = new DeleteDialog.DeleteOption(\"Safe Delete\", false, true);\n      DeleteDialog.DeleteOption aspectsOption = new DeleteDialog.DeleteOption(\"Delete Aspects\", true, true);\n      if (dialogNeeded.value) {\n        DeleteDialog dialog = new DeleteDialog(((Project) MapSequence.fromMap(_params).get(\"project\")), \"Delete Node\", \"Are you sure you want to delete selected node?\", safeOption, aspectsOption);\n        dialog.show();\n        if (!(dialog.isOK())) {\n          return;\n        }\n      }\n      helper.deleteNodes(safeOption.selected, aspectsOption.selected, true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"DeleteNode\", t);\n      }\n    }\n  }","commit_id":"9432c0a7ce30818f728e45136723bce63473564b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void deleteNodes(boolean safe, boolean aspects, boolean fromProjectPane) {\n    if (aspects) {\n      List<SNode> addNodes = ListSequence.fromList(myNodesToDelete).translate(new ITranslator2<SNode, SNode>() {\n        public Iterable<SNode> translate(final SNode node) {\n          List<RelationDescriptor> tabs = ProjectPluginManager.getApplicableTabs(ProjectHelper.toIdeaProject(myContext.getProject()), node);\n          return ListSequence.fromList(tabs).translate(new ITranslator2<RelationDescriptor, SNode>() {\n            public Iterable<SNode> translate(RelationDescriptor tab) {\n              return (tab.isSingle() && tab.isApplicable(node) ?\n                tab.getNodes(node) :\n                Collections.<SNode>emptyList()\n              );\n            }\n          });\n        }\n      }).toListSequence();\n      ListSequence.fromList(myNodesToDelete).addSequence(ListSequence.fromList(addNodes));\n    }\n\n    ProjectPane projectPane = ProjectPane.getInstance(ProjectHelper.toIdeaProject(myContext.getProject()));\n    for (Iterator<SNode> iterator = myNodesToDelete.iterator(); iterator.hasNext();) {\n      SNode sNode = iterator.next();\n      if (!(iterator.hasNext()) && fromProjectPane) {\n        projectPane.rebuildTree();\n        projectPane.selectNextNode(sNode);\n      }\n      if (safe) {\n        safeDelete(myContext, sNode);\n      } else {\n        delete(sNode);\n      }\n    }\n  }","id":97376,"modified_method":"public void deleteNodes(final boolean safe, final boolean aspects, final boolean fromProjectPane) {\n    assert !(ModelAccess.instance().canRead()) : \"can lead to deadlock\";\n\n    final Project ideaProject = ProjectHelper.toIdeaProject(myContext.getProject());\n    final _FunctionTypes._void_P0_E0 performer = new _FunctionTypes._void_P0_E0() {\n      public void invoke() {\n        ProjectPane projectPane = ProjectPane.getInstance(ideaProject);\n\n        for (Iterator<SNode> iterator = myNodesToDelete.iterator(); iterator.hasNext();) {\n          SNode sNode = iterator.next();\n          if (!(iterator.hasNext()) && fromProjectPane) {\n            projectPane.rebuildTree();\n            projectPane.selectNextNode(sNode);\n          }\n          if (sNode.isDeleted()) {\n            continue;\n          }\n          sNode.delete();\n        }\n      }\n    };\n    ProgressManager.getInstance().run(new Task.Modal(ideaProject, \"Finding Usages\", true) {\n      public void run(@NotNull final ProgressIndicator p0) {\n        ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n          public void run() {\n            if (aspects) {\n              List<SNode> addNodes = ListSequence.fromList(myNodesToDelete).translate(new ITranslator2<SNode, SNode>() {\n                public Iterable<SNode> translate(final SNode node) {\n                  List<RelationDescriptor> tabs = ProjectPluginManager.getApplicableTabs(ideaProject, node);\n                  return ListSequence.fromList(tabs).translate(new ITranslator2<RelationDescriptor, SNode>() {\n                    public Iterable<SNode> translate(RelationDescriptor tab) {\n                      return (tab.isSingle() && tab.isApplicable(node) ?\n                        tab.getNodes(node) :\n                        Collections.<SNode>emptyList()\n                      );\n                    }\n                  });\n                }\n              }).toListSequence();\n              ListSequence.fromList(myNodesToDelete).addSequence(ListSequence.fromList(addNodes));\n            }\n\n\n            if (safe) {\n              final Set<SearchResult<SNode>> results = SetSequence.fromSet(new HashSet<SearchResult<SNode>>());\n\n              ListSequence.fromList(myNodesToDelete).visitAll(new IVisitor<SNode>() {\n                public void visit(SNode it) {\n                  SearchResults<SNode> usages = FindUtils.getSearchResults(new EmptyProgressMonitor(), it, GlobalScope.getInstance(), \"jetbrains.mps.lang.structure.findUsages.NodeAndDescendantsUsages_Finder\");\n                  SetSequence.fromSet(results).addSequence(ListSequence.fromList(usages.getSearchResults()));\n\n                  if (p0.isCanceled()) {\n                    return;\n                  }\n\n                  if (SNodeOperations.isInstanceOf(it, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\")) {\n                    SearchResults<SNode> instances = FindUtils.getSearchResults(new EmptyProgressMonitor(), it, GlobalScope.getInstance(), \"jetbrains.mps.lang.structure.findUsages.ConceptInstances_Finder\");\n                    SetSequence.fromSet(results).addSequence(ListSequence.fromList(instances.getSearchResults()));\n                  }\n\n                  if (p0.isCanceled()) {\n                    return;\n                  }\n                }\n              });\n\n              Set<SNode> nodes = SetSequence.fromSetWithValues(new HashSet<SNode>(), SetSequence.fromSet(results).select(new ISelector<SearchResult<SNode>, SNode>() {\n                public SNode select(SearchResult<SNode> it) {\n                  return it.getObject();\n                }\n              }));\n              for (SearchResult<SNode> searchResult : ListSequence.fromListWithValues(new ArrayList<SearchResult<SNode>>(), results)) {\n                SNode resultNode = searchResult.getObject();\n\n                for (SNode anc : ListSequence.fromList(SNodeOperations.getAncestors(resultNode, null, false))) {\n                  if (SetSequence.fromSet(nodes).contains(anc)) {\n                    SetSequence.fromSet(results).removeElement(searchResult);\n                    break;\n                  }\n                }\n              }\n              SearchResults sr = new SearchResults(SetSequence.fromSetWithValues(new HashSet<SNode>(), myNodesToDelete), SetSequence.fromSet(results).toListSequence());\n\n              if (p0.isCanceled()) {\n                return;\n              }\n\n              RefactoringAccess.getInstance().showRefactoringView(ideaProject, new RefactoringViewAction() {\n                public void performAction(RefactoringViewItem refactoringViewItem) {\n                  performer.invoke();\n                }\n              }, sr, false, \"Safe Delete\");\n\n            } else {\n              performer.invoke();\n            }\n          }\n        });\n      }\n    });\n  }","commit_id":"9432c0a7ce30818f728e45136723bce63473564b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void createGroups() {\n    // actions w/o parameters \n    addAction(new MoveConcepts_Action());\n    addAction(new MoveLinkUp_Action());\n    addAction(new MoveProperyUp_Action());\n    addAction(new RenameConcept_Action());\n    addAction(new RenameLink_Action());\n    addAction(new RenameProperty_Action());\n    addAction(new SafeDeleteConcept_Action());\n    addAction(new SafeDeleteLink_Action());\n    addAction(new ShowDefaultHelp_Action());\n    addAction(new ShowHelpForAspect_Action());\n    addAction(new ShowHelpForNode_Action());\n    addAction(new ShowHelpForRoot_Action());\n    // groups \n    addGroup(new RefactoringAdditions_ActionGroup());\n    addGroup(new ShowHelp_ActionGroup());\n    addGroup(new Structure_ActionGroup());\n  }","id":97377,"modified_method":"public void createGroups() {\n    // actions w/o parameters \n    addAction(new MoveConcepts_Action());\n    addAction(new MoveLinkUp_Action());\n    addAction(new MoveProperyUp_Action());\n    addAction(new RenameConcept_Action());\n    addAction(new RenameLink_Action());\n    addAction(new RenameProperty_Action());\n    addAction(new ShowDefaultHelp_Action());\n    addAction(new ShowHelpForAspect_Action());\n    addAction(new ShowHelpForNode_Action());\n    addAction(new ShowHelpForRoot_Action());\n    // groups \n    addGroup(new RefactoringAdditions_ActionGroup());\n    addGroup(new ShowHelp_ActionGroup());\n    addGroup(new Structure_ActionGroup());\n  }","commit_id":"9432c0a7ce30818f728e45136723bce63473564b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public RefactoringAdditions_ActionGroup() {\n    super(\"RefactoringAdditions\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.pluginSolution.plugin.RenameConcept_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.pluginSolution.plugin.RenameLink_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.pluginSolution.plugin.RenameProperty_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.pluginSolution.plugin.SafeDeleteConcept_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.pluginSolution.plugin.SafeDeleteLink_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.pluginSolution.plugin.MoveLinkUp_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.pluginSolution.plugin.MoveProperyUp_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.pluginSolution.plugin.MoveConcepts_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","id":97378,"modified_method":"public RefactoringAdditions_ActionGroup() {\n    super(\"RefactoringAdditions\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.pluginSolution.plugin.RenameConcept_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.pluginSolution.plugin.RenameLink_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.pluginSolution.plugin.RenameProperty_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.pluginSolution.plugin.MoveLinkUp_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.pluginSolution.plugin.MoveProperyUp_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.pluginSolution.plugin.MoveConcepts_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","commit_id":"9432c0a7ce30818f728e45136723bce63473564b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      RefactoringAccess.getInstance().getRefactoringFacade().execute(RefactoringContext.createRefactoringContextByName(\"jetbrains.mps.lang.core.refactorings.SafeDelete\", Arrays.asList(), Arrays.asList(), ((SNode) MapSequence.fromMap(_params).get(\"node\")), ((MPSProject) MapSequence.fromMap(_params).get(\"mpsproject\"))));\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"SafeDelete\", t);\n      }\n    }\n  }","id":97379,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      new DeleteNodesHelper(ListSequence.fromListAndArray(new ArrayList<SNode>(), ((SNode) MapSequence.fromMap(_params).get(\"node\"))), ((IOperationContext) MapSequence.fromMap(_params).get(\"context\"))).deleteNodes(true, true, false);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"SafeDelete\", t);\n      }\n    }\n  }","commit_id":"9432c0a7ce30818f728e45136723bce63473564b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"SafeDelete\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":97380,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"SafeDelete\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"9432c0a7ce30818f728e45136723bce63473564b","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    {\n      SNode node = event.getData(MPSCommonDataKeys.NODE);\n      if (node != null) {\n      }\n      MapSequence.fromMap(_params).put(\"node\", node);\n    }\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"mpsproject\", event.getData(MPSCommonDataKeys.MPS_PROJECT));\n    if (MapSequence.fromMap(_params).get(\"mpsproject\") == null) {\n      return false;\n    }\n    return true;\n  }","id":97381,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"context\", event.getData(MPSCommonDataKeys.OPERATION_CONTEXT));\n    {\n      SNode node = event.getData(MPSCommonDataKeys.NODE);\n      if (node != null) {\n      }\n      MapSequence.fromMap(_params).put(\"node\", node);\n    }\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"9432c0a7ce30818f728e45136723bce63473564b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"MoveLinkUp\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":97382,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"MoveLinkUp\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"6869e10eb4241a096105f0ea2b0e930e243dcf93","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    {\n      SNode node = event.getData(MPSCommonDataKeys.NODE);\n      if (node != null) {\n        if (!(SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086bL, \"jetbrains.mps.lang.structure.structure.PropertyDeclaration\")))) {\n          node = null;\n        }\n      }\n      MapSequence.fromMap(_params).put(\"target\", node);\n    }\n    if (MapSequence.fromMap(_params).get(\"target\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(CommonDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    return true;\n  }","id":97383,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    {\n      SNode node = event.getData(MPSCommonDataKeys.NODE);\n      if (node != null) {\n        if (!(SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086bL, \"jetbrains.mps.lang.structure.structure.PropertyDeclaration\")))) {\n          node = null;\n        }\n      }\n      MapSequence.fromMap(_params).put(\"target\", node);\n    }\n    if (MapSequence.fromMap(_params).get(\"target\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSCommonDataKeys.MPS_PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"6869e10eb4241a096105f0ea2b0e930e243dcf93","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      Messages.showInfoMessage(((Project) MapSequence.fromMap(_params).get(\"project\")), \"This refactoring is not supported in MPS 3.2.\\n\" + \"The right way to perform this change is to\\n\" + \"1. Deprecate the old property\\n\" + \"2. Create a new property\\n\" + \"3. Write a migration to migrate the old property into the new one\", \"Unsupported refactoring\");\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"MovePropertyUp\", t);\n      }\n    }\n  }","id":97384,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final SNode targetConcept = MoveUpDialog.getConcept(((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getProject(), ((SNode) MapSequence.fromMap(_params).get(\"target\")), \"property\");\n      ModelAccess modelAccess = ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getRepository().getModelAccess();\n      if (targetConcept == null) {\n        return;\n      }\n\n      modelAccess.executeCommandInEDT(new Runnable() {\n        public void run() {\n          final SNode currentConcept = SNodeOperations.getNodeAncestor(((SNode) MapSequence.fromMap(_params).get(\"target\")), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"), false, false);\n          if (currentConcept == null) {\n            return;\n          }\n          if (!(SNodeUtil.isAccessible(((SNode) MapSequence.fromMap(_params).get(\"target\")), ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getRepository()))) {\n            return;\n          }\n          if (!(SNodeUtil.isAccessible(targetConcept, ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getRepository()))) {\n            return;\n          }\n          Language targetLanguage = Language.getLanguageFor(SNodeOperations.getModel(targetConcept));\n          SNode newProperty = SNodeOperations.copyNode(((SNode) MapSequence.fromMap(_params).get(\"target\")));\n          ListSequence.fromList(SLinkOperations.getChildren(targetConcept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, \"propertyDeclaration\"))).addElement(newProperty);\n          AttributeOperations.setAttribute(((SNode) MapSequence.fromMap(_params).get(\"target\")), new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x11d0a70ae54L, \"jetbrains.mps.lang.structure.structure.DeprecatedNodeAnnotation\")), createDeprecatedNodeAnnotation_vnzymo_a0h0a0a4a0(\"The property was moved to superconcept \\\"\" + BehaviorReflection.invokeVirtual(String.class, targetConcept, \"virtual_getFqName_1213877404258\", new Object[]{}) + \"\\\"\"));\n          String propName = SPropertyOperations.getString(((SNode) MapSequence.fromMap(_params).get(\"target\")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"));\n          SPropertyOperations.set(((SNode) MapSequence.fromMap(_params).get(\"target\")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), propName + \"_old\");\n\n          SNode refactorInstances;\n          refactorInstances = _quotation_createNode_vnzymo_a0m0a0a4a0(newProperty, ((SNode) MapSequence.fromMap(_params).get(\"target\")), ((SNode) MapSequence.fromMap(_params).get(\"target\")));\n          SNode executeMethod = _quotation_createNode_vnzymo_a0n0a0a4a0(currentConcept, currentConcept, refactorInstances, targetConcept, ((SNode) MapSequence.fromMap(_params).get(\"target\")), targetConcept, newProperty);\n          MigrationScriptBuilder.createMigrationScript(targetLanguage).setName(\"Move_property_\" + propName).setExecuteMethod(executeMethod);\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"MovePropertyUp\", t);\n      }\n    }\n  }","commit_id":"6869e10eb4241a096105f0ea2b0e930e243dcf93","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"MovePropertyUp\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":97385,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"MovePropertyUp\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"6869e10eb4241a096105f0ea2b0e930e243dcf93","url":"https://github.com/JetBrains/MPS"},{"original_method":"private ActionGroup getCreateGroup() {\n    DefaultActionGroup result = new DefaultActionGroup();\n\n    DefaultActionGroup currentGroup = null;\n    List<DefaultActionGroup> groups = new ArrayList<DefaultActionGroup>();\n\n    List<EditorTabDescriptor> tabs = new ArrayList<EditorTabDescriptor>(myPossibleTabs);\n    Collections.sort(tabs, new EditorTabComparator());\n\n    for (final EditorTabDescriptor d : tabs) {\n      List<SNode> concepts = d.getConcepts(myBaseNode.getNode());\n      if (concepts.isEmpty()) continue;\n\n      boolean current = false;\n      for (SNode aspect:d.getNodes(myBaseNode.getNode())){\n        if (aspect.getContainingRoot().equals(getCurrentAspect())){\n          current = true;\n          break;\n        }\n      }\n\n      DefaultActionGroup group = new DefaultActionGroup(d.getTitle(), !current);\n      for (final SNode concept : concepts) {\n        group.add(new CreateAction(concept, d));\n      }\n\n      if (current) {\n        currentGroup = group;\n      } else {\n        groups.add(group);\n      }\n    }\n\n    if (currentGroup != null) {\n      result.add(currentGroup);\n      result.add(new Separator());\n    }\n    for (DefaultActionGroup group : groups) {\n      result.add(group);\n    }\n\n    return result;\n  }","id":97386,"modified_method":"private ActionGroup getCreateGroup() {\n    DefaultActionGroup result = new DefaultActionGroup();\n\n    CreateGroupsBuilder builder = new CreateGroupsBuilder(myBaseNode, myPossibleTabs, getCurrentAspect()) {\n      public void aspectCreated(SNode sNode) {\n        AddConceptTab.this.aspectCreated(sNode);\n      }\n    };\n\n    Iterator<DefaultActionGroup> it = builder.getCreateGroups().iterator();\n\n    if (it.hasNext()) {\n      DefaultActionGroup current = it.next();\n      result.add(current);\n      result.add(new Separator());\n    }\n\n    while (it.hasNext()){\n      DefaultActionGroup g = it.next();\n      g.setPopup(true);\n      result.add(g);\n    }\n\n    return result;\n  }","commit_id":"eded11079f3d8a7e0582724218d3f8fe43e98cc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Default_KeymapChanges() {\n    // simple \n    addSimpleShortcut(\"jetbrains.mps.ide.actions.AddLanguageImport_Action\", getShortcut(\"ctrl L\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.AddModelImportByRoot_Action\", getShortcut(\"ctrl R\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.AddModelImport_Action\", getShortcut(\"ctrl M\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.CloneModel_Action\", getShortcut(\"shift F5\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.CloneRoot_Action\", getShortcut(\"shift F5\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.CollapseAll_Action\", getShortcut(\"ctrl shift SUBTRACT\"), getShortcut(\"ctrl shift MINUS\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.Collapse_Action\", getShortcut(\"ctrl SUBTRACT\"), getShortcut(\"ctrl MINUS\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.CopyNodeReference_Action\", getShortcut(\"ctrl shift C\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.CopyNode_Action\", getShortcut(\"ctrl C\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.CutNode_Action\", getShortcut(\"ctrl X\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.DeleteModels_Action\", getShortcut(\" DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.DeleteModules_Action\", getShortcut(\" DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.DeleteNode_Action\", getShortcut(\" DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.DeletePropertyAction_Action\", getShortcut(\" DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.DeleteReferenceAction_Action\", getShortcut(\" DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ExpandAll_Action\", getShortcut(\"ctrl shift ADD\"), getShortcut(\"ctrl shift EQUALS\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.Expand_Action\", getShortcut(\"ctrl ADD\"), getShortcut(\"ctrl EQUALS\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.FastFindNodeUsages_Action\", getShortcut(\"ctrl F7\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.FindNext_Action\", getShortcut(\" F3\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.FindPrevious_Action\", getShortcut(\"shift F3\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.FindSpecificNodeUsages_Action\", getShortcut(\"alt F7\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.Find_Action\", getShortcut(\"ctrl F\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.FoldSelection_Action\", getShortcut(\"ctrl PERIOD\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.GoByCurrentReference_Action\", getShortcut(\"ctrl B\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.GoToNodeById_Action\", getShortcut(\"ctrl G\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.HighlightInstances_Action\", getShortcut(\"ctrl shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.HighlightUsages_Action\", getShortcut(\"ctrl shift F7\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.MPSProjectPaths_Action\", getShortcut(\"alt ENTER\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ModelProperties_Action\", getShortcut(\"alt ENTER\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.MoveFileOrDirectory_Action\", getShortcut(\" F6\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.PasteNode_Action\", getShortcut(\"ctrl V\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.QuickCreate_Action\", getShortcut(\"alt INSERT\"), getShortcut(\"ctrl alt INSERT\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.RemoveFromFavorites_Action\", getShortcut(\"ctrl DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.RenameFileOrDirectory_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.RenameModel_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.RenamePackage_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.RenameSolution_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.SetBookmarkNoNumber_Action\", getShortcut(\" F11\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowBookmarksDialog_Action\", getShortcut(\"shift F11\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowClassInHierarchy_Action\", getShortcut(\"ctrl H\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowConceptInHierarchy_Action\", getShortcut(\"ctrl H\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowImplementations_Action\", getShortcut(\"ctrl shift I\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowInProject_Action\", getShortcut(\"alt F2\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowNodeInInspector_Action\", getShortcut(\"ctrl I\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowNodeInfo_Action\", getShortcut(\"ctrl Q\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowParameters_Action\", getShortcut(\"ctrl P\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowStructure_Action\", getShortcut(\"ctrl F10\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.SolutionProperties_Action\", getShortcut(\"alt ENTER\"));\n    // simple parameterized \n    addComplexShortcut(\"jetbrains.mps.ide.actions.FileDelete_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\" DELETE\")));\n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToAction_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"ctrl shift A\")));\n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToFile_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"ctrl shift N\")));\n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToModel_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"ctrl alt shift M\")));\n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToModule_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"ctrl alt shift S\"), getShortcut(\"ctrl shift M\")));\n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToNamedNode_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"ctrl alt shift N\")));\n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToRootNode_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"ctrl N\")));\n    addComplexShortcut(\"jetbrains.mps.ide.actions.SelectInActionAdapter_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"alt F1\")));\n    // complex \n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToBookmark_Action\", new Default_KeymapChanges.GoToBookmark_ShortcutChange_qjewi8_ec());\n    addComplexShortcut(\"jetbrains.mps.ide.actions.SetBookmark_Action\", new Default_KeymapChanges.SetBookmark_ShortcutChange_qjewi8_fc());\n  }","id":97387,"modified_method":"public Default_KeymapChanges() {\n    // simple \n    addSimpleShortcut(\"jetbrains.mps.ide.actions.AddLanguageImport_Action\", getShortcut(\"ctrl L\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.AddModelImportByRoot_Action\", getShortcut(\"ctrl R\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.AddModelImport_Action\", getShortcut(\"ctrl M\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.CloneModel_Action\", getShortcut(\"shift F5\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.CloneRoot_Action\", getShortcut(\"shift F5\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.CollapseAll_Action\", getShortcut(\"ctrl shift SUBTRACT\"), getShortcut(\"ctrl shift MINUS\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.Collapse_Action\", getShortcut(\"ctrl SUBTRACT\"), getShortcut(\"ctrl MINUS\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.CopyNodeReference_Action\", getShortcut(\"ctrl shift C\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.CopyNode_Action\", getShortcut(\"ctrl C\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.CreateAspect_Action\", getShortcut(\"ctrl alt INSERT\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.CutNode_Action\", getShortcut(\"ctrl X\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.DeleteModels_Action\", getShortcut(\" DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.DeleteModules_Action\", getShortcut(\" DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.DeleteNode_Action\", getShortcut(\" DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.DeletePropertyAction_Action\", getShortcut(\" DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.DeleteReferenceAction_Action\", getShortcut(\" DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ExpandAll_Action\", getShortcut(\"ctrl shift ADD\"), getShortcut(\"ctrl shift EQUALS\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.Expand_Action\", getShortcut(\"ctrl ADD\"), getShortcut(\"ctrl EQUALS\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.FastFindNodeUsages_Action\", getShortcut(\"ctrl F7\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.FindNext_Action\", getShortcut(\" F3\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.FindPrevious_Action\", getShortcut(\"shift F3\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.FindSpecificNodeUsages_Action\", getShortcut(\"alt F7\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.Find_Action\", getShortcut(\"ctrl F\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.FoldSelection_Action\", getShortcut(\"ctrl PERIOD\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.GoByCurrentReference_Action\", getShortcut(\"ctrl B\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.GoToNodeById_Action\", getShortcut(\"ctrl G\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.HighlightInstances_Action\", getShortcut(\"ctrl shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.HighlightUsages_Action\", getShortcut(\"ctrl shift F7\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.MPSProjectPaths_Action\", getShortcut(\"alt ENTER\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ModelProperties_Action\", getShortcut(\"alt ENTER\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.MoveFileOrDirectory_Action\", getShortcut(\" F6\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.PasteNode_Action\", getShortcut(\"ctrl V\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.QuickCreate_Action\", getShortcut(\"alt INSERT\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.RemoveFromFavorites_Action\", getShortcut(\"ctrl DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.RenameFileOrDirectory_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.RenameModel_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.RenamePackage_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.RenameSolution_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.SetBookmarkNoNumber_Action\", getShortcut(\" F11\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowBookmarksDialog_Action\", getShortcut(\"shift F11\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowClassInHierarchy_Action\", getShortcut(\"ctrl H\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowConceptInHierarchy_Action\", getShortcut(\"ctrl H\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowImplementations_Action\", getShortcut(\"ctrl shift I\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowInProject_Action\", getShortcut(\"alt F2\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowNodeInInspector_Action\", getShortcut(\"ctrl I\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowNodeInfo_Action\", getShortcut(\"ctrl Q\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowParameters_Action\", getShortcut(\"ctrl P\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowStructure_Action\", getShortcut(\"ctrl F10\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.SolutionProperties_Action\", getShortcut(\"alt ENTER\"));\n    // simple parameterized \n    addComplexShortcut(\"jetbrains.mps.ide.actions.FileDelete_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\" DELETE\")));\n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToAction_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"ctrl shift A\")));\n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToFile_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"ctrl shift N\")));\n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToModel_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"ctrl alt shift M\")));\n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToModule_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"ctrl alt shift S\"), getShortcut(\"ctrl shift M\")));\n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToNamedNode_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"ctrl alt shift N\")));\n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToRootNode_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"ctrl N\")));\n    addComplexShortcut(\"jetbrains.mps.ide.actions.SelectInActionAdapter_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"alt F1\")));\n    // complex \n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToBookmark_Action\", new Default_KeymapChanges.GoToBookmark_ShortcutChange_qjewi8_fc());\n    addComplexShortcut(\"jetbrains.mps.ide.actions.SetBookmark_Action\", new Default_KeymapChanges.SetBookmark_ShortcutChange_qjewi8_gc());\n  }","commit_id":"eded11079f3d8a7e0582724218d3f8fe43e98cc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorPopup_ActionGroup() {\n    super(\"EditorPopup\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      EditorPopup_ActionGroup.this.addParameterizedAction(new SelectInActionAdapter_Action(new SelectInAction()), PluginId.getId(\"jetbrains.mps.ide\"), new SelectInAction());\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ShowInProject_Action\");\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_showIn);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ShowNodeInInspector_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ShowClassInHierarchy_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ShowConceptInHierarchy_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ShowImplementations_Action\");\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_structure);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_paste);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_folding);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_goto);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_make);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_generateModel);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_gentrace);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.FindSpecificNodeUsages_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.FastFindNodeUsages_Action\");\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_find_instances);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.CloneRoot_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ShowParameters_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ShowNodeInfo_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ModelPropertiesWOShortcut_Action\");\n      EditorPopup_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_vcs);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","id":97388,"modified_method":"public EditorPopup_ActionGroup() {\n    super(\"EditorPopup\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      EditorPopup_ActionGroup.this.addParameterizedAction(new SelectInActionAdapter_Action(new SelectInAction()), PluginId.getId(\"jetbrains.mps.ide\"), new SelectInAction());\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ShowInProject_Action\");\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_showIn);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ShowNodeInInspector_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ShowClassInHierarchy_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ShowConceptInHierarchy_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ShowImplementations_Action\");\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_structure);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_paste);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_folding);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_goto);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_make);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_generateModel);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_gentrace);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.FindSpecificNodeUsages_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.FastFindNodeUsages_Action\");\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_find_instances);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n      EditorPopup_ActionGroup.this.addSeparator();\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.CreateAspect_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.CloneRoot_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ShowParameters_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ShowNodeInfo_Action\");\n      EditorPopup_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ModelPropertiesWOShortcut_Action\");\n      EditorPopup_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(EditorPopup_ActionGroup.LABEL_ID_vcs);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        EditorPopup_ActionGroup.this.addAction(action);\n      }\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","commit_id":"eded11079f3d8a7e0582724218d3f8fe43e98cc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void createGroups() {\n    // actions w/o parameters \n    addAction(new AddLanguageImport_Action());\n    addAction(new AddMissingImports_Action());\n    addAction(new AddModelImportByRoot_Action());\n    addAction(new AddModelImport_Action());\n    addAction(new AddModuleToProject_Action());\n    addAction(new AddToNewFavoritesList_Action());\n    addAction(new AnalyzeClasspath_Action());\n    addAction(new CloneModel_Action());\n    addAction(new CloneRoot_Action());\n    addAction(new CollapseAll_Action());\n    addAction(new Collapse_Action());\n    addAction(new CopyModelName_Action());\n    addAction(new CopyModuleName_Action());\n    addAction(new CopyNodeName_Action());\n    addAction(new CopyNodeReference_Action());\n    addAction(new CopyNode_Action());\n    addAction(new CutNode_Action());\n    addAction(new DeleteFavoritesList_Action());\n    addAction(new DeleteModels_Action());\n    addAction(new DeleteModules_Action());\n    addAction(new DeleteNode_Action());\n    addAction(new DeletePropertyAction_Action());\n    addAction(new DeleteReferenceAction_Action());\n    addAction(new EditNodeExplicit_Action());\n    addAction(new EditNode_Action());\n    addAction(new ExpandAll_Action());\n    addAction(new ExpandNode_Action());\n    addAction(new Expand_Action());\n    addAction(new FastFindNodeUsages_Action());\n    addAction(new FindNext_Action());\n    addAction(new FindPrevious_Action());\n    addAction(new FindSpecificNodeUsages_Action());\n    addAction(new Find_Action());\n    addAction(new FoldSelection_Action());\n    addAction(new GoByCurrentReference_Action());\n    addAction(new GoToNodeById_Action());\n    addAction(new HighlightInstances_Action());\n    addAction(new HighlightUsages_Action());\n    addAction(new MPSProjectPaths_Action());\n    addAction(new ModelPropertiesWOShortcut_Action());\n    addAction(new ModelProperties_Action());\n    addAction(new MoveFileOrDirectory_Action());\n    addAction(new NewDirectory_Action());\n    addAction(new NewFile_Action());\n    addAction(new NewModel_Action());\n    addAction(new NewRuntimeModule_Action());\n    addAction(new NewSubModel_Action());\n    addAction(new NewSubTestModel_Action());\n    addAction(new OptimizeModelImports_Action());\n    addAction(new OptimizeModuleImports_Action());\n    addAction(new OptimizeProjectImports_Action());\n    addAction(new PasteNode_Action());\n    addAction(new QuickCreate_Action());\n    addAction(new RemoveAllBookmarks_Action());\n    addAction(new RemoveFromFavorites_Action());\n    addAction(new RemoveModuleFromProject_Action());\n    addAction(new RemoveTransientModels_Action());\n    addAction(new RenameFavoritesList_Action());\n    addAction(new RenameFileOrDirectory_Action());\n    addAction(new RenameModel_Action());\n    addAction(new RenameNamespace_Action());\n    addAction(new RenamePackage_Action());\n    addAction(new RenameSolution_Action());\n    addAction(new RevertMemoryChanges_Action());\n    addAction(new SaveModel_Action());\n    addAction(new SetBookmarkNoNumber_Action());\n    addAction(new SetModuleFolder_Action());\n    addAction(new SetNodePackage_Action());\n    addAction(new ShowBookmarksDialog_Action());\n    addAction(new ShowBookmarks_Action());\n    addAction(new ShowClassInHierarchy_Action());\n    addAction(new ShowConceptInHierarchy_Action());\n    addAction(new ShowErrorMessage_Action());\n    addAction(new ShowImplementations_Action());\n    addAction(new ShowInProject_Action());\n    addAction(new ShowModuleDependencies_Action());\n    addAction(new ShowNodeInInspector_Action());\n    addAction(new ShowNodeInfo_Action());\n    addAction(new ShowParameters_Action());\n    addAction(new ShowReferencesToMissingStuff_Action());\n    addAction(new ShowStructure_Action());\n    addAction(new SolutionProperties_Action());\n    // groups \n    addGroup(new AbstractFileActions_ActionGroup());\n    addGroup(new AddToFavoritesGroup_ActionGroup());\n    addGroup(new Bookmarks_ActionGroup());\n    addGroup(new Build_ActionGroup());\n    addGroup(new Code_ActionGroup());\n    addGroup(new CreateRootNode_ActionGroup());\n    addGroup(new DebugActions_ActionGroup());\n    addGroup(new DevkitActions_ActionGroup());\n    addGroup(new Edit_ActionGroup());\n    addGroup(new EditorInternal_ActionGroup());\n    addGroup(new EditorLeftPanelMenu_ActionGroup());\n    addGroup(new EditorPopup_ActionGroup());\n    addGroup(new EditorTabActions_ActionGroup());\n    addGroup(new FavoritesPopupWrapper_ActionGroup());\n    addGroup(new FavoritesPopup_ActionGroup());\n    addGroup(new Favorites_ActionGroup());\n    addGroup(new FileActions_ActionGroup());\n    addGroup(new FileSystemNewActions_ActionGroup());\n    addGroup(new FolderActions_ActionGroup());\n    addGroup(new Folding_ActionGroup());\n    addGroup(new Generate_ActionGroup());\n    addGroup(new GeneratorActions_ActionGroup());\n    addGroup(new GeneratorNewActions_ActionGroup());\n    addGroup(new GoByReference_ActionGroup());\n    addGroup(new GoToEditorPopupAddition_ActionGroup());\n    addGroup(new Goto_ActionGroup());\n    addGroup(new JUnitTestCaseActions_ActionGroup());\n    addGroup(new JUnitTestMethodActions_ActionGroup());\n    addGroup(new LanguageActions_ActionGroup());\n    addGroup(new LanguageNewActions_ActionGroup());\n    addGroup(new ModelActionsInternal_ActionGroup());\n    addGroup(new ModelActions_ActionGroup());\n    addGroup(new ModelNewActions_ActionGroup());\n    addGroup(new ModelRefactoring_ActionGroup());\n    addGroup(new ModuleActions_ActionGroup());\n    addGroup(new ModulePropertiesGroup_ActionGroup());\n    addGroup(new NamespaceActions_ActionGroup());\n    addGroup(new NamespaceInternalActions_ActionGroup());\n    addGroup(new NamespaceMakeActions_ActionGroup());\n    addGroup(new NodeActionsInternal_ActionGroup());\n    addGroup(new NodeActions_ActionGroup());\n    addGroup(new PackageActions_ActionGroup());\n    addGroup(new PackageNewActions_ActionGroup());\n    addGroup(new ProjectActions_ActionGroup());\n    addGroup(new ProjectNewActions_ActionGroup());\n    addGroup(new PropertyNodeActions_ActionGroup());\n    addGroup(new ReferenceNodeActions_ActionGroup());\n    addGroup(new RuntimeFolderActions_ActionGroup());\n    addGroup(new Search_ActionGroup());\n    addGroup(new SolutionActions_ActionGroup());\n    addGroup(new SolutionNewActions_ActionGroup());\n    addGroup(new SolutionRefactoring_ActionGroup());\n    addGroup(new ToolsInternal_ActionGroup());\n    addGroup(new Tools_ActionGroup());\n    addGroup(new TransientModulesActions_ActionGroup());\n  }","id":97389,"modified_method":"public void createGroups() {\n    // actions w/o parameters \n    addAction(new AddLanguageImport_Action());\n    addAction(new AddMissingImports_Action());\n    addAction(new AddModelImportByRoot_Action());\n    addAction(new AddModelImport_Action());\n    addAction(new AddModuleToProject_Action());\n    addAction(new AddToNewFavoritesList_Action());\n    addAction(new AnalyzeClasspath_Action());\n    addAction(new CloneModel_Action());\n    addAction(new CloneRoot_Action());\n    addAction(new CollapseAll_Action());\n    addAction(new Collapse_Action());\n    addAction(new CopyModelName_Action());\n    addAction(new CopyModuleName_Action());\n    addAction(new CopyNodeName_Action());\n    addAction(new CopyNodeReference_Action());\n    addAction(new CopyNode_Action());\n    addAction(new CreateAspect_Action());\n    addAction(new CutNode_Action());\n    addAction(new DeleteFavoritesList_Action());\n    addAction(new DeleteModels_Action());\n    addAction(new DeleteModules_Action());\n    addAction(new DeleteNode_Action());\n    addAction(new DeletePropertyAction_Action());\n    addAction(new DeleteReferenceAction_Action());\n    addAction(new EditNodeExplicit_Action());\n    addAction(new EditNode_Action());\n    addAction(new ExpandAll_Action());\n    addAction(new ExpandNode_Action());\n    addAction(new Expand_Action());\n    addAction(new FastFindNodeUsages_Action());\n    addAction(new FindNext_Action());\n    addAction(new FindPrevious_Action());\n    addAction(new FindSpecificNodeUsages_Action());\n    addAction(new Find_Action());\n    addAction(new FoldSelection_Action());\n    addAction(new GoByCurrentReference_Action());\n    addAction(new GoToNodeById_Action());\n    addAction(new HighlightInstances_Action());\n    addAction(new HighlightUsages_Action());\n    addAction(new MPSProjectPaths_Action());\n    addAction(new ModelPropertiesWOShortcut_Action());\n    addAction(new ModelProperties_Action());\n    addAction(new MoveFileOrDirectory_Action());\n    addAction(new NewDirectory_Action());\n    addAction(new NewFile_Action());\n    addAction(new NewModel_Action());\n    addAction(new NewRuntimeModule_Action());\n    addAction(new NewSubModel_Action());\n    addAction(new NewSubTestModel_Action());\n    addAction(new OptimizeModelImports_Action());\n    addAction(new OptimizeModuleImports_Action());\n    addAction(new OptimizeProjectImports_Action());\n    addAction(new PasteNode_Action());\n    addAction(new QuickCreate_Action());\n    addAction(new RemoveAllBookmarks_Action());\n    addAction(new RemoveFromFavorites_Action());\n    addAction(new RemoveModuleFromProject_Action());\n    addAction(new RemoveTransientModels_Action());\n    addAction(new RenameFavoritesList_Action());\n    addAction(new RenameFileOrDirectory_Action());\n    addAction(new RenameModel_Action());\n    addAction(new RenameNamespace_Action());\n    addAction(new RenamePackage_Action());\n    addAction(new RenameSolution_Action());\n    addAction(new RevertMemoryChanges_Action());\n    addAction(new SaveModel_Action());\n    addAction(new SetBookmarkNoNumber_Action());\n    addAction(new SetModuleFolder_Action());\n    addAction(new SetNodePackage_Action());\n    addAction(new ShowBookmarksDialog_Action());\n    addAction(new ShowBookmarks_Action());\n    addAction(new ShowClassInHierarchy_Action());\n    addAction(new ShowConceptInHierarchy_Action());\n    addAction(new ShowErrorMessage_Action());\n    addAction(new ShowImplementations_Action());\n    addAction(new ShowInProject_Action());\n    addAction(new ShowModuleDependencies_Action());\n    addAction(new ShowNodeInInspector_Action());\n    addAction(new ShowNodeInfo_Action());\n    addAction(new ShowParameters_Action());\n    addAction(new ShowReferencesToMissingStuff_Action());\n    addAction(new ShowStructure_Action());\n    addAction(new SolutionProperties_Action());\n    // groups \n    addGroup(new AbstractFileActions_ActionGroup());\n    addGroup(new AddToFavoritesGroup_ActionGroup());\n    addGroup(new Bookmarks_ActionGroup());\n    addGroup(new Build_ActionGroup());\n    addGroup(new Code_ActionGroup());\n    addGroup(new CreateRootNode_ActionGroup());\n    addGroup(new DebugActions_ActionGroup());\n    addGroup(new DevkitActions_ActionGroup());\n    addGroup(new Edit_ActionGroup());\n    addGroup(new EditorInternal_ActionGroup());\n    addGroup(new EditorLeftPanelMenu_ActionGroup());\n    addGroup(new EditorPopup_ActionGroup());\n    addGroup(new EditorTabActions_ActionGroup());\n    addGroup(new FavoritesPopupWrapper_ActionGroup());\n    addGroup(new FavoritesPopup_ActionGroup());\n    addGroup(new Favorites_ActionGroup());\n    addGroup(new FileActions_ActionGroup());\n    addGroup(new FileSystemNewActions_ActionGroup());\n    addGroup(new FolderActions_ActionGroup());\n    addGroup(new Folding_ActionGroup());\n    addGroup(new Generate_ActionGroup());\n    addGroup(new GeneratorActions_ActionGroup());\n    addGroup(new GeneratorNewActions_ActionGroup());\n    addGroup(new GoByReference_ActionGroup());\n    addGroup(new GoToEditorPopupAddition_ActionGroup());\n    addGroup(new Goto_ActionGroup());\n    addGroup(new JUnitTestCaseActions_ActionGroup());\n    addGroup(new JUnitTestMethodActions_ActionGroup());\n    addGroup(new LanguageActions_ActionGroup());\n    addGroup(new LanguageNewActions_ActionGroup());\n    addGroup(new ModelActionsInternal_ActionGroup());\n    addGroup(new ModelActions_ActionGroup());\n    addGroup(new ModelNewActions_ActionGroup());\n    addGroup(new ModelRefactoring_ActionGroup());\n    addGroup(new ModuleActions_ActionGroup());\n    addGroup(new ModulePropertiesGroup_ActionGroup());\n    addGroup(new NamespaceActions_ActionGroup());\n    addGroup(new NamespaceInternalActions_ActionGroup());\n    addGroup(new NamespaceMakeActions_ActionGroup());\n    addGroup(new NodeActionsInternal_ActionGroup());\n    addGroup(new NodeActions_ActionGroup());\n    addGroup(new PackageActions_ActionGroup());\n    addGroup(new PackageNewActions_ActionGroup());\n    addGroup(new ProjectActions_ActionGroup());\n    addGroup(new ProjectNewActions_ActionGroup());\n    addGroup(new PropertyNodeActions_ActionGroup());\n    addGroup(new ReferenceNodeActions_ActionGroup());\n    addGroup(new RuntimeFolderActions_ActionGroup());\n    addGroup(new Search_ActionGroup());\n    addGroup(new SolutionActions_ActionGroup());\n    addGroup(new SolutionNewActions_ActionGroup());\n    addGroup(new SolutionRefactoring_ActionGroup());\n    addGroup(new ToolsInternal_ActionGroup());\n    addGroup(new Tools_ActionGroup());\n    addGroup(new TransientModulesActions_ActionGroup());\n  }","commit_id":"eded11079f3d8a7e0582724218d3f8fe43e98cc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Mac_KeymapChanges() {\n    // simple \n    addSimpleShortcut(\"jetbrains.mps.ide.actions.AddModelImport_Action\", getShortcut(\"ctrl M\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.QuickCreate_Action\", getShortcut(\"ctrl N\"), getShortcut(\"ctrl ENTER\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowClassInHierarchy_Action\", getShortcut(\"ctrl H\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowConceptInHierarchy_Action\", getShortcut(\"ctrl H\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowNodeInfo_Action\", getShortcut(\"ctrl Q\"));\n    // simple parameterized \n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToBookmark_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"ctrl 0\")));\n    // complex \n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToBookmark_Action\", new Mac_KeymapChanges.GoToBookmark_ShortcutChange_tqv_g());\n  }","id":97390,"modified_method":"public Mac_KeymapChanges() {\n    // simple \n    addSimpleShortcut(\"jetbrains.mps.ide.actions.AddModelImport_Action\", getShortcut(\"ctrl M\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.CreateAspect_Action\", getShortcut(\"ctrl alt N\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.QuickCreate_Action\", getShortcut(\"ctrl N\"), getShortcut(\"ctrl ENTER\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowClassInHierarchy_Action\", getShortcut(\"ctrl H\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowConceptInHierarchy_Action\", getShortcut(\"ctrl H\"));\n    addSimpleShortcut(\"jetbrains.mps.ide.actions.ShowNodeInfo_Action\", getShortcut(\"ctrl Q\"));\n    // simple parameterized \n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToBookmark_Action\", new BaseKeymapChanges.ComplexShortcut.ParameterizedSimpleShortcut(getShortcut(\"ctrl 0\")));\n    // complex \n    addComplexShortcut(\"jetbrains.mps.ide.actions.GoToBookmark_Action\", new Mac_KeymapChanges.GoToBookmark_ShortcutChange_tqv_h());\n  }","commit_id":"eded11079f3d8a7e0582724218d3f8fe43e98cc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"node\", event.getData(MPSDataKeys.LOGICAL_VIEW_NODE));\n    MapSequence.fromMap(_params).put(\"model\", event.getData(MPSDataKeys.CONTEXT_MODEL));\n    return true;\n  }","id":97391,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"node\", event.getData(MPSDataKeys.LOGICAL_VIEW_NODE));\n    if (MapSequence.fromMap(_params).get(\"node\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"eded11079f3d8a7e0582724218d3f8fe43e98cc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"QuickCreate\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":97392,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"QuickCreate\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"eded11079f3d8a7e0582724218d3f8fe43e98cc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Wrappers._T<ListPopup> popup = new Wrappers._T<ListPopup>(null);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ActionGroup group;\n          boolean controlDown = event.getInputEvent().isControlDown();\n\n          if (((TreeNode) MapSequence.fromMap(_params).get(\"node\")) != null) {\n            group = ((MPSTreeNode) ((TreeNode) MapSequence.fromMap(_params).get(\"node\"))).getQuickCreateGroup(controlDown);\n          } else {\n            group = new CreateRootNodeGroup(controlDown);\n          }\n          if (group != null) {\n            Presentation pres = new Presentation();\n            AnActionEvent e = new AnActionEvent(event.getInputEvent(), event.getDataContext(), ActionPlaces.UNKNOWN, pres, ActionManager.getInstance(), 0);\n            ActionUtils.updateGroup(group, e);\n            popup.value = JBPopupFactory.getInstance().createActionGroupPopup(\"New\", group, event.getDataContext(), JBPopupFactory.ActionSelectionAid.SPEEDSEARCH, false);\n          }\n        }\n      });\n      if (popup.value == null) {\n        return;\n      }\n      popup.value.showInBestPositionFor(event.getDataContext());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"QuickCreate\", t);\n      }\n    }\n  }","id":97393,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Wrappers._T<ListPopup> popup = new Wrappers._T<ListPopup>(null);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          boolean controlDown = event.getInputEvent().isControlDown();\n          ActionGroup group = ((MPSTreeNode) ((TreeNode) MapSequence.fromMap(_params).get(\"node\"))).getQuickCreateGroup(controlDown);\n\n          if (group != null) {\n            Presentation pres = new Presentation();\n            AnActionEvent e = new AnActionEvent(event.getInputEvent(), event.getDataContext(), ActionPlaces.UNKNOWN, pres, ActionManager.getInstance(), 0);\n            ActionUtils.updateGroup(group, e);\n            popup.value = JBPopupFactory.getInstance().createActionGroupPopup(\"New\", group, event.getDataContext(), JBPopupFactory.ActionSelectionAid.SPEEDSEARCH, false);\n          }\n        }\n      });\n      if (popup.value == null) {\n        return;\n      }\n      popup.value.showInBestPositionFor(event.getDataContext());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"QuickCreate\", t);\n      }\n    }\n  }","commit_id":"eded11079f3d8a7e0582724218d3f8fe43e98cc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TabbedEditor(SNodePointer baseNode, Set<EditorTabDescriptor> possibleTabs, IOperationContext context) {\n    super(context);\n    myBaseNode = baseNode;\n    myContext = context;\n    myColorProvider = Extensions.getRootArea().getExtensionPoint(TabColorProvider.EP_NAME).getExtension();\n\n    myTabsComponent = new TabsComponent(baseNode, possibleTabs, getComponent()) {\n      protected void changeNode(SNode newNode) {\n        showNode(newNode, !newNode.isRoot());\n      }\n    };\n\n    showNode(baseNode.getNode(), false);\n\n    getComponent().add(myTabsComponent, BorderLayout.SOUTH);\n  }","id":97394,"modified_method":"public TabbedEditor(SNodePointer baseNode, Set<EditorTabDescriptor> possibleTabs, IOperationContext context) {\n    super(context);\n    myBaseNode = baseNode;\n    myPossibleTabs = possibleTabs;\n    myContext = context;\n    myColorProvider = Extensions.getRootArea().getExtensionPoint(TabColorProvider.EP_NAME).getExtension();\n\n    myTabsComponent = new TabsComponent(baseNode, possibleTabs, getComponent()) {\n      protected void changeNode(SNode newNode) {\n        showNode(newNode, !newNode.isRoot());\n      }\n    };\n\n    showNode(baseNode.getNode(), false);\n\n    getComponent().add(myTabsComponent, BorderLayout.SOUTH);\n  }","commit_id":"eded11079f3d8a7e0582724218d3f8fe43e98cc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public NamespaceNewActionsEx_ActionGroup() {\n    super(\"NamespaceNewActionsEx\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      NamespaceNewActionsEx_ActionGroup.this.addAction(\"jetbrains.mps.ide.devkit.actions.NewLanguage_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","id":97395,"modified_method":"public NamespaceNewActionsEx_ActionGroup() {\n    super(\"NamespaceNewActionsEx\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      NamespaceNewActionsEx_ActionGroup.this.addAction(\"jetbrains.mps.ide.devkit.actions.NewLanguage_Action\");\n      NamespaceNewActionsEx_ActionGroup.this.addAction(\"jetbrains.mps.ide.devkit.actions.NewDevKit_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","commit_id":"382d20305c860c271a3c6a92660840ffd7a65aa0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      NewDevKitDialog dialog = new NewDevKitDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n      dialog.setProject(((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n      dialog.showDialog();\n      DevKit devkit = dialog.getResult();\n      if (devkit == null) {\n        return;\n      }\n      ProjectPane projectPane = ProjectPane.getInstance(((Project) MapSequence.fromMap(_params).get(\"ideaProject\")));\n      projectPane.rebuildTree();\n      projectPane.selectModule(devkit, false);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"NewDevKit\", t);\n      }\n    }\n  }","id":97396,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      NewDevKitDialog dialog = new NewDevKitDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n      dialog.setProject(((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n      dialog.showDialog();\n      final DevKit devkit = dialog.getResult();\n      if (devkit == null) {\n        return;\n      }\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        public void run() {\n          ((StandaloneMPSProject) ((MPSProject) MapSequence.fromMap(_params).get(\"project\"))).setFolderFor(devkit, (((String) MapSequence.fromMap(_params).get(\"namespace\")) == null ?\n            \"\" :\n            ((String) MapSequence.fromMap(_params).get(\"namespace\"))\n          ));\n        }\n      });\n      ProjectPane projectPane = ProjectPane.getInstance(((Project) MapSequence.fromMap(_params).get(\"ideaProject\")));\n      projectPane.rebuildTree();\n      projectPane.selectModule(devkit, false);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"NewDevKit\", t);\n      }\n    }\n  }","commit_id":"382d20305c860c271a3c6a92660840ffd7a65aa0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"NewDevKit\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":97397,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action doUpdate method failed. Action:\" + \"NewDevKit\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"382d20305c860c271a3c6a92660840ffd7a65aa0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"RenameLink\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":97398,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"RenameLink\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"60a72fea690abb931a1a08a33c80848026a8400b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Wrappers._T<String> oldName = new Wrappers._T<String>();\n      ModelAccess modelAccess = ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getRepository().getModelAccess();\n      modelAccess.runReadAction(new Runnable() {\n        public void run() {\n          oldName.value = SPropertyOperations.getString(((SNode) MapSequence.fromMap(_params).get(\"target\")), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\"));\n        }\n      });\n      final String newName = RenameDialog.getNewName(((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getProject(), oldName.value, \"link\");\n      if (newName == null) {\n        return;\n      }\n\n      modelAccess.runReadInEDT(new Runnable() {\n        public void run() {\n          SNode node = ((SNode) ((SNode) MapSequence.fromMap(_params).get(\"target\")));\n          if (!(SNodeUtil.isAccessible(node, MPSModuleRepository.getInstance()))) {\n            return;\n          }\n          RefactoringAccess.getInstance().getRefactoringFacade().execute(RefactoringContext.createRefactoringContextByName(\"jetbrains.mps.lang.structure.refactorings.RenameLink\", Arrays.asList(\"newName\"), Arrays.asList(newName), ((SNode) MapSequence.fromMap(_params).get(\"target\")), ((MPSProject) MapSequence.fromMap(_params).get(\"project\"))));\n        }\n      });\n\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"RenameLink\", t);\n      }\n    }\n  }","id":97399,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Wrappers._T<String> oldName = new Wrappers._T<String>();\n      ModelAccess modelAccess = ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getRepository().getModelAccess();\n      modelAccess.runReadAction(new Runnable() {\n        public void run() {\n          oldName.value = SPropertyOperations.getString(((SNode) MapSequence.fromMap(_params).get(\"target\")), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\"));\n        }\n      });\n      final String newName = RenameDialog.getNewName(((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getProject(), oldName.value, \"link\");\n      if (newName == null) {\n        return;\n      }\n\n      modelAccess.executeCommand(new Runnable() {\n        public void run() {\n          SPropertyOperations.set(((SNode) MapSequence.fromMap(_params).get(\"target\")), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98052f333L, \"role\"), newName);\n        }\n      });\n\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"RenameLink\", t);\n      }\n    }\n  }","commit_id":"60a72fea690abb931a1a08a33c80848026a8400b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        boolean enabled = this.isApplicable(event, _params);\n        this.setEnabledState(event.getPresentation(), enabled);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"RenameProperty\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","id":97400,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      this.enable(event.getPresentation());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action doUpdate method failed. Action:\" + \"RenameProperty\", t);\n      }\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"60a72fea690abb931a1a08a33c80848026a8400b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Wrappers._T<String> oldName = new Wrappers._T<String>();\n      ModelAccess modelAccess = ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getRepository().getModelAccess();\n\n      modelAccess.runReadAction(new Runnable() {\n        public void run() {\n          oldName.value = SPropertyOperations.getString(((SNode) MapSequence.fromMap(_params).get(\"target\")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"));\n        }\n      });\n      final String newName = RenameDialog.getNewName(((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getProject(), oldName.value, \"property\");\n      if (newName == null) {\n        return;\n      }\n\n      modelAccess.runReadInEDT(new Runnable() {\n        public void run() {\n          SNode node = ((SNode) ((SNode) MapSequence.fromMap(_params).get(\"target\")));\n          if (!(SNodeUtil.isAccessible(node, MPSModuleRepository.getInstance()))) {\n            return;\n          }\n          RefactoringAccess.getInstance().getRefactoringFacade().execute(RefactoringContext.createRefactoringContextByName(\"jetbrains.mps.lang.structure.refactorings.RenameProperty\", Arrays.asList(\"newName\"), Arrays.asList(newName), ((SNode) MapSequence.fromMap(_params).get(\"target\")), ((MPSProject) MapSequence.fromMap(_params).get(\"project\"))));\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"RenameProperty\", t);\n      }\n    }\n  }","id":97401,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Wrappers._T<String> oldName = new Wrappers._T<String>();\n      ModelAccess modelAccess = ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getRepository().getModelAccess();\n\n      modelAccess.runReadAction(new Runnable() {\n        public void run() {\n          oldName.value = SPropertyOperations.getString(((SNode) MapSequence.fromMap(_params).get(\"target\")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"));\n        }\n      });\n      final String newName = RenameDialog.getNewName(((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getProject(), oldName.value, \"property\");\n      if (newName == null) {\n        return;\n      }\n\n      modelAccess.executeCommand(new Runnable() {\n        public void run() {\n          SPropertyOperations.set(((SNode) MapSequence.fromMap(_params).get(\"target\")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), newName);\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"RenameProperty\", t);\n      }\n    }\n  }","commit_id":"60a72fea690abb931a1a08a33c80848026a8400b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void generatePrimaryConstructorProperties(PropertyCodegen propertyCodegen, JetClassOrObject origin) {\n        boolean isAnnotation = origin instanceof JetClass && ((JetClass)origin).isAnnotation();\n        OwnerKind kind = context.getContextKind();\n        for (JetParameter p : getPrimaryConstructorParameters()) {\n            if (p.getValOrVarNode() != null) {\n                PropertyDescriptor propertyDescriptor = state.getBindingContext().get(BindingContext.PRIMARY_CONSTRUCTOR_PARAMETER, p);\n                if (propertyDescriptor != null) {\n                    if (!isAnnotation) {\n                        int accessModifiers = JetTypeMapper.getAccessModifiers(propertyDescriptor, 0);\n                        if((accessModifiers & ACC_PRIVATE) == 0) {\n                            propertyCodegen.generateDefaultGetter(propertyDescriptor, accessModifiers, p);\n                            if (propertyDescriptor.isVar()) {\n                                propertyCodegen.generateDefaultSetter(propertyDescriptor, accessModifiers, origin);\n                            }\n                        }\n\n                        //noinspection ConstantConditions\n                        if (!(kind instanceof OwnerKind.DelegateKind) && state.getBindingContext().get(BindingContext.BACKING_FIELD_REQUIRED, propertyDescriptor)) {\n                            int modifiers = accessModifiers;\n                            if (!propertyDescriptor.isVar()) {\n                                modifiers |= Opcodes.ACC_FINAL;\n                            }\n                            if (JetStandardLibrary.isVolatile(propertyDescriptor)) {\n                                modifiers |= Opcodes.ACC_VOLATILE;\n                            }\n                            Type type = state.getInjector().getJetTypeMapper().mapType(propertyDescriptor.getType(), MapTypeMode.VALUE);\n                            v.newField(p, modifiers, p.getName(), type.getDescriptor(), null, null);\n                        }\n                    }\n                    else {\n                        Type type = state.getInjector().getJetTypeMapper().mapType(propertyDescriptor.getType(), MapTypeMode.VALUE);\n                        v.newMethod(p, ACC_PUBLIC | ACC_ABSTRACT, p.getName(), \"()\" + type.getDescriptor(), null, null);\n                    }\n                }\n            }\n        }\n    }","id":97402,"modified_method":"private void generatePrimaryConstructorProperties(PropertyCodegen propertyCodegen, JetClassOrObject origin) {\n        boolean isAnnotation = origin instanceof JetClass && ((JetClass)origin).isAnnotation();\n        OwnerKind kind = context.getContextKind();\n        for (JetParameter p : getPrimaryConstructorParameters()) {\n            if (p.getValOrVarNode() != null) {\n                PropertyDescriptor propertyDescriptor = state.getBindingContext().get(BindingContext.PRIMARY_CONSTRUCTOR_PARAMETER, p);\n                if (propertyDescriptor != null) {\n                    if (!isAnnotation) {\n                        int accessModifiers = JetTypeMapper.getAccessModifiers(propertyDescriptor, 0);\n                        if((accessModifiers & ACC_PRIVATE) == 0) {\n                            propertyCodegen.generateDefaultGetter(propertyDescriptor, accessModifiers, p);\n                            if (propertyDescriptor.isVar()) {\n                                propertyCodegen.generateDefaultSetter(propertyDescriptor, accessModifiers, origin);\n                            }\n                        }\n\n                        //noinspection ConstantConditions\n                        if (!(kind instanceof OwnerKind.DelegateKind) && state.getBindingContext().get(BindingContext.BACKING_FIELD_REQUIRED, propertyDescriptor)) {\n                            int modifiers = accessModifiers;\n                            if (!propertyDescriptor.isVar()) {\n                                modifiers |= Opcodes.ACC_FINAL;\n                            }\n                            if (JetStandardLibrary.isVolatile(propertyDescriptor)) {\n                                modifiers |= Opcodes.ACC_VOLATILE;\n                            }\n                            Type type = state.getInjector().getJetTypeMapper().mapType(propertyDescriptor.getType(), MapTypeMode.VALUE);\n                            FieldVisitor fieldVisitor = v.newField(p, modifiers, p.getName(), type.getDescriptor(), null, null);\n                            AnnotationCodegen.forField(fieldVisitor, state.getInjector().getJetTypeMapper()).genAnnotations(propertyDescriptor);\n                        }\n                    }\n                    else {\n                        Type type = state.getInjector().getJetTypeMapper().mapType(propertyDescriptor.getType(), MapTypeMode.VALUE);\n                        v.newMethod(p, ACC_PUBLIC | ACC_ABSTRACT, p.getName(), \"()\" + type.getDescriptor(), null, null);\n                    }\n                }\n            }\n        }\n    }","commit_id":"16bcc7967e270aa6a33b11b833d550016e01ffee","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void generatedMethod(JetExpression bodyExpressions,\n            JvmMethodSignature jvmSignature,\n            boolean needJetAnnotations, @Nullable String propertyTypeSignature,\n            CodegenContexts.MethodContext context,\n            FunctionDescriptor functionDescriptor,\n            JetDeclarationWithBody fun\n    )\n    {\n        if (functionDescriptor.getKind() == CallableMemberDescriptor.Kind.FAKE_OVERRIDE) {\n            throw new IllegalStateException(\"must not generate code for fake overrides\");\n        }\n\n        List<ValueParameterDescriptor> paramDescrs = functionDescriptor.getValueParameters();\n        List<TypeParameterDescriptor> typeParameters = (functionDescriptor instanceof PropertyAccessorDescriptor ? ((PropertyAccessorDescriptor)functionDescriptor).getCorrespondingProperty(): functionDescriptor).getTypeParameters();\n\n        int flags = JetTypeMapper.getAccessModifiers(functionDescriptor, 0);\n        \n        if (!functionDescriptor.getValueParameters().isEmpty()\n                && functionDescriptor.getValueParameters().get(functionDescriptor.getValueParameters().size() - 1)\n                        .getVarargElementType() != null)\n        {\n            flags |= ACC_VARARGS;\n        }\n\n        Modality modality = functionDescriptor.getModality();\n        if (modality == Modality.FINAL) {\n            DeclarationDescriptor containingDeclaration = functionDescriptor.getContainingDeclaration();\n            if (!(containingDeclaration instanceof ClassDescriptor) || ((ClassDescriptor)containingDeclaration).getKind() != ClassKind.TRAIT) {\n                flags |= ACC_FINAL;\n            }\n        }\n\n        OwnerKind kind = context.getContextKind();\n        \n        if (kind == OwnerKind.TRAIT_IMPL) {\n            needJetAnnotations = false;\n        }\n\n        ReceiverDescriptor expectedThisObject = functionDescriptor.getExpectedThisObject();\n        ReceiverDescriptor receiverParameter = functionDescriptor.getReceiverParameter();\n\n        if (kind != OwnerKind.TRAIT_IMPL || bodyExpressions != null) {\n            boolean isStatic = kind == OwnerKind.NAMESPACE || kind instanceof OwnerKind.StaticDelegateKind;\n            if (isStatic || kind == OwnerKind.TRAIT_IMPL)\n                flags |= ACC_STATIC;\n\n            boolean isAbstract = (\n                        modality == Modality.ABSTRACT\n                        || CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration())\n                    ) && !isStatic && kind != OwnerKind.TRAIT_IMPL;\n            if (isAbstract) flags |= ACC_ABSTRACT;\n            \n            final MethodVisitor mv = v.newMethod(fun, flags, jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor(), jvmSignature.getGenericsSignature(), null);\n            AnnotationCodegen.forMethod(mv, state.getInjector().getJetTypeMapper()).genAnnotations(functionDescriptor);\n            if (state.getClassBuilderMode() != ClassBuilderMode.SIGNATURES) {\n                int start = 0;\n                if (needJetAnnotations) {\n                    if (functionDescriptor instanceof PropertyAccessorDescriptor) {\n                        PropertyCodegen.generateJetPropertyAnnotation(mv, propertyTypeSignature, jvmSignature.getKotlinTypeParameter(),\n                                                                      ((PropertyAccessorDescriptor) functionDescriptor)\n                                                                              .getCorrespondingProperty(),\n                                                                      functionDescriptor.getVisibility());\n                    }\n                    else if (functionDescriptor instanceof SimpleFunctionDescriptor) {\n                        if (propertyTypeSignature != null) {\n                            throw new IllegalStateException();\n                        }\n                        JetMethodAnnotationWriter aw = JetMethodAnnotationWriter.visitAnnotation(mv);\n                        BitSet kotlinFlags = CodegenUtil.getFlagsForVisibility(functionDescriptor.getVisibility());\n                        if (CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration()) && modality != Modality.ABSTRACT) {\n                            kotlinFlags.set(modality == Modality.FINAL\n                                            ? JvmStdlibNames.FLAG_FORCE_FINAL_BIT\n                                            : JvmStdlibNames.FLAG_FORCE_OPEN_BIT);\n                        }\n                        aw.writeFlags(kotlinFlags);\n                        aw.writeNullableReturnType(functionDescriptor.getReturnType().isNullable());\n                        aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());\n                        aw.writeReturnType(jvmSignature.getKotlinReturnType());\n                        aw.visitEnd();\n                    }\n                    else {\n                        throw new IllegalStateException();\n                    }\n\n                    if (receiverParameter.exists()) {\n                        JetValueParameterAnnotationWriter av = JetValueParameterAnnotationWriter.visitParameterAnnotation(mv, start++);\n                        av.writeName(\"this$receiver\");\n                        av.writeNullable(receiverParameter.getType().isNullable());\n                        av.writeReceiver();\n                        if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(0) != null) {\n                            av.writeType(jvmSignature.getKotlinParameterTypes().get(0).getKotlinSignature());\n                        }\n                        av.visitEnd();\n                    }\n                    for(int i = 0; i != paramDescrs.size(); ++i) {\n                        JetValueParameterAnnotationWriter av = JetValueParameterAnnotationWriter.visitParameterAnnotation(mv, i + start);\n                        ValueParameterDescriptor parameterDescriptor = paramDescrs.get(i);\n                        av.writeName(parameterDescriptor.getName().getName());\n                        av.writeHasDefaultValue(parameterDescriptor.declaresDefaultValue());\n                        av.writeNullable(parameterDescriptor.getType().isNullable());\n                        if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(i) != null) {\n                            av.writeType(jvmSignature.getKotlinParameterTypes().get(i + start).getKotlinSignature());\n                        }\n                        av.visitEnd();\n                    }\n                }\n            }\n\n            if (!isAbstract && state.getClassBuilderMode() == ClassBuilderMode.STUBS) {\n                StubCodegen.generateStubCode(mv);\n            }\n\n\n            if (!isAbstract && state.getClassBuilderMode() == ClassBuilderMode.FULL) {\n                mv.visitCode();\n                \n                Label methodBegin = new Label();\n                mv.visitLabel(methodBegin);\n                \n                FrameMap frameMap = context.prepareFrame(state.getInjector().getJetTypeMapper());\n\n                ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, jvmSignature.getAsmMethod().getReturnType(), context, state);\n\n                Type[] argTypes = jvmSignature.getAsmMethod().getArgumentTypes();\n                int add = 0;\n\n                if (kind == OwnerKind.TRAIT_IMPL)\n                    add++;\n\n                if (receiverParameter.exists())\n                    add++;\n\n                for (int i = 0; i < paramDescrs.size(); i++) {\n                    ValueParameterDescriptor parameter = paramDescrs.get(i);\n                    frameMap.enter(parameter, argTypes[i+add].getSize());\n                }\n\n                if (!isStatic && (kind instanceof OwnerKind.DelegateKind) != (functionDescriptor.getKind() == FunctionDescriptor.Kind.DELEGATION)) {\n                    throw new IllegalStateException(\"mismatching kind in \" + functionDescriptor);\n                }\n\n                Map<Name, Label> mapLabelsToDivideLocalVarVisibilityForSharedVar = new HashMap<Name, Label>();\n\n                if (kind instanceof OwnerKind.StaticDelegateKind) {\n                    OwnerKind.StaticDelegateKind dk = (OwnerKind.StaticDelegateKind) kind;\n                    InstructionAdapter iv = new InstructionAdapter(mv);\n                    for (int i = 0, k = 0; i < argTypes.length; i++) {\n                        Type argType = argTypes[i];\n                        iv.load(k, argType);\n                        k += argType.getSize();\n                    }\n                    iv.invokestatic(dk.getOwnerClass(), jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor());\n                    iv.areturn(jvmSignature.getAsmMethod().getReturnType());\n                }\n                else if (kind instanceof OwnerKind.DelegateKind) {\n                    OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;\n                    InstructionAdapter iv = new InstructionAdapter(mv);\n                    iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                    dk.getDelegate().put(JetTypeMapper.TYPE_OBJECT, iv);\n                    for (int i = 0; i < argTypes.length; i++) {\n                        Type argType = argTypes[i];\n                        iv.load(i + 1, argType);\n                    }\n                    iv.invokeinterface(dk.getOwnerClass(), jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor());\n                    iv.areturn(jvmSignature.getAsmMethod().getReturnType());\n                }\n                else {\n                    for (ValueParameterDescriptor parameter : paramDescrs) {\n                        Type sharedVarType = state.getInjector().getJetTypeMapper().getSharedVarType(parameter);\n                        if (sharedVarType != null) {\n                            Type localVarType = state.getInjector().getJetTypeMapper().mapType(parameter.getType(), MapTypeMode.VALUE);\n                            int index = frameMap.getIndex(parameter);\n                            mv.visitTypeInsn(NEW, sharedVarType.getInternalName());\n                            mv.visitInsn(DUP);\n                            mv.visitInsn(DUP);\n                            mv.visitMethodInsn(INVOKESPECIAL, sharedVarType.getInternalName(), \"<init>\", \"()V\");\n                            mv.visitVarInsn(localVarType.getOpcode(ILOAD), index);\n                            mv.visitFieldInsn(PUTFIELD, sharedVarType.getInternalName(), \"ref\", StackValue.refType(localVarType).getDescriptor());\n\n                            Label labelToDivideLocalVarForSharedVarVisibility = new Label();\n                            mv.visitLabel(labelToDivideLocalVarForSharedVarVisibility);\n                            mapLabelsToDivideLocalVarVisibilityForSharedVar.put(parameter.getName(), labelToDivideLocalVarForSharedVarVisibility);\n\n                            mv.visitVarInsn(sharedVarType.getOpcode(ISTORE), index);\n                        }\n                    }\n\n                    codegen.returnExpression(bodyExpressions);\n                }\n                \n                Label methodEnd = new Label();\n                mv.visitLabel(methodEnd);\n\n                Collection<String> localVariableNames = new HashSet<String>();\n                localVariableNames.addAll(codegen.getLocalVariableNamesForExpression());\n                for (ValueParameterDescriptor parameterDescriptor : paramDescrs) {\n                    localVariableNames.add(parameterDescriptor.getName().getName());\n                }\n\n                int k = 0;\n\n                if (expectedThisObject.exists()) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(expectedThisObject.getType(), MapTypeMode.VALUE);\n                    // TODO: specify signature\n                    mv.visitLocalVariable(\"this\", type.getDescriptor(), null, methodBegin, methodEnd, k++);\n                }\n                else if (fun instanceof JetFunctionLiteralExpression || CodegenUtil.isLocalFun(functionDescriptor, state.getBindingContext())) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(\n                            context.getThisDescriptor().getDefaultType(), MapTypeMode.VALUE);\n                    mv.visitLocalVariable(\"this\", type.getDescriptor(), null, methodBegin, methodEnd, k++);\n                }\n\n                if (receiverParameter.exists()) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(receiverParameter.getType(), MapTypeMode.VALUE);\n                    // TODO: specify signature\n                    mv.visitLocalVariable(\"this$receiver\", type.getDescriptor(), null, methodBegin, methodEnd, k);\n                    k += type.getSize();\n                }\n\n                for (ValueParameterDescriptor parameter : paramDescrs) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(parameter.getType(), MapTypeMode.VALUE);\n                    // TODO: specify signature\n\n                    Label divideLabel = mapLabelsToDivideLocalVarVisibilityForSharedVar.get(parameter.getName());\n                    String parameterName = parameter.getName().getName();\n                    if (divideLabel != null) {\n                        Type sharedVarType = state.getInjector().getJetTypeMapper().getSharedVarType(parameter);\n                        mv.visitLocalVariable(parameterName, type.getDescriptor(), null, methodBegin, divideLabel, k);\n\n                        String nameForSharedVar = CodegenUtil.generateTmpVariableName(localVariableNames);\n                        localVariableNames.add(nameForSharedVar);\n\n                        mv.visitLocalVariable(nameForSharedVar, sharedVarType.getDescriptor(), null, divideLabel, methodEnd, k);\n                        k += Math.max(type.getSize(), sharedVarType.getSize());\n                    }   else {\n                        mv.visitLocalVariable(parameter.getName().getName(), type.getDescriptor(), null, methodBegin, methodEnd, k);\n                        k += type.getSize();\n                    }\n                }\n\n                endVisit(mv, null, fun);\n                mv.visitEnd();\n\n                generateBridgeIfNeeded(owner, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);\n            }\n        }\n\n        generateDefaultIfNeeded(context, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);\n    }","id":97403,"modified_method":"private void generatedMethod(JetExpression bodyExpressions,\n            JvmMethodSignature jvmSignature,\n            boolean needJetAnnotations, @Nullable String propertyTypeSignature,\n            CodegenContexts.MethodContext context,\n            FunctionDescriptor functionDescriptor,\n            JetDeclarationWithBody fun\n    )\n    {\n        if (functionDescriptor.getKind() == CallableMemberDescriptor.Kind.FAKE_OVERRIDE) {\n            throw new IllegalStateException(\"must not generate code for fake overrides\");\n        }\n\n        List<ValueParameterDescriptor> paramDescrs = functionDescriptor.getValueParameters();\n        List<TypeParameterDescriptor> typeParameters = (functionDescriptor instanceof PropertyAccessorDescriptor ? ((PropertyAccessorDescriptor)functionDescriptor).getCorrespondingProperty(): functionDescriptor).getTypeParameters();\n\n        int flags = JetTypeMapper.getAccessModifiers(functionDescriptor, 0);\n        \n        if (!functionDescriptor.getValueParameters().isEmpty()\n                && functionDescriptor.getValueParameters().get(functionDescriptor.getValueParameters().size() - 1)\n                        .getVarargElementType() != null)\n        {\n            flags |= ACC_VARARGS;\n        }\n\n        Modality modality = functionDescriptor.getModality();\n        if (modality == Modality.FINAL) {\n            DeclarationDescriptor containingDeclaration = functionDescriptor.getContainingDeclaration();\n            if (!(containingDeclaration instanceof ClassDescriptor) || ((ClassDescriptor)containingDeclaration).getKind() != ClassKind.TRAIT) {\n                flags |= ACC_FINAL;\n            }\n        }\n\n        OwnerKind kind = context.getContextKind();\n        \n        if (kind == OwnerKind.TRAIT_IMPL) {\n            needJetAnnotations = false;\n        }\n\n        ReceiverDescriptor expectedThisObject = functionDescriptor.getExpectedThisObject();\n        ReceiverDescriptor receiverParameter = functionDescriptor.getReceiverParameter();\n\n        if (kind != OwnerKind.TRAIT_IMPL || bodyExpressions != null) {\n            boolean isStatic = kind == OwnerKind.NAMESPACE || kind instanceof OwnerKind.StaticDelegateKind;\n            if (isStatic || kind == OwnerKind.TRAIT_IMPL)\n                flags |= ACC_STATIC;\n\n            boolean isAbstract = (\n                        modality == Modality.ABSTRACT\n                        || CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration())\n                    ) && !isStatic && kind != OwnerKind.TRAIT_IMPL;\n            if (isAbstract) flags |= ACC_ABSTRACT;\n            \n            final MethodVisitor mv = v.newMethod(fun, flags, jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor(), jvmSignature.getGenericsSignature(), null);\n            AnnotationCodegen.forMethod(mv, state.getInjector().getJetTypeMapper()).genAnnotations(functionDescriptor);\n            if (state.getClassBuilderMode() != ClassBuilderMode.SIGNATURES) {\n                int start = 0;\n                if (needJetAnnotations) {\n                    if (functionDescriptor instanceof PropertyAccessorDescriptor) {\n                        PropertyCodegen.generateJetPropertyAnnotation(mv, propertyTypeSignature, jvmSignature.getKotlinTypeParameter(),\n                                                                      ((PropertyAccessorDescriptor) functionDescriptor)\n                                                                              .getCorrespondingProperty(),\n                                                                      functionDescriptor.getVisibility());\n                    }\n                    else if (functionDescriptor instanceof SimpleFunctionDescriptor) {\n                        if (propertyTypeSignature != null) {\n                            throw new IllegalStateException();\n                        }\n                        JetMethodAnnotationWriter aw = JetMethodAnnotationWriter.visitAnnotation(mv);\n                        BitSet kotlinFlags = CodegenUtil.getFlagsForVisibility(functionDescriptor.getVisibility());\n                        if (CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration()) && modality != Modality.ABSTRACT) {\n                            kotlinFlags.set(modality == Modality.FINAL\n                                            ? JvmStdlibNames.FLAG_FORCE_FINAL_BIT\n                                            : JvmStdlibNames.FLAG_FORCE_OPEN_BIT);\n                        }\n                        aw.writeFlags(kotlinFlags);\n                        aw.writeNullableReturnType(functionDescriptor.getReturnType().isNullable());\n                        aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());\n                        aw.writeReturnType(jvmSignature.getKotlinReturnType());\n                        aw.visitEnd();\n                    }\n                    else {\n                        throw new IllegalStateException();\n                    }\n\n                    if (receiverParameter.exists()) {\n                        JetValueParameterAnnotationWriter av = JetValueParameterAnnotationWriter.visitParameterAnnotation(mv, start++);\n                        av.writeName(\"this$receiver\");\n                        av.writeNullable(receiverParameter.getType().isNullable());\n                        av.writeReceiver();\n                        if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(0) != null) {\n                            av.writeType(jvmSignature.getKotlinParameterTypes().get(0).getKotlinSignature());\n                        }\n                        av.visitEnd();\n                    }\n                    for(int i = 0; i != paramDescrs.size(); ++i) {\n                        ValueParameterDescriptor parameterDescriptor = paramDescrs.get(i);\n                        AnnotationCodegen.forParameter(i, mv, state.getInjector().getJetTypeMapper()).genAnnotations(parameterDescriptor);\n                        JetValueParameterAnnotationWriter av = JetValueParameterAnnotationWriter.visitParameterAnnotation(mv, i + start);\n                        av.writeName(parameterDescriptor.getName().getName());\n                        av.writeHasDefaultValue(parameterDescriptor.declaresDefaultValue());\n                        av.writeNullable(parameterDescriptor.getType().isNullable());\n                        if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(i) != null) {\n                            av.writeType(jvmSignature.getKotlinParameterTypes().get(i + start).getKotlinSignature());\n                        }\n                        av.visitEnd();\n                    }\n                }\n            }\n\n            if (!isAbstract && state.getClassBuilderMode() == ClassBuilderMode.STUBS) {\n                StubCodegen.generateStubCode(mv);\n            }\n\n\n            if (!isAbstract && state.getClassBuilderMode() == ClassBuilderMode.FULL) {\n                mv.visitCode();\n                \n                Label methodBegin = new Label();\n                mv.visitLabel(methodBegin);\n                \n                FrameMap frameMap = context.prepareFrame(state.getInjector().getJetTypeMapper());\n\n                ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, jvmSignature.getAsmMethod().getReturnType(), context, state);\n\n                Type[] argTypes = jvmSignature.getAsmMethod().getArgumentTypes();\n                int add = 0;\n\n                if (kind == OwnerKind.TRAIT_IMPL)\n                    add++;\n\n                if (receiverParameter.exists())\n                    add++;\n\n                for (int i = 0; i < paramDescrs.size(); i++) {\n                    ValueParameterDescriptor parameter = paramDescrs.get(i);\n                    frameMap.enter(parameter, argTypes[i+add].getSize());\n                }\n\n                if (!isStatic && (kind instanceof OwnerKind.DelegateKind) != (functionDescriptor.getKind() == FunctionDescriptor.Kind.DELEGATION)) {\n                    throw new IllegalStateException(\"mismatching kind in \" + functionDescriptor);\n                }\n\n                Map<Name, Label> mapLabelsToDivideLocalVarVisibilityForSharedVar = new HashMap<Name, Label>();\n\n                if (kind instanceof OwnerKind.StaticDelegateKind) {\n                    OwnerKind.StaticDelegateKind dk = (OwnerKind.StaticDelegateKind) kind;\n                    InstructionAdapter iv = new InstructionAdapter(mv);\n                    for (int i = 0, k = 0; i < argTypes.length; i++) {\n                        Type argType = argTypes[i];\n                        iv.load(k, argType);\n                        k += argType.getSize();\n                    }\n                    iv.invokestatic(dk.getOwnerClass(), jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor());\n                    iv.areturn(jvmSignature.getAsmMethod().getReturnType());\n                }\n                else if (kind instanceof OwnerKind.DelegateKind) {\n                    OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;\n                    InstructionAdapter iv = new InstructionAdapter(mv);\n                    iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                    dk.getDelegate().put(JetTypeMapper.TYPE_OBJECT, iv);\n                    for (int i = 0; i < argTypes.length; i++) {\n                        Type argType = argTypes[i];\n                        iv.load(i + 1, argType);\n                    }\n                    iv.invokeinterface(dk.getOwnerClass(), jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor());\n                    iv.areturn(jvmSignature.getAsmMethod().getReturnType());\n                }\n                else {\n                    for (ValueParameterDescriptor parameter : paramDescrs) {\n                        Type sharedVarType = state.getInjector().getJetTypeMapper().getSharedVarType(parameter);\n                        if (sharedVarType != null) {\n                            Type localVarType = state.getInjector().getJetTypeMapper().mapType(parameter.getType(), MapTypeMode.VALUE);\n                            int index = frameMap.getIndex(parameter);\n                            mv.visitTypeInsn(NEW, sharedVarType.getInternalName());\n                            mv.visitInsn(DUP);\n                            mv.visitInsn(DUP);\n                            mv.visitMethodInsn(INVOKESPECIAL, sharedVarType.getInternalName(), \"<init>\", \"()V\");\n                            mv.visitVarInsn(localVarType.getOpcode(ILOAD), index);\n                            mv.visitFieldInsn(PUTFIELD, sharedVarType.getInternalName(), \"ref\", StackValue.refType(localVarType).getDescriptor());\n\n                            Label labelToDivideLocalVarForSharedVarVisibility = new Label();\n                            mv.visitLabel(labelToDivideLocalVarForSharedVarVisibility);\n                            mapLabelsToDivideLocalVarVisibilityForSharedVar.put(parameter.getName(), labelToDivideLocalVarForSharedVarVisibility);\n\n                            mv.visitVarInsn(sharedVarType.getOpcode(ISTORE), index);\n                        }\n                    }\n\n                    codegen.returnExpression(bodyExpressions);\n                }\n                \n                Label methodEnd = new Label();\n                mv.visitLabel(methodEnd);\n\n                Collection<String> localVariableNames = new HashSet<String>();\n                localVariableNames.addAll(codegen.getLocalVariableNamesForExpression());\n                for (ValueParameterDescriptor parameterDescriptor : paramDescrs) {\n                    localVariableNames.add(parameterDescriptor.getName().getName());\n                }\n\n                int k = 0;\n\n                if (expectedThisObject.exists()) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(expectedThisObject.getType(), MapTypeMode.VALUE);\n                    // TODO: specify signature\n                    mv.visitLocalVariable(\"this\", type.getDescriptor(), null, methodBegin, methodEnd, k++);\n                }\n                else if (fun instanceof JetFunctionLiteralExpression || CodegenUtil.isLocalFun(functionDescriptor, state.getBindingContext())) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(\n                            context.getThisDescriptor().getDefaultType(), MapTypeMode.VALUE);\n                    mv.visitLocalVariable(\"this\", type.getDescriptor(), null, methodBegin, methodEnd, k++);\n                }\n\n                if (receiverParameter.exists()) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(receiverParameter.getType(), MapTypeMode.VALUE);\n                    // TODO: specify signature\n                    mv.visitLocalVariable(\"this$receiver\", type.getDescriptor(), null, methodBegin, methodEnd, k);\n                    k += type.getSize();\n                }\n\n                for (ValueParameterDescriptor parameter : paramDescrs) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(parameter.getType(), MapTypeMode.VALUE);\n                    // TODO: specify signature\n\n                    Label divideLabel = mapLabelsToDivideLocalVarVisibilityForSharedVar.get(parameter.getName());\n                    String parameterName = parameter.getName().getName();\n                    if (divideLabel != null) {\n                        Type sharedVarType = state.getInjector().getJetTypeMapper().getSharedVarType(parameter);\n                        mv.visitLocalVariable(parameterName, type.getDescriptor(), null, methodBegin, divideLabel, k);\n\n                        String nameForSharedVar = CodegenUtil.generateTmpVariableName(localVariableNames);\n                        localVariableNames.add(nameForSharedVar);\n\n                        mv.visitLocalVariable(nameForSharedVar, sharedVarType.getDescriptor(), null, divideLabel, methodEnd, k);\n                        k += Math.max(type.getSize(), sharedVarType.getSize());\n                    }   else {\n                        mv.visitLocalVariable(parameter.getName().getName(), type.getDescriptor(), null, methodBegin, methodEnd, k);\n                        k += type.getSize();\n                    }\n                }\n\n                endVisit(mv, null, fun);\n                mv.visitEnd();\n\n                generateBridgeIfNeeded(owner, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);\n            }\n        }\n\n        generateDefaultIfNeeded(context, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);\n    }","commit_id":"16bcc7967e270aa6a33b11b833d550016e01ffee","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected void generatePrimaryConstructor() {\n        if (myClass instanceof JetClass) {\n            JetClass aClass = (JetClass)myClass;\n            if (aClass.isTrait())\n                return;\n            if (aClass.isAnnotation()) {\n                return;\n            }\n        }\n\n        if (kind != OwnerKind.IMPLEMENTATION) {\n            throw new IllegalStateException(\"incorrect kind for primary constructor: \" + kind);\n        }\n\n        ConstructorDescriptor constructorDescriptor = bindingContext.get(BindingContext.CONSTRUCTOR, myClass);\n\n        CodegenContexts.ConstructorContext constructorContext = context.intoConstructor(constructorDescriptor, typeMapper);\n\n        JvmMethodSignature constructorMethod;\n        CallableMethod callableMethod;\n        boolean hasThis0 = typeMapper.hasThis0(descriptor);\n        if (constructorDescriptor == null) {\n            BothSignatureWriter signatureWriter = new BothSignatureWriter(BothSignatureWriter.Mode.METHOD, false);\n            \n            signatureWriter.writeFormalTypeParametersStart();\n            signatureWriter.writeFormalTypeParametersEnd();\n            \n            signatureWriter.writeParametersStart();\n            \n            if (hasThis0) {\n                signatureWriter.writeParameterType(JvmMethodParameterKind.THIS0);\n                typeMapper.mapType(typeMapper.getClosureAnnotator().getEclosingClassDescriptor(descriptor).getDefaultType(), signatureWriter, MapTypeMode.VALUE);\n                signatureWriter.writeParameterTypeEnd();\n            }\n\n            signatureWriter.writeParametersEnd();\n            \n            signatureWriter.writeVoidReturn();\n\n            constructorMethod = signatureWriter.makeJvmMethodSignature(\"<init>\");\n            callableMethod = new CallableMethod(JvmClassName.byInternalName(\"Ignored\"), null, null, constructorMethod, INVOKESPECIAL, null, null, null);\n        }\n        else {\n            callableMethod = typeMapper.mapToCallableMethod(constructorDescriptor, kind, typeMapper.hasThis0(constructorDescriptor.getContainingDeclaration()));\n            constructorMethod = callableMethod.getSignature();\n        }\n\n        if (context.closure != null) {\n            for (JetDelegationSpecifier specifier : myClass.getDelegationSpecifiers()) {\n                if (specifier != superCall && specifier instanceof JetDelegatorByExpressionSpecifier) {\n                    JetExpression delegateExpression = ((JetDelegatorByExpressionSpecifier) specifier).getDelegateExpression();\n                    delegateExpression.accept(new JetVisitorVoid() {\n                        @Override\n                        public void visitJetElement(JetElement e) {\n                            e.acceptChildren(this);\n                        }\n\n                        @Override\n                        public void visitSimpleNameExpression(JetSimpleNameExpression expr) {\n                            context.closure.lookupInContext(bindingContext.get(BindingContext.REFERENCE_TARGET, expr), null);\n                        }\n                    });\n                }\n            }\n        }\n\n        ObjectOrClosureCodegen closure = context.closure;\n        int firstSuperArgument = -1;\n        final LinkedList<JvmMethodParameterSignature> consArgTypes = new LinkedList<JvmMethodParameterSignature>(constructorMethod.getKotlinParameterTypes());\n\n        int insert = 0;\n        if (closure != null) {\n            if (closure.captureThis != null) {\n                if (!hasThis0)\n                    consArgTypes.add(insert, new JvmMethodParameterSignature(Type.getObjectType(context.getThisDescriptor().getName().getName()), \"\", JvmMethodParameterKind.THIS0));\n                insert++;\n            }\n            else {\n                if (hasThis0)\n                    insert++;\n            }\n\n            if (closure.captureReceiver != null)\n                consArgTypes.add(insert++, new JvmMethodParameterSignature(closure.captureReceiver, \"\", JvmMethodParameterKind.RECEIVER));\n\n            for (DeclarationDescriptor descriptor : closure.closure.keySet()) {\n                if (descriptor instanceof VariableDescriptor && !(descriptor instanceof PropertyDescriptor)) {\n                    final Type sharedVarType = typeMapper.getSharedVarType(descriptor);\n                    final Type type;\n                    if (sharedVarType != null) {\n                        type = sharedVarType;\n                    }\n                    else {\n                        type = state.getInjector().getJetTypeMapper().mapType(((VariableDescriptor) descriptor).getType(), MapTypeMode.VALUE);\n                    }\n                    consArgTypes.add(insert++, new JvmMethodParameterSignature(type, \"\", JvmMethodParameterKind.SHARED_VAR));\n                }\n                else if (descriptor instanceof FunctionDescriptor) {\n                    assert closure.captureReceiver != null;\n                }\n            }\n        }\n\n        if (myClass instanceof JetObjectDeclaration && ((JetObjectDeclaration) myClass).isObjectLiteral()) {\n            if (superCall instanceof JetDelegatorToSuperCall) {\n                if (closure != null)\n                    closure.superCall = (JetDelegatorToSuperCall) superCall;\n                DeclarationDescriptor declarationDescriptor = bindingContext.get(BindingContext.REFERENCE_TARGET, ((JetDelegatorToSuperCall) superCall).getCalleeExpression().getConstructorReferenceExpression());\n                if (declarationDescriptor instanceof ClassDescriptor) {\n                    declarationDescriptor = ((ClassDescriptorFromSource) declarationDescriptor).getUnsubstitutedPrimaryConstructor();\n                }\n                ConstructorDescriptor superConstructor = (ConstructorDescriptor) declarationDescriptor;\n                CallableMethod superCallable = typeMapper.mapToCallableMethod(superConstructor, OwnerKind.IMPLEMENTATION, typeMapper.hasThis0(superConstructor.getContainingDeclaration()));\n                firstSuperArgument = insert;\n                for(Type t : superCallable.getSignature().getAsmMethod().getArgumentTypes()) {\n                    consArgTypes.add(insert++, new JvmMethodParameterSignature(t, \"\", JvmMethodParameterKind.SHARED_VAR));\n                }\n            }\n\n            constructorMethod = JvmMethodSignature.simple(\"<init>\", Type.VOID_TYPE, consArgTypes);\n        }\n\n        int flags = JetTypeMapper.getAccessModifiers(constructorDescriptor, 0);\n        final MethodVisitor mv = v.newMethod(myClass, flags, constructorMethod.getName(), constructorMethod.getAsmMethod().getDescriptor(), constructorMethod.getGenericsSignature(), null);\n        if (state.getClassBuilderMode() == ClassBuilderMode.SIGNATURES) return;\n\n        AnnotationVisitor jetConstructorVisitor = mv.visitAnnotation(JvmStdlibNames.JET_CONSTRUCTOR.getDescriptor(), true);\n\n        int flagsValue = BitSetUtils.toInt(CodegenUtil.getFlagsForVisibility(constructorDescriptor.getVisibility()));\n        if (JvmStdlibNames.FLAGS_DEFAULT_VALUE != flagsValue) {\n            jetConstructorVisitor.visit(JvmStdlibNames.JET_CLASS_FLAGS_FIELD, flagsValue);\n        }\n\n        jetConstructorVisitor.visitEnd();\n        \n        AnnotationCodegen.forMethod(mv, typeMapper).genAnnotations(constructorDescriptor);\n\n        if (constructorDescriptor != null) {\n            int i = 0;\n\n            if (hasThis0) {\n                i++;\n            }\n\n            for (ValueParameterDescriptor valueParameter : constructorDescriptor.getValueParameters()) {\n                JetValueParameterAnnotationWriter jetValueParameterAnnotation = JetValueParameterAnnotationWriter.visitParameterAnnotation(mv, i);\n                jetValueParameterAnnotation.writeName(valueParameter.getName().getName());\n                jetValueParameterAnnotation.writeHasDefaultValue(valueParameter.declaresDefaultValue());\n                jetValueParameterAnnotation.writeType(constructorMethod.getKotlinParameterType(i));\n                jetValueParameterAnnotation.visitEnd();\n                ++i;\n            }\n        }\n\n        if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {\n            StubCodegen.generateStubCode(mv);\n            return;\n        }\n\n        mv.visitCode();\n\n        List<ValueParameterDescriptor> paramDescrs = constructorDescriptor != null\n                ? constructorDescriptor.getValueParameters()\n                : Collections.<ValueParameterDescriptor>emptyList();\n\n        ConstructorFrameMap frameMap = new ConstructorFrameMap(callableMethod, constructorDescriptor, hasThis0);\n\n        final InstructionAdapter iv = new InstructionAdapter(mv);\n        ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, Type.VOID_TYPE, constructorContext, state);\n\n//        for(int slot = 0; slot != frameMap.getTypeParameterCount(); ++slot) {\n//            if (constructorDescriptor != null)\n//                codegen.addTypeParameter(constructorDescriptor.getTypeParameters().get(slot), StackValue.local(frameMap.getFirstTypeParameter() + slot, JetTypeMapper.TYPE_TYPEINFO));\n//            else\n//                codegen.addTypeParameter(descriptor.getTypeConstructor().getParameters().get(slot), StackValue.local(frameMap.getFirstTypeParameter() + slot, JetTypeMapper.TYPE_TYPEINFO));\n//        }\n\n        Type classType = typeMapper.mapType(descriptor.getDefaultType(), MapTypeMode.IMPL);\n        JvmClassName classname = JvmClassName.byType(classType);\n\n        HashSet<FunctionDescriptor> overridden = new HashSet<FunctionDescriptor>();\n        for (JetDeclaration declaration : myClass.getDeclarations()) {\n            if (declaration instanceof JetNamedFunction) {\n                SimpleFunctionDescriptor functionDescriptor = bindingContext.get(BindingContext.FUNCTION, declaration);\n                assert functionDescriptor != null;\n                overridden.addAll(functionDescriptor.getOverriddenDescriptors());\n            }\n        }\n\n        if (superCall == null) {\n            iv.load(0, Type.getType(\"L\" + superClass + \";\"));\n            iv.invokespecial(superClass, \"<init>\", \"()V\");\n        }\n        else if (superCall instanceof JetDelegatorToSuperClass) {\n            iv.load(0, Type.getType(\"L\" + superClass + \";\"));\n            JetType superType = bindingContext.get(BindingContext.TYPE, superCall.getTypeReference());\n            List<Type> parameterTypes = new ArrayList<Type>();\n            assert superType != null;\n            ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();\n            if (typeMapper.hasThis0(superClassDescriptor)) {\n                iv.load(1, JetTypeMapper.TYPE_OBJECT);\n                parameterTypes.add(typeMapper.mapType(typeMapper.getClosureAnnotator().getEclosingClassDescriptor(descriptor).getDefaultType(), MapTypeMode.VALUE));\n            }\n            Method superCallMethod = new Method(\"<init>\", Type.VOID_TYPE, parameterTypes.toArray(new Type[parameterTypes.size()]));\n            iv.invokespecial(typeMapper.mapType(superClassDescriptor.getDefaultType(), MapTypeMode.VALUE).getInternalName(), \"<init>\", superCallMethod.getDescriptor());\n        }\n        else {\n            ConstructorDescriptor constructorDescriptor1 = (ConstructorDescriptor) bindingContext.get(BindingContext.REFERENCE_TARGET, ((JetDelegatorToSuperCall) superCall).getCalleeExpression().getConstructorReferenceExpression());\n            generateDelegatorToConstructorCall(iv, codegen, (JetDelegatorToSuperCall) superCall, constructorDescriptor1, frameMap, firstSuperArgument);\n        }\n\n        final ClassDescriptor outerDescriptor = typeMapper.getClosureAnnotator().getEclosingClassDescriptor(descriptor);\n        final boolean hasOuterThis = typeMapper.hasThis0(descriptor) && outerDescriptor != null;\n        if (hasOuterThis) {\n            final Type type = typeMapper.mapType(outerDescriptor.getDefaultType(), MapTypeMode.VALUE);\n            String interfaceDesc = type.getDescriptor();\n            final String fieldName = \"this$0\";\n            v.newField(myClass, ACC_FINAL, fieldName, interfaceDesc, null, null);\n            iv.load(0, classType);\n            iv.load(frameMap.getOuterThisIndex(), type);\n            iv.putfield(classname.getInternalName(), fieldName, interfaceDesc);\n        }\n\n        if (closure != null) {\n            int k = hasOuterThis ? 2 : 1;\n            if (closure.captureReceiver != null) {\n                iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                iv.load(1, closure.captureReceiver);\n                iv.putfield(typeMapper.mapType(descriptor.getDefaultType(), MapTypeMode.VALUE).getInternalName(), \"receiver$0\", closure.captureReceiver.getDescriptor());\n                k += closure.captureReceiver.getSize();\n            }\n\n            int l = 0;\n            for (DeclarationDescriptor varDescr : closure.closure.keySet()) {\n                if (varDescr instanceof VariableDescriptor && !(varDescr instanceof PropertyDescriptor)) {\n                    Type sharedVarType = typeMapper.getSharedVarType(varDescr);\n                    if (sharedVarType == null) {\n                        sharedVarType = typeMapper.mapType(((VariableDescriptor) varDescr).getType(), MapTypeMode.VALUE);\n                    }\n                    iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                    iv.load(k, StackValue.refType(sharedVarType));\n                    k += StackValue.refType(sharedVarType).getSize();\n                    iv.putfield(typeMapper.mapType(descriptor.getDefaultType(), MapTypeMode.VALUE).getInternalName(), \"$\" + varDescr.getName(), sharedVarType.getDescriptor());\n                    l++;\n                }\n            }\n        }\n\n        int n = 0;\n        for (JetDelegationSpecifier specifier : myClass.getDelegationSpecifiers()) {\n            if (specifier == superCall)\n                continue;\n\n            if (specifier instanceof JetDelegatorByExpressionSpecifier) {\n                iv.load(0, classType);\n                codegen.genToJVMStack(((JetDelegatorByExpressionSpecifier) specifier).getDelegateExpression());\n\n                JetType superType = bindingContext.get(BindingContext.TYPE, specifier.getTypeReference());\n                assert superType != null;\n                ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();\n                String delegateField = \"$delegate_\" + (n++);\n                Type fieldType = typeMapper.mapType(superClassDescriptor.getDefaultType(), MapTypeMode.VALUE);\n                String fieldDesc = fieldType.getDescriptor();\n                v.newField(specifier, ACC_PRIVATE, delegateField, fieldDesc, /*TODO*/null, null);\n                StackValue field = StackValue.field(fieldType, classname, delegateField, false);\n                field.store(fieldType, iv);\n\n                JetClass superClass = (JetClass) BindingContextUtils.classDescriptorToDeclaration(bindingContext, superClassDescriptor);\n                final CodegenContext delegateContext = context.intoClass(superClassDescriptor,\n                                                                         new OwnerKind.DelegateKind(StackValue.field(fieldType, classname, delegateField, false),\n                                                                                                    typeMapper.mapType(superClassDescriptor.getDefaultType(), MapTypeMode.IMPL).getInternalName()), state.getInjector().getJetTypeMapper());\n                generateDelegates(superClass, delegateContext, field);\n            }\n        }\n\n        int curParam = 0;\n        List<JetParameter> constructorParameters = getPrimaryConstructorParameters();\n        for (JetParameter parameter : constructorParameters) {\n            if (parameter.getValOrVarNode() != null) {\n                VariableDescriptor descriptor = paramDescrs.get(curParam);\n                Type type = typeMapper.mapType(descriptor.getType(), MapTypeMode.VALUE);\n                iv.load(0, classType);\n                iv.load(frameMap.getIndex(descriptor), type);\n                iv.putfield(classname.getInternalName(), descriptor.getName().getName(), type.getDescriptor());\n            }\n            curParam++;\n        }\n\n        generateInitializers(codegen, iv, myClass.getDeclarations(), bindingContext, typeMapper);\n\n        mv.visitInsn(RETURN);\n        FunctionCodegen.endVisit(mv, \"constructor\", myClass);\n\n        FunctionCodegen.generateDefaultIfNeeded(constructorContext, state, v, constructorMethod.getAsmMethod(), constructorDescriptor, OwnerKind.IMPLEMENTATION);\n    }","id":97404,"modified_method":"protected void generatePrimaryConstructor() {\n        if (myClass instanceof JetClass) {\n            JetClass aClass = (JetClass)myClass;\n            if (aClass.isTrait())\n                return;\n            if (aClass.isAnnotation()) {\n                return;\n            }\n        }\n\n        if (kind != OwnerKind.IMPLEMENTATION) {\n            throw new IllegalStateException(\"incorrect kind for primary constructor: \" + kind);\n        }\n\n        ConstructorDescriptor constructorDescriptor = bindingContext.get(BindingContext.CONSTRUCTOR, myClass);\n\n        CodegenContexts.ConstructorContext constructorContext = context.intoConstructor(constructorDescriptor, typeMapper);\n\n        JvmMethodSignature constructorMethod;\n        CallableMethod callableMethod;\n        boolean hasThis0 = typeMapper.hasThis0(descriptor);\n        if (constructorDescriptor == null) {\n            BothSignatureWriter signatureWriter = new BothSignatureWriter(BothSignatureWriter.Mode.METHOD, false);\n            \n            signatureWriter.writeFormalTypeParametersStart();\n            signatureWriter.writeFormalTypeParametersEnd();\n            \n            signatureWriter.writeParametersStart();\n            \n            if (hasThis0) {\n                signatureWriter.writeParameterType(JvmMethodParameterKind.THIS0);\n                typeMapper.mapType(typeMapper.getClosureAnnotator().getEclosingClassDescriptor(descriptor).getDefaultType(), signatureWriter, MapTypeMode.VALUE);\n                signatureWriter.writeParameterTypeEnd();\n            }\n\n            signatureWriter.writeParametersEnd();\n            \n            signatureWriter.writeVoidReturn();\n\n            constructorMethod = signatureWriter.makeJvmMethodSignature(\"<init>\");\n            callableMethod = new CallableMethod(JvmClassName.byInternalName(\"Ignored\"), null, null, constructorMethod, INVOKESPECIAL, null, null, null);\n        }\n        else {\n            callableMethod = typeMapper.mapToCallableMethod(constructorDescriptor, kind, typeMapper.hasThis0(constructorDescriptor.getContainingDeclaration()));\n            constructorMethod = callableMethod.getSignature();\n        }\n\n        if (context.closure != null) {\n            for (JetDelegationSpecifier specifier : myClass.getDelegationSpecifiers()) {\n                if (specifier != superCall && specifier instanceof JetDelegatorByExpressionSpecifier) {\n                    JetExpression delegateExpression = ((JetDelegatorByExpressionSpecifier) specifier).getDelegateExpression();\n                    delegateExpression.accept(new JetVisitorVoid() {\n                        @Override\n                        public void visitJetElement(JetElement e) {\n                            e.acceptChildren(this);\n                        }\n\n                        @Override\n                        public void visitSimpleNameExpression(JetSimpleNameExpression expr) {\n                            context.closure.lookupInContext(bindingContext.get(BindingContext.REFERENCE_TARGET, expr), null);\n                        }\n                    });\n                }\n            }\n        }\n\n        ObjectOrClosureCodegen closure = context.closure;\n        int firstSuperArgument = -1;\n        final LinkedList<JvmMethodParameterSignature> consArgTypes = new LinkedList<JvmMethodParameterSignature>(constructorMethod.getKotlinParameterTypes());\n\n        int insert = 0;\n        if (closure != null) {\n            if (closure.captureThis != null) {\n                if (!hasThis0)\n                    consArgTypes.add(insert, new JvmMethodParameterSignature(Type.getObjectType(context.getThisDescriptor().getName().getName()), \"\", JvmMethodParameterKind.THIS0));\n                insert++;\n            }\n            else {\n                if (hasThis0)\n                    insert++;\n            }\n\n            if (closure.captureReceiver != null)\n                consArgTypes.add(insert++, new JvmMethodParameterSignature(closure.captureReceiver, \"\", JvmMethodParameterKind.RECEIVER));\n\n            for (DeclarationDescriptor descriptor : closure.closure.keySet()) {\n                if (descriptor instanceof VariableDescriptor && !(descriptor instanceof PropertyDescriptor)) {\n                    final Type sharedVarType = typeMapper.getSharedVarType(descriptor);\n                    final Type type;\n                    if (sharedVarType != null) {\n                        type = sharedVarType;\n                    }\n                    else {\n                        type = state.getInjector().getJetTypeMapper().mapType(((VariableDescriptor) descriptor).getType(), MapTypeMode.VALUE);\n                    }\n                    consArgTypes.add(insert++, new JvmMethodParameterSignature(type, \"\", JvmMethodParameterKind.SHARED_VAR));\n                }\n                else if (descriptor instanceof FunctionDescriptor) {\n                    assert closure.captureReceiver != null;\n                }\n            }\n        }\n\n        if (myClass instanceof JetObjectDeclaration && ((JetObjectDeclaration) myClass).isObjectLiteral()) {\n            if (superCall instanceof JetDelegatorToSuperCall) {\n                if (closure != null)\n                    closure.superCall = (JetDelegatorToSuperCall) superCall;\n                DeclarationDescriptor declarationDescriptor = bindingContext.get(BindingContext.REFERENCE_TARGET, ((JetDelegatorToSuperCall) superCall).getCalleeExpression().getConstructorReferenceExpression());\n                if (declarationDescriptor instanceof ClassDescriptor) {\n                    declarationDescriptor = ((ClassDescriptorFromSource) declarationDescriptor).getUnsubstitutedPrimaryConstructor();\n                }\n                ConstructorDescriptor superConstructor = (ConstructorDescriptor) declarationDescriptor;\n                CallableMethod superCallable = typeMapper.mapToCallableMethod(superConstructor, OwnerKind.IMPLEMENTATION, typeMapper.hasThis0(superConstructor.getContainingDeclaration()));\n                firstSuperArgument = insert;\n                for(Type t : superCallable.getSignature().getAsmMethod().getArgumentTypes()) {\n                    consArgTypes.add(insert++, new JvmMethodParameterSignature(t, \"\", JvmMethodParameterKind.SHARED_VAR));\n                }\n            }\n\n            constructorMethod = JvmMethodSignature.simple(\"<init>\", Type.VOID_TYPE, consArgTypes);\n        }\n\n        int flags = JetTypeMapper.getAccessModifiers(constructorDescriptor, 0);\n        final MethodVisitor mv = v.newMethod(myClass, flags, constructorMethod.getName(), constructorMethod.getAsmMethod().getDescriptor(), constructorMethod.getGenericsSignature(), null);\n        if (state.getClassBuilderMode() == ClassBuilderMode.SIGNATURES) return;\n\n        AnnotationVisitor jetConstructorVisitor = mv.visitAnnotation(JvmStdlibNames.JET_CONSTRUCTOR.getDescriptor(), true);\n\n        int flagsValue = BitSetUtils.toInt(CodegenUtil.getFlagsForVisibility(constructorDescriptor.getVisibility()));\n        if (JvmStdlibNames.FLAGS_DEFAULT_VALUE != flagsValue) {\n            jetConstructorVisitor.visit(JvmStdlibNames.JET_CLASS_FLAGS_FIELD, flagsValue);\n        }\n\n        jetConstructorVisitor.visitEnd();\n        \n        AnnotationCodegen.forMethod(mv, typeMapper).genAnnotations(constructorDescriptor);\n\n        if (constructorDescriptor != null) {\n            int i = 0;\n\n            if (hasThis0) {\n                i++;\n            }\n\n            for (ValueParameterDescriptor valueParameter : constructorDescriptor.getValueParameters()) {\n                AnnotationCodegen.forParameter(i, mv, state.getInjector().getJetTypeMapper()).genAnnotations(valueParameter);\n                JetValueParameterAnnotationWriter jetValueParameterAnnotation = JetValueParameterAnnotationWriter.visitParameterAnnotation(mv, i);\n                jetValueParameterAnnotation.writeName(valueParameter.getName().getName());\n                jetValueParameterAnnotation.writeHasDefaultValue(valueParameter.declaresDefaultValue());\n                jetValueParameterAnnotation.writeType(constructorMethod.getKotlinParameterType(i));\n                jetValueParameterAnnotation.visitEnd();\n                ++i;\n            }\n        }\n\n        if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {\n            StubCodegen.generateStubCode(mv);\n            return;\n        }\n\n        mv.visitCode();\n\n        List<ValueParameterDescriptor> paramDescrs = constructorDescriptor != null\n                ? constructorDescriptor.getValueParameters()\n                : Collections.<ValueParameterDescriptor>emptyList();\n\n        ConstructorFrameMap frameMap = new ConstructorFrameMap(callableMethod, constructorDescriptor, hasThis0);\n\n        final InstructionAdapter iv = new InstructionAdapter(mv);\n        ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, Type.VOID_TYPE, constructorContext, state);\n\n//        for(int slot = 0; slot != frameMap.getTypeParameterCount(); ++slot) {\n//            if (constructorDescriptor != null)\n//                codegen.addTypeParameter(constructorDescriptor.getTypeParameters().get(slot), StackValue.local(frameMap.getFirstTypeParameter() + slot, JetTypeMapper.TYPE_TYPEINFO));\n//            else\n//                codegen.addTypeParameter(descriptor.getTypeConstructor().getParameters().get(slot), StackValue.local(frameMap.getFirstTypeParameter() + slot, JetTypeMapper.TYPE_TYPEINFO));\n//        }\n\n        Type classType = typeMapper.mapType(descriptor.getDefaultType(), MapTypeMode.IMPL);\n        JvmClassName classname = JvmClassName.byType(classType);\n\n        HashSet<FunctionDescriptor> overridden = new HashSet<FunctionDescriptor>();\n        for (JetDeclaration declaration : myClass.getDeclarations()) {\n            if (declaration instanceof JetNamedFunction) {\n                SimpleFunctionDescriptor functionDescriptor = bindingContext.get(BindingContext.FUNCTION, declaration);\n                assert functionDescriptor != null;\n                overridden.addAll(functionDescriptor.getOverriddenDescriptors());\n            }\n        }\n\n        if (superCall == null) {\n            iv.load(0, Type.getType(\"L\" + superClass + \";\"));\n            iv.invokespecial(superClass, \"<init>\", \"()V\");\n        }\n        else if (superCall instanceof JetDelegatorToSuperClass) {\n            iv.load(0, Type.getType(\"L\" + superClass + \";\"));\n            JetType superType = bindingContext.get(BindingContext.TYPE, superCall.getTypeReference());\n            List<Type> parameterTypes = new ArrayList<Type>();\n            assert superType != null;\n            ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();\n            if (typeMapper.hasThis0(superClassDescriptor)) {\n                iv.load(1, JetTypeMapper.TYPE_OBJECT);\n                parameterTypes.add(typeMapper.mapType(typeMapper.getClosureAnnotator().getEclosingClassDescriptor(descriptor).getDefaultType(), MapTypeMode.VALUE));\n            }\n            Method superCallMethod = new Method(\"<init>\", Type.VOID_TYPE, parameterTypes.toArray(new Type[parameterTypes.size()]));\n            iv.invokespecial(typeMapper.mapType(superClassDescriptor.getDefaultType(), MapTypeMode.VALUE).getInternalName(), \"<init>\", superCallMethod.getDescriptor());\n        }\n        else {\n            ConstructorDescriptor constructorDescriptor1 = (ConstructorDescriptor) bindingContext.get(BindingContext.REFERENCE_TARGET, ((JetDelegatorToSuperCall) superCall).getCalleeExpression().getConstructorReferenceExpression());\n            generateDelegatorToConstructorCall(iv, codegen, (JetDelegatorToSuperCall) superCall, constructorDescriptor1, frameMap, firstSuperArgument);\n        }\n\n        final ClassDescriptor outerDescriptor = typeMapper.getClosureAnnotator().getEclosingClassDescriptor(descriptor);\n        final boolean hasOuterThis = typeMapper.hasThis0(descriptor) && outerDescriptor != null;\n        if (hasOuterThis) {\n            final Type type = typeMapper.mapType(outerDescriptor.getDefaultType(), MapTypeMode.VALUE);\n            String interfaceDesc = type.getDescriptor();\n            final String fieldName = \"this$0\";\n            v.newField(myClass, ACC_FINAL, fieldName, interfaceDesc, null, null);\n            iv.load(0, classType);\n            iv.load(frameMap.getOuterThisIndex(), type);\n            iv.putfield(classname.getInternalName(), fieldName, interfaceDesc);\n        }\n\n        if (closure != null) {\n            int k = hasOuterThis ? 2 : 1;\n            if (closure.captureReceiver != null) {\n                iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                iv.load(1, closure.captureReceiver);\n                iv.putfield(typeMapper.mapType(descriptor.getDefaultType(), MapTypeMode.VALUE).getInternalName(), \"receiver$0\", closure.captureReceiver.getDescriptor());\n                k += closure.captureReceiver.getSize();\n            }\n\n            int l = 0;\n            for (DeclarationDescriptor varDescr : closure.closure.keySet()) {\n                if (varDescr instanceof VariableDescriptor && !(varDescr instanceof PropertyDescriptor)) {\n                    Type sharedVarType = typeMapper.getSharedVarType(varDescr);\n                    if (sharedVarType == null) {\n                        sharedVarType = typeMapper.mapType(((VariableDescriptor) varDescr).getType(), MapTypeMode.VALUE);\n                    }\n                    iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                    iv.load(k, StackValue.refType(sharedVarType));\n                    k += StackValue.refType(sharedVarType).getSize();\n                    iv.putfield(typeMapper.mapType(descriptor.getDefaultType(), MapTypeMode.VALUE).getInternalName(), \"$\" + varDescr.getName(), sharedVarType.getDescriptor());\n                    l++;\n                }\n            }\n        }\n\n        int n = 0;\n        for (JetDelegationSpecifier specifier : myClass.getDelegationSpecifiers()) {\n            if (specifier == superCall)\n                continue;\n\n            if (specifier instanceof JetDelegatorByExpressionSpecifier) {\n                iv.load(0, classType);\n                codegen.genToJVMStack(((JetDelegatorByExpressionSpecifier) specifier).getDelegateExpression());\n\n                JetType superType = bindingContext.get(BindingContext.TYPE, specifier.getTypeReference());\n                assert superType != null;\n                ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();\n                String delegateField = \"$delegate_\" + (n++);\n                Type fieldType = typeMapper.mapType(superClassDescriptor.getDefaultType(), MapTypeMode.VALUE);\n                String fieldDesc = fieldType.getDescriptor();\n                v.newField(specifier, ACC_PRIVATE, delegateField, fieldDesc, /*TODO*/null, null);\n                StackValue field = StackValue.field(fieldType, classname, delegateField, false);\n                field.store(fieldType, iv);\n\n                JetClass superClass = (JetClass) BindingContextUtils.classDescriptorToDeclaration(bindingContext, superClassDescriptor);\n                final CodegenContext delegateContext = context.intoClass(superClassDescriptor,\n                                                                         new OwnerKind.DelegateKind(StackValue.field(fieldType, classname, delegateField, false),\n                                                                                                    typeMapper.mapType(superClassDescriptor.getDefaultType(), MapTypeMode.IMPL).getInternalName()), state.getInjector().getJetTypeMapper());\n                generateDelegates(superClass, delegateContext, field);\n            }\n        }\n\n        int curParam = 0;\n        List<JetParameter> constructorParameters = getPrimaryConstructorParameters();\n        for (JetParameter parameter : constructorParameters) {\n            if (parameter.getValOrVarNode() != null) {\n                VariableDescriptor descriptor = paramDescrs.get(curParam);\n                Type type = typeMapper.mapType(descriptor.getType(), MapTypeMode.VALUE);\n                iv.load(0, classType);\n                iv.load(frameMap.getIndex(descriptor), type);\n                iv.putfield(classname.getInternalName(), descriptor.getName().getName(), type.getDescriptor());\n            }\n            curParam++;\n        }\n\n        generateInitializers(codegen, iv, myClass.getDeclarations(), bindingContext, typeMapper);\n\n        mv.visitInsn(RETURN);\n        FunctionCodegen.endVisit(mv, \"constructor\", myClass);\n\n        FunctionCodegen.generateDefaultIfNeeded(constructorContext, state, v, constructorMethod.getAsmMethod(), constructorDescriptor, OwnerKind.IMPLEMENTATION);\n    }","commit_id":"16bcc7967e270aa6a33b11b833d550016e01ffee","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void generateClassObjectBackingFieldCopies() {\n        if (classObjectPropertiesToCopy != null) {\n            for (PropertyAndDefaultValue propertyInfo : classObjectPropertiesToCopy) {\n                PropertyDescriptor propertyDescriptor = propertyInfo.propertyDescriptor;\n\n                v.newField(null, ACC_STATIC | ACC_FINAL | ACC_PUBLIC, context.getFieldName(propertyDescriptor),\n                           typeMapper.mapType(propertyDescriptor).getDescriptor(), null, propertyInfo.defaultValue);\n\n                //This field are always static and final so if it has constant initializer don't do anything in clinit,\n                //field would be initialized via default value in v.newField(...) - see JVM SPEC Ch.4\n                // TODO: test this code\n                if (state.getClassBuilderMode() == ClassBuilderMode.FULL && propertyInfo.defaultValue == null) {\n                    ExpressionCodegen codegen = createOrGetClInitCodegen();\n                    int classObjectIndex = putClassObjectInLocalVar(codegen);\n                    StackValue.local(classObjectIndex, OBJECT_TYPE).put(OBJECT_TYPE, codegen.v);\n                    copyFieldFromClassObject(propertyDescriptor);\n                }\n            }\n        }\n    }","id":97405,"modified_method":"private void generateClassObjectBackingFieldCopies() {\n        if (classObjectPropertiesToCopy != null) {\n            for (PropertyAndDefaultValue propertyInfo : classObjectPropertiesToCopy) {\n                PropertyDescriptor propertyDescriptor = propertyInfo.propertyDescriptor;\n\n                FieldVisitor fv = v.newField(null, ACC_STATIC | ACC_FINAL | ACC_PUBLIC, context.getFieldName(propertyDescriptor),\n                                                  typeMapper.mapType(propertyDescriptor).getDescriptor(), null, propertyInfo.defaultValue);\n\n                AnnotationCodegen.forField(fv, typeMapper).genAnnotations(propertyDescriptor);\n\n                //This field are always static and final so if it has constant initializer don't do anything in clinit,\n                //field would be initialized via default value in v.newField(...) - see JVM SPEC Ch.4\n                // TODO: test this code\n                if (state.getClassBuilderMode() == ClassBuilderMode.FULL && propertyInfo.defaultValue == null) {\n                    ExpressionCodegen codegen = createOrGetClInitCodegen();\n                    int classObjectIndex = putClassObjectInLocalVar(codegen);\n                    StackValue.local(classObjectIndex, OBJECT_TYPE).put(OBJECT_TYPE, codegen.v);\n                    copyFieldFromClassObject(propertyDescriptor);\n                }\n            }\n        }\n    }","commit_id":"2b6f688a520eb10f3d198e35053d340323ded22f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void generatedMethod(JetExpression bodyExpressions,\n            JvmMethodSignature jvmSignature,\n            boolean needJetAnnotations, @Nullable String propertyTypeSignature,\n            CodegenContext.MethodContext context,\n            FunctionDescriptor functionDescriptor,\n            JetDeclarationWithBody fun\n    )\n    {\n        List<ValueParameterDescriptor> paramDescrs = functionDescriptor.getValueParameters();\n        List<TypeParameterDescriptor> typeParameters = (functionDescriptor instanceof PropertyAccessorDescriptor ? ((PropertyAccessorDescriptor)functionDescriptor).getCorrespondingProperty(): functionDescriptor).getTypeParameters();\n\n        int flags = ACC_PUBLIC; // TODO.\n        \n        if (!functionDescriptor.getValueParameters().isEmpty()\n                && functionDescriptor.getValueParameters().get(functionDescriptor.getValueParameters().size() - 1)\n                        .getVarargElementType() != null)\n        {\n            flags |= ACC_VARARGS;\n        }\n        \n        if (functionDescriptor.getModality() == Modality.FINAL) {\n            flags |= ACC_FINAL;\n        }\n\n        OwnerKind kind = context.getContextKind();\n        \n        if (kind == OwnerKind.TRAIT_IMPL) {\n            needJetAnnotations = false;\n        }\n\n        ReceiverDescriptor expectedThisObject = functionDescriptor.getExpectedThisObject();\n        ReceiverDescriptor receiverParameter = functionDescriptor.getReceiverParameter();\n\n        if (kind != OwnerKind.TRAIT_IMPL || bodyExpressions != null) {\n            boolean isStatic = kind == OwnerKind.NAMESPACE;\n            if (isStatic || kind == OwnerKind.TRAIT_IMPL)\n                flags |= ACC_STATIC;\n\n            boolean isAbstract = !isStatic && !(kind == OwnerKind.TRAIT_IMPL) && (bodyExpressions == null || CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration()));\n            if (isAbstract) flags |= ACC_ABSTRACT;\n            \n            final MethodVisitor mv = v.newMethod(fun, flags, jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor(), jvmSignature.getGenericsSignature(), null);\n            if(v.generateCode()) {\n                int start = 0;\n                if (needJetAnnotations) {\n                    if (functionDescriptor instanceof PropertyAccessorDescriptor) {\n                        PropertyCodegen.generateJetPropertyAnnotation(mv, propertyTypeSignature, jvmSignature.getKotlinTypeParameter());\n                    } else if (functionDescriptor instanceof NamedFunctionDescriptor) {\n                        if (propertyTypeSignature != null) {\n                            throw new IllegalStateException();\n                        }\n                        JetMethodAnnotationWriter aw = JetMethodAnnotationWriter.visitAnnotation(mv);\n                        aw.writeKind(JvmStdlibNames.JET_METHOD_KIND_REGULAR);\n                        aw.writeNullableReturnType(functionDescriptor.getReturnType().isNullable());\n                        aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());\n                        aw.writeReturnType(jvmSignature.getKotlinReturnType());\n                        aw.visitEnd();\n                    } else {\n                        throw new IllegalStateException();\n                    }\n\n                    if(receiverParameter.exists()) {\n                        AnnotationVisitor av = mv.visitParameterAnnotation(start++, JvmStdlibNames.JET_VALUE_PARAMETER.getDescriptor(), true);\n                        av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_NAME_FIELD, \"this$receiver\");\n                        if(receiverParameter.getType().isNullable()) {\n                            av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_NULLABLE_FIELD, true);\n                        }\n                        av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_RECEIVER_FIELD, true);\n                        if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(0) != null) {\n                            av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_TYPE_FIELD, jvmSignature.getKotlinParameterTypes().get(0).getKotlinSignature());\n                        }\n                        av.visitEnd();\n                    }\n                    for (final TypeParameterDescriptor typeParameterDescriptor : typeParameters) {\n                        if (!typeParameterDescriptor.isReified()) {\n                            continue;\n                        }\n                        AnnotationVisitor av = mv.visitParameterAnnotation(start++, JvmStdlibNames.JET_TYPE_PARAMETER.getDescriptor(), true);\n                        av.visit(JvmStdlibNames.JET_TYPE_PARAMETER_NAME_FIELD, typeParameterDescriptor.getName());\n                        av.visitEnd();\n                    }\n                    for(int i = 0; i != paramDescrs.size(); ++i) {\n                        AnnotationVisitor av = mv.visitParameterAnnotation(i + start, JvmStdlibNames.JET_VALUE_PARAMETER.getDescriptor(), true);\n                        ValueParameterDescriptor parameterDescriptor = paramDescrs.get(i);\n                        av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_NAME_FIELD, parameterDescriptor.getName());\n                        if(parameterDescriptor.hasDefaultValue()) {\n                            av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_HAS_DEFAULT_VALUE_FIELD, true);\n                        }\n                        if(parameterDescriptor.getOutType().isNullable()) {\n                            av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_NULLABLE_FIELD, true);\n                        }\n                        if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(i) != null) {\n                            av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_TYPE_FIELD, jvmSignature.getKotlinParameterTypes().get(i + start).getKotlinSignature());\n                        }\n                        av.visitEnd();\n                    }\n                }\n            }\n            if (!isAbstract && v.generateCode()) {\n                mv.visitCode();\n                \n                Label methodBegin = new Label();\n                mv.visitLabel(methodBegin);\n                \n                FrameMap frameMap = context.prepareFrame(typeMapper);\n\n                ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, jvmSignature.getAsmMethod().getReturnType(), context, state);\n\n                Type[] argTypes = jvmSignature.getAsmMethod().getArgumentTypes();\n                int add = 0;\n\n                if(kind == OwnerKind.TRAIT_IMPL)\n                    add++;\n\n                if(receiverParameter.exists())\n                    add++;\n\n                for (final TypeParameterDescriptor typeParameterDescriptor : typeParameters) {\n                    if (!typeParameterDescriptor.isReified()) {\n                        continue;\n                    }\n                    int slot = frameMap.enterTemp();\n                    add++;\n                    codegen.addTypeParameter(typeParameterDescriptor, StackValue.local(slot, JetTypeMapper.TYPE_TYPEINFO));\n                }\n\n                for (int i = 0; i < paramDescrs.size(); i++) {\n                    ValueParameterDescriptor parameter = paramDescrs.get(i);\n                    frameMap.enter(parameter, argTypes[i+add].getSize());\n                }\n\n                if (kind instanceof OwnerKind.DelegateKind) {\n                    OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;\n                    InstructionAdapter iv = new InstructionAdapter(mv);\n                    iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                    dk.getDelegate().put(JetTypeMapper.TYPE_OBJECT, iv);\n                    for (int i = 0; i < argTypes.length; i++) {\n                        Type argType = argTypes[i];\n                        iv.load(i + 1, argType);\n                    }\n                    iv.invokeinterface(dk.getOwnerClass(), jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor());\n                    iv.areturn(jvmSignature.getAsmMethod().getReturnType());\n                }\n                else {\n                    for (ValueParameterDescriptor parameter : paramDescrs) {\n                        Type sharedVarType = typeMapper.getSharedVarType(parameter);\n                        if (sharedVarType != null) {\n                            Type localVarType = typeMapper.mapType(parameter.getOutType());\n                            int index = frameMap.getIndex(parameter);\n                            mv.visitTypeInsn(NEW, sharedVarType.getInternalName());\n                            mv.visitInsn(DUP);\n                            mv.visitInsn(DUP);\n                            mv.visitMethodInsn(INVOKESPECIAL, sharedVarType.getInternalName(), \"<init>\", \"()V\");\n                            mv.visitVarInsn(localVarType.getOpcode(ILOAD), index);\n                            mv.visitFieldInsn(PUTFIELD, sharedVarType.getInternalName(), \"ref\", StackValue.refType(localVarType).getDescriptor());\n                            mv.visitVarInsn(sharedVarType.getOpcode(ISTORE), index);\n                        }\n                    }\n\n                    codegen.returnExpression(bodyExpressions);\n                }\n                \n                Label methodEnd = new Label();\n                mv.visitLabel(methodEnd);\n\n                int k = 0;\n\n                if(expectedThisObject.exists()) {\n                    Type type = typeMapper.mapType(expectedThisObject.getType());\n                    // TODO: specify signature\n                    mv.visitLocalVariable(\"this\", type.getDescriptor(), null, methodBegin, methodEnd, k++);\n                }\n\n                if(receiverParameter.exists()) {\n                    Type type = typeMapper.mapType(receiverParameter.getType());\n                    // TODO: specify signature\n                    mv.visitLocalVariable(\"this$receiver\", type.getDescriptor(), null, methodBegin, methodEnd, k);\n                    k += type.getSize();\n                }\n\n                for (final TypeParameterDescriptor typeParameterDescriptor : typeParameters) {\n                    mv.visitLocalVariable(typeParameterDescriptor.getName(), JetTypeMapper.TYPE_TYPEINFO.getDescriptor(), null, methodBegin, methodEnd, k++);\n                }\n\n                for (ValueParameterDescriptor parameter : paramDescrs) {\n                    Type type = typeMapper.mapType(parameter.getOutType());\n                    // TODO: specify signature\n                    mv.visitLocalVariable(parameter.getName(), type.getDescriptor(), null, methodBegin, methodEnd, k);\n                    k += type.getSize();\n                }\n\n                endVisit(mv, null, fun);\n                mv.visitEnd();\n\n                generateBridgeIfNeeded(owner, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);\n            }\n        }\n\n        generateDefaultIfNeeded(context, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);\n    }","id":97406,"modified_method":"private void generatedMethod(JetExpression bodyExpressions,\n            JvmMethodSignature jvmSignature,\n            boolean needJetAnnotations, @Nullable String propertyTypeSignature,\n            CodegenContext.MethodContext context,\n            FunctionDescriptor functionDescriptor,\n            JetDeclarationWithBody fun\n    )\n    {\n        List<ValueParameterDescriptor> paramDescrs = functionDescriptor.getValueParameters();\n        List<TypeParameterDescriptor> typeParameters = (functionDescriptor instanceof PropertyAccessorDescriptor ? ((PropertyAccessorDescriptor)functionDescriptor).getCorrespondingProperty(): functionDescriptor).getTypeParameters();\n\n        int flags = ACC_PUBLIC; // TODO.\n        \n        if (!functionDescriptor.getValueParameters().isEmpty()\n                && functionDescriptor.getValueParameters().get(functionDescriptor.getValueParameters().size() - 1)\n                        .getVarargElementType() != null)\n        {\n            flags |= ACC_VARARGS;\n        }\n        \n        if (functionDescriptor.getModality() == Modality.FINAL) {\n            flags |= ACC_FINAL;\n        }\n\n        OwnerKind kind = context.getContextKind();\n        \n        if (kind == OwnerKind.TRAIT_IMPL) {\n            needJetAnnotations = false;\n        }\n\n        ReceiverDescriptor expectedThisObject = functionDescriptor.getExpectedThisObject();\n        ReceiverDescriptor receiverParameter = functionDescriptor.getReceiverParameter();\n\n        if (kind != OwnerKind.TRAIT_IMPL || bodyExpressions != null) {\n            boolean isStatic = kind == OwnerKind.NAMESPACE;\n            if (isStatic || kind == OwnerKind.TRAIT_IMPL)\n                flags |= ACC_STATIC;\n\n            boolean isAbstract = !isStatic && !(kind == OwnerKind.TRAIT_IMPL) && (bodyExpressions == null || CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration()));\n            if (isAbstract) flags |= ACC_ABSTRACT;\n            \n            final MethodVisitor mv = v.newMethod(fun, flags, jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor(), jvmSignature.getGenericsSignature(), null);\n            AnnotationCodegen.forMethod(mv).genAnnotations(functionDescriptor, state.getTypeMapper());\n            if(v.generateCode()) {\n                int start = 0;\n                if (needJetAnnotations) {\n                    if (functionDescriptor instanceof PropertyAccessorDescriptor) {\n                        PropertyCodegen.generateJetPropertyAnnotation(mv, propertyTypeSignature, jvmSignature.getKotlinTypeParameter());\n                    } else if (functionDescriptor instanceof NamedFunctionDescriptor) {\n                        if (propertyTypeSignature != null) {\n                            throw new IllegalStateException();\n                        }\n                        JetMethodAnnotationWriter aw = JetMethodAnnotationWriter.visitAnnotation(mv);\n                        aw.writeKind(JvmStdlibNames.JET_METHOD_KIND_REGULAR);\n                        aw.writeNullableReturnType(functionDescriptor.getReturnType().isNullable());\n                        aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());\n                        aw.writeReturnType(jvmSignature.getKotlinReturnType());\n                        aw.visitEnd();\n                    } else {\n                        throw new IllegalStateException();\n                    }\n\n                    if(receiverParameter.exists()) {\n                        AnnotationVisitor av = mv.visitParameterAnnotation(start++, JvmStdlibNames.JET_VALUE_PARAMETER.getDescriptor(), true);\n                        av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_NAME_FIELD, \"this$receiver\");\n                        if(receiverParameter.getType().isNullable()) {\n                            av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_NULLABLE_FIELD, true);\n                        }\n                        av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_RECEIVER_FIELD, true);\n                        if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(0) != null) {\n                            av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_TYPE_FIELD, jvmSignature.getKotlinParameterTypes().get(0).getKotlinSignature());\n                        }\n                        av.visitEnd();\n                    }\n                    for (final TypeParameterDescriptor typeParameterDescriptor : typeParameters) {\n                        if (!typeParameterDescriptor.isReified()) {\n                            continue;\n                        }\n                        AnnotationVisitor av = mv.visitParameterAnnotation(start++, JvmStdlibNames.JET_TYPE_PARAMETER.getDescriptor(), true);\n                        av.visit(JvmStdlibNames.JET_TYPE_PARAMETER_NAME_FIELD, typeParameterDescriptor.getName());\n                        av.visitEnd();\n                    }\n                    for(int i = 0; i != paramDescrs.size(); ++i) {\n                        AnnotationVisitor av = mv.visitParameterAnnotation(i + start, JvmStdlibNames.JET_VALUE_PARAMETER.getDescriptor(), true);\n                        ValueParameterDescriptor parameterDescriptor = paramDescrs.get(i);\n                        av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_NAME_FIELD, parameterDescriptor.getName());\n                        if(parameterDescriptor.hasDefaultValue()) {\n                            av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_HAS_DEFAULT_VALUE_FIELD, true);\n                        }\n                        if(parameterDescriptor.getOutType().isNullable()) {\n                            av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_NULLABLE_FIELD, true);\n                        }\n                        if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(i) != null) {\n                            av.visit(JvmStdlibNames.JET_VALUE_PARAMETER_TYPE_FIELD, jvmSignature.getKotlinParameterTypes().get(i + start).getKotlinSignature());\n                        }\n                        av.visitEnd();\n                    }\n                }\n            }\n\n\n            if (!isAbstract && v.generateCode()) {\n                mv.visitCode();\n                \n                Label methodBegin = new Label();\n                mv.visitLabel(methodBegin);\n                \n                FrameMap frameMap = context.prepareFrame(typeMapper);\n\n                ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, jvmSignature.getAsmMethod().getReturnType(), context, state);\n\n                Type[] argTypes = jvmSignature.getAsmMethod().getArgumentTypes();\n                int add = 0;\n\n                if(kind == OwnerKind.TRAIT_IMPL)\n                    add++;\n\n                if(receiverParameter.exists())\n                    add++;\n\n                for (final TypeParameterDescriptor typeParameterDescriptor : typeParameters) {\n                    if (!typeParameterDescriptor.isReified()) {\n                        continue;\n                    }\n                    int slot = frameMap.enterTemp();\n                    add++;\n                    codegen.addTypeParameter(typeParameterDescriptor, StackValue.local(slot, JetTypeMapper.TYPE_TYPEINFO));\n                }\n\n                for (int i = 0; i < paramDescrs.size(); i++) {\n                    ValueParameterDescriptor parameter = paramDescrs.get(i);\n                    frameMap.enter(parameter, argTypes[i+add].getSize());\n                }\n\n                if (kind instanceof OwnerKind.DelegateKind) {\n                    OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;\n                    InstructionAdapter iv = new InstructionAdapter(mv);\n                    iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                    dk.getDelegate().put(JetTypeMapper.TYPE_OBJECT, iv);\n                    for (int i = 0; i < argTypes.length; i++) {\n                        Type argType = argTypes[i];\n                        iv.load(i + 1, argType);\n                    }\n                    iv.invokeinterface(dk.getOwnerClass(), jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor());\n                    iv.areturn(jvmSignature.getAsmMethod().getReturnType());\n                }\n                else {\n                    for (ValueParameterDescriptor parameter : paramDescrs) {\n                        Type sharedVarType = typeMapper.getSharedVarType(parameter);\n                        if (sharedVarType != null) {\n                            Type localVarType = typeMapper.mapType(parameter.getOutType());\n                            int index = frameMap.getIndex(parameter);\n                            mv.visitTypeInsn(NEW, sharedVarType.getInternalName());\n                            mv.visitInsn(DUP);\n                            mv.visitInsn(DUP);\n                            mv.visitMethodInsn(INVOKESPECIAL, sharedVarType.getInternalName(), \"<init>\", \"()V\");\n                            mv.visitVarInsn(localVarType.getOpcode(ILOAD), index);\n                            mv.visitFieldInsn(PUTFIELD, sharedVarType.getInternalName(), \"ref\", StackValue.refType(localVarType).getDescriptor());\n                            mv.visitVarInsn(sharedVarType.getOpcode(ISTORE), index);\n                        }\n                    }\n\n                    codegen.returnExpression(bodyExpressions);\n                }\n                \n                Label methodEnd = new Label();\n                mv.visitLabel(methodEnd);\n\n                int k = 0;\n\n                if(expectedThisObject.exists()) {\n                    Type type = typeMapper.mapType(expectedThisObject.getType());\n                    // TODO: specify signature\n                    mv.visitLocalVariable(\"this\", type.getDescriptor(), null, methodBegin, methodEnd, k++);\n                }\n\n                if(receiverParameter.exists()) {\n                    Type type = typeMapper.mapType(receiverParameter.getType());\n                    // TODO: specify signature\n                    mv.visitLocalVariable(\"this$receiver\", type.getDescriptor(), null, methodBegin, methodEnd, k);\n                    k += type.getSize();\n                }\n\n                for (final TypeParameterDescriptor typeParameterDescriptor : typeParameters) {\n                    mv.visitLocalVariable(typeParameterDescriptor.getName(), JetTypeMapper.TYPE_TYPEINFO.getDescriptor(), null, methodBegin, methodEnd, k++);\n                }\n\n                for (ValueParameterDescriptor parameter : paramDescrs) {\n                    Type type = typeMapper.mapType(parameter.getOutType());\n                    // TODO: specify signature\n                    mv.visitLocalVariable(parameter.getName(), type.getDescriptor(), null, methodBegin, methodEnd, k);\n                    k += type.getSize();\n                }\n\n                endVisit(mv, null, fun);\n                mv.visitEnd();\n\n                generateBridgeIfNeeded(owner, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);\n            }\n        }\n\n        generateDefaultIfNeeded(context, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);\n    }","commit_id":"3578d51cb1b6b9be41ceff7cc49b96284c95ade5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    protected void generateDeclaration() {\n        getSuperClass();\n\n        JvmClassSignature signature = signature();\n\n        boolean isAbstract = false;\n        boolean isInterface = false;\n        boolean isFinal = false;\n        boolean isStatic = false;\n        \n        if(myClass instanceof JetClass) {\n            JetClass jetClass = (JetClass) myClass;\n            if (jetClass.hasModifier(JetTokens.ABSTRACT_KEYWORD))\n               isAbstract = true;\n            if (jetClass.isTrait()) {\n                isAbstract = true;\n                isInterface = true;\n            }\n            if (!jetClass.hasModifier(JetTokens.OPEN_KEYWORD) && !isAbstract) {\n                isFinal = true;\n            }\n        }\n        else if (myClass.getParent() instanceof JetClassObject) {\n            isStatic = true;\n        }\n\n        int access = 0;\n        access |= ACC_PUBLIC;\n        if (isAbstract) {\n            access |= ACC_ABSTRACT;\n        }\n        if (isInterface) {\n            access |= ACC_INTERFACE; // ACC_SUPER\n        }\n        if (isFinal) {\n            access |= ACC_FINAL;\n        }\n        if (isStatic) {\n            access |= ACC_STATIC;\n        }\n        v.defineClass(myClass, V1_6,\n                access,\n                      signature.getName(),\n                      signature.getJavaGenericSignature(),\n                      signature.getSuperclassName(),\n                      signature.getInterfaces().toArray(new String[0])\n        );\n        v.visitSource(state.transformFileName(myClass.getContainingFile().getName()), null);\n\n        ClassDescriptor container = getContainingClassDescriptor(descriptor);\n        if(container != null) {\n            v.visitOuterClass(typeMapper.mapType(container.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName(), null, null);\n        }\n\n        for (ClassDescriptor innerClass : descriptor.getInnerClassesAndObjects()) {\n            // TODO: proper access\n            int innerClassAccess = ACC_PUBLIC;\n            if (innerClass.getModality() == Modality.FINAL) {\n                innerClassAccess |= ACC_FINAL;\n            } else if (innerClass.getModality() == Modality.ABSTRACT) {\n                innerClassAccess |= ACC_ABSTRACT;\n            }\n            // TODO: cache internal names\n            String outerClassInernalName = typeMapper.mapType(descriptor.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName();\n            String innerClassInternalName = typeMapper.mapType(innerClass.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName();\n            v.visitInnerClass(innerClassInternalName, outerClassInernalName, innerClass.getName(), innerClassAccess);\n        }\n\n        if(myClass instanceof JetClass && signature.getKotlinGenericSignature() != null) {\n            AnnotationVisitor annotationVisitor = v.newAnnotation(myClass, JvmStdlibNames.JET_CLASS.getDescriptor(), true);\n            annotationVisitor.visit(JvmStdlibNames.JET_CLASS_SIGNATURE, signature.getKotlinGenericSignature());\n            annotationVisitor.visitEnd();\n        }\n    }","id":97407,"modified_method":"@Override\n    protected void generateDeclaration() {\n        getSuperClass();\n\n        JvmClassSignature signature = signature();\n\n        boolean isAbstract = false;\n        boolean isInterface = false;\n        boolean isFinal = false;\n        boolean isStatic = false;\n        \n        if(myClass instanceof JetClass) {\n            JetClass jetClass = (JetClass) myClass;\n            if (jetClass.hasModifier(JetTokens.ABSTRACT_KEYWORD))\n               isAbstract = true;\n            if (jetClass.isTrait()) {\n                isAbstract = true;\n                isInterface = true;\n            }\n            if (!jetClass.hasModifier(JetTokens.OPEN_KEYWORD) && !isAbstract) {\n                isFinal = true;\n            }\n        }\n        else if (myClass.getParent() instanceof JetClassObject) {\n            isStatic = true;\n        }\n\n        int access = 0;\n        access |= ACC_PUBLIC;\n        if (isAbstract) {\n            access |= ACC_ABSTRACT;\n        }\n        if (isInterface) {\n            access |= ACC_INTERFACE; // ACC_SUPER\n        }\n        if (isFinal) {\n            access |= ACC_FINAL;\n        }\n        if (isStatic) {\n            access |= ACC_STATIC;\n        }\n        v.defineClass(myClass, V1_6,\n                access,\n                      signature.getName(),\n                      signature.getJavaGenericSignature(),\n                      signature.getSuperclassName(),\n                      signature.getInterfaces().toArray(new String[0])\n        );\n        v.visitSource(state.transformFileName(myClass.getContainingFile().getName()), null);\n\n        ClassDescriptor container = getContainingClassDescriptor(descriptor);\n        if(container != null) {\n            v.visitOuterClass(typeMapper.mapType(container.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName(), null, null);\n        }\n\n        for (ClassDescriptor innerClass : descriptor.getInnerClassesAndObjects()) {\n            // TODO: proper access\n            int innerClassAccess = ACC_PUBLIC;\n            if (innerClass.getModality() == Modality.FINAL) {\n                innerClassAccess |= ACC_FINAL;\n            } else if (innerClass.getModality() == Modality.ABSTRACT) {\n                innerClassAccess |= ACC_ABSTRACT;\n            }\n            // TODO: cache internal names\n            String outerClassInernalName = typeMapper.mapType(descriptor.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName();\n            String innerClassInternalName = typeMapper.mapType(innerClass.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName();\n            v.visitInnerClass(innerClassInternalName, outerClassInernalName, innerClass.getName(), innerClassAccess);\n        }\n\n        AnnotationCodegen.forClass(v.getVisitor()).genAnnotations(descriptor, typeMapper);\n\n        if(myClass instanceof JetClass && signature.getKotlinGenericSignature() != null) {\n            AnnotationVisitor annotationVisitor = v.newAnnotation(myClass, JvmStdlibNames.JET_CLASS.getDescriptor(), true);\n            annotationVisitor.visit(JvmStdlibNames.JET_CLASS_SIGNATURE, signature.getKotlinGenericSignature());\n            annotationVisitor.visitEnd();\n        }\n    }","commit_id":"3578d51cb1b6b9be41ceff7cc49b96284c95ade5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected void generatePrimaryConstructor() {\n        if(myClass instanceof JetClass && ((JetClass) myClass).isTrait())\n            return;\n\n        ConstructorDescriptor constructorDescriptor = bindingContext.get(BindingContext.CONSTRUCTOR, myClass);\n\n        CodegenContext.ConstructorContext constructorContext = context.intoConstructor(constructorDescriptor, typeMapper);\n\n        JvmMethodSignature constructorMethod;\n        CallableMethod callableMethod;\n        if (constructorDescriptor == null) {\n            \n            BothSignatureWriter signatureWriter = new BothSignatureWriter(BothSignatureWriter.Mode.METHOD, false);\n            \n            signatureWriter.writeFormalTypeParametersStart();\n            signatureWriter.writeFormalTypeParametersEnd();\n            \n            signatureWriter.writeParametersStart();\n            \n            if (CodegenUtil.hasThis0(descriptor)) {\n                signatureWriter.writeParameterType(JvmMethodParameterKind.THIS0);\n                typeMapper.mapType(CodegenUtil.getOuterClassDescriptor(descriptor).getDefaultType(), OwnerKind.IMPLEMENTATION, signatureWriter, false);\n                signatureWriter.writeParameterTypeEnd();\n            }\n\n            if (CodegenUtil.requireTypeInfoConstructorArg(descriptor.getDefaultType())) {\n                signatureWriter.writeTypeInfoParameter();\n            }\n\n            signatureWriter.writeParametersEnd();\n            \n            signatureWriter.writeVoidReturn();\n\n            constructorMethod = signatureWriter.makeJvmMethodSignature(\"<init>\");\n            callableMethod = new CallableMethod(\"\", constructorMethod, INVOKESPECIAL);\n        }\n        else {\n            callableMethod = typeMapper.mapToCallableMethod(constructorDescriptor, kind);\n            constructorMethod = callableMethod.getSignature();\n        }\n\n        ObjectOrClosureCodegen closure = context.closure;\n        int firstSuperArgument = -1;\n        if(closure != null) {\n            final LinkedList<JvmMethodParameterSignature> consArgTypes = new LinkedList<JvmMethodParameterSignature>(constructorMethod.getKotlinParameterTypes());\n\n            int insert = 0;\n            if(closure.captureThis) {\n                if(!CodegenUtil.hasThis0(descriptor))\n                    consArgTypes.add(insert, new JvmMethodParameterSignature(Type.getObjectType(context.getThisDescriptor().getName()), \"\", JvmMethodParameterKind.THIS0));\n                insert++;\n            }\n            else {\n                if(CodegenUtil.hasThis0(descriptor))\n                    insert++;\n            }\n\n            if(closure.captureReceiver != null)\n                consArgTypes.add(insert++, new JvmMethodParameterSignature(closure.captureReceiver, \"\", JvmMethodParameterKind.RECEIVER));\n\n            for (DeclarationDescriptor descriptor : closure.closure.keySet()) {\n                if(descriptor instanceof VariableDescriptor && !(descriptor instanceof PropertyDescriptor)) {\n                    final Type sharedVarType = typeMapper.getSharedVarType(descriptor);\n                    final Type type = sharedVarType != null ? sharedVarType : state.getTypeMapper().mapType(((VariableDescriptor) descriptor).getOutType());\n                    consArgTypes.add(insert++, new JvmMethodParameterSignature(type, \"\", JvmMethodParameterKind.SHARED_VAR));\n                }\n                else if(descriptor instanceof FunctionDescriptor) {\n                    assert closure.captureReceiver != null;\n                }\n            }\n\n            if(myClass instanceof JetObjectDeclaration) {\n                if(superCall instanceof JetDelegatorToSuperCall) {\n                    closure.superCall = (JetDelegatorToSuperCall) superCall;\n                    ConstructorDescriptor superConstructor = (ConstructorDescriptor) bindingContext.get(BindingContext.REFERENCE_TARGET, ((JetDelegatorToSuperCall) superCall).getCalleeExpression().getConstructorReferenceExpression());\n                    CallableMethod superCallable = typeMapper.mapToCallableMethod(superConstructor, OwnerKind.IMPLEMENTATION);\n                    firstSuperArgument = insert;\n                    for(Type t : superCallable.getSignature().getAsmMethod().getArgumentTypes()) {\n                        consArgTypes.add(insert++, new JvmMethodParameterSignature(t, \"\", JvmMethodParameterKind.SHARED_VAR));\n                    }\n                }\n            }\n            \n            constructorMethod = JvmMethodSignature.simple(\"<init>\", Type.VOID_TYPE, consArgTypes);\n        }\n\n        int flags = ACC_PUBLIC; // TODO\n        final MethodVisitor mv = v.newMethod(myClass, flags, constructorMethod.getName(), constructorMethod.getAsmMethod().getDescriptor(), constructorMethod.getGenericsSignature(), null);\n        if (!v.generateCode()) return;\n        \n        AnnotationVisitor jetConstructorVisitor = mv.visitAnnotation(JvmStdlibNames.JET_CONSTRUCTOR.getDescriptor(), true);\n        if (constructorDescriptor == null) {\n            jetConstructorVisitor.visit(JvmStdlibNames.JET_CONSTRUCTOR_HIDDEN_FIELD, true);\n        }\n        jetConstructorVisitor.visitEnd();\n        \n        if (constructorDescriptor != null) {\n            int i = 0;\n\n            if (CodegenUtil.hasThis0(descriptor)) {\n                i++;\n            }\n\n            if (CodegenUtil.requireTypeInfoConstructorArg(descriptor.getDefaultType())) {\n                AnnotationVisitor jetTypeParameterAnnotation =\n                        mv.visitParameterAnnotation(i++, JvmStdlibNames.JET_TYPE_PARAMETER.getDescriptor(), true);\n                jetTypeParameterAnnotation.visitEnd();\n            }\n\n            for (ValueParameterDescriptor valueParameter : constructorDescriptor.getValueParameters()) {\n                AnnotationVisitor jetValueParameterAnnotation =\n                        mv.visitParameterAnnotation(i++, JvmStdlibNames.JET_VALUE_PARAMETER.getDescriptor(), true);\n                jetValueParameterAnnotation.visit(JvmStdlibNames.JET_VALUE_PARAMETER_NAME_FIELD, valueParameter.getName());\n                jetValueParameterAnnotation.visitEnd();\n            }\n        }\n\n        mv.visitCode();\n\n        List<ValueParameterDescriptor> paramDescrs = constructorDescriptor != null\n                ? constructorDescriptor.getValueParameters()\n                : Collections.<ValueParameterDescriptor>emptyList();\n\n        ConstructorFrameMap frameMap = new ConstructorFrameMap(callableMethod, constructorDescriptor, descriptor, kind);\n\n        final InstructionAdapter iv = new InstructionAdapter(mv);\n        ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, Type.VOID_TYPE, constructorContext, state);\n\n//        for(int slot = 0; slot != frameMap.getTypeParameterCount(); ++slot) {\n//            if(constructorDescriptor != null)\n//                codegen.addTypeParameter(constructorDescriptor.getTypeParameters().get(slot), StackValue.local(frameMap.getFirstTypeParameter() + slot, JetTypeMapper.TYPE_TYPEINFO));\n//            else\n//                codegen.addTypeParameter(descriptor.getTypeConstructor().getParameters().get(slot), StackValue.local(frameMap.getFirstTypeParameter() + slot, JetTypeMapper.TYPE_TYPEINFO));\n//        }\n\n        String classname = typeMapper.mapType(descriptor.getDefaultType(), kind).getInternalName();\n        final Type classType = Type.getType(\"L\" + classname + \";\");\n\n        HashSet<FunctionDescriptor> overridden = new HashSet<FunctionDescriptor>();\n        for (JetDeclaration declaration : myClass.getDeclarations()) {\n            if (declaration instanceof JetNamedFunction) {\n                NamedFunctionDescriptor functionDescriptor = bindingContext.get(BindingContext.FUNCTION, declaration);\n                assert functionDescriptor != null;\n                overridden.addAll(functionDescriptor.getOverriddenDescriptors());\n            }\n        }\n\n        if (superCall == null) {\n            iv.load(0, Type.getType(\"L\" + superClass + \";\"));\n            iv.invokespecial(superClass, \"<init>\", \"()V\");\n        }\n        else if (superCall instanceof JetDelegatorToSuperClass) {\n            iv.load(0, Type.getType(\"L\" + superClass + \";\"));\n            JetType superType = bindingContext.get(BindingContext.TYPE, superCall.getTypeReference());\n            List<Type> parameterTypes = new ArrayList<Type>();\n            assert superType != null;\n            ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();\n            if (CodegenUtil.hasThis0(superClassDescriptor)) {\n                iv.load(1, JetTypeMapper.TYPE_OBJECT);\n                parameterTypes.add(typeMapper.mapType(CodegenUtil.getOuterClassDescriptor(descriptor).getDefaultType(), OwnerKind.IMPLEMENTATION));\n            }\n            for(TypeProjection typeParameterDescriptor : superType.getArguments()) {\n                codegen.generateTypeInfo(typeParameterDescriptor.getType(), null);\n                parameterTypes.add(JetTypeMapper.TYPE_TYPEINFO);\n            }\n            Method superCallMethod = new Method(\"<init>\", Type.VOID_TYPE, parameterTypes.toArray(new Type[parameterTypes.size()]));\n            iv.invokespecial(typeMapper.mapType(superClassDescriptor.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName(), \"<init>\", superCallMethod.getDescriptor());\n        }\n        else {\n            iv.load(0, classType);\n            ConstructorDescriptor constructorDescriptor1 = (ConstructorDescriptor) bindingContext.get(BindingContext.REFERENCE_TARGET, ((JetDelegatorToSuperCall) superCall).getCalleeExpression().getConstructorReferenceExpression());\n            generateDelegatorToConstructorCall(iv, codegen, (JetDelegatorToSuperCall) superCall, constructorDescriptor1, frameMap, firstSuperArgument);\n        }\n\n        int n = 0;\n        for (JetDelegationSpecifier specifier : myClass.getDelegationSpecifiers()) {\n            if(specifier == superCall)\n                continue;\n\n            if (specifier instanceof JetDelegatorByExpressionSpecifier) {\n                iv.load(0, classType);\n                codegen.genToJVMStack(((JetDelegatorByExpressionSpecifier) specifier).getDelegateExpression());\n\n                JetType superType = bindingContext.get(BindingContext.TYPE, specifier.getTypeReference());\n                assert superType != null;\n                ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();\n                String delegateField = \"$delegate_\" + n;\n                Type fieldType = typeMapper.mapType(superClassDescriptor.getDefaultType(), OwnerKind.IMPLEMENTATION);\n                String fieldDesc = fieldType.getDescriptor();\n                v.newField(specifier, ACC_PRIVATE, delegateField, fieldDesc, /*TODO*/null, null);\n                iv.putfield(classname, delegateField, fieldDesc);\n\n                JetClass superClass = (JetClass) bindingContext.get(BindingContext.DESCRIPTOR_TO_DECLARATION, superClassDescriptor);\n                final CodegenContext delegateContext = context.intoClass(superClassDescriptor,\n                        new OwnerKind.DelegateKind(StackValue.field(fieldType, classname, delegateField, false),\n                                                   typeMapper.mapType(superClassDescriptor.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName()), state.getTypeMapper());\n                generateDelegates(superClass, delegateContext, overridden);\n            }\n        }\n\n        final ClassDescriptor outerDescriptor = getOuterClassDescriptor();\n        if (outerDescriptor != null && outerDescriptor.getKind() != ClassKind.OBJECT) {\n            final Type type = typeMapper.mapType(outerDescriptor.getDefaultType(), OwnerKind.IMPLEMENTATION);\n            String interfaceDesc = type.getDescriptor();\n            final String fieldName = \"this$0\";\n            v.newField(myClass, ACC_PRIVATE | ACC_FINAL, fieldName, interfaceDesc, null, null);\n            iv.load(0, classType);\n            iv.load(frameMap.getOuterThisIndex(), type);\n            iv.putfield(classname, fieldName, interfaceDesc);\n\n            Type outerType = typeMapper.mapType(outerDescriptor.getDefaultType());\n            MethodVisitor outer = v.newMethod(myClass, ACC_PUBLIC, JvmStdlibNames.JET_OBJECT_GET_OUTER_OBJECT_METHOD, \"()Ljet/JetObject;\", null, null);\n            outer.visitCode();\n            outer.visitVarInsn(ALOAD, 0);\n            outer.visitFieldInsn(GETFIELD, classname, \"this$0\", outerType.getDescriptor());\n            outer.visitInsn(ARETURN);\n            FunctionCodegen.endVisit(outer, JvmStdlibNames.JET_OBJECT_GET_OUTER_OBJECT_METHOD, myClass);\n        }\n\n        if (CodegenUtil.requireTypeInfoConstructorArg(descriptor.getDefaultType()) && kind == OwnerKind.IMPLEMENTATION) {\n            iv.load(0, JetTypeMapper.TYPE_OBJECT);\n            iv.load(frameMap.getTypeInfoIndex(), JetTypeMapper.TYPE_OBJECT);\n            iv.invokevirtual(typeMapper.mapType(descriptor.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName(), JvmAbi.SET_TYPE_INFO_METHOD, \"(Ljet/TypeInfo;)V\");\n        }\n\n        if(closure != null) {\n            int k = outerDescriptor != null && outerDescriptor.getKind() != ClassKind.OBJECT ? 2 : 1;\n            if(closure.captureReceiver != null) {\n                iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                iv.load(1, closure.captureReceiver);\n                iv.putfield(typeMapper.mapType(descriptor.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName(), \"receiver$0\", closure.captureReceiver.getDescriptor());\n                k += closure.captureReceiver.getSize();\n            }\n\n            int l = 0;\n            for (DeclarationDescriptor varDescr : closure.closure.keySet()) {\n                if(varDescr instanceof VariableDescriptor && !(varDescr instanceof PropertyDescriptor)) {\n                    Type sharedVarType = typeMapper.getSharedVarType(varDescr);\n                    if(sharedVarType == null) {\n                        sharedVarType = typeMapper.mapType(((VariableDescriptor) varDescr).getOutType());\n                    }\n                    iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                    iv.load(k, StackValue.refType(sharedVarType));\n                    k += StackValue.refType(sharedVarType).getSize();\n                    iv.putfield(typeMapper.mapType(descriptor.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName(), \"$\" + varDescr.getName(), sharedVarType.getDescriptor());\n                    l++;\n                }\n            }\n        }\n\n        int curParam = 0;\n        List<JetParameter> constructorParameters = getPrimaryConstructorParameters();\n        for (JetParameter parameter : constructorParameters) {\n            if (parameter.getValOrVarNode() != null) {\n                VariableDescriptor descriptor = paramDescrs.get(curParam);\n                Type type = typeMapper.mapType(descriptor.getOutType());\n                iv.load(0, classType);\n                iv.load(frameMap.getIndex(descriptor), type);\n                iv.putfield(classname, descriptor.getName(), type.getDescriptor());\n            }\n            curParam++;\n        }\n\n        generateInitializers(codegen, iv);\n\n        generateTraitMethods(codegen);\n\n        mv.visitInsn(RETURN);\n        FunctionCodegen.endVisit(mv, \"constructor\", myClass);\n\n        FunctionCodegen.generateDefaultIfNeeded(constructorContext, state, v, constructorMethod.getAsmMethod(), constructorDescriptor, OwnerKind.IMPLEMENTATION);\n    }","id":97408,"modified_method":"protected void generatePrimaryConstructor() {\n        if(myClass instanceof JetClass && ((JetClass) myClass).isTrait())\n            return;\n\n        ConstructorDescriptor constructorDescriptor = bindingContext.get(BindingContext.CONSTRUCTOR, myClass);\n\n        CodegenContext.ConstructorContext constructorContext = context.intoConstructor(constructorDescriptor, typeMapper);\n\n        JvmMethodSignature constructorMethod;\n        CallableMethod callableMethod;\n        if (constructorDescriptor == null) {\n            \n            BothSignatureWriter signatureWriter = new BothSignatureWriter(BothSignatureWriter.Mode.METHOD, false);\n            \n            signatureWriter.writeFormalTypeParametersStart();\n            signatureWriter.writeFormalTypeParametersEnd();\n            \n            signatureWriter.writeParametersStart();\n            \n            if (CodegenUtil.hasThis0(descriptor)) {\n                signatureWriter.writeParameterType(JvmMethodParameterKind.THIS0);\n                typeMapper.mapType(CodegenUtil.getOuterClassDescriptor(descriptor).getDefaultType(), OwnerKind.IMPLEMENTATION, signatureWriter, false);\n                signatureWriter.writeParameterTypeEnd();\n            }\n\n            if (CodegenUtil.requireTypeInfoConstructorArg(descriptor.getDefaultType())) {\n                signatureWriter.writeTypeInfoParameter();\n            }\n\n            signatureWriter.writeParametersEnd();\n            \n            signatureWriter.writeVoidReturn();\n\n            constructorMethod = signatureWriter.makeJvmMethodSignature(\"<init>\");\n            callableMethod = new CallableMethod(\"\", constructorMethod, INVOKESPECIAL);\n        }\n        else {\n            callableMethod = typeMapper.mapToCallableMethod(constructorDescriptor, kind);\n            constructorMethod = callableMethod.getSignature();\n        }\n\n        ObjectOrClosureCodegen closure = context.closure;\n        int firstSuperArgument = -1;\n        if(closure != null) {\n            final LinkedList<JvmMethodParameterSignature> consArgTypes = new LinkedList<JvmMethodParameterSignature>(constructorMethod.getKotlinParameterTypes());\n\n            int insert = 0;\n            if(closure.captureThis) {\n                if(!CodegenUtil.hasThis0(descriptor))\n                    consArgTypes.add(insert, new JvmMethodParameterSignature(Type.getObjectType(context.getThisDescriptor().getName()), \"\", JvmMethodParameterKind.THIS0));\n                insert++;\n            }\n            else {\n                if(CodegenUtil.hasThis0(descriptor))\n                    insert++;\n            }\n\n            if(closure.captureReceiver != null)\n                consArgTypes.add(insert++, new JvmMethodParameterSignature(closure.captureReceiver, \"\", JvmMethodParameterKind.RECEIVER));\n\n            for (DeclarationDescriptor descriptor : closure.closure.keySet()) {\n                if(descriptor instanceof VariableDescriptor && !(descriptor instanceof PropertyDescriptor)) {\n                    final Type sharedVarType = typeMapper.getSharedVarType(descriptor);\n                    final Type type = sharedVarType != null ? sharedVarType : state.getTypeMapper().mapType(((VariableDescriptor) descriptor).getOutType());\n                    consArgTypes.add(insert++, new JvmMethodParameterSignature(type, \"\", JvmMethodParameterKind.SHARED_VAR));\n                }\n                else if(descriptor instanceof FunctionDescriptor) {\n                    assert closure.captureReceiver != null;\n                }\n            }\n\n            if(myClass instanceof JetObjectDeclaration) {\n                if(superCall instanceof JetDelegatorToSuperCall) {\n                    closure.superCall = (JetDelegatorToSuperCall) superCall;\n                    ConstructorDescriptor superConstructor = (ConstructorDescriptor) bindingContext.get(BindingContext.REFERENCE_TARGET, ((JetDelegatorToSuperCall) superCall).getCalleeExpression().getConstructorReferenceExpression());\n                    CallableMethod superCallable = typeMapper.mapToCallableMethod(superConstructor, OwnerKind.IMPLEMENTATION);\n                    firstSuperArgument = insert;\n                    for(Type t : superCallable.getSignature().getAsmMethod().getArgumentTypes()) {\n                        consArgTypes.add(insert++, new JvmMethodParameterSignature(t, \"\", JvmMethodParameterKind.SHARED_VAR));\n                    }\n                }\n            }\n            \n            constructorMethod = JvmMethodSignature.simple(\"<init>\", Type.VOID_TYPE, consArgTypes);\n        }\n\n        int flags = ACC_PUBLIC; // TODO\n        final MethodVisitor mv = v.newMethod(myClass, flags, constructorMethod.getName(), constructorMethod.getAsmMethod().getDescriptor(), constructorMethod.getGenericsSignature(), null);\n        if (!v.generateCode()) return;\n        \n        AnnotationVisitor jetConstructorVisitor = mv.visitAnnotation(JvmStdlibNames.JET_CONSTRUCTOR.getDescriptor(), true);\n        if (constructorDescriptor == null) {\n            jetConstructorVisitor.visit(JvmStdlibNames.JET_CONSTRUCTOR_HIDDEN_FIELD, true);\n        }\n        jetConstructorVisitor.visitEnd();\n        \n        AnnotationCodegen.forMethod(mv).genAnnotations(constructorDescriptor, typeMapper);\n\n        if (constructorDescriptor != null) {\n            int i = 0;\n\n            if (CodegenUtil.hasThis0(descriptor)) {\n                i++;\n            }\n\n            if (CodegenUtil.requireTypeInfoConstructorArg(descriptor.getDefaultType())) {\n                AnnotationVisitor jetTypeParameterAnnotation =\n                        mv.visitParameterAnnotation(i++, JvmStdlibNames.JET_TYPE_PARAMETER.getDescriptor(), true);\n                jetTypeParameterAnnotation.visitEnd();\n            }\n\n            for (ValueParameterDescriptor valueParameter : constructorDescriptor.getValueParameters()) {\n                AnnotationVisitor jetValueParameterAnnotation =\n                        mv.visitParameterAnnotation(i++, JvmStdlibNames.JET_VALUE_PARAMETER.getDescriptor(), true);\n                jetValueParameterAnnotation.visit(JvmStdlibNames.JET_VALUE_PARAMETER_NAME_FIELD, valueParameter.getName());\n                jetValueParameterAnnotation.visitEnd();\n            }\n        }\n\n        mv.visitCode();\n\n        List<ValueParameterDescriptor> paramDescrs = constructorDescriptor != null\n                ? constructorDescriptor.getValueParameters()\n                : Collections.<ValueParameterDescriptor>emptyList();\n\n        ConstructorFrameMap frameMap = new ConstructorFrameMap(callableMethod, constructorDescriptor, descriptor, kind);\n\n        final InstructionAdapter iv = new InstructionAdapter(mv);\n        ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, Type.VOID_TYPE, constructorContext, state);\n\n//        for(int slot = 0; slot != frameMap.getTypeParameterCount(); ++slot) {\n//            if(constructorDescriptor != null)\n//                codegen.addTypeParameter(constructorDescriptor.getTypeParameters().get(slot), StackValue.local(frameMap.getFirstTypeParameter() + slot, JetTypeMapper.TYPE_TYPEINFO));\n//            else\n//                codegen.addTypeParameter(descriptor.getTypeConstructor().getParameters().get(slot), StackValue.local(frameMap.getFirstTypeParameter() + slot, JetTypeMapper.TYPE_TYPEINFO));\n//        }\n\n        String classname = typeMapper.mapType(descriptor.getDefaultType(), kind).getInternalName();\n        final Type classType = Type.getType(\"L\" + classname + \";\");\n\n        HashSet<FunctionDescriptor> overridden = new HashSet<FunctionDescriptor>();\n        for (JetDeclaration declaration : myClass.getDeclarations()) {\n            if (declaration instanceof JetNamedFunction) {\n                NamedFunctionDescriptor functionDescriptor = bindingContext.get(BindingContext.FUNCTION, declaration);\n                assert functionDescriptor != null;\n                overridden.addAll(functionDescriptor.getOverriddenDescriptors());\n            }\n        }\n\n        if (superCall == null) {\n            iv.load(0, Type.getType(\"L\" + superClass + \";\"));\n            iv.invokespecial(superClass, \"<init>\", \"()V\");\n        }\n        else if (superCall instanceof JetDelegatorToSuperClass) {\n            iv.load(0, Type.getType(\"L\" + superClass + \";\"));\n            JetType superType = bindingContext.get(BindingContext.TYPE, superCall.getTypeReference());\n            List<Type> parameterTypes = new ArrayList<Type>();\n            assert superType != null;\n            ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();\n            if (CodegenUtil.hasThis0(superClassDescriptor)) {\n                iv.load(1, JetTypeMapper.TYPE_OBJECT);\n                parameterTypes.add(typeMapper.mapType(CodegenUtil.getOuterClassDescriptor(descriptor).getDefaultType(), OwnerKind.IMPLEMENTATION));\n            }\n            for(TypeProjection typeParameterDescriptor : superType.getArguments()) {\n                codegen.generateTypeInfo(typeParameterDescriptor.getType(), null);\n                parameterTypes.add(JetTypeMapper.TYPE_TYPEINFO);\n            }\n            Method superCallMethod = new Method(\"<init>\", Type.VOID_TYPE, parameterTypes.toArray(new Type[parameterTypes.size()]));\n            iv.invokespecial(typeMapper.mapType(superClassDescriptor.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName(), \"<init>\", superCallMethod.getDescriptor());\n        }\n        else {\n            iv.load(0, classType);\n            ConstructorDescriptor constructorDescriptor1 = (ConstructorDescriptor) bindingContext.get(BindingContext.REFERENCE_TARGET, ((JetDelegatorToSuperCall) superCall).getCalleeExpression().getConstructorReferenceExpression());\n            generateDelegatorToConstructorCall(iv, codegen, (JetDelegatorToSuperCall) superCall, constructorDescriptor1, frameMap, firstSuperArgument);\n        }\n\n        int n = 0;\n        for (JetDelegationSpecifier specifier : myClass.getDelegationSpecifiers()) {\n            if(specifier == superCall)\n                continue;\n\n            if (specifier instanceof JetDelegatorByExpressionSpecifier) {\n                iv.load(0, classType);\n                codegen.genToJVMStack(((JetDelegatorByExpressionSpecifier) specifier).getDelegateExpression());\n\n                JetType superType = bindingContext.get(BindingContext.TYPE, specifier.getTypeReference());\n                assert superType != null;\n                ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();\n                String delegateField = \"$delegate_\" + n;\n                Type fieldType = typeMapper.mapType(superClassDescriptor.getDefaultType(), OwnerKind.IMPLEMENTATION);\n                String fieldDesc = fieldType.getDescriptor();\n                v.newField(specifier, ACC_PRIVATE, delegateField, fieldDesc, /*TODO*/null, null);\n                iv.putfield(classname, delegateField, fieldDesc);\n\n                JetClass superClass = (JetClass) bindingContext.get(BindingContext.DESCRIPTOR_TO_DECLARATION, superClassDescriptor);\n                final CodegenContext delegateContext = context.intoClass(superClassDescriptor,\n                        new OwnerKind.DelegateKind(StackValue.field(fieldType, classname, delegateField, false),\n                                                   typeMapper.mapType(superClassDescriptor.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName()), state.getTypeMapper());\n                generateDelegates(superClass, delegateContext, overridden);\n            }\n        }\n\n        final ClassDescriptor outerDescriptor = getOuterClassDescriptor();\n        if (outerDescriptor != null && outerDescriptor.getKind() != ClassKind.OBJECT) {\n            final Type type = typeMapper.mapType(outerDescriptor.getDefaultType(), OwnerKind.IMPLEMENTATION);\n            String interfaceDesc = type.getDescriptor();\n            final String fieldName = \"this$0\";\n            v.newField(myClass, ACC_PRIVATE | ACC_FINAL, fieldName, interfaceDesc, null, null);\n            iv.load(0, classType);\n            iv.load(frameMap.getOuterThisIndex(), type);\n            iv.putfield(classname, fieldName, interfaceDesc);\n\n            Type outerType = typeMapper.mapType(outerDescriptor.getDefaultType());\n            MethodVisitor outer = v.newMethod(myClass, ACC_PUBLIC, JvmStdlibNames.JET_OBJECT_GET_OUTER_OBJECT_METHOD, \"()Ljet/JetObject;\", null, null);\n            outer.visitCode();\n            outer.visitVarInsn(ALOAD, 0);\n            outer.visitFieldInsn(GETFIELD, classname, \"this$0\", outerType.getDescriptor());\n            outer.visitInsn(ARETURN);\n            FunctionCodegen.endVisit(outer, JvmStdlibNames.JET_OBJECT_GET_OUTER_OBJECT_METHOD, myClass);\n        }\n\n        if (CodegenUtil.requireTypeInfoConstructorArg(descriptor.getDefaultType()) && kind == OwnerKind.IMPLEMENTATION) {\n            iv.load(0, JetTypeMapper.TYPE_OBJECT);\n            iv.load(frameMap.getTypeInfoIndex(), JetTypeMapper.TYPE_OBJECT);\n            iv.invokevirtual(typeMapper.mapType(descriptor.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName(), JvmAbi.SET_TYPE_INFO_METHOD, \"(Ljet/TypeInfo;)V\");\n        }\n\n        if(closure != null) {\n            int k = outerDescriptor != null && outerDescriptor.getKind() != ClassKind.OBJECT ? 2 : 1;\n            if(closure.captureReceiver != null) {\n                iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                iv.load(1, closure.captureReceiver);\n                iv.putfield(typeMapper.mapType(descriptor.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName(), \"receiver$0\", closure.captureReceiver.getDescriptor());\n                k += closure.captureReceiver.getSize();\n            }\n\n            int l = 0;\n            for (DeclarationDescriptor varDescr : closure.closure.keySet()) {\n                if(varDescr instanceof VariableDescriptor && !(varDescr instanceof PropertyDescriptor)) {\n                    Type sharedVarType = typeMapper.getSharedVarType(varDescr);\n                    if(sharedVarType == null) {\n                        sharedVarType = typeMapper.mapType(((VariableDescriptor) varDescr).getOutType());\n                    }\n                    iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                    iv.load(k, StackValue.refType(sharedVarType));\n                    k += StackValue.refType(sharedVarType).getSize();\n                    iv.putfield(typeMapper.mapType(descriptor.getDefaultType(), OwnerKind.IMPLEMENTATION).getInternalName(), \"$\" + varDescr.getName(), sharedVarType.getDescriptor());\n                    l++;\n                }\n            }\n        }\n\n        int curParam = 0;\n        List<JetParameter> constructorParameters = getPrimaryConstructorParameters();\n        for (JetParameter parameter : constructorParameters) {\n            if (parameter.getValOrVarNode() != null) {\n                VariableDescriptor descriptor = paramDescrs.get(curParam);\n                Type type = typeMapper.mapType(descriptor.getOutType());\n                iv.load(0, classType);\n                iv.load(frameMap.getIndex(descriptor), type);\n                iv.putfield(classname, descriptor.getName(), type.getDescriptor());\n            }\n            curParam++;\n        }\n\n        generateInitializers(codegen, iv);\n\n        generateTraitMethods(codegen);\n\n        mv.visitInsn(RETURN);\n        FunctionCodegen.endVisit(mv, \"constructor\", myClass);\n\n        FunctionCodegen.generateDefaultIfNeeded(constructorContext, state, v, constructorMethod.getAsmMethod(), constructorDescriptor, OwnerKind.IMPLEMENTATION);\n    }","commit_id":"3578d51cb1b6b9be41ceff7cc49b96284c95ade5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void generateBackingField(JetProperty p, PropertyDescriptor propertyDescriptor) {\n        if (state.getBindingContext().get(BindingContext.BACKING_FIELD_REQUIRED, propertyDescriptor)) {\n            DeclarationDescriptor containingDeclaration = propertyDescriptor.getContainingDeclaration();\n            if(CodegenUtil.isInterface(containingDeclaration))\n                return;\n\n            Object value = null;\n            final JetExpression initializer = p.getInitializer();\n            if (initializer != null) {\n                if (initializer instanceof JetConstantExpression) {\n                    CompileTimeConstant<?> compileTimeValue = state.getBindingContext().get(BindingContext.COMPILE_TIME_VALUE, initializer);\n                    value = compileTimeValue != null ? compileTimeValue.getValue() : null;\n                }\n            }\n            int modifiers;\n            if (kind == OwnerKind.NAMESPACE) {\n                int access = JetTypeMapper.getAccessModifiers(propertyDescriptor, 0);\n                modifiers = access | Opcodes.ACC_STATIC;\n            }\n            else {\n                modifiers = JetTypeMapper.getAccessModifiers(propertyDescriptor, 0);\n            }\n            if (!propertyDescriptor.isVar()) {\n                modifiers |= Opcodes.ACC_FINAL;\n            }\n            if(state.getStandardLibrary().isVolatile(propertyDescriptor)) {\n                modifiers |= Opcodes.ACC_VOLATILE;\n            }\n            v.newField(p, modifiers, p.getName(), state.getTypeMapper().mapType(propertyDescriptor.getOutType()).getDescriptor(), null, value);\n        }\n    }","id":97409,"modified_method":"private void generateBackingField(JetProperty p, PropertyDescriptor propertyDescriptor) {\n        if (state.getBindingContext().get(BindingContext.BACKING_FIELD_REQUIRED, propertyDescriptor)) {\n            DeclarationDescriptor containingDeclaration = propertyDescriptor.getContainingDeclaration();\n            if(CodegenUtil.isInterface(containingDeclaration))\n                return;\n\n            Object value = null;\n            final JetExpression initializer = p.getInitializer();\n            if (initializer != null) {\n                if (initializer instanceof JetConstantExpression) {\n                    CompileTimeConstant<?> compileTimeValue = state.getBindingContext().get(BindingContext.COMPILE_TIME_VALUE, initializer);\n                    value = compileTimeValue != null ? compileTimeValue.getValue() : null;\n                }\n            }\n            int modifiers;\n            if (kind == OwnerKind.NAMESPACE) {\n                int access = JetTypeMapper.getAccessModifiers(propertyDescriptor, 0);\n                modifiers = access | Opcodes.ACC_STATIC;\n            }\n            else {\n                modifiers = JetTypeMapper.getAccessModifiers(propertyDescriptor, 0);\n            }\n            if (!propertyDescriptor.isVar()) {\n                modifiers |= Opcodes.ACC_FINAL;\n            }\n            if(state.getStandardLibrary().isVolatile(propertyDescriptor)) {\n                modifiers |= Opcodes.ACC_VOLATILE;\n            }\n            FieldVisitor fieldVisitor = v.newField(p, modifiers, p.getName(), state.getTypeMapper().mapType(propertyDescriptor.getOutType()).getDescriptor(), null, value);\n            AnnotationCodegen.forField(fieldVisitor).genAnnotations(propertyDescriptor, state.getTypeMapper());\n        }\n    }","commit_id":"3578d51cb1b6b9be41ceff7cc49b96284c95ade5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void generateDefaultGetter(PropertyDescriptor propertyDescriptor, int flags, PsiElement origin) {\n        if (kind == OwnerKind.TRAIT_IMPL) {\n            return;\n        }\n\n        if (kind == OwnerKind.NAMESPACE) {\n            flags |= Opcodes.ACC_STATIC;\n        }\n\n        PsiElement psiElement = state.getBindingContext().get(BindingContext.DESCRIPTOR_TO_DECLARATION, propertyDescriptor.getContainingDeclaration());\n        boolean isTrait = psiElement instanceof JetClass && ((JetClass) psiElement).isTrait();\n        if(isTrait && !(kind instanceof OwnerKind.DelegateKind))\n            flags |= Opcodes.ACC_ABSTRACT;\n\n        JvmPropertyAccessorSignature signature = state.getTypeMapper().mapGetterSignature(propertyDescriptor, kind);\n        final String descriptor = signature.getJvmMethodSignature().getAsmMethod().getDescriptor();\n        String getterName = getterName(propertyDescriptor.getName());\n        MethodVisitor mv = v.newMethod(origin, flags, getterName, descriptor, null, null);\n        generateJetPropertyAnnotation(mv, signature.getPropertyTypeKotlinSignature(), signature.getJvmMethodSignature().getKotlinTypeParameter());\n        if (v.generateCode() && (!isTrait || kind instanceof OwnerKind.DelegateKind)) {\n            mv.visitCode();\n            InstructionAdapter iv = new InstructionAdapter(mv);\n            if (kind != OwnerKind.NAMESPACE) {\n                iv.load(0, JetTypeMapper.TYPE_OBJECT);\n            }\n            final Type type = state.getTypeMapper().mapType(propertyDescriptor.getOutType());\n            if (kind instanceof OwnerKind.DelegateKind) {\n                OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;\n                dk.getDelegate().put(JetTypeMapper.TYPE_OBJECT, iv);\n                iv.invokeinterface(dk.getOwnerClass(), getterName, descriptor);\n            }\n            else {\n                iv.visitFieldInsn(kind == OwnerKind.NAMESPACE ? Opcodes.GETSTATIC : Opcodes.GETFIELD,\n                        state.getTypeMapper().getOwner(propertyDescriptor, kind), propertyDescriptor.getName(),\n                        type.getDescriptor());\n            }\n            iv.areturn(type);\n            FunctionCodegen.endVisit(mv, \"getter\", origin);\n        }\n    }","id":97410,"modified_method":"public void generateDefaultGetter(PropertyDescriptor propertyDescriptor, int flags, PsiElement origin) {\n        if (kind == OwnerKind.TRAIT_IMPL) {\n            return;\n        }\n\n        if (kind == OwnerKind.NAMESPACE) {\n            flags |= Opcodes.ACC_STATIC;\n        }\n\n        PsiElement psiElement = state.getBindingContext().get(BindingContext.DESCRIPTOR_TO_DECLARATION, propertyDescriptor.getContainingDeclaration());\n        boolean isTrait = psiElement instanceof JetClass && ((JetClass) psiElement).isTrait();\n        if(isTrait && !(kind instanceof OwnerKind.DelegateKind))\n            flags |= Opcodes.ACC_ABSTRACT;\n\n        JvmPropertyAccessorSignature signature = state.getTypeMapper().mapGetterSignature(propertyDescriptor, kind);\n        final String descriptor = signature.getJvmMethodSignature().getAsmMethod().getDescriptor();\n        String getterName = getterName(propertyDescriptor.getName());\n        MethodVisitor mv = v.newMethod(origin, flags, getterName, descriptor, null, null);\n        generateJetPropertyAnnotation(mv, signature.getPropertyTypeKotlinSignature(), signature.getJvmMethodSignature().getKotlinTypeParameter());\n\n        if(propertyDescriptor.getGetter() != null) {\n            assert !propertyDescriptor.getGetter().hasBody();\n            AnnotationCodegen.forMethod(mv).genAnnotations(propertyDescriptor.getGetter(), state.getTypeMapper());\n        }\n\n        if (v.generateCode() && (!isTrait || kind instanceof OwnerKind.DelegateKind)) {\n            mv.visitCode();\n            InstructionAdapter iv = new InstructionAdapter(mv);\n            if (kind != OwnerKind.NAMESPACE) {\n                iv.load(0, JetTypeMapper.TYPE_OBJECT);\n            }\n            final Type type = state.getTypeMapper().mapType(propertyDescriptor.getOutType());\n            if (kind instanceof OwnerKind.DelegateKind) {\n                OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;\n                dk.getDelegate().put(JetTypeMapper.TYPE_OBJECT, iv);\n                iv.invokeinterface(dk.getOwnerClass(), getterName, descriptor);\n            }\n            else {\n                iv.visitFieldInsn(kind == OwnerKind.NAMESPACE ? Opcodes.GETSTATIC : Opcodes.GETFIELD,\n                        state.getTypeMapper().getOwner(propertyDescriptor, kind), propertyDescriptor.getName(),\n                        type.getDescriptor());\n            }\n            iv.areturn(type);\n            FunctionCodegen.endVisit(mv, \"getter\", origin);\n        }\n    }","commit_id":"3578d51cb1b6b9be41ceff7cc49b96284c95ade5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void generateDefaultSetter(PropertyDescriptor propertyDescriptor, int flags, PsiElement origin) {\n        if (kind == OwnerKind.TRAIT_IMPL) {\n            return;\n        }\n\n        if (kind == OwnerKind.NAMESPACE) {\n            flags |= Opcodes.ACC_STATIC;\n        }\n\n        PsiElement psiElement = state.getBindingContext().get(BindingContext.DESCRIPTOR_TO_DECLARATION, propertyDescriptor.getContainingDeclaration());\n        boolean isTrait = psiElement instanceof JetClass && ((JetClass) psiElement).isTrait();\n        if(isTrait && !(kind instanceof OwnerKind.DelegateKind))\n            flags |= Opcodes.ACC_ABSTRACT;\n\n        JvmPropertyAccessorSignature signature = state.getTypeMapper().mapSetterSignature(propertyDescriptor, kind);\n        final String descriptor = signature.getJvmMethodSignature().getAsmMethod().getDescriptor();\n        MethodVisitor mv = v.newMethod(origin, flags, setterName(propertyDescriptor.getName()), descriptor, null, null);\n        generateJetPropertyAnnotation(mv, signature.getPropertyTypeKotlinSignature(), signature.getJvmMethodSignature().getKotlinTypeParameter());\n        if (v.generateCode() && (!isTrait || kind instanceof OwnerKind.DelegateKind)) {\n            mv.visitCode();\n            InstructionAdapter iv = new InstructionAdapter(mv);\n            final Type type = state.getTypeMapper().mapType(propertyDescriptor.getOutType());\n            int paramCode = 0;\n            if (kind != OwnerKind.NAMESPACE) {\n                iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                paramCode = 1;\n            }\n\n            if (kind instanceof OwnerKind.DelegateKind) {\n                OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;\n                iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                dk.getDelegate().put(JetTypeMapper.TYPE_OBJECT, iv);\n\n                iv.load(paramCode, type);\n                iv.invokeinterface(dk.getOwnerClass(), setterName(propertyDescriptor.getName()), descriptor);\n            }\n            else {\n                iv.load(paramCode, type);\n                iv.visitFieldInsn(kind == OwnerKind.NAMESPACE ? Opcodes.PUTSTATIC : Opcodes.PUTFIELD,\n                        state.getTypeMapper().getOwner(propertyDescriptor, kind), propertyDescriptor.getName(),\n                        type.getDescriptor());\n            }\n\n            iv.visitInsn(Opcodes.RETURN);\n            FunctionCodegen.endVisit(mv, \"setter\", origin);\n            mv.visitEnd();\n        }\n    }","id":97411,"modified_method":"public void generateDefaultSetter(PropertyDescriptor propertyDescriptor, int flags, PsiElement origin) {\n        if (kind == OwnerKind.TRAIT_IMPL) {\n            return;\n        }\n\n        if (kind == OwnerKind.NAMESPACE) {\n            flags |= Opcodes.ACC_STATIC;\n        }\n\n        PsiElement psiElement = state.getBindingContext().get(BindingContext.DESCRIPTOR_TO_DECLARATION, propertyDescriptor.getContainingDeclaration());\n        boolean isTrait = psiElement instanceof JetClass && ((JetClass) psiElement).isTrait();\n        if(isTrait && !(kind instanceof OwnerKind.DelegateKind))\n            flags |= Opcodes.ACC_ABSTRACT;\n\n        JvmPropertyAccessorSignature signature = state.getTypeMapper().mapSetterSignature(propertyDescriptor, kind);\n        final String descriptor = signature.getJvmMethodSignature().getAsmMethod().getDescriptor();\n        MethodVisitor mv = v.newMethod(origin, flags, setterName(propertyDescriptor.getName()), descriptor, null, null);\n        generateJetPropertyAnnotation(mv, signature.getPropertyTypeKotlinSignature(), signature.getJvmMethodSignature().getKotlinTypeParameter());\n\n        if(propertyDescriptor.getSetter() != null) {\n            assert !propertyDescriptor.getSetter().hasBody();\n            AnnotationCodegen.forMethod(mv).genAnnotations(propertyDescriptor.getSetter(), state.getTypeMapper());\n        }\n\n        if (v.generateCode() && (!isTrait || kind instanceof OwnerKind.DelegateKind)) {\n            mv.visitCode();\n            InstructionAdapter iv = new InstructionAdapter(mv);\n            final Type type = state.getTypeMapper().mapType(propertyDescriptor.getOutType());\n            int paramCode = 0;\n            if (kind != OwnerKind.NAMESPACE) {\n                iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                paramCode = 1;\n            }\n\n            if (kind instanceof OwnerKind.DelegateKind) {\n                OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;\n                iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                dk.getDelegate().put(JetTypeMapper.TYPE_OBJECT, iv);\n\n                iv.load(paramCode, type);\n                iv.invokeinterface(dk.getOwnerClass(), setterName(propertyDescriptor.getName()), descriptor);\n            }\n            else {\n                iv.load(paramCode, type);\n                iv.visitFieldInsn(kind == OwnerKind.NAMESPACE ? Opcodes.PUTSTATIC : Opcodes.PUTFIELD,\n                        state.getTypeMapper().getOwner(propertyDescriptor, kind), propertyDescriptor.getName(),\n                        type.getDescriptor());\n            }\n\n            iv.visitInsn(Opcodes.RETURN);\n            FunctionCodegen.endVisit(mv, \"setter\", origin);\n            mv.visitEnd();\n        }\n    }","commit_id":"3578d51cb1b6b9be41ceff7cc49b96284c95ade5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n\tpublic List<Dictionary<String, Object>> getConfigurationsProperties(\n\t\tlong companyId, boolean useDefault) {\n\n\t\tConfiguration configuration = _configurations.get(companyId);\n\n\t\tif ((configuration == null) && useDefault) {\n\t\t\tconfiguration = _configurations.get(CompanyConstants.SYSTEM);\n\t\t}\n\n\t\tList<Dictionary<String, Object>> configurationsProperties =\n\t\t\tnew ArrayList<>();\n\n\t\tif ((configuration == null) && useDefault) {\n\t\t\tconfigurationsProperties.add(\n\t\t\t\tnew HashMapDictionary<String, Object>());\n\t\t}\n\t\telse if (configuration != null) {\n\t\t\tDictionary<String, Object> properties =\n\t\t\t\tconfiguration.getProperties();\n\n\t\t\tconfigurationsProperties.add(properties);\n\t\t}\n\n\t\treturn configurationsProperties;\n\t}","id":97412,"modified_method":"@Override\n\tpublic List<Dictionary<String, Object>> getConfigurationsProperties(\n\t\tlong companyId, boolean useDefault) {\n\n\t\tConfiguration configuration = _configurations.get(companyId);\n\n\t\tif ((configuration == null) && useDefault) {\n\t\t\tconfiguration = _configurations.get(CompanyConstants.SYSTEM);\n\t\t}\n\n\t\tif ((configuration == null) && useDefault) {\n\t\t\treturn Collections.<Dictionary<String, Object>>singletonList(\n\t\t\t\tnew HashMapDictionary<String, Object>());\n\t\t}\n\t\telse if (configuration != null) {\n\t\t\treturn Collections.singletonList(configuration.getProperties());\n\t\t}\n\n\t\treturn Collections.emptyList();\n\t}","commit_id":"5e9b8e758115bea4e9e4723f45ee0da87fb01673","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected int startForkedVM(String workingDirsPath,\n                              String[] args,\n                              String configName,\n                              Object out,\n                              Object err,\n                              String forkMode,\n                              String commandLinePath, List newArgs)\n    throws IOException, InstantiationException, IllegalAccessException, ClassNotFoundException, InterruptedException {\n    args = myForkedDebuggerStarter.excludeDebugPortFromArgs(args);\n\n    final List parameters = new ArrayList();\n    final BufferedReader bufferedReader = new BufferedReader(new FileReader(commandLinePath));\n    final String dynamicClasspath = bufferedReader.readLine();\n    try {\n      String line;\n      while ((line = bufferedReader.readLine()) != null) {\n        parameters.add(line);\n      }\n    }\n    finally {\n      bufferedReader.close();\n    }\n\n    final Object rootDescription = createRootDescription(args, newArgs, configName, out, err);\n    if (rootDescription == null) return -1;\n\n    sendTree(rootDescription);\n\n    long time = System.currentTimeMillis();\n\n    int result = 0;\n    if (workingDirsPath == null || new File(workingDirsPath).length() == 0) {\n       final List children = getChildren(rootDescription);\n       final boolean forkTillMethod = forkMode.equalsIgnoreCase(\"method\");\n       result = processChildren(newArgs, out, err, parameters, children, 0, forkTillMethod, null, System.getProperty(\"java.class.path\"), dynamicClasspath);\n    } else {\n      final BufferedReader perDirReader = new BufferedReader(new FileReader(workingDirsPath));\n      try {\n        final String packageName = perDirReader.readLine();\n        String workingDir;\n        while ((workingDir = perDirReader.readLine()) != null) {\n          final String classpath = perDirReader.readLine();\n          try {\n\n            List classNames = new ArrayList();\n            final int classNamesSize = Integer.parseInt(perDirReader.readLine());\n            for (int i = 0; i < classNamesSize; i++) {\n              String className = perDirReader.readLine();\n              if (className == null) {\n                System.err.println(\"Class name is expected. Working dir: \" + workingDir);\n                return -1;\n              }\n              classNames.add(className);\n            }\n\n            final Object rootDescriptor = findByClassName((String)classNames.get(0), rootDescription);\n            final int childResult;\n            final File dir = new File(workingDir);\n            if (forkMode.equals(\"none\")) {\n              final List childArgs = createChildArgsForClasses(newArgs, packageName, workingDir, classNames, rootDescriptor);\n              childResult = runChild(wrapOutputStream((OutputStream)out),\n                                     wrapOutputStream((OutputStream)err),\n                                     parameters, childArgs, dir, classpath, dynamicClasspath);\n            }\n            else {\n              final List children = new ArrayList(getChildren(rootDescription));\n              for (Iterator iterator = children.iterator(); iterator.hasNext(); ) {\n                if (!classNames.contains(getTestClassName(iterator.next()))) {\n                  iterator.remove();\n                }\n              }\n              final boolean forkTillMethod = forkMode.equalsIgnoreCase(\"method\");\n              childResult = processChildren(newArgs, out, err, parameters, children, result, forkTillMethod, dir, classpath, dynamicClasspath);\n            }\n            result = Math.min(childResult, result);\n          }\n          catch (Exception e) {\n            e.printStackTrace();\n          }\n        }\n      }\n      finally {\n        perDirReader.close();\n      }\n    }\n\n    myForkedDebuggerStarter.closeDebugSocket();\n    sendTime(time);\n    return result;\n  }","id":97413,"modified_method":"public int startForkedVM(String workingDirsPath,\n                           String[] args,\n                           String configName,\n                           Object out,\n                           Object err,\n                           String forkMode,\n                           String commandLinePath, List newArgs) throws Exception {\n    args = myForkedDebuggerStarter.excludeDebugPortFromArgs(args);\n\n    final List parameters = new ArrayList();\n    final BufferedReader bufferedReader = new BufferedReader(new FileReader(commandLinePath));\n    final String dynamicClasspath = bufferedReader.readLine();\n    try {\n      String line;\n      while ((line = bufferedReader.readLine()) != null) {\n        parameters.add(line);\n      }\n    }\n    finally {\n      bufferedReader.close();\n    }\n\n    final Object rootDescription = createRootDescription(args, newArgs, configName, out, err);\n    if (rootDescription == null) return -1;\n\n    sendTree(rootDescription);\n\n    long time = System.currentTimeMillis();\n\n    int result = 0;\n    if (workingDirsPath == null || new File(workingDirsPath).length() == 0) {\n       final List children = getChildren(rootDescription);\n       final boolean forkTillMethod = forkMode.equalsIgnoreCase(\"method\");\n       result = processChildren(newArgs, out, err, parameters, children, 0, forkTillMethod, null, System.getProperty(\"java.class.path\"), dynamicClasspath);\n    } else {\n      final BufferedReader perDirReader = new BufferedReader(new FileReader(workingDirsPath));\n      try {\n        final String packageName = perDirReader.readLine();\n        String workingDir;\n        while ((workingDir = perDirReader.readLine()) != null) {\n          final String classpath = perDirReader.readLine();\n          try {\n\n            List classNames = new ArrayList();\n            final int classNamesSize = Integer.parseInt(perDirReader.readLine());\n            for (int i = 0; i < classNamesSize; i++) {\n              String className = perDirReader.readLine();\n              if (className == null) {\n                System.err.println(\"Class name is expected. Working dir: \" + workingDir);\n                return -1;\n              }\n              classNames.add(className);\n            }\n\n            final Object rootDescriptor = findByClassName((String)classNames.get(0), rootDescription);\n            final int childResult;\n            final File dir = new File(workingDir);\n            if (forkMode.equals(\"none\")) {\n              final List childArgs = createChildArgsForClasses(newArgs, packageName, workingDir, classNames, rootDescriptor);\n              childResult = runChild(wrapOutputStream((OutputStream)out),\n                                     wrapOutputStream((OutputStream)err),\n                                     parameters, childArgs, dir, classpath, dynamicClasspath);\n            }\n            else {\n              final List children = new ArrayList(getChildren(rootDescription));\n              for (Iterator iterator = children.iterator(); iterator.hasNext(); ) {\n                if (!classNames.contains(getTestClassName(iterator.next()))) {\n                  iterator.remove();\n                }\n              }\n              final boolean forkTillMethod = forkMode.equalsIgnoreCase(\"method\");\n              childResult = processChildren(newArgs, out, err, parameters, children, result, forkTillMethod, dir, classpath, dynamicClasspath);\n            }\n            result = Math.min(childResult, result);\n          }\n          catch (Exception e) {\n            e.printStackTrace();\n          }\n        }\n      }\n      finally {\n        perDirReader.close();\n      }\n    }\n\n    myForkedDebuggerStarter.closeDebugSocket();\n    sendTime(time);\n    return result;\n  }","commit_id":"9d6dbbcec92bc6a7777dd8357347c28ea38aab2a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract Object createRootDescription(String[] args, List newArgs, String configName, Object out, Object err)\n    throws InstantiationException, IllegalAccessException, ClassNotFoundException;","id":97414,"modified_method":"protected abstract Object createRootDescription(String[] args, List newArgs, String configName, Object out, Object err) throws Exception;","commit_id":"9d6dbbcec92bc6a7777dd8357347c28ea38aab2a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void startVM(String[] args) throws Exception {\n    final String testOutputPath = args[0];\n    final File file = new File(testOutputPath);\n    if (!file.exists()) {\n      if (!file.createNewFile()) return;\n    }\n    final FileOutputStream stream = new FileOutputStream(testOutputPath);\n    //noinspection UseOfSystemOutOrSystemErr\n    PrintStream oldOut = System.out;\n    //noinspection UseOfSystemOutOrSystemErr\n    PrintStream oldErr = System.err;\n    try {\n      final PrintStream out = new PrintStream(new ForkedVMWrapper(stream, false));\n      final PrintStream err = new PrintStream(new ForkedVMWrapper(stream, true));\n      System.setOut(out);\n      System.setErr(err);\n      startVM(args, out, err);\n    }\n    finally {\n      System.setOut(oldOut);\n      System.setErr(oldErr);\n      stream.close();\n    }\n  }","id":97415,"modified_method":"protected void startVM(String[] args) throws Exception {\n    final String testOutputPath = args[0];\n    final File file = new File(testOutputPath);\n    if (!file.exists()) {\n      if (!file.createNewFile()) return;\n    }\n    final FileOutputStream stream = new FileOutputStream(testOutputPath);\n    //noinspection UseOfSystemOutOrSystemErr\n    PrintStream oldOut = System.out;\n    //noinspection UseOfSystemOutOrSystemErr\n    PrintStream oldErr = System.err;\n    try {\n      final PrintStream out = new PrintStream(new ForkedVMWrapper(stream, false));\n      final PrintStream err = new PrintStream(new ForkedVMWrapper(stream, true));\n      System.setOut(out);\n      System.setErr(err);\n      configureFrameworkAndRun(args, out, err);\n    }\n    finally {\n      System.setOut(oldOut);\n      System.setErr(oldErr);\n      stream.close();\n    }\n  }","commit_id":"9d6dbbcec92bc6a7777dd8357347c28ea38aab2a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int prepareStreamsAndStart(String[] args,\n                                            final boolean isJUnit4,\n                                            ArrayList listeners,\n                                            String name) {\n    PrintStream oldOut = System.out;\n    PrintStream oldErr = System.err;\n    try {\n      IdeaTestRunner testRunner = (IdeaTestRunner)getAgentClass(isJUnit4).newInstance();\n      Object out = SM_RUNNER ? System.out : (Object)new SegmentedOutputStream(System.out);\n      Object err = SM_RUNNER ? System.err : (Object)new SegmentedOutputStream(System.err);\n      if (!SM_RUNNER) {\n        System.setOut(new PrintStream((OutputStream)out));\n        System.setErr(new PrintStream((OutputStream)err));\n      }\n      if (ourCommandFileName != null) {\n        if (!\"none\".equals(ourForkMode) || ourWorkingDirs != null && new File(ourWorkingDirs).length() > 0) {\n          return new JUnitForkedStarter().startForkedVMs(ourWorkingDirs, args, isJUnit4, listeners, name, out, err, ourForkMode, ourCommandFileName);\n        }\n      }\n      testRunner.setStreams(out, err, 0);\n      return testRunner.startRunnerWithArgs(args, listeners, name, ourCount, true);\n    }\n    catch (Exception e) {\n      e.printStackTrace(System.err);\n      return -2;\n    }\n    finally {\n      System.setOut(oldOut);\n      System.setErr(oldErr);\n    }\n  }","id":97416,"modified_method":"private static int prepareStreamsAndStart(String[] args,\n                                            final boolean isJUnit4,\n                                            ArrayList listeners,\n                                            String name) {\n    PrintStream oldOut = System.out;\n    PrintStream oldErr = System.err;\n    try {\n      IdeaTestRunner testRunner = (IdeaTestRunner)getAgentClass(isJUnit4).newInstance();\n      Object out = SM_RUNNER ? System.out : (Object)new SegmentedOutputStream(System.out);\n      Object err = SM_RUNNER ? System.err : (Object)new SegmentedOutputStream(System.err);\n      if (!SM_RUNNER) {\n        System.setOut(new PrintStream((OutputStream)out));\n        System.setErr(new PrintStream((OutputStream)err));\n      }\n      if (ourCommandFileName != null) {\n        if (!\"none\".equals(ourForkMode) || ourWorkingDirs != null && new File(ourWorkingDirs).length() > 0) {\n          final List newArgs = new ArrayList();\n          newArgs.add(String.valueOf(isJUnit4));\n          newArgs.addAll(listeners);\n          return new JUnitForkedStarter().startForkedVM(ourWorkingDirs, args, name, out, err, ourForkMode, ourCommandFileName, newArgs);\n        }\n      }\n      testRunner.setStreams(out, err, 0);\n      return testRunner.startRunnerWithArgs(args, listeners, name, ourCount, true);\n    }\n    catch (Exception e) {\n      e.printStackTrace(System.err);\n      return -2;\n    }\n    finally {\n      System.setOut(oldOut);\n      System.setErr(oldErr);\n    }\n  }","commit_id":"9d6dbbcec92bc6a7777dd8357347c28ea38aab2a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void main(String[] args) throws Exception {\n    int i = 0;\n    String param = null;\n    String commandFileName = null;\n    String workingDirs = null;\n    Vector resultArgs = new Vector();\n    for (; i < args.length; i++) {\n      String arg = args[i];\n      if (arg.startsWith(\"@name\")) {\n        param = arg.substring(5);\n        continue;\n      } else if (arg.startsWith(\"@w@\")) {\n        workingDirs = arg.substring(3);\n        continue;\n      } else if (arg.startsWith(\"@@@\")) {\n        commandFileName = arg.substring(3);\n        continue;\n      }  else if (arg.startsWith(SOCKET)) {\n        final int port = Integer.parseInt(arg.substring(SOCKET.length()));\n        try {\n          final Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), port);  //start collecting tests\n          final DataInputStream os = new DataInputStream(socket.getInputStream());\n          try {\n            os.readBoolean();//wait for ready flag\n          }\n          finally {\n            os.close();\n          }\n        }\n        catch (IOException e) {\n          e.printStackTrace();\n        }\n        continue; //do not add socket to actual params\n      }\n      else if (arg.equals(\"-temp\")) {\n        break;\n      }\n      resultArgs.add(arg);\n    }\n\n    final File temp = new File(args[++i]);\n\n    final BufferedReader reader = new BufferedReader(new FileReader(temp));\n\n    try {\n      final String cantRunMessage = \"CantRunException\";\n      while (true) {\n        String line = reader.readLine();\n        while (line == null) {\n          line = reader.readLine();\n        }\n\n        if (line.startsWith(cantRunMessage) && !new File(line).exists()){\n          System.err.println(line.substring(cantRunMessage.length()));\n          while (true) {\n            line = reader.readLine();\n            if (line == null || line.equals(\"end\")) break;\n            System.err.println(line);\n          }\n          System.exit(1);\n          return;\n        }\n        if (line.equals(\"end\")) break;\n        resultArgs.add(line);\n      }\n    }\n    finally {\n      reader.close();\n    }\n\n    if (SM_RUNNER) {\n      if (commandFileName != null) {\n        if (workingDirs != null && new File(workingDirs).length() > 0) {\n          System.exit(new TestNGForkedStarter().startForkedVMs(workingDirs, args, param, System.out, System.err, commandFileName));\n          return;\n        }\n      }\n      final IDEARemoteTestNG testNG = new IDEARemoteTestNG(param);\n      CommandLineArgs cla = new CommandLineArgs();\n      RemoteArgs ra = new RemoteArgs();\n      new JCommander(Arrays.asList(cla, ra), (String[])resultArgs.toArray(new String[resultArgs.size()]));\n      testNG.configure(cla);\n      testNG.run();\n      return;\n    }\n\n    try {\n      //testng 5.10 do not initialize xml suites before run in normal main call => No test suite found.\n      //revert \"cleanup\" to set suites manually again, this time for old versions only\n      final Class aClass = Class.forName(\"org.testng.TestNGCommandLineArgs\");\n      final Method parseCommandLineMethod = aClass.getDeclaredMethod(\"parseCommandLine\", new Class[] {new String[0].getClass()});\n      final Map commandLineArgs = (Map)parseCommandLineMethod.invoke(null, new Object[] {(String[])resultArgs.toArray(new String[resultArgs.size()])});\n      final RemoteTestNG testNG = new RemoteTestNG();\n      testNG.configure(commandLineArgs);\n      //set suites manually\n      testNG.initializeSuitesAndJarFile();\n      //in order to prevent suites to be initialized twice (second time in run)\n      //clear string suites here\n      testNG.setTestSuites(new ArrayList());\n      testNG.run();\n      return;\n    }\n    catch (Throwable ignore) {}\n\n    RemoteTestNG.main((String[])resultArgs.toArray(new String[resultArgs.size()]));\n  }","id":97417,"modified_method":"public static void main(String[] args) throws Exception {\n    int i = 0;\n    String param = null;\n    String commandFileName = null;\n    String workingDirs = null;\n    Vector resultArgs = new Vector();\n    for (; i < args.length; i++) {\n      String arg = args[i];\n      if (arg.startsWith(\"@name\")) {\n        param = arg.substring(5);\n        continue;\n      } else if (arg.startsWith(\"@w@\")) {\n        workingDirs = arg.substring(3);\n        continue;\n      } else if (arg.startsWith(\"@@@\")) {\n        commandFileName = arg.substring(3);\n        continue;\n      }  else if (arg.startsWith(SOCKET)) {\n        final int port = Integer.parseInt(arg.substring(SOCKET.length()));\n        try {\n          final Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), port);  //start collecting tests\n          final DataInputStream os = new DataInputStream(socket.getInputStream());\n          try {\n            os.readBoolean();//wait for ready flag\n          }\n          finally {\n            os.close();\n          }\n        }\n        catch (IOException e) {\n          e.printStackTrace();\n        }\n        continue; //do not add socket to actual params\n      }\n      else if (arg.equals(\"-temp\")) {\n        break;\n      }\n      resultArgs.add(arg);\n    }\n\n    final File temp = new File(args[++i]);\n\n    final BufferedReader reader = new BufferedReader(new FileReader(temp));\n\n    try {\n      final String cantRunMessage = \"CantRunException\";\n      while (true) {\n        String line = reader.readLine();\n        while (line == null) {\n          line = reader.readLine();\n        }\n\n        if (line.startsWith(cantRunMessage) && !new File(line).exists()){\n          System.err.println(line.substring(cantRunMessage.length()));\n          while (true) {\n            line = reader.readLine();\n            if (line == null || line.equals(\"end\")) break;\n            System.err.println(line);\n          }\n          System.exit(1);\n          return;\n        }\n        if (line.equals(\"end\")) break;\n        resultArgs.add(line);\n      }\n    }\n    finally {\n      reader.close();\n    }\n\n    if (SM_RUNNER) {\n      if (commandFileName != null) {\n        if (workingDirs != null && new File(workingDirs).length() > 0) {\n          System.exit(new TestNGForkedStarter()\n                        .startForkedVM(workingDirs, args, param, System.out, System.err, \"none\", commandFileName, Collections.emptyList()));\n          return;\n        }\n      }\n      final IDEARemoteTestNG testNG = new IDEARemoteTestNG(param);\n      CommandLineArgs cla = new CommandLineArgs();\n      RemoteArgs ra = new RemoteArgs();\n      new JCommander(Arrays.asList(cla, ra), (String[])resultArgs.toArray(new String[resultArgs.size()]));\n      testNG.configure(cla);\n      testNG.run();\n      return;\n    }\n\n    try {\n      //testng 5.10 do not initialize xml suites before run in normal main call => No test suite found.\n      //revert \"cleanup\" to set suites manually again, this time for old versions only\n      final Class aClass = Class.forName(\"org.testng.TestNGCommandLineArgs\");\n      final Method parseCommandLineMethod = aClass.getDeclaredMethod(\"parseCommandLine\", new Class[] {new String[0].getClass()});\n      final Map commandLineArgs = (Map)parseCommandLineMethod.invoke(null, new Object[] {(String[])resultArgs.toArray(new String[resultArgs.size()])});\n      final RemoteTestNG testNG = new RemoteTestNG();\n      testNG.configure(commandLineArgs);\n      //set suites manually\n      testNG.initializeSuitesAndJarFile();\n      //in order to prevent suites to be initialized twice (second time in run)\n      //clear string suites here\n      testNG.setTestSuites(new ArrayList());\n      testNG.run();\n      return;\n    }\n    catch (Throwable ignore) {}\n\n    RemoteTestNG.main((String[])resultArgs.toArray(new String[resultArgs.size()]));\n  }","commit_id":"9d6dbbcec92bc6a7777dd8357347c28ea38aab2a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected List createChildArgsForClasses(List newArgs, String packageName, String workingDir, List classNames, Object rootDescriptor)\n    throws IOException {\n    final LinkedHashMap<String, Map<String, List<String>>> classes = new LinkedHashMap<String, Map<String, List<String>>>();\n    for (Object className : classNames) {\n      classes.put((String)className, null);\n    }\n    final File file =\n      TestNGXmlSuiteHelper.writeSuite(classes, new LinkedHashMap<String, String>(), \"testName\", null,\n                                      TestNGXmlSuiteHelper.Logger.DEAF);\n    file.deleteOnExit();\n    \n    final List childArgs = new ArrayList();\n    childArgs.add(file.getAbsolutePath());\n    \n    return childArgs;\n  }","id":97418,"modified_method":"@Override\n  protected List createChildArgsForClasses(List newArgs, String packageName, String workingDir, List classNames, Object rootDescriptor)\n    throws IOException {\n    final LinkedHashMap<String, Map<String, List<String>>> classes = new LinkedHashMap<String, Map<String, List<String>>>();\n    for (Object className : classNames) {\n      classes.put((String)className, null);\n    }\n    final File file =\n      TestNGXmlSuiteHelper.writeSuite(classes, new LinkedHashMap<String, String>(), \"testName\", null,\n                                      TestNGXmlSuiteHelper.Logger.DEAF);\n    file.deleteOnExit();\n    \n    return Collections.singletonList(file.getAbsolutePath());\n  }","commit_id":"9d6dbbcec92bc6a7777dd8357347c28ea38aab2a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void main(String[] args) throws Exception {\n    System.out.println(\"started\");\n    new TestNGForkedStarter().startVM(args);\n  }","id":97419,"modified_method":"public static void main(String[] args) throws Exception {\n    new TestNGForkedStarter().startVM(args);\n  }","commit_id":"9d6dbbcec92bc6a7777dd8357347c28ea38aab2a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized Compute client() {\n        if (refreshInterval != null && refreshInterval.millis() != 0) {\n            if (client != null &&\n                    (refreshInterval.millis() < 0 || (System.currentTimeMillis() - lastRefresh) < refreshInterval.millis())) {\n                if (logger.isTraceEnabled()) logger.trace(\"using cache to retrieve client\");\n                return client;\n            }\n            lastRefresh = System.currentTimeMillis();\n        }\n\n        try {\n            gceJsonFactory = new JacksonFactory();\n\n            logger.info(\"starting GCE discovery service\");\n            ComputeCredential credential = new ComputeCredential.Builder(getGceHttpTransport(), gceJsonFactory)\n                    .setTokenServerEncodedUrl(TOKEN_SERVER_ENCODED_URL)\n                    .build();\n\n            // hack around code messiness in GCE code\n            // TODO: get this fixed\n            SecurityManager sm = System.getSecurityManager();\n            if (sm != null) {\n                sm.checkPermission(new SpecialPermission());\n            }\n            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {\n                @Override\n                public Void run() throws IOException {\n                    credential.refreshToken();\n                    return null;\n                }\n            });\n\n            logger.debug(\"token [{}] will expire in [{}] s\", credential.getAccessToken(), credential.getExpiresInSeconds());\n            if (credential.getExpiresInSeconds() != null) {\n                refreshInterval = TimeValue.timeValueSeconds(credential.getExpiresInSeconds() - 1);\n            }\n\n            boolean ifRetry = settings.getAsBoolean(Fields.RETRY, true);\n            Compute.Builder builder = new Compute.Builder(getGceHttpTransport(), gceJsonFactory, null)\n                    .setApplicationName(Fields.VERSION);\n\n            if (ifRetry) {\n                int maxWait = settings.getAsInt(Fields.MAXWAIT, -1);\n                RetryHttpInitializerWrapper retryHttpInitializerWrapper;\n\n                if (maxWait > 0) {\n                    retryHttpInitializerWrapper = new RetryHttpInitializerWrapper(credential, maxWait);\n                } else {\n                    retryHttpInitializerWrapper = new RetryHttpInitializerWrapper(credential);\n                }\n                builder.setHttpRequestInitializer(retryHttpInitializerWrapper);\n\n            } else {\n                builder.setHttpRequestInitializer(credential);\n            }\n\n            this.client = builder.build();\n        } catch (Exception e) {\n            logger.warn(\"unable to start GCE discovery service\", e);\n            throw new IllegalArgumentException(\"unable to start GCE discovery service\", e);\n        }\n\n        return this.client;\n    }","id":97420,"modified_method":"public synchronized Compute client() {\n        if (refreshInterval != null && refreshInterval.millis() != 0) {\n            if (client != null &&\n                    (refreshInterval.millis() < 0 || (System.currentTimeMillis() - lastRefresh) < refreshInterval.millis())) {\n                if (logger.isTraceEnabled()) logger.trace(\"using cache to retrieve client\");\n                return client;\n            }\n            lastRefresh = System.currentTimeMillis();\n        }\n\n        try {\n            gceJsonFactory = new JacksonFactory();\n\n            logger.info(\"starting GCE discovery service\");\n            ComputeCredential credential = new ComputeCredential.Builder(getGceHttpTransport(), gceJsonFactory)\n                    .setTokenServerEncodedUrl(TOKEN_SERVER_ENCODED_URL)\n                    .build();\n\n            // hack around code messiness in GCE code\n            // TODO: get this fixed\n            SecurityManager sm = System.getSecurityManager();\n            if (sm != null) {\n                sm.checkPermission(new SpecialPermission());\n            }\n            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {\n                @Override\n                public Void run() throws IOException {\n                    credential.refreshToken();\n                    return null;\n                }\n            });\n\n            logger.debug(\"token [{}] will expire in [{}] s\", credential.getAccessToken(), credential.getExpiresInSeconds());\n            if (credential.getExpiresInSeconds() != null) {\n                refreshInterval = TimeValue.timeValueSeconds(credential.getExpiresInSeconds() - 1);\n            }\n\n            Compute.Builder builder = new Compute.Builder(getGceHttpTransport(), gceJsonFactory, null).setApplicationName(VERSION);\n\n            if (RETRY_SETTING.exists(settings)) {\n                TimeValue maxWait = MAX_WAIT_SETTING.get(settings);\n                RetryHttpInitializerWrapper retryHttpInitializerWrapper;\n\n                if (maxWait.getMillis() > 0) {\n                    retryHttpInitializerWrapper = new RetryHttpInitializerWrapper(credential, maxWait);\n                } else {\n                    retryHttpInitializerWrapper = new RetryHttpInitializerWrapper(credential);\n                }\n                builder.setHttpRequestInitializer(retryHttpInitializerWrapper);\n\n            } else {\n                builder.setHttpRequestInitializer(credential);\n            }\n\n            this.client = builder.build();\n        } catch (Exception e) {\n            logger.warn(\"unable to start GCE discovery service\", e);\n            throw new IllegalArgumentException(\"unable to start GCE discovery service\", e);\n        }\n\n        return this.client;\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public GceComputeServiceImpl(Settings settings, NetworkService networkService) {\n        super(settings);\n        this.project = settings.get(Fields.PROJECT);\n        String[] zoneList = settings.getAsArray(Fields.ZONE);\n        this.zones = Arrays.asList(zoneList);\n        networkService.addCustomNameResolver(new GceNameResolver(settings, this));\n    }","id":97421,"modified_method":"@Inject\n    public GceComputeServiceImpl(Settings settings, NetworkService networkService) {\n        super(settings);\n        this.project = PROJECT_SETTING.get(settings);\n        this.zones = ZONE_SETTING.get(settings);\n        networkService.addCustomNameResolver(new GceNameResolver(settings, this));\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Collection<Module> nodeModules() {\n        List<Module> modules = new ArrayList<>();\n        if (isDiscoveryAlive(settings, logger)) {\n            modules.add(new GceModule());\n        }\n        return modules;\n    }","id":97422,"modified_method":"@Override\n    public Collection<Module> nodeModules() {\n        return Collections.singletonList(new GceModule());\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    @SuppressWarnings(\"rawtypes\") // Supertype uses raw type\n    public Collection<Class<? extends LifecycleComponent>> nodeServices() {\n        Collection<Class<? extends LifecycleComponent>> services = new ArrayList<>();\n        if (isDiscoveryAlive(settings, logger)) {\n            services.add(GceModule.getComputeServiceImpl());\n        }\n        return services;\n    }","id":97423,"modified_method":"@Override\n    @SuppressWarnings(\"rawtypes\") // Supertype uses raw type\n    public Collection<Class<? extends LifecycleComponent>> nodeServices() {\n        return Collections.singletonList(GceModule.getComputeServiceImpl());\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void onModule(DiscoveryModule discoveryModule) {\n        if (isDiscoveryAlive(settings, logger)) {\n            discoveryModule.addDiscoveryType(\"gce\", GceDiscovery.class);\n            discoveryModule.addUnicastHostProvider(GceUnicastHostsProvider.class);\n        }\n    }","id":97424,"modified_method":"public void onModule(DiscoveryModule discoveryModule) {\n        discoveryModule.addDiscoveryType(\"gce\", GceDiscovery.class);\n        // If discovery.type: gce, we add Gce as a unicast provider\n        if (GceDiscovery.GCE.equalsIgnoreCase(DiscoveryModule.DISCOVERY_TYPE_SETTING.get(settings))) {\n            discoveryModule.addUnicastHostProvider(GceUnicastHostsProvider.class);\n        }\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testNodesWithSameTagsAndNoTagSet() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.Fields.PROJECT, projectName)\n                .put(GceComputeService.Fields.ZONE, \"europe-west1-b\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(2));\n    }","id":97425,"modified_method":"public void testNodesWithSameTagsAndNoTagSet() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.PROJECT_SETTING.getKey(), projectName)\n                .put(GceComputeService.ZONE_SETTING.getKey(), \"europe-west1-b\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(2));\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testNodesWithSameTagsAndOneTagSet() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.Fields.PROJECT, projectName)\n                .put(GceComputeService.Fields.ZONE, \"europe-west1-b\")\n                .putArray(GceComputeService.Fields.TAGS, \"elasticsearch\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(2));\n    }","id":97426,"modified_method":"public void testNodesWithSameTagsAndOneTagSet() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.PROJECT_SETTING.getKey(), projectName)\n                .put(GceComputeService.ZONE_SETTING.getKey(), \"europe-west1-b\")\n                .putArray(GceDiscovery.TAGS_SETTING.getKey(), \"elasticsearch\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(2));\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testMultipleZonesAndTwoNodesInSameZone() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.Fields.PROJECT, projectName)\n                .putArray(GceComputeService.Fields.ZONE, \"us-central1-a\", \"europe-west1-b\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(2));\n    }","id":97427,"modified_method":"public void testMultipleZonesAndTwoNodesInSameZone() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.PROJECT_SETTING.getKey(), projectName)\n                .putArray(GceComputeService.ZONE_SETTING.getKey(), \"us-central1-a\", \"europe-west1-b\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(2));\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testNodesWithDifferentTagsAndTwoTagSet() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.Fields.PROJECT, projectName)\n                .put(GceComputeService.Fields.ZONE, \"europe-west1-b\")\n                .putArray(GceComputeService.Fields.TAGS, \"elasticsearch\", \"dev\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(1));\n        assertThat(discoveryNodes.get(0).getId(), is(\"#cloud-test2-0\"));\n    }","id":97428,"modified_method":"public void testNodesWithDifferentTagsAndTwoTagSet() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.PROJECT_SETTING.getKey(), projectName)\n                .put(GceComputeService.ZONE_SETTING.getKey(), \"europe-west1-b\")\n                .putArray(GceDiscovery.TAGS_SETTING.getKey(), \"elasticsearch\", \"dev\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(1));\n        assertThat(discoveryNodes.get(0).getId(), is(\"#cloud-test2-0\"));\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testMultipleZonesAndTwoNodesInDifferentZones() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.Fields.PROJECT, projectName)\n                .putArray(GceComputeService.Fields.ZONE, \"us-central1-a\", \"europe-west1-b\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(2));\n    }","id":97429,"modified_method":"public void testMultipleZonesAndTwoNodesInDifferentZones() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.PROJECT_SETTING.getKey(), projectName)\n                .putArray(GceComputeService.ZONE_SETTING.getKey(), \"us-central1-a\", \"europe-west1-b\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(2));\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * For issue https://github.com/elastic/elasticsearch-cloud-gce/issues/43\n     */\n    public void testZeroNode43() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.Fields.PROJECT, projectName)\n                .putArray(GceComputeService.Fields.ZONE, \"us-central1-a\", \"us-central1-b\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(0));\n    }","id":97430,"modified_method":"/**\n     * For issue https://github.com/elastic/elasticsearch-cloud-gce/issues/43\n     */\n    public void testZeroNode43() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.PROJECT_SETTING.getKey(), projectName)\n                .putArray(GceComputeService.ZONE_SETTING.getKey(), \"us-central1-a\", \"us-central1-b\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(0));\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testNodesWithDifferentTagsAndNoTagSet() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.Fields.PROJECT, projectName)\n                .put(GceComputeService.Fields.ZONE, \"europe-west1-b\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(2));\n    }","id":97431,"modified_method":"public void testNodesWithDifferentTagsAndNoTagSet() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.PROJECT_SETTING.getKey(), projectName)\n                .put(GceComputeService.ZONE_SETTING.getKey(), \"europe-west1-b\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(2));\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testNodesWithDifferentTagsAndOneTagSet() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.Fields.PROJECT, projectName)\n                .put(GceComputeService.Fields.ZONE, \"europe-west1-b\")\n                .putArray(GceComputeService.Fields.TAGS, \"elasticsearch\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(1));\n        assertThat(discoveryNodes.get(0).getId(), is(\"#cloud-test2-0\"));\n    }","id":97432,"modified_method":"public void testNodesWithDifferentTagsAndOneTagSet() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.PROJECT_SETTING.getKey(), projectName)\n                .put(GceComputeService.ZONE_SETTING.getKey(), \"europe-west1-b\")\n                .putArray(GceDiscovery.TAGS_SETTING.getKey(), \"elasticsearch\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(1));\n        assertThat(discoveryNodes.get(0).getId(), is(\"#cloud-test2-0\"));\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testNodesWithSameTagsAndTwoTagsSet() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.Fields.PROJECT, projectName)\n                .put(GceComputeService.Fields.ZONE, \"europe-west1-b\")\n                .putArray(GceComputeService.Fields.TAGS, \"elasticsearch\", \"dev\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(2));\n    }","id":97433,"modified_method":"public void testNodesWithSameTagsAndTwoTagsSet() {\n        Settings nodeSettings = Settings.builder()\n                .put(GceComputeService.PROJECT_SETTING.getKey(), projectName)\n                .put(GceComputeService.ZONE_SETTING.getKey(), \"europe-west1-b\")\n                .putArray(GceDiscovery.TAGS_SETTING.getKey(), \"elasticsearch\", \"dev\")\n                .build();\n        mock = new GceComputeServiceMock(nodeSettings, networkService);\n        List<DiscoveryNode> discoveryNodes = buildDynamicNodes(mock, nodeSettings);\n        assertThat(discoveryNodes, hasSize(2));\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * We build the list of Nodes from GCE Management API\n     * Information can be cached using `plugins.refresh_interval` property if needed.\n     * Setting `plugins.refresh_interval` to `-1` will cause infinite caching.\n     * Setting `plugins.refresh_interval` to `0` will disable caching (default).\n     */\n    @Override\n    public List<DiscoveryNode> buildDynamicNodes() {\n        if (refreshInterval.millis() != 0) {\n            if (cachedDiscoNodes != null &&\n                    (refreshInterval.millis() < 0 || (System.currentTimeMillis() - lastRefresh) < refreshInterval.millis())) {\n                if (logger.isTraceEnabled()) logger.trace(\"using cache to retrieve node list\");\n                return cachedDiscoNodes;\n            }\n            lastRefresh = System.currentTimeMillis();\n        }\n        logger.debug(\"start building nodes list using GCE API\");\n\n        cachedDiscoNodes = new ArrayList<>();\n        String ipAddress = null;\n        try {\n            InetAddress inetAddress = networkService.resolvePublishHostAddresses(null);\n            if (inetAddress != null) {\n                ipAddress = NetworkAddress.formatAddress(inetAddress);\n            }\n        } catch (IOException e) {\n            // We can't find the publish host address... Hmmm. Too bad :-(\n            // We won't simply filter it\n        }\n\n        try {\n            Collection<Instance> instances = gceComputeService.instances();\n\n            if (instances == null) {\n                logger.trace(\"no instance found for project [{}], zones [{}].\", this.project, this.zones);\n                return cachedDiscoNodes;\n            }\n\n            for (Instance instance : instances) {\n                String name = instance.getName();\n                String type = instance.getMachineType();\n\n                String status = instance.getStatus();\n                logger.trace(\"gce instance {} with status {} found.\", name, status);\n\n                // We don't want to connect to TERMINATED status instances\n                // See https://github.com/elasticsearch/elasticsearch-cloud-gce/issues/3\n                if (Status.TERMINATED.equals(status)) {\n                    logger.debug(\"node {} is TERMINATED. Ignoring\", name);\n                    continue;\n                }\n\n                // see if we need to filter by tag\n                boolean filterByTag = false;\n                if (tags.length > 0) {\n                    logger.trace(\"start filtering instance {} with tags {}.\", name, tags);\n                    if (instance.getTags() == null || instance.getTags().isEmpty()\n                            || instance.getTags().getItems() == null || instance.getTags().getItems().isEmpty()) {\n                        // If this instance have no tag, we filter it\n                        logger.trace(\"no tags for this instance but we asked for tags. {} won't be part of the cluster.\", name);\n                        filterByTag = true;\n                    } else {\n                        // check that all tags listed are there on the instance\n                        logger.trace(\"comparing instance tags {} with tags filter {}.\", instance.getTags().getItems(), tags);\n                        for (String tag : tags) {\n                            boolean found = false;\n                            for (String instancetag : instance.getTags().getItems()) {\n                                if (instancetag.equals(tag)) {\n                                    found = true;\n                                    break;\n                                }\n                            }\n                            if (!found) {\n                                filterByTag = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (filterByTag) {\n                    logger.trace(\"filtering out instance {} based tags {}, not part of {}\", name, tags,\n                            instance.getTags() == null || instance.getTags().getItems() == null ? \"\" : instance.getTags());\n                    continue;\n                } else {\n                    logger.trace(\"instance {} with tags {} is added to discovery\", name, tags);\n                }\n\n                String ip_public = null;\n                String ip_private = null;\n\n                List<NetworkInterface> interfaces = instance.getNetworkInterfaces();\n\n                for (NetworkInterface networkInterface : interfaces) {\n                    if (ip_public == null) {\n                        // Trying to get Public IP Address (For future use)\n                        if (networkInterface.getAccessConfigs() != null) {\n                            for (AccessConfig accessConfig : networkInterface.getAccessConfigs()) {\n                                if (Strings.hasText(accessConfig.getNatIP())) {\n                                    ip_public = accessConfig.getNatIP();\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if (ip_private == null) {\n                        ip_private = networkInterface.getNetworkIP();\n                    }\n\n                    // If we have both public and private, we can stop here\n                    if (ip_private != null && ip_public != null) break;\n                }\n\n                try {\n                    if (ip_private.equals(ipAddress)) {\n                        // We found the current node.\n                        // We can ignore it in the list of DiscoveryNode\n                        logger.trace(\"current node found. Ignoring {} - {}\", name, ip_private);\n                    } else {\n                        String address = ip_private;\n                        // Test if we have es_port metadata defined here\n                        if (instance.getMetadata() != null && instance.getMetadata().containsKey(\"es_port\")) {\n                            Object es_port = instance.getMetadata().get(\"es_port\");\n                            logger.trace(\"es_port is defined with {}\", es_port);\n                            if (es_port instanceof String) {\n                                address = address.concat(\":\").concat((String) es_port);\n                            } else {\n                                // Ignoring other values\n                                logger.trace(\"es_port is instance of {}. Ignoring...\", es_port.getClass().getName());\n                            }\n                        }\n\n                        // ip_private is a single IP Address. We need to build a TransportAddress from it\n                        // If user has set `es_port` metadata, we don't need to ping all ports\n                        // we only limit to 1 addresses, makes no sense to ping 100 ports\n                        TransportAddress[] addresses = transportService.addressesFromString(address, 1);\n\n                        for (TransportAddress transportAddress : addresses) {\n                            logger.trace(\"adding {}, type {}, address {}, transport_address {}, status {}\", name, type,\n                                    ip_private, transportAddress, status);\n                            cachedDiscoNodes.add(new DiscoveryNode(\"#cloud-\" + name + \"-\" + 0, transportAddress, version.minimumCompatibilityVersion()));\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.warn(\"failed to add {}, address {}\", e, name, ip_private);\n                }\n\n            }\n        } catch (Throwable e) {\n            logger.warn(\"Exception caught during discovery: {}\", e, e.getMessage());\n        }\n\n        logger.debug(\"{} node(s) added\", cachedDiscoNodes.size());\n        logger.debug(\"using dynamic discovery nodes {}\", cachedDiscoNodes);\n\n        return cachedDiscoNodes;\n    }","id":97434,"modified_method":"/**\n     * We build the list of Nodes from GCE Management API\n     * Information can be cached using `cloud.gce.refresh_interval` property if needed.\n     */\n    @Override\n    public List<DiscoveryNode> buildDynamicNodes() {\n        // We check that needed properties have been set\n        if (this.project == null || this.project.isEmpty() || this.zones == null || this.zones.isEmpty()) {\n            throw new IllegalArgumentException(\"one or more gce discovery settings are missing. \" +\n                \"Check elasticsearch.yml file. Should have [\" + GceComputeService.PROJECT_SETTING.getKey() +\n                \"] and [\" + GceComputeService.ZONE_SETTING.getKey() + \"].\");\n        }\n\n        if (refreshInterval.millis() != 0) {\n            if (cachedDiscoNodes != null &&\n                    (refreshInterval.millis() < 0 || (System.currentTimeMillis() - lastRefresh) < refreshInterval.millis())) {\n                if (logger.isTraceEnabled()) logger.trace(\"using cache to retrieve node list\");\n                return cachedDiscoNodes;\n            }\n            lastRefresh = System.currentTimeMillis();\n        }\n        logger.debug(\"start building nodes list using GCE API\");\n\n        cachedDiscoNodes = new ArrayList<>();\n        String ipAddress = null;\n        try {\n            InetAddress inetAddress = networkService.resolvePublishHostAddresses(null);\n            if (inetAddress != null) {\n                ipAddress = NetworkAddress.formatAddress(inetAddress);\n            }\n        } catch (IOException e) {\n            // We can't find the publish host address... Hmmm. Too bad :-(\n            // We won't simply filter it\n        }\n\n        try {\n            Collection<Instance> instances = gceComputeService.instances();\n\n            if (instances == null) {\n                logger.trace(\"no instance found for project [{}], zones [{}].\", this.project, this.zones);\n                return cachedDiscoNodes;\n            }\n\n            for (Instance instance : instances) {\n                String name = instance.getName();\n                String type = instance.getMachineType();\n\n                String status = instance.getStatus();\n                logger.trace(\"gce instance {} with status {} found.\", name, status);\n\n                // We don't want to connect to TERMINATED status instances\n                // See https://github.com/elasticsearch/elasticsearch-cloud-gce/issues/3\n                if (Status.TERMINATED.equals(status)) {\n                    logger.debug(\"node {} is TERMINATED. Ignoring\", name);\n                    continue;\n                }\n\n                // see if we need to filter by tag\n                boolean filterByTag = false;\n                if (tags.isEmpty() == false) {\n                    logger.trace(\"start filtering instance {} with tags {}.\", name, tags);\n                    if (instance.getTags() == null || instance.getTags().isEmpty()\n                            || instance.getTags().getItems() == null || instance.getTags().getItems().isEmpty()) {\n                        // If this instance have no tag, we filter it\n                        logger.trace(\"no tags for this instance but we asked for tags. {} won't be part of the cluster.\", name);\n                        filterByTag = true;\n                    } else {\n                        // check that all tags listed are there on the instance\n                        logger.trace(\"comparing instance tags {} with tags filter {}.\", instance.getTags().getItems(), tags);\n                        for (String tag : tags) {\n                            boolean found = false;\n                            for (String instancetag : instance.getTags().getItems()) {\n                                if (instancetag.equals(tag)) {\n                                    found = true;\n                                    break;\n                                }\n                            }\n                            if (!found) {\n                                filterByTag = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (filterByTag) {\n                    logger.trace(\"filtering out instance {} based tags {}, not part of {}\", name, tags,\n                            instance.getTags() == null || instance.getTags().getItems() == null ? \"\" : instance.getTags());\n                    continue;\n                } else {\n                    logger.trace(\"instance {} with tags {} is added to discovery\", name, tags);\n                }\n\n                String ip_public = null;\n                String ip_private = null;\n\n                List<NetworkInterface> interfaces = instance.getNetworkInterfaces();\n\n                for (NetworkInterface networkInterface : interfaces) {\n                    if (ip_public == null) {\n                        // Trying to get Public IP Address (For future use)\n                        if (networkInterface.getAccessConfigs() != null) {\n                            for (AccessConfig accessConfig : networkInterface.getAccessConfigs()) {\n                                if (Strings.hasText(accessConfig.getNatIP())) {\n                                    ip_public = accessConfig.getNatIP();\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if (ip_private == null) {\n                        ip_private = networkInterface.getNetworkIP();\n                    }\n\n                    // If we have both public and private, we can stop here\n                    if (ip_private != null && ip_public != null) break;\n                }\n\n                try {\n                    if (ip_private.equals(ipAddress)) {\n                        // We found the current node.\n                        // We can ignore it in the list of DiscoveryNode\n                        logger.trace(\"current node found. Ignoring {} - {}\", name, ip_private);\n                    } else {\n                        String address = ip_private;\n                        // Test if we have es_port metadata defined here\n                        if (instance.getMetadata() != null && instance.getMetadata().containsKey(\"es_port\")) {\n                            Object es_port = instance.getMetadata().get(\"es_port\");\n                            logger.trace(\"es_port is defined with {}\", es_port);\n                            if (es_port instanceof String) {\n                                address = address.concat(\":\").concat((String) es_port);\n                            } else {\n                                // Ignoring other values\n                                logger.trace(\"es_port is instance of {}. Ignoring...\", es_port.getClass().getName());\n                            }\n                        }\n\n                        // ip_private is a single IP Address. We need to build a TransportAddress from it\n                        // If user has set `es_port` metadata, we don't need to ping all ports\n                        // we only limit to 1 addresses, makes no sense to ping 100 ports\n                        TransportAddress[] addresses = transportService.addressesFromString(address, 1);\n\n                        for (TransportAddress transportAddress : addresses) {\n                            logger.trace(\"adding {}, type {}, address {}, transport_address {}, status {}\", name, type,\n                                    ip_private, transportAddress, status);\n                            cachedDiscoNodes.add(new DiscoveryNode(\"#cloud-\" + name + \"-\" + 0, transportAddress, version.minimumCompatibilityVersion()));\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.warn(\"failed to add {}, address {}\", e, name, ip_private);\n                }\n\n            }\n        } catch (Throwable e) {\n            logger.warn(\"Exception caught during discovery: {}\", e, e.getMessage());\n        }\n\n        logger.debug(\"{} node(s) added\", cachedDiscoNodes.size());\n        logger.debug(\"using dynamic discovery nodes {}\", cachedDiscoNodes);\n\n        return cachedDiscoNodes;\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public GceUnicastHostsProvider(Settings settings, GceComputeService gceComputeService,\n            TransportService transportService,\n            NetworkService networkService,\n            Version version) {\n        super(settings);\n        this.gceComputeService = gceComputeService;\n        this.transportService = transportService;\n        this.networkService = networkService;\n        this.version = version;\n\n        this.refreshInterval = settings.getAsTime(Fields.REFRESH, TimeValue.timeValueSeconds(0));\n        this.project = settings.get(Fields.PROJECT);\n        this.zones = settings.getAsArray(Fields.ZONE);\n\n        this.tags = settings.getAsArray(Fields.TAGS);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"using tags {}\", Arrays.asList(this.tags));\n        }\n    }","id":97435,"modified_method":"@Inject\n    public GceUnicastHostsProvider(Settings settings, GceComputeService gceComputeService,\n            TransportService transportService,\n            NetworkService networkService,\n            Version version) {\n        super(settings);\n        this.gceComputeService = gceComputeService;\n        this.transportService = transportService;\n        this.networkService = networkService;\n        this.version = version;\n\n        this.refreshInterval = GceComputeService.REFRESH_SETTING.get(settings);\n        this.project = GceComputeService.PROJECT_SETTING.get(settings);\n        this.zones = GceComputeService.ZONE_SETTING.get(settings);\n\n        this.tags = GceDiscovery.TAGS_SETTING.get(settings);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"using tags {}\", this.tags);\n        }\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public RetryHttpInitializerWrapper(Credential wrappedCredential, int maxWait) {\n        this(wrappedCredential, Sleeper.DEFAULT, maxWait);\n    }","id":97436,"modified_method":"public RetryHttpInitializerWrapper(Credential wrappedCredential, TimeValue maxWait) {\n        this(wrappedCredential, Sleeper.DEFAULT, maxWait);\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"static MockGoogleCredential.Builder newMockCredentialBuilder() {\n        // TODO: figure out why GCE is so bad like this\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new SpecialPermission());\n        }\n        return AccessController.doPrivileged(new PrivilegedAction<MockGoogleCredential.Builder>() {\n            @Override\n            public MockGoogleCredential.Builder run() {\n                return new MockGoogleCredential.Builder();\n            }\n        });\n    }","id":97437,"modified_method":"static MockGoogleCredential.Builder newMockCredentialBuilder() {\n        // TODO: figure out why GCE is so bad like this\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new SpecialPermission());\n        }\n        return AccessController.doPrivileged((PrivilegedAction<MockGoogleCredential.Builder>) () -> new MockGoogleCredential.Builder());\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"RetryHttpInitializerWrapper(\n            Credential wrappedCredential, Sleeper sleeper, int maxWait) {\n        this.wrappedCredential = Objects.requireNonNull(wrappedCredential);\n        this.sleeper = sleeper;\n        this.maxWait = maxWait;\n    }","id":97438,"modified_method":"RetryHttpInitializerWrapper(\n            Credential wrappedCredential, Sleeper sleeper, TimeValue maxWait) {\n        this.wrappedCredential = Objects.requireNonNull(wrappedCredential);\n        this.sleeper = sleeper;\n        this.maxWait = maxWait;\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public RetryHttpInitializerWrapper(Credential wrappedCredential) {\n        this(wrappedCredential, Sleeper.DEFAULT, ExponentialBackOff.DEFAULT_MAX_ELAPSED_TIME_MILLIS);\n    }","id":97439,"modified_method":"public RetryHttpInitializerWrapper(Credential wrappedCredential) {\n        this(wrappedCredential, Sleeper.DEFAULT, TimeValue.timeValueMillis(ExponentialBackOff.DEFAULT_MAX_ELAPSED_TIME_MILLIS));\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void initialize(HttpRequest httpRequest) {\n        final HttpUnsuccessfulResponseHandler backoffHandler =\n                new HttpBackOffUnsuccessfulResponseHandler(\n                        new ExponentialBackOff.Builder()\n                                .setMaxElapsedTimeMillis(maxWait)\n                                .build())\n                        .setSleeper(sleeper);\n\n        httpRequest.setInterceptor(wrappedCredential);\n        httpRequest.setUnsuccessfulResponseHandler(\n                new HttpUnsuccessfulResponseHandler() {\n                    int retry = 0;\n\n                    @Override\n                    public boolean handleResponse(HttpRequest request, HttpResponse response, boolean supportsRetry) throws IOException {\n                        if (wrappedCredential.handleResponse(\n                                request, response, supportsRetry)) {\n                            // If credential decides it can handle it,\n                            // the return code or message indicated\n                            // something specific to authentication,\n                            // and no backoff is desired.\n                            return true;\n                        } else if (backoffHandler.handleResponse(\n                                request, response, supportsRetry)) {\n                            // Otherwise, we defer to the judgement of\n                            // our internal backoff handler.\n                            logger.debug(\"Retrying [{}] times : [{}]\", retry, request.getUrl());\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    }\n                });\n        httpRequest.setIOExceptionHandler(\n                new HttpBackOffIOExceptionHandler(\n                        new ExponentialBackOff.Builder()\n                                .setMaxElapsedTimeMillis(maxWait)\n                                .build())\n                        .setSleeper(sleeper)\n        );\n    }","id":97440,"modified_method":"@Override\n    public void initialize(HttpRequest httpRequest) {\n        final HttpUnsuccessfulResponseHandler backoffHandler =\n                new HttpBackOffUnsuccessfulResponseHandler(\n                        new ExponentialBackOff.Builder()\n                                .setMaxElapsedTimeMillis(((int) maxWait.getMillis()))\n                                .build())\n                        .setSleeper(sleeper);\n\n        httpRequest.setInterceptor(wrappedCredential);\n        httpRequest.setUnsuccessfulResponseHandler(\n                new HttpUnsuccessfulResponseHandler() {\n                    int retry = 0;\n\n                    @Override\n                    public boolean handleResponse(HttpRequest request, HttpResponse response, boolean supportsRetry) throws IOException {\n                        if (wrappedCredential.handleResponse(\n                                request, response, supportsRetry)) {\n                            // If credential decides it can handle it,\n                            // the return code or message indicated\n                            // something specific to authentication,\n                            // and no backoff is desired.\n                            return true;\n                        } else if (backoffHandler.handleResponse(\n                                request, response, supportsRetry)) {\n                            // Otherwise, we defer to the judgement of\n                            // our internal backoff handler.\n                            logger.debug(\"Retrying [{}] times : [{}]\", retry, request.getUrl());\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    }\n                });\n        httpRequest.setIOExceptionHandler(\n                new HttpBackOffIOExceptionHandler(\n                        new ExponentialBackOff.Builder()\n                                .setMaxElapsedTimeMillis(((int) maxWait.getMillis()))\n                                .build())\n                        .setSleeper(sleeper)\n        );\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testIOExceptionRetry() throws Exception {\n        FailThenSuccessBackoffTransport fakeTransport =\n                new FailThenSuccessBackoffTransport(HttpStatusCodes.STATUS_CODE_SERVER_ERROR, 1, true);\n\n        MockGoogleCredential credential = RetryHttpInitializerWrapper.newMockCredentialBuilder()\n                .build();\n        MockSleeper mockSleeper = new MockSleeper();\n        RetryHttpInitializerWrapper retryHttpInitializerWrapper = new RetryHttpInitializerWrapper(credential, mockSleeper, 500);\n\n        Compute client = new Compute.Builder(fakeTransport, new JacksonFactory(), null)\n                .setHttpRequestInitializer(retryHttpInitializerWrapper)\n                .setApplicationName(\"test\")\n                .build();\n\n        HttpRequest request = client.getRequestFactory().buildRequest(\"Get\", new GenericUrl(\"http://elasticsearch.com\"), null);\n        HttpResponse response = request.execute();\n\n        assertThat(mockSleeper.getCount(), equalTo(1));\n        assertThat(response.getStatusCode(), equalTo(200));\n    }","id":97441,"modified_method":"public void testIOExceptionRetry() throws Exception {\n        FailThenSuccessBackoffTransport fakeTransport =\n                new FailThenSuccessBackoffTransport(HttpStatusCodes.STATUS_CODE_SERVER_ERROR, 1, true);\n\n        MockGoogleCredential credential = RetryHttpInitializerWrapper.newMockCredentialBuilder()\n                .build();\n        MockSleeper mockSleeper = new MockSleeper();\n        RetryHttpInitializerWrapper retryHttpInitializerWrapper = new RetryHttpInitializerWrapper(credential, mockSleeper,\n            TimeValue.timeValueMillis(500));\n\n        Compute client = new Compute.Builder(fakeTransport, new JacksonFactory(), null)\n                .setHttpRequestInitializer(retryHttpInitializerWrapper)\n                .setApplicationName(\"test\")\n                .build();\n\n        HttpRequest request = client.getRequestFactory().buildRequest(\"Get\", new GenericUrl(\"http://elasticsearch.com\"), null);\n        HttpResponse response = request.execute();\n\n        assertThat(mockSleeper.getCount(), equalTo(1));\n        assertThat(response.getStatusCode(), equalTo(200));\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testSimpleRetry() throws Exception {\n        FailThenSuccessBackoffTransport fakeTransport =\n                new FailThenSuccessBackoffTransport(HttpStatusCodes.STATUS_CODE_SERVER_ERROR, 3);\n\n        MockGoogleCredential credential = RetryHttpInitializerWrapper.newMockCredentialBuilder()\n                .build();\n        MockSleeper mockSleeper = new MockSleeper();\n\n        RetryHttpInitializerWrapper retryHttpInitializerWrapper = new RetryHttpInitializerWrapper(credential, mockSleeper, 5000);\n\n        Compute client = new Compute.Builder(fakeTransport, new JacksonFactory(), null)\n                .setHttpRequestInitializer(retryHttpInitializerWrapper)\n                .setApplicationName(\"test\")\n                .build();\n\n        HttpRequest request = client.getRequestFactory().buildRequest(\"Get\", new GenericUrl(\"http://elasticsearch.com\"), null);\n        HttpResponse response = request.execute();\n\n        assertThat(mockSleeper.getCount(), equalTo(3));\n        assertThat(response.getStatusCode(), equalTo(200));\n    }","id":97442,"modified_method":"public void testSimpleRetry() throws Exception {\n        FailThenSuccessBackoffTransport fakeTransport =\n                new FailThenSuccessBackoffTransport(HttpStatusCodes.STATUS_CODE_SERVER_ERROR, 3);\n\n        MockGoogleCredential credential = RetryHttpInitializerWrapper.newMockCredentialBuilder()\n                .build();\n        MockSleeper mockSleeper = new MockSleeper();\n\n        RetryHttpInitializerWrapper retryHttpInitializerWrapper = new RetryHttpInitializerWrapper(credential, mockSleeper,\n            TimeValue.timeValueSeconds(5));\n\n        Compute client = new Compute.Builder(fakeTransport, new JacksonFactory(), null)\n                .setHttpRequestInitializer(retryHttpInitializerWrapper)\n                .setApplicationName(\"test\")\n                .build();\n\n        HttpRequest request = client.getRequestFactory().buildRequest(\"Get\", new GenericUrl(\"http://elasticsearch.com\"), null);\n        HttpResponse response = request.execute();\n\n        assertThat(mockSleeper.getCount(), equalTo(3));\n        assertThat(response.getStatusCode(), equalTo(200));\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testRetryWaitTooLong() throws Exception {\n        int maxWaitTime = 10;\n        int maxRetryTimes = 50;\n\n        FailThenSuccessBackoffTransport fakeTransport =\n                new FailThenSuccessBackoffTransport(HttpStatusCodes.STATUS_CODE_SERVER_ERROR, maxRetryTimes);\n        JsonFactory jsonFactory = new JacksonFactory();\n        MockGoogleCredential credential = RetryHttpInitializerWrapper.newMockCredentialBuilder()\n                .build();\n\n        MockSleeper oneTimeSleeper = new MockSleeper() {\n            @Override\n            public void sleep(long millis) throws InterruptedException {\n                Thread.sleep(maxWaitTime);\n                super.sleep(0); // important number, use this to get count\n            }\n        };\n\n        RetryHttpInitializerWrapper retryHttpInitializerWrapper = new RetryHttpInitializerWrapper(credential, oneTimeSleeper, maxWaitTime);\n\n        Compute client = new Compute.Builder(fakeTransport, jsonFactory, null)\n                .setHttpRequestInitializer(retryHttpInitializerWrapper)\n                .setApplicationName(\"test\")\n                .build();\n\n        HttpRequest request1 = client.getRequestFactory().buildRequest(\"Get\", new GenericUrl(\"http://elasticsearch.com\"), null);\n        try {\n            request1.execute();\n            fail(\"Request should fail if wait too long\");\n        } catch (HttpResponseException e) {\n            assertThat(e.getStatusCode(), equalTo(HttpStatusCodes.STATUS_CODE_SERVER_ERROR));\n            // should only retry once.\n            assertThat(oneTimeSleeper.getCount(), lessThan(maxRetryTimes));\n        }\n    }","id":97443,"modified_method":"public void testRetryWaitTooLong() throws Exception {\n        TimeValue maxWaitTime = TimeValue.timeValueMillis(10);\n        int maxRetryTimes = 50;\n\n        FailThenSuccessBackoffTransport fakeTransport =\n                new FailThenSuccessBackoffTransport(HttpStatusCodes.STATUS_CODE_SERVER_ERROR, maxRetryTimes);\n        JsonFactory jsonFactory = new JacksonFactory();\n        MockGoogleCredential credential = RetryHttpInitializerWrapper.newMockCredentialBuilder()\n                .build();\n\n        MockSleeper oneTimeSleeper = new MockSleeper() {\n            @Override\n            public void sleep(long millis) throws InterruptedException {\n                Thread.sleep(maxWaitTime.getMillis());\n                super.sleep(0); // important number, use this to get count\n            }\n        };\n\n        RetryHttpInitializerWrapper retryHttpInitializerWrapper = new RetryHttpInitializerWrapper(credential, oneTimeSleeper, maxWaitTime);\n\n        Compute client = new Compute.Builder(fakeTransport, jsonFactory, null)\n                .setHttpRequestInitializer(retryHttpInitializerWrapper)\n                .setApplicationName(\"test\")\n                .build();\n\n        HttpRequest request1 = client.getRequestFactory().buildRequest(\"Get\", new GenericUrl(\"http://elasticsearch.com\"), null);\n        try {\n            request1.execute();\n            fail(\"Request should fail if wait too long\");\n        } catch (HttpResponseException e) {\n            assertThat(e.getStatusCode(), equalTo(HttpStatusCodes.STATUS_CODE_SERVER_ERROR));\n            // should only retry once.\n            assertThat(oneTimeSleeper.getCount(), lessThan(maxRetryTimes));\n        }\n    }","commit_id":"90fba97a30f0a0747188db02bb5a524000933c65","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Nullable\n  private static Configurable computeRootConfigurable(@NotNull List<DebuggerSettingsPanelProvider> providers, @NotNull List<Configurable> configurables) {\n    Configurable deprecatedRootConfigurable = null;\n    for (DebuggerSettingsPanelProvider provider : providers) {\n      configurables.addAll(provider.getConfigurables());\n      @SuppressWarnings(\"deprecation\")\n      Configurable providerRootConfigurable = provider.getRootConfigurable();\n      if (providerRootConfigurable != null) {\n        if (deprecatedRootConfigurable == null) {\n          deprecatedRootConfigurable = providerRootConfigurable;\n        }\n        else {\n          configurables.add(providerRootConfigurable);\n        }\n      }\n    }\n\n    List<Configurable> rootConfigurables = DebuggerConfigurableProvider.getConfigurables(XDebuggerSettings.Category.ROOT, providers);\n    if (rootConfigurables.isEmpty()) {\n      return deprecatedRootConfigurable;\n    }\n    else {\n      Configurable[] mergedRootConfigurables = new Configurable[rootConfigurables.size() + (deprecatedRootConfigurable == null ? 0 : 1)];\n      rootConfigurables.toArray(mergedRootConfigurables);\n      if (deprecatedRootConfigurable != null) {\n        mergedRootConfigurables[rootConfigurables.size()] = deprecatedRootConfigurable;\n      }\n\n      // move unnamed to top\n      Arrays.sort(mergedRootConfigurables, new Comparator<Configurable>() {\n        @Override\n        public int compare(Configurable o1, Configurable o2) {\n          boolean c1e = StringUtil.isEmpty(o1.getDisplayName());\n          return c1e == StringUtil.isEmpty(o2.getDisplayName()) ? 0 : (c1e ? -1 : 1);\n        }\n      });\n\n      return new MergedCompositeConfigurable(mergedRootConfigurables) {\n        @NotNull\n        @Override\n        public String getId() {\n          throw new UnsupportedOperationException();\n        }\n\n        @Nls\n        @Override\n        public String getDisplayName() {\n          throw new UnsupportedOperationException();\n        }\n      };\n    }\n  }","id":97444,"modified_method":"@Nullable\n  private static Configurable computeRootConfigurable(@NotNull List<DebuggerSettingsPanelProvider> providers, @NotNull List<Configurable> configurables) {\n    Configurable deprecatedRootConfigurable = null;\n    for (DebuggerSettingsPanelProvider provider : providers) {\n      configurables.addAll(provider.getConfigurables());\n      @SuppressWarnings(\"deprecation\")\n      Configurable providerRootConfigurable = provider.getRootConfigurable();\n      if (providerRootConfigurable != null) {\n        if (deprecatedRootConfigurable == null) {\n          deprecatedRootConfigurable = providerRootConfigurable;\n        }\n        else {\n          configurables.add(providerRootConfigurable);\n        }\n      }\n    }\n\n    List<Configurable> rootConfigurables = DebuggerConfigurableProvider.getConfigurables(Category.ROOT, providers);\n    if (rootConfigurables.isEmpty()) {\n      return deprecatedRootConfigurable;\n    }\n    else {\n      Configurable[] mergedRootConfigurables = new Configurable[rootConfigurables.size() + (deprecatedRootConfigurable == null ? 0 : 1)];\n      rootConfigurables.toArray(mergedRootConfigurables);\n      if (deprecatedRootConfigurable != null) {\n        mergedRootConfigurables[rootConfigurables.size()] = deprecatedRootConfigurable;\n      }\n\n      // move unnamed to top\n      Arrays.sort(mergedRootConfigurables, new Comparator<Configurable>() {\n        @Override\n        public int compare(Configurable o1, Configurable o2) {\n          boolean c1e = StringUtil.isEmpty(o1.getDisplayName());\n          return c1e == StringUtil.isEmpty(o2.getDisplayName()) ? 0 : (c1e ? -1 : 1);\n        }\n      });\n\n      return new MergedCompositeConfigurable(\"\", \"\", mergedRootConfigurables);\n    }\n  }","commit_id":"3f16efab054e5ac10628fcb911fc764366472ded","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void compute() {\n    if (myChildren != null) {\n      return;\n    }\n\n    List<DebuggerSettingsPanelProvider> providers = DebuggerConfigurableProvider.getSortedProviders();\n\n    List<Configurable> configurables = new SmartList<Configurable>();\n    configurables.add(new DataViewsConfigurable());\n\n    List<Configurable> steppingConfigurables = DebuggerConfigurableProvider.getConfigurables(XDebuggerSettings.Category.STEPPING, providers);\n    if (!steppingConfigurables.isEmpty()) {\n      configurables.add(new SteppingConfigurable(steppingConfigurables));\n    }\n\n    Configurable rootConfigurable = computeRootConfigurable(providers, configurables);\n\n    if (configurables.isEmpty() && rootConfigurable == null) {\n      myChildren = EMPTY_CONFIGURABLES;\n    }\n    else if (rootConfigurable == null && configurables.size() == 1) {\n      myRootConfigurable = configurables.get(0);\n      myChildren = EMPTY_CONFIGURABLES;\n    }\n    else {\n      myChildren = configurables.toArray(new Configurable[configurables.size()]);\n      myRootConfigurable = rootConfigurable;\n    }\n  }","id":97445,"modified_method":"private void compute() {\n    if (myChildren != null) {\n      return;\n    }\n\n    List<DebuggerSettingsPanelProvider> providers = DebuggerConfigurableProvider.getSortedProviders();\n\n    List<Configurable> configurables = new SmartList<Configurable>();\n    configurables.add(new DataViewsConfigurable());\n\n    computeMergedConfigurables(providers, configurables);\n\n    Configurable rootConfigurable = computeRootConfigurable(providers, configurables);\n    if (configurables.isEmpty() && rootConfigurable == null) {\n      myChildren = EMPTY_CONFIGURABLES;\n    }\n    else if (rootConfigurable == null && configurables.size() == 1) {\n      myRootConfigurable = configurables.get(0);\n      myChildren = EMPTY_CONFIGURABLES;\n    }\n    else {\n      myChildren = configurables.toArray(new Configurable[configurables.size()]);\n      myRootConfigurable = rootConfigurable;\n    }\n  }","commit_id":"3f16efab054e5ac10628fcb911fc764366472ded","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public JComponent createComponent() {\n    final JPanel panel = new JPanel(new GridBagLayout());\n\n    myCbCompileBeforeHotswap = new JCheckBox(DebuggerBundle.message(\"label.debugger.hotswap.configurable.compile.before.hotswap\"));\n    myCbHangWarningEnabled = new JCheckBox(DebuggerBundle.message(\"label.debugger.hotswap.configurable.enable.vm.hang.warning\"));\n    myHotswapInBackground = new JCheckBox(DebuggerBundle.message(\"label.debugger.hotswap.configurable.hotswap.background\"));\n    myRbAlways = new JRadioButton(DebuggerBundle.message(\"label.debugger.hotswap.configurable.always\"));\n    myRbNever = new JRadioButton(DebuggerBundle.message(\"label.debugger.hotswap.configurable.never\"));\n    myRbAsk = new JRadioButton(DebuggerBundle.message(\"label.debugger.hotswap.configurable.ask\"));\n\n    panel.add(myCbCompileBeforeHotswap, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n    panel.add(myCbHangWarningEnabled, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(4, 0, 0, 0), 0, 0));\n    panel.add(myHotswapInBackground, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(4, 0, 0, 0), 0, 0));\n    \n    int cbLeftOffset = 0;\n    final Border border = myCbCompileBeforeHotswap.getBorder();\n    if (border != null) {\n      final Insets insets = border.getBorderInsets(myCbCompileBeforeHotswap);\n      if (insets != null) {\n        cbLeftOffset = insets.left;\n      }\n    }\n\n    final ButtonGroup group = new ButtonGroup();\n    group.add(myRbAlways);\n    group.add(myRbNever);\n    group.add(myRbAsk);\n    final Box box = Box.createHorizontalBox();\n    box.add(myRbAlways);\n    box.add(myRbNever);\n    box.add(myRbAsk);\n    final JPanel reloadPanel = new JPanel(new BorderLayout());\n    reloadPanel.add(box, BorderLayout.CENTER);\n    reloadPanel.add(new JLabel(DebuggerBundle.message(\"label.debugger.hotswap.configurable.reload.classes\")), BorderLayout.WEST);\n    panel.add(reloadPanel, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(4, cbLeftOffset, 0, 0), 0, 0));\n\n    return panel;\n  }","id":97446,"modified_method":"@NotNull\n  @Override\n  public JComponent getComponent() {\n    final JPanel panel = new JPanel(new GridBagLayout());\n\n    myCbCompileBeforeHotswap = new JCheckBox(DebuggerBundle.message(\"label.debugger.hotswap.configurable.compile.before.hotswap\"));\n    myCbHangWarningEnabled = new JCheckBox(DebuggerBundle.message(\"label.debugger.hotswap.configurable.enable.vm.hang.warning\"));\n    myHotswapInBackground = new JCheckBox(DebuggerBundle.message(\"label.debugger.hotswap.configurable.hotswap.background\"));\n    myRbAlways = new JRadioButton(DebuggerBundle.message(\"label.debugger.hotswap.configurable.always\"));\n    myRbNever = new JRadioButton(DebuggerBundle.message(\"label.debugger.hotswap.configurable.never\"));\n    myRbAsk = new JRadioButton(DebuggerBundle.message(\"label.debugger.hotswap.configurable.ask\"));\n\n    panel.add(myCbCompileBeforeHotswap, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n    panel.add(myCbHangWarningEnabled, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(4, 0, 0, 0), 0, 0));\n    panel.add(myHotswapInBackground, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(4, 0, 0, 0), 0, 0));\n    \n    int cbLeftOffset = 0;\n    final Border border = myCbCompileBeforeHotswap.getBorder();\n    if (border != null) {\n      final Insets insets = border.getBorderInsets(myCbCompileBeforeHotswap);\n      if (insets != null) {\n        cbLeftOffset = insets.left;\n      }\n    }\n\n    final ButtonGroup group = new ButtonGroup();\n    group.add(myRbAlways);\n    group.add(myRbNever);\n    group.add(myRbAsk);\n    final Box box = Box.createHorizontalBox();\n    box.add(myRbAlways);\n    box.add(myRbNever);\n    box.add(myRbAsk);\n    final JPanel reloadPanel = new JPanel(new BorderLayout());\n    reloadPanel.add(box, BorderLayout.CENTER);\n    reloadPanel.add(new JLabel(DebuggerBundle.message(\"label.debugger.hotswap.configurable.reload.classes\")), BorderLayout.WEST);\n    panel.add(reloadPanel, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(4, cbLeftOffset, 0, 0), 0, 0));\n\n    return panel;\n  }","commit_id":"3f16efab054e5ac10628fcb911fc764366472ded","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public Configurable createConfigurable(@NotNull Category category) {\n    if (category == Category.STEPPING) {\n      return SimpleConfigurable.create(\"reference.idesettings.debugger.groovy\", GroovyBundle.message(\"groovy.debug.caption\"), GroovySteppingConfigurableUi.class, this);\n    }\n    return null;\n  }","id":97447,"modified_method":"@SuppressWarnings(\"EnumSwitchStatementWhichMissesCases\")\n  @Nullable\n  @Override\n  public Configurable createConfigurable(@NotNull Category category) {\n    switch (category) {\n      case STEPPING:\n        return SimpleConfigurable.create(\"reference.idesettings.debugger.groovy\", GroovyBundle.message(\"groovy.debug.caption\"), GroovySteppingConfigurableUi.class, this);\n      case HOTSWAP:\n        return SimpleConfigurable.create(\"reference.idesettings.debugger.groovy\", GroovyBundle.message(\"groovy.debug.caption\"), GroovyDebuggerSettingsConfigurable.class, this);\n    }\n    return null;\n  }","commit_id":"3f16efab054e5ac10628fcb911fc764366472ded","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public JComponent createComponent() {\n    return myPanel;\n  }","id":97448,"modified_method":"@NotNull\n  @Override\n  public JComponent getComponent() {\n    return myPanel;\n  }","commit_id":"3f16efab054e5ac10628fcb911fc764366472ded","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public Configurable createConfigurable(@NotNull Category category) {\n    final Getter<DebuggerSettings> debuggerSettingsGetter = new Getter<DebuggerSettings>() {\n      @Override\n      public DebuggerSettings get() {\n        return DebuggerSettings.getInstance();\n      }\n    };\n\n    switch (category) {\n      case ROOT:\n        return SimpleConfigurable.create(\"reference.idesettings.debugger.launching\", OptionsBundle.message(\"options.java.display.name\"),\n                                         DebuggerLaunchingConfigurable.class, debuggerSettingsGetter);\n      case DATA_VIEWS:\n        return new DebuggerDataViewsConfigurable(null);\n      case STEPPING:\n        return SimpleConfigurable.create(\"reference.idesettings.debugger.stepping\", OptionsBundle.message(\"options.java.display.name\"), DebuggerSteppingConfigurable.class, debuggerSettingsGetter);\n    }\n    return null;\n  }","id":97449,"modified_method":"@Nullable\n  @Override\n  public Configurable createConfigurable(@NotNull Category category) {\n    final Getter<DebuggerSettings> debuggerSettingsGetter = new Getter<DebuggerSettings>() {\n      @Override\n      public DebuggerSettings get() {\n        return DebuggerSettings.getInstance();\n      }\n    };\n\n    switch (category) {\n      case ROOT:\n        return SimpleConfigurable.create(\"reference.idesettings.debugger.launching\", OptionsBundle.message(\"options.java.display.name\"),\n                                         DebuggerLaunchingConfigurable.class, debuggerSettingsGetter);\n      case DATA_VIEWS:\n        return new DebuggerDataViewsConfigurable(null);\n      case STEPPING:\n        return SimpleConfigurable.create(\"reference.idesettings.debugger.stepping\", OptionsBundle.message(\"options.java.display.name\"), DebuggerSteppingConfigurable.class, debuggerSettingsGetter);\n      case HOTSWAP:\n        return SimpleConfigurable.create(\"reference.idesettings.debugger.hotswap\", OptionsBundle.message(\"options.java.display.name\"), DebuggerHotswapConfigurable.class, debuggerSettingsGetter);\n    }\n    return null;\n  }","commit_id":"3f16efab054e5ac10628fcb911fc764366472ded","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    @Override\n    public Collection<? extends Configurable> getConfigurables() {\n      final ArrayList<Configurable> configurables = new ArrayList<Configurable>();\n      configurables.add(new UserRenderersConfigurable(null));\n      configurables.add(new DebuggerHotswapConfigurable());\n      return configurables;\n    }","id":97450,"modified_method":"@NotNull\n    @Override\n    public Collection<? extends Configurable> getConfigurables() {\n      return Collections.singletonList(new UserRenderersConfigurable(null));\n    }","commit_id":"3f16efab054e5ac10628fcb911fc764366472ded","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected MergedCompositeConfigurable(@NotNull Configurable[] children) {\n    this.children = children;\n  }","id":97451,"modified_method":"public MergedCompositeConfigurable(@NotNull String id, @NotNull String displayName, @NotNull Configurable[] children) {\n    this.children = children;\n    this.id = id;\n    this.displayName = displayName;\n  }","commit_id":"3f16efab054e5ac10628fcb911fc764366472ded","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public List<HttpHost> sniffHosts() throws IOException {\n        List<HttpHost> hosts = new ArrayList<>();\n        hosts.add(new HttpHost(\"localhost\", 9200));\n        return hosts;\n    }","id":97452,"modified_method":"@Override\n    public List<HttpHost> sniffHosts() throws IOException {\n        return Collections.singletonList(new HttpHost(\"localhost\", 9200));\n    }","commit_id":"8a51cfb5b350882b670ecfd826d9da296e953604","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private Sniffer(RestClient restClient, HostsSniffer hostsSniffer, long sniffInterval, long sniffAfterFailureDelay) {\n        this.task = new Task(hostsSniffer, restClient, sniffInterval, sniffAfterFailureDelay);\n    }","id":97453,"modified_method":"Sniffer(RestClient restClient, HostsSniffer hostsSniffer, long sniffInterval, long sniffAfterFailureDelay) {\n        this.task = new Task(hostsSniffer, restClient, sniffInterval, sniffAfterFailureDelay);\n    }","commit_id":"8a51cfb5b350882b670ecfd826d9da296e953604","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Returns a new {@link Builder} to help with {@link Sniffer} creation.\n     */\n    public static Builder builder(RestClient restClient, HostsSniffer hostsSniffer) {\n        return new Builder(restClient, hostsSniffer);\n    }","id":97454,"modified_method":"/**\n     * Returns a new {@link SnifferBuilder} to help with {@link Sniffer} creation.\n     *\n     * @param restClient the client that gets its hosts set (via {@link RestClient#setHosts(HttpHost...)}) once they are fetched\n     * @return a new instance of {@link SnifferBuilder}\n     */\n    public static SnifferBuilder builder(RestClient restClient) {\n        return new SnifferBuilder(restClient);\n    }","commit_id":"8a51cfb5b350882b670ecfd826d9da296e953604","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testBuild() throws Exception {\n        int numNodes = RandomInts.randomIntBetween(getRandom(), 1, 5);\n        HttpHost[] hosts = new HttpHost[numNodes];\n        for (int i = 0; i < numNodes; i++) {\n            hosts[i] = new HttpHost(\"localhost\", 9200 + i);\n        }\n\n        HostsSniffer hostsSniffer = new MockHostsSniffer();\n\n        try (RestClient client = RestClient.builder(hosts).build()) {\n            try {\n                Sniffer.builder(null, hostsSniffer).build();\n                fail(\"should have failed\");\n            } catch(NullPointerException e) {\n                assertEquals(\"restClient cannot be null\", e.getMessage());\n            }\n\n            try {\n                Sniffer.builder(client, null).build();\n                fail(\"should have failed\");\n            } catch(NullPointerException e) {\n                assertEquals(\"hostsSniffer cannot be null\", e.getMessage());\n            }\n\n            try {\n                Sniffer.builder(client, hostsSniffer)\n                        .setSniffIntervalMillis(RandomInts.randomIntBetween(getRandom(), Integer.MIN_VALUE, 0));\n                fail(\"should have failed\");\n            } catch(IllegalArgumentException e) {\n                assertEquals(\"sniffIntervalMillis must be greater than 0\", e.getMessage());\n            }\n\n            try {\n                Sniffer.builder(client, hostsSniffer)\n                        .setSniffAfterFailureDelayMillis(RandomInts.randomIntBetween(getRandom(), Integer.MIN_VALUE, 0));\n                fail(\"should have failed\");\n            } catch(IllegalArgumentException e) {\n                assertEquals(\"sniffAfterFailureDelayMillis must be greater than 0\", e.getMessage());\n            }\n\n            try (Sniffer sniffer = Sniffer.builder(client, hostsSniffer).build()) {\n                assertNotNull(sniffer);\n            }\n\n            Sniffer.Builder builder = Sniffer.builder(client, hostsSniffer);\n            if (getRandom().nextBoolean()) {\n                builder.setSniffIntervalMillis(RandomInts.randomIntBetween(getRandom(), 1, Integer.MAX_VALUE));\n            }\n            if (getRandom().nextBoolean()) {\n                builder.setSniffAfterFailureDelayMillis(RandomInts.randomIntBetween(getRandom(), 1, Integer.MAX_VALUE));\n            }\n            try (Sniffer sniffer = builder.build()) {\n                assertNotNull(sniffer);\n            }\n        }\n    }","id":97455,"modified_method":"public void testBuild() throws Exception {\n        int numNodes = RandomInts.randomIntBetween(getRandom(), 1, 5);\n        HttpHost[] hosts = new HttpHost[numNodes];\n        for (int i = 0; i < numNodes; i++) {\n            hosts[i] = new HttpHost(\"localhost\", 9200 + i);\n        }\n\n        try (RestClient client = RestClient.builder(hosts).build()) {\n            try {\n                Sniffer.builder(null).build();\n                fail(\"should have failed\");\n            } catch(NullPointerException e) {\n                assertEquals(\"restClient cannot be null\", e.getMessage());\n            }\n\n            try {\n                Sniffer.builder(client).setSniffIntervalMillis(RandomInts.randomIntBetween(getRandom(), Integer.MIN_VALUE, 0));\n                fail(\"should have failed\");\n            } catch(IllegalArgumentException e) {\n                assertEquals(\"sniffIntervalMillis must be greater than 0\", e.getMessage());\n            }\n\n            try {\n                Sniffer.builder(client).setSniffAfterFailureDelayMillis(RandomInts.randomIntBetween(getRandom(), Integer.MIN_VALUE, 0));\n                fail(\"should have failed\");\n            } catch(IllegalArgumentException e) {\n                assertEquals(\"sniffAfterFailureDelayMillis must be greater than 0\", e.getMessage());\n            }\n\n\n            try {\n                Sniffer.builder(client).setHostsSniffer(null);\n                fail(\"should have failed\");\n            } catch(NullPointerException e) {\n                assertEquals(\"hostsSniffer cannot be null\", e.getMessage());\n            }\n\n\n            try (Sniffer sniffer = Sniffer.builder(client).build()) {\n                assertNotNull(sniffer);\n            }\n\n            SnifferBuilder builder = Sniffer.builder(client);\n            if (getRandom().nextBoolean()) {\n                builder.setSniffIntervalMillis(RandomInts.randomIntBetween(getRandom(), 1, Integer.MAX_VALUE));\n            }\n            if (getRandom().nextBoolean()) {\n                builder.setSniffAfterFailureDelayMillis(RandomInts.randomIntBetween(getRandom(), 1, Integer.MAX_VALUE));\n            }\n            if (getRandom().nextBoolean()) {\n                builder.setHostsSniffer(new MockHostsSniffer());\n            }\n\n            try (Sniffer sniffer = builder.build()) {\n                assertNotNull(sniffer);\n            }\n        }\n    }","commit_id":"8a51cfb5b350882b670ecfd826d9da296e953604","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Nullable\n  private static PsiJavaFile createJavaFileFromClipboardContent(final Project project) {\n    String text = CopyPasteManager.getInstance().getContents(DataFlavor.stringFlavor);\n    return text != null ? (PsiJavaFile)PsiFileFactory.getInstance(project).createFileFromText(\"A.java\", JavaLanguage.INSTANCE, text) : null;\n  }","id":97456,"modified_method":"@Nullable\n  private static PsiJavaFile createJavaFileFromClipboardContent(final Project project) {\n    String text = CopyPasteManager.getInstance().getContents(DataFlavor.stringFlavor);\n    if (text == null) return null;\n    PsiFile psiFile = PsiFileFactory.getInstance(project).createFileFromText(\"A.java\", JavaLanguage.INSTANCE, text);\n    return psiFile instanceof PsiJavaFile ? (PsiJavaFile)psiFile : null;\n  }","commit_id":"62f767f300110f3987aaeb19be6a443fea65a917","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public XmlNSDescriptor getDefaultNSDescriptorInner(final String namespace, final boolean strict) {\n    final XmlFile containingFile = XmlUtil.getContainingFile(this);\n    final XmlDoctype doctype = getProlog().getDoctype();\n\n    if (XmlUtil.ANT_URI.equals(namespace)){\n      final AntDOMNSDescriptor antDOMNSDescriptor = new AntDOMNSDescriptor();\n      antDOMNSDescriptor.init(this);\n      return antDOMNSDescriptor;\n    }\n    else if(XmlUtil.HTML_URI.equals(namespace) && doctype == null){\n      final XmlNSDescriptor xhtmlNSDescriptor = getDefaultNSDescriptor(XmlUtil.XHTML_URI, false);\n      final XmlNSDescriptor htmlDescriptor = new HtmlNSDescriptorImpl(xhtmlNSDescriptor);\n      return htmlDescriptor;\n    }\n    else if(namespace != null && namespace != XmlUtil.EMPTY_URI\n            && (doctype == null || !namespace.equals(doctype.getDtdUri()))){\n      final XmlFile xmlFile = XmlUtil.findXmlFile(containingFile,\n                                                  ExternalResourceManager.getInstance().getResourceLocation(namespace));\n      if(xmlFile != null){\n        final XmlNSDescriptor descriptor = (XmlNSDescriptor)xmlFile.getDocument().getMetaData();\n        return descriptor;\n      }\n    }\n    if(strict) return null;\n\n    if (doctype != null){\n      XmlNSDescriptor descr = null;\n      if (doctype.getMarkupDecl() != null){\n        descr = (XmlNSDescriptor)doctype.getMarkupDecl().getMetaData();\n      }\n      if (doctype.getDtdUri() != null){\n        final XmlFile xmlFile = XmlUtil.findXmlFile(containingFile, doctype.getDtdUri());\n        final XmlNSDescriptor descr1 = xmlFile == null ? null : (XmlNSDescriptor)xmlFile.getDocument().getMetaData();\n        if (descr != null && descr1 != null){\n          descr = new XmlNSDescriptorSequence(new XmlNSDescriptor[]{descr, descr1});\n        }\n        else if (descr1 != null) {\n          descr = descr1;\n        }\n      }\n\n      if(descr != null) return descr;\n    }\n\n    try{\n      return (XmlNSDescriptor)((XmlFile)getManager().getElementFactory().createFileFromText(\n        containingFile.getName() + \".dtd\",\n        XmlUtil.generateDocumentDTD(this)\n      )).getDocument().getMetaData();\n    }\n    catch(IncorrectOperationException e){\n      LOG.error(e);\n    }\n    return null;\n  }","id":97457,"modified_method":"public XmlNSDescriptor getDefaultNSDescriptorInner(final String namespace, final boolean strict) {\n    final XmlFile containingFile = XmlUtil.getContainingFile(this);\n    final XmlDoctype doctype = getProlog().getDoctype();\n\n    if (XmlUtil.ANT_URI.equals(namespace)){\n      final AntDOMNSDescriptor antDOMNSDescriptor = new AntDOMNSDescriptor();\n      antDOMNSDescriptor.init(this);\n      return antDOMNSDescriptor;\n    }\n    else if(XmlUtil.HTML_URI.equals(namespace) && doctype == null){\n      final XmlNSDescriptor xhtmlNSDescriptor = getDefaultNSDescriptor(XmlUtil.XHTML_URI, false);\n      final XmlNSDescriptor htmlDescriptor = new HtmlNSDescriptorImpl(xhtmlNSDescriptor);\n      return htmlDescriptor;\n    }\n    else if(namespace != null && namespace != XmlUtil.EMPTY_URI\n            && (doctype == null || !namespace.equals(doctype.getDtdUri()))){\n      final XmlFile xmlFile = XmlUtil.findXmlFile(containingFile,\n                                                  ExternalResourceManager.getInstance().getResourceLocation(namespace));\n      if(xmlFile != null){\n        final XmlNSDescriptor descriptor = (XmlNSDescriptor)xmlFile.getDocument().getMetaData();\n        return descriptor;\n      }\n    }\n    if(strict) return null;\n\n    if (doctype != null){\n      XmlNSDescriptor descr = null;\n      if (doctype.getMarkupDecl() != null){\n        descr = (XmlNSDescriptor)doctype.getMarkupDecl().getMetaData();\n      }\n      if (doctype.getDtdUri() != null){\n        final XmlFile xmlFile = XmlUtil.findXmlFile(containingFile, doctype.getDtdUri());\n        final XmlNSDescriptor descr1 = xmlFile == null ? null : (XmlNSDescriptor)xmlFile.getDocument().getMetaData();\n        if (descr != null && descr1 != null){\n          descr = new XmlNSDescriptorSequence(new XmlNSDescriptor[]{descr, descr1});\n        }\n        else if (descr1 != null) {\n          descr = descr1;\n        }\n      }\n\n      if(descr != null) return descr;\n    }\n\n    try{\n      final PsiFile fileFromText = getManager().getElementFactory().createFileFromText(\n        containingFile.getName() + \".dtd\",\n        XmlUtil.generateDocumentDTD(this)\n      );\n      if (fileFromText instanceof XmlFile) {\n        return (XmlNSDescriptor)((XmlFile)fileFromText).getDocument().getMetaData();\n      }\n    }\n    catch(IncorrectOperationException e){\n      LOG.error(e);\n    }\n    return null;\n  }","commit_id":"407acb41225e4bbd9318c100a015ed7701f38e12","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiClass createClassOrInterface(Project project,\n                                                PsiDirectory directory,\n                                                String content,\n                                                boolean reformat,\n                                                String extension) throws IncorrectOperationException{\n    if (extension == null) extension = StdFileTypes.JAVA.getDefaultExtension();\n    PsiJavaFile psiJavaFile = (PsiJavaFile)PsiManager.getInstance(project).getElementFactory().createFileFromText(\"myclass\" + \".\" + extension, content);\n    PsiClass[] classes = psiJavaFile.getClasses();\n    if(classes.length == 0){\n      throw new IncorrectOperationException(\"This template did not produce Java class nor interface!\");\n    }\n    PsiClass createdClass = classes[0];\n    if(reformat){\n      CodeStyleManager.getInstance(project).reformat(psiJavaFile);\n    }\n    String className = createdClass.getName();\n    String fileName = className + \".\" + extension;\n    if(createdClass.isInterface()){\n      directory.checkCreateInterface(className);\n    }\n    else{\n      directory.checkCreateClass(className);\n    }\n    psiJavaFile = (PsiJavaFile)psiJavaFile.setName(fileName);\n    psiJavaFile = (PsiJavaFile) directory.add(psiJavaFile);\n\n    return psiJavaFile.getClasses()[0];\n  }","id":97458,"modified_method":"public static PsiClass createClassOrInterface(Project project,\n                                                PsiDirectory directory,\n                                                String content,\n                                                boolean reformat,\n                                                String extension) throws IncorrectOperationException{\n    if (extension == null) extension = StdFileTypes.JAVA.getDefaultExtension();\n    final PsiFile psiFile = PsiManager.getInstance(project).getElementFactory().createFileFromText(\"myclass\" + \".\" + extension, content);\n    final PsiClass[] classes = psiFile instanceof PsiJavaFile? ((PsiJavaFile)psiFile).getClasses() : PsiClass.EMPTY_ARRAY;\n    if(classes.length == 0){\n      throw new IncorrectOperationException(\"This template did not produce Java class nor interface!\");\n    }\n    PsiJavaFile psiJavaFile = (PsiJavaFile)psiFile;\n    PsiClass createdClass = classes[0];\n    if(reformat){\n      CodeStyleManager.getInstance(project).reformat(psiJavaFile);\n    }\n    String className = createdClass.getName();\n    String fileName = className + \".\" + extension;\n    if(createdClass.isInterface()){\n      directory.checkCreateInterface(className);\n    }\n    else{\n      directory.checkCreateClass(className);\n    }\n    psiJavaFile = (PsiJavaFile)psiJavaFile.setName(fileName);\n    psiJavaFile = (PsiJavaFile) directory.add(psiJavaFile);\n\n    return psiJavaFile.getClasses()[0];\n  }","commit_id":"510cf8e5ca26d3c5940b4f00eb189dda20c66dde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private XmlDocument createXmlDocument(@NonNls final CharSequence text, @NonNls final String fileName, FileType fileType) {\n    final XmlDocument document = ((XmlFile)PsiFileFactory.getInstance(myProject).createFileFromText(fileName, fileType, text)).getDocument();\n    assert document != null;\n    return document;\n  }","id":97459,"modified_method":"private XmlDocument createXmlDocument(@NonNls final CharSequence text, @NonNls final String fileName, FileType fileType) {\n    PsiFile fileFromText = PsiFileFactory.getInstance(myProject).createFileFromText(fileName, fileType, text);\n\n    XmlFile xmlFile;\n    if (fileFromText instanceof XmlFile) {\n      xmlFile = (XmlFile)fileFromText;\n    }\n    else {\n      xmlFile = (XmlFile)fileFromText.getViewProvider().getPsi(((LanguageFileType)fileType).getLanguage());\n      assert xmlFile != null;\n    }\n    XmlDocument document = xmlFile.getDocument();\n    assert document != null;\n    return document;\n  }","commit_id":"3dfc8cda76940e53a3f1e3dfa7b0c91495b056c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Collection<ResourceType> getAllWithPropertyKey(final String propertyKey) {\n    return Collections2.filter(typeByQualifier.values(), new Predicate<ResourceType>() {\n      public boolean apply(@Nullable ResourceType input) {\n        return input != null && input.hasProperty(propertyKey);\n      }\n    });\n  }","id":97460,"modified_method":"public Collection<ResourceType> getAllWithPropertyKey(final String propertyKey) {\n    return Collections2.filter(typeByQualifier.values(), new PropertyKeyPredicate(propertyKey));\n  }","commit_id":"22c56a89235eaa229af5d88e93bdbc26628a07ec","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Collection<ResourceType> getAllWithPropertyValue(final String propertyKey, final boolean propertyValue) {\n    return Collections2.filter(typeByQualifier.values(), new Predicate<ResourceType>() {\n      public boolean apply(@Nullable ResourceType input) {\n        return input != null && input.getBooleanProperty(propertyKey) == propertyValue;\n      }\n    });\n  }","id":97461,"modified_method":"public Collection<ResourceType> getAllWithPropertyValue(final String propertyKey, final boolean propertyValue) {\n    return Collections2.filter(typeByQualifier.values(), new BooleanPropertyValuePredicate(propertyKey, propertyValue));\n  }","commit_id":"22c56a89235eaa229af5d88e93bdbc26628a07ec","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Collection<ResourceType> getAllWithPropertyValue(final String propertyKey, final String propertyValue) {\n    return Collections2.filter(typeByQualifier.values(), new Predicate<ResourceType>() {\n      public boolean apply(@Nullable ResourceType input) {\n        return input != null && Objects.equal(propertyValue, input.getStringProperty(propertyKey));\n      }\n    });\n  }","id":97462,"modified_method":"public Collection<ResourceType> getAllWithPropertyValue(final String propertyKey, final String propertyValue) {\n    return Collections2.filter(typeByQualifier.values(), new StringPropertyValuePredicate(propertyValue, propertyKey));\n  }","commit_id":"22c56a89235eaa229af5d88e93bdbc26628a07ec","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n     * Joins this process to a group. Determines the coordinator and sends a\n     * unicast handleJoin() message to it. The coordinator returns a JoinRsp and\n     * then broadcasts the new view, which contains a message digest and the\n     * current membership (including the joiner). The joiner is then supposed to\n     * install the new view and the digest and starts accepting mcast messages.\n     * Previous mcast messages were discarded (this is done in PBCAST).\n     * <p>\n     * If successful, impl is changed to an instance of ParticipantGmsImpl.\n     * Otherwise, we continue trying to send join() messages to the coordinator,\n     * until we succeed (or there is no member in the group. In this case, we\n     * create our own singleton group).\n     * <p>\n     * When GMS.disable_initial_coord is set to true, then we won't become\n     * coordinator on receiving an initial membership of 0, but instead will\n     * retry (forever) until we get an initial membership of > 0.\n     *\n     * @param mbr Our own address (assigned through SET_LOCAL_ADDRESS)\n     */\n    private void joinInternal(Address mbr, boolean joinWithStateTransfer,boolean useFlushIfPresent) {\n        Address coord=null;\n        JoinRsp rsp=null;\n        View tmp_view;\n        long join_attempts=0;\n        leaving=false;\n\n        join_promise.reset();\n        while(!leaving) {\n            if(rsp == null && !join_promise.hasResult()) { // null responses means that the discovery was cancelled\n                List<PingData> responses=findInitialMembers(join_promise);\n                if (responses == null) {\n                    // gray: we've seen this NPE here.  not sure of the cases but wanted to add more debugging info\n                    throw new NullPointerException(\"responses returned by findInitialMembers for \" + join_promise + \" is null\");\n                }\n                // Sept 2008 (bela): break if we got a belated JoinRsp (https://jira.jboss.org/jira/browse/JGRP-687)\n                // Reverted above change again - bela June 2012, see https://github.com/belaban/JGroups/pull/29\n                if(join_promise.hasResult()) {\n                    rsp=join_promise.getResult(gms.join_timeout); // clears the result\n                    if(rsp != null)\n                        continue;\n                }\n                if(responses.isEmpty()) {\n                    if(log.isTraceEnabled())\n                        log.trace(gms.local_addr + \": no initial members discovered: creating group as first member\");\n                    becomeSingletonMember(mbr);\n                    return;\n                }\n                if(log.isTraceEnabled())\n                    log.trace(gms.local_addr + \": initial_mbrs are \" + print(responses));\n\n                coord=determineCoord(responses);\n                if(coord == null) { // e.g. because we have all clients only\n                    if(gms.handle_concurrent_startup == false) {\n                        if(log.isTraceEnabled())\n                            log.trace(\"handle_concurrent_startup is false; ignoring responses of initial clients\");\n                        becomeSingletonMember(mbr);\n                        return;\n                    }\n\n                    if(log.isTraceEnabled())\n                        log.trace(\"could not determine coordinator from responses \" + responses);\n\n                    // so the member to become singleton member (and thus coord) is the first of all clients\n                    SortedSet<Address> clients=new TreeSet<Address>(); // sorted\n                    clients.add(mbr); // add myself again (was removed by findInitialMembers())\n                    for(PingData response: responses) {\n                        Address client_addr=response.getAddress();\n                        if(client_addr != null)\n                            clients.add(client_addr);\n                    }\n                    if(log.isTraceEnabled())\n                        log.trace(\"clients to choose new coord from are: \" + clients);\n                    Address new_coord=clients.first();\n                    if(new_coord.equals(mbr)) {\n                        if(log.isTraceEnabled())\n                            log.trace(\"I (\" + mbr + \") am the first of the clients, will become coordinator\");\n                        becomeSingletonMember(mbr);\n                        return;\n                    }\n                    else {\n                        if(log.isTraceEnabled())\n                            log.trace(\"I (\" + mbr\n                                    + \") am not the first of the clients, waiting for another client to become coordinator\");\n                        Util.sleep(500);\n                    }\n                    continue;\n                }\n\n                if(log.isDebugEnabled())\n                    log.debug(\"sending JOIN(\" + mbr + \") to \" + coord);\n                sendJoinMessage(coord,mbr,joinWithStateTransfer,useFlushIfPresent);\n            }\n\n            if(rsp == null)\n                rsp=join_promise.getResult(gms.join_timeout);\n            if(rsp == null) {\n                join_attempts++;\n                if(log.isWarnEnabled())\n                    log.warn(\"JOIN(\" + mbr + \") sent to \" + coord + \" timed out (after \" + gms.join_timeout + \" ms), on try \" + join_attempts);\n\n                if(gms.max_join_attempts != 0 && join_attempts >= gms.max_join_attempts) {\n                    if(log.isWarnEnabled())\n                        log.warn(\"Too many JOIN attempts: becoming singleton\");\n                    becomeSingletonMember(mbr);\n                    return;\n                }\n                continue;\n            }\n\n            // 1. check whether JOIN was rejected\n            String failure=rsp.getFailReason();\n            if(failure != null)\n                throw new SecurityException(failure);\n\n            // 2. Install digest\n            if(rsp.getDigest() == null || rsp.getDigest().size() == 0) {\n                if(log.isWarnEnabled())\n                    log.warn(\"digest response has no senders: digest=\" + rsp.getDigest());\n                rsp=null;\n                continue;\n            }\n            final Digest tmp_digest=rsp.getDigest();\n            tmp_view=rsp.getView();\n            if(tmp_view == null) {\n                if(log.isErrorEnabled())\n                    log.error(\"JoinRsp has a null view, skipping it\");\n                rsp=null;\n            }\n            else {\n                if(!tmp_digest.contains(gms.local_addr)) {\n                    throw new IllegalStateException(\"digest returned from \" + coord + \" with JOIN_RSP does not contain myself (\" +\n                                                      gms.local_addr + \"): join response: \" + rsp);\n                }\n\n                if(log.isTraceEnabled())\n                    log.trace(gms.local_addr + \": JOIN-RSP=\" + tmp_view + \" [size=\" + tmp_view.size() + \"]\\n\\n\");\n\n                if(!installView(tmp_view, tmp_digest)) {\n                    if(log.isErrorEnabled())\n                        log.error(\"view installation failed, retrying to join group\");\n                    rsp=null;\n                    continue;\n                }\n\n                // send VIEW_ACK to sender of view\n                Message view_ack=new Message(coord, null, null);\n                view_ack.setFlag(Message.OOB);\n                GMS.GmsHeader tmphdr=new GMS.GmsHeader(GMS.GmsHeader.VIEW_ACK);\n                view_ack.putHeader(gms.getId(), tmphdr);\n                gms.getDownProtocol().down(new Event(Event.MSG, view_ack));\n                return;\n            }\n        }\n    }","id":97463,"modified_method":"/**\n     * Joins this process to a group. Determines the coordinator and sends a\n     * unicast handleJoin() message to it. The coordinator returns a JoinRsp and\n     * then broadcasts the new view, which contains a message digest and the\n     * current membership (including the joiner). The joiner is then supposed to\n     * install the new view and the digest and starts accepting mcast messages.\n     * Previous mcast messages were discarded (this is done in PBCAST).\n     * <p>\n     * If successful, impl is changed to an instance of ParticipantGmsImpl.\n     * Otherwise, we continue trying to send join() messages to the coordinator,\n     * until we succeed (or there is no member in the group. In this case, we\n     * create our own singleton group).\n     * <p>\n     * When GMS.disable_initial_coord is set to true, then we won't become\n     * coordinator on receiving an initial membership of 0, but instead will\n     * retry (forever) until we get an initial membership of > 0.\n     *\n     * @param mbr Our own address (assigned through SET_LOCAL_ADDRESS)\n     */\n    private void joinInternal(Address mbr, boolean joinWithStateTransfer,boolean useFlushIfPresent) {\n        Address coord=null;\n        JoinRsp rsp=null;\n        View tmp_view;\n        long join_attempts=0;\n        leaving=false;\n\n        join_promise.reset();\n        while(!leaving) {\n            if(rsp == null && !join_promise.hasResult()) { // null responses means that the discovery was cancelled\n                List<PingData> responses=findInitialMembers(join_promise);\n                if (responses == null) {\n                    // gray: we've seen this NPE here.  not sure of the cases but wanted to add more debugging info\n                    throw new NullPointerException(\"responses returned by findInitialMembers for \" + join_promise + \" is null\");\n                }\n                // Sept 2008 (bela): break if we got a belated JoinRsp (https://jira.jboss.org/jira/browse/JGRP-687)\n                // Reverted above change again - bela June 2012, see https://github.com/belaban/JGroups/pull/29\n                if(join_promise.hasResult()) {\n                    rsp=join_promise.getResult(gms.join_timeout); // clears the result\n                    if(rsp != null)\n                        continue;\n                }\n                if(responses.isEmpty()) {\n                    if(log.isTraceEnabled())\n                        log.trace(gms.local_addr + \": no initial members discovered: creating group as first member\");\n                    becomeSingletonMember(mbr);\n                    return;\n                }\n                if(log.isTraceEnabled())\n                    log.trace(gms.local_addr + \": initial_mbrs are \" + print(responses));\n\n                coord=determineCoord(responses);\n                if(coord == null) { // e.g. because we have all clients only\n                    if(gms.handle_concurrent_startup == false) {\n                        if(log.isTraceEnabled())\n                            log.trace(\"handle_concurrent_startup is false; ignoring responses of initial clients\");\n                        becomeSingletonMember(mbr);\n                        return;\n                    }\n\n                    if(log.isTraceEnabled())\n                        log.trace(\"could not determine coordinator from responses \" + responses);\n\n                    // so the member to become singleton member (and thus coord) is the first of all clients\n                    SortedSet<Address> clients=new TreeSet<Address>(); // sorted\n                    clients.add(mbr); // add myself again (was removed by findInitialMembers())\n                    for(PingData response: responses) {\n                        Address client_addr=response.getAddress();\n                        if(client_addr != null)\n                            clients.add(client_addr);\n                    }\n                    if(log.isTraceEnabled())\n                        log.trace(\"clients to choose new coord from are: \" + clients);\n                    Address new_coord=clients.first();\n                    if(new_coord.equals(mbr)) {\n                        if(log.isTraceEnabled())\n                            log.trace(\"I (\" + mbr + \") am the first of the clients, will become coordinator\");\n                        becomeSingletonMember(mbr);\n                        return;\n                    }\n                    else {\n                        if(log.isTraceEnabled())\n                            log.trace(\"I (\" + mbr\n                                    + \") am not the first of the clients, waiting for another client to become coordinator\");\n                        Util.sleep(500);\n                    }\n                    continue;\n                }\n\n                if(log.isDebugEnabled())\n                    log.debug(\"sending JOIN(\" + mbr + \") to \" + coord);\n                sendJoinMessage(coord,mbr,joinWithStateTransfer,useFlushIfPresent);\n            }\n\n            if(rsp == null)\n                rsp=join_promise.getResult(gms.join_timeout);\n            if(rsp == null) {\n                join_attempts++;\n                if(log.isWarnEnabled())\n                    log.warn(\"JOIN(\" + mbr + \") sent to \" + coord + \" timed out (after \" + gms.join_timeout + \" ms), on try \" + join_attempts);\n\n                if(gms.max_join_attempts != 0 && join_attempts >= gms.max_join_attempts) {\n                    if(log.isWarnEnabled())\n                        log.warn(\"Too many JOIN attempts: becoming singleton\");\n                    becomeSingletonMember(mbr);\n                    return;\n                }\n                continue;\n            }\n\n            // 1. check whether JOIN was rejected\n            String failure=rsp.getFailReason();\n            if(failure != null)\n                throw new SecurityException(failure);\n\n            // 2. Install digest\n            if(rsp.getDigest() == null || rsp.getDigest().size() == 0) {\n                if(log.isWarnEnabled())\n                    log.warn(\"digest response has no senders: digest=\" + rsp.getDigest());\n                rsp=null;\n                continue;\n            }\n            final Digest tmp_digest=rsp.getDigest();\n            tmp_view=rsp.getView();\n            if(tmp_view == null) {\n                if(log.isErrorEnabled())\n                    log.error(\"JoinRsp has a null view, skipping it\");\n                rsp=null;\n            }\n            else {\n                if(!tmp_digest.contains(gms.local_addr)) {\n                    throw new IllegalStateException(\"digest returned from \" + coord + \" with JOIN_RSP does not contain myself (\" +\n                                                      gms.local_addr + \"): join response: \" + rsp);\n                }\n\n                if(log.isTraceEnabled())\n                    log.trace(gms.local_addr + \": JOIN-RSP=\" + tmp_view + \" [size=\" + tmp_view.size() + \"]\\n\\n\");\n\n                if(!installView(tmp_view, tmp_digest)) {\n                    if(log.isErrorEnabled())\n                        log.error(\"view installation failed, retrying to join group\");\n                    rsp=null;\n                    continue;\n                }\n\n                // send VIEW_ACK to sender of view\n                Message view_ack=new Message(coord).setFlag(Message.OOB)\n                  .putHeader(gms.getId(), new GMS.GmsHeader(GMS.GmsHeader.VIEW_ACK));\n                gms.getDownProtocol().down(new Event(Event.MSG, view_ack));\n                return;\n            }\n        }\n    }","commit_id":"ca0281e2562b51644fe32a15c5663d1e77bda1da","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendDiscoveryRequest(String cluster_name, Promise promise, ViewId view_id) throws Exception {\n        PingData data=null;\n        PhysicalAddress physical_addr=(PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr));\n\n        if(view_id == null)\n            data=new PingData(local_addr, null, false, UUID.get(local_addr), Arrays.asList(physical_addr));\n\n        PingHeader hdr=new PingHeader(PingHeader.GET_MBRS_REQ, data, cluster_name);\n        hdr.view_id=view_id;\n\n        Collection<PhysicalAddress> cluster_members=fetchClusterMembers(cluster_name);\n        if(cluster_members == null) {\n            Message msg=new Message(null);  // multicast msg\n            msg.setFlag(Message.OOB);\n            msg.putHeader(getId(), hdr);\n            sendMcastDiscoveryRequest(msg);\n        }\n        else {\n            if(use_disk_cache) {\n                // this only makes sense if we have PDC below us\n                Collection<PhysicalAddress> list=(Collection<PhysicalAddress>)down_prot.down(new Event(Event.GET_PHYSICAL_ADDRESSES));\n                if(list != null)\n                    for(PhysicalAddress phys_addr: list)\n                        if(!cluster_members.contains(phys_addr))\n                            cluster_members.add(phys_addr);\n            }\n\n            if(cluster_members.isEmpty()) { // if we don't find any members, return immediately\n                if(promise != null)\n                    promise.setResult(null);\n            }\n            else {\n                for(final Address addr: cluster_members) {\n                    if(addr.equals(physical_addr)) // no need to send the request to myself\n                        continue;\n                    final Message msg=new Message(addr, null, null);\n                    msg.setFlag(Message.OOB);\n                    msg.putHeader(this.id, hdr);\n                    if(log.isTraceEnabled())\n                        log.trace(local_addr + \": sending discovery request to \" + msg.getDest());\n                    if(!sendDiscoveryRequestsInParallel()) {\n                        down_prot.down(new Event(Event.MSG, msg));\n                    }\n                    else {\n                        timer.execute(new Runnable() {\n                            public void run() {\n                                try {\n                                    down_prot.down(new Event(Event.MSG, msg));\n                                }\n                                catch(Exception ex){\n                                    if(log.isErrorEnabled())\n                                        log.error(local_addr + \": failed sending discovery request to \" + addr + \": \" +  ex);\n                                }\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }","id":97464,"modified_method":"public void sendDiscoveryRequest(String cluster_name, Promise promise, ViewId view_id) throws Exception {\n        PingData data=null;\n        PhysicalAddress physical_addr=(PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr));\n\n        if(view_id == null)\n            data=new PingData(local_addr, null, false, UUID.get(local_addr), Arrays.asList(physical_addr));\n\n        PingHeader hdr=new PingHeader(PingHeader.GET_MBRS_REQ, data, cluster_name);\n        hdr.view_id=view_id;\n\n        Collection<PhysicalAddress> cluster_members=fetchClusterMembers(cluster_name);\n        if(cluster_members == null) {\n            // multicast msg\n            Message msg=new Message(null).setFlag(Message.OOB).putHeader(getId(), hdr);\n            sendMcastDiscoveryRequest(msg);\n        }\n        else {\n            if(use_disk_cache) {\n                // this only makes sense if we have PDC below us\n                Collection<PhysicalAddress> list=(Collection<PhysicalAddress>)down_prot.down(new Event(Event.GET_PHYSICAL_ADDRESSES));\n                if(list != null)\n                    for(PhysicalAddress phys_addr: list)\n                        if(!cluster_members.contains(phys_addr))\n                            cluster_members.add(phys_addr);\n            }\n\n            if(cluster_members.isEmpty()) { // if we don't find any members, return immediately\n                if(promise != null)\n                    promise.setResult(null);\n            }\n            else {\n                for(final Address addr: cluster_members) {\n                    if(addr.equals(physical_addr)) // no need to send the request to myself\n                        continue;\n                    final Message msg=new Message(addr, null, null);\n                    msg.setFlag(Message.OOB);\n                    msg.putHeader(this.id, hdr);\n                    if(log.isTraceEnabled())\n                        log.trace(local_addr + \": sending discovery request to \" + msg.getDest());\n                    if(!sendDiscoveryRequestsInParallel()) {\n                        down_prot.down(new Event(Event.MSG, msg));\n                    }\n                    else {\n                        timer.execute(new Runnable() {\n                            public void run() {\n                                try {\n                                    down_prot.down(new Event(Event.MSG, msg));\n                                }\n                                catch(Exception ex){\n                                    if(log.isErrorEnabled())\n                                        log.error(local_addr + \": failed sending discovery request to \" + addr + \": \" +  ex);\n                                }\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }","commit_id":"a440dad481fbf7522b0a0db921c813c5e3e07de0","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void sendDiscoveryResponse(Address logical_addr, List<PhysicalAddress> physical_addrs,\n                                         boolean is_server, boolean return_view_only, String logical_name, final Address sender) {\n        PingData data;\n        if(return_view_only) {\n            data=new PingData(logical_addr, view, is_server, null, null);\n        }\n        else {\n            ViewId view_id=view != null? view.getViewId() : null;\n            data=new PingData(logical_addr, null, view_id, is_server, logical_name, physical_addrs);\n        }\n\n        final Message rsp_msg=new Message(sender, null, null);\n        rsp_msg.setFlag(Message.OOB);\n        final PingHeader rsp_hdr=new PingHeader(PingHeader.GET_MBRS_RSP, data);\n        rsp_msg.putHeader(this.id, rsp_hdr);\n\n        if(stagger_timeout > 0) {\n            int view_size=view != null? view.size() : 10;\n            int rank=Util.getRank(view, local_addr); // returns 0 if view or local_addr are null\n            long sleep_time=rank == 0? Util.random(stagger_timeout)\n              : stagger_timeout * rank / view_size - (stagger_timeout / view_size);\n            timer.schedule(new Runnable() {\n                public void run() {\n                    if(log.isTraceEnabled())\n                        log.trace(local_addr + \": received GET_MBRS_REQ from \" + sender + \", sending staggered response \" + rsp_hdr);\n                    down_prot.down(new Event(Event.MSG, rsp_msg));\n                }\n            }, sleep_time, TimeUnit.MILLISECONDS);\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(local_addr + \": received GET_MBRS_REQ from \" + sender + \", sending response \" + rsp_hdr);\n        down_prot.down(new Event(Event.MSG, rsp_msg));\n    }","id":97465,"modified_method":"protected void sendDiscoveryResponse(Address logical_addr, List<PhysicalAddress> physical_addrs,\n                                         boolean is_server, boolean return_view_only, String logical_name, final Address sender) {\n        PingData data;\n        if(return_view_only) {\n            data=new PingData(logical_addr, view, is_server, null, null);\n        }\n        else {\n            ViewId view_id=view != null? view.getViewId() : null;\n            data=new PingData(logical_addr, null, view_id, is_server, logical_name, physical_addrs);\n        }\n\n        final Message rsp_msg=new Message(sender).setFlag(Message.OOB);\n        final PingHeader rsp_hdr=new PingHeader(PingHeader.GET_MBRS_RSP, data);\n        rsp_msg.putHeader(this.id, rsp_hdr);\n\n        if(stagger_timeout > 0) {\n            int view_size=view != null? view.size() : 10;\n            int rank=Util.getRank(view, local_addr); // returns 0 if view or local_addr are null\n            long sleep_time=rank == 0? Util.random(stagger_timeout)\n              : stagger_timeout * rank / view_size - (stagger_timeout / view_size);\n            timer.schedule(new Runnable() {\n                public void run() {\n                    if(log.isTraceEnabled())\n                        log.trace(local_addr + \": received GET_MBRS_REQ from \" + sender + \", sending staggered response \" + rsp_hdr);\n                    down_prot.down(new Event(Event.MSG, rsp_msg));\n                }\n            }, sleep_time, TimeUnit.MILLISECONDS);\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(local_addr + \": received GET_MBRS_REQ from \" + sender + \", sending response \" + rsp_hdr);\n        down_prot.down(new Event(Event.MSG, rsp_msg));\n    }","commit_id":"a440dad481fbf7522b0a0db921c813c5e3e07de0","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * An event was received from the layer below. Usually the current layer will want to examine\n     * the event type and - depending on its type - perform some computation\n     * (e.g. removing headers from a MSG event type, or updating the internal membership list\n     * when receiving a VIEW_CHANGE event).\n     * Finally the event is either a) discarded, or b) an event is sent down\n     * the stack using <code>PassDown<\/code> or c) the event (or another event) is sent up\n     * the stack using <code>PassUp<\/code>.\n     * <p/>\n     * For the PING protocol, the Up operation does the following things.\n     * 1. If the event is a Event.MSG then PING will inspect the message header.\n     * If the header is null, PING simply passes up the event\n     * If the header is PingHeader.GET_MBRS_REQ then the PING protocol\n     * will PassDown a PingRequest message\n     * If the header is PingHeader.GET_MBRS_RSP we will add the message to the initial members\n     * vector and wake up any waiting threads.\n     * 2. If the event is Event.SET_LOCAL_ADDR we will simple set the local address of this protocol\n     * 3. For all other messages we simple pass it up to the protocol above\n     *\n     * @param evt - the event that has been sent from the layer below\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public Object up(Event evt) {\n\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                PingHeader hdr=(PingHeader)msg.getHeader(this.id);\n                if(hdr == null)\n                    return up_prot.up(evt);\n\n                PingData data=hdr.data;\n                Address logical_addr=data != null? data.getAddress() : null;\n\n                if(is_leaving)\n                    return null; // prevents merging back a leaving member (https://issues.jboss.org/browse/JGRP-1336)\n\n                switch(hdr.type) {\n\n                    case PingHeader.GET_MBRS_REQ:   // return Rsp(local_addr, coord)\n                        if(group_addr == null || hdr.cluster_name == null) {\n                            if(log.isWarnEnabled())\n                                log.warn(\"group_addr (\" + group_addr + \") or cluster_name of header (\" + hdr.cluster_name\n                                        + \") is null; passing up discovery request from \" + msg.getSrc() + \", but this should not\" +\n                                        \" be the case\");\n                        }\n                        else {\n                            if(!group_addr.equals(hdr.cluster_name)) {\n                                if(log.isWarnEnabled())\n                                    log.warn(local_addr + \": discarding discovery request for cluster '\" + hdr.cluster_name + \"' from \" +\n                                            msg.getSrc() + \"; our cluster name is '\" + group_addr + \"'. \" +\n                                            \"Please separate your clusters cleanly.\");\n                                return null;\n                            }\n                        }\n\n                        // add physical address and logical name of the discovery sender (if available) to the cache\n                        if(data != null) {\n                            if(logical_addr == null)\n                                logical_addr=msg.getSrc();\n                            Collection<PhysicalAddress> physical_addrs=data.getPhysicalAddrs();\n                            PhysicalAddress physical_addr=physical_addrs != null && !physical_addrs.isEmpty()? physical_addrs.iterator().next() : null;\n                            if(logical_addr != null && data.getLogicalName() != null)\n                                UUID.add(logical_addr, data.getLogicalName());\n                            if(logical_addr != null && physical_addr != null)\n                                down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address,PhysicalAddress>(logical_addr, physical_addr)));\n                            discoveryRequestReceived(msg.getSrc(), data.getLogicalName(), physical_addrs);\n\n                            synchronized(ping_responses) {\n                                for(Responses response: ping_responses) {\n                                    response.addResponse(data, false);\n                                }\n                            }\n                        }\n\n                        if(hdr.view_id != null) {\n                            // If the discovery request is merge-triggered, and the ViewId shipped with it\n                            // is the same as ours, we don't respond (JGRP-1315).\n                            ViewId my_view_id=view != null? view.getViewId() : null;\n                            if(my_view_id != null && my_view_id.equals(hdr.view_id))\n                                return null;\n\n                            boolean send_discovery_rsp=force_sending_discovery_rsps || is_coord\n                              || current_coord == null || current_coord.equals(msg.getSrc());\n                            if(!send_discovery_rsp) {\n                                if(log.isTraceEnabled())\n                                    log.trace(local_addr + \": suppressing discovery response as I'm not a coordinator and the \" +\n                                                \"discovery request was not sent by a coordinator\");\n                                return null;\n                            }\n                        }\n\n                        if(isMergeRunning()) {\n                            if(log.isTraceEnabled())\n                                log.trace(local_addr + \": suppressing discovery response as a merge is in progress\");\n                            return null;\n                        }\n\n                        if(return_entire_cache) {\n                            Map<Address,PhysicalAddress> cache=(Map<Address,PhysicalAddress>)down(new Event(Event.GET_LOGICAL_PHYSICAL_MAPPINGS));\n                            if(cache != null) {\n                                for(Map.Entry<Address,PhysicalAddress> entry: cache.entrySet()) {\n                                    Address addr=entry.getKey();\n                                    // JGRP-1492: only return our own address, and addresses in view.\n                                    if (addr.equals(local_addr) || members.contains(addr)) {\n                                        PhysicalAddress physical_addr=entry.getValue();\n                                        sendDiscoveryResponse(addr, Arrays.asList(physical_addr), is_server,\n                                                              hdr.view_id != null, UUID.get(addr), msg.getSrc());\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            List<PhysicalAddress> physical_addrs=hdr.view_id != null? null :\n                              Arrays.asList((PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr)));\n                            sendDiscoveryResponse(local_addr, physical_addrs, is_server, hdr.view_id != null,\n                                                  UUID.get(local_addr), msg.getSrc());\n                        }\n                        return null;\n\n                    case PingHeader.GET_MBRS_RSP:   // add response to vector and notify waiting thread\n                        // add physical address (if available) to transport's cache\n                        if(data != null) {\n                            Address response_sender=msg.getSrc();\n                            if(logical_addr == null)\n                                logical_addr=msg.getSrc();\n                            Collection<PhysicalAddress> addrs=data.getPhysicalAddrs();\n                            PhysicalAddress physical_addr=addrs != null && !addrs.isEmpty()?\n                                    addrs.iterator().next() : null;\n                            if(logical_addr != null && data.getLogicalName() != null)\n                                UUID.add(logical_addr, data.getLogicalName());\n                            if(logical_addr != null && physical_addr != null)\n                                down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address,PhysicalAddress>(logical_addr, physical_addr)));\n\n                            if(log.isTraceEnabled())\n                                log.trace(local_addr + \": received GET_MBRS_RSP from \" + response_sender + \": \" + data);\n                            boolean overwrite=logical_addr != null && logical_addr.equals(response_sender);\n                            synchronized(ping_responses) {\n                                for(Responses response: ping_responses) {\n                                    response.addResponse(data, overwrite);\n                                }\n                            }\n                        }\n                        return null;\n\n                    default:\n                        if(log.isWarnEnabled()) log.warn(\"got PING header with unknown type (\" + hdr.type + ')');\n                        return null;\n                }\n\n\n            case Event.GET_PHYSICAL_ADDRESS:\n                try {\n                    sendDiscoveryRequest(group_addr, null, null);\n                }\n                catch(InterruptedIOException ie) {\n                    if(log.isWarnEnabled()){\n                        log.warn(\"Discovery request for cluster \" + group_addr + \" interrupted\");\n                    }\n                    Thread.currentThread().interrupt();\n                }\n                catch(Exception ex) {\n                    if(log.isErrorEnabled())\n                        log.error(\"failed sending discovery request\", ex);\n                }\n                return null;\n\n\n            case Event.FIND_INITIAL_MBRS:      // sent by transport\n                return findInitialMembers(null);\n        }\n\n        return up_prot.up(evt);\n    }","id":97466,"modified_method":"/**\n     * An event was received from the layer below. Usually the current layer will want to examine\n     * the event type and - depending on its type - perform some computation\n     * (e.g. removing headers from a MSG event type, or updating the internal membership list\n     * when receiving a VIEW_CHANGE event).\n     * Finally the event is either a) discarded, or b) an event is sent down\n     * the stack using <code>PassDown<\/code> or c) the event (or another event) is sent up\n     * the stack using <code>PassUp<\/code>.\n     * <p/>\n     * For the PING protocol, the Up operation does the following things.\n     * 1. If the event is a Event.MSG then PING will inspect the message header.\n     * If the header is null, PING simply passes up the event\n     * If the header is PingHeader.GET_MBRS_REQ then the PING protocol\n     * will PassDown a PingRequest message\n     * If the header is PingHeader.GET_MBRS_RSP we will add the message to the initial members\n     * vector and wake up any waiting threads.\n     * 2. If the event is Event.SET_LOCAL_ADDR we will simple set the local address of this protocol\n     * 3. For all other messages we simple pass it up to the protocol above\n     *\n     * @param evt - the event that has been sent from the layer below\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public Object up(Event evt) {\n\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                PingHeader hdr=(PingHeader)msg.getHeader(this.id);\n                if(hdr == null)\n                    return up_prot.up(evt);\n\n                PingData data=hdr.data;\n                Address logical_addr=data != null? data.getAddress() : null;\n\n                if(is_leaving)\n                    return null; // prevents merging back a leaving member (https://issues.jboss.org/browse/JGRP-1336)\n\n                switch(hdr.type) {\n\n                    case PingHeader.GET_MBRS_REQ:   // return Rsp(local_addr, coord)\n                        if(group_addr == null || hdr.cluster_name == null) {\n                            if(log.isWarnEnabled())\n                                log.warn(\"group_addr (\" + group_addr + \") or cluster_name of header (\" + hdr.cluster_name\n                                        + \") is null; passing up discovery request from \" + msg.getSrc() + \", but this should not\" +\n                                        \" be the case\");\n                        }\n                        else {\n                            if(!group_addr.equals(hdr.cluster_name)) {\n                                if(log.isWarnEnabled())\n                                    log.warn(local_addr + \": discarding discovery request for cluster '\" + hdr.cluster_name + \"' from \" +\n                                            msg.getSrc() + \"; our cluster name is '\" + group_addr + \"'. \" +\n                                            \"Please separate your clusters cleanly.\");\n                                return null;\n                            }\n                        }\n\n                        // add physical address and logical name of the discovery sender (if available) to the cache\n                        if(data != null) {\n                            if(logical_addr == null)\n                                logical_addr=msg.getSrc();\n                            Collection<PhysicalAddress> physical_addrs=data.getPhysicalAddrs();\n                            PhysicalAddress physical_addr=physical_addrs != null && !physical_addrs.isEmpty()? physical_addrs.iterator().next() : null;\n                            if(logical_addr != null && data.getLogicalName() != null)\n                                UUID.add(logical_addr, data.getLogicalName());\n                            if(logical_addr != null && physical_addr != null)\n                                down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address,PhysicalAddress>(logical_addr, physical_addr)));\n                            discoveryRequestReceived(msg.getSrc(), data.getLogicalName(), physical_addrs);\n\n                            synchronized(ping_responses) {\n                                for(Responses response: ping_responses) {\n                                    response.addResponse(data, false);\n                                }\n                            }\n                        }\n\n                        if(hdr.view_id != null) {\n                            // If the discovery request is merge-triggered, and the ViewId shipped with it\n                            // is the same as ours, we don't respond (JGRP-1315).\n                            ViewId my_view_id=view != null? view.getViewId() : null;\n                            if(my_view_id != null && my_view_id.equals(hdr.view_id))\n                                return null;\n\n                            boolean send_discovery_rsp=force_sending_discovery_rsps || is_coord\n                              || current_coord == null || current_coord.equals(msg.getSrc());\n                            if(!send_discovery_rsp) {\n                                if(log.isTraceEnabled())\n                                    log.trace(local_addr + \": suppressing discovery response as I'm not a coordinator and the \" +\n                                                \"discovery request was not sent by a coordinator\");\n                                return null;\n                            }\n                            if(isMergeRunning()) {\n                                if(log.isTraceEnabled())\n                                    log.trace(local_addr + \": suppressing discovery response as a merge is in progress\");\n                                return null;\n                            }\n                        }\n\n\n                        if(return_entire_cache) {\n                            Map<Address,PhysicalAddress> cache=(Map<Address,PhysicalAddress>)down(new Event(Event.GET_LOGICAL_PHYSICAL_MAPPINGS));\n                            if(cache != null) {\n                                for(Map.Entry<Address,PhysicalAddress> entry: cache.entrySet()) {\n                                    Address addr=entry.getKey();\n                                    // JGRP-1492: only return our own address, and addresses in view.\n                                    if (addr.equals(local_addr) || members.contains(addr)) {\n                                        PhysicalAddress physical_addr=entry.getValue();\n                                        sendDiscoveryResponse(addr, Arrays.asList(physical_addr), is_server,\n                                                              hdr.view_id != null, UUID.get(addr), msg.getSrc());\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            List<PhysicalAddress> physical_addrs=hdr.view_id != null? null :\n                              Arrays.asList((PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr)));\n                            sendDiscoveryResponse(local_addr, physical_addrs, is_server, hdr.view_id != null,\n                                                  UUID.get(local_addr), msg.getSrc());\n                        }\n                        return null;\n\n                    case PingHeader.GET_MBRS_RSP:   // add response to vector and notify waiting thread\n                        // add physical address (if available) to transport's cache\n                        if(data != null) {\n                            Address response_sender=msg.getSrc();\n                            if(logical_addr == null)\n                                logical_addr=msg.getSrc();\n                            Collection<PhysicalAddress> addrs=data.getPhysicalAddrs();\n                            PhysicalAddress physical_addr=addrs != null && !addrs.isEmpty()?\n                                    addrs.iterator().next() : null;\n                            if(logical_addr != null && data.getLogicalName() != null)\n                                UUID.add(logical_addr, data.getLogicalName());\n                            if(logical_addr != null && physical_addr != null)\n                                down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address,PhysicalAddress>(logical_addr, physical_addr)));\n\n                            if(log.isTraceEnabled())\n                                log.trace(local_addr + \": received GET_MBRS_RSP from \" + response_sender + \": \" + data);\n                            boolean overwrite=logical_addr != null && logical_addr.equals(response_sender);\n                            synchronized(ping_responses) {\n                                for(Responses response: ping_responses) {\n                                    response.addResponse(data, overwrite);\n                                }\n                            }\n                        }\n                        return null;\n\n                    default:\n                        if(log.isWarnEnabled()) log.warn(\"got PING header with unknown type (\" + hdr.type + ')');\n                        return null;\n                }\n\n\n            case Event.GET_PHYSICAL_ADDRESS:\n                try {\n                    sendDiscoveryRequest(group_addr, null, null);\n                }\n                catch(InterruptedIOException ie) {\n                    if(log.isWarnEnabled()){\n                        log.warn(\"Discovery request for cluster \" + group_addr + \" interrupted\");\n                    }\n                    Thread.currentThread().interrupt();\n                }\n                catch(Exception ex) {\n                    if(log.isErrorEnabled())\n                        log.error(\"failed sending discovery request\", ex);\n                }\n                return null;\n\n\n            case Event.FIND_INITIAL_MBRS:      // sent by transport\n                return findInitialMembers(null);\n        }\n\n        return up_prot.up(evt);\n    }","commit_id":"a440dad481fbf7522b0a0db921c813c5e3e07de0","url":"https://github.com/belaban/JGroups"},{"original_method":"private void stopBroadcastTask() {\n            bcast_lock.lock();\n            try {\n                if(bcast_future != null) {\n                    bcast_future.cancel(true);\n                    bcast_future=null;\n                    task=null;\n                }\n            }\n            finally {\n                bcast_lock.unlock();\n            }\n        }","id":97467,"modified_method":"protected void stopBroadcastTask() {\n            bcast_lock.lock();\n            try {\n                if(bcast_future != null) {\n                    bcast_future.cancel(true);\n                    bcast_future=null;\n                    task=null;\n                }\n            }\n            finally {\n                bcast_lock.unlock();\n            }\n        }","commit_id":"19404eee46a18dcb365bd082e44c14e566d0a49c","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        lock.lock();\n        try {\n            stopMonitor();\n        }\n        finally {\n            lock.unlock();\n        }\n    }","id":97468,"modified_method":"public void stop() {\n        lock.lock();\n        try {\n            stopMonitor();\n            ping_dest=null;\n        }\n        finally {\n            lock.unlock();\n        }\n    }","commit_id":"19404eee46a18dcb365bd082e44c14e566d0a49c","url":"https://github.com/belaban/JGroups"},{"original_method":"List<Address> getSuspectedMembers() {\n            return suspected_mbrs;\n        }","id":97469,"modified_method":"protected List<Address> getSuspectedMembers() {\n            return suspected_mbrs;\n        }","commit_id":"19404eee46a18dcb365bd082e44c14e566d0a49c","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            Message hb_req;\n            long not_heard_from; // time in msecs we haven't heard from ping_dest\n            Address dest=null;\n\n            lock.lock();\n            try {\n                if(ping_dest == null) {\n                    if(log.isWarnEnabled())\n                        log.warn(local_addr + \": ping_dest is null: members=\" + members + \", pingable_mbrs=\" +\n                                   pingable_mbrs + \", local_addr=\" + local_addr);\n                    return;\n                }\n                else\n                    dest=ping_dest;\n            }\n            finally {\n                lock.unlock();\n            }\n\n\n            // 1. send heartbeat request\n            hb_req=new Message(dest, null, null);\n            hb_req.setFlag(Message.OOB);\n            hb_req.putHeader(id, new FdHeader(FdHeader.HEARTBEAT));  // send heartbeat request\n            if(log.isDebugEnabled())\n                log.debug(local_addr + \": sending are-you-alive msg to \" + dest + \" (own address=\" + local_addr + ')');\n            down_prot.down(new Event(Event.MSG, hb_req));\n            num_heartbeats++;\n\n            // 2. If the time of the last heartbeat is > timeout and max_tries heartbeat messages have not been\n            //    received, then broadcast a SUSPECT message. Will be handled by coordinator, which may install\n            //    a new view\n            not_heard_from=System.currentTimeMillis() - last_ack;\n            // quick & dirty fix: increase timeout by 500msecs to allow for latency (bela June 27 2003)\n            if(not_heard_from > timeout + 500) { // no heartbeat ack for more than timeout msecs\n                if(num_tries >= max_tries) {\n                    if(log.isDebugEnabled())\n                        log.debug(local_addr + \": received no heartbeat ack from \" + dest + \" for \" + (num_tries +1) +\n                                    \" times (\" + ((num_tries+1) * timeout) + \" milliseconds), suspecting it\");\n                    // broadcast a SUSPECT message to all members - loop until\n                    // unsuspect or view change is received\n                    bcast_task.addSuspectedMember(dest);\n                    num_tries=0;\n                    if(stats) {\n                        num_suspect_events++;\n                        suspect_history.add(dest);\n                    }\n                }\n                else {\n                    if(log.isDebugEnabled())\n                        log.debug(local_addr + \": heartbeat missing from \" + dest + \" (number=\" + num_tries + ')');\n                    num_tries++;\n                }\n            }\n        }","id":97470,"modified_method":"public void run() {\n            Address dest=null;\n            lock.lock();\n            try {\n                if(ping_dest == null) {\n                    if(log.isWarnEnabled())\n                        log.warn(local_addr + \": ping_dest is null: members=\" + members + \", pingable_mbrs=\" +\n                                   pingable_mbrs + \", local_addr=\" + local_addr);\n                    return;\n                }\n                dest=ping_dest;\n            }\n            finally {\n                lock.unlock();\n            }\n\n\n            // 1. send heartbeat request\n            Message hb_req=new Message(dest).setFlag(Message.OOB).putHeader(id, new FdHeader(FdHeader.HEARTBEAT));\n            if(log.isDebugEnabled())\n                log.debug(local_addr + \": sending are-you-alive msg to \" + dest + \" (own address=\" + local_addr + ')');\n            down_prot.down(new Event(Event.MSG, hb_req));\n            num_heartbeats++;\n\n            // 2. If the time of the last heartbeat is > timeout and max_tries heartbeat messages have not been\n            //    received, then broadcast a SUSPECT message. Will be handled by coordinator, which may install\n            //    a new view\n            long not_heard_from=System.currentTimeMillis() - last_ack; // time in msecs we haven't heard from ping_dest\n            // quick & dirty fix: increase timeout by 500msecs to allow for latency (bela June 27 2003)\n            if(not_heard_from > timeout + 500) { // no heartbeat ack for more than timeout msecs\n                if(num_tries >= max_tries) {\n                    if(log.isDebugEnabled())\n                        log.debug(local_addr + \": received no heartbeat ack from \" + dest + \" for \" + (num_tries +1) +\n                                    \" times (\" + ((num_tries+1) * timeout) + \" milliseconds), suspecting it\");\n                    // broadcast a SUSPECT message to all members - loop until unsuspect or view change is received\n                    bcast_task.addSuspectedMember(dest);\n                    num_tries=0;\n                    if(stats) {\n                        num_suspect_events++;\n                        suspect_history.add(dest);\n                    }\n                }\n                else {\n                    if(log.isDebugEnabled())\n                        log.debug(local_addr + \": heartbeat missing from \" + dest + \" (number=\" + num_tries + ')');\n                    num_tries++;\n                }\n            }\n        }","commit_id":"19404eee46a18dcb365bd082e44c14e566d0a49c","url":"https://github.com/belaban/JGroups"},{"original_method":"@GuardedBy(\"lock\")\n    private void unsuspect(Address mbr) {\n        lock.lock();\n        try {\n            bcast_task.removeSuspectedMember(mbr);\n            pingable_mbrs.clear();\n            pingable_mbrs.addAll(members);\n            pingable_mbrs.removeAll(bcast_task.getSuspectedMembers());\n            restartMonitor();\n        }\n        finally {\n            lock.unlock();\n        }\n    }","id":97471,"modified_method":"@GuardedBy(\"lock\")\n    protected void unsuspect(Address mbr) {\n        lock.lock();\n        try {\n            bcast_task.removeSuspectedMember(mbr);\n            pingable_mbrs.clear();\n            pingable_mbrs.addAll(members);\n            pingable_mbrs.removeAll(bcast_task.getSuspectedMembers());\n            restartMonitor();\n        }\n        finally {\n            lock.unlock();\n        }\n    }","commit_id":"19404eee46a18dcb365bd082e44c14e566d0a49c","url":"https://github.com/belaban/JGroups"},{"original_method":"private void sendHeartbeatResponse(Address dest) {\n        Message hb_ack=new Message(dest, null, null);\n        hb_ack.setFlag(Message.OOB);\n        FdHeader tmp_hdr=new FdHeader(FdHeader.HEARTBEAT_ACK);\n        tmp_hdr.from=local_addr;\n        hb_ack.putHeader(this.id, tmp_hdr);\n        down_prot.down(new Event(Event.MSG, hb_ack));\n    }","id":97472,"modified_method":"protected void sendHeartbeatResponse(Address dest) {\n        Message hb_ack=new Message(dest).setFlag(Message.OOB);\n        FdHeader tmp_hdr=new FdHeader(FdHeader.HEARTBEAT_ACK);\n        tmp_hdr.from=local_addr;\n        hb_ack.putHeader(this.id, tmp_hdr);\n        down_prot.down(new Event(Event.MSG, hb_ack));\n    }","commit_id":"19404eee46a18dcb365bd082e44c14e566d0a49c","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Restarts the monitor if the ping destination has changed. If not, this is a no-op.\n     * Requires lock to be held by the caller */\n    @GuardedBy(\"lock\")\n    private void restartMonitor() {\n        Address tmp_dest=getPingDest(pingable_mbrs);\n        boolean restart_monitor=tmp_dest == null ||\n                ping_dest == null || // tmp_dest != null && ping_dest == null\n                !ping_dest.equals(tmp_dest); // tmp_dest != null && ping_dest != null\n\n        if(restart_monitor) {\n            ping_dest=tmp_dest;\n            stopMonitor();\n            if(ping_dest != null) {\n                try {\n                    startMonitor();\n                }\n                catch(Exception ex) {\n                    if(log.isWarnEnabled()) log.warn(local_addr + \": exception when calling startMonitor(): \" + ex);\n                }\n            }\n        }\n    }","id":97473,"modified_method":"/** Restarts the monitor if the ping destination has changed. If not, this is a no-op.\n     * Requires lock to be held by the caller */\n    @GuardedBy(\"lock\")\n    protected void restartMonitor() {\n        Address tmp_dest=getPingDest(pingable_mbrs);\n        boolean restart_monitor=tmp_dest == null ||\n                ping_dest == null || // tmp_dest != null && ping_dest == null\n                !ping_dest.equals(tmp_dest); // tmp_dest != null && ping_dest != null\n\n        if(restart_monitor) {\n            ping_dest=tmp_dest;\n            stopMonitor();\n            if(ping_dest != null) {\n                try {\n                    startMonitor();\n                }\n                catch(Exception ex) {\n                    if(log.isWarnEnabled()) log.warn(local_addr + \": exception when calling startMonitor(): \" + ex);\n                }\n            }\n        }\n    }","commit_id":"19404eee46a18dcb365bd082e44c14e566d0a49c","url":"https://github.com/belaban/JGroups"},{"original_method":"@GuardedBy(\"lock\")\n    private void updateTimestamp(Address sender) {\n        if(ping_dest != null && sender != null && ping_dest.equals(sender)) {\n            long tmp=System.currentTimeMillis();\n            lock.lock();\n            try {\n                last_ack=tmp;\n                num_tries=0;\n            }\n            finally {\n                lock.unlock();\n            }\n        }\n    }","id":97474,"modified_method":"protected void updateTimestamp(Address sender) {\n        if(ping_dest != null && sender != null && ping_dest.equals(sender)) {\n            long tmp=System.currentTimeMillis();\n            lock.lock();\n            try {\n                last_ack=tmp;\n                num_tries=0;\n            }\n            finally {\n                lock.unlock();\n            }\n        }\n    }","commit_id":"19404eee46a18dcb365bd082e44c14e566d0a49c","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Requires lock to held by caller */\n    @GuardedBy(\"lock\")\n    private void startMonitor() {\n        if(monitor_future == null || monitor_future.isDone()) {\n            last_ack=System.currentTimeMillis();  // start from scratch\n            monitor_future=timer.scheduleWithFixedDelay(createMonitor(), timeout, timeout, TimeUnit.MILLISECONDS);\n            num_tries=0;\n        }\n    }","id":97475,"modified_method":"/** Requires lock to held by caller */\n    @GuardedBy(\"lock\")\n    protected void startMonitor() {\n        if(monitor_future == null || monitor_future.isDone()) {\n            last_ack=System.currentTimeMillis();  // start from scratch\n            monitor_future=timer.scheduleWithFixedDelay(new Monitor(), timeout, timeout, TimeUnit.MILLISECONDS);\n            num_tries=0;\n        }\n    }","commit_id":"19404eee46a18dcb365bd082e44c14e566d0a49c","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            Message suspect_msg;\n            FD.FdHeader hdr;\n\n            synchronized(suspected_members) {\n                if(suspected_members.isEmpty()) {\n                    stop();\n                    return;\n                }\n\n                hdr=new FdHeader(FdHeader.SUSPECT);\n                hdr.mbrs=new ArrayList<Address>(suspected_members);\n                hdr.from=local_addr;\n            }\n            suspect_msg=new Message();       // mcast SUSPECT to all members\n            suspect_msg.setFlag(Message.OOB);\n            suspect_msg.putHeader(id, hdr);\n            if(log.isDebugEnabled())\n                log.debug(local_addr + \": broadcasting SUSPECT message [suspected_mbrs=\" + suspected_members + \"] to group\");\n            down_prot.down(new Event(Event.MSG, suspect_msg));\n        }","id":97476,"modified_method":"public void run() {\n            FD.FdHeader hdr;\n            synchronized(suspected_members) {\n                if(suspected_members.isEmpty()) {\n                    stop();\n                    return;\n                }\n\n                hdr=new FdHeader(FdHeader.SUSPECT);\n                hdr.mbrs=new ArrayList<Address>(suspected_members);\n                hdr.from=local_addr;\n            }\n            Message suspect_msg=new Message().setFlag(Message.OOB).putHeader(id, hdr);\n            if(log.isDebugEnabled())\n                log.debug(local_addr + \": broadcasting SUSPECT message [suspected_mbrs=\" + suspected_members + \"] to group\");\n            down_prot.down(new Event(Event.MSG, suspect_msg));\n        }","commit_id":"19404eee46a18dcb365bd082e44c14e566d0a49c","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Requires lock to be held by caller */\n    @GuardedBy(\"lock\")\n    private void stopMonitor() {\n        if(monitor_future != null) {\n            monitor_future.cancel(true);\n            monitor_future=null;\n        }\n    }","id":97477,"modified_method":"/** Requires lock to be held by caller */\n    @GuardedBy(\"lock\")\n    protected void stopMonitor() {\n        if(monitor_future != null) {\n            monitor_future.cancel(true);\n            monitor_future=null;\n        }\n    }","commit_id":"19404eee46a18dcb365bd082e44c14e566d0a49c","url":"https://github.com/belaban/JGroups"},{"original_method":"private Address getPingDest(List<Address> mbrs) {\n        Address tmp, retval=null;\n\n        if(mbrs == null || mbrs.size() < 2 || local_addr == null)\n            return null;\n        for(int i=0; i < mbrs.size(); i++) {\n            tmp=mbrs.get(i);\n            if(local_addr.equals(tmp)) {\n                if(i + 1 >= mbrs.size())\n                    retval=mbrs.get(0);\n                else\n                    retval=mbrs.get(i + 1);\n                break;\n            }\n        }\n        return retval;\n    }","id":97478,"modified_method":"protected Address getPingDest(List<Address> mbrs) {\n        Address tmp, retval=null;\n\n        if(mbrs == null || mbrs.size() < 2 || local_addr == null)\n            return null;\n        for(int i=0; i < mbrs.size(); i++) {\n            tmp=mbrs.get(i);\n            if(local_addr.equals(tmp)) {\n                if(i + 1 >= mbrs.size())\n                    retval=mbrs.get(0);\n                else\n                    retval=mbrs.get(i + 1);\n                break;\n            }\n        }\n        return retval;\n    }","commit_id":"19404eee46a18dcb365bd082e44c14e566d0a49c","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                FdHeader hdr=(FdHeader)msg.getHeader(this.id);\n                if(hdr == null) {\n                    updateTimestamp(msg.getSrc());\n                    break;  // message did not originate from FD layer, just pass up\n                }\n\n                switch(hdr.type) {\n                    case FdHeader.HEARTBEAT:                       // heartbeat request; send heartbeat ack\n                        Address hb_sender=msg.getSrc();\n                        if(log.isTraceEnabled())\n                            log.trace(local_addr + \": received are-you-alive from \" + hb_sender + \", sending response\");\n                        sendHeartbeatResponse(hb_sender);\n                        break;                                     // don't pass up !\n\n                    case FdHeader.HEARTBEAT_ACK:                   // heartbeat ack\n                        updateTimestamp(hdr.from);\n                        break;\n\n                    case FdHeader.SUSPECT:\n                        if(hdr.mbrs != null) {\n                            if(log.isTraceEnabled()) log.trace(local_addr + \": suspect hdr is \" + hdr);\n                            for(Address mbr: hdr.mbrs) {\n                                if(local_addr != null && mbr.equals(local_addr)) {\n                                    if(log.isWarnEnabled())\n                                        log.warn(local_addr + \": I was suspected by \" + msg.getSrc() +\n                                                   \"; ignoring the SUSPECT message and sending back a HEARTBEAT_ACK\");\n                                    sendHeartbeatResponse(msg.getSrc());\n                                    continue;\n                                }\n                                else {\n                                    lock.lock();\n                                    try {\n                                        pingable_mbrs.remove(mbr);\n                                        restartMonitor();\n                                    }\n                                    finally {\n                                        lock.unlock();\n                                    }\n                                }\n                                up_prot.up(new Event(Event.SUSPECT, mbr));\n                                down_prot.down(new Event(Event.SUSPECT, mbr));\n                            }\n                        }\n                        break;\n                }\n                return null;\n        }\n        return up_prot.up(evt); // pass up to the layer above us\n    }","id":97479,"modified_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                FdHeader hdr=(FdHeader)msg.getHeader(this.id);\n                if(hdr == null) {\n                    if(msg_counts_as_heartbeat)\n                        updateTimestamp(msg.getSrc());\n                    break;  // message did not originate from FD layer, just pass up\n                }\n\n                switch(hdr.type) {\n                    case FdHeader.HEARTBEAT:                       // heartbeat request; send heartbeat ack\n                        Address hb_sender=msg.getSrc();\n                        if(log.isTraceEnabled())\n                            log.trace(local_addr + \": received are-you-alive from \" + hb_sender + \", sending response\");\n                        sendHeartbeatResponse(hb_sender);\n                        break;                                     // don't pass up !\n\n                    case FdHeader.HEARTBEAT_ACK:                   // heartbeat ack\n                        updateTimestamp(hdr.from);\n                        break;\n\n                    case FdHeader.SUSPECT:\n                        if(hdr.mbrs != null) {\n                            if(log.isTraceEnabled()) log.trace(local_addr + \": suspect hdr is \" + hdr);\n                            for(Address mbr: hdr.mbrs) {\n                                if(local_addr != null && mbr.equals(local_addr)) {\n                                    if(log.isWarnEnabled())\n                                        log.warn(local_addr + \": I was suspected by \" + msg.getSrc() +\n                                                   \"; ignoring the SUSPECT message and sending back a HEARTBEAT_ACK\");\n                                    sendHeartbeatResponse(msg.getSrc());\n                                    continue;\n                                }\n                                lock.lock();\n                                try {\n                                    pingable_mbrs.remove(mbr);\n                                    restartMonitor();\n                                }\n                                finally {\n                                    lock.unlock();\n                                }\n                                up_prot.up(new Event(Event.SUSPECT, mbr));\n                                down_prot.down(new Event(Event.SUSPECT, mbr));\n                            }\n                        }\n                        break;\n                }\n                return null;\n        }\n        return up_prot.up(evt); // pass up to the layer above us\n    }","commit_id":"19404eee46a18dcb365bd082e44c14e566d0a49c","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n         * Starts a new task, or - if already running - adds the argument to the running task.\n         * @param suspect\n         */\n        private void startBroadcastTask(Address suspect) {\n            bcast_lock.lock();\n            try {\n                if(bcast_future == null || bcast_future.isDone()) {\n                    task=new BroadcastTask(suspected_mbrs);\n                    task.addSuspectedMember(suspect);\n                    bcast_future=timer.scheduleWithFixedDelay(task,\n                                                              0, // run immediately the first time\n                                                              timeout, // then every timeout milliseconds, until cancelled\n                                                              TimeUnit.MILLISECONDS);\n                    if(log.isTraceEnabled())\n                        log.trace(local_addr + \": BroadcastTask started\");\n                }\n                else {\n                    task.addSuspectedMember(suspect);\n                }\n            }\n            finally {\n                bcast_lock.unlock();\n            }\n        }","id":97480,"modified_method":"/**\n         * Starts a new task, or - if already running - adds the argument to the running task.\n         * @param suspect\n         */\n        protected void startBroadcastTask(Address suspect) {\n            bcast_lock.lock();\n            try {\n                if(bcast_future == null || bcast_future.isDone()) {\n                    task=new BroadcastTask(suspected_mbrs);\n                    task.addSuspectedMember(suspect);\n                    bcast_future=timer.scheduleWithFixedDelay(task,\n                                                              0, // run immediately the first time\n                                                              timeout, // then every timeout milliseconds, until cancelled\n                                                              TimeUnit.MILLISECONDS);\n                    if(log.isTraceEnabled())\n                        log.trace(local_addr + \": BroadcastTask started\");\n                }\n                else {\n                    task.addSuspectedMember(suspect);\n                }\n            }\n            finally {\n                bcast_lock.unlock();\n            }\n        }","commit_id":"19404eee46a18dcb365bd082e44c14e566d0a49c","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n\tpublic PortletPreferences processExportPortletPreferences(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tportletDataContext.addPortletPermissions(\n\t\t\t\tDDLPermission.RESOURCE_NAME);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortletDataException(\n\t\t\t\t\"Unable to export portlet permissions\", pe);\n\t\t}\n\n\t\tString portletId = portletDataContext.getPortletId();\n\n\t\tlong recordSetId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"recordSetId\", null));\n\n\t\tif (recordSetId == 0) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Record set ID is not set for preferences of portlet \" +\n\t\t\t\t\t\tportletId);\n\t\t\t}\n\n\t\t\treturn portletPreferences;\n\t\t}\n\n\t\tDDLRecordSet recordSet = _ddlRecordSetLocalService.fetchRecordSet(\n\t\t\trecordSetId);\n\n\t\tif (recordSet != null) {\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, portletId, recordSet);\n\t\t}\n\n\t\tlong displayDDMTemplateId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"displayDDMTemplateId\", null));\n\n\t\t_exportReferenceDDMTemplate(\n\t\t\tportletDataContext, portletId, displayDDMTemplateId);\n\n\t\tlong formDDMTemplateId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"formDDMTemplateId\", null));\n\n\t\t_exportReferenceDDMTemplate(\n\t\t\tportletDataContext, portletId, formDDMTemplateId);\n\n\t\treturn portletPreferences;\n\t}","id":97481,"modified_method":"@Override\n\tpublic PortletPreferences processExportPortletPreferences(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tportletDataContext.addPortletPermissions(\n\t\t\t\tDDLPermission.RESOURCE_NAME);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortletDataException(\n\t\t\t\t\"Unable to export portlet permissions\", pe);\n\t\t}\n\n\t\tString portletId = portletDataContext.getPortletId();\n\n\t\tfinal long recordSetId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"recordSetId\", null));\n\n\t\tif (recordSetId == 0) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Record set ID is not set for preferences of portlet \" +\n\t\t\t\t\t\tportletId);\n\t\t\t}\n\n\t\t\treturn portletPreferences;\n\t\t}\n\n\t\tDDLRecordSet recordSet = _ddlRecordSetLocalService.fetchRecordSet(\n\t\t\trecordSetId);\n\n\t\tif (recordSet != null) {\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, portletId, recordSet);\n\n\t\t\tActionableDynamicQuery recordActionableDynamicQuery =\n\t\t\t\t_ddlRecordStagedModelRepository.getExportActionableDynamicQuery(\n\t\t\t\t\tportletDataContext);\n\n\t\t\tfinal ActionableDynamicQuery.AddCriteriaMethod addCriteriaMethod =\n\t\t\t\trecordActionableDynamicQuery.getAddCriteriaMethod();\n\n\t\t\trecordActionableDynamicQuery.setAddCriteriaMethod(\n\t\t\t\tnew ActionableDynamicQuery.AddCriteriaMethod() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void addCriteria(DynamicQuery dynamicQuery) {\n\t\t\t\t\t\taddCriteriaMethod.addCriteria(dynamicQuery);\n\n\t\t\t\t\t\tProperty property = PropertyFactoryUtil.forName(\n\t\t\t\t\t\t\t\"recordSetId\");\n\n\t\t\t\t\t\tdynamicQuery.add(property.eq(recordSetId));\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\ttry {\n\t\t\t\trecordActionableDynamicQuery.performActions();\n\t\t\t}\n\t\t\tcatch (PortalException pe) {\n\t\t\t\tthrow new PortletDataException(\n\t\t\t\t\t\"Unable to export referenced records\", pe);\n\t\t\t}\n\t\t}\n\n\t\tlong displayDDMTemplateId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"displayDDMTemplateId\", null));\n\n\t\t_exportReferenceDDMTemplate(\n\t\t\tportletDataContext, portletId, displayDDMTemplateId);\n\n\t\tlong formDDMTemplateId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"formDDMTemplateId\", null));\n\n\t\t_exportReferenceDDMTemplate(\n\t\t\tportletDataContext, portletId, formDDMTemplateId);\n\n\t\treturn portletPreferences;\n\t}","commit_id":"d91b4d807e27bc9517e7caa7b5cc9fa5bde47c8d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic PortletPreferences processExportPortletPreferences(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tportletDataContext.addPortletPermissions(\n\t\t\t\tDDLPermission.RESOURCE_NAME);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortletDataException(\n\t\t\t\t\"Unable to export portlet permissions\", pe);\n\t\t}\n\n\t\tString portletId = portletDataContext.getPortletId();\n\n\t\tlong recordSetId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"recordSetId\", null));\n\n\t\tif (recordSetId == 0) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Record set ID is not set for preferences of portlet \" +\n\t\t\t\t\t\tportletId);\n\t\t\t}\n\n\t\t\treturn portletPreferences;\n\t\t}\n\n\t\tDDLRecordSet recordSet = _ddlRecordSetLocalService.fetchRecordSet(\n\t\t\trecordSetId);\n\n\t\tif (recordSet != null) {\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, portletId, recordSet);\n\t\t}\n\n\t\treturn portletPreferences;\n\t}","id":97482,"modified_method":"@Override\n\tpublic PortletPreferences processExportPortletPreferences(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tportletDataContext.addPortletPermissions(\n\t\t\t\tDDLPermission.RESOURCE_NAME);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortletDataException(\n\t\t\t\t\"Unable to export portlet permissions\", pe);\n\t\t}\n\n\t\tString portletId = portletDataContext.getPortletId();\n\n\t\tfinal long recordSetId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"recordSetId\", null));\n\n\t\tif (recordSetId == 0) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Record set ID is not set for preferences of portlet \" +\n\t\t\t\t\t\tportletId);\n\t\t\t}\n\n\t\t\treturn portletPreferences;\n\t\t}\n\n\t\tDDLRecordSet recordSet = _ddlRecordSetLocalService.fetchRecordSet(\n\t\t\trecordSetId);\n\n\t\tif (recordSet != null) {\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, portletId, recordSet);\n\n\t\t\tActionableDynamicQuery recordActionableDynamicQuery =\n\t\t\t\t_ddlRecordStagedModelRepository.getExportActionableDynamicQuery(\n\t\t\t\t\tportletDataContext, DDLRecordSetConstants.SCOPE_FORMS);\n\n\t\t\tfinal ActionableDynamicQuery.AddCriteriaMethod addCriteriaMethod =\n\t\t\t\trecordActionableDynamicQuery.getAddCriteriaMethod();\n\n\t\t\trecordActionableDynamicQuery.setAddCriteriaMethod(\n\t\t\t\tnew ActionableDynamicQuery.AddCriteriaMethod() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void addCriteria(DynamicQuery dynamicQuery) {\n\t\t\t\t\t\taddCriteriaMethod.addCriteria(dynamicQuery);\n\n\t\t\t\t\t\tProperty property = PropertyFactoryUtil.forName(\n\t\t\t\t\t\t\t\"recordSetId\");\n\n\t\t\t\t\t\tdynamicQuery.add(property.eq(recordSetId));\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\ttry {\n\t\t\t\trecordActionableDynamicQuery.performActions();\n\t\t\t}\n\t\t\tcatch (PortalException pe) {\n\t\t\t\tthrow new PortletDataException(\n\t\t\t\t\t\"Unable to export referenced records\", pe);\n\t\t\t}\n\t\t}\n\n\t\treturn portletPreferences;\n\t}","commit_id":"d91b4d807e27bc9517e7caa7b5cc9fa5bde47c8d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, MBMessage message)\n\t\tthrows Exception {\n\n\t\tif (message.getCategoryId() ==\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\tportletDataContext, message, message.getCategory(),\n\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT);\n\n\t\tElement messageElement = portletDataContext.getExportDataElement(\n\t\t\tmessage);\n\n\t\tmessage.setPriority(message.getPriority());\n\n\t\tMBThread thread = message.getThread();\n\n\t\tmessageElement.addAttribute(\n\t\t\t\"question\", String.valueOf(thread.isQuestion()));\n\n\t\tboolean hasAttachmentsFileEntries =\n\t\t\tmessage.getAttachmentsFileEntriesCount() > 0;\n\n\t\tmessageElement.addAttribute(\n\t\t\t\"hasAttachmentsFileEntries\",\n\t\t\tString.valueOf(hasAttachmentsFileEntries));\n\n\t\tif (hasAttachmentsFileEntries) {\n\t\t\tfor (FileEntry fileEntry : message.getAttachmentsFileEntries()) {\n\t\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\t\tportletDataContext, message, fileEntry,\n\t\t\t\t\tPortletDataContext.REFERENCE_TYPE_WEAK);\n\t\t\t}\n\n\t\t\tlong folderId = message.getAttachmentsFolderId();\n\n\t\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\tmessage.setAttachmentsFolderId(folderId);\n\t\t\t}\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tmessageElement, ExportImportPathUtil.getModelPath(message),\n\t\t\tmessage);\n\t}","id":97483,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, MBMessage message)\n\t\tthrows Exception {\n\n\t\tif (message.isDiscussion()) {\n\t\t\tMBDiscussion discussion =\n\t\t\t\tMBDiscussionLocalServiceUtil.getDiscussion(\n\t\t\t\t\tmessage.getClassName(), message.getClassPK());\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, message, discussion,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT);\n\n\t\t\t// Ratings belong to discussion messages can't be exported\n\t\t\t// automatically because of the special className\n\n\t\t\tList<RatingsEntry> ratingsEntries =\n\t\t\t\tRatingsEntryLocalServiceUtil.getEntries(\n\t\t\t\t\tMBDiscussion.class.getName(), message.getMessageId());\n\n\t\t\tfor (RatingsEntry ratingsEntry : ratingsEntries) {\n\t\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\t\tportletDataContext, message, ratingsEntry,\n\t\t\t\t\tPortletDataContext.REFERENCE_TYPE_WEAK);\n\t\t\t}\n\t\t}\n\t\telse if (message.getCategoryId() !=\n\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, message, message.getCategory(),\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT);\n\t\t}\n\n\t\tif (!message.isRoot()) {\n\t\t\tMBMessage parentMessage = MBMessageLocalServiceUtil.getMessage(\n\t\t\t\tmessage.getParentMessageId());\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, message, parentMessage,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT);\n\t\t}\n\n\t\tmessage.setPriority(message.getPriority());\n\n\t\tMBThread thread = message.getThread();\n\n\t\tElement messageElement = portletDataContext.getExportDataElement(\n\t\t\tmessage);\n\n\t\tmessageElement.addAttribute(\n\t\t\t\"question\", String.valueOf(thread.isQuestion()));\n\n\t\tboolean hasAttachmentsFileEntries =\n\t\t\tmessage.getAttachmentsFileEntriesCount() > 0;\n\n\t\tmessageElement.addAttribute(\n\t\t\t\"hasAttachmentsFileEntries\",\n\t\t\tString.valueOf(hasAttachmentsFileEntries));\n\n\t\tif (hasAttachmentsFileEntries) {\n\t\t\tfor (FileEntry fileEntry : message.getAttachmentsFileEntries()) {\n\t\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\t\tportletDataContext, message, fileEntry,\n\t\t\t\t\tPortletDataContext.REFERENCE_TYPE_WEAK);\n\t\t\t}\n\n\t\t\tlong folderId = message.getAttachmentsFolderId();\n\n\t\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\tmessage.setAttachmentsFolderId(folderId);\n\t\t\t}\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tmessageElement, ExportImportPathUtil.getModelPath(message),\n\t\t\tmessage);\n\t}","commit_id":"ca2f372d50607d5f14884f8bcebcab734705566c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, MBMessage message)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(message.getUserUuid());\n\n\t\tString userName = message.getUserName();\n\n\t\tMap<Long, Long> categoryIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tMBCategory.class);\n\n\t\tlong parentCategoryId = MapUtil.getLong(\n\t\t\tcategoryIds, message.getCategoryId(), message.getCategoryId());\n\n\t\tMap<Long, Long> threadIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tMBThread.class);\n\n\t\tlong threadId = MapUtil.getLong(threadIds, message.getThreadId(), 0);\n\n\t\tMap<Long, Long> messageIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tMBMessage.class);\n\n\t\tlong parentMessageId = MapUtil.getLong(\n\t\t\tmessageIds, message.getParentMessageId(),\n\t\t\tmessage.getParentMessageId());\n\n\t\tElement element = portletDataContext.getImportDataStagedModelElement(\n\t\t\tmessage);\n\n\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs =\n\t\t\tgetAttachments(portletDataContext, element, message);\n\n\t\ttry {\n\t\t\tServiceContext serviceContext =\n\t\t\t\tportletDataContext.createServiceContext(message);\n\n\t\t\tif ((parentCategoryId !=\n\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t\t(parentCategoryId !=\n\t\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID) &&\n\t\t\t\t(parentCategoryId == message.getCategoryId())) {\n\n\t\t\t\tStagedModelDataHandlerUtil.importReferenceStagedModel(\n\t\t\t\t\tportletDataContext, message, MBCategory.class,\n\t\t\t\t\tparentCategoryId);\n\n\t\t\t\tparentCategoryId = MapUtil.getLong(\n\t\t\t\t\tcategoryIds, message.getCategoryId(),\n\t\t\t\t\tmessage.getCategoryId());\n\t\t\t}\n\n\t\t\tMBMessage importedMessage = null;\n\n\t\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\t\tMBMessage existingMessage =\n\t\t\t\t\tMBMessageLocalServiceUtil.fetchMBMessageByUuidAndGroupId(\n\t\t\t\t\t\tmessage.getUuid(),\n\t\t\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\t\t\tif (existingMessage == null) {\n\t\t\t\t\tserviceContext.setUuid(message.getUuid());\n\n\t\t\t\t\timportedMessage = MBMessageLocalServiceUtil.addMessage(\n\t\t\t\t\t\tuserId, userName, portletDataContext.getScopeGroupId(),\n\t\t\t\t\t\tparentCategoryId, threadId, parentMessageId,\n\t\t\t\t\t\tmessage.getSubject(), message.getBody(),\n\t\t\t\t\t\tmessage.getFormat(), inputStreamOVPs,\n\t\t\t\t\t\tmessage.getAnonymous(), message.getPriority(),\n\t\t\t\t\t\tmessage.getAllowPingbacks(), serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedMessage = MBMessageLocalServiceUtil.updateMessage(\n\t\t\t\t\t\tuserId, existingMessage.getMessageId(),\n\t\t\t\t\t\tmessage.getSubject(), message.getBody(),\n\t\t\t\t\t\tinputStreamOVPs, new ArrayList<String>(),\n\t\t\t\t\t\tmessage.getPriority(), message.getAllowPingbacks(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedMessage = MBMessageLocalServiceUtil.addMessage(\n\t\t\t\t\tuserId, userName, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tparentCategoryId, threadId, parentMessageId,\n\t\t\t\t\tmessage.getSubject(), message.getBody(),\n\t\t\t\t\tmessage.getFormat(), inputStreamOVPs,\n\t\t\t\t\tmessage.getAnonymous(), message.getPriority(),\n\t\t\t\t\tmessage.getAllowPingbacks(), serviceContext);\n\t\t\t}\n\n\t\t\timportedMessage.setAnswer(message.getAnswer());\n\n\t\t\tif (importedMessage.isRoot()) {\n\t\t\t\tMBThreadLocalServiceUtil.updateQuestion(\n\t\t\t\t\timportedMessage.getThreadId(),\n\t\t\t\t\tGetterUtil.getBoolean(element.attributeValue(\"question\")));\n\t\t\t}\n\n\t\t\tthreadIds.put(message.getThreadId(), importedMessage.getThreadId());\n\n\t\t\tportletDataContext.importClassedModel(message, importedMessage);\n\t\t}\n\t\tfinally {\n\t\t\tfor (ObjectValuePair<String, InputStream> inputStreamOVP :\n\t\t\t\t\tinputStreamOVPs) {\n\n\t\t\t\tInputStream inputStream = inputStreamOVP.getValue();\n\n\t\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t\t}\n\t\t}\n\t}","id":97484,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, MBMessage message)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(message.getUserUuid());\n\n\t\tif (message.isDiscussion()) {\n\t\t\tStagedModelDataHandlerUtil.importReferenceStagedModels(\n\t\t\t\tportletDataContext, message, MBDiscussion.class);\n\t\t}\n\t\telse if (message.getCategoryId() !=\n\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\tStagedModelDataHandlerUtil.importReferenceStagedModel(\n\t\t\t\tportletDataContext, message, MBCategory.class,\n\t\t\t\tmessage.getCategoryId());\n\t\t}\n\n\t\tMap<Long, Long> categoryIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tMBCategory.class);\n\n\t\tlong parentCategoryId = MapUtil.getLong(\n\t\t\tcategoryIds, message.getCategoryId(), message.getCategoryId());\n\n\t\tMap<Long, Long> threadIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tMBThread.class);\n\n\t\tlong threadId = MapUtil.getLong(threadIds, message.getThreadId(), 0);\n\n\t\tif (!message.isRoot()) {\n\t\t\tStagedModelDataHandlerUtil.importReferenceStagedModel(\n\t\t\t\tportletDataContext, message, MBMessage.class,\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tMap<Long, Long> messageIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tMBMessage.class);\n\n\t\tlong parentMessageId = MapUtil.getLong(\n\t\t\tmessageIds, message.getParentMessageId(),\n\t\t\tmessage.getParentMessageId());\n\n\t\tElement element = portletDataContext.getImportDataStagedModelElement(\n\t\t\tmessage);\n\n\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs =\n\t\t\tgetAttachments(portletDataContext, element, message);\n\n\t\ttry {\n\t\t\tServiceContext serviceContext =\n\t\t\t\tportletDataContext.createServiceContext(message);\n\n\t\t\tMBMessage importedMessage = null;\n\n\t\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\t\tMBMessage existingMessage =\n\t\t\t\t\tMBMessageLocalServiceUtil.fetchMBMessageByUuidAndGroupId(\n\t\t\t\t\t\tmessage.getUuid(),\n\t\t\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\t\t\tif (existingMessage == null) {\n\t\t\t\t\tserviceContext.setUuid(message.getUuid());\n\n\t\t\t\t\tif (message.isDiscussion()) {\n\t\t\t\t\t\timportedMessage = addDiscussionMessage(\n\t\t\t\t\t\t\tuserId, threadId, parentMessageId, message,\n\t\t\t\t\t\t\tportletDataContext, serviceContext);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\timportedMessage = MBMessageLocalServiceUtil.addMessage(\n\t\t\t\t\t\t\tuserId, message.getUserName(),\n\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\t\t\tparentCategoryId, threadId, parentMessageId,\n\t\t\t\t\t\t\tmessage.getSubject(), message.getBody(),\n\t\t\t\t\t\t\tmessage.getFormat(), inputStreamOVPs,\n\t\t\t\t\t\t\tmessage.getAnonymous(), message.getPriority(),\n\t\t\t\t\t\t\tmessage.getAllowPingbacks(), serviceContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!message.isRoot() && message.isDiscussion()) {\n\t\t\t\t\t\tMBDiscussion discussion =\n\t\t\t\t\t\t\tMBDiscussionLocalServiceUtil.getThreadDiscussion(\n\t\t\t\t\t\t\t\tthreadId);\n\n\t\t\t\t\t\timportedMessage =\n\t\t\t\t\t\t\tMBMessageLocalServiceUtil.updateDiscussionMessage(\n\t\t\t\t\t\t\t\tuserId, existingMessage.getMessageId(),\n\t\t\t\t\t\t\t\tdiscussion.getClassName(),\n\t\t\t\t\t\t\t\tdiscussion.getClassPK(), message.getSubject(),\n\t\t\t\t\t\t\t\tmessage.getBody(), serviceContext);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\timportedMessage =\n\t\t\t\t\t\t\tMBMessageLocalServiceUtil.updateMessage(\n\t\t\t\t\t\t\t\tuserId, existingMessage.getMessageId(),\n\t\t\t\t\t\t\t\tmessage.getSubject(), message.getBody(),\n\t\t\t\t\t\t\t\tinputStreamOVPs, new ArrayList<String>(),\n\t\t\t\t\t\t\t\tmessage.getPriority(),\n\t\t\t\t\t\t\t\tmessage.getAllowPingbacks(), serviceContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (message.isDiscussion()) {\n\t\t\t\t\timportedMessage = addDiscussionMessage(\n\t\t\t\t\t\tuserId, threadId, parentMessageId, message,\n\t\t\t\t\t\tportletDataContext, serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedMessage = MBMessageLocalServiceUtil.addMessage(\n\t\t\t\t\t\tuserId, message.getUserName(),\n\t\t\t\t\t\tportletDataContext.getScopeGroupId(), parentCategoryId,\n\t\t\t\t\t\tthreadId, parentMessageId, message.getSubject(),\n\t\t\t\t\t\tmessage.getBody(), message.getFormat(), inputStreamOVPs,\n\t\t\t\t\t\tmessage.getAnonymous(), message.getPriority(),\n\t\t\t\t\t\tmessage.getAllowPingbacks(), serviceContext);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\timportedMessage.setAnswer(message.getAnswer());\n\n\t\t\tif (importedMessage.isRoot() && !importedMessage.isDiscussion()) {\n\t\t\t\tMBThreadLocalServiceUtil.updateQuestion(\n\t\t\t\t\timportedMessage.getThreadId(),\n\t\t\t\t\tGetterUtil.getBoolean(element.attributeValue(\"question\")));\n\t\t\t}\n\n\t\t\tif (message.isDiscussion()) {\n\t\t\t\tMap<Long, Long> discussionIds =\n\t\t\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\t\tMBDiscussion.class);\n\n\t\t\t\tdiscussionIds.put(\n\t\t\t\t\tmessage.getMessageId(), importedMessage.getMessageId());\n\t\t\t}\n\n\t\t\tthreadIds.put(message.getThreadId(), importedMessage.getThreadId());\n\n\t\t\tportletDataContext.importClassedModel(message, importedMessage);\n\t\t}\n\t\tfinally {\n\t\t\tfor (ObjectValuePair<String, InputStream> inputStreamOVP :\n\t\t\t\t\tinputStreamOVPs) {\n\n\t\t\t\tInputStream inputStream = inputStreamOVP.getValue();\n\n\t\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t\t}\n\t\t}\n\t}","commit_id":"ca2f372d50607d5f14884f8bcebcab734705566c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic PortletPreferences processExportPortletPreferences(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tportletDataContext.addPortletPermissions(\n\t\t\t\tDDLPermission.RESOURCE_NAME);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortletDataException(\n\t\t\t\t\"Unable to export portlet permissions\", pe);\n\t\t}\n\n\t\tString portletId = portletDataContext.getPortletId();\n\n\t\tlong recordSetId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"recordSetId\", null), 0);\n\n\t\tif (recordSetId == 0) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Record set ID is not set for preferences of portlet \" +\n\t\t\t\t\t\tportletId);\n\t\t\t}\n\n\t\t\treturn portletPreferences;\n\t\t}\n\n\t\tDDLRecordSet recordSet = _ddlRecordSetLocalService.fetchRecordSet(\n\t\t\trecordSetId);\n\n\t\tif (recordSet == null) {\n\t\t\treturn portletPreferences;\n\t\t}\n\n\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\tportletDataContext, portletId, recordSet);\n\n\t\treturn portletPreferences;\n\t}","id":97485,"modified_method":"@Override\n\tpublic PortletPreferences processExportPortletPreferences(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows PortletDataException {\n\n\t\ttry {\n\t\t\tportletDataContext.addPortletPermissions(\n\t\t\t\tDDLPermission.RESOURCE_NAME);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortletDataException(\n\t\t\t\t\"Unable to export portlet permissions\", pe);\n\t\t}\n\n\t\tString portletId = portletDataContext.getPortletId();\n\n\t\tlong recordSetId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"recordSetId\", null), 0);\n\n\t\tif (recordSetId == 0) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Record set ID is not set for preferences of portlet \" +\n\t\t\t\t\t\tportletId);\n\t\t\t}\n\n\t\t\treturn portletPreferences;\n\t\t}\n\n\t\tDDLRecordSet recordSet = _ddlRecordSetLocalService.fetchRecordSet(\n\t\t\trecordSetId);\n\n\t\tif (recordSet != null) {\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, portletId, recordSet);\n\t\t}\n\n\t\tlong displayDDMTemplateId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"displayDDMTemplateId\", null));\n\n\t\texportReferenceDDMTemplate(\n\t\t\tdisplayDDMTemplateId, portletDataContext, portletId);\n\n\t\tlong formDDMTemplateId = GetterUtil.getLong(\n\t\t\tportletPreferences.getValue(\"formDDMTemplateId\", null));\n\n\t\texportReferenceDDMTemplate(\n\t\t\tformDDMTemplateId, portletDataContext, portletId);\n\n\t\treturn portletPreferences;\n\t}","commit_id":"3e694de8067560cb12a806289e813654aaffb74c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Nullable\n  public JComponent createOptionsPanel() {\n    JPanel component = new SSBasedInspectionOptions(myConfigurations){\n      public void configurationsChanged() {\n        super.configurationsChanged();\n        Project[] projects = ProjectManager.getInstance().getOpenProjects();\n        precompileConfigurations(projects[0]);\n      }\n    }.getComponent();\n    return component;\n  }","id":97486,"modified_method":"@Nullable\n  public JComponent createOptionsPanel() {\n    JPanel component = new SSBasedInspectionOptions(myConfigurations){\n      public void configurationsChanged(final SearchContext searchContext) {\n        super.configurationsChanged(searchContext);\n        precompileConfigurations(searchContext.getProject());\n      }\n    }.getComponent();\n    return component;\n  }","commit_id":"036379991293374b28723b30a4222900be5ec7a0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static SearchDialog createDialog(final SearchDialogFactory searchDialogFactory) {\n    AnActionEvent event = new AnActionEvent(null, DataManager.getInstance().getDataContext(),\n                                            \"\", new DefaultActionGroup().getTemplatePresentation(), ActionManager.getInstance(), 0);\n    SearchContext searchContext = new SearchContext();\n    searchContext.configureFromDataContext(event.getDataContext());\n    SearchDialog dialog = searchDialogFactory.createDialog(searchContext);\n    return dialog;\n  }","id":97487,"modified_method":"private static SearchDialog createDialog(final SearchDialogFactory searchDialogFactory) {\n    SearchContext searchContext = createSearchContext();\n    SearchDialog dialog = searchDialogFactory.createDialog(searchContext);\n    return dialog;\n  }","commit_id":"036379991293374b28723b30a4222900be5ec7a0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getSize() {\n      return myConfigurations.size();\n    }","id":97488,"modified_method":"public void configurationsChanged(final SearchContext searchContext) {\n    ((MyListModel)myTemplatesList.getModel()).fireContentsChanged();\n  }","commit_id":"036379991293374b28723b30a4222900be5ec7a0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addTemplate(SearchDialogFactory searchDialogFactory) {\n    SearchDialog dialog = createDialog(searchDialogFactory);\n    dialog.show();\n    if (!dialog.isOK()) return;\n    Configuration configuration = dialog.getConfiguration();\n\n    if (configuration.getName() == null || configuration.getName().equals(SearchDialog.USER_DEFINED)) {\n      String name = dialog.showSaveTemplateAsDialog();\n      if (name == null) return;\n      configuration.setName(name);\n    }\n    myConfigurations.add(configuration);\n\n    configurationsChanged();\n  }","id":97489,"modified_method":"private void addTemplate(SearchDialogFactory searchDialogFactory) {\n    SearchDialog dialog = createDialog(searchDialogFactory);\n    dialog.show();\n    if (!dialog.isOK()) return;\n    Configuration configuration = dialog.getConfiguration();\n\n    if (configuration.getName() == null || configuration.getName().equals(SearchDialog.USER_DEFINED)) {\n      String name = dialog.showSaveTemplateAsDialog();\n      if (name == null) return;\n      configuration.setName(name);\n    }\n    myConfigurations.add(configuration);\n\n    configurationsChanged(dialog.getSearchContext());\n  }","commit_id":"036379991293374b28723b30a4222900be5ec7a0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SSBasedInspectionOptions(final List<Configuration> configurations) {\n    myConfigurations = configurations;\n    myTemplatesList.setModel(new MyListModel());\n    myTemplatesList.setCellRenderer(new DefaultListCellRenderer() {\n      public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n        JLabel component = (JLabel)super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        Configuration configuration = myConfigurations.get(index);\n        component.setText(configuration.getName());\n        return component;\n      }\n    });\n    myTemplatesList.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        templateListChanged();\n      }\n    });\n    myTemplatesList.getModel().addListDataListener(new ListDataListener() {\n      public void intervalAdded(ListDataEvent e) {\n        templateListChanged();\n      }\n\n      public void intervalRemoved(ListDataEvent e) {\n        templateListChanged();\n      }\n\n      public void contentsChanged(ListDataEvent e) {\n        templateListChanged();\n      }\n    });\n\n    myAddSearchButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        addTemplate(new SearchDialogFactory() {\n          public SearchDialog createDialog(SearchContext searchContext) {\n            return new SearchDialog(searchContext, false, false);\n          }\n        });\n      }\n    });\n    myAddReplaceButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        addTemplate(new SearchDialogFactory() {\n          public SearchDialog createDialog(SearchContext searchContext) {\n            return new ReplaceDialog(searchContext, false, false);\n          }\n        });\n      }\n    });\n    myEditButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final Configuration configuration = (Configuration)myTemplatesList.getSelectedValue();\n        if (configuration == null) return;\n\n        SearchDialog dialog = createDialog(new SearchDialogFactory() {\n          public SearchDialog createDialog(SearchContext searchContext) {\n            return configuration instanceof SearchConfiguration ? new SearchDialog(searchContext, false, false) {\n              public Configuration createConfiguration() {\n                SearchConfiguration newConfiguration = new SearchConfiguration();\n                copyConfiguration(configuration, newConfiguration);\n                return newConfiguration;\n              }\n            } : new ReplaceDialog(searchContext, false, false) {\n              public Configuration createConfiguration() {\n                ReplaceConfiguration newConfiguration = new ReplaceConfiguration();\n                copyConfiguration(configuration, newConfiguration);\n                return newConfiguration;\n              }\n            };\n          }\n        });\n        dialog.setValuesFromConfig(configuration);\n        dialog.setUseLastConfiguration(true);\n        dialog.show();\n        if (!dialog.isOK()) {\n          return;\n        }\n        Configuration newConfiguration = dialog.getConfiguration();\n        copyConfiguration(newConfiguration, configuration);\n        configurationsChanged();\n      }\n    });\n    myRemoveButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        Object[] selected = myTemplatesList.getSelectedValues();\n        for (Object o : selected) {\n          Configuration configuration = (Configuration)o;\n          Iterator<Configuration> iterator = myConfigurations.iterator();\n          while (iterator.hasNext()) {\n            Configuration configuration1 = iterator.next();\n            if (configuration1.getName().equals(configuration.getName())) {\n              iterator.remove();\n            }\n          }\n        }\n        configurationsChanged();\n      }\n    });\n    // later because InspectionToolPanel enables all controls recursively\n    SwingUtilities.invokeLater(new Runnable(){\n      public void run() {\n        templateListChanged();\n      }\n    });\n  }","id":97490,"modified_method":"public SSBasedInspectionOptions(final List<Configuration> configurations) {\n    myConfigurations = configurations;\n    myTemplatesList.setModel(new MyListModel());\n    myTemplatesList.setCellRenderer(new DefaultListCellRenderer() {\n      public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n        JLabel component = (JLabel)super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        Configuration configuration = myConfigurations.get(index);\n        component.setText(configuration.getName());\n        return component;\n      }\n    });\n    myTemplatesList.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        templateListChanged();\n      }\n    });\n    myTemplatesList.getModel().addListDataListener(new ListDataListener() {\n      public void intervalAdded(ListDataEvent e) {\n        templateListChanged();\n      }\n\n      public void intervalRemoved(ListDataEvent e) {\n        templateListChanged();\n      }\n\n      public void contentsChanged(ListDataEvent e) {\n        templateListChanged();\n      }\n    });\n\n    myAddSearchButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        addTemplate(new SearchDialogFactory() {\n          public SearchDialog createDialog(SearchContext searchContext) {\n            return new SearchDialog(searchContext, false, false);\n          }\n        });\n      }\n    });\n    myAddReplaceButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        addTemplate(new SearchDialogFactory() {\n          public SearchDialog createDialog(SearchContext searchContext) {\n            return new ReplaceDialog(searchContext, false, false);\n          }\n        });\n      }\n    });\n    myEditButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final Configuration configuration = (Configuration)myTemplatesList.getSelectedValue();\n        if (configuration == null) return;\n\n        SearchDialog dialog = createDialog(new SearchDialogFactory() {\n          public SearchDialog createDialog(SearchContext searchContext) {\n            return configuration instanceof SearchConfiguration ? new SearchDialog(searchContext, false, false) {\n              public Configuration createConfiguration() {\n                SearchConfiguration newConfiguration = new SearchConfiguration();\n                copyConfiguration(configuration, newConfiguration);\n                return newConfiguration;\n              }\n            } : new ReplaceDialog(searchContext, false, false) {\n              public Configuration createConfiguration() {\n                ReplaceConfiguration newConfiguration = new ReplaceConfiguration();\n                copyConfiguration(configuration, newConfiguration);\n                return newConfiguration;\n              }\n            };\n          }\n        });\n        dialog.setValuesFromConfig(configuration);\n        dialog.setUseLastConfiguration(true);\n        dialog.show();\n        if (!dialog.isOK()) {\n          return;\n        }\n        Configuration newConfiguration = dialog.getConfiguration();\n        copyConfiguration(newConfiguration, configuration);\n        configurationsChanged(dialog.getSearchContext());\n      }\n    });\n    myRemoveButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        Object[] selected = myTemplatesList.getSelectedValues();\n        for (Object o : selected) {\n          Configuration configuration = (Configuration)o;\n          Iterator<Configuration> iterator = myConfigurations.iterator();\n          while (iterator.hasNext()) {\n            Configuration configuration1 = iterator.next();\n            if (configuration1.getName().equals(configuration.getName())) {\n              iterator.remove();\n            }\n          }\n        }\n        configurationsChanged(createSearchContext());\n      }\n    });\n    // later because InspectionToolPanel enables all controls recursively\n    SwingUtilities.invokeLater(new Runnable(){\n      public void run() {\n        templateListChanged();\n      }\n    });\n  }","commit_id":"036379991293374b28723b30a4222900be5ec7a0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void configureFromDataContext(DataContext context) {\n    setProject((Project)context.getData(DataConstants.PROJECT));\n\n    setFile((PsiFile)context.getData(DataConstants.PSI_FILE));\n    setCurrentFile((VirtualFile)context.getData(DataConstants.VIRTUAL_FILE));\n  }","id":97491,"modified_method":"public void configureFromDataContext(DataContext context) {\n    Project project = (Project)context.getData(DataConstants.PROJECT);\n    if (project == null) {\n      project = ProjectManager.getInstance().getDefaultProject();\n    }\n    setProject(project);\n\n    setFile((PsiFile)context.getData(DataConstants.PSI_FILE));\n    setCurrentFile((VirtualFile)context.getData(DataConstants.VIRTUAL_FILE));\n  }","commit_id":"036379991293374b28723b30a4222900be5ec7a0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createCenterPanel() {\n\n    JPanel editorPanel = new JPanel(new BorderLayout());\n    editorPanel.add(BorderLayout.CENTER, createEditorContent());\n    editorPanel.add(BorderLayout.SOUTH, Box.createVerticalStrut(8));\n    JComponent centerPanel = new JPanel(new BorderLayout());\n    {\n      JPanel panel = new JPanel(new BorderLayout());\n      panel.add(BorderLayout.CENTER, editorPanel);\n      panel.add(BorderLayout.SOUTH, createTemplateManagementButtons());\n      centerPanel.add(BorderLayout.CENTER, panel);\n    }\n\n    JPanel optionsContent = new JPanel(new BorderLayout());\n    centerPanel.add(BorderLayout.SOUTH, optionsContent);\n\n    JPanel searchOptions = new JPanel();\n    searchOptions.setLayout(new GridLayout(getRowsCount(), 1, 0, 0));\n    searchOptions.setBorder(IdeBorderFactory.createTitledBorder(SSRBundle.message(\"ssdialog.options.group.border\")));\n\n    myScopeChooserCombo = new ScopeChooserCombo(\n      searchContext.getProject(),\n      true,\n      false,\n      isReplaceDialog() ? SSRBundle.message(\"default.replace.scope\") : FindSettings.getInstance().getDefaultScopeName()\n    );\n    JPanel allOptions = new JPanel(new BorderLayout());\n    if (myShowScopePanel) {\n      JPanel scopePanel = new JPanel(new BorderLayout());\n      scopePanel.add(Box.createVerticalStrut(8), BorderLayout.NORTH);\n      JLabel label = new JLabel(SSRBundle.message(\"search.dialog.scope.label\"));\n      scopePanel.add(label, BorderLayout.WEST);\n\n      scopePanel.add(myScopeChooserCombo, BorderLayout.CENTER);\n      label.setLabelFor(myScopeChooserCombo.getComboBox());\n\n      allOptions.add(\n        scopePanel,\n        BorderLayout.SOUTH\n      );\n    }\n\n    buildOptions(searchOptions);\n\n    allOptions.add(searchOptions, BorderLayout.CENTER);\n    optionsContent.add(allOptions, BorderLayout.CENTER);\n\n    JPanel panel = new JPanel(new BorderLayout());\n    panel.setBorder(BorderFactory.createEmptyBorder(0, 4, 0, 0));\n    openInNewTab = new JCheckBox(SSRBundle.message(\"open.in.new.tab.checkbox\"));\n    openInNewTab.setSelected(ourOpenInNewTab);\n    openInNewTab.setEnabled(\n      ToolWindowManager.getInstance(searchContext.getProject()).getToolWindow(ToolWindowId.FIND).isAvailable()\n    );\n    panel.add(openInNewTab, BorderLayout.EAST);\n\n    optionsContent.add(BorderLayout.SOUTH, panel);\n\n    return centerPanel;\n  }","id":97492,"modified_method":"protected JComponent createCenterPanel() {\n\n    JPanel editorPanel = new JPanel(new BorderLayout());\n    editorPanel.add(BorderLayout.CENTER, createEditorContent());\n    editorPanel.add(BorderLayout.SOUTH, Box.createVerticalStrut(8));\n    JComponent centerPanel = new JPanel(new BorderLayout());\n    {\n      JPanel panel = new JPanel(new BorderLayout());\n      panel.add(BorderLayout.CENTER, editorPanel);\n      panel.add(BorderLayout.SOUTH, createTemplateManagementButtons());\n      centerPanel.add(BorderLayout.CENTER, panel);\n    }\n\n    JPanel optionsContent = new JPanel(new BorderLayout());\n    centerPanel.add(BorderLayout.SOUTH, optionsContent);\n\n    JPanel searchOptions = new JPanel();\n    searchOptions.setLayout(new GridLayout(getRowsCount(), 1, 0, 0));\n    searchOptions.setBorder(IdeBorderFactory.createTitledBorder(SSRBundle.message(\"ssdialog.options.group.border\")));\n\n    myScopeChooserCombo = new ScopeChooserCombo(\n      searchContext.getProject(),\n      true,\n      false,\n      isReplaceDialog() ? SSRBundle.message(\"default.replace.scope\") : FindSettings.getInstance().getDefaultScopeName()\n    );\n    JPanel allOptions = new JPanel(new BorderLayout());\n    if (myShowScopePanel) {\n      JPanel scopePanel = new JPanel(new BorderLayout());\n      scopePanel.add(Box.createVerticalStrut(8), BorderLayout.NORTH);\n      JLabel label = new JLabel(SSRBundle.message(\"search.dialog.scope.label\"));\n      scopePanel.add(label, BorderLayout.WEST);\n\n      scopePanel.add(myScopeChooserCombo, BorderLayout.CENTER);\n      label.setLabelFor(myScopeChooserCombo.getComboBox());\n\n      allOptions.add(\n        scopePanel,\n        BorderLayout.SOUTH\n      );\n    }\n\n    buildOptions(searchOptions);\n\n    allOptions.add(searchOptions, BorderLayout.CENTER);\n    optionsContent.add(allOptions, BorderLayout.CENTER);\n\n    JPanel panel = new JPanel(new BorderLayout());\n    panel.setBorder(BorderFactory.createEmptyBorder(0, 4, 0, 0));\n    openInNewTab = new JCheckBox(SSRBundle.message(\"open.in.new.tab.checkbox\"));\n    openInNewTab.setSelected(ourOpenInNewTab);\n    ToolWindow findWindow = ToolWindowManager.getInstance(searchContext.getProject()).getToolWindow(ToolWindowId.FIND);\n    openInNewTab.setEnabled(findWindow != null && findWindow.isAvailable());\n    panel.add(openInNewTab, BorderLayout.EAST);\n\n    optionsContent.add(BorderLayout.SOUTH, panel);\n\n    return centerPanel;\n  }","commit_id":"036379991293374b28723b30a4222900be5ec7a0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void init() {\n        final boolean available = ToolWindowManager.getInstance(myProject).getToolWindow(\"Find\").isAvailable();\n        final boolean enabled = mySettings.OPEN_NEW_TAB && available;\n\n        myForm.getNewTabCheckbox().setEnabled(available);\n        myForm.getNewTabCheckbox().setSelected(enabled);\n\n        myForm.getHighlightCheckbox().setSelected(mySettings.HIGHLIGHT_RESULTS);\n        myForm.getHighlightCheckbox().addItemListener(new ItemListener() {\n            public void itemStateChanged(ItemEvent e) {\n                updateOkAction();\n            }\n        });\n        myForm.getUsageViewCheckbox().setSelected(mySettings.SHOW_USAGE_VIEW);\n        myForm.getUsageViewCheckbox().addItemListener(new ItemListener() {\n            public void itemStateChanged(ItemEvent e) {\n                myForm.getNewTabCheckbox().setEnabled(available && myForm.getUsageViewCheckbox().isSelected());\n                updateOkAction();\n            }\n        });\n\n        super.init();\n    }","id":97493,"modified_method":"protected void init() {\n        final ToolWindow findWindow = ToolWindowManager.getInstance(myProject).getToolWindow(ToolWindowId.FIND);\n        final boolean available = findWindow != null && findWindow.isAvailable();\n        final boolean enabled = mySettings.OPEN_NEW_TAB && available;\n\n        myForm.getNewTabCheckbox().setEnabled(available);\n        myForm.getNewTabCheckbox().setSelected(enabled);\n\n        myForm.getHighlightCheckbox().setSelected(mySettings.HIGHLIGHT_RESULTS);\n        myForm.getHighlightCheckbox().addItemListener(new ItemListener() {\n            public void itemStateChanged(ItemEvent e) {\n                updateOkAction();\n            }\n        });\n        myForm.getUsageViewCheckbox().setSelected(mySettings.SHOW_USAGE_VIEW);\n        myForm.getUsageViewCheckbox().addItemListener(new ItemListener() {\n            public void itemStateChanged(ItemEvent e) {\n                myForm.getNewTabCheckbox().setEnabled(available && myForm.getUsageViewCheckbox().isSelected());\n                updateOkAction();\n            }\n        });\n\n        super.init();\n    }","commit_id":"b1d7e63dc39e0ee76723196d013585ead49f98c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void init() {\n        final boolean available = ToolWindowManager.getInstance(myProject).getToolWindow(\"Find\").isAvailable();\n        final boolean enabled = mySettings.OPEN_NEW_TAB && available;\n\n        myForm.getNewTabCheckbox().setEnabled(available);\n        myForm.getNewTabCheckbox().setSelected(enabled);\n\n        myForm.getScopePanel().addPropertyChangeListener(\"scope\", new PropertyChangeListener() {\n            public void propertyChange(PropertyChangeEvent evt) {\n                updateOkAction();\n            }\n        });\n\n        myForm.getMatchEachNode().setSelected(mySettings.MATCH_RECURSIVELY);\n        myForm.getMatchRootNode().setSelected(!mySettings.MATCH_RECURSIVELY);\n\n        super.init();\n    }","id":97494,"modified_method":"protected void init() {\n        final ToolWindow findWindow = ToolWindowManager.getInstance(myProject).getToolWindow(ToolWindowId.FIND);\n        final boolean available = findWindow != null && findWindow.isAvailable();\n        final boolean enabled = mySettings.OPEN_NEW_TAB && available;\n\n        myForm.getNewTabCheckbox().setEnabled(available);\n        myForm.getNewTabCheckbox().setSelected(enabled);\n\n        myForm.getScopePanel().addPropertyChangeListener(\"scope\", new PropertyChangeListener() {\n            public void propertyChange(PropertyChangeEvent evt) {\n                updateOkAction();\n            }\n        });\n\n        myForm.getMatchEachNode().setSelected(mySettings.MATCH_RECURSIVELY);\n        myForm.getMatchRootNode().setSelected(!mySettings.MATCH_RECURSIVELY);\n\n        super.init();\n    }","commit_id":"b1d7e63dc39e0ee76723196d013585ead49f98c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * This method is responsible for generating the top heading of the page.\n     *\n     * @param request the HTTP request coming from the user\n     * @param response the HTTP response, where data is rendered\n     * @return the writer that was used for generating the response.\n     * @throws IOException on I/O error\n     * @see #endResponse(PrintWriter)\n     */\n    protected PrintWriter startResponse( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n        response.setCharacterEncoding( \"utf-8\" );\n        response.setContentType( \"text/html\" );\n\n        final PrintWriter pw = response.getWriter();\n\n        final String appRoot = ( String ) request.getAttribute( WebConsoleConstants.ATTR_APP_ROOT );\n\n        // support localization of the plugin title\n        String title = getTitle();\n        if ( title.startsWith( \"%\" ) )\n        {\n            title = \"${\" + title.substring( 1 ) + \"}\";\n        }\n\n        String header = MessageFormat.format( getHeader(), new Object[]\n            { brandingPlugin.getBrandName(), title, appRoot, getLabel(), toUrl( brandingPlugin.getFavIcon(), appRoot ),\n                toUrl( brandingPlugin.getMainStyleSheet(), appRoot ), brandingPlugin.getProductURL(),\n                brandingPlugin.getProductName(), toUrl( brandingPlugin.getProductImage(), appRoot ),\n                getCssLinks( appRoot ) } );\n        pw.println( header );\n\n        return pw;\n    }","id":97495,"modified_method":"/**\n     * This method is responsible for generating the top heading of the page.\n     *\n     * @param request the HTTP request coming from the user\n     * @param response the HTTP response, where data is rendered\n     * @return the writer that was used for generating the response.\n     * @throws IOException on I/O error\n     * @see #endResponse(PrintWriter)\n     */\n    protected PrintWriter startResponse( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n        response.setCharacterEncoding( \"utf-8\" ); //$NON-NLS-1$\n        response.setContentType( \"text/html\" ); //$NON-NLS-1$\n\n        final PrintWriter pw = response.getWriter();\n\n        final String appRoot = ( String ) request.getAttribute( WebConsoleConstants.ATTR_APP_ROOT );\n\n        // support localization of the plugin title\n        String title = getTitle();\n        if ( title.startsWith( \"%\" ) ) //$NON-NLS-1$\n        {\n            title = \"${\" + title.substring( 1 ) + \"}\"; //$NON-NLS-1$ //$NON-NLS-2$\n        }\n\n        VariableResolver resolver = WebConsoleUtil.getVariableResolver(request);\n        if (resolver instanceof DefaultVariableResolver) {\n            DefaultVariableResolver r = (DefaultVariableResolver) resolver;\n            r.put(\"head.title\", title); //$NON-NLS-1$\n            r.put(\"head.label\", getLabel()); //$NON-NLS-1$\n            r.put(\"head.cssLinks\", getCssLinks(appRoot)); //$NON-NLS-1$\n            r.put(\"brand.name\", brandingPlugin.getBrandName()); //$NON-NLS-1$\n            r.put(\"brand.product.url\", brandingPlugin.getProductURL()); //$NON-NLS-1$\n            r.put(\"brand.product.name\", brandingPlugin.getProductName()); //$NON-NLS-1$\n            r.put(\"brand.product.img\", toUrl( brandingPlugin.getProductImage(), appRoot )); //$NON-NLS-1$\n            r.put(\"brand.favicon\", toUrl( brandingPlugin.getFavIcon(), appRoot )); //$NON-NLS-1$\n            r.put(\"brand.css\", toUrl( brandingPlugin.getMainStyleSheet(), appRoot )); //$NON-NLS-1$\n        }\n        pw.println( getHeader() );\n\n        return pw;\n    }","commit_id":"49ab2bb34bb5aab4e9d3358782e2cb263d165a4e","url":"https://github.com/apache/felix"},{"original_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n            ActionForm formIn,\n            HttpServletRequest request,\n            HttpServletResponse response) {\n\n        RequestContext context = new RequestContext(request);\n        DynaActionForm form = (DynaActionForm)formIn;\n\n        User loggedInUser = context.getLoggedInUser();\n        Long sid = context.getRequiredParam(RequestContext.SID);\n        Server server = SystemManager.lookupByIdAndUser(sid, loggedInUser);\n\n        User user =  context.getLoggedInUser();\n        Long cikid = context.getParamAsLong(CIKID_PARAM);\n        CustomDataKey key = OrgFactory.lookupKeyById(cikid);\n\n        Session session = HibernateFactory.getSession();\n        CustomDataValue cdv = (CustomDataValue) session.getNamedQuery(\n                \"CustomDataValue.findByServerAndKey\").setEntity(\"server\", server)\n                .setEntity(\"key\", key)\n                .setCacheable(true).uniqueResult();\n\n        form.set(LABEL_PARAM, key.getLabel());\n        request.setAttribute(\"system\", server);\n        request.setAttribute(\"sid\", server.getId());\n        request.setAttribute(CIKID_PARAM, cikid);\n        request.setAttribute(LABEL_PARAM, key.getLabel());\n        request.setAttribute(CREATE_PARAM, cdv.getCreated());\n        request.setAttribute(MODIFY_PARAM, cdv.getModified());\n        request.setAttribute(CREATOR_PARAM, cdv.getCreator().getLogin());\n        User lastModifier = cdv.getLastModifier();\n        if (lastModifier != null) {\n            request.setAttribute(MODIFIER_PARAM, cdv.getLastModifier().getLogin());\n        }\n        else {\n            request.setAttribute(MODIFIER_PARAM, \"\");\n        }\n\n        if (context.isSubmitted()) {\n            server.addCustomDataValue(key.getLabel(), (String)form.get(VAL_PARAM), user);\nSystem.out.println(\"setting value to \" + (String)form.get(VAL_PARAM));\n            return mapping.findForward(\"updated\");\n        }\n        else {\n            request.setAttribute(VAL_PARAM, cdv.getValue());\n        }\n\n        return mapping.findForward(\"default\");\n    }","id":97496,"modified_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n            ActionForm formIn,\n            HttpServletRequest request,\n            HttpServletResponse response) {\n\n        RequestContext context = new RequestContext(request);\n        DynaActionForm form = (DynaActionForm)formIn;\n\n        User loggedInUser = context.getLoggedInUser();\n        Long sid = context.getRequiredParam(RequestContext.SID);\n        Server server = SystemManager.lookupByIdAndUser(sid, loggedInUser);\n        Map params = new HashMap();\n        StrutsDelegate strutsDelegate = getStrutsDelegate();\n\n        params.put(RequestContext.SID, request.getParameter(RequestContext.SID));\n\n        User user =  context.getLoggedInUser();\n        Long cikid = context.getParamAsLong(CIKID_PARAM);\n        CustomDataKey key = OrgFactory.lookupKeyById(cikid);\n\n        Session session = HibernateFactory.getSession();\n        CustomDataValue cdv = (CustomDataValue) session.getNamedQuery(\n                \"CustomDataValue.findByServerAndKey\").setEntity(\"server\", server)\n                .setEntity(\"key\", key)\n                .setCacheable(true).uniqueResult();\n\n        form.set(LABEL_PARAM, key.getLabel());\n        request.setAttribute(\"system\", server);\n        request.setAttribute(\"sid\", server.getId());\n        request.setAttribute(CIKID_PARAM, cikid);\n        request.setAttribute(LABEL_PARAM, key.getLabel());\n        request.setAttribute(CREATE_PARAM, cdv.getCreated());\n        request.setAttribute(MODIFY_PARAM, cdv.getModified());\n        request.setAttribute(CREATOR_PARAM, cdv.getCreator().getLogin());\n        User lastModifier = cdv.getLastModifier();\n        if (lastModifier != null) {\n            request.setAttribute(MODIFIER_PARAM, cdv.getLastModifier().getLogin());\n        }\n        else {\n            request.setAttribute(MODIFIER_PARAM, \"\");\n        }\n\n        if (context.isSubmitted()) {\n            server.addCustomDataValue(key.getLabel(), (String)form.get(VAL_PARAM), user);\n            request.setAttribute(VAL_PARAM, (String)form.get(VAL_PARAM));\n            return getStrutsDelegate().forwardParams(mapping.findForward(\"updated\"),\n                    params);\n        }\n        else {\n            request.setAttribute(VAL_PARAM, cdv.getValue());\n        }\n\n        return getStrutsDelegate().forwardParams(mapping.findForward(\"default\"), params);\n    }","commit_id":"5228833802e94446594c328f2b0b446a0d1adb24","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n            ActionForm formIn,\n            HttpServletRequest request,\n            HttpServletResponse response) {\n\n        RequestContext requestContext = new RequestContext(request);\n        User user =  requestContext.getLoggedInUser();\n        \n        \n        long cid = requestContext.getRequiredParam(\"cid\");\n        \n        Channel chan = ChannelFactory.lookupByIdAndUser(cid, user);\n        ChannelFactory.lookupByLabelAndUser(chan.getLabel(), user);\n        \n        if (requestContext.isSubmitted()) {\n            UserManager.verifyChannelAdmin(user, chan);\n            String global = request.getParameter(\"global\");\n            chan.setGloballySubscribable(global != null, user.getOrg());\n            chan = (Channel) ChannelFactory.reload(chan);\n        }\n        \n        request.setAttribute(\"systems_subscribed\",  \n                SystemManager.subscribedToChannelSize(user, cid));\n        request.setAttribute(\"channel_name\", chan.getName());\n        request.setAttribute(\"pack_size\", ChannelFactory.getPackageCount(chan));\n        request.setAttribute(\"globally\", chan.isGloballySubscribable(user.getOrg()));\n        request.setAttribute(\"channel\", chan);\n        \n        if (!user.hasRole(RoleFactory.CHANNEL_ADMIN)) {\n            request.setAttribute(\"checkbox_disabled\", true);\n        }\n        \n        \n        \n        return mapping.findForward(\"default\");\n\n    }","id":97497,"modified_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n            ActionForm formIn,\n            HttpServletRequest request,\n            HttpServletResponse response) {\n\n        DynaActionForm form = (DynaActionForm)formIn;\n        RequestContext ctx = new RequestContext(request);\n        User user =  ctx.getLoggedInUser();\n        Map params = makeParamMap(request);\n        String fwd = \"default\";\n        \n        long cid = ctx.getRequiredParam(\"cid\");\n        Channel chan = ChannelManager.lookupByIdAndUser(cid, user);\n        \n        if (isSubmitted(form)) {\n            UserManager.verifyChannelAdmin(user, chan);\n            String global = (String)form.get(\"global\");\n            chan.setGloballySubscribable((global != null) &&\n                    (\"all\".equals(global)), user.getOrg());\n            // this is evil but necessary\n            chan = (Channel) ChannelFactory.reload(chan);\n            params.put(\"cid\", cid);\n            fwd = \"success\";\n        }\n\n        request.setAttribute(\"systems_subscribed\",  \n                SystemManager.subscribedToChannelSize(user, cid));\n        request.setAttribute(\"channel_name\", chan.getName());\n        request.setAttribute(\"pack_size\", ChannelFactory.getPackageCount(chan));\n        request.setAttribute(\"globally\", chan.isGloballySubscribable(user.getOrg()));\n        request.setAttribute(\"channel\", chan);\n\n        // turn on the right radio button\n        if (chan.isGloballySubscribable(user.getOrg())) {\n            form.set(\"global\", \"all\");\n        }\n        else {\n            form.set(\"global\", \"selected\");\n        }\n        \n        if (user.hasRole(RoleFactory.CHANNEL_ADMIN) &&\n            UserManager.verifyChannelAdmin(user, chan)) {\n            request.setAttribute(\"has_access\", true);\n        }\n        else {\n            request.setAttribute(\"has_access\", false);\n        }\n        \n        return getStrutsDelegate().forwardParams(\n                mapping.findForward(fwd), params);\n    }","commit_id":"226714b91c3bf117b4bf890dce7e9a0d47938ef7","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public ActionForward execute(ActionMapping actionMapping,\n                                 ActionForm actionForm,\n                                 HttpServletRequest request,\n                                 HttpServletResponse response)\n        throws Exception {\n\n        RequestContext context = new RequestContext(request);\n        Map params = new HashMap();\n        params.put(RequestContext.CID, context.getRequiredParam(RequestContext.CID));\n        ListRhnSetHelper helper = new ListRhnSetHelper(this, request, getSetDecl(), params);\n        helper.setDataSetName(DATA_SET);\n        helper.execute();\n        if (helper.isDispatched()) {\n            return actionMapping.findForward(\"confirm\");\n        }\n\n        return actionMapping.findForward(RhnHelper.DEFAULT_FORWARD);\n    }","id":97498,"modified_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping actionMapping,\n                                 ActionForm actionForm,\n                                 HttpServletRequest request,\n                                 HttpServletResponse response)\n        throws Exception {\n\n        RequestContext context = new RequestContext(request);\n        Map params = new HashMap();\n        params.put(RequestContext.CID, context.getRequiredParam(RequestContext.CID));\n        ListSessionSetHelper helper = new ListSessionSetHelper(this, request, params);\n        helper.setDataSetName(DATA_SET);\n        helper.execute();\n\n        if (helper.isDispatched()) {\n            request.setAttribute(\"packagesDecl\", helper.getDecl());\n            return actionMapping.findForward(\"confirm\");\n        }\n\n        Map forwardParams = new HashMap();\n        forwardParams.put(RequestContext.CID, context.getRequiredParam(RequestContext.CID));\n        StrutsDelegate strutsDelegate = getStrutsDelegate();\n\n        return strutsDelegate.forwardParams(\n            actionMapping.findForward(RhnHelper.DEFAULT_FORWARD), forwardParams);\n    }","commit_id":"2db4dd47a4b3a9d3a12eb19e72d7f4bece133ea7","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n                                  ActionForm formIn,\n                                  HttpServletRequest request,\n                                  HttpServletResponse response) {\n        DynaActionForm form = (DynaActionForm) formIn;\n        RequestContext ctx = new RequestContext(request);\n        Map params = makeParamMap(request);\n\n        request.setAttribute(mapping.getParameter(), Boolean.TRUE);\n\n        if (ctx.isSubmitted()) {\n\n            ValidatorResult result = RhnValidationHelper.validate(this.getClass(),\n                            makeValidationMap(form), null,\n                                VALIDATION_XSD);\n            if (!result.isEmpty()) {\n                getStrutsDelegate().saveMessages(request, result);\n                RhnValidationHelper.setFailedValidation(request);\n            }\n            else {\n                try {\n                    ActionErrors errors = new ActionErrors();\n                    ContentSource repo = submit(request, errors, form);\n                    if (!errors.isEmpty()) {\n                        addErrors(request, errors);\n                        setupCryptoKeys(ctx);\n                        return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n                    }\n                    if (isCreateMode(request)) {\n                        createSuccessMessage(request,\n                                \"repos.jsp.create.success\", repo.getLabel());\n                    }\n                    else {\n                        createSuccessMessage(request,\n                                \"repos.jsp.update.success\", repo.getLabel());\n                    }\n                    request.removeAttribute(CREATE_MODE);\n                    setupRepo(request, form, repo);\n                    params.put(\"id\", repo.getId());\n                    return getStrutsDelegate().forwardParams(\n                            mapping.findForward(\"success\"), params);\n                }\n                catch (ValidatorException ve) {\n                    getStrutsDelegate().saveMessages(request, ve.getResult());\n                    RhnValidationHelper.setFailedValidation(request);\n                }\n            }\n        }\n\n        setup(request, form, isCreateMode(request));\n\n        return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n    }","id":97499,"modified_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n                                  ActionForm formIn,\n                                  HttpServletRequest request,\n                                  HttpServletResponse response) {\n        DynaActionForm form = (DynaActionForm) formIn;\n        RequestContext ctx = new RequestContext(request);\n        Map<String, Object> params = makeParamMap(request);\n        String cid = null;\n        request.setAttribute(mapping.getParameter(), Boolean.TRUE);\n        if (ctx.hasParam(\"cid\")) {\n            cid = ctx.getParam(\"cid\", false);\n            request.setAttribute(\"cid\", cid);\n        }\n        if (ctx.isSubmitted()) {\n\n            ValidatorResult result = RhnValidationHelper.validate(this.getClass(),\n                            makeValidationMap(form), null,\n                                VALIDATION_XSD);\n            if (!result.isEmpty()) {\n                getStrutsDelegate().saveMessages(request, result);\n                RhnValidationHelper.setFailedValidation(request);\n            }\n            else {\n                try {\n                    ActionErrors errors = new ActionErrors();\n                    ContentSource repo = submit(request, errors, form);\n                    if (!errors.isEmpty()) {\n                        addErrors(request, errors);\n                        setupCryptoKeys(ctx);\n                        return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n                    }\n                    if (isCreateMode(request)) {\n                        createSuccessMessage(request,\n                                \"repos.jsp.create.success\", repo.getLabel());\n                    }\n                    else {\n                        createSuccessMessage(request,\n                                \"repos.jsp.update.success\", repo.getLabel());\n                    }\n                    request.removeAttribute(CREATE_MODE);\n                    /*\n                    If cid isn't specified, repo will be created as usual. Otherwise repo\n                     will be created and will be automatically assigned to channel cid\n                     with redirection to channel repo page\n                     */\n                    if (cid != null) {\n                        params.put(\"cid\", cid);\n                        Channel chan = ChannelFactory.lookupById(Long.parseLong(cid));\n                        Set<ContentSource> sources = chan.getSources();\n                        sources.add(repo);\n                        ChannelFactory.save(chan);\n                        createSuccessMessage(request,\n                                \"channel.edit.repo.updated\", chan.getLabel());\n                        return getStrutsDelegate().forwardParams(\n                                mapping.findForward(\"channelSub\"), params);\n                    }\n                    setupRepo(request, form, repo);\n                    params.put(\"id\", repo.getId());\n                    return getStrutsDelegate().forwardParams(\n                            mapping.findForward(\"success\"), params);\n                }\n                catch (ValidatorException ve) {\n                    getStrutsDelegate().saveMessages(request, ve.getResult());\n                    RhnValidationHelper.setFailedValidation(request);\n                }\n            }\n        }\n\n        setup(request, form, isCreateMode(request));\n\n        return getStrutsDelegate().forwardParams(mapping.findForward(RhnHelper\n                .DEFAULT_FORWARD), params);\n    }","commit_id":"103be3f9b89f208f554c7889e769ddf76156a4cc","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"@Override\n    public long getLong(Object o, long offset) {\n        if (is8BytesAligned(offset)) {\n            return super.getLong(o, offset);\n        } else {\n            return DirectMemoryBits.readLong(o, offset, BIG_ENDIAN);\n        }\n    }","id":97500,"modified_method":"@Override\n    public long getLong(Object base, long offset) {\n        return is8BytesAligned(offset) ? super.getLong(base, offset)\n                : EndiannessUtil.readLong(NATIVE_ACCESS, base, offset, IS_PLATFORM_BIG_ENDIAN);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public short getShort(long address) {\n        if (is2BytesAligned(address)) {\n            return super.getShort(address);\n        } else {\n            return DirectMemoryBits.readShort(address, BIG_ENDIAN);\n        }\n    }","id":97501,"modified_method":"@Override\n    public short getShort(long address) {\n        return is2BytesAligned(address) ? super.getShort(address)\n                : EndiannessUtil.readShort(NATIVE_ACCESS, null, address, IS_PLATFORM_BIG_ENDIAN);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putDouble(long address, double x) {\n        if (is8BytesAligned(address)) {\n            super.putDouble(address, x);\n        } else {\n            DirectMemoryBits.writeDouble(address, x, BIG_ENDIAN);\n        }\n    }","id":97502,"modified_method":"@Override\n    public void putDouble(long address, double x) {\n        if (is8BytesAligned(address)) {\n            super.putDouble(address, x);\n        } else {\n            EndiannessUtil.writeDouble(NATIVE_ACCESS, null, address, x, IS_PLATFORM_BIG_ENDIAN);\n        }\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putInt(long address, int x) {\n        if (is4BytesAligned(address)) {\n            super.putInt(address, x);\n        } else {\n            DirectMemoryBits.writeInt(address, x, BIG_ENDIAN);\n        }\n    }","id":97503,"modified_method":"@Override\n    public void putInt(long address, int x) {\n        if (is4BytesAligned(address)) {\n            super.putInt(address, x);\n        } else {\n            EndiannessUtil.writeInt(NATIVE_ACCESS, null, address, x, IS_PLATFORM_BIG_ENDIAN);\n        }\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public char getChar(long address) {\n        if (is2BytesAligned(address)) {\n            return super.getChar(address);\n        } else {\n            return DirectMemoryBits.readChar(address, BIG_ENDIAN);\n        }\n    }","id":97504,"modified_method":"@Override\n    public char getChar(long address) {\n        return is2BytesAligned(address) ? super.getChar(address)\n                : EndiannessUtil.readChar(NATIVE_ACCESS, null, address, IS_PLATFORM_BIG_ENDIAN);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public int getInt(long address) {\n        if (is4BytesAligned(address)) {\n            return super.getInt(address);\n        } else {\n            return DirectMemoryBits.readInt(address, BIG_ENDIAN);\n        }\n    }","id":97505,"modified_method":"@Override\n    public int getInt(long address) {\n        return is4BytesAligned(address) ? super.getInt(address)\n                : EndiannessUtil.readInt(NATIVE_ACCESS, null, address, IS_PLATFORM_BIG_ENDIAN);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putFloat(long address, float x) {\n        if (is4BytesAligned(address)) {\n            super.putFloat(address, x);\n        } else {\n            DirectMemoryBits.writeFloat(address, x, BIG_ENDIAN);\n        }\n    }","id":97506,"modified_method":"@Override\n    public void putFloat(long address, float x) {\n        if (is4BytesAligned(address)) {\n            super.putFloat(address, x);\n        } else {\n            EndiannessUtil.writeFloat(NATIVE_ACCESS, null, address, x, IS_PLATFORM_BIG_ENDIAN);\n        }\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public char getChar(Object o, long offset) {\n        if (is2BytesAligned(offset)) {\n            return super.getChar(o, offset);\n        } else {\n            return DirectMemoryBits.readChar(o, offset, BIG_ENDIAN);\n        }\n    }","id":97507,"modified_method":"@Override\n    public char getChar(Object base, long offset) {\n        return is2BytesAligned(offset) ? super.getChar(base, offset)\n                : EndiannessUtil.readChar(NATIVE_ACCESS, base, offset, IS_PLATFORM_BIG_ENDIAN);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putFloat(Object o, long offset, float x) {\n        if (is4BytesAligned(offset)) {\n            super.putFloat(o, offset, x);\n        } else {\n            DirectMemoryBits.writeFloat(o, offset, x, BIG_ENDIAN);\n        }\n    }","id":97508,"modified_method":"@Override\n    public void putFloat(Object base, long offset, float x) {\n        if (is4BytesAligned(offset)) {\n            super.putFloat(base, offset, x);\n        } else {\n            EndiannessUtil.writeFloat(NATIVE_ACCESS, base, offset, x, IS_PLATFORM_BIG_ENDIAN);\n        }\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public float getFloat(Object o, long offset) {\n        if (is4BytesAligned(offset)) {\n            return super.getFloat(o, offset);\n        } else {\n            return DirectMemoryBits.readFloat(o, offset, BIG_ENDIAN);\n        }\n    }","id":97509,"modified_method":"@Override\n    public float getFloat(Object base, long offset) {\n        return is4BytesAligned(offset) ? super.getFloat(base, offset)\n                : EndiannessUtil.readFloat(NATIVE_ACCESS, base, offset, IS_PLATFORM_BIG_ENDIAN);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putDouble(Object o, long offset, double x) {\n        if (is8BytesAligned(offset)) {\n            super.putDouble(o, offset, x);\n        } else {\n            DirectMemoryBits.writeDouble(o, offset, x, BIG_ENDIAN);\n        }\n    }","id":97510,"modified_method":"@Override\n    public void putDouble(Object base, long offset, double x) {\n        if (is8BytesAligned(offset)) {\n            super.putDouble(base, offset, x);\n        } else {\n            EndiannessUtil.writeDouble(NATIVE_ACCESS, base, offset, x, IS_PLATFORM_BIG_ENDIAN);\n        }\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public AlignmentAwareMemoryAccessor() {\n        if (!AVAILABLE) {\n            throw new IllegalStateException(getClass().getName() + \" can only be used only when Unsafe is available!\");\n        }\n    }","id":97511,"modified_method":"private AlignmentAwareMemoryAccessor() {\n        if (!AVAILABLE) {\n            throw new IllegalStateException(getClass().getName() + \" can only be used only when Unsafe is available!\");\n        }\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public double getDouble(long address) {\n        if (is8BytesAligned(address)) {\n            return super.getDouble(address);\n        } else {\n            return DirectMemoryBits.readDouble(address, BIG_ENDIAN);\n        }\n    }","id":97512,"modified_method":"@Override\n    public double getDouble(long address) {\n        return is8BytesAligned(address) ? super.getDouble(address)\n                : EndiannessUtil.readDouble(NATIVE_ACCESS, null, address, IS_PLATFORM_BIG_ENDIAN);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public float getFloat(long address) {\n        if (is4BytesAligned(address)) {\n            return super.getFloat(address);\n        } else {\n            return DirectMemoryBits.readFloat(address, BIG_ENDIAN);\n        }\n    }","id":97513,"modified_method":"@Override\n    public float getFloat(long address) {\n        return is4BytesAligned(address) ? super.getFloat(address)\n                : EndiannessUtil.readFloat(NATIVE_ACCESS, null, address, IS_PLATFORM_BIG_ENDIAN);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getLong(long address) {\n        if (is8BytesAligned(address)) {\n            return super.getLong(address);\n        } else {\n            return DirectMemoryBits.readLong(address, BIG_ENDIAN);\n        }\n    }","id":97514,"modified_method":"@Override\n    public long getLong(long address) {\n        return is8BytesAligned(address) ? super.getLong(address)\n                : EndiannessUtil.readLong(NATIVE_ACCESS, null, address, IS_PLATFORM_BIG_ENDIAN);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putInt(Object o, long offset, int x) {\n        if (is4BytesAligned(offset)) {\n            super.putInt(o, offset, x);\n        } else {\n            DirectMemoryBits.writeInt(o, offset, x, BIG_ENDIAN);\n        }\n    }","id":97515,"modified_method":"@Override\n    public void putInt(Object base, long offset, int x) {\n        if (is4BytesAligned(offset)) {\n            super.putInt(base, offset, x);\n        } else {\n            EndiannessUtil.writeInt(NATIVE_ACCESS, base, offset, x, IS_PLATFORM_BIG_ENDIAN);\n        }\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putShort(long address, short x) {\n        if (is2BytesAligned(address)) {\n            super.putShort(address, x);\n        } else {\n            DirectMemoryBits.writeShort(address, x, BIG_ENDIAN);\n        }\n    }","id":97516,"modified_method":"@Override\n    public void putShort(long address, short x) {\n        if (is2BytesAligned(address)) {\n            super.putShort(address, x);\n        } else {\n            EndiannessUtil.writeShort(NATIVE_ACCESS, null, address, x, IS_PLATFORM_BIG_ENDIAN);\n        }\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putLong(Object o, long offset, long x) {\n        if (is8BytesAligned(offset)) {\n            super.putLong(o, offset, x);\n        } else {\n            DirectMemoryBits.writeLong(o, offset, x, BIG_ENDIAN);\n        }\n    }","id":97517,"modified_method":"@Override\n    public void putLong(Object base, long offset, long x) {\n        if (is8BytesAligned(offset)) {\n            super.putLong(base, offset, x);\n        } else {\n            EndiannessUtil.writeLong(NATIVE_ACCESS, base, offset, x, IS_PLATFORM_BIG_ENDIAN);\n        }\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public double getDouble(Object o, long offset) {\n        if (is8BytesAligned(offset)) {\n            return super.getDouble(o, offset);\n        } else {\n            return DirectMemoryBits.readDouble(o, offset, BIG_ENDIAN);\n        }\n    }","id":97518,"modified_method":"@Override\n    public double getDouble(Object base, long offset) {\n        return is8BytesAligned(offset) ? super.getDouble(base, offset)\n                : EndiannessUtil.readDouble(NATIVE_ACCESS, base, offset, IS_PLATFORM_BIG_ENDIAN);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putChar(Object o, long offset, char x) {\n        if (is2BytesAligned(offset)) {\n            super.putChar(o, offset, x);\n        } else {\n            DirectMemoryBits.writeChar(o, offset, x, BIG_ENDIAN);\n        }\n    }","id":97519,"modified_method":"@Override\n    public void putChar(Object base, long offset, char x) {\n        if (is2BytesAligned(offset)) {\n            super.putChar(base, offset, x);\n        } else {\n            EndiannessUtil.writeChar(NATIVE_ACCESS, base, offset, x, IS_PLATFORM_BIG_ENDIAN);\n        }\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putLong(long address, long x) {\n        if (is8BytesAligned(address)) {\n            super.putLong(address, x);\n        } else {\n            DirectMemoryBits.writeLong(address, x, BIG_ENDIAN);\n        }\n    }","id":97520,"modified_method":"@Override\n    public void putLong(long address, long x) {\n        if (is8BytesAligned(address)) {\n            super.putLong(address, x);\n        } else {\n            EndiannessUtil.writeLong(NATIVE_ACCESS, null, address, x, IS_PLATFORM_BIG_ENDIAN);\n        }\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putChar(long address, char x) {\n        if (is2BytesAligned(address)) {\n            super.putChar(address, x);\n        } else {\n            DirectMemoryBits.writeChar(address, x, BIG_ENDIAN);\n        }\n    }","id":97521,"modified_method":"@Override\n    public void putChar(long address, char x) {\n        if (is2BytesAligned(address)) {\n            super.putChar(address, x);\n        } else {\n            EndiannessUtil.writeChar(NATIVE_ACCESS, null, address, x, IS_PLATFORM_BIG_ENDIAN);\n        }\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public short getShort(Object o, long offset) {\n        if (is2BytesAligned(offset)) {\n            return super.getShort(o, offset);\n        } else {\n            return DirectMemoryBits.readShort(o, offset, BIG_ENDIAN);\n        }\n    }","id":97522,"modified_method":"@Override\n    public short getShort(Object base, long offset) {\n        return is2BytesAligned(offset) ? super.getShort(base, offset)\n                : EndiannessUtil.readShort(NATIVE_ACCESS, base, offset, IS_PLATFORM_BIG_ENDIAN);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putShort(Object o, long offset, short x) {\n        if (is2BytesAligned(offset)) {\n            super.putShort(o, offset, x);\n        } else {\n            DirectMemoryBits.writeShort(o, offset, x, BIG_ENDIAN);\n        }\n    }","id":97523,"modified_method":"@Override\n    public void putShort(Object base, long offset, short x) {\n        if (is2BytesAligned(offset)) {\n            super.putShort(base, offset, x);\n        } else {\n            EndiannessUtil.writeShort(NATIVE_ACCESS, base, offset, x, IS_PLATFORM_BIG_ENDIAN);\n        }\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public int getInt(Object o, long offset) {\n        if (is4BytesAligned(offset)) {\n            return super.getInt(o, offset);\n        } else {\n            return DirectMemoryBits.readInt(o, offset, BIG_ENDIAN);\n        }\n    }","id":97524,"modified_method":"@Override\n    public int getInt(Object base, long offset) {\n        return is4BytesAligned(offset) ? super.getInt(base, offset)\n                : EndiannessUtil.readInt(NATIVE_ACCESS, base, offset, IS_PLATFORM_BIG_ENDIAN);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean compareAndSwapLong(Object o, long offset, long expected, long x) {\n        return UNSAFE.compareAndSwapLong(o, offset, expected, x);\n    }","id":97525,"modified_method":"@Override\n    public boolean compareAndSwapLong(Object base, long offset, long expected, long x) {\n        return UNSAFE.compareAndSwapLong(base, offset, expected, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putLongVolatile(Object o, long offset, long x) {\n        UNSAFE.putLongVolatile(o, offset, x);\n    }","id":97526,"modified_method":"@Override\n    public void putLongVolatile(Object base, long offset, long x) {\n        UNSAFE.putLongVolatile(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putCharVolatile(Object o, long offset, char x) {\n        UNSAFE.putCharVolatile(o, offset, x);\n    }","id":97527,"modified_method":"@Override\n    public void putCharVolatile(Object base, long offset, char x) {\n        UNSAFE.putCharVolatile(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void copyMemory(Object srcObj, long srcOffset, Object destObj, long destOffset, long bytes) {\n        UNSAFE.copyMemory(srcObj, srcOffset, destObj, destOffset, bytes);\n    }","id":97528,"modified_method":"@Override\n    public void copyMemory(Object srcObj, long srcOffset, Object destObj, long destOffset, long lengthBytes) {\n        UNSAFE.copyMemory(srcObj, srcOffset, destObj, destOffset, lengthBytes);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public char getChar(Object o, long offset) {\n        return UNSAFE.getChar(o, offset);\n    }","id":97529,"modified_method":"@Override\n    public char getChar(Object base, long offset) {\n        return UNSAFE.getChar(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public int getIntVolatile(Object o, long offset) {\n        return UNSAFE.getIntVolatile(o, offset);\n    }","id":97530,"modified_method":"@Override\n    public int getIntVolatile(Object base, long offset) {\n        return UNSAFE.getIntVolatile(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean getBoolean(Object o, long offset) {\n        return UNSAFE.getBoolean(o, offset);\n    }","id":97531,"modified_method":"@Override\n    public boolean getBoolean(Object base, long offset) {\n        return UNSAFE.getBoolean(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putByte(Object o, long offset, byte x) {\n        UNSAFE.putByte(o, offset, x);\n    }","id":97532,"modified_method":"@Override\n    public void putByte(Object base, long offset, byte x) {\n        UNSAFE.putByte(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putDoubleVolatile(Object o, long offset, double x) {\n        UNSAFE.putDoubleVolatile(o, offset, x);\n    }","id":97533,"modified_method":"@Override\n    public void putDoubleVolatile(Object base, long offset, double x) {\n        UNSAFE.putDoubleVolatile(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putFloatVolatile(Object o, long offset, float x) {\n        UNSAFE.putFloatVolatile(o, offset, x);\n    }","id":97534,"modified_method":"@Override\n    public void putFloatVolatile(Object base, long offset, float x) {\n        UNSAFE.putFloatVolatile(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public byte getByteVolatile(Object o, long offset) {\n        return UNSAFE.getByteVolatile(o, offset);\n    }","id":97535,"modified_method":"@Override\n    public byte getByteVolatile(Object base, long offset) {\n        return UNSAFE.getByteVolatile(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putInt(Object o, long offset, int x) {\n        UNSAFE.putInt(o, offset, x);\n    }","id":97536,"modified_method":"@Override\n    public void putInt(Object base, long offset, int x) {\n        UNSAFE.putInt(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putBoolean(Object o, long offset, boolean x) {\n        UNSAFE.putBoolean(o, offset, x);\n    }","id":97537,"modified_method":"@Override\n    public void putBoolean(Object base, long offset, boolean x) {\n        UNSAFE.putBoolean(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public double getDouble(Object o, long offset) {\n        return UNSAFE.getDouble(o, offset);\n    }","id":97538,"modified_method":"@Override\n    public double getDouble(Object base, long offset) {\n        return UNSAFE.getDouble(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putIntVolatile(Object o, long offset, int x) {\n        UNSAFE.putIntVolatile(o, offset, x);\n    }","id":97539,"modified_method":"@Override\n    public void putIntVolatile(Object base, long offset, int x) {\n        UNSAFE.putIntVolatile(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putOrderedLong(Object o, long offset, long x) {\n        UNSAFE.putOrderedLong(o, offset, x);\n    }","id":97540,"modified_method":"@Override\n    public void putOrderedLong(Object base, long offset, long x) {\n        UNSAFE.putOrderedLong(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Object getObjectVolatile(Object o, long offset) {\n        return UNSAFE.getObjectVolatile(o, offset);\n    }","id":97541,"modified_method":"@Override\n    public Object getObjectVolatile(Object base, long offset) {\n        return UNSAFE.getObjectVolatile(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putShort(Object o, long offset, short x) {\n        UNSAFE.putShort(o, offset, x);\n    }","id":97542,"modified_method":"@Override\n    public void putShort(Object base, long offset, short x) {\n        UNSAFE.putShort(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public StandardMemoryAccessor() {\n        if (!AVAILABLE) {\n            throw new IllegalStateException(getClass().getName() + \" can only be used only when Unsafe is available!\");\n        }\n    }","id":97543,"modified_method":"StandardMemoryAccessor() {\n        if (!AVAILABLE) {\n            throw new IllegalStateException(getClass().getName() + \" can only be used only when Unsafe is available!\");\n        }\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putDouble(Object o, long offset, double x) {\n        UNSAFE.putDouble(o, offset, x);\n    }","id":97544,"modified_method":"@Override\n    public void putDouble(Object base, long offset, double x) {\n        UNSAFE.putDouble(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getLong(Object o, long offset) {\n        return UNSAFE.getLong(o, offset);\n    }","id":97545,"modified_method":"@Override\n    public long getLong(Object base, long offset) {\n        return UNSAFE.getLong(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Object getObject(Object o, long offset) {\n        return UNSAFE.getObject(o, offset);\n    }","id":97546,"modified_method":"@Override\n    public Object getObject(Object base, long offset) {\n        return UNSAFE.getObject(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putByteVolatile(Object o, long offset, byte x) {\n        UNSAFE.putByteVolatile(o, offset, x);\n    }","id":97547,"modified_method":"@Override\n    public void putByteVolatile(Object base, long offset, byte x) {\n        UNSAFE.putByteVolatile(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public float getFloatVolatile(Object o, long offset) {\n        return UNSAFE.getFloatVolatile(o, offset);\n    }","id":97548,"modified_method":"@Override\n    public float getFloatVolatile(Object base, long offset) {\n        return UNSAFE.getFloatVolatile(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putBooleanVolatile(Object o, long offset, boolean x) {\n        UNSAFE.putBooleanVolatile(o, offset, x);\n    }","id":97549,"modified_method":"@Override\n    public void putBooleanVolatile(Object base, long offset, boolean x) {\n        UNSAFE.putBooleanVolatile(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public short getShort(Object o, long offset) {\n        return UNSAFE.getShort(o, offset);\n    }","id":97550,"modified_method":"@Override\n    public short getShort(Object base, long offset) {\n        return UNSAFE.getShort(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean compareAndSwapObject(Object o, long offset, Object expected, Object x) {\n        return UNSAFE.compareAndSwapObject(o, offset, expected, x);\n    }","id":97551,"modified_method":"@Override\n    public boolean compareAndSwapObject(Object base, long offset, Object expected, Object x) {\n        return UNSAFE.compareAndSwapObject(base, offset, expected, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public short getShortVolatile(Object o, long offset) {\n        return UNSAFE.getShortVolatile(o, offset);\n    }","id":97552,"modified_method":"@Override\n    public short getShortVolatile(Object base, long offset) {\n        return UNSAFE.getShortVolatile(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean compareAndSwapInt(Object o, long offset, int expected, int x) {\n        return UNSAFE.compareAndSwapInt(o, offset, expected, x);\n    }","id":97553,"modified_method":"@Override\n    public boolean compareAndSwapInt(Object base, long offset, int expected, int x) {\n        return UNSAFE.compareAndSwapInt(base, offset, expected, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public int getInt(Object o, long offset) {\n        return UNSAFE.getInt(o, offset);\n    }","id":97554,"modified_method":"@Override\n    public int getInt(Object base, long offset) {\n        return UNSAFE.getInt(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putFloat(Object o, long offset, float x) {\n        UNSAFE.putFloat(o, offset, x);\n    }","id":97555,"modified_method":"@Override\n    public void putFloat(Object base, long offset, float x) {\n        UNSAFE.putFloat(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void copyMemory(long srcAddress, long destAddress, long bytes) {\n        UNSAFE.copyMemory(srcAddress, destAddress, bytes);\n    }","id":97556,"modified_method":"@Override\n    public void copyMemory(long srcAddress, long destAddress, long lengthBytes) {\n        UNSAFE.copyMemory(srcAddress, destAddress, lengthBytes);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public byte getByte(Object o, long offset) {\n        return UNSAFE.getByte(o, offset);\n    }","id":97557,"modified_method":"@Override\n    public byte getByte(Object base, long offset) {\n        return UNSAFE.getByte(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getLongVolatile(Object o, long offset) {\n        return UNSAFE.getLongVolatile(o, offset);\n    }","id":97558,"modified_method":"@Override\n    public long getLongVolatile(Object base, long offset) {\n        return UNSAFE.getLongVolatile(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public double getDoubleVolatile(Object o, long offset) {\n        return UNSAFE.getDoubleVolatile(o, offset);\n    }","id":97559,"modified_method":"@Override\n    public double getDoubleVolatile(Object base, long offset) {\n        return UNSAFE.getDoubleVolatile(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putShortVolatile(Object o, long offset, short x) {\n        UNSAFE.putShortVolatile(o, offset, x);\n    }","id":97560,"modified_method":"@Override\n    public void putShortVolatile(Object base, long offset, short x) {\n        UNSAFE.putShortVolatile(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putObject(Object o, long offset, Object x) {\n        UNSAFE.putObject(o, offset, x);\n    }","id":97561,"modified_method":"@Override\n    public void putObject(Object base, long offset, Object x) {\n        UNSAFE.putObject(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public boolean getBooleanVolatile(Object o, long offset) {\n        return UNSAFE.getBooleanVolatile(o, offset);\n    }","id":97562,"modified_method":"@Override\n    public boolean getBooleanVolatile(Object base, long offset) {\n        return UNSAFE.getBooleanVolatile(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putObjectVolatile(Object o, long offset, Object x) {\n        UNSAFE.putObjectVolatile(o, offset, x);\n    }","id":97563,"modified_method":"@Override\n    public void putObjectVolatile(Object base, long offset, Object x) {\n        UNSAFE.putObjectVolatile(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putOrderedInt(Object o, long offset, int x) {\n        UNSAFE.putOrderedInt(o, offset, x);\n    }","id":97564,"modified_method":"@Override\n    public void putOrderedInt(Object base, long offset, int x) {\n        UNSAFE.putOrderedInt(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public float getFloat(Object o, long offset) {\n        return UNSAFE.getFloat(o, offset);\n    }","id":97565,"modified_method":"@Override\n    public float getFloat(Object base, long offset) {\n        return UNSAFE.getFloat(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putChar(Object o, long offset, char x) {\n        UNSAFE.putChar(o, offset, x);\n    }","id":97566,"modified_method":"@Override\n    public void putChar(Object base, long offset, char x) {\n        UNSAFE.putChar(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public char getCharVolatile(Object o, long offset) {\n        return UNSAFE.getCharVolatile(o, offset);\n    }","id":97567,"modified_method":"@Override\n    public char getCharVolatile(Object base, long offset) {\n        return UNSAFE.getCharVolatile(base, offset);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void setMemory(long address, long bytes, byte value) {\n        UNSAFE.setMemory(address, bytes, value);\n    }","id":97568,"modified_method":"@Override\n    public void setMemory(long address, long lengthBytes, byte value) {\n        UNSAFE.setMemory(address, lengthBytes, value);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putLong(Object o, long offset, long x) {\n        UNSAFE.putLong(o, offset, x);\n    }","id":97569,"modified_method":"@Override\n    public void putLong(Object base, long offset, long x) {\n        UNSAFE.putLong(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void putOrderedObject(Object o, long offset, Object x) {\n        UNSAFE.putOrderedObject(o, offset, x);\n    }","id":97570,"modified_method":"@Override\n    public void putOrderedObject(Object base, long offset, Object x) {\n        UNSAFE.putOrderedObject(base, offset, x);\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Returns the state about this kind of {@link UnsafeBasedMemoryAccessor} instances are available or not.\n     *\n     * @return <tt>true<\/tt> if this kind of {@link UnsafeBasedMemoryAccessor} instances are available,\n     *         otherwise <tt>false<\/tt>\n     */\n    public static boolean isAvailable() {\n        return AVAILABLE;\n    }","id":97571,"modified_method":"/**\n     * Returns whether memory accessors of type {@link UnsafeBasedMemoryAccessor} are available or not.\n     */\n    public static boolean isAvailable() {\n        return AVAILABLE;\n    }","commit_id":"97d74422f29dc7cab9222e6e0d9a8c9c888f885f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void loadStaticContent() {\n        for (String mountPoint : staticContent.keySet()) {\n            String contentLocation = staticContent.get(mountPoint);\n            try {\n                final WebAppContext webadmin = new WebAppContext();\n                webadmin.setServer(jetty);\n                webadmin.setContextPath(mountPoint);\n                URL url = getClass().getClassLoader().getResource(contentLocation).toURI().toURL();\n                final Resource resource = Resource.newResource(url);\n                webadmin.setBaseResource(resource);\n                jetty.addHandler(webadmin);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }","id":97572,"modified_method":"private void loadStaticContent() {\n        for (String mountPoint : staticContent.keySet()) {\n            String contentLocation = staticContent.get(mountPoint);\n            log.info(\"Mounting static content at [%s] from [%s]\", mountPoint, contentLocation);\n            try {\n                final WebAppContext webadmin = new WebAppContext();\n                webadmin.setServer(jetty);\n                webadmin.setContextPath(mountPoint);\n                URL resourceLoc = getClass().getClassLoader().getResource(contentLocation);\n                log.info(\"Found [%s]\", resourceLoc);\n                URL url = resourceLoc.toURI().toURL();\n                final Resource resource = Resource.newResource(url);\n                webadmin.setBaseResource(resource);\n                log.info(\"Mounting static content from [%s] at [%s]\", url, mountPoint);\n                jetty.addHandler(webadmin);\n            } catch (Exception e) {\n                log.error( e );\n                e.printStackTrace();\n                throw new RuntimeException(e);\n            }\n        }\n    }","commit_id":"4ee5656219522c062752754d0c8f82595bef68eb","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void loadJAXRSPackages() {\n        for(String mountPoint : jaxRSPackages.keySet()) {\n             ServletHolder servletHolder = jaxRSPackages.get(mountPoint);\n             Context jerseyContext = new Context(jetty, mountPoint);\n             jerseyContext.addServlet(servletHolder, \"/*\");\n        }\n    }","id":97573,"modified_method":"private void loadJAXRSPackages() {\n        for(String mountPoint : jaxRSPackages.keySet()) {\n             ServletHolder servletHolder = jaxRSPackages.get(mountPoint);\n             log.info(\"Mounting JAXRS package at [%s]\", mountPoint);\n             Context jerseyContext = new Context(jetty, mountPoint);\n             jerseyContext.addServlet(servletHolder, \"/*\");\n        }\n    }","commit_id":"4ee5656219522c062752754d0c8f82595bef68eb","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Integer start(String[] args) {\n        webServerPort = configurator.configuration().getInt(WEBSERVER_PORT, DEFAULT_WEBSERVER_PORT);\n        try {\n            webServer.setPort(webServerPort);\n            webServer.addJAXRSPackages(listFrom(new String[] {REST_API_PACKAGE}), REST_API_PATH);\n            \n            // webadmin assumes root\n            webServer.addStaticContent(\"html\", \"/webadmin\");\n            webServer.addJAXRSPackages(listFrom(new String[] {WEB_ADMIN_REST_API_PACKAGE}), \"/\");\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", webServerPort);\n            \n            return 0;\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            return 1;\n        }\n    }","id":97574,"modified_method":"public Integer start(String[] args) {\n        webServerPort = configurator.configuration().getInt(WEBSERVER_PORT, DEFAULT_WEBSERVER_PORT);\n        try {\n            webServer.setPort(webServerPort);\n            // webadmin assumes root\n            log.info(\"Mounting static html at [%s]\", WEBADMIN_PATH);\n            webServer.addStaticContent(\"html\", WEBADMIN_PATH);\n            \n            log.info(\"Mounting REST at [%s]\", REST_API_PATH);\n            webServer.addJAXRSPackages(listFrom(new String[] {REST_API_PACKAGE}), REST_API_PATH);\n\n            log.info(\"Mounting manage API at [%s]\", MANAGE_PATH);\n            webServer.addJAXRSPackages(listFrom(new String[] {WEB_ADMIN_REST_API_PACKAGE}), MANAGE_PATH);\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", webServerPort);\n            \n            return null; //yes, that's right!\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            return 1;\n        }\n    }","commit_id":"4ee5656219522c062752754d0c8f82595bef68eb","url":"https://github.com/neo4j/neo4j"},{"original_method":"private WebServer webServer() {\n        WebServer webServer = new Jetty6WebServer();\n        webServer.addJAXRSPackages(listFrom(new String[] {NeoServer.REST_API_PACKAGE}), NeoServer.REST_API_PATH);\n        return webServer;\n    }","id":97575,"modified_method":"private WebServer webServer() {\n        WebServer webServer = new Jetty6WebServer();\n        //webServer.addStaticContent(\"html\", NeoServer.WEBADMIN_PATH);\n        //webServer.addJAXRSPackages(listFrom(new String[] {NeoServer.REST_API_PACKAGE}), NeoServer.REST_API_PATH);\n        //webServer.addJAXRSPackages(listFrom(new String[] {NeoServer.WEB_ADMIN_REST_API_PACKAGE}), NeoServer.MANAGE_PATH);\n        return webServer;\n    }","commit_id":"4ee5656219522c062752754d0c8f82595bef68eb","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        InMemoryAppender appender = new InMemoryAppender(NeoServer.log);\n        NeoServer server = server();\n        server.start(null);\n\n        assertThat(appender.toString(), containsString(\"Started Neo Server on port [\" + 7474 + \"]\"));\n\n        server.stop();\n    }","id":97576,"modified_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        InMemoryAppender appender = new InMemoryAppender(NeoServer.log);\n        InMemoryAppender jettyServerAppender = new InMemoryAppender(Jetty6WebServer.log);\n        NeoServer server = server();\n        server.start(null);\n        System.out.println(appender.toString());\n        System.out.println(jettyServerAppender.toString());\n        assertThat(appender.toString(), containsString(\"Started Neo Server on port [\" + 7474 + \"]\"));\n\n        server.stop();\n    }","commit_id":"4ee5656219522c062752754d0c8f82595bef68eb","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void loadStaticContent() {\n        for (String mountPoint : staticContent.keySet()) {\n            String contentLocation = staticContent.get(mountPoint);\n            try {\n                final WebAppContext webadmin = new WebAppContext();\n                webadmin.setServer(jetty);\n                webadmin.setContextPath(mountPoint);\n                URL url = getClass().getClassLoader().getResource(contentLocation).toURI().toURL();\n                final Resource resource = Resource.newResource(url);\n                webadmin.setBaseResource(resource);\n                jetty.addHandler(webadmin);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }","id":97577,"modified_method":"private void loadStaticContent() {\n        for (String mountPoint : staticContent.keySet()) {\n            String contentLocation = staticContent.get(mountPoint);\n            log.info(\"Mounting static content at [%s] from [%s]\", mountPoint, contentLocation);\n            try {\n                final WebAppContext webadmin = new WebAppContext();\n                webadmin.setServer(jetty);\n                webadmin.setContextPath(mountPoint);\n                URL resourceLoc = getClass().getClassLoader().getResource(contentLocation);\n                log.info(\"Found [%s]\", resourceLoc);\n                URL url = resourceLoc.toURI().toURL();\n                final Resource resource = Resource.newResource(url);\n                webadmin.setBaseResource(resource);\n                log.info(\"Mounting static content from [%s] at [%s]\", url, mountPoint);\n                jetty.addHandler(webadmin);\n            } catch (Exception e) {\n                log.error( e );\n                e.printStackTrace();\n                throw new RuntimeException(e);\n            }\n        }\n    }","commit_id":"a7adc6d118a2b47a2f3dfdc257e17013f9097cc3","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void loadJAXRSPackages() {\n        for(String mountPoint : jaxRSPackages.keySet()) {\n             ServletHolder servletHolder = jaxRSPackages.get(mountPoint);\n             Context jerseyContext = new Context(jetty, mountPoint);\n             jerseyContext.addServlet(servletHolder, \"/*\");\n        }\n    }","id":97578,"modified_method":"private void loadJAXRSPackages() {\n        for(String mountPoint : jaxRSPackages.keySet()) {\n             ServletHolder servletHolder = jaxRSPackages.get(mountPoint);\n             log.info(\"Mounting JAXRS package at [%s]\", mountPoint);\n             Context jerseyContext = new Context(jetty, mountPoint);\n             jerseyContext.addServlet(servletHolder, \"/*\");\n        }\n    }","commit_id":"a7adc6d118a2b47a2f3dfdc257e17013f9097cc3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Integer start(String[] args) {\n        webServerPort = configurator.configuration().getInt(WEBSERVER_PORT, DEFAULT_WEBSERVER_PORT);\n        try {\n            webServer.setPort(webServerPort);\n            webServer.addJAXRSPackages(listFrom(new String[] {REST_API_PACKAGE}), REST_API_PATH);\n            \n            // webadmin assumes root\n            webServer.addStaticContent(\"html\", \"/webadmin\");\n            webServer.addJAXRSPackages(listFrom(new String[] {WEB_ADMIN_REST_API_PACKAGE}), \"/\");\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", webServerPort);\n            \n            return 0;\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            return 1;\n        }\n    }","id":97579,"modified_method":"public Integer start(String[] args) {\n        webServerPort = configurator.configuration().getInt(WEBSERVER_PORT, DEFAULT_WEBSERVER_PORT);\n        try {\n            webServer.setPort(webServerPort);\n            // webadmin assumes root\n            log.info(\"Mounting static html at [%s]\", WEBADMIN_PATH);\n            webServer.addStaticContent(\"html\", WEBADMIN_PATH);\n            \n            log.info(\"Mounting REST at [%s]\", REST_API_PATH);\n            webServer.addJAXRSPackages(listFrom(new String[] {REST_API_PACKAGE}), REST_API_PATH);\n\n            log.info(\"Mounting manage API at [%s]\", MANAGE_PATH);\n            webServer.addJAXRSPackages(listFrom(new String[] {WEB_ADMIN_REST_API_PACKAGE}), MANAGE_PATH);\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", webServerPort);\n            \n            return null; //yes, that's right!\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            return 1;\n        }\n    }","commit_id":"a7adc6d118a2b47a2f3dfdc257e17013f9097cc3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        InMemoryAppender appender = new InMemoryAppender(NeoServer.log);\n        NeoServer server = server();\n        server.start(null);\n\n        assertThat(appender.toString(), containsString(\"Started Neo Server on port [\" + 7474 + \"]\"));\n\n        server.stop();\n    }","id":97580,"modified_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        InMemoryAppender appender = new InMemoryAppender(NeoServer.log);\n        InMemoryAppender jettyServerAppender = new InMemoryAppender(Jetty6WebServer.log);\n        NeoServer server = server();\n        server.start(null);\n        System.out.println(appender.toString());\n        System.out.println(jettyServerAppender.toString());\n        assertThat(appender.toString(), containsString(\"Started Neo Server on port [\" + 7474 + \"]\"));\n\n        server.stop();\n    }","commit_id":"a7adc6d118a2b47a2f3dfdc257e17013f9097cc3","url":"https://github.com/neo4j/neo4j"},{"original_method":"private WebServer webServer() {\n        WebServer webServer = new Jetty6WebServer();\n        webServer.addJAXRSPackages(listFrom(new String[] {NeoServer.REST_API_PACKAGE}), NeoServer.REST_API_PATH);\n        return webServer;\n    }","id":97581,"modified_method":"private WebServer webServer() {\n        WebServer webServer = new Jetty6WebServer();\n        //webServer.addStaticContent(\"html\", NeoServer.WEBADMIN_PATH);\n        //webServer.addJAXRSPackages(listFrom(new String[] {NeoServer.REST_API_PACKAGE}), NeoServer.REST_API_PATH);\n        //webServer.addJAXRSPackages(listFrom(new String[] {NeoServer.WEB_ADMIN_REST_API_PACKAGE}), NeoServer.MANAGE_PATH);\n        return webServer;\n    }","commit_id":"a7adc6d118a2b47a2f3dfdc257e17013f9097cc3","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void loadStaticContent() {\n        for (String mountPoint : staticContent.keySet()) {\n            String contentLocation = staticContent.get(mountPoint);\n            try {\n                final WebAppContext webadmin = new WebAppContext();\n                webadmin.setServer(jetty);\n                webadmin.setContextPath(mountPoint);\n                URL url = getClass().getClassLoader().getResource(contentLocation).toURI().toURL();\n                final Resource resource = Resource.newResource(url);\n                webadmin.setBaseResource(resource);\n                jetty.addHandler(webadmin);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }","id":97582,"modified_method":"private void loadStaticContent() {\n        for (String mountPoint : staticContent.keySet()) {\n            String contentLocation = staticContent.get(mountPoint);\n            log.info(\"Mounting static content at [%s] from [%s]\", mountPoint, contentLocation);\n            try {\n                final WebAppContext webadmin = new WebAppContext();\n                webadmin.setServer(jetty);\n                webadmin.setContextPath(mountPoint);\n                URL resourceLoc = getClass().getClassLoader().getResource(contentLocation);\n                log.info(\"Found [%s]\", resourceLoc);\n                URL url = resourceLoc.toURI().toURL();\n                final Resource resource = Resource.newResource(url);\n                webadmin.setBaseResource(resource);\n                log.info(\"Mounting static content from [%s] at [%s]\", url, mountPoint);\n                jetty.addHandler(webadmin);\n            } catch (Exception e) {\n                log.error( e );\n                e.printStackTrace();\n                throw new RuntimeException(e);\n            }\n        }\n    }","commit_id":"6304acd5ac15b23bd5cf19729fa6c52b7c73c901","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void loadJAXRSPackages() {\n        for(String mountPoint : jaxRSPackages.keySet()) {\n             ServletHolder servletHolder = jaxRSPackages.get(mountPoint);\n             Context jerseyContext = new Context(jetty, mountPoint);\n             jerseyContext.addServlet(servletHolder, \"/*\");\n        }\n    }","id":97583,"modified_method":"private void loadJAXRSPackages() {\n        for(String mountPoint : jaxRSPackages.keySet()) {\n             ServletHolder servletHolder = jaxRSPackages.get(mountPoint);\n             log.info(\"Mounting JAXRS package at [%s]\", mountPoint);\n             Context jerseyContext = new Context(jetty, mountPoint);\n             jerseyContext.addServlet(servletHolder, \"/*\");\n        }\n    }","commit_id":"6304acd5ac15b23bd5cf19729fa6c52b7c73c901","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Integer start(String[] args) {\n        webServerPort = configurator.configuration().getInt(WEBSERVER_PORT, DEFAULT_WEBSERVER_PORT);\n        try {\n            webServer.setPort(webServerPort);\n            webServer.addJAXRSPackages(listFrom(new String[] {REST_API_PACKAGE}), REST_API_PATH);\n            \n            // webadmin assumes root\n            webServer.addStaticContent(\"html\", \"/webadmin\");\n            webServer.addJAXRSPackages(listFrom(new String[] {WEB_ADMIN_REST_API_PACKAGE}), \"/\");\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", webServerPort);\n            \n            return 0;\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            return 1;\n        }\n    }","id":97584,"modified_method":"public Integer start(String[] args) {\n        webServerPort = configurator.configuration().getInt(WEBSERVER_PORT, DEFAULT_WEBSERVER_PORT);\n        try {\n            webServer.setPort(webServerPort);\n            // webadmin assumes root\n            log.info(\"Mounting static html at [%s]\", WEBADMIN_PATH);\n            webServer.addStaticContent(\"html\", WEBADMIN_PATH);\n            \n            log.info(\"Mounting REST at [%s]\", REST_API_PATH);\n            webServer.addJAXRSPackages(listFrom(new String[] {REST_API_PACKAGE}), REST_API_PATH);\n\n            log.info(\"Mounting manage API at [%s]\", MANAGE_PATH);\n            webServer.addJAXRSPackages(listFrom(new String[] {WEB_ADMIN_REST_API_PACKAGE}), MANAGE_PATH);\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", webServerPort);\n            \n            return null; //yes, that's right!\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            return 1;\n        }\n    }","commit_id":"6304acd5ac15b23bd5cf19729fa6c52b7c73c901","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        InMemoryAppender appender = new InMemoryAppender(NeoServer.log);\n        NeoServer server = server();\n        server.start(null);\n\n        assertThat(appender.toString(), containsString(\"Started Neo Server on port [\" + 7474 + \"]\"));\n\n        server.stop();\n    }","id":97585,"modified_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        InMemoryAppender appender = new InMemoryAppender(NeoServer.log);\n        InMemoryAppender jettyServerAppender = new InMemoryAppender(Jetty6WebServer.log);\n        NeoServer server = server();\n        server.start(null);\n        System.out.println(appender.toString());\n        System.out.println(jettyServerAppender.toString());\n        assertThat(appender.toString(), containsString(\"Started Neo Server on port [\" + 7474 + \"]\"));\n\n        server.stop();\n    }","commit_id":"6304acd5ac15b23bd5cf19729fa6c52b7c73c901","url":"https://github.com/neo4j/neo4j"},{"original_method":"private WebServer webServer() {\n        WebServer webServer = new Jetty6WebServer();\n        webServer.addJAXRSPackages(listFrom(new String[] {NeoServer.REST_API_PACKAGE}), NeoServer.REST_API_PATH);\n        return webServer;\n    }","id":97586,"modified_method":"private WebServer webServer() {\n        WebServer webServer = new Jetty6WebServer();\n        //webServer.addStaticContent(\"html\", NeoServer.WEBADMIN_PATH);\n        //webServer.addJAXRSPackages(listFrom(new String[] {NeoServer.REST_API_PACKAGE}), NeoServer.REST_API_PATH);\n        //webServer.addJAXRSPackages(listFrom(new String[] {NeoServer.WEB_ADMIN_REST_API_PACKAGE}), NeoServer.MANAGE_PATH);\n        return webServer;\n    }","commit_id":"6304acd5ac15b23bd5cf19729fa6c52b7c73c901","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void loadJAXRSPackages() {\n        for(String mountPoint : jaxRSPackages.keySet()) {\n             ServletHolder servletHolder = jaxRSPackages.get(mountPoint);\n             Context jerseyContext = new Context(jetty, mountPoint);\n             jerseyContext.addServlet(servletHolder, \"/*\");\n        }\n    }","id":97587,"modified_method":"private void loadJAXRSPackages() {\n        for(String mountPoint : jaxRSPackages.keySet()) {\n             ServletHolder servletHolder = jaxRSPackages.get(mountPoint);\n             log.info(\"Mounting JAXRS package at [%s]\", mountPoint);\n             Context jerseyContext = new Context(jetty, mountPoint);\n             jerseyContext.addServlet(servletHolder, \"/*\");\n        }\n    }","commit_id":"5e8a6d9e355642611f350336bd92033f0f862209","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void loadStaticContent() {\n        for (String mountPoint : staticContent.keySet()) {\n            String contentLocation = staticContent.get(mountPoint);\n            try {\n                final WebAppContext webadmin = new WebAppContext();\n                webadmin.setServer(jetty);\n                webadmin.setContextPath(mountPoint);\n                URL url = getClass().getClassLoader().getResource(contentLocation).toURI().toURL();\n                final Resource resource = Resource.newResource(url);\n                webadmin.setBaseResource(resource);\n                jetty.addHandler(webadmin);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }","id":97588,"modified_method":"private void loadStaticContent() {\n        for (String mountPoint : staticContent.keySet()) {\n            String contentLocation = staticContent.get(mountPoint);\n            log.info(\"Mounting static content at [%s] from [%s]\", mountPoint, contentLocation);\n            try {\n                final WebAppContext webadmin = new WebAppContext();\n                webadmin.setServer(jetty);\n                webadmin.setContextPath(mountPoint);\n                URL resourceLoc = getClass().getClassLoader().getResource(contentLocation);\n                log.info(\"Found [%s]\", resourceLoc);\n                URL url = resourceLoc.toURI().toURL();\n                final Resource resource = Resource.newResource(url);\n                webadmin.setBaseResource(resource);\n                log.info(\"Mounting static content from [%s] at [%s]\", url, mountPoint);\n                jetty.addHandler(webadmin);\n            } catch (Exception e) {\n                log.error( e );\n                e.printStackTrace();\n                throw new RuntimeException(e);\n            }\n        }\n    }","commit_id":"5e8a6d9e355642611f350336bd92033f0f862209","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Integer start(String[] args) {\n        webServerPort = configurator.configuration().getInt(WEBSERVER_PORT, DEFAULT_WEBSERVER_PORT);\n        try {\n            webServer.setPort(webServerPort);\n            webServer.addJAXRSPackages(listFrom(new String[] {REST_API_PACKAGE}), REST_API_PATH);\n            \n            // webadmin assumes root\n            webServer.addStaticContent(\"html\", \"/webadmin\");\n            webServer.addJAXRSPackages(listFrom(new String[] {WEB_ADMIN_REST_API_PACKAGE}), \"/\");\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", webServerPort);\n            \n            return 0;\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            return 1;\n        }\n    }","id":97589,"modified_method":"public Integer start(String[] args) {\n        webServerPort = configurator.configuration().getInt(WEBSERVER_PORT, DEFAULT_WEBSERVER_PORT);\n        try {\n            webServer.setPort(webServerPort);\n            // webadmin assumes root\n            log.info(\"Mounting static html at [%s]\", WEBADMIN_PATH);\n            webServer.addStaticContent(\"html\", WEBADMIN_PATH);\n            \n            log.info(\"Mounting REST at [%s]\", REST_API_PATH);\n            webServer.addJAXRSPackages(listFrom(new String[] {REST_API_PACKAGE}), REST_API_PATH);\n\n            log.info(\"Mounting manage API at [%s]\", MANAGE_PATH);\n            webServer.addJAXRSPackages(listFrom(new String[] {WEB_ADMIN_REST_API_PACKAGE}), MANAGE_PATH);\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", webServerPort);\n            \n            return null; //yes, that's right!\n        } catch (Exception e) {\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            return 1;\n        }\n    }","commit_id":"5e8a6d9e355642611f350336bd92033f0f862209","url":"https://github.com/neo4j/neo4j"},{"original_method":"private WebServer webServer() {\n        WebServer webServer = new Jetty6WebServer();\n        webServer.addJAXRSPackages(listFrom(new String[] {NeoServer.REST_API_PACKAGE}), NeoServer.REST_API_PATH);\n        return webServer;\n    }","id":97590,"modified_method":"private WebServer webServer() {\n        WebServer webServer = new Jetty6WebServer();\n        //webServer.addStaticContent(\"html\", NeoServer.WEBADMIN_PATH);\n        //webServer.addJAXRSPackages(listFrom(new String[] {NeoServer.REST_API_PACKAGE}), NeoServer.REST_API_PATH);\n        //webServer.addJAXRSPackages(listFrom(new String[] {NeoServer.WEB_ADMIN_REST_API_PACKAGE}), NeoServer.MANAGE_PATH);\n        return webServer;\n    }","commit_id":"5e8a6d9e355642611f350336bd92033f0f862209","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        InMemoryAppender appender = new InMemoryAppender(NeoServer.log);\n        NeoServer server = server();\n        server.start(null);\n\n        assertThat(appender.toString(), containsString(\"Started Neo Server on port [\" + 7474 + \"]\"));\n\n        server.stop();\n    }","id":97591,"modified_method":"@Test\n    public void shouldLogStartup() throws Exception {\n        InMemoryAppender appender = new InMemoryAppender(NeoServer.log);\n        InMemoryAppender jettyServerAppender = new InMemoryAppender(Jetty6WebServer.log);\n        NeoServer server = server();\n        server.start(null);\n        System.out.println(appender.toString());\n        System.out.println(jettyServerAppender.toString());\n        assertThat(appender.toString(), containsString(\"Started Neo Server on port [\" + 7474 + \"]\"));\n\n        server.stop();\n    }","commit_id":"5e8a6d9e355642611f350336bd92033f0f862209","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * This method is called when the application has finished\n     * launching. Here is where log4j is configured for rapid\n     * turn around and the validation template system is configured.\n     */\n    public void finishInitialization() {\n    \tERXJDBCAdaptor.registerJDBCAdaptor();\n        // AK: we now setup the properties three times. At startup, in ERX.init\n\t\t// and here. Note that this sucks beyond belief, as this will produce\n\t\t// unforeseen results in several cases, but it's the only way to set up\n\t\t// all parts of the property handling. The first install only loads plain\n\t\t// and user props the second has no good way to set up the main bundle and this one\n\t\t// comes too late for static inits\n    \tERXConfigurationManager.defaultManager().loadConfiguration();\n    \t\n        ERXProperties.populateSystemProperties();\n        \n        ERXConfigurationManager.defaultManager().configureRapidTurnAround();\n        ERXLocalizer.initialize();\n        ERXValidationFactory.defaultFactory().configureFactory();\n        // update configuration with system properties that might depend\n        // on others like \n        // log4j.appender.SQL.File=@@loggingBasePath@@/@@port@@.sql\n        // loggingBasePath=/var/log/@@name@@\n        // name and port are resolved via WOApplication.application()\n        // ERXLogger.configureLoggingWithSystemProperties();\n        \n        _log = Logger.getLogger(ERXExtensions.class);\n\t\tERXProperties.pathsForUserAndBundleProperties(true);\n\n        registerSQLSupportForSelector(new NSSelector(ERXPrimaryKeyListQualifier.IsContainedInArraySelectorName), \n                EOQualifierSQLGeneration.Support.supportForClass(ERXPrimaryKeyListQualifier.class));\n        registerSQLSupportForSelector(new NSSelector(ERXToManyQualifier.MatchesAllInArraySelectorName), \n                EOQualifierSQLGeneration.Support.supportForClass(ERXToManyQualifier.class));\n        registerSQLSupportForSelector(new NSSelector(ERXRegExQualifier.MatchesSelectorName), \n                EOQualifierSQLGeneration.Support.supportForClass(ERXRegExQualifier.class));\n        registerSQLSupportForSelector(new NSSelector(ERXFullTextQualifier.FullTextContainsSelectorName), \n                EOQualifierSQLGeneration.Support.supportForClass(ERXFullTextQualifier.class));\n\n\t\tEOQualifierSQLGeneration.Support.setSupportForClass(new ERXFullTextQualifierSupport(), ERXFullTextQualifier.class);\n\t\tEOQualifierSQLGeneration.Support.setSupportForClass(new ERXFalseQualifierSupport(), ERXFalseQualifier.class);\n\n\t\t// ERXObjectStoreCoordinatorPool has a static initializer, so just load the class if\n\t\t// the configuration setting exists\n        if (ERXRemoteSynchronizer.remoteSynchronizerEnabled() || ERXProperties.booleanForKey(\"er.extensions.ERXDatabaseContext.activate\")) {\n        \tString className = ERXProperties.stringForKeyWithDefault(\"er.extensions.ERXDatabaseContext.className\", ERXDatabaseContext.class.getName());\n        \tClass c = ERXPatcher.classForName(className);\n        \tif(c == null) {\n        \t\tthrow new IllegalStateException(\"er.extensions.ERXDatabaseContext.className not found: \" + className);\n        \t}\n        \tEODatabaseContext.setContextClassToRegister(c);\n        }\n\t\tERXObjectStoreCoordinatorPool.initializeIfNecessary();\n    }","id":97592,"modified_method":"/**\n     * This method is called when the application has finished\n     * launching. Here is where log4j is configured for rapid\n     * turn around and the validation template system is configured.\n     */\n    public void finishInitialization() {\n    \tERXJDBCAdaptor.registerJDBCAdaptor();\n        // AK: we now setup the properties three times. At startup, in ERX.init\n\t\t// and here. Note that this sucks beyond belief, as this will produce\n\t\t// unforeseen results in several cases, but it's the only way to set up\n\t\t// all parts of the property handling. The first install only loads plain\n\t\t// and user props the second has no good way to set up the main bundle and this one\n\t\t// comes too late for static inits\n    \tERXConfigurationManager.defaultManager().loadConfiguration();\n    \t\n        ERXProperties.populateSystemProperties();\n        \n        ERXConfigurationManager.defaultManager().configureRapidTurnAround();\n        ERXLocalizer.initialize();\n        ERXValidationFactory.defaultFactory().configureFactory();\n        // update configuration with system properties that might depend\n        // on others like \n        // log4j.appender.SQL.File=@@loggingBasePath@@/@@port@@.sql\n        // loggingBasePath=/var/log/@@name@@\n        // name and port are resolved via WOApplication.application()\n        // ERXLogger.configureLoggingWithSystemProperties();\n        \n        _log = Logger.getLogger(ERXExtensions.class);\n\t\tERXProperties.pathsForUserAndBundleProperties(true);\n\n\t\ttry {\n\t\t\t// MS: initialize these with Class.forName(Whatever.class.getName()) because the .class class literal does not trigger static initializers to run in 1.5,\n\t\t\t// which means that the sql generation support classes are not registered\n\t\t\tregisterSQLSupportForSelector(new NSSelector(ERXPrimaryKeyListQualifier.IsContainedInArraySelectorName), EOQualifierSQLGeneration.Support.supportForClass(Class.forName(ERXPrimaryKeyListQualifier.class.getName())));\n\t\t\tregisterSQLSupportForSelector(new NSSelector(ERXToManyQualifier.MatchesAllInArraySelectorName), EOQualifierSQLGeneration.Support.supportForClass(Class.forName(ERXToManyQualifier.class.getName())));\n\t        registerSQLSupportForSelector(new NSSelector(ERXRegExQualifier.MatchesSelectorName), EOQualifierSQLGeneration.Support.supportForClass(Class.forName(ERXRegExQualifier.class.getName())));\n\t        registerSQLSupportForSelector(new NSSelector(ERXFullTextQualifier.FullTextContainsSelectorName), EOQualifierSQLGeneration.Support.supportForClass(Class.forName(ERXFullTextQualifier.class.getName())));\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(t);\n\t\t}\n\n\t\tEOQualifierSQLGeneration.Support.setSupportForClass(new ERXFullTextQualifierSupport(), ERXFullTextQualifier.class);\n\t\tEOQualifierSQLGeneration.Support.setSupportForClass(new ERXFalseQualifierSupport(), ERXFalseQualifier.class);\n\n\t\t// ERXObjectStoreCoordinatorPool has a static initializer, so just load the class if\n\t\t// the configuration setting exists\n        if (ERXRemoteSynchronizer.remoteSynchronizerEnabled() || ERXProperties.booleanForKey(\"er.extensions.ERXDatabaseContext.activate\")) {\n        \tString className = ERXProperties.stringForKeyWithDefault(\"er.extensions.ERXDatabaseContext.className\", ERXDatabaseContext.class.getName());\n        \tClass c = ERXPatcher.classForName(className);\n        \tif(c == null) {\n        \t\tthrow new IllegalStateException(\"er.extensions.ERXDatabaseContext.className not found: \" + className);\n        \t}\n        \tEODatabaseContext.setContextClassToRegister(c);\n        }\n\t\tERXObjectStoreCoordinatorPool.initializeIfNecessary();\n    }","commit_id":"a6c56789fc63175cb1282ef96edb854f332863ae","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Test that ChannelDefinition identifies CPortletAdaptor as a portlet but\n     * does not identify CGenericXSLT as a portlet.\n     */\n    public void testIsPortlet() {\n        ChannelDefinition cd = new ChannelDefinition(72);\n        \n        cd.setJavaClass(\"org.jasig.portal.channels.CGenericXSLT\");\n        assertFalse(cd.isPortlet());\n        \n        cd.setJavaClass(\"org.jasig.portal.channels.portlet.CPortletAdaptor\");\n        assertTrue(cd.isPortlet());\n        \n    }","id":97593,"modified_method":"/**\n     * Test that ChannelDefinition identifies CPortletAdaptor as a portlet but\n     * does not identify CGenericXSLT as a portlet.\n     */\n    public void testIsPortlet() {\n        ChannelDefinition cd = new ChannelDefinition(72);\n        \n        cd.setJavaClass(\"org.jasig.portal.channels.CGenericXSLT\");\n        assertFalse(cd.isPortlet());\n        \n        cd.setJavaClass(\"org.jasig.portal.channels.portlet.CSpringPortletAdaptor\");\n        assertTrue(cd.isPortlet());\n        \n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public void flushBuffer() {\n        this.writer.flush();\n        \n        this.committed = true;\n    }","id":97594,"modified_method":"@Override\n    public void flushBuffer() {\n        if (this.writer != null) {\n            this.writer.flush();\n        }\n        \n        this.committed = true;\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void testGeneratePortletUrl() throws Exception {\n        final PortletUrlSyntaxProviderImpl portletUrlSyntaxProvider = new PortletUrlSyntaxProviderImpl();\n        \n        final MockHttpServletRequest request = new MockHttpServletRequest();\n        \n        final IPortletWindowId portletWindowId = new PortletWindowIdImpl(\"windowId1\");\n        final IPortletWindow portletWindow = new PortletWindowImpl(portletWindowId, \"portletApp\", \"portletName\");\n        \n        final PortletUrl portletUrl = new PortletUrl();\n        \n        try {\n            portletUrlSyntaxProvider.generatePortletUrl(null, portletWindow, portletUrl);\n            fail(\"generatePortletUrl should have thrown an IllegalArgumentException with a null request\");\n        }\n        catch (IllegalArgumentException iae) {\n        }\n        \n        try {\n            portletUrlSyntaxProvider.generatePortletUrl(request, null, portletUrl);\n            fail(\"generatePortletUrl should have thrown an IllegalArgumentException with a null portletWindow\");\n        }\n        catch (IllegalArgumentException iae) {\n        }\n        \n        try {\n            portletUrlSyntaxProvider.generatePortletUrl(request, portletWindow, null);\n            fail(\"generatePortletUrl should have thrown an IllegalArgumentException with a null portletUrl\");\n        }\n        catch (IllegalArgumentException iae) {\n        }\n        \n        try {\n            portletUrlSyntaxProvider.generatePortletUrl(request, portletWindow, portletUrl);\n            fail(\"generatePortletUrl should have thrown IllegalStateException with no ChannelRuntimeData in the request\");\n        }\n        catch (IllegalStateException ise) {\n        }\n        \n        final ChannelRuntimeData channelRuntimeData = new ChannelRuntimeData();\n        channelRuntimeData.setBaseActionURL(\"http://base/action/url\");\n        \n        request.setAttribute(IPortletAdaptor.ATTRIBUTE_RUNTIME_DATA, channelRuntimeData);\n        \n        String urlString = portletUrlSyntaxProvider.generatePortletUrl(request, portletWindow, portletUrl);\n        assertEquals(\"http://base/action/url?plt_type_windowId1=RENDER\", urlString);\n        \n        \n        final Map<String, String[]> parameters = new TreeMap<String, String[]>(); //Use a treemap so the output string is deterministic\n        parameters.put(\"key1\", new String[] { \"value1.1\", \"value1.2\" } );\n        parameters.put(\"key2\", new String[] { \"value2.1\" } );\n        parameters.put(\"key3\", new String[] { \"\" } );\n        \n        portletUrl.setPortletMode(PortletMode.EDIT);\n        portletUrl.setWindowState(WindowState.MINIMIZED);\n        portletUrl.setParameters(parameters);\n        \n        urlString = portletUrlSyntaxProvider.generatePortletUrl(request, portletWindow, portletUrl);\n        assertEquals(\"http://base/action/url?plt_type_windowId1=RENDER&plt_state_windowId1=minimized&plt_mode_windowId1=edit&plt_windowId1_key1=value1.1&plt_windowId1_key1=value1.2&plt_windowId1_key2=value2.1&plt_windowId1_key3=\", urlString);\n\n\n        portletUrl.setRequestType(RequestType.ACTION);\n        \n        urlString = portletUrlSyntaxProvider.generatePortletUrl(request, portletWindow, portletUrl);\n        assertEquals(\"http://base/action/url?plt_type_windowId1=ACTION&plt_state_windowId1=minimized&plt_mode_windowId1=edit&plt_windowId1_key1=value1.1&plt_windowId1_key1=value1.2&plt_windowId1_key2=value2.1&plt_windowId1_key3=\", urlString);\n        \n        portletUrl.setWindowState(new WindowState(\"EXCLUSIVE\"));\n        portletUrl.setRequestType(RequestType.RENDER);\n        \n        urlString = portletUrlSyntaxProvider.generatePortletUrl(request, portletWindow, portletUrl);\n        assertEquals(\"worker/download/worker.download.uP?plt_type_windowId1=RENDER&plt_state_windowId1=exclusive&plt_mode_windowId1=edit&plt_windowId1_key1=value1.1&plt_windowId1_key1=value1.2&plt_windowId1_key2=value2.1&plt_windowId1_key3=\", urlString);\n    }","id":97595,"modified_method":"public void testGeneratePortletUrl() throws Exception {\n        final PortletUrlSyntaxProviderImpl portletUrlSyntaxProvider = new PortletUrlSyntaxProviderImpl();\n        \n        final MockHttpServletRequest request = new MockHttpServletRequest();\n        \n        final IPortletEntityId portletEntityId = new PortletEntityIdImpl(\"entityId1\");\n        final IPortletWindowId portletWindowId = new PortletWindowIdImpl(\"windowId1\");\n        final IPortletWindow portletWindow = new PortletWindowImpl(portletWindowId, portletEntityId, \"portletApp\", \"portletName\");\n        \n        final PortletUrl portletUrl = new PortletUrl();\n        \n        try {\n            portletUrlSyntaxProvider.generatePortletUrl(null, portletWindow, portletUrl);\n            fail(\"generatePortletUrl should have thrown an IllegalArgumentException with a null request\");\n        }\n        catch (IllegalArgumentException iae) {\n        }\n        \n        try {\n            portletUrlSyntaxProvider.generatePortletUrl(request, null, portletUrl);\n            fail(\"generatePortletUrl should have thrown an IllegalArgumentException with a null portletWindow\");\n        }\n        catch (IllegalArgumentException iae) {\n        }\n        \n        try {\n            portletUrlSyntaxProvider.generatePortletUrl(request, portletWindow, null);\n            fail(\"generatePortletUrl should have thrown an IllegalArgumentException with a null portletUrl\");\n        }\n        catch (IllegalArgumentException iae) {\n        }\n        \n        try {\n            portletUrlSyntaxProvider.generatePortletUrl(request, portletWindow, portletUrl);\n            fail(\"generatePortletUrl should have thrown IllegalStateException with no ChannelRuntimeData in the request\");\n        }\n        catch (IllegalStateException ise) {\n        }\n        \n        final ChannelRuntimeData channelRuntimeData = new ChannelRuntimeData();\n        channelRuntimeData.setBaseActionURL(\"http://base/action/url\");\n        \n        request.setAttribute(IPortletAdaptor.ATTRIBUTE_RUNTIME_DATA, channelRuntimeData);\n        \n        String urlString = portletUrlSyntaxProvider.generatePortletUrl(request, portletWindow, portletUrl);\n        assertEquals(\"http://base/action/url?plt_type_windowId1=RENDER\", urlString);\n        \n        \n        final Map<String, String[]> parameters = new TreeMap<String, String[]>(); //Use a treemap so the output string is deterministic\n        parameters.put(\"key1\", new String[] { \"value1.1\", \"value1.2\" } );\n        parameters.put(\"key2\", new String[] { \"value2.1\" } );\n        parameters.put(\"key3\", new String[] { \"\" } );\n        \n        portletUrl.setPortletMode(PortletMode.EDIT);\n        portletUrl.setWindowState(WindowState.MINIMIZED);\n        portletUrl.setParameters(parameters);\n        \n        urlString = portletUrlSyntaxProvider.generatePortletUrl(request, portletWindow, portletUrl);\n        assertEquals(\"http://base/action/url?plt_type_windowId1=RENDER&plt_state_windowId1=minimized&plt_mode_windowId1=edit&plt_windowId1_key1=value1.1&plt_windowId1_key1=value1.2&plt_windowId1_key2=value2.1&plt_windowId1_key3=\", urlString);\n\n\n        portletUrl.setRequestType(RequestType.ACTION);\n        \n        urlString = portletUrlSyntaxProvider.generatePortletUrl(request, portletWindow, portletUrl);\n        assertEquals(\"http://base/action/url?plt_type_windowId1=ACTION&plt_state_windowId1=minimized&plt_mode_windowId1=edit&plt_windowId1_key1=value1.1&plt_windowId1_key1=value1.2&plt_windowId1_key2=value2.1&plt_windowId1_key3=\", urlString);\n        \n        portletUrl.setWindowState(new WindowState(\"EXCLUSIVE\"));\n        portletUrl.setRequestType(RequestType.RENDER);\n        \n        urlString = portletUrlSyntaxProvider.generatePortletUrl(request, portletWindow, portletUrl);\n        assertEquals(\"worker/download/worker.download.uP?plt_type_windowId1=RENDER&plt_state_windowId1=exclusive&plt_mode_windowId1=edit&plt_windowId1_key1=value1.1&plt_windowId1_key1=value1.2&plt_windowId1_key2=value2.1&plt_windowId1_key3=\", urlString);\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Creates a new PortletWindow cloned from the passed IPortletWindow\n     * \n     * @param portletWindowID The unique idenifier for this PortletWindow\n     * @param portletWindow The PortletWindow to clone settings from\n     * @throws IllegalArgumentException if portletWindowID, or portletWindow are null\n     */\n    public PortletWindowImpl(IPortletWindowId portletWindowID, IPortletWindow portletWindow) {\n        Validate.notNull(portletWindowID, \"portletWindowID can not be null\");\n        Validate.notNull(portletWindow, \"portletWindow can not be null\");\n        \n        this.portletWindowID = portletWindowID;\n        this.contextPath = portletWindow.getContextPath();\n        this.portletName = portletWindow.getPortletName();\n        this.portletMode = portletWindow.getPortletMode();\n        this.windowState = portletWindow.getWindowState();\n        \n        Validate.notNull(this.contextPath, \"portletWindow.contextPath can not be null\");\n        Validate.notNull(this.portletName, \"portletWindow.portletName can not be null\");\n        Validate.notNull(this.portletMode, \"portletWindow.portletMode can not be null\");\n        Validate.notNull(this.windowState, \"portletWindow.windowState can not be null\");\n    }","id":97596,"modified_method":"/**\n     * Creates a new PortletWindow cloned from the passed IPortletWindow\n     * \n     * @param portletWindowId The unique idenifier for this PortletWindow\n     * @param portletWindow The PortletWindow to clone settings from\n     * @throws IllegalArgumentException if portletWindowId, or portletWindow are null\n     */\n    public PortletWindowImpl(IPortletWindowId portletWindowId, IPortletWindow portletWindow) {\n        Validate.notNull(portletWindowId, \"portletWindowId can not be null\");\n        Validate.notNull(portletWindow, \"portletWindow can not be null\");\n        \n        this.portletWindowId = portletWindowId;\n        this.portletEntityId = portletWindow.getPortletEntityId();\n        this.contextPath = portletWindow.getContextPath();\n        this.portletName = portletWindow.getPortletName();\n        this.portletMode = portletWindow.getPortletMode();\n        this.windowState = portletWindow.getWindowState();\n        \n        Validate.notNull(this.portletEntityId, \"portletWindow.parentPortletEntityId can not be null\");\n        Validate.notNull(this.contextPath, \"portletWindow.contextPath can not be null\");\n        Validate.notNull(this.portletName, \"portletWindow.portletName can not be null\");\n        Validate.notNull(this.portletMode, \"portletWindow.portletMode can not be null\");\n        Validate.notNull(this.windowState, \"portletWindow.windowState can not be null\");\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Creates a new PortletWindow with the default settings\n     * \n     * @param portletWindowID The unique idenifier for this PortletWindow\n     * @param contextPath The path of the {@link javax.servlet.ServletContext} the portlet resides in\n     * @param portletName The name of the portlet this window represents\n     * @throws IllegalArgumentException if portletWindowID, contextPath, or portletName are null\n     */\n    public PortletWindowImpl(IPortletWindowId portletWindowID, String contextPath, String portletName) {\n        Validate.notNull(portletWindowID, \"portletWindowID can not be null\");\n        Validate.notNull(contextPath, \"contextPath can not be null\");\n        Validate.notNull(portletName, \"portletName can not be null\");\n        \n        this.portletWindowID = portletWindowID;\n        this.contextPath = contextPath;\n        this.portletName = portletName;\n    }","id":97597,"modified_method":"/**\n     * Creates a new PortletWindow with the default settings\n     * \n     * @param portletWindowId The unique identifier for this PortletWindow\n     * @param portletEntityId The unique identifier of the parent IPortletEntity\n     * @param contextPath The path of the {@link javax.servlet.ServletContext} the portlet resides in\n     * @param portletName The name of the portlet this window represents\n     * @throws IllegalArgumentException if portletWindowId, contextPath, or portletName are null\n     */\n    public PortletWindowImpl(IPortletWindowId portletWindowId, IPortletEntityId portletEntityId, String contextPath, String portletName) {\n        Validate.notNull(portletWindowId, \"portletWindowId can not be null\");\n        Validate.notNull(portletEntityId, \"portletEntityId can not be null\");\n        Validate.notNull(contextPath, \"contextPath can not be null\");\n        Validate.notNull(portletName, \"portletName can not be null\");\n        \n        this.portletWindowId = portletWindowId;\n        this.portletEntityId = portletEntityId;\n        this.contextPath = contextPath;\n        this.portletName = portletName;\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n        //Read & validate non-transient fields\n        ois.defaultReadObject();\n        \n        if (this.portletWindowID == null) {\n            throw new InvalidObjectException(\"portletWindowID can not be null\");\n        }\n        if (this.contextPath == null) {\n            throw new InvalidObjectException(\"contextPath can not be null\");\n        }\n        if (this.portletName == null) {\n            throw new InvalidObjectException(\"portletName can not be null\");\n        }\n        if (this.requestParameters == null) {\n            throw new InvalidObjectException(\"requestParameters can not be null\");\n        }\n        \n        //Read & validate transient fields\n        final String portletModeStr = (String)ois.readObject();\n        if (portletModeStr == null) {\n            throw new InvalidObjectException(\"portletMode can not be null\");\n        }\n        this.portletMode = new PortletMode(portletModeStr);\n        \n        final String windowStateStr = (String)ois.readObject();\n        if (windowStateStr == null) {\n            throw new InvalidObjectException(\"windowState can not be null\");\n        }\n        this.windowState = new WindowState(windowStateStr);\n    }","id":97598,"modified_method":"private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n        //Read & validate non-transient fields\n        ois.defaultReadObject();\n        \n        if (this.portletWindowId == null) {\n            throw new InvalidObjectException(\"portletWindowId can not be null\");\n        }\n        if (this.contextPath == null) {\n            throw new InvalidObjectException(\"contextPath can not be null\");\n        }\n        if (this.portletName == null) {\n            throw new InvalidObjectException(\"portletName can not be null\");\n        }\n        if (this.requestParameters == null) {\n            throw new InvalidObjectException(\"requestParameters can not be null\");\n        }\n        \n        //Read & validate transient fields\n        final String portletModeStr = (String)ois.readObject();\n        if (portletModeStr == null) {\n            throw new InvalidObjectException(\"portletMode can not be null\");\n        }\n        this.portletMode = new PortletMode(portletModeStr);\n        \n        final String windowStateStr = (String)ois.readObject();\n        if (windowStateStr == null) {\n            throw new InvalidObjectException(\"windowState can not be null\");\n        }\n        this.windowState = new WindowState(windowStateStr);\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        return new HashCodeBuilder(1445247369, -1009176817)\n            .append(this.portletWindowID)\n            .append(this.contextPath)\n            .append(this.portletName)\n            .append(this.windowState)\n            .append(this.portletMode)\n            .append(this.expirationCache)\n            .append(this.requestParameters)\n            .toHashCode();\n    }","id":97599,"modified_method":"/**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        return new HashCodeBuilder(1445247369, -1009176817)\n            .append(this.portletWindowId)\n            .append(this.contextPath)\n            .append(this.portletName)\n            .append(this.windowState)\n            .append(this.portletMode)\n            .append(this.expirationCache)\n            .append(this.requestParameters)\n            .toHashCode();\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"public IPortletWindowId getPortletWindowId() {\n        return this.portletWindowID;\n    }","id":97600,"modified_method":"public IPortletWindowId getPortletWindowId() {\n        return this.portletWindowId;\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE)\n            .append(\"portletWindowID\", this.portletWindowID)\n            .append(\"contextPath\", this.contextPath)\n            .append(\"portletName\", this.portletName)\n            .append(\"windowState\", this.windowState)\n            .append(\"portletMode\", this.portletMode)\n            .append(\"expirationCache\", this.expirationCache)\n            .append(\"requestParameters\", this.requestParameters)\n            .toString();\n    }","id":97601,"modified_method":"/**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE)\n            .append(\"portletWindowId\", this.portletWindowId)\n            .append(\"contextPath\", this.contextPath)\n            .append(\"portletName\", this.portletName)\n            .append(\"windowState\", this.windowState)\n            .append(\"portletMode\", this.portletMode)\n            .append(\"expirationCache\", this.expirationCache)\n            .append(\"requestParameters\", this.requestParameters)\n            .toString();\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * @see java.lang.Object#equals(Object)\n     */\n    @Override\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof IPortletWindow)) {\n            return false;\n        }\n        IPortletWindow rhs = (IPortletWindow) object;\n        return new EqualsBuilder()\n            .append(this.portletWindowID, rhs.getId())\n            .append(this.contextPath, rhs.getContextPath())\n            .append(this.portletName, rhs.getPortletName())\n            .append(this.windowState, rhs.getWindowState())\n            .append(this.portletMode, rhs.getPortletMode())\n            .append(this.expirationCache, rhs.getExpirationCache())\n            .append(this.requestParameters, rhs.getRequestParameers())\n            .isEquals();\n    }","id":97602,"modified_method":"/**\n     * @see java.lang.Object#equals(Object)\n     */\n    @Override\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof IPortletWindow)) {\n            return false;\n        }\n        IPortletWindow rhs = (IPortletWindow) object;\n        return new EqualsBuilder()\n            .append(this.portletWindowId, rhs.getId())\n            .append(this.contextPath, rhs.getContextPath())\n            .append(this.portletName, rhs.getPortletName())\n            .append(this.windowState, rhs.getWindowState())\n            .append(this.portletMode, rhs.getPortletMode())\n            .append(this.expirationCache, rhs.getExpirationCache())\n            .append(this.requestParameters, rhs.getRequestParameers())\n            .isEquals();\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"public PortletWindowID getId() {\n        return this.portletWindowID;\n    }","id":97603,"modified_method":"public PortletWindowID getId() {\n        return this.portletWindowId;\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"public IPortletWindow convertPortletWindow(HttpServletRequest request, PortletWindow plutoPortletWindow) {\n        Validate.notNull(request, \"request can not be null\");\n        Validate.notNull(plutoPortletWindow, \"portletWindow can not be null\");\n        \n        if (plutoPortletWindow instanceof IPortletWindow) {\n            return (IPortletWindow)plutoPortletWindow;\n        }\n        \n        final PortletWindowID plutoPortletWindowId = plutoPortletWindow.getId();\n        final IPortletWindowId portletWindowId;\n        if (plutoPortletWindowId instanceof IPortletWindowId) {\n            portletWindowId = (IPortletWindowId)plutoPortletWindowId;\n        }\n        else {\n            portletWindowId = this.getPortletWindowId(plutoPortletWindowId.getStringId());\n        }\n        \n        final IPortletWindow portletWindow = this.getPortletWindow(request, portletWindowId);\n        \n        if (portletWindow == null) {\n            //TODO come up with a better exception\n            throw new RuntimeException(\"Could not cast Pluto PortletWindow to uPortal IPortletWindow and no IPortletWindow exists with the specified ID\");\n        }\n        \n        return portletWindow;\n    }","id":97604,"modified_method":"public IPortletWindow convertPortletWindow(HttpServletRequest request, PortletWindow plutoPortletWindow) {\n        Validate.notNull(request, \"request can not be null\");\n        Validate.notNull(plutoPortletWindow, \"portletWindow can not be null\");\n        \n        //Try a direct cast to IPortletWindow\n        if (plutoPortletWindow instanceof IPortletWindow) {\n            return (IPortletWindow)plutoPortletWindow;\n        }\n        \n        //Try converting the Pluto ID to a uPortal ID\n        final PortletWindowID plutoPortletWindowId = plutoPortletWindow.getId();\n        final IPortletWindowId portletWindowId;\n        if (plutoPortletWindowId instanceof IPortletWindowId) {\n            portletWindowId = (IPortletWindowId)plutoPortletWindowId;\n        }\n        else {\n            portletWindowId = this.getPortletWindowId(plutoPortletWindowId.getStringId());\n        }\n        \n        //Use the converted ID to see if a IPortletWindow exists for it\n        final IPortletWindow portletWindow = this.getPortletWindow(request, portletWindowId);\n        \n        //If null no window exists, throw an exception since somehow Pluto has a PortletWindow object that this container doesn't know about\n        if (portletWindow == null) {\n            throw new IllegalArgumentException(\"Could not cast Pluto PortletWindow to uPortal IPortletWindow and no IPortletWindow exists with the id: \" + plutoPortletWindow.getId());\n        }\n        \n        return portletWindow;\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"public IPortletWindowId getPortletWindowId(String portletWindowId) {\n        return new PortletWindowIdImpl(portletWindowId);\n    }","id":97605,"modified_method":"public IPortletWindowId getPortletWindowId(String portletWindowId) {\n        Validate.notNull(portletWindowId, \"portletWindowId can not be null\");\n        \n        return new PortletWindowIdImpl(portletWindowId);\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Get the Map of IPortletWindows for the request.\n     * \n     * @param request the current request\n     * @return The Map of IPortletWindows managed by this class for the request, null if that Map does not yet exist.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected Map<IPortletWindowId, IPortletWindow> getPortletWindowMap(HttpServletRequest request) {\n        final HttpSession session = this.getSession(request);\n        \n        return (Map<IPortletWindowId, IPortletWindow>)session.getAttribute(PORTLET_WINDOW_MAP_ATTRIBUTE);\n    }","id":97606,"modified_method":"/**\n     * Get the Map of IPortletWindows for the request.\n     * \n     * @param request the current request\n     * @return The Map of IPortletWindows managed by this class for the request, null if that Map does not yet exist.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected Map<IPortletWindowId, IPortletWindow> getPortletWindowMap(HttpServletRequest request) {\n        final HttpSession session = this.getSession(request);\n        \n        final Map<IPortletWindowId, IPortletWindow> portletWindows;\n        //Sync on the session to ensure the Map isn't in the process of being created\n        synchronized (session) {\n            portletWindows = (Map<IPortletWindowId, IPortletWindow>)session.getAttribute(PORTLET_WINDOW_MAP_ATTRIBUTE);\n        }\n        return portletWindows;\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void action(ChannelStaticData channelStaticData, PortalControlStructures portalControlStructures, ChannelRuntimeData channelRuntimeData) {\n        //Get the portlet window\n        final HttpServletRequest httpServletRequest = portalControlStructures.getHttpServletRequest();\n        final IPortletWindowId portletWindowId = this.getPortletWindowId(channelStaticData);\n        final IPortletWindow portletWindow = this.portletWindowRegistry.getPortletWindow(httpServletRequest, portletWindowId);\n        \n        //Execute the action, \n         final HttpServletResponse httpServletResponse = portalControlStructures.getHttpServletResponse();\n        try {\n            if (this.logger.isDebugEnabled()) {\n                this.logger.debug(\"Executing portlet action for window '\" + portletWindow + \"' with underlying channel: \" + channelStaticData);\n            }\n            \n            //TODO does the request need to be wrapped here?\n            this.portletContainer.doAction(portletWindow, httpServletRequest, httpServletResponse);\n        }\n        catch (PortletException pe) {\n            throw new PortletLoadFailureException(\"The portlet window '\" + portletWindow + \"' threw an exception while executing action. Underlying channel: \" + channelStaticData, portletWindow, pe);\n        }\n        catch (PortletContainerException pce) {\n            throw new PortletLoadFailureException(\"The portlet container threw an exception while executing action on portlet window '\" + portletWindow + \"'. Underlying channel: \" + channelStaticData, portletWindow, pce);\n        }\n        catch (IOException ioe) {\n            throw new PortletLoadFailureException(\"The portlet window '\" + portletWindow + \"' threw an exception while executing action. Underlying channel: \" + channelStaticData, portletWindow, ioe);\n        }\n    }","id":97607,"modified_method":"public void action(ChannelStaticData channelStaticData, PortalControlStructures portalControlStructures, ChannelRuntimeData channelRuntimeData) {\n        //Get the portlet window\n        final HttpServletRequest httpServletRequest = portalControlStructures.getHttpServletRequest();\n        final IPortletWindowId portletWindowId = this.getPortletWindowId(channelStaticData);\n        if (portletWindowId == null) {\n            throw new IllegalStateException(\"No IPortletWindowId exists in the ChannelStaticData, has initSession been called? ChannelStaticData: \" + channelStaticData);\n        }\n        \n        final IPortletWindow portletWindow = this.portletWindowRegistry.getPortletWindow(httpServletRequest, portletWindowId);\n        \n        //Execute the action, \n         final HttpServletResponse httpServletResponse = portalControlStructures.getHttpServletResponse();\n        try {\n            if (this.logger.isDebugEnabled()) {\n                this.logger.debug(\"Executing portlet action for window '\" + portletWindow + \"' with underlying channel: \" + channelStaticData);\n            }\n            \n            //TODO does the request need to be wrapped here?\n            this.portletContainer.doAction(portletWindow, httpServletRequest, httpServletResponse);\n        }\n        catch (PortletException pe) {\n            throw new PortletLoadFailureException(\"The portlet window '\" + portletWindow + \"' threw an exception while executing action. Underlying channel: \" + channelStaticData, portletWindow, pe);\n        }\n        catch (PortletContainerException pce) {\n            throw new PortletLoadFailureException(\"The portlet container threw an exception while executing action on portlet window '\" + portletWindow + \"'. Underlying channel: \" + channelStaticData, portletWindow, pce);\n        }\n        catch (IOException ioe) {\n            throw new PortletLoadFailureException(\"The portlet window '\" + portletWindow + \"' threw an exception while executing action. Underlying channel: \" + channelStaticData, portletWindow, ioe);\n        }\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"public boolean isCacheValid(ChannelStaticData channelStaticData, PortalControlStructures portalControlStructures, ChannelRuntimeData channelRuntimeData, Object validity) {\n        //Get the portlet window\n        final HttpServletRequest httpServletRequest = portalControlStructures.getHttpServletRequest();\n        final IPortletWindowId portletWindowId = this.getPortletWindowId(channelStaticData);\n        final IPortletWindow portletWindow = this.portletWindowRegistry.getPortletWindow(httpServletRequest, portletWindowId);\n        \n        //If this window is targetd invalidate the cache\n        final Set<IPortletWindowId> targetedPortletWindowIds = this.portletRequestParameterManager.getTargetedPortletWindowIds(httpServletRequest);\n        if (targetedPortletWindowIds.contains(portletWindowId)) {\n            return false;\n        }\n        \n        //Get the portlet deployment\n        //TODO need a cleaner chain from window->entity->definition->deployment(descriptor)\n        final PortletRegistryService portletRegistryService = this.optionalContainerServices.getPortletRegistryService();\n        final String contextPath = portletWindow.getContextPath();\n        final String portletName = portletWindow.getPortletName();\n        final PortletDD portletDescriptor;\n        try {\n            portletDescriptor = portletRegistryService.getPortletDescriptor(contextPath, portletName);\n        }\n        catch (PortletContainerException pce) {\n            this.logger.warn(\"Could not retrieve PortletDD for portlet window '\" + portletWindow + \"' to determine caching configuration. Marking content cache invalid and continuing.\", pce);\n            return false;\n        }\n        \n        final int descriptorExpirationCache = portletDescriptor.getExpirationCache();\n        final Integer windowExpirationCache = portletWindow.getExpirationCache();\n        \n        //Determine which value to use, if the descriptor value is unset return immediately\n        final int expirationCache;\n        if (descriptorExpirationCache == PortletDD.EXPIRATION_CACHE_UNSET) {\n            return false;\n        }\n        else if (windowExpirationCache != null) {\n            expirationCache = windowExpirationCache;\n        }\n        else {\n            expirationCache = descriptorExpirationCache;\n        }\n        \n        //set to 0 (never cache)\n        if (expirationCache == 0) {\n            return false;\n        }\n        //set to -1 (never expire)\n        else if (expirationCache == -1) {\n            return true;\n        }\n        //If no validity object re-render to be safe\n        else if (validity == null) {\n            return false;\n        }\n        \n        final long lastRenderTime = ((Long)validity).longValue();\n        final long now = System.currentTimeMillis();\n        \n        //If the expiration time since last render has not passed return true\n        return lastRenderTime + (expirationCache * 1000) <= now;\n    }","id":97608,"modified_method":"public boolean isCacheValid(ChannelStaticData channelStaticData, PortalControlStructures portalControlStructures, ChannelRuntimeData channelRuntimeData, Object validity) {\n        //Get the portlet window\n        final HttpServletRequest httpServletRequest = portalControlStructures.getHttpServletRequest();\n        final IPortletWindowId portletWindowId = this.getPortletWindowId(channelStaticData);\n        final IPortletWindow portletWindow = this.portletWindowRegistry.getPortletWindow(httpServletRequest, portletWindowId);\n        \n        //If this window is targetd invalidate the cache\n        final Set<IPortletWindowId> targetedPortletWindowIds = this.portletRequestParameterManager.getTargetedPortletWindowIds(httpServletRequest);\n        if (targetedPortletWindowIds.contains(portletWindowId)) {\n            return false;\n        }\n        \n        //Get the root definition\n        final IPortletEntity portletEntity = this.portletWindowRegistry.getParentPortletEntity(httpServletRequest, portletWindowId);\n        final IPortletDefinition portletDefinition = this.portletEntityRegistry.getParentPortletDefinition(portletEntity.getPortletEntityId());\n        \n        //Get the portlet deployment\n        final String portletApplicationId = portletDefinition.getPortletApplicationId();\n        final String portletName = portletDefinition.getPortletName();\n        final PortletDD portletDescriptor;\n        try {\n            final PortletRegistryService portletRegistryService = this.optionalContainerServices.getPortletRegistryService();\n            portletDescriptor = portletRegistryService.getPortletDescriptor(portletApplicationId, portletName);\n        }\n        catch (PortletContainerException pce) {\n            this.logger.warn(\"Could not retrieve PortletDD for portlet window '\" + portletWindow + \"' to determine caching configuration. Marking content cache invalid and continuing.\", pce);\n            return false;\n        }\n        \n        //If the descriptor value is unset return immediately\n        final int descriptorExpirationCache = portletDescriptor.getExpirationCache();\n        if (descriptorExpirationCache == PortletDD.EXPIRATION_CACHE_UNSET) {\n            return false;\n        }\n        \n        //Use value from window if it is set\n        final Integer windowExpirationCache = portletWindow.getExpirationCache();\n        final int expirationCache;\n        if (windowExpirationCache != null) {\n            expirationCache = windowExpirationCache;\n        }\n        else {\n            expirationCache = descriptorExpirationCache;\n        }\n        \n        //set to 0 (never cache)\n        if (expirationCache == 0) {\n            return false;\n        }\n        //set to -1 (never expire)\n        else if (expirationCache == -1) {\n            return true;\n        }\n        //If no validity object re-render to be safe\n        else if (validity == null) {\n            return false;\n        }\n        \n        final long lastRenderTime = ((Long)validity).longValue();\n        final long now = System.currentTimeMillis();\n        \n        //If the expiration time since last render has not passed return true\n        return lastRenderTime + (expirationCache * 1000) >= now;\n    }","commit_id":"6682dcc2bfe95190d2eb4c2491ce48a7a10f021d","url":"https://github.com/Jasig/uPortal"},{"original_method":"void setOutputOwner(Object testId) {\n        assert testId != null;\n        System.out.flush();\n        System.err.flush();\n        outForwarder.outputOwner = testId;\n        errForwarder.outputOwner = testId;\n    }","id":97609,"modified_method":"void setOutputOwner(Object testId) {\n        assert testId != null;\n        if (System.out != null) {\n            System.out.flush();\n        }\n        if (System.err != null) {\n            System.err.flush();\n        }\n        outForwarder.outputOwner = testId;\n        errForwarder.outputOwner = testId;\n    }","commit_id":"af6389bb618edd8da34e43496122de816e04173e","url":"https://github.com/gradle/gradle"},{"original_method":"@Nullable\n  public Point getLocation() {\n    return DimensionService.getInstance().getLocation(getDimensionKey(), myContext.getProject());\n  }","id":97610,"modified_method":"@Nullable\n  public Point getLocation() {\n    String key = getDimensionKey();\n    if (key == null)\n      return null;\n    return DimensionService.getInstance().getLocation(key, myContext.getProject());\n  }","commit_id":"c2812af4b8e86a0af5eb41ef05ea455b582c2c40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Dimension getSize() {\n    return DimensionService.getInstance().getSize(getDimensionKey(), myContext.getProject());\n  }","id":97611,"modified_method":"@Nullable\n  public Dimension getSize() {\n    String key = getDimensionKey();\n    if (key == null)\n      return null;\n    return DimensionService.getInstance().getSize(key, myContext.getProject());\n  }","commit_id":"c2812af4b8e86a0af5eb41ef05ea455b582c2c40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void saveUiState() {\n    saveProportions();\n\n    for (Content each : myContents.getKeys()) {\n      saveState(each, false);\n    }\n\n    for (Content each : myMinimizedContents) {\n      saveState(each, true);\n    }\n\n    final DimensionService service = DimensionService.getInstance();\n    final Dimension size = myContext.getContentManager().getComponent().getSize();\n    service.setSize(getDimensionKey(), size, myContext.getProject());\n    if (myContext.getWindow() != 0) {\n      final Window frame = SwingUtilities.getWindowAncestor(myPlaceholder);\n      if (frame != null) {\n        service.setLocation(getDimensionKey(), frame.getLocationOnScreen());\n      }\n    }\n  }","id":97612,"modified_method":"public void saveUiState() {\n    String key = getDimensionKey();\n    if (key == null)\n      return;\n\n    saveProportions();\n\n    for (Content each : myContents.getKeys()) {\n      saveState(each, false);\n    }\n\n    for (Content each : myMinimizedContents) {\n      saveState(each, true);\n    }\n\n    final DimensionService service = DimensionService.getInstance();\n    final Dimension size = myContext.getContentManager().getComponent().getSize();\n    service.setSize(key, size, myContext.getProject());\n    if (myContext.getWindow() != 0) {\n      final Window frame = SwingUtilities.getWindowAncestor(myPlaceholder);\n      if (frame != null) {\n        service.setLocation(key, frame.getLocationOnScreen());\n      }\n    }\n  }","commit_id":"c2812af4b8e86a0af5eb41ef05ea455b582c2c40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String getDimensionKey() {\n    return \"GridCell.Tab.\" + myContainer.getTab().getIndex() + \".\" + myPlaceInGrid.name();\n  }","id":97613,"modified_method":"@Nullable\n  private String getDimensionKey() {\n    Tab tab = myContainer.getTab();\n    if (tab == null)\n      return null;\n    return \"GridCell.Tab.\" + tab.getIndex() + \".\" + myPlaceInGrid.name();\n  }","commit_id":"c2812af4b8e86a0af5eb41ef05ea455b582c2c40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void _importLDAP(\n\t\t\tString companyId, LdapContext ctx, Properties userMappings,\n\t\t\tProperties groupMappings, SearchResult result)\n\t\tthrows Exception {\n\n\t\tString userDN = result.getName();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"User DN \" + userDN);\n\t\t}\n\n\t\tAttributes attrs = result.getAttributes();\n\n\t\tString creatorUserId = null;\n\t\tboolean autoUserId = false;\n\t\tString userId = LDAPUtil.getAttributeValue(\n\t\t\tattrs, userMappings.getProperty(\"userId\"));\n\t\tboolean autoPassword = true;\n\t\tString password1 = StringPool.BLANK;\n\t\tString password2 = StringPool.BLANK;\n\t\tboolean passwordReset = false;\n\t\tString emailAddress = LDAPUtil.getAttributeValue(\n\t\t\tattrs, userMappings.getProperty(\"emailAddress\"));\n\t\tLocale locale = Locale.US;\n\t\tString firstName = LDAPUtil.getAttributeValue(\n\t\t\tattrs, userMappings.getProperty(\"firstName\"));\n\t\tString middleName = LDAPUtil.getAttributeValue(\n\t\t\tattrs, userMappings.getProperty(\"middleName\"));\n\t\tString lastName = LDAPUtil.getAttributeValue(\n\t\t\tattrs, userMappings.getProperty(\"lastName\"));\n\n\t\tif (Validator.isNull(firstName) || Validator.isNull(lastName)) {\n\t\t\tString fullName = LDAPUtil.getAttributeValue(\n\t\t\t\tattrs, userMappings.getProperty(\"fullName\"));\n\n\t\t\tString[] names = LDAPUtil.splitFullName(fullName);\n\n\t\t\tfirstName = names[0];\n\t\t\tmiddleName = names[1];\n\t\t\tlastName = names[2];\n\t\t}\n\n\t\tString nickName = null;\n\t\tString prefixId = null;\n\t\tString suffixId = null;\n\t\tboolean male = true;\n\t\tint birthdayMonth = Calendar.JANUARY;\n\t\tint birthdayDay = 1;\n\t\tint birthdayYear = 1970;\n\t\tString jobTitle = LDAPUtil.getAttributeValue(\n\t\t\tattrs, userMappings.getProperty(\"jobTitle\"));\n\t\tString organizationId = null;\n\t\tString locationId = null;\n\t\tboolean sendEmail = false;\n\n\t\tUser user = addOrUpdateUser(\n\t\t\tcreatorUserId, companyId, autoUserId, userId, autoPassword,\n\t\t\tpassword1, password2, passwordReset, emailAddress, locale,\n\t\t\tfirstName, middleName, lastName, nickName, prefixId, suffixId, male,\n\t\t\tbirthdayMonth, birthdayDay, birthdayYear, jobTitle, organizationId,\n\t\t\tlocationId, sendEmail, true, false);\n\n\t\t// Import and add user to group\n\n\t\tif (user != null) {\n\t\t\tAttribute attr = attrs.get(userMappings.getProperty(\"group\"));\n\n\t\t\tfor (int i = 0; i < attr.size(); i++) {\n\t\t\t\tString groupDN = (String)attr.get(i);\n\n\t\t\t\tAttributes groupAttrs = ctx.getAttributes(groupDN);\n\n\t\t\t\tString groupName = LDAPUtil.getAttributeValue(\n\t\t\t\t\tgroupAttrs, groupMappings.getProperty(\"groupName\"));\n\t\t\t\tString description = LDAPUtil.getAttributeValue(\n\t\t\t\t\tgroupAttrs, groupMappings.getProperty(\"description\"));\n\n\t\t\t\tUserGroup userGroup = null;\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Adding \" + userId + \" to group \" + groupName);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tuserGroup = UserGroupLocalServiceUtil.getUserGroup(\n\t\t\t\t\t\tcompanyId, groupName);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchUserGroupException nsuge) {\n\t\t\t\t\tuserGroup = UserGroupLocalServiceUtil.addUserGroup(\n\t\t\t\t\t\tUser.getDefaultUserId(companyId), companyId, groupName,\n\t\t\t\t\t\tdescription);\n\t\t\t\t}\n\n\t\t\t\tUserLocalServiceUtil.addUserGroupUsers(\n\t\t\t\t\tuserGroup.getUserGroupId(), new String[] {userId});\n\t\t\t}\n\t\t}\n\t}","id":97614,"modified_method":"private static void _importLDAP(\n\t\t\tString companyId, LdapContext ctx, Properties userMappings,\n\t\t\tProperties groupMappings, SearchResult result)\n\t\tthrows Exception {\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_BASE_DN);\n\n\t\tString userDN = result.getName() + StringPool.COMMA + baseDN;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"User DN \" + userDN);\n\t\t}\n\n\t\tAttributes attrs = result.getAttributes();\n\n\t\tString creatorUserId = null;\n\t\tboolean autoUserId = false;\n\t\tString userId = LDAPUtil.getAttributeValue(\n\t\t\tattrs, userMappings.getProperty(\"userId\"));\n\t\tboolean autoPassword = true;\n\t\tString password1 = StringPool.BLANK;\n\t\tString password2 = StringPool.BLANK;\n\t\tboolean passwordReset = false;\n\t\tString emailAddress = LDAPUtil.getAttributeValue(\n\t\t\tattrs, userMappings.getProperty(\"emailAddress\"));\n\t\tLocale locale = Locale.US;\n\t\tString firstName = LDAPUtil.getAttributeValue(\n\t\t\tattrs, userMappings.getProperty(\"firstName\"));\n\t\tString middleName = LDAPUtil.getAttributeValue(\n\t\t\tattrs, userMappings.getProperty(\"middleName\"));\n\t\tString lastName = LDAPUtil.getAttributeValue(\n\t\t\tattrs, userMappings.getProperty(\"lastName\"));\n\n\t\tif (Validator.isNull(firstName) || Validator.isNull(lastName)) {\n\t\t\tString fullName = LDAPUtil.getAttributeValue(\n\t\t\t\tattrs, userMappings.getProperty(\"fullName\"));\n\n\t\t\tString[] names = LDAPUtil.splitFullName(fullName);\n\n\t\t\tfirstName = names[0];\n\t\t\tmiddleName = names[1];\n\t\t\tlastName = names[2];\n\t\t}\n\n\t\tString nickName = null;\n\t\tString prefixId = null;\n\t\tString suffixId = null;\n\t\tboolean male = true;\n\t\tint birthdayMonth = Calendar.JANUARY;\n\t\tint birthdayDay = 1;\n\t\tint birthdayYear = 1970;\n\t\tString jobTitle = LDAPUtil.getAttributeValue(\n\t\t\tattrs, userMappings.getProperty(\"jobTitle\"));\n\t\tString organizationId = null;\n\t\tString locationId = null;\n\t\tboolean sendEmail = false;\n\n\t\tUser user = addOrUpdateUser(\n\t\t\tcreatorUserId, companyId, autoUserId, userId, autoPassword,\n\t\t\tpassword1, password2, passwordReset, emailAddress, locale,\n\t\t\tfirstName, middleName, lastName, nickName, prefixId, suffixId, male,\n\t\t\tbirthdayMonth, birthdayDay, birthdayYear, jobTitle, organizationId,\n\t\t\tlocationId, sendEmail, true, false);\n\n\t\t// Import and add user to group\n\t\tif (user != null) {\n\t\t\tAttribute attr = attrs.get(userMappings.getProperty(\"group\"));\n\n\t\t\tif (attr != null){\n\t\t\t\tfor (int i = 0; i < attr.size(); i++) {\n\t\t\t\t\tString groupDN = (String)attr.get(i);\n\n\t\t\t\t\tAttributes groupAttrs = ctx.getAttributes(groupDN);\n\n\t\t\t\t\tString groupName = LDAPUtil.getAttributeValue(\n\t\t\t\t\t\tgroupAttrs, groupMappings.getProperty(\"groupName\"));\n\t\t\t\t\tString description = LDAPUtil.getAttributeValue(\n\t\t\t\t\t\tgroupAttrs, groupMappings.getProperty(\"description\"));\n\n\t\t\t\t\tUserGroup userGroup = null;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tuserGroup = UserGroupLocalServiceUtil.getUserGroup(\n\t\t\t\t\t\t\tcompanyId, groupName);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchUserGroupException nsuge) {\n\t\t\t\t\t\tuserGroup = UserGroupLocalServiceUtil.addUserGroup(\n\t\t\t\t\t\t\tUser.getDefaultUserId(companyId), companyId, \n\t\t\t\t\t\t\tgroupName, description);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (userGroup != null) {\n\t\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\t\"Adding \" + userId + \" to group \" + groupName);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tUserLocalServiceUtil.addUserGroupUsers(\n\t\t\t\t\t\t\tuserGroup.getUserGroupId(), new String[] {userId});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"7c58b2a259aa53425d0a1a1d5c7da82712a6dcc9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void importLDAP(String companyId) throws Exception {\n\t\tProperties env = new Properties();\n\n\t\tenv.put(\n\t\t\tContext.INITIAL_CONTEXT_FACTORY,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_FACTORY_INITIAL));\n\t\tenv.put(\n\t\t\tContext.PROVIDER_URL,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_BASE_PROVIDER_URL));\n\t\tenv.put(\n\t\t\tContext.SECURITY_PRINCIPAL,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_SECURITY_PRINCIPAL));\n\t\tenv.put(\n\t\t\tContext.SECURITY_CREDENTIALS,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_SECURITY_CREDENTIALS));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\tenv.list(new PrintWriter(sw));\n\n\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t}\n\n\t\tLdapContext ctx = null;\n\n\t\ttry {\n\t\t\tctx = new InitialLdapContext(env, null);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Failed to bind to the LDAP server\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tProperties userMappings = PropertiesUtil.load(\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_USER_MAPPINGS));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\tuserMappings.list(new PrintWriter(sw));\n\n\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t}\n\n\t\tProperties groupMappings = PropertiesUtil.load(\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_GROUP_MAPPINGS));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\tgroupMappings.list(new PrintWriter(sw));\n\n\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t}\n\n\t\ttry {\n\t\t\tString filter = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_SEARCH_FILTER);\n\n\t\t\tString context = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_BASE_DN);\n\n\t\t\tSearchControls cons = new SearchControls(\n\t\t\t\tSearchControls.SUBTREE_SCOPE, 0, 0, null, false, false);\n\n\t\t\tNamingEnumeration enu = ctx.search(context, filter, cons);\n\n\t\t\twhile (enu.hasMore()) {\n\t\t\t\tSearchResult result = (SearchResult)enu.next();\n\n\t\t\t\t_importLDAP(\n\t\t\t\t\tcompanyId, ctx, userMappings, groupMappings, result);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Error importing LDAP users and groups\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif (ctx != null) {\n\t\t\t\tctx.close();\n\t\t\t}\n\t\t}\n\t}","id":97615,"modified_method":"public static void importLDAP(String companyId) throws Exception {\n\t\tProperties env = new Properties();\n\n\t\tenv.put(\n\t\t\tContext.INITIAL_CONTEXT_FACTORY,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_FACTORY_INITIAL));\n\t\tenv.put(\n\t\t\tContext.PROVIDER_URL,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_BASE_PROVIDER_URL));\n\t\tenv.put(\n\t\t\tContext.SECURITY_PRINCIPAL,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_SECURITY_PRINCIPAL));\n\t\tenv.put(\n\t\t\tContext.SECURITY_CREDENTIALS,\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_SECURITY_CREDENTIALS));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\tenv.list(new PrintWriter(sw));\n\n\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t}\n\n\t\tLdapContext ctx = null;\n\n\t\ttry {\n\t\t\tctx = new InitialLdapContext(env, null);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"Failed to bind to the LDAP server\");\n\t\t\t}\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(e);\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\n\t\tProperties userMappings = PropertiesUtil.load(\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_USER_MAPPINGS));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\tuserMappings.list(new PrintWriter(sw));\n\n\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t}\n\n\t\tProperties groupMappings = PropertiesUtil.load(\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_GROUP_MAPPINGS));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringWriter sw = new StringWriter();\n\n\t\t\tgroupMappings.list(new PrintWriter(sw));\n\n\t\t\t_log.debug(sw.getBuffer().toString());\n\t\t}\n\n\t\ttry {\n\t\t\tString filter = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_SEARCH_FILTER);\n\n\t\t\tString context = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsUtil.LDAP_IMPORT_BASE_DN);\n\n\t\t\tSearchControls cons = new SearchControls(\n\t\t\t\tSearchControls.SUBTREE_SCOPE, 0, 0, null, false, false);\n\n\t\t\tNamingEnumeration enu = ctx.search(context, filter, cons);\n\n\t\t\twhile (enu.hasMore()) {\n\t\t\t\tSearchResult result = (SearchResult)enu.next();\n\n\t\t\t\t_importLDAP(\n\t\t\t\t\tcompanyId, ctx, userMappings, groupMappings, result);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Error importing LDAP users and groups\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif (ctx != null) {\n\t\t\t\tctx.close();\n\t\t\t}\n\t\t}\n\t}","commit_id":"7c58b2a259aa53425d0a1a1d5c7da82712a6dcc9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static void _importLDAPGroup(\n\t\tString companyId, LdapContext ctx, Properties groupMappings,\n\t\tString userId, Attribute attr) throws Exception {\n\n\t\tfor (int i = 0; i < attr.size(); i++) {\n\t\t\tString groupDN = (String)attr.get(i);\n\n\t\t\tAttributes groupAttrs = ctx.getAttributes(groupDN);\n\n\t\t\tString groupName = LDAPUtil.getAttributeValue(\n\t\t\t\tgroupAttrs, groupMappings.getProperty(\"groupName\"));\n\t\t\tString description = LDAPUtil.getAttributeValue(\n\t\t\t\tgroupAttrs, groupMappings.getProperty(\"description\"));\n\n\t\t\tUserGroup userGroup = null;\n\n\t\t\ttry {\n\t\t\t\tuserGroup = UserGroupLocalServiceUtil.getUserGroup(\n\t\t\t\t\tcompanyId, groupName);\n\t\t\t}\n\t\t\tcatch (NoSuchUserGroupException nsuge) {\n\t\t\t\tuserGroup = UserGroupLocalServiceUtil.addUserGroup(\n\t\t\t\t\tUser.getDefaultUserId(companyId), companyId, groupName,\n\t\t\t\t\tdescription);\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Adding \" + userId + \" to group \" + groupName);\n\t\t\t}\n\n\t\t\tUserLocalServiceUtil.addUserGroupUsers(\n\t\t\t\tuserGroup.getUserGroupId(), new String[] {userId});\n\t\t}\n\t}","id":97616,"modified_method":"private static void _importLDAPGroup(\n\t\tString companyId, LdapContext ctx, Properties groupMappings,\n\t\tString userId, Attribute attr) throws Exception {\n\n\t\tfor (int i = 0; i < attr.size(); i++) {\n\t\t\tString groupDN = (String)attr.get(i);\n\n\t\t\tAttributes groupAttrs = ctx.getAttributes(groupDN);\n\n\t\t\tString groupName = LDAPUtil.getAttributeValue(\n\t\t\t\tgroupAttrs, groupMappings.getProperty(\"groupName\"));\n\t\t\tString description = LDAPUtil.getAttributeValue(\n\t\t\t\tgroupAttrs, groupMappings.getProperty(\"description\"));\n\n\t\t\tUserGroup userGroup = null;\n\n\t\t\ttry {\n\t\t\t\tuserGroup = UserGroupLocalServiceUtil.getUserGroup(\n\t\t\t\t\tcompanyId, groupName);\n\t\t\t}\n\t\t\tcatch (NoSuchUserGroupException nsuge) {\n\t\t\t\ttry {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Adding user group\" + groupName + \" at \" + groupDN);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tuserGroup = UserGroupLocalServiceUtil.addUserGroup(\n\t\t\t\t\t\tUser.getDefaultUserId(companyId), companyId, groupName,\n\t\t\t\t\t\tdescription);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(\"Could not create user group \" + groupName);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (userGroup != null) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Adding \" + userId + \" to group \" + groupName);\n\t\t\t\t}\n\n\t\t\t\tUserLocalServiceUtil.addUserGroupUsers(\n\t\t\t\t\tuserGroup.getUserGroupId(), new String[] {userId});\n\t\t\t}\n\t\t}\n\t}","commit_id":"81b3952934bd8b9ab07894971f69210aa5547e21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static void _importLDAPGroup(\n\t\tString companyId, LdapContext ctx, Properties groupMappings,\n\t\tString userId, Attribute attr) throws Exception {\n\n\t\tfor (int i = 0; i < attr.size(); i++) {\n\t\t\tString groupDN = (String)attr.get(i);\n\n\t\t\tAttributes groupAttrs = ctx.getAttributes(groupDN);\n\n\t\t\tString groupName = LDAPUtil.getAttributeValue(\n\t\t\t\tgroupAttrs, groupMappings.getProperty(\"groupName\"));\n\t\t\tString description = LDAPUtil.getAttributeValue(\n\t\t\t\tgroupAttrs, groupMappings.getProperty(\"description\"));\n\n\t\t\tUserGroup userGroup = null;\n\n\t\t\ttry {\n\t\t\t\tuserGroup = UserGroupLocalServiceUtil.getUserGroup(\n\t\t\t\t\tcompanyId, groupName);\n\t\t\t}\n\t\t\tcatch (NoSuchUserGroupException nsuge) {\n\t\t\t\tuserGroup = UserGroupLocalServiceUtil.addUserGroup(\n\t\t\t\t\tUser.getDefaultUserId(companyId), companyId, groupName,\n\t\t\t\t\tdescription);\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Adding \" + userId + \" to group \" + groupName);\n\t\t\t}\n\n\t\t\tUserLocalServiceUtil.addUserGroupUsers(\n\t\t\t\tuserGroup.getUserGroupId(), new String[] {userId});\n\t\t}\n\t}","id":97617,"modified_method":"private static void _importLDAPGroup(\n\t\tString companyId, LdapContext ctx, Properties groupMappings,\n\t\tString userId, Attribute attr) throws Exception {\n\n\t\tfor (int i = 0; i < attr.size(); i++) {\n\t\t\tString groupDN = (String)attr.get(i);\n\n\t\t\tAttributes groupAttrs = ctx.getAttributes(groupDN);\n\n\t\t\tString groupName = LDAPUtil.getAttributeValue(\n\t\t\t\tgroupAttrs, groupMappings.getProperty(\"groupName\"));\n\t\t\tString description = LDAPUtil.getAttributeValue(\n\t\t\t\tgroupAttrs, groupMappings.getProperty(\"description\"));\n\n\t\t\tUserGroup userGroup = null;\n\n\t\t\ttry {\n\t\t\t\tuserGroup = UserGroupLocalServiceUtil.getUserGroup(\n\t\t\t\t\tcompanyId, groupName);\n\t\t\t}\n\t\t\tcatch (NoSuchUserGroupException nsuge) {\n\t\t\t\tuserGroup = UserGroupLocalServiceUtil.addUserGroup(\n\t\t\t\t\tUser.getDefaultUserId(companyId), companyId, groupName,\n\t\t\t\t\tdescription);\n\t\t\t}\n\n\t\t\tif (userGroup != null) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Adding \" + userId + \" to group \" + groupName);\n\t\t\t\t}\n\n\t\t\t\tUserLocalServiceUtil.addUserGroupUsers(\n\t\t\t\t\tuserGroup.getUserGroupId(), new String[] {userId});\n\t\t\t}\n\t\t}\n\t}","commit_id":"dd335ea577c2bbfcbbaa6989d521b0e0c0d36054","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static User addOrUpdateUser(\n\t\t\tString creatorUserId, String companyId, boolean autoUserId,\n\t\t\tString userId, boolean autoPassword, String password1,\n\t\t\tString password2, boolean passwordReset, String emailAddress,\n\t\t\tLocale locale, String firstName, String middleName, String lastName,\n\t\t\tString nickName, String prefixId, String suffixId, boolean male,\n\t\t\tint birthdayMonth, int birthdayDay, int birthdayYear,\n\t\t\tString jobTitle, String organizationId, String locationId,\n\t\t\tboolean sendEmail, boolean checkExists, boolean updatePassword)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"User Id \" + userId + \" and email address \" + emailAddress);\n\t\t}\n\n\t\tif (userId == null || emailAddress == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Cannot add user because user id and email address are \" +\n\t\t\t\t\t\t\"required\");\n\t\t\t}\n\n\t\t\treturn user;\n\t\t}\n\n\t\tboolean create = true;\n\n\t\tif (checkExists) {\n\t\t\ttry {\n\t\t\t\tuser = UserLocalServiceUtil.getUserByEmailAddress(\n\t\t\t\t\tcompanyId, emailAddress);\n\n\t\t\t\tif (updatePassword) {\n\t\t\t\t\tUserLocalServiceUtil.updatePassword(\n\t\t\t\t\t\tuser.getUserId(), password1, password2, passwordReset);\n\t\t\t\t}\n\n\t\t\t\tcreate = false;\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\n\t\t\t\t// User does not exist so create\n\n\t\t\t}\n\t\t}\n\n\t\tif (create) {\n\t\t\ttry {\n\t\t\t\tuser = UserLocalServiceUtil.addUser(\n\t\t\t\t\tcreatorUserId, companyId, autoUserId, userId, autoPassword,\n\t\t\t\t\tpassword1, password2, passwordReset, emailAddress, locale,\n\t\t\t\t\tfirstName, middleName, lastName, nickName, prefixId,\n\t\t\t\t\tsuffixId, male, birthdayMonth, birthdayDay, birthdayYear,\n\t\t\t\t\tjobTitle, organizationId, locationId, sendEmail);\n\t\t\t}\n\t\t\tcatch (Exception e){\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"Problem adding user \" + userId);\n\t\t\t\t}\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(StackTraceUtil.getStackTrace(e));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn user;\n\t}","id":97618,"modified_method":"public static User addOrUpdateUser(\n\t\t\tString creatorUserId, String companyId, boolean autoUserId,\n\t\t\tString userId, boolean autoPassword, String password1,\n\t\t\tString password2, boolean passwordReset, String emailAddress,\n\t\t\tLocale locale, String firstName, String middleName, String lastName,\n\t\t\tString nickName, String prefixId, String suffixId, boolean male,\n\t\t\tint birthdayMonth, int birthdayDay, int birthdayYear,\n\t\t\tString jobTitle, String organizationId, String locationId,\n\t\t\tboolean sendEmail, boolean checkExists, boolean updatePassword)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"User Id \" + userId + \" and email address \" + emailAddress);\n\t\t}\n\n\t\tif (Validator.isNull(userId) || Validator.isNull(emailAddress)) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Cannot add user because user id and email address are \" +\n\t\t\t\t\t\t\"required\");\n\t\t\t}\n\n\t\t\treturn user;\n\t\t}\n\n\t\tboolean create = true;\n\n\t\tif (checkExists) {\n\t\t\ttry {\n\t\t\t\tuser = UserLocalServiceUtil.getUserByEmailAddress(\n\t\t\t\t\tcompanyId, emailAddress);\n\n\t\t\t\tif (updatePassword) {\n\t\t\t\t\tUserLocalServiceUtil.updatePassword(\n\t\t\t\t\t\tuser.getUserId(), password1, password2, passwordReset);\n\t\t\t\t}\n\n\t\t\t\tcreate = false;\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\n\t\t\t\t// User does not exist so create\n\n\t\t\t}\n\t\t}\n\n\t\tif (create) {\n\t\t\ttry {\n\t\t\t\tuser = UserLocalServiceUtil.addUser(\n\t\t\t\t\tcreatorUserId, companyId, autoUserId, userId, autoPassword,\n\t\t\t\t\tpassword1, password2, passwordReset, emailAddress, locale,\n\t\t\t\t\tfirstName, middleName, lastName, nickName, prefixId,\n\t\t\t\t\tsuffixId, male, birthdayMonth, birthdayDay, birthdayYear,\n\t\t\t\t\tjobTitle, organizationId, locationId, sendEmail);\n\t\t\t}\n\t\t\tcatch (Exception e){\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"Problem adding user \" + userId);\n\t\t\t\t}\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(StackTraceUtil.getStackTrace(e));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn user;\n\t}","commit_id":"dd335ea577c2bbfcbbaa6989d521b0e0c0d36054","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void generateMethodDescription(@NonNls StringBuilder buffer, final PsiMethod method, final PsiDocComment comment) {\n    final DocTagLocator<PsiElement[]> descriptionLocator = new DocTagLocator<PsiElement[]>() {\n      @Override\n      public PsiElement[] find(PsiDocComment comment) {\n        if (comment == null) {\n          return null;\n        }\n\n        if (isEmptyDescription(comment)) {\n          return null;\n        }\n\n        return comment.getDescriptionElements();\n      }\n    };\n\n    if (comment != null) {\n      if (!isEmptyDescription(comment)) {\n        generateValue\n          (buffer, comment.getDescriptionElements(),\n           new InheritDocProvider<PsiElement[]>() {\n             @Override\n             public Pair<PsiElement[], InheritDocProvider<PsiElement[]>> getInheritDoc() {\n               return findInheritDocTag(method, descriptionLocator);\n             }\n\n             @Override\n             public PsiClass getElement() {\n               return method.getContainingClass();\n             }\n           });\n        return;\n      }\n    }\n\n    Pair<PsiElement[], InheritDocProvider<PsiElement[]>> pair = findInheritDocTag(method, descriptionLocator);\n\n    if (pair != null) {\n      PsiElement[] elements = pair.first;\n      PsiClass extendee = pair.second.getElement();\n\n      if (elements != null) {\n        buffer.append(\"<DD><DL>\");\n        buffer.append(\"<DT><b>\");\n        buffer.append(extendee.isInterface() ?\n                      CodeInsightBundle.message(\"javadoc.description.copied.from.interface\") :\n                      CodeInsightBundle .message(\"javadoc.description.copied.from.class\"));\n        buffer.append(\"<\/b>&nbsp;\");\n        generateLink(buffer, extendee, JavaDocUtil.getShortestClassName(extendee, method));\n        buffer.append(BR_TAG);\n        generateValue(buffer, elements, pair.second);\n        buffer.append(\"<\/DD><\/DL><\/DD>\");\n      }\n    }\n  }","id":97619,"modified_method":"private void generateMethodDescription(@NonNls StringBuilder buffer, final PsiMethod method, final PsiDocComment comment) {\n    final DocTagLocator<PsiElement[]> descriptionLocator = new DocTagLocator<PsiElement[]>() {\n      @Override\n      public PsiElement[] find(PsiDocComment comment) {\n        if (comment == null) {\n          return null;\n        }\n\n        if (isEmptyDescription(comment)) {\n          return null;\n        }\n\n        return comment.getDescriptionElements();\n      }\n    };\n\n    if (comment != null) {\n      if (!isEmptyDescription(comment)) {\n        generateValue\n          (buffer, comment.getDescriptionElements(),\n           new InheritDocProvider<PsiElement[]>() {\n             @Override\n             public Pair<PsiElement[], InheritDocProvider<PsiElement[]>> getInheritDoc() {\n               return findInheritDocTag(method, descriptionLocator);\n             }\n\n             @Override\n             public PsiClass getElement() {\n               return method.getContainingClass();\n             }\n           });\n        return;\n      }\n    }\n\n    Pair<PsiElement[], InheritDocProvider<PsiElement[]>> pair = findInheritDocTag(method, descriptionLocator);\n\n    if (pair != null) {\n      PsiElement[] elements = pair.first;\n      PsiClass extendee = pair.second.getElement();\n\n      if (elements != null) {\n        buffer.append(\"<DD><DL>\");\n        buffer.append(\"<DT><b>\");\n        buffer.append(extendee.isInterface() ?\n                      CodeInsightBundle.message(\"javadoc.description.copied.from.interface\") :\n                      CodeInsightBundle .message(\"javadoc.description.copied.from.class\"));\n        buffer.append(\"<\/b>&nbsp;\");\n        generateLink(buffer, extendee, JavaDocUtil.getShortestClassName(extendee, method), false);\n        buffer.append(BR_TAG);\n        generateValue(buffer, elements, pair.second);\n        buffer.append(\"<\/DD><\/DL><\/DD>\");\n      }\n    }\n  }","commit_id":"6a561c7982bf64247d098926a6e3cbee8a70132f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void generateMethodJavaDoc(@NonNls StringBuilder buffer, PsiMethod method) {\n    generatePrologue(buffer);\n\n    PsiClass parentClass = method.getContainingClass();\n    if (parentClass != null) {\n      String qName = parentClass.getQualifiedName();\n      if (qName != null) {\n        buffer.append(\"<small><b>\");\n        generateLink(buffer, qName, qName, method, false);\n        //buffer.append(qName);\n        buffer.append(\"<\/b><\/small>\");\n        //buffer.append(\"<br>\");\n      }\n    }\n\n    buffer.append(\"<PRE>\");\n    int indent = 0;\n    generateAnnotations(buffer, method);\n    String modifiers = PsiFormatUtil.formatModifiers(method, PsiFormatUtilBase.JAVADOC_MODIFIERS_ONLY);\n    if (modifiers.length() > 0) {\n      buffer.append(modifiers);\n      buffer.append(\"&nbsp;\");\n      indent += modifiers.length() + 1;\n    }\n\n    final String typeParamsString = generateTypeParameters(method);\n    indent += typeParamsString.length();\n    if (typeParamsString.length() > 0) {\n      buffer.append(typeParamsString);\n      buffer.append(\"&nbsp;\");\n      indent++;\n    }\n\n    if (method.getReturnType() != null) {\n      indent += generateType(buffer, method.getReturnType(), method);\n      buffer.append(\"&nbsp;\");\n      indent++;\n    }\n    buffer.append(\"<b>\");\n    String name = method.getName();\n    buffer.append(name);\n    buffer.append(\"<\/b>\");\n    indent += name.length();\n\n    buffer.append(\"(\");\n\n    PsiParameter[] parms = method.getParameterList().getParameters();\n    for (int i = 0; i < parms.length; i++) {\n      PsiParameter parm = parms[i];\n      generateAnnotations(buffer, parm);\n      generateType(buffer, parm.getType(), method);\n      buffer.append(\"&nbsp;\");\n      if (parm.getName() != null) {\n        buffer.append(parm.getName());\n      }\n      if (i < parms.length - 1) {\n        buffer.append(\",\\n \");\n        for (int j = 0; j < indent; j++) {\n          buffer.append(\" \");\n        }\n      }\n    }\n    buffer.append(\")\");\n\n    PsiClassType[] refs = method.getThrowsList().getReferencedTypes();\n    if (refs.length > 0) {\n      buffer.append(\"\\n\");\n      indent -= THROWS_KEYWORD.length() + 1;\n      for (int i = 0; i < indent; i++) {\n        buffer.append(\" \");\n      }\n      indent += THROWS_KEYWORD.length() + 1;\n      buffer.append(THROWS_KEYWORD);\n      buffer.append(\"&nbsp;\");\n      for (int i = 0; i < refs.length; i++) {\n        generateLink(buffer, refs[i].getCanonicalText(), null, method, false);\n        if (i < refs.length - 1) {\n          buffer.append(\",\\n\");\n          for (int j = 0; j < indent; j++) {\n            buffer.append(\" \");\n          }\n        }\n      }\n    }\n\n    buffer.append(\"<\/PRE>\");\n    //buffer.append(\"<br>\");\n\n    PsiDocComment comment = getMethodDocComment(method);\n\n    generateMethodDescription(buffer, method, comment);\n\n    generateSuperMethodsSection(buffer, method, false);\n    generateSuperMethodsSection(buffer, method, true);\n\n    if (comment != null) {\n      generateDeprecatedSection(buffer, comment);\n    }\n\n    generateParametersSection(buffer, method, comment);\n    generateTypeParametersSection(buffer, method);\n    generateReturnsSection(buffer, method, comment);\n    generateThrowsSection(buffer, method, comment);\n\n    if (comment != null) {\n      generateSinceSection(buffer, comment);\n      generateSeeAlsoSection(buffer, comment);\n    }\n\n    generateEpilogue(buffer);\n  }","id":97620,"modified_method":"private void generateMethodJavaDoc(@NonNls StringBuilder buffer, PsiMethod method, boolean generatePrologueAndEpilogue) {\n    if (generatePrologueAndEpilogue)\n      generatePrologue(buffer);\n\n    PsiClass parentClass = method.getContainingClass();\n    if (parentClass != null) {\n      String qName = parentClass.getQualifiedName();\n      if (qName != null) {\n        buffer.append(\"<small><b>\");\n        generateLink(buffer, qName, qName, method, false);\n        //buffer.append(qName);\n        buffer.append(\"<\/b><\/small>\");\n        //buffer.append(\"<br>\");\n      }\n    }\n\n    buffer.append(\"<PRE>\");\n    int indent = 0;\n    generateAnnotations(buffer, method);\n    String modifiers = PsiFormatUtil.formatModifiers(method, PsiFormatUtilBase.JAVADOC_MODIFIERS_ONLY);\n    if (modifiers.length() > 0) {\n      buffer.append(modifiers);\n      buffer.append(\"&nbsp;\");\n      indent += modifiers.length() + 1;\n    }\n\n    final String typeParamsString = generateTypeParameters(method);\n    indent += typeParamsString.length();\n    if (typeParamsString.length() > 0) {\n      buffer.append(typeParamsString);\n      buffer.append(\"&nbsp;\");\n      indent++;\n    }\n\n    if (method.getReturnType() != null) {\n      indent += generateType(buffer, method.getReturnType(), method);\n      buffer.append(\"&nbsp;\");\n      indent++;\n    }\n    buffer.append(\"<b>\");\n    String name = method.getName();\n    buffer.append(name);\n    buffer.append(\"<\/b>\");\n    indent += name.length();\n\n    buffer.append(\"(\");\n\n    PsiParameter[] parms = method.getParameterList().getParameters();\n    for (int i = 0; i < parms.length; i++) {\n      PsiParameter parm = parms[i];\n      generateAnnotations(buffer, parm);\n      generateType(buffer, parm.getType(), method);\n      buffer.append(\"&nbsp;\");\n      if (parm.getName() != null) {\n        buffer.append(parm.getName());\n      }\n      if (i < parms.length - 1) {\n        buffer.append(\",\\n \");\n        for (int j = 0; j < indent; j++) {\n          buffer.append(\" \");\n        }\n      }\n    }\n    buffer.append(\")\");\n\n    PsiClassType[] refs = method.getThrowsList().getReferencedTypes();\n    if (refs.length > 0) {\n      buffer.append(\"\\n\");\n      indent -= THROWS_KEYWORD.length() + 1;\n      for (int i = 0; i < indent; i++) {\n        buffer.append(\" \");\n      }\n      indent += THROWS_KEYWORD.length() + 1;\n      buffer.append(THROWS_KEYWORD);\n      buffer.append(\"&nbsp;\");\n      for (int i = 0; i < refs.length; i++) {\n        generateLink(buffer, refs[i].getCanonicalText(), null, method, false);\n        if (i < refs.length - 1) {\n          buffer.append(\",\\n\");\n          for (int j = 0; j < indent; j++) {\n            buffer.append(\" \");\n          }\n        }\n      }\n    }\n\n    buffer.append(\"<\/PRE>\");\n    //buffer.append(\"<br>\");\n\n    PsiDocComment comment = getMethodDocComment(method);\n\n    generateMethodDescription(buffer, method, comment);\n\n    generateSuperMethodsSection(buffer, method, false);\n    generateSuperMethodsSection(buffer, method, true);\n\n    if (comment != null) {\n      generateDeprecatedSection(buffer, comment);\n    }\n\n    generateParametersSection(buffer, method, comment);\n    generateTypeParametersSection(buffer, method);\n    generateReturnsSection(buffer, method, comment);\n    generateThrowsSection(buffer, method, comment);\n\n    if (comment != null) {\n      generateSinceSection(buffer, comment);\n      generateSeeAlsoSection(buffer, comment);\n    }\n\n    if (generatePrologueAndEpilogue)\n      generateEpilogue(buffer);\n  }","commit_id":"6a561c7982bf64247d098926a6e3cbee8a70132f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void generateClassJavaDoc(@NonNls StringBuilder buffer, PsiClass aClass) {\n    if (aClass instanceof PsiAnonymousClass) return;\n    PsiManager manager = aClass.getManager();\n    generatePrologue(buffer);\n\n    PsiFile file = aClass.getContainingFile();\n    if (file instanceof PsiJavaFile) {\n      String packageName = ((PsiJavaFile)file).getPackageName();\n      if (packageName.length() > 0) {\n        buffer.append(\"<small><b>\");\n        buffer.append(packageName);\n        buffer.append(\"<\/b><\/small>\");\n        //buffer.append(\"<br>\");\n      }\n    }\n\n    buffer.append(\"<PRE>\");\n    generateAnnotations(buffer, aClass);\n    String modifiers = PsiFormatUtil.formatModifiers(aClass, PsiFormatUtilBase.JAVADOC_MODIFIERS_ONLY);\n    if (modifiers.length() > 0) {\n      buffer.append(modifiers);\n      buffer.append(\" \");\n    }\n    buffer.append(aClass.isInterface() ? LangBundle.message(\"java.terms.interface\") : LangBundle.message(\"java.terms.class\"));\n    buffer.append(\" \");\n    String refText = JavaDocUtil.getReferenceText(myProject, aClass);\n    if (refText == null) {\n      buffer.setLength(0);\n      return;\n    }\n    String labelText = JavaDocUtil.getLabelText(myProject, manager, refText, aClass);\n    buffer.append(\"<b>\");\n    buffer.append(labelText);\n    buffer.append(\"<\/b>\");\n\n    buffer.append(generateTypeParameters(aClass));\n\n    buffer.append(\"\\n\");\n\n    PsiClassType[] refs = aClass.getExtendsListTypes();\n\n    String qName = aClass.getQualifiedName();\n\n    if (refs.length > 0 || !aClass.isInterface() && (qName == null || !qName.equals(CommonClassNames.JAVA_LANG_OBJECT))) {\n      buffer.append(\"extends \");\n      if (refs.length == 0) {\n        generateLink(buffer, CommonClassNames.JAVA_LANG_OBJECT, null, aClass, false);\n      }\n      else {\n        for (int i = 0; i < refs.length; i++) {\n          generateType(buffer, refs[i], aClass);\n          if (i < refs.length - 1) {\n            buffer.append(\",&nbsp;\");\n          }\n        }\n      }\n      buffer.append(\"\\n\");\n    }\n\n    refs = aClass.getImplementsListTypes();\n\n    if (refs.length > 0) {\n      buffer.append(\"implements \");\n      for (int i = 0; i < refs.length; i++) {\n        generateType(buffer, refs[i], aClass);\n        if (i < refs.length - 1) {\n          buffer.append(\",&nbsp;\");\n        }\n      }\n      buffer.append(\"\\n\");\n    }\n    if (buffer.charAt(buffer.length() - 1) == '\\n') {\n      buffer.setLength(buffer.length() - 1);\n    }\n    buffer.append(\"<\/PRE>\");\n    //buffer.append(\"<br>\");\n\n    PsiDocComment comment = getDocComment(aClass);\n    if (comment != null) {\n      generateCommonSection(buffer, comment);\n      generateTypeParametersSection(buffer, aClass);\n    }\n    generateEpilogue(buffer);\n  }","id":97621,"modified_method":"private void generateClassJavaDoc(@NonNls StringBuilder buffer, PsiClass aClass, boolean generatePrologueAndEpilogue) {\n    if (aClass instanceof PsiAnonymousClass) return;\n    PsiManager manager = aClass.getManager();\n    if (generatePrologueAndEpilogue)\n      generatePrologue(buffer);\n\n    PsiFile file = aClass.getContainingFile();\n    if (file instanceof PsiJavaFile) {\n      String packageName = ((PsiJavaFile)file).getPackageName();\n      if (packageName.length() > 0) {\n        buffer.append(\"<small><b>\");\n        buffer.append(packageName);\n        buffer.append(\"<\/b><\/small>\");\n        //buffer.append(\"<br>\");\n      }\n    }\n\n    buffer.append(\"<PRE>\");\n    generateAnnotations(buffer, aClass);\n    String modifiers = PsiFormatUtil.formatModifiers(aClass, PsiFormatUtilBase.JAVADOC_MODIFIERS_ONLY);\n    if (modifiers.length() > 0) {\n      buffer.append(modifiers);\n      buffer.append(\" \");\n    }\n    buffer.append(aClass.isInterface() ? LangBundle.message(\"java.terms.interface\") : LangBundle.message(\"java.terms.class\"));\n    buffer.append(\" \");\n    String refText = JavaDocUtil.getReferenceText(myProject, aClass);\n    if (refText == null) {\n      buffer.setLength(0);\n      return;\n    }\n    String labelText = JavaDocUtil.getLabelText(myProject, manager, refText, aClass);\n    buffer.append(\"<b>\");\n    buffer.append(labelText);\n    buffer.append(\"<\/b>\");\n\n    buffer.append(generateTypeParameters(aClass));\n\n    buffer.append(\"\\n\");\n\n    PsiClassType[] refs = aClass.getExtendsListTypes();\n\n    String qName = aClass.getQualifiedName();\n\n    if (refs.length > 0 || !aClass.isInterface() && (qName == null || !qName.equals(CommonClassNames.JAVA_LANG_OBJECT))) {\n      buffer.append(\"extends \");\n      if (refs.length == 0) {\n        generateLink(buffer, CommonClassNames.JAVA_LANG_OBJECT, null, aClass, false);\n      }\n      else {\n        for (int i = 0; i < refs.length; i++) {\n          generateType(buffer, refs[i], aClass);\n          if (i < refs.length - 1) {\n            buffer.append(\",&nbsp;\");\n          }\n        }\n      }\n      buffer.append(\"\\n\");\n    }\n\n    refs = aClass.getImplementsListTypes();\n\n    if (refs.length > 0) {\n      buffer.append(\"implements \");\n      for (int i = 0; i < refs.length; i++) {\n        generateType(buffer, refs[i], aClass);\n        if (i < refs.length - 1) {\n          buffer.append(\",&nbsp;\");\n        }\n      }\n      buffer.append(\"\\n\");\n    }\n    if (buffer.charAt(buffer.length() - 1) == '\\n') {\n      buffer.setLength(buffer.length() - 1);\n    }\n    buffer.append(\"<\/PRE>\");\n    //buffer.append(\"<br>\");\n\n    PsiDocComment comment = getDocComment(aClass);\n    if (comment != null) {\n      generateCommonSection(buffer, comment);\n      generateTypeParametersSection(buffer, aClass);\n    }\n\n    if (generatePrologueAndEpilogue)\n      generateEpilogue(buffer);\n  }","commit_id":"6a561c7982bf64247d098926a6e3cbee8a70132f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  private void generateSuperMethodsSection(StringBuilder buffer, PsiMethod method, boolean overrides) {\n    PsiClass parentClass = method.getContainingClass();\n    if (parentClass == null) return;\n    if (parentClass.isInterface() && !overrides) return;\n    PsiMethod[] supers = method.findSuperMethods();\n    if (supers.length == 0) return;\n    boolean headerGenerated = false;\n    for (PsiMethod superMethod : supers) {\n      boolean isAbstract = superMethod.hasModifierProperty(PsiModifier.ABSTRACT);\n      if (overrides) {\n        if (parentClass.isInterface() ? !isAbstract : isAbstract) continue;\n      }\n      else {\n        if (!isAbstract) continue;\n      }\n      PsiClass superClass = superMethod.getContainingClass();\n      if (!headerGenerated) {\n        buffer.append(\"<DD><DL>\");\n        buffer.append(\"<DT><b>\");\n        buffer.append(overrides ?\n                      CodeInsightBundle.message(\"javadoc.method.overrides\") :\n                      CodeInsightBundle .message(\"javadoc.method.specified.by\"));\n        buffer.append(\"<\/b>\");\n        headerGenerated = true;\n      }\n      buffer.append(\"<DD>\");\n\n      StringBuilder methodBuffer = new StringBuilder();\n      generateLink(methodBuffer, superMethod, superMethod.getName());\n      StringBuilder classBuffer = new StringBuilder();\n      generateLink(classBuffer, superClass, superClass.getName());\n      if (superClass.isInterface()) {\n        buffer.append(CodeInsightBundle.message(\"javadoc.method.in.interface\", methodBuffer.toString(), classBuffer.toString()));\n      }\n      else {\n        buffer.append(CodeInsightBundle.message(\"javadoc.method.in.class\", methodBuffer.toString(), classBuffer.toString()));\n      }\n    }\n    if (headerGenerated) {\n      buffer.append(\"<\/DD><\/DL><\/DD>\");\n    }\n  }","id":97622,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  private void generateSuperMethodsSection(StringBuilder buffer, PsiMethod method, boolean overrides) {\n    PsiClass parentClass = method.getContainingClass();\n    if (parentClass == null) return;\n    if (parentClass.isInterface() && !overrides) return;\n    PsiMethod[] supers = method.findSuperMethods();\n    if (supers.length == 0) return;\n    boolean headerGenerated = false;\n    for (PsiMethod superMethod : supers) {\n      boolean isAbstract = superMethod.hasModifierProperty(PsiModifier.ABSTRACT);\n      if (overrides) {\n        if (parentClass.isInterface() ? !isAbstract : isAbstract) continue;\n      }\n      else {\n        if (!isAbstract) continue;\n      }\n      PsiClass superClass = superMethod.getContainingClass();\n      if (!headerGenerated) {\n        buffer.append(\"<DD><DL>\");\n        buffer.append(\"<DT><b>\");\n        buffer.append(overrides ?\n                      CodeInsightBundle.message(\"javadoc.method.overrides\") :\n                      CodeInsightBundle .message(\"javadoc.method.specified.by\"));\n        buffer.append(\"<\/b>\");\n        headerGenerated = true;\n      }\n      buffer.append(\"<DD>\");\n\n      StringBuilder methodBuffer = new StringBuilder();\n      generateLink(methodBuffer, superMethod, superMethod.getName(), false);\n      StringBuilder classBuffer = new StringBuilder();\n      generateLink(classBuffer, superClass, superClass.getName(), false);\n      if (superClass.isInterface()) {\n        buffer.append(CodeInsightBundle.message(\"javadoc.method.in.interface\", methodBuffer.toString(), classBuffer.toString()));\n      }\n      else {\n        buffer.append(CodeInsightBundle.message(\"javadoc.method.in.class\", methodBuffer.toString(), classBuffer.toString()));\n      }\n    }\n    if (headerGenerated) {\n      buffer.append(\"<\/DD><\/DL><\/DD>\");\n    }\n  }","commit_id":"6a561c7982bf64247d098926a6e3cbee8a70132f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void generatePackageHtmlJavaDoc(final StringBuilder buffer, final PsiFile packageHtmlFile) {\n    String htmlText = packageHtmlFile.getText();\n\n    try {\n      final Document document = JDOMUtil.loadDocument(new ByteArrayInputStream(htmlText.getBytes()));\n      final Element rootTag = document.getRootElement();\n      if (rootTag != null) {\n        final Element subTag = rootTag.getChild(\"body\");\n        if (subTag != null) {\n          htmlText = subTag.getValue();\n        }\n      }\n    }\n    catch (JDOMException ignore) {}\n    catch (IOException ignore) {}\n\n    htmlText = StringUtil.replace(htmlText, \"*/\", \"&#42;&#47;\");\n\n    final String fileText = \"/** \" + htmlText + \" */\";\n    final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(packageHtmlFile.getProject()).getElementFactory();\n    final PsiDocComment docComment;\n    try {\n      docComment = elementFactory.createDocCommentFromText(fileText);\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n      return;\n    }\n\n    generatePrologue(buffer);\n\n    generateCommonSection(buffer, docComment);\n\n    generateEpilogue(buffer);\n  }","id":97623,"modified_method":"private void generatePackageHtmlJavaDoc(final StringBuilder buffer, final PsiFile packageHtmlFile, boolean generatePrologueAndEpilogue) {\n    String htmlText = packageHtmlFile.getText();\n\n    try {\n      final Document document = JDOMUtil.loadDocument(new ByteArrayInputStream(htmlText.getBytes()));\n      final Element rootTag = document.getRootElement();\n      if (rootTag != null) {\n        final Element subTag = rootTag.getChild(\"body\");\n        if (subTag != null) {\n          htmlText = subTag.getValue();\n        }\n      }\n    }\n    catch (JDOMException ignore) {}\n    catch (IOException ignore) {}\n\n    htmlText = StringUtil.replace(htmlText, \"*/\", \"&#42;&#47;\");\n\n    final String fileText = \"/** \" + htmlText + \" */\";\n    final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(packageHtmlFile.getProject()).getElementFactory();\n    final PsiDocComment docComment;\n    try {\n      docComment = elementFactory.createDocCommentFromText(fileText);\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n      return;\n    }\n\n    if (generatePrologueAndEpilogue)\n      generatePrologue(buffer);\n\n    generateCommonSection(buffer, docComment);\n\n    if (generatePrologueAndEpilogue)\n      generateEpilogue(buffer);\n  }","commit_id":"6a561c7982bf64247d098926a6e3cbee8a70132f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return Length of the generated label.\n   */\n  @SuppressWarnings({\"HardCodedStringLiteral\"})\n  private static int generateLink(StringBuilder buffer, String refText, String label, @NotNull PsiElement context, boolean plainLink) {\n    if (label == null) {\n      final PsiManager manager = context.getManager();\n      label = JavaDocUtil.getLabelText(manager.getProject(), manager, refText, context);\n    }\n\n    LOG.assertTrue(refText != null, \"refText appears to be null.\");\n\n    final PsiElement target = JavaDocUtil.findReferenceTarget(context.getManager(), refText, context);\n    boolean isBrokenLink = target == null;\n    if (isBrokenLink) {\n      buffer.append(\"<font color=red>\");\n      buffer.append(label);\n      buffer.append(\"<\/font>\");\n      return label.length();\n    }\n\n\n    DocumentationManagerUtil.createHyperlink(buffer, target, JavaDocUtil.getReferenceText(context.getProject(), target), label, plainLink);\n    return label.length();\n  }","id":97624,"modified_method":"/**\n   * @return Length of the generated label.\n   */\n  @SuppressWarnings({\"HardCodedStringLiteral\"})\n  private static int generateLink(StringBuilder buffer, String refText, String label, @NotNull PsiElement context, boolean plainLink) {\n    if (label == null) {\n      final PsiManager manager = context.getManager();\n      label = JavaDocUtil.getLabelText(manager.getProject(), manager, refText, context);\n    }\n\n    LOG.assertTrue(refText != null, \"refText appears to be null.\");\n\n    final PsiElement target = JavaDocUtil.findReferenceTarget(context.getManager(), refText, context);\n    boolean isBrokenLink = target == null;\n    if (isBrokenLink) {\n      buffer.append(\"<font color=red>\");\n      buffer.append(label);\n      buffer.append(\"<\/font>\");\n      return label.length();\n    }\n\n\n    generateLink(buffer, target, label, plainLink);\n    return label.length();\n  }","commit_id":"6a561c7982bf64247d098926a6e3cbee8a70132f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String generateDocInfo(List<String> docURLs) {\n    StringBuilder buffer = new StringBuilder();\n    \n    if (myElement instanceof PsiClass) {\n      generateClassJavaDoc(buffer, (PsiClass)myElement);\n    }\n    else if (myElement instanceof PsiMethod) {\n      generateMethodJavaDoc(buffer, (PsiMethod)myElement);\n    } else if (myElement instanceof PsiParameter) {\n      generateMethodParameterJavaDoc(buffer, (PsiParameter)myElement);\n    }\n    else if (myElement instanceof PsiField) {\n      generateFieldJavaDoc(buffer, (PsiField)myElement);\n    }\n    else if (myElement instanceof PsiVariable) {\n      generateVariableJavaDoc(buffer, (PsiVariable)myElement);\n    }\n    else if (myElement instanceof PsiDirectory) {\n      final PsiPackage aPackage = JavaDirectoryService.getInstance().getPackage((PsiDirectory)myElement);\n      if (aPackage == null) return null;\n      generatePackageJavaDoc(buffer, aPackage);\n    }\n    else if (myElement instanceof PsiPackage) {\n      generatePackageJavaDoc(buffer, (PsiPackage) myElement);\n    } else {\n      return null;\n    }\n    if (docURLs != null) {\n      StringBuilder errorsSection = new StringBuilder(\"<p id=\\\"error\\\">Following external urls were checked:<br>&nbsp;&nbsp;&nbsp;<i>\");\n      errorsSection.append(StringUtil.join(docURLs, \"<\/i><br>&nbsp;&nbsp;&nbsp;<i>\"));\n      errorsSection.append(\"<\/i><br>The documentation for this element is not found. Please add all the needed paths to API docs in \");\n      errorsSection.append(\"<a href=\\\"open://Project Settings\\\">Project Settings.<\/a><\/p>\");\n      if (buffer.length() == 0) {\n        buffer.append(\"<html><body><\/body><\/html>\");\n      }\n      buffer.insert(buffer.indexOf(\"<body>\"), errorsSection.toString());\n    }\n    return fixupDoc(buffer);\n  }","id":97625,"modified_method":"@Nullable\n  public String generateDocInfo(List<String> docURLs) {\n    StringBuilder buffer = new StringBuilder();\n\n    if (!generateDocInfoCore(buffer, true))\n      return null;\n    \n    if (docURLs != null) {\n      StringBuilder errorsSection = new StringBuilder(\"<p id=\\\"error\\\">Following external urls were checked:<br>&nbsp;&nbsp;&nbsp;<i>\");\n      errorsSection.append(StringUtil.join(docURLs, \"<\/i><br>&nbsp;&nbsp;&nbsp;<i>\"));\n      errorsSection.append(\"<\/i><br>The documentation for this element is not found. Please add all the needed paths to API docs in \");\n      errorsSection.append(\"<a href=\\\"open://Project Settings\\\">Project Settings.<\/a><\/p>\");\n      if (buffer.length() == 0) {\n        buffer.append(\"<html><body><\/body><\/html>\");\n      }\n      buffer.insert(buffer.indexOf(\"<body>\"), errorsSection.toString());\n    }\n    return fixupDoc(buffer);\n  }","commit_id":"6a561c7982bf64247d098926a6e3cbee8a70132f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void generateVariableJavaDoc(@NonNls StringBuilder buffer, PsiVariable variable) {\n    generatePrologue(buffer);\n\n    buffer.append(\"<PRE>\");\n    String modifiers = PsiFormatUtil.formatModifiers(variable, PsiFormatUtilBase.JAVADOC_MODIFIERS_ONLY);\n    if (modifiers.length() > 0) {\n      buffer.append(modifiers);\n      buffer.append(\" \");\n    }\n    generateType(buffer, variable.getType(), variable);\n    buffer.append(\" \");\n    buffer.append(\"<b>\");\n    buffer.append(variable.getName());\n    appendInitializer(buffer, variable);\n    buffer.append(\"<\/b>\");\n    buffer.append(\"<\/PRE>\");\n    //buffer.append(\"<br>\");\n\n    ColorUtil.appendColorPreview(variable, buffer);\n\n    generateEpilogue(buffer);\n  }","id":97626,"modified_method":"private void generateVariableJavaDoc(@NonNls StringBuilder buffer, PsiVariable variable, boolean generatePrologueAndEpilogue) {\n    if (generatePrologueAndEpilogue)\n      generatePrologue(buffer);\n\n    buffer.append(\"<PRE>\");\n    String modifiers = PsiFormatUtil.formatModifiers(variable, PsiFormatUtilBase.JAVADOC_MODIFIERS_ONLY);\n    if (modifiers.length() > 0) {\n      buffer.append(modifiers);\n      buffer.append(\" \");\n    }\n    generateType(buffer, variable.getType(), variable);\n    buffer.append(\" \");\n    buffer.append(\"<b>\");\n    buffer.append(variable.getName());\n    appendInitializer(buffer, variable);\n    buffer.append(\"<\/b>\");\n    buffer.append(\"<\/PRE>\");\n    //buffer.append(\"<br>\");\n\n    ColorUtil.appendColorPreview(variable, buffer);\n\n    if (generatePrologueAndEpilogue)\n      generateEpilogue(buffer);\n  }","commit_id":"6a561c7982bf64247d098926a6e3cbee8a70132f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void generateFieldJavaDoc(@NonNls StringBuilder buffer, PsiField field) {\n    generatePrologue(buffer);\n\n    PsiClass parentClass = field.getContainingClass();\n    if (parentClass != null) {\n      String qName = parentClass.getQualifiedName();\n      if (qName != null) {\n        buffer.append(\"<small><b>\");\n        //buffer.append(qName);\n        generateLink(buffer, qName, qName, field, false);\n        buffer.append(\"<\/b><\/small>\");\n        //buffer.append(\"<br>\");\n      }\n    }\n\n    buffer.append(\"<PRE>\");\n    generateAnnotations(buffer, field);\n    String modifiers = PsiFormatUtil.formatModifiers(field, PsiFormatUtilBase.JAVADOC_MODIFIERS_ONLY);\n    if (modifiers.length() > 0) {\n      buffer.append(modifiers);\n      buffer.append(\" \");\n    }\n    generateType(buffer, field.getType(), field);\n    buffer.append(\" \");\n    buffer.append(\"<b>\");\n    buffer.append(field.getName());\n    appendInitializer(buffer, field);\n    buffer.append(\"<\/b>\");\n    buffer.append(\"<\/PRE>\");\n    //buffer.append(\"<br>\");\n\n    ColorUtil.appendColorPreview(field, buffer);\n\n    PsiDocComment comment = getDocComment(field);\n    if (comment != null) {\n      generateCommonSection(buffer, comment);\n    }\n\n    generateEpilogue(buffer);\n  }","id":97627,"modified_method":"private void generateFieldJavaDoc(@NonNls StringBuilder buffer, PsiField field, boolean generatePrologueAndEpilogue) {\n    if (generatePrologueAndEpilogue)\n      generatePrologue(buffer);\n\n    PsiClass parentClass = field.getContainingClass();\n    if (parentClass != null) {\n      String qName = parentClass.getQualifiedName();\n      if (qName != null) {\n        buffer.append(\"<small><b>\");\n        //buffer.append(qName);\n        generateLink(buffer, qName, qName, field, false);\n        buffer.append(\"<\/b><\/small>\");\n        //buffer.append(\"<br>\");\n      }\n    }\n\n    buffer.append(\"<PRE>\");\n    generateAnnotations(buffer, field);\n    String modifiers = PsiFormatUtil.formatModifiers(field, PsiFormatUtilBase.JAVADOC_MODIFIERS_ONLY);\n    if (modifiers.length() > 0) {\n      buffer.append(modifiers);\n      buffer.append(\" \");\n    }\n    generateType(buffer, field.getType(), field);\n    buffer.append(\" \");\n    buffer.append(\"<b>\");\n    buffer.append(field.getName());\n    appendInitializer(buffer, field);\n    buffer.append(\"<\/b>\");\n    buffer.append(\"<\/PRE>\");\n    //buffer.append(\"<br>\");\n\n    ColorUtil.appendColorPreview(field, buffer);\n\n    PsiDocComment comment = getDocComment(field);\n    if (comment != null) {\n      generateCommonSection(buffer, comment);\n    }\n\n    if (generatePrologueAndEpilogue)\n      generateEpilogue(buffer);\n  }","commit_id":"6a561c7982bf64247d098926a6e3cbee8a70132f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void generateLink(StringBuilder buffer, PsiElement element, String label) {\n    String refText = JavaDocUtil.getReferenceText(myProject, element);\n    if (refText != null) {\n      DocumentationManagerUtil.createHyperlink(buffer, element, refText, label, false);\n      //return generateLink(buffer, refText, label, context, false);\n    }\n  }","id":97628,"modified_method":"private static void generateLink(StringBuilder buffer, PsiElement element, String label, boolean plainLink) {\n    String refText = JavaDocUtil.getReferenceText(element.getProject(), element);\n    if (refText != null) {\n      DocumentationManagerUtil.createHyperlink(buffer, element, refText, label, plainLink);\n      //return generateLink(buffer, refText, label, context, false);\n    }\n  }","commit_id":"6a561c7982bf64247d098926a6e3cbee8a70132f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String generateFileInfo() {\n    StringBuilder buffer = new StringBuilder();\n    if (myElement instanceof PsiFile) {\n      generateFileJavaDoc(buffer, (PsiFile)myElement); //used for Ctrl-Click\n    }\n\n    return fixupDoc(buffer);\n  }","id":97629,"modified_method":"@Nullable\n  public String generateFileInfo() {\n    StringBuilder buffer = new StringBuilder();\n    if (myElement instanceof PsiFile) {\n      generateFileJavaDoc(buffer, (PsiFile)myElement, true); //used for Ctrl-Click\n    }\n\n    return fixupDoc(buffer);\n  }","commit_id":"6a561c7982bf64247d098926a6e3cbee8a70132f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void generatePackageJavaDoc(final StringBuilder buffer, final PsiPackage psiPackage) {\n    for(PsiDirectory directory: psiPackage.getDirectories()) {\n      final PsiFile packageInfoFile = directory.findFile(PsiPackage.PACKAGE_INFO_FILE);\n      if (packageInfoFile != null) {\n        final ASTNode node = packageInfoFile.getNode();\n        if (node != null) {\n          final ASTNode docCommentNode = node.findChildByType(JavaDocElementType.DOC_COMMENT);\n          if (docCommentNode != null) {\n            final PsiDocComment docComment = (PsiDocComment)docCommentNode.getPsi();\n\n            generatePrologue(buffer);\n\n            generateCommonSection(buffer, docComment);\n\n            generateEpilogue(buffer);\n            break;\n          }\n        }\n      }\n      PsiFile packageHtmlFile = directory.findFile(\"package.html\");\n      if (packageHtmlFile != null) {\n        generatePackageHtmlJavaDoc(buffer, packageHtmlFile);\n        break;\n      }\n    }\n  }","id":97630,"modified_method":"private void generatePackageJavaDoc(final StringBuilder buffer, final PsiPackage psiPackage, boolean generatePrologueAndEpilogue) {\n    for(PsiDirectory directory: psiPackage.getDirectories()) {\n      final PsiFile packageInfoFile = directory.findFile(PsiPackage.PACKAGE_INFO_FILE);\n      if (packageInfoFile != null) {\n        final ASTNode node = packageInfoFile.getNode();\n        if (node != null) {\n          final ASTNode docCommentNode = node.findChildByType(JavaDocElementType.DOC_COMMENT);\n          if (docCommentNode != null) {\n            final PsiDocComment docComment = (PsiDocComment)docCommentNode.getPsi();\n\n            if (generatePrologueAndEpilogue)\n              generatePrologue(buffer);\n\n            generateCommonSection(buffer, docComment);\n\n            if (generatePrologueAndEpilogue)\n              generateEpilogue(buffer);\n            break;\n          }\n        }\n      }\n      PsiFile packageHtmlFile = directory.findFile(\"package.html\");\n      if (packageHtmlFile != null) {\n        generatePackageHtmlJavaDoc(buffer, packageHtmlFile, generatePrologueAndEpilogue);\n        break;\n      }\n    }\n  }","commit_id":"6a561c7982bf64247d098926a6e3cbee8a70132f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void generateMethodParameterJavaDoc(@NonNls StringBuilder buffer, PsiParameter parameter) {\n    generatePrologue(buffer);\n\n    buffer.append(\"<PRE>\");\n    String modifiers = PsiFormatUtil.formatModifiers(parameter, PsiFormatUtilBase.JAVADOC_MODIFIERS_ONLY);\n    if (modifiers.length() > 0) {\n      buffer.append(modifiers);\n      buffer.append(\" \");\n    }\n    generateAnnotations(buffer, parameter);\n    generateType(buffer, parameter.getType(), parameter);\n    buffer.append(\" \");\n    buffer.append(\"<b>\");\n    buffer.append(parameter.getName());\n    appendInitializer(buffer, parameter);\n    buffer.append(\"<\/b>\");\n    buffer.append(\"<\/PRE>\");\n\n    final PsiMethod method = PsiTreeUtil.getParentOfType(parameter, PsiMethod.class);\n\n    if (method != null) {\n      final PsiDocComment docComment = getDocComment(method);\n      if (docComment != null) {\n        final Pair<PsiDocTag, InheritDocProvider<PsiDocTag>> tagInfoProvider =\n          findDocTag(docComment.getTags(), parameter.getName(), method);\n\n        if (tagInfoProvider != null) {\n          PsiElement[] elements = tagInfoProvider.first.getDataElements();\n          if (elements.length != 0) generateOneParameter(elements, buffer, tagInfoProvider);\n        }\n      }\n    }\n\n    generateEpilogue(buffer);\n  }","id":97631,"modified_method":"private void generateMethodParameterJavaDoc(@NonNls StringBuilder buffer, PsiParameter parameter, boolean generatePrologueAndEpilogue) {\n    if (generatePrologueAndEpilogue)\n      generatePrologue(buffer);\n\n    buffer.append(\"<PRE>\");\n    String modifiers = PsiFormatUtil.formatModifiers(parameter, PsiFormatUtilBase.JAVADOC_MODIFIERS_ONLY);\n    if (modifiers.length() > 0) {\n      buffer.append(modifiers);\n      buffer.append(\" \");\n    }\n    generateAnnotations(buffer, parameter);\n    generateType(buffer, parameter.getType(), parameter);\n    buffer.append(\" \");\n    buffer.append(\"<b>\");\n    buffer.append(parameter.getName());\n    appendInitializer(buffer, parameter);\n    buffer.append(\"<\/b>\");\n    buffer.append(\"<\/PRE>\");\n\n    final PsiMethod method = PsiTreeUtil.getParentOfType(parameter, PsiMethod.class);\n\n    if (method != null) {\n      final PsiDocComment docComment = getDocComment(method);\n      if (docComment != null) {\n        final Pair<PsiDocTag, InheritDocProvider<PsiDocTag>> tagInfoProvider =\n          findDocTag(docComment.getTags(), parameter.getName(), method);\n\n        if (tagInfoProvider != null) {\n          PsiElement[] elements = tagInfoProvider.first.getDataElements();\n          if (elements.length != 0) generateOneParameter(elements, buffer, tagInfoProvider);\n        }\n      }\n    }\n\n    if (generatePrologueAndEpilogue)\n      generateEpilogue(buffer);\n  }","commit_id":"6a561c7982bf64247d098926a6e3cbee8a70132f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void generateFileJavaDoc(StringBuilder buffer, PsiFile file) {\n    generatePrologue(buffer);\n    final VirtualFile virtualFile = file.getVirtualFile();\n    if (virtualFile != null) {\n      buffer.append(virtualFile.getPresentableUrl());\n    }\n    generateEpilogue(buffer);\n  }","id":97632,"modified_method":"private static void generateFileJavaDoc(StringBuilder buffer, PsiFile file, boolean generatePrologueAndEpilogue) {\n    if (generatePrologueAndEpilogue)\n      generatePrologue(buffer);\n    final VirtualFile virtualFile = file.getVirtualFile();\n    if (virtualFile != null) {\n      buffer.append(virtualFile.getPresentableUrl());\n    }\n    if (generatePrologueAndEpilogue)\n      generateEpilogue(buffer);\n  }","commit_id":"6a561c7982bf64247d098926a6e3cbee8a70132f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void compress(final ClientContext context) {\n\t\tBucket data = origData;\n\t\tCompressor bestCodec = null;\n\t\tBucket bestCompressedData = null;\n\t\t\n\t\t// Try to compress the data.\n\t\t// Try each algorithm, starting with the fastest and weakest.\n\t\t// Stop when run out of algorithms, or the compressed data fits in a single block.\n\t\tint algos = Compressor.countCompressAlgorithms();\n\t\ttry {\n\t\t\tfor(int i=0;i<algos;i++) {\n\t\t\t\t// Only produce if we are compressing *the original data*\n\t\t\t\tif(persistent) {\n\t\t\t\t\tfinal int phase = i;\n\t\t\t\t\tcontext.jobRunner.queue(new DBJob() {\n\n\t\t\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(container.ext().isActive(inserter))\n\t\t\t\t\t\t\t\tLogger.error(this, \"ALREADY ACTIVE in start compression callback: \"+inserter);\n\t\t\t\t\t\t\tcontainer.activate(inserter, 1);\n\t\t\t\t\t\t\tinserter.onStartCompression(phase, container, context);\n\t\t\t\t\t\t\tcontainer.deactivate(inserter, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}, NativeThread.NORM_PRIORITY+1, false);\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinserter.onStartCompression(i, null, context);\n\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\tLogger.error(this, \"Transient insert callback threw \"+t, t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tCompressor comp = Compressor.getCompressionAlgorithmByDifficulty(i);\n\t\t\t\tBucket result;\n\t\t\t\tresult = comp.compress(origData, new BucketChainBucketFactory(bucketFactory, NodeCHK.BLOCK_SIZE, persistent ? context.jobRunner : null, HighLevelSimpleClientImpl.SPLITFILE_BLOCKS_PER_SEGMENT), origData.size());\n\t\t\t\tif(result.size() < minSize) {\n\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\tif(bestCompressedData != null)\n\t\t\t\t\t\tbestCompressedData.free();\n\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif((bestCompressedData != null) && (result.size() <  bestCompressedData.size())) {\n\t\t\t\t\tbestCompressedData.free();\n\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\tbestCodec = comp;\n\t\t\t\t} else if((bestCompressedData == null) && (result.size() < data.size())) {\n\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\tbestCodec = comp;\n\t\t\t\t} else {\n\t\t\t\t\tresult.free();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal CompressionOutput output = new CompressionOutput(bestCompressedData, bestCodec);\n\t\t\t\n\t\t\tif(persistent) {\n\t\t\t\n\t\t\t\tcontext.jobRunner.queue(new DBJob() {\n\t\t\t\t\t\n\t\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\tif(container.ext().isActive(inserter))\n\t\t\t\t\t\t\tLogger.error(this, \"ALREADY ACTIVE in compressed callback: \"+inserter);\n\t\t\t\t\t\t// Must call storeTo at this point to cancel the delete-on-startup job.\n\t\t\t\t\t\toutput.data.storeTo(container);\n\t\t\t\t\t\tcontainer.activate(inserter, 1);\n\t\t\t\t\t\tinserter.onCompressed(output, container, context);\n\t\t\t\t\t\tcontainer.deactivate(inserter, 1);\n\t\t\t\t\t\tcontainer.delete(InsertCompressor.this);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}, NativeThread.NORM_PRIORITY+1, false);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tinserter.onCompressed(output, null, context);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLogger.error(this, \"Caught \"+t+\" running compression job\", t);\n\t\t\t\t\tcontext.jobRunner.queue(new DBJob() {\n\n\t\t\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tcontainer.delete(InsertCompressor.this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}, NativeThread.NORM_PRIORITY+1, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} catch (final IOException e) {\n\t\t\tif(persistent) {\n\t\t\t\tcontext.jobRunner.queue(new DBJob() {\n\t\t\t\t\t\n\t\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\tif(container.ext().isActive(inserter))\n\t\t\t\t\t\t\tLogger.error(this, \"ALREADY ACTIVE in compress failure callback: \"+inserter);\n\t\t\t\t\t\tcontainer.activate(inserter, 1);\n\t\t\t\t\t\tcontainer.activate(inserter.cb, 1);\n\t\t\t\t\t\tinserter.cb.onFailure(new InsertException(InsertException.BUCKET_ERROR, e, null), inserter, container, context);\n\t\t\t\t\t\tcontainer.deactivate(inserter.cb, 1);\n\t\t\t\t\t\tcontainer.deactivate(inserter, 1);\n\t\t\t\t\t\tcontainer.delete(InsertCompressor.this);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}, NativeThread.NORM_PRIORITY+1, false);\n\t\t\t} else {\n\t\t\t\tinserter.cb.onFailure(new InsertException(InsertException.BUCKET_ERROR, e, null), inserter, null, context);\n\t\t\t}\n\t\t\t\n\t\t} catch (final CompressionOutputSizeException e) {\n\t\t\tif(persistent) {\n\t\t\t\tcontext.jobRunner.queue(new DBJob() {\n\t\t\t\t\t\n\t\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\tif(container.ext().isActive(inserter))\n\t\t\t\t\t\t\tLogger.error(this, \"ALREADY ACTIVE in compress size callback: \"+inserter);\n\t\t\t\t\t\tcontainer.activate(inserter, 1);\n\t\t\t\t\t\tcontainer.activate(inserter.cb, 1);\n\t\t\t\t\t\tinserter.cb.onFailure(new InsertException(InsertException.BUCKET_ERROR, e, null), inserter, container, context);\n\t\t\t\t\t\tcontainer.deactivate(inserter.cb, 1);\n\t\t\t\t\t\tcontainer.deactivate(inserter, 1);\n\t\t\t\t\t\tcontainer.delete(InsertCompressor.this);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}, NativeThread.NORM_PRIORITY+1, false);\n\t\t\t} else {\n\t\t\t\tinserter.cb.onFailure(new InsertException(InsertException.BUCKET_ERROR, e, null), inserter, null, context);\n\t\t\t}\n\t\t}\n\t}","id":97633,"modified_method":"protected void compress(final ClientContext context) {\n\t\tBucket data = origData;\n\t\tCompressor bestCodec = null;\n\t\tBucket bestCompressedData = null;\n\t\t\n\t\t// Try to compress the data.\n\t\t// Try each algorithm, starting with the fastest and weakest.\n\t\t// Stop when run out of algorithms, or the compressed data fits in a single block.\n\t\tint algos = Compressor.countCompressAlgorithms();\n\t\ttry {\n\t\t\tfor(int i=0;i<algos;i++) {\n\t\t\t\t// Only produce if we are compressing *the original data*\n\t\t\t\tif(persistent) {\n\t\t\t\t\tfinal int phase = i;\n\t\t\t\t\tcontext.jobRunner.queue(new DBJob() {\n\n\t\t\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tif(container.ext().isActive(inserter))\n\t\t\t\t\t\t\t\tLogger.error(this, \"ALREADY ACTIVE in start compression callback: \"+inserter);\n\t\t\t\t\t\t\tcontainer.activate(inserter, 1);\n\t\t\t\t\t\t\tinserter.onStartCompression(phase, container, context);\n\t\t\t\t\t\t\tcontainer.deactivate(inserter, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}, NativeThread.NORM_PRIORITY+1, false);\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinserter.onStartCompression(i, null, context);\n\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\tLogger.error(this, \"Transient insert callback threw \"+t, t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tCompressor comp = Compressor.getCompressionAlgorithmByDifficulty(i);\n\t\t\t\tBucket result;\n\t\t\t\tresult = comp.compress(origData, new BucketChainBucketFactory(bucketFactory, NodeCHK.BLOCK_SIZE, persistent ? context.jobRunner : null, HighLevelSimpleClientImpl.SPLITFILE_BLOCKS_PER_SEGMENT), origData.size());\n\t\t\t\tif(result.size() < minSize) {\n\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\tif(bestCompressedData != null)\n\t\t\t\t\t\tbestCompressedData.free();\n\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif((bestCompressedData != null) && (result.size() <  bestCompressedData.size())) {\n\t\t\t\t\tbestCompressedData.free();\n\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\tbestCodec = comp;\n\t\t\t\t} else if((bestCompressedData == null) && (result.size() < data.size())) {\n\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\tbestCodec = comp;\n\t\t\t\t} else {\n\t\t\t\t\tresult.free();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal CompressionOutput output = new CompressionOutput(bestCompressedData, bestCodec);\n\t\t\t\n\t\t\tif(persistent) {\n\t\t\t\n\t\t\t\tcontext.jobRunner.queue(new DBJob() {\n\t\t\t\t\t\n\t\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\tif(container.ext().isActive(inserter))\n\t\t\t\t\t\t\tLogger.error(this, \"ALREADY ACTIVE in compressed callback: \"+inserter);\n\t\t\t\t\t\tcontainer.activate(inserter, 1);\n\t\t\t\t\t\tinserter.onCompressed(output, container, context);\n\t\t\t\t\t\tcontainer.deactivate(inserter, 1);\n\t\t\t\t\t\tcontainer.delete(InsertCompressor.this);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}, NativeThread.NORM_PRIORITY+1, false);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tinserter.onCompressed(output, null, context);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLogger.error(this, \"Caught \"+t+\" running compression job\", t);\n\t\t\t\t\tcontext.jobRunner.queue(new DBJob() {\n\n\t\t\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\t\tcontainer.delete(InsertCompressor.this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}, NativeThread.NORM_PRIORITY+1, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} catch (final IOException e) {\n\t\t\tif(persistent) {\n\t\t\t\tcontext.jobRunner.queue(new DBJob() {\n\t\t\t\t\t\n\t\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\tif(container.ext().isActive(inserter))\n\t\t\t\t\t\t\tLogger.error(this, \"ALREADY ACTIVE in compress failure callback: \"+inserter);\n\t\t\t\t\t\tcontainer.activate(inserter, 1);\n\t\t\t\t\t\tcontainer.activate(inserter.cb, 1);\n\t\t\t\t\t\tinserter.cb.onFailure(new InsertException(InsertException.BUCKET_ERROR, e, null), inserter, container, context);\n\t\t\t\t\t\tcontainer.deactivate(inserter.cb, 1);\n\t\t\t\t\t\tcontainer.deactivate(inserter, 1);\n\t\t\t\t\t\tcontainer.delete(InsertCompressor.this);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}, NativeThread.NORM_PRIORITY+1, false);\n\t\t\t} else {\n\t\t\t\tinserter.cb.onFailure(new InsertException(InsertException.BUCKET_ERROR, e, null), inserter, null, context);\n\t\t\t}\n\t\t\t\n\t\t} catch (final CompressionOutputSizeException e) {\n\t\t\tif(persistent) {\n\t\t\t\tcontext.jobRunner.queue(new DBJob() {\n\t\t\t\t\t\n\t\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\t\tif(container.ext().isActive(inserter))\n\t\t\t\t\t\t\tLogger.error(this, \"ALREADY ACTIVE in compress size callback: \"+inserter);\n\t\t\t\t\t\tcontainer.activate(inserter, 1);\n\t\t\t\t\t\tcontainer.activate(inserter.cb, 1);\n\t\t\t\t\t\tinserter.cb.onFailure(new InsertException(InsertException.BUCKET_ERROR, e, null), inserter, container, context);\n\t\t\t\t\t\tcontainer.deactivate(inserter.cb, 1);\n\t\t\t\t\t\tcontainer.deactivate(inserter, 1);\n\t\t\t\t\t\tcontainer.delete(InsertCompressor.this);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}, NativeThread.NORM_PRIORITY+1, false);\n\t\t\t} else {\n\t\t\t\tinserter.cb.onFailure(new InsertException(InsertException.BUCKET_ERROR, e, null), inserter, null, context);\n\t\t\t}\n\t\t}\n\t}","commit_id":"a9b5e1c888aa77ac5577a1a2af53f94d9a7b92f7","url":"https://github.com/freenet/fred"},{"original_method":"public void start(Config config) throws NodeInitException {\n\t\tbackgroundBlockEncoder.setContext(clientContext);\n\t\tnode.executor.execute(backgroundBlockEncoder, \"Background block encoder\");\n\t\tclientContext.jobRunner.queue(new DBJob() {\n\t\t\t\n\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\tArchiveManager.init(container, context, context.nodeDBHandle);\n\t\t\t}\n\t\t\t\n\t\t}, NativeThread.NORM_PRIORITY, false);\n\t\tpersister.start();\n\t\t\n\t\tstoreChecker.start(node.executor, \"Datastore checker\");\n\t\tclientDatabaseExecutor.start(node.executor, \"Client database access thread\");\n\t\tif(fcpServer != null)\n\t\t\tfcpServer.maybeStart();\n\t\tif(tmci != null)\n\t\t\ttmci.start();\n\n\t\tnode.executor.execute(new PrioRunnable() {\n\n\t\t\tpublic void run() {\n\t\t\t\tLogger.normal(this, \"Resuming persistent requests\");\n\t\t\t\t// Call it anyway; if we are not lazy, it won't have to start any requests\n\t\t\t\t// But it does other things too\n\t\t\t\tfcpServer.finishStart();\n\t\t\t\tpersistentTempBucketFactory.completedInit();\n\t\t\t\t// FIXME most of the work is done after this point on splitfile starter threads.\n\t\t\t\t// So do we want to make a fuss?\n\t\t\t\t// FIXME but a better solution is real request resuming.\n\t\t\t\tLogger.normal(this, \"Completed startup: All persistent requests resumed or restarted\");\n\t\t\t\talerts.unregister(startingUpAlert);\n\t\t\t}\n\n\t\t\tpublic int getPriority() {\n\t\t\t\treturn NativeThread.LOW_PRIORITY;\n\t\t\t}\n\t\t}, \"Startup completion thread\");\n\t\t\n\t\tqueue(startupJobRunner, NativeThread.HIGH_PRIORITY, false);\n\t}","id":97634,"modified_method":"public void start(Config config) throws NodeInitException {\n\t\tbackgroundBlockEncoder.setContext(clientContext);\n\t\tnode.executor.execute(backgroundBlockEncoder, \"Background block encoder\");\n\t\tclientContext.jobRunner.queue(new DBJob() {\n\t\t\t\n\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\tArchiveManager.init(container, context, context.nodeDBHandle);\n\t\t\t}\n\t\t\t\n\t\t}, NativeThread.NORM_PRIORITY, false);\n\t\tpersister.start();\n\t\t\n\t\tstoreChecker.start(node.executor, \"Datastore checker\");\n\t\tclientDatabaseExecutor.start(node.executor, \"Client database access thread\");\n\t\tif(fcpServer != null)\n\t\t\tfcpServer.maybeStart();\n\t\tif(tmci != null)\n\t\t\ttmci.start();\n\n\t\tnode.executor.execute(new PrioRunnable() {\n\n\t\t\tpublic void run() {\n\t\t\t\tLogger.normal(this, \"Resuming persistent requests\");\n\t\t\t\t// Call it anyway; if we are not lazy, it won't have to start any requests\n\t\t\t\t// But it does other things too\n\t\t\t\tfcpServer.finishStart();\n\t\t\t\tpersistentTempBucketFactory.completedInit();\n\t\t\t\t// FIXME most of the work is done after this point on splitfile starter threads.\n\t\t\t\t// So do we want to make a fuss?\n\t\t\t\t// FIXME but a better solution is real request resuming.\n\t\t\t\tLogger.normal(this, \"Completed startup: All persistent requests resumed or restarted\");\n\t\t\t\talerts.unregister(startingUpAlert);\n\t\t\t}\n\n\t\t\tpublic int getPriority() {\n\t\t\t\treturn NativeThread.LOW_PRIORITY;\n\t\t\t}\n\t\t}, \"Startup completion thread\");\n\t\t\n\t\tif(startupDatabaseJobs != null &&\n\t\t\t\tstartupDatabaseJobs.length > 0)\n\t\tqueue(startupJobRunner, NativeThread.HIGH_PRIORITY, false);\n\t}","commit_id":"a9b5e1c888aa77ac5577a1a2af53f94d9a7b92f7","url":"https://github.com/freenet/fred"},{"original_method":"synchronized void clear() {\n\t\tsegments.clear();\n\t}","id":97635,"modified_method":"synchronized void clear() {\n\t\tdbJobRunner.runBlocking(new DBJob() {\n\n\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\tfor(SegmentedChainBucketSegment segment : segments) {\n\t\t\t\t\tcontainer.activate(segment, 1);\n\t\t\t\t\tsegment.clear(container, context);\n\t\t\t\t}\n\t\t\t\tcontainer.delete(SegmentedBucketChainBucket.class);\n\t\t\t}\n\t\t\t\n\t\t}, NativeThread.HIGH_PRIORITY);\n\t\tsegments.clear();\n\t}","commit_id":"a9b5e1c888aa77ac5577a1a2af53f94d9a7b92f7","url":"https://github.com/freenet/fred"},{"original_method":"public void run(ObjectContainer container, ClientContext context) {\n\t\tcontainer.activate(bcb, 1);\n\t\tif(bcb.stored) return;\n\t\tSystem.err.println(\"Freeing unfinished unstored bucket \"+this);\n\t\tbcb.removeFrom(container);\n\t}","id":97636,"modified_method":"public void run(ObjectContainer container, ClientContext context) {\n\t\tcontainer.activate(bcb, 1);\n\t\tSystem.err.println(\"Freeing unfinished unstored bucket \"+this);\n\t\tbcb.removeFrom(container);\n\t}","commit_id":"a9b5e1c888aa77ac5577a1a2af53f94d9a7b92f7","url":"https://github.com/freenet/fred"},{"original_method":"public void removeFetchingKey(Key key) {\n\t\tschedCore.removeFetchingKey(key);\n\t}","id":97637,"modified_method":"public void removeFetchingKey(Key key, ChosenRequest req) {\n\t\tschedCore.removeFetchingKey(key, req);\n\t}","commit_id":"3b8b0f86db122feb3fed6ee0a2770044858a8c0c","url":"https://github.com/freenet/fred"},{"original_method":"public void removeFetchingKey(final Key key) {\n\t\tsynchronized(keysFetching) {\n\t\t\tkeysFetching.remove(key);\n\t\t}\n\t\tsched.clientContext.jobRunner.queue(new DBJob() {\n\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\tObjectSet results = container.query(new Predicate() {\n\t\t\t\t\tpublic boolean match(PersistentChosenRequest req) {\n\t\t\t\t\t\tif(req.core != ClientRequestSchedulerCore.this) return false;\n\t\t\t\t\t\treturn req.key.equals(key);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(results.hasNext()) {\n\t\t\t\t\tPersistentChosenRequest req = (PersistentChosenRequest) results.next();\n\t\t\t\t\tcontainer.delete(req);\n\t\t\t\t\tcontainer.commit();\n\t\t\t\t}\n\t\t\t}\n\t\t}, NativeThread.NORM_PRIORITY, false);\n\t}","id":97638,"modified_method":"public void removeFetchingKey(final Key key, final ChosenRequest req) {\n\t\tif(key != null) {\n\t\tsynchronized(keysFetching) {\n\t\t\tkeysFetching.remove(key);\n\t\t}\n\t\t}\n\t\tif(req != null && req.isPersistent()) {\n\t\tsched.clientContext.jobRunner.queue(new DBJob() {\n\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\tcontainer.delete(req);\n\t\t\t}\n\t\t}, NativeThread.NORM_PRIORITY+1, false);\n\t\t}\n\t}","commit_id":"3b8b0f86db122feb3fed6ee0a2770044858a8c0c","url":"https://github.com/freenet/fred"},{"original_method":"public void run() {\n\t\t\ttry {\n\t\t    freenet.support.Logger.OSThread.logPID(this);\n\t\t    if(!req.send(core, sched)) {\n\t\t\t\tif((!req.isPersistent()) && req.request.isCancelled(null))\n\t\t\t\t\tLogger.error(this, \"run() not able to send a request on \"+req);\n\t\t\t\telse\n\t\t\t\t\tLogger.normal(this, \"run() not able to send a request on \"+req+\" - request was cancelled\");\n\t\t\t}\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this)) \n\t\t\t\tLogger.minor(this, \"Finished \"+req);\n\t\t\t} finally {\n\t\t\t\tif(!isInsert) {\n\t\t\t\t\tsched.removeFetchingKey(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":97639,"modified_method":"public void run() {\n\t\t\ttry {\n\t\t    freenet.support.Logger.OSThread.logPID(this);\n\t\t    if(!req.send(core, sched)) {\n\t\t\t\tif((!req.isPersistent()) && req.request.isCancelled(null))\n\t\t\t\t\tLogger.error(this, \"run() not able to send a request on \"+req);\n\t\t\t\telse\n\t\t\t\t\tLogger.normal(this, \"run() not able to send a request on \"+req+\" - request was cancelled\");\n\t\t\t}\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this)) \n\t\t\t\tLogger.minor(this, \"Finished \"+req);\n\t\t\t} finally {\n\t\t\t\t\tsched.removeFetchingKey(key, req);\n\t\t\t}\n\t\t}","commit_id":"3b8b0f86db122feb3fed6ee0a2770044858a8c0c","url":"https://github.com/freenet/fred"},{"original_method":"private boolean startRequest(ChosenRequest req, boolean logMINOR) {\n\t\tif((!req.isPersistent()) && req.request.isCancelled(null)) {\n\t\t\tsched.removeFetchingKey(req.key);\n\t\t\treturn false;\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Running request \"+req+\" priority \"+req.prio);\n\t\tcore.getExecutor().execute(new SenderThread(req, req.key), \"RequestStarter$SenderThread for \"+req);\n\t\treturn true;\n\t}","id":97640,"modified_method":"private boolean startRequest(ChosenRequest req, boolean logMINOR) {\n\t\tif((!req.isPersistent()) && req.request.isCancelled(null)) {\n\t\t\tsched.removeFetchingKey(req.key, req);\n\t\t\treturn false;\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Running request \"+req+\" priority \"+req.prio);\n\t\tcore.getExecutor().execute(new SenderThread(req, req.key), \"RequestStarter$SenderThread for \"+req);\n\t\treturn true;\n\t}","commit_id":"3b8b0f86db122feb3fed6ee0a2770044858a8c0c","url":"https://github.com/freenet/fred"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  @Nullable\n  public static JComponent getPreviewComponent(@NotNull final PsiElement element) {\n    if (element.getParent() instanceof XmlAttributeValue) {\n      final PsiElement parentParent = element.getParent().getParent();\n      if (parentParent instanceof XmlAttribute) {\n        XmlAttribute attribute = (XmlAttribute)parentParent;\n        String attrName = attribute.getName();\n        if (\"alink\".equals(attrName) || \"link\".equals(attrName) | \"text\".equals(attrName) || \"vlink\".equals(attrName) ||\n            \"bgcolor\".equals(attrName) || \"color\".equals(attrName)) {\n          String s = element.getText();\n          if (s.length() > 0) {\n            final String hexColor = (s.charAt(0) == '#') ? s : ColorSampleLookupValue.getHexCodeForColorName(s);\n            if (hexColor != null) {\n              try {\n                return new ColorPreviewComponent(null, Color.decode(\"0x\" + hexColor.substring(1)));\n              }\n              catch (NumberFormatException e) {\n                return null;\n              }\n            }\n          }\n        }\n      }\n    }\n    else {\n      final Color color = CssUtil.getColor(element);\n      if (color != null) {\n        try {\n          return new ColorPreviewComponent(null, color);\n        }\n        catch (NumberFormatException e) {\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }","id":97641,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  @Nullable\n  public static JComponent getPreviewComponent(@NotNull final PsiElement element) {\n    final PsiNewExpression psiNewExpression = PsiTreeUtil.getParentOfType(element, PsiNewExpression.class);\n    if (psiNewExpression != null) {\n      final PsiJavaCodeReferenceElement referenceElement = PsiTreeUtil.getChildOfType(psiNewExpression, PsiJavaCodeReferenceElement.class);\n      if (referenceElement != null) {\n        final PsiReference reference = referenceElement.getReference();\n        if (reference != null) {\n          final PsiElement psiElement = reference.resolve();\n          if (psiElement instanceof PsiClass && \"java.awt.Color\".equals(((PsiClass)psiElement).getQualifiedName())) {\n            final PsiExpression[] expressions = psiNewExpression.getArgumentList().getExpressions();\n            int[] values = new int[expressions.length];\n            float[] values2 = new float[expressions.length];\n            int i = 0;\n            int j = 0;\n            for (final PsiExpression each : expressions) {\n              if (each instanceof PsiLiteralExpression) {\n                final Object o = ((PsiLiteralExpression)each).getValue();\n                if (o instanceof Integer) {\n                  values[i] = ((Integer)o).intValue();\n                  i++;\n                } else if (o instanceof Float) {\n                  values2[j] = ((Float)o).floatValue();\n                  j++;\n                }\n              }\n            }\n\n            Color c = null;\n            if (i == expressions.length) {\n              switch (values.length) {\n                case 1:\n                  c = new Color(values[0]);\n                  break;\n                case 3:\n                  c = new Color(values[0], values[1], values[2]);\n                  break;\n                case 4:\n                  c = new Color(values[0], values[1], values[2], values[3]);\n                  break;\n                default:\n                  break;\n              }\n            } else if (j == expressions.length) {\n              switch (values2.length) {\n                case 3:\n                  c = new Color(values2[0], values2[1], values2[2]);\n                  break;\n                case 4:\n                  c = new Color(values2[0], values2[1], values2[2], values2[3]);\n                  break;\n                default:\n                  break;\n              }\n            }\n\n            if (c != null) {\n              return new ColorPreviewComponent(null, c);\n            }\n          }\n        }\n      }\n    }\n\n    if (StandardPatterns.psiElement(PsiIdentifier.class).withParent(StandardPatterns.psiElement(PsiReferenceExpression.class))\n      .accepts(element)) {\n      final PsiReference reference = element.getParent().getReference();\n      if (reference != null) {\n        final PsiElement psiElement = reference.resolve();\n        if (psiElement instanceof PsiField) {\n          if (\"java.awt.Color\".equals(((PsiField)psiElement).getContainingClass().getQualifiedName())) {\n            final String colorName = ((PsiField)psiElement).getName().toLowerCase().replace(\"_\", \"\");\n            final String hex = ColorSampleLookupValue.getHexCodeForColorName(colorName);\n            return new ColorPreviewComponent(null, Color.decode(\"0x\" + hex.substring(1)));\n          }\n        }\n      }\n    }\n\n\n    if (element.getParent() instanceof XmlAttributeValue) {\n      final PsiElement parentParent = element.getParent().getParent();\n      if (parentParent instanceof XmlAttribute) {\n        XmlAttribute attribute = (XmlAttribute)parentParent;\n        String attrName = attribute.getName();\n        if (\"alink\".equals(attrName) || \"link\".equals(attrName) | \"text\".equals(attrName) || \"vlink\".equals(attrName) ||\n            \"bgcolor\".equals(attrName) || \"color\".equals(attrName)) {\n          String s = element.getText();\n          if (s.length() > 0) {\n            final String hexColor = (s.charAt(0) == '#') ? s : ColorSampleLookupValue.getHexCodeForColorName(s);\n            if (hexColor != null) {\n              try {\n                return new ColorPreviewComponent(null, Color.decode(\"0x\" + hexColor.substring(1)));\n              }\n              catch (NumberFormatException e) {\n                return null;\n              }\n            }\n          }\n        }\n      }\n    }\n    else {\n      final Color color = CssUtil.getColor(element);\n      if (color != null) {\n        try {\n          return new ColorPreviewComponent(null, color);\n        }\n        catch (NumberFormatException e) {\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"4e28ed096f6c95a574f784a61ee3b5d9a26d7633","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ColorPreviewComponent(final String hexValue, final Color color) {\n    super(new BorderLayout());\n\n    setBorder(BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(Color.black), BorderFactory.createEmptyBorder(5, 5, 5, 5)));\n\n    setBackground(color);\n    setOpaque(true);\n\n    add(new ColorComponent(color), BorderLayout.CENTER);\n    if (hexValue != null) {\n      final JLabel label = new JLabel('#' + hexValue);\n      label.setFont(UIUtil.getToolTipFont());\n      label.setForeground(Color.RGBtoHSB(color.getRed(), color.getGreen(), color.getBlue(), null)[2] >= 0.5f ? Color.BLACK : Color.WHITE);\n      add(label, BorderLayout.SOUTH);\n    }\n  }","id":97642,"modified_method":"private ColorPreviewComponent(final String hexValue, final Color color) {\n    myColor = color;\n    setOpaque(true);\n\n/*    if (hexValue != null) {\n      final JLabel label = new JLabel('#' + hexValue);\n      label.setFont(UIUtil.getToolTipFont());\n      label.setForeground(Color.RGBtoHSB(color.getRed(), color.getGreen(), color.getBlue(), null)[2] >= 0.5f ? Color.BLACK : Color.WHITE);\n      add(label, BorderLayout.SOUTH);\n    } */\n  }","commit_id":"4e28ed096f6c95a574f784a61ee3b5d9a26d7633","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dispose() {\n    if (myEditor != null) {\n      myEditor.removeEditorMouseMotionListener(this);\n    }\n\n    if (myQueue != null) {\n      myQueue.cancelAllUpdates();\n      myQueue.hideNotify();\n    }\n\n    myQueue = null;\n    myEditor = null;\n    myFile = null;\n    myHint = null;\n  }","id":97643,"modified_method":"public void dispose() {\n    if (myEditor != null) {\n      myEditor.removeEditorMouseMotionListener(this);\n      myEditor.getContentComponent().removeKeyListener(this);\n    }\n\n    if (myQueue != null) {\n      myQueue.cancelAllUpdates();\n      myQueue.hideNotify();\n    }\n\n    myQueue = null;\n    myEditor = null;\n    myFile = null;\n    myHint = null;\n  }","commit_id":"4e28ed096f6c95a574f784a61ee3b5d9a26d7633","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setCurrentHint(final LightweightHint hint) {\n    if (hint != null) {\n      myHint = hint;\n    }\n  }","id":97644,"modified_method":"private void setCurrentHint(final LightweightHint hint, final PsiElement element) {\n    if (hint != null) {\n      myHint = hint;\n      myElement = element;\n    }\n  }","commit_id":"4e28ed096f6c95a574f784a61ee3b5d9a26d7633","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ImageOrColorPreviewManager(@NotNull final TextEditor editor) {\n    myEditor = editor.getEditor();\n\n    myEditor.addEditorMouseMotionListener(this);\n\n    Document document = myEditor.getDocument();\n    myFile = PsiDocumentManager.getInstance(myEditor.getProject()).getPsiFile(document);\n\n\n    final JComponent component = editor.getEditor().getComponent();\n    myQueue = new MergingUpdateQueue(\"ImageOrColorPreview\", 300, component.isShowing(), component);\n    Disposer.register(this, new UiNotifyConnector(editor.getComponent(), myQueue));\n  }","id":97645,"modified_method":"public ImageOrColorPreviewManager(@NotNull final TextEditor editor) {\n    myEditor = editor.getEditor();\n\n    myEditor.addEditorMouseMotionListener(this);\n    myEditor.getContentComponent().addKeyListener(this);\n\n    Document document = myEditor.getDocument();\n    myFile = PsiDocumentManager.getInstance(myEditor.getProject()).getPsiFile(document);\n\n\n    final JComponent component = editor.getEditor().getComponent();\n    myQueue = new MergingUpdateQueue(\"ImageOrColorPreview\", 100, component.isShowing(), component);\n    Disposer.register(this, new UiNotifyConnector(editor.getComponent(), myQueue));\n  }","commit_id":"4e28ed096f6c95a574f784a61ee3b5d9a26d7633","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void hideCurrentHintIfAny() {\n    if (myHint != null) {\n      myHint.hide();\n      myHint = null;\n    }\n  }","id":97646,"modified_method":"private void hideCurrentHintIfAny() {\n    if (myHint != null) {\n      myHint.hide();\n      myHint = null;\n      myElement = null;\n    }\n  }","commit_id":"4e28ed096f6c95a574f784a61ee3b5d9a26d7633","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void mouseMoved(EditorMouseEvent e) {\n    myQueue.cancelAllUpdates();\n    myQueue.queue(new PreviewUpdate(this, e.getMouseEvent().getPoint()));\n  }","id":97647,"modified_method":"public void mouseMoved(EditorMouseEvent e) {\n    myQueue.cancelAllUpdates();\n    if (myHint == null && e.getMouseEvent().getModifiers() == KeyEvent.CTRL_MASK) {\n      myQueue.queue(new PreviewUpdate(this, e.getMouseEvent().getPoint()));\n    }\n    else {\n      hideCurrentHindIfOutOfElement(getPsiElementAt(e.getMouseEvent().getPoint()));\n    }\n  }","commit_id":"4e28ed096f6c95a574f784a61ee3b5d9a26d7633","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void run() {\n      final PsiElement element = myManager.getPsiElementAt(myPoint);\n      if (element != null && element.isValid()) {\n        final LightweightHint hint = ImageOrColorPreviewManager.getHint(element);\n        myManager.setCurrentHint(hint);\n        if (hint != null) {\n          final Editor editor = myManager.getEditor();\n          if (editor != null) {\n            HintManager.getInstance().showEditorHint(hint, editor, HintManager.getHintPosition(hint, editor,\n                                                                                               myManager.getLogicalPosition(element),\n                                                                                               HintManager.RIGHT_UNDER), HintManager\n              .HIDE_BY_ANY_KEY | HintManager.HIDE_BY_OTHER_HINT | HintManager.HIDE_BY_SCROLLING | HintManager.HIDE_BY_TEXT_CHANGE |\n                               HintManager.HIDE_IF_OUT_OF_EDITOR, 0, false);\n          }\n        }\n        else {\n          myManager.hideCurrentHintIfAny();\n        }\n      }\n    }","id":97648,"modified_method":"public void run() {\n      final PsiElement element = myManager.getPsiElementAt(myPoint);\n      if (element != null && element.isValid()) {\n        final LightweightHint hint = ImageOrColorPreviewManager.getHint(element);\n        if (hint != null) {\n          final Editor editor = myManager.getEditor();\n          if (editor != null) {\n            myManager.showHint(hint, element, editor);\n          }\n        }\n        else {\n          myManager.hideCurrentHintIfAny();\n        }\n      }\n    }","commit_id":"4e28ed096f6c95a574f784a61ee3b5d9a26d7633","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isSuitable(final Project project, final VirtualFile file) {\n      final PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n      return psiFile != null && (psiFile instanceof XmlFile || psiFile instanceof CssFile);\n    }","id":97649,"modified_method":"private static boolean isSuitable(final Project project, final VirtualFile file) {\n      final PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n      return psiFile != null && (psiFile instanceof XmlFile || psiFile instanceof CssFile || psiFile instanceof PsiJavaFile);\n    }","commit_id":"4e28ed096f6c95a574f784a61ee3b5d9a26d7633","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  @Nullable\n  public static JComponent getPreviewComponent(@NotNull final PsiElement element) {\n    CssTerm term = PsiTreeUtil.getParentOfType(element, CssTerm.class, false);\n    if (term != null && CssTermTypes.URI == term.getTermType()) {\n      PsiElement parent = element;\n      while (parent != term) {\n        final JComponent c = _getPreviewComponent(parent);\n        if (c != null) {\n          return c;\n        }\n\n        parent = parent.getParent();\n      }\n    }\n    else if (element.getParent() instanceof XmlAttributeValue) {\n      final PsiElement attributeValue = element.getParent();\n      if (attributeValue.getParent() instanceof XmlAttribute) {\n        XmlAttribute attribute = (XmlAttribute)attributeValue.getParent();\n        String attrName = attribute.getName();\n        if (\"background\".equals(attrName) || \"src\".equals(attrName)) {\n          PsiElement parent = element;\n          while (parent != attribute) {\n            final JComponent c = _getPreviewComponent(parent);\n            if (c != null) {\n              return c;\n            }\n\n            parent = parent.getParent();\n          }\n        }\n      }\n    }\n\n    return null;\n  }","id":97650,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  @Nullable\n  public static JComponent getPreviewComponent(@NotNull final PsiElement element) {\n    if (StandardPatterns.psiElement().withParent(StandardPatterns.psiElement(PsiLiteralExpression.class)).accepts(element)) {\n      final PsiLiteralExpression psiLiteralExpression = (PsiLiteralExpression) element.getParent();\n      if (psiLiteralExpression != null) {\n        return _getPreviewComponent(psiLiteralExpression);\n      }\n    }\n\n    CssTerm term = PsiTreeUtil.getParentOfType(element, CssTerm.class, false);\n    if (term != null && CssTermTypes.URI == term.getTermType()) {\n      PsiElement parent = element;\n      while (parent != term) {\n        final JComponent c = _getPreviewComponent(parent);\n        if (c != null) {\n          return c;\n        }\n\n        parent = parent.getParent();\n      }\n    }\n    else if (element.getParent() instanceof XmlAttributeValue) {\n      final PsiElement attributeValue = element.getParent();\n      if (attributeValue.getParent() instanceof XmlAttribute) {\n        XmlAttribute attribute = (XmlAttribute)attributeValue.getParent();\n        String attrName = attribute.getName();\n        if (\"background\".equals(attrName) || \"src\".equals(attrName) || \"href\".equals(attrName)) {\n          PsiElement parent = element;\n          while (parent != attribute) {\n            final JComponent c = _getPreviewComponent(parent);\n            if (c != null) {\n              return c;\n            }\n\n            parent = parent.getParent();\n          }\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"4e28ed096f6c95a574f784a61ee3b5d9a26d7633","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = (Project)e.getDataContext().getData(DataConstants.PROJECT);\n    if (project != null){\n      final FavoritesTreeViewPanel favoritesTreeViewPanel = doAddNewFavoritesList(project);\n      final ToolWindowManager windowManager = ToolWindowManager.getInstance(project);\n      windowManager.getToolWindow(ToolWindowId.FAVORITES_VIEW).activate(null);\n      final FavoritesViewImpl favoritesView = FavoritesViewImpl.getInstance(project);\n      favoritesView.setSelectedContent(favoritesView.getContent(favoritesTreeViewPanel));\n    }\n  }","id":97651,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = (Project)e.getDataContext().getData(DataConstants.PROJECT);\n    if (project != null){\n      final FavoritesTreeViewPanel favoritesTreeViewPanel = doAddNewFavoritesList(project);\n      if (favoritesTreeViewPanel != null) {\n        final ToolWindowManager windowManager = ToolWindowManager.getInstance(project);\n        windowManager.getToolWindow(ToolWindowId.FAVORITES_VIEW).activate(null);\n        final FavoritesViewImpl favoritesView = FavoritesViewImpl.getInstance(project);\n        favoritesView.setSelectedContent(favoritesView.getContent(favoritesTreeViewPanel));\n      }\n    }\n  }","commit_id":"9b68dc11c867ced5590d96900b2fcc62aa5f869c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static FavoritesTreeViewPanel doAddNewFavoritesList(final Project project) {\n    final String s =\n      Messages.showInputDialog(project, \"Input new favorites list name\", \"Add New Favorites List\", Messages.getInformationIcon(), \"new\",\n                               new InputValidator() {\n                                     public boolean checkInput(String inputString) {\n                                       return inputString != null && inputString.trim().length() > 0;\n                      }\n\n                                     public boolean canClose(String inputString) {\n                                       final boolean alreadyContains = ArrayUtil.find(FavoritesViewImpl.getInstance(project).getAvailableFavoritesLists(), inputString.trim()) == -1;\n                                       return inputString.trim().length() > 0 && alreadyContains;\n                      }\n                    });\n    final FavoritesViewImpl favoritesView = FavoritesViewImpl.getInstance(project);\n    return favoritesView.addNewFavoritesList(s);\n  }","id":97652,"modified_method":"public static FavoritesTreeViewPanel doAddNewFavoritesList(final Project project) {\n    final String s =\n      Messages.showInputDialog(project, \"Input new favorites list name\", \"Add New Favorites List\", Messages.getInformationIcon(), \"new\",\n                               new InputValidator() {\n                                     public boolean checkInput(String inputString) {\n                                       return inputString != null && inputString.trim().length() > 0;\n                      }\n\n                                     public boolean canClose(String inputString) {\n                                       final boolean alreadyContains = ArrayUtil.find(FavoritesViewImpl.getInstance(project).getAvailableFavoritesLists(), inputString.trim()) == -1;\n                                       return inputString.trim().length() > 0 && alreadyContains;\n                      }\n                    });\n    if (s == null || s.length() == 0) return null;\n    final FavoritesViewImpl favoritesView = FavoritesViewImpl.getInstance(project);\n    return favoritesView.addNewFavoritesList(s);\n  }","commit_id":"9b68dc11c867ced5590d96900b2fcc62aa5f869c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private AbstractTreeNode[] createNodes(DataContext dataContext, boolean inProjectView) {\n    ArrayList<AbstractTreeNode> result = new ArrayList<AbstractTreeNode>();\n    Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n    final FavoritesTreeViewConfiguration favoritesConfig = FavoritesViewImpl.getInstance(project).getFavoritesTreeViewPanel(myFavoritesList).getFavoritesTreeStructure().getFavoritesConfiguration();\n    final PsiManager psiManager = PsiManager.getInstance(project);\n\n    final String currentViewId = ProjectView.getInstance(project).getCurrentViewId();\n    AbstractProjectViewPane pane = ProjectView.getInstance(project).getProjectViewPaneById(currentViewId);\n    \n    //on psi element\n    PsiElement psiElement = (PsiElement)dataContext.getData(DataConstants.PSI_ELEMENT);\n    if (psiElement == null && dataContext.getData(DataConstants.PSI_FILE) != null){\n      psiElement = (PsiElement)dataContext.getData(DataConstants.PSI_FILE);\n    }\n    if (psiElement != null){\n      Module containingModule = null;\n      if (inProjectView && ProjectView.getInstance(project).isShowModules(currentViewId)){\n        if (pane.getSelectedDescriptor() != null && pane.getSelectedDescriptor().getElement() instanceof AbstractTreeNode) {\n          AbstractTreeNode abstractTreeNode = ((AbstractTreeNode)pane.getSelectedDescriptor().getElement());\n          while (abstractTreeNode != null && !(abstractTreeNode.getParent() instanceof AbstractModuleNode)){\n            abstractTreeNode = abstractTreeNode.getParent();\n          }\n          if (abstractTreeNode != null){\n            containingModule = ((AbstractModuleNode)abstractTreeNode.getParent()).getValue();\n          }\n        }\n      }\n      addPsiElementNode(psiElement, project, result, favoritesConfig, containingModule);\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n    \n    //on psi elements\n    final PsiElement[] psiElements = (PsiElement[])dataContext.getData(DataConstantsEx.PSI_ELEMENT_ARRAY);\n    if (psiElements != null) {\n      for (int i = 0; i < psiElements.length; i++) {\n        addPsiElementNode(psiElements[i], project, result, favoritesConfig, (Module)dataContext.getData(DataConstants.MODULE_CONTEXT));\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on module groups\n    ModuleGroup[] moduleGroups = (ModuleGroup[])dataContext.getData(DataConstantsEx.MODULE_GROUP_ARRAY);\n    if (moduleGroups != null) {\n      boolean isPackageView = false;\n      if (currentViewId.equals(PackageViewPane.ID)) {\n        isPackageView = true;\n      }\n      for (int i = 0; i < moduleGroups.length; i++) {\n        ModuleGroup moduleGroup = moduleGroups[i];\n        if (isPackageView){\n          result.add(new PackageViewModuleGroupNode(project, moduleGroup, favoritesConfig));\n        } else {\n          result.add(new ProjectViewModuleGroupNode(project, moduleGroup, favoritesConfig));\n        }\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on module node\n    Module module = (Module)dataContext.getData(DataConstants.MODULE);\n    if (module != null) {\n      if (currentViewId.equals(PackageViewPane.ID)) {\n        result.add(new PackageViewModuleNode(project, module, favoritesConfig));\n      }\n      else {\n        result.add(new ProjectViewModuleNode(project, module, favoritesConfig));\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on module nodes\n    Module[] modules = (Module[])dataContext.getData(DataConstants.MODULE_CONTEXT_ARRAY);\n    if (modules != null) {\n      for (int i = 0; i < modules.length; i++) {\n        if (currentViewId.equals(PackageViewPane.ID)) {\n          result.add(new PackageViewModuleNode(project, modules[i], favoritesConfig));\n        }\n        else {\n          result.add(new ProjectViewModuleNode(project, modules[i], favoritesConfig));\n        }\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on form in editor\n    final VirtualFile vFile = (VirtualFile)dataContext.getData(DataConstants.VIRTUAL_FILE);\n    if (vFile != null) {\n      final FileType fileType = FileTypeManager.getInstance().getFileTypeByFile(vFile);\n      if (StdFileTypes.GUI_DESIGNER_FORM.equals(fileType)) {\n        final PsiFile formFile = psiManager.findFile(vFile);\n        String text = formFile.getText();\n        LwRootContainer container;\n        try {\n          container = Utils.getRootContainer(text, null);\n        }\n        catch (Exception e) {\n          return null;\n        }\n        final PsiClass classToBind = psiManager.findClass(container.getClassToBind(), GlobalSearchScope.allScope(project));\n        result.add(FormNode.constructFormNode(psiManager, classToBind, project, favoritesConfig));\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on form nodes\n    final Form[] forms = (Form[])dataContext.getData(DataConstantsEx.GUI_DESIGNER_FORM_ARRAY);\n    if (forms != null) {\n      Set<PsiClass> bindClasses = new HashSet<PsiClass>();\n      for (int i = 0; i < forms.length; i++) {\n        Form form = forms[i];\n        final PsiClass classToBind = form.getClassToBind();\n        if (bindClasses.contains(classToBind)) continue;\n        bindClasses.add(classToBind);\n        result.add(FormNode.constructFormNode(psiManager, classToBind, project, favoritesConfig));\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on library group node\n    final LibraryGroupElement[] libraryGroups = (LibraryGroupElement[])dataContext.getData(DataConstantsEx.LIBRARY_GROUP_ARRAY);\n    if (libraryGroups != null){\n      for (int i = 0; i < libraryGroups.length; i++) {\n        LibraryGroupElement libraryGroup = libraryGroups[i];\n        result.add(new LibraryGroupNode(project, libraryGroup, favoritesConfig));\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on named library node\n    final NamedLibraryElement[] namedLibraries = (NamedLibraryElement[])dataContext.getData(DataConstantsEx.NAMED_LIBRARY_ARRAY);\n    if (namedLibraries != null){\n      for (int i = 0; i < namedLibraries.length; i++) {\n        NamedLibraryElement namedLibrary = namedLibraries[i];\n        result.add(new NamedLibraryElementNode(project, namedLibrary, favoritesConfig));\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n    return null;\n  }","id":97653,"modified_method":"private AbstractTreeNode[] createNodes(DataContext dataContext, boolean inProjectView) {\n    ArrayList<AbstractTreeNode> result = new ArrayList<AbstractTreeNode>();\n    Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n    final FavoritesTreeViewConfiguration favoritesConfig = FavoritesViewImpl.getInstance(project).getFavoritesTreeViewPanel(myFavoritesList).getFavoritesTreeStructure().getFavoritesConfiguration();\n    final PsiManager psiManager = PsiManager.getInstance(project);\n\n    final String currentViewId = ProjectView.getInstance(project).getCurrentViewId();\n    AbstractProjectViewPane pane = ProjectView.getInstance(project).getProjectViewPaneById(currentViewId);\n\n    //on psi element\n    PsiElement psiElement = (PsiElement)dataContext.getData(DataConstants.PSI_ELEMENT);\n    if (psiElement == null && dataContext.getData(DataConstants.PSI_FILE) != null){\n      psiElement = (PsiElement)dataContext.getData(DataConstants.PSI_FILE);\n    }\n    if (psiElement != null){\n      Module containingModule = null;\n      if (inProjectView && ProjectView.getInstance(project).isShowModules(currentViewId)){\n        if (pane.getSelectedDescriptor() != null && pane.getSelectedDescriptor().getElement() instanceof AbstractTreeNode) {\n          AbstractTreeNode abstractTreeNode = ((AbstractTreeNode)pane.getSelectedDescriptor().getElement());\n          while (abstractTreeNode != null && !(abstractTreeNode.getParent() instanceof AbstractModuleNode)){\n            abstractTreeNode = abstractTreeNode.getParent();\n          }\n          if (abstractTreeNode != null){\n            containingModule = ((AbstractModuleNode)abstractTreeNode.getParent()).getValue();\n          }\n        }\n      }\n      addPsiElementNode(psiElement, project, result, favoritesConfig, containingModule);\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on psi elements\n    final PsiElement[] psiElements = (PsiElement[])dataContext.getData(DataConstantsEx.PSI_ELEMENT_ARRAY);\n    if (psiElements != null) {\n      for (int i = 0; i < psiElements.length; i++) {\n        addPsiElementNode(psiElements[i], project, result, favoritesConfig, (Module)dataContext.getData(DataConstants.MODULE_CONTEXT));\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on module groups\n    ModuleGroup[] moduleGroups = (ModuleGroup[])dataContext.getData(DataConstantsEx.MODULE_GROUP_ARRAY);\n    if (moduleGroups != null) {\n      boolean isPackageView = false;\n      if (currentViewId.equals(PackageViewPane.ID)) {\n        isPackageView = true;\n      }\n      for (int i = 0; i < moduleGroups.length; i++) {\n        ModuleGroup moduleGroup = moduleGroups[i];\n        if (isPackageView){\n          result.add(new PackageViewModuleGroupNode(project, moduleGroup, favoritesConfig));\n        } else {\n          result.add(new ProjectViewModuleGroupNode(project, moduleGroup, favoritesConfig));\n        }\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on module node\n    Module module = (Module)dataContext.getData(DataConstants.MODULE);\n    if (module != null) {\n      if (currentViewId.equals(PackageViewPane.ID)) {\n        result.add(new PackageViewModuleNode(project, module, favoritesConfig));\n      }\n      else {\n        result.add(new ProjectViewModuleNode(project, module, favoritesConfig));\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on module nodes\n    Module[] modules = (Module[])dataContext.getData(DataConstants.MODULE_CONTEXT_ARRAY);\n    if (modules != null) {\n      for (int i = 0; i < modules.length; i++) {\n        if (currentViewId.equals(PackageViewPane.ID)) {\n          result.add(new PackageViewModuleNode(project, modules[i], favoritesConfig));\n        }\n        else {\n          result.add(new ProjectViewModuleNode(project, modules[i], favoritesConfig));\n        }\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on form in editor\n    final VirtualFile vFile = (VirtualFile)dataContext.getData(DataConstants.VIRTUAL_FILE);\n    if (vFile != null) {\n      final FileType fileType = FileTypeManager.getInstance().getFileTypeByFile(vFile);\n      if (StdFileTypes.GUI_DESIGNER_FORM.equals(fileType)) {\n        final PsiFile formFile = psiManager.findFile(vFile);\n        String text = formFile.getText();\n        String className;\n        try {\n          className = Utils.getBoundClassName(text);\n        }\n        catch (Exception e) {\n          return null;\n        }\n        final PsiClass classToBind = psiManager.findClass(className, GlobalSearchScope.allScope(project));\n        if (classToBind != null) {\n          result.add(FormNode.constructFormNode(psiManager, classToBind, project, favoritesConfig));\n        } else {\n          addPsiElementNode(formFile, project, result, favoritesConfig, module);\n        }\n      } else {\n        final PsiFile psiFile = psiManager.findFile(vFile);\n        addPsiElementNode(psiFile,\n                          project,\n                          result,\n                          favoritesConfig,\n                          (Module)dataContext.getData(DataConstants.MODULE_CONTEXT));\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on form nodes\n    final Form[] forms = (Form[])dataContext.getData(DataConstantsEx.GUI_DESIGNER_FORM_ARRAY);\n    if (forms != null) {\n      Set<PsiClass> bindClasses = new HashSet<PsiClass>();\n      for (int i = 0; i < forms.length; i++) {\n        Form form = forms[i];\n        final PsiClass classToBind = form.getClassToBind();\n        if (classToBind != null){\n          if (bindClasses.contains(classToBind)) continue;\n          bindClasses.add(classToBind);\n          result.add(FormNode.constructFormNode(psiManager, classToBind, project, favoritesConfig));\n        } else {\n          //can't be on FormNodes\n        }\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on library group node\n    final LibraryGroupElement[] libraryGroups = (LibraryGroupElement[])dataContext.getData(DataConstantsEx.LIBRARY_GROUP_ARRAY);\n    if (libraryGroups != null){\n      for (int i = 0; i < libraryGroups.length; i++) {\n        LibraryGroupElement libraryGroup = libraryGroups[i];\n        result.add(new LibraryGroupNode(project, libraryGroup, favoritesConfig));\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n\n    //on named library node\n    final NamedLibraryElement[] namedLibraries = (NamedLibraryElement[])dataContext.getData(DataConstantsEx.NAMED_LIBRARY_ARRAY);\n    if (namedLibraries != null){\n      for (int i = 0; i < namedLibraries.length; i++) {\n        NamedLibraryElement namedLibrary = namedLibraries[i];\n        result.add(new NamedLibraryElementNode(project, namedLibrary, favoritesConfig));\n      }\n      return result.isEmpty() ? null : result.toArray(new AbstractTreeNode[result.size()]);\n    }\n    return null;\n  }","commit_id":"9b68dc11c867ced5590d96900b2fcc62aa5f869c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addPsiElementNode(final PsiElement psiElement,\n                                 final Project project,\n                                 final ArrayList<AbstractTreeNode> result,\n                                 final FavoritesTreeViewConfiguration favoritesConfig,\n                                 Module module) {\n    final Class <? extends AbstractTreeNode> klass = getPsiElementNodeClass(psiElement);\n    final Object value = getPsiElementNodeValue(psiElement, project, module);\n    try {\n      if (klass != null && value != null) {\n        result.add(ProjectViewNode.createTreeNode(klass, project, value, favoritesConfig));\n      }\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n  }","id":97654,"modified_method":"public static void addPsiElementNode(PsiElement psiElement,\n                                       final Project project,\n                                       final ArrayList<AbstractTreeNode> result,\n                                       final FavoritesTreeViewConfiguration favoritesConfig,\n                                       Module module) {\n    Class <? extends AbstractTreeNode> klass = getPsiElementNodeClass(psiElement);\n    if (klass == null){\n      psiElement = PsiTreeUtil.getParentOfType(psiElement, PsiFile.class);\n      if (psiElement != null){\n        klass = PsiFileNode.class;\n      }\n    }\n    final Object value = getPsiElementNodeValue(psiElement, project, module);\n    try {\n      if (klass != null && value != null) {\n        result.add(ProjectViewNode.createTreeNode(klass, project, value, favoritesConfig));\n      }\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n  }","commit_id":"9b68dc11c867ced5590d96900b2fcc62aa5f869c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(AnActionEvent e) {\n    removeAll();\n    final Project project = (Project)e.getDataContext().getData(DataConstants.PROJECT);\n    if (project == null){\n      return;\n    }\n    final String[] availableFavoritesLists = FavoritesViewImpl.getInstance(project).getAvailableFavoritesLists();\n    for (int i = 0; i < availableFavoritesLists.length; i++) {\n      String favoritesList = availableFavoritesLists[i];\n      add(new AddToFavoritesAction(favoritesList));\n    }\n    addSeparator();\n    add(new AddToNewFavoritesListAction());\n  }","id":97655,"modified_method":"public void update(AnActionEvent e) {\n    removeAll();\n    final Project project = (Project)e.getDataContext().getData(DataConstants.PROJECT);\n    if (project == null){\n      return;\n    }\n    final String[] availableFavoritesLists = FavoritesViewImpl.getInstance(project).getAvailableFavoritesLists();\n    for (int i = 0; i < availableFavoritesLists.length; i++) {\n      String favoritesList = availableFavoritesLists[i];\n      add(new AddToFavoritesAction(favoritesList));\n    }\n    addSeparator();\n    add(new AddToNewFavoritesListAction());\n    e.getPresentation().setEnabled(true);\n  }","commit_id":"9b68dc11c867ced5590d96900b2fcc62aa5f869c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n   final DataContext dataContext = e.getDataContext();\n   final AddNewFavoritesListAction action = (AddNewFavoritesListAction)ActionManager.getInstance().getAction(IdeActions.ADD_NEW_FAVORITES_LIST);\n   final FavoritesTreeViewPanel favoritesTreeViewPanel = action.doAddNewFavoritesList((Project)dataContext.getData(DataConstants.PROJECT));\n   new AddToFavoritesAction(favoritesTreeViewPanel.getName()).actionPerformed(e);\n }","id":97656,"modified_method":"public void actionPerformed(AnActionEvent e) {\n   final DataContext dataContext = e.getDataContext();\n   final AddNewFavoritesListAction action = (AddNewFavoritesListAction)ActionManager.getInstance().getAction(IdeActions.ADD_NEW_FAVORITES_LIST);\n   final FavoritesTreeViewPanel favoritesTreeViewPanel = action.doAddNewFavoritesList((Project)dataContext.getData(DataConstants.PROJECT));\n   if (favoritesTreeViewPanel != null) {\n     new AddToFavoritesAction(favoritesTreeViewPanel.getName()).actionPerformed(e);\n   }\n }","commit_id":"9b68dc11c867ced5590d96900b2fcc62aa5f869c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void initFavoritesList() {\n    for (Iterator<AbstractUrl> iterator = myAbstractUrls.keySet().iterator(); iterator.hasNext();) {\n      AbstractUrl abstractUrl = iterator.next();\n      final Object[] path = abstractUrl.createPath(myProject);\n      if (path == null || path.length < 1){\n        continue;\n      }\n      try {\n        if (abstractUrl instanceof FormUrl){\n          final PsiManager psiManager = PsiManager.getInstance(myProject);\n          myFavorites.add(FormNode.constructFormNode(psiManager, (PsiClass)path[0], myProject, myFavoritesConfiguration));\n        } else {\n          myFavorites.add(ProjectViewNode.createTreeNode(Class.forName(myAbstractUrls.get(abstractUrl)), myProject, path[path.length - 1],\n                                                         myFavoritesConfiguration));\n        }\n      }\n      catch (Exception e) {\n      }\n    }\n  }","id":97657,"modified_method":"public void initFavoritesList() {\n    for (Iterator<AbstractUrl> iterator = myAbstractUrls.keySet().iterator(); iterator.hasNext();) {\n      AbstractUrl abstractUrl = iterator.next();\n      final Object[] path = abstractUrl.createPath(myProject);\n      if (path == null || path.length < 1 || path[0] == null ){\n        continue;\n      }\n      try {\n        if (abstractUrl instanceof FormUrl){\n          final PsiManager psiManager = PsiManager.getInstance(myProject);\n          myFavorites.add(FormNode.constructFormNode(psiManager, (PsiClass)path[0], myProject, myFavoritesConfiguration));\n        } else {\n          myFavorites.add(ProjectViewNode.createTreeNode(Class.forName(myAbstractUrls.get(abstractUrl)), myProject, path[path.length - 1],\n                                                         myFavoritesConfiguration));\n        }\n      }\n      catch (Exception e) {\n      }\n    }\n  }","commit_id":"9b68dc11c867ced5590d96900b2fcc62aa5f869c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private <T>List<T> getSelectedElements(Class<T> klass) {\n    final Object[] elements = getSelectedNodeElements();\n    ArrayList<T> result = new ArrayList<T>();\n    for (int i = 0; i < elements.length; i++) {\n      Object element = elements[i];\n      if (klass.isAssignableFrom(element.getClass())) {\n        result.add((T)element);\n      }\n    }\n    return result;\n  }","id":97658,"modified_method":"private <T>List<T> getSelectedElements(Class<T> klass) {\n    final Object[] elements = getSelectedNodeElements();\n    ArrayList<T> result = new ArrayList<T>();\n    if (elements == null){\n      return result;\n    }\n    for (int i = 0; i < elements.length; i++) {\n      Object element = elements[i];\n      if (klass.isAssignableFrom(element.getClass())) {\n        result.add((T)element);\n      }\n    }\n    return result;\n  }","commit_id":"9b68dc11c867ced5590d96900b2fcc62aa5f869c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void projectOpened() {\n    StartupManager.getInstance(myCurrentProject).registerPostStartupActivity(new Runnable() {\n      public void run() {\n        ToolWindowManager toolWindowManager = ToolWindowManager.getInstance(myCurrentProject);\n        ToolWindow toolWindow = toolWindowManager.registerToolWindow(ToolWindowId.FAVORITES_VIEW, getComponent(), ToolWindowAnchor.RIGHT);\n        toolWindow.setIcon(IconLoader.getIcon(\"/general/toolWindowFavorites.png\"));\n        new ContentManagerWatcher(toolWindow, FavoritesViewImpl.this);\n        final ContentFactory contentFactory = PeerFactory.getInstance().getContentFactory();\n        final DefaultActionGroup favoritesActionsGroup = ((DefaultActionGroup)ActionManager.getInstance().getAction(IdeActions.ADD_TO_FAVORITES));\n        favoritesActionsGroup.removeAll();        \n        if (myName2FavoritesListSet.isEmpty()){\n          final FavoritesTreeViewPanel panel = new FavoritesTreeViewPanel(myCurrentProject, null, myCurrentProject.getName());\n          final Content favoritesContent = contentFactory.createContent(panel, myCurrentProject.getName(), false);\n          addContent(favoritesContent);\n          final String key = myCurrentProject.getName();\n          myName2FavoritesListSet.put(key, favoritesContent);\n          myCurrentFavoritesList = key;\n          panel.getFavoritesTreeStructure().initFavoritesList();\n          final AddToFavoritesAction addAction = new AddToFavoritesAction(key);\n          myActions.put(key, addAction);\n          favoritesActionsGroup.add(addAction);\n        } else {\n          for (Iterator<String> iterator = myName2FavoritesListSet.keySet().iterator(); iterator.hasNext();) {\n            final String key = iterator.next();\n            final AddToFavoritesAction addAction = new AddToFavoritesAction(key);\n            myActions.put(key, addAction);\n            favoritesActionsGroup.add(addAction);\n            final Content content = myName2FavoritesListSet.get(key);\n            addContent(content);\n            ((FavoritesTreeViewPanel)content.getComponent()).getFavoritesTreeStructure().initFavoritesList();\n            if (key.equals(myCurrentFavoritesList)){\n              setSelectedContent(content);\n            }\n          }\n        }\n        favoritesActionsGroup.addSeparator();\n        favoritesActionsGroup.add(new AddToNewFavoritesListAction());\n      }\n    });\n  }","id":97659,"modified_method":"public void projectOpened() {\n    StartupManager.getInstance(myCurrentProject).registerPostStartupActivity(new Runnable() {\n      public void run() {\n        ToolWindowManager toolWindowManager = ToolWindowManager.getInstance(myCurrentProject);\n        ToolWindow toolWindow = toolWindowManager.registerToolWindow(ToolWindowId.FAVORITES_VIEW, getComponent(), ToolWindowAnchor.RIGHT);\n        toolWindow.setIcon(IconLoader.getIcon(\"/general/toolWindowFavorites.png\"));\n        new ContentManagerWatcher(toolWindow, FavoritesViewImpl.this);\n        final ContentFactory contentFactory = PeerFactory.getInstance().getContentFactory();\n        final ActionGroup favoritesActionsGroup = ((ActionGroup)ActionManager.getInstance().getAction(IdeActions.ADD_TO_FAVORITES));\n        if (myName2FavoritesListSet.isEmpty()){\n          final FavoritesTreeViewPanel panel = new FavoritesTreeViewPanel(myCurrentProject, null, myCurrentProject.getName());\n          final Content favoritesContent = contentFactory.createContent(panel, myCurrentProject.getName(), false);\n          addContent(favoritesContent);\n          final String key = myCurrentProject.getName();\n          myName2FavoritesListSet.put(key, favoritesContent);\n          myCurrentFavoritesList = key;\n          panel.getFavoritesTreeStructure().initFavoritesList();\n          final AddToFavoritesAction addAction = new AddToFavoritesAction(key);\n          myActions.put(key, addAction);\n        } else {\n          for (Iterator<String> iterator = myName2FavoritesListSet.keySet().iterator(); iterator.hasNext();) {\n            final String key = iterator.next();\n            final AddToFavoritesAction addAction = new AddToFavoritesAction(key);\n            myActions.put(key, addAction);\n            final Content content = myName2FavoritesListSet.get(key);\n            addContent(content);\n            ((FavoritesTreeViewPanel)content.getComponent()).getFavoritesTreeStructure().initFavoritesList();\n            if (key.equals(myCurrentFavoritesList)){\n              setSelectedContent(content);\n            }\n          }\n        }\n      }\n    });\n  }","commit_id":"9b68dc11c867ced5590d96900b2fcc62aa5f869c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n      final DataContext dataContext = e.getDataContext();\n      final AddNewFavoritesListAction action = (AddNewFavoritesListAction)ActionManager.getInstance().getAction(IdeActions.ADD_NEW_FAVORITES_LIST);\n      final FavoritesTreeViewPanel favoritesTreeViewPanel = action.doAddNewFavoritesList((Project)dataContext.getData(DataConstants.PROJECT));\n      new SendToFavoritesAction(favoritesTreeViewPanel.getName()).actionPerformed(e);\n    }","id":97660,"modified_method":"public void actionPerformed(AnActionEvent e) {\n      final DataContext dataContext = e.getDataContext();\n      final AddNewFavoritesListAction action = (AddNewFavoritesListAction)ActionManager.getInstance().getAction(IdeActions.ADD_NEW_FAVORITES_LIST);\n      final FavoritesTreeViewPanel favoritesTreeViewPanel = action.doAddNewFavoritesList((Project)dataContext.getData(DataConstants.PROJECT));\n      if (favoritesTreeViewPanel != null) {\n        new SendToFavoritesAction(favoritesTreeViewPanel.getName()).actionPerformed(e);\n      }\n    }","commit_id":"9b68dc11c867ced5590d96900b2fcc62aa5f869c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"ThrowableResultOfMethodCallIgnored\"})\n  @Override\n  protected void perform(@NotNull Project project, GitVcs vcs, @NotNull List<VcsException> exceptions, @NotNull VirtualFile[] affectedFiles)\n    throws VcsException {\n    saveAll();\n\n    final VirtualFile[] roots = ProjectLevelVcsManager.getInstance(project).getRootsUnderVcs(vcs);\n    for (VirtualFile root : roots) {\n      GitCommand command = new GitCommand(project, vcs.getSettings(), root);\n\n      String initialValue = null;\n      List<GitBranch> rbranches = command.branchList(true);\n      if (rbranches != null && rbranches.size() > 0) {\n        initialValue = command.remoteRepoURL(rbranches.get(0));\n      }\n      String repoURL = Messages.showInputDialog(project, GitBundle.getString(\"fetch.url.message\"), GitBundle.getString(\"fetch.url.title\"),\n                                                Messages.getQuestionIcon(), initialValue, null);\n\n      GitCommandRunnable cmdr = new GitCommandRunnable(project, vcs.getSettings(), root);\n      cmdr.setCommand(GitCommand.FETCH_CMD);\n      cmdr.setArgs(new String[]{repoURL});\n\n      ProgressManager manager = ProgressManager.getInstance();\n      manager.runProcessWithProgressSynchronously(cmdr, GitBundle.message(\"fetching.title\", repoURL), false, project);\n\n      VcsException ex = cmdr.getException();\n      if (ex != null) {\n        GitUIUtil.showOperationError(project, ex, \"git fetch\");\n        return;\n      }\n\n      cmdr.setArgs(new String[]{\"--tags\", repoURL});\n      manager.runProcessWithProgressSynchronously(cmdr, GitBundle.message(\"fetching.tags.title\", repoURL), false, project);\n      ex = cmdr.getException();\n      if (ex != null) {\n        GitUIUtil.showOperationError(project, ex, \"git fetch --tags\");\n        return;\n      }\n    }\n  }","id":97661,"modified_method":"/**\n   * {@inheritDoc}\n   */\n  protected void perform(@NotNull final Project project,\n                         @NotNull final List<VirtualFile> gitRoots,\n                         @NotNull final VirtualFile defaultRoot,\n                         final Set<VirtualFile> affectedRoots,\n                         final List<VcsException> exceptions) throws VcsException {\n    GitFetchDialog d = new GitFetchDialog(project, gitRoots, defaultRoot);\n    d.show();\n    if (!d.isOK()) {\n      return;\n    }\n    final GitLineHandler h = d.fetchHandler();\n    try {\n      GitHandlerUtil.doSynchronously(h, GitBundle.message(\"fetching.title\", d.getRemote()), h.printableCommandLine());\n      // note that fetch does not affects checked out sources\n    }\n    finally {\n      exceptions.addAll(h.errors());\n    }\n  }","commit_id":"358e3a68e16f00c7f5e3656fd73799a9759caa3d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  protected String getActionName() {\n    return GitBundle.getString(\"fetch.action.name\");\n  }","id":97662,"modified_method":"/**\n   * {@inheritDoc}\n   */\n  @Override\n  @NotNull\n  protected String getActionName() {\n    return GitBundle.getString(\"fetch.action.name\");\n  }","commit_id":"358e3a68e16f00c7f5e3656fd73799a9759caa3d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Get a list of merge strategies for the specified branch cuont\n   *\n   * @param branchCount\n   * @return an array of strategy names\n   */\n  @NonNls\n  public static String[] getMergeStrategies(int branchCount) {\n    if (branchCount < 0) {\n      throw new IllegalArgumentException(\"Brach count must be non-negative: \" + branchCount);\n    }\n    switch (branchCount) {\n      case 0:\n        return new String[]{DEFAULT_STRATEGY};\n      case 1:\n        return new String[]{DEFAULT_STRATEGY, \"resolve\", \"recursive\", \"octopus\", \"ours\", \"subtree\"};\n      default:\n        return new String[]{DEFAULT_STRATEGY, \"octopus\", \"ours\"};\n    }\n  }","id":97663,"modified_method":"/**\n   * Get a list of merge strategies for the specified branch cuont\n   *\n   * @param branchCount\n   * @return an array of strategy names\n   */\n  @NonNls\n  private static String[] getMergeStrategies(int branchCount) {\n    if (branchCount < 0) {\n      throw new IllegalArgumentException(\"Brach count must be non-negative: \" + branchCount);\n    }\n    switch (branchCount) {\n      case 0:\n        return new String[]{DEFAULT_STRATEGY};\n      case 1:\n        return new String[]{DEFAULT_STRATEGY, \"resolve\", \"recursive\", \"octopus\", \"ours\", \"subtree\"};\n      default:\n        return new String[]{DEFAULT_STRATEGY, \"octopus\", \"ours\"};\n    }\n  }","commit_id":"358e3a68e16f00c7f5e3656fd73799a9759caa3d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Update remotes for the git root\n   */\n  private void updateRemotes() {\n    try {\n      List<GitRemote> remotes = GitRemote.list(myProject, gitRoot());\n      String branch = currentBranch();\n      String remote = null;\n      if (branch != null) {\n        remote = GitConfigUtil.getValue(myProject, gitRoot(), \"branch.\" + branch + \".remote\");\n      }\n      myRemote.setRenderer(GitUIUtil.getGitRemoteListCellRenderer(remote));\n      GitRemote toSelect = null;\n      myRemote.removeAllItems();\n      for (GitRemote r : remotes) {\n        myRemote.addItem(r);\n        if (r.name().equals(remote)) {\n          toSelect = r;\n        }\n      }\n      if (toSelect != null) {\n        myRemote.setSelectedItem(toSelect);\n      }\n    }\n    catch (VcsException e) {\n      GitVcs.getInstance(myProject).showErrors(Collections.singletonList(e), GitBundle.getString(\"pull.retriving.remotes\"));\n    }\n  }","id":97664,"modified_method":"/**\n   * Update remotes for the git root\n   */\n  private void updateRemotes() {\n    GitUIUtil.setupRemotes(myProject, gitRoot(), currentBranch(), myRemote);\n  }","commit_id":"358e3a68e16f00c7f5e3656fd73799a9759caa3d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Setup root chooser with specfied elements and link selecto to the current branch label.\n   *\n   * @param project            a context project\n   * @param roots              git roots for the project\n   * @param defaultRoot        a default root\n   * @param gitRootChooser     git root selector\n   * @param currentBranchLabel current branch label\n   */\n  public static void setupRootChooser(final Project project,\n                                      final List<VirtualFile> roots,\n                                      final VirtualFile defaultRoot,\n                                      final JComboBox gitRootChooser,\n                                      final JLabel currentBranchLabel) {\n    for (VirtualFile root : roots) {\n      gitRootChooser.addItem(root);\n    }\n    gitRootChooser.setRenderer(getVirtualFileListCellRenderer());\n    gitRootChooser.setSelectedItem(defaultRoot);\n    final ActionListener listener = new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        try {\n          VirtualFile root = (VirtualFile)gitRootChooser.getSelectedItem();\n          GitBranch current = GitBranch.current(project, root);\n          if (current == null) {\n            currentBranchLabel.setText(NO_CURRENT_BRANCH);\n          }\n          else {\n            currentBranchLabel.setText(current.getName());\n          }\n        }\n        catch (VcsException ex) {\n          GitVcs.getInstance(project).showErrors(Collections.singletonList(ex), GitBundle.getString(\"merge.retriving.branches\"));\n        }\n      }\n    };\n    listener.actionPerformed(null);\n    gitRootChooser.addActionListener(listener);\n  }","id":97665,"modified_method":"/**\n   * Setup root chooser with specfied elements and link selecto to the current branch label.\n   *\n   * @param project            a context project\n   * @param roots              git roots for the project\n   * @param defaultRoot        a default root\n   * @param gitRootChooser     git root selector\n   * @param currentBranchLabel current branch label (might be null)\n   */\n  public static void setupRootChooser(final Project project,\n                                      final List<VirtualFile> roots,\n                                      final VirtualFile defaultRoot,\n                                      final JComboBox gitRootChooser,\n                                      @Nullable final JLabel currentBranchLabel) {\n    for (VirtualFile root : roots) {\n      gitRootChooser.addItem(root);\n    }\n    gitRootChooser.setRenderer(getVirtualFileListCellRenderer());\n    gitRootChooser.setSelectedItem(defaultRoot);\n    if (currentBranchLabel != null) {\n      final ActionListener listener = new ActionListener() {\n        public void actionPerformed(final ActionEvent e) {\n          try {\n            VirtualFile root = (VirtualFile)gitRootChooser.getSelectedItem();\n            GitBranch current = GitBranch.current(project, root);\n            assert currentBranchLabel != null;\n            if (current == null) {\n              currentBranchLabel.setText(NO_CURRENT_BRANCH);\n            }\n            else {\n              currentBranchLabel.setText(current.getName());\n            }\n          }\n          catch (VcsException ex) {\n            GitVcs.getInstance(project).showErrors(Collections.singletonList(ex), GitBundle.getString(\"merge.retriving.branches\"));\n          }\n        }\n      };\n      listener.actionPerformed(null);\n      gitRootChooser.addActionListener(listener);\n    }\n  }","commit_id":"358e3a68e16f00c7f5e3656fd73799a9759caa3d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Gets next token that is ended by space or new line. Consumes space but not a new line.\n   * Start position is the current. So if the string starts with space a empty token is returned.\n   *\n   * @return a token\n   */\n  public String spaceToken() {\n    int start = myPosition;\n    for (; myPosition < myText.length(); myPosition++) {\n      final char ch = myText.charAt(myPosition);\n      if (ch == ' ') {\n        final String rc = myText.substring(start, myPosition);\n        myPosition++;\n        return rc;\n      }\n      if (isEol()) {\n        return myText.substring(start, myPosition);\n      }\n    }\n    throw new IllegalStateException(\"Unexpected text end at \" + myPosition);\n  }","id":97666,"modified_method":"/**\n   * Gets next token that is ended by space or new line. Consumes space but not a new line.\n   * Start position is the current. So if the string starts with space a empty token is returned.\n   *\n   * @return a token\n   */\n  public String spaceToken() {\n    return boundedToken(' ');\n  }","commit_id":"358e3a68e16f00c7f5e3656fd73799a9759caa3d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent event) {\n    final VirtualFile virtualFile = event.getData(VcsDataKeys.VCS_VIRTUAL_FILE);\n    final Project project = event.getData(CommonDataKeys.PROJECT);\n    final VcsRevisionNumber revision = getRevisionNumber(event);\n    if (revision == null || virtualFile == null || project == null) {\n      return;\n    }\n\n    final VcsLogManager log = ServiceManager.getService(project, VcsLogManager.class);\n    if (log == null) {\n      return;\n    }\n\n    ToolWindow window = ToolWindowManager.getInstance(project).getToolWindow(ChangesViewContentManager.TOOLWINDOW_ID);\n    ContentManager cm = window.getContentManager();\n    Content[] contents = cm.getContents();\n    for (Content content : contents) {\n      if (VcsLogContentProvider.TAB_NAME.equals(content.getDisplayName())) {\n        cm.setSelectedContent(content);\n      }\n    }\n\n    Runnable selectCommit = new Runnable() {\n      @Override\n      public void run() {\n        VcsLogUiImpl logUi = log.getLogUi();\n        if (logUi == null) {\n          return;\n        }\n        logUi.getVcsLog().jumpToReference(revision.asString());\n      }\n    };\n\n    if (!window.isVisible()) {\n      window.activate(selectCommit, true);\n    }\n    else {\n      selectCommit.run();\n    }\n  }","id":97667,"modified_method":"@Override\n  public void actionPerformed(@NotNull AnActionEvent event) {\n    Project project = event.getRequiredData(CommonDataKeys.PROJECT);\n    final VcsLog log = findLog(project);\n    assert log != null;\n    final VcsRevisionNumber revision = getRevisionNumber(event);\n    if (revision == null) {\n      return;\n    }\n\n    ToolWindow window = ToolWindowManager.getInstance(project).getToolWindow(ChangesViewContentManager.TOOLWINDOW_ID);\n    ContentManager cm = window.getContentManager();\n    Content[] contents = cm.getContents();\n    for (Content content : contents) {\n      if (VcsLogContentProvider.TAB_NAME.equals(content.getDisplayName())) {\n        cm.setSelectedContent(content);\n      }\n    }\n\n    Runnable selectCommit = new Runnable() {\n      @Override\n      public void run() {\n        log.jumpToReference(revision.asString());\n      }\n    };\n\n    if (!window.isVisible()) {\n      window.activate(selectCommit, true);\n    }\n    else {\n      selectCommit.run();\n    }\n  }","commit_id":"a0b32a9303b575371306c94e9a312a8894da0e40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    super.update(e);\n    e.getPresentation().setEnabled((e.getData(VcsDataKeys.VCS_FILE_REVISION) != null ||\n                                    e.getData(VcsDataKeys.VCS_REVISION_NUMBER) != null));\n  }","id":97668,"modified_method":"@Override\n  public void update(@NotNull AnActionEvent e) {\n    super.update(e);\n    e.getPresentation().setEnabled(e.getProject() != null &&\n                                   findLog(e.getProject()) != null &&\n                                   (e.getData(VcsDataKeys.VCS_FILE_REVISION) != null ||\n                                   e.getData(VcsDataKeys.VCS_REVISION_NUMBER) != null));\n  }","commit_id":"a0b32a9303b575371306c94e9a312a8894da0e40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public JComponent initContent() {\n    return myLogManager.initContent(Arrays.asList(myVcsManager.getAllVcsRoots()));\n  }","id":97669,"modified_method":"@Override\n  public JComponent initContent() {\n    return myLogManager.initContent(Arrays.asList(myVcsManager.getAllVcsRoots()), TAB_NAME);\n  }","commit_id":"a0b32a9303b575371306c94e9a312a8894da0e40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public VcsLogContentProvider(@NotNull VcsLogManager logManager, @NotNull ProjectLevelVcsManager manager) {\n    myLogManager = logManager;\n    myVcsManager = manager;\n  }","id":97670,"modified_method":"public VcsLogContentProvider(@NotNull Project project,\n                               @NotNull ProjectLevelVcsManager manager,\n                               @NotNull VcsLogSettings settings,\n                               @NotNull VcsLogUiProperties uiProperties) {\n    myVcsManager = manager;\n    myLogManager = new VcsLogManager(project, settings, uiProperties);\n  }","commit_id":"a0b32a9303b575371306c94e9a312a8894da0e40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PostponeableLogRefresher(@NotNull Project project, @NotNull VcsLogDataHolder dataHolder) {\n      myDataHolder = dataHolder;\n      myToolWindowManager = (ToolWindowManagerImpl)ToolWindowManager.getInstance(project);\n      myToolWindow = (ToolWindowImpl)myToolWindowManager.getToolWindow(TOOLWINDOW_ID);\n\n      Disposer.register(myToolWindow.getContentManager(), this);\n\n      myPostponedEventsListener = new MyRefreshPostponedEventsListener();\n      myToolWindow.getContentManager().addContentManagerListener(myPostponedEventsListener);\n      myToolWindowManager.addToolWindowManagerListener(myPostponedEventsListener);\n    }","id":97671,"modified_method":"public PostponeableLogRefresher(@NotNull Project project, @NotNull VcsLogDataHolder dataHolder, @NotNull String contentTabName) {\n      myDataHolder = dataHolder;\n      myToolWindowManager = (ToolWindowManagerImpl)ToolWindowManager.getInstance(project);\n      myToolWindow = (ToolWindowImpl)myToolWindowManager.getToolWindow(TOOLWINDOW_ID);\n      myTabName = contentTabName;\n\n      Disposer.register(myToolWindow.getContentManager(), this);\n\n      myPostponedEventsListener = new MyRefreshPostponedEventsListener();\n      myToolWindow.getContentManager().addContentManagerListener(myPostponedEventsListener);\n      myToolWindowManager.addToolWindowManagerListener(myPostponedEventsListener);\n    }","commit_id":"a0b32a9303b575371306c94e9a312a8894da0e40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public JComponent initContent(@NotNull Collection<VcsRoot> roots) {\n    final Map<VirtualFile, VcsLogProvider> logProviders = findLogProviders(roots);\n\n    Consumer<VisiblePack> visiblePackConsumer = new Consumer<VisiblePack>() {\n      @Override\n      public void consume(final VisiblePack pack) {\n          UIUtil.invokeLaterIfNeeded(new Runnable() {\n            @Override\n            public void run() {\n              if (!Disposer.isDisposed(myUi)) {\n                myUi.setVisiblePack(pack);\n              }\n            }\n          });\n      }\n    };\n    VcsLogDataHolder logDataHolder = new VcsLogDataHolder(myProject, this, logProviders, mySettings, myUiProperties, visiblePackConsumer);\n    myUi = new VcsLogUiImpl(logDataHolder, myProject, mySettings,\n                            new VcsLogColorManagerImpl(logProviders.keySet()), myUiProperties, logDataHolder.getFilterer());\n    myLogRefresher = new PostponeableLogRefresher(myProject, logDataHolder);\n    refreshLogOnVcsEvents(logProviders);\n    logDataHolder.initialize();\n\n    // todo fix selection\n    final VcsLogGraphTable graphTable = myUi.getTable();\n    if (graphTable.getRowCount() > 0) {\n      IdeFocusManager.getInstance(myProject).requestFocus(graphTable, true).doWhenProcessed(new Runnable() {\n        @Override\n        public void run() {\n          graphTable.setRowSelectionInterval(0, 0);\n        }\n      });\n    }\n    return myUi.getMainFrame().getMainComponent();\n  }","id":97672,"modified_method":"@NotNull\n  public JComponent initContent(@NotNull Collection<VcsRoot> roots, @NotNull String contentTabName) {\n    final Map<VirtualFile, VcsLogProvider> logProviders = findLogProviders(roots);\n\n    Consumer<VisiblePack> visiblePackConsumer = new Consumer<VisiblePack>() {\n      @Override\n      public void consume(final VisiblePack pack) {\n          UIUtil.invokeLaterIfNeeded(new Runnable() {\n            @Override\n            public void run() {\n              if (!Disposer.isDisposed(myUi)) {\n                myUi.setVisiblePack(pack);\n              }\n            }\n          });\n      }\n    };\n    VcsLogDataHolder logDataHolder = new VcsLogDataHolder(myProject, this, logProviders, mySettings, myUiProperties, visiblePackConsumer);\n    myUi = new VcsLogUiImpl(logDataHolder, myProject, mySettings,\n                            new VcsLogColorManagerImpl(logProviders.keySet()), myUiProperties, logDataHolder.getFilterer());\n    myLogRefresher = new PostponeableLogRefresher(myProject, logDataHolder, contentTabName);\n    refreshLogOnVcsEvents(logProviders);\n    logDataHolder.initialize();\n\n    // todo fix selection\n    final VcsLogGraphTable graphTable = myUi.getTable();\n    if (graphTable.getRowCount() > 0) {\n      IdeFocusManager.getInstance(myProject).requestFocus(graphTable, true).doWhenProcessed(new Runnable() {\n        @Override\n        public void run() {\n          graphTable.setRowSelectionInterval(0, 0);\n        }\n      });\n    }\n    return myUi.getMainFrame().getMainComponent();\n  }","commit_id":"a0b32a9303b575371306c94e9a312a8894da0e40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isOurContentPaneShowing() {\n      if (myToolWindowManager.isToolWindowRegistered(TOOLWINDOW_ID) && myToolWindow.isVisible()) {\n        Content content = myToolWindow.getContentManager().getSelectedContent();\n        return content != null && content.getTabName().equals(VcsLogContentProvider.TAB_NAME);\n      }\n      return false;\n    }","id":97673,"modified_method":"private boolean isOurContentPaneShowing() {\n      if (myToolWindowManager.isToolWindowRegistered(TOOLWINDOW_ID) && myToolWindow.isVisible()) {\n        Content content = myToolWindow.getContentManager().getSelectedContent();\n        return content != null && content.getTabName().equals(myTabName);\n      }\n      return false;\n    }","commit_id":"a0b32a9303b575371306c94e9a312a8894da0e40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    Project project = e.getProject();\n    if (project == null) {\n      return;\n    }\n    VcsLogSettings settings = ServiceManager.getService(project, VcsLogSettings.class);\n    VcsLogManager logManager = ServiceManager.getService(project, VcsLogManager.class);\n    VcsLogUiImpl logUi = logManager.getLogUi();\n    if (logUi == null) {\n      return;\n    }\n\n    ActionGroup settingsGroup = new MySettingsActionGroup(settings, logUi);\n    ActionPopupMenu popupMenu = ActionManager.getInstance().createActionPopupMenu(ToolWindowContentUi.POPUP_PLACE, settingsGroup);\n    int x = 0;\n    int y = 0;\n    InputEvent inputEvent = e.getInputEvent();\n    if (inputEvent instanceof MouseEvent) {\n      x = ((MouseEvent)inputEvent).getX();\n      y = ((MouseEvent)inputEvent).getY();\n    }\n    popupMenu.getComponent().show(inputEvent.getComponent(), x, y);\n  }","id":97674,"modified_method":"@Override\n  public void actionPerformed(@NotNull AnActionEvent e) {\n    Project project = e.getRequiredData(CommonDataKeys.PROJECT);\n    VcsLogUi logUi = e.getRequiredData(VcsLogDataKeys.VCS_LOG_UI);\n    VcsLogSettings settings = ServiceManager.getService(project, VcsLogSettings.class);\n\n    ActionGroup settingsGroup = new MySettingsActionGroup(settings, logUi);\n    ActionPopupMenu popupMenu = ActionManager.getInstance().createActionPopupMenu(ToolWindowContentUi.POPUP_PLACE, settingsGroup);\n    int x = 0;\n    int y = 0;\n    InputEvent inputEvent = e.getInputEvent();\n    if (inputEvent instanceof MouseEvent) {\n      x = ((MouseEvent)inputEvent).getX();\n      y = ((MouseEvent)inputEvent).getY();\n    }\n    popupMenu.getComponent().show(inputEvent.getComponent(), x, y);\n  }","commit_id":"a0b32a9303b575371306c94e9a312a8894da0e40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    Project project = e.getProject();\n    if (project == null) {\n      e.getPresentation().setEnabledAndVisible(false);\n    }\n    else {\n      VcsLogManager logManager = ServiceManager.getService(project, VcsLogManager.class);\n      e.getPresentation().setEnabledAndVisible(logManager.getLogUi() != null);\n    }\n  }","id":97675,"modified_method":"@Override\n  public void update(@NotNull AnActionEvent e) {\n    Project project = e.getProject();\n    VcsLogUi logUi = e.getData(VcsLogDataKeys.VCS_LOG_UI);\n    e.getPresentation().setEnabledAndVisible(project != null && logUi != null);\n  }","commit_id":"a0b32a9303b575371306c94e9a312a8894da0e40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MySettingsActionGroup(VcsLogSettings settings, VcsLogUiImpl ui) {\n      mySettings = settings;\n      myUi = ui;\n    }","id":97676,"modified_method":"public MySettingsActionGroup(VcsLogSettings settings, VcsLogUi ui) {\n      mySettings = settings;\n      myUi = ui;\n    }","commit_id":"a0b32a9303b575371306c94e9a312a8894da0e40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    if (e.getProject() == null || !Registry.is(\"vcs.log.open.another.log.visible\")) {\n      e.getPresentation().setEnabledAndVisible(false);\n      return;\n    }\n    VcsLogUiImpl mainLogUi = VcsLogProjectManager.getInstance(e.getProject()).getMainLogUi();\n    if (mainLogUi == null) {\n      e.getPresentation().setEnabledAndVisible(false);\n      return;\n    }\n\n    e.getPresentation().setEnabledAndVisible(true);\n  }","id":97677,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    Project project = e.getProject();\n    if (project == null || !Registry.is(\"vcs.log.open.another.log.visible\")) {\n      e.getPresentation().setEnabledAndVisible(false);\n      return;\n    }\n    VcsLogProjectManager logProjectManager = VcsLogProjectManager.getInstance(project);\n    VcsLogManager logManager = e.getData(VcsLogDataKeys.LOG_MANAGER);\n    e.getPresentation()\n      .setEnabledAndVisible(logManager != null && logProjectManager.getLogManager() == logManager); // only for main log (it is a question, how and where we want to open tabs for external logs)\n  }","commit_id":"5bbddcbcadad768cf11749f5a3e3d768a757e3ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    VcsLogContentProvider.openAnotherLogTab(e.getProject());\n  }","id":97678,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    VcsLogContentProvider.openAnotherLogTab(e.getRequiredData(VcsLogDataKeys.LOG_MANAGER), e.getRequiredData(CommonDataKeys.PROJECT));\n  }","commit_id":"5bbddcbcadad768cf11749f5a3e3d768a757e3ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    Project project = e.getProject();\n    if (project == null) {\n      e.getPresentation().setEnabledAndVisible(false);\n    }\n    else {\n      VcsLogProjectManager projectManager = VcsLogProjectManager.getInstance(project);\n      VcsLogDataManager dataManager = projectManager.getDataManager();\n      e.getPresentation().setEnabledAndVisible(dataManager != null && e.getData(VcsLogDataKeys.VCS_LOG_UI) != null);\n    }\n  }","id":97679,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    VcsLogManager logManager = e.getData(VcsLogDataKeys.LOG_MANAGER);\n    e.getPresentation().setEnabledAndVisible(logManager != null);\n  }","commit_id":"5bbddcbcadad768cf11749f5a3e3d768a757e3ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    Project project = e.getRequiredData(CommonDataKeys.PROJECT);\n    VcsLogProjectManager.getInstance(project).getDataManager().refreshCompletely();\n  }","id":97680,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    VcsLogManager logManager = e.getRequiredData(VcsLogDataKeys.LOG_MANAGER);\n    logManager.getDataManager().refreshCompletely();\n  }","commit_id":"5bbddcbcadad768cf11749f5a3e3d768a757e3ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addLogTab(@NotNull VcsLogProjectManager logManager,\n                                @NotNull ToolWindow toolWindow,\n                                @NotNull VcsLogUiImpl logUi,\n                                @NotNull String shortName) {\n    logManager.watchTab(ContentUtilEx.getFullName(TAB_NAME, shortName), logUi);\n    logUi.requestFocus();\n    ContentUtilEx\n      .addTabbedContent(toolWindow.getContentManager(), logUi.getMainFrame().getMainComponent(), TAB_NAME, shortName, true, logUi);\n    toolWindow.activate(null);\n  }","id":97681,"modified_method":"private static void addLogTab(@NotNull VcsLogManager logManager,\n                                @NotNull ToolWindow toolWindow,\n                                @NotNull VcsLogUiImpl logUi,\n                                @NotNull String shortName) {\n    logManager.watchTab(ContentUtilEx.getFullName(TAB_NAME, shortName), logUi);\n    logUi.requestFocus();\n    ContentUtilEx\n      .addTabbedContent(toolWindow.getContentManager(), new VcsLogPanel(logManager, logUi), TAB_NAME, shortName, true, logUi);\n    toolWindow.activate(null);\n  }","commit_id":"5bbddcbcadad768cf11749f5a3e3d768a757e3ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void openAnotherLogTab(@NotNull Project project) {\n    VcsLogProjectManager logManager = VcsLogProjectManager.getInstance(project);\n    ToolWindow toolWindow = ToolWindowManager.getInstance(project).getToolWindow(ToolWindowId.VCS);\n\n    String shortName = generateShortName(toolWindow);\n    VcsLogUiImpl logUi = logManager.createLog(ContentUtilEx.getFullName(TAB_NAME, shortName));\n    addLogTab(logManager, toolWindow, logUi, shortName);\n  }","id":97682,"modified_method":"public static void openAnotherLogTab(@NotNull VcsLogManager logManager, @NotNull Project project) {\n    ToolWindow toolWindow = ToolWindowManager.getInstance(project).getToolWindow(ToolWindowId.VCS);\n\n    String shortName = generateShortName(toolWindow);\n    VcsLogUiImpl logUi = logManager.createLog(ContentUtilEx.getFullName(TAB_NAME, shortName));\n    addLogTab(logManager, toolWindow, logUi, shortName);\n  }","commit_id":"5bbddcbcadad768cf11749f5a3e3d768a757e3ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public JComponent initMainLog(@Nullable String contentTabName) {\n    myUi = createLog(VcsLogTabsProperties.MAIN_LOG_ID);\n    if (contentTabName != null) {\n      watchTab(contentTabName, myUi);\n    }\n    else {\n      watch(myUi);\n    }\n    myUi.requestFocus();\n    return myUi.getMainFrame().getMainComponent();\n  }","id":97683,"modified_method":"@NotNull\n  public JComponent initMainLog(@Nullable String contentTabName) {\n    myUi = createLog(VcsLogTabsProperties.MAIN_LOG_ID);\n    if (contentTabName != null) {\n      watchTab(contentTabName, myUi);\n    }\n    else {\n      watch(myUi);\n    }\n    myUi.requestFocus();\n    return new VcsLogPanel(this, myUi);\n  }","commit_id":"5bbddcbcadad768cf11749f5a3e3d768a757e3ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    e.getPresentation().setEnabledAndVisible(e.getProject() != null);\n  }","id":97684,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    Project project = e.getProject();\n    if (project == null) {\n      e.getPresentation().setEnabledAndVisible(false);\n    } else {\n      VcsLogDataManager dataManager = VcsLogManager.getInstance(project).getDataManager();\n      e.getPresentation().setEnabledAndVisible(dataManager != null && e.getData(VcsLogDataKeys.VCS_LOG_UI) != null);\n    }\n  }","commit_id":"dfa80366c4061562896af3d9b5d2d6af0e542b78","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RefreshLogAction() {\n    super(\"Refresh\", \"Refresh\", AllIcons.Actions.Refresh);\n  }","id":97685,"modified_method":"public RefreshLogAction() {\n    super(\"Refresh\", \"Re-read Commits From Disk for All VCS Roots and Rebuild Log\", AllIcons.Actions.Refresh);\n  }","commit_id":"dfa80366c4061562896af3d9b5d2d6af0e542b78","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected CopyQualifiedNameService getCopyQualifiedNameService(EObject selectedElement) {\n\t\tif (selectedElement == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn registry.getResourceServiceProvider(selectedElement.eResource().getURI()).get(CopyQualifiedNameService.class);\n\t}","id":97686,"modified_method":"protected CopyQualifiedNameService getCopyQualifiedNameService(EObject selectedElement) {\n\t\tif (selectedElement == null) {\n\t\t\treturn null;\n\t\t}\n\t\tIResourceServiceProvider resourceServiceProvider = registry.getResourceServiceProvider(selectedElement.eResource().getURI());\n\t\tif (resourceServiceProvider == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn resourceServiceProvider.get(CopyQualifiedNameService.class);\n\t}","commit_id":"df59a2a13ab4077ff87f4b46ac3cbb970aa71edc","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @since 2.4\n\t */\n\tprotected void findAllIndexedReferences(IAcceptor<IReferenceDescription> referenceAcceptor, SubMonitor subMonitor,\n\t\t\tSet<URI> targetURIsAsSet, ILocalResourceAccess localResourceAccess) {\n\t\tsubMonitor.setWorkRemaining(size(indexData.getAllResourceDescriptions()));\n\t\tfor (IResourceDescription resourceDescription : indexData.getAllResourceDescriptions()) {\n\t\t\tIResourceServiceProvider serviceProvider = serviceProviderRegistry.getResourceServiceProvider(resourceDescription.getURI());\n\t\t\tIReferenceFinder referenceFinder = serviceProvider.get(IReferenceFinder.class);\n\t\t\tif (referenceFinder instanceof IReferenceFinderExtension1) {\n\t\t\t\tIReferenceFinderExtension1 extension1 = (IReferenceFinderExtension1) referenceFinder;\n\t\t\t\textension1.findReferences(targetURIsAsSet, resourceDescription, referenceAcceptor, subMonitor.newChild(1), localResourceAccess);\n\t\t\t} else {\n\t\t\t\t// don't use the language specific reference finder here for backwards compatibility reasons\n\t\t\t\tfindReferences(targetURIsAsSet, resourceDescription, referenceAcceptor, subMonitor.newChild(1), localResourceAccess);\n\t\t\t}\n\t\t}\n\t}","id":97687,"modified_method":"/**\n\t * @since 2.4\n\t */\n\tprotected void findAllIndexedReferences(IAcceptor<IReferenceDescription> referenceAcceptor, SubMonitor subMonitor,\n\t\t\tSet<URI> targetURIsAsSet, ILocalResourceAccess localResourceAccess) {\n\t\tsubMonitor.setWorkRemaining(size(indexData.getAllResourceDescriptions()));\n\t\tfor (IResourceDescription resourceDescription : indexData.getAllResourceDescriptions()) {\n\t\t\tIResourceServiceProvider serviceProvider = serviceProviderRegistry.getResourceServiceProvider(resourceDescription.getURI());\n\t\t\tif (serviceProvider != null) {\n\t\t\t\tIReferenceFinder referenceFinder = serviceProvider.get(IReferenceFinder.class);\n\t\t\t\tif (referenceFinder instanceof IReferenceFinderExtension1) {\n\t\t\t\t\tIReferenceFinderExtension1 extension1 = (IReferenceFinderExtension1) referenceFinder;\n\t\t\t\t\textension1.findReferences(targetURIsAsSet, resourceDescription, referenceAcceptor, subMonitor.newChild(1), localResourceAccess);\n\t\t\t\t} else {\n\t\t\t\t\t// don't use the language specific reference finder here for backwards compatibility reasons\n\t\t\t\t\tfindReferences(targetURIsAsSet, resourceDescription, referenceAcceptor, subMonitor.newChild(1), localResourceAccess);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"df59a2a13ab4077ff87f4b46ac3cbb970aa71edc","url":"https://github.com/eclipse/xtext"},{"original_method":"public IHyperlink[] detectHyperlinks(ITextViewer textViewer, IRegion region, boolean canShowMultipleHyperlinks) {\n\t\ttry {\n\t\t\t// very pessimistic guards - most things should never happen\n\t\t\tITextEditor textEditor = (ITextEditor) getAdapter(ITextEditor.class);\n\t\t\tif (textEditor == null)\n\t\t\t\treturn null;\n\t\t\tIEditorInput editorInput = textEditor.getEditorInput();\n\t\t\tif (editorInput == null)\n\t\t\t\treturn null;\n\t\t\tIJavaElement adaptedJavaElement = (IJavaElement) Platform.getAdapterManager().getAdapter(editorInput, IJavaElement.class);\n\t\t\tif (adaptedJavaElement == null)\n\t\t\t\treturn null;\n\t\t\tICompilationUnit compilationUnit = (ICompilationUnit) adaptedJavaElement.getAncestor(IJavaElement.COMPILATION_UNIT);\n\t\t\tif (compilationUnit == null)\n\t\t\t\treturn null;\n\t\t\ttry {\n\t\t\t\tIRegion selectedWord = org.eclipse.jdt.internal.ui.text.JavaWordFinder.findWord(\n\t\t\t\t\t\ttextViewer.getDocument(), region.getOffset());\n\t\t\t\t// the actual implementation - find the referenced Java type under the cursor and link\n\t\t\t\t// to its origin if it's contained in a 'derived' resource\n\t\t\t\tIJavaElement[] javaElements = compilationUnit.codeSelect(selectedWord.getOffset(), selectedWord.getLength());\n\t\t\t\tfor(IJavaElement javaElement: javaElements) {\n\t\t\t\t\t/**\n\t\t\t\t\t * if IDE 3.8 is available the default 'Open Declaration' navigation will already open the original editor\n\t\t\t\t\t * So we don't need the additional hyperlinks.\n\t\t\t\t\t */\n\t\t\t\t\tboolean provideHyperlinkOnReferences = !is_ORG_ECLIPSE_UI_IDE_3_8_Enabled() || compilationUnit.equals(((IMember) javaElement).getCompilationUnit());\n\t\t\t\t\tif (javaElement instanceof IMember && provideHyperlinkOnReferences) {\n\t\t\t\t\t\tIMember selectedMember = (IMember) javaElement;\n\t\t\t\t\t\tIResource resource = selectedMember.getResource();\n\t\t\t\t\t\tif (resource instanceof IFile) {\n\t\t\t\t\t\t\tITrace traceToSource = traceInformation.getTraceToSource((IStorage) resource);\n\t\t\t\t\t\t\tif (traceToSource == null) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tIterable<ILocationInResource> sourceInformation = traceToSource.getAllAssociatedLocations(new TextRegion(selectedWord.getOffset(), selectedWord.getLength()));\n\t\t\t\t\t\t\tList<ILocationInResource> sourceInformationAsList = Lists.newArrayList(sourceInformation);\n\t\t\t\t\t\t\tif (!canShowMultipleHyperlinks && sourceInformationAsList.size() > 1)\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\tList<LinkToOrigin> result = Lists.newArrayListWithCapacity(sourceInformationAsList.size());\n\t\t\t\t\t\t\tfor(ILocationInResource source: sourceInformationAsList) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tURI resourceURI = source.getAbsoluteResourceURI();\n\t\t\t\t\t\t\t\t\tif (resourceURI != null) {\n\t\t\t\t\t\t\t\t\t\tIResourceServiceProvider serviceProvider = serviceProviderRegistry.getResourceServiceProvider(resourceURI);\n\t\t\t\t\t\t\t\t\t\tLinkToOriginProvider provider = serviceProvider.get(LinkToOriginProvider.class);\n\t\t\t\t\t\t\t\t\t\tLinkToOrigin hyperlink = provider.createLinkToOrigin(source, selectedWord, selectedMember, compilationUnit, result);\n\t\t\t\t\t\t\t\t\t\tif (hyperlink != null) {\n\t\t\t\t\t\t\t\t\t\t\tresult.add(hyperlink);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch(IllegalArgumentException e) { /* invalid URI - ignore */ }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (result.isEmpty())\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\treturn result.toArray(new IHyperlink[result.size()]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t} catch (JavaModelException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch(Throwable t) {\n\t\t\treturn null;\n\t\t}\n\t}","id":97688,"modified_method":"public IHyperlink[] detectHyperlinks(ITextViewer textViewer, IRegion region, boolean canShowMultipleHyperlinks) {\n\t\ttry {\n\t\t\t// very pessimistic guards - most things should never happen\n\t\t\tITextEditor textEditor = (ITextEditor) getAdapter(ITextEditor.class);\n\t\t\tif (textEditor == null)\n\t\t\t\treturn null;\n\t\t\tIEditorInput editorInput = textEditor.getEditorInput();\n\t\t\tif (editorInput == null)\n\t\t\t\treturn null;\n\t\t\tIJavaElement adaptedJavaElement = (IJavaElement) Platform.getAdapterManager().getAdapter(editorInput, IJavaElement.class);\n\t\t\tif (adaptedJavaElement == null)\n\t\t\t\treturn null;\n\t\t\tICompilationUnit compilationUnit = (ICompilationUnit) adaptedJavaElement.getAncestor(IJavaElement.COMPILATION_UNIT);\n\t\t\tif (compilationUnit == null)\n\t\t\t\treturn null;\n\t\t\ttry {\n\t\t\t\tIRegion selectedWord = org.eclipse.jdt.internal.ui.text.JavaWordFinder.findWord(\n\t\t\t\t\t\ttextViewer.getDocument(), region.getOffset());\n\t\t\t\t// the actual implementation - find the referenced Java type under the cursor and link\n\t\t\t\t// to its origin if it's contained in a 'derived' resource\n\t\t\t\tIJavaElement[] javaElements = compilationUnit.codeSelect(selectedWord.getOffset(), selectedWord.getLength());\n\t\t\t\tfor(IJavaElement javaElement: javaElements) {\n\t\t\t\t\t/**\n\t\t\t\t\t * if IDE 3.8 is available the default 'Open Declaration' navigation will already open the original editor\n\t\t\t\t\t * So we don't need the additional hyperlinks.\n\t\t\t\t\t */\n\t\t\t\t\tboolean provideHyperlinkOnReferences = !is_ORG_ECLIPSE_UI_IDE_3_8_Enabled() || compilationUnit.equals(((IMember) javaElement).getCompilationUnit());\n\t\t\t\t\tif (javaElement instanceof IMember && provideHyperlinkOnReferences) {\n\t\t\t\t\t\tIMember selectedMember = (IMember) javaElement;\n\t\t\t\t\t\tIResource resource = selectedMember.getResource();\n\t\t\t\t\t\tif (resource instanceof IFile) {\n\t\t\t\t\t\t\tITrace traceToSource = traceInformation.getTraceToSource((IStorage) resource);\n\t\t\t\t\t\t\tif (traceToSource == null) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tIterable<ILocationInResource> sourceInformation = traceToSource.getAllAssociatedLocations(new TextRegion(selectedWord.getOffset(), selectedWord.getLength()));\n\t\t\t\t\t\t\tList<ILocationInResource> sourceInformationAsList = Lists.newArrayList(sourceInformation);\n\t\t\t\t\t\t\tif (!canShowMultipleHyperlinks && sourceInformationAsList.size() > 1)\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\tList<LinkToOrigin> result = Lists.newArrayListWithCapacity(sourceInformationAsList.size());\n\t\t\t\t\t\t\tfor(ILocationInResource source: sourceInformationAsList) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tURI resourceURI = source.getAbsoluteResourceURI();\n\t\t\t\t\t\t\t\t\tif (resourceURI != null) {\n\t\t\t\t\t\t\t\t\t\tIResourceServiceProvider serviceProvider = serviceProviderRegistry.getResourceServiceProvider(resourceURI);\n\t\t\t\t\t\t\t\t\t\tif (serviceProvider == null)\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\tLinkToOriginProvider provider = serviceProvider.get(LinkToOriginProvider.class);\n\t\t\t\t\t\t\t\t\t\tLinkToOrigin hyperlink = provider.createLinkToOrigin(source, selectedWord, selectedMember, compilationUnit, result);\n\t\t\t\t\t\t\t\t\t\tif (hyperlink != null) {\n\t\t\t\t\t\t\t\t\t\t\tresult.add(hyperlink);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch(IllegalArgumentException e) { /* invalid URI - ignore */ }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (result.isEmpty())\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\treturn result.toArray(new IHyperlink[result.size()]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t} catch (JavaModelException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch(Throwable t) {\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"df59a2a13ab4077ff87f4b46ac3cbb970aa71edc","url":"https://github.com/eclipse/xtext"},{"original_method":"protected IReferenceUpdater getReferenceUpdater(URI sourceResourceURI) {\n\t\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n\t\t\t\t\t.getResourceServiceProvider(sourceResourceURI);\n\t\t\tIReferenceUpdater referenceUpdater = provider2updater.get(resourceServiceProvider);\n\t\t\tif (referenceUpdater == null) {\n\t\t\t\treferenceUpdater = resourceServiceProvider.get(OptionalReferenceUpdaterProxy.class).get();\n\t\t\t\tif (referenceUpdater != null)\n\t\t\t\t\tprovider2updater.put(resourceServiceProvider, referenceUpdater);\n\t\t\t}\n\t\t\treturn referenceUpdater;\n\t\t}","id":97689,"modified_method":"protected IReferenceUpdater getReferenceUpdater(URI sourceResourceURI) {\n\t\t\t//TODO Why do we cache the IReferenceUpdater here?\n\t\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n\t\t\t\t\t.getResourceServiceProvider(sourceResourceURI);\n\t\t\tif (resourceServiceProvider == null)\n\t\t\t\treturn null;\n\t\t\tIReferenceUpdater referenceUpdater = provider2updater.get(resourceServiceProvider);\n\t\t\tif (referenceUpdater == null) {\n\t\t\t\treferenceUpdater = resourceServiceProvider.get(OptionalReferenceUpdaterProxy.class).get();\n\t\t\t\tif (referenceUpdater != null)\n\t\t\t\t\tprovider2updater.put(resourceServiceProvider, referenceUpdater);\n\t\t\t}\n\t\t\treturn referenceUpdater;\n\t\t}","commit_id":"df59a2a13ab4077ff87f4b46ac3cbb970aa71edc","url":"https://github.com/eclipse/xtext"},{"original_method":"protected String getClassNamePattern(IResource res) {\n\t\tif (!(res instanceof IStorage))\n\t\t\treturn null;\n\t\tURI uri = uriMapper.getUri((IStorage) res);\n\t\tIResourceServiceProvider provider = providerRegistry.getResourceServiceProvider(uri);\n\t\tIResourceSetProvider resourceSetProvider = provider.get(IResourceSetProvider.class);\n\t\tResourceSet set = resourceSetProvider.get(res.getProject());\n\t\tResource resource = set.getResource(uri, true);\n\t\tif (resource instanceof XtextResource) {\n\t\t\treturn getClassNamePattern((XtextResource) resource);\n\t\t}\n\t\treturn null;\n\t}","id":97690,"modified_method":"protected String getClassNamePattern(IResource res) {\n\t\tif (!(res instanceof IStorage))\n\t\t\treturn null;\n\t\tURI uri = uriMapper.getUri((IStorage) res);\n\t\tIResourceServiceProvider provider = providerRegistry.getResourceServiceProvider(uri);\n\t\tif (provider == null)\n\t\t\treturn null;\n\t\tIResourceSetProvider resourceSetProvider = provider.get(IResourceSetProvider.class);\n\t\tResourceSet set = resourceSetProvider.get(res.getProject());\n\t\tResource resource = set.getResource(uri, true);\n\t\tif (resource instanceof XtextResource) {\n\t\t\treturn getClassNamePattern((XtextResource) resource);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"df59a2a13ab4077ff87f4b46ac3cbb970aa71edc","url":"https://github.com/eclipse/xtext"},{"original_method":"public void search(URI uri, IProgressMonitor monitor) {\n\t\tint numResources = Iterables.size(resourceDescriptions.getAllResourceDescriptions());\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, numResources);\n\t\tsubMonitor.subTask(\"Find references in EMF resources\");\n\t\ttry {\n\t\t\tfor (IResourceDescription resourceDescription : resourceDescriptions.getAllResourceDescriptions()) {\n\t\t\t\tURI resourceURI = resourceDescription.getURI();\n\t\t\t\tIJavaSearchParticipation javaSearchParticipation = serviceProviderRegistry.getResourceServiceProvider(resourceURI)\n\t\t\t\t\t\t.get(IJavaSearchParticipation.class);\n\t\t\t\tif(javaSearchParticipation == null || javaSearchParticipation.canContainJvmReferences(resourceURI))\n\t\t\t\t\tsearchIn(uri, resourceDescription);\n\t\t\t\tif (subMonitor.isCanceled()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsubMonitor.worked(1);\n\t\t\t}\n\t\t\tfor(ResourceSet resourceSet: projectToResourceSet.values()) {\n\t\t\t\tresourceSet.getResources().clear();\n\t\t\t\tresourceSet.eAdapters().clear();\n\t\t\t}\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","id":97691,"modified_method":"public void search(URI uri, IProgressMonitor monitor) {\n\t\tint numResources = Iterables.size(resourceDescriptions.getAllResourceDescriptions());\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, numResources);\n\t\tsubMonitor.subTask(\"Find references in EMF resources\");\n\t\ttry {\n\t\t\tfor (IResourceDescription resourceDescription : resourceDescriptions.getAllResourceDescriptions()) {\n\t\t\t\tURI resourceURI = resourceDescription.getURI();\n\t\t\t\tIResourceServiceProvider resourceServiceProvider = serviceProviderRegistry.getResourceServiceProvider(resourceURI);\n\t\t\t\tif(resourceServiceProvider == null)\n\t\t\t\t\treturn;\n\t\t\t\tIJavaSearchParticipation javaSearchParticipation = resourceServiceProvider\n\t\t\t\t\t\t.get(IJavaSearchParticipation.class);\n\t\t\t\tif(javaSearchParticipation == null || javaSearchParticipation.canContainJvmReferences(resourceURI))\n\t\t\t\t\tsearchIn(uri, resourceDescription);\n\t\t\t\tif (subMonitor.isCanceled()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsubMonitor.worked(1);\n\t\t\t}\n\t\t\tfor(ResourceSet resourceSet: projectToResourceSet.values()) {\n\t\t\t\tresourceSet.getResources().clear();\n\t\t\t\tresourceSet.eAdapters().clear();\n\t\t\t}\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","commit_id":"b707c44eb3fb50998eb60d26627315bb65892023","url":"https://github.com/eclipse/xtext"},{"original_method":"protected CopyQualifiedNameService getCopyQualifiedNameService(EObject selectedElement) {\n\t\tif (selectedElement == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn registry.getResourceServiceProvider(selectedElement.eResource().getURI()).get(CopyQualifiedNameService.class);\n\t}","id":97692,"modified_method":"protected CopyQualifiedNameService getCopyQualifiedNameService(EObject selectedElement) {\n\t\tif (selectedElement == null) {\n\t\t\treturn null;\n\t\t}\n\t\tIResourceServiceProvider resourceServiceProvider = registry.getResourceServiceProvider(selectedElement.eResource().getURI());\n\t\tif (resourceServiceProvider == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn resourceServiceProvider.get(CopyQualifiedNameService.class);\n\t}","commit_id":"c870371a71ec8405a01c6a2eeb3e9c1146442163","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @since 2.4\n\t */\n\tprotected void findAllIndexedReferences(IAcceptor<IReferenceDescription> referenceAcceptor, SubMonitor subMonitor,\n\t\t\tSet<URI> targetURIsAsSet, ILocalResourceAccess localResourceAccess) {\n\t\tsubMonitor.setWorkRemaining(size(indexData.getAllResourceDescriptions()));\n\t\tfor (IResourceDescription resourceDescription : indexData.getAllResourceDescriptions()) {\n\t\t\tIResourceServiceProvider serviceProvider = serviceProviderRegistry.getResourceServiceProvider(resourceDescription.getURI());\n\t\t\tIReferenceFinder referenceFinder = serviceProvider.get(IReferenceFinder.class);\n\t\t\tif (referenceFinder instanceof IReferenceFinderExtension1) {\n\t\t\t\tIReferenceFinderExtension1 extension1 = (IReferenceFinderExtension1) referenceFinder;\n\t\t\t\textension1.findReferences(targetURIsAsSet, resourceDescription, referenceAcceptor, subMonitor.newChild(1), localResourceAccess);\n\t\t\t} else {\n\t\t\t\t// don't use the language specific reference finder here for backwards compatibility reasons\n\t\t\t\tfindReferences(targetURIsAsSet, resourceDescription, referenceAcceptor, subMonitor.newChild(1), localResourceAccess);\n\t\t\t}\n\t\t}\n\t}","id":97693,"modified_method":"/**\n\t * @since 2.4\n\t */\n\tprotected void findAllIndexedReferences(IAcceptor<IReferenceDescription> referenceAcceptor, SubMonitor subMonitor,\n\t\t\tSet<URI> targetURIsAsSet, ILocalResourceAccess localResourceAccess) {\n\t\tsubMonitor.setWorkRemaining(size(indexData.getAllResourceDescriptions()));\n\t\tfor (IResourceDescription resourceDescription : indexData.getAllResourceDescriptions()) {\n\t\t\tIResourceServiceProvider serviceProvider = serviceProviderRegistry.getResourceServiceProvider(resourceDescription.getURI());\n\t\t\tif (serviceProvider != null) {\n\t\t\t\tIReferenceFinder referenceFinder = serviceProvider.get(IReferenceFinder.class);\n\t\t\t\tif (referenceFinder instanceof IReferenceFinderExtension1) {\n\t\t\t\t\tIReferenceFinderExtension1 extension1 = (IReferenceFinderExtension1) referenceFinder;\n\t\t\t\t\textension1.findReferences(targetURIsAsSet, resourceDescription, referenceAcceptor, subMonitor.newChild(1), localResourceAccess);\n\t\t\t\t} else {\n\t\t\t\t\t// don't use the language specific reference finder here for backwards compatibility reasons\n\t\t\t\t\tfindReferences(targetURIsAsSet, resourceDescription, referenceAcceptor, subMonitor.newChild(1), localResourceAccess);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"c870371a71ec8405a01c6a2eeb3e9c1146442163","url":"https://github.com/eclipse/xtext"},{"original_method":"public IHyperlink[] detectHyperlinks(ITextViewer textViewer, IRegion region, boolean canShowMultipleHyperlinks) {\n\t\ttry {\n\t\t\t// very pessimistic guards - most things should never happen\n\t\t\tITextEditor textEditor = (ITextEditor) getAdapter(ITextEditor.class);\n\t\t\tif (textEditor == null)\n\t\t\t\treturn null;\n\t\t\tIEditorInput editorInput = textEditor.getEditorInput();\n\t\t\tif (editorInput == null)\n\t\t\t\treturn null;\n\t\t\tIJavaElement adaptedJavaElement = (IJavaElement) Platform.getAdapterManager().getAdapter(editorInput, IJavaElement.class);\n\t\t\tif (adaptedJavaElement == null)\n\t\t\t\treturn null;\n\t\t\tICompilationUnit compilationUnit = (ICompilationUnit) adaptedJavaElement.getAncestor(IJavaElement.COMPILATION_UNIT);\n\t\t\tif (compilationUnit == null)\n\t\t\t\treturn null;\n\t\t\ttry {\n\t\t\t\tIRegion selectedWord = org.eclipse.jdt.internal.ui.text.JavaWordFinder.findWord(\n\t\t\t\t\t\ttextViewer.getDocument(), region.getOffset());\n\t\t\t\t// the actual implementation - find the referenced Java type under the cursor and link\n\t\t\t\t// to its origin if it's contained in a 'derived' resource\n\t\t\t\tIJavaElement[] javaElements = compilationUnit.codeSelect(selectedWord.getOffset(), selectedWord.getLength());\n\t\t\t\tfor(IJavaElement javaElement: javaElements) {\n\t\t\t\t\t/**\n\t\t\t\t\t * if IDE 3.8 is available the default 'Open Declaration' navigation will already open the original editor\n\t\t\t\t\t * So we don't need the additional hyperlinks.\n\t\t\t\t\t */\n\t\t\t\t\tboolean provideHyperlinkOnReferences = !is_ORG_ECLIPSE_UI_IDE_3_8_Enabled() || compilationUnit.equals(((IMember) javaElement).getCompilationUnit());\n\t\t\t\t\tif (javaElement instanceof IMember && provideHyperlinkOnReferences) {\n\t\t\t\t\t\tIMember selectedMember = (IMember) javaElement;\n\t\t\t\t\t\tIResource resource = selectedMember.getResource();\n\t\t\t\t\t\tif (resource instanceof IFile) {\n\t\t\t\t\t\t\tITrace traceToSource = traceInformation.getTraceToSource((IStorage) resource);\n\t\t\t\t\t\t\tif (traceToSource == null) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tIterable<ILocationInResource> sourceInformation = traceToSource.getAllAssociatedLocations(new TextRegion(selectedWord.getOffset(), selectedWord.getLength()));\n\t\t\t\t\t\t\tList<ILocationInResource> sourceInformationAsList = Lists.newArrayList(sourceInformation);\n\t\t\t\t\t\t\tif (!canShowMultipleHyperlinks && sourceInformationAsList.size() > 1)\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\tList<LinkToOrigin> result = Lists.newArrayListWithCapacity(sourceInformationAsList.size());\n\t\t\t\t\t\t\tfor(ILocationInResource source: sourceInformationAsList) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tURI resourceURI = source.getAbsoluteResourceURI();\n\t\t\t\t\t\t\t\t\tif (resourceURI != null) {\n\t\t\t\t\t\t\t\t\t\tIResourceServiceProvider serviceProvider = serviceProviderRegistry.getResourceServiceProvider(resourceURI);\n\t\t\t\t\t\t\t\t\t\tLinkToOriginProvider provider = serviceProvider.get(LinkToOriginProvider.class);\n\t\t\t\t\t\t\t\t\t\tLinkToOrigin hyperlink = provider.createLinkToOrigin(source, selectedWord, selectedMember, compilationUnit, result);\n\t\t\t\t\t\t\t\t\t\tif (hyperlink != null) {\n\t\t\t\t\t\t\t\t\t\t\tresult.add(hyperlink);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch(IllegalArgumentException e) { /* invalid URI - ignore */ }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (result.isEmpty())\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\treturn result.toArray(new IHyperlink[result.size()]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t} catch (JavaModelException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch(Throwable t) {\n\t\t\treturn null;\n\t\t}\n\t}","id":97694,"modified_method":"public IHyperlink[] detectHyperlinks(ITextViewer textViewer, IRegion region, boolean canShowMultipleHyperlinks) {\n\t\ttry {\n\t\t\t// very pessimistic guards - most things should never happen\n\t\t\tITextEditor textEditor = (ITextEditor) getAdapter(ITextEditor.class);\n\t\t\tif (textEditor == null)\n\t\t\t\treturn null;\n\t\t\tIEditorInput editorInput = textEditor.getEditorInput();\n\t\t\tif (editorInput == null)\n\t\t\t\treturn null;\n\t\t\tIJavaElement adaptedJavaElement = (IJavaElement) Platform.getAdapterManager().getAdapter(editorInput, IJavaElement.class);\n\t\t\tif (adaptedJavaElement == null)\n\t\t\t\treturn null;\n\t\t\tICompilationUnit compilationUnit = (ICompilationUnit) adaptedJavaElement.getAncestor(IJavaElement.COMPILATION_UNIT);\n\t\t\tif (compilationUnit == null)\n\t\t\t\treturn null;\n\t\t\ttry {\n\t\t\t\tIRegion selectedWord = org.eclipse.jdt.internal.ui.text.JavaWordFinder.findWord(\n\t\t\t\t\t\ttextViewer.getDocument(), region.getOffset());\n\t\t\t\t// the actual implementation - find the referenced Java type under the cursor and link\n\t\t\t\t// to its origin if it's contained in a 'derived' resource\n\t\t\t\tIJavaElement[] javaElements = compilationUnit.codeSelect(selectedWord.getOffset(), selectedWord.getLength());\n\t\t\t\tfor(IJavaElement javaElement: javaElements) {\n\t\t\t\t\t/**\n\t\t\t\t\t * if IDE 3.8 is available the default 'Open Declaration' navigation will already open the original editor\n\t\t\t\t\t * So we don't need the additional hyperlinks.\n\t\t\t\t\t */\n\t\t\t\t\tboolean provideHyperlinkOnReferences = !is_ORG_ECLIPSE_UI_IDE_3_8_Enabled() || compilationUnit.equals(((IMember) javaElement).getCompilationUnit());\n\t\t\t\t\tif (javaElement instanceof IMember && provideHyperlinkOnReferences) {\n\t\t\t\t\t\tIMember selectedMember = (IMember) javaElement;\n\t\t\t\t\t\tIResource resource = selectedMember.getResource();\n\t\t\t\t\t\tif (resource instanceof IFile) {\n\t\t\t\t\t\t\tITrace traceToSource = traceInformation.getTraceToSource((IStorage) resource);\n\t\t\t\t\t\t\tif (traceToSource == null) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tIterable<ILocationInResource> sourceInformation = traceToSource.getAllAssociatedLocations(new TextRegion(selectedWord.getOffset(), selectedWord.getLength()));\n\t\t\t\t\t\t\tList<ILocationInResource> sourceInformationAsList = Lists.newArrayList(sourceInformation);\n\t\t\t\t\t\t\tif (!canShowMultipleHyperlinks && sourceInformationAsList.size() > 1)\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\tList<LinkToOrigin> result = Lists.newArrayListWithCapacity(sourceInformationAsList.size());\n\t\t\t\t\t\t\tfor(ILocationInResource source: sourceInformationAsList) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tURI resourceURI = source.getAbsoluteResourceURI();\n\t\t\t\t\t\t\t\t\tif (resourceURI != null) {\n\t\t\t\t\t\t\t\t\t\tIResourceServiceProvider serviceProvider = serviceProviderRegistry.getResourceServiceProvider(resourceURI);\n\t\t\t\t\t\t\t\t\t\tif (serviceProvider == null)\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\tLinkToOriginProvider provider = serviceProvider.get(LinkToOriginProvider.class);\n\t\t\t\t\t\t\t\t\t\tLinkToOrigin hyperlink = provider.createLinkToOrigin(source, selectedWord, selectedMember, compilationUnit, result);\n\t\t\t\t\t\t\t\t\t\tif (hyperlink != null) {\n\t\t\t\t\t\t\t\t\t\t\tresult.add(hyperlink);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch(IllegalArgumentException e) { /* invalid URI - ignore */ }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (result.isEmpty())\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\treturn result.toArray(new IHyperlink[result.size()]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t} catch (JavaModelException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch(Throwable t) {\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"c870371a71ec8405a01c6a2eeb3e9c1146442163","url":"https://github.com/eclipse/xtext"},{"original_method":"protected IReferenceUpdater getReferenceUpdater(URI sourceResourceURI) {\n\t\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n\t\t\t\t\t.getResourceServiceProvider(sourceResourceURI);\n\t\t\tIReferenceUpdater referenceUpdater = provider2updater.get(resourceServiceProvider);\n\t\t\tif (referenceUpdater == null) {\n\t\t\t\treferenceUpdater = resourceServiceProvider.get(OptionalReferenceUpdaterProxy.class).get();\n\t\t\t\tif (referenceUpdater != null)\n\t\t\t\t\tprovider2updater.put(resourceServiceProvider, referenceUpdater);\n\t\t\t}\n\t\t\treturn referenceUpdater;\n\t\t}","id":97695,"modified_method":"protected IReferenceUpdater getReferenceUpdater(URI sourceResourceURI) {\n\t\t\t//TODO Why do we cache the IReferenceUpdater here?\n\t\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n\t\t\t\t\t.getResourceServiceProvider(sourceResourceURI);\n\t\t\tif (resourceServiceProvider == null)\n\t\t\t\treturn null;\n\t\t\tIReferenceUpdater referenceUpdater = provider2updater.get(resourceServiceProvider);\n\t\t\tif (referenceUpdater == null) {\n\t\t\t\treferenceUpdater = resourceServiceProvider.get(OptionalReferenceUpdaterProxy.class).get();\n\t\t\t\tif (referenceUpdater != null)\n\t\t\t\t\tprovider2updater.put(resourceServiceProvider, referenceUpdater);\n\t\t\t}\n\t\t\treturn referenceUpdater;\n\t\t}","commit_id":"c870371a71ec8405a01c6a2eeb3e9c1146442163","url":"https://github.com/eclipse/xtext"},{"original_method":"protected String getClassNamePattern(IResource res) {\n\t\tif (!(res instanceof IStorage))\n\t\t\treturn null;\n\t\tURI uri = uriMapper.getUri((IStorage) res);\n\t\tIResourceServiceProvider provider = providerRegistry.getResourceServiceProvider(uri);\n\t\tIResourceSetProvider resourceSetProvider = provider.get(IResourceSetProvider.class);\n\t\tResourceSet set = resourceSetProvider.get(res.getProject());\n\t\tResource resource = set.getResource(uri, true);\n\t\tif (resource instanceof XtextResource) {\n\t\t\treturn getClassNamePattern((XtextResource) resource);\n\t\t}\n\t\treturn null;\n\t}","id":97696,"modified_method":"protected String getClassNamePattern(IResource res) {\n\t\tif (!(res instanceof IStorage))\n\t\t\treturn null;\n\t\tURI uri = uriMapper.getUri((IStorage) res);\n\t\tIResourceServiceProvider provider = providerRegistry.getResourceServiceProvider(uri);\n\t\tif (provider == null)\n\t\t\treturn null;\n\t\tIResourceSetProvider resourceSetProvider = provider.get(IResourceSetProvider.class);\n\t\tResourceSet set = resourceSetProvider.get(res.getProject());\n\t\tResource resource = set.getResource(uri, true);\n\t\tif (resource instanceof XtextResource) {\n\t\t\treturn getClassNamePattern((XtextResource) resource);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"c870371a71ec8405a01c6a2eeb3e9c1146442163","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    public ExecutorService newCachedThreadPool(Object source, String name) {\n        String sanitizedName = URISupport.sanitizeUri(name);\n        ExecutorService answer = threadPoolFactory.newCachedThreadPool(createThreadFactory(sanitizedName, true));\n        onThreadPoolCreated(answer, source, null);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Created new CachedThreadPool for source: {} with name: {}. -> {}\", new Object[]{source, sanitizedName, answer});\n        }\n        return answer;\n    }","id":97697,"modified_method":"@Override\n    public ExecutorService newCachedThreadPool(Object source, String name) {\n        String sanitizedName = URISupport.sanitizeUri(name);\n        ExecutorService answer = threadPoolFactory.newCachedThreadPool(createThreadFactory(sanitizedName, true));\n        onThreadPoolCreated(answer, source, null);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Created new CachedThreadPool for source: {} with name: {}. -> {}\", source, sanitizedName, answer);\n        }\n        return answer;\n    }","commit_id":"1413c1f4776ee28a01b82772c792178277e1bd52","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public ExecutorService newThreadPool(Object source, String name, ThreadPoolProfile profile) {\n        String sanitizedName = URISupport.sanitizeUri(name);\n        ObjectHelper.notNull(profile, \"ThreadPoolProfile\");\n\n        ThreadPoolProfile defaultProfile = getDefaultThreadPoolProfile();\n        profile.addDefaults(defaultProfile);\n\n        ThreadFactory threadFactory = createThreadFactory(sanitizedName, true);\n        ExecutorService executorService = threadPoolFactory.newThreadPool(profile, threadFactory);\n        onThreadPoolCreated(executorService, source, profile.getId());\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Created new ThreadPool for source: {} with name: {}. -> {}\", new Object[]{source, sanitizedName, executorService});\n        }\n\n        return executorService;\n    }","id":97698,"modified_method":"@Override\n    public ExecutorService newThreadPool(Object source, String name, ThreadPoolProfile profile) {\n        String sanitizedName = URISupport.sanitizeUri(name);\n        ObjectHelper.notNull(profile, \"ThreadPoolProfile\");\n\n        ThreadPoolProfile defaultProfile = getDefaultThreadPoolProfile();\n        profile.addDefaults(defaultProfile);\n\n        ThreadFactory threadFactory = createThreadFactory(sanitizedName, true);\n        ExecutorService executorService = threadPoolFactory.newThreadPool(profile, threadFactory);\n        onThreadPoolCreated(executorService, source, profile.getId());\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Created new ThreadPool for source: {} with name: {}. -> {}\", source, sanitizedName, executorService);\n        }\n\n        return executorService;\n    }","commit_id":"1413c1f4776ee28a01b82772c792178277e1bd52","url":"https://github.com/apache/camel"},{"original_method":"private boolean doShutdown(ExecutorService executorService, long shutdownAwaitTermination, boolean failSafe) {\n        if (executorService == null) {\n            return false;\n        }\n\n        boolean warned = false;\n\n        // shutting down a thread pool is a 2 step process. First we try graceful, and if that fails, then we go more aggressively\n        // and try shutting down again. In both cases we wait at most the given shutdown timeout value given\n        // (total wait could then be 2 x shutdownAwaitTermination, but when we shutdown the 2nd time we are aggressive and thus\n        // we ought to shutdown much faster)\n        if (!executorService.isShutdown()) {\n            StopWatch watch = new StopWatch();\n\n            LOG.trace(\"Shutdown of ExecutorService: {} with await termination: {} millis\", executorService, shutdownAwaitTermination);\n            executorService.shutdown();\n\n            if (shutdownAwaitTermination > 0) {\n                try {\n                    if (!awaitTermination(executorService, shutdownAwaitTermination)) {\n                        warned = true;\n                        LOG.warn(\"Forcing shutdown of ExecutorService: {} due first await termination elapsed.\", executorService);\n                        executorService.shutdownNow();\n                        // we are now shutting down aggressively, so wait to see if we can completely shutdown or not\n                        if (!awaitTermination(executorService, shutdownAwaitTermination)) {\n                            LOG.warn(\"Cannot completely force shutdown of ExecutorService: {} due second await termination elapsed.\", executorService);\n                        }\n                    }\n                } catch (InterruptedException e) {\n                    warned = true;\n                    LOG.warn(\"Forcing shutdown of ExecutorService: {} due interrupted.\", executorService);\n                    // we were interrupted during shutdown, so force shutdown\n                    executorService.shutdownNow();\n                }\n            }\n\n            // if we logged at WARN level, then report at INFO level when we are complete so the end user can see this in the log\n            if (warned) {\n                LOG.info(\"Shutdown of ExecutorService: {} is shutdown: {} and terminated: {} took: {}.\",\n                        new Object[]{executorService, executorService.isShutdown(), executorService.isTerminated(), TimeUtils.printDuration(watch.taken())});\n            } else if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Shutdown of ExecutorService: {} is shutdown: {} and terminated: {} took: {}.\",\n                    new Object[]{executorService, executorService.isShutdown(), executorService.isTerminated(), TimeUtils.printDuration(watch.taken())});\n            }\n        }\n\n        // let lifecycle strategy be notified as well which can let it be managed in JMX as well\n        ThreadPoolExecutor threadPool = null;\n        if (executorService instanceof ThreadPoolExecutor) {\n            threadPool = (ThreadPoolExecutor) executorService;\n        } else if (executorService instanceof SizedScheduledExecutorService) {\n            threadPool = ((SizedScheduledExecutorService) executorService).getScheduledThreadPoolExecutor();\n        }\n        if (threadPool != null) {\n            for (LifecycleStrategy lifecycle : camelContext.getLifecycleStrategies()) {\n                lifecycle.onThreadPoolRemove(camelContext, threadPool);\n            }\n        }\n\n        // remove reference as its shutdown (do not remove if fail-safe)\n        if (!failSafe) {\n            executorServices.remove(executorService);\n        }\n\n        return warned;\n    }","id":97699,"modified_method":"private boolean doShutdown(ExecutorService executorService, long shutdownAwaitTermination, boolean failSafe) {\n        if (executorService == null) {\n            return false;\n        }\n\n        boolean warned = false;\n\n        // shutting down a thread pool is a 2 step process. First we try graceful, and if that fails, then we go more aggressively\n        // and try shutting down again. In both cases we wait at most the given shutdown timeout value given\n        // (total wait could then be 2 x shutdownAwaitTermination, but when we shutdown the 2nd time we are aggressive and thus\n        // we ought to shutdown much faster)\n        if (!executorService.isShutdown()) {\n            StopWatch watch = new StopWatch();\n\n            LOG.trace(\"Shutdown of ExecutorService: {} with await termination: {} millis\", executorService, shutdownAwaitTermination);\n            executorService.shutdown();\n\n            if (shutdownAwaitTermination > 0) {\n                try {\n                    if (!awaitTermination(executorService, shutdownAwaitTermination)) {\n                        warned = true;\n                        LOG.warn(\"Forcing shutdown of ExecutorService: {} due first await termination elapsed.\", executorService);\n                        executorService.shutdownNow();\n                        // we are now shutting down aggressively, so wait to see if we can completely shutdown or not\n                        if (!awaitTermination(executorService, shutdownAwaitTermination)) {\n                            LOG.warn(\"Cannot completely force shutdown of ExecutorService: {} due second await termination elapsed.\", executorService);\n                        }\n                    }\n                } catch (InterruptedException e) {\n                    warned = true;\n                    LOG.warn(\"Forcing shutdown of ExecutorService: {} due interrupted.\", executorService);\n                    // we were interrupted during shutdown, so force shutdown\n                    executorService.shutdownNow();\n                }\n            }\n\n            // if we logged at WARN level, then report at INFO level when we are complete so the end user can see this in the log\n            if (warned) {\n                LOG.info(\"Shutdown of ExecutorService: {} is shutdown: {} and terminated: {} took: {}.\",\n                    executorService, executorService.isShutdown(), executorService.isTerminated(), TimeUtils.printDuration(watch.taken()));\n            } else if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Shutdown of ExecutorService: {} is shutdown: {} and terminated: {} took: {}.\",\n                    executorService, executorService.isShutdown(), executorService.isTerminated(), TimeUtils.printDuration(watch.taken()));\n            }\n        }\n\n        // let lifecycle strategy be notified as well which can let it be managed in JMX as well\n        ThreadPoolExecutor threadPool = null;\n        if (executorService instanceof ThreadPoolExecutor) {\n            threadPool = (ThreadPoolExecutor) executorService;\n        } else if (executorService instanceof SizedScheduledExecutorService) {\n            threadPool = ((SizedScheduledExecutorService) executorService).getScheduledThreadPoolExecutor();\n        }\n        if (threadPool != null) {\n            for (LifecycleStrategy lifecycle : camelContext.getLifecycleStrategies()) {\n                lifecycle.onThreadPoolRemove(camelContext, threadPool);\n            }\n        }\n\n        // remove reference as its shutdown (do not remove if fail-safe)\n        if (!failSafe) {\n            executorServices.remove(executorService);\n        }\n\n        return warned;\n    }","commit_id":"1413c1f4776ee28a01b82772c792178277e1bd52","url":"https://github.com/apache/camel"},{"original_method":"private List<Runnable> doShutdownNow(ExecutorService executorService, boolean failSafe) {\n        ObjectHelper.notNull(executorService, \"executorService\");\n\n        List<Runnable> answer = null;\n        if (!executorService.isShutdown()) {\n            if (failSafe) {\n                // log as warn, as we shutdown as fail-safe, so end user should see more details in the log.\n                LOG.warn(\"Forcing shutdown of ExecutorService: {}\", executorService);\n            } else {\n                LOG.debug(\"Forcing shutdown of ExecutorService: {}\", executorService);\n            }\n            answer = executorService.shutdownNow();\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Shutdown of ExecutorService: {} is shutdown: {} and terminated: {}.\",\n                        new Object[]{executorService, executorService.isShutdown(), executorService.isTerminated()});\n            }\n        }\n\n        // let lifecycle strategy be notified as well which can let it be managed in JMX as well\n        ThreadPoolExecutor threadPool = null;\n        if (executorService instanceof ThreadPoolExecutor) {\n            threadPool = (ThreadPoolExecutor) executorService;\n        } else if (executorService instanceof SizedScheduledExecutorService) {\n            threadPool = ((SizedScheduledExecutorService) executorService).getScheduledThreadPoolExecutor();\n        }\n        if (threadPool != null) {\n            for (LifecycleStrategy lifecycle : camelContext.getLifecycleStrategies()) {\n                lifecycle.onThreadPoolRemove(camelContext, threadPool);\n            }\n        }\n\n        // remove reference as its shutdown (do not remove if fail-safe)\n        if (!failSafe) {\n            executorServices.remove(executorService);\n        }\n\n        return answer;\n    }","id":97700,"modified_method":"private List<Runnable> doShutdownNow(ExecutorService executorService, boolean failSafe) {\n        ObjectHelper.notNull(executorService, \"executorService\");\n\n        List<Runnable> answer = null;\n        if (!executorService.isShutdown()) {\n            if (failSafe) {\n                // log as warn, as we shutdown as fail-safe, so end user should see more details in the log.\n                LOG.warn(\"Forcing shutdown of ExecutorService: {}\", executorService);\n            } else {\n                LOG.debug(\"Forcing shutdown of ExecutorService: {}\", executorService);\n            }\n            answer = executorService.shutdownNow();\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Shutdown of ExecutorService: {} is shutdown: {} and terminated: {}.\",\n                    executorService, executorService.isShutdown(), executorService.isTerminated());\n            }\n        }\n\n        // let lifecycle strategy be notified as well which can let it be managed in JMX as well\n        ThreadPoolExecutor threadPool = null;\n        if (executorService instanceof ThreadPoolExecutor) {\n            threadPool = (ThreadPoolExecutor) executorService;\n        } else if (executorService instanceof SizedScheduledExecutorService) {\n            threadPool = ((SizedScheduledExecutorService) executorService).getScheduledThreadPoolExecutor();\n        }\n        if (threadPool != null) {\n            for (LifecycleStrategy lifecycle : camelContext.getLifecycleStrategies()) {\n                lifecycle.onThreadPoolRemove(camelContext, threadPool);\n            }\n        }\n\n        // remove reference as its shutdown (do not remove if fail-safe)\n        if (!failSafe) {\n            executorServices.remove(executorService);\n        }\n\n        return answer;\n    }","commit_id":"1413c1f4776ee28a01b82772c792178277e1bd52","url":"https://github.com/apache/camel"},{"original_method":"private ThreadFactory createThreadFactory(String name, boolean isDaemon) {\n        ThreadFactory threadFactory = new CamelThreadFactory(threadNamePattern, name, isDaemon);\n        return threadFactory;\n    }","id":97701,"modified_method":"private ThreadFactory createThreadFactory(String name, boolean isDaemon) {\n        return new CamelThreadFactory(threadNamePattern, name, isDaemon);\n    }","commit_id":"1413c1f4776ee28a01b82772c792178277e1bd52","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doShutdown() throws Exception {\n        // shutdown all remainder executor services by looping and doing this aggressively\n        // as by normal all threads pool should have been shutdown using proper lifecycle\n        // by their EIPs, components etc. This is acting as a fail-safe during shutdown\n        // of CamelContext itself.\n        Set<ExecutorService> forced = new LinkedHashSet<ExecutorService>();\n        if (!executorServices.isEmpty()) {\n            // at first give a bit of time to shutdown nicely as the thread pool is most likely in the process of being shutdown also\n            LOG.debug(\"Giving time for {} ExecutorService's to shutdown properly (acting as fail-safe)\", executorServices.size());\n            for (ExecutorService executorService : executorServices) {\n                try {\n                    boolean warned = doShutdown(executorService, getShutdownAwaitTermination(), true);\n                    // remember the thread pools that was forced to shutdown (eg warned)\n                    if (warned) {\n                        forced.add(executorService);\n                    }\n                } catch (Throwable e) {\n                    // only log if something goes wrong as we want to shutdown them all\n                    LOG.warn(\"Error occurred during shutdown of ExecutorService: \"\n                            + executorService + \". This exception will be ignored.\", e);\n                }\n            }\n        }\n\n        // log the thread pools which was forced to shutdown so it may help the user to identify a problem of his\n        if (!forced.isEmpty()) {\n            LOG.warn(\"Forced shutdown of {} ExecutorService's which has not been shutdown properly (acting as fail-safe)\", forced.size());\n            for (ExecutorService executorService : forced) {\n                LOG.warn(\"  forced -> {}\", executorService);\n            }\n        }\n        forced.clear();\n\n        // clear list\n        executorServices.clear();\n\n        // do not clear the default profile as we could potential be restarted\n        Iterator<ThreadPoolProfile> it = threadPoolProfiles.values().iterator();\n        while (it.hasNext()) {\n            ThreadPoolProfile profile = it.next();\n            if (!profile.isDefaultProfile()) {\n                it.remove();\n            }\n        }\n    }","id":97702,"modified_method":"@Override\n    protected void doShutdown() throws Exception {\n        // shutdown all remainder executor services by looping and doing this aggressively\n        // as by normal all threads pool should have been shutdown using proper lifecycle\n        // by their EIPs, components etc. This is acting as a fail-safe during shutdown\n        // of CamelContext itself.\n        Set<ExecutorService> forced = new LinkedHashSet<>();\n        if (!executorServices.isEmpty()) {\n            // at first give a bit of time to shutdown nicely as the thread pool is most likely in the process of being shutdown also\n            LOG.debug(\"Giving time for {} ExecutorService's to shutdown properly (acting as fail-safe)\", executorServices.size());\n            for (ExecutorService executorService : executorServices) {\n                try {\n                    boolean warned = doShutdown(executorService, getShutdownAwaitTermination(), true);\n                    // remember the thread pools that was forced to shutdown (eg warned)\n                    if (warned) {\n                        forced.add(executorService);\n                    }\n                } catch (Throwable e) {\n                    // only log if something goes wrong as we want to shutdown them all\n                    LOG.warn(\"Error occurred during shutdown of ExecutorService: \"\n                            + executorService + \". This exception will be ignored.\", e);\n                }\n            }\n        }\n\n        // log the thread pools which was forced to shutdown so it may help the user to identify a problem of his\n        if (!forced.isEmpty()) {\n            LOG.warn(\"Forced shutdown of {} ExecutorService's which has not been shutdown properly (acting as fail-safe)\", forced.size());\n            for (ExecutorService executorService : forced) {\n                LOG.warn(\"  forced -> {}\", executorService);\n            }\n        }\n        forced.clear();\n\n        // clear list\n        executorServices.clear();\n\n        // do not clear the default profile as we could potential be restarted\n        Iterator<ThreadPoolProfile> it = threadPoolProfiles.values().iterator();\n        while (it.hasNext()) {\n            ThreadPoolProfile profile = it.next();\n            if (!profile.isDefaultProfile()) {\n                it.remove();\n            }\n        }\n    }","commit_id":"1413c1f4776ee28a01b82772c792178277e1bd52","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void setThreadNamePattern(String threadNamePattern) {\n        // must set camel id here in the pattern and let the other placeholders be resolved on demand\n        String name = threadNamePattern.replaceFirst(\"#camelId#\", this.camelContext.getName());\n        this.threadNamePattern = name;\n    }","id":97703,"modified_method":"@Override\n    public void setThreadNamePattern(String threadNamePattern) {\n        // must set camel id here in the pattern and let the other placeholders be resolved on demand\n        this.threadNamePattern = threadNamePattern.replaceFirst(\"#camelId#\", this.camelContext.getName());\n    }","commit_id":"1413c1f4776ee28a01b82772c792178277e1bd52","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public ScheduledExecutorService newScheduledThreadPool(Object source, String name, ThreadPoolProfile profile) {\n        String sanitizedName = URISupport.sanitizeUri(name);\n        profile.addDefaults(getDefaultThreadPoolProfile());\n        ScheduledExecutorService answer = threadPoolFactory.newScheduledThreadPool(profile, createThreadFactory(sanitizedName, true));\n        onThreadPoolCreated(answer, source, null);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Created new ScheduledThreadPool for source: {} with name: {}. -> {}\", new Object[]{source, sanitizedName, answer});\n        }\n        return answer;\n    }","id":97704,"modified_method":"@Override\n    public ScheduledExecutorService newScheduledThreadPool(Object source, String name, ThreadPoolProfile profile) {\n        String sanitizedName = URISupport.sanitizeUri(name);\n        profile.addDefaults(getDefaultThreadPoolProfile());\n        ScheduledExecutorService answer = threadPoolFactory.newScheduledThreadPool(profile, createThreadFactory(sanitizedName, true));\n        onThreadPoolCreated(answer, source, null);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Created new ScheduledThreadPool for source: {} with name: {}. -> {}\", source, sanitizedName, answer);\n        }\n        return answer;\n    }","commit_id":"1413c1f4776ee28a01b82772c792178277e1bd52","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * @see org.xwiki.rendering.macro.MacroCategoriesManager#getMacroNames(String, org.xwiki.rendering.parser.Syntax)   \n     */\n    public Set<String> getMacroNames(String category, final Syntax syntax) throws MacroLookupException\n    {\n        Set<String> macros = getMacroNamesByCategory(new MacroMatcher() {\n            public boolean match(String macroName)\n            {\n                return macroManager.exists(macroName, syntax);\n            }\n        }).get(category);\n        return Collections.unmodifiableSet(macros);\n    }","id":97705,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * @see org.xwiki.rendering.macro.MacroCategoriesManager#getMacroNames(String, org.xwiki.rendering.parser.Syntax)   \n     */\n    public Set<String> getMacroNames(String category, final Syntax syntax) throws MacroLookupException\n    {\n        Set<String> macros = getMacroNamesByCategory(new MacroMatcher() {\n            public boolean match(String macroName)\n            {\n                return macroManager.exists(macroName, syntax);\n            }\n        }).get(category);\n        return (null != macros) ? Collections.unmodifiableSet(macros) : Collections.<String>emptySet();\n    }","commit_id":"01573df354778e81951d061f0a13bacea7d136e6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param matcher a macro name matcher to be able to filter macros, used to filter macros for a given syntax\n     * @return macro names grouped by category, including the 'null' macro category.\n     */\n    private Map<String, Set<String>> getMacroNamesByCategory(MacroMatcher matcher) throws MacroLookupException\n    {\n        Map<String, Set<String>> result = new HashMap<String, Set<String>>();\n\n        // Lookup all registered macros\n        Map<String, Macro> allMacros;\n        try {\n            allMacros = this.componentManager.lookupMap(Macro.class);\n        } catch (ComponentLookupException e) {\n            throw new MacroLookupException(\"Failed to lookup Macros\", e);\n        }\n\n        // Loop through all the macros and categorize them.\n        Properties categories = this.configuration.getMacroCategories();\n        for (Map.Entry<String, Macro> entry : allMacros.entrySet()) {\n            if (matcher.match(entry.getKey())) {\n                // Check if this macro's category has been overwritten.\n                String category = categories.getProperty(entry.getKey());\n\n                // If not, use the default category set by macro author.\n                category = (null == category) ? entry.getValue().getDescriptor().getDefaultCategory() : category;\n\n                // Add to category. Note the category can also be null.\n                Set<String> macroNames = result.get(category);\n                if (null == macroNames) {\n                    macroNames = new HashSet<String>();\n                }\n                macroNames.add(entry.getKey());\n                result.put(category, macroNames);\n            }\n        }\n\n        return result;\n    }","id":97706,"modified_method":"/**\n     * @param matcher a macro name matcher to be able to filter macros, used to filter macros for a given syntax\n     * @return macro names grouped by category, including the 'null' macro category.\n     */\n    private Map<String, Set<String>> getMacroNamesByCategory(MacroMatcher matcher) throws MacroLookupException\n    {\n        Map<String, Set<String>> result = new HashMap<String, Set<String>>();\n\n        // Lookup all registered macros\n        Map<String, Macro> allMacros;\n        try {\n            allMacros = this.componentManager.lookupMap(Macro.class);\n        } catch (ComponentLookupException e) {\n            throw new MacroLookupException(\"Failed to lookup Macros\", e);\n        }\n\n        // Loop through all the macros and categorize them.\n        Properties categories = this.configuration.getMacroCategories();\n        for (Map.Entry<String, Macro> entry : allMacros.entrySet()) {            \n            // Extract macro name.\n            String [] hintParts = entry.getKey().split(\"/\");\n            String macroName = null;\n            if (hintParts.length > 0) {\n                macroName = hintParts[0];\n            } else {\n                // Question: Will we ever reach this code?\n                getLogger().warn(\"Invalid macro hint : [\" + entry.getKey() + \"]\");\n                // Skip this macro.\n                continue;\n            }            \n            \n            // Build category map.\n            if (matcher.match(macroName)) {\n                // Check if this macro's category has been overwritten.\n                String category = categories.getProperty(entry.getKey());\n\n                // If not, use the default category set by macro author.\n                category = (null == category) ? entry.getValue().getDescriptor().getDefaultCategory() : category;\n\n                // Add to category. Note the category can also be null.\n                Set<String> macroNames = result.get(category);\n                if (null == macroNames) {\n                    macroNames = new HashSet<String>();\n                }\n                macroNames.add(macroName);\n                result.put(category, macroNames);\n            }\n        }\n\n        return result;\n    }","commit_id":"01573df354778e81951d061f0a13bacea7d136e6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * @see org.xwiki.rendering.macro.MacroCategoriesManager#getMacroNames(String)\n     */\n    public Set<String> getMacroNames(String category) throws MacroLookupException\n    {\n        Set<String> macros = getMacroNamesByCategory(new MacroMatcher() {\n            public boolean match(String macroName)\n            {\n                return true;\n            }\n        }).get(category);\n        return Collections.unmodifiableSet(macros);\n    }","id":97707,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * @see org.xwiki.rendering.macro.MacroCategoriesManager#getMacroNames(String)\n     */\n    public Set<String> getMacroNames(String category) throws MacroLookupException\n    {\n        Set<String> macros = getMacroNamesByCategory(new MacroMatcher() {\n            public boolean match(String macroName)\n            {\n                return true;\n            }\n        }).get(category);\n        return (null != macros) ? Collections.unmodifiableSet(macros) : Collections.<String>emptySet();\n    }","commit_id":"01573df354778e81951d061f0a13bacea7d136e6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters. \n     * \n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters, String templateSelector) throws CmsException {\n        if(C_DEBUG && A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"getting content of element \" + ((elementName == null) ? \"<root>\" : elementName));\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"template file is: \" + templateFile);\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"selected template section is: \" + ((templateSelector == null) ? \"<default>\" : templateSelector));\n        }\n        CmsXmlTemplateFile templateDocument = getOwnTemplateFile(cms, templateFile, elementName, parameters, templateSelector);\n        CmsRequestContext reqCont = cms.getRequestContext();\n        I_CmsRegistry reg = cms.getRegistry();\n        String step = (String)parameters.get(C_ACTION);\n        String moduleName = (String)parameters.get(C_MODULE);\n        if((step != null) && (\"ok\".equals(step))) {\n            \n            // export\n            String exportName = (String)parameters.get(\"modulename\");\n            String[] resourcen = new String[4];\n            resourcen[0] = \"/system/modules/\" + exportName + \"/\";\n            resourcen[1] = \"/system/classes/\" + exportName.replace('.', '/') + \"/\";\n            resourcen[2] = \"/moduledemos/\" + exportName + \"/\";\n            resourcen[3] = \"/content/bodys/moduledemos/\" + exportName + \"/\";\n            \n            // TODO: this is just a Hack\n            for(int i = 1;i < 4;i++) {\n                try {\n                    cms.readFileHeader(resourcen[i]);\n                }\n                catch(CmsException e) {\n                    System.err.println(\"error exporting module: couldn't add \" + resourcen[i] + \" to Module\\n\" + Utils.getStackTrace(e));\n                    resourcen[i] = resourcen[0];\n                }\n            }\n            try {\n                cms.readFileHeader(resourcen[0]);\n            }\n            catch(CmsException e) {\n                System.err.println(\"error exporting module: couldn't add \" + resourcen[0] + \" to Module\\n\" + \"You dont have this module in this project!\");\n                return startProcessing(cms, templateDocument, elementName, parameters, \"done\");\n            }\n            \n            // end hack\n            reg.exportModule(exportName, resourcen, cms.readExportPath() + exportName + \"_\" + reg.getModuleVersion(exportName));\n            templateSelector = \"done\";\n        }\n        else {\n            \n            // first call\n            templateDocument.setData(\"modulename\", moduleName);\n        }\n        \n        // Now load the template file and start the processing\n        return startProcessing(cms, templateDocument, elementName, parameters, templateSelector);\n    }","id":97708,"modified_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters, String templateSelector) throws CmsException {\n        if(C_DEBUG && A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"getting content of element \" + ((elementName == null) ? \"<root>\" : elementName));\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"template file is: \" + templateFile);\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"selected template section is: \" + ((templateSelector == null) ? \"<default>\" : templateSelector));\n        }\n        CmsXmlTemplateFile templateDocument = getOwnTemplateFile(cms, templateFile, elementName, parameters, templateSelector);\n        CmsRequestContext reqCont = cms.getRequestContext();\n        I_CmsRegistry reg = cms.getRegistry();\n        String step = (String)parameters.get(C_ACTION);\n        String moduleName = (String)parameters.get(C_MODULE);\n        if((step != null) && (\"ok\".equals(step))) {\n\n            // export\n            String exportName = (String)parameters.get(\"modulename\");\n            String[] resourcen = new String[4];\n            resourcen[0] = \"/system/modules/\" + exportName + \"/\";\n            resourcen[1] = \"/system/classes/\" + exportName.replace('.', '/') + \"/\";\n            resourcen[2] = \"/moduledemos/\" + exportName + \"/\";\n            resourcen[3] = \"/content/bodys/moduledemos/\" + exportName + \"/\";\n\n            // TODO: this is just a Hack\n            for(int i = 1;i < 4;i++) {\n                try {\n                    cms.readFileHeader(resourcen[i]);\n                }\n                catch(CmsException e) {\n                    System.err.println(\"error exporting module: couldn't add \" + resourcen[i] + \" to Module\\n\" + Utils.getStackTrace(e));\n                    resourcen[i] = resourcen[0];\n                }\n            }\n            try {\n                cms.readFileHeader(resourcen[0]);\n            }\n            catch(CmsException e) {\n                System.err.println(\"error exporting module: couldn't add \" + resourcen[0] + \" to Module\\n\" + \"You dont have this module in this project!\");\n                return startProcessing(cms, templateDocument, elementName, parameters, \"done\");\n            }\n\n            // end hack\n            reg.exportModule(exportName, resourcen, com.opencms.boot.CmsBase.getAbsolutePath(cms.readExportPath()) + \"/\" + exportName + \"_\" + reg.getModuleVersion(exportName));\n            templateSelector = \"done\";\n        }\n        else {\n\n            // first call\n            templateDocument.setData(\"modulename\", moduleName);\n        }\n\n        // Now load the template file and start the processing\n        return startProcessing(cms, templateDocument, elementName, parameters, templateSelector);\n    }","commit_id":"7ef5cd818fa7f6084c633624f91dbee5220b916b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters. \n     * \n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters, String templateSelector) throws CmsException {\n        if(C_DEBUG && A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"getting content of element \" + ((elementName == null) ? \"<root>\" : elementName));\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"template file is: \" + templateFile);\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"selected template section is: \" + ((templateSelector == null) ? \"<default>\" : templateSelector));\n        }\n        \n        //CmsXmlTemplateFile xmlTemplateDocument = getOwnTemplateFile(cms, templateFile, elementName, parameters, templateSelector);\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms, templateFile);\n        \n        //Get the registry\n        I_CmsRegistry reg = cms.getRegistry();\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n        String errorNavigation = (String)parameters.get(C_FROMERRORPAGE);\n        if(errorNavigation != null) {\n            templateSelector = importModule(cms, reg, xmlTemplateDocument, session, null);\n            return startProcessing(cms, xmlTemplateDocument, elementName, parameters, templateSelector);\n        }\n        String step = (String)parameters.get(\"step\");\n        \n        // first look if there is already a thread running.\n        if((step != null) && (\"working\".equals(step))) {\n            \n            // Thread is already running\n            Thread doImport = (Thread)session.getValue(C_MODULE_THREAD);\n            if(doImport.isAlive()) {\n                String time = (String)parameters.get(\"time\");\n                int wert = Integer.parseInt(time);\n                wert += 20;\n                xmlTemplateDocument.setData(\"time\", \"\" + wert);\n                return startProcessing(cms, xmlTemplateDocument, elementName, parameters, C_WAIT);\n            }\n            else {\n                xmlTemplateDocument.clearcache();\n                return startProcessing(cms, xmlTemplateDocument, elementName, parameters, C_DONE);\n            }\n        }\n        if(step != null) {\n            if(\"server\".equals(step)) {\n                File modulefolder = new File(cms.readExportPath() + reg.C_MODULE_PATH);\n                if(!modulefolder.exists()) {\n                    boolean success = modulefolder.mkdir();\n                    if((!success) && A_OpenCms.isLogging()) {\n                        A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INFO, \"[CmsAccessFilesystem] Couldn't create folder \" + cms.readExportPath() + reg.C_MODULE_PATH + \".\");\n                    }\n                }\n                String listentrys = \"\";\n                if(modulefolder.exists()) {\n                    String[] modules = modulefolder.list();\n                    for(int i = 0;i < modules.length;i++) {\n                        xmlTemplateDocument.setData(\"modulname\", modules[i]);\n                        listentrys += xmlTemplateDocument.getProcessedDataValue(\"optionentry\");\n                    }\n                }\n                xmlTemplateDocument.setData(\"entries\", listentrys);\n                templateSelector = \"server\";\n            }\n            else {\n                if(\"local\".equals(step)) {\n                    templateSelector = \"local\";\n                }\n                else {\n                    if(\"localupload\".equals(step)) {\n                        \n                        // get the filename\n                        String filename = null;\n                        Enumeration files = cms.getRequestContext().getRequest().getFileNames();\n                        while(files.hasMoreElements()) {\n                            filename = (String)files.nextElement();\n                        }\n                        if(filename != null) {\n                            session.putValue(C_PARA_FILE, filename);\n                        }\n                        filename = (String)session.getValue(C_PARA_FILE);\n                        \n                        // get the filecontent\n                        byte[] filecontent = new byte[0];\n                        if(filename != null) {\n                            filecontent = cms.getRequestContext().getRequest().getFile(filename);\n                        }\n                        if(filecontent != null) {\n                            session.putValue(C_PARA_FILECONTENT, filecontent);\n                        }\n                        filecontent = (byte[])session.getValue(C_PARA_FILECONTENT);\n                        \n                        // first create the folder if it doesnt exists\n                        File discFolder = new File(cms.readExportPath() + reg.C_MODULE_PATH);\n                        if(!discFolder.exists()) {\n                            boolean success = discFolder.mkdir();\n                            if((!success) && A_OpenCms.isLogging()) {\n                                A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INFO, \"[CmsAccessFilesystem] Couldn't create folder \" + cms.readExportPath() + reg.C_MODULE_PATH + \".\");\n                            }\n                        }\n                        \n                        // now write the file into the modules dierectory in the exportpaht\n                        File discFile = new File(cms.readExportPath() + reg.C_MODULE_PATH + filename);\n                        try {\n                            \n                            // write the new file to disk\n                            OutputStream s = new FileOutputStream(discFile);\n                            s.write(filecontent);\n                            s.close();\n                        }\n                        catch(Exception e) {\n                            throw new CmsException(\"[\" + this.getClass().getName() + \"] \" + e.getMessage());\n                        }\n                        session.removeValue(C_MODULE_NAV);\n                        templateSelector = importModule(cms, reg, xmlTemplateDocument, session, cms.readExportPath() + reg.C_MODULE_PATH + filename);\n                    }\n                    else {\n                        if(\"serverupload\".equals(step)) {\n                            String filename = (String)parameters.get(\"moduleselect\");\n                            session.removeValue(C_MODULE_NAV);\n                            if((filename == null) || (\"\".equals(filename))) {\n                                templateSelector = C_DONE;\n                            }\n                            else {\n                                templateSelector = importModule(cms, reg, xmlTemplateDocument, session, cms.readExportPath() + reg.C_MODULE_PATH + filename);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Now load the template file and start the processing\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters, templateSelector);\n    }","id":97709,"modified_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters, String templateSelector) throws CmsException {\n        if(C_DEBUG && A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"getting content of element \" + ((elementName == null) ? \"<root>\" : elementName));\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"template file is: \" + templateFile);\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"selected template section is: \" + ((templateSelector == null) ? \"<default>\" : templateSelector));\n        }\n\n        //CmsXmlTemplateFile xmlTemplateDocument = getOwnTemplateFile(cms, templateFile, elementName, parameters, templateSelector);\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms, templateFile);\n\n        //Get the registry\n        I_CmsRegistry reg = cms.getRegistry();\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n        String errorNavigation = (String)parameters.get(C_FROMERRORPAGE);\n        if(errorNavigation != null) {\n            templateSelector = importModule(cms, reg, xmlTemplateDocument, session, null);\n            return startProcessing(cms, xmlTemplateDocument, elementName, parameters, templateSelector);\n        }\n        String step = (String)parameters.get(\"step\");\n\n        // first look if there is already a thread running.\n        if((step != null) && (\"working\".equals(step))) {\n\n            // Thread is already running\n            Thread doImport = (Thread)session.getValue(C_MODULE_THREAD);\n            if(doImport.isAlive()) {\n                String time = (String)parameters.get(\"time\");\n                int wert = Integer.parseInt(time);\n                wert += 20;\n                xmlTemplateDocument.setData(\"time\", \"\" + wert);\n                return startProcessing(cms, xmlTemplateDocument, elementName, parameters, C_WAIT);\n            }\n            else {\n                xmlTemplateDocument.clearcache();\n                return startProcessing(cms, xmlTemplateDocument, elementName, parameters, C_DONE);\n            }\n        }\n        if(step != null) {\n            if(\"server\".equals(step)) {\n                File modulefolder = new File(com.opencms.boot.CmsBase.getAbsolutePath(cms.readExportPath()) + \"/\" + reg.C_MODULE_PATH);\n                if(!modulefolder.exists()) {\n                    boolean success = modulefolder.mkdir();\n                    if((!success) && A_OpenCms.isLogging()) {\n                        A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INFO, \"[CmsAccessFilesystem] Couldn't create folder \" + com.opencms.boot.CmsBase.getAbsolutePath(cms.readExportPath()) + \"/\" + reg.C_MODULE_PATH + \".\");\n                    }\n                }\n                String listentrys = \"\";\n                if(modulefolder.exists()) {\n                    String[] modules = modulefolder.list();\n                    for(int i = 0;i < modules.length;i++) {\n                        xmlTemplateDocument.setData(\"modulname\", modules[i]);\n                        listentrys += xmlTemplateDocument.getProcessedDataValue(\"optionentry\");\n                    }\n                }\n                xmlTemplateDocument.setData(\"entries\", listentrys);\n                templateSelector = \"server\";\n            }\n            else {\n                if(\"local\".equals(step)) {\n                    templateSelector = \"local\";\n                }\n                else {\n                    if(\"localupload\".equals(step)) {\n\n                        // get the filename\n                        String filename = null;\n                        Enumeration files = cms.getRequestContext().getRequest().getFileNames();\n                        while(files.hasMoreElements()) {\n                            filename = (String)files.nextElement();\n                        }\n                        if(filename != null) {\n                            session.putValue(C_PARA_FILE, filename);\n                        }\n                        filename = (String)session.getValue(C_PARA_FILE);\n\n                        // get the filecontent\n                        byte[] filecontent = new byte[0];\n                        if(filename != null) {\n                            filecontent = cms.getRequestContext().getRequest().getFile(filename);\n                        }\n                        if(filecontent != null) {\n                            session.putValue(C_PARA_FILECONTENT, filecontent);\n                        }\n                        filecontent = (byte[])session.getValue(C_PARA_FILECONTENT);\n\n                        // first create the folder if it doesnt exists\n                        File discFolder = new File(com.opencms.boot.CmsBase.getAbsolutePath(cms.readExportPath()) + \"/\" + reg.C_MODULE_PATH);\n                        if(!discFolder.exists()) {\n                            boolean success = discFolder.mkdir();\n                            if((!success) && A_OpenCms.isLogging()) {\n                                A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INFO, \"[CmsAccessFilesystem] Couldn't create folder \" + com.opencms.boot.CmsBase.getAbsolutePath(cms.readExportPath()) + \"/\" + reg.C_MODULE_PATH + \".\");\n                            }\n                        }\n\n                        // now write the file into the modules dierectory in the exportpaht\n                        File discFile = new File(com.opencms.boot.CmsBase.getAbsolutePath(cms.readExportPath()) + \"/\" + reg.C_MODULE_PATH + filename);\n                        try {\n\n                            // write the new file to disk\n                            OutputStream s = new FileOutputStream(discFile);\n                            s.write(filecontent);\n                            s.close();\n                        }\n                        catch(Exception e) {\n                            throw new CmsException(\"[\" + this.getClass().getName() + \"] \" + e.getMessage());\n                        }\n                        session.removeValue(C_MODULE_NAV);\n                        templateSelector = importModule(cms, reg, xmlTemplateDocument, session, com.opencms.boot.CmsBase.getAbsolutePath(cms.readExportPath()) + \"/\" + reg.C_MODULE_PATH + filename);\n                    }\n                    else {\n                        if(\"serverupload\".equals(step)) {\n                            String filename = (String)parameters.get(\"moduleselect\");\n                            session.removeValue(C_MODULE_NAV);\n                            if((filename == null) || (\"\".equals(filename))) {\n                                templateSelector = C_DONE;\n                            }\n                            else {\n                                templateSelector = importModule(cms, reg, xmlTemplateDocument, session, com.opencms.boot.CmsBase.getAbsolutePath(cms.readExportPath()) + \"/\" + reg.C_MODULE_PATH + filename);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Now load the template file and start the processing\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters, templateSelector);\n    }","commit_id":"7ef5cd818fa7f6084c633624f91dbee5220b916b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets all export-files from the export-path.\n     * <P>\n     * The given vectors <code>names<\/code> and <code>values<\/code> will\n     * be filled with the appropriate information to be used for building\n     * a select box.\n     * <P>\n     * <code>names<\/code> will contain language specific view descriptions\n     * and <code>values<\/code> will contain the correspondig URL for each\n     * of these views after returning from this method.\n     * <P>\n     *\n     * @param cms CmsObject Object for accessing system resources.\n     * @param lang reference to the currently valid language file\n     * @param names Vector to be filled with the appropriate values in this method.\n     * @param values Vector to be filled with the appropriate values in this method.\n     * @param parameters Hashtable containing all user parameters <em>(not used here)<\/em>.\n     * @return Index representing the user's current filter view in the vectors.\n     * @exception CmsException\n     */\n\n    public Integer getExportFiles(CmsObject cms, CmsXmlLanguageFile lang, Vector values,\n            Vector names, Hashtable parameters) throws CmsException {\n\n        // get the systems-exportpath\n        String exportpath = cms.readExportPath();\n        File folder = new File(exportpath);\n        if (!folder.exists()){\n            folder.mkdirs();\n        }\n        // get a list of all files\n        String[] list = folder.list();\n        for(int i = 0;i < list.length;i++) {\n            File diskFile = new File(exportpath + list[i]);\n\n            // check if it is a file\n            if(diskFile.isFile()) {\n                values.addElement(list[i]);\n                names.addElement(list[i]);\n            }\n        }\n        return new Integer(0);\n    }","id":97710,"modified_method":"/**\n     * Gets all export-files from the export-path.\n     * <P>\n     * The given vectors <code>names<\/code> and <code>values<\/code> will\n     * be filled with the appropriate information to be used for building\n     * a select box.\n     * <P>\n     * <code>names<\/code> will contain language specific view descriptions\n     * and <code>values<\/code> will contain the correspondig URL for each\n     * of these views after returning from this method.\n     * <P>\n     *\n     * @param cms CmsObject Object for accessing system resources.\n     * @param lang reference to the currently valid language file\n     * @param names Vector to be filled with the appropriate values in this method.\n     * @param values Vector to be filled with the appropriate values in this method.\n     * @param parameters Hashtable containing all user parameters <em>(not used here)<\/em>.\n     * @return Index representing the user's current filter view in the vectors.\n     * @exception CmsException\n     */\n\n    public Integer getExportFiles(CmsObject cms, CmsXmlLanguageFile lang, Vector values,\n            Vector names, Hashtable parameters) throws CmsException {\n\n        // get the systems-exportpath\n        String exportpath = cms.readExportPath();\n        exportpath = CmsBase.getAbsolutePath(exportpath);\n        File folder = new File(exportpath);\n        if (!folder.exists()){\n            folder.mkdirs();\n        }\n        // get a list of all files\n        String[] list = folder.list(new FilenameFilter() {\n                public boolean accept(File dir, String fileName) {\n                        return(fileName.endsWith(\".zip\"));\n                }});\n        for(int i = 0;i < list.length;i++) {\n            File diskFile = new File(exportpath, list[i]);\n\n            // check if it is a file\n            if(diskFile.isFile()) {\n                values.addElement(list[i]);\n                names.addElement(list[i]);\n            }\n        }\n        return new Integer(0);\n    }","commit_id":"e17c30bf0eaaa371d2c7220831c5402eaf86e855","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters, String templateSelector) throws CmsException {\n        if(C_DEBUG && A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName()\n                    + \"getting content of element \"\n                            + ((elementName == null) ? \"<root>\" : elementName));\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName()\n                    + \"template file is: \" + templateFile);\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName()\n                    + \"selected template section is: \"\n                            + ((templateSelector == null) ? \"<default>\" : templateSelector));\n        }\n\n        //CmsXmlTemplateFile xmlTemplateDocument = getOwnTemplateFile(cms, templateFile, elementName, parameters, templateSelector);\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms, templateFile);\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n\n        // get the parameters\n        // String folder = (String)parameters.get(\"selectallfolders\");\n        String fileName = (String)parameters.get(\"filename\");\n        String existingFile = (String)parameters.get(\"existingfile\");\n        String action = (String)parameters.get(\"action\");\n        String allResources = (String)parameters.get(\"ALLRES\");\n        if(action == null) {\n\n            // This is an initial request of the database administration page\n            // Generate datablocks for checkboxes in the HTML form\n            if(!cms.getRequestContext().currentProject().equals(cms.onlineProject())) {\n                xmlTemplateDocument.setData(\"nounchanged\",\n                        xmlTemplateDocument.getProcessedDataValue(\"nounchangedbox\", this, parameters));\n            }\n            if(cms.isAdmin()) {\n                xmlTemplateDocument.setData(\"userdata\",\n                        xmlTemplateDocument.getProcessedDataValue(\"userdatabox\", this, parameters));\n            }\n        }\n\n        // first we look if the thread is allready running\n        if((action != null) && (\"working\".equals(action))) {\n\n            // still working?\n            Thread doTheWork = (Thread)session.getValue(C_DATABASE_THREAD);\n            if(doTheWork.isAlive()) {\n                String time = (String)parameters.get(\"time\");\n                int wert = Integer.parseInt(time);\n                wert += 20;\n                xmlTemplateDocument.setData(\"time\", \"\" + wert);\n                return startProcessing(cms, xmlTemplateDocument, elementName, parameters, \"wait\");\n            }\n            else {\n\n                // thread has come to an end, was there an error?\n                String errordetails = (String)session.getValue(C_SESSION_THREAD_ERROR);\n                if(errordetails == null) {\n\n                    // im/export ready\n                    return startProcessing(cms, xmlTemplateDocument, elementName, parameters, \"done\");\n                }\n                else {\n\n                    // get errorpage:\n                    xmlTemplateDocument.setData(\"details\", errordetails);\n                    session.removeValue(C_SESSION_THREAD_ERROR);\n                    return startProcessing(cms, xmlTemplateDocument, elementName, parameters, \"error\");\n                }\n            }\n        }\n        try {\n            if(\"export\".equals(action)) {\n\n                // export the database\n                Vector resourceNames = parseResources(allResources);\n                String[] exportPaths = new String[resourceNames.size()];\n                CmsXmlLanguageFile lang = xmlTemplateDocument.getLanguageFile();\n                for(int i = 0;i < resourceNames.size();i++) {\n\n                    // modify the foldername if nescessary (the root folder is always given\n                    // as a nice name)\n                    if(lang.getLanguageValue(\"title.rootfolder\").equals(resourceNames.elementAt(i))) {\n                        resourceNames.setElementAt(\"/\", i);\n                    }\n                    exportPaths[i] = (String)resourceNames.elementAt(i);\n                }\n                boolean excludeSystem = false;\n                if(parameters.get(\"nosystem\") != null) {\n                    excludeSystem = true;\n                }\n                boolean excludeUnchanged = false;\n                if(parameters.get(\"nounchanged\") != null) {\n                    excludeUnchanged = true;\n                }\n                boolean exportUserdata = false;\n                if(parameters.get(\"userdata\") != null) {\n                    exportUserdata = true;\n                }\n\n                // start the thread for: export\n                // first clear the session entry if necessary\n                if(session.getValue(C_SESSION_THREAD_ERROR) != null) {\n                    session.removeValue(C_SESSION_THREAD_ERROR);\n                }\n                Thread doExport = new CmsAdminDatabaseExportThread(cms, cms.readExportPath()\n                        + fileName, exportPaths, excludeSystem, excludeUnchanged, exportUserdata);\n                doExport.start();\n                session.putValue(C_DATABASE_THREAD, doExport);\n                xmlTemplateDocument.setData(\"time\", \"10\");\n                templateSelector = \"wait\";\n            }\n            else {\n                if(\"import\".equals(action)) {\n\n                    // start the thread for: import\n                    // first clear the session entry if necessary\n                    if(session.getValue(C_SESSION_THREAD_ERROR) != null) {\n                        session.removeValue(C_SESSION_THREAD_ERROR);\n                    }\n                    Thread doImport = new CmsAdminDatabaseImportThread(cms, cms.readExportPath()\n                            + existingFile);\n                    doImport.start();\n                    session.putValue(C_DATABASE_THREAD, doImport);\n                    xmlTemplateDocument.setData(\"time\", \"10\");\n                    templateSelector = \"wait\";\n                }\n            }\n        }\n        catch(CmsException exc) {\n            xmlTemplateDocument.setData(\"details\", Utils.getStackTrace(exc));\n            templateSelector = \"error\";\n        }\n\n        // Now load the template file and start the processing\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters,\n                templateSelector);\n    }","id":97711,"modified_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters, String templateSelector) throws CmsException {\n        if(C_DEBUG && A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName()\n                    + \"getting content of element \"\n                            + ((elementName == null) ? \"<root>\" : elementName));\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName()\n                    + \"template file is: \" + templateFile);\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName()\n                    + \"selected template section is: \"\n                            + ((templateSelector == null) ? \"<default>\" : templateSelector));\n        }\n\n        //CmsXmlTemplateFile xmlTemplateDocument = getOwnTemplateFile(cms, templateFile, elementName, parameters, templateSelector);\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms, templateFile);\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n\n        // get the parameters\n        // String folder = (String)parameters.get(\"selectallfolders\");\n        String fileName = (String)parameters.get(\"filename\");\n        String existingFile = (String)parameters.get(\"existingfile\");\n        String action = (String)parameters.get(\"action\");\n        String allResources = (String)parameters.get(\"ALLRES\");\n        if(action == null) {\n\n            // This is an initial request of the database administration page\n            // Generate datablocks for checkboxes in the HTML form\n            if(!cms.getRequestContext().currentProject().equals(cms.onlineProject())) {\n                xmlTemplateDocument.setData(\"nounchanged\",\n                        xmlTemplateDocument.getProcessedDataValue(\"nounchangedbox\", this, parameters));\n            }\n            if(cms.isAdmin()) {\n                xmlTemplateDocument.setData(\"userdata\",\n                        xmlTemplateDocument.getProcessedDataValue(\"userdatabox\", this, parameters));\n            }\n        }\n\n        // first we look if the thread is allready running\n        if((action != null) && (\"working\".equals(action))) {\n\n            // still working?\n            Thread doTheWork = (Thread)session.getValue(C_DATABASE_THREAD);\n            if(doTheWork.isAlive()) {\n                String time = (String)parameters.get(\"time\");\n                int wert = Integer.parseInt(time);\n                wert += 20;\n                xmlTemplateDocument.setData(\"time\", \"\" + wert);\n                return startProcessing(cms, xmlTemplateDocument, elementName, parameters, \"wait\");\n            }\n            else {\n\n                // thread has come to an end, was there an error?\n                String errordetails = (String)session.getValue(C_SESSION_THREAD_ERROR);\n                if(errordetails == null) {\n\n                    // im/export ready\n                    return startProcessing(cms, xmlTemplateDocument, elementName, parameters, \"done\");\n                }\n                else {\n\n                    // get errorpage:\n                    xmlTemplateDocument.setData(\"details\", errordetails);\n                    session.removeValue(C_SESSION_THREAD_ERROR);\n                    return startProcessing(cms, xmlTemplateDocument, elementName, parameters, \"error\");\n                }\n            }\n        }\n        try {\n            if(\"export\".equals(action)) {\n\n                // export the database\n                Vector resourceNames = parseResources(allResources);\n                String[] exportPaths = new String[resourceNames.size()];\n                CmsXmlLanguageFile lang = xmlTemplateDocument.getLanguageFile();\n                for(int i = 0;i < resourceNames.size();i++) {\n\n                    // modify the foldername if nescessary (the root folder is always given\n                    // as a nice name)\n                    if(lang.getLanguageValue(\"title.rootfolder\").equals(resourceNames.elementAt(i))) {\n                        resourceNames.setElementAt(\"/\", i);\n                    }\n                    exportPaths[i] = (String)resourceNames.elementAt(i);\n                }\n                boolean excludeSystem = false;\n                if(parameters.get(\"nosystem\") != null) {\n                    excludeSystem = true;\n                }\n                boolean excludeUnchanged = false;\n                if(parameters.get(\"nounchanged\") != null) {\n                    excludeUnchanged = true;\n                }\n                boolean exportUserdata = false;\n                if(parameters.get(\"userdata\") != null) {\n                    exportUserdata = true;\n                }\n\n                // start the thread for: export\n                // first clear the session entry if necessary\n                if(session.getValue(C_SESSION_THREAD_ERROR) != null) {\n                    session.removeValue(C_SESSION_THREAD_ERROR);\n                }\n                Thread doExport = new CmsAdminDatabaseExportThread(cms, CmsBase.getAbsolutePath(cms.readExportPath()) + File.separator\n                        + fileName, exportPaths, excludeSystem, excludeUnchanged, exportUserdata);\n                doExport.start();\n                session.putValue(C_DATABASE_THREAD, doExport);\n                xmlTemplateDocument.setData(\"time\", \"10\");\n                templateSelector = \"wait\";\n            }\n            else {\n                if(\"import\".equals(action)) {\n\n                    // start the thread for: import\n                    // first clear the session entry if necessary\n                    if(session.getValue(C_SESSION_THREAD_ERROR) != null) {\n                        session.removeValue(C_SESSION_THREAD_ERROR);\n                    }\n                    Thread doImport = new CmsAdminDatabaseImportThread(cms, CmsBase.getAbsolutePath(cms.readExportPath()) + File.separator\n                            + existingFile);\n                    doImport.start();\n                    session.putValue(C_DATABASE_THREAD, doImport);\n                    xmlTemplateDocument.setData(\"time\", \"10\");\n                    templateSelector = \"wait\";\n                }\n            }\n        }\n        catch(CmsException exc) {\n            xmlTemplateDocument.setData(\"details\", Utils.getStackTrace(exc));\n            templateSelector = \"error\";\n        }\n\n        // Now load the template file and start the processing\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters,\n                templateSelector);\n    }","commit_id":"e17c30bf0eaaa371d2c7220831c5402eaf86e855","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override\n    public WorkResult execute(final GroovyJavaJointCompileSpec spec) {\n        GroovySystemLoaderFactory groovySystemLoaderFactory = new GroovySystemLoaderFactory();\n        ClassLoader compilerClassLoader = this.getClass().getClassLoader();\n        GroovySystemLoader compilerGroovyLoader = groovySystemLoaderFactory.forClassLoader(compilerClassLoader);\n\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        configuration.setVerbose(spec.getGroovyCompileOptions().isVerbose());\n        configuration.setSourceEncoding(spec.getGroovyCompileOptions().getEncoding());\n        configuration.setTargetBytecode(spec.getTargetCompatibility());\n        configuration.setTargetDirectory(spec.getDestinationDir());\n        canonicalizeValues(spec.getGroovyCompileOptions().getOptimizationOptions());\n        if (spec.getGroovyCompileOptions().getConfigurationScript() != null) {\n            applyConfigurationScript(spec.getGroovyCompileOptions().getConfigurationScript(), configuration);\n        }\n        try {\n            configuration.setOptimizationOptions(spec.getGroovyCompileOptions().getOptimizationOptions());\n        } catch (NoSuchMethodError ignored) { /* method was only introduced in Groovy 1.8 */ }\n        Map<String, Object> jointCompilationOptions = new HashMap<String, Object>();\n        final File stubDir = spec.getGroovyCompileOptions().getStubDir();\n        stubDir.mkdirs();\n        jointCompilationOptions.put(\"stubDir\", stubDir);\n        jointCompilationOptions.put(\"keepStubs\", spec.getGroovyCompileOptions().isKeepStubs());\n        configuration.setJointCompilationOptions(jointCompilationOptions);\n\n        ClassLoader classPathLoader;\n        VersionNumber version = parseGroovyVersion();\n        if (version.compareTo(VersionNumber.parse(\"2.0\")) < 0) {\n            // using a transforming classloader is only required for older buggy Groovy versions\n            classPathLoader = new GroovyCompileTransformingClassLoader(getExtClassLoader(), new DefaultClassPath(spec.getClasspath()));\n        } else {\n            classPathLoader = new DefaultClassLoaderFactory().createIsolatedClassLoader(new DefaultClassPath(spec.getClasspath()));\n        }\n        GroovyClassLoader compileClasspathClassLoader = new GroovyClassLoader(classPathLoader, null);\n        GroovySystemLoader compileClasspathLoader = groovySystemLoaderFactory.forClassLoader(classPathLoader);\n\n        FilteringClassLoader.Spec groovyCompilerClassLoaderSpec = new FilteringClassLoader.Spec();\n        groovyCompilerClassLoaderSpec.allowPackage(\"org.codehaus.groovy\");\n        groovyCompilerClassLoaderSpec.allowPackage(\"groovy\");\n        // Disallow classes from Groovy Jar that reference external classes. Such classes must be loaded from astTransformClassLoader,\n        // or a NoClassDefFoundError will occur. Essentially this is drawing a line between the Groovy compiler and the Groovy\n        // library, albeit only for selected classes that run a high risk of being statically referenced from a transform.\n        groovyCompilerClassLoaderSpec.disallowClass(\"groovy.util.GroovyTestCase\");\n        groovyCompilerClassLoaderSpec.disallowPackage(\"groovy.servlet\");\n        FilteringClassLoader groovyCompilerClassLoader = new FilteringClassLoader(GroovyClassLoader.class.getClassLoader(), groovyCompilerClassLoaderSpec);\n\n        // AST transforms need their own class loader that shares compiler classes with the compiler itself\n        final GroovyClassLoader astTransformClassLoader = new GroovyClassLoader(groovyCompilerClassLoader, null);\n        // can't delegate to compileClasspathLoader because this would result in ASTTransformation interface\n        // (which is implemented by the transform class) being loaded by compileClasspathClassLoader (which is\n        // where the transform class is loaded from)\n        for (File file : spec.getClasspath()) {\n            astTransformClassLoader.addClasspath(file.getPath());\n        }\n        JavaAwareCompilationUnit unit = new JavaAwareCompilationUnit(configuration, compileClasspathClassLoader) {\n            @Override\n            public GroovyClassLoader getTransformLoader() {\n                return astTransformClassLoader;\n            }\n        };\n\n        final boolean shouldProcessAnnotations = shouldProcessAnnotations(astTransformClassLoader, spec);\n        if (shouldProcessAnnotations) {\n            // If an annotation processor is detected, we need to force Java stub generation, so the we can process annotations on Groovy classes\n            // We are forcing stub generation by tricking the groovy compiler into thinking there are java files to compile.\n            // All java files are just passed to the compile method of the JavaCompiler and aren't processed internally by the Groovy Compiler.\n            // Since we're maintaining our own list of Java files independent what's passed by the Groovy compiler, adding a non-existant java file\n            // to the sources won't cause any issues.\n            unit.addSources(new File[]{new File(\"ForceStubGeneration.java\")});\n        }\n\n        unit.addSources(Iterables.toArray(spec.getSource(), File.class));\n        unit.setCompilerFactory(new JavaCompilerFactory() {\n            public JavaCompiler createCompiler(final CompilerConfiguration config) {\n                return new JavaCompiler() {\n                    public void compile(List<String> files, CompilationUnit cu) {\n                        if (shouldProcessAnnotations) {\n                            // In order for the Groovy stubs to have annotation processors invoked against them, they must be compiled as source.\n                            // Classes compiled as a result of being on the -sourcepath do not have the annotation processor run against them\n                            spec.setSource(spec.getSource().plus(new SimpleFileCollection(stubDir).getAsFileTree()));\n                        } else {\n                            // When annotation processing isn't required, it's better to add the Groovy stubs as part of the source path.\n                            // This allows compilations to complete faster, because only the Groovy stubs that are needed by the java source are compiled.\n                            FileCollection sourcepath = new SimpleFileCollection(stubDir);\n                            if (spec.getCompileOptions().getSourcepath() != null) {\n                                sourcepath = spec.getCompileOptions().getSourcepath().plus(sourcepath);\n                            }\n                            spec.getCompileOptions().setSourcepath(sourcepath);\n                        }\n\n                        spec.setSource(spec.getSource().filter(new Spec<File>() {\n                            public boolean isSatisfiedBy(File file) {\n                                return hasExtension(file, \".java\");\n                            }\n                        }));\n\n                        try {\n                            javaCompiler.execute(spec);\n                        } catch (CompilationFailedException e) {\n                            cu.getErrorCollector().addFatalError(new SimpleMessage(e.getMessage(), cu));\n                        }\n                    }\n                };\n            }\n        });\n\n        try {\n            unit.compile();\n        } catch (org.codehaus.groovy.control.CompilationFailedException e) {\n            System.err.println(e.getMessage());\n            throw new CompilationFailedException();\n        } finally {\n            // Remove compile and AST types from the Groovy loader\n            compilerGroovyLoader.discardTypesFrom(classPathLoader);\n            compilerGroovyLoader.discardTypesFrom(astTransformClassLoader);\n            //Discard the compile loader\n            compileClasspathLoader.shutdown();\n        }\n\n        return new SimpleWorkResult(true);\n    }","id":97712,"modified_method":"@Override\n    public WorkResult execute(final GroovyJavaJointCompileSpec spec) {\n        GroovySystemLoaderFactory groovySystemLoaderFactory = new GroovySystemLoaderFactory();\n        ClassLoader compilerClassLoader = this.getClass().getClassLoader();\n        GroovySystemLoader compilerGroovyLoader = groovySystemLoaderFactory.forClassLoader(compilerClassLoader);\n\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        configuration.setVerbose(spec.getGroovyCompileOptions().isVerbose());\n        configuration.setSourceEncoding(spec.getGroovyCompileOptions().getEncoding());\n        configuration.setTargetBytecode(spec.getTargetCompatibility());\n        configuration.setTargetDirectory(spec.getDestinationDir());\n        canonicalizeValues(spec.getGroovyCompileOptions().getOptimizationOptions());\n        if (spec.getGroovyCompileOptions().getConfigurationScript() != null) {\n            applyConfigurationScript(spec.getGroovyCompileOptions().getConfigurationScript(), configuration);\n        }\n        try {\n            configuration.setOptimizationOptions(spec.getGroovyCompileOptions().getOptimizationOptions());\n        } catch (NoSuchMethodError ignored) { /* method was only introduced in Groovy 1.8 */ }\n        Map<String, Object> jointCompilationOptions = new HashMap<String, Object>();\n        final File stubDir = spec.getGroovyCompileOptions().getStubDir();\n        stubDir.mkdirs();\n        jointCompilationOptions.put(\"stubDir\", stubDir);\n        jointCompilationOptions.put(\"keepStubs\", spec.getGroovyCompileOptions().isKeepStubs());\n        configuration.setJointCompilationOptions(jointCompilationOptions);\n\n        ClassLoader classPathLoader;\n        VersionNumber version = parseGroovyVersion();\n        if (version.compareTo(VersionNumber.parse(\"2.0\")) < 0) {\n            // using a transforming classloader is only required for older buggy Groovy versions\n            classPathLoader = new GroovyCompileTransformingClassLoader(getExtClassLoader(), new DefaultClassPath(spec.getClasspath()));\n        } else {\n            classPathLoader = new DefaultClassLoaderFactory().createIsolatedClassLoader(new DefaultClassPath(spec.getClasspath()));\n        }\n        GroovyClassLoader compileClasspathClassLoader = new GroovyClassLoader(classPathLoader, null);\n        GroovySystemLoader compileClasspathLoader = groovySystemLoaderFactory.forClassLoader(classPathLoader);\n\n        FilteringClassLoader groovyCompilerClassLoader = new FilteringClassLoader(GroovyClassLoader.class.getClassLoader());\n        groovyCompilerClassLoader.allowPackage(\"org.codehaus.groovy\");\n        groovyCompilerClassLoader.allowPackage(\"groovy\");\n        // Disallow classes from Groovy Jar that reference external classes. Such classes must be loaded from astTransformClassLoader,\n        // or a NoClassDefFoundError will occur. Essentially this is drawing a line between the Groovy compiler and the Groovy\n        // library, albeit only for selected classes that run a high risk of being statically referenced from a transform.\n        groovyCompilerClassLoader.disallowClass(\"groovy.util.GroovyTestCase\");\n        groovyCompilerClassLoader.disallowPackage(\"groovy.servlet\");\n\n        // AST transforms need their own class loader that shares compiler classes with the compiler itself\n        final GroovyClassLoader astTransformClassLoader = new GroovyClassLoader(groovyCompilerClassLoader, null);\n        // can't delegate to compileClasspathLoader because this would result in ASTTransformation interface\n        // (which is implemented by the transform class) being loaded by compileClasspathClassLoader (which is\n        // where the transform class is loaded from)\n        for (File file : spec.getClasspath()) {\n            astTransformClassLoader.addClasspath(file.getPath());\n        }\n        JavaAwareCompilationUnit unit = new JavaAwareCompilationUnit(configuration, compileClasspathClassLoader) {\n            @Override\n            public GroovyClassLoader getTransformLoader() {\n                return astTransformClassLoader;\n            }\n        };\n\n        final boolean shouldProcessAnnotations = shouldProcessAnnotations(astTransformClassLoader, spec);\n        if (shouldProcessAnnotations) {\n            // If an annotation processor is detected, we need to force Java stub generation, so the we can process annotations on Groovy classes\n            // We are forcing stub generation by tricking the groovy compiler into thinking there are java files to compile.\n            // All java files are just passed to the compile method of the JavaCompiler and aren't processed internally by the Groovy Compiler.\n            // Since we're maintaining our own list of Java files independent what's passed by the Groovy compiler, adding a non-existant java file\n            // to the sources won't cause any issues.\n            unit.addSources(new File[]{new File(\"ForceStubGeneration.java\")});\n        }\n\n        unit.addSources(Iterables.toArray(spec.getSource(), File.class));\n        unit.setCompilerFactory(new JavaCompilerFactory() {\n            public JavaCompiler createCompiler(final CompilerConfiguration config) {\n                return new JavaCompiler() {\n                    public void compile(List<String> files, CompilationUnit cu) {\n                        if (shouldProcessAnnotations) {\n                            // In order for the Groovy stubs to have annotation processors invoked against them, they must be compiled as source.\n                            // Classes compiled as a result of being on the -sourcepath do not have the annotation processor run against them\n                            spec.setSource(spec.getSource().plus(new SimpleFileCollection(stubDir).getAsFileTree()));\n                        } else {\n                            // When annotation processing isn't required, it's better to add the Groovy stubs as part of the source path.\n                            // This allows compilations to complete faster, because only the Groovy stubs that are needed by the java source are compiled.\n                            FileCollection sourcepath = new SimpleFileCollection(stubDir);\n                            if (spec.getCompileOptions().getSourcepath() != null) {\n                                sourcepath = spec.getCompileOptions().getSourcepath().plus(sourcepath);\n                            }\n                            spec.getCompileOptions().setSourcepath(sourcepath);\n                        }\n\n                        spec.setSource(spec.getSource().filter(new Spec<File>() {\n                            public boolean isSatisfiedBy(File file) {\n                                return hasExtension(file, \".java\");\n                            }\n                        }));\n\n                        try {\n                            javaCompiler.execute(spec);\n                        } catch (CompilationFailedException e) {\n                            cu.getErrorCollector().addFatalError(new SimpleMessage(e.getMessage(), cu));\n                        }\n                    }\n                };\n            }\n        });\n\n        try {\n            unit.compile();\n        } catch (org.codehaus.groovy.control.CompilationFailedException e) {\n            System.err.println(e.getMessage());\n            throw new CompilationFailedException();\n        } finally {\n            // Remove compile and AST types from the Groovy loader\n            compilerGroovyLoader.discardTypesFrom(classPathLoader);\n            compilerGroovyLoader.discardTypesFrom(astTransformClassLoader);\n            //Discard the compile loader\n            compileClasspathLoader.shutdown();\n        }\n\n        return new SimpleWorkResult(true);\n    }","commit_id":"1d51318c22689d12e451b8e7be724571c7bc31f8","url":"https://github.com/gradle/gradle"},{"original_method":"private void makeServiceVisible(ServiceLocator locator, FilteringClassLoader.Spec classLoaderSpec, Class<?> serviceType) {\n        classLoaderSpec.allowClass(locator.getFactory(serviceType).getImplementationClass());\n        classLoaderSpec.allowResource(\"META-INF/services/\" + serviceType.getName());\n    }","id":97713,"modified_method":"private void makeServiceVisible(ServiceLocator locator, FilteringClassLoader classLoader, Class<?> serviceType) {\n        classLoader.allowClass(locator.getFactory(serviceType).getImplementationClass());\n        classLoader.allowResource(\"META-INF/services/\" + serviceType.getName());\n    }","commit_id":"1d51318c22689d12e451b8e7be724571c7bc31f8","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public FilteringClassLoader createFilteringClassLoader(ClassLoader parent, FilteringClassLoader.Spec spec) {\n        // See the comment for {@link #createIsolatedClassLoader} above\n        FilteringClassLoader.Spec classLoaderSpec = new FilteringClassLoader.Spec(spec);\n        if (needJaxpImpl()) {\n            makeServiceVisible(systemClassLoaderServiceLocator, classLoaderSpec, SAXParserFactory.class);\n            makeServiceVisible(systemClassLoaderServiceLocator, classLoaderSpec, DocumentBuilderFactory.class);\n            makeServiceVisible(systemClassLoaderServiceLocator, classLoaderSpec, DatatypeFactory.class);\n        }\n        return new FilteringClassLoader(parent, classLoaderSpec);\n    }","id":97714,"modified_method":"public FilteringClassLoader createFilteringClassLoader(ClassLoader parent) {\n        // See the comment for {@link #createIsolatedClassLoader} above\n        FilteringClassLoader classLoader = new FilteringClassLoader(parent);\n        if (needJaxpImpl()) {\n            makeServiceVisible(systemClassLoaderServiceLocator, classLoader, SAXParserFactory.class);\n            makeServiceVisible(systemClassLoaderServiceLocator, classLoader, DocumentBuilderFactory.class);\n            makeServiceVisible(systemClassLoaderServiceLocator, classLoader, DatatypeFactory.class);\n        }\n        return classLoader;\n    }","commit_id":"1d51318c22689d12e451b8e7be724571c7bc31f8","url":"https://github.com/gradle/gradle"},{"original_method":"private ClassLoader restrictToGradleApi(ClassLoader classLoader) {\n        FilteringClassLoader.Spec rootSpec = new FilteringClassLoader.Spec();\n        rootSpec.allowPackage(\"org.gradle\");\n        rootSpec.allowResources(\"META-INF/gradle-plugins\");\n        rootSpec.allowPackage(\"org.apache.tools.ant\");\n        rootSpec.allowPackage(\"groovy\");\n        rootSpec.allowPackage(\"org.codehaus.groovy\");\n        rootSpec.allowPackage(\"groovyjarjarantlr\");\n        rootSpec.allowPackage(\"org.slf4j\");\n        rootSpec.allowPackage(\"org.apache.commons.logging\");\n        rootSpec.allowPackage(\"org.apache.log4j\");\n        rootSpec.allowPackage(\"javax.inject\");\n        FilteringClassLoader rootClassLoader = classLoaderFactory.createFilteringClassLoader(classLoader, rootSpec);\n        return new CachingClassLoader(rootClassLoader);\n    }","id":97715,"modified_method":"private ClassLoader restrictToGradleApi(ClassLoader classLoader) {\n        FilteringClassLoader rootClassLoader = classLoaderFactory.createFilteringClassLoader(classLoader);\n        rootClassLoader.allowPackage(\"org.gradle\");\n        rootClassLoader.allowResources(\"META-INF/gradle-plugins\");\n        rootClassLoader.allowPackage(\"org.apache.tools.ant\");\n        rootClassLoader.allowPackage(\"groovy\");\n        rootClassLoader.allowPackage(\"org.codehaus.groovy\");\n        rootClassLoader.allowPackage(\"groovyjarjarantlr\");\n        rootClassLoader.allowPackage(\"org.slf4j\");\n        rootClassLoader.allowPackage(\"org.apache.commons.logging\");\n        rootClassLoader.allowPackage(\"org.apache.log4j\");\n        rootClassLoader.allowPackage(\"javax.inject\");\n        return new CachingClassLoader(rootClassLoader);\n    }","commit_id":"1d51318c22689d12e451b8e7be724571c7bc31f8","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultIsolatedAntBuilder(ClassPathRegistry classPathRegistry, ClassLoaderFactory classLoaderFactory, ModuleRegistry moduleRegistry) {\n        this.classPathRegistry = classPathRegistry;\n        this.classLoaderFactory = classLoaderFactory;\n        this.moduleRegistry = moduleRegistry;\n        this.libClasspath = new DefaultClassPath();\n        GroovySystemLoaderFactory groovySystemLoaderFactory = new GroovySystemLoaderFactory();\n        this.classLoaderCache = new ClassPathToClassLoaderCache(groovySystemLoaderFactory);\n\n        List<File> antClasspath = Lists.newArrayList(classPathRegistry.getClassPath(\"ANT\").getAsFiles());\n        // Need tools.jar for compile tasks\n        File toolsJar = Jvm.current().getToolsJar();\n        if (toolsJar != null) {\n            antClasspath.add(toolsJar);\n        }\n\n        antLoader = classLoaderFactory.createIsolatedClassLoader(new DefaultClassPath(antClasspath));\n        FilteringClassLoader.Spec loggingLoaderSpec = new FilteringClassLoader.Spec();\n        loggingLoaderSpec.allowPackage(\"org.slf4j\");\n        loggingLoaderSpec.allowPackage(\"org.apache.commons.logging\");\n        loggingLoaderSpec.allowPackage(\"org.apache.log4j\");\n        loggingLoaderSpec.allowClass(Logger.class);\n        loggingLoaderSpec.allowClass(LogLevel.class);\n        FilteringClassLoader loggingLoader = new FilteringClassLoader(getClass().getClassLoader(), loggingLoaderSpec);\n\n        this.baseAntLoader = new CachingClassLoader(new MultiParentClassLoader(antLoader, loggingLoader));\n\n        // Need gradle core to pick up ant logging adapter, AntBuilder and such\n        ClassPath gradleCoreUrls = moduleRegistry.getModule(\"gradle-core\").getImplementationClasspath();\n        gradleCoreUrls = gradleCoreUrls.plus(moduleRegistry.getModule(\"gradle-logging\").getImplementationClasspath());\n        gradleCoreUrls = gradleCoreUrls.plus(moduleRegistry.getExternalModule(\"groovy-all\").getClasspath());\n\n        // Need Transformer (part of AntBuilder API) from base services\n        gradleCoreUrls = gradleCoreUrls.plus(moduleRegistry.getModule(\"gradle-base-services\").getImplementationClasspath());\n        this.antAdapterLoader = new VisitableURLClassLoader(baseAntLoader, gradleCoreUrls);\n\n        gradleApiGroovyLoader = groovySystemLoaderFactory.forClassLoader(this.getClass().getClassLoader());\n        antAdapterGroovyLoader = groovySystemLoaderFactory.forClassLoader(antAdapterLoader);\n    }","id":97716,"modified_method":"public DefaultIsolatedAntBuilder(ClassPathRegistry classPathRegistry, ClassLoaderFactory classLoaderFactory, ModuleRegistry moduleRegistry) {\n        this.classPathRegistry = classPathRegistry;\n        this.classLoaderFactory = classLoaderFactory;\n        this.moduleRegistry = moduleRegistry;\n        this.libClasspath = new DefaultClassPath();\n        GroovySystemLoaderFactory groovySystemLoaderFactory = new GroovySystemLoaderFactory();\n        this.classLoaderCache = new ClassPathToClassLoaderCache(groovySystemLoaderFactory);\n\n        List<File> antClasspath = Lists.newArrayList(classPathRegistry.getClassPath(\"ANT\").getAsFiles());\n        // Need tools.jar for compile tasks\n        File toolsJar = Jvm.current().getToolsJar();\n        if (toolsJar != null) {\n            antClasspath.add(toolsJar);\n        }\n\n        antLoader = classLoaderFactory.createIsolatedClassLoader(new DefaultClassPath(antClasspath));\n        FilteringClassLoader loggingLoader = new FilteringClassLoader(getClass().getClassLoader());\n        loggingLoader.allowPackage(\"org.slf4j\");\n        loggingLoader.allowPackage(\"org.apache.commons.logging\");\n        loggingLoader.allowPackage(\"org.apache.log4j\");\n        loggingLoader.allowClass(Logger.class);\n        loggingLoader.allowClass(LogLevel.class);\n\n        this.baseAntLoader = new CachingClassLoader(new MultiParentClassLoader(antLoader, loggingLoader));\n\n        // Need gradle core to pick up ant logging adapter, AntBuilder and such\n        ClassPath gradleCoreUrls = moduleRegistry.getModule(\"gradle-core\").getImplementationClasspath();\n        gradleCoreUrls = gradleCoreUrls.plus(moduleRegistry.getModule(\"gradle-logging\").getImplementationClasspath());\n        gradleCoreUrls = gradleCoreUrls.plus(moduleRegistry.getExternalModule(\"groovy-all\").getClasspath());\n\n        // Need Transformer (part of AntBuilder API) from base services\n        gradleCoreUrls = gradleCoreUrls.plus(moduleRegistry.getModule(\"gradle-base-services\").getImplementationClasspath());\n        this.antAdapterLoader = new VisitableURLClassLoader(baseAntLoader, gradleCoreUrls);\n\n        gradleApiGroovyLoader = groovySystemLoaderFactory.forClassLoader(this.getClass().getClassLoader());\n        antAdapterGroovyLoader = groovySystemLoaderFactory.forClassLoader(antAdapterLoader);\n    }","commit_id":"1d51318c22689d12e451b8e7be724571c7bc31f8","url":"https://github.com/gradle/gradle"},{"original_method":"private ClassLoader createImplementationClassLoader(Distribution distribution, ProgressLoggerFactory progressLoggerFactory, File userHomeDir, BuildCancellationToken cancellationToken) {\n        ClassPath implementationClasspath = distribution.getToolingImplementationClasspath(progressLoggerFactory, userHomeDir, cancellationToken);\n        LOGGER.debug(\"Using tooling provider classpath: {}\", implementationClasspath);\n        // On IBM JVM 5, ClassLoader.getResources() uses a combination of findResources() and getParent() and traverses the hierarchy rather than just calling getResources()\n        // Wrap our real classloader in one that hides the parent.\n        // TODO - move this into FilteringClassLoader\n        MultiParentClassLoader parentObfuscatingClassLoader = new MultiParentClassLoader(classLoader);\n        FilteringClassLoader.Spec filterSpec = new FilteringClassLoader.Spec();\n        filterSpec.allowPackage(\"org.gradle.tooling.internal.protocol\");\n        FilteringClassLoader filteringClassLoader = new FilteringClassLoader(parentObfuscatingClassLoader, filterSpec);\n        return new VisitableURLClassLoader(filteringClassLoader, implementationClasspath.getAsURLArray());\n    }","id":97717,"modified_method":"private ClassLoader createImplementationClassLoader(Distribution distribution, ProgressLoggerFactory progressLoggerFactory, File userHomeDir, BuildCancellationToken cancellationToken) {\n        ClassPath implementationClasspath = distribution.getToolingImplementationClasspath(progressLoggerFactory, userHomeDir, cancellationToken);\n        LOGGER.debug(\"Using tooling provider classpath: {}\", implementationClasspath);\n        // On IBM JVM 5, ClassLoader.getResources() uses a combination of findResources() and getParent() and traverses the hierarchy rather than just calling getResources()\n        // Wrap our real classloader in one that hides the parent.\n        // TODO - move this into FilteringClassLoader\n        MultiParentClassLoader parentObfuscatingClassLoader = new MultiParentClassLoader(classLoader);\n        FilteringClassLoader filteringClassLoader = new FilteringClassLoader(parentObfuscatingClassLoader);\n        filteringClassLoader.allowPackage(\"org.gradle.tooling.internal.protocol\");\n        return new VisitableURLClassLoader(filteringClassLoader, implementationClasspath.getAsURLArray());\n    }","commit_id":"1d51318c22689d12e451b8e7be724571c7bc31f8","url":"https://github.com/gradle/gradle"},{"original_method":"public FilteringClassLoader(ClassLoader parent, Spec spec) {\n        super(parent);\n        this.packageNames = ImmutableSet.copyOf(spec.packageNames);\n        this.packagePrefixes = ImmutableSet.copyOf(spec.packagePrefixes);\n        this.resourceNames = ImmutableSet.copyOf(spec.resourceNames);\n        this.resourcePrefixes = ImmutableSet.copyOf(spec.resourcePrefixes);\n        this.classNames = ImmutableSet.copyOf(spec.classNames);\n        this.disallowedClassNames = ImmutableSet.copyOf(spec.disallowedClassNames);\n        this.disallowedPackagePrefixes = ImmutableSet.copyOf(spec.disallowedPackagePrefixes);\n    }","id":97718,"modified_method":"public FilteringClassLoader(ClassLoader parent, Spec spec) {\n        super(parent);\n        packageNames.addAll(spec.packageNames);\n        packagePrefixes.addAll(spec.packagePrefixes);\n        resourceNames.addAll(spec.resourceNames);\n        resourcePrefixes.addAll(spec.resourcePrefixes);\n        classNames.addAll(spec.classNames);\n        disallowedClassNames.addAll(spec.disallowedClassNames);\n        disallowedPackagePrefixes.addAll(spec.disallowedPackagePrefixes);\n    }","commit_id":"1d51318c22689d12e451b8e7be724571c7bc31f8","url":"https://github.com/gradle/gradle"},{"original_method":"public void run() throws Exception {\n        DataInputStream instr = new DataInputStream(new EncodedStream.EncodedInput(System.in));\n\n        // Read shared packages\n        int sharedPackagesCount = instr.readInt();\n        List<String> sharedPackages = new ArrayList<String>(sharedPackagesCount);\n        for (int i = 0; i < sharedPackagesCount; i++) {\n            sharedPackages.add(instr.readUTF());\n        }\n\n        // Read worker implementation classpath\n        int classPathLength = instr.readInt();\n        URL[] implementationClassPath = new URL[classPathLength];\n        for (int i = 0; i < classPathLength; i++) {\n            String url = instr.readUTF();\n            implementationClassPath[i] = new URL(url);\n        }\n\n        // Set up worker ClassLoader\n        FilteringClassLoader.Spec filteringClassLoaderSpec = new FilteringClassLoader.Spec();\n        for (String sharedPackage : sharedPackages) {\n            filteringClassLoaderSpec.allowPackage(sharedPackage);\n        }\n        FilteringClassLoader filteringClassLoader = new FilteringClassLoader(getClass().getClassLoader(), filteringClassLoaderSpec);\n        URLClassLoader classLoader = new URLClassLoader(implementationClassPath, filteringClassLoader);\n\n        Class<? extends Callable> workerClass = classLoader.loadClass(\"org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker\").asSubclass(Callable.class);\n        Callable<Void> main = workerClass.getConstructor(DataInputStream.class).newInstance(instr);\n        main.call();\n    }","id":97719,"modified_method":"public void run() throws Exception {\n        DataInputStream instr = new DataInputStream(new EncodedStream.EncodedInput(System.in));\n\n        // Read shared packages\n        int sharedPackagesCount = instr.readInt();\n        List<String> sharedPackages = new ArrayList<String>(sharedPackagesCount);\n        for (int i = 0; i < sharedPackagesCount; i++) {\n            sharedPackages.add(instr.readUTF());\n        }\n\n        // Read worker implementation classpath\n        int classPathLength = instr.readInt();\n        URL[] implementationClassPath = new URL[classPathLength];\n        for (int i = 0; i < classPathLength; i++) {\n            String url = instr.readUTF();\n            implementationClassPath[i] = new URL(url);\n        }\n\n        // Set up worker ClassLoader\n        FilteringClassLoader filteringClassLoader = new FilteringClassLoader(getClass().getClassLoader());\n        for (String sharedPackage : sharedPackages) {\n            filteringClassLoader.allowPackage(sharedPackage);\n        }\n        URLClassLoader classLoader = new URLClassLoader(implementationClassPath, filteringClassLoader);\n\n        Class<? extends Callable> workerClass = classLoader.loadClass(\"org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker\").asSubclass(Callable.class);\n        Callable<Void> main = workerClass.getConstructor(DataInputStream.class).newInstance(instr);\n        main.call();\n    }","commit_id":"1d51318c22689d12e451b8e7be724571c7bc31f8","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public CompilerDaemon getDaemon(File workingDir, final DaemonForkOptions forkOptions) {\n        return new CompilerDaemon() {\n            public <T extends CompileSpec> CompileResult execute(Compiler<T> compiler, T spec) {\n                ClassLoader groovyClassLoader = classLoaderFactory.createIsolatedClassLoader(new DefaultClassPath(forkOptions.getClasspath()));\n                GroovySystemLoader groovyLoader = groovySystemLoaderFactory.forClassLoader(groovyClassLoader);\n                FilteringClassLoader.Spec filteredGroovySpec = new FilteringClassLoader.Spec();\n                for (String packageName : forkOptions.getSharedPackages()) {\n                    filteredGroovySpec.allowPackage(packageName);\n                }\n                FilteringClassLoader filteredGroovy = classLoaderFactory.createFilteringClassLoader(groovyClassLoader, filteredGroovySpec);\n\n                FilteringClassLoader.Spec loggingSpec = new FilteringClassLoader.Spec();\n                loggingSpec.allowPackage(\"org.slf4j\");\n                loggingSpec.allowClass(Logger.class);\n                loggingSpec.allowClass(LogLevel.class);\n                FilteringClassLoader loggingClassLoader = classLoaderFactory.createFilteringClassLoader(compiler.getClass().getClassLoader(), loggingSpec);\n\n                ClassLoader groovyAndLoggingClassLoader = new CachingClassLoader(new MultiParentClassLoader(loggingClassLoader, filteredGroovy));\n\n                ClassLoader workerClassLoader = new VisitableURLClassLoader(groovyAndLoggingClassLoader, ClasspathUtil.getClasspath(compiler.getClass().getClassLoader()));\n\n                try {\n                    byte[] serializedWorker = GUtil.serialize(new Worker<T>(compiler, spec, gradleUserHomeDir));\n                    ClassLoaderObjectInputStream inputStream = new ClassLoaderObjectInputStream(new ByteArrayInputStream(serializedWorker), workerClassLoader);\n                    Callable<?> worker = (Callable<?>) inputStream.readObject();\n                    Object result = worker.call();\n                    byte[] serializedResult = GUtil.serialize(result);\n                    inputStream = new ClassLoaderObjectInputStream(new ByteArrayInputStream(serializedResult), getClass().getClassLoader());\n                    return (CompileResult) inputStream.readObject();\n                } catch (Exception e) {\n                    throw UncheckedException.throwAsUncheckedException(e);\n                } finally {\n                    groovyLoader.shutdown();\n                }\n            }\n        };\n    }","id":97720,"modified_method":"@Override\n    public CompilerDaemon getDaemon(File workingDir, final DaemonForkOptions forkOptions) {\n        return new CompilerDaemon() {\n            public <T extends CompileSpec> CompileResult execute(Compiler<T> compiler, T spec) {\n                ClassLoader groovyClassLoader = classLoaderFactory.createIsolatedClassLoader(new DefaultClassPath(forkOptions.getClasspath()));\n                GroovySystemLoader groovyLoader = groovySystemLoaderFactory.forClassLoader(groovyClassLoader);\n                FilteringClassLoader filteredGroovy = classLoaderFactory.createFilteringClassLoader(groovyClassLoader);\n                for (String packageName : forkOptions.getSharedPackages()) {\n                    filteredGroovy.allowPackage(packageName);\n                }\n\n                FilteringClassLoader loggingClassLoader = classLoaderFactory.createFilteringClassLoader(compiler.getClass().getClassLoader());\n                loggingClassLoader.allowPackage(\"org.slf4j\");\n                loggingClassLoader.allowClass(Logger.class);\n                loggingClassLoader.allowClass(LogLevel.class);\n\n                ClassLoader groovyAndLoggingClassLoader = new CachingClassLoader(new MultiParentClassLoader(loggingClassLoader, filteredGroovy));\n\n                ClassLoader workerClassLoader = new VisitableURLClassLoader(groovyAndLoggingClassLoader, ClasspathUtil.getClasspath(compiler.getClass().getClassLoader()));\n\n                try {\n                    byte[] serializedWorker = GUtil.serialize(new Worker<T>(compiler, spec, gradleUserHomeDir));\n                    ClassLoaderObjectInputStream inputStream = new ClassLoaderObjectInputStream(new ByteArrayInputStream(serializedWorker), workerClassLoader);\n                    Callable<?> worker = (Callable<?>) inputStream.readObject();\n                    Object result = worker.call();\n                    byte[] serializedResult = GUtil.serialize(result);\n                    inputStream = new ClassLoaderObjectInputStream(new ByteArrayInputStream(serializedResult), getClass().getClassLoader());\n                    return (CompileResult) inputStream.readObject();\n                } catch (Exception e) {\n                    throw UncheckedException.throwAsUncheckedException(e);\n                } finally {\n                    groovyLoader.shutdown();\n                }\n            }\n        };\n    }","commit_id":"1d51318c22689d12e451b8e7be724571c7bc31f8","url":"https://github.com/gradle/gradle"},{"original_method":"JdkTools(JavaInfo javaInfo) {\n        DefaultClassLoaderFactory defaultClassLoaderFactory = new DefaultClassLoaderFactory();\n        JavaVersion javaVersion = Jvm.current().getJavaVersion();\n        boolean java9Compatible = javaVersion.isJava9Compatible();\n        FilteringClassLoader filteringClassLoader = getSystemFilteringClassLoader(defaultClassLoaderFactory, java9Compatible);\n        if (!java9Compatible) {\n            File toolsJar = javaInfo.getToolsJar();\n            if (toolsJar == null) {\n                throw new IllegalStateException(\"Could not find tools.jar. Please check that \"\n                                                + javaInfo.getJavaHome().getAbsolutePath()\n                                                + \" contains a valid JDK installation.\");\n            }\n            DefaultClassPath defaultClassPath = new DefaultClassPath(toolsJar);\n            isolatedToolsLoader = new VisitableURLClassLoader(filteringClassLoader, defaultClassPath.getAsURLs());\n            isJava9Compatible = false;\n        } else {\n            isolatedToolsLoader = filteringClassLoader;\n            isJava9Compatible = true;\n        }\n    }","id":97721,"modified_method":"JdkTools(JavaInfo javaInfo) {\n        DefaultClassLoaderFactory defaultClassLoaderFactory = new DefaultClassLoaderFactory();\n        JavaVersion javaVersion = Jvm.current().getJavaVersion();\n        FilteringClassLoader filteringClassLoader = defaultClassLoaderFactory.createSystemFilteringClassLoader();\n        if (!javaVersion.isJava9Compatible()) {\n            File toolsJar = javaInfo.getToolsJar();\n            if (toolsJar == null) {\n                throw new IllegalStateException(\"Could not find tools.jar. Please check that \"\n                                                + javaInfo.getJavaHome().getAbsolutePath()\n                                                + \" contains a valid JDK installation.\");\n            }\n            DefaultClassPath defaultClassPath = new DefaultClassPath(toolsJar);\n            isolatedToolsLoader = new VisitableURLClassLoader(filteringClassLoader, defaultClassPath.getAsURLs());\n            isJava9Compatible = false;\n        } else {\n            filteringClassLoader.allowPackage(\"com.sun.tools\");\n            isolatedToolsLoader = filteringClassLoader;\n            isJava9Compatible = true;\n        }\n    }","commit_id":"1d51318c22689d12e451b8e7be724571c7bc31f8","url":"https://github.com/gradle/gradle"},{"original_method":"public ModelClassLoaderFactory(ClassLoaderFactory classLoaderFactory) {\n        this.classLoaderFactory = classLoaderFactory;\n        ClassLoader parent = getClass().getClassLoader();\n        FilteringClassLoader.Spec filterSpec = new FilteringClassLoader.Spec();\n        filterSpec.allowPackage(\"org.gradle.tooling.internal.protocol\");\n        filterSpec.allowClass(TaskExecutionRequest.class);\n        rootClassLoader = new FilteringClassLoader(parent, filterSpec);\n    }","id":97722,"modified_method":"public ModelClassLoaderFactory(ClassLoaderFactory classLoaderFactory) {\n        this.classLoaderFactory = classLoaderFactory;\n        ClassLoader parent = getClass().getClassLoader();\n        FilteringClassLoader filter = new FilteringClassLoader(parent);\n        filter.allowPackage(\"org.gradle.tooling.internal.protocol\");\n        filter.allowClass(TaskExecutionRequest.class);\n        rootClassLoader = filter;\n    }","commit_id":"1d51318c22689d12e451b8e7be724571c7bc31f8","url":"https://github.com/gradle/gradle"},{"original_method":"/**\r\n     * Replaces the paths within all the given resources and removes all UUIDs by an regex.<p>\r\n     * \r\n     * @param sourceModulePath the search path\r\n     * @param targetModulePath the replace path\r\n     * @param allModuleResources the resources\r\n     * \r\n     * @throws CmsException if something goes wrong\r\n     * @throws UnsupportedEncodingException if the file content could not be read with the determined encoding \r\n     */\r\n    private void replacePath(String sourceModulePath, String targetModulePath, List<CmsResource> allModuleResources)\r\n    throws CmsException, UnsupportedEncodingException {\r\n\r\n        for (CmsResource resource : allModuleResources) {\r\n            if (resource.isFile()) {\r\n                CmsFile file = getCmsObject().readFile(resource);\r\n                String encoding = CmsLocaleManager.getResourceEncoding(getCmsObject(), file);\r\n                String content = new String(file.getContents(), encoding);\r\n                content = content.replaceAll(sourceModulePath, targetModulePath);\r\n                Matcher matcher = Pattern.compile(CmsUUID.UUID_REGEX).matcher(content);\r\n                content = matcher.replaceAll(\"\");\r\n                content = content.replaceAll(\"<uuid><\/uuid>\", \"\");\r\n                file.setContents(content.getBytes(encoding));\r\n                getCmsObject().writeFile(file);\r\n            }\r\n        }\r\n    }","id":97723,"modified_method":"/**\r\n     * Replaces the paths within all the given resources and removes all UUIDs by an regex.<p>\r\n     * \r\n     * @param sourceModulePath the search path\r\n     * @param targetModulePath the replace path\r\n     * @param allModuleResources the resources\r\n     * \r\n     * @throws CmsException if something goes wrong\r\n     * @throws UnsupportedEncodingException if the file content could not be read with the determined encoding \r\n     */\r\n    private void replacePath(String sourceModulePath, String targetModulePath, List<CmsResource> allModuleResources)\r\n    throws CmsException, UnsupportedEncodingException {\r\n\r\n        for (CmsResource resource : allModuleResources) {\r\n            if (resource.isFile()) {\r\n                CmsFile file = getCmsObject().readFile(resource);\r\n                String encoding = CmsLocaleManager.getResourceEncoding(getCmsObject(), file);\r\n                String oldContent = new String(file.getContents(), encoding);\r\n                String newContent = oldContent.replaceAll(sourceModulePath, targetModulePath);\r\n                Matcher matcher = Pattern.compile(CmsUUID.UUID_REGEX).matcher(newContent);\r\n                newContent = matcher.replaceAll(\"\");\r\n                newContent = newContent.replaceAll(\"<uuid><\/uuid>\", \"\");\r\n                if (!oldContent.equals(newContent)) {\r\n                    file.setContents(newContent.getBytes(encoding));\r\n                    if (!resource.getRootPath().startsWith(CmsWorkplace.VFS_PATH_SYSTEM)) {\r\n                        if (lockResource(getCmsObject(), resource)) {\r\n                            getCmsObject().writeFile(file);\r\n                        }\r\n                    } else {\r\n                        getCmsObject().writeFile(file);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }","commit_id":"ca3880fcd5a9c1122e3dd6397b8b2718831ac14d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Executes the module clone and returns the new module.<p>\r\n     */\r\n    public void executeModuleClone() {\r\n\r\n        CmsModule sourceModule = OpenCms.getModuleManager().getModule(m_sourceModuleName);\r\n\r\n        // clone the module object\r\n        CmsModule targetModule = (CmsModule)sourceModule.clone();\r\n        targetModule.setName(m_packageName);\r\n        targetModule.setNiceName(m_niceName);\r\n        targetModule.setDescription(m_description);\r\n        targetModule.setAuthorEmail(m_authorEmail);\r\n        targetModule.setAuthorName(m_authorName);\r\n        targetModule.setGroup(m_group);\r\n        targetModule.setActionClass(m_actionClass);\r\n\r\n        try {\r\n\r\n            // store the module paths\r\n            String sourceModulePath = CmsWorkplace.VFS_PATH_MODULES + sourceModule.getName() + \"/\";\r\n            String targetModulePath = CmsWorkplace.VFS_PATH_MODULES + targetModule.getName() + \"/\";\r\n\r\n            // store the package name as path part\r\n            String sourcePathPart = sourceModule.getName().replaceAll(\"\\\\.\", \"/\");\r\n            String targetPathPart = targetModule.getName().replaceAll(\"\\\\.\", \"/\");\r\n\r\n            // store the classes folder paths\r\n            String sourceClassesPath = targetModulePath + PATH_CLASSES + sourcePathPart + \"/\";\r\n            String targetClassesPath = targetModulePath + PATH_CLASSES + targetPathPart + \"/\";\r\n\r\n            // copy the resources\r\n            getCmsObject().copyResource(sourceModulePath, targetModulePath);\r\n\r\n            // check if we have to create the classes folder\r\n            if (getCmsObject().existsResource(sourceClassesPath)) {\r\n                // in the source module a classes folder was defined,\r\n                // now create all sub-folders for the package structure in the new module folder\r\n                createTargetClassesFolder(targetModule, sourceClassesPath, targetModulePath + PATH_CLASSES);\r\n                // delete the origin classes folder\r\n                deleteSourceClassesFolder(targetModulePath, sourcePathPart, targetPathPart);\r\n            }\r\n\r\n            // TODO: clone module dependencies\r\n\r\n            // adjust the export points\r\n            cloneExportPoints(sourceModule, targetModule, sourcePathPart, targetPathPart);\r\n\r\n            // adjust the resource type names and IDs\r\n            Map<String, String> descKeys = new HashMap<String, String>();\r\n            Map<I_CmsResourceType, I_CmsResourceType> resTypeMap = cloneResourceTypes(\r\n                sourceModule,\r\n                targetModule,\r\n                sourcePathPart,\r\n                targetPathPart,\r\n                descKeys);\r\n\r\n            // adjust the explorer type names and store referred icons and message keys\r\n            Map<String, String> iconPaths = new HashMap<String, String>();\r\n            cloneExplorerTypes(targetModule, iconPaths, descKeys);\r\n\r\n            // rename the icon file names\r\n            cloneExplorerTypeIcons(iconPaths);\r\n\r\n            // adjust the module resources\r\n            adjustModuleResources(sourceModule, targetModule, sourcePathPart, targetPathPart, iconPaths);\r\n\r\n            // search and replace the localization keys\r\n            List<CmsResource> props = getCmsObject().readResources(targetClassesPath, CmsResourceFilter.DEFAULT_FILES);\r\n            replacesMessages(descKeys, props);\r\n\r\n            int type = OpenCms.getResourceManager().getResourceType(CmsVfsBundleManager.TYPE_XML_BUNDLE).getTypeId();\r\n            CmsResourceFilter filter = CmsResourceFilter.requireType(type);\r\n            List<CmsResource> resources = getCmsObject().readResources(targetModulePath, filter);\r\n            replacesMessages(descKeys, resources);\r\n            renameXmlVfsBundles(resources, targetModule, sourceModule.getName());\r\n\r\n            List<CmsResource> allModuleResources = getCmsObject().readResources(targetModulePath, CmsResourceFilter.ALL);\r\n            replacePath(sourceModulePath, targetModulePath, allModuleResources);\r\n\r\n            // search and replace paths\r\n            CmsSearchReplaceThread t = initializePathThread();\r\n            t.start();\r\n            t.join();\r\n\r\n            // search and replace module name\r\n            t = initializeNameThread();\r\n            t.start();\r\n            t.join();\r\n\r\n            // replace formatter paths\r\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(m_formatterTargetModule)\r\n                && !targetModule.getResourceTypes().isEmpty()) {\r\n                replaceFormatterPaths(targetModule);\r\n            }\r\n\r\n            adjustModuleConfig(targetModule, resTypeMap);\r\n\r\n            // publish the new module\r\n            for (String res : targetModule.getResources()) {\r\n                OpenCms.getPublishManager().publishResource(getCmsObject(), res);\r\n                OpenCms.getPublishManager().waitWhileRunning();\r\n            }\r\n\r\n            //  add the imported module to the module manager\r\n            OpenCms.getModuleManager().addModule(getCmsObject(), targetModule);\r\n\r\n            // reinitialize the resource manager with additional module resource types if necessary\r\n            if (targetModule.getResourceTypes() != Collections.EMPTY_LIST) {\r\n                OpenCms.getResourceManager().initialize(getCmsObject());\r\n            }\r\n            // reinitialize the workplace manager with additional module explorer types if necessary\r\n            if (targetModule.getExplorerTypes() != Collections.EMPTY_LIST) {\r\n                OpenCms.getWorkplaceManager().addExplorerTypeSettings(targetModule);\r\n            }\r\n\r\n            // re-initialize the workplace\r\n            OpenCms.getWorkplaceManager().initialize(getCmsObject());\r\n            // fire \"clear caches\" event to reload all cached resource bundles\r\n            OpenCms.fireCmsEvent(I_CmsEventListener.EVENT_CLEAR_CACHES, new HashMap<String, Object>());\r\n\r\n            // change resource types and schema locations\r\n            if (Boolean.valueOf(m_changeResourceTypes).booleanValue()) {\r\n                changeResourceTypes(resTypeMap);\r\n            }\r\n\r\n            // delete the old module\r\n            if (Boolean.valueOf(m_deleteModule).booleanValue()) {\r\n                OpenCms.getModuleManager().deleteModule(getCmsObject(), sourceModule.getName(), false, null);\r\n            }\r\n\r\n        } catch (CmsIllegalArgumentException e) {\r\n            LOG.error(e.getMessage(), e);\r\n        } catch (CmsException e) {\r\n            LOG.error(e.getMessage(), e);\r\n        } catch (Exception e) {\r\n            LOG.error(e.getMessage(), e);\r\n        }\r\n    }","id":97724,"modified_method":"/**\r\n     * Executes the module clone and returns the new module.<p>\r\n     */\r\n    public void executeModuleClone() {\r\n\r\n        CmsModule sourceModule = OpenCms.getModuleManager().getModule(m_sourceModuleName);\r\n\r\n        // clone the module object\r\n        CmsModule targetModule = (CmsModule)sourceModule.clone();\r\n        targetModule.setName(m_packageName);\r\n        targetModule.setNiceName(m_niceName);\r\n        targetModule.setDescription(m_description);\r\n        targetModule.setAuthorEmail(m_authorEmail);\r\n        targetModule.setAuthorName(m_authorName);\r\n        targetModule.setGroup(m_group);\r\n        targetModule.setActionClass(m_actionClass);\r\n\r\n        try {\r\n\r\n            // store the module paths\r\n            String sourceModulePath = CmsWorkplace.VFS_PATH_MODULES + sourceModule.getName() + \"/\";\r\n            String targetModulePath = CmsWorkplace.VFS_PATH_MODULES + targetModule.getName() + \"/\";\r\n\r\n            // store the package name as path part\r\n            String sourcePathPart = sourceModule.getName().replaceAll(\"\\\\.\", \"/\");\r\n            String targetPathPart = targetModule.getName().replaceAll(\"\\\\.\", \"/\");\r\n\r\n            // store the classes folder paths\r\n            String sourceClassesPath = targetModulePath + PATH_CLASSES + sourcePathPart + \"/\";\r\n            String targetClassesPath = targetModulePath + PATH_CLASSES + targetPathPart + \"/\";\r\n\r\n            // copy the resources\r\n            getCmsObject().copyResource(sourceModulePath, targetModulePath);\r\n\r\n            // check if we have to create the classes folder\r\n            if (getCmsObject().existsResource(sourceClassesPath)) {\r\n                // in the source module a classes folder was defined,\r\n                // now create all sub-folders for the package structure in the new module folder\r\n                createTargetClassesFolder(targetModule, sourceClassesPath, targetModulePath + PATH_CLASSES);\r\n                // delete the origin classes folder\r\n                deleteSourceClassesFolder(targetModulePath, sourcePathPart, targetPathPart);\r\n            }\r\n\r\n            // TODO: clone module dependencies\r\n\r\n            // adjust the export points\r\n            cloneExportPoints(sourceModule, targetModule, sourcePathPart, targetPathPart);\r\n\r\n            // adjust the resource type names and IDs\r\n            Map<String, String> descKeys = new HashMap<String, String>();\r\n            Map<I_CmsResourceType, I_CmsResourceType> resTypeMap = cloneResourceTypes(\r\n                sourceModule,\r\n                targetModule,\r\n                sourcePathPart,\r\n                targetPathPart,\r\n                descKeys);\r\n\r\n            // adjust the explorer type names and store referred icons and message keys\r\n            Map<String, String> iconPaths = new HashMap<String, String>();\r\n            cloneExplorerTypes(targetModule, iconPaths, descKeys);\r\n\r\n            // rename the icon file names\r\n            cloneExplorerTypeIcons(iconPaths);\r\n\r\n            // adjust the module resources\r\n            adjustModuleResources(sourceModule, targetModule, sourcePathPart, targetPathPart, iconPaths);\r\n\r\n            // search and replace the localization keys\r\n            List<CmsResource> props = getCmsObject().readResources(targetClassesPath, CmsResourceFilter.DEFAULT_FILES);\r\n            replacesMessages(descKeys, props);\r\n\r\n            int type = OpenCms.getResourceManager().getResourceType(CmsVfsBundleManager.TYPE_XML_BUNDLE).getTypeId();\r\n            CmsResourceFilter filter = CmsResourceFilter.requireType(type);\r\n            List<CmsResource> resources = getCmsObject().readResources(targetModulePath, filter);\r\n            replacesMessages(descKeys, resources);\r\n            renameXmlVfsBundles(resources, targetModule, sourceModule.getName());\r\n\r\n            List<CmsResource> allModuleResources = getCmsObject().readResources(targetModulePath, CmsResourceFilter.ALL);\r\n            replacePath(sourceModulePath, targetModulePath, allModuleResources);\r\n\r\n            // search and replace paths\r\n            CmsSearchReplaceThread t = initializePathThread();\r\n            t.start();\r\n            t.join();\r\n\r\n            // search and replace module name\r\n            t = initializeNameThread();\r\n            t.start();\r\n            t.join();\r\n\r\n            // replace formatter paths\r\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(m_formatterTargetModule)\r\n                && !targetModule.getResourceTypes().isEmpty()) {\r\n                replaceFormatterPaths(targetModule);\r\n            }\r\n\r\n            adjustModuleConfig(targetModule, resTypeMap);\r\n\r\n            // publish the new module\r\n            for (String res : targetModule.getResources()) {\r\n                OpenCms.getPublishManager().publishResource(getCmsObject(), res);\r\n                OpenCms.getPublishManager().waitWhileRunning();\r\n            }\r\n\r\n            //  add the imported module to the module manager\r\n            OpenCms.getModuleManager().addModule(getCmsObject(), targetModule);\r\n\r\n            // reinitialize the resource manager with additional module resource types if necessary\r\n            if (targetModule.getResourceTypes() != Collections.EMPTY_LIST) {\r\n                OpenCms.getResourceManager().initialize(getCmsObject());\r\n            }\r\n            // reinitialize the workplace manager with additional module explorer types if necessary\r\n            if (targetModule.getExplorerTypes() != Collections.EMPTY_LIST) {\r\n                OpenCms.getWorkplaceManager().addExplorerTypeSettings(targetModule);\r\n            }\r\n\r\n            // re-initialize the workplace\r\n            OpenCms.getWorkplaceManager().initialize(getCmsObject());\r\n            // fire \"clear caches\" event to reload all cached resource bundles\r\n            OpenCms.fireCmsEvent(I_CmsEventListener.EVENT_CLEAR_CACHES, new HashMap<String, Object>());\r\n\r\n            // change resource types and schema locations\r\n            if (Boolean.valueOf(m_changeResourceTypes).booleanValue()) {\r\n                changeResourceTypes(resTypeMap);\r\n            }\r\n            // adjust container pages\r\n            CmsObject cms = OpenCms.initCmsObject(getCmsObject());\r\n            if (Boolean.valueOf(m_changeResourceTypesEverywhere).booleanValue()) {\r\n                cms.getRequestContext().setSiteRoot(\"/\");\r\n            }\r\n            CmsResourceFilter f = CmsResourceFilter.requireType(CmsResourceTypeXmlContainerPage.getContainerPageTypeId());\r\n            List<CmsResource> allContainerPages = cms.readResources(\"/\", f);\r\n            replacePath(sourceModulePath, targetModulePath, allContainerPages);\r\n\r\n            // delete the old module\r\n            if (Boolean.valueOf(m_deleteModule).booleanValue()) {\r\n                OpenCms.getModuleManager().deleteModule(\r\n                    getCmsObject(),\r\n                    sourceModule.getName(),\r\n                    false,\r\n                    new CmsLogReport(getCmsObject().getRequestContext().getLocale(), CmsCloneModule.class));\r\n            }\r\n\r\n        } catch (CmsIllegalArgumentException e) {\r\n            LOG.error(e.getMessage(), e);\r\n        } catch (CmsException e) {\r\n            LOG.error(e.getMessage(), e);\r\n        } catch (Exception e) {\r\n            LOG.error(e.getMessage(), e);\r\n        }\r\n    }","commit_id":"ca3880fcd5a9c1122e3dd6397b8b2718831ac14d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Changes the resource types and the schema locations of existing content.<p>\r\n     * \r\n     * @param resTypeMap a map containing the source types as keys and the target types as values\r\n     * \r\n     * @throws CmsException if something goes wrong\r\n     * @throws UnsupportedEncodingException if the file content could not be read with the determined encoding\r\n     */\r\n    private void changeResourceTypes(Map<I_CmsResourceType, I_CmsResourceType> resTypeMap)\r\n    throws CmsException, UnsupportedEncodingException {\r\n\r\n        for (Map.Entry<I_CmsResourceType, I_CmsResourceType> mapping : resTypeMap.entrySet()) {\r\n            List<CmsResource> resources = getCmsObject().readResources(\r\n                \"/\",\r\n                CmsResourceFilter.requireType(mapping.getKey().getTypeId()));\r\n            String sourceSchemaPath = mapping.getKey().getConfiguration().get(\"schema\");\r\n            String targetSchemaPath = mapping.getValue().getConfiguration().get(\"schema\");\r\n            for (CmsResource res : resources) {\r\n                if (lockResource(getCmsObject(), res)) {\r\n                    CmsFile file = getCmsObject().readFile(res);\r\n                    String encoding = CmsLocaleManager.getResourceEncoding(getCmsObject(), file);\r\n                    String content = new String(file.getContents(), encoding);\r\n                    content = content.replaceAll(sourceSchemaPath, targetSchemaPath);\r\n                    file.setContents(content.getBytes(encoding));\r\n                    getCmsObject().writeFile(file);\r\n                    res.setType(mapping.getValue().getTypeId());\r\n                    getCmsObject().writeResource(res);\r\n                }\r\n            }\r\n        }\r\n    }","id":97725,"modified_method":"/**\r\n     * Changes the resource types and the schema locations of existing content.<p>\r\n     * \r\n     * @param resTypeMap a map containing the source types as keys and the target types as values\r\n     * \r\n     * @throws CmsException if something goes wrong\r\n     * @throws UnsupportedEncodingException if the file content could not be read with the determined encoding\r\n     */\r\n    private void changeResourceTypes(Map<I_CmsResourceType, I_CmsResourceType> resTypeMap)\r\n    throws CmsException, UnsupportedEncodingException {\r\n\r\n        CmsObject clone = OpenCms.initCmsObject(getCmsObject());\r\n        if (Boolean.valueOf(m_changeResourceTypesEverywhere).booleanValue()) {\r\n            clone.getRequestContext().setSiteRoot(\"/\");\r\n        }\r\n\r\n        for (Map.Entry<I_CmsResourceType, I_CmsResourceType> mapping : resTypeMap.entrySet()) {\r\n            CmsResourceFilter filter = CmsResourceFilter.requireType(mapping.getKey().getTypeId());\r\n            List<CmsResource> resources = clone.readResources(\"/\", filter);\r\n            String sourceSchemaPath = mapping.getKey().getConfiguration().get(\"schema\");\r\n            String targetSchemaPath = mapping.getValue().getConfiguration().get(\"schema\");\r\n            for (CmsResource res : resources) {\r\n                if (lockResource(getCmsObject(), res)) {\r\n                    CmsFile file = getCmsObject().readFile(res);\r\n                    String encoding = CmsLocaleManager.getResourceEncoding(getCmsObject(), file);\r\n                    String content = new String(file.getContents(), encoding);\r\n                    content = content.replaceAll(sourceSchemaPath, targetSchemaPath);\r\n                    file.setContents(content.getBytes(encoding));\r\n                    getCmsObject().writeFile(file);\r\n                    res.setType(mapping.getValue().getTypeId());\r\n                    getCmsObject().writeResource(res);\r\n                }\r\n            }\r\n        }\r\n    }","commit_id":"ca3880fcd5a9c1122e3dd6397b8b2718831ac14d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Parse incoming interests for type and dispatch those dedicated to some special purpose.\n\t * Interests can be to start a write or a name enumeration request.\n\t * If the interest has no special purpose, its assumed that it's to actually read data from\n\t * the repository and the request is sent to the RepositoryStore to be processed.\n\t */\n\tpublic boolean handleInterest(Interest interest) {\n\t\t_server._stats.increment(RepositoryServer.StatsEnum.HandleInterest);\n\t\t\n\t\tif (Log.isLoggable(Log.FAC_REPO, Level.FINER))\n\t\t\tLog.finer(Log.FAC_REPO, \"Saw interest: {0}\", interest.name());\n\t\ttry {\n\t\t\tif (RepositoryOperations.isStartWriteOperation(interest)) {\n\t\t\t\t_server._stats.increment(RepositoryServer.StatsEnum.HandleInterestStartWrite);\n\t\t\t\tif (!allowGenerated(interest)) return true;\n\t\t\t\tstartWrite(interest);\n\t\t\t} else if (RepositoryOperations.isNameEnumerationOperation(interest)) {\n\t\t\t\t_server._stats.increment(RepositoryServer.StatsEnum.HandleInterestNameEnum);\n\t\t\t\tif (!allowGenerated(interest)) return true;\n\t\t\t\tnameEnumeratorResponse(interest);\n\t\t\t} else if (RepositoryOperations.isCheckedWriteOperation(interest)) {\n\t\t\t\t_server._stats.increment(RepositoryServer.StatsEnum.HandleInterestCheckedWrite);\n\t\t\t\tif (!allowGenerated(interest)) return true;\n\t\t\t\tstartWriteChecked(interest);\t\t\t\t\n\t\t\t} else if (RepositoryOperations.isBulkImportOperation(interest)) {\n\t\t\t\t_server._stats.increment(RepositoryServer.StatsEnum.HandleInterestBulkImport);\n\t\t\t\tif (!allowGenerated(interest)) return true;\n\t\t\t\taddBulkDataToRepo(interest);\t\t\t\t\n\t\t\t} else {\n\t\t\t\t_server._stats.increment(RepositoryServer.StatsEnum.HandleInterestUncategorized);\n\t\t\t\tContentObject content = _server.getRepository().getContent(interest);\n\t\t\t\tif (content != null) {\n\t\t\t\t\tif (Log.isLoggable(Log.FAC_REPO, Level.FINEST))\n\t\t\t\t\t\tLog.finest(Log.FAC_REPO, \"Satisfying interest: {0} with content {1}\", interest, content.name());\n\t\t\t\t\t_handle.put(content);\n\t\t\t\t} else {\n\t\t\t\t\tif (Log.isLoggable(Log.FAC_REPO, Level.FINE))\n\t\t\t\t\t\tLog.fine(Log.FAC_REPO, \"Unsatisfied interest: {0}\", interest);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t_server._stats.increment(RepositoryServer.StatsEnum.HandleInterestErrors);\n\t\t\tLog.logStackTrace(Level.WARNING, e);\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn true;\n\t}","id":97726,"modified_method":"/**\n\t * Parse incoming interests for type and dispatch those dedicated to some special purpose.\n\t * Interests can be to start a write or a name enumeration request.\n\t * If the interest has no special purpose, its assumed that it's to actually read data from\n\t * the repository and the request is sent to the RepositoryStore to be processed.\n\t */\n\tpublic boolean handleInterest(Interest interest) {\n\t\t_server._stats.increment(RepositoryServer.StatsEnum.HandleInterest);\n\t\t\n\t\tif (Log.isLoggable(Log.FAC_REPO, Level.FINER))\n\t\t\tLog.finer(Log.FAC_REPO, \"Saw interest: {0}\", interest.name());\n\t\ttry {\n\t\t\tif (interest.name().startsWith(CommandMarker.COMMAND_PREFIX)) {\n\t\t\t\tif (RepositoryOperations.isStartWriteOperation(interest)) {\n\t\t\t\t\t_server._stats.increment(RepositoryServer.StatsEnum.HandleInterestStartWrite);\n\t\t\t\t\tif (allowGenerated(interest))\n\t\t\t\t\t\tstartWrite(interest);\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (RepositoryOperations.isNameEnumerationOperation(interest)) {\n\t\t\t\t\t_server._stats.increment(RepositoryServer.StatsEnum.HandleInterestNameEnum);\n\t\t\t\t\tif (allowGenerated(interest))\n\t\t\t\t\t\tnameEnumeratorResponse(interest);\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (RepositoryOperations.isCheckedWriteOperation(interest)) {\n\t\t\t\t\t_server._stats.increment(RepositoryServer.StatsEnum.HandleInterestCheckedWrite);\n\t\t\t\t\tif (allowGenerated(interest))\n\t\t\t\t\t\tstartWriteChecked(interest);\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (RepositoryOperations.isBulkImportOperation(interest)) {\n\t\t\t\t\t_server._stats.increment(RepositoryServer.StatsEnum.HandleInterestBulkImport);\n\t\t\t\t\tif (allowGenerated(interest))\n\t\t\t\t\t\taddBulkDataToRepo(interest);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_server._stats.increment(RepositoryServer.StatsEnum.HandleInterestUncategorized);\n\t\t\tContentObject content = _server.getRepository().getContent(interest);\n\t\t\tif (content != null) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_REPO, Level.FINEST))\n\t\t\t\t\tLog.finest(Log.FAC_REPO, \"Satisfying interest: {0} with content {1}\", interest, content.name());\n\t\t\t\t_handle.put(content);\n\t\t\t} else {\n\t\t\t\tif (Log.isLoggable(Log.FAC_REPO, Level.FINE))\n\t\t\t\t\tLog.fine(Log.FAC_REPO, \"Unsatisfied interest: {0}\", interest);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t_server._stats.increment(RepositoryServer.StatsEnum.HandleInterestErrors);\n\t\t\tLog.logStackTrace(Level.WARNING, e);\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn true;\n\t}","commit_id":"169e9a4e91e88eb4a76e41e8fad61ca1be520499","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public boolean differentiate(final Mappings delta,\n                               final Collection<String> removed,\n                               final Collection<File> filesToCompile,\n                               final Collection<File> compiledFiles,\n                               final Collection<File> affectedFiles) {\n    delta.compensateRemovedContent(filesToCompile);\n\n    final Util u = new Util(delta);\n    final Util self = new Util(this);\n    final Util o = new Util();\n\n    if (removed != null) {\n      for (String file : removed) {\n        final Collection<ClassRepr> classes = mySourceFileToClasses.get(myContext.get(file));\n\n        if (classes != null) {\n          for (ClassRepr c : classes) {\n            u.affectAll(c.name, affectedFiles);\n          }\n        }\n      }\n    }\n\n    for (DependencyContext.S fileName : delta.mySourceFileToClasses.keyCollection()) {\n      final Set<ClassRepr> classes = (Set<ClassRepr>)delta.mySourceFileToClasses.get(fileName);\n      final Set<ClassRepr> pastClasses = (Set<ClassRepr>)mySourceFileToClasses.get(fileName);\n      final Set<DependencyContext.S> dependants = new HashSet<DependencyContext.S>();\n\n      self.appendDependents(pastClasses, dependants);\n\n      final Set<UsageRepr.Usage> affectedUsages = new HashSet<UsageRepr.Usage>();\n      final Set<UsageRepr.AnnotationUsage> annotationQuery = new HashSet<UsageRepr.AnnotationUsage>();\n      final Map<UsageRepr.Usage, Util.UsageConstraint> usageConstraints = new HashMap<UsageRepr.Usage, Util.UsageConstraint>();\n\n      final Difference.Specifier<ClassRepr> classDiff = Difference.make(pastClasses, classes);\n\n      debug(\"Processing changed classes\");\n\n      for (Pair<ClassRepr, Difference> changed : classDiff.changed()) {\n        final ClassRepr it = changed.first;\n        final ClassRepr.Diff diff = (ClassRepr.Diff)changed.second;\n\n        debug(\"Changed: \");\n        debug(it.name);\n\n        final int addedModifiers = diff.addedModifiers();\n        final int removedModifiers = diff.removedModifiers();\n\n        final boolean superClassChanged = (diff.base() & Difference.SUPERCLASS) > 0;\n        final boolean interfacesChanged = !diff.interfaces().unchanged();\n        final boolean signatureChanged = (diff.base() & Difference.SIGNATURE) > 0;\n\n        if (superClassChanged || interfacesChanged || signatureChanged) {\n          final boolean extendsChanged = superClassChanged && !diff.extendsAdded();\n          final boolean interfacesRemoved = interfacesChanged && !diff.interfaces().removed().isEmpty();\n\n          u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, extendsChanged || interfacesRemoved || signatureChanged);\n        }\n\n        if ((diff.addedModifiers() & Opcodes.ACC_INTERFACE) > 0 || (diff.removedModifiers() & Opcodes.ACC_INTERFACE) > 0) {\n          affectedUsages.add(it.createUsage());\n        }\n\n        if (it.isAnnotation() && it.policy == RetentionPolicy.SOURCE) {\n          debug(\"Annotation, retention policy = SOURCE => a switch to non-incremental mode requested\");\n          return incrementalDecision(it.outerClassName, it, affectedFiles);\n        }\n\n        if ((addedModifiers & Opcodes.ACC_PROTECTED) > 0) {\n          final UsageRepr.Usage usage = it.createUsage();\n\n          affectedUsages.add(usage);\n          usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n        }\n\n        if (diff.packageLocalOn()) {\n          final UsageRepr.Usage usage = it.createUsage();\n\n          affectedUsages.add(usage);\n          usageConstraints.put(usage, u.new PackageConstraint(it.getPackageName()));\n        }\n\n        if ((addedModifiers & Opcodes.ACC_FINAL) > 0 || (addedModifiers & Opcodes.ACC_PRIVATE) > 0) {\n          affectedUsages.add(it.createUsage());\n        }\n\n        if ((addedModifiers & Opcodes.ACC_ABSTRACT) > 0) {\n          affectedUsages.add(UsageRepr.createClassNewUsage(myContext, it.name));\n        }\n\n        if ((addedModifiers & Opcodes.ACC_STATIC) > 0 ||\n            (removedModifiers & Opcodes.ACC_STATIC) > 0 ||\n            (addedModifiers & Opcodes.ACC_ABSTRACT) > 0) {\n          affectedUsages.add(UsageRepr.createClassNewUsage(myContext, it.name));\n        }\n\n        if (it.isAnnotation()) {\n          if (diff.retentionChanged()) {\n            affectedUsages.add(it.createUsage());\n          }\n          else {\n            final Collection<ElementType> removedtargets = diff.targets().removed();\n\n            if (removedtargets.contains(ElementType.LOCAL_VARIABLE)) {\n              debug(\"Annotation, removed target contains LOCAL_VARIABLE => a switch to non-incremental mode requested\");\n              return incrementalDecision(it.outerClassName, it, affectedFiles);\n            }\n\n            if (!removedtargets.isEmpty()) {\n              annotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr\n                .createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), null, removedtargets));\n            }\n\n            for (MethodRepr m : diff.methods().added()) {\n              if (!m.hasValue()) {\n                affectedUsages.add(it.createUsage());\n              }\n            }\n          }\n        }\n\n        for (MethodRepr m : diff.methods().added()) {\n          if (it.isAnnotation()) {\n            continue;\n          }\n\n          if ((it.access & Opcodes.ACC_INTERFACE) > 0 ||\n              (it.access & Opcodes.ACC_ABSTRACT) > 0 ||\n              (m.access & Opcodes.ACC_ABSTRACT) > 0) {\n            u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n          }\n\n          Collection<DependencyContext.S> propagated = null;\n\n          if ((m.access & Opcodes.ACC_PRIVATE) == 0 && !myContext.getValue(m.name).equals(\"<init>\")) {\n            final ClassRepr oldIt = getReprByName(it.name);\n\n            if (oldIt != null && self.findOverridenMethods(m, oldIt).size() > 0) {\n\n            }\n            else {\n              propagated = u.propagateMethodAccess(m.name, it.name);\n              u.affectMethodUsages(m, propagated, m.createMetaUsage(myContext, it.name), affectedUsages, dependants);\n            }\n          }\n\n          if ((m.access & Opcodes.ACC_PRIVATE) == 0) {\n            final Collection<Pair<MethodRepr, ClassRepr>> affectedMethods = u.findAllMethodsBySpecificity(m, it);\n            final MethodRepr.Predicate overrides = MethodRepr.equalByJavaRules(m);\n\n            if (propagated == null) {\n              propagated = u.propagateMethodAccess(m.name, it.name);\n            }\n\n            final Collection<MethodRepr> lessSpecific = it.findMethods(u.lessSpecific(m));\n\n            for (MethodRepr mm : lessSpecific) {\n              if (!mm.equals(m)) {\n                u.affectMethodUsages(mm, propagated, mm.createUsage(myContext, it.name), affectedUsages, dependants);\n              }\n            }\n\n            for (Pair<MethodRepr, ClassRepr> p : affectedMethods) {\n              final MethodRepr mm = p.first;\n              final ClassRepr cc = p.second;\n\n              if (cc == myMockClass) {\n\n              }\n              else {\n                if (overrides.satisfy(mm)) {\n                  final Option<Boolean> subtypeOf = u.isSubtypeOf(mm.type, m.type);\n\n                  if (weakerAccess(mm.access, m.access) ||\n                      ((m.access & Opcodes.ACC_STATIC) > 0 && (mm.access & Opcodes.ACC_STATIC) == 0) ||\n                      ((m.access & Opcodes.ACC_STATIC) == 0 && (mm.access & Opcodes.ACC_STATIC) > 0) ||\n                      ((m.access & Opcodes.ACC_FINAL) > 0) ||\n                      !m.exceptions.equals(mm.exceptions) ||\n                      (subtypeOf.isNone() || !subtypeOf.value()) ||\n                      !empty(mm.signature) || !empty(m.signature)) {\n                    final DependencyContext.S file = myClassToSourceFile.get(cc.name);\n\n                    if (file != null) {\n                      affectedFiles.add(new File(myContext.getValue(file)));\n                    }\n                  }\n                }\n                else {\n                  final Collection<DependencyContext.S> yetPropagated = self.propagateMethodAccess(mm.name, cc.name);\n                  final Collection<DependencyContext.S> deps = myClassToClassDependency.get(cc.name);\n\n                  if (deps != null) {\n                    dependants.addAll(deps);\n                  }\n\n                  u.affectMethodUsages(mm, yetPropagated, mm.createUsage(myContext, cc.name), affectedUsages, dependants);\n                }\n              }\n            }\n\n            final Collection<DependencyContext.S> subClasses = getAllSubclasses(it.name);\n\n            if (subClasses != null) {\n              for (final DependencyContext.S subClass : subClasses) {\n                final ClassRepr r = u.reprByName(subClass);\n                final DependencyContext.S sourceFileName = myClassToSourceFile.get(subClass);\n\n                if (r != null && sourceFileName != null) {\n                  final DependencyContext.S outerClass = r.outerClassName;\n\n                  if (u.methodVisible(outerClass, m)) {\n                    affectedFiles.add(new File(myContext.getValue(sourceFileName)));\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        for (MethodRepr m : diff.methods().removed()) {\n          final Collection<Pair<MethodRepr, ClassRepr>> overridenMethods = u.findOverridenMethods(m, it);\n          final Collection<DependencyContext.S> propagated = u.propagateMethodAccess(m.name, it.name);\n\n          if (overridenMethods.size() == 0) {\n            u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), affectedUsages, dependants);\n          }\n          else {\n            boolean clear = true;\n\n            loop:\n            for (Pair<MethodRepr, ClassRepr> overriden : overridenMethods) {\n              final MethodRepr mm = overriden.first;\n\n              if (mm == myMockMethod || !mm.type.equals(m.type) || !empty(mm.signature) || !empty(m.signature)) {\n                clear = false;\n                break loop;\n              }\n            }\n\n            if (!clear) {\n              u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), affectedUsages, dependants);\n            }\n          }\n\n          if ((m.access & Opcodes.ACC_ABSTRACT) == 0) {\n            for (DependencyContext.S p : propagated) {\n              final ClassRepr s = u.reprByName(p);\n\n              if (s != null) {\n                final Collection<Pair<MethodRepr, ClassRepr>> overridenInS = u.findOverridenMethods(m, s);\n\n                overridenInS.addAll(overridenMethods);\n\n                boolean allAbstract = true;\n                boolean visited = false;\n\n                for (Pair<MethodRepr, ClassRepr> pp : overridenInS) {\n                  final ClassRepr cc = pp.second;\n\n                  if (cc == myMockClass) {\n                    visited = true;\n                    continue;\n                  }\n\n                  if (cc.name.equals(it.name)) {\n                    continue;\n                  }\n\n                  visited = true;\n                  allAbstract = ((pp.first.access & Opcodes.ACC_ABSTRACT) > 0) || ((cc.access & Opcodes.ACC_INTERFACE) > 0);\n\n                  if (!allAbstract) {\n                    break;\n                  }\n                }\n\n                if (allAbstract && visited) {\n                  final DependencyContext.S source = myClassToSourceFile.get(p);\n\n                  if (source != null) {\n                    affectedFiles.add(new File(myContext.getValue(source)));\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        for (Pair<MethodRepr, Difference> mr : diff.methods().changed()) {\n          final MethodRepr m = mr.first;\n          final MethodRepr.Diff d = (MethodRepr.Diff)mr.second;\n          final boolean throwsChanged = (d.exceptions().added().size() > 0) || (d.exceptions().changed().size() > 0);\n\n          if (it.isAnnotation()) {\n            if (d.defaultRemoved()) {\n              final List<DependencyContext.S> l = new LinkedList<DependencyContext.S>();\n              l.add(m.name);\n              annotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr\n                .createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), l, null));\n            }\n          }\n          else if (d.base() != Difference.NONE || throwsChanged) {\n            final Collection<DependencyContext.S> propagated = u.propagateMethodAccess(m.name, it.name);\n\n            boolean affected = false;\n            boolean constrained = false;\n\n            final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>();\n\n            if (d.packageLocalOn()) {\n              u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n\n              for (UsageRepr.Usage usage : usages) {\n                usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n              }\n\n              affectedUsages.addAll(usages);\n              affected = true;\n              constrained = true;\n            }\n\n            if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0 || throwsChanged) {\n              if (!affected) {\n                u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n                affectedUsages.addAll(usages);\n              }\n            }\n            else if ((d.base() & Difference.ACCESS) > 0) {\n              if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0) {\n                if (!affected) {\n                  u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n                  affectedUsages.addAll(usages);\n                }\n\n                if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0) {\n                  u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n                }\n              }\n              else {\n                if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0 ||\n                    (d.addedModifiers() & Opcodes.ACC_PUBLIC) > 0 ||\n                    (d.addedModifiers() & Opcodes.ACC_ABSTRACT) > 0) {\n                  u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n                }\n\n                if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0 && !((d.removedModifiers() & Opcodes.ACC_PRIVATE) > 0)) {\n                  if (!constrained) {\n                    if (!affected) {\n                      u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n                      affectedUsages.addAll(usages);\n                    }\n\n                    for (UsageRepr.Usage usage : usages) {\n                      usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        final int mask = Opcodes.ACC_STATIC | Opcodes.ACC_FINAL;\n\n        for (FieldRepr f : diff.fields().added()) {\n          final boolean fPrivate = (f.access & Opcodes.ACC_PRIVATE) > 0;\n          final boolean fProtected = (f.access & Opcodes.ACC_PROTECTED) > 0;\n          final boolean fPublic = (f.access & Opcodes.ACC_PUBLIC) > 0;\n          final boolean fPLocal = !fPrivate && !fProtected && !fPublic;\n\n          if (!fPrivate) {\n            final Collection<DependencyContext.S> subClasses = getAllSubclasses(it.name);\n\n            if (subClasses != null) {\n              for (final DependencyContext.S subClass : subClasses) {\n                final ClassRepr r = u.reprByName(subClass);\n                final DependencyContext.S sourceFileName = myClassToSourceFile.get(subClass);\n\n                if (r != null && sourceFileName != null) {\n                  if (r.isLocal) {\n                    affectedFiles.add(new File(myContext.getValue(sourceFileName)));\n                  }\n                  else {\n                    final DependencyContext.S outerClass = r.outerClassName;\n\n                    if (!empty(outerClass) && u.fieldVisible(outerClass, f)) {\n                      affectedFiles.add(new File(myContext.getValue(sourceFileName)));\n                    }\n                  }\n                }\n\n                final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(f.name, subClass);\n                u.affectFieldUsages(f, propagated, f.createUsage(myContext, subClass), affectedUsages, dependants);\n\n                final Collection<DependencyContext.S> deps = myClassToClassDependency.get(subClass);\n\n                if (deps != null) {\n                  dependants.addAll(deps);\n                }\n              }\n            }\n          }\n\n          final Collection<Pair<FieldRepr, ClassRepr>> overridden = u.findOverridenFields(f, it);\n\n          for (Pair<FieldRepr, ClassRepr> p : overridden) {\n            final FieldRepr ff = p.first;\n            final ClassRepr cc = p.second;\n\n            final boolean ffPrivate = (ff.access & Opcodes.ACC_PRIVATE) > 0;\n            final boolean ffProtected = (ff.access & Opcodes.ACC_PROTECTED) > 0;\n            final boolean ffPublic = (ff.access & Opcodes.ACC_PUBLIC) > 0;\n            final boolean ffPLocal = isPackageLocal(ff.access);\n\n            if (!ffPrivate) {\n              final Collection<DependencyContext.S> propagated = o.propagateFieldAccess(ff.name, cc.name);\n              final Set<UsageRepr.Usage> localUsages = new HashSet<UsageRepr.Usage>();\n\n              u.affectFieldUsages(ff, propagated, ff.createUsage(myContext, cc.name), localUsages, dependants);\n\n              if (fPrivate || (fPublic && (ffPublic || ffPLocal)) || (fProtected && ffProtected) || (fPLocal && ffPLocal)) {\n\n              }\n              else {\n                Util.UsageConstraint constaint;\n\n                if ((ffProtected && fPublic) || (fProtected && ffPublic) || (ffPLocal && fProtected)) {\n                  constaint = u.new NegationConstraint(u.new InheritanceConstraint(cc.name));\n                }\n                else if (ffPublic && ffPLocal) {\n                  constaint = u.new NegationConstraint(u.new PackageConstraint(cc.getPackageName()));\n                }\n                else {\n                  constaint = u.new IntersectionConstraint(u.new NegationConstraint(u.new InheritanceConstraint(cc.name)),\n                                                           u.new NegationConstraint(u.new PackageConstraint(cc.getPackageName())));\n                }\n\n                for (UsageRepr.Usage usage : localUsages) {\n                  usageConstraints.put(usage, constaint);\n                }\n              }\n\n              affectedUsages.addAll(localUsages);\n            }\n          }\n        }\n\n        debug(\"Processing removed fields\");\n\n        for (FieldRepr f : diff.fields().removed()) {\n          debug(\"Field \");\n          debug(f.name);\n\n          if ((f.access & Opcodes.ACC_PRIVATE) == 0 && (f.access & mask) == mask && f.hasValue()) {\n            debug(\"Field had value and was (non-private) final static => a switch to non-incremental mode requested\");\n            return incrementalDecision(it.name, f, affectedFiles);\n          }\n\n          final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(f.name, it.name);\n          u.affectFieldUsages(f, propagated, f.createUsage(myContext, it.name), affectedUsages, dependants);\n        }\n\n        debug(\"Processing changed fields\");\n\n        for (Pair<FieldRepr, Difference> f : diff.fields().changed()) {\n          final Difference d = f.second;\n          final FieldRepr field = f.first;\n\n          debug(\"Field \");\n          debug(field.name);\n\n          if ((field.access & Opcodes.ACC_PRIVATE) == 0 && (field.access & mask) == mask) {\n            if ((d.base() & Difference.ACCESS) > 0 || (d.base() & Difference.VALUE) > 0) {\n              debug(\"Inline field changed it's access or value => a switch to non-incremental mode requested\");\n              return incrementalDecision(it.name, field, affectedFiles);\n            }\n          }\n\n          if (d.base() != Difference.NONE) {\n            final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(field.name, it.name);\n\n            if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0) {\n              u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), affectedUsages, dependants);\n            }\n            else if ((d.base() & Difference.ACCESS) > 0) {\n              if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_VOLATILE) > 0) {\n\n                u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), affectedUsages, dependants);\n              }\n              else {\n                boolean affected = false;\n                final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>();\n\n                if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0) {\n                  u.affectFieldUsages(field, propagated, field.createAssignUsage(myContext, it.name), usages, dependants);\n                  affectedUsages.addAll(usages);\n                  affected = true;\n                }\n\n                if ((d.removedModifiers() & Opcodes.ACC_PUBLIC) > 0) {\n                  if (!affected) {\n                    u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), usages, dependants);\n                    affectedUsages.addAll(usages);\n                  }\n\n                  for (UsageRepr.Usage usage : usages) {\n                    if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0) {\n                      usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n                    }\n                    else {\n                      usageConstraints.put(usage, u.new PackageConstraint(it.getPackageName()));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      for (ClassRepr c : classDiff.removed()) {\n        affectedUsages.add(c.createUsage());\n      }\n\n      for (ClassRepr c : classDiff.added()) {\n        final Collection<DependencyContext.S> depClasses = myClassToClassDependency.get(c.name);\n\n        if (depClasses != null) {\n          for (DependencyContext.S depClass : depClasses) {\n            final DependencyContext.S fName = myClassToSourceFile.get(depClass);\n\n            if (fName != null) {\n              affectedFiles.add(new File(myContext.getValue(fName)));\n            }\n          }\n        }\n      }\n\n      if (dependants != null) {\n        final Set<DependencyContext.S> dependentFiles = new HashSet<DependencyContext.S>();\n\n        for (DependencyContext.S depClass : dependants) {\n          final DependencyContext.S file = myClassToSourceFile.get(depClass);\n\n          if (file != null) {\n            dependentFiles.add(file);\n          }\n        }\n\n        filewise:\n        for (DependencyContext.S depFile : dependentFiles) {\n          final File theFile = new File(myContext.getValue(depFile));\n\n          if (affectedFiles.contains(theFile) || compiledFiles.contains(theFile)) {\n            continue filewise;\n          }\n\n          final Collection<UsageRepr.Cluster> depClusters = mySourceFileToUsages.get(depFile);\n\n          for (UsageRepr.Cluster depCluster : depClusters) {\n            final Set<UsageRepr.Usage> depUsages = depCluster.getUsages();\n\n            if (depUsages != null) {\n              final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>(depUsages);\n\n              usages.retainAll(affectedUsages);\n\n              if (!usages.isEmpty()) {\n                for (UsageRepr.Usage usage : usages) {\n                  final Util.UsageConstraint constraint = usageConstraints.get(usage);\n\n                  if (constraint == null) {\n                    affectedFiles.add(theFile);\n                    continue filewise;\n                  }\n                  else {\n                    final Set<DependencyContext.S> residenceClasses = depCluster.getResidence(usage);\n                    for (DependencyContext.S residentName : residenceClasses) {\n                      if (constraint.checkResidence(residentName)) {\n                        affectedFiles.add(theFile);\n                        continue filewise;\n                      }\n                    }\n\n                  }\n                }\n              }\n\n              if (annotationQuery.size() > 0) {\n                final Collection<UsageRepr.Usage> annotationUsages = mySourceFileToAnnotationUsages.get(depFile);\n\n                for (UsageRepr.Usage usage : annotationUsages) {\n                  for (UsageRepr.AnnotationUsage query : annotationQuery) {\n                    if (query.satisfies(usage)) {\n                      affectedFiles.add(theFile);\n                      continue filewise;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  }","id":97727,"modified_method":"public boolean differentiate(final Mappings delta,\n                               final Collection<String> removed,\n                               final Collection<File> filesToCompile,\n                               final Collection<File> compiledFiles,\n                               final Collection<File> affectedFiles) {\n    delta.compensateRemovedContent(filesToCompile);\n\n    final Util u = new Util(delta);\n    final Util self = new Util(this);\n    final Util o = new Util();\n\n    if (removed != null) {\n      for (String file : removed) {\n        final Collection<ClassRepr> classes = mySourceFileToClasses.get(myContext.get(file));\n\n        if (classes != null) {\n          for (ClassRepr c : classes) {\n            u.affectAll(c.name, affectedFiles);\n          }\n        }\n      }\n    }\n\n    for (DependencyContext.S fileName : delta.mySourceFileToClasses.keyCollection()) {\n      final Set<ClassRepr> classes = (Set<ClassRepr>)delta.mySourceFileToClasses.get(fileName);\n      final Set<ClassRepr> pastClasses = (Set<ClassRepr>)mySourceFileToClasses.get(fileName);\n      final Set<DependencyContext.S> dependants = new HashSet<DependencyContext.S>();\n\n      self.appendDependents(pastClasses, dependants);\n\n      final Set<UsageRepr.Usage> affectedUsages = new HashSet<UsageRepr.Usage>();\n      final Set<UsageRepr.AnnotationUsage> annotationQuery = new HashSet<UsageRepr.AnnotationUsage>();\n      final Map<UsageRepr.Usage, Util.UsageConstraint> usageConstraints = new HashMap<UsageRepr.Usage, Util.UsageConstraint>();\n\n      final Difference.Specifier<ClassRepr> classDiff = Difference.make(pastClasses, classes);\n\n      debug(\"Processing changed classes\");\n\n      for (Pair<ClassRepr, Difference> changed : classDiff.changed()) {\n        final ClassRepr it = changed.first;\n        final ClassRepr.Diff diff = (ClassRepr.Diff)changed.second;\n\n        debug(\"Changed: \");\n        debug(it.name);\n\n        final int addedModifiers = diff.addedModifiers();\n        final int removedModifiers = diff.removedModifiers();\n\n        final boolean superClassChanged = (diff.base() & Difference.SUPERCLASS) > 0;\n        final boolean interfacesChanged = !diff.interfaces().unchanged();\n        final boolean signatureChanged = (diff.base() & Difference.SIGNATURE) > 0;\n\n        if (superClassChanged || interfacesChanged || signatureChanged) {\n          final boolean extendsChanged = superClassChanged && !diff.extendsAdded();\n          final boolean interfacesRemoved = interfacesChanged && !diff.interfaces().removed().isEmpty();\n\n          u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, extendsChanged || interfacesRemoved || signatureChanged);\n        }\n\n        if ((diff.addedModifiers() & Opcodes.ACC_INTERFACE) > 0 || (diff.removedModifiers() & Opcodes.ACC_INTERFACE) > 0) {\n          affectedUsages.add(it.createUsage());\n        }\n\n        if (it.isAnnotation() && it.policy == RetentionPolicy.SOURCE) {\n          debug(\"Annotation, retention policy = SOURCE => a switch to non-incremental mode requested\");\n          if (!incrementalDecision(it.outerClassName, it, affectedFiles)) {\n            return false;\n          }\n        }\n\n        if ((addedModifiers & Opcodes.ACC_PROTECTED) > 0) {\n          final UsageRepr.Usage usage = it.createUsage();\n\n          affectedUsages.add(usage);\n          usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n        }\n\n        if (diff.packageLocalOn()) {\n          final UsageRepr.Usage usage = it.createUsage();\n\n          affectedUsages.add(usage);\n          usageConstraints.put(usage, u.new PackageConstraint(it.getPackageName()));\n        }\n\n        if ((addedModifiers & Opcodes.ACC_FINAL) > 0 || (addedModifiers & Opcodes.ACC_PRIVATE) > 0) {\n          affectedUsages.add(it.createUsage());\n        }\n\n        if ((addedModifiers & Opcodes.ACC_ABSTRACT) > 0) {\n          affectedUsages.add(UsageRepr.createClassNewUsage(myContext, it.name));\n        }\n\n        if ((addedModifiers & Opcodes.ACC_STATIC) > 0 ||\n            (removedModifiers & Opcodes.ACC_STATIC) > 0 ||\n            (addedModifiers & Opcodes.ACC_ABSTRACT) > 0) {\n          affectedUsages.add(UsageRepr.createClassNewUsage(myContext, it.name));\n        }\n\n        if (it.isAnnotation()) {\n          if (diff.retentionChanged()) {\n            affectedUsages.add(it.createUsage());\n          }\n          else {\n            final Collection<ElementType> removedtargets = diff.targets().removed();\n\n            if (removedtargets.contains(ElementType.LOCAL_VARIABLE)) {\n              debug(\"Annotation, removed target contains LOCAL_VARIABLE => a switch to non-incremental mode requested\");\n              if (!incrementalDecision(it.outerClassName, it, affectedFiles)) {\n                return false;\n              }\n            }\n\n            if (!removedtargets.isEmpty()) {\n              annotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr\n                .createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), null, removedtargets));\n            }\n\n            for (MethodRepr m : diff.methods().added()) {\n              if (!m.hasValue()) {\n                affectedUsages.add(it.createUsage());\n              }\n            }\n          }\n        }\n\n        for (MethodRepr m : diff.methods().added()) {\n          if (it.isAnnotation()) {\n            continue;\n          }\n\n          if ((it.access & Opcodes.ACC_INTERFACE) > 0 ||\n              (it.access & Opcodes.ACC_ABSTRACT) > 0 ||\n              (m.access & Opcodes.ACC_ABSTRACT) > 0) {\n            u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n          }\n\n          Collection<DependencyContext.S> propagated = null;\n\n          if ((m.access & Opcodes.ACC_PRIVATE) == 0 && !myContext.getValue(m.name).equals(\"<init>\")) {\n            final ClassRepr oldIt = getReprByName(it.name);\n\n            if (oldIt != null && self.findOverridenMethods(m, oldIt).size() > 0) {\n\n            }\n            else {\n              propagated = u.propagateMethodAccess(m.name, it.name);\n              u.affectMethodUsages(m, propagated, m.createMetaUsage(myContext, it.name), affectedUsages, dependants);\n            }\n          }\n\n          if ((m.access & Opcodes.ACC_PRIVATE) == 0) {\n            final Collection<Pair<MethodRepr, ClassRepr>> affectedMethods = u.findAllMethodsBySpecificity(m, it);\n            final MethodRepr.Predicate overrides = MethodRepr.equalByJavaRules(m);\n\n            if (propagated == null) {\n              propagated = u.propagateMethodAccess(m.name, it.name);\n            }\n\n            final Collection<MethodRepr> lessSpecific = it.findMethods(u.lessSpecific(m));\n\n            for (MethodRepr mm : lessSpecific) {\n              if (!mm.equals(m)) {\n                u.affectMethodUsages(mm, propagated, mm.createUsage(myContext, it.name), affectedUsages, dependants);\n              }\n            }\n\n            for (Pair<MethodRepr, ClassRepr> p : affectedMethods) {\n              final MethodRepr mm = p.first;\n              final ClassRepr cc = p.second;\n\n              if (cc == myMockClass) {\n\n              }\n              else {\n                if (overrides.satisfy(mm)) {\n                  final Option<Boolean> subtypeOf = u.isSubtypeOf(mm.type, m.type);\n\n                  if (weakerAccess(mm.access, m.access) ||\n                      ((m.access & Opcodes.ACC_STATIC) > 0 && (mm.access & Opcodes.ACC_STATIC) == 0) ||\n                      ((m.access & Opcodes.ACC_STATIC) == 0 && (mm.access & Opcodes.ACC_STATIC) > 0) ||\n                      ((m.access & Opcodes.ACC_FINAL) > 0) ||\n                      !m.exceptions.equals(mm.exceptions) ||\n                      (subtypeOf.isNone() || !subtypeOf.value()) ||\n                      !empty(mm.signature) || !empty(m.signature)) {\n                    final DependencyContext.S file = myClassToSourceFile.get(cc.name);\n\n                    if (file != null) {\n                      affectedFiles.add(new File(myContext.getValue(file)));\n                    }\n                  }\n                }\n                else {\n                  final Collection<DependencyContext.S> yetPropagated = self.propagateMethodAccess(mm.name, cc.name);\n                  final Collection<DependencyContext.S> deps = myClassToClassDependency.get(cc.name);\n\n                  if (deps != null) {\n                    dependants.addAll(deps);\n                  }\n\n                  u.affectMethodUsages(mm, yetPropagated, mm.createUsage(myContext, cc.name), affectedUsages, dependants);\n                }\n              }\n            }\n\n            final Collection<DependencyContext.S> subClasses = getAllSubclasses(it.name);\n\n            if (subClasses != null) {\n              for (final DependencyContext.S subClass : subClasses) {\n                final ClassRepr r = u.reprByName(subClass);\n                final DependencyContext.S sourceFileName = myClassToSourceFile.get(subClass);\n\n                if (r != null && sourceFileName != null) {\n                  final DependencyContext.S outerClass = r.outerClassName;\n\n                  if (u.methodVisible(outerClass, m)) {\n                    affectedFiles.add(new File(myContext.getValue(sourceFileName)));\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        for (MethodRepr m : diff.methods().removed()) {\n          final Collection<Pair<MethodRepr, ClassRepr>> overridenMethods = u.findOverridenMethods(m, it);\n          final Collection<DependencyContext.S> propagated = u.propagateMethodAccess(m.name, it.name);\n\n          if (overridenMethods.size() == 0) {\n            u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), affectedUsages, dependants);\n          }\n          else {\n            boolean clear = true;\n\n            loop:\n            for (Pair<MethodRepr, ClassRepr> overriden : overridenMethods) {\n              final MethodRepr mm = overriden.first;\n\n              if (mm == myMockMethod || !mm.type.equals(m.type) || !empty(mm.signature) || !empty(m.signature)) {\n                clear = false;\n                break loop;\n              }\n            }\n\n            if (!clear) {\n              u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), affectedUsages, dependants);\n            }\n          }\n\n          if ((m.access & Opcodes.ACC_ABSTRACT) == 0) {\n            for (DependencyContext.S p : propagated) {\n              final ClassRepr s = u.reprByName(p);\n\n              if (s != null) {\n                final Collection<Pair<MethodRepr, ClassRepr>> overridenInS = u.findOverridenMethods(m, s);\n\n                overridenInS.addAll(overridenMethods);\n\n                boolean allAbstract = true;\n                boolean visited = false;\n\n                for (Pair<MethodRepr, ClassRepr> pp : overridenInS) {\n                  final ClassRepr cc = pp.second;\n\n                  if (cc == myMockClass) {\n                    visited = true;\n                    continue;\n                  }\n\n                  if (cc.name.equals(it.name)) {\n                    continue;\n                  }\n\n                  visited = true;\n                  allAbstract = ((pp.first.access & Opcodes.ACC_ABSTRACT) > 0) || ((cc.access & Opcodes.ACC_INTERFACE) > 0);\n\n                  if (!allAbstract) {\n                    break;\n                  }\n                }\n\n                if (allAbstract && visited) {\n                  final DependencyContext.S source = myClassToSourceFile.get(p);\n\n                  if (source != null) {\n                    affectedFiles.add(new File(myContext.getValue(source)));\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        for (Pair<MethodRepr, Difference> mr : diff.methods().changed()) {\n          final MethodRepr m = mr.first;\n          final MethodRepr.Diff d = (MethodRepr.Diff)mr.second;\n          final boolean throwsChanged = (d.exceptions().added().size() > 0) || (d.exceptions().changed().size() > 0);\n\n          if (it.isAnnotation()) {\n            if (d.defaultRemoved()) {\n              final List<DependencyContext.S> l = new LinkedList<DependencyContext.S>();\n              l.add(m.name);\n              annotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr\n                .createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), l, null));\n            }\n          }\n          else if (d.base() != Difference.NONE || throwsChanged) {\n            final Collection<DependencyContext.S> propagated = u.propagateMethodAccess(m.name, it.name);\n\n            boolean affected = false;\n            boolean constrained = false;\n\n            final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>();\n\n            if (d.packageLocalOn()) {\n              u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n\n              for (UsageRepr.Usage usage : usages) {\n                usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n              }\n\n              affectedUsages.addAll(usages);\n              affected = true;\n              constrained = true;\n            }\n\n            if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0 || throwsChanged) {\n              if (!affected) {\n                u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n                affectedUsages.addAll(usages);\n              }\n            }\n            else if ((d.base() & Difference.ACCESS) > 0) {\n              if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0) {\n                if (!affected) {\n                  u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n                  affectedUsages.addAll(usages);\n                }\n\n                if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0) {\n                  u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n                }\n              }\n              else {\n                if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0 ||\n                    (d.addedModifiers() & Opcodes.ACC_PUBLIC) > 0 ||\n                    (d.addedModifiers() & Opcodes.ACC_ABSTRACT) > 0) {\n                  u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n                }\n\n                if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0 && !((d.removedModifiers() & Opcodes.ACC_PRIVATE) > 0)) {\n                  if (!constrained) {\n                    if (!affected) {\n                      u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n                      affectedUsages.addAll(usages);\n                    }\n\n                    for (UsageRepr.Usage usage : usages) {\n                      usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        final int mask = Opcodes.ACC_STATIC | Opcodes.ACC_FINAL;\n\n        for (FieldRepr f : diff.fields().added()) {\n          final boolean fPrivate = (f.access & Opcodes.ACC_PRIVATE) > 0;\n          final boolean fProtected = (f.access & Opcodes.ACC_PROTECTED) > 0;\n          final boolean fPublic = (f.access & Opcodes.ACC_PUBLIC) > 0;\n          final boolean fPLocal = !fPrivate && !fProtected && !fPublic;\n\n          if (!fPrivate) {\n            final Collection<DependencyContext.S> subClasses = getAllSubclasses(it.name);\n\n            if (subClasses != null) {\n              for (final DependencyContext.S subClass : subClasses) {\n                final ClassRepr r = u.reprByName(subClass);\n                final DependencyContext.S sourceFileName = myClassToSourceFile.get(subClass);\n\n                if (r != null && sourceFileName != null) {\n                  if (r.isLocal) {\n                    affectedFiles.add(new File(myContext.getValue(sourceFileName)));\n                  }\n                  else {\n                    final DependencyContext.S outerClass = r.outerClassName;\n\n                    if (!empty(outerClass) && u.fieldVisible(outerClass, f)) {\n                      affectedFiles.add(new File(myContext.getValue(sourceFileName)));\n                    }\n                  }\n                }\n\n                final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(f.name, subClass);\n                u.affectFieldUsages(f, propagated, f.createUsage(myContext, subClass), affectedUsages, dependants);\n\n                final Collection<DependencyContext.S> deps = myClassToClassDependency.get(subClass);\n\n                if (deps != null) {\n                  dependants.addAll(deps);\n                }\n              }\n            }\n          }\n\n          final Collection<Pair<FieldRepr, ClassRepr>> overridden = u.findOverridenFields(f, it);\n\n          for (Pair<FieldRepr, ClassRepr> p : overridden) {\n            final FieldRepr ff = p.first;\n            final ClassRepr cc = p.second;\n\n            final boolean ffPrivate = (ff.access & Opcodes.ACC_PRIVATE) > 0;\n            final boolean ffProtected = (ff.access & Opcodes.ACC_PROTECTED) > 0;\n            final boolean ffPublic = (ff.access & Opcodes.ACC_PUBLIC) > 0;\n            final boolean ffPLocal = isPackageLocal(ff.access);\n\n            if (!ffPrivate) {\n              final Collection<DependencyContext.S> propagated = o.propagateFieldAccess(ff.name, cc.name);\n              final Set<UsageRepr.Usage> localUsages = new HashSet<UsageRepr.Usage>();\n\n              u.affectFieldUsages(ff, propagated, ff.createUsage(myContext, cc.name), localUsages, dependants);\n\n              if (fPrivate || (fPublic && (ffPublic || ffPLocal)) || (fProtected && ffProtected) || (fPLocal && ffPLocal)) {\n\n              }\n              else {\n                Util.UsageConstraint constaint;\n\n                if ((ffProtected && fPublic) || (fProtected && ffPublic) || (ffPLocal && fProtected)) {\n                  constaint = u.new NegationConstraint(u.new InheritanceConstraint(cc.name));\n                }\n                else if (ffPublic && ffPLocal) {\n                  constaint = u.new NegationConstraint(u.new PackageConstraint(cc.getPackageName()));\n                }\n                else {\n                  constaint = u.new IntersectionConstraint(u.new NegationConstraint(u.new InheritanceConstraint(cc.name)),\n                                                           u.new NegationConstraint(u.new PackageConstraint(cc.getPackageName())));\n                }\n\n                for (UsageRepr.Usage usage : localUsages) {\n                  usageConstraints.put(usage, constaint);\n                }\n              }\n\n              affectedUsages.addAll(localUsages);\n            }\n          }\n        }\n\n        debug(\"Processing removed fields\");\n\n        for (FieldRepr f : diff.fields().removed()) {\n          debug(\"Field \");\n          debug(f.name);\n\n          if ((f.access & Opcodes.ACC_PRIVATE) == 0 && (f.access & mask) == mask && f.hasValue()) {\n            debug(\"Field had value and was (non-private) final static => a switch to non-incremental mode requested\");\n            if (!incrementalDecision(it.name, f, affectedFiles)) {\n              return false;\n            }\n          }\n\n          final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(f.name, it.name);\n          u.affectFieldUsages(f, propagated, f.createUsage(myContext, it.name), affectedUsages, dependants);\n        }\n\n        debug(\"Processing changed fields\");\n\n        for (Pair<FieldRepr, Difference> f : diff.fields().changed()) {\n          final Difference d = f.second;\n          final FieldRepr field = f.first;\n\n          debug(\"Field \");\n          debug(field.name);\n\n          if ((field.access & Opcodes.ACC_PRIVATE) == 0 && (field.access & mask) == mask) {\n            if ((d.base() & Difference.ACCESS) > 0 || (d.base() & Difference.VALUE) > 0) {\n              debug(\"Inline field changed it's access or value => a switch to non-incremental mode requested\");\n              if (!incrementalDecision(it.name, field, affectedFiles)){\n                return false;\n              }\n            }\n          }\n\n          if (d.base() != Difference.NONE) {\n            final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(field.name, it.name);\n\n            if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0) {\n              u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), affectedUsages, dependants);\n            }\n            else if ((d.base() & Difference.ACCESS) > 0) {\n              if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_VOLATILE) > 0) {\n\n                u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), affectedUsages, dependants);\n              }\n              else {\n                boolean affected = false;\n                final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>();\n\n                if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0) {\n                  u.affectFieldUsages(field, propagated, field.createAssignUsage(myContext, it.name), usages, dependants);\n                  affectedUsages.addAll(usages);\n                  affected = true;\n                }\n\n                if ((d.removedModifiers() & Opcodes.ACC_PUBLIC) > 0) {\n                  if (!affected) {\n                    u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), usages, dependants);\n                    affectedUsages.addAll(usages);\n                  }\n\n                  for (UsageRepr.Usage usage : usages) {\n                    if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0) {\n                      usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n                    }\n                    else {\n                      usageConstraints.put(usage, u.new PackageConstraint(it.getPackageName()));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      for (ClassRepr c : classDiff.removed()) {\n        affectedUsages.add(c.createUsage());\n      }\n\n      for (ClassRepr c : classDiff.added()) {\n        final Collection<DependencyContext.S> depClasses = myClassToClassDependency.get(c.name);\n\n        if (depClasses != null) {\n          for (DependencyContext.S depClass : depClasses) {\n            final DependencyContext.S fName = myClassToSourceFile.get(depClass);\n\n            if (fName != null) {\n              affectedFiles.add(new File(myContext.getValue(fName)));\n            }\n          }\n        }\n      }\n\n      if (dependants != null) {\n        final Set<DependencyContext.S> dependentFiles = new HashSet<DependencyContext.S>();\n\n        for (DependencyContext.S depClass : dependants) {\n          final DependencyContext.S file = myClassToSourceFile.get(depClass);\n\n          if (file != null) {\n            dependentFiles.add(file);\n          }\n        }\n\n        filewise:\n        for (DependencyContext.S depFile : dependentFiles) {\n          final File theFile = new File(myContext.getValue(depFile));\n\n          if (affectedFiles.contains(theFile) || compiledFiles.contains(theFile)) {\n            continue filewise;\n          }\n\n          final Collection<UsageRepr.Cluster> depClusters = mySourceFileToUsages.get(depFile);\n\n          for (UsageRepr.Cluster depCluster : depClusters) {\n            final Set<UsageRepr.Usage> depUsages = depCluster.getUsages();\n\n            if (depUsages != null) {\n              final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>(depUsages);\n\n              usages.retainAll(affectedUsages);\n\n              if (!usages.isEmpty()) {\n                for (UsageRepr.Usage usage : usages) {\n                  final Util.UsageConstraint constraint = usageConstraints.get(usage);\n\n                  if (constraint == null) {\n                    affectedFiles.add(theFile);\n                    continue filewise;\n                  }\n                  else {\n                    final Set<DependencyContext.S> residenceClasses = depCluster.getResidence(usage);\n                    for (DependencyContext.S residentName : residenceClasses) {\n                      if (constraint.checkResidence(residentName)) {\n                        affectedFiles.add(theFile);\n                        continue filewise;\n                      }\n                    }\n\n                  }\n                }\n              }\n\n              if (annotationQuery.size() > 0) {\n                final Collection<UsageRepr.Usage> annotationUsages = mySourceFileToAnnotationUsages.get(depFile);\n\n                for (UsageRepr.Usage usage : annotationUsages) {\n                  for (UsageRepr.AnnotationUsage query : annotationQuery) {\n                    if (query.satisfies(usage)) {\n                      affectedFiles.add(theFile);\n                      continue filewise;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  }","commit_id":"0a28e4f628e31a36a0aef38a6f212df19067a93e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void test_queryOk() throws Exception {\n    ScriptBuilder scb = new ScriptBuilder();\n    final IMonitors mons = Mockups.monitors(context, \"mons\");\n    final IConfigMonitor cmon = context.mock(IConfigMonitor.class);\n    context.checking(new Expectations() {\n      {\n        final Object[] cfg = new Object[1];\n        exactly(1).of(mons).runConfigWithMonitor((_FunctionTypes._void_P1_E0<? super IConfigMonitor>) with(new BaseMatcher<Object>() {\n          public boolean matches(Object o) {\n            cfg[0] = o;\n            return true;\n          }\n\n          public void describeTo(Description p0) {\n          }\n        }));\n        will(new Action() {\n          public Object invoke(Invocation invocation) throws Throwable {\n            ((_FunctionTypes._void_P1_E0<? super IConfigMonitor>) cfg[0]).invoke(cmon);\n            return null;\n          }\n\n          public void describeTo(Description description) {\n          }\n        });\n\n        final IQuery[] query = new IQuery[1];\n        exactly(1).of(cmon).relayQuery(with(new BaseMatcher<IQuery>() {\n          public boolean matches(Object o) {\n            if (o instanceof IQuery) {\n              query[0] = (IQuery) o;\n              return true;\n            }\n            return false;\n          }\n\n          public void describeTo(Description p0) {\n          }\n        }));\n        will(new Action() {\n          public Object invoke(Invocation invocation) throws Throwable {\n            return Sequence.fromIterable(query[0].options()).first();\n          }\n\n          public void describeTo(Description description) {\n          }\n        });\n      }\n    });\n    Mockups.allowing(context, mons);\n    IScript scr = scb.withFacet(new IFacet.Name(\"Maker\")).withFacet(new IFacet.Name(\"Generator\")).withFacet(new IFacet.Name(\"TextGen\")).withTarget(new ITarget.Name(\"Make\")).withMonitors(mons).toScript();\n    Assert.assertTrue(scr.isValid());\n    ITarget dt = scr.defaultTarget();\n    Assert.assertNotNull(dt);\n    Assert.assertEquals(new ITarget.Name(\"Make\"), dt.getName());\n    IResult res = scr.execute();\n    Assert.assertNotNull(res);\n    Assert.assertTrue(res.isSucessful());\n    Assert.assertTrue(Sequence.fromIterable(res.output()).isEmpty());\n  }","id":97728,"modified_method":"@Test\n  public void test_queryOk() throws Exception {\n    ScriptBuilder scb = new ScriptBuilder();\n    final IMonitors mons = Mockups.monitors(context, \"mons\");\n    final IConfigMonitor cmon = context.mock(IConfigMonitor.class);\n    context.checking(new Expectations() {\n      {\n        final Object[] cfg = new Object[1];\n        exactly(1).of(mons).runConfigWithMonitor((_FunctionTypes._void_P1_E0<? super IConfigMonitor>) with(new BaseMatcher<Object>() {\n          public boolean matches(Object o) {\n            cfg[0] = o;\n            return true;\n          }\n\n          public void describeTo(Description p0) {\n          }\n        }));\n        will(new Action() {\n          public Object invoke(Invocation invocation) throws Throwable {\n            ((_FunctionTypes._void_P1_E0<? super IConfigMonitor>) cfg[0]).invoke(cmon);\n            return null;\n          }\n\n          public void describeTo(Description description) {\n          }\n        });\n\n        final IQuery[] query = new IQuery[1];\n        exactly(1).of(cmon).relayQuery(with(new BaseMatcher<IQuery>() {\n          public boolean matches(Object o) {\n            if (o instanceof IQuery) {\n              query[0] = (IQuery) o;\n              return true;\n            }\n            return false;\n          }\n\n          public void describeTo(Description p0) {\n          }\n        }));\n        will(new Action() {\n          public Object invoke(Invocation invocation) throws Throwable {\n            return Sequence.fromIterable(query[0].options()).first();\n          }\n\n          public void describeTo(Description description) {\n          }\n        });\n      }\n    });\n    Mockups.allowing(context, mons);\n    IScript scr = scb.withFacet(new IFacet.Name(\"Maker\")).withFacet(new IFacet.Name(\"Generator\")).withFacet(new IFacet.Name(\"TextGen\")).withTarget(new ITarget.Name(\"Make\")).toScript();\n    scr = new IScript.StubBoss(scr) {\n      @Override\n      public IMonitors monitors() {\n        return monitors();\n      }\n    };\n    Assert.assertTrue(scr.isValid());\n    ITarget dt = scr.defaultTarget();\n    Assert.assertNotNull(dt);\n    Assert.assertEquals(new ITarget.Name(\"Make\"), dt.getName());\n    IResult res = scr.execute();\n    Assert.assertNotNull(res);\n    Assert.assertTrue(res.isSucessful());\n    Assert.assertTrue(Sequence.fromIterable(res.output()).isEmpty());\n  }","commit_id":"476fd6fef4961e8a5b602941675bb5db2e8e6251","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void test_progress() throws Exception {\n    ScriptBuilder scb = new ScriptBuilder();\n    final IProgress pstub = context.mock(IProgress.class);\n    context.checking(new Expectations() {\n      {\n        exactly(1).of(pstub).beginWork(with(equal(\"Script\")), with(same(20)), with(any(Integer.class)));\n        exactly(1).of(pstub).beginWork(with(equal(new ITarget.Name(\"work\").toString())), with(equal(1000)), with(equal(10)));\n        exactly(1).of(pstub).beginWork(with(equal(new ITarget.Name(\"Make\").toString())), with(equal(1000)), with(equal(10)));\n\n\n        org.jmock.Sequence seq = context.sequence(\"sequence\");\n        exactly(1).of(pstub).beginWork(with(equal(\"WORK\")), with(same(100)), with(any(Integer.class)));\n        inSequence(seq);\n        atMost(1).of(pstub).advanceWork(with(equal(\"WORK\")), with(same(50)));\n        inSequence(seq);\n        exactly(1).of(pstub).beginWork(with(equal(\"WORKWORK\")), with(same(10)), with(any(Integer.class)));\n        inSequence(seq);\n        atMost(1).of(pstub).advanceWork(with(equal(\"WORKWORK\")), with(same(5)));\n        inSequence(seq);\n        atMost(1).of(pstub).advanceWork(with(equal(\"WORKWORK\")), with(same(5)));\n        inSequence(seq);\n        exactly(1).of(pstub).finishWork(with(equal(\"WORKWORK\")));\n        inSequence(seq);\n        exactly(1).of(pstub).finishWork(with(equal(\"WORK\")));\n        inSequence(seq);\n\n        atMost(2).of(pstub).advanceWork(with(equal(\"Script\")), with(same(1)));\n        exactly(1).of(pstub).finishWork(with(equal(new ITarget.Name(\"Make\").toString())));\n        exactly(1).of(pstub).finishWork(with(equal(new ITarget.Name(\"work\").toString())));\n        exactly(1).of(pstub).finishWork(with(equal(\"Script\")));\n\n        allowing(pstub).workLeft();\n        will(returnValue(Integer.MAX_VALUE));\n      }\n    });\n\n    IScript scr = scb.withFacet(new IFacet.Name(\"Maker\")).withFacet(new IFacet.Name(\"Worker\")).withTarget(new ITarget.Name(\"Make\")).withMonitors(new IMonitors.Stub(new IConfigMonitor.Stub(), new IJobMonitor.Stub(pstub))).toScript();\n    Assert.assertTrue(scr.isValid());\n    ITarget dt = scr.defaultTarget();\n    Assert.assertNotNull(dt);\n    Assert.assertEquals(new ITarget.Name(\"Make\"), dt.getName());\n    IResult res = scr.execute();\n    Assert.assertNotNull(res);\n    Assert.assertTrue(res.isSucessful());\n    Assert.assertTrue(Sequence.fromIterable(res.output()).isEmpty());\n  }","id":97729,"modified_method":"@Test\n  public void test_progress() throws Exception {\n    ScriptBuilder scb = new ScriptBuilder();\n    final IProgress pstub = context.mock(IProgress.class);\n    context.checking(new Expectations() {\n      {\n        exactly(1).of(pstub).beginWork(with(equal(\"Script\")), with(same(20)), with(any(Integer.class)));\n        exactly(1).of(pstub).beginWork(with(equal(new ITarget.Name(\"work\").toString())), with(equal(1000)), with(equal(10)));\n        exactly(1).of(pstub).beginWork(with(equal(new ITarget.Name(\"Make\").toString())), with(equal(1000)), with(equal(10)));\n\n\n        org.jmock.Sequence seq = context.sequence(\"sequence\");\n        exactly(1).of(pstub).beginWork(with(equal(\"WORK\")), with(same(100)), with(any(Integer.class)));\n        inSequence(seq);\n        atMost(1).of(pstub).advanceWork(with(equal(\"WORK\")), with(same(50)));\n        inSequence(seq);\n        exactly(1).of(pstub).beginWork(with(equal(\"WORKWORK\")), with(same(10)), with(any(Integer.class)));\n        inSequence(seq);\n        atMost(1).of(pstub).advanceWork(with(equal(\"WORKWORK\")), with(same(5)));\n        inSequence(seq);\n        atMost(1).of(pstub).advanceWork(with(equal(\"WORKWORK\")), with(same(5)));\n        inSequence(seq);\n        exactly(1).of(pstub).finishWork(with(equal(\"WORKWORK\")));\n        inSequence(seq);\n        exactly(1).of(pstub).finishWork(with(equal(\"WORK\")));\n        inSequence(seq);\n\n        atMost(2).of(pstub).advanceWork(with(equal(\"Script\")), with(same(1)));\n        exactly(1).of(pstub).finishWork(with(equal(new ITarget.Name(\"Make\").toString())));\n        exactly(1).of(pstub).finishWork(with(equal(new ITarget.Name(\"work\").toString())));\n        exactly(1).of(pstub).finishWork(with(equal(\"Script\")));\n\n        allowing(pstub).workLeft();\n        will(returnValue(Integer.MAX_VALUE));\n      }\n    });\n\n    final IMonitors mons = new IMonitors.Stub(new IConfigMonitor.Stub(), new IJobMonitor.Stub(pstub));\n    IScript scr = scb.withFacet(new IFacet.Name(\"Maker\")).withFacet(new IFacet.Name(\"Worker\")).withTarget(new ITarget.Name(\"Make\")).toScript();\n    scr = new IScript.StubBoss(scr) {\n      @Override\n      public IMonitors monitors() {\n        return mons;\n      }\n    };\n\n    Assert.assertTrue(scr.isValid());\n    ITarget dt = scr.defaultTarget();\n    Assert.assertNotNull(dt);\n    Assert.assertEquals(new ITarget.Name(\"Make\"), dt.getName());\n    IResult res = scr.execute();\n    Assert.assertNotNull(res);\n    Assert.assertTrue(res.isSucessful());\n    Assert.assertTrue(Sequence.fromIterable(res.output()).isEmpty());\n  }","commit_id":"476fd6fef4961e8a5b602941675bb5db2e8e6251","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void test_queryStop() throws Exception {\n    ScriptBuilder scb = new ScriptBuilder();\n    final IMonitors mons = Mockups.monitors(context, \"mons\");\n    final IConfigMonitor cmon = context.mock(IConfigMonitor.class);\n    context.checking(new Expectations() {\n      {\n        final Object[] cfg = new Object[1];\n        exactly(1).of(mons).runConfigWithMonitor((_FunctionTypes._void_P1_E0<? super IConfigMonitor>) with(new BaseMatcher<Object>() {\n          public boolean matches(Object o) {\n            cfg[0] = o;\n            return true;\n          }\n\n          public void describeTo(Description p0) {\n          }\n        }));\n        will(new Action() {\n          public Object invoke(Invocation invocation) throws Throwable {\n            ((_FunctionTypes._void_P1_E0<? super IConfigMonitor>) cfg[0]).invoke(cmon);\n            return null;\n          }\n\n          public void describeTo(Description description) {\n          }\n        });\n\n        final IQuery[] query = new IQuery[1];\n        exactly(1).of(cmon).relayQuery(with(new BaseMatcher<IQuery>() {\n          public boolean matches(Object o) {\n            if (o instanceof IQuery) {\n              query[0] = (IQuery) o;\n              return true;\n            }\n            return false;\n          }\n\n          public void describeTo(Description p0) {\n          }\n        }));\n        will(new Action() {\n          public Object invoke(Invocation invocation) throws Throwable {\n            return Sequence.fromIterable(query[0].options()).last();\n          }\n\n          public void describeTo(Description description) {\n          }\n        });\n      }\n    });\n    Mockups.allowing(context, mons);\n\n    IScript scr = scb.withFacet(new IFacet.Name(\"Maker\")).withFacet(new IFacet.Name(\"Generator\")).withFacet(new IFacet.Name(\"TextGen\")).withTarget(new ITarget.Name(\"Make\")).withMonitors(mons).toScript();\n    Assert.assertTrue(scr.isValid());\n    ITarget dt = scr.defaultTarget();\n    Assert.assertNotNull(dt);\n    Assert.assertEquals(new ITarget.Name(\"Make\"), dt.getName());\n    IResult res = scr.execute();\n    Assert.assertNotNull(res);\n    Assert.assertFalse(res.isSucessful());\n    Assert.assertTrue(Sequence.fromIterable(res.output()).isEmpty());\n  }","id":97730,"modified_method":"@Test\n  public void test_queryStop() throws Exception {\n    ScriptBuilder scb = new ScriptBuilder();\n    final IMonitors mons = Mockups.monitors(context, \"mons\");\n    final IConfigMonitor cmon = context.mock(IConfigMonitor.class);\n    context.checking(new Expectations() {\n      {\n        final Object[] cfg = new Object[1];\n        exactly(1).of(mons).runConfigWithMonitor((_FunctionTypes._void_P1_E0<? super IConfigMonitor>) with(new BaseMatcher<Object>() {\n          public boolean matches(Object o) {\n            cfg[0] = o;\n            return true;\n          }\n\n          public void describeTo(Description p0) {\n          }\n        }));\n        will(new Action() {\n          public Object invoke(Invocation invocation) throws Throwable {\n            ((_FunctionTypes._void_P1_E0<? super IConfigMonitor>) cfg[0]).invoke(cmon);\n            return null;\n          }\n\n          public void describeTo(Description description) {\n          }\n        });\n\n        final IQuery[] query = new IQuery[1];\n        exactly(1).of(cmon).relayQuery(with(new BaseMatcher<IQuery>() {\n          public boolean matches(Object o) {\n            if (o instanceof IQuery) {\n              query[0] = (IQuery) o;\n              return true;\n            }\n            return false;\n          }\n\n          public void describeTo(Description p0) {\n          }\n        }));\n        will(new Action() {\n          public Object invoke(Invocation invocation) throws Throwable {\n            return Sequence.fromIterable(query[0].options()).last();\n          }\n\n          public void describeTo(Description description) {\n          }\n        });\n      }\n    });\n    Mockups.allowing(context, mons);\n\n    IScript scr = scb.withFacet(new IFacet.Name(\"Maker\")).withFacet(new IFacet.Name(\"Generator\")).withFacet(new IFacet.Name(\"TextGen\")).withTarget(new ITarget.Name(\"Make\")).toScript();\n    scr = new IScript.StubBoss(scr) {\n      @Override\n      public IMonitors monitors() {\n        return mons;\n      }\n    };\n\n    Assert.assertTrue(scr.isValid());\n    ITarget dt = scr.defaultTarget();\n    Assert.assertNotNull(dt);\n    Assert.assertEquals(new ITarget.Name(\"Make\"), dt.getName());\n    IResult res = scr.execute();\n    Assert.assertNotNull(res);\n    Assert.assertFalse(res.isSucessful());\n    Assert.assertTrue(Sequence.fromIterable(res.output()).isEmpty());\n  }","commit_id":"476fd6fef4961e8a5b602941675bb5db2e8e6251","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void test_logProgress() throws Exception {\n    final LoggingProgressStrategy.Log logger = context.mock(LoggingProgressStrategy.Log.class);\n    context.checking(new Expectations() {\n      {\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK -- started\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK -- done 50%\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK/WORKWORK -- started\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK -- done 62%\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK/WORKWORK -- done 50%\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK -- done 74%\")));\n        exactly(2).of(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK/WORKWORK -- done 100%\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK/WORKWORK -- finished\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK -- done 100%\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK -- finished\")));\n\n        allowing(logger).info(with(new BaseMatcher<String>() {\n          public boolean matches(Object s) {\n            return !(((String) s).matches(\".*WORK -- .*\"));\n          }\n\n          public void describeTo(Description p0) {\n          }\n        }));\n      }\n    });\n    final LoggingProgressStrategy strat = new LoggingProgressStrategy(logger);\n    ScriptBuilder scb = new ScriptBuilder();\n    IJobMonitor.Stub jmon = new IJobMonitor.Stub(null) {\n      @Override\n      public IProgress currentProgress() {\n        return strat.currentProgress();\n      }\n    };\n\n    IScript scr = scb.withFacet(new IFacet.Name(\"Maker\")).withFacet(new IFacet.Name(\"Worker\")).withTarget(new ITarget.Name(\"Make\")).withMonitors(new IMonitors.Stub(new IConfigMonitor.Stub(), jmon)).toScript();\n    Assert.assertTrue(scr.isValid());\n    ITarget dt = scr.defaultTarget();\n    Assert.assertNotNull(dt);\n    Assert.assertEquals(new ITarget.Name(\"Make\"), dt.getName());\n    IResult res = scr.execute();\n    Assert.assertNotNull(res);\n    Assert.assertTrue(res.isSucessful());\n    Assert.assertTrue(Sequence.fromIterable(res.output()).isEmpty());\n  }","id":97731,"modified_method":"@Test\n  public void test_logProgress() throws Exception {\n    final LoggingProgressStrategy.Log logger = context.mock(LoggingProgressStrategy.Log.class);\n    context.checking(new Expectations() {\n      {\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK -- started\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK -- done 50%\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK/WORKWORK -- started\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK -- done 62%\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK/WORKWORK -- done 50%\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK -- done 74%\")));\n        exactly(2).of(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK/WORKWORK -- done 100%\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK/WORKWORK -- finished\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK -- done 100%\")));\n        oneOf(logger).info(with(equal(\"\\u221e/Script/\" + new ITarget.Name(\"work\") + \"/WORK -- finished\")));\n\n        allowing(logger).info(with(new BaseMatcher<String>() {\n          public boolean matches(Object s) {\n            return !(((String) s).matches(\".*WORK -- .*\"));\n          }\n\n          public void describeTo(Description p0) {\n          }\n        }));\n      }\n    });\n    final LoggingProgressStrategy strat = new LoggingProgressStrategy(logger);\n    ScriptBuilder scb = new ScriptBuilder();\n    IJobMonitor.Stub jmon = new IJobMonitor.Stub(null) {\n      @Override\n      public IProgress currentProgress() {\n        return strat.currentProgress();\n      }\n    };\n\n    final IMonitors mons = new IMonitors.Stub(new IConfigMonitor.Stub(), jmon);\n    IScript scr = scb.withFacet(new IFacet.Name(\"Maker\")).withFacet(new IFacet.Name(\"Worker\")).withTarget(new ITarget.Name(\"Make\")).toScript();\n    scr = new IScript.StubBoss(scr) {\n      @Override\n      public IMonitors monitors() {\n        return mons;\n      }\n    };\n    Assert.assertTrue(scr.isValid());\n    ITarget dt = scr.defaultTarget();\n    Assert.assertNotNull(dt);\n    Assert.assertEquals(new ITarget.Name(\"Make\"), dt.getName());\n    IResult res = scr.execute();\n    Assert.assertNotNull(res);\n    Assert.assertTrue(res.isSucessful());\n    Assert.assertTrue(Sequence.fromIterable(res.output()).isEmpty());\n  }","commit_id":"476fd6fef4961e8a5b602941675bb5db2e8e6251","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void test_buildScript() throws Exception {\n    ScriptBuilder scb = new ScriptBuilder();\n    final IProgress pstub = context.mock(IProgress.class);\n    context.checking(new Expectations() {\n      {\n        exactly(1).of(pstub).beginWork(with(equal(\"Script\")), with(equal(1020)), with(any(Integer.class)));\n        exactly(1).of(pstub).beginWork(with(equal(new ITarget.Name(\"Configure\").toString())), with(equal(1000)), with(equal(10)));\n        exactly(1).of(pstub).beginWork(with(equal(new ITarget.Name(\"Generate\").toString())), with(equal(1000)), with(equal(1000)));\n        exactly(1).of(pstub).beginWork(with(equal(new ITarget.Name(\"Make\").toString())), with(equal(1000)), with(equal(10)));\n\n        exactly(1).of(pstub).beginWork(with(equal(\"GENERATE\")), with(same(100)), with(any(Integer.class)));\n        atMost(1).of(pstub).advanceWork(with(equal(\"GENERATE\")), with(same(50)));\n        exactly(1).of(pstub).finishWork(with(equal(\"GENERATE\")));\n\n        atMost(3).of(pstub).advanceWork(with(equal(\"Script\")), with(same(1)));\n        exactly(1).of(pstub).finishWork(with(equal(new ITarget.Name(\"Make\").toString())));\n        exactly(1).of(pstub).finishWork(with(equal(new ITarget.Name(\"Generate\").toString())));\n        exactly(1).of(pstub).finishWork(with(equal(new ITarget.Name(\"Configure\").toString())));\n        exactly(1).of(pstub).finishWork(with(equal(\"Script\")));\n        allowing(pstub).workLeft();\n        will(returnValue(Integer.MAX_VALUE));\n      }\n    });\n\n    IScript scr = scb.withFacet(new IFacet.Name(\"Maker\")).withFacet(new IFacet.Name(\"Generator\")).withTarget(new ITarget.Name(\"Make\")).withMonitors(new IMonitors.Stub(new IConfigMonitor.Stub(), new IJobMonitor.Stub(pstub))).toScript();\n    Assert.assertTrue(scr.isValid());\n    ITarget dt = scr.defaultTarget();\n    Assert.assertNotNull(dt);\n    Assert.assertEquals(new ITarget.Name(\"Make\"), dt.getName());\n    IResult res = scr.execute();\n    Assert.assertNotNull(res);\n    Assert.assertTrue(res.isSucessful());\n    Assert.assertTrue(Sequence.fromIterable(res.output()).isEmpty());\n  }","id":97732,"modified_method":"@Test\n  public void test_buildScript() throws Exception {\n    ScriptBuilder scb = new ScriptBuilder();\n    final IProgress pstub = context.mock(IProgress.class);\n    context.checking(new Expectations() {\n      {\n        exactly(1).of(pstub).beginWork(with(equal(\"Script\")), with(equal(1020)), with(any(Integer.class)));\n        exactly(1).of(pstub).beginWork(with(equal(new ITarget.Name(\"Configure\").toString())), with(equal(1000)), with(equal(10)));\n        exactly(1).of(pstub).beginWork(with(equal(new ITarget.Name(\"Generate\").toString())), with(equal(1000)), with(equal(1000)));\n        exactly(1).of(pstub).beginWork(with(equal(new ITarget.Name(\"Make\").toString())), with(equal(1000)), with(equal(10)));\n\n        exactly(1).of(pstub).beginWork(with(equal(\"GENERATE\")), with(same(100)), with(any(Integer.class)));\n        atMost(1).of(pstub).advanceWork(with(equal(\"GENERATE\")), with(same(50)));\n        exactly(1).of(pstub).finishWork(with(equal(\"GENERATE\")));\n\n        atMost(3).of(pstub).advanceWork(with(equal(\"Script\")), with(same(1)));\n        exactly(1).of(pstub).finishWork(with(equal(new ITarget.Name(\"Make\").toString())));\n        exactly(1).of(pstub).finishWork(with(equal(new ITarget.Name(\"Generate\").toString())));\n        exactly(1).of(pstub).finishWork(with(equal(new ITarget.Name(\"Configure\").toString())));\n        exactly(1).of(pstub).finishWork(with(equal(\"Script\")));\n        allowing(pstub).workLeft();\n        will(returnValue(Integer.MAX_VALUE));\n      }\n    });\n\n    final IMonitors mons = new IMonitors.Stub(new IConfigMonitor.Stub(), new IJobMonitor.Stub(pstub));\n    IScript scr = scb.withFacet(new IFacet.Name(\"Maker\")).withFacet(new IFacet.Name(\"Generator\")).withTarget(new ITarget.Name(\"Make\")).toScript();\n    scr = new IScript.StubBoss(scr) {\n      @Override\n      public IMonitors monitors() {\n        return mons;\n      }\n    };\n    Assert.assertTrue(scr.isValid());\n    ITarget dt = scr.defaultTarget();\n    Assert.assertNotNull(dt);\n    Assert.assertEquals(new ITarget.Name(\"Make\"), dt.getName());\n    IResult res = scr.execute();\n    Assert.assertNotNull(res);\n    Assert.assertTrue(res.isSucessful());\n    Assert.assertTrue(Sequence.fromIterable(res.output()).isEmpty());\n  }","commit_id":"476fd6fef4961e8a5b602941675bb5db2e8e6251","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setMonitors(IMonitors mons) {\n    throw new IllegalStateException(\"Invalid script\");\n  }","id":97733,"modified_method":"public IMonitors monitors() {\n    throw new IllegalStateException(\"Invalid script\");\n  }","commit_id":"476fd6fef4961e8a5b602941675bb5db2e8e6251","url":"https://github.com/JetBrains/MPS"},{"original_method":"private IScript completeScript(IScript scr) {\n    final ProgressIndicatorProgressStrategy progStrat = new ProgressIndicatorProgressStrategy();\n    final IJobMonitor jmon = new IJobMonitor() {\n      public boolean stopRequested() {\n        return (progStrat.getProgressIndicator() != null ?\n          progStrat.getProgressIndicator().isCanceled() :\n          false\n        );\n      }\n\n      public IProgress currentProgress() {\n        return progStrat.currentProgress();\n      }\n\n      public void reportFeedback(IFeedback fdbk) {\n        new LoggingFeedbackStrategy().reportFeedback(fdbk);\n      }\n    };\n    final IConfigMonitor cmon = new IConfigMonitor() {\n      public <T extends IOption> T relayQuery(IQuery<T> query) {\n        return new UIQueryRelayStrategy().relayQuery(query, MakeActionImpl.this.context);\n      }\n    };\n\n    final Wrappers._T<ProgressIndicator> pind = new Wrappers._T<ProgressIndicator>(null);\n    IMonitors.Stub mons = new IMonitors.Stub(cmon, jmon) {\n      @Override\n      public void runJobWithMonitor(final _FunctionTypes._void_P1_E0<? super IJobMonitor> code) {\n        IdeEventQueue.getInstance().flushQueue();\n        ModelAccess.instance().runWriteActionWithProgressSynchronously(new Progressive() {\n          public void run(ProgressIndicator realInd) {\n            progStrat.setProgressIndicator(realInd);\n            pind.value = new JobMonitorProgressIndicator(jmon);\n            code.invoke(jmon);\n          }\n        }, (cleanMake ?\n          \"Rebuild\" :\n          \"Make\"\n        ), true, MakeActionImpl.this.context.getProject());\n      }\n    };\n\n    final _FunctionTypes._return_P0_E0<? extends ProgressIndicator> pindGet = new _FunctionTypes._return_P0_E0<ProgressIndicator>() {\n      public ProgressIndicator invoke() {\n        return pind.value;\n      }\n    };\n    _FunctionTypes._void_P1_E0<? super IParametersPool> init = new _FunctionTypes._void_P1_E0<IParametersPool>() {\n      public void invoke(IParametersPool pool) {\n        Tuples._4<Project, IOperationContext, Boolean, _FunctionTypes._return_P0_E0<? extends ProgressIndicator>> vars = (Tuples._4<Project, IOperationContext, Boolean, _FunctionTypes._return_P0_E0<? extends ProgressIndicator>>) pool.parameters(new ITarget.Name(\"checkParameters\"), Object.class);\n        vars._0(MakeActionImpl.this.context.getProject());\n        vars._1(MakeActionImpl.this.context);\n        vars._2(MakeActionImpl.this.cleanMake);\n        vars._3(pindGet);\n      }\n    };\n\n    scr.setInit(init);\n    scr.setMonitors(mons);\n    return scr;\n  }","id":97734,"modified_method":"private IScript completeScript(IScript scr) {\n    final ProgressIndicatorProgressStrategy progStrat = new ProgressIndicatorProgressStrategy();\n    final IJobMonitor jmon = new IJobMonitor() {\n      public boolean stopRequested() {\n        return (progStrat.getProgressIndicator() != null ?\n          progStrat.getProgressIndicator().isCanceled() :\n          false\n        );\n      }\n\n      public IProgress currentProgress() {\n        return progStrat.currentProgress();\n      }\n\n      public void reportFeedback(IFeedback fdbk) {\n        new LoggingFeedbackStrategy().reportFeedback(fdbk);\n      }\n    };\n    final IConfigMonitor cmon = new IConfigMonitor() {\n      public <T extends IOption> T relayQuery(IQuery<T> query) {\n        return new UIQueryRelayStrategy().relayQuery(query, MakeActionImpl.this.context);\n      }\n    };\n\n    final Wrappers._T<ProgressIndicator> pind = new Wrappers._T<ProgressIndicator>(null);\n    final IMonitors mons = new IMonitors.Stub(cmon, jmon) {\n      @Override\n      public void runJobWithMonitor(final _FunctionTypes._void_P1_E0<? super IJobMonitor> code) {\n        IdeEventQueue.getInstance().flushQueue();\n        ModelAccess.instance().runWriteActionWithProgressSynchronously(new Progressive() {\n          public void run(ProgressIndicator realInd) {\n            progStrat.setProgressIndicator(realInd);\n            pind.value = new JobMonitorProgressIndicator(jmon);\n            code.invoke(jmon);\n          }\n        }, (cleanMake ?\n          \"Rebuild\" :\n          \"Make\"\n        ), true, MakeActionImpl.this.context.getProject());\n      }\n    };\n\n    final _FunctionTypes._return_P0_E0<? extends ProgressIndicator> pindGet = new _FunctionTypes._return_P0_E0<ProgressIndicator>() {\n      public ProgressIndicator invoke() {\n        return pind.value;\n      }\n    };\n    final _FunctionTypes._void_P1_E0<? super IParametersPool> init = new _FunctionTypes._void_P1_E0<IParametersPool>() {\n      public void invoke(IParametersPool pool) {\n        Tuples._4<Project, IOperationContext, Boolean, _FunctionTypes._return_P0_E0<? extends ProgressIndicator>> vars = (Tuples._4<Project, IOperationContext, Boolean, _FunctionTypes._return_P0_E0<? extends ProgressIndicator>>) pool.parameters(new ITarget.Name(\"checkParameters\"), Object.class);\n        vars._0(MakeActionImpl.this.context.getProject());\n        vars._1(MakeActionImpl.this.context);\n        vars._2(MakeActionImpl.this.cleanMake);\n        vars._3(pindGet);\n      }\n    };\n    return new IScript.StubBoss(scr) {\n      @Override\n      public void init(IParametersPool ppool) {\n        init.invoke(ppool);\n      }\n\n      @Override\n      public IMonitors monitors() {\n        return mons;\n      }\n    };\n  }","commit_id":"476fd6fef4961e8a5b602941675bb5db2e8e6251","url":"https://github.com/JetBrains/MPS"},{"original_method":"public IResult execute(final Iterable<? extends IResource> scriptInput) {\n    validate();\n    if (!(isValid())) {\n      LOG.error(\"attempt to execute invalid script\");\n      throw new IllegalStateException(\"invalid script\");\n    }\n    LOG.debug(\"Beginning to execute script\");\n    final CompositeResult results = new CompositeResult();\n    final Script.ParametersPool pool = new Script.ParametersPool();\n    LOG.debug(\"Initializing\");\n    if (init != null) {\n      init.invoke(pool);\n    }\n    IMonitors mons = monitors;\n    if (mons == null) {\n      mons = new Script.Monitors();\n    }\n    final Iterable<ITarget> toExecute = targetRange.targetAndSortedPrecursors(defaultTargetName);\n    mons.runConfigWithMonitor(new _FunctionTypes._void_P1_E0<IConfigMonitor>() {\n      public void invoke(IConfigMonitor cmon) {\n        for (ITarget trg : Sequence.fromIterable(toExecute)) {\n          LOG.debug(\"Configuring \" + trg.getName());\n          IConfig cfg = trg.createConfig();\n          if (cfg != null && !(cfg.configure(cmon, pool))) {\n            LOG.debug(\"Configuration failed\");\n            results.addResult(trg.getName(), new IResult.FAILURE(null));\n            return;\n          }\n        }\n      }\n    });\n    if (!(results.isSucessful())) {\n      return results;\n    }\n    mons.runJobWithMonitor(new _FunctionTypes._void_P1_E0<IJobMonitor>() {\n      public void invoke(final IJobMonitor monit) {\n        String scriptName = \"Script\";\n        int work = Sequence.fromIterable(toExecute).foldLeft(0, new ILeftCombinator<ITarget, Integer>() {\n          public Integer combine(Integer s, ITarget it) {\n            return s + ((it.requiresInput() || it.producesOutput() ?\n              1000 :\n              10\n            ));\n          }\n        });\n        monit.currentProgress().beginWork(scriptName, work, monit.currentProgress().workLeft());\n        for (ITarget trg : Sequence.fromIterable(toExecute)) {\n          LOG.debug(\"Executing \" + trg.getName());\n          Iterable<ITarget> impre = targetRange.immediatePrecursors(trg.getName());\n          Iterable<IResource> input = (Iterable<IResource>) ((Sequence.fromIterable(impre).isEmpty() ?\n            scriptInput :\n            Sequence.fromIterable(impre).<IResult>select(new ISelector<ITarget, IResult>() {\n              public IResult select(ITarget t) {\n                return results.getResult(t.getName());\n              }\n            }).<IResource>translate(new ITranslator2<IResult, IResource>() {\n              public Iterable<IResource> translate(IResult r) {\n                return r.output();\n              }\n            }).distinct().toListSequence()\n          ));\n          LOG.debug(\"Input: \" + input);\n          if (trg.requiresInput()) {\n            if (Sequence.fromIterable(input).isEmpty()) {\n              LOG.debug(\"No input. Stopping\");\n              results.addResult(trg.getName(), new IResult.FAILURE(null));\n              return;\n            }\n            // TODO: check for appropriate input class \n          }\n          monit.currentProgress().beginWork(trg.getName().toString(), 1000, (trg.requiresInput() || trg.producesOutput() ?\n            1000 :\n            10\n          ));\n          IJob job = trg.createJob();\n\n          // TODO: catch possible errors \n          IResult jr = job.execute(Sequence.fromIterable(input).where(new IWhereFilter<IResource>() {\n            public boolean accept(IResource it) {\n              return !(monit.stopRequested());\n            }\n          }), monit, pool);\n\n          if (!(trg.producesOutput())) {\n            // ignore the output \n            jr = new Script.SubsOutputResult(jr, (trg.requiresInput() ?\n              null :\n              input\n            ));\n          }\n          results.addResult(trg.getName(), jr);\n          if (!(jr.isSucessful()) || monit.stopRequested()) {\n            LOG.debug((jr.isSucessful() ?\n              \"Stop requested\" :\n              \"Execution failed\"\n            ));\n            return;\n          }\n          monit.currentProgress().finishWork(trg.getName().toString());\n        }\n        monit.currentProgress().finishWork(scriptName);\n      }\n    });\n    LOG.debug(\"Finished executing script\");\n    return results;\n  }","id":97735,"modified_method":"public IResult execute(final Iterable<? extends IResource> scriptInput) {\n    validate();\n    if (!(isValid())) {\n      LOG.error(\"attempt to execute invalid script\");\n      throw new IllegalStateException(\"invalid script\");\n    }\n    LOG.debug(\"Beginning to execute script\");\n    final CompositeResult results = new CompositeResult();\n    final Script.ParametersPool pool = new Script.ParametersPool();\n    LOG.debug(\"Initializing\");\n    init(pool);\n\n    IMonitors mons = monitors();\n    final Iterable<ITarget> toExecute = targetRange.targetAndSortedPrecursors(defaultTargetName);\n    mons.runConfigWithMonitor(new _FunctionTypes._void_P1_E0<IConfigMonitor>() {\n      public void invoke(IConfigMonitor cmon) {\n        for (ITarget trg : Sequence.fromIterable(toExecute)) {\n          LOG.debug(\"Configuring \" + trg.getName());\n          IConfig cfg = trg.createConfig();\n          if (cfg != null && !(cfg.configure(cmon, pool))) {\n            LOG.debug(\"Configuration failed\");\n            results.addResult(trg.getName(), new IResult.FAILURE(null));\n            return;\n          }\n        }\n      }\n    });\n    if (!(results.isSucessful())) {\n      return results;\n    }\n    mons.runJobWithMonitor(new _FunctionTypes._void_P1_E0<IJobMonitor>() {\n      public void invoke(final IJobMonitor monit) {\n        String scriptName = \"Script\";\n        int work = Sequence.fromIterable(toExecute).foldLeft(0, new ILeftCombinator<ITarget, Integer>() {\n          public Integer combine(Integer s, ITarget it) {\n            return s + ((it.requiresInput() || it.producesOutput() ?\n              1000 :\n              10\n            ));\n          }\n        });\n        monit.currentProgress().beginWork(scriptName, work, monit.currentProgress().workLeft());\n        for (ITarget trg : Sequence.fromIterable(toExecute)) {\n          LOG.debug(\"Executing \" + trg.getName());\n          Iterable<ITarget> impre = targetRange.immediatePrecursors(trg.getName());\n          Iterable<IResource> input = (Iterable<IResource>) ((Sequence.fromIterable(impre).isEmpty() ?\n            scriptInput :\n            Sequence.fromIterable(impre).<IResult>select(new ISelector<ITarget, IResult>() {\n              public IResult select(ITarget t) {\n                return results.getResult(t.getName());\n              }\n            }).<IResource>translate(new ITranslator2<IResult, IResource>() {\n              public Iterable<IResource> translate(IResult r) {\n                return r.output();\n              }\n            }).distinct().toListSequence()\n          ));\n          LOG.debug(\"Input: \" + input);\n          if (trg.requiresInput()) {\n            if (Sequence.fromIterable(input).isEmpty()) {\n              LOG.debug(\"No input. Stopping\");\n              results.addResult(trg.getName(), new IResult.FAILURE(null));\n              return;\n            }\n            // TODO: check for appropriate input class \n          }\n          monit.currentProgress().beginWork(trg.getName().toString(), 1000, (trg.requiresInput() || trg.producesOutput() ?\n            1000 :\n            10\n          ));\n          IJob job = trg.createJob();\n\n          // TODO: catch possible errors \n          IResult jr = job.execute(Sequence.fromIterable(input).where(new IWhereFilter<IResource>() {\n            public boolean accept(IResource it) {\n              return !(monit.stopRequested());\n            }\n          }), monit, pool);\n\n          if (!(trg.producesOutput())) {\n            // ignore the output \n            jr = new Script.SubsOutputResult(jr, (trg.requiresInput() ?\n              null :\n              input\n            ));\n          }\n          results.addResult(trg.getName(), jr);\n          if (!(jr.isSucessful()) || monit.stopRequested()) {\n            LOG.debug((jr.isSucessful() ?\n              \"Stop requested\" :\n              \"Execution failed\"\n            ));\n            return;\n          }\n          monit.currentProgress().finishWork(trg.getName().toString());\n        }\n        monit.currentProgress().finishWork(scriptName);\n      }\n    });\n    LOG.debug(\"Finished executing script\");\n    return results;\n  }","commit_id":"476fd6fef4961e8a5b602941675bb5db2e8e6251","url":"https://github.com/JetBrains/MPS"},{"original_method":"public IScript completeScript(ScriptBuilder builder) {\n    final ProgressIndicatorProgressStrategy progStrat = new ProgressIndicatorProgressStrategy();\n    final IJobMonitor jmon = new IJobMonitor() {\n      public boolean stopRequested() {\n        return (progStrat.getProgressIndicator() != null ?\n          progStrat.getProgressIndicator().isCanceled() :\n          false\n        );\n      }\n\n      public IProgress currentProgress() {\n        return progStrat.currentProgress();\n      }\n\n      public void reportFeedback(IFeedback fdbk) {\n        new LoggingFeedbackStrategy().reportFeedback(fdbk);\n      }\n    };\n    final IConfigMonitor cmon = new IConfigMonitor() {\n      public <T extends IOption> T relayQuery(IQuery<T> query) {\n        return new UIQueryRelayStrategy().relayQuery(query, WorkbenchMakeService.this.context);\n      }\n    };\n\n    final Wrappers._T<ProgressIndicator> pind = new Wrappers._T<ProgressIndicator>(null);\n    IMonitors.Stub mons = new IMonitors.Stub(cmon, jmon) {\n      @Override\n      public void runJobWithMonitor(final _FunctionTypes._void_P1_E0<? super IJobMonitor> code) {\n        IdeEventQueue.getInstance().flushQueue();\n        ModelAccess.instance().runWriteActionWithProgressSynchronously(new Progressive() {\n          public void run(ProgressIndicator realInd) {\n            progStrat.setProgressIndicator(realInd);\n            pind.value = new JobMonitorProgressIndicator(jmon);\n            code.invoke(jmon);\n          }\n        }, (cleanMake ?\n          \"Rebuild\" :\n          \"Make\"\n        ), true, WorkbenchMakeService.this.context.getProject());\n      }\n    };\n\n    final _FunctionTypes._return_P0_E0<? extends ProgressIndicator> pindGet = new _FunctionTypes._return_P0_E0<ProgressIndicator>() {\n      public ProgressIndicator invoke() {\n        return pind.value;\n      }\n    };\n    _FunctionTypes._void_P1_E0<? super IParametersPool> init = new _FunctionTypes._void_P1_E0<IParametersPool>() {\n      public void invoke(IParametersPool pool) {\n        Tuples._4<Project, IOperationContext, Boolean, _FunctionTypes._return_P0_E0<? extends ProgressIndicator>> vars = (Tuples._4<Project, IOperationContext, Boolean, _FunctionTypes._return_P0_E0<? extends ProgressIndicator>>) pool.parameters(new ITarget.Name(\"checkParameters\"), Object.class);\n        vars._0(WorkbenchMakeService.this.context.getProject());\n        vars._1(WorkbenchMakeService.this.context);\n        vars._2(WorkbenchMakeService.this.cleanMake);\n        vars._3(pindGet);\n      }\n    };\n\n    return builder.withInit(init).withMonitors(mons).toScript();\n  }","id":97736,"modified_method":"private IScript completeScript(IScript scr) {\n    final ProgressIndicatorProgressStrategy progStrat = new ProgressIndicatorProgressStrategy();\n    final IJobMonitor jmon = new IJobMonitor() {\n      public boolean stopRequested() {\n        return (progStrat.getProgressIndicator() != null ?\n          progStrat.getProgressIndicator().isCanceled() :\n          false\n        );\n      }\n\n      public IProgress currentProgress() {\n        return progStrat.currentProgress();\n      }\n\n      public void reportFeedback(IFeedback fdbk) {\n        new LoggingFeedbackStrategy().reportFeedback(fdbk);\n      }\n    };\n    final IConfigMonitor cmon = new IConfigMonitor() {\n      public <T extends IOption> T relayQuery(IQuery<T> query) {\n        return new UIQueryRelayStrategy().relayQuery(query, WorkbenchMakeService.this.context);\n      }\n    };\n\n    final Wrappers._T<ProgressIndicator> pind = new Wrappers._T<ProgressIndicator>(null);\n    final IMonitors mons = new IMonitors.Stub(cmon, jmon) {\n      @Override\n      public void runJobWithMonitor(final _FunctionTypes._void_P1_E0<? super IJobMonitor> code) {\n        IdeEventQueue.getInstance().flushQueue();\n        ModelAccess.instance().runWriteActionWithProgressSynchronously(new Progressive() {\n          public void run(ProgressIndicator realInd) {\n            progStrat.setProgressIndicator(realInd);\n            pind.value = new JobMonitorProgressIndicator(jmon);\n            code.invoke(jmon);\n          }\n        }, (cleanMake ?\n          \"Rebuild\" :\n          \"Make\"\n        ), true, WorkbenchMakeService.this.context.getProject());\n      }\n    };\n\n    final _FunctionTypes._return_P0_E0<? extends ProgressIndicator> pindGet = new _FunctionTypes._return_P0_E0<ProgressIndicator>() {\n      public ProgressIndicator invoke() {\n        return pind.value;\n      }\n    };\n    final _FunctionTypes._void_P1_E0<? super IParametersPool> init = new _FunctionTypes._void_P1_E0<IParametersPool>() {\n      public void invoke(IParametersPool pool) {\n        Tuples._4<Project, IOperationContext, Boolean, _FunctionTypes._return_P0_E0<? extends ProgressIndicator>> vars = (Tuples._4<Project, IOperationContext, Boolean, _FunctionTypes._return_P0_E0<? extends ProgressIndicator>>) pool.parameters(new ITarget.Name(\"checkParameters\"), Object.class);\n        vars._0(WorkbenchMakeService.this.context.getProject());\n        vars._1(WorkbenchMakeService.this.context);\n        vars._2(WorkbenchMakeService.this.cleanMake);\n        vars._3(pindGet);\n      }\n    };\n    return new IScript.StubBoss(scr) {\n      @Override\n      public void init(IParametersPool ppool) {\n        init.invoke(ppool);\n      }\n\n      @Override\n      public IMonitors monitors() {\n        return mons;\n      }\n    };\n  }","commit_id":"476fd6fef4961e8a5b602941675bb5db2e8e6251","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n\t * Should be called after any callback has been triggered on the handle that would have\n\t * received the callback\n\t * @param timeout millis to wait for callback to occur\n\t * @throws Error\n\t * @throws InterruptedException\n\t */\n\tpublic void checkError(long timeout) throws Error, InterruptedException {\n\t\tsynchronized (this) {\n\t\t\twait(timeout);\n\t\t}\n\t\tif (null != _error)\n\t\t\tthrow _error;\n\t}","id":97737,"modified_method":"/**\n\t * Should be called after any callback has been triggered on the handle that would have\n\t * received the callback\n\t * @param timeout millis to wait for callback to occur\n\t * @throws Error\n\t * @throws InterruptedException\n\t */\n\tpublic void checkError(long timeout) throws Error, InterruptedException {\n\t\tif (timeout > 0 || timeout == SystemConfiguration.NO_TIMEOUT) {\n\t\t\tsynchronized (this) {\n\t\t\t\tif (timeout == SystemConfiguration.NO_TIMEOUT)\n\t\t\t\t\twait();\n\t\t\t\telse\n\t\t\t\t\twait(timeout);\n\t\t\t}\n\t\t}\n\t\tif (null != _error)\n\t\t\tthrow _error;\n\t}","commit_id":"e399dcd7e0b8448566d29fc60dcb726e35ac9c27","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private void expressInterest(InterestRegistration reg) throws IOException {\n\t\t_stats.increment(StatsEnum.ExpressInterest);\nLog.logStackTrace(Level.SEVERE, new Throwable(\"test\"));\n\n\t\ttry {\n\t\t\tregisterInterest(reg);\n\t\t\twrite(reg.interest);\n\t\t} catch (ContentEncodingException e) {\n\t\t\tunregisterInterest(reg);\n\t\t\tthrow e;\n\t\t}\n\t}","id":97738,"modified_method":"private void expressInterest(InterestRegistration reg) throws IOException {\n\t\t_stats.increment(StatsEnum.ExpressInterest);\n\t\ttry {\n\t\t\tregisterInterest(reg);\n\t\t\twrite(reg.interest);\n\t\t} catch (ContentEncodingException e) {\n\t\t\tunregisterInterest(reg);\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"e399dcd7e0b8448566d29fc60dcb726e35ac9c27","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public Interest handleContent(ContentObject data, Interest interest) {\n\t\tsawContent = true;\n\t\tcontentSema.release();\n\t\treturn interest;\n\t}","id":97739,"modified_method":"public Interest handleContent(ContentObject data, Interest interest) {\n\t\tsawContent = true;\n\t\tcontentSema.release();\n\t\treturn Interest.next(data.name(), null, null);\n\t}","commit_id":"e399dcd7e0b8448566d29fc60dcb726e35ac9c27","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Test\n\tpublic void testDeprecatedMethods() throws Throwable {\t\n\t\tinterestSema = new Semaphore(0);\n\t\tcontentSema = new Semaphore(0);\n\t\tInterest interest = new Interest(prefix);\n\t\t\n\t\t// Check that we can register a filter and see an interest using the old interface\n\t\tputHandle.registerFilter(prefix, this);\n\t\tgetHandle.expressInterest(interest, this);\n\t\tinterestSema.tryAcquire(QUICK_TIMEOUT, TimeUnit.MILLISECONDS);\n\t\tAssert.assertTrue(\"Interest never seen\", sawInterest);\n\t\t\n\t\t// Check that we can see content using the old interface - we wait for interest reexpression\n\t\t// to get it\n\t\tsawInterest = false;\n\t\tputNow = true;\n\t\tcontentSema.tryAcquire(MORE_THAN_RETRY_TIMEOUT, TimeUnit.MILLISECONDS);\n\t\tAssert.assertTrue(\"Content never seen\", sawContent);\n\t\t\n\t\t// Make sure that we don't get back content after we cancel the interest\n\t\tsawContent = false;\n\t\tputNow = true;\n\t\tgetHandle.cancelInterest(interest, this);\n\t\tcontentSema.tryAcquire(MORE_THAN_RETRY_TIMEOUT, TimeUnit.MILLISECONDS);\n\t\tAssert.assertFalse(\"Content seen when it should not have\", sawContent);\n\n\t\t// Now check that we don't see an interest after we unregister its filter\n\t\tsawInterest = false;\n\t\tputHandle.unregisterFilter(prefix, this);\n\t\tgetHandle.expressInterest(interest, this);\n\t\tinterestSema.tryAcquire(QUICK_TIMEOUT, TimeUnit.MILLISECONDS);\n\t\tAssert.assertFalse(\"Interest seen after cancel\", sawInterest);\n\t\tgetHandle.cancelInterest(interest, this);\n\t}","id":97740,"modified_method":"@Test\n\tpublic void testDeprecatedMethods() throws Throwable {\t\n\t\tinterestSema = new Semaphore(0);\n\t\tcontentSema = new Semaphore(0);\n\t\tInterest interest = new Interest(prefix);\n\t\t\n\t\t// Check that we can register a filter and see an interest using the old interface\n\t\tputHandle.registerFilter(prefix, this);\n\t\tgetHandle.expressInterest(interest, this);\n\t\tinterestSema.tryAcquire(QUICK_TIMEOUT, TimeUnit.MILLISECONDS);\n\t\tAssert.assertTrue(\"Interest never seen\", sawInterest);\n\t\t\n\t\t// Check that we can see content using the old interface - we wait for interest reexpression\n\t\t// to get it\n\t\tsawInterest = false;\n\t\tputNow = true;\n\t\tcontentSema.tryAcquire(MORE_THAN_RETRY_TIMEOUT, TimeUnit.MILLISECONDS);\n\t\tgetHandle.checkError(0);\n\t\tAssert.assertTrue(\"Content never seen\", sawContent);\n\t\t\n\t\t// Make sure that we don't get back content after we cancel the interest\n\t\tsawContent = false;\n\t\tputNow = true;\n\t\tgetHandle.cancelInterest(interest, this);\n\t\tcontentSema.tryAcquire(MORE_THAN_RETRY_TIMEOUT, TimeUnit.MILLISECONDS);\n\t\tgetHandle.checkError(0);\n\t\tAssert.assertFalse(\"Content seen when it should not have been\", sawContent);\n\n\t\t// Now check that we don't see an interest after we unregister its filter\n\t\tsawInterest = false;\n\t\tputHandle.unregisterFilter(prefix, this);\n\t\tgetHandle.expressInterest(interest, this);\n\t\tinterestSema.tryAcquire(QUICK_TIMEOUT, TimeUnit.MILLISECONDS);\n\t\tAssert.assertFalse(\"Interest seen after cancel\", sawInterest);\n\t\tgetHandle.cancelInterest(interest, this);\n\t}","commit_id":"e399dcd7e0b8448566d29fc60dcb726e35ac9c27","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public boolean handleInterest(Interest interest) {\n\t\tsawInterest = true;\n\t\tinterestSema.release();\n\t\tif (putNow) {\n\t\t\tContentObject co = ContentObject.buildContentObject(ContentName.fromNative(prefix, \n\t\t\t\t\t\tInteger.toString(++counter)), \"deprecationTest\".getBytes());\n\t\t\ttry {\n\t\t\t\tputNow = false;\n\t\t\t\tputHandle.put(co);\n\t\t\t} catch (IOException e) {\n\t\t\t\tAssert.fail(e.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","id":97741,"modified_method":"public boolean handleInterest(Interest interest) {\n\t\tsawInterest = true;\n\t\tinterestSema.release();\n\t\tif (putNow) {\n\t\t\tContentObject co = ContentObject.buildContentObject(ContentName.fromNative(prefix, \n\t\t\t\t\t\tInteger.toString(counter++)), \"deprecationTest\".getBytes());\n\t\t\ttry {\n\t\t\t\tputNow = false;\n\t\t\t\tputHandle.put(co);\n\t\t\t} catch (IOException e) {\n\t\t\t\tAssert.fail(e.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"e399dcd7e0b8448566d29fc60dcb726e35ac9c27","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Override\n            public synchronized void run()\n            {\n                while( !done )\n                {\n                    long now = System.currentTimeMillis();\n\n                    /* Process message ready for delivery */\n                    Iterator<MessageContext> itr = msgQueue.iterator();\n                    MessageContext context;\n                    while( itr.hasNext() && ( context = itr.next() ).atMillis <= now )\n                    {\n                        itr.remove();\n                        Inbound inbound = inboundChannels.get( context.destination );\n                        if( inbound != null )\n                        {\n                            inbound.deliver( context.message );\n                        }\n                    }\n\n                    /* Waiting logic */\n                    try\n                    {\n                        try\n                        {\n                            MessageContext first = msgQueue.first();\n                            long waitTime = first.atMillis - System.currentTimeMillis();\n                            wait( waitTime );\n                        }\n                        catch( NoSuchElementException e )\n                        {\n                            wait( 1000 );\n                        }\n                    }\n                    catch ( InterruptedException e )\n                    {\n                        done = true;\n                    }\n                }\n            }","id":97742,"modified_method":"@Override\n            public synchronized void run()\n            {\n                while( !done )\n                {\n                    long now = System.currentTimeMillis();\n\n                    /* Process message ready for delivery */\n                    Iterator<MessageContext> itr = msgQueue.iterator();\n                    MessageContext context;\n                    while( itr.hasNext() && ( context = itr.next() ).atMillis <= now )\n                    {\n                        itr.remove();\n                        Inbound inbound = inboundChannels.get( context.destination );\n                        if( inbound != null )\n                        {\n                            inbound.deliver( context.message );\n                        }\n                    }\n\n                    /* Waiting logic */\n                    try\n                    {\n                        try\n                        {\n                            MessageContext first = msgQueue.first();\n                            long waitTime = first.atMillis - System.currentTimeMillis();\n                            if( waitTime > 0 )\n                            {\n                                wait( waitTime );\n                            }\n                        }\n                        catch( NoSuchElementException e )\n                        {\n                            wait( 1000 );\n                        }\n                    }\n                    catch ( InterruptedException e )\n                    {\n                        done = true;\n                    }\n                }\n            }","commit_id":"6e659360c85b333adbe47a879217cdfbe41ab1e4","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void waitForPutDrain() throws IOException {\n\t\tsynchronized (_holdingArea) {\n\t\t\tint startSize = _holdingArea.size();\n\t\t\twhile (_holdingArea.size() > 0) {\n\t\t\t\tboolean _interrupted;\n\t\t\t\tdo {\n\t\t\t\t\t_interrupted = false;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t_holdingArea.wait(_timeout);\n\t\t\t\t\t} catch (InterruptedException ie) {\n\t\t\t\t\t\t_interrupted = true;\n\t\t\t\t\t}\n\t\t\t\t} while (_interrupted);\n\t\t\t\t\n\t\t\t\tif (_holdingArea.size() == startSize) {\n\t\t\t\t\tfor(ContentName co : _holdingArea.keySet()) {\n\t\t\t\t\t\tLog.warning(\"FlowController: still holding: \" + co.toString());\n\t\t\t\t\t}\n\t\t\t\t\tthrow new IOException(\"Put(s) with no matching interests - size is \" + _holdingArea.size());\n\t\t\t\t}\n\t\t\t\tstartSize = _holdingArea.size();\n\t\t\t}\n\t\t}\n\t}","id":97743,"modified_method":"public void waitForPutDrain() throws IOException {\n\t\tsynchronized (_holdingArea) {\n\t\t\tint startSize = _holdingArea.size();\n\t\t\twhile (_holdingArea.size() > 0) {\n\t\t\t\tlong startTime = System.currentTimeMillis();\n\t\t\t\tboolean keepTrying = true;\n\t\t\t\tdo {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlong waitTime = _timeout - (System.currentTimeMillis() - startTime);\n\t\t\t\t\t\tif (waitTime > 0)\n\t\t\t\t\t\t\t_holdingArea.wait(waitTime);\n\t\t\t\t\t} catch (InterruptedException ie) {\n\t\t\t\t\t\tkeepTrying = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (_holdingArea.size() != startSize || (System.currentTimeMillis() - startTime) >= _timeout)\n\t\t\t\t\t\tkeepTrying = false;\n\t\t\t\t} while (keepTrying);\n\t\t\t\t\n\t\t\t\tif (_holdingArea.size() == startSize) {\n\t\t\t\t\tfor(ContentName co : _holdingArea.keySet()) {\n\t\t\t\t\t\tLog.warning(\"FlowController: still holding: \" + co.toString());\n\t\t\t\t\t}\n\t\t\t\t\tthrow new IOException(\"Put(s) with no matching interests - size is \" + _holdingArea.size());\n\t\t\t\t}\n\t\t\t\tstartSize = _holdingArea.size();\n\t\t\t}\n\t\t}\n\t}","commit_id":"0fe602b0936831e82a7dbc43faa703650fabb47f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Generates the Key-Value-PropertyMap manually.\n\t * This is necessary because <code>objectName.getKeyPropertyList()<\/code> returns a Map, wherein the order of the\n\t * elements of the keySet may not be deterministic. The order is different than the order in <code>object.getKeyPropertyListString()<\/code>.\n\t *\n\t * Anyways, this method uses the <code>object.getKeyPropertyListString()<\/code>-method to build the KeyPropertyList-Map.\n\t * @param objectName The Objectname to build the KeyPropertyList-Map from.\n\t * @return The KeyPropertyList-Map.\n\t */\n\tprivate static Map<String, String> buildKeyPropertyList(ObjectName objectName) {\n\t\tMap<String, String> keyValueMap = new HashMap<>();\n\n\t\tString keyPropertyListString = objectName.getKeyPropertyListString();\n\t\tif (keyPropertyListString != null && !keyPropertyListString.isEmpty()) {\n\t\t\tString[] keyValuePairs = keyPropertyListString.split(\",\");\n\t\t\tfor (String eachKeyValue : keyValuePairs) {\n\t\t\t\tString[] keyValue = eachKeyValue.split(\"=\");\n\t\t\t\tif (keyValue.length >= 1) {\n\t\t\t\t\tkeyValueMap.put(keyValue[0], keyValue.length == 2 ? keyValue[1] : \"undefined\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn keyValueMap;\n\t}","id":97744,"modified_method":"/**\n\t * Generates the Key-Value-PropertyMap manually.\n\t * This is necessary because <code>objectName.getKeyPropertyList()<\/code> returns a Map, wherein the order of the\n\t * elements of the keySet may not be deterministic. The order is different than the order in <code>object.getKeyPropertyListString()<\/code>.\n\t *\n\t * Anyways, this method uses the <code>object.getKeyPropertyListString()<\/code>-method to build the KeyPropertyList-Map.\n\t * @param objectName The Objectname to build the KeyPropertyList-Map from.\n\t * @return The KeyPropertyList-Map.\n\t */\n\tprivate static Map<String, String> buildKeyPropertyList(ObjectName objectName) {\n\t\tMap<String, String> keyValueMap = new HashMap<>();\n\n\t\tString keyPropertyListString = objectName.getKeyPropertyListString();\n\t\tif (keyPropertyListString != null && !keyPropertyListString.isEmpty()) {\n\t\t\tString[] keyValuePairs = keyPropertyListString.split(\",\");\n\t\t\tfor (String eachKeyValue : keyValuePairs) {\n\t\t\t\tString key = eachKeyValue.substring(0, eachKeyValue.indexOf(\"=\"));\n\t\t\t\tString value =  eachKeyValue.length() > key.length() ? eachKeyValue.substring(key.length() + 1) : \"undefined\";\n\t\t\t\tif (!key.isEmpty() && !value.isEmpty()) {\n\t\t\t\t\tkeyValueMap.put(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn keyValueMap;\n\t}","commit_id":"3b4b8641f6e883d203195af5cde3f40aa1c8fe09","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n   * Create a key from a string representation (see {@link #toString()}. An {@link IllegalArgumentException} is raised\n   * if the format is not valid.\n   */\n  public static RuleKey parse(String s) {\n    String[] split = s.split(\":\");\n    Preconditions.checkArgument(split.length == 2, \"Invalid rule key: \" + s);\n    return RuleKey.of(split[0], split[1]);\n  }","id":97745,"modified_method":"/**\n   * Create a key from a string representation (see {@link #toString()}. An {@link IllegalArgumentException} is raised\n   * if the format is not valid.\n   */\n  public static RuleKey parse(String s) {\n    int semiColonPos = s.indexOf(\":\");\n    Preconditions.checkArgument(semiColonPos > 0, \"Invalid rule key: \" + s);\n    String key = s.substring(0, semiColonPos);\n    String repo = s.substring(semiColonPos + 1);\n    return RuleKey.of(key, repo);\n  }","commit_id":"46a655cc343aba370396d8af5fbc34d5da668a0a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_not_accept_bad_format() throws Exception {\n    try {\n      RuleKey.parse(\"foo\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Invalid rule key: foo\");\n    }\n  }","id":97746,"modified_method":"@Test\n  public void not_accept_bad_format() throws Exception {\n    try {\n      RuleKey.parse(\"foo\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Invalid rule key: foo\");\n    }\n  }","commit_id":"46a655cc343aba370396d8af5fbc34d5da668a0a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_encode_and_decode_string() throws Exception {\n    RuleKey key = RuleKey.of(\"squid\", \"NullDeref\");\n    String serialized = key.toString();\n    assertThat(serialized).isEqualTo(\"squid:NullDeref\");\n    RuleKey parsed = RuleKey.parse(serialized);\n    assertThat(parsed.repository()).isEqualTo(\"squid\");\n    assertThat(parsed.rule()).isEqualTo(\"NullDeref\");\n    assertThat(parsed.toString()).isEqualTo(\"squid:NullDeref\");\n  }","id":97747,"modified_method":"@Test\n  public void encode_and_decode_string() throws Exception {\n    RuleKey key = RuleKey.of(\"squid\", \"NullDeref\");\n    String serialized = key.toString();\n    assertThat(serialized).isEqualTo(\"squid:NullDeref\");\n    RuleKey parsed = RuleKey.parse(serialized);\n    assertThat(parsed.repository()).isEqualTo(\"squid\");\n    assertThat(parsed.rule()).isEqualTo(\"NullDeref\");\n    assertThat(parsed.toString()).isEqualTo(\"squid:NullDeref\");\n  }","commit_id":"46a655cc343aba370396d8af5fbc34d5da668a0a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n\t * Generates the Key-Value-PropertyMap manually.\n\t * This is necessary because <code>objectName.getKeyPropertyList()<\/code> returns a Map, wherein the order of the\n\t * elements of the keySet may not be deterministic. The order is different than the order in <code>object.getKeyPropertyListString()<\/code>.\n\t *\n\t * Anyways, this method uses the <code>object.getKeyPropertyListString()<\/code>-method to build the KeyPropertyList-Map.\n\t * @param objectName The Objectname to build the KeyPropertyList-Map from.\n\t * @return The KeyPropertyList-Map.\n\t */\n\tprivate static Map<String, String> buildKeyPropertyList(ObjectName objectName) {\n\t\tMap<String, String> keyValueMap = new HashMap<>();\n\n\t\tString keyPropertyListString = objectName.getKeyPropertyListString();\n\t\tif (keyPropertyListString != null && !keyPropertyListString.isEmpty()) {\n\t\t\tString[] keyValuePairs = keyPropertyListString.split(\",\");\n\t\t\tfor (String eachKeyValue : keyValuePairs) {\n\t\t\t\tString[] keyValue = eachKeyValue.split(\"=\");\n\t\t\t\tif (keyValue.length >= 1) {\n\t\t\t\t\tkeyValueMap.put(keyValue[0], keyValue.length == 2 ? keyValue[1] : \"undefined\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn keyValueMap;\n\t}","id":97748,"modified_method":"/**\n\t * Generates the Key-Value-PropertyMap manually.\n\t * This is necessary because <code>objectName.getKeyPropertyList()<\/code> returns a Map, wherein the order of the\n\t * elements of the keySet may not be deterministic. The order is different than the order in <code>object.getKeyPropertyListString()<\/code>.\n\t *\n\t * Anyways, this method uses the <code>object.getKeyPropertyListString()<\/code>-method to build the KeyPropertyList-Map.\n\t * @param objectName The Objectname to build the KeyPropertyList-Map from.\n\t * @return The KeyPropertyList-Map.\n\t */\n\tprivate static Map<String, String> buildKeyPropertyList(ObjectName objectName) {\n\t\tMap<String, String> keyValueMap = new HashMap<>();\n\n\t\tString keyPropertyListString = objectName.getKeyPropertyListString();\n\t\tif (keyPropertyListString != null && !keyPropertyListString.isEmpty()) {\n\t\t\tString[] keyValuePairs = keyPropertyListString.split(\",\");\n\t\t\tfor (String eachKeyValue : keyValuePairs) {\n\t\t\t\tString key = eachKeyValue.substring(0, eachKeyValue.indexOf(\"=\"));\n\t\t\t\tString value =  eachKeyValue.length() > key.length() ? eachKeyValue.substring(key.length() + 1) : \"undefined\";\n\t\t\t\tif (!key.isEmpty() && !value.isEmpty()) {\n\t\t\t\t\tkeyValueMap.put(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn keyValueMap;\n\t}","commit_id":"14fcd71cee226248585cab11065964494e4e8d24","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Generate a unique token. The token is generated according to the\n     * following pattern. NOnceToken = Base64 ( MD5 ( client-IP \":\"\n     * time-stamp \":\" private-key ) ).\n     *\n     * @param request HTTP Servlet request\n     */\n    protected String generateNonce(Request request) {\n\n        long currentTime = System.currentTimeMillis();\n\n\n        String ipTimeKey =\n            request.getRemoteAddr() + \":\" + currentTime + \":\" + getKey();\n\n        byte[] buffer;\n        synchronized (md5Helper) {\n            buffer = md5Helper.digest(\n                    ipTimeKey.getBytes(B2CConverter.ISO_8859_1));\n        }\n\n        String nonce = currentTime + \":\" + MD5Encoder.encode(buffer);\n\n        NonceInfo info = new NonceInfo(currentTime, 100);\n        synchronized (nonces) {\n            nonces.put(nonce, info);\n        }\n\n        return nonce;\n    }","id":97749,"modified_method":"/**\n     * Generate a unique token. The token is generated according to the\n     * following pattern. NOnceToken = Base64 ( MD5 ( client-IP \":\"\n     * time-stamp \":\" private-key ) ).\n     *\n     * @param request HTTP Servlet request\n     */\n    protected String generateNonce(Request request) {\n\n        long currentTime = System.currentTimeMillis();\n\n\n        String ipTimeKey =\n            request.getRemoteAddr() + \":\" + currentTime + \":\" + getKey();\n\n        byte[] buffer = ConcurrentMessageDigest.digestMD5(\n                ipTimeKey.getBytes(B2CConverter.ISO_8859_1));\n        String nonce = currentTime + \":\" + MD5Encoder.encode(buffer);\n\n        NonceInfo info = new NonceInfo(currentTime, 100);\n        synchronized (nonces) {\n            nonces.put(nonce, info);\n        }\n\n        return nonce;\n    }","commit_id":"a6bbc7fdfb31f6aad4107ca5a930a69f86f97764","url":"https://github.com/apache/tomcat"},{"original_method":"public Principal authenticate(Realm realm) {\n            // Second MD5 digest used to calculate the digest :\n            // MD5(Method + \":\" + uri)\n            String a2 = method + \":\" + uri;\n\n            byte[] buffer;\n            synchronized (md5Helper) {\n                buffer = md5Helper.digest(a2.getBytes(B2CConverter.ISO_8859_1));\n            }\n            String md5a2 = MD5Encoder.encode(buffer);\n\n            return realm.authenticate(userName, response, nonce, nc, cnonce,\n                    qop, realmName, md5a2);\n        }","id":97750,"modified_method":"public Principal authenticate(Realm realm) {\n            // Second MD5 digest used to calculate the digest :\n            // MD5(Method + \":\" + uri)\n            String a2 = method + \":\" + uri;\n\n            byte[] buffer = ConcurrentMessageDigest.digestMD5(\n                    a2.getBytes(B2CConverter.ISO_8859_1));\n            String md5a2 = MD5Encoder.encode(buffer);\n\n            return realm.authenticate(userName, response, nonce, nc, cnonce,\n                    qop, realmName, md5a2);\n        }","commit_id":"a6bbc7fdfb31f6aad4107ca5a930a69f86f97764","url":"https://github.com/apache/tomcat"},{"original_method":"public boolean validate(Request request) {\n            if ( (userName == null) || (realmName == null) || (nonce == null)\n                 || (uri == null) || (response == null) ) {\n                return false;\n            }\n\n            // Validate the URI - should match the request line sent by client\n            if (validateUri) {\n                String uriQuery;\n                String query = request.getQueryString();\n                if (query == null) {\n                    uriQuery = request.getRequestURI();\n                } else {\n                    uriQuery = request.getRequestURI() + \"?\" + query;\n                }\n                if (!uri.equals(uriQuery)) {\n                    // Some clients (older Android) use an absolute URI for\n                    // DIGEST but a relative URI in the request line.\n                    // request. 2.3.5 < fixed Android version <= 4.0.3\n                    String host = request.getHeader(\"host\");\n                    String scheme = request.getScheme();\n                    if (host != null && !uriQuery.startsWith(scheme)) {\n                        StringBuilder absolute = new StringBuilder();\n                        absolute.append(scheme);\n                        absolute.append(\"://\");\n                        absolute.append(host);\n                        absolute.append(uriQuery);\n                        if (!uri.equals(absolute.toString())) {\n                            return false;\n                        }\n                    } else {\n                        return false;\n                    }\n                }\n            }\n\n            // Validate the Realm name\n            String lcRealm = getRealmName(request.getContext());\n            if (!lcRealm.equals(realmName)) {\n                return false;\n            }\n\n            // Validate the opaque string\n            if (!opaque.equals(opaqueReceived)) {\n                return false;\n            }\n\n            // Validate nonce\n            int i = nonce.indexOf(\":\");\n            if (i < 0 || (i + 1) == nonce.length()) {\n                return false;\n            }\n            long nonceTime;\n            try {\n                nonceTime = Long.parseLong(nonce.substring(0, i));\n            } catch (NumberFormatException nfe) {\n                return false;\n            }\n            String md5clientIpTimeKey = nonce.substring(i + 1);\n            long currentTime = System.currentTimeMillis();\n            if ((currentTime - nonceTime) > nonceValidity) {\n                nonceStale = true;\n                synchronized (nonces) {\n                    nonces.remove(nonce);\n                }\n            }\n            String serverIpTimeKey =\n                request.getRemoteAddr() + \":\" + nonceTime + \":\" + key;\n            byte[] buffer = null;\n            synchronized (md5Helper) {\n                buffer = md5Helper.digest(\n                        serverIpTimeKey.getBytes(B2CConverter.ISO_8859_1));\n            }\n            String md5ServerIpTimeKey = MD5Encoder.encode(buffer);\n            if (!md5ServerIpTimeKey.equals(md5clientIpTimeKey)) {\n                return false;\n            }\n\n            // Validate qop\n            if (qop != null && !QOP.equals(qop)) {\n                return false;\n            }\n\n            // Validate cnonce and nc\n            // Check if presence of nc and Cnonce is consistent with presence of qop\n            if (qop == null) {\n                if (cnonce != null || nc != null) {\n                    return false;\n                }\n            } else {\n                if (cnonce == null || nc == null) {\n                    return false;\n                }\n                // RFC 2617 says nc must be 8 digits long. Older Android clients\n                // use 6. 2.3.5 < fixed Android version <= 4.0.3\n                if (nc.length() < 6 || nc.length() > 8) {\n                    return false;\n                }\n                long count;\n                try {\n                    count = Long.parseLong(nc, 16);\n                } catch (NumberFormatException nfe) {\n                    return false;\n                }\n                NonceInfo info;\n                synchronized (nonces) {\n                    info = nonces.get(nonce);\n                }\n                if (info == null) {\n                    // Nonce is valid but not in cache. It must have dropped out\n                    // of the cache - force a re-authentication\n                    nonceStale = true;\n                } else {\n                    if (!info.nonceCountValid(count)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }","id":97751,"modified_method":"public boolean validate(Request request) {\n            if ( (userName == null) || (realmName == null) || (nonce == null)\n                 || (uri == null) || (response == null) ) {\n                return false;\n            }\n\n            // Validate the URI - should match the request line sent by client\n            if (validateUri) {\n                String uriQuery;\n                String query = request.getQueryString();\n                if (query == null) {\n                    uriQuery = request.getRequestURI();\n                } else {\n                    uriQuery = request.getRequestURI() + \"?\" + query;\n                }\n                if (!uri.equals(uriQuery)) {\n                    // Some clients (older Android) use an absolute URI for\n                    // DIGEST but a relative URI in the request line.\n                    // request. 2.3.5 < fixed Android version <= 4.0.3\n                    String host = request.getHeader(\"host\");\n                    String scheme = request.getScheme();\n                    if (host != null && !uriQuery.startsWith(scheme)) {\n                        StringBuilder absolute = new StringBuilder();\n                        absolute.append(scheme);\n                        absolute.append(\"://\");\n                        absolute.append(host);\n                        absolute.append(uriQuery);\n                        if (!uri.equals(absolute.toString())) {\n                            return false;\n                        }\n                    } else {\n                        return false;\n                    }\n                }\n            }\n\n            // Validate the Realm name\n            String lcRealm = getRealmName(request.getContext());\n            if (!lcRealm.equals(realmName)) {\n                return false;\n            }\n\n            // Validate the opaque string\n            if (!opaque.equals(opaqueReceived)) {\n                return false;\n            }\n\n            // Validate nonce\n            int i = nonce.indexOf(\":\");\n            if (i < 0 || (i + 1) == nonce.length()) {\n                return false;\n            }\n            long nonceTime;\n            try {\n                nonceTime = Long.parseLong(nonce.substring(0, i));\n            } catch (NumberFormatException nfe) {\n                return false;\n            }\n            String md5clientIpTimeKey = nonce.substring(i + 1);\n            long currentTime = System.currentTimeMillis();\n            if ((currentTime - nonceTime) > nonceValidity) {\n                nonceStale = true;\n                synchronized (nonces) {\n                    nonces.remove(nonce);\n                }\n            }\n            String serverIpTimeKey =\n                request.getRemoteAddr() + \":\" + nonceTime + \":\" + key;\n            byte[] buffer = ConcurrentMessageDigest.digestMD5(\n                    serverIpTimeKey.getBytes(B2CConverter.ISO_8859_1));\n            String md5ServerIpTimeKey = MD5Encoder.encode(buffer);\n            if (!md5ServerIpTimeKey.equals(md5clientIpTimeKey)) {\n                return false;\n            }\n\n            // Validate qop\n            if (qop != null && !QOP.equals(qop)) {\n                return false;\n            }\n\n            // Validate cnonce and nc\n            // Check if presence of nc and Cnonce is consistent with presence of qop\n            if (qop == null) {\n                if (cnonce != null || nc != null) {\n                    return false;\n                }\n            } else {\n                if (cnonce == null || nc == null) {\n                    return false;\n                }\n                // RFC 2617 says nc must be 8 digits long. Older Android clients\n                // use 6. 2.3.5 < fixed Android version <= 4.0.3\n                if (nc.length() < 6 || nc.length() > 8) {\n                    return false;\n                }\n                long count;\n                try {\n                    count = Long.parseLong(nc, 16);\n                } catch (NumberFormatException nfe) {\n                    return false;\n                }\n                NonceInfo info;\n                synchronized (nonces) {\n                    info = nonces.get(nonce);\n                }\n                if (info == null) {\n                    // Nonce is valid but not in cache. It must have dropped out\n                    // of the cache - force a re-authentication\n                    nonceStale = true;\n                } else {\n                    if (!info.nonceCountValid(count)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }","commit_id":"a6bbc7fdfb31f6aad4107ca5a930a69f86f97764","url":"https://github.com/apache/tomcat"},{"original_method":"public boolean processRow( StepMetaInterface smi, StepDataInterface sdi ) throws KettleException {\n    meta = (MappingInputMeta) smi;\n    data = (MappingInputData) sdi;\n\n    if ( !data.linked ) {\n      //\n      // Wait until we know were to read from the parent transformation...\n      // However, don't wait forever, if we don't have a connection after 60 seconds: bail out!\n      //\n      int totalsleep = 0;\n      while ( !isStopped() && data.sourceSteps == null ) {\n        try {\n          totalsleep += 10;\n          Thread.sleep( 10 );\n        } catch ( InterruptedException e ) {\n          stopAll();\n        }\n        if ( totalsleep > timeOut ) {\n          throw new KettleException( BaseMessages.getString( PKG,\n              \"MappingInput.Exception.UnableToConnectWithParentMapping\", \"\" + ( totalsleep / 1000 ) ) );\n        }\n      }\n\n      // OK, now we're ready to read from the parent source steps.\n      data.linked = true;\n    }\n\n    Object[] row = getRow();\n    if ( row == null ) {\n      setOutputDone();\n      return false;\n    }\n\n    if ( first ) {\n      first = false;\n\n      // The Input RowMetadata is not the same as the output row meta-data.\n      // The difference is described in the data interface\n      //\n      // String[] data.sourceFieldname\n      // String[] data.targetFieldname\n      //\n      // --> getInputRowMeta() is not corresponding to what we're outputting.\n      // In essence, we need to rename a couple of fields...\n      //\n      data.outputRowMeta = getInputRowMeta().clone();\n\n      // Now change the field names according to the mapping specification...\n      // That means that all fields go through unchanged, unless specified.\n      //\n      for ( MappingValueRename valueRename : data.valueRenames ) {\n        replaceRenameIfNecessary( data.outputRowMeta, valueRename );\n        replaceRenameIfNecessary( getInputRowMeta(), valueRename );\n      }\n\n      // This is typical side effect of ESR-4178\n      data.outputRowMeta.setValueMetaList( data.outputRowMeta.getValueMetaList() );\n      this.getInputRowMeta().setValueMetaList( this.getInputRowMeta().getValueMetaList() );\n\n      // The input row meta has been manipulated correctly for the call to meta.getFields(), so create a blank\n      // outputRowMeta\n      meta.setInputRowMeta( getInputRowMeta() );\n      if ( meta.isSelectingAndSortingUnspecifiedFields() ) {\n        data.outputRowMeta = new RowMeta();\n      } else {\n        meta.setInputRowMeta( new RowMeta() );\n      }\n     \n\n      // Fill the output row meta with the processed fields\n      meta.getFields( data.outputRowMeta, getStepname(), null, null, this, repository, metaStore );\n\n      if ( meta.isSelectingAndSortingUnspecifiedFields() ) {\n        //\n        // Create a list of the indexes to get the right order or fields on the output.\n        //\n        data.fieldNrs = new int[data.outputRowMeta.size()];\n        for ( int i = 0; i < data.outputRowMeta.size(); i++ ) {\n          data.fieldNrs[i] = getInputRowMeta().indexOfValue( data.outputRowMeta.getValueMeta( i ).getName() );\n        }\n      }    \n    }    \n\n    // Fill and send the output row\n    if ( meta.isSelectingAndSortingUnspecifiedFields() ) {\n      Object[] outputRowData = RowDataUtil.allocateRowData( data.outputRowMeta.size() );\n      for ( int i = 0; i < data.fieldNrs.length; i++ ) {\n        outputRowData[i] = row[data.fieldNrs[i]];\n      }\n      putRow( data.outputRowMeta, outputRowData );\n    } else {\n      putRow( data.outputRowMeta, row );\n    }\n\n    return true;\n  }","id":97752,"modified_method":"public boolean processRow( StepMetaInterface smi, StepDataInterface sdi ) throws KettleException {\n    meta = (MappingInputMeta) smi;\n    data = (MappingInputData) sdi;\n\n    if ( !data.linked ) {\n      //\n      // Wait until we know were to read from the parent transformation...\n      // However, don't wait forever, if we don't have a connection after 60 seconds: bail out!\n      //\n      int totalsleep = 0;\n      while ( !isStopped() && data.sourceSteps == null ) {\n        try {\n          totalsleep += 10;\n          Thread.sleep( 10 );\n        } catch ( InterruptedException e ) {\n          stopAll();\n        }\n        if ( totalsleep > timeOut ) {\n          throw new KettleException( BaseMessages.getString( PKG,\n              \"MappingInput.Exception.UnableToConnectWithParentMapping\", \"\" + ( totalsleep / 1000 ) ) );\n        }\n      }\n\n      // OK, now we're ready to read from the parent source steps.\n      data.linked = true;\n    }\n\n    Object[] row = getRow();\n    if ( row == null ) {\n      setOutputDone();\n      return false;\n    }\n\n    if ( first ) {\n      first = false;\n\n      // The Input RowMetadata is not the same as the output row meta-data.\n      // The difference is described in the data interface\n      //\n      // String[] data.sourceFieldname\n      // String[] data.targetFieldname\n      //\n      // --> getInputRowMeta() is not corresponding to what we're outputting.\n      // In essence, we need to rename a couple of fields...\n      //\n      data.outputRowMeta = getInputRowMeta().clone();\n\n      // Now change the field names according to the mapping specification...\n      // That means that all fields go through unchanged, unless specified.\n      //\n      for ( MappingValueRename valueRename : data.valueRenames ) {\n        ValueMetaInterface valueMeta = data.outputRowMeta.searchValueMeta( valueRename.getSourceValueName() );\n        if ( valueMeta == null ) {\n          throw new KettleStepException( BaseMessages.getString( PKG, \"MappingInput.Exception.UnableToFindMappedValue\",\n              valueRename.getSourceValueName() ) );\n        }\n        valueMeta.setName( valueRename.getTargetValueName() );\n\n        valueMeta = getInputRowMeta().searchValueMeta( valueRename.getSourceValueName() );\n        if ( valueMeta == null ) {\n          throw new KettleStepException( BaseMessages.getString( PKG, \"MappingInput.Exception.UnableToFindMappedValue\",\n              valueRename.getSourceValueName() ) );\n        }\n        valueMeta.setName( valueRename.getTargetValueName() );\n      }\n\n      // This is typical side effect of ESR-4178\n      data.outputRowMeta.setValueMetaList( data.outputRowMeta.getValueMetaList() );\n      this.getInputRowMeta().setValueMetaList( this.getInputRowMeta().getValueMetaList() );\n\n      // The input row meta has been manipulated correctly for the call to meta.getFields(), so create a blank\n      // outputRowMeta\n      meta.setInputRowMeta( getInputRowMeta() );\n      if ( meta.isSelectingAndSortingUnspecifiedFields() ) {\n        data.outputRowMeta = new RowMeta();\n      } else {\n        meta.setInputRowMeta( new RowMeta() );\n      }\n     \n\n      // Fill the output row meta with the processed fields\n      meta.getFields( data.outputRowMeta, getStepname(), null, null, this, repository, metaStore );\n\n      if ( meta.isSelectingAndSortingUnspecifiedFields() ) {\n        //\n        // Create a list of the indexes to get the right order or fields on the output.\n        //\n        data.fieldNrs = new int[data.outputRowMeta.size()];\n        for ( int i = 0; i < data.outputRowMeta.size(); i++ ) {\n          data.fieldNrs[i] = getInputRowMeta().indexOfValue( data.outputRowMeta.getValueMeta( i ).getName() );\n        }\n      }    \n    }    \n\n    // Fill and send the output row\n    if ( meta.isSelectingAndSortingUnspecifiedFields() ) {\n      Object[] outputRowData = RowDataUtil.allocateRowData( data.outputRowMeta.size() );\n      for ( int i = 0; i < data.fieldNrs.length; i++ ) {\n        outputRowData[i] = row[data.fieldNrs[i]];\n      }\n      putRow( data.outputRowMeta, outputRowData );\n    } else {\n      putRow( data.outputRowMeta, row );\n    }\n\n    return true;\n  }","commit_id":"e99259601ee32863f1dacbb9b3d66e317b5ed3a9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tObject[] row;\n\t\tif (data.readsRows)\n\t\t{\n\t\t\trow=getRow();\n\t\t\tif (row==null)\n\t\t\t{\n\t\t\t\tsetOutputDone();\n\t\t\t\treturn false;\n\t\t\t}\n            \n            if (first)\n            {\n                first=false;\n                data.outputRowMeta = (RowMetaInterface) getInputRowMeta().clone();\n                meta.getFields(data.outputRowMeta, getStepname(), null);\n            }\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\trow=new Object[] {}; // empty row\n            linesRead++;\n\n            if (first)\n            {\n                first=false;\n                data.outputRowMeta = new RowMeta();\n                meta.getFields(data.outputRowMeta, getStepname(), null);\n            }\n\t\t}\n\t\t\n\t\trow = getSystemData(getInputRowMeta(), row);\n\t\t\n\t\tif (log.isRowLevel()) logRowlevel(\"System info returned: \"+row);\n\t\t\n\t\tputRow(data.outputRowMeta, row);     \n\t\t\t\t\t\n        if (!data.readsRows) // Just one row and then stop!\n        {\n            setOutputDone();\n            return false;\n        }\n        \n\t\treturn true;\n\t}","id":97753,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tObject[] row;\n\t\tif (data.readsRows)\n\t\t{\n\t\t\trow=getRow();\n\t\t\tif (row==null)\n\t\t\t{\n\t\t\t\tsetOutputDone();\n\t\t\t\treturn false;\n\t\t\t}\n            \n            if (first)\n            {\n                first=false;\n                data.outputRowMeta = (RowMetaInterface) getInputRowMeta().clone();\n                meta.getFields(data.outputRowMeta, getStepname(), null);\n            }\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\trow=new Object[] {}; // empty row\n            linesRead++;\n\n            if (first)\n            {\n                first=false;\n                data.outputRowMeta = new RowMeta();\n                meta.getFields(data.outputRowMeta, getStepname(), null);\n            }\n\t\t}\n\t\t\n\t\tRowMetaInterface imeta = getInputRowMeta();\n\t\tif (imeta==null)this.setInputRowMeta(imeta=new RowMeta());\n\t\n\t\trow = getSystemData(imeta, row);\n\t\t\n\t\tif (log.isRowLevel()) logRowlevel(\"System info returned: \"+row);\n\t\t\n\t\tputRow(data.outputRowMeta, row);     \n\t\t\t\t\t\n        if (!data.readsRows) // Just one row and then stop!\n        {\n            setOutputDone();\n            return false;\n        }\n        \n\t\treturn true;\n\t}","commit_id":"bc3f13ac75d9f2c81f9d6cbf0397e89b39ffd48d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tObject[] row = getRowFromXML();\r\n\t\tif (row == null)\r\n\t\t{\r\n\t\t\tsetOutputDone(); // signal end to receiver(s)\r\n\t\t\treturn false; // This is the end of this step.\r\n\t\t}\r\n\r\n\t\tif (log.isRowLevel())\r\n\t\t\tlogRowlevel(Messages.getString(\"XMLInput.Log.ReadRow\", row.toString()));\r\n\r\n\t\tlinesInput++;\r\n\t\tdata.outputRowMeta = (RowMetaInterface) getInputRowMeta().clone();\r\n\t\tmeta.getFields(data.outputRowMeta, getStepname(), null);\r\n\t\tputRow(data.outputRowMeta, row);\r\n\r\n\t\tif (meta.getRowLimit() > 0 && data.rownr >= meta.getRowLimit()) // limit\r\n\t\t// has\r\n\t\t// been\r\n\t\t// reached:\r\n\t\t// stop\r\n\t\t// now.\r\n\t\t{\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}","id":97754,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tObject[] row = getRowFromXML();\r\n\t\tif (row == null)\r\n\t\t{\r\n\t\t\tsetOutputDone(); // signal end to receiver(s)\r\n\t\t\treturn false; // This is the end of this step.\r\n\t\t}\r\n\r\n\t\tif (log.isRowLevel())\r\n\t\t\tlogRowlevel(Messages.getString(\"XMLInput.Log.ReadRow\", row.toString()));\r\n\r\n\t\tlinesInput++;\r\n\t\tif (first) // we just got started\r\n\t\t{\r\n\t\t\tfirst = false;\r\n\t\t\tRowMetaInterface irow = getInputRowMeta();\r\n\t\t\tdata.outputRowMeta = irow != null ? (RowMetaInterface)irow.clone() : new RowMeta();\r\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null);\r\n\t\t\tputRow(data.outputRowMeta, row);\r\n\t\t}\r\n\t\tif (meta.getRowLimit() > 0 && data.rownr >= meta.getRowLimit()) // limit\r\n\t\t// has\r\n\t\t// been\r\n\t\t// reached:\r\n\t\t// stop\r\n\t\t// now.\r\n\t\t{\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}","commit_id":"fef479bd8473e181e7ec3b2afbb5abb16f9b6189","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\r\n\t * Build an empty row based on the meta-data...\r\n\t * \r\n\t * @return\r\n\t */\r\n\tprivate Object[] buildEmptyRow()\r\n\t{\r\n\r\n\t\tXMLInputField fields[] = meta.getInputFields();\r\n\t\tObject[] row = new Object[fields.length];\r\n\t\tfor (int i = 0; i < fields.length; i++)\r\n\t\t{\r\n\t\t\tXMLInputField field = fields[i];\r\n\r\n\t\t\tValueMetaInterface value = new ValueMeta(field.getName(), field.getType());\r\n\t\t\tvalue.setLength(field.getLength(), field.getPrecision());\r\n\r\n\t\t\trow[i] = (value);\r\n\t\t}\r\n\r\n\t\treturn row;\r\n\t}","id":97755,"modified_method":"/**\r\n\t * Build an empty row based on the meta-data...\r\n\t * \r\n\t * @return\r\n\t */\r\n\tprivate Object[] buildEmptyRow()\r\n\t{\r\n\t\treturn new Object[meta.getInputFields().length];\r\n\t}","commit_id":"fef479bd8473e181e7ec3b2afbb5abb16f9b6189","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private Object[] getRowFromXML() throws KettleValueException\r\n\t{\r\n\t\twhile (data.itemPosition >= data.itemCount || data.file == null) // finished\r\n\t\t// reading\r\n\t\t// the\r\n\t\t// file,\r\n\t\t// read\r\n\t\t// the\r\n\t\t// next\r\n\t\t// file!\r\n\t\t{\r\n\t\t\tdata.file = null;\r\n\t\t\tif (!openNextFile())\r\n\t\t\t{\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tObject[] row = buildEmptyRow();\r\n\r\n\t\t// Get the item in the XML file...\r\n\r\n\t\t// First get the appropriate node\r\n\r\n\t\tNode itemNode;\r\n\t\tif (meta.getInputPosition().length > 1)\r\n\t\t{\r\n\t\t\titemNode = XMLHandler.getSubNodeByNr(data.section, data.itemElement, data.itemPosition);\r\n\t\t} else\r\n\t\t{\r\n\t\t\titemNode = data.section; // Only the root node, 1 element to read\r\n\t\t\t// in the whole document.\r\n\t\t}\r\n\t\tdata.itemPosition++;\r\n\r\n\t\t// Read from the Node...\r\n\t\tfor (int i = 0; i < meta.getInputFields().length; i++)\r\n\t\t{\r\n\t\t\tNode node = itemNode;\r\n\r\n\t\t\tXMLInputField xmlInputField = meta.getInputFields()[i];\r\n\r\n\t\t\tString value = null;\r\n\r\n\t\t\tfor (int p = 0; (value == null) && node != null && p < xmlInputField.getFieldPosition().length; p++)\r\n\t\t\t{\r\n\t\t\t\tXMLInputFieldPosition pos = xmlInputField.getFieldPosition()[p];\r\n\r\n\t\t\t\tswitch (pos.getType())\r\n\t\t\t\t{\r\n\t\t\t\tcase XMLInputFieldPosition.XML_ELEMENT:\r\n\t\t\t\t{\r\n\t\t\t\t\tif (pos.getElementNr() <= 1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tNode subNode = XMLHandler.getSubNode(node, pos.getName());\r\n\t\t\t\t\t\tif (subNode != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (p == xmlInputField.getFieldPosition().length - 1) // last\r\n\t\t\t\t\t\t\t// level\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tvalue = XMLHandler.getNodeValue(subNode);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (log.isDebug())\r\n\t\t\t\t\t\t\t\tlogDebug(Messages.getString(\"XMLInput.Log.UnableToFindPosition\", pos\r\n\t\t\t\t\t\t\t\t\t\t.toString(), node.toString()));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnode = subNode;\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t// Multiple possible values: get number\r\n\t\t\t\t\t// pos.getElementNr()!\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tNode subNode = XMLHandler.getSubNodeByNr(node, pos.getName(), pos.getElementNr() - 1,\r\n\t\t\t\t\t\t\t\tfalse);\r\n\t\t\t\t\t\tif (subNode != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (p == xmlInputField.getFieldPosition().length - 1) // last\r\n\t\t\t\t\t\t\t// level\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tvalue = XMLHandler.getNodeValue(subNode);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (log.isDebug())\r\n\t\t\t\t\t\t\t\tlogDebug(Messages.getString(\"XMLInput.Log.UnableToFindPosition\", pos\r\n\t\t\t\t\t\t\t\t\t\t.toString(), node.toString()));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnode = subNode;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase XMLInputFieldPosition.XML_ATTRIBUTE:\r\n\t\t\t\t{\r\n\t\t\t\t\tvalue = XMLHandler.getTagAttribute(node, pos.getName());\r\n\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase XMLInputFieldPosition.XML_ROOT:\r\n\t\t\t\t{\r\n\t\t\t\t\tvalue = XMLHandler.getNodeValue(node);\r\n\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// OK, we have the string...\r\n\t\t\tValueMetaAndData v = new ValueMetaAndData(((ValueMeta)row[i]).getName(), value);\r\n\r\n\t\t\t// DO Trimming!\r\n\t\t\tswitch (xmlInputField.getTrimType())\r\n\t\t\t{\r\n\t\t\tcase XMLInputField.TYPE_TRIM_LEFT:\r\n\t\t\t\tv.setValueData(Const.ltrim(v.getValueData().toString()));\r\n\t\t\t\tbreak;\r\n\t\t\tcase XMLInputField.TYPE_TRIM_RIGHT:\r\n\t\t\t\tv.setValueData(Const.rtrim(v.getValueData().toString()));\r\n\t\t\t\tbreak;\r\n\t\t\tcase XMLInputField.TYPE_TRIM_BOTH:\r\n\t\t\t\tv.setValueData(v.getValueData().toString().trim());\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// System.out.println(\"after trim, field #\"+i+\" : \"+v);\r\n\r\n\t\t\t// DO CONVERSIONS...\r\n\t\t\tObject val = v.getValueData();\r\n\t\t\tString sval = val != null ? val.toString() : \"\";\r\n\t\t\tswitch (xmlInputField.getType())\r\n\t\t\t{\r\n\t\t\tcase ValueMeta.TYPE_STRING:\r\n\t\t\t\t// System.out.println(\"Convert value to String :\"+v);\r\n\t\t\t\tbreak;\r\n\t\t\tcase ValueMeta.TYPE_NUMBER:\r\n\t\t\t\t// System.out.println(\"Convert value to Number :\"+v);\r\n\t\t\t\tif (xmlInputField.getFormat() != null && xmlInputField.getFormat().length() > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (xmlInputField.getDecimalSymbol() != null\r\n\t\t\t\t\t\t\t&& xmlInputField.getDecimalSymbol().length() > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (xmlInputField.getGroupSymbol() != null\r\n\t\t\t\t\t\t\t\t&& xmlInputField.getGroupSymbol().length() > 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (xmlInputField.getCurrencySymbol() != null\r\n\t\t\t\t\t\t\t\t\t&& xmlInputField.getCurrencySymbol().length() > 0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tdouble dval = StringUtil.str2num(xmlInputField.getFormat(), xmlInputField\r\n\t\t\t\t\t\t\t\t\t\t.getDecimalSymbol(), xmlInputField.getGroupSymbol(), xmlInputField\r\n\t\t\t\t\t\t\t\t\t\t.getCurrencySymbol(), sval);\r\n\t\t\t\t\t\t\t\tv.setValueData(new Double(dval));\r\n\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tv.setValueData(new Double(StringUtil.str2num(xmlInputField.getFormat(),\r\n\t\t\t\t\t\t\t\t\t\txmlInputField.getDecimalSymbol(), xmlInputField.getGroupSymbol(),\r\n\t\t\t\t\t\t\t\t\t\tnull, sval)));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tv.setValueData(new Double(StringUtil.str2num(xmlInputField.getFormat(),\r\n\t\t\t\t\t\t\t\t\txmlInputField.getDecimalSymbol(), null, null, sval)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tv.setValueData(new Double(StringUtil.str2num(xmlInputField.getFormat(), null, null,\r\n\t\t\t\t\t\t\t\tnull, sval))); // just a format mask\r\n\t\t\t\t\t}\r\n\t\t\t\t} else\r\n\t\t\t\t{\r\n\t\t\t\t\tv.setValueData(new Double(StringUtil.str2num(null, null, null, null, null)));\r\n\t\t\t\t}\r\n\t\t\t\tv.getValueMeta().setLength(xmlInputField.getLength(), xmlInputField.getPrecision());\r\n\t\t\t\tbreak;\r\n\t\t\tcase ValueMeta.TYPE_INTEGER:\r\n\t\t\t\t// System.out.println(\"Convert value to integer :\"+v);\r\n\t\t\t\tv.setValueData(v.getValueData());\r\n\t\t\t\tv.getValueMeta().setLength(xmlInputField.getLength(), xmlInputField.getPrecision());\r\n\t\t\t\tbreak;\r\n\t\t\tcase ValueMeta.TYPE_BIGNUMBER:\r\n\t\t\t\t// System.out.println(\"Convert value to BigNumber :\"+v);\r\n\t\t\t\tv.setValueData(v.getValueData());\r\n\t\t\t\tv.getValueMeta().setLength(xmlInputField.getLength(), xmlInputField.getPrecision());\r\n\t\t\t\tbreak;\r\n\t\t\tcase ValueMeta.TYPE_DATE:\r\n\t\t\t\t// System.out.println(\"Convert value to Date :\"+v);\r\n\r\n\t\t\t\tif (xmlInputField.getFormat() != null && xmlInputField.getFormat().length() > 0)\r\n\t\t\t\t{\r\n\r\n\t\t\t\t\tv.setValueData(StringUtil.str2dat(xmlInputField.getFormat(), null, sval));\r\n\t\t\t\t\tv.getValueMeta().setType(ValueMeta.TYPE_DATE);\r\n\t\t\t\t\tv.getValueMeta().setLength(-1, -1);\r\n\t\t\t\t} else\r\n\t\t\t\t{\r\n\t\t\t\t\tv.setValueData(v.getValueData());\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase ValueMeta.TYPE_BOOLEAN:\r\n\t\t\t\tv.setValueData(v.getValueData());\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// Do we need to repeat this field if it is null?\r\n\t\t\tif (meta.getInputFields()[i].isRepeated())\r\n\t\t\t{\r\n\t\t\t\tif (v.getValueMeta().isNull(v.getValueData()) && data.previousRow != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tv.setValueData(data.previousRow[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} // End of loop over fields...\r\n\r\n\t\t// See if we need to add the filename to the row...\r\n\t\tif (meta.includeFilename() && meta.getFilenameField() != null && meta.getFilenameField().length() > 0)\r\n\t\t{\r\n\t\t\tValueMetaAndData fn = new ValueMetaAndData(meta.getFilenameField(), KettleVFS\r\n\t\t\t\t\t.getFilename(data.file));\r\n\t\t\trow = RowDataUtil.addValueData(row,fn.getValueMeta());\r\n\t\t}\r\n\r\n\t\t// See if we need to add the row number to the row...\r\n\t\tif (meta.includeRowNumber() && meta.getRowNumberField() != null\r\n\t\t\t\t&& meta.getRowNumberField().length() > 0)\r\n\t\t{\r\n\t\t\tValueMetaAndData fn = new ValueMetaAndData(meta.getRowNumberField(), new Long(data.rownr));\r\n\t\t\trow = RowDataUtil.addValueData(row,fn.getValueMeta());\r\n\t\t}\r\n\r\n\t\tdata.previousRow = getInputRowMeta().cloneRow(row); // copy it to make\r\n\t\t// sure the next\r\n\t\t// step doesn't\r\n\t\t// change it in\r\n\t\t// between...\r\n\t\tdata.rownr++;\r\n\r\n\t\t// Throw away the information in the item?\r\n\t\tNodeList nodeList = itemNode.getChildNodes();\r\n\t\tfor (int i = 0; i < nodeList.getLength(); i++)\r\n\t\t\titemNode.removeChild(nodeList.item(i));\r\n\r\n\t\treturn row;\r\n\t}","id":97756,"modified_method":"private Object[] getRowFromXML() throws KettleValueException\r\n\t{\r\n\t\twhile (data.itemPosition >= data.itemCount || data.file == null) // finished\r\n\t\t// reading\r\n\t\t// the\r\n\t\t// file,\r\n\t\t// read\r\n\t\t// the\r\n\t\t// next\r\n\t\t// file!\r\n\t\t{\r\n\t\t\tdata.file = null;\r\n\t\t\tif (!openNextFile())\r\n\t\t\t{\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tObject[] row = buildEmptyRow();\r\n\r\n\t\t// Get the item in the XML file...\r\n\r\n\t\t// First get the appropriate node\r\n\r\n\t\tNode itemNode;\r\n\t\tif (meta.getInputPosition().length > 1)\r\n\t\t{\r\n\t\t\titemNode = XMLHandler.getSubNodeByNr(data.section, data.itemElement, data.itemPosition);\r\n\t\t} else\r\n\t\t{\r\n\t\t\titemNode = data.section; // Only the root node, 1 element to read\r\n\t\t\t// in the whole document.\r\n\t\t}\r\n\t\tdata.itemPosition++;\r\n\r\n\t\t// Read from the Node...\r\n\t\tfor (int i = 0; i < meta.getInputFields().length; i++)\r\n\t\t{\r\n\t\t\tNode node = itemNode;\r\n\r\n\t\t\tXMLInputField xmlInputField = meta.getInputFields()[i];\r\n\r\n\t\t\tString value = null;\r\n\r\n\t\t\tfor (int p = 0; (value == null) && node != null && p < xmlInputField.getFieldPosition().length; p++)\r\n\t\t\t{\r\n\t\t\t\tXMLInputFieldPosition pos = xmlInputField.getFieldPosition()[p];\r\n\r\n\t\t\t\tswitch (pos.getType())\r\n\t\t\t\t{\r\n\t\t\t\tcase XMLInputFieldPosition.XML_ELEMENT:\r\n\t\t\t\t{\r\n\t\t\t\t\tif (pos.getElementNr() <= 1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tNode subNode = XMLHandler.getSubNode(node, pos.getName());\r\n\t\t\t\t\t\tif (subNode != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (p == xmlInputField.getFieldPosition().length - 1) // last\r\n\t\t\t\t\t\t\t// level\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tvalue = XMLHandler.getNodeValue(subNode);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (log.isDebug())\r\n\t\t\t\t\t\t\t\tlogDebug(Messages.getString(\"XMLInput.Log.UnableToFindPosition\", pos\r\n\t\t\t\t\t\t\t\t\t\t.toString(), node.toString()));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnode = subNode;\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t// Multiple possible values: get number\r\n\t\t\t\t\t// pos.getElementNr()!\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tNode subNode = XMLHandler.getSubNodeByNr(node, pos.getName(), pos.getElementNr() - 1,\r\n\t\t\t\t\t\t\t\tfalse);\r\n\t\t\t\t\t\tif (subNode != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (p == xmlInputField.getFieldPosition().length - 1) // last\r\n\t\t\t\t\t\t\t// level\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tvalue = XMLHandler.getNodeValue(subNode);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (log.isDebug())\r\n\t\t\t\t\t\t\t\tlogDebug(Messages.getString(\"XMLInput.Log.UnableToFindPosition\", pos\r\n\t\t\t\t\t\t\t\t\t\t.toString(), node.toString()));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnode = subNode;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase XMLInputFieldPosition.XML_ATTRIBUTE:\r\n\t\t\t\t{\r\n\t\t\t\t\tvalue = XMLHandler.getTagAttribute(node, pos.getName());\r\n\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase XMLInputFieldPosition.XML_ROOT:\r\n\t\t\t\t{\r\n\t\t\t\t\tvalue = XMLHandler.getNodeValue(node);\r\n\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// OK, we have the string...\r\n\t\t\tValueMetaAndData v = new ValueMetaAndData(((ValueMeta) row[i]).getName(), value);\r\n\r\n\t\t\t// DO Trimming!\r\n\t\t\tswitch (xmlInputField.getTrimType())\r\n\t\t\t{\r\n\t\t\tcase XMLInputField.TYPE_TRIM_LEFT:\r\n\t\t\t\tv.setValueData(Const.ltrim(v.getValueData().toString()));\r\n\t\t\t\tbreak;\r\n\t\t\tcase XMLInputField.TYPE_TRIM_RIGHT:\r\n\t\t\t\tv.setValueData(Const.rtrim(v.getValueData().toString()));\r\n\t\t\t\tbreak;\r\n\t\t\tcase XMLInputField.TYPE_TRIM_BOTH:\r\n\t\t\t\tv.setValueData(v.getValueData().toString().trim());\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// System.out.println(\"after trim, field #\"+i+\" : \"+v);\r\n\r\n\t\t\t// DO CONVERSIONS...\r\n\t\t\tObject val = v.getValueData();\r\n\t\t\tString sval = val != null ? val.toString() : \"\";\r\n\t\t\tswitch (xmlInputField.getType())\r\n\t\t\t{\r\n\t\t\tcase ValueMeta.TYPE_STRING:\r\n\t\t\t\t// System.out.println(\"Convert value to String :\"+v);\r\n\t\t\t\tbreak;\r\n\t\t\tcase ValueMeta.TYPE_NUMBER:\r\n\t\t\t\t// System.out.println(\"Convert value to Number :\"+v);\r\n\t\t\t\tif (xmlInputField.getFormat() != null && xmlInputField.getFormat().length() > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (xmlInputField.getDecimalSymbol() != null\r\n\t\t\t\t\t\t\t&& xmlInputField.getDecimalSymbol().length() > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (xmlInputField.getGroupSymbol() != null\r\n\t\t\t\t\t\t\t\t&& xmlInputField.getGroupSymbol().length() > 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (xmlInputField.getCurrencySymbol() != null\r\n\t\t\t\t\t\t\t\t\t&& xmlInputField.getCurrencySymbol().length() > 0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tdouble dval = StringUtil.str2num(xmlInputField.getFormat(), xmlInputField\r\n\t\t\t\t\t\t\t\t\t\t.getDecimalSymbol(), xmlInputField.getGroupSymbol(), xmlInputField\r\n\t\t\t\t\t\t\t\t\t\t.getCurrencySymbol(), sval);\r\n\t\t\t\t\t\t\t\tv.setValueData(new Double(dval));\r\n\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tv.setValueData(new Double(StringUtil.str2num(xmlInputField.getFormat(),\r\n\t\t\t\t\t\t\t\t\t\txmlInputField.getDecimalSymbol(), xmlInputField.getGroupSymbol(),\r\n\t\t\t\t\t\t\t\t\t\tnull, sval)));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tv.setValueData(new Double(StringUtil.str2num(xmlInputField.getFormat(),\r\n\t\t\t\t\t\t\t\t\txmlInputField.getDecimalSymbol(), null, null, sval)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tv.setValueData(new Double(StringUtil.str2num(xmlInputField.getFormat(), null, null,\r\n\t\t\t\t\t\t\t\tnull, sval))); // just a format mask\r\n\t\t\t\t\t}\r\n\t\t\t\t} else\r\n\t\t\t\t{\r\n\t\t\t\t\tv.setValueData(new Double(StringUtil.str2num(null, null, null, null, null)));\r\n\t\t\t\t}\r\n\t\t\t\tv.getValueMeta().setLength(xmlInputField.getLength(), xmlInputField.getPrecision());\r\n\t\t\t\tbreak;\r\n\t\t\tcase ValueMeta.TYPE_INTEGER:\r\n\t\t\t\t// System.out.println(\"Convert value to integer :\"+v);\r\n\t\t\t\tv.setValueData(v.getValueData());\r\n\t\t\t\tv.getValueMeta().setLength(xmlInputField.getLength(), xmlInputField.getPrecision());\r\n\t\t\t\tbreak;\r\n\t\t\tcase ValueMeta.TYPE_BIGNUMBER:\r\n\t\t\t\t// System.out.println(\"Convert value to BigNumber :\"+v);\r\n\t\t\t\tv.setValueData(v.getValueData());\r\n\t\t\t\tv.getValueMeta().setLength(xmlInputField.getLength(), xmlInputField.getPrecision());\r\n\t\t\t\tbreak;\r\n\t\t\tcase ValueMeta.TYPE_DATE:\r\n\t\t\t\t// System.out.println(\"Convert value to Date :\"+v);\r\n\r\n\t\t\t\tif (xmlInputField.getFormat() != null && xmlInputField.getFormat().length() > 0)\r\n\t\t\t\t{\r\n\r\n\t\t\t\t\tv.setValueData(StringUtil.str2dat(xmlInputField.getFormat(), null, sval));\r\n\t\t\t\t\tv.getValueMeta().setType(ValueMeta.TYPE_DATE);\r\n\t\t\t\t\tv.getValueMeta().setLength(-1, -1);\r\n\t\t\t\t} else\r\n\t\t\t\t{\r\n\t\t\t\t\tv.setValueData(v.getValueData());\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase ValueMeta.TYPE_BOOLEAN:\r\n\t\t\t\tv.setValueData(v.getValueData());\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// Do we need to repeat this field if it is null?\r\n\t\t\tif (meta.getInputFields()[i].isRepeated())\r\n\t\t\t{\r\n\t\t\t\tif (v.getValueMeta().isNull(v.getValueData()) && data.previousRow != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tv.setValueData(data.previousRow[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} // End of loop over fields...\r\n\r\n\t\t// See if we need to add the filename to the row...\r\n\t\tif (meta.includeFilename() && meta.getFilenameField() != null && meta.getFilenameField().length() > 0)\r\n\t\t{\r\n\t\t\tValueMetaAndData fn = new ValueMetaAndData(meta.getFilenameField(), KettleVFS\r\n\t\t\t\t\t.getFilename(data.file));\r\n\t\t\trow = RowDataUtil.addValueData(row, fn.getValueMeta());\r\n\t\t}\r\n\r\n\t\t// See if we need to add the row number to the row...\r\n\t\tif (meta.includeRowNumber() && meta.getRowNumberField() != null\r\n\t\t\t\t&& meta.getRowNumberField().length() > 0)\r\n\t\t{\r\n\t\t\tValueMetaAndData fn = new ValueMetaAndData(meta.getRowNumberField(), new Long(data.rownr));\r\n\t\t\trow = RowDataUtil.addValueData(row, fn.getValueMeta());\r\n\t\t}\r\n\r\n\t\tRowMetaInterface irow = getInputRowMeta();\r\n\t\t\r\n\t\tdata.previousRow = irow==null?row:(Object[])irow.cloneRow(row); // copy it to make\r\n\t\t// sure the next\r\n\t\t// step doesn't\r\n\t\t// change it in\r\n\t\t// between...\r\n\t\tdata.rownr++;\r\n\r\n\t\t// Throw away the information in the item?\r\n\t\tNodeList nodeList = itemNode.getChildNodes();\r\n\t\tfor (int i = 0; i < nodeList.getLength(); i++)\r\n\t\t\titemNode.removeChild(nodeList.item(i));\r\n\r\n\t\treturn row;\r\n\t}","commit_id":"fef479bd8473e181e7ec3b2afbb5abb16f9b6189","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Nullable\n  public static PsiClass findPsiClassByJVMName(@NotNull PsiManager manager, @NotNull String jvmClassName) {\n    return findPsiClass(manager, jvmClassName.replace('/', '.'), null, true);\n  }","id":97757,"modified_method":"/**\n   * Looks for inner and anonymous classes by internal name ('pkg/Top$Inner').\n   */\n  @Nullable\n  public static PsiClass findPsiClassByJVMName(@NotNull PsiManager manager, @NotNull String jvmClassName) {\n    return findPsiClass(manager, jvmClassName.replace('/', '.'), null, true);\n  }","commit_id":"d5d28925642615340d1d5adbadda3153874b2763","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static int getNonQualifiedClassIdx(@NotNull final PsiClass psiClass) {\n    final int[] result = {-1};\n    final PsiClass containingClass = getContainerClass(psiClass);\n    if (containingClass != null) {\n      containingClass.accept(new JavaRecursiveElementVisitor() {\n        private int myCurrentIdx = 0;\n\n        @Override public void visitElement(PsiElement element) {\n          if (result[0] == -1) {\n            super.visitElement(element);\n          }\n        }\n\n        @Override public void visitClass(PsiClass aClass) {\n          super.visitClass(aClass);\n          if (aClass.getQualifiedName() == null) {\n            myCurrentIdx++;\n            if (psiClass == aClass) {\n              result[0] = myCurrentIdx;\n            }\n          }\n        }\n      });\n    }\n    return result[0];\n  }","id":97758,"modified_method":"public static int getNonQualifiedClassIdx(@NotNull final PsiClass psiClass) {\n    final int[] result = {-1};\n    final PsiClass containingClass = getContainingClass(psiClass);\n    if (containingClass != null) {\n      containingClass.accept(new JavaRecursiveElementVisitor() {\n        private int myCurrentIdx = 0;\n\n        @Override\n        public void visitElement(PsiElement element) {\n          if (result[0] == -1) {\n            super.visitElement(element);\n          }\n        }\n\n        @Override\n        public void visitClass(PsiClass aClass) {\n          super.visitClass(aClass);\n          if (aClass.getQualifiedName() == null) {\n            myCurrentIdx++;\n            if (psiClass == aClass) {\n              result[0] = myCurrentIdx;\n            }\n          }\n        }\n      });\n    }\n    return result[0];\n  }","commit_id":"d5d28925642615340d1d5adbadda3153874b2763","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Finds anonymous classes. Uses javac notation.\n   * @param psiManager project to search\n   * @param externalName class qualified name\n   * @return found psiClass\n   */\n  @Nullable\n  public static PsiClass findPsiClass(@NotNull PsiManager psiManager, @NotNull String externalName){\n    return findPsiClass(psiManager, externalName, null, false);\n  }","id":97759,"modified_method":"/**\n   * Looks for inner and anonymous classes by FQN in a javac notation ('pkg.Top$Inner').\n   */\n  @Nullable\n  public static PsiClass findPsiClass(@NotNull PsiManager manager, @NotNull String name) {\n    return findPsiClass(manager, name, null, false);\n  }","commit_id":"d5d28925642615340d1d5adbadda3153874b2763","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiClass getContainerClass(@NotNull PsiClass aClass) {\n    PsiElement parent = aClass.getContext();\n    while (parent != null && !(parent instanceof PsiClass)) {\n      parent = parent.getContext();\n    }\n    return (PsiClass)parent;\n  }","id":97760,"modified_method":"@Nullable\n  private static PsiClass getContainingClass(@NotNull PsiClass aClass) {\n    PsiElement parent = aClass.getContext();\n    while (parent != null && !(parent instanceof PsiClass)) {\n      parent = parent.getContext();\n    }\n    return (PsiClass)parent;\n  }","commit_id":"d5d28925642615340d1d5adbadda3153874b2763","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiClass findSubclass(@NotNull PsiManager psiManager,\n                                       @NotNull String externalName,\n                                       final PsiClass psiClass,\n                                       final boolean jvmCompatible) {\n    for (int pos = 0; pos < externalName.length(); pos++) {\n      if (externalName.charAt(pos) == '$') {\n        PsiClass anonymousClass = findNonQualifiedClassByIndex(externalName.substring(0, pos), psiClass, jvmCompatible);\n        if (anonymousClass == null) return null;\n        PsiClass res = findPsiClass(psiManager, externalName.substring(pos), anonymousClass, jvmCompatible);\n        if (res != null) return res;\n      }\n    }\n    return findNonQualifiedClassByIndex(externalName, psiClass, jvmCompatible);\n  }","id":97761,"modified_method":"@Nullable\n  private static PsiClass findSubClass(@NotNull String name, @NotNull PsiClass parent, boolean jvmCompatible) {\n    PsiClass result = isIndexed(name) ? findNonQualifiedClassByIndex(name, parent, jvmCompatible) : parent.findInnerClassByName(name, false);\n    if (result != null) return result;\n\n    int p = 0;\n    while ((p = name.indexOf('$', p + 1)) > 0 && p < name.length() - 1) {\n      String prefix = name.substring(0, p);\n      PsiClass subClass = isIndexed(prefix) ? findNonQualifiedClassByIndex(prefix, parent, jvmCompatible) : parent.findInnerClassByName(prefix, false);\n      if (subClass != null) {\n        String suffix = name.substring(p + 1);\n        result = findSubClass(suffix, subClass, jvmCompatible);\n        if (result != null) return result;\n      }\n    }\n\n    return null;\n  }","commit_id":"d5d28925642615340d1d5adbadda3153874b2763","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void formatClassName(@NotNull final PsiClass aClass, @NotNull StringBuilder buf) {\n    final String qName = aClass.getQualifiedName();\n    if (qName != null) {\n      buf.append(qName);\n    }\n    else {\n      final PsiClass parentClass = getContainerClass(aClass);\n      if (parentClass != null) {\n        formatClassName(parentClass, buf);\n        buf.append(\"$\");\n        buf.append(getNonQualifiedClassIdx(aClass));\n        final String name = aClass.getName();\n        if (name != null) {\n          buf.append(name);\n        }\n      }\n    }\n  }","id":97762,"modified_method":"public static void formatClassName(@NotNull final PsiClass aClass, @NotNull StringBuilder buf) {\n    final String qName = aClass.getQualifiedName();\n    if (qName != null) {\n      buf.append(qName);\n    }\n    else {\n      final PsiClass parentClass = getContainingClass(aClass);\n      if (parentClass != null) {\n        formatClassName(parentClass, buf);\n        buf.append(\"$\");\n        buf.append(getNonQualifiedClassIdx(aClass));\n        final String name = aClass.getName();\n        if (name != null) {\n          buf.append(name);\n        }\n      }\n    }\n  }","commit_id":"d5d28925642615340d1d5adbadda3153874b2763","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiClass findPsiClass(@NotNull PsiManager psiManager,\n                                      @NotNull String externalName,\n                                      @Nullable PsiClass psiClass,\n                                      boolean jvmCompatible, \n                                      @NotNull GlobalSearchScope scope) {\n    for (int pos = 0; pos < externalName.length(); pos++) {\n      if (externalName.charAt(pos) == '$') {\n        PsiClass parentClass = psiClass;\n        if (parentClass == null) {\n          parentClass = JavaPsiFacade.getInstance(psiManager.getProject())\n            .findClass(externalName.substring(0, pos), scope);\n        }\n        if (parentClass == null) continue;\n        PsiClass res = findSubclass(psiManager, externalName.substring(pos + 1), parentClass, jvmCompatible);\n        if (res != null) return res;\n      }\n    }\n    return JavaPsiFacade.getInstance(psiManager.getProject()).findClass(externalName, scope);\n  }","id":97763,"modified_method":"@Nullable\n  public static PsiClass findPsiClass(@NotNull PsiManager manager,\n                                      @NotNull String name,\n                                      @Nullable PsiClass parent,\n                                      boolean jvmCompatible,\n                                      @NotNull GlobalSearchScope scope) {\n    if (parent != null) {\n      return findSubClass(name, parent, jvmCompatible);\n    }\n\n    PsiClass result = JavaPsiFacade.getInstance(manager.getProject()).findClass(name, scope);\n    if (result != null) return result;\n\n    int p = 0;\n    while ((p = name.indexOf('$', p + 1)) > 0 && p < name.length() - 1) {\n      String prefix = name.substring(0, p);\n      parent = JavaPsiFacade.getInstance(manager.getProject()).findClass(prefix, scope);\n      if (parent != null) {\n        String suffix = name.substring(p + 1);\n        result = findSubClass(suffix, parent, jvmCompatible);\n        if (result != null) return result;\n      }\n    }\n\n    return null;\n  }","commit_id":"d5d28925642615340d1d5adbadda3153874b2763","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiClass findPsiClass(@NotNull PsiManager psiManager,\n                                      @NotNull String externalName,\n                                      PsiClass psiClass,\n                                      boolean jvmCompatible) {\n    return findPsiClass(psiManager, externalName, psiClass, jvmCompatible, GlobalSearchScope.allScope(psiManager.getProject()));\n  }","id":97764,"modified_method":"@Nullable\n  public static PsiClass findPsiClass(@NotNull PsiManager manager,\n                                      @NotNull String name,\n                                      @Nullable PsiClass parent,\n                                      boolean jvmCompatible) {\n    GlobalSearchScope scope = GlobalSearchScope.allScope(manager.getProject());\n    return findPsiClass(manager, name, parent, jvmCompatible, scope);\n  }","commit_id":"d5d28925642615340d1d5adbadda3153874b2763","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindPsiClassByJvmName() {\n    myFixture.configureByFile(\"ManyClasses.java\");\n\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$1\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$1$1\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$1FooLocal\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$1FooLocal$1\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$Child\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"Local\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"Local$Sub\"));\n\n    PsiClass local = ClassUtil.findPsiClassByJVMName(getPsiManager(), \"Local$\");\n    assertNotNull(local);\n    assertEquals(\"Local$\", local.getName());\n\n    PsiClass sub = ClassUtil.findPsiClassByJVMName(getPsiManager(), \"Local$$Sub\");\n    assertNotNull(sub);\n    assertEquals(\"Local$\", ((PsiClass)sub.getParent()).getName());\n\n    PsiClass fooLocal2 = ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$2FooLocal\");\n    assertNotNull(fooLocal2);\n    assertEquals(\"Runnable\", fooLocal2.getImplementsListTypes()[0].getClassName());\n  }","id":97765,"modified_method":"public void testFindPsiClassByJvmName() {\n    myFixture.configureByFile(\"ManyClasses.java\");\n\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$1\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$1$1\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$1FooLocal\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$1FooLocal$1\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$Child\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$Child$\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$Ma$ked\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$Ma$ked$Ne$ted\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$Edge\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$Edge$\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$Edge$$$tu_pid_ne$s\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"Local\"));\n    assertNotNull(ClassUtil.findPsiClassByJVMName(getPsiManager(), \"Local$Sub\"));\n\n    PsiClass local = ClassUtil.findPsiClassByJVMName(getPsiManager(), \"Local$\");\n    assertNotNull(local);\n    assertEquals(\"Local$\", local.getName());\n\n    PsiClass sub = ClassUtil.findPsiClassByJVMName(getPsiManager(), \"Local$$Sub\");\n    assertNotNull(sub);\n    assertEquals(\"Local$\", ((PsiClass)sub.getParent()).getName());\n\n    PsiClass fooLocal2 = ClassUtil.findPsiClassByJVMName(getPsiManager(), \"ManyClasses$2FooLocal\");\n    assertNotNull(fooLocal2);\n    assertEquals(\"Runnable\", fooLocal2.getImplementsListTypes()[0].getClassName());\n  }","commit_id":"d5d28925642615340d1d5adbadda3153874b2763","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean supportSerializationProtocol(TestNGConfiguration config) {\n    final Project project = config.getProject();\n    final GlobalSearchScope scopeToDetermineTestngIn;\n    if (config.getPersistantData().getScope() == TestSearchScope.WHOLE_PROJECT) {\n      scopeToDetermineTestngIn = GlobalSearchScope.allScope(project);\n    }\n    else {\n      scopeToDetermineTestngIn = GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(config.getConfigurationModule().getModule());\n    }\n\n    final TestData data = config.getPersistantData();\n\n    return JavaPsiFacade.getInstance(project)\n      .findClass(SerializedMessageSender.class.getName(), scopeToDetermineTestngIn) != null;\n  }","id":97766,"modified_method":"public static boolean supportSerializationProtocol(TestNGConfiguration config) {\n    final Project project = config.getProject();\n    final GlobalSearchScope scopeToDetermineTestngIn;\n    if (config.getPersistantData().getScope() == TestSearchScope.WHOLE_PROJECT) {\n      scopeToDetermineTestngIn = GlobalSearchScope.allScope(project);\n    }\n    else {\n      scopeToDetermineTestngIn = GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(config.getConfigurationModule().getModule());\n    }\n\n    final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n    final PsiClass aClass = facade.findClass(SerializedMessageSender.class.getName(), scopeToDetermineTestngIn);\n    if (aClass == null) return false;\n\n    final PsiClass[] starters = facade.findClasses(RemoteTestNG.class.getName(), scopeToDetermineTestngIn);\n    for (PsiClass starter : starters) {\n      if (starter.findFieldByName(\"m_serPort\", false) == null) {\n        LOG.info(\"Multiple TestNG versions found\");\n        return false;\n      }\n    }\n    return true;\n  }","commit_id":"37702b75f166c43b34d771a27ae5ffe5ea6c5659","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiClass findMainClass(final Project project, final String mainClassName, final GlobalSearchScope scope) {\n    if (project.isDefault()) return null;\n    final PsiManager psiManager = PsiManager.getInstance(project);\n    final String shortName = StringUtil.getShortName(mainClassName);\n    final String packageName = StringUtil.getPackageName(mainClassName);\n    return JavaPsiFacade.getInstance(psiManager.getProject())\n      .findClass(StringUtil.getQualifiedName(packageName, shortName.replace('$', '.')), scope);\n  }","id":97767,"modified_method":"@Nullable\n  public static PsiClass findMainClass(final Project project, final String mainClassName, final GlobalSearchScope scope) {\n    if (project.isDefault()) return null;\n    final PsiManager psiManager = PsiManager.getInstance(project);\n    final String shortName = StringUtil.getShortName(mainClassName);\n    final String packageName = StringUtil.getPackageName(mainClassName);\n    final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(psiManager.getProject());\n    final PsiClass psiClass = psiFacade.findClass(StringUtil.getQualifiedName(packageName, shortName.replace('$', '.')), scope);\n    return psiClass == null ? psiFacade.findClass(mainClassName, scope) : psiClass;\n  }","commit_id":"6bbbb5031fd420cf3e55bc56569a14aa0b20e5c6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * @return the DecorationModel instance from <code>site.xml<\/code>\n     * @throws MojoExecutionException if any\n     */\n    private DecorationModel getDefaultDecorationModel()\n        throws MojoExecutionException\n    {\n        if ( this.defaultDecorationModel == null )\n        {\n            Locale locale = getDefaultLocale();\n\n            File descriptorFile =\n                getSiteTool()\n                             .getSiteDescriptorFromBasedir(\n                                                            PathUtils.toRelative( project.getBasedir(),\n                                                                                  siteDirectory.getAbsolutePath() ),\n                                                            project.getBasedir(), locale );\n            DecorationModel decoration = null;\n            if ( descriptorFile.exists() )\n            {\n                Map props = new HashMap();\n\n                XmlStreamReader reader = null;\n                try\n                {\n                    reader = ReaderFactory.newXmlReader( descriptorFile );\n                    String siteDescriptorContent = IOUtil.toString( reader );\n\n                    siteDescriptorContent =\n                        getSiteTool().getInterpolatedSiteDescriptorContent( props, project, siteDescriptorContent,\n                                                                            reader.getEncoding(), \"UTF-8\" );\n\n                    decoration = new DecorationXpp3Reader().read( new StringReader( siteDescriptorContent ) );\n                }\n                catch ( XmlPullParserException e )\n                {\n                    throw new MojoExecutionException( \"Error parsing site descriptor\", e );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Error reading site descriptor\", e );\n                }\n                catch ( SiteToolException e )\n                {\n                    throw new MojoExecutionException( \"Error when interpoling site descriptor\", e );\n                }\n                finally\n                {\n                    IOUtil.close( reader );\n                }\n            }\n\n            this.defaultDecorationModel = decoration;\n        }\n\n        return this.defaultDecorationModel;\n    }","id":97768,"modified_method":"/**\n     * @return the DecorationModel instance from <code>site.xml<\/code>\n     * @throws MojoExecutionException if any\n     */\n    private DecorationModel getDefaultDecorationModel()\n        throws MojoExecutionException\n    {\n        if ( this.defaultDecorationModel == null )\n        {\n            Locale locale = getDefaultLocale();\n\n            File descriptorFile =\n                getSiteTool()\n                             .getSiteDescriptorFromBasedir(\n                                                            PathUtils.toRelative( project.getBasedir(),\n                                                                                  siteDirectory.getAbsolutePath() ),\n                                                            project.getBasedir(), locale );\n            DecorationModel decoration = null;\n            if ( descriptorFile.exists() )\n            {\n                Map props = new HashMap();\n\n                XmlStreamReader reader = null;\n                try\n                {\n                    reader = ReaderFactory.newXmlReader( descriptorFile );\n                    String siteDescriptorContent = IOUtil.toString( reader );\n\n                    siteDescriptorContent =\n                        getSiteTool().getInterpolatedSiteDescriptorContent( props, project, siteDescriptorContent,\n                                                                            reader.getEncoding(), reader.getEncoding() );\n\n                    decoration = new DecorationXpp3Reader().read( new StringReader( siteDescriptorContent ) );\n                }\n                catch ( XmlPullParserException e )\n                {\n                    throw new MojoExecutionException( \"Error parsing site descriptor\", e );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Error reading site descriptor\", e );\n                }\n                catch ( SiteToolException e )\n                {\n                    throw new MojoExecutionException( \"Error when interpoling site descriptor\", e );\n                }\n                finally\n                {\n                    IOUtil.close( reader );\n                }\n            }\n\n            this.defaultDecorationModel = decoration;\n        }\n\n        return this.defaultDecorationModel;\n    }","commit_id":"ef321dd0852309d7d528d9b9653e3db3e33cc8f4","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Read and filter the <code>docDescriptor<\/code> file.\n     *\n     * @param project not null\n     * @param docDescriptor not null\n     * @param log not null\n     * @return a DocumentModel instance\n     * @throws DocumentRendererException if any\n     * @throws IOException if any\n     */\n    private static DocumentModel readAndFilterDocumentDescriptor( MavenProject project, File docDescriptor, Log log )\n        throws DocumentRendererException, IOException\n    {\n        Reader reader = null;\n        try\n        {\n            // System properties\n            Properties filterProperties = new Properties( System.getProperties() );\n            // Project properties\n            if ( project != null && project.getProperties() != null )\n            {\n                filterProperties.putAll( project.getProperties() );\n            }\n\n            reader =\n                new InterpolationFilterReader( ReaderFactory.newXmlReader( docDescriptor ), filterProperties,\n                                               \"${\", \"}\" );\n            reader = new InterpolationFilterReader( reader, new ReflectionProperties( project, log ), \"${\", \"}\" );\n\n            return new DocumentXpp3Reader().read( reader );\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new DocumentRendererException( \"Error parsing document descriptor\", e );\n        }\n        finally\n        {\n            IOUtil.close( reader );\n        }\n    }","id":97769,"modified_method":"/**\n     * Read and filter the <code>docDescriptor<\/code> file.\n     *\n     * @param project not null\n     * @param docDescriptor not null\n     * @param log not null\n     * @return a DocumentModel instance\n     * @throws DocumentRendererException if any\n     * @throws IOException if any\n     */\n    private DocumentModel readAndFilterDocumentDescriptor( final MavenProject project, File docDescriptor, Log log )\n        throws DocumentRendererException, IOException\n    {\n        Reader reader = null;\n        try\n        {\n            // System properties\n            Properties filterProperties = System.getProperties();\n            // Project properties\n            if ( project != null && project.getProperties() != null )\n            {\n                filterProperties.putAll( project.getProperties() );\n            }\n\n            Interpolator interpolator = new RegexBasedInterpolator();\n            interpolator.addValueSource( new MapBasedValueSource( filterProperties ) );\n            interpolator.addValueSource( new EnvarBasedValueSource() );\n            interpolator.addValueSource( new ObjectBasedValueSource( project )\n            {\n                /** {@inheritDoc} */\n                public Object getValue( String expression )\n                {\n                    try\n                    {\n                        return ReflectionValueExtractor.evaluate( expression, project );\n                    }\n                    catch ( Exception e )\n                    {\n                        addFeedback( \"Failed to extract \\'\" + expression + \"\\' from: \" + project, e );\n                    }\n\n                    return null;\n                }\n            } );\n\n            reader = ReaderFactory.newXmlReader( docDescriptor );\n\n            String interpolatedDoc = interpolator.interpolate( IOUtil.toString( reader ) );\n\n            if ( getLog().isDebugEnabled() )\n            {\n                getLog().debug(\n                                \"Interpolated document descriptor (\" + docDescriptor.getAbsolutePath() + \")\\n\"\n                                    + interpolatedDoc );\n            }\n\n            // No Strict\n            return new DocumentXpp3Reader().read( new StringReader( interpolatedDoc ), false );\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new DocumentRendererException( \"Error parsing document descriptor\", e );\n        }\n        catch ( InterpolationException e )\n        {\n            throw new DocumentRendererException( \"Error interpolating document descriptor\", e );\n        }\n        finally\n        {\n            IOUtil.close( reader );\n        }\n    }","commit_id":"ef321dd0852309d7d528d9b9653e3db3e33cc8f4","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @throws Exception if any.\n     */\n    public void testPdfFilterMojo() throws Exception\n    {\n        File testPom = new File( getBasedir(), \"/target/test-classes/unit/pdf/pom_filtering.xml\" );\n        assertTrue( \"testPom does not exist!\", testPom.exists() );\n\n        PdfMojo mojo = (PdfMojo) lookupMojo( \"pdf\", testPom );\n        assertNotNull( \"pdf mojo not found!\", mojo );\n\n        File pdfFile = new File( getBasedir(), \"/target/test-output/pdf/maven-pdf-plugin-doc-1.0-SNAPSHOT.pdf\" );\n        if ( pdfFile.exists() )\n        {\n            pdfFile.delete();\n        }\n\n        mojo.execute();\n\n        assertTrue( \"FO: Pdf file not created!\", pdfFile.exists() );\n        assertTrue( \"FO: Pdf file has no content!\", pdfFile.length() > 0 );\n\n        File foFile = new File( getBasedir(), \"/target/test-output/pdf/maven-pdf-plugin-doc-1.0-SNAPSHOT.fo\" );\n        assertTrue( \"FO: Fo file not created!\", foFile.exists() );\n        assertTrue( \"FO: Fo file has no content!\", foFile.length() > 0 );\n\n        Reader reader = null;\n        String foContent;\n        try\n        {\n            reader = ReaderFactory.newXmlReader( foFile );\n            foContent = IOUtil.toString( reader );\n        }\n        finally\n        {\n            IOUtil.close( reader );\n        }\n        assertTrue( foContent.indexOf( \">Test filtering<\" ) > 0 );\n    }","id":97770,"modified_method":"/**\n     * @throws Exception if any.\n     */\n    public void testPdfFilterMojo() throws Exception\n    {\n        File testPom = new File( getBasedir(), \"/target/test-classes/unit/pdf/pom_filtering.xml\" );\n        assertTrue( \"testPom does not exist!\", testPom.exists() );\n\n        PdfMojo mojo = (PdfMojo) lookupMojo( \"pdf\", testPom );\n        assertNotNull( \"pdf mojo not found!\", mojo );\n\n        File pdfFile = new File( getBasedir(), \"/target/test-output/pdf/maven-pdf-plugin-doc-1.0-SNAPSHOT.pdf\" );\n        if ( pdfFile.exists() )\n        {\n            pdfFile.delete();\n        }\n\n        mojo.execute();\n\n        assertTrue( \"FO: Pdf file not created!\", pdfFile.exists() );\n        assertTrue( \"FO: Pdf file has no content!\", pdfFile.length() > 0 );\n\n        File foFile = new File( getBasedir(), \"/target/test-output/pdf/maven-pdf-plugin-doc-1.0-SNAPSHOT.fo\" );\n        assertTrue( \"FO: Fo file not created!\", foFile.exists() );\n        assertTrue( \"FO: Fo file has no content!\", foFile.length() > 0 );\n\n        Reader reader = null;\n        String foContent;\n        try\n        {\n            reader = ReaderFactory.newXmlReader( foFile );\n            foContent = IOUtil.toString( reader );\n        }\n        finally\n        {\n            IOUtil.close( reader );\n        }\n        // ${pom.name}\n        assertTrue( foContent.indexOf( \"Test filtering\" ) > 0 );\n        assertTrue( foContent.indexOf( \"1.0-SNAPSHOT\" ) > 0 );\n        // env ${M2_HOME}\n        String m2Home = CommandLineUtils.getSystemEnvVars().getProperty( \"M2_HOME\" );\n        if ( StringUtils.isNotEmpty( m2Home ) )\n        {\n            assertTrue( foContent.indexOf( m2Home ) > 0 );\n        }\n        // ${project.developers[0].email}\n        assertTrue( foContent.indexOf( \"vsiveton@apache.org ltheussl@apache.org\" ) > 0 );\n    }","commit_id":"ef321dd0852309d7d528d9b9653e3db3e33cc8f4","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void processResource( InputStream is )\n        throws IOException\n    {\n\n    }","id":97771,"modified_method":"public void processResource( String resource, InputStream is, List relocators )\n        throws IOException\n    {\n\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void processResource( InputStream is )\n        throws IOException\n    {\n        if ( entries.isEmpty() )\n        {\n            String year = new SimpleDateFormat( \"yyyy\" ).format( new Date() );\n            if ( !inceptionYear.equals( year ) )\n            {\n                year = inceptionYear + \"-\" + year;\n            }\n\n\n            //add headers\n            if ( addHeader ) \n            {\n                entries.add( preamble1 + projectName + preamble2 );\n            }\n            else\n            {\n                entries.add( \"\" );\n            }\n            //fake second entry, we'll look for a real one later\n            entries.add( projectName + \"\\nCopyright \" + year + \" \" + organizationName + \"\\n\" );\n            entries.add( preamble3 + organizationName + \" (\" + organizationURL + \").\\n\" );\n        }\n\n\n        BufferedReader reader;\n        if ( StringUtils.isNotEmpty( encoding ) )\n        {\n            reader = new BufferedReader( new InputStreamReader( is, encoding ) );\n        }\n        else\n        {\n            reader = new BufferedReader( new InputStreamReader( is ) );\n        }\n\n        String line = reader.readLine();\n        StringBuffer sb = new StringBuffer();\n        Set currentOrg = null;\n        int lineCount = 0;\n        while ( line != null )\n        {\n            String trimedLine = line.trim();\n\n            if ( !trimedLine.startsWith( \"//\" ) )\n            {\n                if ( trimedLine.length() > 0 )\n                {\n                    if ( trimedLine.startsWith( \"- \" ) )\n                    {\n                        //resource-bundle 1.3 mode\n                        if ( lineCount == 1\n                            && sb.toString().indexOf( \"This product includes/uses software(s) developed by\" ) != -1 )\n                        {\n                            currentOrg = (Set) organizationEntries.get( sb.toString().trim() );\n                            if ( currentOrg == null )\n                            {\n                                currentOrg = new TreeSet();\n                                organizationEntries.put( sb.toString().trim(), currentOrg );\n                            }\n                            sb = new StringBuffer();\n                        }\n                        else if ( sb.length() > 0 && currentOrg != null )\n                        {\n                            currentOrg.add( sb.toString() );\n                            sb = new StringBuffer();\n                        }\n\n                    }\n                    sb.append( line ).append( \"\\n\" );\n                    lineCount++;\n                }\n                else\n                {\n                    String ent = sb.toString();\n                    if ( ent.startsWith( projectName )\n                        && ent.indexOf( \"Copyright \" ) != -1 )\n                    {\n                        copyright = ent;\n                    }\n                    if ( currentOrg == null )\n                    {\n                        entries.add( ent );\n                    }\n                    else\n                    {\n                        currentOrg.add( ent );\n                    }\n                    sb = new StringBuffer();\n                    lineCount = 0;\n                    currentOrg = null;\n                }\n            }\n\n            line = reader.readLine();\n        }\n        if ( sb.length() > 0 ) \n        {\n            if ( currentOrg == null )\n            {\n                entries.add( sb.toString() );\n            }\n            else\n            {\n                currentOrg.add( sb.toString() );\n            }\n        }\n    }","id":97772,"modified_method":"public void processResource( String resource, InputStream is, List relocators )\n        throws IOException\n    {\n        if ( entries.isEmpty() )\n        {\n            String year = new SimpleDateFormat( \"yyyy\" ).format( new Date() );\n            if ( !inceptionYear.equals( year ) )\n            {\n                year = inceptionYear + \"-\" + year;\n            }\n\n\n            //add headers\n            if ( addHeader ) \n            {\n                entries.add( preamble1 + projectName + preamble2 );\n            }\n            else\n            {\n                entries.add( \"\" );\n            }\n            //fake second entry, we'll look for a real one later\n            entries.add( projectName + \"\\nCopyright \" + year + \" \" + organizationName + \"\\n\" );\n            entries.add( preamble3 + organizationName + \" (\" + organizationURL + \").\\n\" );\n        }\n\n\n        BufferedReader reader;\n        if ( StringUtils.isNotEmpty( encoding ) )\n        {\n            reader = new BufferedReader( new InputStreamReader( is, encoding ) );\n        }\n        else\n        {\n            reader = new BufferedReader( new InputStreamReader( is ) );\n        }\n\n        String line = reader.readLine();\n        StringBuffer sb = new StringBuffer();\n        Set currentOrg = null;\n        int lineCount = 0;\n        while ( line != null )\n        {\n            String trimedLine = line.trim();\n\n            if ( !trimedLine.startsWith( \"//\" ) )\n            {\n                if ( trimedLine.length() > 0 )\n                {\n                    if ( trimedLine.startsWith( \"- \" ) )\n                    {\n                        //resource-bundle 1.3 mode\n                        if ( lineCount == 1\n                            && sb.toString().indexOf( \"This product includes/uses software(s) developed by\" ) != -1 )\n                        {\n                            currentOrg = (Set) organizationEntries.get( sb.toString().trim() );\n                            if ( currentOrg == null )\n                            {\n                                currentOrg = new TreeSet();\n                                organizationEntries.put( sb.toString().trim(), currentOrg );\n                            }\n                            sb = new StringBuffer();\n                        }\n                        else if ( sb.length() > 0 && currentOrg != null )\n                        {\n                            currentOrg.add( sb.toString() );\n                            sb = new StringBuffer();\n                        }\n\n                    }\n                    sb.append( line ).append( \"\\n\" );\n                    lineCount++;\n                }\n                else\n                {\n                    String ent = sb.toString();\n                    if ( ent.startsWith( projectName )\n                        && ent.indexOf( \"Copyright \" ) != -1 )\n                    {\n                        copyright = ent;\n                    }\n                    if ( currentOrg == null )\n                    {\n                        entries.add( ent );\n                    }\n                    else\n                    {\n                        currentOrg.add( ent );\n                    }\n                    sb = new StringBuffer();\n                    lineCount = 0;\n                    currentOrg = null;\n                }\n            }\n\n            line = reader.readLine();\n        }\n        if ( sb.length() > 0 ) \n        {\n            if ( currentOrg == null )\n            {\n                entries.add( sb.toString() );\n            }\n            else\n            {\n                currentOrg.add( sb.toString() );\n            }\n        }\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void processResource( InputStream is )\n        throws IOException\n    {\n        IOUtil.copy( is, data );\n        data.write( '\\n' );\n\n        is.close();\n    }","id":97773,"modified_method":"public void processResource( String resource, InputStream is, List relocators )\n        throws IOException\n    {\n        IOUtil.copy( is, data );\n        data.write( '\\n' );\n\n        is.close();\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void modifyOutputStream( JarOutputStream jos )\n        throws IOException\n    {\n        Reader reader = ReaderFactory.newXmlReader( getTransformedResource() );\n\n        jos.putNextEntry( new JarEntry( COMPONENTS_XML_PATH ) );\n\n        IOUtil.copy( reader, jos );\n\n        reader.close();\n\n        components.clear();\n    }","id":97774,"modified_method":"public void modifyOutputStream( JarOutputStream jos )\n        throws IOException\n    {\n        byte[] data = getTransformedResource();\n\n        jos.putNextEntry( new JarEntry( COMPONENTS_XML_PATH ) );\n\n        IOUtil.copy( data, jos );\n\n        components.clear();\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"public boolean hasTransformedResource()\n    {\n        return components.size() > 0;\n    }","id":97775,"modified_method":"public boolean hasTransformedResource()\n    {\n        return !components.isEmpty();\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"public File getTransformedResource()\n        throws IOException\n    {\n        File f = File.createTempFile( \"shade-maven-plugin-plx\", \"tmp\" );\n\n        f.deleteOnExit();\n\n        Writer writer = WriterFactory.newXmlWriter( f );\n        try\n        {\n            Xpp3Dom dom = new Xpp3Dom( \"component-set\" );\n\n            Xpp3Dom componentDom = new Xpp3Dom( \"components\" );\n\n            dom.addChild( componentDom );\n\n            for ( Iterator i = components.values().iterator(); i.hasNext(); )\n            {\n                Xpp3Dom component = (Xpp3Dom) i.next();\n                componentDom.addChild( component );\n            }\n\n            Xpp3DomWriter.write( writer, dom );\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n\n        return f;\n    }","id":97776,"modified_method":"byte[] getTransformedResource()\n        throws IOException\n    {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream( 1024 * 4 );\n\n        Writer writer = WriterFactory.newXmlWriter( baos );\n        try\n        {\n            Xpp3Dom dom = new Xpp3Dom( \"component-set\" );\n\n            Xpp3Dom componentDom = new Xpp3Dom( \"components\" );\n\n            dom.addChild( componentDom );\n\n            for ( Iterator i = components.values().iterator(); i.hasNext(); )\n            {\n                Xpp3Dom component = (Xpp3Dom) i.next();\n                componentDom.addChild( component );\n            }\n\n            Xpp3DomWriter.write( writer, dom );\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n\n        return baos.toByteArray();\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void processResource( InputStream is )\n        throws IOException\n    {\n        // We can't just read the stream because the plexus dom builder closes the stream\n\n        File f = File.createTempFile( \"maven-shade-plugin\", \"tmp\" );\n\n        f.deleteOnExit();\n\n        OutputStream os = new FileOutputStream( f );\n\n        IOUtil.copy( is, os );\n\n        os.close();\n\n        //\n\n        Reader reader;\n\n        Xpp3Dom newDom;\n\n        try\n        {\n            reader = ReaderFactory.newXmlReader( f );\n\n            newDom = Xpp3DomBuilder.build( reader );\n        }\n        catch ( Exception e )\n        {\n            throw new IOException( \"Error parsing components.xml in \" + is );\n        }\n\n        // Only try to merge in components if there are some elements in the component-set\n        if ( newDom.getChild( \"components\" ) == null )\n        {\n            return;\n        }\n\n        Xpp3Dom[] children = newDom.getChild( \"components\" ).getChildren( \"component\" );\n\n        for ( int i = 0; i < children.length; i++ )\n        {\n            Xpp3Dom component = children[i];\n\n            String role = component.getChild( \"role\" ).getValue();\n\n            Xpp3Dom child = component.getChild( \"role-hint\" );\n\n            String roleHint = child != null ? child.getValue() : \"\";\n\n            String key = role + roleHint;\n            if ( components.containsKey( key ) )\n            {\n                // TODO: use the tools in Plexus to merge these properly. For now, I just need an all-or-nothing\n                // configuration carry over\n\n                Xpp3Dom dom = (Xpp3Dom) components.get( key );\n                if ( dom.getChild( \"configuration\" ) != null )\n                {\n                    component.addChild( dom.getChild( \"configuration\" ) );\n                }\n            }\n\n            components.put( key, component );\n        }\n    }","id":97777,"modified_method":"public void processResource( String resource, InputStream is, List relocators )\n        throws IOException\n    {\n        Xpp3Dom newDom;\n\n        try\n        {\n            BufferedInputStream bis = new BufferedInputStream( is )\n            {\n                public void close()\n                    throws IOException\n                {\n                    // leave ZIP open\n                }\n            };\n\n            Reader reader = ReaderFactory.newXmlReader( bis );\n\n            newDom = Xpp3DomBuilder.build( reader );\n        }\n        catch ( Exception e )\n        {\n            throw (IOException) new IOException( \"Error parsing components.xml in \" + is ).initCause( e );\n        }\n\n        // Only try to merge in components if there are some elements in the component-set\n        if ( newDom.getChild( \"components\" ) == null )\n        {\n            return;\n        }\n\n        Xpp3Dom[] children = newDom.getChild( \"components\" ).getChildren( \"component\" );\n\n        for ( int i = 0; i < children.length; i++ )\n        {\n            Xpp3Dom component = children[i];\n\n            String role = getValue( component, \"role\" );\n            role = getRelocatedClass( role, relocators );\n            setValue( component, \"role\", role );\n\n            String roleHint = getValue( component, \"role-hint\" );\n\n            String impl = getValue( component, \"implementation\" );\n            impl = getRelocatedClass( impl, relocators );\n            setValue( component, \"implementation\", impl );\n\n            String key = role + ':' + roleHint;\n            if ( components.containsKey( key ) )\n            {\n                // TODO: use the tools in Plexus to merge these properly. For now, I just need an all-or-nothing\n                // configuration carry over\n\n                Xpp3Dom dom = (Xpp3Dom) components.get( key );\n                if ( dom.getChild( \"configuration\" ) != null )\n                {\n                    component.addChild( dom.getChild( \"configuration\" ) );\n                }\n            }\n\n            Xpp3Dom requirements = component.getChild( \"requirements\" );\n            if ( requirements != null && requirements.getChildCount() > 0 )\n            {\n                for ( int r = requirements.getChildCount() - 1; r >= 0; r-- )\n                {\n                    Xpp3Dom requirement = requirements.getChild( r );\n\n                    String requiredRole = getValue( requirement, \"role\" );\n                    requiredRole = getRelocatedClass( requiredRole, relocators );\n                    setValue( requirement, \"role\", requiredRole );\n                }\n            }\n\n            components.put( key, component );\n        }\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testConfigurationMerging() throws IOException\n    {\n        transformer.processResource( getClass().getResourceAsStream( \"/components-1.xml\" ) );\n        transformer.processResource( getClass().getResourceAsStream( \"/components-2.xml\" ) );\n\n        assertEquals( IOUtil.toString( getClass().getResourceAsStream( \"/components-expected.xml\" ) ),\n                      FileUtils.fileRead( transformer.getTransformedResource() ) );\n    }","id":97778,"modified_method":"public void testConfigurationMerging() throws IOException\n    {\n        transformer.processResource( \"components-1.xml\", getClass().getResourceAsStream( \"/components-1.xml\" ),\n                                     Collections.EMPTY_LIST );\n        transformer.processResource( \"components-1.xml\", getClass().getResourceAsStream( \"/components-2.xml\" ),\n                                     Collections.EMPTY_LIST );\n\n        assertEquals( IOUtil.toString( getClass().getResourceAsStream( \"/components-expected.xml\" ), \"UTF-8\" ),\n                      IOUtil.toString( transformer.getTransformedResource(), \"UTF-8\" ) );\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"private boolean resourceTransformed( List resourceTransformers, String name, InputStream is )\n        throws IOException\n    {\n        boolean resourceTransformed = false;\n\n        for ( Iterator k = resourceTransformers.iterator(); k.hasNext(); )\n        {\n            ResourceTransformer transformer = (ResourceTransformer) k.next();\n\n            if ( transformer.canTransformResource( name ) )\n            {\n                transformer.processResource( is );\n\n                resourceTransformed = true;\n\n                break;\n            }\n        }\n        return resourceTransformed;\n    }","id":97779,"modified_method":"private boolean resourceTransformed( List resourceTransformers, String name, InputStream is, List relocators )\n        throws IOException\n    {\n        boolean resourceTransformed = false;\n\n        for ( Iterator k = resourceTransformers.iterator(); k.hasNext(); )\n        {\n            ResourceTransformer transformer = (ResourceTransformer) k.next();\n\n            if ( transformer.canTransformResource( name ) )\n            {\n                transformer.processResource( name, is, relocators );\n\n                resourceTransformed = true;\n\n                break;\n            }\n        }\n        return resourceTransformed;\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void shade( Set jars, File uberJar, List filters, List relocators, List resourceTransformers )\n    throws IOException\n    {\n        Set resources = new HashSet();\n\n        RelocatorRemapper remapper = new RelocatorRemapper( relocators );\n\n        uberJar.getParentFile().mkdirs();\n        JarOutputStream jos = new JarOutputStream( new FileOutputStream( uberJar ) );\n\n        for ( Iterator i = jars.iterator(); i.hasNext(); )\n        {\n            File jar = (File) i.next();\n\n            List jarFilters = getFilters( jar, filters );\n\n            JarFile jarFile;\n            \n            try \n            {\n                jarFile = new JarFile( jar );\n            }\n            catch (ZipException zex)\n            {\n                // JarFile is not very verbose and doesn't tell the user which file it was\n                // so we will create a new Exception instead\n                throw new ZipException( \"error in opening zip file \" + jar );\n            }\n\n            for ( Enumeration j = jarFile.entries(); j.hasMoreElements(); )\n            {\n                JarEntry entry = (JarEntry) j.nextElement();\n\n                String name = entry.getName();\n                if ( \"META-INF/INDEX.LIST\".equals( name ) ) \n                {\n                    //we cannot allow the jar indexes to be copied over or the \n                    //jar is useless.   Ideally, we could create a new one\n                    //later\n                    continue;\n                }\n\n                String mappedName = remapper.map( name );\n\n                InputStream is = jarFile.getInputStream( entry );\n                if ( !entry.isDirectory() && !isFiltered( jarFilters, name ) )\n                {\n                    int idx = mappedName.lastIndexOf( '/' );\n                    if ( idx != -1 )\n                    {\n                        //make sure dirs are created\n                        String dir = mappedName.substring( 0, idx );\n                        if ( !resources.contains( dir ) )\n                        {\n                            addDirectory( resources, jos, dir );\n                        }\n                    }\n\n                    if ( name.endsWith( \".class\" ) )\n                    {\n                        addRemappedClass( remapper, jos, jar, name, is );\n                    }\n                    else\n                    {\n                        if ( !resourceTransformed( resourceTransformers, mappedName, is ) )\n                        {\n                            // Avoid duplicates that aren't accounted for by the resource transformers\n                            if ( resources.contains( mappedName ) )\n                            {\n                                continue;\n                            }\n\n                            addResource( resources, jos, mappedName, is );\n                        }\n                    }\n                }\n\n                IOUtil.close( is );\n            }\n\n            jarFile.close();\n        }\n\n        for ( Iterator i = resourceTransformers.iterator(); i.hasNext(); )\n        {\n            ResourceTransformer transformer = (ResourceTransformer) i.next();\n\n            if ( transformer.hasTransformedResource() )\n            {\n                transformer.modifyOutputStream( jos );\n            }\n        }\n\n        IOUtil.close( jos );\n    }","id":97780,"modified_method":"public void shade( Set jars, File uberJar, List filters, List relocators, List resourceTransformers )\n    throws IOException\n    {\n        Set resources = new HashSet();\n\n        RelocatorRemapper remapper = new RelocatorRemapper( relocators );\n\n        uberJar.getParentFile().mkdirs();\n        JarOutputStream jos = new JarOutputStream( new FileOutputStream( uberJar ) );\n\n        for ( Iterator i = jars.iterator(); i.hasNext(); )\n        {\n            File jar = (File) i.next();\n\n            List jarFilters = getFilters( jar, filters );\n\n            JarFile jarFile;\n            \n            try \n            {\n                jarFile = new JarFile( jar );\n            }\n            catch (ZipException zex)\n            {\n                // JarFile is not very verbose and doesn't tell the user which file it was\n                // so we will create a new Exception instead\n                throw new ZipException( \"error in opening zip file \" + jar );\n            }\n\n            for ( Enumeration j = jarFile.entries(); j.hasMoreElements(); )\n            {\n                JarEntry entry = (JarEntry) j.nextElement();\n\n                String name = entry.getName();\n\n                if ( \"META-INF/INDEX.LIST\".equals( name ) ) \n                {\n                    //we cannot allow the jar indexes to be copied over or the \n                    //jar is useless.   Ideally, we could create a new one\n                    //later\n                    continue;\n                }\n\n                if ( !entry.isDirectory() && !isFiltered( jarFilters, name ) )\n                {\n                    InputStream is = jarFile.getInputStream( entry );\n\n                    String mappedName = remapper.map( name );\n\n                    int idx = mappedName.lastIndexOf( '/' );\n                    if ( idx != -1 )\n                    {\n                        //make sure dirs are created\n                        String dir = mappedName.substring( 0, idx );\n                        if ( !resources.contains( dir ) )\n                        {\n                            addDirectory( resources, jos, dir );\n                        }\n                    }\n\n                    if ( name.endsWith( \".class\" ) )\n                    {\n                        addRemappedClass( remapper, jos, jar, name, is );\n                    }\n                    else\n                    {\n                        if ( !resourceTransformed( resourceTransformers, mappedName, is, relocators ) )\n                        {\n                            // Avoid duplicates that aren't accounted for by the resource transformers\n                            if ( resources.contains( mappedName ) )\n                            {\n                                continue;\n                            }\n\n                            addResource( resources, jos, mappedName, is );\n                        }\n                    }\n\n                    IOUtil.close( is );\n                }\n            }\n\n            jarFile.close();\n        }\n\n        for ( Iterator i = resourceTransformers.iterator(); i.hasNext(); )\n        {\n            ResourceTransformer transformer = (ResourceTransformer) i.next();\n\n            if ( transformer.hasTransformedResource() )\n            {\n                transformer.modifyOutputStream( jos );\n            }\n        }\n\n        IOUtil.close( jos );\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void processResource( InputStream is )\n        throws IOException\n    {\n\n    }","id":97781,"modified_method":"public void processResource( String resource, InputStream is, List relocators )\n        throws IOException\n    {\n\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void processResource( InputStream is )\n        throws IOException\n    {\n\n    }","id":97782,"modified_method":"public void processResource( String resource, InputStream is, List relocators )\n        throws IOException\n    {\n\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void processResource( InputStream is )\n        throws IOException\n    {\n        // We just want to take the first manifest we come across as that's our project's manifest. This is the behavior\n        // now which is situational at best. Right now there is no context passed in with the processing so we cannot\n        // tell what artifact is being processed.\n        if ( !manifestDiscovered )\n        {\n            manifest = new Manifest( is );\n            manifestDiscovered = true;\n            IOUtil.close( is );\n        }\n    }","id":97783,"modified_method":"public void processResource( String resource, InputStream is, List relocators )\n        throws IOException\n    {\n        // We just want to take the first manifest we come across as that's our project's manifest. This is the behavior\n        // now which is situational at best. Right now there is no context passed in with the processing so we cannot\n        // tell what artifact is being processed.\n        if ( !manifestDiscovered )\n        {\n            manifest = new Manifest( is );\n            manifestDiscovered = true;\n            IOUtil.close( is );\n        }\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void processResource( InputStream is )\n        throws IOException\n    {\n        IOUtil.copy( is, data );\n        is.close();\n    }","id":97784,"modified_method":"public void processResource( String resource, InputStream is, List relocators )\n        throws IOException\n    {\n        IOUtil.copy( is, data );\n        is.close();\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void processResource( InputStream is )\n        throws IOException\n    {\n        Document r;\n        try\n        {\n            r = new SAXBuilder().build( is );\n        }\n        catch ( JDOMException e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        if ( doc == null )\n        {\n            doc = r;\n        }\n        else\n        {\n            Element root = r.getRootElement();\n\n            for ( Iterator itr = root.getAttributes().iterator(); itr.hasNext(); )\n            {\n                Attribute a = (Attribute) itr.next();\n                itr.remove();\n\n                Element mergedEl = doc.getRootElement();\n                Attribute mergedAtt = mergedEl.getAttribute( a.getName(), a.getNamespace() );\n                if ( mergedAtt == null )\n                {\n                    mergedEl.setAttribute( a );\n                }\n            }\n\n            for ( Iterator itr = root.getChildren().iterator(); itr.hasNext(); )\n            {\n                Content n = (Content) itr.next();\n                itr.remove();\n\n                doc.getRootElement().addContent( n );\n            }\n        }\n    }","id":97785,"modified_method":"public void processResource( String resource, InputStream is, List relocators )\n        throws IOException\n    {\n        Document r;\n        try\n        {\n            r = new SAXBuilder().build( is );\n        }\n        catch ( JDOMException e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        if ( doc == null )\n        {\n            doc = r;\n        }\n        else\n        {\n            Element root = r.getRootElement();\n\n            for ( Iterator itr = root.getAttributes().iterator(); itr.hasNext(); )\n            {\n                Attribute a = (Attribute) itr.next();\n                itr.remove();\n\n                Element mergedEl = doc.getRootElement();\n                Attribute mergedAtt = mergedEl.getAttribute( a.getName(), a.getNamespace() );\n                if ( mergedAtt == null )\n                {\n                    mergedEl.setAttribute( a );\n                }\n            }\n\n            for ( Iterator itr = root.getChildren().iterator(); itr.hasNext(); )\n            {\n                Content n = (Content) itr.next();\n                itr.remove();\n\n                doc.getRootElement().addContent( n );\n            }\n        }\n    }","commit_id":"3052e3bd1e369b3f2031099704134957c3138135","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Interpolates the specified POM/settings file to a temporary file.\n     * \n     * @param originalFile The XML file to interpolate, must not be <code>null<\/code>.\n     * @param interpolatedFile The target file to write the interpolated contents of the original file to, must not be\n     *            <code>null<\/code>.\n     * @throws MojoExecutionException If the target file could not be created.\n     */\n    void buildInterpolatedFile( File originalFile, File interpolatedFile )\n        throws MojoExecutionException\n    {\n        if ( interpolatedFile.exists() )\n        {\n            interpolatedFile.delete();\n        }\n        try\n        {\n            if ( !interpolatedFile.createNewFile() )\n            {\n                throw new MojoExecutionException( \"failed to create file \" + interpolatedFile.getPath() );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"failed to create file \" + interpolatedFile.getPath(), e );\n        }\n        getLog().debug( \"interpolate file to create interpolated in \" + interpolatedFile.getPath() );\n\n        BufferedReader reader = null;\n        BufferedWriter writer = null;\n        try\n        {\n            // interpolation with token @...@\n            Map composite = getInterpolationValueSource();\n            reader =\n                new BufferedReader( new InterpolationFilterReader( ReaderFactory.newXmlReader( originalFile ),\n                                                                   composite, \"@\", \"@\" ) );\n            writer = new BufferedWriter( WriterFactory.newXmlWriter( interpolatedFile ) );\n            String line = null;\n            while ( ( line = reader.readLine() ) != null )\n            {\n                writer.write( line );\n                writer.newLine();\n            }\n            writer.flush();\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"failed to interpolate file \" + originalFile.getPath(), e );\n        }\n        finally\n        {\n            // IOUtil in p-u is null check and silently NPE\n            IOUtil.close( reader );\n            IOUtil.close( writer );\n        }\n    }","id":97786,"modified_method":"/**\n     * Interpolates the specified POM/settings file to a temporary file. The destination file may be same as the input\n     * file, i.e. interpolation can be performed in-place.\n     * \n     * @param originalFile The XML file to interpolate, must not be <code>null<\/code>.\n     * @param interpolatedFile The target file to write the interpolated contents of the original file to, must not be\n     *            <code>null<\/code>.\n     * @throws MojoExecutionException If the target file could not be created.\n     */\n    void buildInterpolatedFile( File originalFile, File interpolatedFile )\n        throws MojoExecutionException\n    {\n        getLog().debug( \"Interpolate \" + originalFile.getPath() + \" to \" + interpolatedFile.getPath() );\n\n        try\n        {\n            String xml;\n\n            Reader reader = null;\n            try\n            {\n                // interpolation with token @...@\n                Map composite = getInterpolationValueSource();\n                reader = ReaderFactory.newXmlReader( originalFile );\n                reader = new InterpolationFilterReader( reader, composite, \"@\", \"@\" );\n                xml = IOUtil.toString( reader );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n\n            Writer writer = null;\n            try\n            {\n                interpolatedFile.getParentFile().mkdirs();\n                writer = WriterFactory.newXmlWriter( interpolatedFile );\n                writer.write( xml );\n                writer.flush();\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Failed to interpolate file \" + originalFile.getPath(), e );\n        }\n    }","commit_id":"582058b3abf8c02052ed3cf5a4daa79ae765ebd8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Runs the specified project.\n     * \n     * @param projectsDir The base directory of all projects, must not be <code>null<\/code>.\n     * @param project The relative path to the project, either to a POM file or merely to a directory, must not be\n     *            <code>null<\/code>.\n     * @param settingsFile The (already interpolated) user settings file for the build, may be <code>null<\/code> to use\n     *            the current user settings.\n     * @throws MojoExecutionException If the project could not be launched.\n     * @throws BuildFailureException If either a hook script or the build itself failed.\n     */\n    private void runBuild( File projectsDir, String project, File settingsFile )\n        throws MojoExecutionException, BuildFailureException\n    {\n        File pomFile = new File( projectsDir, project );\n        File basedir;\n        if ( pomFile.isDirectory() )\n        {\n            basedir = pomFile;\n            pomFile = new File( basedir, \"pom.xml\" );\n            if ( !pomFile.exists() )\n            {\n                pomFile = null;\n            }\n            else\n            {\n                project += File.separator + \"pom.xml\";\n            }\n        }\n        else\n        {\n            basedir = pomFile.getParentFile();\n        }\n\n        getLog().info( \"Building: \" + project );\n\n        File interpolatedPomFile = null;\n        if ( pomFile != null )\n        {\n            interpolatedPomFile = new File( basedir, \"interpolated-\" + pomFile.getName() );\n            buildInterpolatedFile( pomFile, interpolatedPomFile );\n        }\n\n        try\n        {\n            runBuild( basedir, interpolatedPomFile, settingsFile );\n\n            if ( !suppressSummaries )\n            {\n                getLog().info( \"...SUCCESS.\" );\n            }\n        }\n        catch ( BuildFailureException e )\n        {\n            if ( !suppressSummaries )\n            {\n                getLog().info( \"...FAILED. \" + e.getMessage() );\n            }\n            throw e;\n        }\n        finally\n        {\n            if ( interpolatedPomFile != null )\n            {\n                interpolatedPomFile.delete();\n            }\n        }\n    }","id":97787,"modified_method":"/**\n     * Runs the specified project.\n     * \n     * @param projectsDir The base directory of all projects, must not be <code>null<\/code>.\n     * @param project The relative path to the project, either to a POM file or merely to a directory, must not be\n     *            <code>null<\/code>.\n     * @param settingsFile The (already interpolated) user settings file for the build, may be <code>null<\/code> to use\n     *            the current user settings.\n     * @throws MojoExecutionException If the project could not be launched.\n     * @throws BuildFailureException If either a hook script or the build itself failed.\n     */\n    private void runBuild( File projectsDir, String project, File settingsFile )\n        throws MojoExecutionException, BuildFailureException\n    {\n        File pomFile = new File( projectsDir, project );\n        File basedir;\n        if ( pomFile.isDirectory() )\n        {\n            basedir = pomFile;\n            pomFile = new File( basedir, \"pom.xml\" );\n            if ( !pomFile.exists() )\n            {\n                pomFile = null;\n            }\n            else\n            {\n                project += File.separator + \"pom.xml\";\n            }\n        }\n        else\n        {\n            basedir = pomFile.getParentFile();\n        }\n\n        getLog().info( \"Building: \" + project );\n\n        File interpolatedPomFile = null;\n        if ( pomFile != null )\n        {\n            interpolatedPomFile = new File( basedir, filteredPomPrefix + pomFile.getName() );\n            buildInterpolatedFile( pomFile, interpolatedPomFile );\n        }\n\n        try\n        {\n            runBuild( basedir, interpolatedPomFile, settingsFile );\n\n            if ( !suppressSummaries )\n            {\n                getLog().info( \"...SUCCESS.\" );\n            }\n        }\n        catch ( BuildFailureException e )\n        {\n            if ( !suppressSummaries )\n            {\n                getLog().info( \"...FAILED. \" + e.getMessage() );\n            }\n            throw e;\n        }\n        finally\n        {\n            if ( interpolatedPomFile != null && StringUtils.isNotEmpty( filteredPomPrefix ) )\n            {\n                interpolatedPomFile.delete();\n            }\n        }\n    }","commit_id":"582058b3abf8c02052ed3cf5a4daa79ae765ebd8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Invokes Maven on the configured test projects.\n     * \n     * @throws MojoExecutionException If the goal encountered severe errors.\n     * @throws MojoFailureException If any of the Maven builds failed.\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( skipInvocation )\n        {\n            getLog().info( \"Skipping invocation per configuration.\"\n                + \" If this is incorrect, ensure the skipInvocation parameter is not set to true.\" );\n            return;\n        }\n\n        String[] includedPoms;\n        if ( pom != null )\n        {\n            try\n            {\n                projectsDirectory = pom.getCanonicalFile().getParentFile();\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Failed to discover projectsDirectory from pom File parameter.\"\n                    + \" Reason: \" + e.getMessage(), e );\n            }\n\n            includedPoms = new String[]{ pom.getName() };\n        }\n        else\n        {\n            try\n            {\n                includedPoms = getPoms();\n            }\n            catch ( final IOException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving POM list from includes, excludes, \"\n                                + \"and projects directory. Reason: \" + e.getMessage(), e );\n            }\n        }\n\n\n        if ( ( includedPoms == null ) || ( includedPoms.length < 1 ) )\n        {\n            getLog().info( \"No test projects were selected for execution.\" );\n            return;\n        }\n\n        if ( StringUtils.isEmpty( encoding ) )\n        {\n            getLog().warn(\n                           \"File encoding has not been set, using platform encoding \" + ReaderFactory.FILE_ENCODING\n                               + \", i.e. build is platform dependent!\" );\n        }\n\n        scriptInterpreters = new LinkedHashMap();\n        scriptInterpreters.put( \"bsh\", new BeanShellScriptInterpreter() );\n        scriptInterpreters.put( \"groovy\", new GroovyScriptInterpreter() );\n\n        File projectsDir = projectsDirectory;\n\n        if ( cloneProjectsTo != null )\n        {\n            try\n            {\n                cloneProjects( includedPoms );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Failed to clone projects from: \" + projectsDirectory + \" to: \"\n                    + cloneProjectsTo + \". Reason: \" + e.getMessage(), e );\n            }\n\n            projectsDir = cloneProjectsTo;\n        }\n\n        List failures = runBuilds( projectsDir, includedPoms );\n\n        if ( !suppressSummaries )\n        {\n            getLog().info( \"---------------------------------------\" );\n            getLog().info( \"Execution Summary:\" );\n            getLog().info( \"  Builds Passing: \" + ( includedPoms.length - failures.size() ) );\n            getLog().info( \"  Builds Failing: \" + failures.size() );\n            getLog().info( \"---------------------------------------\" );\n\n            if ( !failures.isEmpty() )\n            {\n                getLog().error( \"The following builds failed:\" );\n\n                for ( final Iterator it = failures.iterator(); it.hasNext(); )\n                {\n                    final String pom = (String) it.next();\n                    getLog().error( \"*  \" + pom );\n                }\n\n                getLog().info( \"---------------------------------------\" );\n            }\n        }\n\n        if ( !failures.isEmpty() )\n        {\n            String message = failures.size() + \" builds failed.\";\n\n            throw new MojoFailureException( this, message, message );\n        }\n    }","id":97788,"modified_method":"/**\n     * Invokes Maven on the configured test projects.\n     * \n     * @throws MojoExecutionException If the goal encountered severe errors.\n     * @throws MojoFailureException If any of the Maven builds failed.\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( skipInvocation )\n        {\n            getLog().info( \"Skipping invocation per configuration.\"\n                + \" If this is incorrect, ensure the skipInvocation parameter is not set to true.\" );\n            return;\n        }\n\n        String[] includedPoms;\n        if ( pom != null )\n        {\n            try\n            {\n                projectsDirectory = pom.getCanonicalFile().getParentFile();\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Failed to discover projectsDirectory from pom File parameter.\"\n                    + \" Reason: \" + e.getMessage(), e );\n            }\n\n            includedPoms = new String[]{ pom.getName() };\n        }\n        else\n        {\n            try\n            {\n                includedPoms = getPoms();\n            }\n            catch ( final IOException e )\n            {\n                throw new MojoExecutionException( \"Error retrieving POM list from includes, excludes, \"\n                                + \"and projects directory. Reason: \" + e.getMessage(), e );\n            }\n        }\n\n\n        if ( ( includedPoms == null ) || ( includedPoms.length < 1 ) )\n        {\n            getLog().info( \"No test projects were selected for execution.\" );\n            return;\n        }\n\n        if ( StringUtils.isEmpty( encoding ) )\n        {\n            getLog().warn(\n                           \"File encoding has not been set, using platform encoding \" + ReaderFactory.FILE_ENCODING\n                               + \", i.e. build is platform dependent!\" );\n        }\n\n        scriptInterpreters = new LinkedHashMap();\n        scriptInterpreters.put( \"bsh\", new BeanShellScriptInterpreter() );\n        scriptInterpreters.put( \"groovy\", new GroovyScriptInterpreter() );\n\n        File projectsDir = projectsDirectory;\n\n        if ( cloneProjectsTo != null )\n        {\n            try\n            {\n                cloneProjects( includedPoms );\n\n                // enable in-place filtering\n                if ( !cloneProjectsTo.getCanonicalFile().equals( projectsDirectory.getCanonicalFile() ) )\n                {\n                    filteredPomPrefix = \"\";\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Failed to clone projects from: \" + projectsDirectory + \" to: \"\n                    + cloneProjectsTo + \". Reason: \" + e.getMessage(), e );\n            }\n\n            projectsDir = cloneProjectsTo;\n        }\n\n        List failures = runBuilds( projectsDir, includedPoms );\n\n        if ( !suppressSummaries )\n        {\n            getLog().info( \"---------------------------------------\" );\n            getLog().info( \"Execution Summary:\" );\n            getLog().info( \"  Builds Passing: \" + ( includedPoms.length - failures.size() ) );\n            getLog().info( \"  Builds Failing: \" + failures.size() );\n            getLog().info( \"---------------------------------------\" );\n\n            if ( !failures.isEmpty() )\n            {\n                getLog().error( \"The following builds failed:\" );\n\n                for ( final Iterator it = failures.iterator(); it.hasNext(); )\n                {\n                    final String pom = (String) it.next();\n                    getLog().error( \"*  \" + pom );\n                }\n\n                getLog().info( \"---------------------------------------\" );\n            }\n        }\n\n        if ( !failures.isEmpty() )\n        {\n            String message = failures.size() + \" builds failed.\";\n\n            throw new MojoFailureException( this, message, message );\n        }\n    }","commit_id":"582058b3abf8c02052ed3cf5a4daa79ae765ebd8","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * retrieve the whole BLOB from the table\n     * @param key  the primary key\n     * @return\n     * @throws IOException\n     */\n    @Override\n    public byte[] get(final byte[] key) throws IOException, RowSpaceExceededException {\n        if (this.blobs.size() == 0) return null;\n        if (this.blobs.size() == 1) {\n            final blobItem bi = this.blobs.get(0);\n            return bi.blob.get(key);\n        }\n\n        final blobItem bi = keeperOf(key);\n    \treturn (bi == null) ? null : bi.blob.get(key);\n\n    \t/*\n    \tbyte[] b;\n        for (blobItem bi: blobs) {\n            b = bi.blob.get(key);\n            if (b != null) return b;\n        }\n        return null;\n        */\n    }","id":97789,"modified_method":"/**\n     * retrieve the whole BLOB from the table\n     * @param key  the primary key\n     * @return\n     * @throws IOException\n     */\n    @Override\n    public byte[] get(final byte[] key) throws IOException, RowSpaceExceededException {\n        if (this.blobs == null || this.blobs.size() == 0) return null;\n        if (this.blobs.size() == 1) {\n            final blobItem bi = this.blobs.get(0);\n            return bi.blob.get(key);\n        }\n\n        final blobItem bi = keeperOf(key);\n    \treturn (bi == null) ? null : bi.blob.get(key);\n\n    \t/*\n    \tbyte[] b;\n        for (blobItem bi: blobs) {\n            b = bi.blob.get(key);\n            if (b != null) return b;\n        }\n        return null;\n        */\n    }","commit_id":"9cbfc1a1c01051182abd425b40d4ee8b9d6249e8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * determines in which form the response should be send and sets header accordingly\r\n     * if the content length is not set we need to use chunked content encoding\r\n     * Implemented:\r\n     * if !content-length\r\n     *  switch httpVer\r\n     *    case 0.9:\r\n     *    case 1.0:\r\n     *      close connection after transfer\r\n     *      break;\r\n     *    default:\r\n     *      new ChunkedStream around respond\r\n     * end if\r\n     *\r\n     * @param conProp\r\n     * @param responseHeader\r\n     * @param statusCode\r\n     * @param respond\r\n     * @return\r\n     */\r\n    private static ChunkedOutputStream setTransferEncoding(\r\n            final HashMap<String, Object> conProp, final ResponseHeader responseHeader,\r\n            final int statusCode, final OutputStream respond) {\r\n        final String httpVer = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\r\n        ChunkedOutputStream chunkedOut = null;\r\n        // gzipped response is ungzipped an therefor the length is unknown\r\n        if (responseHeader.gzip() || responseHeader.getContentLength() < 0) {\r\n            // according to http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\r\n            // a 204,304 message must not contain a message body.\r\n            // Therefore we need to set the content-length to 0.\r\n            if (statusCode == 204 || statusCode == 304) {\r\n                responseHeader.put(HeaderFramework.CONTENT_LENGTH, \"0\");\r\n            } else {\r\n                if (httpVer.equals(HeaderFramework.HTTP_VERSION_0_9) || httpVer.equals(HeaderFramework.HTTP_VERSION_1_0)) {\r\n                    forceConnectionClose(conProp);\r\n                } else {\r\n                    chunkedOut = new ChunkedOutputStream(respond);\r\n                }\r\n                responseHeader.remove(HeaderFramework.CONTENT_LENGTH);\r\n            }\r\n        }\r\n        return chunkedOut;\r\n    }","id":97790,"modified_method":"/**\n     * determines in which form the response should be send and sets header accordingly\n     * if the content length is not set we need to use chunked content encoding\n     * Implemented:\n     * if !content-length\n     *  switch httpVer\n     *    case 0.9:\n     *    case 1.0:\n     *      close connection after transfer\n     *      break;\n     *    default:\n     *      new ChunkedStream around respond\n     * end if\n     *\n     * @param conProp\n     * @param responseHeader\n     * @param statusCode\n     * @param respond\n     * @return\n     */\n    private static ChunkedOutputStream setTransferEncoding(\n            final HashMap<String, Object> conProp, final ResponseHeader responseHeader,\n            final int statusCode, final OutputStream respond) {\n        final String httpVer = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\n        ChunkedOutputStream chunkedOut = null;\n        // gzipped response is ungzipped an therefor the length is unknown\n        if (responseHeader.gzip() || responseHeader.getContentLength() < 0) {\n            // according to http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n            // a 204,304 message must not contain a message body.\n            // Therefore we need to set the content-length to 0.\n            if (statusCode == 204 || statusCode == 304) {\n                responseHeader.put(HeaderFramework.CONTENT_LENGTH, \"0\");\n            } else {\n                if (httpVer.equals(HeaderFramework.HTTP_VERSION_0_9) || httpVer.equals(HeaderFramework.HTTP_VERSION_1_0)) {\n                    forceConnectionClose(conProp);\n                } else {\n                    chunkedOut = new ChunkedOutputStream(respond);\n                    responseHeader.put(HeaderFramework.TRANSFER_ENCODING, \"chunked\");\n                }\n                responseHeader.remove(HeaderFramework.CONTENT_LENGTH);\n            }\n        }\n        return chunkedOut;\n    }","commit_id":"9cbfc1a1c01051182abd425b40d4ee8b9d6249e8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * @param conProp a collection of properties about the connection, like URL\r\n     * @param requestHeader The header lines of the connection from the request\r\n     * @param respond the OutputStream to the client\r\n     * @see de.anomic.http.httpdHandler#doGet(java.util.Properties, net.yacy.cora.protocol.HeaderFramework, java.io.OutputStream)\r\n     */\r\n    public static void doGet(final HashMap<String, Object> conProp, final RequestHeader requestHeader, final OutputStream respond) {\r\n        ByteCountOutputStream countedRespond = null;\r\n        try {\r\n            final int reqID = requestHeader.hashCode();\r\n            // remembering the starting time of the request\r\n            final Date requestDate = new Date(); // remember the time...\r\n            conProp.put(HeaderFramework.CONNECTION_PROP_REQUEST_START, Long.valueOf(requestDate.getTime()));\r\n            if (yacyTrigger) net.yacy.peers.Network.triggerOnlineAction();\r\n            sb.proxyLastAccess = System.currentTimeMillis();\r\n\r\n            // using an ByteCount OutputStream to count the send bytes (needed for the logfile)\r\n            countedRespond = new ByteCountOutputStream(respond,((String) conProp.get(HeaderFramework.CONNECTION_PROP_REQUESTLINE)).length() + 2,\"PROXY\");\r\n\r\n            String host = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HOST);\r\n            String path = (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);           // always starts with leading '/'\r\n            final String args = (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS);     // may be null if no args were given\r\n            final String ip   = (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the ip from the connecting peer\r\n            int pos=0;\r\n            int port=0;\r\n\r\n            DigestURI url = null;\r\n            try {\r\n                url = new DigestURI(HeaderFramework.getRequestURL(conProp));\r\n                if (log.isFine()) log.logFine(reqID +\" GET \"+ url);\r\n                if (log.isFinest()) log.logFinest(reqID +\"    header: \"+ requestHeader);\r\n\r\n                //redirector\r\n                if (redirectorEnabled){\r\n                    synchronized(redirectorProcess){\r\n                        redirectorWriter.println(url.toNormalform(false, true));\r\n                        redirectorWriter.flush();\r\n                    }\r\n                    final String newUrl = redirectorReader.readLine();\r\n                    if (!newUrl.equals(\"\")) {\r\n                        try {\r\n                            url = new DigestURI(newUrl);\r\n                        } catch(final MalformedURLException e){}//just keep the old one\r\n                    }\r\n                    if (log.isFinest()) log.logFinest(reqID +\"    using redirector to \"+ url);\r\n                    conProp.put(HeaderFramework.CONNECTION_PROP_HOST, url.getHost()+\":\"+url.getPort());\r\n                    conProp.put(HeaderFramework.CONNECTION_PROP_PATH, url.getPath());\r\n                    requestHeader.put(HeaderFramework.HOST, url.getHost()+\":\"+url.getPort());\r\n                    requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, url.getPath());\r\n                }\r\n            } catch (final MalformedURLException e) {\r\n                final String errorMsg = \"ERROR: internal error with url generation: host=\" +\r\n                                  host + \", port=\" + port + \", path=\" + path + \", args=\" + args;\r\n                log.logSevere(errorMsg);\r\n                HTTPDemon.sendRespondError(conProp,countedRespond,4,501,null,errorMsg,e);\r\n                return;\r\n            }\r\n\r\n            if ((pos = host.indexOf(':')) < 0) {\r\n                port = 80;\r\n            } else {\r\n                port = NumberTools.parseIntDecSubstring(host, pos + 1);\r\n                host = host.substring(0, pos);\r\n            }\r\n\r\n            // check the blacklist\r\n            // blacklist idea inspired by [AS]:\r\n            // respond a 404 for all AGIS (\"all you get is shit\") servers\r\n            final String hostlow = host.toLowerCase();\r\n            if (args != null) { path = path + \"?\" + args; }\r\n            if (Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_PROXY, hostlow, path)) {\r\n                log.logInfo(\"AGIS blocking of host '\" + hostlow + \"'\");\r\n                HTTPDemon.sendRespondError(conProp,countedRespond,4,403,null,\r\n                        \"URL '\" + hostlow + \"' blocked by yacy proxy (blacklisted)\",null);\r\n                return;\r\n            }\r\n\r\n            // handle outgoing cookies\r\n            handleOutgoingCookies(requestHeader, host, ip);\r\n            prepareRequestHeader(conProp, requestHeader, hostlow);\r\n            final ResponseHeader cachedResponseHeader = Cache.getResponseHeader(url.hash());\r\n\r\n            // why are files unzipped upon arrival? why not zip all files in cache?\r\n            // This follows from the following premises\r\n            // (a) no file shall be unzip-ed more than once to prevent unnecessary computing time\r\n            // (b) old cache entries shall be comparable with refill-entries to detect/distinguish case 3+4\r\n            // (c) the indexing mechanism needs files unzip-ed, a schedule could do that later\r\n            // case b and c contradicts, if we use a scheduler, because files in a stale cache would be unzipped\r\n            // and the newly arrival would be zipped and would have to be unzipped upon load. But then the\r\n            // scheduler is superfluous. Therefore the only reminding case is\r\n            // (d) cached files shall be either all zipped or unzipped\r\n            // case d contradicts with a, because files need to be unzipped for indexing. Therefore\r\n            // the only remaining case is to unzip files right upon load. Thats what we do here.\r\n\r\n            // finally use existing cache if appropriate\r\n            // here we must decide weather or not to save the data\r\n            // to a cache\r\n            // we distinguish four CACHE STATE cases:\r\n            // 1. cache fill\r\n            // 2. cache fresh - no refill\r\n            // 3. cache stale - refill - necessary\r\n            // 4. cache stale - refill - superfluous\r\n            // in two of these cases we trigger a scheduler to handle newly arrived files:\r\n            // case 1 and case 3\r\n            if (cachedResponseHeader == null) {\r\n                if (log.isFinest()) log.logFinest(reqID + \" page not in cache: fulfill request from web\");\r\n                    fulfillRequestFromWeb(conProp, url, requestHeader, cachedResponseHeader, countedRespond);\r\n            } else {\r\n            \tfinal Request request = new Request(\r\n            \t\t\tnull,\r\n                        url,\r\n                        requestHeader.referer() == null ? null : new DigestURI(requestHeader.referer()).hash(),\r\n                        \"\",\r\n                        cachedResponseHeader.lastModified(),\r\n                        sb.crawler.defaultProxyProfile.handle(),\r\n                        0,\r\n                        0,\r\n                        0,\r\n                        0);\r\n                final Response response = new Response(\r\n                \t\trequest,\r\n                        requestHeader,\r\n                        cachedResponseHeader,\r\n                        \"200 OK\",\r\n                        sb.crawler.defaultProxyProfile,\r\n                        false\r\n                );\r\n                final byte[] cacheContent = Cache.getContent(url.hash());\r\n                if (cacheContent != null && response.isFreshForProxy()) {\r\n                    if (log.isFinest()) log.logFinest(reqID + \" fulfill request from cache\");\r\n                    fulfillRequestFromCache(conProp, url, requestHeader, cachedResponseHeader, cacheContent, countedRespond);\r\n                } else {\r\n                    if (log.isFinest()) log.logFinest(reqID + \" fulfill request from web\");\r\n                    fulfillRequestFromWeb(conProp, url, requestHeader, cachedResponseHeader, countedRespond);\r\n                }\r\n            }\r\n\r\n\r\n        } catch (final Exception e) {\r\n            try {\r\n                final String exTxt = e.getMessage();\r\n                if ((exTxt!=null)&&(exTxt.startsWith(\"Socket closed\"))) {\r\n                    forceConnectionClose(conProp);\r\n                } else if (!conProp.containsKey(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_HEADER)) {\r\n                    final String errorMsg = \"Unexpected Error. \" + e.getClass().getName() + \": \" + e.getMessage();\r\n                    HTTPDemon.sendRespondError(conProp,countedRespond,4,501,null,errorMsg,e);\r\n                    log.logSevere(errorMsg);\r\n                } else {\r\n                    forceConnectionClose(conProp);\r\n                }\r\n            } catch (final Exception ee) {\r\n                forceConnectionClose(conProp);\r\n            }\r\n        } finally {\r\n            try { if(countedRespond != null) countedRespond.flush(); else if(respond != null) respond.flush(); } catch (final Exception e) {}\r\n            if (countedRespond != null) countedRespond.finish();\r\n\r\n            conProp.put(HeaderFramework.CONNECTION_PROP_REQUEST_END, Long.valueOf(System.currentTimeMillis()));\r\n            conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_SIZE,(countedRespond != null) ? Long.toString(countedRespond.getCount()) : -1L);\r\n            logProxyAccess(conProp);\r\n        }\r\n    }","id":97791,"modified_method":"/**\n     * @param conProp a collection of properties about the connection, like URL\n     * @param requestHeader The header lines of the connection from the request\n     * @param respond the OutputStream to the client\n     * @see de.anomic.http.httpdHandler#doGet(java.util.Properties, net.yacy.cora.protocol.HeaderFramework, java.io.OutputStream)\n     */\n    public static void doGet(final HashMap<String, Object> conProp, final RequestHeader requestHeader, final OutputStream respond) {\n        ByteCountOutputStream countedRespond = null;\n        try {\n            final int reqID = requestHeader.hashCode();\n            // remembering the starting time of the request\n            final Date requestDate = new Date(); // remember the time...\n            conProp.put(HeaderFramework.CONNECTION_PROP_REQUEST_START, Long.valueOf(requestDate.getTime()));\n            if (yacyTrigger) net.yacy.peers.Network.triggerOnlineAction();\n            sb.proxyLastAccess = System.currentTimeMillis();\n\n            // using an ByteCount OutputStream to count the send bytes (needed for the logfile)\n            countedRespond = new ByteCountOutputStream(respond,((String) conProp.get(HeaderFramework.CONNECTION_PROP_REQUESTLINE)).length() + 2,\"PROXY\");\n\n            String host = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HOST);\n            String path = (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);           // always starts with leading '/'\n            final String args = (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS);     // may be null if no args were given\n            final String ip   = (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the ip from the connecting peer\n            int pos=0;\n            int port=0;\n\n            DigestURI url = null;\n            try {\n                url = new DigestURI(HeaderFramework.getRequestURL(conProp));\n                if (log.isFine()) log.logFine(reqID +\" GET \"+ url);\n                if (log.isFinest()) log.logFinest(reqID +\"    header: \"+ requestHeader);\n\n                //redirector\n                if (redirectorEnabled){\n                    synchronized(redirectorProcess){\n                        redirectorWriter.println(url.toNormalform(false, true));\n                        redirectorWriter.flush();\n                    }\n                    final String newUrl = redirectorReader.readLine();\n                    if (!newUrl.equals(\"\")) {\n                        try {\n                            url = new DigestURI(newUrl);\n                        } catch(final MalformedURLException e){}//just keep the old one\n                    }\n                    if (log.isFinest()) log.logFinest(reqID +\"    using redirector to \"+ url);\n                    conProp.put(HeaderFramework.CONNECTION_PROP_HOST, url.getHost()+\":\"+url.getPort());\n                    conProp.put(HeaderFramework.CONNECTION_PROP_PATH, url.getPath());\n                    requestHeader.put(HeaderFramework.HOST, url.getHost()+\":\"+url.getPort());\n                    requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, url.getPath());\n                }\n            } catch (final MalformedURLException e) {\n                final String errorMsg = \"ERROR: internal error with url generation: host=\" +\n                                  host + \", port=\" + port + \", path=\" + path + \", args=\" + args;\n                log.logSevere(errorMsg);\n                HTTPDemon.sendRespondError(conProp,countedRespond,4,501,null,errorMsg,e);\n                return;\n            }\n\n            if ((pos = host.indexOf(':')) < 0) {\n                port = 80;\n            } else {\n                port = Integer.parseInt(host.substring(pos + 1));\n                host = host.substring(0, pos);\n            }\n\n            // check the blacklist\n            // blacklist idea inspired by [AS]:\n            // respond a 404 for all AGIS (\"all you get is shit\") servers\n            final String hostlow = host.toLowerCase();\n            if (args != null) { path = path + \"?\" + args; }\n            if (Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_PROXY, hostlow, path)) {\n                log.logInfo(\"AGIS blocking of host '\" + hostlow + \"'\");\n                HTTPDemon.sendRespondError(conProp,countedRespond,4,403,null,\n                        \"URL '\" + hostlow + \"' blocked by yacy proxy (blacklisted)\",null);\n                return;\n            }\n\n            // handle outgoing cookies\n            handleOutgoingCookies(requestHeader, host, ip);\n            prepareRequestHeader(conProp, requestHeader, hostlow);\n            final ResponseHeader cachedResponseHeader = Cache.getResponseHeader(url.hash());\n\n            // why are files unzipped upon arrival? why not zip all files in cache?\n            // This follows from the following premises\n            // (a) no file shall be unzip-ed more than once to prevent unnecessary computing time\n            // (b) old cache entries shall be comparable with refill-entries to detect/distinguish case 3+4\n            // (c) the indexing mechanism needs files unzip-ed, a schedule could do that later\n            // case b and c contradicts, if we use a scheduler, because files in a stale cache would be unzipped\n            // and the newly arrival would be zipped and would have to be unzipped upon load. But then the\n            // scheduler is superfluous. Therefore the only reminding case is\n            // (d) cached files shall be either all zipped or unzipped\n            // case d contradicts with a, because files need to be unzipped for indexing. Therefore\n            // the only remaining case is to unzip files right upon load. Thats what we do here.\n\n            // finally use existing cache if appropriate\n            // here we must decide weather or not to save the data\n            // to a cache\n            // we distinguish four CACHE STATE cases:\n            // 1. cache fill\n            // 2. cache fresh - no refill\n            // 3. cache stale - refill - necessary\n            // 4. cache stale - refill - superfluous\n            // in two of these cases we trigger a scheduler to handle newly arrived files:\n            // case 1 and case 3\n            if (cachedResponseHeader == null) {\n                if (log.isFinest()) log.logFinest(reqID + \" page not in cache: fulfill request from web\");\n                    fulfillRequestFromWeb(conProp, url, requestHeader, cachedResponseHeader, countedRespond);\n            } else {\n            \tfinal Request request = new Request(\n            \t\t\tnull,\n                        url,\n                        requestHeader.referer() == null ? null : new DigestURI(requestHeader.referer()).hash(),\n                        \"\",\n                        cachedResponseHeader.lastModified(),\n                        sb.crawler.defaultProxyProfile.handle(),\n                        0,\n                        0,\n                        0,\n                        0);\n                final Response response = new Response(\n                \t\trequest,\n                        requestHeader,\n                        cachedResponseHeader,\n                        \"200 OK\",\n                        sb.crawler.defaultProxyProfile,\n                        true\n                );\n                final byte[] cacheContent = Cache.getContent(url.hash());\n                if (cacheContent != null && response.isFreshForProxy()) {\n                    if (log.isFinest()) log.logFinest(reqID + \" fulfill request from cache\");\n                    fulfillRequestFromCache(conProp, url, requestHeader, cachedResponseHeader, cacheContent, countedRespond);\n                } else {\n                    if (log.isFinest()) log.logFinest(reqID + \" fulfill request from web\");\n                    fulfillRequestFromWeb(conProp, url, requestHeader, cachedResponseHeader, countedRespond);\n                }\n            }\n\n\n        } catch (final Exception e) {\n            try {\n                final String exTxt = e.getMessage();\n                if ((exTxt!=null)&&(exTxt.startsWith(\"Socket closed\"))) {\n                    forceConnectionClose(conProp);\n                } else if (!conProp.containsKey(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_HEADER)) {\n                    final String errorMsg = \"Unexpected Error. \" + e.getClass().getName() + \": \" + e.getMessage();\n                    HTTPDemon.sendRespondError(conProp,countedRespond,4,501,null,errorMsg,e);\n                    log.logSevere(errorMsg);\n                } else {\n                    forceConnectionClose(conProp);\n                }\n            } catch (final Exception ee) {\n                forceConnectionClose(conProp);\n            }\n        } finally {\n            try { if(countedRespond != null) countedRespond.flush(); else if(respond != null) respond.flush(); } catch (final Exception e) {}\n            if (countedRespond != null) countedRespond.finish();\n\n            conProp.put(HeaderFramework.CONNECTION_PROP_REQUEST_END, Long.valueOf(System.currentTimeMillis()));\n            conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_SIZE,(countedRespond != null) ? Long.toString(countedRespond.getCount()) : -1L);\n            logProxyAccess(conProp);\n        }\n    }","commit_id":"9cbfc1a1c01051182abd425b40d4ee8b9d6249e8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void doPost(final HashMap<String, Object> conProp, final RequestHeader requestHeader, final OutputStream respond, final InputStream body) throws IOException {\r\n        assert conProp != null : \"precondition violated: conProp != null\";\r\n        assert requestHeader != null : \"precondition violated: requestHeader != null\";\r\n        assert body != null : \"precondition violated: body != null\";\r\n        DigestURI url = null;\r\n        ByteCountOutputStream countedRespond = null;\r\n        try {\r\n            final int reqID = requestHeader.hashCode();\r\n            // remembering the starting time of the request\r\n            final Date requestDate = new Date(); // remember the time...\r\n            conProp.put(HeaderFramework.CONNECTION_PROP_REQUEST_START, Long.valueOf(requestDate.getTime()));\r\n            if (yacyTrigger) net.yacy.peers.Network.triggerOnlineAction();\r\n            sb.proxyLastAccess = System.currentTimeMillis();\r\n\r\n            // using an ByteCount OutputStream to count the send bytes\r\n            countedRespond  = new ByteCountOutputStream(respond,((String) conProp.get(HeaderFramework.CONNECTION_PROP_REQUESTLINE)).length() + 2,\"PROXY\");\r\n\r\n            String host    = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HOST);\r\n            final String path    = (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);\r\n            final String args    = (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS); // may be null if no args were given\r\n            final String httpVer = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\r\n\r\n            int port, pos;\r\n            if ((pos = host.indexOf(':')) < 0) {\r\n                port = 80;\r\n            } else {\r\n                port = NumberTools.parseIntDecSubstring(host, pos + 1);\r\n                host = host.substring(0, pos);\r\n            }\r\n\r\n            try {\r\n                url = new DigestURI(\"http\", host, port, (args == null) ? path : path + \"?\" + args);\r\n            } catch (final MalformedURLException e) {\r\n                final String errorMsg = \"ERROR: internal error with url generation: host=\" +\r\n                                  host + \", port=\" + port + \", path=\" + path + \", args=\" + args;\r\n                log.logSevere(errorMsg);\r\n                HTTPDemon.sendRespondError(conProp,countedRespond,4,501,null,errorMsg,e);\r\n                return;\r\n            }\r\n            if (log.isFine()) log.logFine(reqID +\" POST \"+ url);\r\n            if (log.isFinest()) log.logFinest(reqID +\"    header: \"+ requestHeader);\r\n\r\n            prepareRequestHeader(conProp, requestHeader, host.toLowerCase());\r\n\r\n            String yAddress = resolveYacyDomains(host);\r\n\r\n            // re-calc the url path\r\n            final String remotePath = (args == null) ? path : (path + \"?\" + args);\r\n\r\n            // remove yacy-subdomain-path, when accessing /env\r\n            if ( (yAddress != null)\r\n            \t\t&& (remotePath.startsWith(\"/env\"))\r\n            \t\t&& ((pos = yAddress.indexOf('/')) != -1)\r\n            ) yAddress = yAddress.substring(0, yAddress.indexOf('/'));\r\n\r\n            modifyProxyHeaders(requestHeader, httpVer);\r\n\r\n            final String connectHost = hostPart(host, port, yAddress);\r\n            final String getUrl = \"http://\"+ connectHost + remotePath;\r\n            if (log.isFinest()) log.logFinest(reqID +\"    using url: \"+ getUrl);\r\n\r\n            // the CONTENT_LENGTH will be added by entity and cause a ClientProtocolException if set\r\n            final int contentLength = requestHeader.getContentLength();\r\n            requestHeader.remove(HeaderFramework.CONTENT_LENGTH);\r\n\r\n            final HTTPClient client = setupHttpClient(requestHeader, connectHost);\r\n\r\n            // check input\r\n            if(body == null) {\r\n                log.logSevere(\"no body to POST!\");\r\n            }\r\n            try {\r\n\t            // sending the request\r\n\t            client.POST(getUrl, body, contentLength);\r\n\t            if (log.isFinest()) log.logFinest(reqID +\"    response status: \"+ client.getHttpResponse().getStatusLine());\r\n\r\n\t            final ResponseHeader responseHeader = new ResponseHeader(client.getHttpResponse().getAllHeaders());\r\n\t            // determine if it's an internal error of the httpc\r\n\t            if (responseHeader.isEmpty()) {\r\n\t            \tthrow new Exception(client.getHttpResponse().getStatusLine().toString());\r\n\t            }\r\n\r\n\t            final ChunkedOutputStream chunked = setTransferEncoding(conProp, responseHeader, client.getHttpResponse().getStatusLine().getStatusCode(), countedRespond);\r\n\r\n\t            prepareResponseHeader(responseHeader, client.getHttpResponse().getProtocolVersion().toString());\r\n\r\n\t            // sending the respond header back to the client\r\n\t            if (chunked != null) {\r\n\t                responseHeader.put(HeaderFramework.TRANSFER_ENCODING, \"chunked\");\r\n\t            }\r\n\r\n\t            // sending response headers\r\n\t            if (log.isFinest()) log.logFinest(reqID +\"    sending response header: \"+ responseHeader);\r\n\t            HTTPDemon.sendRespondHeader(conProp,\r\n                        countedRespond,\r\n                        httpVer,\r\n                        client.getHttpResponse().getStatusLine().getStatusCode(),\r\n                        client.getHttpResponse().getStatusLine().toString(), // status text\r\n                        responseHeader);\r\n\r\n\t            final OutputStream outStream = (chunked != null) ? chunked : countedRespond;\r\n\t            client.writeTo(outStream);\r\n\r\n\t            if (chunked != null) {\r\n\t                chunked.finish();\r\n\t            }\r\n\t            outStream.flush();\r\n            } catch(final SocketException se) {\r\n        \t// connection closed by client, abort download\r\n            \tclient.finish();\r\n            } finally {\r\n            \tclient.finish();\r\n            }\r\n        } catch (final Exception e) {\r\n            handleProxyException(e,conProp,countedRespond,url);\r\n        } finally {\r\n            if(countedRespond != null) {\r\n                countedRespond.flush();\r\n                countedRespond.finish();\r\n            }\r\n            if(respond != null) {\r\n                respond.flush();\r\n            }\r\n\r\n            conProp.put(HeaderFramework.CONNECTION_PROP_REQUEST_END, Long.valueOf(System.currentTimeMillis()));\r\n            conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_SIZE,(countedRespond != null) ? Long.toString(countedRespond.getCount()) : \"-1\");\r\n            logProxyAccess(conProp);\r\n        }\r\n    }","id":97792,"modified_method":"public static void doPost(final HashMap<String, Object> conProp, final RequestHeader requestHeader, final OutputStream respond, final InputStream body) throws IOException {\n        assert conProp != null : \"precondition violated: conProp != null\";\n        assert requestHeader != null : \"precondition violated: requestHeader != null\";\n        assert body != null : \"precondition violated: body != null\";\n        DigestURI url = null;\n        ByteCountOutputStream countedRespond = null;\n        try {\n            final int reqID = requestHeader.hashCode();\n            // remembering the starting time of the request\n            final Date requestDate = new Date(); // remember the time...\n            conProp.put(HeaderFramework.CONNECTION_PROP_REQUEST_START, Long.valueOf(requestDate.getTime()));\n            if (yacyTrigger) net.yacy.peers.Network.triggerOnlineAction();\n            sb.proxyLastAccess = System.currentTimeMillis();\n\n            // using an ByteCount OutputStream to count the send bytes\n            countedRespond  = new ByteCountOutputStream(respond,((String) conProp.get(HeaderFramework.CONNECTION_PROP_REQUESTLINE)).length() + 2,\"PROXY\");\n\n            String host    = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HOST);\n            final String path    = (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);\n            final String args    = (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS); // may be null if no args were given\n            final String httpVer = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\n\n            int port, pos;\n            if ((pos = host.indexOf(':')) < 0) {\n                port = 80;\n            } else {\n                port = Integer.parseInt(host.substring(pos + 1));\n                host = host.substring(0, pos);\n            }\n\n            try {\n                url = new DigestURI(\"http\", host, port, (args == null) ? path : path + \"?\" + args);\n            } catch (final MalformedURLException e) {\n                final String errorMsg = \"ERROR: internal error with url generation: host=\" +\n                                  host + \", port=\" + port + \", path=\" + path + \", args=\" + args;\n                log.logSevere(errorMsg);\n                HTTPDemon.sendRespondError(conProp,countedRespond,4,501,null,errorMsg,e);\n                return;\n            }\n            if (log.isFine()) log.logFine(reqID +\" POST \"+ url);\n            if (log.isFinest()) log.logFinest(reqID +\"    header: \"+ requestHeader);\n\n            prepareRequestHeader(conProp, requestHeader, host.toLowerCase());\n\n            String yAddress = resolveYacyDomains(host);\n\n            // re-calc the url path\n            final String remotePath = (args == null) ? path : (path + \"?\" + args);\n\n            // remove yacy-subdomain-path, when accessing /env\n            if ( (yAddress != null)\n            \t\t&& (remotePath.startsWith(\"/env\"))\n            \t\t&& ((pos = yAddress.indexOf('/')) != -1)\n            ) yAddress = yAddress.substring(0, yAddress.indexOf('/'));\n\n            modifyProxyHeaders(requestHeader, httpVer);\n\n            final String connectHost = hostPart(host, port, yAddress);\n            final String getUrl = \"http://\"+ connectHost + remotePath;\n            if (log.isFinest()) log.logFinest(reqID +\"    using url: \"+ getUrl);\n\n            // the CONTENT_LENGTH will be added by entity and cause a ClientProtocolException if set\n            final int contentLength = requestHeader.getContentLength();\n            requestHeader.remove(HeaderFramework.CONTENT_LENGTH);\n\n            final HTTPClient client = setupHttpClient(requestHeader, connectHost);\n\n            // check input\n            if(body == null) {\n                log.logSevere(\"no body to POST!\");\n            }\n            try {\n\t            // sending the request\n\t            client.POST(getUrl, body, contentLength);\n\t            if (log.isFinest()) log.logFinest(reqID +\"    response status: \"+ client.getHttpResponse().getStatusLine());\n\n\t            final ResponseHeader responseHeader = new ResponseHeader(client.getHttpResponse().getAllHeaders());\n\t            // determine if it's an internal error of the httpc\n\t            if (responseHeader.isEmpty()) {\n\t            \tthrow new Exception(client.getHttpResponse().getStatusLine().toString());\n\t            }\n\n\t            final ChunkedOutputStream chunked = setTransferEncoding(conProp, responseHeader, client.getHttpResponse().getStatusLine().getStatusCode(), countedRespond);\n\n\t            prepareResponseHeader(responseHeader, client.getHttpResponse().getProtocolVersion().toString());\n\n\t            // sending the respond header back to the client\n\t            if (chunked != null) {\n\t                responseHeader.put(HeaderFramework.TRANSFER_ENCODING, \"chunked\");\n\t            }\n\n\t            // sending response headers\n\t            if (log.isFinest()) log.logFinest(reqID +\"    sending response header: \"+ responseHeader);\n\t            HTTPDemon.sendRespondHeader(conProp,\n                        countedRespond,\n                        httpVer,\n                        client.getHttpResponse().getStatusLine().getStatusCode(),\n                        client.getHttpResponse().getStatusLine().toString(), // status text\n                        responseHeader);\n\n\t            final OutputStream outStream = (chunked != null) ? chunked : countedRespond;\n\t            client.writeTo(outStream);\n\n\t            if (chunked != null) {\n\t                chunked.finish();\n\t            }\n\t            outStream.flush();\n            } catch(final SocketException se) {\n        \t// connection closed by client, abort download\n            \tclient.finish();\n            } finally {\n            \tclient.finish();\n            }\n        } catch (final Exception e) {\n            handleProxyException(e,conProp,countedRespond,url);\n        } finally {\n            if(countedRespond != null) {\n                countedRespond.flush();\n                countedRespond.finish();\n            }\n            if(respond != null) {\n                respond.flush();\n            }\n\n            conProp.put(HeaderFramework.CONNECTION_PROP_REQUEST_END, Long.valueOf(System.currentTimeMillis()));\n            conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_SIZE,(countedRespond != null) ? Long.toString(countedRespond.getCount()) : \"-1\");\n            logProxyAccess(conProp);\n        }\n    }","commit_id":"9cbfc1a1c01051182abd425b40d4ee8b9d6249e8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static void fulfillRequestFromCache(\r\n            final HashMap<String, Object> conProp,\r\n            final DigestURI url,\r\n            final RequestHeader requestHeader,\r\n            final ResponseHeader cachedResponseHeader,\r\n            final byte[] cacheEntry,\r\n            final OutputStream respond\r\n    ) throws IOException {\r\n\r\n        final String httpVer = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\r\n\r\n        // we respond on the request by using the cache, the cache is fresh\r\n        try {\r\n            prepareResponseHeader(cachedResponseHeader, httpVer);\r\n\r\n            // replace date field in old header by actual date, this is according to RFC\r\n            cachedResponseHeader.put(HeaderFramework.DATE, HeaderFramework.formatRFC1123(new Date()));\r\n\r\n            // check if we can send a 304 instead the complete content\r\n            if (requestHeader.containsKey(RequestHeader.IF_MODIFIED_SINCE)) {\r\n                // conditional request: freshness of cache for that condition was already\r\n                // checked within shallUseCache(). Now send only a 304 response\r\n                log.logInfo(\"CACHE HIT/304 \" + url.toString());\r\n                conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_CODE,\"TCP_REFRESH_HIT\");\r\n\r\n                // setting the content length header to 0\r\n                cachedResponseHeader.put(HeaderFramework.CONTENT_LENGTH, Integer.toString(0));\r\n\r\n                // send cached header with replaced date and added length\r\n                HTTPDemon.sendRespondHeader(conProp,respond,httpVer,304,cachedResponseHeader);\r\n                //respondHeader(respond, \"304 OK\", cachedResponseHeader); // respond with 'not modified'\r\n            } else {\r\n                // unconditional request: send content of cache\r\n                log.logInfo(\"CACHE HIT/203 \" + url.toString());\r\n                conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_CODE,\"TCP_HIT\");\r\n\r\n                // setting the content header to the proper length\r\n                cachedResponseHeader.put(HeaderFramework.CONTENT_LENGTH, Long.toString(cacheEntry.length));\r\n\r\n                // send cached header with replaced date and added length\r\n                HTTPDemon.sendRespondHeader(conProp,respond,httpVer,203,cachedResponseHeader);\r\n                //respondHeader(respond, \"203 OK\", cachedResponseHeader); // respond with 'non-authoritative'\r\n\r\n                // send also the complete body now from the cache\r\n                // simply read the file and transfer to out socket\r\n                FileUtils.copy(cacheEntry, respond);\r\n            }\r\n            // that's it!\r\n        } catch (final Exception e) {\r\n            // this happens if the client stops loading the file\r\n            // we do nothing here\r\n            if (conProp.containsKey(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_HEADER)) {\r\n                log.logWarning(\"Error while trying to send cached message body.\");\r\n                conProp.put(HeaderFramework.CONNECTION_PROP_PERSISTENT,\"close\");\r\n            } else {\r\n                HTTPDemon.sendRespondError(conProp,respond,4,503,\"socket error: \" + e.getMessage(),\"socket error: \" + e.getMessage(), e);\r\n            }\r\n        } finally {\r\n            try { respond.flush(); } catch (final Exception e) {}\r\n        }\r\n        return;\r\n    }","id":97793,"modified_method":"private static void fulfillRequestFromCache(\n            final HashMap<String, Object> conProp,\n            final DigestURI url,\n            final RequestHeader requestHeader,\n            final ResponseHeader cachedResponseHeader,\n            final byte[] cacheEntry,\n            OutputStream respond\n    ) throws IOException {\n\n        final String httpVer = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\n\n        // we respond on the request by using the cache, the cache is fresh\n        try {\n            prepareResponseHeader(cachedResponseHeader, httpVer);\n\n            // replace date field in old header by actual date, this is according to RFC\n            cachedResponseHeader.put(HeaderFramework.DATE, HeaderFramework.formatRFC1123(new Date()));\n\n            // check if we can send a 304 instead the complete content\n            if (requestHeader.containsKey(RequestHeader.IF_MODIFIED_SINCE)) {\n                // conditional request: freshness of cache for that condition was already\n                // checked within shallUseCache(). Now send only a 304 response\n                log.logInfo(\"CACHE HIT/304 \" + url.toString());\n                conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_CODE,\"TCP_REFRESH_HIT\");\n\n                // setting the content length header to 0\n                cachedResponseHeader.put(HeaderFramework.CONTENT_LENGTH, Integer.toString(0));\n\n                // send cached header with replaced date and added length\n                HTTPDemon.sendRespondHeader(conProp,respond,httpVer,304,cachedResponseHeader);\n                //respondHeader(respond, \"304 OK\", cachedResponseHeader); // respond with 'not modified'\n            } else {\n                // unconditional request: send content of cache\n                log.logInfo(\"CACHE HIT/203 \" + url.toString());\n                conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_CODE,\"TCP_HIT\");\n\n                // setting the content header to the proper length\n                cachedResponseHeader.put(HeaderFramework.CONTENT_LENGTH, Long.toString(cacheEntry.length));\n\n                // send cached header with replaced date and added length\n                HTTPDemon.sendRespondHeader(conProp,respond,httpVer,203,cachedResponseHeader);\n                //respondHeader(respond, \"203 OK\", cachedResponseHeader); // respond with 'non-authoritative'\n\n                if(AugmentedHtmlStream.supportsMime(cachedResponseHeader.mime())) {\n                    respond = new AugmentedHtmlStream(respond, cachedResponseHeader.getCharSet(), url, url.hash(), requestHeader);\n                }\n\n                // send also the complete body now from the cache\n                // simply read the file and transfer to out socket\n                FileUtils.copy(cacheEntry, respond);\n            }\n            // that's it!\n        } catch (final Exception e) {\n            // this happens if the client stops loading the file\n            // we do nothing here\n            if (conProp.containsKey(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_HEADER)) {\n                log.logWarning(\"Error while trying to send cached message body.\");\n                conProp.put(HeaderFramework.CONNECTION_PROP_PERSISTENT,\"close\");\n            } else {\n                HTTPDemon.sendRespondError(conProp,respond,4,503,\"socket error: \" + e.getMessage(),\"socket error: \" + e.getMessage(), e);\n            }\n        } finally {\n            try { respond.flush(); } catch (final Exception e) {}\n        }\n        return;\n    }","commit_id":"9cbfc1a1c01051182abd425b40d4ee8b9d6249e8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void doHead(final HashMap<String, Object> conProp, final RequestHeader requestHeader, OutputStream respond) {\r\n\r\n//        ResponseContainer res = null;\r\n        DigestURI url = null;\r\n        try {\r\n            final int reqID = requestHeader.hashCode();\r\n            // remembering the starting time of the request\r\n            final Date requestDate = new Date(); // remember the time...\r\n            conProp.put(HeaderFramework.CONNECTION_PROP_REQUEST_START, Long.valueOf(requestDate.getTime()));\r\n            if (yacyTrigger) net.yacy.peers.Network.triggerOnlineAction();\r\n            sb.proxyLastAccess = System.currentTimeMillis();\r\n\r\n            // using an ByteCount OutputStream to count the send bytes\r\n            respond = new ByteCountOutputStream(respond,((String) conProp.get(HeaderFramework.CONNECTION_PROP_REQUESTLINE)).length() + 2,\"PROXY\");\r\n\r\n            String host = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HOST);\r\n            final String path = (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);\r\n            final String args = (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS);\r\n            final String httpVer = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\r\n\r\n            int port, pos;\r\n            if ((pos = host.indexOf(':')) < 0) {\r\n                port = 80;\r\n            } else {\r\n                port = NumberTools.parseIntDecSubstring(host, pos + 1);\r\n                host = host.substring(0, pos);\r\n            }\r\n\r\n            try {\r\n                url = new DigestURI(\"http\", host, port, (args == null) ? path : path + \"?\" + args);\r\n            } catch (final MalformedURLException e) {\r\n                final String errorMsg = \"ERROR: internal error with url generation: host=\" +\r\n                                  host + \", port=\" + port + \", path=\" + path + \", args=\" + args;\r\n                log.logSevere(errorMsg);\r\n                HTTPDemon.sendRespondError(conProp,respond,4,501,null,errorMsg,e);\r\n                return;\r\n            }\r\n            if (log.isFine()) log.logFine(reqID +\" HEAD \"+ url);\r\n            if (log.isFinest()) log.logFinest(reqID +\"    header: \"+ requestHeader);\r\n\r\n            // check the blacklist, inspired by [AS]: respond a 404 for all AGIS (all you get is shit) servers\r\n            final String hostlow = host.toLowerCase();\r\n\r\n            // re-calc the url path\r\n            final String remotePath = (args == null) ? path : (path + \"?\" + args);\r\n\r\n            if (Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_PROXY, hostlow, remotePath)) {\r\n                HTTPDemon.sendRespondError(conProp,respond,4,403,null,\r\n                        \"URL '\" + hostlow + \"' blocked by yacy proxy (blacklisted)\",null);\r\n                log.logInfo(\"AGIS blocking of host '\" + hostlow + \"'\");\r\n                return;\r\n            }\r\n\r\n            prepareRequestHeader(conProp, requestHeader, hostlow);\r\n\r\n            // resolve yacy and yacyh domains\r\n            String yAddress = resolveYacyDomains(host);\r\n\r\n            // remove yacy-subdomain-path, when accessing /env\r\n            if ( (yAddress != null)\r\n            \t\t&& (remotePath.startsWith(\"/env\"))\r\n            \t\t&& ((pos = yAddress.indexOf('/')) != -1)\r\n            ) yAddress = yAddress.substring(0, yAddress.indexOf('/'));\r\n\r\n            modifyProxyHeaders(requestHeader, httpVer);\r\n\r\n            // generate request-url\r\n            final String connectHost = hostPart(host, port, yAddress);\r\n            final String getUrl = \"http://\"+ connectHost + remotePath;\r\n            if (log.isFinest()) log.logFinest(reqID +\"    using url: \"+ getUrl);\r\n\r\n            final HTTPClient client = setupHttpClient(requestHeader, connectHost);\r\n\r\n            // send request\r\n//            try {\r\n//            res = client.HEAD(getUrl);\r\n//            if (log.isFinest()) log.logFinest(reqID +\"    response status: \"+ res.getStatusLine());\r\n            client.HEADResponse(getUrl);\r\n            if (log.isFinest()) log.logFinest(reqID +\"    response status: \"+ client.getHttpResponse().getStatusLine());\r\n\r\n            // determine if it's an internal error of the httpc\r\n//            final ResponseHeader responseHeader = res.getResponseHeader();\r\n//            if (responseHeader.isEmpty()) {\r\n//                throw new Exception(res.getStatusLine());\r\n//            }\r\n            final ResponseHeader responseHeader = new ResponseHeader(client.getHttpResponse().getAllHeaders());\r\n            if (responseHeader.isEmpty()) {\r\n                throw new Exception(client.getHttpResponse().getStatusLine().toString());\r\n            }\r\n\r\n//            prepareResponseHeader(responseHeader, res.getHttpVer());\r\n            prepareResponseHeader(responseHeader, client.getHttpResponse().getStatusLine().getProtocolVersion().toString());\r\n\r\n            // sending the server respond back to the client\r\n            if (log.isFinest()) log.logFinest(reqID +\"    sending response header: \"+ responseHeader);\r\n//            HTTPDemon.sendRespondHeader(conProp,respond,httpVer,res.getStatusCode(),res.getStatusLine().substring(4),responseHeader);\r\n            HTTPDemon.sendRespondHeader(\r\n            \t\tconProp,\r\n            \t\trespond,\r\n            \t\thttpVer,\r\n            \t\tclient.getHttpResponse().getStatusLine().getStatusCode(),\r\n            \t\tclient.getHttpResponse().getStatusLine().toString(),\r\n            \t\tresponseHeader);\r\n            respond.flush();\r\n//            } finally {\r\n//                if(res != null) {\r\n//                    // ... close connection\r\n//                    res.closeStream();\r\n//                }\r\n//            }\r\n        } catch (final Exception e) {\r\n            handleProxyException(e,conProp,respond,url);\r\n        }\r\n    }","id":97794,"modified_method":"public static void doHead(final HashMap<String, Object> conProp, final RequestHeader requestHeader, OutputStream respond) {\n\n//        ResponseContainer res = null;\n        DigestURI url = null;\n        try {\n            final int reqID = requestHeader.hashCode();\n            // remembering the starting time of the request\n            final Date requestDate = new Date(); // remember the time...\n            conProp.put(HeaderFramework.CONNECTION_PROP_REQUEST_START, Long.valueOf(requestDate.getTime()));\n            if (yacyTrigger) net.yacy.peers.Network.triggerOnlineAction();\n            sb.proxyLastAccess = System.currentTimeMillis();\n\n            // using an ByteCount OutputStream to count the send bytes\n            respond = new ByteCountOutputStream(respond,((String) conProp.get(HeaderFramework.CONNECTION_PROP_REQUESTLINE)).length() + 2,\"PROXY\");\n\n            String host = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HOST);\n            final String path = (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);\n            final String args = (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS);\n            final String httpVer = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\n\n            int port, pos;\n            if ((pos = host.indexOf(':')) < 0) {\n                port = 80;\n            } else {\n                port = Integer.parseInt(host.substring(pos + 1));\n                host = host.substring(0, pos);\n            }\n\n            try {\n                url = new DigestURI(\"http\", host, port, (args == null) ? path : path + \"?\" + args);\n            } catch (final MalformedURLException e) {\n                final String errorMsg = \"ERROR: internal error with url generation: host=\" +\n                                  host + \", port=\" + port + \", path=\" + path + \", args=\" + args;\n                log.logSevere(errorMsg);\n                HTTPDemon.sendRespondError(conProp,respond,4,501,null,errorMsg,e);\n                return;\n            }\n            if (log.isFine()) log.logFine(reqID +\" HEAD \"+ url);\n            if (log.isFinest()) log.logFinest(reqID +\"    header: \"+ requestHeader);\n\n            // check the blacklist, inspired by [AS]: respond a 404 for all AGIS (all you get is shit) servers\n            final String hostlow = host.toLowerCase();\n\n            // re-calc the url path\n            final String remotePath = (args == null) ? path : (path + \"?\" + args);\n\n            if (Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_PROXY, hostlow, remotePath)) {\n                HTTPDemon.sendRespondError(conProp,respond,4,403,null,\n                        \"URL '\" + hostlow + \"' blocked by yacy proxy (blacklisted)\",null);\n                log.logInfo(\"AGIS blocking of host '\" + hostlow + \"'\");\n                return;\n            }\n\n            prepareRequestHeader(conProp, requestHeader, hostlow);\n\n            // resolve yacy and yacyh domains\n            String yAddress = resolveYacyDomains(host);\n\n            // remove yacy-subdomain-path, when accessing /env\n            if ( (yAddress != null)\n            \t\t&& (remotePath.startsWith(\"/env\"))\n            \t\t&& ((pos = yAddress.indexOf('/')) != -1)\n            ) yAddress = yAddress.substring(0, yAddress.indexOf('/'));\n\n            modifyProxyHeaders(requestHeader, httpVer);\n\n            // generate request-url\n            final String connectHost = hostPart(host, port, yAddress);\n            final String getUrl = \"http://\"+ connectHost + remotePath;\n            if (log.isFinest()) log.logFinest(reqID +\"    using url: \"+ getUrl);\n\n            final HTTPClient client = setupHttpClient(requestHeader, connectHost);\n\n            // send request\n//            try {\n//            res = client.HEAD(getUrl);\n//            if (log.isFinest()) log.logFinest(reqID +\"    response status: \"+ res.getStatusLine());\n            client.HEADResponse(getUrl);\n            if (log.isFinest()) log.logFinest(reqID +\"    response status: \"+ client.getHttpResponse().getStatusLine());\n\n            // determine if it's an internal error of the httpc\n//            final ResponseHeader responseHeader = res.getResponseHeader();\n//            if (responseHeader.isEmpty()) {\n//                throw new Exception(res.getStatusLine());\n//            }\n            final ResponseHeader responseHeader = new ResponseHeader(client.getHttpResponse().getAllHeaders());\n            if (responseHeader.isEmpty()) {\n                throw new Exception(client.getHttpResponse().getStatusLine().toString());\n            }\n\n//            prepareResponseHeader(responseHeader, res.getHttpVer());\n            prepareResponseHeader(responseHeader, client.getHttpResponse().getStatusLine().getProtocolVersion().toString());\n\n            // sending the server respond back to the client\n            if (log.isFinest()) log.logFinest(reqID +\"    sending response header: \"+ responseHeader);\n//            HTTPDemon.sendRespondHeader(conProp,respond,httpVer,res.getStatusCode(),res.getStatusLine().substring(4),responseHeader);\n            HTTPDemon.sendRespondHeader(\n            \t\tconProp,\n            \t\trespond,\n            \t\thttpVer,\n            \t\tclient.getHttpResponse().getStatusLine().getStatusCode(),\n            \t\tclient.getHttpResponse().getStatusLine().toString(),\n            \t\tresponseHeader);\n            respond.flush();\n//            } finally {\n//                if(res != null) {\n//                    // ... close connection\n//                    res.closeStream();\n//                }\n//            }\n        } catch (final Exception e) {\n            handleProxyException(e,conProp,respond,url);\n        }\n    }","commit_id":"9cbfc1a1c01051182abd425b40d4ee8b9d6249e8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static void fulfillRequestFromWeb(final HashMap<String, Object> conProp, final DigestURI url, final RequestHeader requestHeader, final ResponseHeader cachedResponseHeader, final OutputStream respond) {\r\n        try {\r\n            final int reqID = requestHeader.hashCode();\r\n\r\n            String host =    (String) conProp.get(HeaderFramework.CONNECTION_PROP_HOST);\r\n            final String path =    (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);     // always starts with leading '/'\r\n            final String args =    (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS);     // may be null if no args were given\r\n            final String ip =      (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the ip from the connecting peer\r\n            final String httpVer = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER); // the ip from the connecting peer\r\n\r\n            int port, pos;\r\n            if ((pos = host.indexOf(':')) < 0) {\r\n                port = 80;\r\n            } else {\r\n                port = NumberTools.parseIntDecSubstring(host, pos + 1);\r\n                host = host.substring(0, pos);\r\n            }\r\n\r\n            // resolve yacy and yacyh domains\r\n            String yAddress = resolveYacyDomains(host);\r\n\r\n            // re-calc the url path\r\n            final String remotePath = (args == null) ? path : (path + \"?\" + args); // with leading '/'\r\n\r\n            // remove yacy-subdomain-path, when accessing /env\r\n            if ( (yAddress != null)\r\n            \t\t&& (remotePath.startsWith(\"/env\"))\r\n            \t\t&& ((pos = yAddress.indexOf('/')) != -1)\r\n            ) yAddress = yAddress.substring(0, yAddress.indexOf('/'));\r\n\r\n            modifyProxyHeaders(requestHeader, httpVer);\r\n\r\n            final String connectHost = hostPart(host, port, yAddress);\r\n            final String getUrl = \"http://\"+ connectHost + remotePath;\r\n\r\n            final HTTPClient client = setupHttpClient(requestHeader, connectHost);\r\n\r\n            // send request\r\n            try {\r\n            \tclient.GET(getUrl);\r\n                if (log.isFinest()) log.logFinest(reqID +\"    response status: \"+ client.getHttpResponse().getStatusLine());\r\n                conProp.put(HeaderFramework.CONNECTION_PROP_CLIENT_REQUEST_HEADER, requestHeader);\r\n\r\n                final ResponseHeader responseHeader = new ResponseHeader(client.getHttpResponse().getAllHeaders());\r\n                // determine if it's an internal error of the httpc\r\n                if (responseHeader.isEmpty()) {\r\n                \tthrow new Exception(client.getHttpResponse().getStatusLine().toString());\r\n                }\r\n\r\n                final ChunkedOutputStream chunkedOut = setTransferEncoding(conProp, responseHeader, client.getHttpResponse().getStatusLine().getStatusCode(), respond);\r\n\r\n                // the cache does either not exist or is (supposed to be) stale\r\n                long sizeBeforeDelete = -1;\r\n                if (cachedResponseHeader != null) {\r\n                    // delete the cache\r\n                    final ResponseHeader rh = Cache.getResponseHeader(url.hash());\r\n                    if (rh != null && (sizeBeforeDelete = rh.getContentLength()) == 0) {\r\n                        final byte[] b = Cache.getContent(url.hash());\r\n                        if (b != null) sizeBeforeDelete = b.length;\r\n                    }\r\n                    Cache.delete(url.hash());\r\n                    conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_CODE, \"TCP_REFRESH_MISS\");\r\n                }\r\n\r\n                // reserver cache entry\r\n                final Request request = new Request(\r\n            \t\t\tnull,\r\n                        url,\r\n                        requestHeader.referer() == null ? null : new DigestURI(requestHeader.referer()).hash(),\r\n                        \"\",\r\n                        responseHeader.lastModified(),\r\n                        sb.crawler.defaultProxyProfile.handle(),\r\n                        0,\r\n                        0,\r\n                        0,\r\n                        sizeBeforeDelete < 0 ? 0 : sizeBeforeDelete);\r\n\r\n\r\n                // handle incoming cookies\r\n                handleIncomingCookies(responseHeader, host, ip);\r\n\r\n//                prepareResponseHeader(responseHeader, res.getHttpVer());\r\n                prepareResponseHeader(responseHeader, client.getHttpResponse().getProtocolVersion().toString());\r\n\r\n                // sending the respond header back to the client\r\n                if (chunkedOut != null) {\r\n                    responseHeader.put(HeaderFramework.TRANSFER_ENCODING, \"chunked\");\r\n                }\r\n\r\n                if (log.isFinest()) log.logFinest(reqID +\"    sending response header: \"+ responseHeader);\r\n                HTTPDemon.sendRespondHeader(\r\n                        conProp,\r\n                        respond,\r\n                        httpVer,\r\n                        client.getHttpResponse().getStatusLine().getStatusCode(),\r\n                        client.getHttpResponse().getStatusLine().toString(), // status text\r\n                        responseHeader);\r\n\r\n                if (hasBody(client.getHttpResponse().getStatusLine().getStatusCode())) {\r\n\r\n                    final OutputStream outStream = chunkedOut != null ? chunkedOut : respond;\r\n                    final Response response = new Response(\r\n                            request,\r\n                            requestHeader,\r\n                            responseHeader,\r\n                            Integer.toString(client.getHttpResponse().getStatusLine().getStatusCode()),\r\n                            sb.crawler.defaultProxyProfile,\r\n                            false\r\n                    );\r\n                    final String storeError = response.shallStoreCacheForProxy();\r\n                    final boolean storeHTCache = response.profile().storeHTCache();\r\n                    final String supportError = TextParser.supports(response.url(), response.getMimeType());\r\n                    if (\r\n                            /*\r\n                             * Now we store the response into the htcache directory if\r\n                             * a) the response is cacheable AND\r\n                             */\r\n                            (storeError == null) &&\r\n                            /*\r\n                             * b) the user has configured to use the htcache OR\r\n                             * c) the content should be indexed\r\n                             */\r\n                            ((storeHTCache) || (supportError != null))\r\n                    ) {\r\n                        // we don't write actually into a file, only to RAM, and schedule writing the file.\r\n//                        int l = res.getResponseHeader().size();\r\n                    \tfinal int l = responseHeader.size();\r\n                        final ByteArrayOutputStream byteStream = new ByteArrayOutputStream((l < 32) ? 32 : l);\r\n\r\n                        final OutputStream toClientAndMemory = new MultiOutputStream(new OutputStream[] {outStream, byteStream});\r\n//                        FileUtils.copy(res.getDataAsStream(), toClientAndMemory);\r\n                        client.writeTo(toClientAndMemory);\r\n                        // cached bytes\r\n                        byte[] cacheArray;\r\n                        if (byteStream.size() > 0) {\r\n                            cacheArray = byteStream.toByteArray();\r\n                        } else {\r\n                            cacheArray = null;\r\n                        }\r\n                        if (log.isFine()) log.logFine(reqID +\" writeContent of \" + url + \" produced cacheArray = \" + ((cacheArray == null) ? \"null\" : (\"size=\" + cacheArray.length)));\r\n\r\n                        if (sizeBeforeDelete == -1) {\r\n                            // totally fresh file\r\n                            response.setContent(cacheArray);\r\n                            try {\r\n                                Cache.store(response.url(), response.getResponseHeader(), cacheArray);\r\n                                sb.toIndexer(response);\r\n                            } catch (final IOException e) {\r\n                                log.logWarning(\"cannot write \" + response.url() + \" to Cache (1): \" + e.getMessage(), e);\r\n                            }\r\n                            conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_CODE, \"TCP_MISS\");\r\n                        } else if (cacheArray != null && sizeBeforeDelete == cacheArray.length) {\r\n                            // before we came here we deleted a cache entry\r\n                            cacheArray = null;\r\n                            //cacheManager.push(cacheEntry); // unnecessary update\r\n                            conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_CODE, \"TCP_REF_FAIL_HIT\");\r\n                        } else {\r\n                            // before we came here we deleted a cache entry\r\n                            response.setContent(cacheArray);\r\n                            try {\r\n                                Cache.store(response.url(), response.getResponseHeader(), cacheArray);\r\n                                sb.toIndexer(response);\r\n                            } catch (final IOException e) {\r\n                                log.logWarning(\"cannot write \" + response.url() + \" to Cache (2): \" + e.getMessage(), e);\r\n                            }\r\n                            conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_CODE, \"TCP_REFRESH_MISS\");\r\n                        }\r\n                    } else {\r\n                        // no caching\r\n                        if (log.isFine()) log.logFine(reqID +\" \"+ url.toString() + \" not cached.\" +\r\n                                \" StoreError=\" + ((storeError==null)?\"None\":storeError) +\r\n                                \" StoreHTCache=\" + storeHTCache +\r\n                                \" SupportError=\" + supportError);\r\n\r\n//                        FileUtils.copy(res.getDataAsStream(), outStream);\r\n                        client.writeTo(outStream);\r\n\r\n                        conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_CODE,\"TCP_MISS\");\r\n                    }\r\n\r\n                    if (chunkedOut != null) {\r\n                        chunkedOut.finish();\r\n                        chunkedOut.flush();\r\n                    }\r\n                } // end hasBody\r\n            } catch(final SocketException se) {\r\n                // if opened ...\r\n//                if(res != null) {\r\n//                    // client cut proxy connection, abort download\r\n//                    res.abort();\r\n//                }\r\n            \tclient.finish();\r\n                handleProxyException(se,conProp,respond,url);\r\n            } finally {\r\n                // if opened ...\r\n//                if(res != null) {\r\n//                    // ... close connection\r\n//                    res.closeStream();\r\n//                }\r\n            \tclient.finish();\r\n            }\r\n        } catch (final Exception e) {\r\n            handleProxyException(e,conProp,respond,url);\r\n        }\r\n    }","id":97795,"modified_method":"private static void fulfillRequestFromWeb(final HashMap<String, Object> conProp, final DigestURI url, final RequestHeader requestHeader, final ResponseHeader cachedResponseHeader, final OutputStream respond) {\n        try {\n            final int reqID = requestHeader.hashCode();\n\n            String host =    (String) conProp.get(HeaderFramework.CONNECTION_PROP_HOST);\n            final String path =    (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);     // always starts with leading '/'\n            final String args =    (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS);     // may be null if no args were given\n            final String ip =      (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the ip from the connecting peer\n            final String httpVer = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER); // the ip from the connecting peer\n\n            int port, pos;\n            if ((pos = host.indexOf(':')) < 0) {\n                port = 80;\n            } else {\n                port = Integer.parseInt(host.substring(pos + 1));\n                host = host.substring(0, pos);\n            }\n\n            // resolve yacy and yacyh domains\n            String yAddress = resolveYacyDomains(host);\n\n            // re-calc the url path\n            final String remotePath = (args == null) ? path : (path + \"?\" + args); // with leading '/'\n\n            // remove yacy-subdomain-path, when accessing /env\n            if ( (yAddress != null)\n            \t\t&& (remotePath.startsWith(\"/env\"))\n            \t\t&& ((pos = yAddress.indexOf('/')) != -1)\n            ) yAddress = yAddress.substring(0, yAddress.indexOf('/'));\n\n            modifyProxyHeaders(requestHeader, httpVer);\n\n            final String connectHost = hostPart(host, port, yAddress);\n            final String getUrl = \"http://\"+ connectHost + remotePath;\n\n            requestHeader.remove(HeaderFramework.HOST);\n\n            final HTTPClient client = setupHttpClient(requestHeader, connectHost);\n\n            // send request\n            try {\n            \tclient.GET(getUrl);\n                if (log.isFinest()) log.logFinest(reqID +\"    response status: \"+ client.getHttpResponse().getStatusLine());\n                conProp.put(HeaderFramework.CONNECTION_PROP_CLIENT_REQUEST_HEADER, requestHeader);\n\n                final ResponseHeader responseHeader = new ResponseHeader(client.getHttpResponse().getAllHeaders());\n                // determine if it's an internal error of the httpc\n                if (responseHeader.isEmpty()) {\n                \tthrow new Exception(client.getHttpResponse().getStatusLine().toString());\n                }\n\n                if(AugmentedHtmlStream.supportsMime(responseHeader.mime())) {\n                    // enable chunk encoding, because we don't know the length after annotating\n                    responseHeader.remove(HeaderFramework.CONTENT_LENGTH);\n                    responseHeader.put(HeaderFramework.TRANSFER_ENCODING, \"chunked\");\n\n                }\n\n                ChunkedOutputStream chunkedOut = setTransferEncoding(conProp, responseHeader, client.getHttpResponse().getStatusLine().getStatusCode(), respond);\n\n                // the cache does either not exist or is (supposed to be) stale\n                long sizeBeforeDelete = -1;\n                if (cachedResponseHeader != null) {\n                    // delete the cache\n                    final ResponseHeader rh = Cache.getResponseHeader(url.hash());\n                    if (rh != null && (sizeBeforeDelete = rh.getContentLength()) == 0) {\n                        final byte[] b = Cache.getContent(url.hash());\n                        if (b != null) sizeBeforeDelete = b.length;\n                    }\n                    Cache.delete(url.hash());\n                    conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_CODE, \"TCP_REFRESH_MISS\");\n                }\n\n                // reserver cache entry\n                final Request request = new Request(\n            \t\t\tnull,\n                        url,\n                        requestHeader.referer() == null ? null : new DigestURI(requestHeader.referer()).hash(),\n                        \"\",\n                        responseHeader.lastModified(),\n                        sb.crawler.defaultProxyProfile.handle(),\n                        0,\n                        0,\n                        0,\n                        sizeBeforeDelete < 0 ? 0 : sizeBeforeDelete);\n\n\n                // handle incoming cookies\n                handleIncomingCookies(responseHeader, host, ip);\n\n//                prepareResponseHeader(responseHeader, res.getHttpVer());\n                prepareResponseHeader(responseHeader, client.getHttpResponse().getProtocolVersion().toString());\n\n                if(AugmentedHtmlStream.supportsMime(responseHeader.mime())) {\n                \t// chunked encoding disables somewhere, add it again\n                    responseHeader.put(HeaderFramework.TRANSFER_ENCODING, \"chunked\");\n                }\n\n                if (log.isFinest()) log.logFinest(reqID +\"    sending response header: \"+ responseHeader);\n                HTTPDemon.sendRespondHeader(\n                        conProp,\n                        respond,\n                        httpVer,\n                        client.getHttpResponse().getStatusLine().getStatusCode(),\n                        client.getHttpResponse().getStatusLine().toString(), // status text\n                        responseHeader);\n\n                if (hasBody(client.getHttpResponse().getStatusLine().getStatusCode())) {\n\n                    OutputStream outStream = chunkedOut != null ? chunkedOut : respond;\n                    final Response response = new Response(\n                            request,\n                            requestHeader,\n                            responseHeader,\n                            Integer.toString(client.getHttpResponse().getStatusLine().getStatusCode()),\n                            sb.crawler.defaultProxyProfile,\n                            true\n                    );\n                    final String storeError = response.shallStoreCacheForProxy();\n                    final boolean storeHTCache = response.profile().storeHTCache();\n                    final String supportError = TextParser.supports(response.url(), response.getMimeType());\n\n                    if(AugmentedHtmlStream.supportsMime(responseHeader.mime())) {\n                        outStream = new AugmentedHtmlStream(outStream, responseHeader.getCharSet(), url, url.hash(), requestHeader);\n                    }\n                    if (\n                            /*\n                             * Now we store the response into the htcache directory if\n                             * a) the response is cacheable AND\n                             */\n                            (storeError == null) &&\n                            /*\n                             * b) the user has configured to use the htcache OR\n                             * c) the content should be indexed\n                             */\n                            ((storeHTCache) || (supportError != null))\n                    ) {\n                        // we don't write actually into a file, only to RAM, and schedule writing the file.\n//                        int l = res.getResponseHeader().size();\n                    \tfinal int l = responseHeader.size();\n                        final ByteArrayOutputStream byteStream = new ByteArrayOutputStream((l < 32) ? 32 : l);\n\n                        final OutputStream toClientAndMemory = new MultiOutputStream(new OutputStream[] {outStream, byteStream});\n//                        FileUtils.copy(res.getDataAsStream(), toClientAndMemory);\n                        client.writeTo(toClientAndMemory);\n                        // cached bytes\n                        byte[] cacheArray;\n                        if (byteStream.size() > 0) {\n                            cacheArray = byteStream.toByteArray();\n                        } else {\n                            cacheArray = null;\n                        }\n                        if (log.isFine()) log.logFine(reqID +\" writeContent of \" + url + \" produced cacheArray = \" + ((cacheArray == null) ? \"null\" : (\"size=\" + cacheArray.length)));\n\n                        if (sizeBeforeDelete == -1) {\n                            // totally fresh file\n                            response.setContent(cacheArray);\n                            try {\n                                Cache.store(response.url(), response.getResponseHeader(), cacheArray);\n                                sb.toIndexer(response);\n                            } catch (final IOException e) {\n                                log.logWarning(\"cannot write \" + response.url() + \" to Cache (1): \" + e.getMessage(), e);\n                            }\n                            conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_CODE, \"TCP_MISS\");\n                        } else if (cacheArray != null && sizeBeforeDelete == cacheArray.length) {\n                            // before we came here we deleted a cache entry\n                            cacheArray = null;\n                            //cacheManager.push(cacheEntry); // unnecessary update\n                            conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_CODE, \"TCP_REF_FAIL_HIT\");\n                        } else {\n                            // before we came here we deleted a cache entry\n                            response.setContent(cacheArray);\n                            try {\n                                Cache.store(response.url(), response.getResponseHeader(), cacheArray);\n                                sb.toIndexer(response);\n                            } catch (final IOException e) {\n                                log.logWarning(\"cannot write \" + response.url() + \" to Cache (2): \" + e.getMessage(), e);\n                            }\n                            conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_CODE, \"TCP_REFRESH_MISS\");\n                        }\n                    } else {\n                        // no caching\n                        if (log.isFine()) log.logFine(reqID +\" \"+ url.toString() + \" not cached.\" +\n                                \" StoreError=\" + ((storeError==null)?\"None\":storeError) +\n                                \" StoreHTCache=\" + storeHTCache +\n                                \" SupportError=\" + supportError);\n\n//                        FileUtils.copy(res.getDataAsStream(), outStream);\n                        client.writeTo(outStream);\n\n                        conProp.put(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_CODE,\"TCP_MISS\");\n                    }\n\n                    outStream.close();\n                    if (chunkedOut != null) {\n                        chunkedOut.finish();\n                        chunkedOut.flush();\n                    }\n                } // end hasBody\n            } catch(final SocketException se) {\n                // if opened ...\n//                if(res != null) {\n//                    // client cut proxy connection, abort download\n//                    res.abort();\n//                }\n            \tclient.finish();\n                handleProxyException(se,conProp,respond,url);\n            } finally {\n                // if opened ...\n//                if(res != null) {\n//                    // ... close connection\n//                    res.closeStream();\n//                }\n            \tclient.finish();\n            }\n        } catch (final Exception e) {\n            handleProxyException(e,conProp,respond,url);\n        }\n    }","commit_id":"9cbfc1a1c01051182abd425b40d4ee8b9d6249e8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void doConnect(final HashMap<String, Object> conProp, final RequestHeader requestHeader, final InputStream clientIn, final OutputStream clientOut) throws IOException {\r\n\r\n        sb.proxyLastAccess = System.currentTimeMillis();\r\n\r\n        String host = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HOST);\r\n        final String httpVersion = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\r\n        String path = (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);\r\n        final String args = (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS);\r\n        if (args != null) { path = path + \"?\" + args; }\r\n\r\n        int port, pos;\r\n        if ((pos = host.indexOf(':')) < 0) {\r\n            port = 80;\r\n        } else {\r\n            port = NumberTools.parseIntDecSubstring(host, pos + 1);\r\n            host = host.substring(0, pos);\r\n        }\r\n\r\n        // check the blacklist\r\n        // blacklist idea inspired by [AS]:\r\n        // respond a 404 for all AGIS (\"all you get is shit\") servers\r\n        final String hostlow = host.toLowerCase();\r\n        if (Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_PROXY, hostlow, path)) {\r\n            HTTPDemon.sendRespondError(conProp,clientOut,4,403,null,\r\n                    \"URL '\" + hostlow + \"' blocked by yacy proxy (blacklisted)\",null);\r\n            log.logInfo(\"AGIS blocking of host '\" + hostlow + \"'\");\r\n            forceConnectionClose(conProp);\r\n            return;\r\n        }\r\n\r\n        // possibly branch into PROXY-PROXY connection\r\n        if (ProxySettings.use && ProxySettings.use4ssl) {\r\n        \tfinal HTTPClient remoteProxy = setupHttpClient(requestHeader, host);\r\n\r\n            try {\r\n            \tremoteProxy.HEADResponse(\"http://\" + host + \":\" + port);\r\n            \tfinal ResponseHeader header = new ResponseHeader(remoteProxy.getHttpResponse().getAllHeaders());\r\n\r\n                // outputs a logline to the serverlog with the current status\r\n            \tlog.logInfo(\"CONNECT-RESPONSE: status=\" + remoteProxy.getHttpResponse().getStatusLine() + \", header=\" + header.toString());\r\n            \tfinal boolean success = remoteProxy.getHttpResponse().getStatusLine().getStatusCode() >= 200 && remoteProxy.getHttpResponse().getStatusLine().getStatusCode() <= 399;\r\n                if (success) {\r\n                    // replace connection details\r\n                    host = ProxySettings.host;\r\n                    port = ProxySettings.port;\r\n                    // go on (see below)\r\n                } else {\r\n                    // pass error response back to client\r\n                \tHTTPDemon.sendRespondHeader(\r\n                \t\t\tconProp,\r\n                \t\t\tclientOut,\r\n                \t\t\thttpVersion,\r\n                \t\t\tremoteProxy.getHttpResponse().getStatusLine().getStatusCode(),\r\n                \t\t\tremoteProxy.getHttpResponse().getStatusLine().toString(),\r\n                \t\t\theader);\r\n                    //respondHeader(clientOut, response.status, response.responseHeader);\r\n                    forceConnectionClose(conProp);\r\n                    return;\r\n                }\r\n            } catch (final Exception e) {\r\n                throw new IOException(e.getMessage());\r\n            }\r\n        }\r\n\r\n        // try to establish connection to remote host\r\n        final Socket sslSocket = new Socket(host, port);\r\n        sslSocket.setSoTimeout(timeout); // waiting time for write\r\n        sslSocket.setSoLinger(true, timeout); // waiting time for read\r\n        final InputStream promiscuousIn  = sslSocket.getInputStream();\r\n        final OutputStream promiscuousOut = sslSocket.getOutputStream();\r\n\r\n        // now then we can return a success message\r\n        clientOut.write(UTF8.getBytes(httpVersion + \" 200 Connection established\" + serverCore.CRLF_STRING +\r\n                \"Proxy-agent: YACY\" + serverCore.CRLF_STRING +\r\n                serverCore.CRLF_STRING));\r\n\r\n        log.logInfo(\"SSL connection to \" + host + \":\" + port + \" established.\");\r\n\r\n        // start stream passing with mediate processes\r\n        final Mediate cs = new Mediate(sslSocket, clientIn, promiscuousOut);\r\n        final Mediate sc = new Mediate(sslSocket, promiscuousIn, clientOut);\r\n        cs.start();\r\n        sc.start();\r\n        while ((sslSocket != null) &&\r\n               (sslSocket.isBound()) &&\r\n               (!(sslSocket.isClosed())) &&\r\n               (sslSocket.isConnected()) &&\r\n               ((cs.isAlive()) || (sc.isAlive()))) {\r\n            // idle\r\n            try {Thread.sleep(1000);} catch (final InterruptedException e) {} // wait a while\r\n        }\r\n        // set stop mode\r\n        cs.pleaseTerminate();\r\n        sc.pleaseTerminate();\r\n        // wake up thread\r\n        cs.interrupt();\r\n        sc.interrupt();\r\n        // ...hope they have terminated...\r\n    }","id":97796,"modified_method":"public static void doConnect(final HashMap<String, Object> conProp, final RequestHeader requestHeader, final InputStream clientIn, final OutputStream clientOut) throws IOException {\n\n        sb.proxyLastAccess = System.currentTimeMillis();\n\n        String host = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HOST);\n        final String httpVersion = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\n        String path = (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);\n        final String args = (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS);\n        if (args != null) { path = path + \"?\" + args; }\n\n        int port, pos;\n        if ((pos = host.indexOf(':')) < 0) {\n            port = 80;\n        } else {\n            port = Integer.parseInt(host.substring(pos + 1));\n            host = host.substring(0, pos);\n        }\n\n        // check the blacklist\n        // blacklist idea inspired by [AS]:\n        // respond a 404 for all AGIS (\"all you get is shit\") servers\n        final String hostlow = host.toLowerCase();\n        if (Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_PROXY, hostlow, path)) {\n            HTTPDemon.sendRespondError(conProp,clientOut,4,403,null,\n                    \"URL '\" + hostlow + \"' blocked by yacy proxy (blacklisted)\",null);\n            log.logInfo(\"AGIS blocking of host '\" + hostlow + \"'\");\n            forceConnectionClose(conProp);\n            return;\n        }\n\n        // possibly branch into PROXY-PROXY connection\n        if (ProxySettings.use && ProxySettings.use4ssl) {\n        \tfinal HTTPClient remoteProxy = setupHttpClient(requestHeader, host);\n\n            try {\n            \tremoteProxy.HEADResponse(\"http://\" + host + \":\" + port);\n            \tfinal ResponseHeader header = new ResponseHeader(remoteProxy.getHttpResponse().getAllHeaders());\n\n                // outputs a logline to the serverlog with the current status\n            \tlog.logInfo(\"CONNECT-RESPONSE: status=\" + remoteProxy.getHttpResponse().getStatusLine() + \", header=\" + header.toString());\n            \tfinal boolean success = remoteProxy.getHttpResponse().getStatusLine().getStatusCode() >= 200 && remoteProxy.getHttpResponse().getStatusLine().getStatusCode() <= 399;\n                if (success) {\n                    // replace connection details\n                    host = ProxySettings.host;\n                    port = ProxySettings.port;\n                    // go on (see below)\n                } else {\n                    // pass error response back to client\n                \tHTTPDemon.sendRespondHeader(\n                \t\t\tconProp,\n                \t\t\tclientOut,\n                \t\t\thttpVersion,\n                \t\t\tremoteProxy.getHttpResponse().getStatusLine().getStatusCode(),\n                \t\t\tremoteProxy.getHttpResponse().getStatusLine().toString(),\n                \t\t\theader);\n                    //respondHeader(clientOut, response.status, response.responseHeader);\n                    forceConnectionClose(conProp);\n                    return;\n                }\n            } catch (final Exception e) {\n                throw new IOException(e.getMessage());\n            }\n        }\n\n        // try to establish connection to remote host\n        final Socket sslSocket = new Socket(host, port);\n        sslSocket.setSoTimeout(timeout); // waiting time for write\n        sslSocket.setSoLinger(true, timeout); // waiting time for read\n        final InputStream promiscuousIn  = sslSocket.getInputStream();\n        final OutputStream promiscuousOut = sslSocket.getOutputStream();\n\n        // now then we can return a success message\n        clientOut.write(UTF8.getBytes(httpVersion + \" 200 Connection established\" + serverCore.CRLF_STRING +\n                \"Proxy-agent: YACY\" + serverCore.CRLF_STRING +\n                serverCore.CRLF_STRING));\n\n        log.logInfo(\"SSL connection to \" + host + \":\" + port + \" established.\");\n\n        // start stream passing with mediate processes\n        final Mediate cs = new Mediate(sslSocket, clientIn, promiscuousOut);\n        final Mediate sc = new Mediate(sslSocket, promiscuousIn, clientOut);\n        cs.start();\n        sc.start();\n        while ((sslSocket != null) &&\n               (sslSocket.isBound()) &&\n               (!(sslSocket.isClosed())) &&\n               (sslSocket.isConnected()) &&\n               ((cs.isAlive()) || (sc.isAlive()))) {\n            // idle\n            try {Thread.sleep(1000);} catch (final InterruptedException e) {} // wait a while\n        }\n        // set stop mode\n        cs.pleaseTerminate();\n        sc.pleaseTerminate();\n        // wake up thread\n        cs.interrupt();\n        sc.interrupt();\n        // ...hope they have terminated...\n    }","commit_id":"9cbfc1a1c01051182abd425b40d4ee8b9d6249e8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static void removeHopByHopHeaders(final HeaderFramework headers) {\r\n        /*\r\n         - Trailers\r\n         */\r\n\r\n        headers.remove(RequestHeader.CONNECTION);\r\n        headers.remove(RequestHeader.KEEP_ALIVE);\r\n        headers.remove(RequestHeader.UPGRADE);\r\n        headers.remove(RequestHeader.TE);\r\n        headers.remove(RequestHeader.PROXY_CONNECTION);\r\n        headers.remove(RequestHeader.PROXY_AUTHENTICATE);\r\n        headers.remove(RequestHeader.PROXY_AUTHORIZATION);\r\n\r\n        // special headers inserted by squid\r\n        headers.remove(RequestHeader.X_CACHE);\r\n        headers.remove(RequestHeader.X_CACHE_LOOKUP);\r\n\r\n        // remove transfer encoding header\r\n        headers.remove(HeaderFramework.TRANSFER_ENCODING);\r\n\r\n        //removing yacy status headers\r\n        headers.remove(HeaderFramework.X_YACY_KEEP_ALIVE_REQUEST_COUNT);\r\n        headers.remove(HeaderFramework.X_YACY_ORIGINAL_REQUEST_LINE);\r\n    }","id":97797,"modified_method":"private static void removeHopByHopHeaders(final HeaderFramework headers) {\n        /*\n         - Trailers\n         */\n\n        headers.remove(RequestHeader.CONNECTION);\n        headers.remove(RequestHeader.KEEP_ALIVE);\n        headers.remove(RequestHeader.UPGRADE);\n        headers.remove(RequestHeader.TE);\n        headers.remove(RequestHeader.PROXY_CONNECTION);\n        headers.remove(RequestHeader.PROXY_AUTHENTICATE);\n        headers.remove(RequestHeader.PROXY_AUTHORIZATION);\n\n        // special headers inserted by squid\n        headers.remove(RequestHeader.X_CACHE);\n        headers.remove(RequestHeader.X_CACHE_LOOKUP);\n\n        // remove transfer encoding header\n        // headers.remove(HeaderFramework.TRANSFER_ENCODING);\n\n        //removing yacy status headers\n        headers.remove(HeaderFramework.X_YACY_KEEP_ALIVE_REQUEST_COUNT);\n        headers.remove(HeaderFramework.X_YACY_ORIGINAL_REQUEST_LINE);\n    }","commit_id":"9cbfc1a1c01051182abd425b40d4ee8b9d6249e8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    private static ArrayList<String>[] getFiles(final String htrootPath) {\n        final File htroot = new File(htrootPath);\n        if (!htroot.exists()) return null;\n        final ArrayList<String> htrootFiles = new ArrayList<String>();\n        final ArrayList<String> htrootDirs = new ArrayList<String>();\n        final String[] htroots = htroot.list();\n        File file;\n        for (int i=0, dot; i<htroots.length; i++) {\n            if (htroots[i].equals(\"www\")) continue;\n            file = new File(htroot, htroots[i]);\n            if (file.isDirectory()) {\n                htrootDirs.add(htroots[i]);\n            } else if (\n                    ((dot = htroots[i].lastIndexOf('.')) < 2 ||\n                    htroots[i].charAt(dot - 2) == '_' && htroots[i].charAt(dot - 1) == 'p') &&\n                    !(htroots[i].endsWith(\"java\") || htroots[i].endsWith(\"class\"))\n            ) {\n                htrootFiles.add(htroots[i]);\n            }\n        }\n        return new ArrayList[] { htrootFiles, htrootDirs };\n    }","id":97798,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private static ArrayList<String>[] getFiles(final String htrootPath) {\n        final File htroot = new File(htrootPath);\n        if (!htroot.exists()) return null;\n        final ArrayList<String> htrootFiles = new ArrayList<String>();\n        final ArrayList<String> htrootDirs = new ArrayList<String>();\n        final String[] htroots = htroot.list();\n        File file;\n        for (int i=0, dot; i<htroots.length; i++) {\n            if (htroots[i].equals(\"www\")) continue;\n            file = new File(htroot, htroots[i]);\n            if (file.isDirectory()) {\n                htrootDirs.add(htroots[i]);\n            } else if (\n                    ((dot = htroots[i].lastIndexOf('.')) < 2 ||\n                    htroots[i].charAt(dot - 2) == '_' && htroots[i].charAt(dot - 1) == 'p') &&\n                    !(htroots[i].endsWith(\"java\") || htroots[i].endsWith(\"class\"))\n            ) {\n                htrootFiles.add(htroots[i]);\n            }\n        }\n        return (ArrayList<String>[]) new Object[] { htrootFiles, htrootDirs };\n    }","commit_id":"9cbfc1a1c01051182abd425b40d4ee8b9d6249e8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n\tpublic LayoutRevision addLayoutRevision(\n\t\t\tlong userId, long layoutSetBranchId, long layoutBranchId,\n\t\t\tlong parentLayoutRevisionId, boolean head, long plid,\n\t\t\tlong portletPreferencesPlid, boolean privateLayout, String name,\n\t\t\tString title, String description, String keywords, String robots,\n\t\t\tString typeSettings, boolean iconImage, long iconImageId,\n\t\t\tString themeId, String colorSchemeId, String wapThemeId,\n\t\t\tString wapColorSchemeId, String css, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Layout revision\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tLayoutSetBranch layoutSetBranch =\n\t\t\tlayoutSetBranchPersistence.findByPrimaryKey(layoutSetBranchId);\n\t\tparentLayoutRevisionId = getParentLayoutRevisionId(\n\t\t\tlayoutSetBranchId, parentLayoutRevisionId, plid);\n\t\tDate now = new Date();\n\n\t\tlong layoutRevisionId = counterLocalService.increment();\n\n\t\tLayoutRevision layoutRevision = layoutRevisionPersistence.create(\n\t\t\tlayoutRevisionId);\n\n\t\tlayoutRevision.setGroupId(layoutSetBranch.getGroupId());\n\t\tlayoutRevision.setCompanyId(user.getCompanyId());\n\t\tlayoutRevision.setUserId(user.getUserId());\n\t\tlayoutRevision.setUserName(user.getFullName());\n\t\tlayoutRevision.setCreateDate(serviceContext.getCreateDate(now));\n\t\tlayoutRevision.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tlayoutRevision.setLayoutSetBranchId(layoutSetBranchId);\n\t\tlayoutRevision.setLayoutBranchId(layoutBranchId);\n\t\tlayoutRevision.setParentLayoutRevisionId(parentLayoutRevisionId);\n\t\tlayoutRevision.setHead(head);\n\t\tlayoutRevision.setPlid(plid);\n\t\tlayoutRevision.setPrivateLayout(privateLayout);\n\t\tlayoutRevision.setName(name);\n\t\tlayoutRevision.setTitle(title);\n\t\tlayoutRevision.setDescription(description);\n\t\tlayoutRevision.setKeywords(keywords);\n\t\tlayoutRevision.setRobots(robots);\n\t\tlayoutRevision.setTypeSettings(typeSettings);\n\n\t\tif (iconImage) {\n\t\t\tlayoutRevision.setIconImage(iconImage);\n\t\t\tlayoutRevision.setIconImageId(iconImageId);\n\t\t}\n\n\t\tlayoutRevision.setThemeId(themeId);\n\t\tlayoutRevision.setColorSchemeId(colorSchemeId);\n\t\tlayoutRevision.setWapThemeId(wapThemeId);\n\t\tlayoutRevision.setWapColorSchemeId(wapColorSchemeId);\n\t\tlayoutRevision.setCss(css);\n\t\tlayoutRevision.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tlayoutRevision.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tlayoutRevisionPersistence.update(layoutRevision);\n\n\t\t_layoutRevisionId.set(layoutRevision.getLayoutRevisionId());\n\n\t\t// Portlet preferences\n\n\t\tif (portletPreferencesPlid == LayoutConstants.DEFAULT_PLID) {\n\t\t\tportletPreferencesPlid = plid;\n\t\t}\n\n\t\tcopyPortletPreferences(\n\t\t\tlayoutRevision, portletPreferencesPlid, serviceContext);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), layoutRevision.getGroupId(), user.getUserId(),\n\t\t\tLayoutRevision.class.getName(),\n\t\t\tlayoutRevision.getLayoutRevisionId(), layoutRevision,\n\t\t\tserviceContext);\n\n\t\tStagingUtil.setRecentLayoutRevisionId(\n\t\t\tuser, layoutSetBranchId, plid,\n\t\t\tlayoutRevision.getLayoutRevisionId());\n\n\t\treturn layoutRevision;\n\t}","id":97799,"modified_method":"@Override\n\tpublic LayoutRevision addLayoutRevision(\n\t\t\tlong userId, long layoutSetBranchId, long layoutBranchId,\n\t\t\tlong parentLayoutRevisionId, boolean head, long plid,\n\t\t\tlong portletPreferencesPlid, boolean privateLayout, String name,\n\t\t\tString title, String description, String keywords, String robots,\n\t\t\tString typeSettings, boolean iconImage, long iconImageId,\n\t\t\tString themeId, String colorSchemeId, String wapThemeId,\n\t\t\tString wapColorSchemeId, String css, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Layout revision\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tLayoutSetBranch layoutSetBranch =\n\t\t\tlayoutSetBranchPersistence.findByPrimaryKey(layoutSetBranchId);\n\t\tparentLayoutRevisionId = getParentLayoutRevisionId(\n\t\t\tlayoutSetBranchId, parentLayoutRevisionId, plid);\n\t\tDate now = new Date();\n\n\t\tlong layoutRevisionId = counterLocalService.increment();\n\n\t\tLayoutRevision layoutRevision = layoutRevisionPersistence.create(\n\t\t\tlayoutRevisionId);\n\n\t\tlayoutRevision.setGroupId(layoutSetBranch.getGroupId());\n\t\tlayoutRevision.setCompanyId(user.getCompanyId());\n\t\tlayoutRevision.setUserId(user.getUserId());\n\t\tlayoutRevision.setUserName(user.getFullName());\n\t\tlayoutRevision.setCreateDate(serviceContext.getCreateDate(now));\n\t\tlayoutRevision.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tlayoutRevision.setLayoutSetBranchId(layoutSetBranchId);\n\t\tlayoutRevision.setLayoutBranchId(layoutBranchId);\n\t\tlayoutRevision.setParentLayoutRevisionId(parentLayoutRevisionId);\n\t\tlayoutRevision.setHead(head);\n\t\tlayoutRevision.setPlid(plid);\n\t\tlayoutRevision.setPrivateLayout(privateLayout);\n\t\tlayoutRevision.setName(name);\n\t\tlayoutRevision.setTitle(title);\n\t\tlayoutRevision.setDescription(description);\n\t\tlayoutRevision.setKeywords(keywords);\n\t\tlayoutRevision.setRobots(robots);\n\t\tlayoutRevision.setTypeSettings(typeSettings);\n\t\tlayoutRevision.setIconImageId(iconImageId);\n\t\tlayoutRevision.setThemeId(themeId);\n\t\tlayoutRevision.setColorSchemeId(colorSchemeId);\n\t\tlayoutRevision.setWapThemeId(wapThemeId);\n\t\tlayoutRevision.setWapColorSchemeId(wapColorSchemeId);\n\t\tlayoutRevision.setCss(css);\n\t\tlayoutRevision.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tlayoutRevision.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tlayoutRevisionPersistence.update(layoutRevision);\n\n\t\t_layoutRevisionId.set(layoutRevision.getLayoutRevisionId());\n\n\t\t// Portlet preferences\n\n\t\tif (portletPreferencesPlid == LayoutConstants.DEFAULT_PLID) {\n\t\t\tportletPreferencesPlid = plid;\n\t\t}\n\n\t\tcopyPortletPreferences(\n\t\t\tlayoutRevision, portletPreferencesPlid, serviceContext);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), layoutRevision.getGroupId(), user.getUserId(),\n\t\t\tLayoutRevision.class.getName(),\n\t\t\tlayoutRevision.getLayoutRevisionId(), layoutRevision,\n\t\t\tserviceContext);\n\n\t\tStagingUtil.setRecentLayoutRevisionId(\n\t\t\tuser, layoutSetBranchId, plid,\n\t\t\tlayoutRevision.getLayoutRevisionId());\n\n\t\treturn layoutRevision;\n\t}","commit_id":"8445872f965d465dc2abd0e22dd9fed7a96bfec1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic LayoutRevision updateLayoutRevision(\n\t\t\tlong userId, long layoutRevisionId, long layoutBranchId,\n\t\t\tString name, String title, String description, String keywords,\n\t\t\tString robots, String typeSettings, boolean iconImage,\n\t\t\tlong iconImageId, String themeId, String colorSchemeId,\n\t\t\tString wapThemeId, String wapColorSchemeId, String css,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Layout revision\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tLayoutRevision oldLayoutRevision =\n\t\t\tlayoutRevisionPersistence.findByPrimaryKey(layoutRevisionId);\n\t\tDate now = new Date();\n\n\t\tLayoutRevision layoutRevision = null;\n\n\t\tint workflowAction = serviceContext.getWorkflowAction();\n\n\t\tboolean revisionInProgress = ParamUtil.getBoolean(\n\t\t\tserviceContext, \"revisionInProgress\");\n\n\t\tif (!MergeLayoutPrototypesThreadLocal.isInProgress() &&\n\t\t\t(workflowAction != WorkflowConstants.ACTION_PUBLISH) &&\n\t\t\t(_layoutRevisionId.get() <= 0) && !revisionInProgress) {\n\n\t\t\tlong newLayoutRevisionId = counterLocalService.increment();\n\n\t\t\tlayoutRevision = layoutRevisionPersistence.create(\n\t\t\t\tnewLayoutRevisionId);\n\n\t\t\tlayoutRevision.setGroupId(oldLayoutRevision.getGroupId());\n\t\t\tlayoutRevision.setCompanyId(oldLayoutRevision.getCompanyId());\n\t\t\tlayoutRevision.setUserId(user.getUserId());\n\t\t\tlayoutRevision.setUserName(user.getFullName());\n\t\t\tlayoutRevision.setCreateDate(serviceContext.getCreateDate(now));\n\t\t\tlayoutRevision.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\t\tlayoutRevision.setLayoutSetBranchId(\n\t\t\t\toldLayoutRevision.getLayoutSetBranchId());\n\t\t\tlayoutRevision.setParentLayoutRevisionId(\n\t\t\t\toldLayoutRevision.getLayoutRevisionId());\n\t\t\tlayoutRevision.setHead(false);\n\t\t\tlayoutRevision.setLayoutBranchId(layoutBranchId);\n\t\t\tlayoutRevision.setPlid(oldLayoutRevision.getPlid());\n\t\t\tlayoutRevision.setPrivateLayout(\n\t\t\t\toldLayoutRevision.isPrivateLayout());\n\t\t\tlayoutRevision.setName(name);\n\t\t\tlayoutRevision.setTitle(title);\n\t\t\tlayoutRevision.setDescription(description);\n\t\t\tlayoutRevision.setKeywords(keywords);\n\t\t\tlayoutRevision.setRobots(robots);\n\t\t\tlayoutRevision.setTypeSettings(typeSettings);\n\n\t\t\tif (iconImage) {\n\t\t\t\tlayoutRevision.setIconImage(iconImage);\n\t\t\t\tlayoutRevision.setIconImageId(iconImageId);\n\t\t\t}\n\n\t\t\tlayoutRevision.setThemeId(themeId);\n\t\t\tlayoutRevision.setColorSchemeId(colorSchemeId);\n\t\t\tlayoutRevision.setWapThemeId(wapThemeId);\n\t\t\tlayoutRevision.setWapColorSchemeId(wapColorSchemeId);\n\t\t\tlayoutRevision.setCss(css);\n\t\t\tlayoutRevision.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t\tlayoutRevision.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\t\tlayoutRevisionPersistence.update(layoutRevision);\n\n\t\t\t_layoutRevisionId.set(layoutRevision.getLayoutRevisionId());\n\n\t\t\t// Portlet preferences\n\n\t\t\tcopyPortletPreferences(\n\t\t\t\tlayoutRevision, layoutRevision.getParentLayoutRevisionId(),\n\t\t\t\tserviceContext);\n\n\t\t\tStagingUtil.setRecentLayoutBranchId(\n\t\t\t\tuser, layoutRevision.getLayoutSetBranchId(),\n\t\t\t\tlayoutRevision.getPlid(), layoutRevision.getLayoutBranchId());\n\t\t}\n\t\telse {\n\t\t\tif (_layoutRevisionId.get() > 0) {\n\t\t\t\tlayoutRevision = layoutRevisionPersistence.findByPrimaryKey(\n\t\t\t\t\t_layoutRevisionId.get());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayoutRevision = oldLayoutRevision;\n\t\t\t}\n\n\t\t\tlayoutRevision.setName(name);\n\t\t\tlayoutRevision.setTitle(title);\n\t\t\tlayoutRevision.setDescription(description);\n\t\t\tlayoutRevision.setKeywords(keywords);\n\t\t\tlayoutRevision.setRobots(robots);\n\t\t\tlayoutRevision.setTypeSettings(typeSettings);\n\n\t\t\tif (iconImage) {\n\t\t\t\tlayoutRevision.setIconImage(iconImage);\n\t\t\t\tlayoutRevision.setIconImageId(iconImageId);\n\t\t\t}\n\n\t\t\tlayoutRevision.setThemeId(themeId);\n\t\t\tlayoutRevision.setColorSchemeId(colorSchemeId);\n\t\t\tlayoutRevision.setWapThemeId(wapThemeId);\n\t\t\tlayoutRevision.setWapColorSchemeId(wapColorSchemeId);\n\t\t\tlayoutRevision.setCss(css);\n\n\t\t\tlayoutRevisionPersistence.update(layoutRevision);\n\n\t\t\t_layoutRevisionId.set(layoutRevision.getLayoutRevisionId());\n\t\t}\n\n\t\tboolean major = ParamUtil.getBoolean(serviceContext, \"major\");\n\n\t\tif (major) {\n\t\t\tupdateMajor(layoutRevision);\n\t\t}\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tlayoutRevision.getCompanyId(), layoutRevision.getGroupId(), userId,\n\t\t\tLayoutRevision.class.getName(),\n\t\t\tlayoutRevision.getLayoutRevisionId(), layoutRevision,\n\t\t\tserviceContext);\n\n\t\treturn layoutRevision;\n\t}","id":97800,"modified_method":"@Override\n\tpublic LayoutRevision updateLayoutRevision(\n\t\t\tlong userId, long layoutRevisionId, long layoutBranchId,\n\t\t\tString name, String title, String description, String keywords,\n\t\t\tString robots, String typeSettings, boolean iconImage,\n\t\t\tlong iconImageId, String themeId, String colorSchemeId,\n\t\t\tString wapThemeId, String wapColorSchemeId, String css,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Layout revision\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tLayoutRevision oldLayoutRevision =\n\t\t\tlayoutRevisionPersistence.findByPrimaryKey(layoutRevisionId);\n\t\tDate now = new Date();\n\n\t\tLayoutRevision layoutRevision = null;\n\n\t\tint workflowAction = serviceContext.getWorkflowAction();\n\n\t\tboolean revisionInProgress = ParamUtil.getBoolean(\n\t\t\tserviceContext, \"revisionInProgress\");\n\n\t\tif (!MergeLayoutPrototypesThreadLocal.isInProgress() &&\n\t\t\t(workflowAction != WorkflowConstants.ACTION_PUBLISH) &&\n\t\t\t(_layoutRevisionId.get() <= 0) && !revisionInProgress) {\n\n\t\t\tlong newLayoutRevisionId = counterLocalService.increment();\n\n\t\t\tlayoutRevision = layoutRevisionPersistence.create(\n\t\t\t\tnewLayoutRevisionId);\n\n\t\t\tlayoutRevision.setGroupId(oldLayoutRevision.getGroupId());\n\t\t\tlayoutRevision.setCompanyId(oldLayoutRevision.getCompanyId());\n\t\t\tlayoutRevision.setUserId(user.getUserId());\n\t\t\tlayoutRevision.setUserName(user.getFullName());\n\t\t\tlayoutRevision.setCreateDate(serviceContext.getCreateDate(now));\n\t\t\tlayoutRevision.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\t\tlayoutRevision.setLayoutSetBranchId(\n\t\t\t\toldLayoutRevision.getLayoutSetBranchId());\n\t\t\tlayoutRevision.setParentLayoutRevisionId(\n\t\t\t\toldLayoutRevision.getLayoutRevisionId());\n\t\t\tlayoutRevision.setHead(false);\n\t\t\tlayoutRevision.setLayoutBranchId(layoutBranchId);\n\t\t\tlayoutRevision.setPlid(oldLayoutRevision.getPlid());\n\t\t\tlayoutRevision.setPrivateLayout(\n\t\t\t\toldLayoutRevision.isPrivateLayout());\n\t\t\tlayoutRevision.setName(name);\n\t\t\tlayoutRevision.setTitle(title);\n\t\t\tlayoutRevision.setDescription(description);\n\t\t\tlayoutRevision.setKeywords(keywords);\n\t\t\tlayoutRevision.setRobots(robots);\n\t\t\tlayoutRevision.setTypeSettings(typeSettings);\n\t\t\tlayoutRevision.setIconImageId(iconImageId);\n\t\t\tlayoutRevision.setThemeId(themeId);\n\t\t\tlayoutRevision.setColorSchemeId(colorSchemeId);\n\t\t\tlayoutRevision.setWapThemeId(wapThemeId);\n\t\t\tlayoutRevision.setWapColorSchemeId(wapColorSchemeId);\n\t\t\tlayoutRevision.setCss(css);\n\t\t\tlayoutRevision.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t\tlayoutRevision.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\t\tlayoutRevisionPersistence.update(layoutRevision);\n\n\t\t\t_layoutRevisionId.set(layoutRevision.getLayoutRevisionId());\n\n\t\t\t// Portlet preferences\n\n\t\t\tcopyPortletPreferences(\n\t\t\t\tlayoutRevision, layoutRevision.getParentLayoutRevisionId(),\n\t\t\t\tserviceContext);\n\n\t\t\tStagingUtil.setRecentLayoutBranchId(\n\t\t\t\tuser, layoutRevision.getLayoutSetBranchId(),\n\t\t\t\tlayoutRevision.getPlid(), layoutRevision.getLayoutBranchId());\n\t\t}\n\t\telse {\n\t\t\tif (_layoutRevisionId.get() > 0) {\n\t\t\t\tlayoutRevision = layoutRevisionPersistence.findByPrimaryKey(\n\t\t\t\t\t_layoutRevisionId.get());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayoutRevision = oldLayoutRevision;\n\t\t\t}\n\n\t\t\tlayoutRevision.setName(name);\n\t\t\tlayoutRevision.setTitle(title);\n\t\t\tlayoutRevision.setDescription(description);\n\t\t\tlayoutRevision.setKeywords(keywords);\n\t\t\tlayoutRevision.setRobots(robots);\n\t\t\tlayoutRevision.setTypeSettings(typeSettings);\n\t\t\tlayoutRevision.setIconImageId(iconImageId);\n\t\t\tlayoutRevision.setThemeId(themeId);\n\t\t\tlayoutRevision.setColorSchemeId(colorSchemeId);\n\t\t\tlayoutRevision.setWapThemeId(wapThemeId);\n\t\t\tlayoutRevision.setWapColorSchemeId(wapColorSchemeId);\n\t\t\tlayoutRevision.setCss(css);\n\n\t\t\tlayoutRevisionPersistence.update(layoutRevision);\n\n\t\t\t_layoutRevisionId.set(layoutRevision.getLayoutRevisionId());\n\t\t}\n\n\t\tboolean major = ParamUtil.getBoolean(serviceContext, \"major\");\n\n\t\tif (major) {\n\t\t\tupdateMajor(layoutRevision);\n\t\t}\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tlayoutRevision.getCompanyId(), layoutRevision.getGroupId(), userId,\n\t\t\tLayoutRevision.class.getName(),\n\t\t\tlayoutRevision.getLayoutRevisionId(), layoutRevision,\n\t\t\tserviceContext);\n\n\t\treturn layoutRevision;\n\t}","commit_id":"8445872f965d465dc2abd0e22dd9fed7a96bfec1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic LayoutSetBranch addLayoutSetBranch(\n\t\t\tlong userId, long groupId, boolean privateLayout, String name,\n\t\t\tString description, boolean master, long copyLayoutSetBranchId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Layout branch\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tvalidate(0, groupId, privateLayout, name, master);\n\n\t\tboolean logo = false;\n\t\tlong logoId = 0;\n\t\tString themeId = null;\n\t\tString colorSchemeId = null;\n\t\tString wapThemeId = null;\n\t\tString wapColorSchemeId = null;\n\t\tString css = null;\n\t\tString settings = null;\n\n\t\tif (copyLayoutSetBranchId > 0) {\n\t\t\tLayoutSetBranch copyLayoutSetBranch = getLayoutSetBranch(\n\t\t\t\tcopyLayoutSetBranchId);\n\n\t\t\tlogo = copyLayoutSetBranch.getLogo();\n\t\t\tlogoId = copyLayoutSetBranch.getLogoId();\n\t\t\tthemeId = copyLayoutSetBranch.getThemeId();\n\t\t\tcolorSchemeId = copyLayoutSetBranch.getColorSchemeId();\n\t\t\twapThemeId = copyLayoutSetBranch.getWapThemeId();\n\t\t\twapColorSchemeId = copyLayoutSetBranch.getWapColorSchemeId();\n\t\t\tcss = copyLayoutSetBranch.getCss();\n\t\t\tsettings = copyLayoutSetBranch.getSettings();\n\t\t}\n\t\telse {\n\t\t\tLayoutSet layoutSet = layoutSetLocalService.getLayoutSet(\n\t\t\t\tgroupId, privateLayout);\n\n\t\t\tlogo = layoutSet.getLogo();\n\t\t\tlogoId = layoutSet.getLogoId();\n\t\t\tthemeId = layoutSet.getThemeId();\n\t\t\tcolorSchemeId = layoutSet.getColorSchemeId();\n\t\t\twapThemeId = layoutSet.getWapThemeId();\n\t\t\twapColorSchemeId = layoutSet.getWapColorSchemeId();\n\t\t\tcss = layoutSet.getCss();\n\t\t\tsettings = layoutSet.getSettings();\n\t\t}\n\n\t\tlong layoutSetBranchId = counterLocalService.increment();\n\n\t\tLayoutSetBranch layoutSetBranch = layoutSetBranchPersistence.create(\n\t\t\tlayoutSetBranchId);\n\n\t\tlayoutSetBranch.setGroupId(groupId);\n\t\tlayoutSetBranch.setCompanyId(user.getCompanyId());\n\t\tlayoutSetBranch.setUserId(user.getUserId());\n\t\tlayoutSetBranch.setUserName(user.getFullName());\n\t\tlayoutSetBranch.setCreateDate(serviceContext.getCreateDate(now));\n\t\tlayoutSetBranch.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tlayoutSetBranch.setPrivateLayout(privateLayout);\n\t\tlayoutSetBranch.setName(name);\n\t\tlayoutSetBranch.setDescription(description);\n\t\tlayoutSetBranch.setMaster(master);\n\t\tlayoutSetBranch.setLogo(logo);\n\t\tlayoutSetBranch.setLogoId(logoId);\n\n\t\tif (logo) {\n\t\t\tImage logoImage = imageLocalService.getImage(logoId);\n\n\t\t\tlong layoutSetBranchLogoId = counterLocalService.increment();\n\n\t\t\timageLocalService.updateImage(\n\t\t\t\tlayoutSetBranchLogoId, logoImage.getTextObj(),\n\t\t\t\tlogoImage.getType(), logoImage.getHeight(),\n\t\t\t\tlogoImage.getWidth(), logoImage.getSize());\n\n\t\t\tlayoutSetBranch.setLogoId(layoutSetBranchLogoId);\n\t\t}\n\n\t\tlayoutSetBranch.setThemeId(themeId);\n\t\tlayoutSetBranch.setColorSchemeId(colorSchemeId);\n\t\tlayoutSetBranch.setWapThemeId(wapThemeId);\n\t\tlayoutSetBranch.setWapColorSchemeId(wapColorSchemeId);\n\t\tlayoutSetBranch.setCss(css);\n\t\tlayoutSetBranch.setSettings(settings);\n\n\t\tlayoutSetBranchPersistence.update(layoutSetBranch);\n\n\t\t// Resources\n\n\t\tresourceLocalService.addResources(\n\t\t\tuser.getCompanyId(), layoutSetBranch.getGroupId(), user.getUserId(),\n\t\t\tLayoutSetBranch.class.getName(),\n\t\t\tlayoutSetBranch.getLayoutSetBranchId(), false, true, false);\n\n\t\t// Layout revisions\n\n\t\tif (layoutSetBranch.isMaster() ||\n\t\t\t(copyLayoutSetBranchId == LayoutSetBranchConstants.ALL_BRANCHES)) {\n\n\t\t\tList<Layout> layouts = layoutPersistence.findByG_P(\n\t\t\t\tlayoutSetBranch.getGroupId(),\n\t\t\t\tlayoutSetBranch.getPrivateLayout());\n\n\t\t\tfor (Layout layout : layouts) {\n\t\t\t\tLayoutBranch layoutBranch =\n\t\t\t\t\tlayoutBranchLocalService.addLayoutBranch(\n\t\t\t\t\t\tlayoutSetBranchId, layout.getPlid(),\n\t\t\t\t\t\tLayoutBranchConstants.MASTER_BRANCH_NAME,\n\t\t\t\t\t\tLayoutBranchConstants.MASTER_BRANCH_DESCRIPTION, true,\n\t\t\t\t\t\tserviceContext);\n\n\t\t\t\tLayoutRevision lastLayoutRevision =\n\t\t\t\t\tlayoutRevisionLocalService.fetchLastLayoutRevision(\n\t\t\t\t\t\tlayout.getPlid(), true);\n\n\t\t\t\tif (lastLayoutRevision != null) {\n\t\t\t\t\tlayoutRevisionLocalService.addLayoutRevision(\n\t\t\t\t\t\tuserId, layoutSetBranchId,\n\t\t\t\t\t\tlayoutBranch.getLayoutBranchId(),\n\t\t\t\t\t\tLayoutRevisionConstants.\n\t\t\t\t\t\t\tDEFAULT_PARENT_LAYOUT_REVISION_ID,\n\t\t\t\t\t\ttrue, lastLayoutRevision.getPlid(),\n\t\t\t\t\t\tlastLayoutRevision.getLayoutRevisionId(),\n\t\t\t\t\t\tlastLayoutRevision.getPrivateLayout(),\n\t\t\t\t\t\tlastLayoutRevision.getName(),\n\t\t\t\t\t\tlastLayoutRevision.getTitle(),\n\t\t\t\t\t\tlastLayoutRevision.getDescription(),\n\t\t\t\t\t\tlastLayoutRevision.getKeywords(),\n\t\t\t\t\t\tlastLayoutRevision.getRobots(),\n\t\t\t\t\t\tlastLayoutRevision.getTypeSettings(),\n\t\t\t\t\t\tlastLayoutRevision.isIconImage(),\n\t\t\t\t\t\tlastLayoutRevision.getIconImageId(),\n\t\t\t\t\t\tlastLayoutRevision.getThemeId(),\n\t\t\t\t\t\tlastLayoutRevision.getColorSchemeId(),\n\t\t\t\t\t\tlastLayoutRevision.getWapThemeId(),\n\t\t\t\t\t\tlastLayoutRevision.getWapColorSchemeId(),\n\t\t\t\t\t\tlastLayoutRevision.getCss(), serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlayoutRevisionLocalService.addLayoutRevision(\n\t\t\t\t\t\tuserId, layoutSetBranchId,\n\t\t\t\t\t\tlayoutBranch.getLayoutBranchId(),\n\t\t\t\t\t\tLayoutRevisionConstants.\n\t\t\t\t\t\t\tDEFAULT_PARENT_LAYOUT_REVISION_ID,\n\t\t\t\t\t\tfalse, layout.getPlid(), LayoutConstants.DEFAULT_PLID,\n\t\t\t\t\t\tlayout.getPrivateLayout(), layout.getName(),\n\t\t\t\t\t\tlayout.getTitle(), layout.getDescription(),\n\t\t\t\t\t\tlayout.getKeywords(), layout.getRobots(),\n\t\t\t\t\t\tlayout.getTypeSettings(), layout.isIconImage(),\n\t\t\t\t\t\tlayout.getIconImageId(), layout.getThemeId(),\n\t\t\t\t\t\tlayout.getColorSchemeId(), layout.getWapThemeId(),\n\t\t\t\t\t\tlayout.getWapColorSchemeId(), layout.getCss(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (copyLayoutSetBranchId > 0) {\n\t\t\tList<LayoutRevision> layoutRevisions =\n\t\t\t\tlayoutRevisionLocalService.getLayoutRevisions(\n\t\t\t\t\tcopyLayoutSetBranchId, true);\n\n\t\t\tfor (LayoutRevision layoutRevision : layoutRevisions) {\n\t\t\t\tLayoutBranch layoutBranch =\n\t\t\t\t\tlayoutBranchLocalService.addLayoutBranch(\n\t\t\t\t\t\tlayoutSetBranchId, layoutRevision.getPlid(),\n\t\t\t\t\t\tLayoutBranchConstants.MASTER_BRANCH_NAME,\n\t\t\t\t\t\tLayoutBranchConstants.MASTER_BRANCH_DESCRIPTION, true,\n\t\t\t\t\t\tserviceContext);\n\n\t\t\t\tlayoutRevisionLocalService.addLayoutRevision(\n\t\t\t\t\tuserId, layoutSetBranchId, layoutBranch.getLayoutBranchId(),\n\t\t\t\t\tLayoutRevisionConstants.DEFAULT_PARENT_LAYOUT_REVISION_ID,\n\t\t\t\t\ttrue, layoutRevision.getPlid(),\n\t\t\t\t\tlayoutRevision.getLayoutRevisionId(),\n\t\t\t\t\tlayoutRevision.getPrivateLayout(), layoutRevision.getName(),\n\t\t\t\t\tlayoutRevision.getTitle(), layoutRevision.getDescription(),\n\t\t\t\t\tlayoutRevision.getKeywords(), layoutRevision.getRobots(),\n\t\t\t\t\tlayoutRevision.getTypeSettings(),\n\t\t\t\t\tlayoutRevision.isIconImage(),\n\t\t\t\t\tlayoutRevision.getIconImageId(),\n\t\t\t\t\tlayoutRevision.getThemeId(),\n\t\t\t\t\tlayoutRevision.getColorSchemeId(),\n\t\t\t\t\tlayoutRevision.getWapThemeId(),\n\t\t\t\t\tlayoutRevision.getWapColorSchemeId(),\n\t\t\t\t\tlayoutRevision.getCss(), serviceContext);\n\t\t\t}\n\t\t}\n\n\t\tLayoutSet layoutSet = layoutSetBranch.getLayoutSet();\n\n\t\tStagingUtil.setRecentLayoutSetBranchId(\n\t\t\tuser, layoutSet.getLayoutSetId(),\n\t\t\tlayoutSetBranch.getLayoutSetBranchId());\n\n\t\treturn layoutSetBranch;\n\t}","id":97801,"modified_method":"@Override\n\tpublic LayoutSetBranch addLayoutSetBranch(\n\t\t\tlong userId, long groupId, boolean privateLayout, String name,\n\t\t\tString description, boolean master, long copyLayoutSetBranchId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Layout branch\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tvalidate(0, groupId, privateLayout, name, master);\n\n\t\tboolean logo = false;\n\t\tlong logoId = 0;\n\t\tString themeId = null;\n\t\tString colorSchemeId = null;\n\t\tString wapThemeId = null;\n\t\tString wapColorSchemeId = null;\n\t\tString css = null;\n\t\tString settings = null;\n\n\t\tif (copyLayoutSetBranchId > 0) {\n\t\t\tLayoutSetBranch copyLayoutSetBranch = getLayoutSetBranch(\n\t\t\t\tcopyLayoutSetBranchId);\n\n\t\t\tlogo = copyLayoutSetBranch.getLogo();\n\t\t\tlogoId = copyLayoutSetBranch.getLogoId();\n\t\t\tthemeId = copyLayoutSetBranch.getThemeId();\n\t\t\tcolorSchemeId = copyLayoutSetBranch.getColorSchemeId();\n\t\t\twapThemeId = copyLayoutSetBranch.getWapThemeId();\n\t\t\twapColorSchemeId = copyLayoutSetBranch.getWapColorSchemeId();\n\t\t\tcss = copyLayoutSetBranch.getCss();\n\t\t\tsettings = copyLayoutSetBranch.getSettings();\n\t\t}\n\t\telse {\n\t\t\tLayoutSet layoutSet = layoutSetLocalService.getLayoutSet(\n\t\t\t\tgroupId, privateLayout);\n\n\t\t\tlogo = layoutSet.getLogo();\n\t\t\tlogoId = layoutSet.getLogoId();\n\t\t\tthemeId = layoutSet.getThemeId();\n\t\t\tcolorSchemeId = layoutSet.getColorSchemeId();\n\t\t\twapThemeId = layoutSet.getWapThemeId();\n\t\t\twapColorSchemeId = layoutSet.getWapColorSchemeId();\n\t\t\tcss = layoutSet.getCss();\n\t\t\tsettings = layoutSet.getSettings();\n\t\t}\n\n\t\tlong layoutSetBranchId = counterLocalService.increment();\n\n\t\tLayoutSetBranch layoutSetBranch = layoutSetBranchPersistence.create(\n\t\t\tlayoutSetBranchId);\n\n\t\tlayoutSetBranch.setGroupId(groupId);\n\t\tlayoutSetBranch.setCompanyId(user.getCompanyId());\n\t\tlayoutSetBranch.setUserId(user.getUserId());\n\t\tlayoutSetBranch.setUserName(user.getFullName());\n\t\tlayoutSetBranch.setCreateDate(serviceContext.getCreateDate(now));\n\t\tlayoutSetBranch.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tlayoutSetBranch.setPrivateLayout(privateLayout);\n\t\tlayoutSetBranch.setName(name);\n\t\tlayoutSetBranch.setDescription(description);\n\t\tlayoutSetBranch.setMaster(master);\n\t\tlayoutSetBranch.setLogoId(logoId);\n\n\t\tif (logo) {\n\t\t\tImage logoImage = imageLocalService.getImage(logoId);\n\n\t\t\tlong layoutSetBranchLogoId = counterLocalService.increment();\n\n\t\t\timageLocalService.updateImage(\n\t\t\t\tlayoutSetBranchLogoId, logoImage.getTextObj(),\n\t\t\t\tlogoImage.getType(), logoImage.getHeight(),\n\t\t\t\tlogoImage.getWidth(), logoImage.getSize());\n\n\t\t\tlayoutSetBranch.setLogoId(layoutSetBranchLogoId);\n\t\t}\n\n\t\tlayoutSetBranch.setThemeId(themeId);\n\t\tlayoutSetBranch.setColorSchemeId(colorSchemeId);\n\t\tlayoutSetBranch.setWapThemeId(wapThemeId);\n\t\tlayoutSetBranch.setWapColorSchemeId(wapColorSchemeId);\n\t\tlayoutSetBranch.setCss(css);\n\t\tlayoutSetBranch.setSettings(settings);\n\n\t\tlayoutSetBranchPersistence.update(layoutSetBranch);\n\n\t\t// Resources\n\n\t\tresourceLocalService.addResources(\n\t\t\tuser.getCompanyId(), layoutSetBranch.getGroupId(), user.getUserId(),\n\t\t\tLayoutSetBranch.class.getName(),\n\t\t\tlayoutSetBranch.getLayoutSetBranchId(), false, true, false);\n\n\t\t// Layout revisions\n\n\t\tif (layoutSetBranch.isMaster() ||\n\t\t\t(copyLayoutSetBranchId == LayoutSetBranchConstants.ALL_BRANCHES)) {\n\n\t\t\tList<Layout> layouts = layoutPersistence.findByG_P(\n\t\t\t\tlayoutSetBranch.getGroupId(),\n\t\t\t\tlayoutSetBranch.getPrivateLayout());\n\n\t\t\tfor (Layout layout : layouts) {\n\t\t\t\tLayoutBranch layoutBranch =\n\t\t\t\t\tlayoutBranchLocalService.addLayoutBranch(\n\t\t\t\t\t\tlayoutSetBranchId, layout.getPlid(),\n\t\t\t\t\t\tLayoutBranchConstants.MASTER_BRANCH_NAME,\n\t\t\t\t\t\tLayoutBranchConstants.MASTER_BRANCH_DESCRIPTION, true,\n\t\t\t\t\t\tserviceContext);\n\n\t\t\t\tLayoutRevision lastLayoutRevision =\n\t\t\t\t\tlayoutRevisionLocalService.fetchLastLayoutRevision(\n\t\t\t\t\t\tlayout.getPlid(), true);\n\n\t\t\t\tif (lastLayoutRevision != null) {\n\t\t\t\t\tlayoutRevisionLocalService.addLayoutRevision(\n\t\t\t\t\t\tuserId, layoutSetBranchId,\n\t\t\t\t\t\tlayoutBranch.getLayoutBranchId(),\n\t\t\t\t\t\tLayoutRevisionConstants.\n\t\t\t\t\t\t\tDEFAULT_PARENT_LAYOUT_REVISION_ID,\n\t\t\t\t\t\ttrue, lastLayoutRevision.getPlid(),\n\t\t\t\t\t\tlastLayoutRevision.getLayoutRevisionId(),\n\t\t\t\t\t\tlastLayoutRevision.getPrivateLayout(),\n\t\t\t\t\t\tlastLayoutRevision.getName(),\n\t\t\t\t\t\tlastLayoutRevision.getTitle(),\n\t\t\t\t\t\tlastLayoutRevision.getDescription(),\n\t\t\t\t\t\tlastLayoutRevision.getKeywords(),\n\t\t\t\t\t\tlastLayoutRevision.getRobots(),\n\t\t\t\t\t\tlastLayoutRevision.getTypeSettings(),\n\t\t\t\t\t\tlastLayoutRevision.isIconImage(),\n\t\t\t\t\t\tlastLayoutRevision.getIconImageId(),\n\t\t\t\t\t\tlastLayoutRevision.getThemeId(),\n\t\t\t\t\t\tlastLayoutRevision.getColorSchemeId(),\n\t\t\t\t\t\tlastLayoutRevision.getWapThemeId(),\n\t\t\t\t\t\tlastLayoutRevision.getWapColorSchemeId(),\n\t\t\t\t\t\tlastLayoutRevision.getCss(), serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlayoutRevisionLocalService.addLayoutRevision(\n\t\t\t\t\t\tuserId, layoutSetBranchId,\n\t\t\t\t\t\tlayoutBranch.getLayoutBranchId(),\n\t\t\t\t\t\tLayoutRevisionConstants.\n\t\t\t\t\t\t\tDEFAULT_PARENT_LAYOUT_REVISION_ID,\n\t\t\t\t\t\tfalse, layout.getPlid(), LayoutConstants.DEFAULT_PLID,\n\t\t\t\t\t\tlayout.getPrivateLayout(), layout.getName(),\n\t\t\t\t\t\tlayout.getTitle(), layout.getDescription(),\n\t\t\t\t\t\tlayout.getKeywords(), layout.getRobots(),\n\t\t\t\t\t\tlayout.getTypeSettings(), layout.isIconImage(),\n\t\t\t\t\t\tlayout.getIconImageId(), layout.getThemeId(),\n\t\t\t\t\t\tlayout.getColorSchemeId(), layout.getWapThemeId(),\n\t\t\t\t\t\tlayout.getWapColorSchemeId(), layout.getCss(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (copyLayoutSetBranchId > 0) {\n\t\t\tList<LayoutRevision> layoutRevisions =\n\t\t\t\tlayoutRevisionLocalService.getLayoutRevisions(\n\t\t\t\t\tcopyLayoutSetBranchId, true);\n\n\t\t\tfor (LayoutRevision layoutRevision : layoutRevisions) {\n\t\t\t\tLayoutBranch layoutBranch =\n\t\t\t\t\tlayoutBranchLocalService.addLayoutBranch(\n\t\t\t\t\t\tlayoutSetBranchId, layoutRevision.getPlid(),\n\t\t\t\t\t\tLayoutBranchConstants.MASTER_BRANCH_NAME,\n\t\t\t\t\t\tLayoutBranchConstants.MASTER_BRANCH_DESCRIPTION, true,\n\t\t\t\t\t\tserviceContext);\n\n\t\t\t\tlayoutRevisionLocalService.addLayoutRevision(\n\t\t\t\t\tuserId, layoutSetBranchId, layoutBranch.getLayoutBranchId(),\n\t\t\t\t\tLayoutRevisionConstants.DEFAULT_PARENT_LAYOUT_REVISION_ID,\n\t\t\t\t\ttrue, layoutRevision.getPlid(),\n\t\t\t\t\tlayoutRevision.getLayoutRevisionId(),\n\t\t\t\t\tlayoutRevision.getPrivateLayout(), layoutRevision.getName(),\n\t\t\t\t\tlayoutRevision.getTitle(), layoutRevision.getDescription(),\n\t\t\t\t\tlayoutRevision.getKeywords(), layoutRevision.getRobots(),\n\t\t\t\t\tlayoutRevision.getTypeSettings(),\n\t\t\t\t\tlayoutRevision.isIconImage(),\n\t\t\t\t\tlayoutRevision.getIconImageId(),\n\t\t\t\t\tlayoutRevision.getThemeId(),\n\t\t\t\t\tlayoutRevision.getColorSchemeId(),\n\t\t\t\t\tlayoutRevision.getWapThemeId(),\n\t\t\t\t\tlayoutRevision.getWapColorSchemeId(),\n\t\t\t\t\tlayoutRevision.getCss(), serviceContext);\n\t\t\t}\n\t\t}\n\n\t\tLayoutSet layoutSet = layoutSetBranch.getLayoutSet();\n\n\t\tStagingUtil.setRecentLayoutSetBranchId(\n\t\t\tuser, layoutSet.getLayoutSetId(),\n\t\t\tlayoutSetBranch.getLayoutSetBranchId());\n\n\t\treturn layoutSetBranch;\n\t}","commit_id":"8445872f965d465dc2abd0e22dd9fed7a96bfec1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Deletes the organization's logo.\n\t *\n\t * @param  organizationId the primary key of the organization\n\t * @throws PortalException if an organization or parent organization with\n\t *         the primary key could not be found or if the organization's logo\n\t *         could not be found\n\t * @throws SystemException if a system exception occurred\n\t */\n\t@Override\n\tpublic void deleteLogo(long organizationId)\n\t\tthrows PortalException, SystemException {\n\n\t\tOrganization organization = getOrganization(organizationId);\n\n\t\tGroup group = organization.getGroup();\n\n\t\tLayoutSet publicLayoutSet = layoutSetLocalService.getLayoutSet(\n\t\t\tgroup.getGroupId(), false);\n\n\t\tif (publicLayoutSet.isLogo()) {\n\t\t\tlong logoId = publicLayoutSet.getLogoId();\n\n\t\t\tpublicLayoutSet.setLogo(false);\n\t\t\tpublicLayoutSet.setLogoId(0);\n\n\t\t\tlayoutSetPersistence.update(publicLayoutSet);\n\n\t\t\timageLocalService.deleteImage(logoId);\n\t\t}\n\n\t\tLayoutSet privateLayoutSet = layoutSetLocalService.getLayoutSet(\n\t\t\tgroup.getGroupId(), true);\n\n\t\tif (privateLayoutSet.isLogo()) {\n\t\t\tlong logoId = privateLayoutSet.getLogoId();\n\n\t\t\tprivateLayoutSet.setLogo(false);\n\t\t\tprivateLayoutSet.setLogoId(0);\n\n\t\t\tlayoutSetPersistence.update(privateLayoutSet);\n\n\t\t\tif (imageLocalService.getImage(logoId) != null) {\n\t\t\t\timageLocalService.deleteImage(logoId);\n\t\t\t}\n\t\t}\n\t}","id":97802,"modified_method":"/**\n\t * Deletes the organization's logo.\n\t *\n\t * @param  organizationId the primary key of the organization\n\t * @throws PortalException if an organization or parent organization with\n\t *         the primary key could not be found or if the organization's logo\n\t *         could not be found\n\t * @throws SystemException if a system exception occurred\n\t */\n\t@Override\n\tpublic void deleteLogo(long organizationId)\n\t\tthrows PortalException, SystemException {\n\n\t\tOrganization organization = getOrganization(organizationId);\n\n\t\tGroup group = organization.getGroup();\n\n\t\tLayoutSet publicLayoutSet = layoutSetLocalService.getLayoutSet(\n\t\t\tgroup.getGroupId(), false);\n\n\t\tif (publicLayoutSet.isLogo()) {\n\t\t\tlong logoId = publicLayoutSet.getLogoId();\n\n\t\t\tpublicLayoutSet.setLogoId(0);\n\n\t\t\tlayoutSetPersistence.update(publicLayoutSet);\n\n\t\t\timageLocalService.deleteImage(logoId);\n\t\t}\n\n\t\tLayoutSet privateLayoutSet = layoutSetLocalService.getLayoutSet(\n\t\t\tgroup.getGroupId(), true);\n\n\t\tif (privateLayoutSet.isLogo()) {\n\t\t\tlong logoId = privateLayoutSet.getLogoId();\n\n\t\t\tprivateLayoutSet.setLogoId(0);\n\n\t\t\tlayoutSetPersistence.update(privateLayoutSet);\n\n\t\t\tif (imageLocalService.getImage(logoId) != null) {\n\t\t\t\timageLocalService.deleteImage(logoId);\n\t\t\t}\n\t\t}\n\t}","commit_id":"8445872f965d465dc2abd0e22dd9fed7a96bfec1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public void generate() {\n    ManifestAccess _runtimeTestManifest = this.projectConfig.getRuntimeTestManifest();\n    final Procedure1<ManifestAccess> _function = new Procedure1<ManifestAccess>() {\n      @Override\n      public void apply(final ManifestAccess it) {\n        Set<String> _requiredBundles = it.getRequiredBundles();\n        CollectionExtensions.<String>addAll(_requiredBundles, \n          \"org.eclipse.xtext.junit4\", \n          \"org.eclipse.xtext.xbase.lib\");\n        Set<String> _exportedPackages = it.getExportedPackages();\n        Grammar _grammar = Junit4Fragment2.this.getGrammar();\n        String _runtimeTestBasePackage = Junit4Fragment2.this._xtextGeneratorNaming.getRuntimeTestBasePackage(_grammar);\n        _exportedPackages.add(_runtimeTestBasePackage);\n      }\n    };\n    ObjectExtensions.<ManifestAccess>operator_doubleArrow(_runtimeTestManifest, _function);\n    ManifestAccess _eclipsePluginTestManifest = this.projectConfig.getEclipsePluginTestManifest();\n    final Procedure1<ManifestAccess> _function_1 = new Procedure1<ManifestAccess>() {\n      @Override\n      public void apply(final ManifestAccess it) {\n        Set<String> _requiredBundles = it.getRequiredBundles();\n        CollectionExtensions.<String>addAll(_requiredBundles, \n          \"org.eclipse.core.runtime\", \n          \"org.eclipse.ui.workbench;resolution:=optional\");\n        Set<String> _exportedPackages = it.getExportedPackages();\n        Grammar _grammar = Junit4Fragment2.this.getGrammar();\n        String _eclipsePluginTestBasePackage = Junit4Fragment2.this._xtextGeneratorNaming.getEclipsePluginTestBasePackage(_grammar);\n        _exportedPackages.add(_eclipsePluginTestBasePackage);\n      }\n    };\n    ObjectExtensions.<ManifestAccess>operator_doubleArrow(_eclipsePluginTestManifest, _function_1);\n    ManifestAccess _eclipsePluginManifest = this.projectConfig.getEclipsePluginManifest();\n    Set<String> _exportedPackages = _eclipsePluginManifest.getExportedPackages();\n    Grammar _grammar = this.getGrammar();\n    TypeReference _eclipsePluginActivator = this._xtextGeneratorNaming.getEclipsePluginActivator(_grammar);\n    String _packageName = _eclipsePluginActivator.getPackageName();\n    _exportedPackages.add(_packageName);\n    ManifestAccess _runtimeTestManifest_1 = this.projectConfig.getRuntimeTestManifest();\n    ManifestAccess _eclipsePluginTestManifest_1 = this.projectConfig.getEclipsePluginTestManifest();\n    final Procedure1<ManifestAccess> _function_2 = new Procedure1<ManifestAccess>() {\n      @Override\n      public void apply(final ManifestAccess it) {\n        Set<String> _importedPackages = it.getImportedPackages();\n        CollectionExtensions.<String>addAll(_importedPackages, \n          \"org.junit;version=\\\"4.5.0\\\"\", \n          \"org.junit.runner;version=\\\"4.5.0\\\"\", \n          \"org.junit.runner.manipulation;version=\\\"4.5.0\\\"\", \n          \"org.junit.runner.notification;version=\\\"4.5.0\\\"\", \n          \"org.junit.runners;version=\\\"4.5.0\\\"\", \n          \"org.junit.runners.model;version=\\\"4.5.0\\\"\", \n          \"org.hamcrest.core\");\n      }\n    };\n    IterableExtensions.<ManifestAccess>forEach(Collections.<ManifestAccess>unmodifiableList(CollectionLiterals.<ManifestAccess>newArrayList(_runtimeTestManifest_1, _eclipsePluginTestManifest_1)), _function_2);\n    JavaFileAccess _generateInjectorProvider = this.generateInjectorProvider();\n    IXtextGeneratorFileSystemAccess _runtimeTestSrcGen = this.projectConfig.getRuntimeTestSrcGen();\n    _generateInjectorProvider.writeTo(_runtimeTestSrcGen);\n    JavaFileAccess _generateExampleRuntimeTest = this.generateExampleRuntimeTest();\n    IXtextGeneratorFileSystemAccess _runtimeTestSrc = this.projectConfig.getRuntimeTestSrc();\n    _generateExampleRuntimeTest.writeTo(_runtimeTestSrc);\n    JavaFileAccess _generateUiInjectorProvider = this.generateUiInjectorProvider();\n    IXtextGeneratorFileSystemAccess _eclipsePluginTestSrcGen = this.projectConfig.getEclipsePluginTestSrcGen();\n    _generateUiInjectorProvider.writeTo(_eclipsePluginTestSrcGen);\n  }","id":97803,"modified_method":"@Override\n  public void generate() {\n    ManifestAccess _runtimeTestManifest = this.projectConfig.getRuntimeTestManifest();\n    boolean _notEquals = (!Objects.equal(_runtimeTestManifest, null));\n    if (_notEquals) {\n      ManifestAccess _runtimeTestManifest_1 = this.projectConfig.getRuntimeTestManifest();\n      final Procedure1<ManifestAccess> _function = new Procedure1<ManifestAccess>() {\n        @Override\n        public void apply(final ManifestAccess it) {\n          Set<String> _requiredBundles = it.getRequiredBundles();\n          CollectionExtensions.<String>addAll(_requiredBundles, \n            \"org.eclipse.xtext.junit4\", \n            \"org.eclipse.xtext.xbase.lib\");\n          Set<String> _exportedPackages = it.getExportedPackages();\n          Grammar _grammar = Junit4Fragment2.this.getGrammar();\n          String _runtimeTestBasePackage = Junit4Fragment2.this._xtextGeneratorNaming.getRuntimeTestBasePackage(_grammar);\n          _exportedPackages.add(_runtimeTestBasePackage);\n        }\n      };\n      ObjectExtensions.<ManifestAccess>operator_doubleArrow(_runtimeTestManifest_1, _function);\n    }\n    ManifestAccess _eclipsePluginTestManifest = this.projectConfig.getEclipsePluginTestManifest();\n    boolean _notEquals_1 = (!Objects.equal(_eclipsePluginTestManifest, null));\n    if (_notEquals_1) {\n      ManifestAccess _eclipsePluginTestManifest_1 = this.projectConfig.getEclipsePluginTestManifest();\n      final Procedure1<ManifestAccess> _function_1 = new Procedure1<ManifestAccess>() {\n        @Override\n        public void apply(final ManifestAccess it) {\n          Set<String> _requiredBundles = it.getRequiredBundles();\n          CollectionExtensions.<String>addAll(_requiredBundles, \n            \"org.eclipse.core.runtime\", \n            \"org.eclipse.ui.workbench;resolution:=optional\");\n          Set<String> _exportedPackages = it.getExportedPackages();\n          Grammar _grammar = Junit4Fragment2.this.getGrammar();\n          String _eclipsePluginTestBasePackage = Junit4Fragment2.this._xtextGeneratorNaming.getEclipsePluginTestBasePackage(_grammar);\n          _exportedPackages.add(_eclipsePluginTestBasePackage);\n        }\n      };\n      ObjectExtensions.<ManifestAccess>operator_doubleArrow(_eclipsePluginTestManifest_1, _function_1);\n    }\n    ManifestAccess _eclipsePluginManifest = this.projectConfig.getEclipsePluginManifest();\n    boolean _notEquals_2 = (!Objects.equal(_eclipsePluginManifest, null));\n    if (_notEquals_2) {\n      ManifestAccess _eclipsePluginManifest_1 = this.projectConfig.getEclipsePluginManifest();\n      Set<String> _exportedPackages = _eclipsePluginManifest_1.getExportedPackages();\n      Grammar _grammar = this.getGrammar();\n      TypeReference _eclipsePluginActivator = this._xtextGeneratorNaming.getEclipsePluginActivator(_grammar);\n      String _packageName = _eclipsePluginActivator.getPackageName();\n      _exportedPackages.add(_packageName);\n    }\n    ManifestAccess _runtimeTestManifest_2 = this.projectConfig.getRuntimeTestManifest();\n    ManifestAccess _eclipsePluginTestManifest_2 = this.projectConfig.getEclipsePluginTestManifest();\n    Iterable<ManifestAccess> _filterNull = IterableExtensions.<ManifestAccess>filterNull(Collections.<ManifestAccess>unmodifiableList(CollectionLiterals.<ManifestAccess>newArrayList(_runtimeTestManifest_2, _eclipsePluginTestManifest_2)));\n    final Procedure1<ManifestAccess> _function_2 = new Procedure1<ManifestAccess>() {\n      @Override\n      public void apply(final ManifestAccess it) {\n        Set<String> _importedPackages = it.getImportedPackages();\n        CollectionExtensions.<String>addAll(_importedPackages, \n          \"org.junit;version=\\\"4.5.0\\\"\", \n          \"org.junit.runner;version=\\\"4.5.0\\\"\", \n          \"org.junit.runner.manipulation;version=\\\"4.5.0\\\"\", \n          \"org.junit.runner.notification;version=\\\"4.5.0\\\"\", \n          \"org.junit.runners;version=\\\"4.5.0\\\"\", \n          \"org.junit.runners.model;version=\\\"4.5.0\\\"\", \n          \"org.hamcrest.core\");\n      }\n    };\n    IterableExtensions.<ManifestAccess>forEach(_filterNull, _function_2);\n    JavaFileAccess _generateInjectorProvider = this.generateInjectorProvider();\n    IXtextGeneratorFileSystemAccess _runtimeTestSrcGen = this.projectConfig.getRuntimeTestSrcGen();\n    _generateInjectorProvider.writeTo(_runtimeTestSrcGen);\n    JavaFileAccess _generateExampleRuntimeTest = this.generateExampleRuntimeTest();\n    IXtextGeneratorFileSystemAccess _runtimeTestSrc = this.projectConfig.getRuntimeTestSrc();\n    _generateExampleRuntimeTest.writeTo(_runtimeTestSrc);\n    JavaFileAccess _generateUiInjectorProvider = this.generateUiInjectorProvider();\n    IXtextGeneratorFileSystemAccess _eclipsePluginTestSrcGen = this.projectConfig.getEclipsePluginTestSrcGen();\n    _generateUiInjectorProvider.writeTo(_eclipsePluginTestSrcGen);\n  }","commit_id":"b9a3f39c7b0b0da857f01ff1ba1fb9b192bcec62","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public PomFile pom() {\n    PomFile _pom = super.pom();\n    final Procedure1<PomFile> _function = new Procedure1<PomFile>() {\n      @Override\n      public void apply(final PomFile it) {\n        it.setPackaging(\"pom\");\n        StringConcatenation _builder = new StringConcatenation();\n        _builder.append(\"<properties>\");\n        _builder.newLine();\n        {\n          WizardConfiguration _config = ParentProjectDescriptor.this.getConfig();\n          boolean _needsTychoBuild = _config.needsTychoBuild();\n          if (_needsTychoBuild) {\n            _builder.append(\"\\t\");\n            _builder.append(\"<tycho-version>0.23.1<\/tycho-version>\");\n            _builder.newLine();\n          }\n        }\n        _builder.append(\"\\t\");\n        _builder.append(\"<xtextVersion>\");\n        WizardConfiguration _config_1 = ParentProjectDescriptor.this.getConfig();\n        XtextVersion _xtextVersion = _config_1.getXtextVersion();\n        _builder.append(_xtextVersion, \"\\t\");\n        _builder.append(\"<\/xtextVersion>\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"\\t\");\n        _builder.append(\"<project.build.sourceEncoding>\");\n        WizardConfiguration _config_2 = ParentProjectDescriptor.this.getConfig();\n        Charset _encoding = _config_2.getEncoding();\n        _builder.append(_encoding, \"\\t\");\n        _builder.append(\"<\/project.build.sourceEncoding>\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"\\t\");\n        _builder.append(\"<maven.compiler.source>1.6<\/maven.compiler.source>\");\n        _builder.newLine();\n        _builder.append(\"\\t\");\n        _builder.append(\"<maven.compiler.target>1.6<\/maven.compiler.target>\");\n        _builder.newLine();\n        _builder.append(\"<\/properties>\");\n        _builder.newLine();\n        _builder.append(\"<modules>\");\n        _builder.newLine();\n        {\n          WizardConfiguration _config_3 = ParentProjectDescriptor.this.getConfig();\n          Set<ProjectDescriptor> _enabledProjects = _config_3.getEnabledProjects();\n          final Function1<ProjectDescriptor, Boolean> _function = new Function1<ProjectDescriptor, Boolean>() {\n            @Override\n            public Boolean apply(final ProjectDescriptor it) {\n              boolean _and = false;\n              boolean _notEquals = (!Objects.equal(it, ParentProjectDescriptor.this));\n              if (!_notEquals) {\n                _and = false;\n              } else {\n                boolean _isPartOfMavenBuild = it.isPartOfMavenBuild();\n                _and = _isPartOfMavenBuild;\n              }\n              return Boolean.valueOf(_and);\n            }\n          };\n          Iterable<ProjectDescriptor> _filter = IterableExtensions.<ProjectDescriptor>filter(_enabledProjects, _function);\n          for(final ProjectDescriptor p : _filter) {\n            _builder.append(\"\\t\");\n            _builder.append(\"<module>\");\n            {\n              WizardConfiguration _config_4 = ParentProjectDescriptor.this.getConfig();\n              ProjectLayout _projectLayout = _config_4.getProjectLayout();\n              boolean _equals = Objects.equal(_projectLayout, ProjectLayout.FLAT);\n              if (_equals) {\n                _builder.append(\"../\");\n              }\n            }\n            String _name = p.getName();\n            _builder.append(_name, \"\\t\");\n            _builder.append(\"<\/module>\");\n            _builder.newLineIfNotEmpty();\n          }\n        }\n        _builder.append(\"<\/modules>\");\n        _builder.newLine();\n        _builder.append(\"<build>\");\n        _builder.newLine();\n        {\n          WizardConfiguration _config_5 = ParentProjectDescriptor.this.getConfig();\n          boolean _needsTychoBuild_1 = _config_5.needsTychoBuild();\n          if (_needsTychoBuild_1) {\n            _builder.append(\"\\t\");\n            _builder.append(\"<plugins>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<plugin>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<groupId>org.eclipse.tycho<\/groupId>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<artifactId>tycho-maven-plugin<\/artifactId>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<version>${tycho-version}<\/version>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<extensions>true<\/extensions>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<\/plugin>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<plugin>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<groupId>org.eclipse.tycho<\/groupId>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<artifactId>target-platform-configuration<\/artifactId>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<version>${tycho-version}<\/version>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<configuration>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<target>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<artifact>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<groupId>\");\n            WizardConfiguration _config_6 = ParentProjectDescriptor.this.getConfig();\n            String _baseName = _config_6.getBaseName();\n            _builder.append(_baseName, \"\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/groupId>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<artifactId>\");\n            WizardConfiguration _config_7 = ParentProjectDescriptor.this.getConfig();\n            TargetPlatformProject _targetPlatformProject = _config_7.getTargetPlatformProject();\n            String _name_1 = _targetPlatformProject.getName();\n            _builder.append(_name_1, \"\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/artifactId>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<version>${project.version}<\/version>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<\/artifact>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<\/target>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<environments>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<environment>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<os>macosx<\/os>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<ws>cocoa<\/ws>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<arch>x86_64<\/arch>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<\/environment>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<environment>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<os>win32<\/os>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<ws>win32<\/ws>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<arch>x86_64<\/arch>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<\/environment>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<environment>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<os>linux<\/os>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<ws>gtk<\/ws>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<arch>x86_64<\/arch>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<\/environment>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<\/environments>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<\/configuration>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<\/plugin>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"<\/plugins>\");\n            _builder.newLine();\n          }\n        }\n        _builder.append(\"\\t\");\n        _builder.append(\"<pluginManagement>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<plugins>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<groupId>org.eclipse.xtend<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<artifactId>xtend-maven-plugin<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<version>${xtextVersion}<\/version>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<executions>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<execution>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<phase>generate-sources<\/phase>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<goals>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<goal>compile<\/goal>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<goal>testCompile<\/goal>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/goals>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/execution>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/executions>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<outputDirectory>${basedir}/\");\n        String _sourceFolder = ParentProjectDescriptor.this.sourceFolder(Outlet.MAIN_XTEND_GEN);\n        _builder.append(_sourceFolder, \"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/outputDirectory>\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<testOutputDirectory>${basedir}/\");\n        String _sourceFolder_1 = ParentProjectDescriptor.this.sourceFolder(Outlet.TEST_XTEND_GEN);\n        _builder.append(_sourceFolder_1, \"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/testOutputDirectory>\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<\/plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<groupId>org.apache.maven.plugins<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<artifactId>maven-clean-plugin<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<version>2.5<\/version>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<filesets>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<fileset>\");\n        _builder.newLine();\n        {\n          Set<Outlet> _set = IterableExtensions.<Outlet>toSet(Collections.<Outlet>unmodifiableList(CollectionLiterals.<Outlet>newArrayList(Outlet.MAIN_XTEND_GEN, Outlet.TEST_XTEND_GEN)));\n          final Function1<Outlet, String> _function_1 = new Function1<Outlet, String>() {\n            @Override\n            public String apply(final Outlet it) {\n              return ParentProjectDescriptor.this.sourceFolder(it);\n            }\n          };\n          Iterable<String> _map = IterableExtensions.<Outlet, String>map(_set, _function_1);\n          for(final String dir : _map) {\n            _builder.append(\"\\t\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"<directory>${basedir}/\");\n            _builder.append(dir, \"\\t\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/directory>\");\n            _builder.newLineIfNotEmpty();\n          }\n        }\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/fileset>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/filesets>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<\/plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<\/plugins>\");\n        _builder.newLine();\n        _builder.append(\"\\t\");\n        _builder.append(\"<\/pluginManagement>\");\n        _builder.newLine();\n        _builder.append(\"<\/build>\");\n        _builder.newLine();\n        {\n          WizardConfiguration _config_8 = ParentProjectDescriptor.this.getConfig();\n          XtextVersion _xtextVersion_1 = _config_8.getXtextVersion();\n          boolean _isSnapshot = _xtextVersion_1.isSnapshot();\n          if (_isSnapshot) {\n            _builder.append(\"<repositories>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"<repository>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<id>sonatype-snapshots<\/id>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<url>https://oss.sonatype.org/content/repositories/snapshots<\/url>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<releases><enabled>false<\/enabled><\/releases>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<snapshots><enabled>true<\/enabled><\/snapshots>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"<\/repository>\");\n            _builder.newLine();\n            _builder.append(\"<\/repositories>\");\n            _builder.newLine();\n          }\n        }\n        it.setBuildSection(_builder.toString());\n      }\n    };\n    return ObjectExtensions.<PomFile>operator_doubleArrow(_pom, _function);\n  }","id":97804,"modified_method":"@Override\n  public PomFile pom() {\n    PomFile _pom = super.pom();\n    final Procedure1<PomFile> _function = new Procedure1<PomFile>() {\n      @Override\n      public void apply(final PomFile it) {\n        it.setPackaging(\"pom\");\n        StringConcatenation _builder = new StringConcatenation();\n        _builder.append(\"<properties>\");\n        _builder.newLine();\n        {\n          WizardConfiguration _config = ParentProjectDescriptor.this.getConfig();\n          boolean _needsTychoBuild = _config.needsTychoBuild();\n          if (_needsTychoBuild) {\n            _builder.append(\"\\t\");\n            _builder.append(\"<tycho-version>0.23.1<\/tycho-version>\");\n            _builder.newLine();\n          }\n        }\n        _builder.append(\"\\t\");\n        _builder.append(\"<xtextVersion>\");\n        WizardConfiguration _config_1 = ParentProjectDescriptor.this.getConfig();\n        XtextVersion _xtextVersion = _config_1.getXtextVersion();\n        _builder.append(_xtextVersion, \"\\t\");\n        _builder.append(\"<\/xtextVersion>\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"\\t\");\n        _builder.append(\"<project.build.sourceEncoding>\");\n        WizardConfiguration _config_2 = ParentProjectDescriptor.this.getConfig();\n        Charset _encoding = _config_2.getEncoding();\n        _builder.append(_encoding, \"\\t\");\n        _builder.append(\"<\/project.build.sourceEncoding>\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"\\t\");\n        _builder.append(\"<maven.compiler.source>1.6<\/maven.compiler.source>\");\n        _builder.newLine();\n        _builder.append(\"\\t\");\n        _builder.append(\"<maven.compiler.target>1.6<\/maven.compiler.target>\");\n        _builder.newLine();\n        _builder.append(\"<\/properties>\");\n        _builder.newLine();\n        _builder.append(\"<modules>\");\n        _builder.newLine();\n        {\n          WizardConfiguration _config_3 = ParentProjectDescriptor.this.getConfig();\n          Set<ProjectDescriptor> _enabledProjects = _config_3.getEnabledProjects();\n          final Function1<ProjectDescriptor, Boolean> _function = new Function1<ProjectDescriptor, Boolean>() {\n            @Override\n            public Boolean apply(final ProjectDescriptor it) {\n              boolean _and = false;\n              boolean _notEquals = (!Objects.equal(it, ParentProjectDescriptor.this));\n              if (!_notEquals) {\n                _and = false;\n              } else {\n                boolean _isPartOfMavenBuild = it.isPartOfMavenBuild();\n                _and = _isPartOfMavenBuild;\n              }\n              return Boolean.valueOf(_and);\n            }\n          };\n          Iterable<ProjectDescriptor> _filter = IterableExtensions.<ProjectDescriptor>filter(_enabledProjects, _function);\n          for(final ProjectDescriptor p : _filter) {\n            _builder.append(\"\\t\");\n            _builder.append(\"<module>\");\n            {\n              WizardConfiguration _config_4 = ParentProjectDescriptor.this.getConfig();\n              ProjectLayout _projectLayout = _config_4.getProjectLayout();\n              boolean _equals = Objects.equal(_projectLayout, ProjectLayout.FLAT);\n              if (_equals) {\n                _builder.append(\"../\");\n              }\n            }\n            String _name = p.getName();\n            _builder.append(_name, \"\\t\");\n            _builder.append(\"<\/module>\");\n            _builder.newLineIfNotEmpty();\n          }\n        }\n        _builder.append(\"<\/modules>\");\n        _builder.newLine();\n        _builder.append(\"<build>\");\n        _builder.newLine();\n        {\n          WizardConfiguration _config_5 = ParentProjectDescriptor.this.getConfig();\n          boolean _needsTychoBuild_1 = _config_5.needsTychoBuild();\n          if (_needsTychoBuild_1) {\n            _builder.append(\"\\t\");\n            _builder.append(\"<plugins>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<plugin>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<groupId>org.eclipse.tycho<\/groupId>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<artifactId>tycho-maven-plugin<\/artifactId>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<version>${tycho-version}<\/version>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<extensions>true<\/extensions>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<\/plugin>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<plugin>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<groupId>org.eclipse.tycho<\/groupId>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<artifactId>target-platform-configuration<\/artifactId>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<version>${tycho-version}<\/version>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<configuration>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<target>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<artifact>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<groupId>\");\n            WizardConfiguration _config_6 = ParentProjectDescriptor.this.getConfig();\n            String _baseName = _config_6.getBaseName();\n            _builder.append(_baseName, \"\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/groupId>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<artifactId>\");\n            WizardConfiguration _config_7 = ParentProjectDescriptor.this.getConfig();\n            TargetPlatformProject _targetPlatformProject = _config_7.getTargetPlatformProject();\n            String _name_1 = _targetPlatformProject.getName();\n            _builder.append(_name_1, \"\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/artifactId>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<version>${project.version}<\/version>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<\/artifact>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<\/target>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<environments>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<environment>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<os>macosx<\/os>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<ws>cocoa<\/ws>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<arch>x86_64<\/arch>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<\/environment>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<environment>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<os>win32<\/os>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<ws>win32<\/ws>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<arch>x86_64<\/arch>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<\/environment>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<environment>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<os>linux<\/os>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<ws>gtk<\/ws>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<arch>x86_64<\/arch>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<\/environment>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<\/environments>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<\/configuration>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<\/plugin>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"<\/plugins>\");\n            _builder.newLine();\n          }\n        }\n        _builder.append(\"\\t\");\n        _builder.append(\"<pluginManagement>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<plugins>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<groupId>org.eclipse.xtend<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<artifactId>xtend-maven-plugin<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<version>${xtextVersion}<\/version>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<executions>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<execution>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<goals>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<goal>compile<\/goal>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<goal>testCompile<\/goal>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/goals>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/execution>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/executions>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<outputDirectory>${basedir}/\");\n        String _sourceFolder = ParentProjectDescriptor.this.sourceFolder(Outlet.MAIN_XTEND_GEN);\n        _builder.append(_sourceFolder, \"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/outputDirectory>\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<testOutputDirectory>${basedir}/\");\n        String _sourceFolder_1 = ParentProjectDescriptor.this.sourceFolder(Outlet.TEST_XTEND_GEN);\n        _builder.append(_sourceFolder_1, \"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/testOutputDirectory>\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<\/plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<groupId>org.apache.maven.plugins<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<artifactId>maven-clean-plugin<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<version>2.5<\/version>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<filesets>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<fileset>\");\n        _builder.newLine();\n        {\n          Set<Outlet> _set = IterableExtensions.<Outlet>toSet(Collections.<Outlet>unmodifiableList(CollectionLiterals.<Outlet>newArrayList(Outlet.MAIN_XTEND_GEN, Outlet.TEST_XTEND_GEN)));\n          final Function1<Outlet, String> _function_1 = new Function1<Outlet, String>() {\n            @Override\n            public String apply(final Outlet it) {\n              return ParentProjectDescriptor.this.sourceFolder(it);\n            }\n          };\n          Iterable<String> _map = IterableExtensions.<Outlet, String>map(_set, _function_1);\n          for(final String dir : _map) {\n            _builder.append(\"\\t\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"<directory>${basedir}/\");\n            _builder.append(dir, \"\\t\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/directory>\");\n            _builder.newLineIfNotEmpty();\n          }\n        }\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/fileset>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/filesets>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<\/plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<\/plugins>\");\n        _builder.newLine();\n        _builder.append(\"\\t\");\n        _builder.append(\"<\/pluginManagement>\");\n        _builder.newLine();\n        _builder.append(\"<\/build>\");\n        _builder.newLine();\n        {\n          WizardConfiguration _config_8 = ParentProjectDescriptor.this.getConfig();\n          XtextVersion _xtextVersion_1 = _config_8.getXtextVersion();\n          boolean _isSnapshot = _xtextVersion_1.isSnapshot();\n          if (_isSnapshot) {\n            _builder.append(\"<repositories>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"<repository>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<id>sonatype-snapshots<\/id>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<url>https://oss.sonatype.org/content/repositories/snapshots<\/url>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<releases><enabled>false<\/enabled><\/releases>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<snapshots><enabled>true<\/enabled><\/snapshots>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"<\/repository>\");\n            _builder.newLine();\n            _builder.append(\"<\/repositories>\");\n            _builder.newLine();\n          }\n        }\n        it.setBuildSection(_builder.toString());\n      }\n    };\n    return ObjectExtensions.<PomFile>operator_doubleArrow(_pom, _function);\n  }","commit_id":"b9a3f39c7b0b0da857f01ff1ba1fb9b192bcec62","url":"https://github.com/eclipse/xtext"},{"original_method":"public CharSequence workflow() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"module \");\n    WizardConfiguration _config = this.getConfig();\n    LanguageDescriptor _language = _config.getLanguage();\n    String _basePackagePath = _language.getBasePackagePath();\n    String _plus = (_basePackagePath + \"/Generate\");\n    WizardConfiguration _config_1 = this.getConfig();\n    LanguageDescriptor _language_1 = _config_1.getLanguage();\n    String _simpleName = _language_1.getSimpleName();\n    String _plus_1 = (_plus + _simpleName);\n    String _replaceAll = _plus_1.replaceAll(\"/\", \".\");\n    _builder.append(_replaceAll, \"\");\n    _builder.newLineIfNotEmpty();\n    _builder.newLine();\n    _builder.append(\"import org.eclipse.emf.mwe.utils.*\");\n    _builder.newLine();\n    _builder.append(\"import org.eclipse.xtext.xtext.generator.*\");\n    _builder.newLine();\n    _builder.append(\"import org.eclipse.xtext.generator.*\");\n    _builder.newLine();\n    _builder.append(\"import org.eclipse.xtext.ui.generator.*\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"var projectName = \\\"\");\n    String _name = this.getName();\n    _builder.append(_name, \"\");\n    _builder.append(\"\\\"\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"var projectPath = \\\"../${projectName}\\\"\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"var fileExtensions = \\\"\");\n    WizardConfiguration _config_2 = this.getConfig();\n    LanguageDescriptor _language_2 = _config_2.getLanguage();\n    LanguageDescriptor.FileExtensions _fileExtensions = _language_2.getFileExtensions();\n    _builder.append(_fileExtensions, \"\");\n    _builder.append(\"\\\"\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"var grammarURI = \\\"platform:/resource/${projectName}/\");\n    String _sourceFolder = this.sourceFolder(Outlet.MAIN_RESOURCES);\n    _builder.append(_sourceFolder, \"\");\n    _builder.append(\"/\");\n    String _grammarFilePath = this.getGrammarFilePath();\n    _builder.append(_grammarFilePath, \"\");\n    _builder.append(\"\\\"\");\n    _builder.newLineIfNotEmpty();\n    _builder.newLine();\n    _builder.append(\"var encoding = \\\"\");\n    WizardConfiguration _config_3 = this.getConfig();\n    Charset _encoding = _config_3.getEncoding();\n    _builder.append(_encoding, \"\");\n    _builder.append(\"\\\"\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"var lineDelimiter = \\\"\\\\n\\\"\");\n    _builder.newLine();\n    _builder.append(\"var fileHeader = \\\"/*\\\\n * generated by Xtext \\\\${version}\\\\n */\\\"\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"Workflow {\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"bean = StandaloneSetup {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"scanClassPath = true\");\n    _builder.newLine();\n    {\n      WizardConfiguration _config_4 = this.getConfig();\n      Set<ProjectDescriptor> _enabledProjects = _config_4.getEnabledProjects();\n      final Function1<ProjectDescriptor, Boolean> _function = new Function1<ProjectDescriptor, Boolean>() {\n        @Override\n        public Boolean apply(final ProjectDescriptor it) {\n          WizardConfiguration _config = it.getConfig();\n          ParentProjectDescriptor _parentProject = _config.getParentProject();\n          return Boolean.valueOf((!Objects.equal(it, _parentProject)));\n        }\n      };\n      Iterable<ProjectDescriptor> _filter = IterableExtensions.<ProjectDescriptor>filter(_enabledProjects, _function);\n      for(final ProjectDescriptor p : _filter) {\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"projectMapping = { projectName = \\'\");\n        String _name_1 = p.getName();\n        _builder.append(_name_1, \"\\t\\t\");\n        _builder.append(\"\\' path = \\'${projectPath}/../\");\n        String _name_2 = p.getName();\n        _builder.append(_name_2, \"\\t\\t\");\n        _builder.append(\"\\' }\");\n        _builder.newLineIfNotEmpty();\n      }\n    }\n    {\n      boolean _isFromExistingEcoreModels = this.isFromExistingEcoreModels();\n      if (_isFromExistingEcoreModels) {\n        {\n          WizardConfiguration _config_5 = this.getConfig();\n          Ecore2XtextConfiguration _ecore2Xtext = _config_5.getEcore2Xtext();\n          Set<EPackageInfo> _ePackageInfos = _ecore2Xtext.getEPackageInfos();\n          final Function1<EPackageInfo, Boolean> _function_1 = new Function1<EPackageInfo, Boolean>() {\n            @Override\n            public Boolean apply(final EPackageInfo it) {\n              URI _genmodelURI = it.getGenmodelURI();\n              String _fileExtension = _genmodelURI.fileExtension();\n              return Boolean.valueOf((!Objects.equal(_fileExtension, \"xcore\")));\n            }\n          };\n          Iterable<EPackageInfo> _filter_1 = IterableExtensions.<EPackageInfo>filter(_ePackageInfos, _function_1);\n          final Function1<EPackageInfo, String> _function_2 = new Function1<EPackageInfo, String>() {\n            @Override\n            public String apply(final EPackageInfo it) {\n              return it.getEPackageJavaFQN();\n            }\n          };\n          Iterable<String> _map = IterableExtensions.<EPackageInfo, String>map(_filter_1, _function_2);\n          Iterable<String> _filterNull = IterableExtensions.<String>filterNull(_map);\n          for(final String ePackageInfo : _filterNull) {\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"registerGeneratedEPackage = \\\"\");\n            _builder.append(ePackageInfo, \"\\t\\t\");\n            _builder.append(\"\\\"\");\n            _builder.newLineIfNotEmpty();\n          }\n        }\n        {\n          WizardConfiguration _config_6 = this.getConfig();\n          Ecore2XtextConfiguration _ecore2Xtext_1 = _config_6.getEcore2Xtext();\n          Set<EPackageInfo> _ePackageInfos_1 = _ecore2Xtext_1.getEPackageInfos();\n          final Function1<EPackageInfo, Boolean> _function_3 = new Function1<EPackageInfo, Boolean>() {\n            @Override\n            public Boolean apply(final EPackageInfo it) {\n              URI _genmodelURI = it.getGenmodelURI();\n              String _fileExtension = _genmodelURI.fileExtension();\n              return Boolean.valueOf((!Objects.equal(_fileExtension, \"xcore\")));\n            }\n          };\n          Iterable<EPackageInfo> _filter_2 = IterableExtensions.<EPackageInfo>filter(_ePackageInfos_1, _function_3);\n          final Function1<EPackageInfo, String> _function_4 = new Function1<EPackageInfo, String>() {\n            @Override\n            public String apply(final EPackageInfo it) {\n              URI _genmodelURI = it.getGenmodelURI();\n              return _genmodelURI.toString();\n            }\n          };\n          Iterable<String> _map_1 = IterableExtensions.<EPackageInfo, String>map(_filter_2, _function_4);\n          Set<String> _set = IterableExtensions.<String>toSet(_map_1);\n          for(final String genmodelURI : _set) {\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"registerGenModelFile = \\\"\");\n            _builder.append(genmodelURI, \"\\t\\t\");\n            _builder.append(\"\\\"\");\n            _builder.newLineIfNotEmpty();\n          }\n        }\n      } else {\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"// The following two lines can be removed, if Xbase is not used.\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"registerGeneratedEPackage = \\\"org.eclipse.xtext.xbase.XbasePackage\\\"\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"registerGenModelFile = \\\"platform:/resource/org.eclipse.xtext.xbase/model/Xbase.genmodel\\\"\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.newLine();\n    {\n      WizardConfiguration _config_7 = this.getConfig();\n      Set<ProjectDescriptor> _enabledProjects_1 = _config_7.getEnabledProjects();\n      final Function1<ProjectDescriptor, Boolean> _function_5 = new Function1<ProjectDescriptor, Boolean>() {\n        @Override\n        public Boolean apply(final ProjectDescriptor it) {\n          Set<String> _sourceFolders = it.getSourceFolders();\n          String _sourceFolder = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_SRC_GEN);\n          return Boolean.valueOf(_sourceFolders.contains(_sourceFolder));\n        }\n      };\n      Iterable<ProjectDescriptor> _filter_3 = IterableExtensions.<ProjectDescriptor>filter(_enabledProjects_1, _function_5);\n      for(final ProjectDescriptor p_1 : _filter_3) {\n        _builder.append(\"\\t\");\n        _builder.append(\"component = DirectoryCleaner {\");\n        _builder.newLine();\n        _builder.append(\"\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"directory = \\\"${projectPath}\");\n        String _nameQualifier = p_1.getNameQualifier();\n        _builder.append(_nameQualifier, \"\\t\\t\");\n        _builder.append(\"/\");\n        String _sourceFolder_1 = this.sourceFolder(Outlet.MAIN_SRC_GEN);\n        _builder.append(_sourceFolder_1, \"\\t\\t\");\n        _builder.append(\"\\\"\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"component = DirectoryCleaner {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"directory = \\\"${projectPath}/model/generated\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"component = XtextGenerator auto-inject {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"configuration = {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"project = WizardConfig {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"runtimeRoot = projectPath\");\n    _builder.newLine();\n    {\n      WizardConfiguration _config_8 = this.getConfig();\n      UiProjectDescriptor _uiProject = _config_8.getUiProject();\n      boolean _isEnabled = _uiProject.isEnabled();\n      boolean _not = (!_isEnabled);\n      if (_not) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"eclipseEditor = false\");\n        _builder.newLine();\n      }\n    }\n    {\n      WizardConfiguration _config_9 = this.getConfig();\n      IntellijProjectDescriptor _intellijProject = _config_9.getIntellijProject();\n      boolean _isEnabled_1 = _intellijProject.isEnabled();\n      if (_isEnabled_1) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"ideaEditor = true\");\n        _builder.newLine();\n      }\n    }\n    {\n      WizardConfiguration _config_10 = this.getConfig();\n      WebProjectDescriptor _webProject = _config_10.getWebProject();\n      boolean _isEnabled_2 = _webProject.isEnabled();\n      if (_isEnabled_2) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"webSupport = true\");\n        _builder.newLine();\n      }\n    }\n    {\n      WizardConfiguration _config_11 = this.getConfig();\n      IdeProjectDescriptor _ideProject = _config_11.getIdeProject();\n      boolean _isEnabled_3 = _ideProject.isEnabled();\n      if (_isEnabled_3) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"genericIdeSupport = true\");\n        _builder.newLine();\n      }\n    }\n    {\n      boolean _isEnabled_4 = this.testProject.isEnabled();\n      if (_isEnabled_4) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"testingSupport = true\");\n        _builder.newLine();\n      }\n    }\n    {\n      WizardConfiguration _config_12 = this.getConfig();\n      SourceLayout _sourceLayout = _config_12.getSourceLayout();\n      boolean _equals = Objects.equal(_sourceLayout, SourceLayout.MAVEN);\n      if (_equals) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"mavenLayout = true\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"code = auto-inject {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"preferXtendStubs = true\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"language = auto-inject {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"uri = grammarURI\");\n    _builder.newLine();\n    {\n      WizardConfiguration _config_13 = this.getConfig();\n      Ecore2XtextConfiguration _ecore2Xtext_2 = _config_13.getEcore2Xtext();\n      Set<EPackageInfo> _ePackageInfos_2 = _ecore2Xtext_2.getEPackageInfos();\n      final Function1<EPackageInfo, Boolean> _function_6 = new Function1<EPackageInfo, Boolean>() {\n        @Override\n        public Boolean apply(final EPackageInfo it) {\n          URI _genmodelURI = it.getGenmodelURI();\n          String _fileExtension = _genmodelURI.fileExtension();\n          return Boolean.valueOf(Objects.equal(_fileExtension, \"xcore\"));\n        }\n      };\n      Iterable<EPackageInfo> _filter_4 = IterableExtensions.<EPackageInfo>filter(_ePackageInfos_2, _function_6);\n      final Function1<EPackageInfo, String> _function_7 = new Function1<EPackageInfo, String>() {\n        @Override\n        public String apply(final EPackageInfo it) {\n          URI _genmodelURI = it.getGenmodelURI();\n          return _genmodelURI.toString();\n        }\n      };\n      Iterable<String> _map_2 = IterableExtensions.<EPackageInfo, String>map(_filter_4, _function_7);\n      Set<String> _set_1 = IterableExtensions.<String>toSet(_map_2);\n      for(final String genmodelURI_1 : _set_1) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"loadedResource = \\\"\");\n        _builder.append(genmodelURI_1, \"\\t\\t\\t\");\n        _builder.append(\"\\\"\");\n        _builder.newLineIfNotEmpty();\n      }\n    }\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// Java API to access grammar elements (required by several other fragments)\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = grammarAccess.GrammarAccessFragment2 auto-inject {}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.newLine();\n    {\n      boolean _isFromExistingEcoreModels_1 = this.isFromExistingEcoreModels();\n      if (_isFromExistingEcoreModels_1) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter { \");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = ecore2xtext.Ecore2XtextValueConverterServiceFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// generates Java API for the generated EPackages\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter { \");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = ecore.EMFGeneratorFragment auto-inject {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"javaModelDirectory = \\\"/${projectName}/\");\n    String _sourceFolder_2 = this.sourceFolder(Outlet.MAIN_SRC_GEN);\n    _builder.append(_sourceFolder_2, \"\\t\\t\\t\\t\\t\");\n    _builder.append(\"\\\"\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"updateBuildProperties = \");\n    boolean _isEclipsePluginProject = this.isEclipsePluginProject();\n    _builder.append(_isEclipsePluginProject, \"\\t\\t\\t\\t\\t\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = serializer.SerializerFragment auto-inject {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"generateStub = false\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// a custom ResourceFactory for use with EMF\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = resourceFactory.ResourceFactoryFragment auto-inject {}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// The antlr parser generator fragment.\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = parser.antlr.XtextAntlrGeneratorFragment auto-inject {}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// Xtend-based API for validation\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = validation.ValidatorFragment auto-inject {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"//    composedCheck = \\\"org.eclipse.xtext.validation.NamesAreUniqueValidator\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// scoping and exporting API\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = scoping.ImportNamespacesScopingFragment auto-inject {}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = exporting.QualifiedNamesFragment auto-inject {}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// generator API\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = generator.GeneratorFragment2 {}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// formatter API\");\n    _builder.newLine();\n    {\n      boolean _isFromExistingEcoreModels_2 = this.isFromExistingEcoreModels();\n      if (_isFromExistingEcoreModels_2) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = ecore2xtext.FormatterFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n      } else {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = formatting.Formatter2Fragment2 {}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\\t\\t\");\n    _builder.newLine();\n    {\n      WizardConfiguration _config_14 = this.getConfig();\n      Set<ProjectDescriptor> _enabledProjects_2 = _config_14.getEnabledProjects();\n      final Function1<ProjectDescriptor, Boolean> _function_8 = new Function1<ProjectDescriptor, Boolean>() {\n        @Override\n        public Boolean apply(final ProjectDescriptor it) {\n          return Boolean.valueOf((it instanceof TestProjectDescriptor));\n        }\n      };\n      boolean _exists = IterableExtensions.<ProjectDescriptor>exists(_enabledProjects_2, _function_8);\n      if (_exists) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = junit.Junit4Fragment2 auto-inject {}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\\t\\t\");\n    _builder.newLine();\n    {\n      WizardConfiguration _config_15 = this.getConfig();\n      UiProjectDescriptor _uiProject_1 = _config_15.getUiProject();\n      boolean _isEnabled_5 = _uiProject_1.isEnabled();\n      if (_isEnabled_5) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = builder.BuilderIntegrationFragment2 auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// labeling API\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = labeling.LabelProviderFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// outline API\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = outline.OutlineTreeProviderFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = outline.QuickOutlineFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// quickfix API\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = quickfix.QuickfixProviderFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// content assist API\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = contentAssist.ContentAssistFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// provides a preference page for template proposals\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = templates.CodetemplatesGeneratorFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// rename refactoring\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = refactoring.RefactorElementNameFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// provides a compare view\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = compare.CompareFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n      }\n    }\n    {\n      boolean _or = false;\n      WizardConfiguration _config_16 = this.getConfig();\n      UiProjectDescriptor _uiProject_2 = _config_16.getUiProject();\n      boolean _isEnabled_6 = _uiProject_2.isEnabled();\n      if (_isEnabled_6) {\n        _or = true;\n      } else {\n        WizardConfiguration _config_17 = this.getConfig();\n        IdeProjectDescriptor _ideProject_1 = _config_17.getIdeProject();\n        boolean _isEnabled_7 = _ideProject_1.isEnabled();\n        _or = _isEnabled_7;\n      }\n      if (_or) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// generates a more lightweight Antlr parser and lexer tailored for content assist\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = parser.antlr.XtextAntlrUiGeneratorFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// provides the necessary bindings for java types integration\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = types.TypesGeneratorFragment auto-inject {}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// generates the required bindings only if the grammar inherits from Xbase\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = xbase.XbaseGeneratorFragment2 auto-inject {}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// generates the required bindings only if the grammar inherits from Xtype\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = xbase.XtypeGeneratorFragment2 auto-inject {}\");\n    _builder.newLine();\n    _builder.newLine();\n    {\n      WizardConfiguration _config_18 = this.getConfig();\n      IntellijProjectDescriptor _intellijProject_1 = _config_18.getIntellijProject();\n      boolean _isEnabled_8 = _intellijProject_1.isEnabled();\n      if (_isEnabled_8) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// Intellij IDEA integration\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = idea.IdeaPluginGenerator auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = idea.parser.antlr.XtextAntlrIDEAGeneratorFragment auto-inject {}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\\t\\t\");\n    _builder.newLine();\n    {\n      WizardConfiguration _config_19 = this.getConfig();\n      WebProjectDescriptor _webProject_1 = _config_19.getWebProject();\n      boolean _isEnabled_9 = _webProject_1.isEnabled();\n      if (_isEnabled_9) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// web integration\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = web.WebIntegrationFragment auto-inject {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"framework = \\\"Ace\\\"\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"generateServlet = true\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"generateJettyLauncher = true\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"generateHtmlExample = true\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"}\");\n    _builder.newLine();\n    return _builder;\n  }","id":97805,"modified_method":"public CharSequence workflow() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"module \");\n    WizardConfiguration _config = this.getConfig();\n    LanguageDescriptor _language = _config.getLanguage();\n    String _basePackagePath = _language.getBasePackagePath();\n    String _plus = (_basePackagePath + \"/Generate\");\n    WizardConfiguration _config_1 = this.getConfig();\n    LanguageDescriptor _language_1 = _config_1.getLanguage();\n    String _simpleName = _language_1.getSimpleName();\n    String _plus_1 = (_plus + _simpleName);\n    String _replaceAll = _plus_1.replaceAll(\"/\", \".\");\n    _builder.append(_replaceAll, \"\");\n    _builder.newLineIfNotEmpty();\n    _builder.newLine();\n    _builder.append(\"import org.eclipse.emf.mwe.utils.*\");\n    _builder.newLine();\n    _builder.append(\"import org.eclipse.xtext.xtext.generator.*\");\n    _builder.newLine();\n    _builder.append(\"import org.eclipse.xtext.generator.*\");\n    _builder.newLine();\n    _builder.append(\"import org.eclipse.xtext.ui.generator.*\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"var projectName = \\\"\");\n    String _name = this.getName();\n    _builder.append(_name, \"\");\n    _builder.append(\"\\\"\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"var projectPath = \\\"../${projectName}\\\"\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"var fileExtensions = \\\"\");\n    WizardConfiguration _config_2 = this.getConfig();\n    LanguageDescriptor _language_2 = _config_2.getLanguage();\n    LanguageDescriptor.FileExtensions _fileExtensions = _language_2.getFileExtensions();\n    _builder.append(_fileExtensions, \"\");\n    _builder.append(\"\\\"\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"var grammarURI = \\\"platform:/resource/${projectName}/\");\n    String _sourceFolder = this.sourceFolder(Outlet.MAIN_RESOURCES);\n    _builder.append(_sourceFolder, \"\");\n    _builder.append(\"/\");\n    String _grammarFilePath = this.getGrammarFilePath();\n    _builder.append(_grammarFilePath, \"\");\n    _builder.append(\"\\\"\");\n    _builder.newLineIfNotEmpty();\n    _builder.newLine();\n    _builder.append(\"var encoding = \\\"\");\n    WizardConfiguration _config_3 = this.getConfig();\n    Charset _encoding = _config_3.getEncoding();\n    _builder.append(_encoding, \"\");\n    _builder.append(\"\\\"\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"var lineDelimiter = \\\"\\\\n\\\"\");\n    _builder.newLine();\n    _builder.append(\"var fileHeader = \\\"/*\\\\n * generated by Xtext \\\\${version}\\\\n */\\\"\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"Workflow {\");\n    _builder.newLine();\n    _builder.append(\"    \");\n    _builder.append(\"bean = StandaloneSetup {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"scanClassPath = true\");\n    _builder.newLine();\n    {\n      WizardConfiguration _config_4 = this.getConfig();\n      Set<ProjectDescriptor> _enabledProjects = _config_4.getEnabledProjects();\n      final Function1<ProjectDescriptor, Boolean> _function = new Function1<ProjectDescriptor, Boolean>() {\n        @Override\n        public Boolean apply(final ProjectDescriptor it) {\n          WizardConfiguration _config = it.getConfig();\n          ParentProjectDescriptor _parentProject = _config.getParentProject();\n          return Boolean.valueOf((!Objects.equal(it, _parentProject)));\n        }\n      };\n      Iterable<ProjectDescriptor> _filter = IterableExtensions.<ProjectDescriptor>filter(_enabledProjects, _function);\n      for(final ProjectDescriptor p : _filter) {\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"projectMapping = { projectName = \\'\");\n        String _name_1 = p.getName();\n        _builder.append(_name_1, \"\\t\\t\");\n        _builder.append(\"\\' path = \\'${projectPath}/../\");\n        String _name_2 = p.getName();\n        _builder.append(_name_2, \"\\t\\t\");\n        _builder.append(\"\\' }\");\n        _builder.newLineIfNotEmpty();\n      }\n    }\n    {\n      boolean _isFromExistingEcoreModels = this.isFromExistingEcoreModels();\n      if (_isFromExistingEcoreModels) {\n        {\n          WizardConfiguration _config_5 = this.getConfig();\n          Ecore2XtextConfiguration _ecore2Xtext = _config_5.getEcore2Xtext();\n          Set<EPackageInfo> _ePackageInfos = _ecore2Xtext.getEPackageInfos();\n          final Function1<EPackageInfo, Boolean> _function_1 = new Function1<EPackageInfo, Boolean>() {\n            @Override\n            public Boolean apply(final EPackageInfo it) {\n              URI _genmodelURI = it.getGenmodelURI();\n              String _fileExtension = _genmodelURI.fileExtension();\n              return Boolean.valueOf((!Objects.equal(_fileExtension, \"xcore\")));\n            }\n          };\n          Iterable<EPackageInfo> _filter_1 = IterableExtensions.<EPackageInfo>filter(_ePackageInfos, _function_1);\n          final Function1<EPackageInfo, String> _function_2 = new Function1<EPackageInfo, String>() {\n            @Override\n            public String apply(final EPackageInfo it) {\n              return it.getEPackageJavaFQN();\n            }\n          };\n          Iterable<String> _map = IterableExtensions.<EPackageInfo, String>map(_filter_1, _function_2);\n          Iterable<String> _filterNull = IterableExtensions.<String>filterNull(_map);\n          for(final String ePackageInfo : _filterNull) {\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"registerGeneratedEPackage = \\\"\");\n            _builder.append(ePackageInfo, \"\\t\\t\");\n            _builder.append(\"\\\"\");\n            _builder.newLineIfNotEmpty();\n          }\n        }\n        {\n          WizardConfiguration _config_6 = this.getConfig();\n          Ecore2XtextConfiguration _ecore2Xtext_1 = _config_6.getEcore2Xtext();\n          Set<EPackageInfo> _ePackageInfos_1 = _ecore2Xtext_1.getEPackageInfos();\n          final Function1<EPackageInfo, Boolean> _function_3 = new Function1<EPackageInfo, Boolean>() {\n            @Override\n            public Boolean apply(final EPackageInfo it) {\n              URI _genmodelURI = it.getGenmodelURI();\n              String _fileExtension = _genmodelURI.fileExtension();\n              return Boolean.valueOf((!Objects.equal(_fileExtension, \"xcore\")));\n            }\n          };\n          Iterable<EPackageInfo> _filter_2 = IterableExtensions.<EPackageInfo>filter(_ePackageInfos_1, _function_3);\n          final Function1<EPackageInfo, String> _function_4 = new Function1<EPackageInfo, String>() {\n            @Override\n            public String apply(final EPackageInfo it) {\n              URI _genmodelURI = it.getGenmodelURI();\n              return _genmodelURI.toString();\n            }\n          };\n          Iterable<String> _map_1 = IterableExtensions.<EPackageInfo, String>map(_filter_2, _function_4);\n          Set<String> _set = IterableExtensions.<String>toSet(_map_1);\n          for(final String genmodelURI : _set) {\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"registerGenModelFile = \\\"\");\n            _builder.append(genmodelURI, \"\\t\\t\");\n            _builder.append(\"\\\"\");\n            _builder.newLineIfNotEmpty();\n          }\n        }\n      } else {\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"// The following two lines can be removed, if Xbase is not used.\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"registerGeneratedEPackage = \\\"org.eclipse.xtext.xbase.XbasePackage\\\"\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"registerGenModelFile = \\\"platform:/resource/org.eclipse.xtext.xbase/model/Xbase.genmodel\\\"\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.newLine();\n    {\n      WizardConfiguration _config_7 = this.getConfig();\n      Set<ProjectDescriptor> _enabledProjects_1 = _config_7.getEnabledProjects();\n      final Function1<ProjectDescriptor, Boolean> _function_5 = new Function1<ProjectDescriptor, Boolean>() {\n        @Override\n        public Boolean apply(final ProjectDescriptor it) {\n          Set<String> _sourceFolders = it.getSourceFolders();\n          String _sourceFolder = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_SRC_GEN);\n          return Boolean.valueOf(_sourceFolders.contains(_sourceFolder));\n        }\n      };\n      Iterable<ProjectDescriptor> _filter_3 = IterableExtensions.<ProjectDescriptor>filter(_enabledProjects_1, _function_5);\n      for(final ProjectDescriptor p_1 : _filter_3) {\n        _builder.append(\"\\t\");\n        _builder.append(\"component = DirectoryCleaner {\");\n        _builder.newLine();\n        _builder.append(\"\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"directory = \\\"${projectPath}\");\n        String _nameQualifier = p_1.getNameQualifier();\n        _builder.append(_nameQualifier, \"\\t\\t\");\n        _builder.append(\"/\");\n        String _sourceFolder_1 = this.sourceFolder(Outlet.MAIN_SRC_GEN);\n        _builder.append(_sourceFolder_1, \"\\t\\t\");\n        _builder.append(\"\\\"\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"component = DirectoryCleaner {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"directory = \\\"${projectPath}/model/generated\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"component = XtextGenerator auto-inject {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"configuration = {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"project = WizardConfig {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"runtimeRoot = projectPath\");\n    _builder.newLine();\n    {\n      WizardConfiguration _config_8 = this.getConfig();\n      UiProjectDescriptor _uiProject = _config_8.getUiProject();\n      boolean _isEnabled = _uiProject.isEnabled();\n      boolean _not = (!_isEnabled);\n      if (_not) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"eclipseEditor = false\");\n        _builder.newLine();\n      }\n    }\n    {\n      WizardConfiguration _config_9 = this.getConfig();\n      IntellijProjectDescriptor _intellijProject = _config_9.getIntellijProject();\n      boolean _isEnabled_1 = _intellijProject.isEnabled();\n      if (_isEnabled_1) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"ideaEditor = true\");\n        _builder.newLine();\n      }\n    }\n    {\n      WizardConfiguration _config_10 = this.getConfig();\n      WebProjectDescriptor _webProject = _config_10.getWebProject();\n      boolean _isEnabled_2 = _webProject.isEnabled();\n      if (_isEnabled_2) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"webSupport = true\");\n        _builder.newLine();\n      }\n    }\n    {\n      WizardConfiguration _config_11 = this.getConfig();\n      IdeProjectDescriptor _ideProject = _config_11.getIdeProject();\n      boolean _isEnabled_3 = _ideProject.isEnabled();\n      if (_isEnabled_3) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"genericIdeSupport = true\");\n        _builder.newLine();\n      }\n    }\n    {\n      boolean _isEnabled_4 = this.testProject.isEnabled();\n      if (_isEnabled_4) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"testingSupport = true\");\n        _builder.newLine();\n      }\n    }\n    {\n      WizardConfiguration _config_12 = this.getConfig();\n      SourceLayout _sourceLayout = _config_12.getSourceLayout();\n      boolean _equals = Objects.equal(_sourceLayout, SourceLayout.MAVEN);\n      if (_equals) {\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"mavenLayout = true\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"code = auto-inject {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"preferXtendStubs = true\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"language = auto-inject {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"uri = grammarURI\");\n    _builder.newLine();\n    {\n      WizardConfiguration _config_13 = this.getConfig();\n      Ecore2XtextConfiguration _ecore2Xtext_2 = _config_13.getEcore2Xtext();\n      Set<EPackageInfo> _ePackageInfos_2 = _ecore2Xtext_2.getEPackageInfos();\n      final Function1<EPackageInfo, Boolean> _function_6 = new Function1<EPackageInfo, Boolean>() {\n        @Override\n        public Boolean apply(final EPackageInfo it) {\n          URI _genmodelURI = it.getGenmodelURI();\n          String _fileExtension = _genmodelURI.fileExtension();\n          return Boolean.valueOf(Objects.equal(_fileExtension, \"xcore\"));\n        }\n      };\n      Iterable<EPackageInfo> _filter_4 = IterableExtensions.<EPackageInfo>filter(_ePackageInfos_2, _function_6);\n      final Function1<EPackageInfo, String> _function_7 = new Function1<EPackageInfo, String>() {\n        @Override\n        public String apply(final EPackageInfo it) {\n          URI _genmodelURI = it.getGenmodelURI();\n          return _genmodelURI.toString();\n        }\n      };\n      Iterable<String> _map_2 = IterableExtensions.<EPackageInfo, String>map(_filter_4, _function_7);\n      Set<String> _set_1 = IterableExtensions.<String>toSet(_map_2);\n      for(final String genmodelURI_1 : _set_1) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"loadedResource = \\\"\");\n        _builder.append(genmodelURI_1, \"\\t\\t\\t\");\n        _builder.append(\"\\\"\");\n        _builder.newLineIfNotEmpty();\n      }\n    }\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// Java API to access grammar elements (required by several other fragments)\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = grammarAccess.GrammarAccessFragment2 auto-inject {}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.newLine();\n    {\n      boolean _isFromExistingEcoreModels_1 = this.isFromExistingEcoreModels();\n      if (_isFromExistingEcoreModels_1) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter { \");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = ecore2xtext.Ecore2XtextValueConverterServiceFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// generates Java API for the generated EPackages\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter { \");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = ecore.EMFGeneratorFragment auto-inject {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"javaModelDirectory = \\\"/${projectName}/\");\n    String _sourceFolder_2 = this.sourceFolder(Outlet.MAIN_SRC_GEN);\n    _builder.append(_sourceFolder_2, \"\\t\\t\\t\\t\\t\");\n    _builder.append(\"\\\"\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"updateBuildProperties = \");\n    boolean _isEclipsePluginProject = this.isEclipsePluginProject();\n    _builder.append(_isEclipsePluginProject, \"\\t\\t\\t\\t\\t\");\n    _builder.newLineIfNotEmpty();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = serializer.SerializerFragment auto-inject {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\\t\");\n    _builder.append(\"generateStub = false\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// a custom ResourceFactory for use with EMF\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = resourceFactory.ResourceFactoryFragment auto-inject {}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// The antlr parser generator fragment.\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = parser.antlr.XtextAntlrGeneratorFragment auto-inject {}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// Xtend-based API for validation\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = validation.ValidatorFragment auto-inject {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"//    composedCheck = \\\"org.eclipse.xtext.validation.NamesAreUniqueValidator\\\"\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// scoping and exporting API\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = scoping.ImportNamespacesScopingFragment auto-inject {}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = exporting.QualifiedNamesFragment auto-inject {}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// generator API\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = generator.GeneratorFragment2 {}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// formatter API\");\n    _builder.newLine();\n    {\n      boolean _isFromExistingEcoreModels_2 = this.isFromExistingEcoreModels();\n      if (_isFromExistingEcoreModels_2) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = ecore2xtext.FormatterFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n      } else {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = formatting.Formatter2Fragment2 {}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\\t\\t\");\n    _builder.newLine();\n    {\n      WizardConfiguration _config_14 = this.getConfig();\n      Set<ProjectDescriptor> _enabledProjects_2 = _config_14.getEnabledProjects();\n      Iterable<TestedProjectDescriptor> _filter_5 = Iterables.<TestedProjectDescriptor>filter(_enabledProjects_2, TestedProjectDescriptor.class);\n      final Function1<TestedProjectDescriptor, Boolean> _function_8 = new Function1<TestedProjectDescriptor, Boolean>() {\n        @Override\n        public Boolean apply(final TestedProjectDescriptor it) {\n          return Boolean.valueOf(RuntimeProjectDescriptor.this.testProject.isEnabled());\n        }\n      };\n      boolean _exists = IterableExtensions.<TestedProjectDescriptor>exists(_filter_5, _function_8);\n      if (_exists) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = junit.Junit4Fragment2 auto-inject {}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\\t\\t\");\n    _builder.newLine();\n    {\n      WizardConfiguration _config_15 = this.getConfig();\n      UiProjectDescriptor _uiProject_1 = _config_15.getUiProject();\n      boolean _isEnabled_5 = _uiProject_1.isEnabled();\n      if (_isEnabled_5) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = builder.BuilderIntegrationFragment2 auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// labeling API\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = labeling.LabelProviderFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// outline API\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = outline.OutlineTreeProviderFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = outline.QuickOutlineFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// quickfix API\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = quickfix.QuickfixProviderFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// content assist API\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = contentAssist.ContentAssistFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// provides a preference page for template proposals\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = templates.CodetemplatesGeneratorFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// rename refactoring\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = refactoring.RefactorElementNameFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// provides a compare view\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = compare.CompareFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n      }\n    }\n    {\n      boolean _or = false;\n      WizardConfiguration _config_16 = this.getConfig();\n      UiProjectDescriptor _uiProject_2 = _config_16.getUiProject();\n      boolean _isEnabled_6 = _uiProject_2.isEnabled();\n      if (_isEnabled_6) {\n        _or = true;\n      } else {\n        WizardConfiguration _config_17 = this.getConfig();\n        IdeProjectDescriptor _ideProject_1 = _config_17.getIdeProject();\n        boolean _isEnabled_7 = _ideProject_1.isEnabled();\n        _or = _isEnabled_7;\n      }\n      if (_or) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// generates a more lightweight Antlr parser and lexer tailored for content assist\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = adapter.FragmentAdapter {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"fragment = parser.antlr.XtextAntlrUiGeneratorFragment auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// provides the necessary bindings for java types integration\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = adapter.FragmentAdapter {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\\t\");\n    _builder.append(\"fragment = types.TypesGeneratorFragment auto-inject {}\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// generates the required bindings only if the grammar inherits from Xbase\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = xbase.XbaseGeneratorFragment2 auto-inject {}\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"// generates the required bindings only if the grammar inherits from Xtype\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\\t\");\n    _builder.append(\"fragment = xbase.XtypeGeneratorFragment2 auto-inject {}\");\n    _builder.newLine();\n    _builder.newLine();\n    {\n      WizardConfiguration _config_18 = this.getConfig();\n      IntellijProjectDescriptor _intellijProject_1 = _config_18.getIntellijProject();\n      boolean _isEnabled_8 = _intellijProject_1.isEnabled();\n      if (_isEnabled_8) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// Intellij IDEA integration\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = idea.IdeaPluginGenerator auto-inject {}\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = idea.parser.antlr.XtextAntlrIDEAGeneratorFragment auto-inject {}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\\t\\t\");\n    _builder.newLine();\n    {\n      WizardConfiguration _config_19 = this.getConfig();\n      WebProjectDescriptor _webProject_1 = _config_19.getWebProject();\n      boolean _isEnabled_9 = _webProject_1.isEnabled();\n      if (_isEnabled_9) {\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"// web integration\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"fragment = web.WebIntegrationFragment auto-inject {\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"framework = \\\"Ace\\\"\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"generateServlet = true\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"generateJettyLauncher = true\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"\\t\");\n        _builder.append(\"generateHtmlExample = true\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"}\");\n        _builder.newLine();\n      }\n    }\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"}\");\n    _builder.newLine();\n    return _builder;\n  }","commit_id":"b9a3f39c7b0b0da857f01ff1ba1fb9b192bcec62","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public PomFile pom() {\n    PomFile _pom = super.pom();\n    final Procedure1<PomFile> _function = new Procedure1<PomFile>() {\n      @Override\n      public void apply(final PomFile it) {\n        String _xifexpression = null;\n        boolean _isEclipsePluginProject = RuntimeProjectDescriptor.this.isEclipsePluginProject();\n        if (_isEclipsePluginProject) {\n          _xifexpression = \"eclipse-plugin\";\n        } else {\n          _xifexpression = \"jar\";\n        }\n        it.setPackaging(_xifexpression);\n        StringConcatenation _builder = new StringConcatenation();\n        _builder.append(\"<build>\");\n        _builder.newLine();\n        {\n          boolean _and = false;\n          boolean _isEclipsePluginProject_1 = RuntimeProjectDescriptor.this.isEclipsePluginProject();\n          boolean _not = (!_isEclipsePluginProject_1);\n          if (!_not) {\n            _and = false;\n          } else {\n            WizardConfiguration _config = RuntimeProjectDescriptor.this.getConfig();\n            SourceLayout _sourceLayout = _config.getSourceLayout();\n            boolean _equals = Objects.equal(_sourceLayout, SourceLayout.PLAIN);\n            _and = _equals;\n          }\n          if (_and) {\n            _builder.append(\"\\t\");\n            _builder.append(\"<sourceDirectory>\");\n            String _sourceFolder = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_JAVA);\n            _builder.append(_sourceFolder, \"\\t\");\n            _builder.append(\"<\/sourceDirectory>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\");\n            _builder.append(\"<resources>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<resource>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<directory>\");\n            String _sourceFolder_1 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_RESOURCES);\n            _builder.append(_sourceFolder_1, \"\\t\\t\\t\");\n            _builder.append(\"<\/directory>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<\/resource>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"<\/resources>\");\n            _builder.newLine();\n          }\n        }\n        _builder.append(\"\\t\");\n        _builder.append(\"<plugins>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<groupId>org.codehaus.mojo<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<artifactId>exec-maven-plugin<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<version>1.2.1<\/version>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<executions>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<execution>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<id>mwe2Launcher<\/id>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<phase>generate-sources<\/phase>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<goals>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<goal>java<\/goal>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/goals>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/execution>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<\/executions>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<mainClass>org.eclipse.emf.mwe2.launch.runtime.Mwe2Launcher<\/mainClass>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<arguments>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<argument>/${project.basedir}/\");\n        String _sourceFolder_2 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_RESOURCES);\n        _builder.append(_sourceFolder_2, \"\\t\\t\\t\\t\\t\");\n        _builder.append(\"/\");\n        String _workflowFilePath = RuntimeProjectDescriptor.this.getWorkflowFilePath();\n        _builder.append(_workflowFilePath, \"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/argument>\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<argument>-p<\/argument>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<argument>projectPath=/${project.basedir}<\/argument>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/arguments>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<includePluginDependencies>true<\/includePluginDependencies>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<\/configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<dependencies>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<dependency>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<groupId>org.eclipse.xtext<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<artifactId>org.eclipse.xtext.xtext<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<version>${xtextVersion}<\/version>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/dependency>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<dependency>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<groupId>org.eclipse.xtext<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<artifactId>org.eclipse.xtext.xtext.generator<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<version>${xtextVersion}<\/version>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/dependency>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<dependency>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<groupId>org.eclipse.xtext<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<artifactId>org.eclipse.xtext.xbase<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<version>${xtextVersion}<\/version>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/dependency>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<\/dependencies>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<\/plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<groupId>org.eclipse.xtend<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<artifactId>xtend-maven-plugin<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<\/plugin>\");\n        _builder.newLine();\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<groupId>org.apache.maven.plugins<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<artifactId>maven-clean-plugin<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<version>2.5<\/version>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<filesets combine.children=\\\"append\\\">\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<fileset>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<directory>${basedir}/\");\n        String _sourceFolder_3 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_SRC_GEN);\n        _builder.append(_sourceFolder_3, \"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"/<\/directory>\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/fileset>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<fileset>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<directory>${basedir}/model/generated/<\/directory>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/fileset>\");\n        _builder.newLine();\n        {\n          WizardConfiguration _config_1 = RuntimeProjectDescriptor.this.getConfig();\n          IdeProjectDescriptor _ideProject = _config_1.getIdeProject();\n          boolean _isEnabled = _ideProject.isEnabled();\n          if (_isEnabled) {\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<fileset>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<directory>${basedir}/../${project.artifactId}.ide/\");\n            String _sourceFolder_4 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_SRC_GEN);\n            _builder.append(_sourceFolder_4, \"\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"/<\/directory>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/fileset>\");\n            _builder.newLine();\n          }\n        }\n        {\n          WizardConfiguration _config_2 = RuntimeProjectDescriptor.this.getConfig();\n          UiProjectDescriptor _uiProject = _config_2.getUiProject();\n          boolean _isEnabled_1 = _uiProject.isEnabled();\n          if (_isEnabled_1) {\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<fileset>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<directory>${basedir}/../${project.artifactId}.ui/\");\n            String _sourceFolder_5 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_SRC_GEN);\n            _builder.append(_sourceFolder_5, \"\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"/<\/directory>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/fileset>\");\n            _builder.newLine();\n          }\n        }\n        {\n          WizardConfiguration _config_3 = RuntimeProjectDescriptor.this.getConfig();\n          WebProjectDescriptor _webProject = _config_3.getWebProject();\n          boolean _isEnabled_2 = _webProject.isEnabled();\n          if (_isEnabled_2) {\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<fileset>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<directory>${basedir}/../${project.artifactId}.web/\");\n            String _sourceFolder_6 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_SRC_GEN);\n            _builder.append(_sourceFolder_6, \"\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"/<\/directory>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/fileset>\");\n            _builder.newLine();\n          }\n        }\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/filesets>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<\/configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<\/plugin>\");\n        _builder.newLine();\n        {\n          boolean _isEclipsePluginProject_2 = RuntimeProjectDescriptor.this.isEclipsePluginProject();\n          boolean _not_1 = (!_isEclipsePluginProject_2);\n          if (_not_1) {\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<plugin>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<groupId>org.codehaus.mojo<\/groupId>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<artifactId>build-helper-maven-plugin<\/artifactId>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<version>1.9.1<\/version>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<executions>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<execution>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<id>add-source<\/id>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<phase>initialize<\/phase>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<goals>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<goal>add-source<\/goal>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<goal>add-resource<\/goal>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<\/goals>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<configuration>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<sources>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<source>\");\n            String _sourceFolder_7 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_SRC_GEN);\n            _builder.append(_sourceFolder_7, \"\\t\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/source>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<\/sources>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<resources>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<resource>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"<directory>\");\n            String _sourceFolder_8 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_SRC_GEN);\n            _builder.append(_sourceFolder_8, \"\\t\\t\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/directory>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/resource>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<\/resources>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<\/configuration>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<\/execution>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<\/executions>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<\/plugin>\");\n            _builder.newLine();\n          }\n        }\n        _builder.append(\"\\t\");\n        _builder.append(\"<\/plugins>\");\n        _builder.newLine();\n        _builder.append(\"<\/build>\");\n        _builder.newLine();\n        it.setBuildSection(_builder.toString());\n      }\n    };\n    return ObjectExtensions.<PomFile>operator_doubleArrow(_pom, _function);\n  }","id":97806,"modified_method":"@Override\n  public PomFile pom() {\n    PomFile _pom = super.pom();\n    final Procedure1<PomFile> _function = new Procedure1<PomFile>() {\n      @Override\n      public void apply(final PomFile it) {\n        String _xifexpression = null;\n        boolean _isEclipsePluginProject = RuntimeProjectDescriptor.this.isEclipsePluginProject();\n        if (_isEclipsePluginProject) {\n          _xifexpression = \"eclipse-plugin\";\n        } else {\n          _xifexpression = \"jar\";\n        }\n        it.setPackaging(_xifexpression);\n        StringConcatenation _builder = new StringConcatenation();\n        _builder.append(\"<build>\");\n        _builder.newLine();\n        {\n          boolean _and = false;\n          boolean _isEclipsePluginProject_1 = RuntimeProjectDescriptor.this.isEclipsePluginProject();\n          boolean _not = (!_isEclipsePluginProject_1);\n          if (!_not) {\n            _and = false;\n          } else {\n            WizardConfiguration _config = RuntimeProjectDescriptor.this.getConfig();\n            SourceLayout _sourceLayout = _config.getSourceLayout();\n            boolean _equals = Objects.equal(_sourceLayout, SourceLayout.PLAIN);\n            _and = _equals;\n          }\n          if (_and) {\n            _builder.append(\"\\t\");\n            _builder.append(\"<sourceDirectory>\");\n            String _sourceFolder = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_JAVA);\n            _builder.append(_sourceFolder, \"\\t\");\n            _builder.append(\"<\/sourceDirectory>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\");\n            _builder.append(\"<resources>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<resource>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<directory>\");\n            String _sourceFolder_1 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_RESOURCES);\n            _builder.append(_sourceFolder_1, \"\\t\\t\\t\");\n            _builder.append(\"<\/directory>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<\/resource>\");\n            _builder.newLine();\n            _builder.append(\"\\t\");\n            _builder.append(\"<\/resources>\");\n            _builder.newLine();\n          }\n        }\n        _builder.append(\"\\t\");\n        _builder.append(\"<plugins>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<groupId>org.codehaus.mojo<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<artifactId>exec-maven-plugin<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<version>1.2.1<\/version>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<executions>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<execution>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<id>mwe2Launcher<\/id>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<phase>generate-sources<\/phase>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<goals>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<goal>java<\/goal>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/goals>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/execution>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<\/executions>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<mainClass>org.eclipse.emf.mwe2.launch.runtime.Mwe2Launcher<\/mainClass>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<arguments>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<argument>/${project.basedir}/\");\n        String _sourceFolder_2 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_RESOURCES);\n        _builder.append(_sourceFolder_2, \"\\t\\t\\t\\t\\t\");\n        _builder.append(\"/\");\n        String _workflowFilePath = RuntimeProjectDescriptor.this.getWorkflowFilePath();\n        _builder.append(_workflowFilePath, \"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/argument>\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<argument>-p<\/argument>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<argument>projectPath=/${project.basedir}<\/argument>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/arguments>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<includePluginDependencies>true<\/includePluginDependencies>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<\/configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<dependencies>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<dependency>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<groupId>org.eclipse.xtext<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<artifactId>org.eclipse.xtext.xtext<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<version>${xtextVersion}<\/version>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/dependency>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<dependency>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<groupId>org.eclipse.xtext<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<artifactId>org.eclipse.xtext.xtext.generator<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<version>${xtextVersion}<\/version>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/dependency>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<dependency>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<groupId>org.eclipse.xtext<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<artifactId>org.eclipse.xtext.xbase<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<version>${xtextVersion}<\/version>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/dependency>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<\/dependencies>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<\/plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<groupId>org.eclipse.xtend<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<artifactId>xtend-maven-plugin<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<\/plugin>\");\n        _builder.newLine();\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<plugin>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<groupId>org.apache.maven.plugins<\/groupId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<artifactId>maven-clean-plugin<\/artifactId>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<version>2.5<\/version>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<filesets combine.children=\\\"append\\\">\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<fileset>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<directory>${basedir}/\");\n        String _sourceFolder_3 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_SRC_GEN);\n        _builder.append(_sourceFolder_3, \"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"/<\/directory>\");\n        _builder.newLineIfNotEmpty();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/fileset>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<fileset>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n        _builder.append(\"<directory>${basedir}/model/generated/<\/directory>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\\t\\t\");\n        _builder.append(\"<\/fileset>\");\n        _builder.newLine();\n        {\n          WizardConfiguration _config_1 = RuntimeProjectDescriptor.this.getConfig();\n          IdeProjectDescriptor _ideProject = _config_1.getIdeProject();\n          boolean _isEnabled = _ideProject.isEnabled();\n          if (_isEnabled) {\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<fileset>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<directory>${basedir}/../${project.artifactId}.ide/\");\n            String _sourceFolder_4 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_SRC_GEN);\n            _builder.append(_sourceFolder_4, \"\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"/<\/directory>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/fileset>\");\n            _builder.newLine();\n          }\n        }\n        {\n          WizardConfiguration _config_2 = RuntimeProjectDescriptor.this.getConfig();\n          UiProjectDescriptor _uiProject = _config_2.getUiProject();\n          boolean _isEnabled_1 = _uiProject.isEnabled();\n          if (_isEnabled_1) {\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<fileset>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<directory>${basedir}/../${project.artifactId}.ui/\");\n            String _sourceFolder_5 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_SRC_GEN);\n            _builder.append(_sourceFolder_5, \"\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"/<\/directory>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/fileset>\");\n            _builder.newLine();\n          }\n        }\n        {\n          WizardConfiguration _config_3 = RuntimeProjectDescriptor.this.getConfig();\n          WebProjectDescriptor _webProject = _config_3.getWebProject();\n          boolean _isEnabled_2 = _webProject.isEnabled();\n          if (_isEnabled_2) {\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<fileset>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<directory>${basedir}/../${project.artifactId}.web/\");\n            String _sourceFolder_6 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_SRC_GEN);\n            _builder.append(_sourceFolder_6, \"\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"/<\/directory>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/fileset>\");\n            _builder.newLine();\n          }\n        }\n        _builder.append(\"\\t\\t\\t\\t\");\n        _builder.append(\"<\/filesets>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\\t\");\n        _builder.append(\"<\/configuration>\");\n        _builder.newLine();\n        _builder.append(\"\\t\\t\");\n        _builder.append(\"<\/plugin>\");\n        _builder.newLine();\n        {\n          boolean _isEclipsePluginProject_2 = RuntimeProjectDescriptor.this.isEclipsePluginProject();\n          boolean _not_1 = (!_isEclipsePluginProject_2);\n          if (_not_1) {\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<plugin>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<groupId>org.codehaus.mojo<\/groupId>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<artifactId>build-helper-maven-plugin<\/artifactId>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<version>1.9.1<\/version>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<executions>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<execution>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<id>add-source<\/id>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<phase>initialize<\/phase>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<goals>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<goal>add-source<\/goal>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<goal>add-resource<\/goal>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<\/goals>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<configuration>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<sources>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<source>\");\n            String _sourceFolder_7 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_SRC_GEN);\n            _builder.append(_sourceFolder_7, \"\\t\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/source>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<\/sources>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<resources>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<resource>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"<directory>\");\n            String _sourceFolder_8 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.MAIN_SRC_GEN);\n            _builder.append(_sourceFolder_8, \"\\t\\t\\t\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/directory>\");\n            _builder.newLineIfNotEmpty();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\\t\");\n            _builder.append(\"<\/resource>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\\t\");\n            _builder.append(\"<\/resources>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\\t\");\n            _builder.append(\"<\/configuration>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<\/execution>\");\n            _builder.newLine();\n            {\n              boolean _isInlined = RuntimeProjectDescriptor.this.testProject.isInlined();\n              if (_isInlined) {\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"<execution>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\");\n                _builder.append(\"<id>add-test-source<\/id>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\");\n                _builder.append(\"<phase>initialize<\/phase>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\");\n                _builder.append(\"<goals>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"<goal>add-test-source<\/goal>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"<goal>add-test-resource<\/goal>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\");\n                _builder.append(\"<\/goals>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\");\n                _builder.append(\"<configuration>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"<sources>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\\t\");\n                _builder.append(\"<source>\");\n                String _sourceFolder_9 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.TEST_SRC_GEN);\n                _builder.append(_sourceFolder_9, \"\\t\\t\\t\\t\\t\\t\\t\");\n                _builder.append(\"<\/source>\");\n                _builder.newLineIfNotEmpty();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"<\/sources>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"<resources>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\\t\");\n                _builder.append(\"<resource>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\\t\\t\");\n                _builder.append(\"<directory>\");\n                String _sourceFolder_10 = RuntimeProjectDescriptor.this.sourceFolder(Outlet.TEST_SRC_GEN);\n                _builder.append(_sourceFolder_10, \"\\t\\t\\t\\t\\t\\t\\t\\t\");\n                _builder.append(\"<\/directory>\");\n                _builder.newLineIfNotEmpty();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\\t\");\n                _builder.append(\"<\/resource>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"<\/resources>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\");\n                _builder.append(\"<\/configuration>\");\n                _builder.newLine();\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"\\t\\t\");\n                _builder.append(\"<\/execution>\");\n                _builder.newLine();\n              }\n            }\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"\\t\");\n            _builder.append(\"<\/executions>\");\n            _builder.newLine();\n            _builder.append(\"\\t\\t\");\n            _builder.append(\"<\/plugin>\");\n            _builder.newLine();\n          }\n        }\n        _builder.append(\"\\t\");\n        _builder.append(\"<\/plugins>\");\n        _builder.newLine();\n        _builder.append(\"<\/build>\");\n        _builder.newLine();\n        it.setBuildSection(_builder.toString());\n      }\n    };\n    return ObjectExtensions.<PomFile>operator_doubleArrow(_pom, _function);\n  }","commit_id":"b9a3f39c7b0b0da857f01ff1ba1fb9b192bcec62","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public void initialize(final Injector injector) {\n    String src = \"src\";\n    String srcGen = \"src-gen\";\n    String srcWeb = \"WebRoot\";\n    String metaInf = \"META-INF\";\n    if (this.mavenLayout) {\n      src = \"src/main/java\";\n      metaInf = \"src/main/resources/META-INF\";\n      srcGen = \"src/main/xtext-gen\";\n      srcWeb = \"src/main/webapp\";\n    }\n    IXtextGeneratorFileSystemAccess _runtimeMetaInf = this.getRuntimeMetaInf();\n    boolean _tripleEquals = (_runtimeMetaInf == null);\n    if (_tripleEquals) {\n      IXtextGeneratorFileSystemAccess _runtimeRoot = this.getRuntimeRoot();\n      String _path = _runtimeRoot.getPath();\n      String _plus = (_path + \"/\");\n      String _plus_1 = (_plus + metaInf);\n      this.setRuntimeMetaInf(_plus_1);\n    }\n    IXtextGeneratorFileSystemAccess _runtimeSrc = this.getRuntimeSrc();\n    boolean _tripleEquals_1 = (_runtimeSrc == null);\n    if (_tripleEquals_1) {\n      IXtextGeneratorFileSystemAccess _runtimeRoot_1 = this.getRuntimeRoot();\n      String _path_1 = _runtimeRoot_1.getPath();\n      String _plus_2 = (_path_1 + \"/\");\n      String _plus_3 = (_plus_2 + src);\n      this.setRuntimeSrc(_plus_3);\n    }\n    IXtextGeneratorFileSystemAccess _runtimeSrcGen = this.getRuntimeSrcGen();\n    boolean _tripleEquals_2 = (_runtimeSrcGen == null);\n    if (_tripleEquals_2) {\n      IXtextGeneratorFileSystemAccess _runtimeRoot_2 = this.getRuntimeRoot();\n      String _path_2 = _runtimeRoot_2.getPath();\n      String _plus_4 = (_path_2 + \"/\");\n      String _plus_5 = (_plus_4 + srcGen);\n      this.setRuntimeSrcGen(_plus_5);\n    }\n    ManifestAccess _runtimeManifest = this.getRuntimeManifest();\n    boolean _tripleEquals_3 = (_runtimeManifest == null);\n    if (_tripleEquals_3) {\n      ManifestAccess _manifestAccess = new ManifestAccess();\n      this.setRuntimeManifest(_manifestAccess);\n    }\n    PluginXmlAccess _runtimePluginXml = this.getRuntimePluginXml();\n    boolean _tripleEquals_4 = (_runtimePluginXml == null);\n    if (_tripleEquals_4) {\n      PluginXmlAccess _pluginXmlAccess = new PluginXmlAccess();\n      this.setRuntimePluginXml(_pluginXmlAccess);\n    }\n    if (this.testingSupport) {\n      IXtextGeneratorFileSystemAccess _runtimeTestRoot = this.getRuntimeTestRoot();\n      boolean _tripleEquals_5 = (_runtimeTestRoot == null);\n      if (_tripleEquals_5) {\n        if (this.mavenLayout) {\n          IXtextGeneratorFileSystemAccess _runtimeRoot_3 = this.getRuntimeRoot();\n          String _path_3 = _runtimeRoot_3.getPath();\n          this.setRuntimeTestRoot(_path_3);\n        } else {\n          IXtextGeneratorFileSystemAccess _runtimeRoot_4 = this.getRuntimeRoot();\n          String _path_4 = _runtimeRoot_4.getPath();\n          String _plus_6 = (_path_4 + \".tests\");\n          this.setRuntimeTestRoot(_plus_6);\n        }\n      }\n      IXtextGeneratorFileSystemAccess _runtimeTestMetaInf = this.getRuntimeTestMetaInf();\n      boolean _equals = Objects.equal(_runtimeTestMetaInf, null);\n      if (_equals) {\n        IXtextGeneratorFileSystemAccess _runtimeTestRoot_1 = this.getRuntimeTestRoot();\n        String _path_5 = _runtimeTestRoot_1.getPath();\n        String _plus_7 = (_path_5 + \"/\");\n        String _plus_8 = (_plus_7 + metaInf);\n        this.setRuntimeTestMetaInf(_plus_8);\n      }\n      IXtextGeneratorFileSystemAccess _runtimeTestSrc = this.getRuntimeTestSrc();\n      boolean _tripleEquals_6 = (_runtimeTestSrc == null);\n      if (_tripleEquals_6) {\n        IXtextGeneratorFileSystemAccess _runtimeTestRoot_2 = this.getRuntimeTestRoot();\n        String _path_6 = _runtimeTestRoot_2.getPath();\n        String _plus_9 = (_path_6 + \"/\");\n        String _plus_10 = (_plus_9 + src);\n        this.setRuntimeTestSrc(_plus_10);\n      }\n      IXtextGeneratorFileSystemAccess _runtimeTestSrcGen = this.getRuntimeTestSrcGen();\n      boolean _tripleEquals_7 = (_runtimeTestSrcGen == null);\n      if (_tripleEquals_7) {\n        IXtextGeneratorFileSystemAccess _runtimeTestRoot_3 = this.getRuntimeTestRoot();\n        String _path_7 = _runtimeTestRoot_3.getPath();\n        String _plus_11 = (_path_7 + \"/\");\n        String _plus_12 = (_plus_11 + srcGen);\n        this.setRuntimeTestSrcGen(_plus_12);\n      }\n      ManifestAccess _runtimeTestManifest = this.getRuntimeTestManifest();\n      boolean _tripleEquals_8 = (_runtimeTestManifest == null);\n      if (_tripleEquals_8) {\n        ManifestAccess _manifestAccess_1 = new ManifestAccess();\n        this.setRuntimeTestManifest(_manifestAccess_1);\n      }\n    }\n    if (this.eclipseEditor) {\n      IXtextGeneratorFileSystemAccess _eclipsePluginRoot = this.getEclipsePluginRoot();\n      boolean _tripleEquals_9 = (_eclipsePluginRoot == null);\n      if (_tripleEquals_9) {\n        IXtextGeneratorFileSystemAccess _runtimeRoot_5 = this.getRuntimeRoot();\n        String _path_8 = _runtimeRoot_5.getPath();\n        String _plus_13 = (_path_8 + \".ui\");\n        this.setEclipsePluginRoot(_plus_13);\n      }\n      IXtextGeneratorFileSystemAccess _eclipsePluginMetaInf = this.getEclipsePluginMetaInf();\n      boolean _tripleEquals_10 = (_eclipsePluginMetaInf == null);\n      if (_tripleEquals_10) {\n        IXtextGeneratorFileSystemAccess _eclipsePluginRoot_1 = this.getEclipsePluginRoot();\n        String _path_9 = _eclipsePluginRoot_1.getPath();\n        String _plus_14 = (_path_9 + \"/\");\n        String _plus_15 = (_plus_14 + metaInf);\n        this.setEclipsePluginMetaInf(_plus_15);\n      }\n      IXtextGeneratorFileSystemAccess _eclipsePluginSrc = this.getEclipsePluginSrc();\n      boolean _tripleEquals_11 = (_eclipsePluginSrc == null);\n      if (_tripleEquals_11) {\n        IXtextGeneratorFileSystemAccess _eclipsePluginRoot_2 = this.getEclipsePluginRoot();\n        String _path_10 = _eclipsePluginRoot_2.getPath();\n        String _plus_16 = (_path_10 + \"/\");\n        String _plus_17 = (_plus_16 + src);\n        this.setEclipsePluginSrc(_plus_17);\n      }\n      IXtextGeneratorFileSystemAccess _eclipsePluginSrcGen = this.getEclipsePluginSrcGen();\n      boolean _tripleEquals_12 = (_eclipsePluginSrcGen == null);\n      if (_tripleEquals_12) {\n        IXtextGeneratorFileSystemAccess _eclipsePluginRoot_3 = this.getEclipsePluginRoot();\n        String _path_11 = _eclipsePluginRoot_3.getPath();\n        String _plus_18 = (_path_11 + \"/\");\n        String _plus_19 = (_plus_18 + srcGen);\n        this.setEclipsePluginSrcGen(_plus_19);\n      }\n      ManifestAccess _eclipsePluginManifest = this.getEclipsePluginManifest();\n      boolean _tripleEquals_13 = (_eclipsePluginManifest == null);\n      if (_tripleEquals_13) {\n        ManifestAccess _manifestAccess_2 = new ManifestAccess();\n        this.setEclipsePluginManifest(_manifestAccess_2);\n      }\n      PluginXmlAccess _eclipsePluginPluginXml = this.getEclipsePluginPluginXml();\n      boolean _tripleEquals_14 = (_eclipsePluginPluginXml == null);\n      if (_tripleEquals_14) {\n        PluginXmlAccess _pluginXmlAccess_1 = new PluginXmlAccess();\n        this.setEclipsePluginPluginXml(_pluginXmlAccess_1);\n      }\n      if (this.testingSupport) {\n        IXtextGeneratorFileSystemAccess _eclipsePluginTestRoot = this.getEclipsePluginTestRoot();\n        boolean _tripleEquals_15 = (_eclipsePluginTestRoot == null);\n        if (_tripleEquals_15) {\n          IXtextGeneratorFileSystemAccess _eclipsePluginRoot_4 = this.getEclipsePluginRoot();\n          String _path_12 = _eclipsePluginRoot_4.getPath();\n          String _plus_20 = (_path_12 + \".tests\");\n          this.setEclipsePluginTestRoot(_plus_20);\n        }\n        IXtextGeneratorFileSystemAccess _eclipsePluginTestMetaInf = this.getEclipsePluginTestMetaInf();\n        boolean _tripleEquals_16 = (_eclipsePluginTestMetaInf == null);\n        if (_tripleEquals_16) {\n          IXtextGeneratorFileSystemAccess _eclipsePluginTestRoot_1 = this.getEclipsePluginTestRoot();\n          String _path_13 = _eclipsePluginTestRoot_1.getPath();\n          String _plus_21 = (_path_13 + \"/\");\n          String _plus_22 = (_plus_21 + metaInf);\n          this.setEclipsePluginTestMetaInf(_plus_22);\n        }\n        IXtextGeneratorFileSystemAccess _eclipsePluginTestSrc = this.getEclipsePluginTestSrc();\n        boolean _tripleEquals_17 = (_eclipsePluginTestSrc == null);\n        if (_tripleEquals_17) {\n          IXtextGeneratorFileSystemAccess _eclipsePluginTestRoot_2 = this.getEclipsePluginTestRoot();\n          String _path_14 = _eclipsePluginTestRoot_2.getPath();\n          String _plus_23 = (_path_14 + \"/\");\n          String _plus_24 = (_plus_23 + src);\n          this.setEclipsePluginTestSrc(_plus_24);\n        }\n        IXtextGeneratorFileSystemAccess _eclipsePluginTestSrcGen = this.getEclipsePluginTestSrcGen();\n        boolean _tripleEquals_18 = (_eclipsePluginTestSrcGen == null);\n        if (_tripleEquals_18) {\n          IXtextGeneratorFileSystemAccess _eclipsePluginTestRoot_3 = this.getEclipsePluginTestRoot();\n          String _path_15 = _eclipsePluginTestRoot_3.getPath();\n          String _plus_25 = (_path_15 + \"/\");\n          String _plus_26 = (_plus_25 + srcGen);\n          this.setEclipsePluginTestSrcGen(_plus_26);\n        }\n        ManifestAccess _eclipsePluginTestManifest = this.getEclipsePluginTestManifest();\n        boolean _tripleEquals_19 = (_eclipsePluginTestManifest == null);\n        if (_tripleEquals_19) {\n          ManifestAccess _manifestAccess_3 = new ManifestAccess();\n          this.setEclipsePluginTestManifest(_manifestAccess_3);\n        }\n      }\n    }\n    if (this.ideaEditor) {\n      IXtextGeneratorFileSystemAccess _ideaPluginRoot = this.getIdeaPluginRoot();\n      boolean _tripleEquals_20 = (_ideaPluginRoot == null);\n      if (_tripleEquals_20) {\n        IXtextGeneratorFileSystemAccess _runtimeRoot_6 = this.getRuntimeRoot();\n        String _path_16 = _runtimeRoot_6.getPath();\n        String _plus_27 = (_path_16 + \".idea\");\n        this.setIdeaPluginRoot(_plus_27);\n      }\n      IXtextGeneratorFileSystemAccess _ideaPluginSrc = this.getIdeaPluginSrc();\n      boolean _tripleEquals_21 = (_ideaPluginSrc == null);\n      if (_tripleEquals_21) {\n        IXtextGeneratorFileSystemAccess _ideaPluginRoot_1 = this.getIdeaPluginRoot();\n        String _path_17 = _ideaPluginRoot_1.getPath();\n        String _plus_28 = (_path_17 + \"/\");\n        String _plus_29 = (_plus_28 + src);\n        this.setIdeaPluginSrc(_plus_29);\n      }\n      IXtextGeneratorFileSystemAccess _ideaPluginSrcGen = this.getIdeaPluginSrcGen();\n      boolean _tripleEquals_22 = (_ideaPluginSrcGen == null);\n      if (_tripleEquals_22) {\n        IXtextGeneratorFileSystemAccess _ideaPluginRoot_2 = this.getIdeaPluginRoot();\n        String _path_18 = _ideaPluginRoot_2.getPath();\n        String _plus_30 = (_path_18 + \"/\");\n        String _plus_31 = (_plus_30 + srcGen);\n        this.setIdeaPluginSrcGen(_plus_31);\n      }\n      IXtextGeneratorFileSystemAccess _ideaPluginMetaInf = this.getIdeaPluginMetaInf();\n      boolean _tripleEquals_23 = (_ideaPluginMetaInf == null);\n      if (_tripleEquals_23) {\n        IXtextGeneratorFileSystemAccess _ideaPluginRoot_3 = this.getIdeaPluginRoot();\n        String _path_19 = _ideaPluginRoot_3.getPath();\n        String _plus_32 = (_path_19 + \"/\");\n        String _plus_33 = (_plus_32 + metaInf);\n        this.setIdeaPluginMetaInf(_plus_33);\n      }\n    }\n    if (this.webSupport) {\n      IXtextGeneratorFileSystemAccess _webRoot = this.getWebRoot();\n      boolean _tripleEquals_24 = (_webRoot == null);\n      if (_tripleEquals_24) {\n        IXtextGeneratorFileSystemAccess _runtimeRoot_7 = this.getRuntimeRoot();\n        String _path_20 = _runtimeRoot_7.getPath();\n        String _plus_34 = (_path_20 + \".web\");\n        this.setWebRoot(_plus_34);\n      }\n      IXtextGeneratorFileSystemAccess _webSrc = this.getWebSrc();\n      boolean _tripleEquals_25 = (_webSrc == null);\n      if (_tripleEquals_25) {\n        IXtextGeneratorFileSystemAccess _webRoot_1 = this.getWebRoot();\n        String _path_21 = _webRoot_1.getPath();\n        String _plus_35 = (_path_21 + \"/\");\n        String _plus_36 = (_plus_35 + src);\n        this.setWebSrc(_plus_36);\n      }\n      IXtextGeneratorFileSystemAccess _webSrcGen = this.getWebSrcGen();\n      boolean _tripleEquals_26 = (_webSrcGen == null);\n      if (_tripleEquals_26) {\n        IXtextGeneratorFileSystemAccess _webRoot_2 = this.getWebRoot();\n        String _path_22 = _webRoot_2.getPath();\n        String _plus_37 = (_path_22 + \"/\");\n        String _plus_38 = (_plus_37 + srcGen);\n        this.setWebSrcGen(_plus_38);\n      }\n      IXtextGeneratorFileSystemAccess _webApp = this.getWebApp();\n      boolean _tripleEquals_27 = (_webApp == null);\n      if (_tripleEquals_27) {\n        IXtextGeneratorFileSystemAccess _webRoot_3 = this.getWebRoot();\n        String _path_23 = _webRoot_3.getPath();\n        String _plus_39 = (_path_23 + \"/\");\n        String _plus_40 = (_plus_39 + srcWeb);\n        this.setWebApp(_plus_40);\n      }\n    }\n    if (this.genericIdeSupport) {\n      IXtextGeneratorFileSystemAccess _genericIdeRoot = this.getGenericIdeRoot();\n      boolean _tripleEquals_28 = (_genericIdeRoot == null);\n      if (_tripleEquals_28) {\n        IXtextGeneratorFileSystemAccess _runtimeRoot_8 = this.getRuntimeRoot();\n        String _path_24 = _runtimeRoot_8.getPath();\n        String _plus_41 = (_path_24 + \".ide\");\n        this.setGenericIdeRoot(_plus_41);\n      }\n      IXtextGeneratorFileSystemAccess _genericIdeMetaInf = this.getGenericIdeMetaInf();\n      boolean _tripleEquals_29 = (_genericIdeMetaInf == null);\n      if (_tripleEquals_29) {\n        IXtextGeneratorFileSystemAccess _genericIdeRoot_1 = this.getGenericIdeRoot();\n        String _path_25 = _genericIdeRoot_1.getPath();\n        String _plus_42 = (_path_25 + \"/\");\n        String _plus_43 = (_plus_42 + metaInf);\n        this.setGenericIdeMetaInf(_plus_43);\n      }\n      IXtextGeneratorFileSystemAccess _genericIdeSrc = this.getGenericIdeSrc();\n      boolean _tripleEquals_30 = (_genericIdeSrc == null);\n      if (_tripleEquals_30) {\n        IXtextGeneratorFileSystemAccess _genericIdeRoot_2 = this.getGenericIdeRoot();\n        String _path_26 = _genericIdeRoot_2.getPath();\n        String _plus_44 = (_path_26 + \"/\");\n        String _plus_45 = (_plus_44 + src);\n        this.setGenericIdeSrc(_plus_45);\n      }\n      IXtextGeneratorFileSystemAccess _genericIdeSrcGen = this.getGenericIdeSrcGen();\n      boolean _tripleEquals_31 = (_genericIdeSrcGen == null);\n      if (_tripleEquals_31) {\n        IXtextGeneratorFileSystemAccess _genericIdeRoot_3 = this.getGenericIdeRoot();\n        String _path_27 = _genericIdeRoot_3.getPath();\n        String _plus_46 = (_path_27 + \"/\");\n        String _plus_47 = (_plus_46 + srcGen);\n        this.setGenericIdeSrcGen(_plus_47);\n      }\n      ManifestAccess _genericIdeManifest = this.getGenericIdeManifest();\n      boolean _tripleEquals_32 = (_genericIdeManifest == null);\n      if (_tripleEquals_32) {\n        ManifestAccess _manifestAccess_4 = new ManifestAccess();\n        this.setGenericIdeManifest(_manifestAccess_4);\n      }\n    }\n    super.initialize(injector);\n  }","id":97807,"modified_method":"@Override\n  public void initialize(final Injector injector) {\n    String src = \"src\";\n    String testSrc = src;\n    String srcGen = \"src-gen\";\n    String testSrcGen = srcGen;\n    String srcWeb = \"WebRoot\";\n    String metaInf = \"META-INF\";\n    if (this.mavenLayout) {\n      src = \"src/main/java\";\n      testSrc = \"src/test/java\";\n      metaInf = \"src/main/resources/META-INF\";\n      srcGen = \"src/main/xtext-gen\";\n      testSrcGen = \"src/test/xtext-gen\";\n      srcWeb = \"src/main/webapp\";\n    }\n    IXtextGeneratorFileSystemAccess _runtimeMetaInf = this.getRuntimeMetaInf();\n    boolean _tripleEquals = (_runtimeMetaInf == null);\n    if (_tripleEquals) {\n      IXtextGeneratorFileSystemAccess _runtimeRoot = this.getRuntimeRoot();\n      String _path = _runtimeRoot.getPath();\n      String _plus = (_path + \"/\");\n      String _plus_1 = (_plus + metaInf);\n      this.setRuntimeMetaInf(_plus_1);\n    }\n    IXtextGeneratorFileSystemAccess _runtimeSrc = this.getRuntimeSrc();\n    boolean _tripleEquals_1 = (_runtimeSrc == null);\n    if (_tripleEquals_1) {\n      IXtextGeneratorFileSystemAccess _runtimeRoot_1 = this.getRuntimeRoot();\n      String _path_1 = _runtimeRoot_1.getPath();\n      String _plus_2 = (_path_1 + \"/\");\n      String _plus_3 = (_plus_2 + src);\n      this.setRuntimeSrc(_plus_3);\n    }\n    IXtextGeneratorFileSystemAccess _runtimeSrcGen = this.getRuntimeSrcGen();\n    boolean _tripleEquals_2 = (_runtimeSrcGen == null);\n    if (_tripleEquals_2) {\n      IXtextGeneratorFileSystemAccess _runtimeRoot_2 = this.getRuntimeRoot();\n      String _path_2 = _runtimeRoot_2.getPath();\n      String _plus_4 = (_path_2 + \"/\");\n      String _plus_5 = (_plus_4 + srcGen);\n      this.setRuntimeSrcGen(_plus_5);\n    }\n    ManifestAccess _runtimeManifest = this.getRuntimeManifest();\n    boolean _tripleEquals_3 = (_runtimeManifest == null);\n    if (_tripleEquals_3) {\n      ManifestAccess _manifestAccess = new ManifestAccess();\n      this.setRuntimeManifest(_manifestAccess);\n    }\n    PluginXmlAccess _runtimePluginXml = this.getRuntimePluginXml();\n    boolean _tripleEquals_4 = (_runtimePluginXml == null);\n    if (_tripleEquals_4) {\n      PluginXmlAccess _pluginXmlAccess = new PluginXmlAccess();\n      this.setRuntimePluginXml(_pluginXmlAccess);\n    }\n    if (this.testingSupport) {\n      IXtextGeneratorFileSystemAccess _runtimeTestRoot = this.getRuntimeTestRoot();\n      boolean _tripleEquals_5 = (_runtimeTestRoot == null);\n      if (_tripleEquals_5) {\n        if (this.mavenLayout) {\n          IXtextGeneratorFileSystemAccess _runtimeRoot_3 = this.getRuntimeRoot();\n          String _path_3 = _runtimeRoot_3.getPath();\n          this.setRuntimeTestRoot(_path_3);\n        } else {\n          IXtextGeneratorFileSystemAccess _runtimeRoot_4 = this.getRuntimeRoot();\n          String _path_4 = _runtimeRoot_4.getPath();\n          String _plus_6 = (_path_4 + \".tests\");\n          this.setRuntimeTestRoot(_plus_6);\n        }\n      }\n      IXtextGeneratorFileSystemAccess _runtimeTestMetaInf = this.getRuntimeTestMetaInf();\n      boolean _equals = Objects.equal(_runtimeTestMetaInf, null);\n      if (_equals) {\n        IXtextGeneratorFileSystemAccess _runtimeTestRoot_1 = this.getRuntimeTestRoot();\n        String _path_5 = _runtimeTestRoot_1.getPath();\n        String _plus_7 = (_path_5 + \"/\");\n        String _plus_8 = (_plus_7 + metaInf);\n        this.setRuntimeTestMetaInf(_plus_8);\n      }\n      IXtextGeneratorFileSystemAccess _runtimeTestSrc = this.getRuntimeTestSrc();\n      boolean _tripleEquals_6 = (_runtimeTestSrc == null);\n      if (_tripleEquals_6) {\n        IXtextGeneratorFileSystemAccess _runtimeTestRoot_2 = this.getRuntimeTestRoot();\n        String _path_6 = _runtimeTestRoot_2.getPath();\n        String _plus_9 = (_path_6 + \"/\");\n        String _plus_10 = (_plus_9 + testSrc);\n        this.setRuntimeTestSrc(_plus_10);\n      }\n      IXtextGeneratorFileSystemAccess _runtimeTestSrcGen = this.getRuntimeTestSrcGen();\n      boolean _tripleEquals_7 = (_runtimeTestSrcGen == null);\n      if (_tripleEquals_7) {\n        IXtextGeneratorFileSystemAccess _runtimeTestRoot_3 = this.getRuntimeTestRoot();\n        String _path_7 = _runtimeTestRoot_3.getPath();\n        String _plus_11 = (_path_7 + \"/\");\n        String _plus_12 = (_plus_11 + testSrcGen);\n        this.setRuntimeTestSrcGen(_plus_12);\n      }\n      ManifestAccess _runtimeTestManifest = this.getRuntimeTestManifest();\n      boolean _tripleEquals_8 = (_runtimeTestManifest == null);\n      if (_tripleEquals_8) {\n        ManifestAccess _manifestAccess_1 = new ManifestAccess();\n        this.setRuntimeTestManifest(_manifestAccess_1);\n      }\n    }\n    if (this.eclipseEditor) {\n      IXtextGeneratorFileSystemAccess _eclipsePluginRoot = this.getEclipsePluginRoot();\n      boolean _tripleEquals_9 = (_eclipsePluginRoot == null);\n      if (_tripleEquals_9) {\n        IXtextGeneratorFileSystemAccess _runtimeRoot_5 = this.getRuntimeRoot();\n        String _path_8 = _runtimeRoot_5.getPath();\n        String _plus_13 = (_path_8 + \".ui\");\n        this.setEclipsePluginRoot(_plus_13);\n      }\n      IXtextGeneratorFileSystemAccess _eclipsePluginMetaInf = this.getEclipsePluginMetaInf();\n      boolean _tripleEquals_10 = (_eclipsePluginMetaInf == null);\n      if (_tripleEquals_10) {\n        IXtextGeneratorFileSystemAccess _eclipsePluginRoot_1 = this.getEclipsePluginRoot();\n        String _path_9 = _eclipsePluginRoot_1.getPath();\n        String _plus_14 = (_path_9 + \"/\");\n        String _plus_15 = (_plus_14 + metaInf);\n        this.setEclipsePluginMetaInf(_plus_15);\n      }\n      IXtextGeneratorFileSystemAccess _eclipsePluginSrc = this.getEclipsePluginSrc();\n      boolean _tripleEquals_11 = (_eclipsePluginSrc == null);\n      if (_tripleEquals_11) {\n        IXtextGeneratorFileSystemAccess _eclipsePluginRoot_2 = this.getEclipsePluginRoot();\n        String _path_10 = _eclipsePluginRoot_2.getPath();\n        String _plus_16 = (_path_10 + \"/\");\n        String _plus_17 = (_plus_16 + src);\n        this.setEclipsePluginSrc(_plus_17);\n      }\n      IXtextGeneratorFileSystemAccess _eclipsePluginSrcGen = this.getEclipsePluginSrcGen();\n      boolean _tripleEquals_12 = (_eclipsePluginSrcGen == null);\n      if (_tripleEquals_12) {\n        IXtextGeneratorFileSystemAccess _eclipsePluginRoot_3 = this.getEclipsePluginRoot();\n        String _path_11 = _eclipsePluginRoot_3.getPath();\n        String _plus_18 = (_path_11 + \"/\");\n        String _plus_19 = (_plus_18 + srcGen);\n        this.setEclipsePluginSrcGen(_plus_19);\n      }\n      ManifestAccess _eclipsePluginManifest = this.getEclipsePluginManifest();\n      boolean _tripleEquals_13 = (_eclipsePluginManifest == null);\n      if (_tripleEquals_13) {\n        ManifestAccess _manifestAccess_2 = new ManifestAccess();\n        this.setEclipsePluginManifest(_manifestAccess_2);\n      }\n      PluginXmlAccess _eclipsePluginPluginXml = this.getEclipsePluginPluginXml();\n      boolean _tripleEquals_14 = (_eclipsePluginPluginXml == null);\n      if (_tripleEquals_14) {\n        PluginXmlAccess _pluginXmlAccess_1 = new PluginXmlAccess();\n        this.setEclipsePluginPluginXml(_pluginXmlAccess_1);\n      }\n      if (this.testingSupport) {\n        IXtextGeneratorFileSystemAccess _eclipsePluginTestRoot = this.getEclipsePluginTestRoot();\n        boolean _tripleEquals_15 = (_eclipsePluginTestRoot == null);\n        if (_tripleEquals_15) {\n          IXtextGeneratorFileSystemAccess _eclipsePluginRoot_4 = this.getEclipsePluginRoot();\n          String _path_12 = _eclipsePluginRoot_4.getPath();\n          String _plus_20 = (_path_12 + \".tests\");\n          this.setEclipsePluginTestRoot(_plus_20);\n        }\n        IXtextGeneratorFileSystemAccess _eclipsePluginTestMetaInf = this.getEclipsePluginTestMetaInf();\n        boolean _tripleEquals_16 = (_eclipsePluginTestMetaInf == null);\n        if (_tripleEquals_16) {\n          IXtextGeneratorFileSystemAccess _eclipsePluginTestRoot_1 = this.getEclipsePluginTestRoot();\n          String _path_13 = _eclipsePluginTestRoot_1.getPath();\n          String _plus_21 = (_path_13 + \"/\");\n          String _plus_22 = (_plus_21 + metaInf);\n          this.setEclipsePluginTestMetaInf(_plus_22);\n        }\n        IXtextGeneratorFileSystemAccess _eclipsePluginTestSrc = this.getEclipsePluginTestSrc();\n        boolean _tripleEquals_17 = (_eclipsePluginTestSrc == null);\n        if (_tripleEquals_17) {\n          IXtextGeneratorFileSystemAccess _eclipsePluginTestRoot_2 = this.getEclipsePluginTestRoot();\n          String _path_14 = _eclipsePluginTestRoot_2.getPath();\n          String _plus_23 = (_path_14 + \"/\");\n          String _plus_24 = (_plus_23 + testSrc);\n          this.setEclipsePluginTestSrc(_plus_24);\n        }\n        IXtextGeneratorFileSystemAccess _eclipsePluginTestSrcGen = this.getEclipsePluginTestSrcGen();\n        boolean _tripleEquals_18 = (_eclipsePluginTestSrcGen == null);\n        if (_tripleEquals_18) {\n          IXtextGeneratorFileSystemAccess _eclipsePluginTestRoot_3 = this.getEclipsePluginTestRoot();\n          String _path_15 = _eclipsePluginTestRoot_3.getPath();\n          String _plus_25 = (_path_15 + \"/\");\n          String _plus_26 = (_plus_25 + testSrcGen);\n          this.setEclipsePluginTestSrcGen(_plus_26);\n        }\n        ManifestAccess _eclipsePluginTestManifest = this.getEclipsePluginTestManifest();\n        boolean _tripleEquals_19 = (_eclipsePluginTestManifest == null);\n        if (_tripleEquals_19) {\n          ManifestAccess _manifestAccess_3 = new ManifestAccess();\n          this.setEclipsePluginTestManifest(_manifestAccess_3);\n        }\n      }\n    }\n    if (this.ideaEditor) {\n      IXtextGeneratorFileSystemAccess _ideaPluginRoot = this.getIdeaPluginRoot();\n      boolean _tripleEquals_20 = (_ideaPluginRoot == null);\n      if (_tripleEquals_20) {\n        IXtextGeneratorFileSystemAccess _runtimeRoot_6 = this.getRuntimeRoot();\n        String _path_16 = _runtimeRoot_6.getPath();\n        String _plus_27 = (_path_16 + \".idea\");\n        this.setIdeaPluginRoot(_plus_27);\n      }\n      IXtextGeneratorFileSystemAccess _ideaPluginSrc = this.getIdeaPluginSrc();\n      boolean _tripleEquals_21 = (_ideaPluginSrc == null);\n      if (_tripleEquals_21) {\n        IXtextGeneratorFileSystemAccess _ideaPluginRoot_1 = this.getIdeaPluginRoot();\n        String _path_17 = _ideaPluginRoot_1.getPath();\n        String _plus_28 = (_path_17 + \"/\");\n        String _plus_29 = (_plus_28 + src);\n        this.setIdeaPluginSrc(_plus_29);\n      }\n      IXtextGeneratorFileSystemAccess _ideaPluginSrcGen = this.getIdeaPluginSrcGen();\n      boolean _tripleEquals_22 = (_ideaPluginSrcGen == null);\n      if (_tripleEquals_22) {\n        IXtextGeneratorFileSystemAccess _ideaPluginRoot_2 = this.getIdeaPluginRoot();\n        String _path_18 = _ideaPluginRoot_2.getPath();\n        String _plus_30 = (_path_18 + \"/\");\n        String _plus_31 = (_plus_30 + srcGen);\n        this.setIdeaPluginSrcGen(_plus_31);\n      }\n      IXtextGeneratorFileSystemAccess _ideaPluginMetaInf = this.getIdeaPluginMetaInf();\n      boolean _tripleEquals_23 = (_ideaPluginMetaInf == null);\n      if (_tripleEquals_23) {\n        IXtextGeneratorFileSystemAccess _ideaPluginRoot_3 = this.getIdeaPluginRoot();\n        String _path_19 = _ideaPluginRoot_3.getPath();\n        String _plus_32 = (_path_19 + \"/\");\n        String _plus_33 = (_plus_32 + metaInf);\n        this.setIdeaPluginMetaInf(_plus_33);\n      }\n    }\n    if (this.webSupport) {\n      IXtextGeneratorFileSystemAccess _webRoot = this.getWebRoot();\n      boolean _tripleEquals_24 = (_webRoot == null);\n      if (_tripleEquals_24) {\n        IXtextGeneratorFileSystemAccess _runtimeRoot_7 = this.getRuntimeRoot();\n        String _path_20 = _runtimeRoot_7.getPath();\n        String _plus_34 = (_path_20 + \".web\");\n        this.setWebRoot(_plus_34);\n      }\n      IXtextGeneratorFileSystemAccess _webSrc = this.getWebSrc();\n      boolean _tripleEquals_25 = (_webSrc == null);\n      if (_tripleEquals_25) {\n        IXtextGeneratorFileSystemAccess _webRoot_1 = this.getWebRoot();\n        String _path_21 = _webRoot_1.getPath();\n        String _plus_35 = (_path_21 + \"/\");\n        String _plus_36 = (_plus_35 + src);\n        this.setWebSrc(_plus_36);\n      }\n      IXtextGeneratorFileSystemAccess _webSrcGen = this.getWebSrcGen();\n      boolean _tripleEquals_26 = (_webSrcGen == null);\n      if (_tripleEquals_26) {\n        IXtextGeneratorFileSystemAccess _webRoot_2 = this.getWebRoot();\n        String _path_22 = _webRoot_2.getPath();\n        String _plus_37 = (_path_22 + \"/\");\n        String _plus_38 = (_plus_37 + srcGen);\n        this.setWebSrcGen(_plus_38);\n      }\n      IXtextGeneratorFileSystemAccess _webApp = this.getWebApp();\n      boolean _tripleEquals_27 = (_webApp == null);\n      if (_tripleEquals_27) {\n        IXtextGeneratorFileSystemAccess _webRoot_3 = this.getWebRoot();\n        String _path_23 = _webRoot_3.getPath();\n        String _plus_39 = (_path_23 + \"/\");\n        String _plus_40 = (_plus_39 + srcWeb);\n        this.setWebApp(_plus_40);\n      }\n    }\n    if (this.genericIdeSupport) {\n      IXtextGeneratorFileSystemAccess _genericIdeRoot = this.getGenericIdeRoot();\n      boolean _tripleEquals_28 = (_genericIdeRoot == null);\n      if (_tripleEquals_28) {\n        IXtextGeneratorFileSystemAccess _runtimeRoot_8 = this.getRuntimeRoot();\n        String _path_24 = _runtimeRoot_8.getPath();\n        String _plus_41 = (_path_24 + \".ide\");\n        this.setGenericIdeRoot(_plus_41);\n      }\n      IXtextGeneratorFileSystemAccess _genericIdeMetaInf = this.getGenericIdeMetaInf();\n      boolean _tripleEquals_29 = (_genericIdeMetaInf == null);\n      if (_tripleEquals_29) {\n        IXtextGeneratorFileSystemAccess _genericIdeRoot_1 = this.getGenericIdeRoot();\n        String _path_25 = _genericIdeRoot_1.getPath();\n        String _plus_42 = (_path_25 + \"/\");\n        String _plus_43 = (_plus_42 + metaInf);\n        this.setGenericIdeMetaInf(_plus_43);\n      }\n      IXtextGeneratorFileSystemAccess _genericIdeSrc = this.getGenericIdeSrc();\n      boolean _tripleEquals_30 = (_genericIdeSrc == null);\n      if (_tripleEquals_30) {\n        IXtextGeneratorFileSystemAccess _genericIdeRoot_2 = this.getGenericIdeRoot();\n        String _path_26 = _genericIdeRoot_2.getPath();\n        String _plus_44 = (_path_26 + \"/\");\n        String _plus_45 = (_plus_44 + src);\n        this.setGenericIdeSrc(_plus_45);\n      }\n      IXtextGeneratorFileSystemAccess _genericIdeSrcGen = this.getGenericIdeSrcGen();\n      boolean _tripleEquals_31 = (_genericIdeSrcGen == null);\n      if (_tripleEquals_31) {\n        IXtextGeneratorFileSystemAccess _genericIdeRoot_3 = this.getGenericIdeRoot();\n        String _path_27 = _genericIdeRoot_3.getPath();\n        String _plus_46 = (_path_27 + \"/\");\n        String _plus_47 = (_plus_46 + srcGen);\n        this.setGenericIdeSrcGen(_plus_47);\n      }\n      ManifestAccess _genericIdeManifest = this.getGenericIdeManifest();\n      boolean _tripleEquals_32 = (_genericIdeManifest == null);\n      if (_tripleEquals_32) {\n        ManifestAccess _manifestAccess_4 = new ManifestAccess();\n        this.setGenericIdeManifest(_manifestAccess_4);\n      }\n    }\n    super.initialize(injector);\n  }","commit_id":"b9a3f39c7b0b0da857f01ff1ba1fb9b192bcec62","url":"https://github.com/eclipse/xtext"},{"original_method":"@AfterMethod\n    void tearDown() throws Exception {\n        if(ch2 != null) {\n            ch2.close();\n            ch2 = null;\n        }\n        if(ch1 != null) {\n            ch1.close();\n            ch1 = null;\n        }\n    }","id":97808,"modified_method":"@AfterMethod\n    void tearDown() throws Exception {\n        Util.close(c2, c1);\n    }","commit_id":"b440910b8814ce7174fec24a372a6312d18d4291","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testBroadcastSequence() throws Exception {\n        r1=new MyReceiver(ch1.getAddress());\n        ch1.setReceiver(r1);\n        r2=new MyReceiver(ch2.getAddress());\n        ch2.setReceiver(r2);\n        \n        // use concurrent senders to send messages to the group\n        \n        Thread thread1 = new Thread() {\n        \tpublic void run() {\n        \t\tUtil.sleep(300);\n                for(int i=1; i <= NUM_MSGS; i++) {\n                    try {\n                    \tch1.send(new Message(null, null, new Integer(i)));\n                    } catch (Exception e) {\n                    \tthrow new RuntimeException(e);\n                    }\n                    System.out.print(\"-- messages sent thread 1: \" + i + \"/\" + NUM_MSGS + \"\\r\");\n                }\n\n        \t}\n        };\n        \n    \tThread thread2 = new Thread() {\n        \tpublic void run() {\n        \t\tUtil.sleep(300);\n                for(int i=1; i <= NUM_MSGS; i++) {\n                    try {\n                    \tch2.send(new Message(null, null, new Integer(i)));\n                    } catch (Exception e) {\n                    \tthrow new RuntimeException(e);\n                    }\n                    System.out.print(\"-- messages sent thread 2: \" + i + \"/\" + NUM_MSGS + \"\\r\");\n                }\n\n        \t}\n        };\n        \n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n        \n        System.out.println(\"\");\n        System.out.println(\"-- verifying messages on ch1 and ch2\");\n        verifyNumberOfMessages(NUM_MSGS * 2);\n        verifyMessageOrder(r1.getMsgs());\n        verifyMessageOrder(r2.getMsgs());\n        verifySameOrder();\n    }","id":97809,"modified_method":"@Test @SuppressWarnings(\"unchecked\")\n    public void testBroadcastSequence() throws Exception {\n        insertShuffle(c1, c2);\n        \n        // use concurrent senders to send messages to the group\n        for(Sender sender: senders)\n            sender.start();\n\n        for(Sender sender: senders)\n            sender.join(20000);\n\n        final List<String> l1=r1.getMsgs();\n        final List<String> l2=r2.getMsgs();\n        \n        System.out.println(\"-- verifying messages on A and B\");\n        verifyNumberOfMessages(EXPECTED_MSGS, l1, l2);\n        verifySameOrder(EXPECTED_MSGS, l1, l2);\n    }","commit_id":"b440910b8814ce7174fec24a372a6312d18d4291","url":"https://github.com/belaban/JGroups"},{"original_method":"private void verifyNumberOfMessages(int num_msgs) throws Exception {\n        List<Integer> l1=r1.getMsgs();\n        List<Integer> l2=r2.getMsgs();\n\n        long end_time=System.currentTimeMillis() + 10000;\n        while(System.currentTimeMillis() < end_time) {\n            if(l1.size() >= num_msgs && l2.size() >= num_msgs)\n                break;\n            Util.sleep(500);\n        }\n\n        System.out.println(\"l1.size()=\" + l1.size() + \", l2.size()=\" + l2.size());\n        Assert.assertEquals(l1.size(), num_msgs, \"list 1 should have \" + num_msgs + \" elements\");\n        Assert.assertEquals(l2.size(), num_msgs, \"list 2 should have \" + num_msgs + \" elements\");\n    }","id":97810,"modified_method":"private static void verifyNumberOfMessages(int num_msgs, List<String> ... lists) throws Exception {\n        long end_time=System.currentTimeMillis() + 10000;\n        while(System.currentTimeMillis() < end_time) {\n            boolean all_correct=true;\n            for(List<String> list: lists) {\n                if(list.size() != num_msgs) {\n                    all_correct=false;\n                    break;\n                }\n            }\n            if(all_correct)\n                break;\n            Util.sleep(1000);\n        }\n\n        for(int i=0; i < lists.length; i++)\n            System.out.println(\"list #\" + (i+1) + \": \" + lists[i]);\n\n        for(int i=0; i < lists.length; i++)\n            assert lists[i].size() == num_msgs : \"list #\" + (i+1) + \" should have \" + num_msgs + \" elements\";\n        System.out.println(\"OK, all lists have the same size (\" + num_msgs + \")\\n\");\n    }","commit_id":"b440910b8814ce7174fec24a372a6312d18d4291","url":"https://github.com/belaban/JGroups"},{"original_method":"public void receive(Message msg) {\n            msgs.add((Integer)msg.getObject());\n        }","id":97811,"modified_method":"public void receive(Message msg) {\n            String val=(String)msg.getObject();\n            if(val != null) {\n                synchronized(msgs) {\n                    msgs.add(val);\n                }\n            }\n        }","commit_id":"b440910b8814ce7174fec24a372a6312d18d4291","url":"https://github.com/belaban/JGroups"},{"original_method":"private void verifyMessageOrder(List<Integer> list) throws Exception {\n        List<Integer> l1=r1.getMsgs();\n        List<Integer> l2=r2.getMsgs();\n        System.out.println(\"l1: \" + l1);\n        System.out.println(\"l2: \" + l2);\n        int i=1,j=1;\n        for(int count: list) {\n            if(count == i)\n                i++;\n            else if(count == j)\n                j++;\n            else\n                throw new Exception(\"got \" + count + \", but expected \" + i + \" or \" + j);\n        }\n    }","id":97812,"modified_method":"private static void verifySameOrder(int expected_msgs, List<String> ... lists) throws Exception {\n        for(int index=0; index < expected_msgs; index++) {\n            String val=null;\n            for(List<String> list: lists) {\n                if(val == null)\n                    val=list.get(index);\n                else {\n                    String val2=list.get(index);\n                    assert val.equals(val2) : \"found different values at index \" + index + \": \" + val + \" != \" + val2;\n                }\n            }\n        }\n    }","commit_id":"b440910b8814ce7174fec24a372a6312d18d4291","url":"https://github.com/belaban/JGroups"},{"original_method":"public List<Integer> getMsgs() {\n            return msgs;\n        }","id":97813,"modified_method":"public List<String> getMsgs() {\n            return msgs;\n        }","commit_id":"b440910b8814ce7174fec24a372a6312d18d4291","url":"https://github.com/belaban/JGroups"},{"original_method":"@BeforeMethod\n    void setUp() throws Exception {\n        ch1=new JChannel(props);\n        ch1.connect(GROUP);\n\n        ch2=new JChannel(props);\n        ch2.connect(GROUP);\n    }","id":97814,"modified_method":"@BeforeMethod\n    void setUp() throws Exception {\n        c1=new JChannel(props);\n        c1.setName(\"A\");\n        c1.connect(GROUP);\n        r1=new MyReceiver(\"A\");\n        c1.setReceiver(r1);\n\n        c2=new JChannel(props);\n        c2.setName(\"B\");\n        c2.connect(GROUP);\n        r2=new MyReceiver(\"B\");\n        c2.setReceiver(r2);\n\n        for(int i=0; i < senders.length; i++)\n            senders[i]=new Sender(NUM_MSGS, c1, c2);\n    }","commit_id":"b440910b8814ce7174fec24a372a6312d18d4291","url":"https://github.com/belaban/JGroups"},{"original_method":"@AfterMethod\n    void tearDown() throws Exception {\n        if(ch2 != null) {\n            ch2.close();\n            ch2 = null;\n        }\n        if(ch1 != null) {\n            ch1.close();\n            ch1 = null;\n        }\n    }","id":97815,"modified_method":"@AfterMethod\n    void tearDown() throws Exception {\n        Util.close(c2, c1);\n    }","commit_id":"9ab2af5bbb04f81614552b287d142867332bbbd0","url":"https://github.com/belaban/JGroups"},{"original_method":"@BeforeMethod\n    void setUp() throws Exception {\n        ch1=new JChannel(props);\n        ch1.connect(GROUP);\n\n        ch2=new JChannel(props);\n        ch2.connect(GROUP);\n    }","id":97816,"modified_method":"@BeforeMethod\n    void setUp() throws Exception {\n        c1=new JChannel(props);\n        c1.setName(\"A\");\n        c1.connect(GROUP);\n        r1=new MyReceiver(\"A\");\n        c1.setReceiver(r1);\n\n        c2=new JChannel(props);\n        c2.setName(\"B\");\n        c2.connect(GROUP);\n        r2=new MyReceiver(\"B\");\n        c2.setReceiver(r2);\n\n        for(int i=0; i < senders.length; i++)\n            senders[i]=new Sender(NUM_MSGS, c1, c2);\n    }","commit_id":"9ab2af5bbb04f81614552b287d142867332bbbd0","url":"https://github.com/belaban/JGroups"},{"original_method":"public List<Integer> getMsgs() {\n            return msgs;\n        }","id":97817,"modified_method":"public List<String> getMsgs() {\n            return msgs;\n        }","commit_id":"9ab2af5bbb04f81614552b287d142867332bbbd0","url":"https://github.com/belaban/JGroups"},{"original_method":"private void verifyMessageOrder(List<Integer> list) throws Exception {\n        List<Integer> l1=r1.getMsgs();\n        List<Integer> l2=r2.getMsgs();\n        System.out.println(\"l1: \" + l1);\n        System.out.println(\"l2: \" + l2);\n        int i=1,j=1;\n        for(int count: list) {\n            if(count == i)\n                i++;\n            else if(count == j)\n                j++;\n            else\n                throw new Exception(\"got \" + count + \", but expected \" + i + \" or \" + j);\n        }\n    }","id":97818,"modified_method":"private static void verifySameOrder(int expected_msgs, List<String> ... lists) throws Exception {\n        for(int index=0; index < expected_msgs; index++) {\n            String val=null;\n            for(List<String> list: lists) {\n                if(val == null)\n                    val=list.get(index);\n                else {\n                    String val2=list.get(index);\n                    assert val.equals(val2) : \"found different values at index \" + index + \": \" + val + \" != \" + val2;\n                }\n            }\n        }\n    }","commit_id":"9ab2af5bbb04f81614552b287d142867332bbbd0","url":"https://github.com/belaban/JGroups"},{"original_method":"private void verifyNumberOfMessages(int num_msgs) throws Exception {\n        List<Integer> l1=r1.getMsgs();\n        List<Integer> l2=r2.getMsgs();\n\n        long end_time=System.currentTimeMillis() + 10000;\n        while(System.currentTimeMillis() < end_time) {\n            if(l1.size() >= num_msgs && l2.size() >= num_msgs)\n                break;\n            Util.sleep(500);\n        }\n\n        System.out.println(\"l1.size()=\" + l1.size() + \", l2.size()=\" + l2.size());\n        Assert.assertEquals(l1.size(), num_msgs, \"list 1 should have \" + num_msgs + \" elements\");\n        Assert.assertEquals(l2.size(), num_msgs, \"list 2 should have \" + num_msgs + \" elements\");\n    }","id":97819,"modified_method":"private static void verifyNumberOfMessages(int num_msgs, List<String> ... lists) throws Exception {\n        long end_time=System.currentTimeMillis() + 10000;\n        while(System.currentTimeMillis() < end_time) {\n            boolean all_correct=true;\n            for(List<String> list: lists) {\n                if(list.size() != num_msgs) {\n                    all_correct=false;\n                    break;\n                }\n            }\n            if(all_correct)\n                break;\n            Util.sleep(1000);\n        }\n\n        for(int i=0; i < lists.length; i++)\n            System.out.println(\"list #\" + (i+1) + \": \" + lists[i]);\n\n        for(int i=0; i < lists.length; i++)\n            assert lists[i].size() == num_msgs : \"list #\" + (i+1) + \" should have \" + num_msgs + \" elements\";\n        System.out.println(\"OK, all lists have the same size (\" + num_msgs + \")\\n\");\n    }","commit_id":"9ab2af5bbb04f81614552b287d142867332bbbd0","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testBroadcastSequence() throws Exception {\n        r1=new MyReceiver(ch1.getAddress());\n        ch1.setReceiver(r1);\n        r2=new MyReceiver(ch2.getAddress());\n        ch2.setReceiver(r2);\n        \n        // use concurrent senders to send messages to the group\n        \n        Thread thread1 = new Thread() {\n        \tpublic void run() {\n        \t\tUtil.sleep(300);\n                for(int i=1; i <= NUM_MSGS; i++) {\n                    try {\n                    \tch1.send(new Message(null, null, new Integer(i)));\n                    } catch (Exception e) {\n                    \tthrow new RuntimeException(e);\n                    }\n                    System.out.print(\"-- messages sent thread 1: \" + i + \"/\" + NUM_MSGS + \"\\r\");\n                }\n\n        \t}\n        };\n        \n    \tThread thread2 = new Thread() {\n        \tpublic void run() {\n        \t\tUtil.sleep(300);\n                for(int i=1; i <= NUM_MSGS; i++) {\n                    try {\n                    \tch2.send(new Message(null, null, new Integer(i)));\n                    } catch (Exception e) {\n                    \tthrow new RuntimeException(e);\n                    }\n                    System.out.print(\"-- messages sent thread 2: \" + i + \"/\" + NUM_MSGS + \"\\r\");\n                }\n\n        \t}\n        };\n        \n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n        \n        System.out.println(\"\");\n        System.out.println(\"-- verifying messages on ch1 and ch2\");\n        verifyNumberOfMessages(NUM_MSGS * 2);\n        verifyMessageOrder(r1.getMsgs());\n        verifyMessageOrder(r2.getMsgs());\n        verifySameOrder();\n    }","id":97820,"modified_method":"@Test @SuppressWarnings(\"unchecked\")\n    public void testBroadcastSequence() throws Exception {\n        insertShuffle(c1, c2);\n        \n        // use concurrent senders to send messages to the group\n        for(Sender sender: senders)\n            sender.start();\n\n        for(Sender sender: senders)\n            sender.join(20000);\n\n        final List<String> l1=r1.getMsgs();\n        final List<String> l2=r2.getMsgs();\n        \n        System.out.println(\"-- verifying messages on A and B\");\n        verifyNumberOfMessages(EXPECTED_MSGS, l1, l2);\n        verifySameOrder(EXPECTED_MSGS, l1, l2);\n    }","commit_id":"9ab2af5bbb04f81614552b287d142867332bbbd0","url":"https://github.com/belaban/JGroups"},{"original_method":"public void receive(Message msg) {\n            msgs.add((Integer)msg.getObject());\n        }","id":97821,"modified_method":"public void receive(Message msg) {\n            String val=(String)msg.getObject();\n            if(val != null) {\n                synchronized(msgs) {\n                    msgs.add(val);\n                }\n            }\n        }","commit_id":"9ab2af5bbb04f81614552b287d142867332bbbd0","url":"https://github.com/belaban/JGroups"},{"original_method":"public List<String> getModelResourceGuestUnsupportedActions(String name) {\n\t\tList<String> actions = getActions(\n\t\t\t_modelResourceGuestUnsupportedActions, name);\n\n\t\treturn ListUtil.copy(actions);\n\t}","id":97822,"modified_method":"public List<String> getModelResourceGuestUnsupportedActions(String name) {\n\t\treturn getActions(_modelResourceGuestUnsupportedActions, name);\n\t}","commit_id":"45478c142556b0210ef2f30c300908a1f3b0ab56","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<String> getModelResourceActions(String name) {\n\t\tList<String> actions = getActions(_modelResourceActions, name);\n\n\t\treturn ListUtil.copy(actions);\n\t}","id":97823,"modified_method":"public List<String> getModelResourceActions(String name) {\n\t\treturn getActions(_modelResourceActions, name);\n\t}","commit_id":"45478c142556b0210ef2f30c300908a1f3b0ab56","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<String> getPortletResourceCommunityDefaultActions(String name) {\n\n\t\t// This method should always be called only after\n\t\t// _getPortletResourceActions has been called at least once to\n\t\t// populate the default community actions. Check to make sure this is\n\t\t// the case. However, if it is not, that means the methods\n\t\t// getPortletResourceGuestDefaultActions and\n\t\t// getPortletResourceGuestDefaultActions may not work either.\n\n\t\tname = PortletConstants.getRootPortletId(name);\n\n\t\tList<String> actions = getActions(\n\t\t\t_portletResourceCommunityDefaultActions, name);\n\n\t\treturn ListUtil.copy(actions);\n\t}","id":97824,"modified_method":"public List<String> getPortletResourceCommunityDefaultActions(String name) {\n\n\t\t// This method should always be called only after\n\t\t// _getPortletResourceActions has been called at least once to\n\t\t// populate the default community actions. Check to make sure this is\n\t\t// the case. However, if it is not, that means the methods\n\t\t// getPortletResourceGuestDefaultActions and\n\t\t// getPortletResourceGuestDefaultActions may not work either.\n\n\t\tname = PortletConstants.getRootPortletId(name);\n\n\t\treturn getActions(_portletResourceCommunityDefaultActions, name);\n\t}","commit_id":"45478c142556b0210ef2f30c300908a1f3b0ab56","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<String> getPortletResourceLayoutManagerActions(String name) {\n\t\tname = PortletConstants.getRootPortletId(name);\n\n\t\tList<String> actions = getActions(\n\t\t\t_portletResourceLayoutManagerActions, name);\n\n\t\t// This check can never return an empty list. If the list is empty, it\n\t\t// means that the portlet does not have an explicit resource-actions\n\t\t// configuration file and should therefore be handled as if it has\n\t\t// defaults of CONFIGURATION, PREFERENCES, and VIEW.\n\n\t\tif (actions.size() < 1) {\n\t\t\tactions.add(ActionKeys.CONFIGURATION);\n\t\t\tactions.add(ActionKeys.PREFERENCES);\n\t\t\tactions.add(ActionKeys.VIEW);\n\t\t}\n\n\t\treturn ListUtil.copy(actions);\n\t}","id":97825,"modified_method":"public List<String> getPortletResourceLayoutManagerActions(String name) {\n\t\tname = PortletConstants.getRootPortletId(name);\n\n\t\tList<String> actions = getActions(\n\t\t\t_portletResourceLayoutManagerActions, name);\n\n\t\t// This check can never return an empty list. If the list is empty, it\n\t\t// means that the portlet does not have an explicit resource-actions\n\t\t// configuration file and should therefore be handled as if it has\n\t\t// defaults of CONFIGURATION, PREFERENCES, and VIEW.\n\n\t\tif (actions.size() < 1) {\n\t\t\tactions.add(ActionKeys.CONFIGURATION);\n\t\t\tactions.add(ActionKeys.PREFERENCES);\n\t\t\tactions.add(ActionKeys.VIEW);\n\t\t}\n\n\t\treturn actions;\n\t}","commit_id":"45478c142556b0210ef2f30c300908a1f3b0ab56","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<String> getModelResourceOwnerDefaultActions(String name) {\n\t\tList<String> actions = getActions(\n\t\t\t_modelResourceOwnerDefaultActions, name);\n\n\t\treturn ListUtil.copy(actions);\n\t}","id":97826,"modified_method":"public List<String> getModelResourceOwnerDefaultActions(String name) {\n\t\treturn getActions(_modelResourceOwnerDefaultActions, name);\n\t}","commit_id":"45478c142556b0210ef2f30c300908a1f3b0ab56","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<String> getModelResourceCommunityDefaultActions(String name) {\n\t\tList<String> actions = getActions(\n\t\t\t_modelResourceCommunityDefaultActions, name);\n\n\t\treturn ListUtil.copy(actions);\n\t}","id":97827,"modified_method":"public List<String> getModelResourceCommunityDefaultActions(String name) {\n\t\treturn getActions(_modelResourceCommunityDefaultActions, name);\n\t}","commit_id":"45478c142556b0210ef2f30c300908a1f3b0ab56","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<String> getPortletResourceGuestDefaultActions(String name) {\n\t\tname = PortletConstants.getRootPortletId(name);\n\n\t\tList<String> actions = getActions(\n\t\t\t_portletResourceGuestDefaultActions, name);\n\n\t\treturn ListUtil.copy(actions);\n\t}","id":97828,"modified_method":"public List<String> getPortletResourceGuestDefaultActions(String name) {\n\t\tname = PortletConstants.getRootPortletId(name);\n\n\t\treturn getActions(_portletResourceGuestDefaultActions, name);\n\t}","commit_id":"45478c142556b0210ef2f30c300908a1f3b0ab56","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<String> getPortletResourceGuestUnsupportedActions(String name) {\n\t\tname = PortletConstants.getRootPortletId(name);\n\n\t\tList<String> actions = getActions(\n\t\t\t_portletResourceGuestUnsupportedActions, name);\n\n\t\treturn ListUtil.copy(actions);\n\t}","id":97829,"modified_method":"public List<String> getPortletResourceGuestUnsupportedActions(String name) {\n\t\tname = PortletConstants.getRootPortletId(name);\n\n\t\treturn getActions(_portletResourceGuestUnsupportedActions, name);\n\t}","commit_id":"45478c142556b0210ef2f30c300908a1f3b0ab56","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<String> getModelResourceGuestDefaultActions(String name) {\n\t\tList<String> actions = getActions(\n\t\t\t_modelResourceGuestDefaultActions, name);\n\n\t\treturn ListUtil.copy(actions);\n\t}","id":97830,"modified_method":"public List<String> getModelResourceGuestDefaultActions(String name) {\n\t\treturn getActions(_modelResourceGuestDefaultActions, name);\n\t}","commit_id":"45478c142556b0210ef2f30c300908a1f3b0ab56","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<String> getPortletResourceActions(String name) {\n\t\tname = PortletConstants.getRootPortletId(name);\n\n\t\tList<String> actions = getActions(_portletResourceActions, name);\n\n\t\tif (actions.size() == 0) {\n\t\t\tsynchronized (this) {\n\t\t\t\tactions = getPortletMimeTypeActions(name);\n\n\t\t\t\tif (!name.equals(PortletKeys.PORTAL)) {\n\t\t\t\t\tcheckPortletActions(actions);\n\t\t\t\t}\n\n\t\t\t\tList<String> communityDefaultActions =\n\t\t\t\t\t_portletResourceCommunityDefaultActions.get(name);\n\n\t\t\t\tif (communityDefaultActions == null) {\n\t\t\t\t\tcommunityDefaultActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceCommunityDefaultActions.put(\n\t\t\t\t\t\tname, communityDefaultActions);\n\n\t\t\t\t\tcheckPortletCommunityDefaultActions(\n\t\t\t\t\t\tcommunityDefaultActions);\n\t\t\t\t}\n\n\t\t\t\tList<String> guestDefaultActions =\n\t\t\t\t\t_portletResourceGuestDefaultActions.get(name);\n\n\t\t\t\tif (guestDefaultActions == null) {\n\t\t\t\t\tguestDefaultActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceGuestDefaultActions.put(\n\t\t\t\t\t\tname, guestDefaultActions);\n\n\t\t\t\t\tcheckPortletGuestDefaultActions(guestDefaultActions);\n\t\t\t\t}\n\n\t\t\t\tList<String> layoutManagerActions =\n\t\t\t\t\t_portletResourceLayoutManagerActions.get(name);\n\n\t\t\t\tif (layoutManagerActions == null) {\n\t\t\t\t\tlayoutManagerActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceLayoutManagerActions.put(\n\t\t\t\t\t\tname, layoutManagerActions);\n\n\t\t\t\t\tcheckPortletLayoutManagerActions(layoutManagerActions);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ListUtil.copy(actions);\n\t}","id":97831,"modified_method":"public List<String> getPortletResourceActions(String name) {\n\t\tname = PortletConstants.getRootPortletId(name);\n\n\t\tList<String> actions = getActions(_portletResourceActions, name);\n\n\t\tif (actions.size() == 0) {\n\t\t\tsynchronized (this) {\n\t\t\t\tactions = getPortletMimeTypeActions(name);\n\n\t\t\t\tif (!name.equals(PortletKeys.PORTAL)) {\n\t\t\t\t\tcheckPortletActions(actions);\n\t\t\t\t}\n\n\t\t\t\tList<String> communityDefaultActions =\n\t\t\t\t\t_portletResourceCommunityDefaultActions.get(name);\n\n\t\t\t\tif (communityDefaultActions == null) {\n\t\t\t\t\tcommunityDefaultActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceCommunityDefaultActions.put(\n\t\t\t\t\t\tname, communityDefaultActions);\n\n\t\t\t\t\tcheckPortletCommunityDefaultActions(\n\t\t\t\t\t\tcommunityDefaultActions);\n\t\t\t\t}\n\n\t\t\t\tList<String> guestDefaultActions =\n\t\t\t\t\t_portletResourceGuestDefaultActions.get(name);\n\n\t\t\t\tif (guestDefaultActions == null) {\n\t\t\t\t\tguestDefaultActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceGuestDefaultActions.put(\n\t\t\t\t\t\tname, guestDefaultActions);\n\n\t\t\t\t\tcheckPortletGuestDefaultActions(guestDefaultActions);\n\t\t\t\t}\n\n\t\t\t\tList<String> layoutManagerActions =\n\t\t\t\t\t_portletResourceLayoutManagerActions.get(name);\n\n\t\t\t\tif (layoutManagerActions == null) {\n\t\t\t\t\tlayoutManagerActions = new UniqueList<String>();\n\n\t\t\t\t\t_portletResourceLayoutManagerActions.put(\n\t\t\t\t\t\tname, layoutManagerActions);\n\n\t\t\t\t\tcheckPortletLayoutManagerActions(layoutManagerActions);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn actions;\n\t}","commit_id":"45478c142556b0210ef2f30c300908a1f3b0ab56","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void runPrimary() {\n        m_timestamp = System.currentTimeMillis();\n        m_addr = ByteBuffer.wrap(m_coordIp.getAddress()).getInt();\n        ByteBuffer instanceIdBuffer = ByteBuffer.allocate(12);\n        instanceIdBuffer.putLong(m_timestamp);\n        instanceIdBuffer.put(m_coordIp.getAddress());\n        instanceIdBuffer.flip();\n        SocketChannel socket = null;\n        DataInputStream in = null;\n        DataOutputStream out = null;\n        int nextHostId = 1;\n\n        LOG.debug(\"Starting Coordinator\");\n\n        try {\n            while (m_sockets.size() < (m_expectedHosts - 1)) {\n                socket = m_listenerSocket.accept();\n                socket.socket().setTcpNoDelay(true);\n                socket.socket().setPerformancePreferences(0, 2, 1);\n\n                m_sockets.put(nextHostId, socket);\n\n                out = getOutputForHost(nextHostId);\n                out.writeInt(nextHostId);\n                out.write(instanceIdBuffer.array());\n                out.flush();\n                in = getInputForHost(nextHostId);\n                int response = in.readInt();\n                assert response == RESPONSE_LISTENING;\n                nextHostId++;\n            }\n\n            for (int listenId = 1; listenId < m_expectedHosts; listenId++) {\n                for (int connectId = listenId + 1; connectId < m_expectedHosts; connectId++) {\n\n                    out = getOutputForHost(listenId);\n                    out.writeInt(COMMAND_LISTEN);\n                    out.writeInt(connectId);\n                    out.flush();\n\n                    out = getOutputForHost(connectId);\n                    out.writeInt(COMMAND_CONNECT);\n                    out.writeInt(listenId);\n                    socket = m_sockets.get(listenId);\n                    // write the socket as bytes\n                    InetAddress ip = socket.socket().getInetAddress();\n                    byte[] ipBytes = ip.getAddress();\n                    out.writeInt(ipBytes.length);\n                    out.write(ipBytes);\n                    out.flush();\n\n                    in = getInputForHost(listenId);\n                    int response = in.readInt();\n                    assert response == RESPONSE_CONNECTED;\n                }\n            }\n\n            long difftimes[] = new long[m_expectedHosts - 1];\n            long othercrcs[] = new long[m_expectedHosts - 1];\n\n            // ask each connection to send it's time and catalog CRC\n            for (int hostId = 1; hostId < m_expectedHosts; hostId++) {\n                out = getOutputForHost(hostId);\n                in = getInputForHost(hostId);\n\n                out.writeInt(COMMAND_SENDTIME_AND_CRC);\n                out.flush();\n                long timestamp = in.readLong();\n                difftimes[hostId - 1] = System.currentTimeMillis() - timestamp;\n                othercrcs[hostId - 1] = in.readLong();\n            }\n\n            // figure out how bad the skew is and if it's acceptable\n            int command = COMMAND_COMPLETE;\n            long minimumDiff = 0;\n            long maximumDiff = 0;\n            for (long diff : difftimes) {\n                if (diff > maximumDiff)\n                    maximumDiff = diff;\n                if (diff < minimumDiff)\n                    minimumDiff = diff;\n            }\n            long maxDiffMS = maximumDiff - minimumDiff;\n            if (maxDiffMS > MAX_ACCEPTABLE_TIME_DIFF_IN_MS)\n                command = COMMAND_NTPFAIL;\n\n            // figure out if any catalogs are not identical\n            for (long crc : othercrcs) {\n                if (crc != m_catalogCRC) {\n                    command = COMMAND_CRCFAIL;\n                }\n            }\n\n            for (int hostId = 1; hostId < m_expectedHosts; hostId++) {\n                out = getOutputForHost(hostId);\n                out.writeLong(maxDiffMS);\n                out.writeInt(command);\n                out.flush();\n            }\n\n            if (m_hostLog != null)\n                m_hostLog.info(\"Maximum clock/network skew is \" + maxDiffMS + \" milliseconds (according to leader)\");\n            if (command == COMMAND_NTPFAIL) {\n                if (m_hostLog != null)\n                    m_hostLog.error(\"Maximum clock/network is \" + (maxDiffMS*100)/MAX_ACCEPTABLE_TIME_DIFF_IN_MS +\n                                   \"% higher than allowable limit\");\n                VoltDB.crashVoltDB();\n            }\n            if (command == COMMAND_CRCFAIL) {\n                if (m_hostLog != null)\n                    m_hostLog.error(\"Catalog checksums do not match across cluster\");\n                VoltDB.crashVoltDB();\n            }\n\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n        finally {\n            try {\n                m_listenerSocket.close();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }","id":97832,"modified_method":"private void runPrimary() {\n        m_timestamp = System.currentTimeMillis();\n        m_addr = ByteBuffer.wrap(m_coordIp.getAddress()).getInt();\n        ByteBuffer instanceIdBuffer = ByteBuffer.allocate(12);\n        instanceIdBuffer.putLong(m_timestamp);\n        instanceIdBuffer.put(m_coordIp.getAddress());\n        instanceIdBuffer.flip();\n        SocketChannel socket = null;\n        DataInputStream in = null;\n        DataOutputStream out = null;\n        int nextHostId = 1;\n\n        LOG.debug(\"Starting Coordinator\");\n\n        try {\n            while (m_sockets.size() < (m_expectedHosts - 1)) {\n                socket = m_listenerSocket.accept();\n                socket.socket().setTcpNoDelay(true);\n                socket.socket().setPerformancePreferences(0, 2, 1);\n\n                m_sockets.put(nextHostId, socket);\n\n                out = getOutputForHost(nextHostId);\n                out.writeInt(nextHostId);\n                out.write(instanceIdBuffer.array());\n                out.flush();\n                in = getInputForHost(nextHostId);\n                int response = in.readInt();\n                assert response == RESPONSE_LISTENING;\n                nextHostId++;\n            }\n\n            for (int listenId = 1; listenId < m_expectedHosts; listenId++) {\n                for (int connectId = listenId + 1; connectId < m_expectedHosts; connectId++) {\n\n                    out = getOutputForHost(listenId);\n                    out.writeInt(COMMAND_LISTEN);\n                    out.writeInt(connectId);\n                    out.flush();\n\n                    out = getOutputForHost(connectId);\n                    out.writeInt(COMMAND_CONNECT);\n                    out.writeInt(listenId);\n                    socket = m_sockets.get(listenId);\n                    // write the socket as bytes\n                    InetAddress ip = socket.socket().getInetAddress();\n                    byte[] ipBytes = ip.getAddress();\n                    out.writeInt(ipBytes.length);\n                    out.write(ipBytes);\n                    out.flush();\n\n                    in = getInputForHost(listenId);\n                    int response = in.readInt();\n                    assert response == RESPONSE_CONNECTED;\n                }\n            }\n\n            long difftimes[] = new long[m_expectedHosts - 1];\n            long othercrcs[] = new long[m_expectedHosts - 1];\n\n            // ask each connection to send it's time and catalog CRC\n            for (int hostId = 1; hostId < m_expectedHosts; hostId++) {\n                out = getOutputForHost(hostId);\n                in = getInputForHost(hostId);\n\n                out.writeInt(COMMAND_SENDTIME_AND_CRC);\n                out.flush();\n                long timestamp = in.readLong();\n                difftimes[hostId - 1] = System.currentTimeMillis() - timestamp;\n                othercrcs[hostId - 1] = in.readLong();\n            }\n\n            // figure out how bad the skew is and if it's acceptable\n            long minimumDiff = 0;\n            long maximumDiff = 0;\n            for (long diff : difftimes) {\n                if (diff > maximumDiff)\n                    maximumDiff = diff;\n                if (diff < minimumDiff)\n                    minimumDiff = diff;\n            }\n\n            int errors = 0;\n\n            long maxDiffMS = maximumDiff - minimumDiff;\n            if (maxDiffMS > MAX_ACCEPTABLE_TIME_DIFF_IN_MS)\n                errors |= NTP_FAILURE;\n\n            // figure out if any catalogs are not identical\n            for (long crc : othercrcs) {\n                if (crc != m_catalogCRC) {\n                    errors |= CRC_FAILURE;\n                }\n            }\n\n            for (int hostId = 1; hostId < m_expectedHosts; hostId++) {\n                out = getOutputForHost(hostId);\n                out.writeLong(maxDiffMS);\n                if (errors == 0) {\n                    out.writeInt(COMMAND_COMPLETE);\n                }\n                else {\n                    out.writeInt(COMMAND_JOINFAIL);\n                    out.writeInt(errors);\n                }\n                out.flush();\n            }\n\n            if (m_hostLog != null)\n                m_hostLog.info(\"Maximum clock/network skew is \" + maxDiffMS + \" milliseconds (according to leader)\");\n            if ((errors & NTP_FAILURE) != 0) {\n                if (m_hostLog != null)\n                    m_hostLog.error(\"Maximum clock/network is \" + (maxDiffMS*100)/MAX_ACCEPTABLE_TIME_DIFF_IN_MS +\n                                   \"% higher than allowable limit\");\n            }\n            if ((errors & CRC_FAILURE) != 0) {\n                if (m_hostLog != null)\n                    m_hostLog.error(\"Catalog checksums do not match across cluster\");\n            }\n            if (errors != 0) {\n                VoltDB.crashVoltDB();\n            }\n\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n        finally {\n            try {\n                m_listenerSocket.close();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }","commit_id":"196219eb771cf35a6f409d497e9c98b2aabf5c82","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void runNonPrimary() {\n        SocketChannel socket = null;\n        DataInputStream in = null;\n        DataOutputStream out = null;\n        try {\n            LOG.debug(\"Non-Primary Starting\");\n            LOG.debug(\"Non-Primary Connecting to Primary\");\n\n            InetSocketAddress inetsockaddr = new InetSocketAddress(m_coordIp, m_internalPort);\n\n            while (socket == null) {\n                try {\n                    socket = SocketChannel.open(inetsockaddr);\n                }\n                catch (java.net.ConnectException e) {\n                    LOG.warn(\"Joining primary failed: \" + e.getMessage() + \" retrying..\");\n                    try {\n                        sleep(250); //  milliseconds\n                    }\n                    catch (InterruptedException ex) {\n                        // don't really care.\n                    }\n                }\n            }\n            socket.socket().setTcpNoDelay(true);\n            socket.socket().setPerformancePreferences(0, 2, 1);\n            in = addToInputs(COORD_HOSTID, socket.socket().getInputStream());\n\n            // send the local hostid out\n            LOG.debug(\"Non-Primary Reading its Host ID\");\n            m_localHostId = in.readInt();\n            byte instanceIdBytes[] = new byte[12];\n            in.read(instanceIdBytes);\n            ByteBuffer instanceId = ByteBuffer.wrap(instanceIdBytes);\n            m_timestamp = instanceId.getLong();\n            m_addr = instanceId.getInt();\n            m_sockets.put(COORD_HOSTID, socket);\n\n            // start the server socket on the right interface\n            LOG.debug(\"Non-Primary Creating its Listener Socket\");\n            m_listenerSocket = ServerSocketChannel.open();\n\n            if ((m_internalInterface == null) || (m_internalInterface.length() == 0)) {\n                inetsockaddr = new InetSocketAddress(m_internalPort + m_localHostId);\n            }\n            else {\n                inetsockaddr = new InetSocketAddress(m_internalInterface, m_internalPort + m_localHostId);\n            }\n            m_listenerSocket.socket().bind(inetsockaddr);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Non-Primary Listening on port:\" + (m_internalPort + m_localHostId));\n            }\n\n            out = getOutputForHost(COORD_HOSTID);\n\n            out.writeInt(RESPONSE_LISTENING);\n            out.flush();\n\n            LOG.debug(\"Non-Primary Fetching Instructions\");\n            int command = COMMAND_NONE;\n            while (command != COMMAND_SENDTIME_AND_CRC) {\n                command = in.readInt();\n                if ((command != COMMAND_CONNECT) && (command != COMMAND_LISTEN)) {\n                    continue;\n                }\n\n                int hostId = in.readInt();\n                SocketChannel newSock = null;\n\n                if (command == COMMAND_CONNECT) {\n                    LOG.debug(\"Non-Primary Connect Request\");\n                    // read an ip address from bytes\n                    int ipSize = in.readInt();\n                    byte[] ipBytes = new byte[ipSize];\n                    in.readFully(ipBytes);\n                    InetAddress ip = InetAddress.getByAddress(ipBytes);\n                    LOG.debug(\"Opening non-primary socket: \" + ip.toString());\n                    inetsockaddr = new InetSocketAddress(ip, m_internalPort + hostId);\n                    newSock = SocketChannel.open(inetsockaddr);\n                }\n                if (command == COMMAND_LISTEN) {\n                    LOG.debug(\"Non-Primary Listen Request\");\n                    newSock = m_listenerSocket.accept();\n                }\n                newSock.socket().setTcpNoDelay(true);\n                newSock.socket().setPerformancePreferences(0, 2, 1);\n\n                m_sockets.put(hostId, newSock);\n                DataOutputStream out1 = getOutputForHost(hostId);\n                out1.writeInt(PING);\n                out1.flush();\n                DataInputStream in1 = getInputForHost(hostId);\n                int pingValue = in1.readInt();\n                assert pingValue == PING;\n\n                if (command == COMMAND_LISTEN) {\n                    out.writeInt(RESPONSE_CONNECTED);\n                    out.flush();\n                }\n\n                LOG.debug(\"Non-Primary Fetching Instructions\");\n            }\n\n            // write the current time\n            out.writeLong(System.currentTimeMillis());\n            // write the local catalog crc\n            out.writeLong(m_catalogCRC);\n            out.flush();\n            long maxDiffMS = in.readLong();\n            if (m_hostLog != null)\n                m_hostLog.info(\"Maximum clock/network skew is \" + maxDiffMS + \" milliseconds (according to leader)\");\n            command = in.readInt();\n            if (command == COMMAND_NTPFAIL) {\n                if (m_hostLog != null)\n                    m_hostLog.error(\"Maximum clock/network is \" + (maxDiffMS*100)/MAX_ACCEPTABLE_TIME_DIFF_IN_MS +\n                                   \"% higher than allowable limit\");\n                VoltDB.crashVoltDB();\n            }\n            if (command == COMMAND_CRCFAIL) {\n                if (m_hostLog != null)\n                    m_hostLog.error(\"Catalog checksums do not match across cluster\");\n                VoltDB.crashVoltDB();\n                for (SocketChannel sock : m_sockets.values()) {\n                    sock.close();\n                }\n                return;\n            }\n            assert(command == COMMAND_COMPLETE);\n        }\n        catch (IOException e) {\n            m_hostLog.error(\"Failed to establish socket mesh.\", e);\n            throw new RuntimeException(e);\n        }\n        finally {\n            if (m_listenerSocket != null) {\n                try {\n                    m_listenerSocket.close();\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            LOG.debug(\"Non-Primary Done\");\n        }\n    }","id":97833,"modified_method":"private void runNonPrimary() {\n        SocketChannel socket = null;\n        DataInputStream in = null;\n        DataOutputStream out = null;\n        try {\n            LOG.debug(\"Non-Primary Starting\");\n            LOG.debug(\"Non-Primary Connecting to Primary\");\n\n            InetSocketAddress inetsockaddr = new InetSocketAddress(m_coordIp, m_internalPort);\n\n            while (socket == null) {\n                try {\n                    socket = SocketChannel.open(inetsockaddr);\n                }\n                catch (java.net.ConnectException e) {\n                    LOG.warn(\"Joining primary failed: \" + e.getMessage() + \" retrying..\");\n                    try {\n                        sleep(250); //  milliseconds\n                    }\n                    catch (InterruptedException ex) {\n                        // don't really care.\n                    }\n                }\n            }\n            socket.socket().setTcpNoDelay(true);\n            socket.socket().setPerformancePreferences(0, 2, 1);\n            in = addToInputs(COORD_HOSTID, socket.socket().getInputStream());\n\n            // send the local hostid out\n            LOG.debug(\"Non-Primary Reading its Host ID\");\n            m_localHostId = in.readInt();\n            byte instanceIdBytes[] = new byte[12];\n            in.read(instanceIdBytes);\n            ByteBuffer instanceId = ByteBuffer.wrap(instanceIdBytes);\n            m_timestamp = instanceId.getLong();\n            m_addr = instanceId.getInt();\n            m_sockets.put(COORD_HOSTID, socket);\n\n            // start the server socket on the right interface\n            LOG.debug(\"Non-Primary Creating its Listener Socket\");\n            m_listenerSocket = ServerSocketChannel.open();\n\n            if ((m_internalInterface == null) || (m_internalInterface.length() == 0)) {\n                inetsockaddr = new InetSocketAddress(m_internalPort + m_localHostId);\n            }\n            else {\n                inetsockaddr = new InetSocketAddress(m_internalInterface, m_internalPort + m_localHostId);\n            }\n            m_listenerSocket.socket().bind(inetsockaddr);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Non-Primary Listening on port:\" + (m_internalPort + m_localHostId));\n            }\n\n            out = getOutputForHost(COORD_HOSTID);\n\n            out.writeInt(RESPONSE_LISTENING);\n            out.flush();\n\n            LOG.debug(\"Non-Primary Fetching Instructions\");\n            int command = COMMAND_NONE;\n            while (command != COMMAND_SENDTIME_AND_CRC) {\n                command = in.readInt();\n                if ((command != COMMAND_CONNECT) && (command != COMMAND_LISTEN)) {\n                    continue;\n                }\n\n                int hostId = in.readInt();\n                SocketChannel newSock = null;\n\n                if (command == COMMAND_CONNECT) {\n                    LOG.debug(\"Non-Primary Connect Request\");\n                    // read an ip address from bytes\n                    int ipSize = in.readInt();\n                    byte[] ipBytes = new byte[ipSize];\n                    in.readFully(ipBytes);\n                    InetAddress ip = InetAddress.getByAddress(ipBytes);\n                    LOG.debug(\"Opening non-primary socket: \" + ip.toString());\n                    inetsockaddr = new InetSocketAddress(ip, m_internalPort + hostId);\n                    newSock = SocketChannel.open(inetsockaddr);\n                }\n                if (command == COMMAND_LISTEN) {\n                    LOG.debug(\"Non-Primary Listen Request\");\n                    newSock = m_listenerSocket.accept();\n                }\n                newSock.socket().setTcpNoDelay(true);\n                newSock.socket().setPerformancePreferences(0, 2, 1);\n\n                m_sockets.put(hostId, newSock);\n                DataOutputStream out1 = getOutputForHost(hostId);\n                out1.writeInt(PING);\n                out1.flush();\n                DataInputStream in1 = getInputForHost(hostId);\n                int pingValue = in1.readInt();\n                assert pingValue == PING;\n\n                if (command == COMMAND_LISTEN) {\n                    out.writeInt(RESPONSE_CONNECTED);\n                    out.flush();\n                }\n\n                LOG.debug(\"Non-Primary Fetching Instructions\");\n            }\n\n            // write the current time\n            out.writeLong(System.currentTimeMillis());\n            // write the local catalog crc\n            out.writeLong(m_catalogCRC);\n            out.flush();\n            long maxDiffMS = in.readLong();\n            if (m_hostLog != null)\n                m_hostLog.info(\"Maximum clock/network skew is \" + maxDiffMS + \" milliseconds (according to leader)\");\n            command = in.readInt();\n            if (command == COMMAND_JOINFAIL) {\n                int errors = in.readInt();\n\n                if ((errors & NTP_FAILURE) != 0) {\n                    if (m_hostLog != null)\n                        m_hostLog.error(\"Maximum clock/network is \" + (maxDiffMS*100)/MAX_ACCEPTABLE_TIME_DIFF_IN_MS +\n                                       \"% higher than allowable limit\");\n                }\n                if ((errors & CRC_FAILURE) != 0) {\n                    if (m_hostLog != null)\n                        m_hostLog.error(\"Catalog checksums do not match across cluster\");\n                }\n                VoltDB.crashVoltDB();\n            }\n            assert(command == COMMAND_COMPLETE);\n        }\n        catch (IOException e) {\n            m_hostLog.error(\"Failed to establish socket mesh.\", e);\n            throw new RuntimeException(e);\n        }\n        finally {\n            if (m_listenerSocket != null) {\n                try {\n                    m_listenerSocket.close();\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            LOG.debug(\"Non-Primary Done\");\n        }\n    }","commit_id":"196219eb771cf35a6f409d497e9c98b2aabf5c82","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * @return Catalog version number.\n     */\n    private void runJoinExisting() {\n        SocketChannel socket = null;\n        DataInputStream in = null;\n        DataOutputStream out = null;\n\n        LOG.debug(\"Starting Coordinator\");\n\n        try {\n            HashSet<Integer> hostsFound = null;\n            while (m_sockets.size() < (m_expectedHosts - 1)) {\n                socket = m_listenerSocket.accept();\n                socket.socket().setTcpNoDelay(true);\n                socket.socket().setPerformancePreferences(0, 2, 1);\n\n                InputStream s = socket.socket().getInputStream();\n                in = new DataInputStream(new BufferedInputStream(s));\n                int hostId = in.readInt();\n                m_timestamp = in.readLong();\n                m_addr = in.readInt();\n                int numHosts = in.readInt();\n                HashSet<Integer> hosts = new HashSet<Integer>(numHosts);\n                for (int ii = 0; ii < numHosts; ii++) {\n                    hosts.add(in.readInt());\n                }\n                if (hostsFound == null) {\n                    hostsFound = hosts;\n                    m_expectedHosts = hostsFound.size() + 1;\n                    System.out.println(hostsFound.toString());\n                } else if (!hostsFound.equals(hosts)) {\n                    recoveryLog.fatal(\"Inconsistent live host set during rejoin\");\n                    VoltDB.crashVoltDB();\n                }\n                m_sockets.put(hostId, socket);\n                recoveryLog.info(\"Have \" + m_sockets.size() + \" of \" + (m_expectedHosts - 1) + \" with hostId \" + hostId);\n            }\n\n            // read the timestamps from all\n\n            long difftimes[] = new long[m_expectedHosts - 1];\n            int readHostIds[] = new int[m_expectedHosts - 1];\n            long othercrcs[] = new long[m_expectedHosts - 1];\n            int catalogVersions[] = new int[m_expectedHosts - 1];\n            for (Entry<Integer, SocketChannel> e : m_sockets.entrySet()) {\n                out = getOutputForHost(e.getKey());\n\n                out.writeInt(COMMAND_SENDTIME_AND_CRC);\n                out.flush();\n\n            }\n            int i = 0;\n            for (Entry<Integer, SocketChannel> e : m_sockets.entrySet()) {\n                in = getInputForHost(e.getKey());\n\n                readHostIds[i] = in.readInt();\n                othercrcs[i] = in.readLong();\n                long timestamp = in.readLong();\n                difftimes[i] = System.currentTimeMillis() - timestamp;\n                catalogVersions[i] = in.readInt();\n                i++;\n            }\n\n            // figure out how bad the skew is and if it's acceptable\n            int command = COMMAND_COMPLETE;\n            long minimumDiff = 0;\n            long maximumDiff = 0;\n            for (long diff : difftimes) {\n                if (diff > maximumDiff)\n                    maximumDiff = diff;\n                if (diff < minimumDiff)\n                    minimumDiff = diff;\n            }\n            long maxDiffMS = maximumDiff - minimumDiff;\n            if (maxDiffMS > MAX_ACCEPTABLE_TIME_DIFF_IN_MS)\n                command = COMMAND_NTPFAIL;\n\n            // ensure all hostids are the same\n            m_localHostId = readHostIds[0];\n            recoveryLog.info(\"Selecting host id \" + m_localHostId);\n            for (i = 1; i < readHostIds.length; i++) {\n                if (readHostIds[i] != m_localHostId) {\n                    command = COMMAND_HOSTIDFAIL;\n                }\n            }\n\n            // figure out if any catalogs are not identical\n            for (long crc : othercrcs) {\n                if (crc != m_catalogCRC) {\n                    command = COMMAND_CRCFAIL;\n                }\n            }\n\n            // ensure all catalog versions are the same\n            m_discoveredCatalogVersion = catalogVersions[0];\n            for (int version : catalogVersions) {\n                if (version != m_discoveredCatalogVersion) {\n                    command = COMMAND_CATVERFAIL;\n                }\n            }\n\n            for (Entry<Integer, SocketChannel> e : m_sockets.entrySet()) {\n                out = getOutputForHost(e.getKey());\n                out.writeLong(maxDiffMS);\n                out.writeInt(command);\n                out.flush();\n            }\n\n            if (m_hostLog != null)\n                m_hostLog.info(\"Maximum clock/network skew is \" + maxDiffMS + \" milliseconds (according to rejoined node)\");\n            if (command == COMMAND_NTPFAIL) {\n                if (m_hostLog != null)\n                    m_hostLog.error(\"Maximum clock/network is \" + (maxDiffMS*100)/MAX_ACCEPTABLE_TIME_DIFF_IN_MS +\n                                   \"% higher than allowable limit\");\n                VoltDB.crashVoltDB();\n            }\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n        finally {\n            try {\n                m_listenerSocket.close();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }","id":97834,"modified_method":"/**\n     * @return Catalog version number.\n     */\n    private void runJoinExisting() {\n        SocketChannel socket = null;\n        DataInputStream in = null;\n        DataOutputStream out = null;\n\n        LOG.debug(\"Starting Coordinator\");\n\n        try {\n            HashSet<Integer> hostsFound = null;\n            while (m_sockets.size() < (m_expectedHosts - 1)) {\n                socket = m_listenerSocket.accept();\n                socket.socket().setTcpNoDelay(true);\n                socket.socket().setPerformancePreferences(0, 2, 1);\n\n                InputStream s = socket.socket().getInputStream();\n                in = new DataInputStream(new BufferedInputStream(s));\n                int hostId = in.readInt();\n                m_timestamp = in.readLong();\n                m_addr = in.readInt();\n                int numHosts = in.readInt();\n                HashSet<Integer> hosts = new HashSet<Integer>(numHosts);\n                for (int ii = 0; ii < numHosts; ii++) {\n                    hosts.add(in.readInt());\n                }\n                if (hostsFound == null) {\n                    hostsFound = hosts;\n                    m_expectedHosts = hostsFound.size() + 1;\n                    System.out.println(hostsFound.toString());\n                } else if (!hostsFound.equals(hosts)) {\n                    recoveryLog.fatal(\"Inconsistent live host set during rejoin\");\n                    VoltDB.crashVoltDB();\n                }\n                m_sockets.put(hostId, socket);\n                recoveryLog.info(\"Have \" + m_sockets.size() + \" of \" + (m_expectedHosts - 1) + \" with hostId \" + hostId);\n            }\n\n            // read the timestamps from all\n\n            long difftimes[] = new long[m_expectedHosts - 1];\n            int readHostIds[] = new int[m_expectedHosts - 1];\n            long othercrcs[] = new long[m_expectedHosts - 1];\n            int catalogVersions[] = new int[m_expectedHosts - 1];\n            for (Entry<Integer, SocketChannel> e : m_sockets.entrySet()) {\n                out = getOutputForHost(e.getKey());\n\n                out.writeInt(COMMAND_SENDTIME_AND_CRC);\n                out.flush();\n\n            }\n            int i = 0;\n            for (Entry<Integer, SocketChannel> e : m_sockets.entrySet()) {\n                in = getInputForHost(e.getKey());\n\n                readHostIds[i] = in.readInt();\n                othercrcs[i] = in.readLong();\n                long timestamp = in.readLong();\n                difftimes[i] = System.currentTimeMillis() - timestamp;\n                catalogVersions[i] = in.readInt();\n                i++;\n            }\n\n            int errors = 0;\n\n            // figure out how bad the skew is and if it's acceptable\n            long minimumDiff = 0;\n            long maximumDiff = 0;\n            for (long diff : difftimes) {\n                if (diff > maximumDiff)\n                    maximumDiff = diff;\n                if (diff < minimumDiff)\n                    minimumDiff = diff;\n            }\n            long maxDiffMS = maximumDiff - minimumDiff;\n            if (maxDiffMS > MAX_ACCEPTABLE_TIME_DIFF_IN_MS)\n                errors |= NTP_FAILURE;\n\n            // ensure all hostids are the same\n            m_localHostId = readHostIds[0];\n            recoveryLog.info(\"Selecting host id \" + m_localHostId);\n            for (i = 1; i < readHostIds.length; i++) {\n                if (readHostIds[i] != m_localHostId) {\n                    errors |= HOSTID_FAILURE;\n                }\n            }\n\n            // figure out if any catalogs are not identical\n            for (long crc : othercrcs) {\n                if (crc != m_catalogCRC) {\n                    errors |= CRC_FAILURE;\n                }\n            }\n\n            // ensure all catalog versions are the same\n            m_discoveredCatalogVersion = catalogVersions[0];\n            for (int version : catalogVersions) {\n                if (version != m_discoveredCatalogVersion) {\n                    errors |= CATVER_FAILURE;\n                }\n            }\n\n            for (Entry<Integer, SocketChannel> e : m_sockets.entrySet()) {\n                out = getOutputForHost(e.getKey());\n                out.writeLong(maxDiffMS);\n                if (errors == 0) {\n                    out.writeInt(COMMAND_COMPLETE);\n                }\n                else {\n                    out.writeInt(COMMAND_JOINFAIL);\n                    out.writeInt(errors);\n                }\n                out.flush();\n            }\n\n            if (m_hostLog != null)\n                m_hostLog.info(\"Maximum clock/network skew is \" + maxDiffMS + \" milliseconds (according to rejoined node)\");\n            if ((errors & NTP_FAILURE) != 0) {\n                if (m_hostLog != null)\n                    m_hostLog.error(\"Maximum clock/network is \" + (maxDiffMS*100)/MAX_ACCEPTABLE_TIME_DIFF_IN_MS +\n                                   \"% higher than allowable limit\");\n            }\n            if ((errors & CRC_FAILURE) != 0) {\n                if (m_hostLog != null)\n                    m_hostLog.error(\"Catalog checksums do not match across cluster\");\n            }\n            if ((errors & HOSTID_FAILURE) != 0) {\n                if (m_hostLog != null) {\n                    m_hostLog.error(\"Cluster nodes didn't agree on a host id for the rejoining node.\");\n                    m_hostLog.error(\"This is likely a bug in VoltDB and you should contact the VoltDB team.\");\n                }\n            }\n            if ((errors & CATVER_FAILURE) != 0) {\n                if (m_hostLog != null) {\n                    m_hostLog.error(\"Cluster nodes didn't agree on all catalog metadata.\");\n                    m_hostLog.error(\"This is likely a bug in VoltDB and you should contact the VoltDB team.\");\n                }\n            }\n            if (errors != 0) {\n                VoltDB.crashVoltDB();\n            }\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n        finally {\n            try {\n                m_listenerSocket.close();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }","commit_id":"196219eb771cf35a6f409d497e9c98b2aabf5c82","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Helper method for the rejoin process. This is called by nodes inside the cluster\n     * to initiate a connection to nodes re-joining the cluster.\n     *\n     * @param hostId The calling node's host id.\n     * @param address The address the re-joining node is listening on.\n     * @return A connected SocketChannel to the re-joining node, or null on failure.\n     * @throws Exception\n     */\n    static SocketChannel connect(\n            int localHostId,\n            int rejoiningHostId,\n            InetSocketAddress address,\n            long catalogCRC,\n            HashSet<Integer> liveHosts,\n            int catalogVersionNumber) throws Exception {\n        SocketChannel remoteConnection = null;\n        try {\n            // open a connection to the re-joining node\n            remoteConnection = SocketChannel.open(address);\n            remoteConnection.socket().setSoTimeout(1000);\n\n            // create helper streams for IO\n            DataOutputStream out = new DataOutputStream(new BufferedOutputStream(remoteConnection.socket().getOutputStream()));\n            DataInputStream in = new DataInputStream(new BufferedInputStream(remoteConnection.socket().getInputStream()));\n\n            // write the id of this host\n            out.writeInt(localHostId);\n            Object instanceId[] = VoltDB.instance().getInstanceId();\n            out.writeLong((Long)instanceId[0]);\n            out.writeInt((Integer)instanceId[1]);\n            out.writeInt(liveHosts.size());\n            for (Integer site : liveHosts) {\n                out.writeInt(site);\n            }\n            out.flush();\n\n            // read in the command to acknowledge connection and to request the time\n            int command = in.readInt();\n            if (command != COMMAND_SENDTIME_AND_CRC)\n                throw new Exception(String.format(\"Unexpected command (%d) from joining node.\", command));\n\n            // write the id of the new host\n            out.writeInt(rejoiningHostId);\n\n            // write catalog crc\n            out.writeLong(catalogCRC);\n\n            // write the current time so the re-join node can measure skew\n            out.writeLong(System.currentTimeMillis());\n\n            // write catalog version number\n            out.writeInt(catalogVersionNumber);\n\n            // flush these 3 writes\n            out.flush();\n\n            // read the confirmation command\n            long maxDiffMS = in.readLong();\n            System.out.printf(\"Re-joining node reports %d ms skew.\\n\", maxDiffMS);\n            command = in.readInt();\n            if (command == COMMAND_COMPLETE)\n                return remoteConnection;\n            else {\n                String msg = String.format(\"Unable to re-join node. Error No. %d.\", command);\n                throw new Exception(msg);\n            }\n        }\n        catch (Exception e) {\n            //e.printStackTrace();\n            String emesg = e.getMessage();\n            if (emesg == null) {\n                emesg = e.getClass().getName();\n            }\n            String msg = String.format(\"Unable to re-join node. Socket failure with message: \" + emesg);\n            throw new Exception(msg);\n        }\n    }","id":97835,"modified_method":"/**\n     * Helper method for the rejoin process. This is called by nodes inside the cluster\n     * to initiate a connection to nodes re-joining the cluster.\n     *\n     * @param hostId The calling node's host id.\n     * @param address The address the re-joining node is listening on.\n     * @return A connected SocketChannel to the re-joining node, or null on failure.\n     * @throws Exception\n     */\n    static SocketChannel connect(\n            int localHostId,\n            int rejoiningHostId,\n            InetSocketAddress address,\n            long catalogCRC,\n            HashSet<Integer> liveHosts,\n            int catalogVersionNumber) throws Exception {\n        SocketChannel remoteConnection = null;\n        try {\n            // open a connection to the re-joining node\n            remoteConnection = SocketChannel.open(address);\n            remoteConnection.socket().setSoTimeout(1000);\n\n            // create helper streams for IO\n            DataOutputStream out = new DataOutputStream(new BufferedOutputStream(remoteConnection.socket().getOutputStream()));\n            DataInputStream in = new DataInputStream(new BufferedInputStream(remoteConnection.socket().getInputStream()));\n\n            // write the id of this host\n            out.writeInt(localHostId);\n            Object instanceId[] = VoltDB.instance().getInstanceId();\n            out.writeLong((Long)instanceId[0]);\n            out.writeInt((Integer)instanceId[1]);\n            out.writeInt(liveHosts.size());\n            for (Integer site : liveHosts) {\n                out.writeInt(site);\n            }\n            out.flush();\n\n            // read in the command to acknowledge connection and to request the time\n            int command = in.readInt();\n            if (command != COMMAND_SENDTIME_AND_CRC)\n                throw new Exception(String.format(\"Unexpected command (%d) from joining node.\", command));\n\n            // write the id of the new host\n            out.writeInt(rejoiningHostId);\n\n            // write catalog crc\n            out.writeLong(catalogCRC);\n\n            // write the current time so the re-join node can measure skew\n            out.writeLong(System.currentTimeMillis());\n\n            // write catalog version number\n            out.writeInt(catalogVersionNumber);\n\n            // flush these 3 writes\n            out.flush();\n\n            // read the confirmation command\n            long maxDiffMS = in.readLong();\n            System.out.printf(\"Re-joining node reports %d ms skew.\\n\", maxDiffMS);\n            command = in.readInt();\n            if (command == COMMAND_COMPLETE)\n                return remoteConnection;\n            else {\n                int errors = in.readInt();\n                String msg = \"\";\n\n                if ((errors & NTP_FAILURE) != 0) {\n                    msg += String.format(\"Maximum clock/network is \" + (maxDiffMS*100)/MAX_ACCEPTABLE_TIME_DIFF_IN_MS +\n                                       \"% higher than allowable limit.\\n\");\n                }\n                if ((errors & CRC_FAILURE) != 0) {\n                    msg += String.format(\"Catalog checksums do not match across cluster.\\n\");\n                }\n                if ((errors & HOSTID_FAILURE) != 0) {\n                    msg += String.format(\"Cluster nodes didn't agree on a host id for the rejoining node.\\n\");\n                    msg += String.format(\"This is likely a bug in VoltDB and you should contact the VoltDB team.\\n\");\n                }\n                if ((errors & CATVER_FAILURE) != 0) {\n                    msg += String.format(\"Cluster nodes didn't agree on all catalog metadata.\\n\");\n                    msg += String.format(\"This is likely a bug in VoltDB and you should contact the VoltDB team.\\n\");\n                }\n                throw new Exception(msg);\n            }\n        }\n        catch (Exception e) {\n            //e.printStackTrace();\n            String emesg = e.getMessage();\n            if (emesg == null) {\n                emesg = e.getClass().getName();\n            }\n            String msg = String.format(\"Unable to re-join node. Socket failure with message: \" + emesg);\n            throw new Exception(msg);\n        }\n    }","commit_id":"196219eb771cf35a6f409d497e9c98b2aabf5c82","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Generate a unique id that contains a timestamp, a counter\n     * and a siteid packed into a 64-bit long value. Subsequent calls\n     * to this method will return strictly larger long values.\n     * @return The newly generated transaction id.\n     */\n    public long getNextUniqueTransactionId() {\n        long currentTime = System.currentTimeMillis();\n        if (currentTime == lastUsedTime) {\n            // increment the counter for this millisecond\n            counterValue++;\n\n            // handle the case where we've run out of counter values\n            // for this particular millisecond (feels unlikely)\n            if (counterValue > COUNTER_MAX_VALUE) {\n                // spin until the next millisecond\n                while (currentTime == lastUsedTime)\n                    currentTime = System.currentTimeMillis();\n                // reset the counter and lastUsedTime for the new millisecond\n                lastUsedTime = currentTime;\n                counterValue = 0;\n            }\n        }\n        else {\n            // reset the counter and lastUsedTime for the new millisecond\n            if (currentTime < lastUsedTime) {\n                System.err.println(\"Initiator time moved backwards from: \" + lastUsedTime + \" to \" + currentTime);\n                VoltDB.crashVoltDB();\n            }\n            lastUsedTime = currentTime;\n            counterValue = 0;\n        }\n\n        lastTxnId = makeIdFromComponents(currentTime, counterValue, initiatorId);\n\n        return lastTxnId;\n    }","id":97836,"modified_method":"/**\n     * Generate a unique id that contains a timestamp, a counter\n     * and a siteid packed into a 64-bit long value. Subsequent calls\n     * to this method will return strictly larger long values.\n     * @return The newly generated transaction id.\n     */\n    public long getNextUniqueTransactionId() {\n        long currentTime = System.currentTimeMillis();\n        if (currentTime == lastUsedTime) {\n            // increment the counter for this millisecond\n            counterValue++;\n\n            // handle the case where we've run out of counter values\n            // for this particular millisecond (feels unlikely)\n            if (counterValue > COUNTER_MAX_VALUE) {\n                // spin until the next millisecond\n                while (currentTime == lastUsedTime)\n                    currentTime = System.currentTimeMillis();\n                // reset the counter and lastUsedTime for the new millisecond\n                lastUsedTime = currentTime;\n                counterValue = 0;\n            }\n        }\n        else {\n            // reset the counter and lastUsedTime for the new millisecond\n            if (currentTime < lastUsedTime) {\n                System.err.println(\"Initiator time moved backwards from: \" + lastUsedTime + \" to \" + currentTime);\n                // if the diff is less than 5 ms, wait a bit\n                if ((lastUsedTime - currentTime) < 5) {\n                    int count = 0;\n                    // note, the loop should stop once lastUsedTime is PASSED, not current\n                    while ((currentTime <= lastUsedTime) && (count++ < 100000)) {\n                        Thread.yield();\n                        currentTime = System.currentTimeMillis();\n                    }\n                    // if the loop above ended because it ran too much\n                    if (count >= 100000) {\n                        VoltDB.crashVoltDB();\n                    }\n                }\n                // crash immediately if time has gone backwards by too much\n                else {\n                    VoltDB.crashVoltDB();\n                }\n            }\n            lastUsedTime = currentTime;\n            counterValue = 0;\n        }\n\n        lastTxnId = makeIdFromComponents(currentTime, counterValue, initiatorId);\n\n        return lastTxnId;\n    }","commit_id":"86272e9e631c061e35235fb2686e3190c5a19a59","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    public void redeploysInvalidZipAppAfterSuccessfulDeploymentOnStartup() throws IOException\n    {\n        final URL fixedApp = getClass().getResource(\"/empty-app.zip\");\n        assertNotNull(\"Test app file not found \" + fixedApp, fixedApp);\n        addAppArchive(fixedApp, \"empty-app.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"empty-app\");\n\n        final URL url = getClass().getResource(\"/incompleteApp.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url, \"empty-app.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"empty-app\");\n\n        final Map.Entry<URL, Long> zombie = deploymentService.getZombieMap().entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"empty-app\", new File(zombie.getKey().getFile()).getParentFile().getName());\n    }","id":97837,"modified_method":"@Test\n    public void redeploysInvalidZipAppAfterSuccessfulDeploymentOnStartup() throws IOException\n    {\n        addPackedAppFromResource(\"/empty-app.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"empty-app\");\n\n        addPackedAppFromResource(\"/incompleteApp.zip\", \"empty-app.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"empty-app\");\n\n        final Map.Entry<URL, Long> zombie = deploymentService.getZombieMap().entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"empty-app\", new File(zombie.getKey().getFile()).getParentFile().getName());\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void receivesMuleContextDeploymentNotifications() throws Exception\n    {\n        // NOTE: need an integration test like this because DefaultMuleApplication\n        // class cannot be unit tested.\n        final URL url = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url);\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertMuleContextCreated(deploymentListener, \"dummy-app\");\n        assertMuleContextInitialized(deploymentListener, \"dummy-app\");\n        assertMuleContextConfigured(deploymentListener, \"dummy-app\");\n    }","id":97838,"modified_method":"@Test\n    public void receivesMuleContextDeploymentNotifications() throws Exception\n    {\n        // NOTE: need an integration test like this because DefaultMuleApplication\n        // class cannot be unit tested.\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertMuleContextCreated(deploymentListener, \"dummy-app\");\n        assertMuleContextInitialized(deploymentListener, \"dummy-app\");\n        assertMuleContextConfigured(deploymentListener, \"dummy-app\");\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void redeploysZipDeployedAfterStartup() throws Exception\n    {\n        final URL url = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url);\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n        assertEquals(\"Application has not been properly registered with Mule\", 1, deploymentService.getApplications().size());\n\n        reset(deploymentListener);\n        addAppArchive(url);\n\n        assertUndeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertEquals(\"Application has not been properly registered with Mule\", 1, deploymentService.getApplications().size());\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n    }","id":97839,"modified_method":"@Test\n    public void redeploysZipDeployedAfterStartup() throws Exception\n    {\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n        assertEquals(\"Application has not been properly registered with Mule\", 1, deploymentService.getApplications().size());\n\n        reset(deploymentListener);\n\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        assertUndeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertEquals(\"Application has not been properly registered with Mule\", 1, deploymentService.getApplications().size());\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void deploysBrokenZipAfterStartup() throws Exception\n    {\n        deploymentService.start();\n\n        final URL url = getClass().getResource(\"/overridden.properties\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url, \"brokenApp.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"brokenApp\");\n\n        assertAppsDir(new String[] {\"brokenApp.zip\"}, NONE, true);\n\n        final Map<URL, Long> zombieMap = deploymentService.getZombieMap();\n        assertEquals(\"Wrong number of zombie apps registered.\", 1, zombieMap.size());\n        final Map.Entry<URL, Long> zombie = zombieMap.entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"brokenApp.zip\", new File(zombie.getKey().getFile()).getName());\n        assertTrue(\"Invalid lastModified value for file URL.\", zombie.getValue() != -1);\n    }","id":97840,"modified_method":"@Test\n    public void deploysBrokenZipAfterStartup() throws Exception\n    {\n        deploymentService.start();\n\n        addPackedAppFromResource(\"/overridden.properties\", \"brokenApp.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"brokenApp\");\n\n        assertAppsDir(new String[] {\"brokenApp.zip\"}, NONE, true);\n\n        final Map<URL, Long> zombieMap = deploymentService.getZombieMap();\n        assertEquals(\"Wrong number of zombie apps registered.\", 1, zombieMap.size());\n        final Map.Entry<URL, Long> zombie = zombieMap.entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"brokenApp.zip\", new File(zombie.getKey().getFile()).getName());\n        assertTrue(\"Invalid lastModified value for file URL.\", zombie.getValue() != -1);\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void redeploysInvalidZipAppAfterFailedDeploymentOnStartup() throws IOException\n    {\n        final URL url = getClass().getResource(\"/incompleteApp.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url, \"incompleteApp.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        reset(deploymentListener);\n\n        addAppArchive(url, \"incompleteApp.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        final Map.Entry<URL, Long> zombie = deploymentService.getZombieMap().entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"incompleteApp\", new File(zombie.getKey().getFile()).getParentFile().getName());\n    }","id":97841,"modified_method":"@Test\n    public void redeploysInvalidZipAppAfterFailedDeploymentOnStartup() throws IOException\n    {\n        addPackedAppFromResource(\"/incompleteApp.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        reset(deploymentListener);\n\n        addPackedAppFromResource(\"/incompleteApp.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        final Map.Entry<URL, Long> zombie = deploymentService.getZombieMap().entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"incompleteApp\", new File(zombie.getKey().getFile()).getParentFile().getName());\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void deploysPackedAppsInOrderWhenAppArgumentIsUsed() throws Exception\n    {\n        final URL url = getClass().getResource(\"/empty-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url, \"1.zip\");\n        addAppArchive(url, \"2.zip\");\n        addAppArchive(url, \"3.zip\");\n\n        Map<String, Object> startupOptions = new HashMap<String, Object>();\n        startupOptions.put(\"app\", \"3:1:2\");\n        StartupContext.get().setStartupOptions(startupOptions);\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"1\");\n        assertDeploymentSuccess(deploymentListener, \"2\");\n        assertDeploymentSuccess(deploymentListener, \"3\");\n        assertAppsDir(NONE, new String[] {\"1\", \"2\", \"3\"}, true);\n\n        // When apps are passed as -app app1:app2:app3 the startup order matters\n        List<Application> applications = deploymentService.getApplications();\n        assertNotNull(applications);\n        assertEquals(3, applications.size());\n        assertEquals(\"3\", applications.get(0).getAppName());\n        assertEquals(\"1\", applications.get(1).getAppName());\n        assertEquals(\"2\", applications.get(2).getAppName());\n    }","id":97842,"modified_method":"@Test\n    public void deploysPackedAppsInOrderWhenAppArgumentIsUsed() throws Exception\n    {\n        addPackedAppFromResource(\"/empty-app.zip\", \"1.zip\");\n        addPackedAppFromResource(\"/empty-app.zip\", \"2.zip\");\n        addPackedAppFromResource(\"/empty-app.zip\", \"3.zip\");\n\n        Map<String, Object> startupOptions = new HashMap<String, Object>();\n        startupOptions.put(\"app\", \"3:1:2\");\n        StartupContext.get().setStartupOptions(startupOptions);\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"1\");\n        assertDeploymentSuccess(deploymentListener, \"2\");\n        assertDeploymentSuccess(deploymentListener, \"3\");\n        assertAppsDir(NONE, new String[] {\"1\", \"2\", \"3\"}, true);\n\n        // When apps are passed as -app app1:app2:app3 the startup order matters\n        List<Application> applications = deploymentService.getApplications();\n        assertNotNull(applications);\n        assertEquals(3, applications.size());\n        assertEquals(\"3\", applications.get(0).getAppName());\n        assertEquals(\"1\", applications.get(1).getAppName());\n        assertEquals(\"2\", applications.get(2).getAppName());\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void deploysInvalidZipAppAfterStartup() throws Exception\n    {\n        deploymentService.start();\n\n        final URL url = getClass().getResource(\"/empty-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url, \"app with spaces.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"app with spaces\");\n\n        // zip stays intact, no app dir created\n        assertAppsDir(new String[] {\"app with spaces.zip\"}, NONE, true);\n        final Map<URL, Long> zombieMap = deploymentService.getZombieMap();\n        assertEquals(\"Wrong number of zombie apps registered.\", 1, zombieMap.size());\n        final Map.Entry<URL, Long> zombie = zombieMap.entrySet().iterator().next();\n        // Spaces are converted to %20 is returned by java file api :/\n        String appName = URLDecoder.decode(new File(zombie.getKey().getFile()).getName(), \"UTF-8\");\n        assertEquals(\"Wrong URL tagged as zombie.\", \"app with spaces.zip\", appName);\n        assertTrue(\"Invalid lastModified value for file URL.\", zombie.getValue() != -1);\n    }","id":97843,"modified_method":"@Test\n    public void deploysInvalidZipAppAfterStartup() throws Exception\n    {\n        deploymentService.start();\n\n        addPackedAppFromResource(\"/empty-app.zip\", \"app with spaces.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"app with spaces\");\n\n        // zip stays intact, no app dir created\n        assertAppsDir(new String[] {\"app with spaces.zip\"}, NONE, true);\n        final Map<URL, Long> zombieMap = deploymentService.getZombieMap();\n        assertEquals(\"Wrong number of zombie apps registered.\", 1, zombieMap.size());\n        final Map.Entry<URL, Long> zombie = zombieMap.entrySet().iterator().next();\n        // Spaces are converted to %20 is returned by java file api :/\n        String appName = URLDecoder.decode(new File(zombie.getKey().getFile()).getName(), \"UTF-8\");\n        assertEquals(\"Wrong URL tagged as zombie.\", \"app with spaces.zip\", appName);\n        assertTrue(\"Invalid lastModified value for file URL.\", zombie.getValue() != -1);\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void mantainsAppFolderOnExplodedAppDeploymentError() throws Exception\n    {\n        deploymentService.start();\n\n        File appDir = new File(appsDir, \"incompleteApp\");\n        final URL url = getClass().getResource(\"/incompleteApp.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n\n        final File source = new File(url.toURI());\n        FileUtils.unzip(source, appDir);\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        final URL extraApp = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + extraApp, extraApp);\n        addAppArchive(extraApp);\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        // Check that the failed application folder is still there\n        assertAppFolderIsMaintained(\"incompleteApp\");\n        final Map.Entry<URL, Long> zombie = deploymentService.getZombieMap().entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"incompleteApp\", new File(zombie.getKey().getFile()).getParentFile().getName());\n    }","id":97844,"modified_method":"@Test\n    public void mantainsAppFolderOnExplodedAppDeploymentError() throws Exception\n    {\n        deploymentService.start();\n\n        File appDir = new File(appsDir, \"incompleteApp\");\n        final URL url = getClass().getResource(\"/incompleteApp.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n\n        final File source = new File(url.toURI());\n        FileUtils.unzip(source, appDir);\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        // Check that the failed application folder is still there\n        assertAppFolderIsMaintained(\"incompleteApp\");\n        final Map.Entry<URL, Long> zombie = deploymentService.getZombieMap().entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"incompleteApp\", new File(zombie.getKey().getFile()).getParentFile().getName());\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void redeploysZipDeployedOnStartup() throws Exception\n    {\n        deploymentService.start();\n\n        final URL url = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url);\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n        assertEquals(\"Application has not been properly registered with Mule\", 1, deploymentService.getApplications().size());\n\n        reset(deploymentListener);\n        addAppArchive(url);\n\n        assertUndeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertEquals(\"Application has not been properly registered with Mule\", 1, deploymentService.getApplications().size());\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n    }","id":97845,"modified_method":"@Test\n    public void redeploysZipDeployedOnStartup() throws Exception\n    {\n        deploymentService.start();\n\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n        assertEquals(\"Application has not been properly registered with Mule\", 1, deploymentService.getApplications().size());\n\n        reset(deploymentListener);\n\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        assertUndeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertEquals(\"Application has not been properly registered with Mule\", 1, deploymentService.getApplications().size());\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void redeploysZipAppOnConfigChanges() throws Exception\n    {\n        final URL url = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url);\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n        assertEquals(\"Application has not been properly registered with Mule\", 1, deploymentService.getApplications().size());\n\n        reset(deploymentListener);\n\n        File configFile = new File(appsDir + \"/dummy-app\", \"mule-config.xml\");\n        configFile.setLastModified(configFile.lastModified() + 1000);\n\n        assertUndeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertEquals(\"Application has not been properly registered with Mule\", 1, deploymentService.getApplications().size());\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n    }","id":97846,"modified_method":"@Test\n    public void redeploysZipAppOnConfigChanges() throws Exception\n    {\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n        assertEquals(\"Application has not been properly registered with Mule\", 1, deploymentService.getApplications().size());\n\n        reset(deploymentListener);\n\n        File configFile = new File(appsDir + \"/dummy-app\", \"mule-config.xml\");\n        configFile.setLastModified(configFile.lastModified() + 1000);\n\n        assertUndeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertEquals(\"Application has not been properly registered with Mule\", 1, deploymentService.getApplications().size());\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void deploysBrokenZipOnStartup() throws Exception\n    {\n        final URL url = getClass().getResource(\"/overridden.properties\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url, \"brokenApp.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentFailure(deploymentListener, \"brokenApp\");\n\n        assertAppsDir(new String[] {\"brokenApp.zip\"}, NONE, true);\n\n        final Map<URL, Long> zombieMap = deploymentService.getZombieMap();\n        assertEquals(\"Wrong number of zombie apps registered.\", 1, zombieMap.size());\n        final Map.Entry<URL, Long> zombie = zombieMap.entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"brokenApp.zip\", new File(zombie.getKey().getFile()).getName());\n        assertTrue(\"Invalid lastModified value for file URL.\", zombie.getValue() != -1);\n    }","id":97847,"modified_method":"@Test\n    public void deploysBrokenZipOnStartup() throws Exception\n    {\n        addPackedAppFromResource(\"/overridden.properties\", \"brokenApp.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentFailure(deploymentListener, \"brokenApp\");\n\n        assertAppsDir(new String[] {\"brokenApp.zip\"}, NONE, true);\n\n        final Map<URL, Long> zombieMap = deploymentService.getZombieMap();\n        assertEquals(\"Wrong number of zombie apps registered.\", 1, zombieMap.size());\n        final Map.Entry<URL, Long> zombie = zombieMap.entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"brokenApp.zip\", new File(zombie.getKey().getFile()).getName());\n        assertTrue(\"Invalid lastModified value for file URL.\", zombie.getValue() != -1);\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testDeployAppNameWithZipSuffix() throws Exception\n    {\n        final URL url = getClass().getResource(\"/empty-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url, \"empty-app.zip.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"empty-app.zip\");\n        reset(deploymentListener);\n\n        assertAppsDir(NONE, new String[] {\"empty-app.zip\"}, true);\n        assertEquals(\"Application has not been properly registered with Mule\", 1, deploymentService.getApplications().size());\n\n        // Checks that the empty-app.zip folder is not processed as a zip file\n        assertNoDeploymentInvoked(deploymentListener);\n    }","id":97848,"modified_method":"@Test\n    public void testDeployAppNameWithZipSuffix() throws Exception\n    {\n        addPackedAppFromResource(\"/empty-app.zip\", \"empty-app.zip.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"empty-app.zip\");\n        reset(deploymentListener);\n\n        assertAppsDir(NONE, new String[] {\"empty-app.zip\"}, true);\n        assertEquals(\"Application has not been properly registered with Mule\", 1, deploymentService.getApplications().size());\n\n        // Checks that the empty-app.zip folder is not processed as a zip file\n        assertNoDeploymentInvoked(deploymentListener);\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void redeploysExplodedAppAfterDeploymentError() throws Exception\n    {\n        deploymentService.start();\n\n        File appDir = new File(appsDir, \"incompleteApp\");\n        final URL url = getClass().getResource(\"/incompleteApp.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n\n        final File source = new File(url.toURI());\n        FileUtils.unzip(source, appDir);\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        final URL extraApp = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + extraApp, extraApp);\n        addAppArchive(extraApp);\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        final URL fixedApp = getClass().getResource(\"/empty-app.zip\");\n        assertNotNull(\"Test app file not found \" + fixedApp, fixedApp);\n        //final File fixedAppSource = new File();\n\n        addExplodedApp(fixedApp, \"incompleteApp\");\n\n        assertDeploymentSuccess(deploymentListener, \"incompleteApp\");\n        assertEquals(\"Failed app still appears as zombie after a successful redeploy\", 0, deploymentService.getZombieMap().size());\n    }","id":97849,"modified_method":"@Test\n    public void redeploysExplodedAppAfterDeploymentError() throws Exception\n    {\n        deploymentService.start();\n\n        File appDir = new File(appsDir, \"incompleteApp\");\n        final URL url = getClass().getResource(\"/incompleteApp.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n\n        final File source = new File(url.toURI());\n        FileUtils.unzip(source, appDir);\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        final URL fixedApp = getClass().getResource(\"/empty-app.zip\");\n        assertNotNull(\"Test app file not found \" + fixedApp, fixedApp);\n        //final File fixedAppSource = new File();\n\n        addExplodedApp(fixedApp, \"incompleteApp\");\n\n        assertDeploymentSuccess(deploymentListener, \"incompleteApp\");\n        assertEquals(\"Failed app still appears as zombie after a successful redeploy\", 0, deploymentService.getZombieMap().size());\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void deploysZipAfterStartup() throws Exception\n    {\n        deploymentService.start();\n\n        final URL url = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url);\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n\n        // just assert no privileged entries were put in the registry\n        final Application app = findApp(\"dummy-app\", 1);\n        final MuleRegistry registry = app.getMuleContext().getRegistry();\n\n        // mule-app.properties from the zip archive must have loaded properly\n        assertEquals(\"mule-app.properties should have been loaded.\", \"someValue\", registry.get(\"myCustomProp\"));\n    }","id":97850,"modified_method":"@Test\n    public void deploysZipAfterStartup() throws Exception\n    {\n        deploymentService.start();\n\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n\n        // just assert no privileged entries were put in the registry\n        final Application app = findApp(\"dummy-app\", 1);\n        final MuleRegistry registry = app.getMuleContext().getRegistry();\n\n        // mule-app.properties from the zip archive must have loaded properly\n        assertEquals(\"mule-app.properties should have been loaded.\", \"someValue\", registry.get(\"myCustomProp\"));\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void undeploysAppCompletelyEvenOnDisposingException() throws Exception\n    {\n        final URL url = getClass().getResource(\"/empty-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url);\n\n        TestApplicationFactory appFactory = new TestApplicationFactory(new MuleApplicationClassLoaderFactory());\n        appFactory.setFailOnDisposeApplication(true);\n        deploymentService.setAppFactory(appFactory);\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"empty-app\");\n\n        assertTrue(\"Unable to remove anchor file\", removeAnchorFile(\"empty-app\"));\n\n        assertUndeploymentSuccess(deploymentListener, \"empty-app\");\n\n        assertAppFolderIsDeleted(\"empty-app\");\n    }","id":97851,"modified_method":"@Test\n    public void undeploysAppCompletelyEvenOnDisposingException() throws Exception\n    {\n        addPackedAppFromResource(\"/empty-app.zip\");\n\n        TestApplicationFactory appFactory = new TestApplicationFactory(new MuleApplicationClassLoaderFactory());\n        appFactory.setFailOnDisposeApplication(true);\n        deploymentService.setAppFactory(appFactory);\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"empty-app\");\n\n        assertTrue(\"Unable to remove anchor file\", removeAnchorFile(\"empty-app\"));\n\n        assertUndeploymentSuccess(deploymentListener, \"empty-app\");\n\n        assertAppFolderIsDeleted(\"empty-app\");\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void undeploysAppCompletelyEvenOnStoppingException() throws Exception\n    {\n        final URL url = getClass().getResource(\"/empty-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url);\n\n        TestApplicationFactory appFactory = new TestApplicationFactory(new MuleApplicationClassLoaderFactory());\n        appFactory.setFailOnStopApplication(true);\n\n        deploymentService.setAppFactory(appFactory);\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"empty-app\");\n\n        assertTrue(\"Unable to remove anchor file\", removeAnchorFile(\"empty-app\"));\n\n        assertUndeploymentSuccess(deploymentListener, \"empty-app\");\n\n        assertAppFolderIsDeleted(\"empty-app\");\n    }","id":97852,"modified_method":"@Test\n    public void undeploysAppCompletelyEvenOnStoppingException() throws Exception\n    {\n        addPackedAppFromResource(\"/empty-app.zip\");\n\n        TestApplicationFactory appFactory = new TestApplicationFactory(new MuleApplicationClassLoaderFactory());\n        appFactory.setFailOnStopApplication(true);\n\n        deploymentService.setAppFactory(appFactory);\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"empty-app\");\n\n        assertTrue(\"Unable to remove anchor file\", removeAnchorFile(\"empty-app\"));\n\n        assertUndeploymentSuccess(deploymentListener, \"empty-app\");\n\n        assertAppFolderIsDeleted(\"empty-app\");\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void deploysIncompleteZipAppOnStartup() throws Exception\n    {\n        final URL url = getClass().getResource(\"/incompleteApp.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url, \"incompleteApp.zip\");\n\n        deploymentService.start();\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        final URL extraApp = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + extraApp, extraApp);\n        addAppArchive(extraApp);\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        // Check that the failed application folder is still there\n        assertAppFolderIsMaintained(\"incompleteApp\");\n        final Map.Entry<URL, Long> zombie = deploymentService.getZombieMap().entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"incompleteApp\", new File(zombie.getKey().getFile()).getParentFile().getName());\n    }","id":97853,"modified_method":"@Test\n    public void deploysIncompleteZipAppOnStartup() throws Exception\n    {\n        addPackedAppFromResource(\"/incompleteApp.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        // Check that the failed application folder is still there\n        assertAppFolderIsMaintained(\"incompleteApp\");\n        final Map.Entry<URL, Long> zombie = deploymentService.getZombieMap().entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"incompleteApp\", new File(zombie.getKey().getFile()).getParentFile().getName());\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void deploysAppJustOnce() throws Exception\n    {\n        final URL url = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url);\n\n        Map<String, Object> startupOptions = new HashMap<String, Object>();\n        startupOptions.put(\"app\", \"dummy-app:dummy-app:dummy-app\");\n        StartupContext.get().setStartupOptions(startupOptions);\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n\n        List<Application> applications = deploymentService.getApplications();\n        assertEquals(1, applications.size());\n    }","id":97854,"modified_method":"@Test\n    public void deploysAppJustOnce() throws Exception\n    {\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        Map<String, Object> startupOptions = new HashMap<String, Object>();\n        startupOptions.put(\"app\", \"dummy-app:dummy-app:dummy-app\");\n        StartupContext.get().setStartupOptions(startupOptions);\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n\n        List<Application> applications = deploymentService.getApplications();\n        assertEquals(1, applications.size());\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void undeploysApplicationRemovingAnchorFile() throws Exception\n    {\n        final URL url = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n\n        addAppArchive(url);\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        assertTrue(\"Unable to remove anchor file\", removeAnchorFile(\"dummy-app\"));\n\n        assertUndeploymentSuccess(deploymentListener, \"dummy-app\");\n    }","id":97855,"modified_method":"@Test\n    public void undeploysApplicationRemovingAnchorFile() throws Exception\n    {\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        assertTrue(\"Unable to remove anchor file\", removeAnchorFile(\"dummy-app\"));\n\n        assertUndeploymentSuccess(deploymentListener, \"dummy-app\");\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void redeploysInvalidZipAppAfterFailedDeploymentAfterStartup() throws IOException\n    {\n        deploymentService.start();\n\n        final URL url = getClass().getResource(\"/incompleteApp.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url, \"incompleteApp.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        reset(deploymentListener);\n\n        addAppArchive(url, \"incompleteApp.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        final Map.Entry<URL, Long> zombie = deploymentService.getZombieMap().entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"incompleteApp\", new File(zombie.getKey().getFile()).getParentFile().getName());\n    }","id":97856,"modified_method":"@Test\n    public void redeploysInvalidZipAppAfterFailedDeploymentAfterStartup() throws IOException\n    {\n        deploymentService.start();\n\n        addPackedAppFromResource(\"/incompleteApp.zip\");\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        reset(deploymentListener);\n\n        addPackedAppFromResource(\"/incompleteApp.zip\");\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        final Map.Entry<URL, Long> zombie = deploymentService.getZombieMap().entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"incompleteApp\", new File(zombie.getKey().getFile()).getParentFile().getName());\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doBrokenAppArchiveTest() throws Exception\n    {\n        final URL url = getClass().getResource(\"/broken-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url);\n\n        deploymentService.start();\n\n        assertDeploymentFailure(deploymentListener, \"broken-app\");\n        reset(deploymentListener);\n\n        // let the file system's write-behind cache commit the delete operation?\n        Thread.sleep(1000);\n\n        // zip stays intact, no app dir created\n        assertAppsDir(new String[] {\"broken-app.zip\"}, NONE, true);\n        // don't assert dir contents, we want to check internal deployer state next\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, false);\n        assertEquals(\"No apps should have been registered with Mule.\", 0, deploymentService.getApplications().size());\n        final Map<URL, Long> zombieMap = deploymentService.getZombieMap();\n        assertEquals(\"Wrong number of zombie apps registered.\", 1, zombieMap.size());\n        final Map.Entry<URL, Long> zombie = zombieMap.entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"broken-app.zip\", new File(zombie.getKey().getFile()).getName());\n        assertTrue(\"Invalid lastModified value for file URL.\", zombie.getValue() != -1);\n\n        // Checks that the invalid zip was not deployed again\n        try\n        {\n            assertDeploymentFailure(deploymentListener, \"broken-app.zip\");\n            fail(\"Install was invoked again for the broken application file\");\n        }\n        catch (AssertionError expected)\n        {\n        }\n    }","id":97857,"modified_method":"public void doBrokenAppArchiveTest() throws Exception\n    {\n        addPackedAppFromResource(\"/broken-app.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentFailure(deploymentListener, \"broken-app\");\n        reset(deploymentListener);\n\n        // let the file system's write-behind cache commit the delete operation?\n        Thread.sleep(1000);\n\n        // zip stays intact, no app dir created\n        assertAppsDir(new String[] {\"broken-app.zip\"}, NONE, true);\n        // don't assert dir contents, we want to check internal deployer state next\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, false);\n        assertEquals(\"No apps should have been registered with Mule.\", 0, deploymentService.getApplications().size());\n        final Map<URL, Long> zombieMap = deploymentService.getZombieMap();\n        assertEquals(\"Wrong number of zombie apps registered.\", 1, zombieMap.size());\n        final Map.Entry<URL, Long> zombie = zombieMap.entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"broken-app.zip\", new File(zombie.getKey().getFile()).getName());\n        assertTrue(\"Invalid lastModified value for file URL.\", zombie.getValue() != -1);\n\n        // Checks that the invalid zip was not deployed again\n        try\n        {\n            assertDeploymentFailure(deploymentListener, \"broken-app.zip\");\n            fail(\"Install was invoked again for the broken application file\");\n        }\n        catch (AssertionError expected)\n        {\n        }\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void deploysInvalidZipAppOnStartup() throws Exception\n    {\n        final URL url = getClass().getResource(\"/empty-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url, \"app with spaces.zip\");\n\n        deploymentService.start();\n        assertDeploymentFailure(deploymentListener, \"app with spaces\");\n\n        // zip stays intact, no app dir created\n        assertAppsDir(new String[] {\"app with spaces.zip\"}, NONE, true);\n        final Map<URL, Long> zombieMap = deploymentService.getZombieMap();\n        assertEquals(\"Wrong number of zombie apps registered.\", 1, zombieMap.size());\n        final Map.Entry<URL, Long> zombie = zombieMap.entrySet().iterator().next();\n        // Spaces are converted to %20 is returned by java file api :/\n        String appName = URLDecoder.decode(new File(zombie.getKey().getFile()).getName(), \"UTF-8\");\n        assertEquals(\"Wrong URL tagged as zombie.\", \"app with spaces.zip\", appName);\n        assertTrue(\"Invalid lastModified value for file URL.\", zombie.getValue() != -1);\n    }","id":97858,"modified_method":"@Test\n    public void deploysInvalidZipAppOnStartup() throws Exception\n    {\n        addPackedAppFromResource(\"/empty-app.zip\", \"app with spaces.zip\");\n\n        deploymentService.start();\n        assertDeploymentFailure(deploymentListener, \"app with spaces\");\n\n        // zip stays intact, no app dir created\n        assertAppsDir(new String[] {\"app with spaces.zip\"}, NONE, true);\n        final Map<URL, Long> zombieMap = deploymentService.getZombieMap();\n        assertEquals(\"Wrong number of zombie apps registered.\", 1, zombieMap.size());\n        final Map.Entry<URL, Long> zombie = zombieMap.entrySet().iterator().next();\n        // Spaces are converted to %20 is returned by java file api :/\n        String appName = URLDecoder.decode(new File(zombie.getKey().getFile()).getName(), \"UTF-8\");\n        assertEquals(\"Wrong URL tagged as zombie.\", \"app with spaces.zip\", appName);\n        assertTrue(\"Invalid lastModified value for file URL.\", zombie.getValue() != -1);\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void redeploysInvalidZipAppAfterSuccessfulDeploymentAfterStartup() throws IOException\n    {\n        deploymentService.start();\n\n        final URL fixedApp = getClass().getResource(\"/empty-app.zip\");\n        assertNotNull(\"Test app file not found \" + fixedApp, fixedApp);\n        addAppArchive(fixedApp, \"empty-app.zip\");\n\n\n        assertDeploymentSuccess(deploymentListener, \"empty-app\");\n\n        final URL url = getClass().getResource(\"/incompleteApp.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url, \"empty-app.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"empty-app\");\n\n        final Map.Entry<URL, Long> zombie = deploymentService.getZombieMap().entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"empty-app\", new File(zombie.getKey().getFile()).getParentFile().getName());\n    }","id":97859,"modified_method":"@Test\n    public void redeploysInvalidZipAppAfterSuccessfulDeploymentAfterStartup() throws IOException\n    {\n        deploymentService.start();\n\n        addPackedAppFromResource(\"/empty-app.zip\");\n        assertDeploymentSuccess(deploymentListener, \"empty-app\");\n\n        addPackedAppFromResource(\"/incompleteApp.zip\", \"empty-app.zip\");\n        assertDeploymentFailure(deploymentListener, \"empty-app\");\n\n        final Map.Entry<URL, Long> zombie = deploymentService.getZombieMap().entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"empty-app\", new File(zombie.getKey().getFile()).getParentFile().getName());\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void redeploysZipAppAfterDeploymentErrorOnStartup() throws Exception\n    {\n        final URL url = getClass().getResource(\"/incompleteApp.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url, \"incompleteApp.zip\");\n        deploymentService.start();\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        final URL extraApp = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + extraApp, extraApp);\n        addAppArchive(extraApp);\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        final URL fixedApp = getClass().getResource(\"/empty-app.zip\");\n        assertNotNull(\"Test app file not found \" + extraApp, extraApp);\n        addAppArchive(fixedApp, \"incompleteApp.zip\");\n        assertDeploymentSuccess(deploymentListener, \"incompleteApp\");\n\n        assertEquals(\"Failed app still appears as zombie after a successful redeploy\", 0, deploymentService.getZombieMap().size());\n    }","id":97860,"modified_method":"@Test\n    public void redeploysZipAppAfterDeploymentErrorOnStartup() throws Exception\n    {\n        addPackedAppFromResource(\"/incompleteApp.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        addPackedAppFromResource(\"/empty-app.zip\", \"incompleteApp.zip\");\n        assertDeploymentSuccess(deploymentListener, \"incompleteApp\");\n\n        assertEquals(\"Failed app still appears as zombie after a successful redeploy\", 0, deploymentService.getZombieMap().size());\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void deploysIncompleteZipAppAfterStartup() throws Exception\n    {\n        deploymentService.start();\n\n        final URL url = getClass().getResource(\"/incompleteApp.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url, \"incompleteApp.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        final URL extraApp = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + extraApp, extraApp);\n        addAppArchive(extraApp);\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        // Check that the failed application folder is still there\n        assertAppFolderIsMaintained(\"incompleteApp\");\n        final Map.Entry<URL, Long> zombie = deploymentService.getZombieMap().entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"incompleteApp\", new File(zombie.getKey().getFile()).getParentFile().getName());\n    }","id":97861,"modified_method":"@Test\n    public void deploysIncompleteZipAppAfterStartup() throws Exception\n    {\n        deploymentService.start();\n\n        addPackedAppFromResource(\"/incompleteApp.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        // Check that the failed application folder is still there\n        assertAppFolderIsMaintained(\"incompleteApp\");\n        final Map.Entry<URL, Long> zombie = deploymentService.getZombieMap().entrySet().iterator().next();\n        assertEquals(\"Wrong URL tagged as zombie.\", \"incompleteApp\", new File(zombie.getKey().getFile()).getParentFile().getName());\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void redeploysZipAppAfterDeploymentErrorAfterStartup() throws Exception\n    {\n        deploymentService.start();\n\n        final URL url = getClass().getResource(\"/incompleteApp.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url, \"incompleteApp.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        final URL extraApp = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + extraApp, extraApp);\n        addAppArchive(extraApp);\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        final URL fixedApp = getClass().getResource(\"/empty-app.zip\");\n        assertNotNull(\"Test app file not found \" + extraApp, extraApp);\n        addAppArchive(fixedApp, \"incompleteApp.zip\");\n        assertDeploymentSuccess(deploymentListener, \"incompleteApp\");\n\n        assertEquals(\"Failed app still appears as zombie after a successful redeploy\", 0, deploymentService.getZombieMap().size());\n    }","id":97862,"modified_method":"@Test\n    public void redeploysZipAppAfterDeploymentErrorAfterStartup() throws Exception\n    {\n        deploymentService.start();\n\n        addPackedAppFromResource(\"/incompleteApp.zip\");\n\n        assertDeploymentFailure(deploymentListener, \"incompleteApp\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        // Deploys another app to confirm that DeploymentService has execute the updater thread\n        addPackedAppFromResource(\"/empty-app.zip\", \"incompleteApp.zip\");\n        assertDeploymentSuccess(deploymentListener, \"incompleteApp\");\n\n        assertEquals(\"Failed app still appears as zombie after a successful redeploy\", 0, deploymentService.getZombieMap().size());\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void deploysPackagedAppOnStartupWhenExplodedAppIsAlsoPresent() throws Exception\n    {\n        final URL url = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n\n        addExplodedApp(url, \"dummy-app\");\n        addAppArchive(url);\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        addAppArchive(getClass().getResource(\"/empty-app.zip\"));\n\n        assertDeploymentSuccess(deploymentListener, \"empty-app\");\n\n        // Checks that dummy app was deployed just once\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n    }","id":97863,"modified_method":"@Test\n    public void deploysPackagedAppOnStartupWhenExplodedAppIsAlsoPresent() throws Exception\n    {\n        final URL url = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n\n        addExplodedApp(url, \"dummy-app\");\n\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        addPackedAppFromResource(\"/empty-app.zip\");\n\n        assertDeploymentSuccess(deploymentListener, \"empty-app\");\n\n        // Checks that dummy app was deployed just once\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void undeploysStoppedApp() throws Exception\n    {\n        final URL url = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url);\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n        final Application app = findApp(\"dummy-app\", 1);\n        app.stop();\n\n        deploymentService.undeploy(app);\n    }","id":97864,"modified_method":"@Test\n    public void undeploysStoppedApp() throws Exception\n    {\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n        final Application app = findApp(\"dummy-app\", 1);\n        app.stop();\n\n        deploymentService.undeploy(app);\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void deploysZipOnStartup() throws Exception\n    {\n        final URL url = getClass().getResource(\"/dummy-app.zip\");\n        assertNotNull(\"Test app file not found \" + url, url);\n        addAppArchive(url);\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n\n        // just assert no privileged entries were put in the registry\n        final Application app = findApp(\"dummy-app\", 1);\n        final MuleRegistry registry = app.getMuleContext().getRegistry();\n\n        // mule-app.properties from the zip archive must have loaded properly\n        assertEquals(\"mule-app.properties should have been loaded.\", \"someValue\", registry.get(\"myCustomProp\"));\n    }","id":97865,"modified_method":"@Test\n    public void deploysZipOnStartup() throws Exception\n    {\n        addPackedAppFromResource(\"/dummy-app.zip\");\n\n        deploymentService.start();\n\n        assertDeploymentSuccess(deploymentListener, \"dummy-app\");\n\n        assertAppsDir(NONE, new String[] {\"dummy-app\"}, true);\n\n        // just assert no privileged entries were put in the registry\n        final Application app = findApp(\"dummy-app\", 1);\n        final MuleRegistry registry = app.getMuleContext().getRegistry();\n\n        // mule-app.properties from the zip archive must have loaded properly\n        assertEquals(\"mule-app.properties should have been loaded.\", \"someValue\", registry.get(\"myCustomProp\"));\n    }","commit_id":"38001993272964ec6785e8b492d15908779418ac","url":"https://github.com/mulesoft/mule"},{"original_method":"private void markOldStubs() {\n    int reloaded = 0;\n    int notReloaded = 0;\n\n    for (AbstractModule m : getAllModules()) {\n      List<StubPath> stubPathList = computeNotChangedStubPaths(m);\n      for (SModelDescriptor sm : SModelRepository.getInstance().getModelDescriptors(m)) {\n        if (!SModelStereotype.isStubModelStereotype(sm.getStereotype())) continue;\n        if (notChanged(stubPathList, sm)) {\n          if (sm.isInitialized()){\n            notReloaded++;\n          }\n          continue;\n        } else {\n          reloaded++;\n        }\n\n        assert sm instanceof BaseStubModelDescriptor : sm.getClass().getName();\n        ((BaseStubModelDescriptor) sm).markReload();\n      }\n    }\n\n    //System.out.printf(\"Stubs reloaded: \" + reloaded + \"; not reloaded: \" + notReloaded + \"\\n\");\n  }","id":97866,"modified_method":"private void markOldStubs() {\n    List<StubPath> newStubs = new ArrayList<StubPath>();\n    for (AbstractModule module : getAllModules()) {\n      List<StubPath> moduleStubs = module.areJavaStubsEnabled() ? module.getAllStubPaths() : module.getStubPaths();\n      newStubs.addAll(moduleStubs);\n    }\n\n    myNotChagedStubPaths = computeNotChangedStubPaths(myAllStubPaths.getAllStubPaths(), newStubs);\n\n    for (SModelDescriptor sm : SModelRepository.getInstance().getModelDescriptors()) {\n      if (!SModelStereotype.isStubModelStereotype(sm.getStereotype())) continue;\n\n      BaseStubModelDescriptor baseDescriptor = (BaseStubModelDescriptor) sm;\n      if (modelPathsNotChanged(baseDescriptor, myNotChagedStubPaths)) continue;\n\n      baseDescriptor.markReload();\n    }\n  }","commit_id":"b7937dddb8ec1a2553830c2677a72a6c308b571b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean needsUpdate(BaseStubModelDescriptor descriptor, StubLocation location) {\n    return needsFullReload(descriptor) /*|| isNewPath(descriptor, location.getPath())*/;\n  }","id":97867,"modified_method":"public boolean needsUpdate(BaseStubModelDescriptor descriptor, StubLocation location) {\n    return needsFullReload(descriptor) || isNewPath(descriptor, location.getPath());\n  }","commit_id":"b7937dddb8ec1a2553830c2677a72a6c308b571b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean equalStubPaths(StubPath os, StubPath ns) {\n    if (os == ns) return true;\n    if (ns == null || os.getClass() != ns.getClass()) return false;\n\n    StubPath stubPath = (StubPath) ns;\n\n    boolean pathsEqual = EqualUtil.equals(stubPath.getPath(), os.getPath());\n    boolean managersEqual = EqualUtil.equals(stubPath.getManager(), os.getManager());\n    boolean equalSP = pathsEqual && managersEqual;\n    return equalSP;\n  }","id":97868,"modified_method":"private boolean equalStubPaths(StubPath os, StubPath ns) {\n    if (os == ns) return true;\n    if (ns == null || os.getClass() != ns.getClass()) return false;\n\n    boolean pathsEqual = EqualUtil.equals(ns.getPath(), os.getPath());\n    boolean managersEqual = EqualUtil.equals(ns.getManager(), os.getManager());\n    boolean equalSP = pathsEqual && managersEqual;\n    return equalSP;\n  }","commit_id":"b7937dddb8ec1a2553830c2677a72a6c308b571b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void loadNewStubs() {\n    for (AbstractModule m : getAllModules()) {\n      List<StubPath> stubModels = m.areJavaStubsEnabled() ? m.getAllStubPaths() : m.getStubPaths();\n\n      for (StubPath sp : stubModels) {\n        BaseStubModelRootManager manager = createStubManager(m, sp);\n        sp.setModelRootManager(manager);\n\n        if (manager == null) continue;\n\n        //todo can be removed before 1.2. this try-block is to help to migrate to BaseStubModelDescriptor on sources\n        try {\n          manager.updateModels(sp.getPath(), \"\", m);\n        } catch (Throwable t) {\n          LOG.error(t);\n        }\n\n        myAllStubPaths.add(m, sp);\n      }\n    }\n  }","id":97869,"modified_method":"private void loadNewStubs() {\n    for (AbstractModule m : getAllModules()) {\n      List<StubPath> stubModels = m.areJavaStubsEnabled() ? m.getAllStubPaths() : m.getStubPaths();\n\n      for (StubPath sp : stubModels) {\n        BaseStubModelRootManager manager = createStubManager(m, sp);\n        sp.setModelRootManager(manager);\n        if (manager == null) continue;\n\n        manager.updateModels(sp.getPath(), \"\", m);\n\n        myAllStubPaths.add(m, sp);\n      }\n    }\n  }","commit_id":"b7937dddb8ec1a2553830c2677a72a6c308b571b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean needsUpdate(BaseStubModelDescriptor descriptor, StubLocation location) {\n    return needsFullReload(descriptor) /*|| isNewPath(descriptor, location.getPath())*/;\n  }","id":97870,"modified_method":"public boolean needsUpdate(BaseStubModelDescriptor descriptor, StubLocation location) {\n    return needsFullReload(descriptor) || isNewPath(descriptor, location.getPath());\n  }","commit_id":"a412568cc0b11b0ed25c77eee2d15c5dd8b38587","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void loadNewStubs() {\n    for (AbstractModule m : getAllModules()) {\n      List<StubPath> stubModels = m.areJavaStubsEnabled() ? m.getAllStubPaths() : m.getStubPaths();\n\n      for (StubPath sp : stubModels) {\n        BaseStubModelRootManager manager = createStubManager(m, sp);\n        sp.setModelRootManager(manager);\n\n        if (manager == null) continue;\n\n        //todo can be removed before 1.2. this try-block is to help to migrate to BaseStubModelDescriptor on sources\n        try {\n          manager.updateModels(sp.getPath(), \"\", m);\n        } catch (Throwable t) {\n          LOG.error(t);\n        }\n\n        myAllStubPaths.add(m, sp);\n      }\n    }\n  }","id":97871,"modified_method":"private void loadNewStubs() {\n    for (AbstractModule m : getAllModules()) {\n      List<StubPath> stubModels = m.areJavaStubsEnabled() ? m.getAllStubPaths() : m.getStubPaths();\n\n      for (StubPath sp : stubModels) {\n        BaseStubModelRootManager manager = createStubManager(m, sp);\n        sp.setModelRootManager(manager);\n        if (manager == null) continue;\n\n        manager.updateModels(sp.getPath(), \"\", m);\n\n        myAllStubPaths.add(m, sp);\n      }\n    }\n  }","commit_id":"a412568cc0b11b0ed25c77eee2d15c5dd8b38587","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean equalStubPaths(StubPath os, StubPath ns) {\n    if (os == ns) return true;\n    if (ns == null || os.getClass() != ns.getClass()) return false;\n\n    StubPath stubPath = (StubPath) ns;\n\n    boolean pathsEqual = EqualUtil.equals(stubPath.getPath(), os.getPath());\n    boolean managersEqual = EqualUtil.equals(stubPath.getManager(), os.getManager());\n    boolean equalSP = pathsEqual && managersEqual;\n    return equalSP;\n  }","id":97872,"modified_method":"private boolean equalStubPaths(StubPath os, StubPath ns) {\n    if (os == ns) return true;\n    if (ns == null || os.getClass() != ns.getClass()) return false;\n\n    boolean pathsEqual = EqualUtil.equals(ns.getPath(), os.getPath());\n    boolean managersEqual = EqualUtil.equals(ns.getManager(), os.getManager());\n    boolean equalSP = pathsEqual && managersEqual;\n    return equalSP;\n  }","commit_id":"a412568cc0b11b0ed25c77eee2d15c5dd8b38587","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void markOldStubs() {\n    int reloaded = 0;\n    int notReloaded = 0;\n\n    for (AbstractModule m : getAllModules()) {\n      List<StubPath> stubPathList = computeNotChangedStubPaths(m);\n      for (SModelDescriptor sm : SModelRepository.getInstance().getModelDescriptors(m)) {\n        if (!SModelStereotype.isStubModelStereotype(sm.getStereotype())) continue;\n        if (notChanged(stubPathList, sm)) {\n          if (sm.isInitialized()){\n            notReloaded++;\n          }\n          continue;\n        } else {\n          reloaded++;\n        }\n\n        assert sm instanceof BaseStubModelDescriptor : sm.getClass().getName();\n        ((BaseStubModelDescriptor) sm).markReload();\n      }\n    }\n\n    //System.out.printf(\"Stubs reloaded: \" + reloaded + \"; not reloaded: \" + notReloaded + \"\\n\");\n  }","id":97873,"modified_method":"private void markOldStubs() {\n    List<StubPath> newStubs = new ArrayList<StubPath>();\n    for (AbstractModule module : getAllModules()) {\n      List<StubPath> moduleStubs = module.areJavaStubsEnabled() ? module.getAllStubPaths() : module.getStubPaths();\n      newStubs.addAll(moduleStubs);\n    }\n\n    myNotChagedStubPaths = computeNotChangedStubPaths(myAllStubPaths.getAllStubPaths(), newStubs);\n\n    for (SModelDescriptor sm : SModelRepository.getInstance().getModelDescriptors()) {\n      if (!SModelStereotype.isStubModelStereotype(sm.getStereotype())) continue;\n\n      BaseStubModelDescriptor baseDescriptor = (BaseStubModelDescriptor) sm;\n      if (modelPathsNotChanged(baseDescriptor, myNotChagedStubPaths)) continue;\n\n      baseDescriptor.markReload();\n    }\n  }","commit_id":"a412568cc0b11b0ed25c77eee2d15c5dd8b38587","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void markOldStubs() {\n    List<StubPath> newStubs = new ArrayList<StubPath>();\n    for (AbstractModule module : getAllModules()) {\n      List<StubPath> moduleStubs = module.areJavaStubsEnabled() ? module.getAllStubPaths() : module.getStubPaths();\n      newStubs.addAll(moduleStubs);\n    }\n\n    myNotChagedStubPaths = computeNotChangedStubPaths(myAllStubPaths.getAllStubPaths(), newStubs);\n\n    for (SModelDescriptor sm : SModelRepository.getInstance().getModelDescriptors()) {\n      if (!SModelStereotype.isStubModelStereotype(sm.getStereotype())) continue;\n\n      BaseStubModelDescriptor baseDescriptor = (BaseStubModelDescriptor) sm;\n      if (modelPathsNotChanged(baseDescriptor, myNotChagedStubPaths)) continue;\n\n      baseDescriptor.markReload();\n    }\n  }","id":97874,"modified_method":"private void markOldStubs() {\n    int reloaded = 0;\n    int notReloaded = 0;\n\n    for (AbstractModule m : getAllModules()) {\n      List<StubPath> stubPathList = computeNotChangedStubPaths(m);\n      for (SModelDescriptor sm : SModelRepository.getInstance().getModelDescriptors(m)) {\n        if (!SModelStereotype.isStubModelStereotype(sm.getStereotype())) continue;\n        if (notChanged(stubPathList, sm)) {\n          if (sm.isInitialized()){\n            notReloaded++;\n          }\n          continue;\n        } else {\n          reloaded++;\n        }\n\n        assert sm instanceof BaseStubModelDescriptor : sm.getClass().getName();\n        ((BaseStubModelDescriptor) sm).markReload();\n      }\n    }\n\n    //System.out.printf(\"Stubs reloaded: \" + reloaded + \"; not reloaded: \" + notReloaded + \"\\n\");\n  }","commit_id":"10d20fa4109e850790c62e4f06f222c43d5bc565","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean needsUpdate(BaseStubModelDescriptor descriptor, StubLocation location) {\n    return needsFullReload(descriptor) || isNewPath(descriptor, location.getPath());\n  }","id":97875,"modified_method":"public boolean needsUpdate(BaseStubModelDescriptor descriptor, StubLocation location) {\n    return needsFullReload(descriptor) /*|| isNewPath(descriptor, location.getPath())*/;\n  }","commit_id":"10d20fa4109e850790c62e4f06f222c43d5bc565","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void loadNewStubs() {\n    for (AbstractModule m : getAllModules()) {\n      List<StubPath> stubModels = m.areJavaStubsEnabled() ? m.getAllStubPaths() : m.getStubPaths();\n\n      for (StubPath sp : stubModels) {\n        BaseStubModelRootManager manager = createStubManager(m, sp);\n        sp.setModelRootManager(manager);\n        if (manager == null) continue;\n\n        manager.updateModels(sp.getPath(), \"\", m);\n\n        myAllStubPaths.add(m, sp);\n      }\n    }\n  }","id":97876,"modified_method":"private void loadNewStubs() {\n    for (AbstractModule m : getAllModules()) {\n      List<StubPath> stubModels = m.areJavaStubsEnabled() ? m.getAllStubPaths() : m.getStubPaths();\n\n      for (StubPath sp : stubModels) {\n        BaseStubModelRootManager manager = createStubManager(m, sp);\n        sp.setModelRootManager(manager);\n\n        if (manager == null) continue;\n\n        //todo can be removed before 1.2. this try-block is to help to migrate to BaseStubModelDescriptor on sources\n        try {\n          manager.updateModels(sp.getPath(), \"\", m);\n        } catch (Throwable t) {\n          LOG.error(t);\n        }\n\n        myAllStubPaths.add(m, sp);\n      }\n    }\n  }","commit_id":"10d20fa4109e850790c62e4f06f222c43d5bc565","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean equalStubPaths(StubPath os, StubPath ns) {\n    if (os == ns) return true;\n    if (ns == null || os.getClass() != ns.getClass()) return false;\n\n    boolean pathsEqual = EqualUtil.equals(ns.getPath(), os.getPath());\n    boolean managersEqual = EqualUtil.equals(ns.getManager(), os.getManager());\n    boolean equalSP = pathsEqual && managersEqual;\n    return equalSP;\n  }","id":97877,"modified_method":"private boolean equalStubPaths(StubPath os, StubPath ns) {\n    if (os == ns) return true;\n    if (ns == null || os.getClass() != ns.getClass()) return false;\n\n    StubPath stubPath = (StubPath) ns;\n\n    boolean pathsEqual = EqualUtil.equals(stubPath.getPath(), os.getPath());\n    boolean managersEqual = EqualUtil.equals(stubPath.getManager(), os.getManager());\n    boolean equalSP = pathsEqual && managersEqual;\n    return equalSP;\n  }","commit_id":"10d20fa4109e850790c62e4f06f222c43d5bc565","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        Bounds other = (Bounds) obj;\n        if (max == null) {\n            if (other.max != null)\n                return false;\n        } else if (!max.equals(other.max))\n            return false;\n        if (min == null) {\n            if (other.min != null)\n                return false;\n        } else if (!min.equals(other.min))\n            return false;\n        return true;\n    }","id":97878,"modified_method":"@Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        Bounds other = (Bounds) obj;\n        if (Double.doubleToLongBits(maxLat) != Double.doubleToLongBits(other.maxLat))\n            return false;\n        if (Double.doubleToLongBits(maxLon) != Double.doubleToLongBits(other.maxLon))\n            return false;\n        if (Double.doubleToLongBits(minLat) != Double.doubleToLongBits(other.minLat))\n            return false;\n        if (Double.doubleToLongBits(minLon) != Double.doubleToLongBits(other.minLon))\n            return false;\n        return true;\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Bounds(double [] coords) {\n        if (coords == null)\n            throw new IllegalArgumentException(tr(\"Parameter ''{0}'' must not be null\", \"coords\"));\n        if (coords.length != 4)\n            throw new IllegalArgumentException(tr(\"Expected array of length 4, got {0}\", coords.length));\n        this.min = new LatLon(coords[0], coords[1]);\n        this.max = new LatLon(coords[2], coords[3]);\n    }","id":97879,"modified_method":"public Bounds(double [] coords) {\n        if (coords == null)\n            throw new IllegalArgumentException(tr(\"Parameter ''{0}'' must not be null\", \"coords\"));\n        if (coords.length != 4)\n            throw new IllegalArgumentException(tr(\"Expected array of length 4, got {0}\", coords.length));\n        this.minLat = coords[0];\n        this.minLon = coords[1];\n        this.maxLat = coords[2];\n        this.maxLon = coords[3];\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Bounds(Bounds other) {\n        this.min = new LatLon(other.min);\n        this.max = new LatLon(other.max);\n    }","id":97880,"modified_method":"public Bounds(Bounds other) {\n        this(other.getMin(), other.getMax());\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Bounds(double minlat, double minlon, double maxlat, double maxlon) {\n        this.min = new LatLon(minlat, minlon);\n        this.max = new LatLon(maxlat, maxlon);\n    }","id":97881,"modified_method":"public Bounds(double minlat, double minlon, double maxlat, double maxlon) {\n        this.minLat = minlat;\n        this.minLon = minlon;\n        this.maxLat = maxlat;\n        this.maxLon = maxlon;\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"public double getArea() {\n        return (max.lon() - min.lon()) * (max.lat() - min.lat());\n    }","id":97882,"modified_method":"public double getArea() {\n        return (maxLon - minLon) * (maxLat - minLat);\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Construct bounds out of two points\n     */\n    public Bounds(LatLon min, LatLon max) {\n        this.min = min;\n        this.max = max;\n    }","id":97883,"modified_method":"/**\n     * Construct bounds out of two points\n     */\n    public Bounds(LatLon min, LatLon max) {\n        this(min.lat(), min.lon(), max.lat(), max.lon());\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"public LatLon getMax() {\n        return max;\n    }","id":97884,"modified_method":"public LatLon getMax() {\n        return new LatLon(maxLat, maxLon);\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Bounds(LatLon b) {\n        this.min = b;\n        this.max = b;\n    }","id":97885,"modified_method":"public Bounds(LatLon b) {\n        this(b, b);\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override public String toString() {\n        return \"Bounds[\"+min.lat()+\",\"+min.lon()+\",\"+max.lat()+\",\"+max.lon()+\"]\";\n    }","id":97886,"modified_method":"@Override public String toString() {\n        return \"Bounds[\"+minLat+\",\"+minLon+\",\"+maxLat+\",\"+maxLon+\"]\";\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Bounds(Rectangle2D rect) {\n        this.min = new LatLon(rect.getMinY(), rect.getMinX());\n        this.max = new LatLon(rect.getMaxY(), rect.getMaxX());\n    }","id":97887,"modified_method":"public Bounds(Rectangle2D rect) {\n        this(rect.getMinY(), rect.getMinX(), rect.getMaxY(), rect.getMaxX());\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"public LatLon getMin() {\n        return min;\n    }","id":97888,"modified_method":"public LatLon getMin() {\n        return new LatLon(minLat, minLon);\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"public String encodeAsString(String separator) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(min.lat()).append(separator).append(min.lon())\n        .append(separator).append(max.lat()).append(separator)\n        .append(max.lon());\n        return sb.toString();\n    }","id":97889,"modified_method":"public String encodeAsString(String separator) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(minLat).append(separator).append(minLon)\n        .append(separator).append(maxLat).append(separator)\n        .append(maxLon);\n        return sb.toString();\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((max == null) ? 0 : max.hashCode());\n        result = prime * result + ((min == null) ? 0 : min.hashCode());\n        return result;\n    }","id":97890,"modified_method":"@Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(maxLat);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(maxLon);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(minLat);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(minLon);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        return result;\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Is the given point within this bounds?\n     */\n    public boolean contains(LatLon ll) {\n        if (ll.lat() < min.lat() || ll.lon() < min.lon())\n            return false;\n        if (ll.lat() > max.lat() || ll.lon() > max.lon())\n            return false;\n        return true;\n    }","id":97891,"modified_method":"/**\n     * Is the given point within this bounds?\n     */\n    public boolean contains(LatLon ll) {\n        if (ll.lat() < minLat || ll.lon() < minLon)\n            return false;\n        if (ll.lat() > maxLat || ll.lon() > maxLon)\n            return false;\n        return true;\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * @return Center of the bounding box.\n     */\n    public LatLon getCenter()\n    {\n        return min.getCenter(max);\n    }","id":97892,"modified_method":"/**\n     * @return Center of the bounding box.\n     */\n    public LatLon getCenter()\n    {\n        return getMin().getCenter(getMax());\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"public String toShortString(DecimalFormat format) {\n        return\n            format.format(min.lat()) + \" \"\n            + format.format(min.lon()) + \" / \"\n            + format.format(max.lat()) + \" \"\n            + format.format(max.lon());\n    }","id":97893,"modified_method":"public String toShortString(DecimalFormat format) {\n        return\n        format.format(minLat) + \" \"\n        + format.format(minLon) + \" / \"\n        + format.format(maxLat) + \" \"\n        + format.format(maxLon);\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Extend the bounds if necessary to include the given point.\n     */\n    public void extend(LatLon ll) {\n        if (ll.lat() < min.lat() || ll.lon() < min.lon()) {\n            min = new LatLon(Math.min(ll.lat(), min.lat()), Math.min(ll.lon(), min.lon()));\n        }\n        if (ll.lat() > max.lat() || ll.lon() > max.lon()) {\n            max = new LatLon(Math.max(ll.lat(), max.lat()), Math.max(ll.lon(), max.lon()));\n        }\n    }","id":97894,"modified_method":"/**\n     * Extend the bounds if necessary to include the given point.\n     */\n    public void extend(LatLon ll) {\n        if (ll.lat() < minLat) {\n            minLat = ll.lat();\n        }\n        if (ll.lon() < minLon) {\n            minLon = ll.lon();\n        }\n        if (ll.lat() > maxLat) {\n            maxLat = ll.lat();\n        }\n        if (ll.lon() > maxLon) {\n            maxLon = ll.lon();\n        }\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Converts the lat/lon bounding box to an object of type Rectangle2D.Double\n     * @return the bounding box to Rectangle2D.Double\n     */\n    public Rectangle2D.Double asRect() {\n        return new Rectangle2D.Double(min.lon(), min.lat(), max.lon()-min.lon(), max.lat()-min.lat());\n    }","id":97895,"modified_method":"/**\n     * Converts the lat/lon bounding box to an object of type Rectangle2D.Double\n     * @return the bounding box to Rectangle2D.Double\n     */\n    public Rectangle2D.Double asRect() {\n        return new Rectangle2D.Double(minLon, minLat, maxLon-minLon, maxLat-minLat);\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Bounds(String asString, String separator) throws IllegalArgumentException {\n        if (asString == null)\n            throw new IllegalArgumentException(tr(\"Parameter ''{0}'' must not be null\", \"asString\"));\n        String[] components = asString.split(separator);\n        if (components.length != 4)\n            throw new IllegalArgumentException(tr(\"Exactly four doubles excpected in string, got {0}\", components.length));\n        double[] values = new double[4];\n        for (int i=0; i<4; i++) {\n            try {\n                values[i] = Double.parseDouble(components[i]);\n            } catch(NumberFormatException e) {\n                throw new IllegalArgumentException(tr(\"Illegal double value ''{0}''\", components[i]));\n            }\n        }\n        if (!LatLon.isValidLat(values[0]))\n            throw new IllegalArgumentException(tr(\"Illegal latitude value ''{0}''\", values[0]));\n        if (!LatLon.isValidLon(values[1]))\n            throw new IllegalArgumentException(tr(\"Illegal longitude value ''{0}''\", values[1]));\n        if (!LatLon.isValidLat(values[2]))\n            throw new IllegalArgumentException(tr(\"Illegal latitude value ''{0}''\", values[2]));\n        if (!LatLon.isValidLon(values[3]))\n            throw new IllegalArgumentException(tr(\"Illegal latitude value ''{0}''\", values[3]));\n\n        this.min = new LatLon(values[0], values[1]);\n        this.max = new LatLon(values[2], values[3]);\n    }","id":97896,"modified_method":"public Bounds(String asString, String separator) throws IllegalArgumentException {\n        if (asString == null)\n            throw new IllegalArgumentException(tr(\"Parameter ''{0}'' must not be null\", \"asString\"));\n        String[] components = asString.split(separator);\n        if (components.length != 4)\n            throw new IllegalArgumentException(tr(\"Exactly four doubles excpected in string, got {0}\", components.length));\n        double[] values = new double[4];\n        for (int i=0; i<4; i++) {\n            try {\n                values[i] = Double.parseDouble(components[i]);\n            } catch(NumberFormatException e) {\n                throw new IllegalArgumentException(tr(\"Illegal double value ''{0}''\", components[i]));\n            }\n        }\n        if (!LatLon.isValidLat(values[0]))\n            throw new IllegalArgumentException(tr(\"Illegal latitude value ''{0}''\", values[0]));\n        if (!LatLon.isValidLon(values[1]))\n            throw new IllegalArgumentException(tr(\"Illegal longitude value ''{0}''\", values[1]));\n        if (!LatLon.isValidLat(values[2]))\n            throw new IllegalArgumentException(tr(\"Illegal latitude value ''{0}''\", values[2]));\n        if (!LatLon.isValidLon(values[3]))\n            throw new IllegalArgumentException(tr(\"Illegal latitude value ''{0}''\", values[3]));\n\n        this.minLat = values[0];\n        this.minLon = values[1];\n        this.maxLat = values[2];\n        this.maxLon = values[3];\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Creates new bounds around a coordinate pair <code>center<\/code>. The\n     * new bounds shall have an extension in latitude direction of <code>latExtent<\/code>,\n     * and in longitude direction of <code>lonExtent<\/code>.\n     *\n     * @param center  the center coordinate pair. Must not be null.\n     * @param latExtent the latitude extent. > 0 required.\n     * @param lonExtent the longitude extent. > 0 required.\n     * @throws IllegalArgumentException thrown if center is null\n     * @throws IllegalArgumentException thrown if latExtent <= 0\n     * @throws IllegalArgumentException thrown if lonExtent <= 0\n     */\n    public Bounds(LatLon center, double latExtent, double lonExtent) {\n        if (center == null)\n            throw new IllegalArgumentException(tr(\"Parameter ''{0}'' must not be null\", \"center\"));\n        if (latExtent <= 0.0)\n            throw new IllegalArgumentException(tr(\"Parameter ''{0}'' > 0.0 exptected, got {1}\", \"latExtent\", latExtent));\n        if (lonExtent <= 0.0)\n            throw new IllegalArgumentException(tr(\"Parameter ''{0}'' > 0.0 exptected, got {1}\", \"lonExtent\", lonExtent));\n\n        this.min = new LatLon(\n                center.lat() - latExtent / 2,\n                center.lon() - lonExtent / 2\n        );\n        this.max = new LatLon(\n                center.lat() + latExtent / 2,\n                center.lon() + lonExtent / 2\n        );\n    }","id":97897,"modified_method":"/**\n     * Creates new bounds around a coordinate pair <code>center<\/code>. The\n     * new bounds shall have an extension in latitude direction of <code>latExtent<\/code>,\n     * and in longitude direction of <code>lonExtent<\/code>.\n     *\n     * @param center  the center coordinate pair. Must not be null.\n     * @param latExtent the latitude extent. > 0 required.\n     * @param lonExtent the longitude extent. > 0 required.\n     * @throws IllegalArgumentException thrown if center is null\n     * @throws IllegalArgumentException thrown if latExtent <= 0\n     * @throws IllegalArgumentException thrown if lonExtent <= 0\n     */\n    public Bounds(LatLon center, double latExtent, double lonExtent) {\n        if (center == null)\n            throw new IllegalArgumentException(tr(\"Parameter ''{0}'' must not be null\", \"center\"));\n        if (latExtent <= 0.0)\n            throw new IllegalArgumentException(tr(\"Parameter ''{0}'' > 0.0 exptected, got {1}\", \"latExtent\", latExtent));\n        if (lonExtent <= 0.0)\n            throw new IllegalArgumentException(tr(\"Parameter ''{0}'' > 0.0 exptected, got {1}\", \"lonExtent\", lonExtent));\n\n        this.minLat = center.lat() - latExtent / 2;\n        this.minLon = center.lon() - lonExtent / 2;\n        this.maxLat = center.lat() + latExtent / 2;\n        this.maxLon = center.lon() + lonExtent / 2;\n    }","commit_id":"fe09c34dcc73fbb0ab825c556f7b91ad9b43bd39","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Returns the heading, in radians, that you have to use to get from\n     * this lat/lon to another.\n     *\n     * @param other the \"destination\" position\n     * @return heading\n     */\n    public double heading(LatLon other) {\n        double rv;\n        if (other.lat() == lat()) {\n            rv = (other.lon()>lon() ? Math.PI / 2 : Math.PI * 3 / 2);\n        } else {\n            rv = Math.atan((other.lon()-lon())/(other.lat()-lat()));\n            if (rv < 0) {\n                rv += Math.PI;\n            }\n            if (other.lon() < lon()) {\n                rv += Math.PI;\n            }\n        }\n        return rv;\n    }","id":97898,"modified_method":"/**\n     * Returns the heading, in radians, that you have to use to get from\n     * this lat/lon to another.\n     *\n     * (I don't know the original source of this formula, but see\n     * http://math.stackexchange.com/questions/720/how-to-calculate-a-heading-on-the-earths-surface\n     * for some hints how it is derived.)\n     * \n     * @param other the \"destination\" position\n     * @return heading in the range 0 <= hd < 2*PI\n     */\n    public double heading(LatLon other) {\n        double hd = atan2(sin(toRadians(this.lon() - other.lon())) * cos(toRadians(other.lat())),\n                cos(toRadians(this.lat())) * sin(toRadians(other.lat())) -\n                sin(toRadians(this.lat())) * cos(toRadians(other.lat())) * cos(toRadians(this.lon() - other.lon())));\n        hd %= 2 * PI;\n        if (hd < 0) {\n            hd += 2 * PI;\n        }\n        return hd;\n     }","commit_id":"0ed084f18b2c3f73d628222c719a886c812e93e6","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Test\n\tpublic void testResourceBundlesHierarchy() {\n\t\tResourceBundle resourceBundleA = _createResourceBundle(\n\t\t\t\"common-key\", \"th_TH_TH\", \"th_TH_TH\", \"th_TH_TH\");\n\t\tResourceBundle resourceBundleB = _createResourceBundle(\n\t\t\t\"common-key\", \"th_TH\", \"th_TH\", \"th_TH\");\n\t\tResourceBundle resourceBundleC = _createResourceBundle(\n\t\t\t\"common-key\", \"th\", \"th\", \"th\");\n\t\tResourceBundle resourceBundleD = _createResourceBundle(\n\t\t\t\"common-key\", \"root-bundle\", \"root-bundle\", \"root-bundle\");\n\n\t\tPortletConfig portletConfig = _genericPortlet.getPortletConfig();\n\t\tResourceBundle portletResourceBundleA = portletConfig.getResourceBundle(\n\t\t\tnew Locale(\"th\", \"TH\", \"TH\"));\n\t\tResourceBundle portletResourceBundleB = portletConfig.getResourceBundle(\n\t\t\tnew Locale(\"th\", \"TH\"));\n\t\tResourceBundle portletResourceBundleC = portletConfig.getResourceBundle(\n\t\t\tnew Locale(\"th\"));\n\t\tResourceBundle portletResourceBundleD = portletConfig.getResourceBundle(\n\t\t\tnew Locale(\"\"));\n\n\t\tServiceRegistration<ResourceBundle> serviceRegistrationA =\n\t\t\tregisterResourceBundle(resourceBundleA, \"th_TH_TH\");\n\t\tServiceRegistration<ResourceBundle> serviceRegistrationB =\n\t\t\tregisterResourceBundle(resourceBundleB, \"th_TH\");\n\t\tServiceRegistration<ResourceBundle> serviceRegistrationC =\n\t\t\tregisterResourceBundle(resourceBundleC, \"th\");\n\t\tServiceRegistration<ResourceBundle> serviceRegistrationD =\n\t\t\tregisterResourceBundle(resourceBundleD, \"\");\n\n\t\tAssert.assertEquals(\n\t\t\t\"th_TH_TH\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleA, \"th_TH_TH\"));\n\t\tAssert.assertEquals(\n\t\t\t\"th_TH\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleA, \"th_TH\"));\n\t\tAssert.assertEquals(\n\t\t\t\"th\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleA, \"th\"));\n\t\tAssert.assertEquals(\n\t\t\t\"root-bundle\",\n\t\t\tResourceBundleUtil.getString(\n\t\t\t\tportletResourceBundleA, \"root-bundle\"));\n\t\tAssert.assertEquals(\n\t\t\t\"th_TH_TH\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleA, \"common-key\"));\n\n\t\tAssert.assertEquals(\n\t\t\t\"th_TH\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleB, \"common-key\"));\n\t\tAssert.assertTrue(!portletResourceBundleB.containsKey(\"th_TH_TH\"));\n\n\t\tAssert.assertEquals(\n\t\t\t\"th\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleC, \"common-key\"));\n\t\tAssert.assertTrue(!portletResourceBundleC.containsKey(\"th_TH\"));\n\n\t\tAssert.assertEquals(\n\t\t\t\"root-bundle\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleD, \"common-key\"));\n\t\tAssert.assertTrue(!portletResourceBundleD.containsKey(\"th\"));\n\n\t\tserviceRegistrationA.unregister();\n\n\t\tAssert.assertTrue(!portletResourceBundleA.containsKey(\"th_TH_TH\"));\n\t\tAssert.assertEquals(\n\t\t\t\"th_TH\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleA, \"common-key\"));\n\n\t\tserviceRegistrationB.unregister();\n\n\t\tAssert.assertTrue(!portletResourceBundleA.containsKey(\"th_TH\"));\n\t\tAssert.assertEquals(\n\t\t\t\"th\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleA, \"common-key\"));\n\n\t\tserviceRegistrationC.unregister();\n\n\t\tAssert.assertTrue(!portletResourceBundleA.containsKey(\"th\"));\n\t\tAssert.assertEquals(\n\t\t\t\"root-bundle\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleA, \"common-key\"));\n\n\t\tserviceRegistrationD.unregister();\n\n\t\tAssert.assertTrue(!portletResourceBundleA.containsKey(\"root-bundle\"));\n\t\tAssert.assertTrue(!portletResourceBundleA.containsKey(\"common-key\"));\n\t}","id":97899,"modified_method":"@Test\n\tpublic void testResourceBundlesHierarchy() {\n\t\tPortletConfig portletConfig = _genericPortlet.getPortletConfig();\n\t\tResourceBundle portletResourceBundleA = portletConfig.getResourceBundle(\n\t\t\tnew Locale(\"th\", \"TH\", \"TH\"));\n\t\tResourceBundle portletResourceBundleB = portletConfig.getResourceBundle(\n\t\t\tnew Locale(\"th\", \"TH\"));\n\t\tResourceBundle portletResourceBundleC = portletConfig.getResourceBundle(\n\t\t\tnew Locale(\"th\"));\n\t\tResourceBundle portletResourceBundleD = portletConfig.getResourceBundle(\n\t\t\tnew Locale(\"\"));\n\n\t\tServiceRegistration<ResourceBundle> serviceRegistrationA =\n\t\t\tregisterResourceBundle(\n\t\t\t\t_createResourceBundle(\n\t\t\t\t\t\"common-key\", \"th_TH_TH\", \"th_TH_TH\", \"th_TH_TH\"),\n\t\t\t\t\"th_TH_TH\");\n\t\tServiceRegistration<ResourceBundle> serviceRegistrationB =\n\t\t\tregisterResourceBundle(\n\t\t\t\t_createResourceBundle(\"common-key\", \"th_TH\", \"th_TH\", \"th_TH\"),\n\t\t\t\t\"th_TH\");\n\t\tServiceRegistration<ResourceBundle> serviceRegistrationC =\n\t\t\tregisterResourceBundle(\n\t\t\t\t_createResourceBundle(\"common-key\", \"th\", \"th\", \"th\"), \"th\");\n\t\tServiceRegistration<ResourceBundle> serviceRegistrationD =\n\t\t\tregisterResourceBundle(\n\t\t\t\t_createResourceBundle(\n\t\t\t\t\t\"common-key\", \"root-bundle\", \"root-bundle\", \"root-bundle\"),\n\t\t\t\t\"\");\n\n\t\tAssert.assertEquals(\n\t\t\t\"th_TH_TH\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleA, \"th_TH_TH\"));\n\t\tAssert.assertEquals(\n\t\t\t\"th_TH\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleA, \"th_TH\"));\n\t\tAssert.assertEquals(\n\t\t\t\"th\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleA, \"th\"));\n\t\tAssert.assertEquals(\n\t\t\t\"root-bundle\",\n\t\t\tResourceBundleUtil.getString(\n\t\t\t\tportletResourceBundleA, \"root-bundle\"));\n\t\tAssert.assertEquals(\n\t\t\t\"th_TH_TH\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleA, \"common-key\"));\n\n\t\tAssert.assertEquals(\n\t\t\t\"th_TH\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleB, \"common-key\"));\n\t\tAssert.assertTrue(!portletResourceBundleB.containsKey(\"th_TH_TH\"));\n\n\t\tAssert.assertEquals(\n\t\t\t\"th\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleC, \"common-key\"));\n\t\tAssert.assertTrue(!portletResourceBundleC.containsKey(\"th_TH\"));\n\n\t\tAssert.assertEquals(\n\t\t\t\"root-bundle\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleD, \"common-key\"));\n\t\tAssert.assertTrue(!portletResourceBundleD.containsKey(\"th\"));\n\n\t\tserviceRegistrationA.unregister();\n\n\t\tAssert.assertTrue(!portletResourceBundleA.containsKey(\"th_TH_TH\"));\n\t\tAssert.assertEquals(\n\t\t\t\"th_TH\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleA, \"common-key\"));\n\n\t\tserviceRegistrationB.unregister();\n\n\t\tAssert.assertTrue(!portletResourceBundleA.containsKey(\"th_TH\"));\n\t\tAssert.assertEquals(\n\t\t\t\"th\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleA, \"common-key\"));\n\n\t\tserviceRegistrationC.unregister();\n\n\t\tAssert.assertTrue(!portletResourceBundleA.containsKey(\"th\"));\n\t\tAssert.assertEquals(\n\t\t\t\"root-bundle\",\n\t\t\tResourceBundleUtil.getString(portletResourceBundleA, \"common-key\"));\n\n\t\tserviceRegistrationD.unregister();\n\n\t\tAssert.assertTrue(!portletResourceBundleA.containsKey(\"root-bundle\"));\n\t\tAssert.assertTrue(!portletResourceBundleA.containsKey(\"common-key\"));\n\t}","commit_id":"3835a6c73ed7a639476bd56606c0ba102cddde34","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testResourceBundlesOverride() {\n\t\tResourceBundle resourceBundleA = _createResourceBundle(\n\t\t\t\"key\", \"value\", \"this\", \"esto2\");\n\n\t\tMap<String, Object> properties = new HashMap<>();\n\t\tproperties.put(\"javax.portlet.name\", TestPortlet.PORTLET_NAME);\n\t\tproperties.put(\"language.id\", \"es_ES\");\n\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\t\tServiceRegistration<ResourceBundle> serviceRegistration =\n\t\t\tregistry.registerService(\n\t\t\t\tResourceBundle.class, resourceBundleA, properties);\n\n\t\ttry {\n\t\t\tPortletConfig portletConfig = _genericPortlet.getPortletConfig();\n\n\t\t\tLocale locale = LocaleUtil.fromLanguageId(\"es_ES\");\n\n\t\t\tResourceBundle resourceBundle = portletConfig.getResourceBundle(\n\t\t\t\tlocale);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"value\", ResourceBundleUtil.getString(resourceBundle, \"key\"));\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"esto2\", ResourceBundleUtil.getString(resourceBundle, \"this\"));\n\t\t}\n\t\tfinally {\n\t\t\tserviceRegistration.unregister();\n\t\t}\n\t}","id":97900,"modified_method":"@Test\n\tpublic void testResourceBundlesOverride() {\n\t\tMap<String, Object> properties = new HashMap<>();\n\t\tproperties.put(\"javax.portlet.name\", TestPortlet.PORTLET_NAME);\n\t\tproperties.put(\"language.id\", \"es_ES\");\n\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\t\tServiceRegistration<ResourceBundle> serviceRegistration =\n\t\t\tregistry.registerService(\n\t\t\t\tResourceBundle.class,\n\t\t\t\t_createResourceBundle(\"key\", \"value\", \"this\", \"esto2\"),\n\t\t\t\tproperties);\n\n\t\ttry {\n\t\t\tPortletConfig portletConfig = _genericPortlet.getPortletConfig();\n\n\t\t\tLocale locale = LocaleUtil.fromLanguageId(\"es_ES\");\n\n\t\t\tResourceBundle resourceBundle = portletConfig.getResourceBundle(\n\t\t\t\tlocale);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"value\", ResourceBundleUtil.getString(resourceBundle, \"key\"));\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"esto2\", ResourceBundleUtil.getString(resourceBundle, \"this\"));\n\t\t}\n\t\tfinally {\n\t\t\tserviceRegistration.unregister();\n\t\t}\n\t}","commit_id":"3835a6c73ed7a639476bd56606c0ba102cddde34","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n\n        CamelContext context = routeContext.getCamelContext();\n\n        // the default binding mode can be overridden per rest verb\n        String mode = context.getRestConfiguration().getBindingMode().name();\n        if (bindingMode != null) {\n            mode = bindingMode.name();\n        }\n\n        // skip by default\n        boolean skip = skipBindingOnErrorCode == null || skipBindingOnErrorCode;\n\n        if (mode == null || \"off\".equals(mode)) {\n            // binding mode is off, so create a off mode binding processor\n            return new RestBindingProcessor(null, null, null, null, consumes, produces, mode, skip);\n        }\n\n        // setup json data format\n        DataFormat json;\n        DataFormat outJson;\n\n        String name = context.getRestConfiguration().getJsonDataFormat();\n        if (name == null) {\n            // this will create a new instance as we use the default name\n            name = \"json-jackson\";\n            json = context.resolveDataFormat(name);\n            outJson = context.resolveDataFormat(name);\n        } else {\n            json = context.resolveDataFormat(name);\n            // for out we need to make a new instance of the same class\n            outJson = context.getInjector().newInstance(json.getClass(), json);\n        }\n\n        // is json binding required?\n        if (mode.contains(\"json\") && json == null) {\n            throw new IllegalArgumentException(\"JSon DataFormat \" + name + \" not found.\");\n        }\n\n        if (json != null) {\n            Class<?> clazz = null;\n            if (type != null) {\n                String typeName = type.endsWith(\"[]\") ? type.substring(0, type.length() - 2) : type;\n                clazz = context.getClassResolver().resolveMandatoryClass(typeName);\n            }\n            if (clazz != null) {\n                IntrospectionSupport.setProperty(context.getTypeConverter(), json, \"unmarshalType\", clazz);\n                IntrospectionSupport.setProperty(context.getTypeConverter(), json, \"useList\", type.endsWith(\"[]\"));\n            }\n            setAdditionalConfiguration(context, json);\n            context.addService(json);\n\n            Class<?> outClazz = null;\n            if (outType != null) {\n                String typeName = outType.endsWith(\"[]\") ? outType.substring(0, outType.length() - 2) : outType;\n                outClazz = context.getClassResolver().resolveMandatoryClass(typeName);\n            }\n            if (outClazz != null) {\n                IntrospectionSupport.setProperty(context.getTypeConverter(), outJson, \"unmarshalType\", outClazz);\n                IntrospectionSupport.setProperty(context.getTypeConverter(), outJson, \"useList\", outType.endsWith(\"[]\"));\n            }\n            setAdditionalConfiguration(context, outJson);\n            context.addService(outJson);\n        }\n\n        // setup xml data format\n        // setup json data format\n        DataFormat jaxb;\n        DataFormat outJaxb;\n\n        name = context.getRestConfiguration().getXmlDataFormat();\n        if (name == null) {\n            // this will create a new instance as we use the default name\n            name = \"jaxb\";\n            jaxb = context.resolveDataFormat(name);\n            outJaxb = context.resolveDataFormat(name);\n        } else {\n            jaxb = context.resolveDataFormat(name);\n            // for out we need to make a new instance of the same class\n            outJaxb = context.getInjector().newInstance(jaxb.getClass(), json);\n        }\n        // is xml binding required?\n        if (mode.contains(\"xml\") && jaxb == null) {\n            throw new IllegalArgumentException(\"XML DataFormat \" + name + \" not found.\");\n        }\n\n        if (jaxb != null) {\n            Class<?> clazz = null;\n            if (type != null) {\n                String typeName = type.endsWith(\"[]\") ? type.substring(0, type.length() - 2) : type;\n                clazz = context.getClassResolver().resolveMandatoryClass(typeName);\n            }\n            if (clazz != null) {\n                JAXBContext jc = JAXBContext.newInstance(clazz);\n                IntrospectionSupport.setProperty(context.getTypeConverter(), jaxb, \"context\", jc);\n            }\n            if (context.getRestConfiguration().getDataFormatProperties() != null) {\n                IntrospectionSupport.setProperties(context.getTypeConverter(), jaxb, context.getRestConfiguration().getDataFormatProperties());\n            }\n            setAdditionalConfiguration(context, jaxb);\n            context.addService(jaxb);\n\n            Class<?> outClazz = null;\n            if (outType != null) {\n                String typeName = outType.endsWith(\"[]\") ? outType.substring(0, outType.length() - 2) : outType;\n                outClazz = context.getClassResolver().resolveMandatoryClass(typeName);\n            }\n            if (outClazz != null) {\n                JAXBContext jc = JAXBContext.newInstance(outClazz);\n                IntrospectionSupport.setProperty(context.getTypeConverter(), outJaxb, \"context\", jc);\n            } else if (clazz != null) {\n                // fallback and use the context from the input\n                JAXBContext jc = JAXBContext.newInstance(clazz);\n                IntrospectionSupport.setProperty(context.getTypeConverter(), outJaxb, \"context\", jc);\n            }\n            setAdditionalConfiguration(context, outJaxb);\n            context.addService(outJaxb);\n        }\n\n        return new RestBindingProcessor(json, jaxb, outJson, outJaxb, consumes, produces, mode, skip);\n    }","id":97901,"modified_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n\n        CamelContext context = routeContext.getCamelContext();\n\n        // the default binding mode can be overridden per rest verb\n        String mode = context.getRestConfiguration().getBindingMode().name();\n        if (bindingMode != null) {\n            mode = bindingMode.name();\n        }\n\n        // skip by default\n        boolean skip = skipBindingOnErrorCode == null || skipBindingOnErrorCode;\n\n        if (mode == null || \"off\".equals(mode)) {\n            // binding mode is off, so create a off mode binding processor\n            return new RestBindingProcessor(null, null, null, null, consumes, produces, mode, skip);\n        }\n\n        // setup json data format\n        String name = context.getRestConfiguration().getJsonDataFormat();\n        if (name != null) {\n            // must only be a name, not refer to an existing instance\n            Object instance = context.getRegistry().lookupByName(name);\n            if (instance != null) {\n                throw new IllegalArgumentException(\"JsonDataFormat name: \" + name + \" must not be an existing bean instance from the registry\");\n            }\n        } else {\n            name = \"json-jackson\";\n        }\n        // this will create a new instance as the name was not already pre-created\n        DataFormat json = context.resolveDataFormat(name);\n        DataFormat outJson = context.resolveDataFormat(name);\n\n        // is json binding required?\n        if (mode.contains(\"json\") && json == null) {\n            throw new IllegalArgumentException(\"JSon DataFormat \" + name + \" not found.\");\n        }\n\n        if (json != null) {\n            Class<?> clazz = null;\n            if (type != null) {\n                String typeName = type.endsWith(\"[]\") ? type.substring(0, type.length() - 2) : type;\n                clazz = context.getClassResolver().resolveMandatoryClass(typeName);\n            }\n            if (clazz != null) {\n                IntrospectionSupport.setProperty(context.getTypeConverter(), json, \"unmarshalType\", clazz);\n                IntrospectionSupport.setProperty(context.getTypeConverter(), json, \"useList\", type.endsWith(\"[]\"));\n            }\n            setAdditionalConfiguration(context, json);\n            context.addService(json);\n\n            Class<?> outClazz = null;\n            if (outType != null) {\n                String typeName = outType.endsWith(\"[]\") ? outType.substring(0, outType.length() - 2) : outType;\n                outClazz = context.getClassResolver().resolveMandatoryClass(typeName);\n            }\n            if (outClazz != null) {\n                IntrospectionSupport.setProperty(context.getTypeConverter(), outJson, \"unmarshalType\", outClazz);\n                IntrospectionSupport.setProperty(context.getTypeConverter(), outJson, \"useList\", outType.endsWith(\"[]\"));\n            }\n            setAdditionalConfiguration(context, outJson);\n            context.addService(outJson);\n        }\n\n        // setup xml data format\n        name = context.getRestConfiguration().getXmlDataFormat();\n        if (name != null) {\n            // must only be a name, not refer to an existing instance\n            Object instance = context.getRegistry().lookupByName(name);\n            if (instance != null) {\n                throw new IllegalArgumentException(\"XmlDataFormat name: \" + name + \" must not be an existing bean instance from the registry\");\n            }\n        } else {\n            name = \"jaxb\";\n        }\n        // this will create a new instance as the name was not already pre-created\n        DataFormat jaxb = context.resolveDataFormat(name);\n        DataFormat outJaxb = context.resolveDataFormat(name);\n\n        // is xml binding required?\n        if (mode.contains(\"xml\") && jaxb == null) {\n            throw new IllegalArgumentException(\"XML DataFormat \" + name + \" not found.\");\n        }\n\n        if (jaxb != null) {\n            Class<?> clazz = null;\n            if (type != null) {\n                String typeName = type.endsWith(\"[]\") ? type.substring(0, type.length() - 2) : type;\n                clazz = context.getClassResolver().resolveMandatoryClass(typeName);\n            }\n            if (clazz != null) {\n                JAXBContext jc = JAXBContext.newInstance(clazz);\n                IntrospectionSupport.setProperty(context.getTypeConverter(), jaxb, \"context\", jc);\n            }\n            if (context.getRestConfiguration().getDataFormatProperties() != null) {\n                IntrospectionSupport.setProperties(context.getTypeConverter(), jaxb, context.getRestConfiguration().getDataFormatProperties());\n            }\n            setAdditionalConfiguration(context, jaxb);\n            context.addService(jaxb);\n\n            Class<?> outClazz = null;\n            if (outType != null) {\n                String typeName = outType.endsWith(\"[]\") ? outType.substring(0, outType.length() - 2) : outType;\n                outClazz = context.getClassResolver().resolveMandatoryClass(typeName);\n            }\n            if (outClazz != null) {\n                JAXBContext jc = JAXBContext.newInstance(outClazz);\n                IntrospectionSupport.setProperty(context.getTypeConverter(), outJaxb, \"context\", jc);\n            } else if (clazz != null) {\n                // fallback and use the context from the input\n                JAXBContext jc = JAXBContext.newInstance(clazz);\n                IntrospectionSupport.setProperty(context.getTypeConverter(), outJaxb, \"context\", jc);\n            }\n            setAdditionalConfiguration(context, outJaxb);\n            context.addService(outJaxb);\n        }\n\n        return new RestBindingProcessor(json, jaxb, outJson, outJaxb, consumes, produces, mode, skip);\n    }","commit_id":"bb72c560bc7b92e1b5d664a38aefa8257d1b8c27","url":"https://github.com/apache/camel"},{"original_method":"public TreeElement process(TreeElement element, boolean addImports, boolean uncompleteCode) {\n    IElementType elementType = element.getElementType();\n    if (elementType == JAVA_CODE_REFERENCE || elementType == REFERENCE_EXPRESSION) {\n      if (elementType == JAVA_CODE_REFERENCE || element.getTreeParent().getElementType() == REFERENCE_EXPRESSION || uncompleteCode) {\n        final PsiJavaCodeReferenceElement ref = (PsiJavaCodeReferenceElement)SourceTreeToPsiMap.treeElementToPsi(element);\n        final PsiTypeElement[] typeParameters = ref.getParameterList().getTypeParameterElements();\n        for (int i = 0; i < typeParameters.length; i++) {\n          process((TreeElement)SourceTreeToPsiMap.psiElementToTree(typeParameters[i]), addImports, uncompleteCode);\n        }\n\n        boolean rightKind = true;\n        if (elementType == JAVA_CODE_REFERENCE) {\n          int kind = ((PsiJavaCodeReferenceElementImpl)element).getKind();\n          rightKind = kind == PsiJavaCodeReferenceElementImpl.CLASS_NAME_KIND ||\n            kind == PsiJavaCodeReferenceElementImpl.CLASS_OR_PACKAGE_NAME_KIND;\n        }\n\n        if (rightKind) {\n          boolean isInsideDocComment = TreeUtil.findParent(element, JavaDocElementType.DOC_COMMENT) != null;\n          boolean isShort = !((SourceJavaCodeReference)element).isQualified();\n          if (!makeFQ(isInsideDocComment)) {\n            if (isShort) return element; // short name already, no need to change\n          }\n          PsiElement refElement;\n          if (!uncompleteCode) {\n            refElement = ref.resolve();\n          }\n          else {\n            PsiResolveHelper helper = element.getManager().getResolveHelper();\n            refElement = helper.resolveReferencedClass(\n                ((SourceJavaCodeReference)element).getClassNameText(),\n              SourceTreeToPsiMap.treeElementToPsi(element)\n            );\n          }\n          if (refElement instanceof PsiClass) {\n            if (makeFQ(isInsideDocComment)) {\n              String qName = ((PsiClass)refElement).getQualifiedName();\n              if (qName == null) return element;\n              PsiFile file = SourceTreeToPsiMap.treeElementToPsi(element).getContainingFile();\n              if (ImportHelper.isImplicitlyImported(qName, file)) {\n                if (isShort) return element;\n                return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n              }\n              if (file instanceof PsiJavaFile) {\n                String thisPackageName = ((PsiJavaFile)file).getPackageName();\n                if (ImportHelper.hasPackage(qName, thisPackageName)) {\n                  if (!isShort) {\n                    return (TreeElement)makeShortReference(\n                      (CompositeElement)element,\n                      (PsiClass)refElement,\n                      addImports,\n                      uncompleteCode\n                    );\n                  }\n                }\n              }\n              return (TreeElement)replaceReferenceWithFQ(element, (PsiClass)refElement);\n            }\n            else {\n              return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n            }\n          }\n        }\n      }\n    }\n\n    if (element instanceof CompositeElement) {\n      ChameleonTransforming.transformChildren(element);\n      for (TreeElement child = (TreeElement)element.getFirstChildNode(); child != null; child = child.getTreeNext()) {\n        child = process(child, addImports, uncompleteCode);\n      }\n    }\n\n    return element;\n  }","id":97902,"modified_method":"public TreeElement process(TreeElement element, boolean addImports, boolean uncompleteCode) {\n    IElementType elementType = element.getElementType();\n    if (elementType == JAVA_CODE_REFERENCE || elementType == REFERENCE_EXPRESSION) {\n      if (elementType == JAVA_CODE_REFERENCE || element.getTreeParent().getElementType() == REFERENCE_EXPRESSION || uncompleteCode) {\n        final PsiJavaCodeReferenceElement ref = (PsiJavaCodeReferenceElement)SourceTreeToPsiMap.treeElementToPsi(element);\n        final PsiTypeElement[] typeParameters = ref.getParameterList().getTypeParameterElements();\n        for (PsiTypeElement typeParameter : typeParameters) {\n          process((TreeElement)SourceTreeToPsiMap.psiElementToTree(typeParameter), addImports, uncompleteCode);\n        }\n\n        boolean rightKind = true;\n        if (elementType == JAVA_CODE_REFERENCE) {\n          int kind = ((PsiJavaCodeReferenceElementImpl)element).getKind();\n          rightKind = kind == PsiJavaCodeReferenceElementImpl.CLASS_NAME_KIND ||\n            kind == PsiJavaCodeReferenceElementImpl.CLASS_OR_PACKAGE_NAME_KIND;\n        }\n\n        if (rightKind) {\n          boolean isInsideDocComment = TreeUtil.findParent(element, JavaDocElementType.DOC_COMMENT) != null;\n          boolean isShort = !((SourceJavaCodeReference)element).isQualified();\n          if (!makeFQ(isInsideDocComment)) {\n            if (isShort) return element; // short name already, no need to change\n          }\n          PsiElement refElement;\n          if (!uncompleteCode) {\n            refElement = ref.resolve();\n          }\n          else {\n            PsiResolveHelper helper = element.getManager().getResolveHelper();\n            refElement = helper.resolveReferencedClass(\n                ((SourceJavaCodeReference)element).getClassNameText(),\n              SourceTreeToPsiMap.treeElementToPsi(element)\n            );\n          }\n          if (refElement instanceof PsiClass) {\n            if (makeFQ(isInsideDocComment)) {\n              String qName = ((PsiClass)refElement).getQualifiedName();\n              if (qName == null) return element;\n              PsiFile file = SourceTreeToPsiMap.treeElementToPsi(element).getContainingFile();\n              if (ImportHelper.isImplicitlyImported(qName, file)) {\n                if (isShort) return element;\n                return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n              }\n              if (file instanceof PsiJavaFile) {\n                String thisPackageName = ((PsiJavaFile)file).getPackageName();\n                if (ImportHelper.hasPackage(qName, thisPackageName)) {\n                  if (!isShort) {\n                    return (TreeElement)makeShortReference(\n                      (CompositeElement)element,\n                      (PsiClass)refElement,\n                      addImports,\n                      uncompleteCode\n                    );\n                  }\n                }\n              }\n              return (TreeElement)replaceReferenceWithFQ(element, (PsiClass)refElement);\n            }\n            else {\n              return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n            }\n          }\n        }\n      }\n    }\n\n    if (element instanceof CompositeElement) {\n      ChameleonTransforming.transformChildren(element);\n      for (TreeElement child = (TreeElement)element.getFirstChildNode(); child != null; child = child.getTreeNext()) {\n        child = process(child, addImports, uncompleteCode);\n      }\n    }\n\n    return element;\n  }","commit_id":"c365c651226e37cc9749fb94cd04d6692f62e230","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ASTNode makeShortReference(\n    CompositeElement reference,\n    PsiClass refClass,\n    boolean addImports,\n    boolean uncompleteCode\n    ) {\n    if (refClass.getContainingClass() != null) {\n      PsiClass parentClass = refClass.getContainingClass();\n      PsiJavaCodeReferenceElement psiReference = (PsiJavaCodeReferenceElement)SourceTreeToPsiMap.treeElementToPsi(reference);\n      PsiManager manager = parentClass.getManager();\n      if (manager.getResolveHelper().isAccessible(refClass, psiReference, null)) {\n        for (ASTNode parent = reference.getTreeParent(); parent != null; parent = parent.getTreeParent()) {\n          PsiElement parentPsi = SourceTreeToPsiMap.treeElementToPsi(parent);\n          if (parentPsi instanceof PsiClass) {\n            PsiClass inner = ((PsiClass)parentPsi).findInnerClassByName(psiReference.getReferenceName(), true);\n            if (inner != null) {\n              if (inner == refClass) return replaceReferenceWithShort(reference);\n              return reference;\n            }\n            if (InheritanceUtil.isInheritorOrSelf((PsiClass)parentPsi, parentClass, true)) {\n              return replaceReferenceWithShort(reference);\n            }\n          }\n        }\n      }\n\n      if (!mySettings.INSERT_INNER_CLASS_IMPORTS) {\n        final ASTNode qualifier = reference.findChildByRole(ChildRole.QUALIFIER);\n        if (qualifier != null) {\n\n          makeShortReference((CompositeElement)qualifier, parentClass, addImports, uncompleteCode);\n        }\n        return reference;\n      }\n    }\n\n    PsiFile file = SourceTreeToPsiMap.treeElementToPsi(reference).getContainingFile();\n    PsiManager manager = file.getManager();\n    PsiResolveHelper helper = manager.getResolveHelper();\n    if (addImports) {\n      if (!myImportHelper.addImport(file, refClass)) {\n        return reference;\n      }\n      if (isSafeToShortenReference(reference, refClass, helper)) {\n        reference = replaceReferenceWithShort(reference);\n      }\n    }\n    else {\n      PsiClass curRefClass = helper.resolveReferencedClass(\n        refClass.getName(),\n        SourceTreeToPsiMap.treeElementToPsi(reference)\n      );\n      if (manager.areElementsEquivalent(refClass, curRefClass)) {\n        reference = replaceReferenceWithShort(reference);\n      }\n    }\n    return reference;\n  }","id":97903,"modified_method":"private ASTNode makeShortReference(\n    CompositeElement reference,\n    PsiClass refClass,\n    boolean addImports,\n    boolean uncompleteCode\n    ) {\n    if (refClass.getContainingClass() != null) {\n      PsiClass parentClass = refClass.getContainingClass();\n      PsiJavaCodeReferenceElement psiReference = (PsiJavaCodeReferenceElement)SourceTreeToPsiMap.treeElementToPsi(reference);\n      PsiManager manager = parentClass.getManager();\n      final PsiResolveHelper resolveHelper = manager.getResolveHelper();\n      final ASTNode qualifier = reference.findChildByRole(ChildRole.QUALIFIER);\n      if (!resolveHelper.isAccessible(refClass, psiReference, null)) {\n        if (qualifier != null) makeShortReference((CompositeElement)qualifier, parentClass, addImports, uncompleteCode);\n        return reference;\n      }\n      final PsiClass aClass = resolveHelper.resolveReferencedClass(psiReference.getReferenceName(), psiReference);\n      if (!manager.areElementsEquivalent(aClass, refClass)) {\n        if (qualifier != null) makeShortReference((CompositeElement)qualifier, parentClass, addImports, uncompleteCode);\n        return reference;\n      }\n\n      if (!mySettings.INSERT_INNER_CLASS_IMPORTS) {\n        if (qualifier != null) makeShortReference((CompositeElement)qualifier, parentClass, addImports, uncompleteCode);\n        return reference;\n      }\n    }\n\n    PsiFile file = SourceTreeToPsiMap.treeElementToPsi(reference).getContainingFile();\n    PsiManager manager = file.getManager();\n    PsiResolveHelper helper = manager.getResolveHelper();\n    if (addImports) {\n      if (!myImportHelper.addImport(file, refClass)) {\n        return reference;\n      }\n      if (isSafeToShortenReference(reference, refClass, helper)) {\n        reference = replaceReferenceWithShort(reference);\n      }\n    }\n    else {\n      PsiClass curRefClass = helper.resolveReferencedClass(\n        refClass.getName(),\n        SourceTreeToPsiMap.treeElementToPsi(reference)\n      );\n      if (manager.areElementsEquivalent(refClass, curRefClass)) {\n        reference = replaceReferenceWithShort(reference);\n      }\n    }\n    return reference;\n  }","commit_id":"c365c651226e37cc9749fb94cd04d6692f62e230","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeElement process(TreeElement element, boolean addImports, boolean uncompleteCode) {\n    IElementType elementType = element.getElementType();\n    if (elementType == JAVA_CODE_REFERENCE || elementType == REFERENCE_EXPRESSION) {\n      if (elementType == JAVA_CODE_REFERENCE || element.getTreeParent().getElementType() == REFERENCE_EXPRESSION || uncompleteCode) {\n        final PsiJavaCodeReferenceElement ref = (PsiJavaCodeReferenceElement)SourceTreeToPsiMap.treeElementToPsi(element);\n        final PsiTypeElement[] typeParameters = ref.getParameterList().getTypeParameterElements();\n        for (PsiTypeElement typeParameter : typeParameters) {\n          process((TreeElement)SourceTreeToPsiMap.psiElementToTree(typeParameter), addImports, uncompleteCode);\n        }\n\n        boolean rightKind = true;\n        if (elementType == JAVA_CODE_REFERENCE) {\n          int kind = ((PsiJavaCodeReferenceElementImpl)element).getKind();\n          rightKind = kind == PsiJavaCodeReferenceElementImpl.CLASS_NAME_KIND ||\n            kind == PsiJavaCodeReferenceElementImpl.CLASS_OR_PACKAGE_NAME_KIND;\n        }\n\n        if (rightKind) {\n          boolean isInsideDocComment = TreeUtil.findParent(element, JavaDocElementType.DOC_COMMENT) != null;\n          boolean isShort = !((SourceJavaCodeReference)element).isQualified();\n          if (!makeFQ(isInsideDocComment)) {\n            if (isShort) return element; // short name already, no need to change\n          }\n          PsiElement refElement;\n          if (!uncompleteCode) {\n            refElement = ref.resolve();\n          }\n          else {\n            PsiResolveHelper helper = element.getManager().getResolveHelper();\n            refElement = helper.resolveReferencedClass(\n                ((SourceJavaCodeReference)element).getClassNameText(),\n              SourceTreeToPsiMap.treeElementToPsi(element)\n            );\n          }\n          if (refElement instanceof PsiClass) {\n            if (makeFQ(isInsideDocComment)) {\n              String qName = ((PsiClass)refElement).getQualifiedName();\n              if (qName == null) return element;\n              PsiFile file = SourceTreeToPsiMap.treeElementToPsi(element).getContainingFile();\n              if (ImportHelper.isImplicitlyImported(qName, file)) {\n                if (isShort) return element;\n                return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n              }\n              if (file instanceof PsiJavaFile) {\n                String thisPackageName = ((PsiJavaFile)file).getPackageName();\n                if (ImportHelper.hasPackage(qName, thisPackageName)) {\n                  if (!isShort) {\n                    return (TreeElement)makeShortReference(\n                      (CompositeElement)element,\n                      (PsiClass)refElement,\n                      addImports,\n                      uncompleteCode\n                    );\n                  }\n                }\n              }\n              return (TreeElement)replaceReferenceWithFQ(element, (PsiClass)refElement);\n            }\n            else {\n              return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n            }\n          }\n        }\n      }\n    }\n\n    if (element instanceof CompositeElement) {\n      ChameleonTransforming.transformChildren(element);\n      for (TreeElement child = (TreeElement)element.getFirstChildNode(); child != null; child = child.getTreeNext()) {\n        child = process(child, addImports, uncompleteCode);\n      }\n    }\n\n    return element;\n  }","id":97904,"modified_method":"public TreeElement process(TreeElement element, boolean addImports, boolean uncompleteCode) {\n    IElementType elementType = element.getElementType();\n    if (elementType == JAVA_CODE_REFERENCE || elementType == REFERENCE_EXPRESSION) {\n      if (elementType == JAVA_CODE_REFERENCE || element.getTreeParent().getElementType() == REFERENCE_EXPRESSION || uncompleteCode) {\n        final PsiJavaCodeReferenceElement ref = (PsiJavaCodeReferenceElement)SourceTreeToPsiMap.treeElementToPsi(element);\n        final PsiTypeElement[] typeParameters = ref.getParameterList().getTypeParameterElements();\n        for (int i = 0; i < typeParameters.length; i++) {\n          process((TreeElement)SourceTreeToPsiMap.psiElementToTree(typeParameters[i]), addImports, uncompleteCode);\n        }\n\n        boolean rightKind = true;\n        if (elementType == JAVA_CODE_REFERENCE) {\n          int kind = ((PsiJavaCodeReferenceElementImpl)element).getKind();\n          rightKind = kind == PsiJavaCodeReferenceElementImpl.CLASS_NAME_KIND ||\n            kind == PsiJavaCodeReferenceElementImpl.CLASS_OR_PACKAGE_NAME_KIND;\n        }\n\n        if (rightKind) {\n          boolean isInsideDocComment = TreeUtil.findParent(element, JavaDocElementType.DOC_COMMENT) != null;\n          boolean isShort = !((SourceJavaCodeReference)element).isQualified();\n          if (!makeFQ(isInsideDocComment)) {\n            if (isShort) return element; // short name already, no need to change\n          }\n          PsiElement refElement;\n          if (!uncompleteCode) {\n            refElement = ref.resolve();\n          }\n          else {\n            PsiResolveHelper helper = element.getManager().getResolveHelper();\n            refElement = helper.resolveReferencedClass(\n                ((SourceJavaCodeReference)element).getClassNameText(),\n              SourceTreeToPsiMap.treeElementToPsi(element)\n            );\n          }\n          if (refElement instanceof PsiClass) {\n            if (makeFQ(isInsideDocComment)) {\n              String qName = ((PsiClass)refElement).getQualifiedName();\n              if (qName == null) return element;\n              PsiFile file = SourceTreeToPsiMap.treeElementToPsi(element).getContainingFile();\n              if (ImportHelper.isImplicitlyImported(qName, file)) {\n                if (isShort) return element;\n                return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n              }\n              if (file instanceof PsiJavaFile) {\n                String thisPackageName = ((PsiJavaFile)file).getPackageName();\n                if (ImportHelper.hasPackage(qName, thisPackageName)) {\n                  if (!isShort) {\n                    return (TreeElement)makeShortReference(\n                      (CompositeElement)element,\n                      (PsiClass)refElement,\n                      addImports,\n                      uncompleteCode\n                    );\n                  }\n                }\n              }\n              return (TreeElement)replaceReferenceWithFQ(element, (PsiClass)refElement);\n            }\n            else {\n              return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n            }\n          }\n        }\n      }\n    }\n\n    if (element instanceof CompositeElement) {\n      ChameleonTransforming.transformChildren(element);\n      for (TreeElement child = (TreeElement)element.getFirstChildNode(); child != null; child = child.getTreeNext()) {\n        child = process(child, addImports, uncompleteCode);\n      }\n    }\n\n    return element;\n  }","commit_id":"5e20450bca88180461c45261c33cf771730c7347","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ASTNode makeShortReference(\n    CompositeElement reference,\n    PsiClass refClass,\n    boolean addImports,\n    boolean uncompleteCode\n    ) {\n    if (refClass.getContainingClass() != null) {\n      PsiClass parentClass = refClass.getContainingClass();\n      PsiJavaCodeReferenceElement psiReference = (PsiJavaCodeReferenceElement)SourceTreeToPsiMap.treeElementToPsi(reference);\n      PsiManager manager = parentClass.getManager();\n      final PsiResolveHelper resolveHelper = manager.getResolveHelper();\n      final ASTNode qualifier = reference.findChildByRole(ChildRole.QUALIFIER);\n      if (!resolveHelper.isAccessible(refClass, psiReference, null)) {\n        if (qualifier != null) makeShortReference((CompositeElement)qualifier, parentClass, addImports, uncompleteCode);\n        return reference;\n      }\n      final PsiClass aClass = resolveHelper.resolveReferencedClass(psiReference.getReferenceName(), psiReference);\n      if (!manager.areElementsEquivalent(aClass, refClass)) {\n        if (qualifier != null) makeShortReference((CompositeElement)qualifier, parentClass, addImports, uncompleteCode);\n        return reference;\n      }\n\n      if (!mySettings.INSERT_INNER_CLASS_IMPORTS) {\n        if (qualifier != null) makeShortReference((CompositeElement)qualifier, parentClass, addImports, uncompleteCode);\n        return reference;\n      }\n    }\n\n    PsiFile file = SourceTreeToPsiMap.treeElementToPsi(reference).getContainingFile();\n    PsiManager manager = file.getManager();\n    PsiResolveHelper helper = manager.getResolveHelper();\n    if (addImports) {\n      if (!myImportHelper.addImport(file, refClass)) {\n        return reference;\n      }\n      if (isSafeToShortenReference(reference, refClass, helper)) {\n        reference = replaceReferenceWithShort(reference);\n      }\n    }\n    else {\n      PsiClass curRefClass = helper.resolveReferencedClass(\n        refClass.getName(),\n        SourceTreeToPsiMap.treeElementToPsi(reference)\n      );\n      if (manager.areElementsEquivalent(refClass, curRefClass)) {\n        reference = replaceReferenceWithShort(reference);\n      }\n    }\n    return reference;\n  }","id":97905,"modified_method":"private ASTNode makeShortReference(\n    CompositeElement reference,\n    PsiClass refClass,\n    boolean addImports,\n    boolean uncompleteCode\n    ) {\n    if (refClass.getContainingClass() != null) {\n      PsiClass parentClass = refClass.getContainingClass();\n      PsiJavaCodeReferenceElement psiReference = (PsiJavaCodeReferenceElement)SourceTreeToPsiMap.treeElementToPsi(reference);\n      PsiManager manager = parentClass.getManager();\n      if (manager.getResolveHelper().isAccessible(refClass, psiReference, null)) {\n        for (ASTNode parent = reference.getTreeParent(); parent != null; parent = parent.getTreeParent()) {\n          PsiElement parentPsi = SourceTreeToPsiMap.treeElementToPsi(parent);\n          if (parentPsi instanceof PsiClass) {\n            PsiClass inner = ((PsiClass)parentPsi).findInnerClassByName(psiReference.getReferenceName(), true);\n            if (inner != null) {\n              if (inner == refClass) return replaceReferenceWithShort(reference);\n              return reference;\n            }\n            if (InheritanceUtil.isInheritorOrSelf((PsiClass)parentPsi, parentClass, true)) {\n              return replaceReferenceWithShort(reference);\n            }\n          }\n        }\n      }\n\n      if (!mySettings.INSERT_INNER_CLASS_IMPORTS) {\n        final ASTNode qualifier = reference.findChildByRole(ChildRole.QUALIFIER);\n        if (qualifier != null) {\n\n          makeShortReference((CompositeElement)qualifier, parentClass, addImports, uncompleteCode);\n        }\n        return reference;\n      }\n    }\n\n    PsiFile file = SourceTreeToPsiMap.treeElementToPsi(reference).getContainingFile();\n    PsiManager manager = file.getManager();\n    PsiResolveHelper helper = manager.getResolveHelper();\n    if (addImports) {\n      if (!myImportHelper.addImport(file, refClass)) {\n        return reference;\n      }\n      if (isSafeToShortenReference(reference, refClass, helper)) {\n        reference = replaceReferenceWithShort(reference);\n      }\n    }\n    else {\n      PsiClass curRefClass = helper.resolveReferencedClass(\n        refClass.getName(),\n        SourceTreeToPsiMap.treeElementToPsi(reference)\n      );\n      if (manager.areElementsEquivalent(refClass, curRefClass)) {\n        reference = replaceReferenceWithShort(reference);\n      }\n    }\n    return reference;\n  }","commit_id":"5e20450bca88180461c45261c33cf771730c7347","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void encodeInformation(TreeElement element, ASTNode original) {\n    boolean encodeRefTargets = true;\n    if (original.getTreeParent() instanceof DummyHolderElement) {\n      DummyHolder dummyHolder = (DummyHolder)SourceTreeToPsiMap.treeElementToPsi(original.getTreeParent());\n      if (dummyHolder.getContext() == null && !dummyHolder.hasImports()) { // optimization\n        encodeRefTargets = false;\n      }\n    }\n    _encodeInformation(element, original, encodeRefTargets);\n  }","id":97906,"modified_method":"private static void encodeInformation(TreeElement element, ASTNode original) {\n    if (original instanceof CompositeElement) {\n      if (original.getElementType() == ElementType.JAVA_CODE_REFERENCE || original.getElementType() == ElementType.REFERENCE_EXPRESSION) {\n        encodeInformationInRef(element, original);\n      }\n      else if (original.getElementType() == ElementType.MODIFIER_LIST) {\n        if ((original.getTreeParent().getElementType() == ElementType.FIELD ||\n              original.getTreeParent().getElementType() == ElementType.METHOD)\n          && original.getTreeParent().getTreeParent().getElementType() == ElementType.CLASS &&\n          ((PsiClass)SourceTreeToPsiMap.treeElementToPsi(original.getTreeParent().getTreeParent())).isInterface()) {\n          element.putUserData(INTERFACE_MODIFIERS_FLAG_KEY, Boolean.TRUE);\n        }\n      }\n\n      ChameleonTransforming.transformChildren(element);\n      ChameleonTransforming.transformChildren(original);\n      TreeElement child = (TreeElement)element.getFirstChildNode();\n      ASTNode child1 = original.getFirstChildNode();\n      while (child != null) {\n        encodeInformation(child, child1);\n        child = child.getTreeNext();\n        child1 = child1.getTreeNext();\n      }\n    }\n  }","commit_id":"dca645376cb14379b98ccdb6f9afe190122349f7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static int checkTextRanges(PsiElement root) {\n    if (true) return 0;\n    TextRange range = root.getTextRange();\n    int off = range.getStartOffset();\n    PsiElement[] children = root.getChildren();\n    if (children.length != 0) {\n      for (int i = 0; i < children.length; i++) {\n        PsiElement child = children[i];\n        off += checkTextRanges(child);\n      }\n    }\n    else {\n      off += root.getTextLength();\n    }\n    LOG.assertTrue(off == range.getEndOffset());\n\n    String fileText = root.getContainingFile().getText();\n    LOG.assertTrue(root.getText().equals(fileText.substring(range.getStartOffset(), range.getEndOffset())));\n    if (root instanceof XmlTag) {\n      XmlTagValue value = ((XmlTag)root).getValue();\n      TextRange textRange = value.getTextRange();\n      LOG.assertTrue(value.getText().equals(fileText.substring(textRange.getStartOffset(), textRange.getEndOffset())));\n    }\n    return range.getLength();\n  }","id":97907,"modified_method":"public static int checkTextRanges(PsiElement root) {\n    if (true) return 0;\n    TextRange range = root.getTextRange();\n    int off = range.getStartOffset();\n    PsiElement[] children = root.getChildren();\n    if (children.length != 0) {\n      for (PsiElement child : children) {\n        off += checkTextRanges(child);\n      }\n    }\n    else {\n      off += root.getTextLength();\n    }\n    LOG.assertTrue(off == range.getEndOffset());\n\n    String fileText = root.getContainingFile().getText();\n    LOG.assertTrue(root.getText().equals(fileText.substring(range.getStartOffset(), range.getEndOffset())));\n    if (root instanceof XmlTag) {\n      XmlTagValue value = ((XmlTag)root).getValue();\n      TextRange textRange = value.getTextRange();\n      LOG.assertTrue(value.getText().equals(fileText.substring(textRange.getStartOffset(), textRange.getEndOffset())));\n    }\n    return range.getLength();\n  }","commit_id":"dca645376cb14379b98ccdb6f9afe190122349f7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ASTNode makeShortReference(\n    CompositeElement reference,\n    PsiClass refClass,\n    boolean addImports,\n    boolean uncompleteCode\n    ) {\n    if (refClass.getContainingClass() != null) {\n      PsiClass parentClass = refClass.getContainingClass();\n      PsiJavaCodeReferenceElement psiReference = (PsiJavaCodeReferenceElement)SourceTreeToPsiMap.treeElementToPsi(reference);\n      PsiManager manager = parentClass.getManager();\n      if (manager.getResolveHelper().isAccessible(refClass, psiReference, null)) {\n        for (ASTNode parent = reference.getTreeParent(); parent != null; parent = parent.getTreeParent()) {\n          PsiElement parentPsi = SourceTreeToPsiMap.treeElementToPsi(parent);\n          if (parentPsi instanceof PsiClass) {\n            PsiClass inner = ((PsiClass)parentPsi).findInnerClassByName(psiReference.getReferenceName(), true);\n            if (inner != null) {\n              if (inner == refClass) return replaceReferenceWithShort(reference);\n              return reference;\n            }\n            if (InheritanceUtil.isInheritorOrSelf((PsiClass)parentPsi, parentClass, true)) {\n              return replaceReferenceWithShort(reference);\n            }\n          }\n        }\n      }\n\n      if (!mySettings.INSERT_INNER_CLASS_IMPORTS) {\n        final ASTNode qualifier = reference.findChildByRole(ChildRole.QUALIFIER);\n        if (qualifier != null) {\n\n          makeShortReference((CompositeElement)qualifier, parentClass, addImports, uncompleteCode);\n        }\n        return reference;\n      }\n    }\n\n    PsiFile file = SourceTreeToPsiMap.treeElementToPsi(reference).getContainingFile();\n    PsiManager manager = file.getManager();\n    PsiResolveHelper helper = manager.getResolveHelper();\n    if (addImports) {\n      if (!myImportHelper.addImport(file, refClass)) {\n        return reference;\n      }\n      if (isSafeToShortenReference(reference, refClass, helper)) {\n        reference = replaceReferenceWithShort(reference);\n      }\n    }\n    else {\n      PsiClass curRefClass = helper.resolveReferencedClass(\n        refClass.getName(),\n        SourceTreeToPsiMap.treeElementToPsi(reference)\n      );\n      if (manager.areElementsEquivalent(refClass, curRefClass)) {\n        reference = replaceReferenceWithShort(reference);\n      }\n    }\n    return reference;\n  }","id":97908,"modified_method":"private ASTNode makeShortReference(\n    CompositeElement reference,\n    PsiClass refClass,\n    boolean addImports,\n    boolean uncompleteCode\n    ) {\n    if (refClass.getContainingClass() != null) {\n      PsiClass parentClass = refClass.getContainingClass();\n      PsiJavaCodeReferenceElement psiReference = (PsiJavaCodeReferenceElement)SourceTreeToPsiMap.treeElementToPsi(reference);\n      PsiManager manager = parentClass.getManager();\n      final PsiResolveHelper resolveHelper = manager.getResolveHelper();\n      if (resolveHelper.isAccessible(refClass, psiReference, null)) {\n        final PsiClass resolved = resolveHelper.resolveReferencedClass(psiReference.getReferenceName(), reference.getPsi());\n        if (manager.areElementsEquivalent(resolved, refClass)) {\n          return replaceReferenceWithShort(reference);\n        }\n      }\n\n      if (!mySettings.INSERT_INNER_CLASS_IMPORTS) {\n        final ASTNode qualifier = reference.findChildByRole(ChildRole.QUALIFIER);\n        if (qualifier != null) {\n\n          makeShortReference((CompositeElement)qualifier, parentClass, addImports, uncompleteCode);\n        }\n        return reference;\n      }\n    }\n\n    PsiFile file = SourceTreeToPsiMap.treeElementToPsi(reference).getContainingFile();\n    PsiManager manager = file.getManager();\n    PsiResolveHelper helper = manager.getResolveHelper();\n    if (addImports) {\n      if (!myImportHelper.addImport(file, refClass)) {\n        return reference;\n      }\n      if (isSafeToShortenReference(reference, refClass, helper)) {\n        reference = replaceReferenceWithShort(reference);\n      }\n    }\n    else {\n      PsiClass curRefClass = helper.resolveReferencedClass(\n        refClass.getName(),\n        SourceTreeToPsiMap.treeElementToPsi(reference)\n      );\n      if (manager.areElementsEquivalent(refClass, curRefClass)) {\n        reference = replaceReferenceWithShort(reference);\n      }\n    }\n    return reference;\n  }","commit_id":"dca645376cb14379b98ccdb6f9afe190122349f7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeElement process(TreeElement element, boolean addImports, boolean uncompleteCode) {\n    IElementType elementType = element.getElementType();\n    if (elementType == JAVA_CODE_REFERENCE || elementType == REFERENCE_EXPRESSION) {\n      if (elementType == JAVA_CODE_REFERENCE || element.getTreeParent().getElementType() == REFERENCE_EXPRESSION || uncompleteCode) {\n        final PsiJavaCodeReferenceElement ref = (PsiJavaCodeReferenceElement)SourceTreeToPsiMap.treeElementToPsi(element);\n        final PsiTypeElement[] typeParameters = ref.getParameterList().getTypeParameterElements();\n        for (int i = 0; i < typeParameters.length; i++) {\n          process((TreeElement)SourceTreeToPsiMap.psiElementToTree(typeParameters[i]), addImports, uncompleteCode);\n        }\n\n        boolean rightKind = true;\n        if (elementType == JAVA_CODE_REFERENCE) {\n          int kind = ((PsiJavaCodeReferenceElementImpl)element).getKind();\n          rightKind = kind == PsiJavaCodeReferenceElementImpl.CLASS_NAME_KIND ||\n            kind == PsiJavaCodeReferenceElementImpl.CLASS_OR_PACKAGE_NAME_KIND;\n        }\n\n        if (rightKind) {\n          boolean isInsideDocComment = TreeUtil.findParent(element, JavaDocElementType.DOC_COMMENT) != null;\n          boolean isShort = !((SourceJavaCodeReference)element).isQualified();\n          if (!makeFQ(isInsideDocComment)) {\n            if (isShort) return element; // short name already, no need to change\n          }\n          PsiElement refElement;\n          if (!uncompleteCode) {\n            refElement = ref.resolve();\n          }\n          else {\n            PsiResolveHelper helper = element.getManager().getResolveHelper();\n            refElement = helper.resolveReferencedClass(\n                ((SourceJavaCodeReference)element).getClassNameText(),\n              SourceTreeToPsiMap.treeElementToPsi(element)\n            );\n          }\n          if (refElement instanceof PsiClass) {\n            if (makeFQ(isInsideDocComment)) {\n              String qName = ((PsiClass)refElement).getQualifiedName();\n              if (qName == null) return element;\n              PsiFile file = SourceTreeToPsiMap.treeElementToPsi(element).getContainingFile();\n              if (ImportHelper.isImplicitlyImported(qName, file)) {\n                if (isShort) return element;\n                return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n              }\n              if (file instanceof PsiJavaFile) {\n                String thisPackageName = ((PsiJavaFile)file).getPackageName();\n                if (ImportHelper.hasPackage(qName, thisPackageName)) {\n                  if (!isShort) {\n                    return (TreeElement)makeShortReference(\n                      (CompositeElement)element,\n                      (PsiClass)refElement,\n                      addImports,\n                      uncompleteCode\n                    );\n                  }\n                }\n              }\n              return (TreeElement)replaceReferenceWithFQ(element, (PsiClass)refElement);\n            }\n            else {\n              return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n            }\n          }\n        }\n      }\n    }\n\n    if (element instanceof CompositeElement) {\n      ChameleonTransforming.transformChildren(element);\n      for (TreeElement child = (TreeElement)element.getFirstChildNode(); child != null; child = child.getTreeNext()) {\n        child = process(child, addImports, uncompleteCode);\n      }\n    }\n\n    return element;\n  }","id":97909,"modified_method":"public TreeElement process(TreeElement element, boolean addImports, boolean uncompleteCode) {\n    IElementType elementType = element.getElementType();\n    if (elementType == JAVA_CODE_REFERENCE || elementType == REFERENCE_EXPRESSION) {\n      if (elementType == JAVA_CODE_REFERENCE || element.getTreeParent().getElementType() == REFERENCE_EXPRESSION || uncompleteCode) {\n        final PsiJavaCodeReferenceElement ref = (PsiJavaCodeReferenceElement)SourceTreeToPsiMap.treeElementToPsi(element);\n        final PsiTypeElement[] typeParameters = ref.getParameterList().getTypeParameterElements();\n        for (PsiTypeElement typeParameter : typeParameters) {\n          process((TreeElement)SourceTreeToPsiMap.psiElementToTree(typeParameter), addImports, uncompleteCode);\n        }\n\n        boolean rightKind = true;\n        if (elementType == JAVA_CODE_REFERENCE) {\n          int kind = ((PsiJavaCodeReferenceElementImpl)element).getKind();\n          rightKind = kind == PsiJavaCodeReferenceElementImpl.CLASS_NAME_KIND ||\n            kind == PsiJavaCodeReferenceElementImpl.CLASS_OR_PACKAGE_NAME_KIND;\n        }\n\n        if (rightKind) {\n          boolean isInsideDocComment = TreeUtil.findParent(element, JavaDocElementType.DOC_COMMENT) != null;\n          boolean isShort = !((SourceJavaCodeReference)element).isQualified();\n          if (!makeFQ(isInsideDocComment)) {\n            if (isShort) return element; // short name already, no need to change\n          }\n          PsiElement refElement;\n          if (!uncompleteCode) {\n            refElement = ref.resolve();\n          }\n          else {\n            PsiResolveHelper helper = element.getManager().getResolveHelper();\n            refElement = helper.resolveReferencedClass(\n                ((SourceJavaCodeReference)element).getClassNameText(),\n              SourceTreeToPsiMap.treeElementToPsi(element)\n            );\n          }\n          if (refElement instanceof PsiClass) {\n            if (makeFQ(isInsideDocComment)) {\n              String qName = ((PsiClass)refElement).getQualifiedName();\n              if (qName == null) return element;\n              PsiFile file = SourceTreeToPsiMap.treeElementToPsi(element).getContainingFile();\n              if (ImportHelper.isImplicitlyImported(qName, file)) {\n                if (isShort) return element;\n                return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n              }\n              if (file instanceof PsiJavaFile) {\n                String thisPackageName = ((PsiJavaFile)file).getPackageName();\n                if (ImportHelper.hasPackage(qName, thisPackageName)) {\n                  if (!isShort) {\n                    return (TreeElement)makeShortReference(\n                      (CompositeElement)element,\n                      (PsiClass)refElement,\n                      addImports,\n                      uncompleteCode\n                    );\n                  }\n                }\n              }\n              return (TreeElement)replaceReferenceWithFQ(element, (PsiClass)refElement);\n            }\n            else {\n              return (TreeElement)makeShortReference((CompositeElement)element, (PsiClass)refElement, addImports, uncompleteCode);\n            }\n          }\n        }\n      }\n    }\n\n    if (element instanceof CompositeElement) {\n      ChameleonTransforming.transformChildren(element);\n      for (TreeElement child = (TreeElement)element.getFirstChildNode(); child != null; child = child.getTreeNext()) {\n        child = process(child, addImports, uncompleteCode);\n      }\n    }\n\n    return element;\n  }","commit_id":"dca645376cb14379b98ccdb6f9afe190122349f7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CamelTestContextManager(Class<?> testClass) {\n            super(testClass);\n\n            // turn off auto starting spring as we need to do this later\n            System.setProperty(\"skipStartingCamelContext\", \"true\");\n\n            // inject Camel first, and then disable jmx and add the stop-watch\n            // (ensure to get the current list as we need to re-order that list so Camel comes first)\n            List<TestExecutionListener> list = getTestExecutionListeners();\n            addIfMissingType(list, new CamelSpringTestContextLoaderTestExecutionListener());\n            addIfMissingType(list, new DisableJmxTestExecutionListener());\n            addIfMissingType(list, new CamelSpringBootExecutionListener());\n            addIfMissingType(list, new StopWatchTestExecutionListener());\n            OrderComparator.sort(list);\n            registerTestExecutionListeners(list);\n        }","id":97910,"modified_method":"public CamelTestContextManager(Class<?> testClass) {\n            super(testClass);\n\n            // turn off auto starting spring as we need to do this later\n            System.setProperty(\"skipStartingCamelContext\", \"true\");\n\n            // is Camel already registered\n            if (!alreadyRegistered()) {\n                // inject Camel first, and then disable jmx and add the stop-watch\n                List<TestExecutionListener> list = getTestExecutionListeners();\n                list.add(0, new CamelSpringTestContextLoaderTestExecutionListener());\n                list.add(1, new DisableJmxTestExecutionListener());\n                list.add(2, new CamelSpringBootExecutionListener());\n                list.add(3, new StopWatchTestExecutionListener());\n            }\n        }","commit_id":"83f909bfa5f100a8b15861676edb215d925c32af","url":"https://github.com/apache/camel"},{"original_method":"public CamelTestContextManager(Class<?> testClass) {\n            super(testClass);\n\n            // inject Camel first, and then disable jmx and add the stop-watch\n            // (ensure to get the current list as we need to re-order that list so Camel comes first)\n            List<TestExecutionListener> list = getTestExecutionListeners();\n            addIfMissingType(list, new CamelSpringTestContextLoaderTestExecutionListener());\n            addIfMissingType(list, new DisableJmxTestExecutionListener());\n            addIfMissingType(list, new StopWatchTestExecutionListener());\n            OrderComparator.sort(list);\n            registerTestExecutionListeners(list);\n        }","id":97911,"modified_method":"public CamelTestContextManager(Class<?> testClass) {\n            super(testClass);\n\n            // is Camel already registered\n            if (!alreadyRegistered()) {\n                // inject Camel first, and then disable jmx and add the stop-watch\n                List<TestExecutionListener> list = getTestExecutionListeners();\n                list.add(0, new CamelSpringTestContextLoaderTestExecutionListener());\n                list.add(1, new DisableJmxTestExecutionListener());\n                list.add(2, new StopWatchTestExecutionListener());\n            }\n        }","commit_id":"83f909bfa5f100a8b15861676edb215d925c32af","url":"https://github.com/apache/camel"},{"original_method":"@Override\n  public String getName() {\n    return getPropertyDescriptor().getName();\n  }","id":97912,"modified_method":"@Override\n  public String getName() {\n    PropertyDescriptor d = getPropertyDescriptor();\n    if (d == null) {\n      //invalid property, needed for propertyRead event in SNode until event is rewritten\n      return myPropertyName;\n    }\n    return d.getName();\n  }","commit_id":"0fbb247492bc59bc5ef463f426f6752146c175c0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public ReferenceConstraintsDescriptor getReference(String role) {\n    return getReference(ConceptRegistryUtil.getConceptDescriptor(myConcept).getRefDescriptor(role).getId());\n  }","id":97913,"modified_method":"@NotNull\n  @Override\n  public ReferenceConstraintsDescriptor getReference(String role) {\n    ReferenceDescriptor refDescriptor = ConceptRegistryUtil.getConceptDescriptor(myConcept).getRefDescriptor(role);\n    if (refDescriptor == null) {\n      return new IllegalReferenceConstraintsDescriptor(null, role, this);\n    }\n    return getReference(refDescriptor.getId());\n  }","commit_id":"b21634ab515e6e987e5d93e68100bc6068221324","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public PropertyConstraintsDescriptor getProperty(String propertyName) {\n    return getProperty(ConceptRegistryUtil.getConceptDescriptor(getConceptId()).getPropertyDescriptor(propertyName).getId());\n  }","id":97914,"modified_method":"@NotNull\n  @Override\n  public PropertyConstraintsDescriptor getProperty(String propertyName) {\n    PropertyDescriptor propertyDescriptor = ConceptRegistryUtil.getConceptDescriptor(getConceptId()).getPropertyDescriptor(propertyName);\n    if (propertyDescriptor == null) {\n      return new IllegalPropertyConstraintsDescriptor(null, propertyName, this);\n    }\n    return getProperty(propertyDescriptor.getId());\n  }","commit_id":"b21634ab515e6e987e5d93e68100bc6068221324","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public ConstraintsDescriptor getConstraintsDescriptor(@Nullable String fqName) {\n    if (fqName == null) {\n      return new IllegalConstraintsDescriptor(null, null);\n    }\n    ConceptDescriptor conceptDescriptor = getConceptDescriptor(fqName);\n    return getConstraintsDescriptor(conceptDescriptor.getId());\n  }","id":97915,"modified_method":"@Deprecated\n  @NotNull\n  public ConstraintsDescriptor getConstraintsDescriptor(@NotNull String fqName) {\n    ConceptDescriptor conceptDescriptor = getConceptDescriptor(fqName);\n    return getConstraintsDescriptor(conceptDescriptor.getId());\n  }","commit_id":"b21634ab515e6e987e5d93e68100bc6068221324","url":"https://github.com/JetBrains/MPS"},{"original_method":"public IllegalPropertyConstraintsDescriptor(SPropertyId property, String propertyName, ConstraintsDescriptor container) {\n    this.myProperty = property;\n    this.container = container;\n    this.myPropertyName = propertyName;\n  }","id":97916,"modified_method":"public IllegalPropertyConstraintsDescriptor(SPropertyId property, String propertyName, ConstraintsDescriptor container) {\n    this.myProperty = property;\n    this.container = container;\n    this.myPropertyName = propertyName == null ? DebugRegistry.getInstance().getPropertyName(property) : propertyName;\n  }","commit_id":"b21634ab515e6e987e5d93e68100bc6068221324","url":"https://github.com/JetBrains/MPS"},{"original_method":"public IllegalReferenceConstraintsDescriptor(SReferenceLinkId referenceLink, String referenceLinkName, ConstraintsDescriptor container) {\n    this.myReferenceLink = referenceLink;\n    this.myReferenceLinkName = referenceLinkName;\n    this.container = container;\n  }","id":97917,"modified_method":"public IllegalReferenceConstraintsDescriptor(SReferenceLinkId referenceLink, String referenceLinkName, ConstraintsDescriptor container) {\n    this.myReferenceLink = referenceLink;\n    this.container = container;\n    this.myReferenceLinkName = referenceLinkName == null ? DebugRegistry.getInstance().getRefName(referenceLink) : referenceLinkName;\n  }","commit_id":"b21634ab515e6e987e5d93e68100bc6068221324","url":"https://github.com/JetBrains/MPS"},{"original_method":"@SuppressWarnings({ \"unchecked\" })\n    protected DbEvaluation createEvaluation(DbIssue issue, String who, long when, String designation, String comment) {\n        DbUser user;\n        Query query = getPersistenceManager().newQuery(\n                \"select from \" + persistenceHelper.getDbUserClassname() + \" where openid == :myopenid\");\n        List<DbUser> results = (List<DbUser>) query.execute(\"http://\" + who);\n        if (results.isEmpty()) {\n            user = persistenceHelper.createDbUser(\"http://\" + who, who);\n            getPersistenceManager().makePersistent(user);\n\n        } else {\n            user = results.iterator().next();\n        }\n        query.closeAll();\n        DbEvaluation eval = persistenceHelper.createDbEvaluation();\n        eval.setComment(comment);\n        eval.setDesignation(designation);\n        eval.setIssue(issue);\n        eval.setWhen(when);\n        eval.setWho(user.createKeyObject());\n        eval.setPrimaryClass(issue.getPrimaryClass());\n        eval.setPackages(UpdateServlet.buildPackageList(issue.getPrimaryClass()));\n        eval.setEmail(who);\n        issue.addEvaluation(eval);\n        return eval;\n    }","id":97918,"modified_method":"@SuppressWarnings({ \"unchecked\" })\n    protected DbEvaluation createEvaluation(DbIssue issue, String who, long when, String designation, String comment) {\n        DbUser user;\n        Query query = getPersistenceManager().newQuery(\n                \"select from \" + persistenceHelper.getDbUserClassname() + \" where openid == :myopenid\");\n        List<DbUser> results = (List<DbUser>) query.execute(\"http://\" + who);\n        if (results.isEmpty()) {\n            user = persistenceHelper.createDbUser(\"http://\" + who, who);\n            getPersistenceManager().makePersistent(user);\n\n        } else {\n            user = results.iterator().next();\n        }\n        query.closeAll();\n        DbEvaluation eval = persistenceHelper.createDbEvaluation();\n        eval.setComment(comment);\n        eval.setDesignation(designation);\n        eval.setIssue(issue);\n        eval.setWhen(SAMPLE_TIMESTAMP + when);\n        eval.setWho(user.createKeyObject());\n        eval.setPrimaryClass(issue.getPrimaryClass());\n        eval.setPackages(UpdateServlet.buildPackageList(issue.getPrimaryClass()));\n        eval.setEmail(who);\n        issue.addEvaluation(eval);\n        return eval;\n    }","commit_id":"9d46502b51277d87c969746a362152280c74a4a3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testGetRecentEvaluationsNoneFound() throws Exception {\n        DbIssue issue = createDbIssue(\"fad\");\n        createEvaluation(issue, \"someone\", 100);\n        createEvaluation(issue, \"someone\", 200);\n        createEvaluation(issue, \"someone\", 300);\n\n        getPersistenceManager().makePersistent(issue);\n\n        executePost(\"/get-recent-evaluations\", createRecentEvalsRequest(300).toByteArray());\n        checkResponse(200);\n        RecentEvaluations result = RecentEvaluations.parseFrom(outputCollector.toByteArray());\n        assertEquals(0, result.getIssuesCount());\n    }","id":97919,"modified_method":"public void testGetRecentEvaluationsNoneFound() throws Exception {\n        DbIssue issue = createDbIssue(\"fad\");\n        createEvaluation(issue, \"someone\", 100);\n        createEvaluation(issue, \"someone\", 200);\n        createEvaluation(issue, \"someone\", 300);\n\n        getPersistenceManager().makePersistent(issue);\n\n        executePost(\"/get-recent-evaluations\", createRecentEvalsRequest(300).toByteArray());\n        checkResponse(200);\n        RecentEvaluations result = RecentEvaluations.parseFrom(outputCollector.toByteArray());\n        if (WORKING)\n        assertEquals(0, result.getIssuesCount());\n    }","commit_id":"9d46502b51277d87c969746a362152280c74a4a3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testGetRecentEvaluations() throws Exception {\n        DbIssue issue = createDbIssue(\"fad\");\n        createEvaluation(issue, \"someone1\", 100);\n        DbEvaluation eval2 = createEvaluation(issue, \"someone2\", 200);\n        DbEvaluation eval3 = createEvaluation(issue, \"someone3\", 300);\n\n        getPersistenceManager().makePersistent(issue);\n\n        executePost(\"/get-recent-evaluations\", createRecentEvalsRequest(150).toByteArray());\n        checkResponse(200);\n        RecentEvaluations result = RecentEvaluations.parseFrom(outputCollector.toByteArray());\n        assertEquals(1, result.getIssuesCount());\n\n        // check issues\n        Issue foundissueProto = result.getIssues(0);\n        checkIssuesEqualExceptTimestamps(issue, foundissueProto);\n\n        // check evaluations\n        assertEquals(2, foundissueProto.getEvaluationsCount());\n        checkEvaluationsEqual(eval2, foundissueProto.getEvaluations(0));\n        checkEvaluationsEqual(eval3, foundissueProto.getEvaluations(1));\n\n        assertFalse(result.getAskAgain());\n    }","id":97920,"modified_method":"public void testGetRecentEvaluations() throws Exception {\n        DbIssue issue = createDbIssue(\"fad\");\n        createEvaluation(issue, \"someone1\", 100);\n        DbEvaluation eval2 = createEvaluation(issue, \"someone2\", 200);\n        DbEvaluation eval3 = createEvaluation(issue, \"someone3\", 300);\n\n        getPersistenceManager().makePersistent(issue);\n\n        executePost(\"/get-recent-evaluations\", createRecentEvalsRequest(150).toByteArray());\n        checkResponse(200);\n        RecentEvaluations result = RecentEvaluations.parseFrom(outputCollector.toByteArray());\n        assertEquals(1, result.getIssuesCount());\n\n        // check issues\n        Issue foundissueProto = result.getIssues(0);\n        if (WORKING) {\n        checkIssuesEqualExceptTimestamps(issue, foundissueProto);\n\n        // check evaluations\n        assertEquals(2, foundissueProto.getEvaluationsCount());\n        checkEvaluationsEqual(eval2, foundissueProto.getEvaluations(0));\n        checkEvaluationsEqual(eval3, foundissueProto.getEvaluations(1));\n        }\n\n        assertFalse(result.getAskAgain());\n    }","commit_id":"9d46502b51277d87c969746a362152280c74a4a3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testGraphEvalsByPackageOverTime() throws Exception {\n        DbIssue foundIssue1 = createDbIssue(\"fad2\");\n        DbIssue foundIssue2 = createDbIssue(\"fad3\");\n        DbIssue foundIssue3 = createDbIssue(\"fad4\");\n        foundIssue1.setPrimaryClass(\"net.kano.test.Blah\");\n        foundIssue2.setPrimaryClass(\"net.kano.test.Blah2\");\n        foundIssue3.setPrimaryClass(\"net.kano.test2.Blah\");\n        // week 1\n        createEvaluation(foundIssue1, \"someone\", days(2));\n        createEvaluation(foundIssue1, \"someone-else\", days(2));\n        createEvaluation(foundIssue1, \"someone\", days(3));\n\n        // week 2\n        createEvaluation(foundIssue2, \"someone3\", days(9));\n        createEvaluation(foundIssue1, \"someone3\", days(10));\n\n        // week 4\n        createEvaluation(foundIssue3, \"someone3\", days(24));\n        createEvaluation(foundIssue1, \"someone3\", days(25));\n        createEvaluation(foundIssue2, \"someone3\", days(25));\n\n        getPersistenceManager().makePersistentAll(foundIssue1, foundIssue2, foundIssue3);\n\n        prepareRequestAndResponse(\"/stats\", null);\n        Mockito.when(mockRequest.getParameter(\"package\")).thenReturn(\"net.kano.test\");\n        servlet.doGet(mockRequest, mockResponse);\n\n        String url = generatedCharts.get(0);\n        checkParam(url, \"chxl\", \"1:|3/14/10|3/21|3/28|4/4|4/11\");\n        checkParam(url, \"chd\", \"t:0.0,100.0,66.7,0.0,66.7|0.0,33.3,33.3,0.0,0.0\");\n    }","id":97921,"modified_method":"public void testGraphEvalsByPackageOverTime() throws Exception {\n        DbIssue foundIssue1 = createDbIssue(\"fad2\");\n        DbIssue foundIssue2 = createDbIssue(\"fad3\");\n        DbIssue foundIssue3 = createDbIssue(\"fad4\");\n        foundIssue1.setPrimaryClass(\"net.kano.test.Blah\");\n        foundIssue2.setPrimaryClass(\"net.kano.test.Blah2\");\n        foundIssue3.setPrimaryClass(\"net.kano.test2.Blah\");\n        // week 1\n        createEvaluation(foundIssue1, \"someone\", days(2));\n        createEvaluation(foundIssue1, \"someone-else\", days(2));\n        createEvaluation(foundIssue1, \"someone\", days(3));\n\n        // week 2\n        createEvaluation(foundIssue2, \"someone3\", days(9));\n        createEvaluation(foundIssue1, \"someone3\", days(10));\n\n        // week 4\n        createEvaluation(foundIssue3, \"someone3\", days(24));\n        createEvaluation(foundIssue1, \"someone3\", days(25));\n        createEvaluation(foundIssue2, \"someone3\", days(25));\n\n        getPersistenceManager().makePersistentAll(foundIssue1, foundIssue2, foundIssue3);\n\n        prepareRequestAndResponse(\"/stats\", null);\n        Mockito.when(mockRequest.getParameter(\"package\")).thenReturn(\"net.kano.test\");\n        servlet.doGet(mockRequest, mockResponse);\n\n        String url = generatedCharts.get(0);\n        if (WORKING) {\n        checkParam(url, \"chxl\", \"1:|3/14/10|3/21|3/28|4/4|4/11\");\n        checkParam(url, \"chd\", \"t:0.0,100.0,66.7,0.0,66.7|0.0,33.3,33.3,0.0,0.0\");\n        }\n    }","commit_id":"9d46502b51277d87c969746a362152280c74a4a3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testGraphUserEvalsByDate() throws Exception {\n        DbIssue foundIssue1 = createDbIssue(\"fad2\");\n        DbIssue foundIssue2 = createDbIssue(\"fad3\");\n        DbIssue foundIssue3 = createDbIssue(\"fad4\");\n        // week 1\n        createEvaluation(foundIssue1, \"someone\", days(2));\n        createEvaluation(foundIssue1, \"someone-else\", days(2));\n        createEvaluation(foundIssue1, \"someone\", days(3));\n\n        // week 2\n        createEvaluation(foundIssue2, \"someone3\", days(9));\n        createEvaluation(foundIssue1, \"someone3\", days(10));\n\n        // week 4\n        createEvaluation(foundIssue3, \"someone3\", days(24));\n        createEvaluation(foundIssue1, \"someone3\", days(25));\n        createEvaluation(foundIssue2, \"someone3\", days(25));\n\n        getPersistenceManager().makePersistentAll(foundIssue1, foundIssue2, foundIssue3);\n\n        prepareRequestAndResponse(\"/stats\", null);\n        Mockito.when(mockRequest.getParameter(\"user\")).thenReturn(\"someone3\");\n        servlet.doGet(mockRequest, mockResponse);\n\n        String url = generatedCharts.get(0);\n        checkParam(url, \"chxl\", \"1:|3/21/10|3/28|4/4|4/11\");\n        checkParam(url, \"chd\", \"t:0.0,66.7,0.0,100.0|0.0,66.7,0.0,33.3\");\n    }","id":97922,"modified_method":"public void testGraphUserEvalsByDate() throws Exception {\n        DbIssue foundIssue1 = createDbIssue(\"fad2\");\n        DbIssue foundIssue2 = createDbIssue(\"fad3\");\n        DbIssue foundIssue3 = createDbIssue(\"fad4\");\n        // week 1\n        createEvaluation(foundIssue1, \"someone\", days(2));\n        createEvaluation(foundIssue1, \"someone-else\", days(2));\n        createEvaluation(foundIssue1, \"someone\", days(3));\n\n        // week 2\n        createEvaluation(foundIssue2, \"someone3\", days(9));\n        createEvaluation(foundIssue1, \"someone3\", days(10));\n\n        // week 4\n        createEvaluation(foundIssue3, \"someone3\", days(24));\n        createEvaluation(foundIssue1, \"someone3\", days(25));\n        createEvaluation(foundIssue2, \"someone3\", days(25));\n\n        getPersistenceManager().makePersistentAll(foundIssue1, foundIssue2, foundIssue3);\n\n        prepareRequestAndResponse(\"/stats\", null);\n        Mockito.when(mockRequest.getParameter(\"user\")).thenReturn(\"someone3\");\n        servlet.doGet(mockRequest, mockResponse);\n\n        String url = generatedCharts.get(0);\n        if (WORKING) {\n        checkParam(url, \"chxl\", \"1:|3/21/10|3/28|4/4|4/11\");\n        checkParam(url, \"chd\", \"t:0.0,66.7,0.0,100.0|0.0,66.7,0.0,33.3\");\n        }\n    }","commit_id":"9d46502b51277d87c969746a362152280c74a4a3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testCumulativeTimelineGraph() throws Exception {\n        DbIssue foundIssue1 = createDbIssue(\"fad2\");\n        DbIssue foundIssue2 = createDbIssue(\"fad3\");\n        DbIssue foundIssue3 = createDbIssue(\"fad4\");\n        // week 1\n        createEvaluation(foundIssue1, \"someone\", days(2));\n        createEvaluation(foundIssue1, \"someone-else\", days(2));\n        createEvaluation(foundIssue1, \"someone\", days(3));\n\n        // week 2\n        createEvaluation(foundIssue2, \"someone3\", days(9));\n        createEvaluation(foundIssue1, \"someone3\", days(10));\n\n        // week 4\n        createEvaluation(foundIssue3, \"someone3\", days(24));\n        createEvaluation(foundIssue1, \"someone3\", days(25));\n\n        getPersistenceManager().makePersistentAll(foundIssue1, foundIssue2, foundIssue3);\n\n        executeGet(\"/stats\");\n\n        String url = generatedCharts.get(1);\n        checkParam(url, \"chxl\", \"2:|3/14/10|3/21|3/28|4/4|4/11\");\n        checkParam(url, \"chd\", \"t:0.0,42.9,71.4,71.4,100.0|0.0,14.3,28.6,28.6,42.9|0.0,66.7,100.0,100.0,100.0\");\n    }","id":97923,"modified_method":"public void testCumulativeTimelineGraph() throws Exception {\n        DbIssue foundIssue1 = createDbIssue(\"fad2\");\n        DbIssue foundIssue2 = createDbIssue(\"fad3\");\n        DbIssue foundIssue3 = createDbIssue(\"fad4\");\n        // week 1\n        createEvaluation(foundIssue1, \"someone\", days(2));\n        createEvaluation(foundIssue1, \"someone-else\", days(2));\n        createEvaluation(foundIssue1, \"someone\", days(3));\n\n        // week 2\n        createEvaluation(foundIssue2, \"someone3\", days(9));\n        createEvaluation(foundIssue1, \"someone3\", days(10));\n\n        // week 4\n        createEvaluation(foundIssue3, \"someone3\", days(24));\n        createEvaluation(foundIssue1, \"someone3\", days(25));\n\n        getPersistenceManager().makePersistentAll(foundIssue1, foundIssue2, foundIssue3);\n\n        executeGet(\"/stats\");\n\n        String url = generatedCharts.get(1);\n        if (WORKING) {\n        checkParam(url, \"chxl\", \"2:|3/14/10|3/21|3/28|4/4|4/11\");\n        checkParam(url, \"chd\", \"t:0.0,42.9,71.4,71.4,100.0|0.0,14.3,28.6,28.6,42.9|0.0,66.7,100.0,100.0,100.0\");\n        }\n    }","commit_id":"9d46502b51277d87c969746a362152280c74a4a3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testGraphEvalsByDate() throws Exception {\n        DbIssue foundIssue1 = createDbIssue(\"fad2\");\n        DbIssue foundIssue2 = createDbIssue(\"fad3\");\n        DbIssue foundIssue3 = createDbIssue(\"fad4\");\n        // week 1\n        createEvaluation(foundIssue1, \"someone\", days(2));\n        createEvaluation(foundIssue1, \"someone-else\", days(2));\n        createEvaluation(foundIssue1, \"someone\", days(3));\n\n        // week 2\n        createEvaluation(foundIssue2, \"someone3\", days(9));\n        createEvaluation(foundIssue1, \"someone3\", days(10));\n\n        // week 4\n        createEvaluation(foundIssue3, \"someone3\", days(24));\n        createEvaluation(foundIssue1, \"someone3\", days(25));\n\n        getPersistenceManager().makePersistentAll(foundIssue1, foundIssue2, foundIssue3);\n\n        executeGet(\"/stats\");\n\n        String url = generatedCharts.get(0);\n        checkParam(url, \"chxl\", \"1:|3/14/10|3/21|3/28|4/4|4/11\");\n        checkParam(url, \"chd\", \"t:0.0,100.0,66.7,0.0,66.7|0.0,33.3,33.3,0.0,33.3|0.0,66.7,33.3,0.0,0.0\");\n    }","id":97924,"modified_method":"public void testGraphEvalsByDate() throws Exception {\n        DbIssue foundIssue1 = createDbIssue(\"fad2\");\n        DbIssue foundIssue2 = createDbIssue(\"fad3\");\n        DbIssue foundIssue3 = createDbIssue(\"fad4\");\n        // week 1\n        createEvaluation(foundIssue1, \"someone\", days(2));\n        createEvaluation(foundIssue1, \"someone-else\", days(2));\n        createEvaluation(foundIssue1, \"someone\", days(3));\n\n        // week 2\n        createEvaluation(foundIssue2, \"someone3\", days(9));\n        createEvaluation(foundIssue1, \"someone3\", days(10));\n\n        // week 4\n        createEvaluation(foundIssue3, \"someone3\", days(24));\n        createEvaluation(foundIssue1, \"someone3\", days(25));\n\n        getPersistenceManager().makePersistentAll(foundIssue1, foundIssue2, foundIssue3);\n\n        executeGet(\"/stats\");\n\n        String url = generatedCharts.get(0);\n        if (WORKING) {\n        checkParam(url, \"chxl\", \"1:|3/14/10|3/21|3/28|4/4|4/11\");\n        checkParam(url, \"chd\", \"t:0.0,100.0,66.7,0.0,66.7|0.0,33.3,33.3,0.0,33.3|0.0,66.7,33.3,0.0,0.0\");\n        }\n    }","commit_id":"9d46502b51277d87c969746a362152280c74a4a3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testGraphUserEvalsByDateJustOneWeek() throws Exception {\n        DbIssue foundIssue1 = createDbIssue(\"fad2\");\n        // week 1\n        createEvaluation(foundIssue1, \"someone\", days(2));\n        createEvaluation(foundIssue1, \"someone2\", days(2));\n\n        // week 2\n        createEvaluation(foundIssue1, \"someone2\", days(9));\n\n        getPersistenceManager().makePersistentAll(foundIssue1);\n\n        prepareRequestAndResponse(\"/stats\", null);\n        Mockito.when(mockRequest.getParameter(\"user\")).thenReturn(\"someone\");\n        servlet.doGet(mockRequest, mockResponse);\n\n        String url = generatedCharts.get(0);\n        checkParam(url, \"chxl\", \"1:|3/14/10|3/21\");\n        checkParam(url, \"chd\", \"t:0.0,100.0|0.0,100.0\");\n    }","id":97925,"modified_method":"public void testGraphUserEvalsByDateJustOneWeek() throws Exception {\n        DbIssue foundIssue1 = createDbIssue(\"fad2\");\n        // week 1\n        createEvaluation(foundIssue1, \"someone\", days(2));\n        createEvaluation(foundIssue1, \"someone2\", days(2));\n\n        // week 2\n        createEvaluation(foundIssue1, \"someone2\", days(9));\n\n        getPersistenceManager().makePersistentAll(foundIssue1);\n\n        prepareRequestAndResponse(\"/stats\", null);\n        Mockito.when(mockRequest.getParameter(\"user\")).thenReturn(\"someone\");\n        servlet.doGet(mockRequest, mockResponse);\n\n        String url = generatedCharts.get(0);\n//        checkParam(url, \"chxl\", \"1:|3/14/10|3/21\");\n//        checkParam(url, \"chd\", \"t:0.0,100.0|0.0,100.0\");\n    }","commit_id":"9d46502b51277d87c969746a362152280c74a4a3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Check for unconditionally dereferenced null values\n\t * at a particular location in the CFG.\n\t * \n\t * @param nullValueGuaranteedDerefMap map to be populated with null values and where they are derefed \n\t * @param vnaFrame                    value number frame to check\n\t * @param invFrame                    null-value frame to check\n\t * @param derefSet                    set of unconditionally derefed values at this location \n\t */\n\tprivate void checkForUnconditionallyDereferencedNullValues(\n\t\t\tMap<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap,\n\t\t\tValueNumberFrame vnaFrame,\n\t\t\tIsNullValueFrame invFrame,\n\t\t\tUnconditionalValueDerefSet derefSet) {\n\t\t\n\t\tif (false && DEBUG_DEREFS) {\n\t\t\tSystem.out.println(\"vna *** \" + vnaFrame);\n\t\t\tSystem.out.println(\"inv *** \" + invFrame);\n\t\t\tSystem.out.println(\"deref * \" + derefSet);\n\t\t}\n\t\t\n\t\t// Make sure the frames contain meaningful information\n\t\tif (!vnaFrame.isValid() || !invFrame.isValid() || vnaFrame.getNumSlots() != invFrame.getNumSlots())  {\n\t\t\treturn;\n\t\t}\n\n\t\t// See if there are any definitely-null values in the frame\n\t\tfor (int j = 0; j < invFrame.getNumSlots(); j++) {\n\t\t\tIsNullValue isNullValue = invFrame.getValue(j); \n\t\t\t\n\t\t\tif (isNullValue.isDefinitelyNull()) {\n\t\t\t\t// Is this value unconditionally dereferenced?\n\t\t\t\tValueNumber valueNumber = vnaFrame.getValue(j);\n\t\t\t\t\n\t\t\t\tif (derefSet.isUnconditionallyDereferenced(valueNumber)) {\n\t\t\t\t\tif (DEBUG_DEREFS) {\n\t\t\t\t\t\tSystem.out.println(\"vna *** \" + vnaFrame);\n\t\t\t\t\t\tSystem.out.println(\"inv *** \" + invFrame);\n\t\t\t\t\t\tSystem.out.println(\"deref * \" + derefSet);\n\t\t\t\t\n\t\t\t\t\t\tSystem.out.println(\"%%% HIT for value number \" + valueNumber);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// OK, we have a null value that is unconditionally\n\t\t\t\t\t// derferenced.  Make a note of the locations where it\n\t\t\t\t\t// will be dereferenced.\n\t\t\t\t\tNullValueUnconditionalDeref thisNullValueDeref = nullValueGuaranteedDerefMap.get(valueNumber);\n\t\t\t\t\tif (thisNullValueDeref == null) {\n\t\t\t\t\t\tthisNullValueDeref = new NullValueUnconditionalDeref();\n\t\t\t\t\t\tnullValueGuaranteedDerefMap.put(valueNumber, thisNullValueDeref);\n\t\t\t\t\t}\n//\t\t\t\t\tthisValueNumberDerefLocationSet.addAll(derefSet.getUnconditionalDerefLocationSet(valueNumber));\n\t\t\t\t\tthisNullValueDeref.add(isNullValue, derefSet.getUnconditionalDerefLocationSet(valueNumber));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":97926,"modified_method":"/**\n\t * Check for unconditionally dereferenced null values\n\t * at a particular location in the CFG.\n\t * \n\t * @param nullValueGuaranteedDerefMap map to be populated with null values and where they are derefed \n\t * @param vnaFrame                    value number frame to check\n\t * @param invFrame                    null-value frame to check\n\t * @param derefSet                    set of unconditionally derefed values at this location \n\t */\n\tprivate void checkForUnconditionallyDereferencedNullValues(\n\t\t\tMap<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap,\n\t\t\tValueNumberFrame vnaFrame,\n\t\t\tIsNullValueFrame invFrame,\n\t\t\tUnconditionalValueDerefSet derefSet) {\n\t\t\n\t\tif (DEBUG_DEREFS) {\n\t\t\tSystem.out.println(\"vna *** \" + vnaFrame);\n\t\t\tSystem.out.println(\"inv *** \" + invFrame);\n\t\t\tSystem.out.println(\"deref * \" + derefSet);\n\t\t}\n\t\t\n\t\t// Make sure the frames contain meaningful information\n\t\tif (!vnaFrame.isValid() || !invFrame.isValid() || vnaFrame.getNumSlots() != invFrame.getNumSlots())  {\n\t\t\treturn;\n\t\t}\n\n\t\t// See if there are any definitely-null values in the frame\n\t\tfor (int j = 0; j < invFrame.getNumSlots(); j++) {\n\t\t\tIsNullValue isNullValue = invFrame.getValue(j); \n\t\t\t\n\t\t\tif (isNullValue.isDefinitelyNull()) {\n\t\t\t\t// Is this value unconditionally dereferenced?\n\t\t\t\tValueNumber valueNumber = vnaFrame.getValue(j);\n\t\t\t\t\n\t\t\t\tif (derefSet.isUnconditionallyDereferenced(valueNumber)) {\n\t\t\t\t\tnoteUnconditionallyDereferencedNullValue(\n\t\t\t\t\t\t\tnullValueGuaranteedDerefMap,\n\t\t\t\t\t\t\tderefSet,\n\t\t\t\t\t\t\tisNullValue,\n\t\t\t\t\t\t\tvalueNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// See if there are any known-null values in the heap that\n\t\t// will be dereferenced in the future.\n\t\tfor (Map.Entry<ValueNumber, IsNullValue> entry : invFrame.getKnownValueMapEntrySet()) {\n\t\t\tif (!entry.getValue().isDefinitelyNull()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (derefSet.isUnconditionallyDereferenced(entry.getKey())) {\n\t\t\t\tnoteUnconditionallyDereferencedNullValue(\n\t\t\t\t\t\tnullValueGuaranteedDerefMap,\n\t\t\t\t\t\tderefSet,\n\t\t\t\t\t\tentry.getValue(),\n\t\t\t\t\t\tentry.getKey());\n\t\t\t}\n\t\t}\n\t\t\n\t}","commit_id":"b0d07b3aec81c0a6b8a12d287dff36a155a424de","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Find out if any VNs in the source block\n\t * contribute to unconditionally dereferenced VNs in the\n\t * target block.  If so, the VN in the source block is\n\t * also unconditionally dereferenced, and we must propagate\n\t * the target VN's dereferences.\n\t *  \n\t * @param fact a dataflow value\n\t * @param edge edge to check for merge input values\n\t * @return possibly-modified dataflow value\n\t */\n\tprivate  UnconditionalValueDerefSet propagateDerefSetsToMergeInputValues(\n\t\t\tUnconditionalValueDerefSet fact, Edge edge) {\n\t\t\n\t\tValueNumberFrame blockValueNumberFrame =\n\t\t\tvnaDataflow.getResultFact(edge.getSource());\n\t\tValueNumberFrame targetValueNumberFrame =\n\t\t\tvnaDataflow.getStartFact(edge.getTarget());\n\n\t\tfact = duplicateFact(fact);\n\n\t\tif (blockValueNumberFrame.isValid() && targetValueNumberFrame.isValid() &&\n\t\t\t\tblockValueNumberFrame.getNumSlots() == targetValueNumberFrame.getNumSlots()) {\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"** Valid VNA frames for \" + edge);\n\t\t\t\tSystem.out.println(\"** Block : \" + blockValueNumberFrame);\n\t\t\t\tSystem.out.println(\"** Target: \" + targetValueNumberFrame);\n\t\t\t}\n\t\t\tfor (int i = 0; i < blockValueNumberFrame.getNumSlots(); i++) {\n\t\t\t\tValueNumber blockVN = blockValueNumberFrame.getValue(i);\n\t\t\t\tValueNumber targetVN = targetValueNumberFrame.getValue(i);\n\t\t\t\tif (!blockVN.equals(targetVN)) {\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"Merge: \" + targetVN + \" -> \" + blockVN);\n\t\t\t\t\t}\n\t\t\t\t\tif (fact.isUnconditionallyDereferenced(targetVN)\n\t\t\t\t\t\t\t&& !fact.isUnconditionallyDereferenced(blockVN)) {\n\t\t\t\t\t\t// Block VN is also dereferenced unconditionally.\n\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tSystem.out.println(\"** Copy vn derefs \" + targetVN.getNumber() + \n\t\t\t\t\t\t\t\t\t\" --> \" + blockVN.getNumber());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfact.setDerefSet(blockVN, fact.getUnconditionalDerefLocationSet(targetVN));\n\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tSystem.out.println(\"Result is: \" + fact);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // for all slots\n\t\n\t\t\tfor(ValueNumber blockVN : blockValueNumberFrame.valueNumbersForLoads()) {\n\t\t\t\tAvailableLoad load = blockValueNumberFrame.getLoad(blockVN);\n\t\t\t\tif (load == null) continue;\n\t\t\t\tValueNumber [] targetVNs = targetValueNumberFrame.getAvailableLoad(load);\n\t\t\t\tif (targetVNs != null)\n\t\t\t\t\tfor(ValueNumber targetVN : targetVNs) \n\t\t\t\t\t\tif (targetVN.hasFlag(ValueNumber.PHI_NODE) && fact.isUnconditionallyDereferenced(targetVN)\n\t\t\t\t\t\t\t\t&& !fact.isUnconditionallyDereferenced(blockVN)) {\n\t\t\t\t\t\t\t//  Block VN is also dereferenced unconditionally.\n\t\t\t\t\t\t\tAvailableLoad targetLoad = targetValueNumberFrame.getLoad(targetVN);\n\t\t\t\t\t\t\tif (!load.equals(targetLoad)) continue;\n\t\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\t\tSystem.out.println(\"** Copy vn derefs for \" + load +\" from \" + targetVN + \n\t\t\t\t\t\t\t\t\t\t\" --> \" + blockVN);\n\t\t\t\t\t\t\t\tSystem.out.println(\"** block phi for \" +  System.identityHashCode(blockValueNumberFrame)\n\t\t\t\t\t\t\t\t\t\t+ \"is \" + blockValueNumberFrame.phiNodeForLoads);\n\t\t\t\t\t\t\t\tSystem.out.println(\"** target phi for \" +  System.identityHashCode(targetValueNumberFrame)\n\t\t\t\t\t\t\t\t\t\t+ \"is \" + targetValueNumberFrame.phiNodeForLoads);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfact.setDerefSet(blockVN, fact.getUnconditionalDerefLocationSet(targetVN));\n\n\t\t\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Target VNF: \" + targetValueNumberFrame);\n\t\t\tSystem.out.println(\"Block VNF: \" + blockValueNumberFrame);\n\t\t\tSystem.out.println(\"fact: \" + fact);\n\t\t}\n\t\tfact.cleanDerefSet(null, blockValueNumberFrame);\n\t\treturn fact;\n\t}","id":97927,"modified_method":"/**\n\t * Find out if any VNs in the source block\n\t * contribute to unconditionally dereferenced VNs in the\n\t * target block.  If so, the VN in the source block is\n\t * also unconditionally dereferenced, and we must propagate\n\t * the target VN's dereferences.\n\t *  \n\t * @param fact a dataflow value\n\t * @param edge edge to check for merge input values\n\t * @return possibly-modified dataflow value\n\t */\n\tprivate  UnconditionalValueDerefSet propagateDerefSetsToMergeInputValues(\n\t\t\tUnconditionalValueDerefSet fact, Edge edge) {\n\t\t\n\t\tValueNumberFrame blockValueNumberFrame =\n\t\t\tvnaDataflow.getResultFact(edge.getSource());\n\t\tValueNumberFrame targetValueNumberFrame =\n\t\t\tvnaDataflow.getStartFact(edge.getTarget());\n\n\t\tUnconditionalValueDerefSet originalFact = fact;\n\t\tfact = duplicateFact(fact);\n\n\t\tif (blockValueNumberFrame.isValid() && targetValueNumberFrame.isValid() &&\n\t\t\t\tblockValueNumberFrame.getNumSlots() == targetValueNumberFrame.getNumSlots()) {\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"** Valid VNA frames for \" + edge);\n\t\t\t\tSystem.out.println(\"** Block : \" + blockValueNumberFrame);\n\t\t\t\tSystem.out.println(\"** Target: \" + targetValueNumberFrame);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < blockValueNumberFrame.getNumSlots(); i++) {\n\t\t\t\tValueNumber blockVN = blockValueNumberFrame.getValue(i);\n\t\t\t\tValueNumber targetVN = targetValueNumberFrame.getValue(i);\n\t\t\t\tfact.clearDerefSet(blockVN);\n\t\t\t\tif (originalFact.isUnconditionallyDereferenced(targetVN))\n\t\t\t\t\tfact.setDerefSet(blockVN, originalFact.getUnconditionalDerefLocationSet(targetVN));\n\n\t\t\t} // for all slots\n\t\n\t\t\tfor(ValueNumber blockVN : blockValueNumberFrame.valueNumbersForLoads()) {\n\t\t\t\tAvailableLoad load = blockValueNumberFrame.getLoad(blockVN);\n\t\t\t\tif (load == null) continue;\n\t\t\t\tValueNumber [] targetVNs = targetValueNumberFrame.getAvailableLoad(load);\n\t\t\t\tif (targetVNs != null)\n\t\t\t\t\tfor(ValueNumber targetVN : targetVNs) \n\t\t\t\t\t\tif (targetVN.hasFlag(ValueNumber.PHI_NODE) && fact.isUnconditionallyDereferenced(targetVN)\n\t\t\t\t\t\t\t\t&& !fact.isUnconditionallyDereferenced(blockVN)) {\n\t\t\t\t\t\t\t//  Block VN is also dereferenced unconditionally.\n\t\t\t\t\t\t\tAvailableLoad targetLoad = targetValueNumberFrame.getLoad(targetVN);\n\t\t\t\t\t\t\tif (!load.equals(targetLoad)) continue;\n\t\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\t\tSystem.out.println(\"** Copy vn derefs for \" + load +\" from \" + targetVN + \n\t\t\t\t\t\t\t\t\t\t\" --> \" + blockVN);\n\t\t\t\t\t\t\t\tSystem.out.println(\"** block phi for \" +  System.identityHashCode(blockValueNumberFrame)\n\t\t\t\t\t\t\t\t\t\t+ \"is \" + blockValueNumberFrame.phiNodeForLoads);\n\t\t\t\t\t\t\t\tSystem.out.println(\"** target phi for \" +  System.identityHashCode(targetValueNumberFrame)\n\t\t\t\t\t\t\t\t\t\t+ \"is \" + targetValueNumberFrame.phiNodeForLoads);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfact.setDerefSet(blockVN, fact.getUnconditionalDerefLocationSet(targetVN));\n\n\t\t\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Target VNF: \" + targetValueNumberFrame);\n\t\t\tSystem.out.println(\"Block VNF: \" + blockValueNumberFrame);\n\t\t\tSystem.out.println(\"fact: \" + fact);\n\t\t}\n\t\tfact.cleanDerefSet(null, blockValueNumberFrame);\n\t\treturn fact;\n\t}","commit_id":"67d215607042de5742ebb4f430eb128a098ca614","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Check for unconditionally dereferenced null values\n\t * at a particular location in the CFG.\n\t * @param thisLocation TODO\n\t * @param knownNullAndDoomedAt TODO\n\t * @param nullValueGuaranteedDerefMap map to be populated with null values and where they are derefed \n\t * @param vnaFrame                    value number frame to check\n\t * @param invFrame                    null-value frame to check\n\t * @param derefSet                    set of unconditionally derefed values at this location \n\t */\n\tprivate void checkForUnconditionallyDereferencedNullValues(\n\t\t\tLocation thisLocation,\n\t\t\tMap<ValueNumber, SortedSet<Location>> knownNullAndDoomedAt,\n\t\t\tMap<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap,\n\t\t\tValueNumberFrame vnaFrame, IsNullValueFrame invFrame, UnconditionalValueDerefSet derefSet) {\n\t\t\n\t\tif (DEBUG_DEREFS) {\n\t\t\tSystem.out.println(\"vna *** \" + vnaFrame);\n\t\t\tSystem.out.println(\"inv *** \" + invFrame);\n\t\t\tSystem.out.println(\"deref * \" + derefSet);\n\t\t}\n\t\t\n\t\t// Make sure the frames contain meaningful information\n\t\tif (!vnaFrame.isValid() || !invFrame.isValid() || vnaFrame.getNumSlots() != invFrame.getNumSlots())  {\n\t\t\treturn;\n\t\t}\n\n\t\t// See if there are any definitely-null values in the frame\n\t\tfor (int j = 0; j < invFrame.getNumSlots(); j++) {\n\t\t    IsNullValue isNullValue = invFrame.getValue(j); \n\t\t    ValueNumber valueNumber = vnaFrame.getValue(j);\n\t\t    if (isNullValue.isDefinitelyNull() && (derefSet.isUnconditionallyDereferenced(valueNumber) \n                    || derefSet.isUnconditionallyDereferencedOnNonExceptionPath(valueNumber))) {\n                if (MY_DEBUG) {\n                    System.out.println(\"Found NP bug\");\n                    System.out.println(\"Location: \" + thisLocation);\n                    System.out.println(\"Value number: \" + valueNumber);\n                    System.out.println(\"IsNullValue frame: \" + invFrame);\n                    System.out.println(\"IsNullValue value: \" + isNullValue);\n                    System.out.println(\"Unconditional dere framef: \" + derefSet);\n                    System.out.println(\"Unconditionally dereferenced: \" + derefSet.isUnconditionallyDereferenced(valueNumber) );\n                    System.out.println(\"Uncexceptionally dereferenced: \" + derefSet.isUnconditionallyDereferencedOnNonExceptionPath(valueNumber) );\n\n                }\n                noteUnconditionallyDereferencedNullValue(\n\t\t                thisLocation,\n\t\t                knownNullAndDoomedAt,\n\t\t                nullValueGuaranteedDerefMap,\n\t\t                derefSet, isNullValue, valueNumber);\n\t\t    }\n\t\t}\n\n\t\t// See if there are any known-null values in the heap that\n\t\t// will be dereferenced in the future.\n\t\tfor (Map.Entry<ValueNumber, IsNullValue> entry : invFrame.getKnownValueMapEntrySet()) {\n\t\t    ValueNumber valueNumber = entry.getKey();\n\t\t    IsNullValue isNullValue = entry.getValue();\n\t\t    if (isNullValue.isDefinitelyNull() && (derefSet.isUnconditionallyDereferenced(valueNumber) \n                    || derefSet.isUnconditionallyDereferencedOnNonExceptionPath(valueNumber))) {\n               noteUnconditionallyDereferencedNullValue(\n\t\t                thisLocation,\n\t\t                knownNullAndDoomedAt,\n\t\t                nullValueGuaranteedDerefMap,\n\t\t                derefSet, isNullValue, valueNumber);\n\t\t    }\n\t\t}\n\t}","id":97928,"modified_method":"/**\n\t * Check for unconditionally dereferenced null values\n\t * at a particular location in the CFG.\n\t * @param thisLocation TODO\n\t * @param knownNullAndDoomedAt TODO\n\t * @param nullValueGuaranteedDerefMap map to be populated with null values and where they are derefed \n\t * @param vnaFrame                    value number frame to check\n\t * @param invFrame                    null-value frame to check\n\t * @param derefSet                    set of unconditionally derefed values at this location \n\t */\n\tprivate void checkForUnconditionallyDereferencedNullValues(\n\t\t\tLocation thisLocation,\n\t\t\tMap<ValueNumber, SortedSet<Location>> knownNullAndDoomedAt,\n\t\t\tMap<ValueNumber, NullValueUnconditionalDeref> nullValueGuaranteedDerefMap,\n\t\t\tValueNumberFrame vnaFrame, IsNullValueFrame invFrame, UnconditionalValueDerefSet derefSet) {\n\t\t\n\t\tif (DEBUG_DEREFS) {\n\t\t\tSystem.out.println(\"vna *** \" + vnaFrame);\n\t\t\tSystem.out.println(\"inv *** \" + invFrame);\n\t\t\tSystem.out.println(\"deref * \" + derefSet);\n\t\t}\n\t\t\n\t\t// Make sure the frames contain meaningful information\n\t\tif (!vnaFrame.isValid() || !invFrame.isValid() || vnaFrame.getNumSlots() != invFrame.getNumSlots())  {\n\t\t\treturn;\n\t\t}\n\n\t\t// See if there are any definitely-null values in the frame\n\t\tfor (int j = 0; j < invFrame.getNumSlots(); j++) {\n\t\t    IsNullValue isNullValue = invFrame.getValue(j); \n\t\t    ValueNumber valueNumber = vnaFrame.getValue(j);\n\t\t    if (isNullValue.isDefinitelyNull() && (derefSet.isUnconditionallyDereferenced(valueNumber) \n                  )) {\n                if (MY_DEBUG) {\n                    System.out.println(\"Found NP bug\");\n                    System.out.println(\"Location: \" + thisLocation);\n                    System.out.println(\"Value number: \" + valueNumber);\n                    System.out.println(\"IsNullValue frame: \" + invFrame);\n                    System.out.println(\"IsNullValue value: \" + isNullValue);\n                    System.out.println(\"Unconditional dere framef: \" + derefSet);\n                    System.out.println(\"Unconditionally dereferenced: \" + derefSet.isUnconditionallyDereferenced(valueNumber) );\n              \n                }\n                noteUnconditionallyDereferencedNullValue(\n\t\t                thisLocation,\n\t\t                knownNullAndDoomedAt,\n\t\t                nullValueGuaranteedDerefMap,\n\t\t                derefSet, isNullValue, valueNumber);\n\t\t    }\n\t\t}\n\n\t\t// See if there are any known-null values in the heap that\n\t\t// will be dereferenced in the future.\n\t\tfor (Map.Entry<ValueNumber, IsNullValue> entry : invFrame.getKnownValueMapEntrySet()) {\n\t\t    ValueNumber valueNumber = entry.getKey();\n\t\t    IsNullValue isNullValue = entry.getValue();\n\t\t    if (isNullValue.isDefinitelyNull() && derefSet.isUnconditionallyDereferenced(valueNumber) ) {\n               noteUnconditionallyDereferencedNullValue(\n\t\t                thisLocation,\n\t\t                knownNullAndDoomedAt,\n\t\t                nullValueGuaranteedDerefMap,\n\t\t                derefSet, isNullValue, valueNumber);\n\t\t    }\n\t\t}\n\t}","commit_id":"412d47e5c51d1ed9854c53f2a72af9226be18c77","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void meetInto(UnconditionalValueDerefSet fact, Edge edge,\n\t\t\tUnconditionalValueDerefSet result, boolean onlyEdge) throws DataflowAnalysisException {\n\t\t\n        if (isExceptionEdge(edge) && !onlyEdge) {\n            if (DEBUG) System.out.println(\"Skipping exception edge\");\n            return;\n        }\n        \n        if (false && isExceptionEdge(edge) && !result.isTop() && !result.isBottom()) {\n            UnconditionalValueDerefSet tmpFact = createFact();\n            tmpFact.makeSameAs(fact);\n            fact = tmpFact;\n            fact.markAsOnExceptionPath();\n        }\n\t\tValueNumber knownNonnullOnBranch = null;\n\t\t// Edge transfer function\n\t\tif (isFactValid(fact)) {\n\t\t\tfact = propagateDerefSetsToMergeInputValues(fact, edge);\n\t\t\tif (invDataflow != null) {\n\t\t\t\tknownNonnullOnBranch = findValueKnownNonnullOnBranch(fact, edge);\n\t\t\t\tif (knownNonnullOnBranch != null) {\n\t\t\t\t\tfact = duplicateFact(fact);\n\t\t\t\t\tfact.clearDerefSet(knownNonnullOnBranch);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean isBackEdge = edge.isBackwardInBytecode();\n\t\tboolean sourceIsTopOfLoop = edge.sourceIsTopOfLoop(ClassContext.getLoopExitBranches(methodGen));\n\t\tif (sourceIsTopOfLoop && edge.getType() == EdgeTypes.FALL_THROUGH_EDGE)\n\t\t\tisBackEdge = true;\n\t\tif (false && (edge.getType() == EdgeTypes.IFCMP_EDGE || sourceIsTopOfLoop)) {\n\t\t\tSystem.out.println(\"Meet into \" + edge);\n\t\t\tSystem.out.println(\"  foo2: \" + sourceIsTopOfLoop);\n\t\t\tSystem.out.println(\"  getType: \" + edge.getType() );\n\t\t    System.out.println(\"  Backedge according to bytecode: \" + isBackEdge);\n\t\t    System.out.println(\"  Fact hashCode: \" + System.identityHashCode(result));\n\t\t    System.out.println(\"  Initial fact: \" + result);\n\t\t    System.out.println(\"  Edge fact: \" + fact);\n\t\t}\n\t\tif (result.isTop() || fact.isBottom()) {\n\t\t\t// Make result identical to other fact\n\t\t\tcopy(fact, result);\n\t\t\tif (ASSUME_NONZERO_TRIP_LOOPS && isBackEdge && !fact.isTop())\n\t\t\t\tresult.resultsFromBackEdge = true;\n\t\t} else if (ASSUME_NONZERO_TRIP_LOOPS && isBackEdge && !fact.isTop()) {\n\t\t\tresult.unionWith(fact, vnaDataflow.getAnalysis().getFactory());\n\t\t\tresult.resultsFromBackEdge = true;\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"\\n Forcing union of \" +  System.identityHashCode(result) + \" due to backedge info\");\n\t\t\t\tSystem.out.println(\"  result: \" +  result);\n\t\t\t}\n\t\t\t\n\t\t} else if (result.isBottom() || fact.isTop()) {\n\t\t\t// No change in result fact\n\t\t} else {\n\t\t\t// Dataflow merge\n\t\t\t// (intersection of unconditional deref values)\n           if (ASSUME_NONZERO_TRIP_LOOPS && result.resultsFromBackEdge) {\n\t\t\t\tresult.backEdgeUpdateCount++;\n\t\t\t\tif (result.backEdgeUpdateCount < 10) {\n\t\t\t\t\tif (DEBUG) System.out.println(\"\\n Union update of \" +  System.identityHashCode(result) + \" due to backedge info\");\n\t\t\t\t\tresult.unionWith(fact, vnaDataflow.getAnalysis().getFactory());\n                    return;\n\t\t\t\t}\n\t\t\t}\n\t\t    result.mergeWith(fact, knownNonnullOnBranch, vnaDataflow.getAnalysis().getFactory());\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"  updated: \" + System.identityHashCode(result));\n\t\t\t\tSystem.out.println(\"  result: \" +  result);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (DEBUG && isBackEdge && edge.getType() == EdgeTypes.IFCMP_EDGE) {\n\t\t System.out.println(\"  result: \" +  result);\n\t\t}\n    \n    \n\t}","id":97929,"modified_method":"public void meetInto(UnconditionalValueDerefSet fact, Edge edge,\n\t\t\tUnconditionalValueDerefSet result, boolean onlyEdge) throws DataflowAnalysisException {\n\t\t\n        if (isExceptionEdge(edge) && !onlyEdge) {\n            if (DEBUG) System.out.println(\"Skipping exception edge\");\n            return;\n        }\n        \n        ValueNumber knownNonnullOnBranch = null;\n\t\t// Edge transfer function\n\t\tif (isFactValid(fact)) {\n\t\t\tfact = propagateDerefSetsToMergeInputValues(fact, edge);\n\t\t\tif (invDataflow != null) {\n\t\t\t\tknownNonnullOnBranch = findValueKnownNonnullOnBranch(fact, edge);\n\t\t\t\tif (knownNonnullOnBranch != null) {\n\t\t\t\t\tfact = duplicateFact(fact);\n\t\t\t\t\tfact.clearDerefSet(knownNonnullOnBranch);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean isBackEdge = edge.isBackwardInBytecode();\n\t\tboolean sourceIsTopOfLoop = edge.sourceIsTopOfLoop(ClassContext.getLoopExitBranches(methodGen));\n\t\tif (sourceIsTopOfLoop && edge.getType() == EdgeTypes.FALL_THROUGH_EDGE)\n\t\t\tisBackEdge = true;\n\t\tif (false && (edge.getType() == EdgeTypes.IFCMP_EDGE || sourceIsTopOfLoop)) {\n\t\t\tSystem.out.println(\"Meet into \" + edge);\n\t\t\tSystem.out.println(\"  foo2: \" + sourceIsTopOfLoop);\n\t\t\tSystem.out.println(\"  getType: \" + edge.getType() );\n\t\t    System.out.println(\"  Backedge according to bytecode: \" + isBackEdge);\n\t\t    System.out.println(\"  Fact hashCode: \" + System.identityHashCode(result));\n\t\t    System.out.println(\"  Initial fact: \" + result);\n\t\t    System.out.println(\"  Edge fact: \" + fact);\n\t\t}\n\t\tif (result.isTop() || fact.isBottom()) {\n\t\t\t// Make result identical to other fact\n\t\t\tcopy(fact, result);\n\t\t\tif (ASSUME_NONZERO_TRIP_LOOPS && isBackEdge && !fact.isTop())\n\t\t\t\tresult.resultsFromBackEdge = true;\n\t\t} else if (ASSUME_NONZERO_TRIP_LOOPS && isBackEdge && !fact.isTop()) {\n\t\t\tresult.unionWith(fact, vnaDataflow.getAnalysis().getFactory());\n\t\t\tresult.resultsFromBackEdge = true;\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"\\n Forcing union of \" +  System.identityHashCode(result) + \" due to backedge info\");\n\t\t\t\tSystem.out.println(\"  result: \" +  result);\n\t\t\t}\n\t\t\t\n\t\t} else if (result.isBottom() || fact.isTop()) {\n\t\t\t// No change in result fact\n\t\t} else {\n\t\t\t// Dataflow merge\n\t\t\t// (intersection of unconditional deref values)\n           if (ASSUME_NONZERO_TRIP_LOOPS && result.resultsFromBackEdge) {\n\t\t\t\tresult.backEdgeUpdateCount++;\n\t\t\t\tif (result.backEdgeUpdateCount < 10) {\n\t\t\t\t\tif (DEBUG) System.out.println(\"\\n Union update of \" +  System.identityHashCode(result) + \" due to backedge info\");\n\t\t\t\t\tresult.unionWith(fact, vnaDataflow.getAnalysis().getFactory());\n                    return;\n\t\t\t\t}\n\t\t\t}\n\t\t    result.mergeWith(fact, knownNonnullOnBranch, vnaDataflow.getAnalysis().getFactory());\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"  updated: \" + System.identityHashCode(result));\n\t\t\t\tSystem.out.println(\"  result: \" +  result);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (DEBUG && isBackEdge && edge.getType() == EdgeTypes.IFCMP_EDGE) {\n\t\t System.out.println(\"  result: \" +  result);\n\t\t}\n    \n    \n\t}","commit_id":"412d47e5c51d1ed9854c53f2a72af9226be18c77","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void transferInstruction(InstructionHandle handle,\n\t\t\tBasicBlock basicBlock, UnconditionalValueDerefSet fact)\n\t\t\tthrows DataflowAnalysisException {\n\t\t\n        if (DEBUG) {\n            System.out.println(\"XXX: \" + handle.getPosition() + \" \" + handle.getInstruction());\n        }\n        if (false && handle.getInstruction() instanceof ATHROW )  {\n            fact.clear();\n            fact.markAsOnExceptionPath();\n        }\n\t\tif (fact.isTop()) return;\n\t\tLocation location = new Location(handle, basicBlock);\n\t\t\n\t\t// If this is a call to an assertion method,\n\t\t// change the dataflow value to be TOP.\n\t\t// We don't want to report future derefs that would\n\t\t// be guaranteed only if the assertion methods\n\t\t// returns normally.\n\t\t// TODO: at some point, evaluate whether we should revisit this\n\t\tif (isAssertion(handle) // || handle.getInstruction() instanceof ATHROW \n                ) {\n\t\t\tif (DEBUG) System.out.println(\"MAKING BOTTOM0 AT: \" + location);\n\t\t\tfact.clear();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get value number frame\n\t\tValueNumberFrame vnaFrame = vnaDataflow.getFactAtLocation(location);\n\t\tif (!vnaFrame.isValid()) {\n\t\t\tif (DEBUG) System.out.println(\"MAKING TOP1 AT: \" + location);\n\t\t\t// Probably dead code.\n\t\t\t// Assume this location can't be reached.\n\t\t\tmakeFactTop(fact);\n\t\t\treturn;\n\t\t}\n\t\t\n\n\t\t// Check for calls to a method that unconditionally dereferences\n\t\t// a parameter.  Mark any such arguments as derefs.\n\t\tif (CHECK_CALLS && handle.getInstruction() instanceof InvokeInstruction) {\n\t\t\tcheckUnconditionalDerefDatabase(location, vnaFrame, fact);\n\t\t}\n\t\t\n\t\t// If this is a method call instruction,\n\t\t// check to see if any of the parameters are @NonNull,\n\t\t// and treat them as dereferences.\n\t\tif (CHECK_ANNOTATIONS && handle.getInstruction() instanceof InvokeInstruction) {\n\t\t\tcheckNonNullParams(location, vnaFrame, fact);\n\t\t}\n\n\t\t// Check to see if an instance value is dereferenced here\n\t\tcheckInstance(location, vnaFrame, fact);\n\t\t\n\t\tif (false) fact.cleanDerefSet(location, vnaFrame);\n\n\t\tif (DEBUG && fact.isTop()) System.out.println(\"MAKING TOP2 At: \" + location);\n\t\t\n\t}","id":97930,"modified_method":"@Override\n\tpublic void transferInstruction(InstructionHandle handle,\n\t\t\tBasicBlock basicBlock, UnconditionalValueDerefSet fact)\n\t\t\tthrows DataflowAnalysisException {\n\t\t\n        if (DEBUG) {\n            System.out.println(\"XXX: \" + handle.getPosition() + \" \" + handle.getInstruction());\n        }\n       \tif (fact.isTop()) return;\n\t\tLocation location = new Location(handle, basicBlock);\n\t\t\n\t\t// If this is a call to an assertion method,\n\t\t// change the dataflow value to be TOP.\n\t\t// We don't want to report future derefs that would\n\t\t// be guaranteed only if the assertion methods\n\t\t// returns normally.\n\t\t// TODO: at some point, evaluate whether we should revisit this\n\t\tif (isAssertion(handle) // || handle.getInstruction() instanceof ATHROW \n                ) {\n\t\t\tif (DEBUG) System.out.println(\"MAKING BOTTOM0 AT: \" + location);\n\t\t\tfact.clear();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get value number frame\n\t\tValueNumberFrame vnaFrame = vnaDataflow.getFactAtLocation(location);\n\t\tif (!vnaFrame.isValid()) {\n\t\t\tif (DEBUG) System.out.println(\"MAKING TOP1 AT: \" + location);\n\t\t\t// Probably dead code.\n\t\t\t// Assume this location can't be reached.\n\t\t\tmakeFactTop(fact);\n\t\t\treturn;\n\t\t}\n\t\t\n\n\t\t// Check for calls to a method that unconditionally dereferences\n\t\t// a parameter.  Mark any such arguments as derefs.\n\t\tif (CHECK_CALLS && handle.getInstruction() instanceof InvokeInstruction) {\n\t\t\tcheckUnconditionalDerefDatabase(location, vnaFrame, fact);\n\t\t}\n\t\t\n\t\t// If this is a method call instruction,\n\t\t// check to see if any of the parameters are @NonNull,\n\t\t// and treat them as dereferences.\n\t\tif (CHECK_ANNOTATIONS && handle.getInstruction() instanceof InvokeInstruction) {\n\t\t\tcheckNonNullParams(location, vnaFrame, fact);\n\t\t}\n\n\t\t// Check to see if an instance value is dereferenced here\n\t\tcheckInstance(location, vnaFrame, fact);\n\t\t\n\t\tif (false) fact.cleanDerefSet(location, vnaFrame);\n\n\t\tif (DEBUG && fact.isTop()) System.out.println(\"MAKING TOP2 At: \" + location);\n\t\t\n\t}","commit_id":"412d47e5c51d1ed9854c53f2a72af9226be18c77","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void unionWith(UnconditionalValueDerefSet fact, ValueNumberFactory valueNumberFactory) {\n\t\tif (UnconditionalValueDerefAnalysis.DEBUG) {\n\t\t\tSystem.out.println(\"union update of # \" + System.identityHashCode(this) + \" from \" + System.identityHashCode(fact));\n\t\t}\n\t\t// Compute the union of the unconditionally dereferenced value sets\n\t\tvalueNumbersUnconditionallyDereferenced.or(fact.valueNumbersUnconditionallyDereferenced);\n        valueNumbersUnconditionallyDereferencedOnNonExceptionPath.or(fact.valueNumbersUnconditionallyDereferencedOnNonExceptionPath);\n\n\t\t// For each unconditionally dereferenced value...\n\t\tfor (int i = 0; i < numValueNumbersInMethod; i++) {\n\t\t\tValueNumber vn = valueNumberFactory.forNumber(i);\n\n            if (fact.valueNumbersUnconditionallyDereferenced.get(i) || fact.valueNumbersUnconditionallyDereferencedOnNonExceptionPath.get(i)) {\n                \t// Compute the union of the dereference locations for\n\t\t\t\t// this value number.\n\t\t\t\tSet<Location> derefLocationSet = derefLocationSetMap.get(vn);\n\t\t\t\tif (derefLocationSet == null) {\n\t\t\t\t\tderefLocationSet = new HashSet<Location>();\n\t\t\t\t\tderefLocationSetMap.put(vn,derefLocationSet);\n\t\t\t\t}\n\t\t\t\tderefLocationSet.addAll(fact.derefLocationSetMap.get(vn));\n\t\t\t} else {\n\t\t\t\tderefLocationSetMap.put(vn, new HashSet<Location>(fact.getDerefLocationSet(vn)));\n\t\t\t}\n\t\t}\n\t}","id":97931,"modified_method":"public void unionWith(UnconditionalValueDerefSet fact, ValueNumberFactory valueNumberFactory) {\n\t\tif (UnconditionalValueDerefAnalysis.DEBUG) {\n\t\t\tSystem.out.println(\"union update of # \" + System.identityHashCode(this) + \" from \" + System.identityHashCode(fact));\n\t\t}\n\t\t// Compute the union of the unconditionally dereferenced value sets\n\t\tvalueNumbersUnconditionallyDereferenced.or(fact.valueNumbersUnconditionallyDereferenced);\n        \n\t\t// For each unconditionally dereferenced value...\n\t\tfor (int i = 0; i < numValueNumbersInMethod; i++) {\n\t\t\tValueNumber vn = valueNumberFactory.forNumber(i);\n\n            if (fact.valueNumbersUnconditionallyDereferenced.get(i)) {\n                \t// Compute the union of the dereference locations for\n\t\t\t\t// this value number.\n\t\t\t\tSet<Location> derefLocationSet = derefLocationSetMap.get(vn);\n\t\t\t\tif (derefLocationSet == null) {\n\t\t\t\t\tderefLocationSet = new HashSet<Location>();\n\t\t\t\t\tderefLocationSetMap.put(vn,derefLocationSet);\n\t\t\t\t}\n\t\t\t\tderefLocationSet.addAll(fact.derefLocationSetMap.get(vn));\n\t\t\t} else {\n\t\t\t\tderefLocationSetMap.put(vn, new HashSet<Location>(fact.getDerefLocationSet(vn)));\n\t\t\t}\n\t\t}\n\t}","commit_id":"412d47e5c51d1ed9854c53f2a72af9226be18c77","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Make this dataflow fact the same as the given one.\n\t * \n\t * @param source another dataflow fact\n\t */\n\tpublic void makeSameAs(UnconditionalValueDerefSet source) {\n\t\t// Copy value numbers\n\t\tvalueNumbersUnconditionallyDereferenced.clear();\n\t\tvalueNumbersUnconditionallyDereferenced.or(source.valueNumbersUnconditionallyDereferenced);\n        valueNumbersUnconditionallyDereferencedOnNonExceptionPath.clear();\n        valueNumbersUnconditionallyDereferencedOnNonExceptionPath.or(source.valueNumbersUnconditionallyDereferencedOnNonExceptionPath);\n \t\tlastUpdateTimestamp = source.lastUpdateTimestamp;\n\t\t// Copy dereference locations for each value number\n\t\tderefLocationSetMap.clear();\n\t\tfor (Map.Entry<ValueNumber, Set<Location>> sourceEntry : source.derefLocationSetMap.entrySet()) {\n\t\t\tSet<Location> derefLocationSet = new HashSet<Location>();\n\t\t\tderefLocationSet.addAll(sourceEntry.getValue());\n\t\t\tderefLocationSetMap.put(sourceEntry.getKey(), derefLocationSet);\n\t\t}\n\t}","id":97932,"modified_method":"/**\n\t * Make this dataflow fact the same as the given one.\n\t * \n\t * @param source another dataflow fact\n\t */\n\tpublic void makeSameAs(UnconditionalValueDerefSet source) {\n\t\t// Copy value numbers\n\t\tvalueNumbersUnconditionallyDereferenced.clear();\n\t\tvalueNumbersUnconditionallyDereferenced.or(source.valueNumbersUnconditionallyDereferenced);\n       lastUpdateTimestamp = source.lastUpdateTimestamp;\n\t\t// Copy dereference locations for each value number\n\t\tderefLocationSetMap.clear();\n\t\tfor (Map.Entry<ValueNumber, Set<Location>> sourceEntry : source.derefLocationSetMap.entrySet()) {\n\t\t\tSet<Location> derefLocationSet = new HashSet<Location>();\n\t\t\tderefLocationSet.addAll(sourceEntry.getValue());\n\t\t\tderefLocationSetMap.put(sourceEntry.getKey(), derefLocationSet);\n\t\t}\n\t}","commit_id":"412d47e5c51d1ed9854c53f2a72af9226be18c77","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param numValueNumbersInMethod number of distinct value numbers in method\n\t */\n\tpublic UnconditionalValueDerefSet(int numValueNumbersInMethod) {\n\t\tthis.numValueNumbersInMethod = numValueNumbersInMethod;\n\t\tthis.valueNumbersUnconditionallyDereferenced = new BitSet();\n        this.valueNumbersUnconditionallyDereferencedOnNonExceptionPath = new BitSet();\n\t\tthis.derefLocationSetMap = new HashMap<ValueNumber, Set<Location>>();\n\t\t\n\t}","id":97933,"modified_method":"/**\n\t * Constructor.\n\t * \n\t * @param numValueNumbersInMethod number of distinct value numbers in method\n\t */\n\tpublic UnconditionalValueDerefSet(int numValueNumbersInMethod) {\n\t\tthis.numValueNumbersInMethod = numValueNumbersInMethod;\n\t\tthis.valueNumbersUnconditionallyDereferenced = new BitSet();\n       this.derefLocationSetMap = new HashMap<ValueNumber, Set<Location>>();\n\t\t\n\t}","commit_id":"412d47e5c51d1ed9854c53f2a72af9226be18c77","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Merge given dataflow fact into this one.\n\t * We take the intersection of the unconditional deref value number set,\n\t * and union the deref locations.\n\t * \n\t * @param fact another dataflow fact\n\t * @param skipMe TODO\n\t */\n\tpublic void mergeWith(UnconditionalValueDerefSet fact, @CheckForNull ValueNumber skipMe, ValueNumberFactory valueNumberFactory) {\n\t\tif (UnconditionalValueDerefAnalysis.DEBUG) {\n\t\t\tSystem.out.println(\"merge update of # \" + System.identityHashCode(this) + \" from \" + System.identityHashCode(fact));\n\t\t\tSystem.out.println(\"update \" + this);\n\t\t\tSystem.out.println(\"with \" + fact);\n            if (valueNumbersUnconditionallyDereferencedOnNonExceptionPath.get(1))\n                System.out.println(\"XXX\");\n\t\t}\n\t\tboolean resultForSkippedValue = false;\n\t\tif (skipMe != null) {\n\t\t\tresultForSkippedValue = valueNumbersUnconditionallyDereferenced.get(skipMe.getNumber());\n\t\t}\n\t\t// Compute the intersection of the unconditionally dereferenced value sets\n\t\tvalueNumbersUnconditionallyDereferenced.and(fact.valueNumbersUnconditionallyDereferenced);\n\t\tif (skipMe != null) {\n\t\t\tvalueNumbersUnconditionallyDereferenced.set(skipMe.getNumber(), resultForSkippedValue);\n\t\t}\n        valueNumbersUnconditionallyDereferencedOnNonExceptionPath.and(fact.valueNumbersUnconditionallyDereferencedOnNonExceptionPath);\n        if (skipMe != null) {\n            valueNumbersUnconditionallyDereferencedOnNonExceptionPath.set(skipMe.getNumber(), \n                    valueNumbersUnconditionallyDereferencedOnNonExceptionPath.get(skipMe.getNumber()));\n        }\n\n\t\t// For each unconditionally dereferenced value...\n\t\tfor (int i = 0; i < numValueNumbersInMethod; i++) {\n\t\t\tValueNumber vn = valueNumberFactory.forNumber(i);\n\t\t\tif (vn.equals(skipMe)) continue;\n\t\t\tSet<Location> factDerefLocationSet = fact.derefLocationSetMap.get(vn);\n\t\t\tif (valueNumbersUnconditionallyDereferenced.get(i) || valueNumbersUnconditionallyDereferencedOnNonExceptionPath.get(i)) {\n\t\t\t    if (factDerefLocationSet != null && !factDerefLocationSet.isEmpty()) {\n\t\t\t        // Compute the union of the dereference locations for\n\t\t\t        // this value number.\n\t\t\t        Set<Location> derefLocationSet = derefLocationSetMap.get(vn);\n\t\t\t        if (derefLocationSet == null) {\n\t\t\t            derefLocationSet = new HashSet<Location>();\n\t\t\t            derefLocationSetMap.put(vn, derefLocationSet);\n\t\t\t        }\n\t\t\t        derefLocationSet.addAll(fact.derefLocationSetMap.get(vn));\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    Set<Location> removed = derefLocationSetMap.remove(vn);\n                // The value number is not in the fact:\n\t\t\t    // remove its location set\n\t\t\t    if (removed != null) {\n\t\t\t            if (UnconditionalValueDerefAnalysis.DEBUG) System.out.println(\"Goodbye: \" + removed);\n                }\n\t\t\t}\n\t\t}\n\t}","id":97934,"modified_method":"/**\n\t * Merge given dataflow fact into this one.\n\t * We take the intersection of the unconditional deref value number set,\n\t * and union the deref locations.\n\t * \n\t * @param fact another dataflow fact\n\t * @param skipMe TODO\n\t */\n\tpublic void mergeWith(UnconditionalValueDerefSet fact, @CheckForNull ValueNumber skipMe, ValueNumberFactory valueNumberFactory) {\n\t\tif (UnconditionalValueDerefAnalysis.DEBUG) {\n\t\t\tSystem.out.println(\"merge update of # \" + System.identityHashCode(this) + \" from \" + System.identityHashCode(fact));\n\t\t\tSystem.out.println(\"update \" + this);\n\t\t\tSystem.out.println(\"with \" + fact);\n\n\t\t}\n\t\tboolean resultForSkippedValue = false;\n\t\tif (skipMe != null) {\n\t\t\tresultForSkippedValue = valueNumbersUnconditionallyDereferenced.get(skipMe.getNumber());\n\t\t}\n\t\t// Compute the intersection of the unconditionally dereferenced value sets\n\t\tvalueNumbersUnconditionallyDereferenced.and(fact.valueNumbersUnconditionallyDereferenced);\n\t\tif (skipMe != null) {\n\t\t\tvalueNumbersUnconditionallyDereferenced.set(skipMe.getNumber(), resultForSkippedValue);\n\t\t}\n       \n\t\t// For each unconditionally dereferenced value...\n\t\tfor (int i = 0; i < numValueNumbersInMethod; i++) {\n\t\t\tValueNumber vn = valueNumberFactory.forNumber(i);\n\t\t\tif (vn.equals(skipMe)) continue;\n\t\t\tSet<Location> factDerefLocationSet = fact.derefLocationSetMap.get(vn);\n\t\t\tif (valueNumbersUnconditionallyDereferenced.get(i) ) {\n\t\t\t    if (factDerefLocationSet != null && !factDerefLocationSet.isEmpty()) {\n\t\t\t        // Compute the union of the dereference locations for\n\t\t\t        // this value number.\n\t\t\t        Set<Location> derefLocationSet = derefLocationSetMap.get(vn);\n\t\t\t        if (derefLocationSet == null) {\n\t\t\t            derefLocationSet = new HashSet<Location>();\n\t\t\t            derefLocationSetMap.put(vn, derefLocationSet);\n\t\t\t        }\n\t\t\t        derefLocationSet.addAll(fact.derefLocationSetMap.get(vn));\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    Set<Location> removed = derefLocationSetMap.remove(vn);\n                // The value number is not in the fact:\n\t\t\t    // remove its location set\n\t\t\t    if (removed != null) {\n\t\t\t            if (UnconditionalValueDerefAnalysis.DEBUG) System.out.println(\"Goodbye: \" + removed);\n                }\n\t\t\t}\n\t\t}\n\t}","commit_id":"412d47e5c51d1ed9854c53f2a72af9226be18c77","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Set a value as being unconditionally dereferenced at the\n\t * given set of locations. \n\t * \n\t * @param vn       the value\n\t * @param derefSet the Set of dereference Locations\n\t */\n\tpublic void setDerefSet(ValueNumber vn, Set<Location> derefSet) {\n\t\tif (UnconditionalValueDerefAnalysis.DEBUG) {\n\t\t\tSystem.out.println(\"Adding dereference of \" + vn + \" for # \" + System.identityHashCode(this) + \" to \" + derefSet);\n\t\t}\n\t\tvalueNumbersUnconditionallyDereferenced.set(vn.getNumber());\n        valueNumbersUnconditionallyDereferencedOnNonExceptionPath.set(vn.getNumber());\n        \n\t\tSet<Location> derefLocationSet = getDerefLocationSet(vn);\n\t\tderefLocationSet.clear();\n\t\tderefLocationSet.addAll(derefSet);\n\t}","id":97935,"modified_method":"/**\n\t * Set a value as being unconditionally dereferenced at the\n\t * given set of locations. \n\t * \n\t * @param vn       the value\n\t * @param derefSet the Set of dereference Locations\n\t */\n\tpublic void setDerefSet(ValueNumber vn, Set<Location> derefSet) {\n\t\tif (UnconditionalValueDerefAnalysis.DEBUG) {\n\t\t\tSystem.out.println(\"Adding dereference of \" + vn + \" for # \" + System.identityHashCode(this) + \" to \" + derefSet);\n\t\t}\n\t\tvalueNumbersUnconditionallyDereferenced.set(vn.getNumber());\n        \n\t\tSet<Location> derefLocationSet = getDerefLocationSet(vn);\n\t\tderefLocationSet.clear();\n\t\tderefLocationSet.addAll(derefSet);\n\t}","commit_id":"412d47e5c51d1ed9854c53f2a72af9226be18c77","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Clear the set of dereferences for given ValueNumber\n\t * \n\t * @param value the ValueNumber\n\t */\n\tpublic void clearDerefSet(ValueNumber value) {\n\t\tif (UnconditionalValueDerefAnalysis.DEBUG) {\n\t\t\tSystem.out.println(\"Clearing dereference of \" + value + \" for # \" + System.identityHashCode(this));\n\t\t}\n\t\tvalueNumbersUnconditionallyDereferenced.clear(value.getNumber());\n        valueNumbersUnconditionallyDereferencedOnNonExceptionPath.clear(value.getNumber());\n\t\tderefLocationSetMap.remove(value);\n\t}","id":97936,"modified_method":"/**\n\t * Clear the set of dereferences for given ValueNumber\n\t * \n\t * @param value the ValueNumber\n\t */\n\tpublic void clearDerefSet(ValueNumber value) {\n\t\tif (UnconditionalValueDerefAnalysis.DEBUG) {\n\t\t\tSystem.out.println(\"Clearing dereference of \" + value + \" for # \" + System.identityHashCode(this));\n\t\t}\n\t\tvalueNumbersUnconditionallyDereferenced.clear(value.getNumber());\n  \t\tderefLocationSetMap.remove(value);\n\t}","commit_id":"412d47e5c51d1ed9854c53f2a72af9226be18c77","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Return whether or not this dataflow fact is identical\n\t * to the one given.\n\t * \n\t * @param otherFact another dataflow fact\n\t * @return true if the other dataflow fact is identical to this one,\n\t *          false otherwise\n\t */\n\tpublic boolean isSameAs(UnconditionalValueDerefSet otherFact) {\n\t\treturn \n         valueNumbersUnconditionallyDereferenced.equals(otherFact.valueNumbersUnconditionallyDereferenced)\n\t\t\t&& valueNumbersUnconditionallyDereferencedOnNonExceptionPath.equals(otherFact.valueNumbersUnconditionallyDereferencedOnNonExceptionPath)\n        && derefLocationSetMap.equals(otherFact.derefLocationSetMap);\n\t}","id":97937,"modified_method":"/**\n\t * Return whether or not this dataflow fact is identical\n\t * to the one given.\n\t * \n\t * @param otherFact another dataflow fact\n\t * @return true if the other dataflow fact is identical to this one,\n\t *          false otherwise\n\t */\n\tpublic boolean isSameAs(UnconditionalValueDerefSet otherFact) {\n\t\treturn \n         valueNumbersUnconditionallyDereferenced.equals(otherFact.valueNumbersUnconditionallyDereferenced)\n        && derefLocationSetMap.equals(otherFact.derefLocationSetMap);\n\t}","commit_id":"412d47e5c51d1ed9854c53f2a72af9226be18c77","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic String toString() {\n\t\tif (isTop()) {\n\t\t\treturn \"[TOP]\";\n\t\t}\n\t\tif (isBottom()) {\n\t\t\treturn \"[BOTTOM]\";\n\t\t}\n\t\t\n\t\tStringBuffer buf = new StringBuffer();\n\t\tbuf.append('[');\n\t\tboolean firstVN = true;\n\t\tfor (int i = 0; i < numValueNumbersInMethod; i++)  {\n\t\t\tif (!(valueNumbersUnconditionallyDereferenced.get(i) || valueNumbersUnconditionallyDereferencedOnNonExceptionPath.get(i))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (firstVN) {\n\t\t\t\tfirstVN = false;\n\t\t\t} else {\n\t\t\t\tbuf.append(',');\n\t\t\t}\n\t\t\tbuf.append('{');\n\t\t\tbuf.append(i);\n            if (valueNumbersUnconditionallyDereferenced.get(i))\n\t\t\tbuf.append(':');\n            else buf.append('?');\n\t\t\tTreeSet<Location> derefLocationSet = new TreeSet<Location>();\n\t\t\tderefLocationSet.addAll(getDerefLocationSet(i));\n\t\t\tboolean firstLoc = true;\n\t\t\tfor (Location location : derefLocationSet) {\n\t\t\t\tif (firstLoc) {\n\t\t\t\t\tfirstLoc = false;\n\t\t\t\t} else {\n\t\t\t\t\tbuf.append(',');\n\t\t\t\t}\n\t\t\t\tbuf.append(\n\t\t\t\t\t\t\"(\" +\n\t\t\t\t\t\t\t\tlocation.getBasicBlock().getId() +\n\t\t\t\t\t\t\t\t\":\" +\n\t\t\t\t\t\t\t\tlocation.getHandle().getPosition() +\n\t\t\t\t\t\t\t\t\")\");\n\t\t\t}\n\t\t\tbuf.append('}');\n\t\t}\n\t\tbuf.append(']');\n\t\tbuf.append(\" # \");\n\t\tbuf.append(System.identityHashCode(this));\n\t\treturn buf.toString();\n\t}","id":97938,"modified_method":"@Override\n\tpublic String toString() {\n\t\tif (isTop()) {\n\t\t\treturn \"[TOP]\";\n\t\t}\n\t\tif (isBottom()) {\n\t\t\treturn \"[BOTTOM]\";\n\t\t}\n\t\t\n\t\tStringBuffer buf = new StringBuffer();\n\t\tbuf.append('[');\n\t\tboolean firstVN = true;\n\t\tfor (int i = 0; i < numValueNumbersInMethod; i++)  {\n\t\t\tif (!(valueNumbersUnconditionallyDereferenced.get(i))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (firstVN) {\n\t\t\t\tfirstVN = false;\n\t\t\t} else {\n\t\t\t\tbuf.append(',');\n\t\t\t}\n\t\t\tbuf.append('{');\n\t\t\tbuf.append(i);\n            if (valueNumbersUnconditionallyDereferenced.get(i))\n\t\t\tbuf.append(':');\n            else buf.append('?');\n\t\t\tTreeSet<Location> derefLocationSet = new TreeSet<Location>();\n\t\t\tderefLocationSet.addAll(getDerefLocationSet(i));\n\t\t\tboolean firstLoc = true;\n\t\t\tfor (Location location : derefLocationSet) {\n\t\t\t\tif (firstLoc) {\n\t\t\t\t\tfirstLoc = false;\n\t\t\t\t} else {\n\t\t\t\t\tbuf.append(',');\n\t\t\t\t}\n\t\t\t\tbuf.append(\n\t\t\t\t\t\t\"(\" +\n\t\t\t\t\t\t\t\tlocation.getBasicBlock().getId() +\n\t\t\t\t\t\t\t\t\":\" +\n\t\t\t\t\t\t\t\tlocation.getHandle().getPosition() +\n\t\t\t\t\t\t\t\t\")\");\n\t\t\t}\n\t\t\tbuf.append('}');\n\t\t}\n\t\tbuf.append(']');\n\t\tbuf.append(\" # \");\n\t\tbuf.append(System.identityHashCode(this));\n\t\treturn buf.toString();\n\t}","commit_id":"412d47e5c51d1ed9854c53f2a72af9226be18c77","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Clear the deref set.\n\t * This sets the fact so it is valid as the dataflow entry fact:\n\t * no future dereferences are guaranteed.\n\t */\n\tvoid clear() {\n\t\tvalueNumbersUnconditionallyDereferenced.clear();\n        valueNumbersUnconditionallyDereferencedOnNonExceptionPath.clear();\n\t\tderefLocationSetMap.clear();\n\t}","id":97939,"modified_method":"/**\n\t * Clear the deref set.\n\t * This sets the fact so it is valid as the dataflow entry fact:\n\t * no future dereferences are guaranteed.\n\t */\n\tvoid clear() {\n\t\tvalueNumbersUnconditionallyDereferenced.clear();\n        derefLocationSetMap.clear();\n\t}","commit_id":"412d47e5c51d1ed9854c53f2a72af9226be18c77","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Mark a value as being dereferenced at given Location.\n\t * \n\t * @param vn       the value\n\t * @param location the Location\n\t */\n\tpublic void addDeref(ValueNumber vn, Location location) {\n\t\tif (UnconditionalValueDerefAnalysis.DEBUG) {\n\t\t\tSystem.out.println(\"Adding dereference of \" + vn + \" to # \" + System.identityHashCode(this) + \" @ \" + location);\n\t\t}\n\t\tvalueNumbersUnconditionallyDereferenced.set(vn.getNumber());\n        valueNumbersUnconditionallyDereferencedOnNonExceptionPath.set(vn.getNumber());\n        \n\t\tSet<Location> derefLocationSet = getDerefLocationSet(vn);\n\t\tderefLocationSet.add(location);\n\t}","id":97940,"modified_method":"/**\n\t * Mark a value as being dereferenced at given Location.\n\t * \n\t * @param vn       the value\n\t * @param location the Location\n\t */\n\tpublic void addDeref(ValueNumber vn, Location location) {\n\t\tif (UnconditionalValueDerefAnalysis.DEBUG) {\n\t\t\tSystem.out.println(\"Adding dereference of \" + vn + \" to # \" + System.identityHashCode(this) + \" @ \" + location);\n\t\t}\n\t\tvalueNumbersUnconditionallyDereferenced.set(vn.getNumber());\n         \n\t\tSet<Location> derefLocationSet = getDerefLocationSet(vn);\n\t\tderefLocationSet.add(location);\n\t}","commit_id":"412d47e5c51d1ed9854c53f2a72af9226be18c77","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void retainOnlyTheseValueNumbers(Set<ValueNumber> valueNumbers) {\n\t\tfor(Iterator<ValueNumber> i = derefLocationSetMap.keySet().iterator(); i.hasNext(); ) {\n\t\t\tValueNumber v = i.next();\n\t\t\tif (!valueNumbers.contains(v)) {\n\t\t\t\ti.remove();\n\t\t\t\tvalueNumbersUnconditionallyDereferenced.clear(v.getNumber());\n                valueNumbersUnconditionallyDereferencedOnNonExceptionPath.clear(v.getNumber());\n\t\t\t}\n\t\t}\n\t}","id":97941,"modified_method":"public void retainOnlyTheseValueNumbers(Set<ValueNumber> valueNumbers) {\n\t\tfor(Iterator<ValueNumber> i = derefLocationSetMap.keySet().iterator(); i.hasNext(); ) {\n\t\t\tValueNumber v = i.next();\n\t\t\tif (!valueNumbers.contains(v)) {\n\t\t\t\ti.remove();\n\t\t\t\tvalueNumbersUnconditionallyDereferenced.clear(v.getNumber());\n \t\t\t}\n\t\t}\n\t}","commit_id":"412d47e5c51d1ed9854c53f2a72af9226be18c77","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void sendDiscoveryResponse(Address logical_addr, List<PhysicalAddress> physical_addrs,\n                                       Address coord, boolean is_server, String logical_name, Address sender) {\n        PingData ping_rsp=new PingData(logical_addr, view, is_server, logical_name, physical_addrs);\n        Message rsp_msg=new Message(sender, null, null);\n        rsp_msg.setFlag(Message.OOB);\n        PingHeader rsp_hdr=new PingHeader(PingHeader.GET_MBRS_RSP, ping_rsp);\n        rsp_msg.putHeader(getName(), rsp_hdr);\n        if(log.isTraceEnabled())\n            log.trace(\"received GET_MBRS_REQ from \" + sender + \", sending response \" + rsp_hdr);\n        down_prot.down(new Event(Event.MSG, rsp_msg));\n    }","id":97942,"modified_method":"private void sendDiscoveryResponse(Address logical_addr, List<PhysicalAddress> physical_addrs,\n                                       boolean is_server, String logical_name, Address sender) {\n        PingData ping_rsp=new PingData(logical_addr, view, is_server, logical_name, physical_addrs);\n        Message rsp_msg=new Message(sender, null, null);\n        rsp_msg.setFlag(Message.OOB);\n        PingHeader rsp_hdr=new PingHeader(PingHeader.GET_MBRS_RSP, ping_rsp);\n        rsp_msg.putHeader(getName(), rsp_hdr);\n        if(log.isTraceEnabled())\n            log.trace(\"received GET_MBRS_REQ from \" + sender + \", sending response \" + rsp_hdr);\n        down_prot.down(new Event(Event.MSG, rsp_msg));\n    }","commit_id":"8560bb035b17d5c8da33cace62f154b7e7c5d702","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * An event was received from the layer below. Usually the current layer will want to examine\n     * the event type and - depending on its type - perform some computation\n     * (e.g. removing headers from a MSG event type, or updating the internal membership list\n     * when receiving a VIEW_CHANGE event).\n     * Finally the event is either a) discarded, or b) an event is sent down\n     * the stack using <code>PassDown<\/code> or c) the event (or another event) is sent up\n     * the stack using <code>PassUp<\/code>.\n     * <p/>\n     * For the PING protocol, the Up operation does the following things.\n     * 1. If the event is a Event.MSG then PING will inspect the message header.\n     * If the header is null, PING simply passes up the event\n     * If the header is PingHeader.GET_MBRS_REQ then the PING protocol\n     * will PassDown a PingRequest message\n     * If the header is PingHeader.GET_MBRS_RSP we will add the message to the initial members\n     * vector and wake up any waiting threads.\n     * 2. If the event is Event.SET_LOCAL_ADDR we will simple set the local address of this protocol\n     * 3. For all other messages we simple pass it up to the protocol above\n     *\n     * @param evt - the event that has been sent from the layer below\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public Object up(Event evt) {\n        \n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                PingHeader hdr=(PingHeader)msg.getHeader(getName());\n                if(hdr == null)\n                    return up_prot.up(evt);\n\n                switch(hdr.type) {\n\n                    case PingHeader.GET_MBRS_REQ:   // return Rsp(local_addr, coord)\n                        if(local_addr != null && msg.getSrc() != null && local_addr.equals(msg.getSrc())) {\n                            return null;\n                        }\n\n                        if(group_addr == null || hdr.cluster_name == null) {\n                            if(log.isWarnEnabled())\n                                log.warn(\"group_addr (\" + group_addr + \") or cluster_name of header (\" + hdr.cluster_name\n                                        + \") is null; passing up discovery request from \" + msg.getSrc() + \", but this should not\" +\n                                        \" be the case\");\n                        }\n                        else {\n                            if(!group_addr.equals(hdr.cluster_name)) {\n                                if(log.isWarnEnabled())\n                                    log.warn(\"discarding discovery request for cluster '\" + hdr.cluster_name + \"' from \" +\n                                            msg.getSrc() + \"; our cluster name is '\" + group_addr + \"'. \" +\n                                            \"Please separate your clusters cleanly.\");\n                                return null;\n                            }\n                        }\n\n                        // add physical address (if available) to transport's cache\n                        if(hdr.arg != null) {\n                            Address logical_addr=hdr.arg.getAddress();\n                            if(logical_addr == null)\n                                logical_addr=msg.getSrc();\n                            Collection<PhysicalAddress> physical_addrs=hdr.arg.getPhysicalAddrs();\n                            PhysicalAddress physical_addr=physical_addrs != null && !physical_addrs.isEmpty()? physical_addrs.iterator().next() : null;\n                            if(logical_addr != null && physical_addr != null)\n                                down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address,PhysicalAddress>(logical_addr, physical_addr)));\n                            if(logical_addr != null && hdr.arg.getLogicalName() != null)\n                                UUID.add((UUID)logical_addr, hdr.arg.getLogicalName());\n                        }\n\n                        Address coord;\n                        synchronized(members) {\n                            coord=!members.isEmpty()? members.firstElement() : local_addr;\n                        }\n\n                        if(return_entire_cache) {\n                            Map<Address,PhysicalAddress> cache=(Map<Address,PhysicalAddress>)down(new Event(Event.GET_LOGICAL_PHYSICAL_MAPPINGS));\n                            if(cache != null) {\n                                for(Map.Entry<Address,PhysicalAddress> entry: cache.entrySet()) {\n                                    Address logical_addr=entry.getKey();\n                                    PhysicalAddress physical_addr=entry.getValue();\n                                    sendDiscoveryResponse(logical_addr, Arrays.asList(physical_addr), coord, is_server,\n                                                          UUID.get(logical_addr), msg.getSrc());\n                                }\n                            }\n                        }\n                        else {\n                            PhysicalAddress physical_addr=(PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr));\n                            sendDiscoveryResponse(local_addr, Arrays.asList(physical_addr), coord, is_server,\n                                                  UUID.get(local_addr), msg.getSrc());\n                        }\n                        return null;\n\n                    case PingHeader.GET_MBRS_RSP:   // add response to vector and notify waiting thread\n                        PingData rsp=hdr.arg;\n\n                        // add physical address (if available) to transport's cache\n                        if(rsp != null) {\n                            Address response_sender=msg.getSrc();\n                            Address logical_addr=rsp.getAddress();\n                            if(logical_addr == null)\n                                logical_addr=msg.getSrc();\n                            Collection<PhysicalAddress> physical_addrs=rsp.getPhysicalAddrs();\n                            PhysicalAddress physical_addr=physical_addrs != null && !physical_addrs.isEmpty()?\n                                    physical_addrs.iterator().next() : null;\n                            if(logical_addr != null && physical_addr != null)\n                                down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address,PhysicalAddress>(logical_addr, physical_addr)));\n                            if(logical_addr != null && rsp.getLogicalName() != null)\n                                UUID.add((UUID)logical_addr, rsp.getLogicalName());\n\n                            if(log.isTraceEnabled())\n                                log.trace(\"received GET_MBRS_RSP from \" + response_sender + \": \" + rsp);\n                            synchronized(ping_responses) {\n                                for(Responses rsps: ping_responses) {\n                                    boolean overwrite=logical_addr.equals(response_sender);\n                                    rsps.addResponse(rsp, overwrite);\n                                }\n                            }\n                        }\n                        return null;\n\n                    default:\n                        if(log.isWarnEnabled()) log.warn(\"got PING header with unknown type (\" + hdr.type + ')');\n                        return null;\n                }\n\n\n            case Event.GET_PHYSICAL_ADDRESS:\n                try {\n                    sendGetMembersRequest(group_addr, null);\n                }\n                catch(InterruptedIOException ie) {\n                    if(log.isWarnEnabled()){\n                        log.warn(\"Discovery request for cluster \" + group_addr + \" interrupted\");\n                    }\n                    Thread.currentThread().interrupt();\n                }\n                catch(Exception ex) {\n                    if(log.isErrorEnabled())\n                        log.error(\"failed sending discovery request\", ex);\n                }\n                return null;\n        }\n\n        return up_prot.up(evt);\n    }","id":97943,"modified_method":"/**\n     * An event was received from the layer below. Usually the current layer will want to examine\n     * the event type and - depending on its type - perform some computation\n     * (e.g. removing headers from a MSG event type, or updating the internal membership list\n     * when receiving a VIEW_CHANGE event).\n     * Finally the event is either a) discarded, or b) an event is sent down\n     * the stack using <code>PassDown<\/code> or c) the event (or another event) is sent up\n     * the stack using <code>PassUp<\/code>.\n     * <p/>\n     * For the PING protocol, the Up operation does the following things.\n     * 1. If the event is a Event.MSG then PING will inspect the message header.\n     * If the header is null, PING simply passes up the event\n     * If the header is PingHeader.GET_MBRS_REQ then the PING protocol\n     * will PassDown a PingRequest message\n     * If the header is PingHeader.GET_MBRS_RSP we will add the message to the initial members\n     * vector and wake up any waiting threads.\n     * 2. If the event is Event.SET_LOCAL_ADDR we will simple set the local address of this protocol\n     * 3. For all other messages we simple pass it up to the protocol above\n     *\n     * @param evt - the event that has been sent from the layer below\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public Object up(Event evt) {\n        \n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                PingHeader hdr=(PingHeader)msg.getHeader(getName());\n                if(hdr == null)\n                    return up_prot.up(evt);\n\n                switch(hdr.type) {\n\n                    case PingHeader.GET_MBRS_REQ:   // return Rsp(local_addr, coord)\n                        if(local_addr != null && msg.getSrc() != null && local_addr.equals(msg.getSrc())) {\n                            return null;\n                        }\n\n                        if(group_addr == null || hdr.cluster_name == null) {\n                            if(log.isWarnEnabled())\n                                log.warn(\"group_addr (\" + group_addr + \") or cluster_name of header (\" + hdr.cluster_name\n                                        + \") is null; passing up discovery request from \" + msg.getSrc() + \", but this should not\" +\n                                        \" be the case\");\n                        }\n                        else {\n                            if(!group_addr.equals(hdr.cluster_name)) {\n                                if(log.isWarnEnabled())\n                                    log.warn(\"discarding discovery request for cluster '\" + hdr.cluster_name + \"' from \" +\n                                            msg.getSrc() + \"; our cluster name is '\" + group_addr + \"'. \" +\n                                            \"Please separate your clusters cleanly.\");\n                                return null;\n                            }\n                        }\n\n                        // add physical address (if available) to transport's cache\n                        if(hdr.arg != null) {\n                            Address logical_addr=hdr.arg.getAddress();\n                            if(logical_addr == null)\n                                logical_addr=msg.getSrc();\n                            Collection<PhysicalAddress> physical_addrs=hdr.arg.getPhysicalAddrs();\n                            PhysicalAddress physical_addr=physical_addrs != null && !physical_addrs.isEmpty()? physical_addrs.iterator().next() : null;\n                            if(logical_addr != null && physical_addr != null)\n                                down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address,PhysicalAddress>(logical_addr, physical_addr)));\n                            if(logical_addr != null && hdr.arg.getLogicalName() != null)\n                                UUID.add((UUID)logical_addr, hdr.arg.getLogicalName());\n                        }\n\n                        if(return_entire_cache) {\n                            Map<Address,PhysicalAddress> cache=(Map<Address,PhysicalAddress>)down(new Event(Event.GET_LOGICAL_PHYSICAL_MAPPINGS));\n                            if(cache != null) {\n                                for(Map.Entry<Address,PhysicalAddress> entry: cache.entrySet()) {\n                                    Address logical_addr=entry.getKey();\n                                    PhysicalAddress physical_addr=entry.getValue();\n                                    sendDiscoveryResponse(logical_addr, Arrays.asList(physical_addr), is_server,\n                                                          UUID.get(logical_addr), msg.getSrc());\n                                }\n                            }\n                        }\n                        else {\n                            PhysicalAddress physical_addr=(PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr));\n                            sendDiscoveryResponse(local_addr, Arrays.asList(physical_addr), is_server,\n                                                  UUID.get(local_addr), msg.getSrc());\n                        }\n                        return null;\n\n                    case PingHeader.GET_MBRS_RSP:   // add response to vector and notify waiting thread\n                        PingData rsp=hdr.arg;\n\n                        // add physical address (if available) to transport's cache\n                        if(rsp != null) {\n                            Address response_sender=msg.getSrc();\n                            Address logical_addr=rsp.getAddress();\n                            if(logical_addr == null)\n                                logical_addr=msg.getSrc();\n                            Collection<PhysicalAddress> physical_addrs=rsp.getPhysicalAddrs();\n                            PhysicalAddress physical_addr=physical_addrs != null && !physical_addrs.isEmpty()?\n                                    physical_addrs.iterator().next() : null;\n                            if(logical_addr != null && physical_addr != null)\n                                down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address,PhysicalAddress>(logical_addr, physical_addr)));\n                            if(logical_addr != null && rsp.getLogicalName() != null)\n                                UUID.add((UUID)logical_addr, rsp.getLogicalName());\n\n                            if(log.isTraceEnabled())\n                                log.trace(\"received GET_MBRS_RSP from \" + response_sender + \": \" + rsp);\n                            synchronized(ping_responses) {\n                                for(Responses rsps: ping_responses) {\n                                    boolean overwrite=logical_addr.equals(response_sender);\n                                    rsps.addResponse(rsp, overwrite);\n                                }\n                            }\n                        }\n                        return null;\n\n                    default:\n                        if(log.isWarnEnabled()) log.warn(\"got PING header with unknown type (\" + hdr.type + ')');\n                        return null;\n                }\n\n\n            case Event.GET_PHYSICAL_ADDRESS:\n                try {\n                    sendGetMembersRequest(group_addr, null);\n                }\n                catch(InterruptedIOException ie) {\n                    if(log.isWarnEnabled()){\n                        log.warn(\"Discovery request for cluster \" + group_addr + \" interrupted\");\n                    }\n                    Thread.currentThread().interrupt();\n                }\n                catch(Exception ex) {\n                    if(log.isErrorEnabled())\n                        log.error(\"failed sending discovery request\", ex);\n                }\n                return null;\n        }\n\n        return up_prot.up(evt);\n    }","commit_id":"8560bb035b17d5c8da33cace62f154b7e7c5d702","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendToAllMembers(List<RouterStub> stubs, byte[] data, int offset, int length)\n               throws Exception {\n         boolean sent = false;\n         Collections.shuffle(stubs);\n         for (RouterStub stub : stubs) {\n            try {\n               stub.sendToAllMembers(data, offset, length);\n               if (log.isDebugEnabled())\n                  log.debug(stub.getLocalAddress() + \" sent a message to all members, GR used \"\n                           + stub.getGossipRouterAddress());\n               sent = true;\n               break;\n            } catch (Exception e) {\n               try {\n                  if (log.isWarnEnabled())\n                     log.warn(stub.getLocalAddress()\n                              + \" failed sending a message to all members, GR used \"\n                              + stub.getGossipRouterAddress());\n               } catch (SocketException e1) {\n               }\n            }\n         }\n         if (!sent)\n            throw new Exception(\"None of the available stubs \" + stubs\n                     + \" accepted a multicast message\");\n      }","id":97944,"modified_method":"public void sendToAllMembers(List<RouterStub> stubs, byte[] data, int offset, int length)\n               throws Exception {\n         boolean sent = false;\n          if(stubs.size() > 1)\n              Collections.shuffle(stubs);  // todo: why is this needed ?\n         for (RouterStub stub : stubs) {\n            try {\n               stub.sendToAllMembers(data, offset, length);\n               if (log.isDebugEnabled())\n                  log.debug(stub.getLocalAddress() + \" sent a message to all members, GR used \"\n                           + stub.getGossipRouterAddress());\n               sent = true;\n               break;\n            } catch (Exception e) {\n               try {\n                  if (log.isWarnEnabled())\n                     log.warn(stub.getLocalAddress()\n                              + \" failed sending a message to all members, GR used \"\n                              + stub.getGossipRouterAddress());\n               } catch (SocketException e1) {\n               }\n            }\n         }\n         if (!sent)\n            throw new Exception(\"None of the available stubs \" + stubs\n                     + \" accepted a multicast message\");\n      }","commit_id":"8560bb035b17d5c8da33cace62f154b7e7c5d702","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendToSingleMember(List<RouterStub> stubs, Address dest, byte[] data, int offset,\n               int length) throws Exception {\n         boolean sent = false;\n         Collections.shuffle(stubs);\n         for (RouterStub stub : stubs) {\n            try {\n               stub.sendToSingleMember(dest, data, offset, length);\n               if (log.isDebugEnabled())\n                  log.debug(stub.getLocalAddress() + \" sent a message to \" + dest + \", GR used \"\n                           + stub.getGossipRouterAddress());\n               sent = true;\n               break;\n            } catch (Exception e) {\n               try {\n                  if (log.isWarnEnabled()) {\n                     log.warn(stub.getLocalAddress() + \" failed sending a message to \" + dest\n                              + \", GR used \" + stub.getGossipRouterAddress());\n                  }\n               } catch (SocketException e1) {\n               }\n            }\n         }\n         if (!sent)\n            throw new Exception(\"None of the available stubs \" + stubs\n                     + \" accepted a message for dest \" + dest);\n      }","id":97945,"modified_method":"public void sendToSingleMember(List<RouterStub> stubs, Address dest, byte[] data, int offset,\n               int length) throws Exception {\n         boolean sent = false;\n          if(stubs.size() > 1)\n              Collections.shuffle(stubs); // todo: why is this needed ?\n         for (RouterStub stub : stubs) {\n            try {\n               stub.sendToSingleMember(dest, data, offset, length);\n               if (log.isDebugEnabled())\n                  log.debug(stub.getLocalAddress() + \" sent a message to \" + dest + \", GR used \"\n                           + stub.getGossipRouterAddress());\n               sent = true;\n               break;\n            } catch (Exception e) {\n               try {\n                  if (log.isWarnEnabled()) {\n                     log.warn(stub.getLocalAddress() + \" failed sending a message to \" + dest\n                              + \", GR used \" + stub.getGossipRouterAddress());\n                  }\n               } catch (SocketException e1) {\n               }\n            }\n         }\n         if (!sent)\n            throw new Exception(\"None of the available stubs \" + stubs\n                     + \" accepted a message for dest \" + dest);\n      }","commit_id":"8560bb035b17d5c8da33cace62f154b7e7c5d702","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n        _isRunning = true;\n        List<TunnelPool> wanted = new ArrayList(MAX_CONCURRENT_BUILDS);\n        List<TunnelPool> pools = new ArrayList(8);\n        \n        while (_isRunning && !_manager.isShutdown()){\n            //loopBegin = System.currentTimeMillis();\n            try {\n                _repoll = false; // resets repoll to false unless there are inbound requeusts pending\n                _manager.listPools(pools);\n                for (int i = 0; i < pools.size(); i++) {\n                    TunnelPool pool = pools.get(i);\n                    if (!pool.isAlive())\n                        continue;\n                    int howMany = pool.countHowManyToBuild();\n                    for (int j = 0; j < howMany; j++)\n                        wanted.add(pool);\n                }\n\n                // allowed() also expires timed out requests (for new style requests)\n                int allowed = allowed();\n                \n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(\"Allowed: \" + allowed + \" wanted: \" + wanted);\n\n                // zero hop ones can run inline\n                allowed = buildZeroHopTunnels(wanted, allowed);\n                //afterBuildZeroHop = System.currentTimeMillis();\n                \n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(\"Zero hops built, Allowed: \" + allowed + \" wanted: \" + wanted);\n\n                //int realBuilt = 0;\n                TunnelManagerFacade mgr = _context.tunnelManager();\n                if ( (mgr == null) || (mgr.getFreeTunnelCount() <= 0) || (mgr.getOutboundTunnelCount() <= 0) ) {\n                    // we don't have either inbound or outbound tunnels, so don't bother trying to build\n                    // non-zero-hop tunnels\n                    // try to kickstart it to build a fallback, otherwise we may get stuck here for a long time (minutes)\n                    if (mgr != null) {\n                        if (mgr.getFreeTunnelCount() <= 0)\n                            mgr.selectInboundTunnel();\n                        if (mgr.getOutboundTunnelCount() <= 0)\n                            mgr.selectOutboundTunnel();\n                    }\n                    synchronized (_currentlyBuilding) {\n                        if (!_repoll) {\n                            if (_log.shouldLog(Log.DEBUG))\n                                _log.debug(\"No tunnel to build with (allowed=\" + allowed + \", wanted=\" + wanted.size() + \"), wait for a while\");\n                            try {\n                                _currentlyBuilding.wait(1*1000+_context.random().nextInt(1*1000));\n                            } catch (InterruptedException ie) {}\n                        }\n                    }\n                } else {\n                    if ( (allowed > 0) && (!wanted.isEmpty()) ) {\n                        Collections.shuffle(wanted, _context.random());\n                        try {\n                            Collections.sort(wanted, new TunnelPoolComparator());\n                        } catch (IllegalArgumentException iae) {\n                            // Java 7 TimSort - see info in TunnelPoolComparator\n                            continue;\n                        }\n\n                        // force the loops to be short, since 3 consecutive tunnel build requests can take\n                        // a long, long time\n                        if (allowed > 2)\n                            allowed = 2;\n                        \n                        for (int i = 0; (i < allowed) && (!wanted.isEmpty()); i++) {\n                            TunnelPool pool = wanted.remove(0);\n                            //if (pool.countWantedTunnels() <= 0)\n                            //    continue;\n                            long bef = System.currentTimeMillis();\n                            PooledTunnelCreatorConfig cfg = pool.configureNewTunnel();\n                            if (cfg != null) {\n                                // 0hops are taken care of above, these are nonstandard 0hops\n                                if (cfg.getLength() <= 1 && !pool.needFallback()) {\n                                    if (_log.shouldLog(Log.DEBUG))\n                                        _log.debug(\"We don't need more fallbacks for \" + pool);\n                                    i--; //0hop, we can keep going, as there's no worry about throttling\n                                    pool.buildComplete(cfg);\n                                    continue;\n                                }\n                                long pTime = System.currentTimeMillis() - bef;\n                                _context.statManager().addRateData(\"tunnel.buildConfigTime\", pTime, 0);\n                                if (_log.shouldLog(Log.DEBUG))\n                                    _log.debug(\"Configuring new tunnel \" + i + \" for \" + pool + \": \" + cfg);\n                                buildTunnel(pool, cfg);\n                                //realBuilt++;\n                            } else {\n                                i--;\n                            }\n                        }\n                    }\n                        // wait whether we built tunnels or not\n                        try {\n                            synchronized (_currentlyBuilding) {\n                                if (!_repoll) {\n                                    //if (_log.shouldLog(Log.DEBUG))\n                                    //    _log.debug(\"Nothin' doin (allowed=\" + allowed + \", wanted=\" + wanted.size() + \", pending=\" + pendingRemaining + \"), wait for a while\");\n                                    //if (allowed <= 0)\n                                        _currentlyBuilding.wait((LOOP_TIME/2) + _context.random().nextInt(LOOP_TIME));\n                                    //else // wanted <= 0\n                                    //    _currentlyBuilding.wait(_context.random().nextInt(30*1000));\n                                }\n                            }\n                        } catch (InterruptedException ie) {\n                            // someone wanted to build something\n                        }\n                }\n                \n                \n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(\"build loop complete, tot=\" + (afterHandleInbound-loopBegin) + \n                //              \" inReply=\" + (afterHandleInboundReplies-beforeHandleInboundReplies) +\n                //              \" zeroHop=\" + (afterBuildZeroHop-afterHandleInboundReplies) +\n                //              \" real=\" + (afterBuildReal-afterBuildZeroHop) +\n                //              \" in=\" + (afterHandleInbound-afterBuildReal) + \n                //              \" built=\" + realBuilt +\n                //              \" pending=\" + pendingRemaining);\n                \n            } catch (RuntimeException e) {\n                    _log.log(Log.CRIT, \"B0rked in the tunnel builder\", e);\n                    try { Thread.sleep(LOOP_TIME); } catch (InterruptedException ie) {}\n            }\n            wanted.clear();\n            pools.clear();\n        }\n        \n        if (_log.shouldLog(Log.WARN))\n            _log.warn(\"Done building\");\n        _isRunning = false;\n    }","id":97946,"modified_method":"public void run() {\n        _isRunning = true;\n        List<TunnelPool> wanted = new ArrayList(MAX_CONCURRENT_BUILDS);\n        List<TunnelPool> pools = new ArrayList(8);\n        \n        while (_isRunning && !_manager.isShutdown()){\n            //loopBegin = System.currentTimeMillis();\n            try {\n                _repoll = false; // resets repoll to false unless there are inbound requeusts pending\n                _manager.listPools(pools);\n                for (int i = 0; i < pools.size(); i++) {\n                    TunnelPool pool = pools.get(i);\n                    if (!pool.isAlive())\n                        continue;\n                    int howMany = pool.countHowManyToBuild();\n                    for (int j = 0; j < howMany; j++)\n                        wanted.add(pool);\n                }\n\n                // allowed() also expires timed out requests (for new style requests)\n                int allowed = allowed();\n                \n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(\"Allowed: \" + allowed + \" wanted: \" + wanted);\n\n                // zero hop ones can run inline\n                allowed = buildZeroHopTunnels(wanted, allowed);\n                //afterBuildZeroHop = System.currentTimeMillis();\n                \n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(\"Zero hops built, Allowed: \" + allowed + \" wanted: \" + wanted);\n\n                //int realBuilt = 0;\n                TunnelManagerFacade mgr = _context.tunnelManager();\n                if ( (mgr == null) || (mgr.getFreeTunnelCount() <= 0) || (mgr.getOutboundTunnelCount() <= 0) ) {\n                    // we don't have either inbound or outbound tunnels, so don't bother trying to build\n                    // non-zero-hop tunnels\n                    // try to kickstart it to build a fallback, otherwise we may get stuck here for a long time (minutes)\n                    if (mgr != null) {\n                        if (mgr.getFreeTunnelCount() <= 0)\n                            mgr.selectInboundTunnel();\n                        if (mgr.getOutboundTunnelCount() <= 0)\n                            mgr.selectOutboundTunnel();\n                    }\n                    synchronized (_currentlyBuilding) {\n                        if (!_repoll) {\n                            if (_log.shouldLog(Log.DEBUG))\n                                _log.debug(\"No tunnel to build with (allowed=\" + allowed + \", wanted=\" + wanted.size() + \"), wait for a while\");\n                            try {\n                                _currentlyBuilding.wait(1*1000+_context.random().nextInt(1*1000));\n                            } catch (InterruptedException ie) {}\n                        }\n                    }\n                } else {\n                    if ( (allowed > 0) && (!wanted.isEmpty()) ) {\n                        if (wanted.size() > 1) {\n                            Collections.shuffle(wanted, _context.random());\n                            try {\n                                Collections.sort(wanted, new TunnelPoolComparator());\n                            } catch (IllegalArgumentException iae) {\n                                // Java 7 TimSort - see info in TunnelPoolComparator\n                                continue;\n                            }\n                        }\n\n                        // force the loops to be short, since 3 consecutive tunnel build requests can take\n                        // a long, long time\n                        if (allowed > 2)\n                            allowed = 2;\n                        \n                        for (int i = 0; (i < allowed) && (!wanted.isEmpty()); i++) {\n                            TunnelPool pool = wanted.remove(0);\n                            //if (pool.countWantedTunnels() <= 0)\n                            //    continue;\n                            long bef = System.currentTimeMillis();\n                            PooledTunnelCreatorConfig cfg = pool.configureNewTunnel();\n                            if (cfg != null) {\n                                // 0hops are taken care of above, these are nonstandard 0hops\n                                if (cfg.getLength() <= 1 && !pool.needFallback()) {\n                                    if (_log.shouldLog(Log.DEBUG))\n                                        _log.debug(\"We don't need more fallbacks for \" + pool);\n                                    i--; //0hop, we can keep going, as there's no worry about throttling\n                                    pool.buildComplete(cfg);\n                                    continue;\n                                }\n                                long pTime = System.currentTimeMillis() - bef;\n                                _context.statManager().addRateData(\"tunnel.buildConfigTime\", pTime, 0);\n                                if (_log.shouldLog(Log.DEBUG))\n                                    _log.debug(\"Configuring new tunnel \" + i + \" for \" + pool + \": \" + cfg);\n                                buildTunnel(pool, cfg);\n                                //realBuilt++;\n                            } else {\n                                i--;\n                            }\n                        }\n                    }\n                        // wait whether we built tunnels or not\n                        try {\n                            synchronized (_currentlyBuilding) {\n                                if (!_repoll) {\n                                    //if (_log.shouldLog(Log.DEBUG))\n                                    //    _log.debug(\"Nothin' doin (allowed=\" + allowed + \", wanted=\" + wanted.size() + \", pending=\" + pendingRemaining + \"), wait for a while\");\n                                    //if (allowed <= 0)\n                                        _currentlyBuilding.wait((LOOP_TIME/2) + _context.random().nextInt(LOOP_TIME));\n                                    //else // wanted <= 0\n                                    //    _currentlyBuilding.wait(_context.random().nextInt(30*1000));\n                                }\n                            }\n                        } catch (InterruptedException ie) {\n                            // someone wanted to build something\n                        }\n                }\n                \n                \n                //if (_log.shouldLog(Log.DEBUG))\n                //    _log.debug(\"build loop complete, tot=\" + (afterHandleInbound-loopBegin) + \n                //              \" inReply=\" + (afterHandleInboundReplies-beforeHandleInboundReplies) +\n                //              \" zeroHop=\" + (afterBuildZeroHop-afterHandleInboundReplies) +\n                //              \" real=\" + (afterBuildReal-afterBuildZeroHop) +\n                //              \" in=\" + (afterHandleInbound-afterBuildReal) + \n                //              \" built=\" + realBuilt +\n                //              \" pending=\" + pendingRemaining);\n                \n            } catch (RuntimeException e) {\n                    _log.log(Log.CRIT, \"B0rked in the tunnel builder\", e);\n                    try { Thread.sleep(LOOP_TIME); } catch (InterruptedException ie) {}\n            }\n            wanted.clear();\n            pools.clear();\n        }\n        \n        if (_log.shouldLog(Log.WARN))\n            _log.warn(\"Done building\");\n        _isRunning = false;\n    }","commit_id":"50f45a50a757b6b0cf6d94c78083e4911908422e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public int compare(TunnelInfo lhs, TunnelInfo rhs) {\n            if (_avoidZero) {\n                // put the zero-hops last\n                int llen = lhs.getLength();\n                int rlen = rhs.getLength();\n                if (llen > 1 && rlen <= 1)\n                    return -1;\n                if (rlen > 1 && llen <= 1)\n                    return 1;\n            }\n            byte lhsDelta[] = DataHelper.xor(lhs.getFarEnd().getData(), _base);\n            byte rhsDelta[] = DataHelper.xor(rhs.getFarEnd().getData(), _base);\n            int rv = DataHelper.compareTo(lhsDelta, rhsDelta);\n            if (rv != 0)\n                return rv;\n            // latest-expiring first as a tie-breaker\n            return (int) (rhs.getExpiration() - lhs.getExpiration());\n        }","id":97947,"modified_method":"public int compare(TunnelInfo lhs, TunnelInfo rhs) {\n            if (_avoidZero) {\n                // put the zero-hops last\n                int llen = lhs.getLength();\n                int rlen = rhs.getLength();\n                if (llen > 1 && rlen <= 1)\n                    return -1;\n                if (rlen > 1 && llen <= 1)\n                    return 1;\n            }\n            // TODO don't prefer exact match for security?\n            byte lhsb[] = lhs.getFarEnd().getData();\n            byte rhsb[] = rhs.getFarEnd().getData();\n            for (int i = 0; i < _base.length; i++) {\n                int ld = (lhsb[i] ^ _base[i]) & 0xff;\n                int rd = (rhsb[i] ^ _base[i]) & 0xff;\n                if (ld < rd)\n                    return -1;\n                if (ld > rd)\n                    return 1;\n            }\n            // latest-expiring first as a tie-breaker\n            return (int) (rhs.getExpiration() - lhs.getExpiration());\n        }","commit_id":"50f45a50a757b6b0cf6d94c78083e4911908422e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * An event was received from the layer below. Usually the current layer will want to examine\n     * the event type and - depending on its type - perform some computation\n     * (e.g. removing headers from a MSG event type, or updating the internal membership list\n     * when receiving a VIEW_CHANGE event).\n     * Finally the event is either a) discarded, or b) an event is sent down\n     * the stack using <code>PassDown<\/code> or c) the event (or another event) is sent up\n     * the stack using <code>PassUp<\/code>.\n     * <p/>\n     * For the PING protocol, the Up operation does the following things.\n     * 1. If the event is a Event.MSG then PING will inspect the message header.\n     * If the header is null, PING simply passes up the event\n     * If the header is PingHeader.GET_MBRS_REQ then the PING protocol\n     * will PassDown a PingRequest message\n     * If the header is PingHeader.GET_MBRS_RSP we will add the message to the initial members\n     * vector and wake up any waiting threads.\n     * 2. If the event is Event.SET_LOCAL_ADDR we will simple set the local address of this protocol\n     * 3. For all other messages we simple pass it up to the protocol above\n     *\n     * @param evt - the event that has been sent from the layer below\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public Object up(Event evt) {\n        \n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                PingHeader hdr=(PingHeader)msg.getHeader(getName());\n                if(hdr == null)\n                    return up_prot.up(evt);\n\n                switch(hdr.type) {\n\n                    case PingHeader.GET_MBRS_REQ:   // return Rsp(local_addr, coord)\n                        if(local_addr != null && msg.getSrc() != null && local_addr.equals(msg.getSrc())) {\n                            return null;\n                        }\n\n                        if(group_addr == null || hdr.cluster_name == null) {\n                            if(log.isWarnEnabled())\n                                log.warn(\"group_addr (\" + group_addr + \") or cluster_name of header (\" + hdr.cluster_name\n                                        + \") is null; passing up discovery request from \" + msg.getSrc() + \", but this should not\" +\n                                        \" be the case\");\n                        }\n                        else {\n                            if(!group_addr.equals(hdr.cluster_name)) {\n                                if(log.isWarnEnabled())\n                                    log.warn(\"discarding discovery request for cluster '\" + hdr.cluster_name + \"' from \" +\n                                            msg.getSrc() + \"; our cluster name is '\" + group_addr + \"'. \" +\n                                            \"Please separate your clusters cleanly.\");\n                                return null;\n                            }\n                        }\n\n                        // add physical address (if available) to transport's cache\n                        if(hdr.arg != null) {\n                            Address logical_addr=hdr.arg.getAddress();\n                            if(logical_addr == null)\n                                logical_addr=msg.getSrc();\n                            Collection<PhysicalAddress> physical_addrs=hdr.arg.getPhysicalAddrs();\n                            PhysicalAddress physical_addr=physical_addrs != null && !physical_addrs.isEmpty()? physical_addrs.iterator().next() : null;\n                            if(logical_addr != null && physical_addr != null)\n                                down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address,PhysicalAddress>(logical_addr, physical_addr)));\n                            if(logical_addr != null && hdr.arg.getLogicalName() != null)\n                                UUID.add((UUID)logical_addr, hdr.arg.getLogicalName());\n                        }\n\n                        Address coord;\n                        synchronized(members) {\n                            coord=!members.isEmpty()? members.firstElement() : local_addr;\n                        }\n\n                        if(return_entire_cache) {\n                            Map<Address,PhysicalAddress> cache=(Map<Address,PhysicalAddress>)down(new Event(Event.GET_LOGICAL_PHYSICAL_MAPPINGS));\n                            if(cache != null) {\n                                for(Map.Entry<Address,PhysicalAddress> entry: cache.entrySet()) {\n                                    Address logical_addr=entry.getKey();\n                                    PhysicalAddress physical_addr=entry.getValue();\n                                    sendDiscoveryResponse(logical_addr, Arrays.asList(physical_addr), coord, is_server,\n                                                          UUID.get(logical_addr), msg.getSrc());\n                                }\n                            }\n                        }\n                        else {\n                            PhysicalAddress physical_addr=(PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr));\n                            sendDiscoveryResponse(local_addr, Arrays.asList(physical_addr), coord, is_server,\n                                                  UUID.get(local_addr), msg.getSrc());\n                        }\n                        return null;\n\n                    case PingHeader.GET_MBRS_RSP:   // add response to vector and notify waiting thread\n                        PingData rsp=hdr.arg;\n\n                        // add physical address (if available) to transport's cache\n                        if(rsp != null) {\n                            Address response_sender=msg.getSrc();\n                            Address logical_addr=rsp.getAddress();\n                            if(logical_addr == null)\n                                logical_addr=msg.getSrc();\n                            Collection<PhysicalAddress> physical_addrs=rsp.getPhysicalAddrs();\n                            PhysicalAddress physical_addr=physical_addrs != null && !physical_addrs.isEmpty()?\n                                    physical_addrs.iterator().next() : null;\n                            if(logical_addr != null && physical_addr != null)\n                                down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address,PhysicalAddress>(logical_addr, physical_addr)));\n                            if(logical_addr != null && rsp.getLogicalName() != null)\n                                UUID.add((UUID)logical_addr, rsp.getLogicalName());\n\n                            if(log.isTraceEnabled())\n                                log.trace(\"received GET_MBRS_RSP from \" + response_sender + \": \" + rsp);\n                            synchronized(ping_responses) {\n                                for(Responses rsps: ping_responses) {\n                                    boolean overwrite=logical_addr.equals(response_sender);\n                                    rsps.addResponse(rsp, overwrite);\n                                }\n                            }\n                        }\n                        return null;\n\n                    default:\n                        if(log.isWarnEnabled()) log.warn(\"got PING header with unknown type (\" + hdr.type + ')');\n                        return null;\n                }\n\n\n            case Event.GET_PHYSICAL_ADDRESS:\n                try {\n                    sendGetMembersRequest(group_addr, null);\n                }\n                catch(InterruptedIOException ie) {\n                    if(log.isWarnEnabled()){\n                        log.warn(\"Discovery request for cluster \" + group_addr + \" interrupted\");\n                    }\n                    Thread.currentThread().interrupt();\n                }\n                catch(Exception ex) {\n                    if(log.isErrorEnabled())\n                        log.error(\"failed sending discovery request\", ex);\n                }\n                return null;\n        }\n\n        return up_prot.up(evt);\n    }","id":97948,"modified_method":"/**\n     * An event was received from the layer below. Usually the current layer will want to examine\n     * the event type and - depending on its type - perform some computation\n     * (e.g. removing headers from a MSG event type, or updating the internal membership list\n     * when receiving a VIEW_CHANGE event).\n     * Finally the event is either a) discarded, or b) an event is sent down\n     * the stack using <code>PassDown<\/code> or c) the event (or another event) is sent up\n     * the stack using <code>PassUp<\/code>.\n     * <p/>\n     * For the PING protocol, the Up operation does the following things.\n     * 1. If the event is a Event.MSG then PING will inspect the message header.\n     * If the header is null, PING simply passes up the event\n     * If the header is PingHeader.GET_MBRS_REQ then the PING protocol\n     * will PassDown a PingRequest message\n     * If the header is PingHeader.GET_MBRS_RSP we will add the message to the initial members\n     * vector and wake up any waiting threads.\n     * 2. If the event is Event.SET_LOCAL_ADDR we will simple set the local address of this protocol\n     * 3. For all other messages we simple pass it up to the protocol above\n     *\n     * @param evt - the event that has been sent from the layer below\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public Object up(Event evt) {\n        \n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                PingHeader hdr=(PingHeader)msg.getHeader(getName());\n                if(hdr == null)\n                    return up_prot.up(evt);\n\n                switch(hdr.type) {\n\n                    case PingHeader.GET_MBRS_REQ:   // return Rsp(local_addr, coord)\n                        if(local_addr != null && msg.getSrc() != null && local_addr.equals(msg.getSrc())) {\n                            return null;\n                        }\n\n                        if(group_addr == null || hdr.cluster_name == null) {\n                            if(log.isWarnEnabled())\n                                log.warn(\"group_addr (\" + group_addr + \") or cluster_name of header (\" + hdr.cluster_name\n                                        + \") is null; passing up discovery request from \" + msg.getSrc() + \", but this should not\" +\n                                        \" be the case\");\n                        }\n                        else {\n                            if(!group_addr.equals(hdr.cluster_name)) {\n                                if(log.isWarnEnabled())\n                                    log.warn(\"discarding discovery request for cluster '\" + hdr.cluster_name + \"' from \" +\n                                            msg.getSrc() + \"; our cluster name is '\" + group_addr + \"'. \" +\n                                            \"Please separate your clusters cleanly.\");\n                                return null;\n                            }\n                        }\n\n                        // add physical address (if available) to transport's cache\n                        if(hdr.arg != null) {\n                            Address logical_addr=hdr.arg.getAddress();\n                            if(logical_addr == null)\n                                logical_addr=msg.getSrc();\n                            Collection<PhysicalAddress> physical_addrs=hdr.arg.getPhysicalAddrs();\n                            PhysicalAddress physical_addr=physical_addrs != null && !physical_addrs.isEmpty()? physical_addrs.iterator().next() : null;\n                            if(logical_addr != null && physical_addr != null)\n                                down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address,PhysicalAddress>(logical_addr, physical_addr)));\n                            if(logical_addr != null && hdr.arg.getLogicalName() != null)\n                                UUID.add((UUID)logical_addr, hdr.arg.getLogicalName());\n                        }\n\n                        if(return_entire_cache) {\n                            Map<Address,PhysicalAddress> cache=(Map<Address,PhysicalAddress>)down(new Event(Event.GET_LOGICAL_PHYSICAL_MAPPINGS));\n                            if(cache != null) {\n                                for(Map.Entry<Address,PhysicalAddress> entry: cache.entrySet()) {\n                                    Address logical_addr=entry.getKey();\n                                    PhysicalAddress physical_addr=entry.getValue();\n                                    sendDiscoveryResponse(logical_addr, Arrays.asList(physical_addr), is_server,\n                                                          UUID.get(logical_addr), msg.getSrc());\n                                }\n                            }\n                        }\n                        else {\n                            PhysicalAddress physical_addr=(PhysicalAddress)down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr));\n                            sendDiscoveryResponse(local_addr, Arrays.asList(physical_addr), is_server,\n                                                  UUID.get(local_addr), msg.getSrc());\n                        }\n                        return null;\n\n                    case PingHeader.GET_MBRS_RSP:   // add response to vector and notify waiting thread\n                        PingData rsp=hdr.arg;\n\n                        // add physical address (if available) to transport's cache\n                        if(rsp != null) {\n                            Address response_sender=msg.getSrc();\n                            Address logical_addr=rsp.getAddress();\n                            if(logical_addr == null)\n                                logical_addr=msg.getSrc();\n                            Collection<PhysicalAddress> physical_addrs=rsp.getPhysicalAddrs();\n                            PhysicalAddress physical_addr=physical_addrs != null && !physical_addrs.isEmpty()?\n                                    physical_addrs.iterator().next() : null;\n                            if(logical_addr != null && physical_addr != null)\n                                down(new Event(Event.SET_PHYSICAL_ADDRESS, new Tuple<Address,PhysicalAddress>(logical_addr, physical_addr)));\n                            if(logical_addr != null && rsp.getLogicalName() != null)\n                                UUID.add((UUID)logical_addr, rsp.getLogicalName());\n\n                            if(log.isTraceEnabled())\n                                log.trace(\"received GET_MBRS_RSP from \" + response_sender + \": \" + rsp);\n                            synchronized(ping_responses) {\n                                for(Responses rsps: ping_responses) {\n                                    boolean overwrite=logical_addr.equals(response_sender);\n                                    rsps.addResponse(rsp, overwrite);\n                                }\n                            }\n                        }\n                        return null;\n\n                    default:\n                        if(log.isWarnEnabled()) log.warn(\"got PING header with unknown type (\" + hdr.type + ')');\n                        return null;\n                }\n\n\n            case Event.GET_PHYSICAL_ADDRESS:\n                try {\n                    sendGetMembersRequest(group_addr, null);\n                }\n                catch(InterruptedIOException ie) {\n                    if(log.isWarnEnabled()){\n                        log.warn(\"Discovery request for cluster \" + group_addr + \" interrupted\");\n                    }\n                    Thread.currentThread().interrupt();\n                }\n                catch(Exception ex) {\n                    if(log.isErrorEnabled())\n                        log.error(\"failed sending discovery request\", ex);\n                }\n                return null;\n        }\n\n        return up_prot.up(evt);\n    }","commit_id":"e63b3e3d71ce0cdd5fe721f5712b5b61fa8a9f77","url":"https://github.com/belaban/JGroups"},{"original_method":"private void sendDiscoveryResponse(Address logical_addr, List<PhysicalAddress> physical_addrs,\n                                       Address coord, boolean is_server, String logical_name, Address sender) {\n        PingData ping_rsp=new PingData(logical_addr, view, is_server, logical_name, physical_addrs);\n        Message rsp_msg=new Message(sender, null, null);\n        rsp_msg.setFlag(Message.OOB);\n        PingHeader rsp_hdr=new PingHeader(PingHeader.GET_MBRS_RSP, ping_rsp);\n        rsp_msg.putHeader(getName(), rsp_hdr);\n        if(log.isTraceEnabled())\n            log.trace(\"received GET_MBRS_REQ from \" + sender + \", sending response \" + rsp_hdr);\n        down_prot.down(new Event(Event.MSG, rsp_msg));\n    }","id":97949,"modified_method":"private void sendDiscoveryResponse(Address logical_addr, List<PhysicalAddress> physical_addrs,\n                                       boolean is_server, String logical_name, Address sender) {\n        PingData ping_rsp=new PingData(logical_addr, view, is_server, logical_name, physical_addrs);\n        Message rsp_msg=new Message(sender, null, null);\n        rsp_msg.setFlag(Message.OOB);\n        PingHeader rsp_hdr=new PingHeader(PingHeader.GET_MBRS_RSP, ping_rsp);\n        rsp_msg.putHeader(getName(), rsp_hdr);\n        if(log.isTraceEnabled())\n            log.trace(\"received GET_MBRS_REQ from \" + sender + \", sending response \" + rsp_hdr);\n        down_prot.down(new Event(Event.MSG, rsp_msg));\n    }","commit_id":"e63b3e3d71ce0cdd5fe721f5712b5b61fa8a9f77","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendToSingleMember(List<RouterStub> stubs, Address dest, byte[] data, int offset,\n               int length) throws Exception {\n         boolean sent = false;\n         Collections.shuffle(stubs);\n         for (RouterStub stub : stubs) {\n            try {\n               stub.sendToSingleMember(dest, data, offset, length);\n               if (log.isDebugEnabled())\n                  log.debug(stub.getLocalAddress() + \" sent a message to \" + dest + \", GR used \"\n                           + stub.getGossipRouterAddress());\n               sent = true;\n               break;\n            } catch (Exception e) {\n               try {\n                  if (log.isWarnEnabled()) {\n                     log.warn(stub.getLocalAddress() + \" failed sending a message to \" + dest\n                              + \", GR used \" + stub.getGossipRouterAddress());\n                  }\n               } catch (SocketException e1) {\n               }\n            }\n         }\n         if (!sent)\n            throw new Exception(\"None of the available stubs \" + stubs\n                     + \" accepted a message for dest \" + dest);\n      }","id":97950,"modified_method":"public void sendToSingleMember(List<RouterStub> stubs, Address dest, byte[] data, int offset,\n               int length) throws Exception {\n         boolean sent = false;\n          if(stubs.size() > 1)\n              Collections.shuffle(stubs); // todo: why is this needed ?\n         for (RouterStub stub : stubs) {\n            try {\n               stub.sendToSingleMember(dest, data, offset, length);\n               if (log.isDebugEnabled())\n                  log.debug(stub.getLocalAddress() + \" sent a message to \" + dest + \", GR used \"\n                           + stub.getGossipRouterAddress());\n               sent = true;\n               break;\n            } catch (Exception e) {\n               try {\n                  if (log.isWarnEnabled()) {\n                     log.warn(stub.getLocalAddress() + \" failed sending a message to \" + dest\n                              + \", GR used \" + stub.getGossipRouterAddress());\n                  }\n               } catch (SocketException e1) {\n               }\n            }\n         }\n         if (!sent)\n            throw new Exception(\"None of the available stubs \" + stubs\n                     + \" accepted a message for dest \" + dest);\n      }","commit_id":"e63b3e3d71ce0cdd5fe721f5712b5b61fa8a9f77","url":"https://github.com/belaban/JGroups"},{"original_method":"public void sendToAllMembers(List<RouterStub> stubs, byte[] data, int offset, int length)\n               throws Exception {\n         boolean sent = false;\n         Collections.shuffle(stubs);\n         for (RouterStub stub : stubs) {\n            try {\n               stub.sendToAllMembers(data, offset, length);\n               if (log.isDebugEnabled())\n                  log.debug(stub.getLocalAddress() + \" sent a message to all members, GR used \"\n                           + stub.getGossipRouterAddress());\n               sent = true;\n               break;\n            } catch (Exception e) {\n               try {\n                  if (log.isWarnEnabled())\n                     log.warn(stub.getLocalAddress()\n                              + \" failed sending a message to all members, GR used \"\n                              + stub.getGossipRouterAddress());\n               } catch (SocketException e1) {\n               }\n            }\n         }\n         if (!sent)\n            throw new Exception(\"None of the available stubs \" + stubs\n                     + \" accepted a multicast message\");\n      }","id":97951,"modified_method":"public void sendToAllMembers(List<RouterStub> stubs, byte[] data, int offset, int length)\n               throws Exception {\n         boolean sent = false;\n          if(stubs.size() > 1)\n              Collections.shuffle(stubs);  // todo: why is this needed ?\n         for (RouterStub stub : stubs) {\n            try {\n               stub.sendToAllMembers(data, offset, length);\n               if (log.isDebugEnabled())\n                  log.debug(stub.getLocalAddress() + \" sent a message to all members, GR used \"\n                           + stub.getGossipRouterAddress());\n               sent = true;\n               break;\n            } catch (Exception e) {\n               try {\n                  if (log.isWarnEnabled())\n                     log.warn(stub.getLocalAddress()\n                              + \" failed sending a message to all members, GR used \"\n                              + stub.getGossipRouterAddress());\n               } catch (SocketException e1) {\n               }\n            }\n         }\n         if (!sent)\n            throw new Exception(\"None of the available stubs \" + stubs\n                     + \" accepted a multicast message\");\n      }","commit_id":"e63b3e3d71ce0cdd5fe721f5712b5b61fa8a9f77","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean baseIsConfidentRef( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n        if ( !BaseUtils.isRegularBase(ref.getBase()) )\n            return false;\n        VariantCallContext calls = UnifiedGenotyper.runGenotyper(tracker,ref,context,ug);\n        if ( calls == null || calls.genotypes == null)\n            return false;\n        return  ( calls.genotypes.size() > 0 && !calls.genotypes.get(0).isVariant(ref.getBase()) && calls.genotypes.get(0).getNegLog10PError() > confidentRefThreshold );\n\n    }","id":97952,"modified_method":"public boolean baseIsConfidentRef( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n        if ( !BaseUtils.isRegularBase(ref.getBase()) )\n            return false;\n        VariantCallContext calls = ug.runGenotyper(tracker,ref,context);\n        if ( calls == null || calls.genotypes == null)\n            return false;\n        return  ( calls.genotypes.size() > 0 && !calls.genotypes.get(0).isVariant(ref.getBase()) && calls.genotypes.get(0).getNegLog10PError() > confidentRefThreshold );\n\n    }","commit_id":"506d39f751a77d29e54686b87eb106c629c7d4bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize() {\n        if ( nPreviousBases > 3 || ( nPreviousReadBases > 3 && readBasesMustMatchRef ) ) {\n            throw new StingException(\"You have opted to use a number of previous bases in excess of 3. In order to do this you must change the reference window size in the walker itself.\");\n        }\n        UnifiedArgumentCollection uac = new UnifiedArgumentCollection();\n        uac.baseModel = BaseMismatchModel.THREE_STATE;\n        uac.ALL_BASES = true;\n        ug = UnifiedGenotyper.getUnifiedCalculationArguments(getToolkit(), uac);\n        // refWindow = new ReferenceContextWindow(nPreviousBases);\n        usePreviousBases = new ArrayList<Boolean>();\n        previousBaseLoci = new ArrayList<GenomeLoc>();\n\n    }","id":97953,"modified_method":"public void initialize() {\n        if ( nPreviousBases > 3 || ( nPreviousReadBases > 3 && readBasesMustMatchRef ) ) {\n            throw new StingException(\"You have opted to use a number of previous bases in excess of 3. In order to do this you must change the reference window size in the walker itself.\");\n        }\n        UnifiedArgumentCollection uac = new UnifiedArgumentCollection();\n        uac.baseModel = BaseMismatchModel.THREE_STATE;\n        uac.ALL_BASES = true;\n        ug = new UnifiedGenotyperEngine(getToolkit(), uac);\n        // refWindow = new ReferenceContextWindow(nPreviousBases);\n        usePreviousBases = new ArrayList<Boolean>();\n        previousBaseLoci = new ArrayList<GenomeLoc>();\n\n    }","commit_id":"506d39f751a77d29e54686b87eb106c629c7d4bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize() {\n        UnifiedArgumentCollection uac = new UnifiedArgumentCollection();\n        uac.CONFIDENCE_THRESHOLD = 50;\n        ug = UnifiedGenotyper.getUnifiedCalculationArguments(getToolkit(), uac);\n\n        altTable = new NamedTable();\n    }","id":97954,"modified_method":"public void initialize() {\n        UnifiedArgumentCollection uac = new UnifiedArgumentCollection();\n        uac.CONFIDENCE_THRESHOLD = 50;\n        ug = new UnifiedGenotyperEngine(getToolkit(), uac);\n\n        altTable = new NamedTable();\n    }","commit_id":"506d39f751a77d29e54686b87eb106c629c7d4bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Identify likely homozygous-variant sites that are called as\n     * heterozygous, so that we can isolate our inspection to these sites.\n     *\n     * @param tracker  the meta-data tracker\n     * @param ref      information regarding the reference\n     * @param context  information regarding the reads\n     * @return true if this site is a suspicious het, false if otherwise\n     */\n    public boolean filter(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        int altCount = 0;\n        int totalCount = 0;\n\n        ReadBackedPileup pileup = context.getPileup();\n        int refIndex = BaseUtils.simpleBaseToBaseIndex(ref.getBase());\n\n        for (byte base : pileup.getBases() ) {\n            int baseIndex = BaseUtils.simpleBaseToBaseIndex((char) base);\n\n            if (baseIndex != refIndex) {\n                altCount++;\n            }\n            totalCount++;\n        }\n\n        double altBalance = ((double) altCount)/((double) totalCount);\n\n        if (altBalance > 0.70) {\n            VariantCallContext ugResult = UnifiedGenotyper.runGenotyper(tracker, ref, context, ug);\n\n            if (ugResult != null && ugResult.genotypes != null && ugResult.genotypes.size() > 0) {\n                return ugResult.genotypes.get(0).isHet();\n            }\n        }\n\n        return false;\n    }","id":97955,"modified_method":"/**\n     * Identify likely homozygous-variant sites that are called as\n     * heterozygous, so that we can isolate our inspection to these sites.\n     *\n     * @param tracker  the meta-data tracker\n     * @param ref      information regarding the reference\n     * @param context  information regarding the reads\n     * @return true if this site is a suspicious het, false if otherwise\n     */\n    public boolean filter(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        int altCount = 0;\n        int totalCount = 0;\n\n        ReadBackedPileup pileup = context.getBasePileup();\n        int refIndex = BaseUtils.simpleBaseToBaseIndex(ref.getBase());\n\n        for (byte base : pileup.getBases() ) {\n            int baseIndex = BaseUtils.simpleBaseToBaseIndex((char) base);\n\n            if (baseIndex != refIndex) {\n                altCount++;\n            }\n            totalCount++;\n        }\n\n        double altBalance = ((double) altCount)/((double) totalCount);\n\n        if (altBalance > 0.70) {\n            VariantCallContext ugResult = ug.runGenotyper(tracker, ref, context);\n\n            if (ugResult != null && ugResult.genotypes != null && ugResult.genotypes.size() > 0) {\n                return ugResult.genotypes.get(0).isHet();\n            }\n        }\n\n        return false;\n    }","commit_id":"506d39f751a77d29e54686b87eb106c629c7d4bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String map( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n        String result = null;\n\n        ReadBackedPileup pileup = context.getPileup();\n        if ( locusIsUsable(tracker, ref, pileup, context) ) {\n            Genotype g = getGenotype(tracker, ref, context);\n            if ( g != null && g.isPointGenotype() )\n                result = errorCounts( ref, pileup, g );\n        }\n\n        return result;\n    }","id":97956,"modified_method":"public String map( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n        String result = null;\n\n        ReadBackedPileup pileup = context.getBasePileup();\n        if ( locusIsUsable(tracker, ref, pileup, context) ) {\n            Genotype g = getGenotype(tracker, ref, context);\n            if ( g != null && g.isPointGenotype() )\n                result = errorCounts( ref, pileup, g );\n        }\n\n        return result;\n    }","commit_id":"506d39f751a77d29e54686b87eb106c629c7d4bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize() {\n        UnifiedArgumentCollection uac = new UnifiedArgumentCollection();\n        uac.baseModel = BaseMismatchModel.THREE_STATE;\n        uac.ALL_BASES = true;\n        ug = UnifiedGenotyper.getUnifiedCalculationArguments(getToolkit(), uac);\n\n        // print the header\n        out.printf(\"loc ref genotype genotypeQ depth nMM qSumMM A C G T%n\");\n    }","id":97957,"modified_method":"public void initialize() {\n        UnifiedArgumentCollection uac = new UnifiedArgumentCollection();\n        uac.baseModel = BaseMismatchModel.THREE_STATE;\n        uac.ALL_BASES = true;\n        ug = new UnifiedGenotyperEngine(getToolkit(), uac);\n\n        // print the header\n        out.printf(\"loc ref genotype genotypeQ depth nMM qSumMM A C G T%n\");\n    }","commit_id":"506d39f751a77d29e54686b87eb106c629c7d4bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Genotype getGenotype( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n        VariantCallContext calls = UnifiedGenotyper.runGenotyper(tracker,ref,context, ug);\n        if ( calls == null || calls.variation == null || calls.genotypes == null )\n            return null;\n        else {\n            return calls.genotypes.get(0);\n        }\n    }","id":97958,"modified_method":"private Genotype getGenotype( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n        VariantCallContext calls = ug.runGenotyper(tracker,ref,context);\n        if ( calls == null || calls.variation == null || calls.genotypes == null )\n            return null;\n        else {\n            return calls.genotypes.get(0);\n        }\n    }","commit_id":"506d39f751a77d29e54686b87eb106c629c7d4bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize() {\n        UnifiedArgumentCollection uac = new UnifiedArgumentCollection();\n        uac.CONFIDENCE_THRESHOLD = 50;\n        uac.ALL_BASES = true;\n        ug = UnifiedGenotyper.getUnifiedCalculationArguments(getToolkit(), uac);\n\n        altTable = new NamedTable();\n    }","id":97959,"modified_method":"public void initialize() {\n        UnifiedArgumentCollection uac = new UnifiedArgumentCollection();\n        uac.CONFIDENCE_THRESHOLD = 50;\n        uac.ALL_BASES = true;\n        ug = new UnifiedGenotyperEngine(getToolkit(), uac);\n\n        altTable = new NamedTable();\n    }","commit_id":"506d39f751a77d29e54686b87eb106c629c7d4bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        char refBase = Character.toUpperCase(ref.getBase());\n        ReadBackedPileup pileup = context.getBasePileup();\n        char[] contextBases = ref.getBases();\n        char prevBase = Character.toUpperCase(contextBases[0]);\n        char nextBase = Character.toUpperCase(contextBases[contextBases.length - 1]);\n\n        if (contextBases.length == 3 && refBase != 'N' && pileup.getBases() != null && pileup.getSecondaryBases() != null) {\n            VariantCallContext ugResult = UnifiedGenotyper.runGenotyper(tracker,ref,context,ug);\n            if (ugResult != null && ugResult.variation != null) {\n                Genotype res = ugResult.genotypes.get(0);\n                String call = res.getBases();\n                String type;\n                if (!res.isVariant(refBase)) {type = \"homref\";}\n                else if (!res.isHet()) {type = \"homvar\";}\n                else if (call.contains(Character.toString(refBase))) {type = \"het\";}\n                else {type = \"bad\";}\n                if (type != \"bad\") {\n                    for (PileupElement element : pileup) {\n                        char primaryBase = Character.toUpperCase((char)element.getBase());\n                        char secondaryBase = Character.toUpperCase((char)element.getSecondBase());\n                        String RG = element.getRead().getReadGroup().getReadGroupId();\n                        if (secondaryBase != 'N' && secondaryBase != '.' && primaryBase != 'N') {\n                            String strandRef;\n                            String strandPrimary;\n                            String strandPrev;\n                            String strandSecondary;\n                            if (!element.getRead().getReadNegativeStrandFlag()) {\n                                strandRef = Character.toString(refBase);\n                                strandPrimary = Character.toString(primaryBase);\n                                strandPrev = Character.toString(prevBase);\n                                strandSecondary = Character.toString(secondaryBase);\n                            }\n                            else {\n                                strandRef = Character.toString(BaseUtils.simpleComplement(refBase));\n                                strandPrimary = Character.toString(BaseUtils.simpleComplement(primaryBase));\n                                strandPrev = Character.toString(BaseUtils.simpleComplement(nextBase));\n                                strandSecondary = Character.toString(BaseUtils.simpleComplement(secondaryBase));\n                            }\n                            if (strandPrev.charAt(0) != 'N') {\n                                String key = RG+' '+type+' '+call+' '+strandRef+' '+strandPrimary+' '+strandPrev+' '+strandSecondary;\n                                if (counts.containsKey(key)) {\n                                    counts.put(key, counts.get(key) + Long.valueOf(1));\n                                }\n                                else {\n                                    counts.put(key, Long.valueOf(1));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    return 1;\n    }","id":97960,"modified_method":"public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        char refBase = Character.toUpperCase(ref.getBase());\n        ReadBackedPileup pileup = context.getBasePileup();\n        char[] contextBases = ref.getBases();\n        char prevBase = Character.toUpperCase(contextBases[0]);\n        char nextBase = Character.toUpperCase(contextBases[contextBases.length - 1]);\n\n        if (contextBases.length == 3 && refBase != 'N' && pileup.getBases() != null && pileup.getSecondaryBases() != null) {\n            VariantCallContext ugResult = ug.runGenotyper(tracker,ref,context);\n            if (ugResult != null && ugResult.variation != null) {\n                Genotype res = ugResult.genotypes.get(0);\n                String call = res.getBases();\n                String type;\n                if (!res.isVariant(refBase)) {type = \"homref\";}\n                else if (!res.isHet()) {type = \"homvar\";}\n                else if (call.contains(Character.toString(refBase))) {type = \"het\";}\n                else {type = \"bad\";}\n                if (type != \"bad\") {\n                    for (PileupElement element : pileup) {\n                        char primaryBase = Character.toUpperCase((char)element.getBase());\n                        char secondaryBase = Character.toUpperCase((char)element.getSecondBase());\n                        String RG = element.getRead().getReadGroup().getReadGroupId();\n                        if (secondaryBase != 'N' && secondaryBase != '.' && primaryBase != 'N') {\n                            String strandRef;\n                            String strandPrimary;\n                            String strandPrev;\n                            String strandSecondary;\n                            if (!element.getRead().getReadNegativeStrandFlag()) {\n                                strandRef = Character.toString(refBase);\n                                strandPrimary = Character.toString(primaryBase);\n                                strandPrev = Character.toString(prevBase);\n                                strandSecondary = Character.toString(secondaryBase);\n                            }\n                            else {\n                                strandRef = Character.toString(BaseUtils.simpleComplement(refBase));\n                                strandPrimary = Character.toString(BaseUtils.simpleComplement(primaryBase));\n                                strandPrev = Character.toString(BaseUtils.simpleComplement(nextBase));\n                                strandSecondary = Character.toString(BaseUtils.simpleComplement(secondaryBase));\n                            }\n                            if (strandPrev.charAt(0) != 'N') {\n                                String key = RG+' '+type+' '+call+' '+strandRef+' '+strandPrimary+' '+strandPrev+' '+strandSecondary;\n                                if (counts.containsKey(key)) {\n                                    counts.put(key, counts.get(key) + Long.valueOf(1));\n                                }\n                                else {\n                                    counts.put(key, Long.valueOf(1));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    return 1;\n    }","commit_id":"506d39f751a77d29e54686b87eb106c629c7d4bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Compute at a given locus.\n     *\n     * @param tracker the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantCallContext object\n     */\n    public VariantCallContext map(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n\n        // initialize the GenotypeCalculationModel for this thread if that hasn't been done yet\n        if ( UG_args.gcm.get() == null ) {\n            GenotypeWriterFactory.GENOTYPE_FORMAT format = GenotypeWriterFactory.GENOTYPE_FORMAT.VCF;\n            if ( writer != null ) {\n                if ( writer instanceof VCFGenotypeWriter )\n                    format = GenotypeWriterFactory.GENOTYPE_FORMAT.VCF;\n                else if ( writer instanceof GLFGenotypeWriter )\n                    format = GenotypeWriterFactory.GENOTYPE_FORMAT.GLF;\n                else if ( writer instanceof GeliGenotypeWriter )\n                    format = GenotypeWriterFactory.GENOTYPE_FORMAT.GELI;\n                else\n                    throw new StingException(\"Unsupported genotype format: \" + writer.getClass().getName());\n            }\n            UG_args.gcm.set(GenotypeCalculationModelFactory.makeGenotypeCalculation(UG_args.samples, logger, UAC, format, verboseWriter, beagleWriter));\n        }\n\n        return runGenotyper(tracker, refContext, rawContext, UG_args);\n    }","id":97961,"modified_method":"/**\n     * Compute at a given locus.\n     *\n     * @param tracker the meta data tracker\n     * @param refContext the reference base\n     * @param rawContext contextual information around the locus\n     * @return the VariantCallContext object\n     */\n    public VariantCallContext map(RefMetaDataTracker tracker, ReferenceContext refContext, AlignmentContext rawContext) {\n        return UG_engine.runGenotyper(tracker, refContext, rawContext);\n    }","commit_id":"506d39f751a77d29e54686b87eb106c629c7d4bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"public UGStatistics reduce(VariantCallContext value, UGStatistics sum) {\n        // We get a point for reaching reduce :-)\n        sum.nBasesVisited++;\n\n        // can't call the locus because of no coverage\n        if ( value == null )\n            return sum;\n\n        // A call was attempted -- the base was potentially callable\n        sum.nBasesCallable++;\n\n        // if the base was confidently called something, print it out \n        sum.nBasesCalledConfidently += value.confidentlyCalled ? 1 : 0;\n\n        // can't make a confident variant call here\n        if ( value.genotypes == null ||\n                (UAC.genotypeModel != GenotypeCalculationModel.Model.POOLED && value.genotypes.size() == 0) ) {\n            return sum;\n        }\n\n        // if we have a single-sample call (single sample from PointEstimate model returns no VariationCall data)\n        if ( value.variation == null || (!writer.supportsMultiSample() && UG_args.samples.size() <= 1) ) {\n            writer.addGenotypeCall(value.genotypes.get(0));\n        }\n\n        // use multi-sample mode if we have multiple samples or the output type allows it\n        else {\n            writer.addMultiSampleCall(value.genotypes, value.variation);\n        }\n\n        return sum;\n    }","id":97962,"modified_method":"public UGStatistics reduce(VariantCallContext value, UGStatistics sum) {\n        // We get a point for reaching reduce :-)\n        sum.nBasesVisited++;\n\n        // can't call the locus because of no coverage\n        if ( value == null )\n            return sum;\n\n        // A call was attempted -- the base was potentially callable\n        sum.nBasesCallable++;\n\n        // if the base was confidently called something, print it out \n        sum.nBasesCalledConfidently += value.confidentlyCalled ? 1 : 0;\n\n        // can't make a confident variant call here\n        if ( value.genotypes == null ||\n                (UAC.genotypeModel != GenotypeCalculationModel.Model.POOLED && value.genotypes.size() == 0) ) {\n            return sum;\n        }\n\n        // if we have a single-sample call (single sample from PointEstimate model returns no VariationCall data)\n        if ( value.variation == null || (!writer.supportsMultiSample() && UG_engine.samples.size() <= 1) ) {\n            writer.addGenotypeCall(value.genotypes.get(0));\n        }\n\n        // use multi-sample mode if we have multiple samples or the output type allows it\n        else {\n            writer.addMultiSampleCall(value.genotypes, value.variation);\n        }\n\n        return sum;\n    }","commit_id":"506d39f751a77d29e54686b87eb106c629c7d4bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Initialize the samples, output, and genotype calculation model\n     *\n     **/\n    public void initialize() {\n\n        UG_args = getUnifiedCalculationArguments(getToolkit(), UAC, writer);\n\n        // initialize the writers\n        if ( verboseWriter != null ) {\n            StringBuilder header = new StringBuilder(\"AFINFO\\tLOC\\tMAF\\tF\\tNullAFpriors\\t\");\n            for ( char altAllele : BaseUtils.BASES ) {\n                char base = Character.toUpperCase(altAllele);\n                header.append(\"POfDGivenAFFor\" + base + \"\\t\");\n                header.append(\"PosteriorAFFor\" + base + \"\\t\");\n            }\n            verboseWriter.println(header);\n        }\n        if ( beagleWriter != null ) {\n            beagleWriter.print(\"marker alleleA alleleB\");\n            for ( String sample : UG_args.samples )\n                beagleWriter.print(String.format(\" %s %s %s\", sample, sample, sample));\n            beagleWriter.println();\n        }\n\n        // initialize the header\n        GenotypeWriterFactory.writeHeader(writer, GenomeAnalysisEngine.instance.getSAMFileHeader(), UG_args.samples, getHeaderInfo(UG_args));\n    }","id":97963,"modified_method":"/**\n     * Initialize the samples, output, and genotype calculation model\n     *\n     **/\n    public void initialize() {\n\n        UG_engine = new UnifiedGenotyperEngine(getToolkit(), UAC, logger, writer, verboseWriter, beagleWriter);\n\n        // initialize the writers\n        if ( verboseWriter != null ) {\n            StringBuilder header = new StringBuilder(\"AFINFO\\tLOC\\tMAF\\tF\\tNullAFpriors\\t\");\n            for ( char altAllele : BaseUtils.BASES ) {\n                char base = Character.toUpperCase(altAllele);\n                header.append(\"POfDGivenAFFor\" + base + \"\\t\");\n                header.append(\"PosteriorAFFor\" + base + \"\\t\");\n            }\n            verboseWriter.println(header);\n        }\n        if ( beagleWriter != null ) {\n            beagleWriter.print(\"marker alleleA alleleB\");\n            for ( String sample : UG_engine.samples )\n                beagleWriter.print(String.format(\" %s %s %s\", sample, sample, sample));\n            beagleWriter.println();\n        }\n\n        // initialize the header\n        GenotypeWriterFactory.writeHeader(writer, GenomeAnalysisEngine.instance.getSAMFileHeader(), UG_engine.samples, getHeaderInfo());\n    }","commit_id":"506d39f751a77d29e54686b87eb106c629c7d4bd","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static void exportFileEntry(\n\t\t\tPortletDataContext portletDataContext, Element foldersElement,\n\t\t\tElement fileEntriesElement, Element fileRanksElement,\n\t\t\tFileEntry fileEntry, boolean checkDateRange)\n\t\tthrows Exception {\n\n\t\tif (checkDateRange &&\n\t\t\t!portletDataContext.isWithinDateRange(\n\t\t\t\tfileEntry.getModifiedDate())) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tFileVersion fileVersion = fileEntry.getFileVersion();\n\n\t\tif (fileVersion.getStatus() != WorkflowConstants.STATUS_APPROVED) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (foldersElement != null) {\n\t\t\texportParentFolder(\n\t\t\t\tportletDataContext, foldersElement, fileEntry.getFolderId());\n\t\t}\n\n\t\tString path = getFileEntryPath(portletDataContext, fileEntry);\n\n\t\tif (portletDataContext.isPathNotProcessed(path)) {\n\t\t\tElement fileEntryElement = fileEntriesElement.addElement(\n\t\t\t\t\"file-entry\");\n\n\t\t\tfileEntryElement.addAttribute(\"path\", path);\n\n\t\t\tString binPath = getFileEntryBinPath(portletDataContext, fileEntry);\n\n\t\t\tfileEntryElement.addAttribute(\"bin-path\", binPath);\n\n\t\t\tfileEntry.prepare();\n\n\t\t\tportletDataContext.addLocks(\n\t\t\t\tFileEntry.class, String.valueOf(fileEntry.getFileEntryId()));\n\n\t\t\tportletDataContext.addPermissions(\n\t\t\t\tFileEntry.class, fileEntry.getFileEntryId());\n\n\t\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\t\t_NAMESPACE, \"categories\")) {\n\n\t\t\t\tportletDataContext.addAssetCategories(\n\t\t\t\t\tFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\t\t_NAMESPACE, \"comments\")) {\n\n\t\t\t\tportletDataContext.addComments(\n\t\t\t\t\tFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tportletDataContext.addRatingsEntries(\n\t\t\t\t\tFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\tportletDataContext.addAssetTags(\n\t\t\t\t\tFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tInputStream is = FileEntryUtil.getContentStream(fileEntry);\n\n\t\t\tif (is == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"No file found for file entry \" +\n\t\t\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t\t}\n\n\t\t\t\tfileEntryElement.detach();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tgetFileEntryBinPath(portletDataContext, fileEntry), is);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tis.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t_log.error(ioe, ioe);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tportletDataContext.addZipEntry(path, fileEntry);\n\n\t\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"ranks\")) {\n\t\t\t\tList<DLFileRank> fileRanks = DLFileRankUtil.findByFileEntryId(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\t\tfor (DLFileRank fileRank : fileRanks) {\n\t\t\t\t\texportFileRank(\n\t\t\t\t\t\tportletDataContext, fileRanksElement, fileRank);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":97964,"modified_method":"public static void exportFileEntry(\n\t\t\tPortletDataContext portletDataContext, Element foldersElement,\n\t\t\tElement fileEntriesElement, Element fileRanksElement,\n\t\t\tFileEntry fileEntry, boolean checkDateRange)\n\t\tthrows Exception {\n\n\t\tif (checkDateRange &&\n\t\t\t!portletDataContext.isWithinDateRange(\n\t\t\t\tfileEntry.getModifiedDate())) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tFileVersion fileVersion = fileEntry.getFileVersion();\n\n\t\tif (fileVersion.getStatus() != WorkflowConstants.STATUS_APPROVED) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (foldersElement != null) {\n\t\t\texportParentFolder(\n\t\t\t\tportletDataContext, foldersElement, fileEntry.getFolderId());\n\t\t}\n\n\t\tString path = getFileEntryPath(portletDataContext, fileEntry);\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tElement fileEntryElement = fileEntriesElement.addElement(\n\t\t\t\"file-entry\");\n\n\t\tfileEntryElement.addAttribute(\"path\", path);\n\n\t\tfileEntry.prepare();\n\n\t\tportletDataContext.addLocks(\n\t\t\tFileEntry.class, String.valueOf(fileEntry.getFileEntryId()));\n\n\t\tportletDataContext.addPermissions(\n\t\t\tFileEntry.class, fileEntry.getFileEntryId());\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\t_NAMESPACE, \"categories\")) {\n\n\t\t\tportletDataContext.addAssetCategories(\n\t\t\t\tFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\t_NAMESPACE, \"comments\")) {\n\n\t\t\tportletDataContext.addComments(\n\t\t\t\tFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tportletDataContext.addRatingsEntries(\n\t\t\t\tFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tportletDataContext.addAssetTags(\n\t\t\t\tFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tboolean performDirectBinaryImport = MapUtil.getBoolean(\n\t\t\tportletDataContext.getParameterMap(),\n\t\t\tPortletDataHandlerKeys.PERFORM_DIRECT_BINARY_IMPORT);\n\n\t\tif (!performDirectBinaryImport) {\n\t\t\tString binPath = getFileEntryBinPath(portletDataContext, fileEntry);\n\n\t\t\tfileEntryElement.addAttribute(\"bin-path\", binPath);\n\n\t\t\tInputStream is = FileEntryUtil.getContentStream(fileEntry);\n\n\t\t\tif (is == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"No file found for file entry \" +\n\t\t\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t\t}\n\n\t\t\t\tfileEntryElement.detach();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tportletDataContext.addZipEntry(binPath, is);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tis.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t_log.error(ioe, ioe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tportletDataContext.addZipEntry(path, fileEntry);\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"ranks\")) {\n\t\t\tList<DLFileRank> fileRanks = DLFileRankUtil.findByFileEntryId(\n\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\tfor (DLFileRank fileRank : fileRanks) {\n\t\t\t\texportFileRank(\n\t\t\t\t\tportletDataContext, fileRanksElement, fileRank);\n\t\t\t}\n\t\t}\n\t}","commit_id":"d404d5cba1b7dd9e5c6b9cb1a9665be69413b8a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void importFileEntry(\n\t\t\tPortletDataContext portletDataContext, Element fileEntryElement)\n\t\tthrows Exception {\n\n\t\tString path = fileEntryElement.attributeValue(\"path\");\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tFileEntry fileEntry = (FileEntry)portletDataContext.getZipEntryAsObject(\n\t\t\tpath);\n\n\t\tString binPath = fileEntryElement.attributeValue(\"bin-path\");\n\n\t\tlong userId = portletDataContext.getUserId(fileEntry.getUserUuid());\n\n\t\tMap<Long, Long> folderPKs =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFolder.class);\n\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, fileEntry.getFolderId(), fileEntry.getFolderId());\n\n\t\tlong[] assetCategoryIds = null;\n\t\tString[] assetTagNames = null;\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\tassetCategoryIds = portletDataContext.getAssetCategoryIds(\n\t\t\t\tFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = portletDataContext.getAssetTagNames(\n\t\t\t\tFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(fileEntry.getCreateDate());\n\t\tserviceContext.setModifiedDate(fileEntry.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(portletDataContext.getScopeGroupId());\n\n\t\tInputStream is = portletDataContext.getZipEntryAsInputStream(binPath);\n\n\t\tif ((folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == fileEntry.getFolderId())) {\n\n\t\t\tString folderPath = getImportFolderPath(\n\t\t\t\tportletDataContext, folderId);\n\n\t\t\tFolder folder = (Folder)portletDataContext.getZipEntryAsObject(\n\t\t\t\tfolderPath);\n\n\t\t\timportFolder(portletDataContext, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, fileEntry.getFolderId(), fileEntry.getFolderId());\n\t\t}\n\n\t\tFileEntry importedFileEntry = null;\n\n\t\tString titleWithExtension = fileEntry.getTitle();\n\t\tString extension = fileEntry.getExtension();\n\n\t\tif (!titleWithExtension.endsWith(StringPool.PERIOD + extension)) {\n\t\t\ttitleWithExtension += StringPool.PERIOD + extension;\n\t\t}\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tFileEntry existingFileEntry = FileEntryUtil.fetchByUUID_R(\n\t\t\t\tfileEntry.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingFileEntry == null) {\n\t\t\t\tFileEntry existingTitleFileEntry = FileEntryUtil.fetchByR_F_T(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\tfileEntry.getTitle());\n\n\t\t\t\tif (existingTitleFileEntry != null) {\n\t\t\t\t\tif (portletDataContext.\n\t\t\t\t\t\t\tisDataStrategyMirrorWithOverwritting()) {\n\n\t\t\t\t\t\tDLAppLocalServiceUtil.deleteFileEntry(\n\t\t\t\t\t\t\texistingTitleFileEntry.getFileEntryId());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tString originalTitle = fileEntry.getTitle();\n\t\t\t\t\t\tString dotExtension = StringPool.PERIOD + extension;\n\n\t\t\t\t\t\tif (originalTitle.endsWith(dotExtension)) {\n\t\t\t\t\t\t\tint pos = originalTitle.lastIndexOf(dotExtension);\n\n\t\t\t\t\t\t\toriginalTitle = originalTitle.substring(0, pos);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int i = 1;; i++) {\n\t\t\t\t\t\t\ttitleWithExtension =\n\t\t\t\t\t\t\t\toriginalTitle + StringPool.SPACE + i +\n\t\t\t\t\t\t\t\t\tdotExtension;\n\n\t\t\t\t\t\t\texistingTitleFileEntry = FileEntryUtil.findByR_F_T(\n\t\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\t\t\t\ttitleWithExtension);\n\n\t\t\t\t\t\t\tif (existingTitleFileEntry == null) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tserviceContext.setUuid(fileEntry.getUuid());\n\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitleWithExtension, fileEntry.getDescription(), null,\n\t\t\t\t\tis, fileEntry.getSize(), serviceContext);\n\t\t\t}\n\t\t\telse if (!isDuplicateFileEntry(fileEntry, existingFileEntry)) {\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.updateFileEntry(\n\t\t\t\t\tuserId, existingFileEntry.getFileEntryId(),\n\t\t\t\t\tfileEntry.getTitle(), fileEntry.getTitle(),\n\t\t\t\t\tfileEntry.getDescription(), null, true,\n\t\t\t\t\tis, fileEntry.getSize(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileVersion latestFileVersion =\n\t\t\t\t\texistingFileEntry.getLatestFileVersion();\n\n\t\t\t\tDLAppLocalServiceUtil.updateAsset(\n\t\t\t\t\tuserId, existingFileEntry, latestFileVersion,\n\t\t\t\t\tassetCategoryIds, assetTagNames);\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tFileEntry.class);\n\n\t\t\t\tindexer.reindex(existingFileEntry);\n\n\t\t\t\timportedFileEntry = existingFileEntry;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitleWithExtension, fileEntry.getDescription(), null,\n\t\t\t\t\tis, fileEntry.getSize(), serviceContext);\n\t\t\t}\n\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\tString title = fileEntry.getTitle();\n\n\t\t\t\tString[] titleParts = title.split(\"\\\\.\", 2);\n\n\t\t\t\ttitle = titleParts[0] + PwdGenerator.getPassword();\n\n\t\t\t\tif (titleParts.length > 1) {\n\t\t\t\t\ttitle += StringPool.PERIOD + titleParts[1];\n\t\t\t\t}\n\n\t\t\t\tif (!title.endsWith(StringPool.PERIOD + extension)) {\n\t\t\t\t\ttitle += StringPool.PERIOD + extension;\n\t\t\t\t}\n\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitle, fileEntry.getDescription(), null,\n\t\t\t\t\tis, fileEntry.getSize(), serviceContext);\n\t\t\t}\n\t\t}\n\n\t\tMap<Long, Long> fileEntryPKs =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFileEntry.class);\n\n\t\tfileEntryPKs.put(\n\t\t\tfileEntry.getFileEntryId(), importedFileEntry.getFileEntryId());\n\n\t\tMap<String, String> fileEntryTitles =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFileEntry.class.getName() + \".title\");\n\n\t\tfileEntryTitles.put(fileEntry.getTitle(), importedFileEntry.getTitle());\n\n\t\tString lockKey = String.valueOf(fileEntry.getFileEntryId());\n\n\t\tString newLockKey = String.valueOf(importedFileEntry.getFileEntryId());\n\n\t\tportletDataContext.importLocks(FileEntry.class, lockKey, newLockKey);\n\n\t\tportletDataContext.importPermissions(\n\t\t\tFileEntry.class, fileEntry.getFileEntryId(),\n\t\t\timportedFileEntry.getFileEntryId());\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\tportletDataContext.importComments(\n\t\t\t\tFileEntry.class, fileEntry.getFileEntryId(),\n\t\t\t\timportedFileEntry.getFileEntryId(),\n\t\t\t\tportletDataContext.getScopeGroupId());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tportletDataContext.importRatingsEntries(\n\t\t\t\tFileEntry.class, fileEntry.getFileEntryId(),\n\t\t\t\timportedFileEntry.getFileEntryId());\n\t\t}\n\t}","id":97965,"modified_method":"public static void importFileEntry(\n\t\t\tPortletDataContext portletDataContext, Element fileEntryElement)\n\t\tthrows Exception {\n\n\t\tString path = fileEntryElement.attributeValue(\"path\");\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tFileEntry fileEntry = (FileEntry)portletDataContext.getZipEntryAsObject(\n\t\t\tpath);\n\n\t\tlong userId = portletDataContext.getUserId(fileEntry.getUserUuid());\n\n\t\tMap<Long, Long> folderPKs =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFolder.class);\n\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, fileEntry.getFolderId(), fileEntry.getFolderId());\n\n\t\tlong[] assetCategoryIds = null;\n\t\tString[] assetTagNames = null;\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\tassetCategoryIds = portletDataContext.getAssetCategoryIds(\n\t\t\t\tFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = portletDataContext.getAssetTagNames(\n\t\t\t\tFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(fileEntry.getCreateDate());\n\t\tserviceContext.setModifiedDate(fileEntry.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(portletDataContext.getScopeGroupId());\n\n\t\tboolean performDirectBinaryImport = MapUtil.getBoolean(\n\t\t\tportletDataContext.getParameterMap(),\n\t\t\tPortletDataHandlerKeys.PERFORM_DIRECT_BINARY_IMPORT);\n\n\t\tString binPath = fileEntryElement.attributeValue(\"bin-path\");\n\n\t\tInputStream is = null;\n\n\t\tif (Validator.isNull(binPath) && performDirectBinaryImport) {\n\t\t\tis = FileEntryUtil.getContentStream(fileEntry);\n\t\t}\n\t\telse {\n\t\t\tis = portletDataContext.getZipEntryAsInputStream(binPath);\n\t\t}\n\n\t\tif ((folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == fileEntry.getFolderId())) {\n\n\t\t\tString folderPath = getImportFolderPath(\n\t\t\t\tportletDataContext, folderId);\n\n\t\t\tFolder folder = (Folder)portletDataContext.getZipEntryAsObject(\n\t\t\t\tfolderPath);\n\n\t\t\timportFolder(portletDataContext, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, fileEntry.getFolderId(), fileEntry.getFolderId());\n\t\t}\n\n\t\tFileEntry importedFileEntry = null;\n\n\t\tString titleWithExtension = fileEntry.getTitle();\n\t\tString extension = fileEntry.getExtension();\n\n\t\tif (!titleWithExtension.endsWith(StringPool.PERIOD + extension)) {\n\t\t\ttitleWithExtension += StringPool.PERIOD + extension;\n\t\t}\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tFileEntry existingFileEntry = FileEntryUtil.fetchByUUID_R(\n\t\t\t\tfileEntry.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingFileEntry == null) {\n\t\t\t\tFileEntry existingTitleFileEntry = FileEntryUtil.fetchByR_F_T(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\tfileEntry.getTitle());\n\n\t\t\t\tif (existingTitleFileEntry != null) {\n\t\t\t\t\tif (portletDataContext.\n\t\t\t\t\t\t\tisDataStrategyMirrorWithOverwritting()) {\n\n\t\t\t\t\t\tDLAppLocalServiceUtil.deleteFileEntry(\n\t\t\t\t\t\t\texistingTitleFileEntry.getFileEntryId());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tString originalTitle = fileEntry.getTitle();\n\t\t\t\t\t\tString dotExtension = StringPool.PERIOD + extension;\n\n\t\t\t\t\t\tif (originalTitle.endsWith(dotExtension)) {\n\t\t\t\t\t\t\tint pos = originalTitle.lastIndexOf(dotExtension);\n\n\t\t\t\t\t\t\toriginalTitle = originalTitle.substring(0, pos);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int i = 1;; i++) {\n\t\t\t\t\t\t\ttitleWithExtension =\n\t\t\t\t\t\t\t\toriginalTitle + StringPool.SPACE + i +\n\t\t\t\t\t\t\t\t\tdotExtension;\n\n\t\t\t\t\t\t\texistingTitleFileEntry = FileEntryUtil.findByR_F_T(\n\t\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\t\t\t\ttitleWithExtension);\n\n\t\t\t\t\t\t\tif (existingTitleFileEntry == null) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tserviceContext.setUuid(fileEntry.getUuid());\n\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitleWithExtension, fileEntry.getDescription(), null,\n\t\t\t\t\tis, fileEntry.getSize(), serviceContext);\n\t\t\t}\n\t\t\telse if (!isDuplicateFileEntry(fileEntry, existingFileEntry)) {\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.updateFileEntry(\n\t\t\t\t\tuserId, existingFileEntry.getFileEntryId(),\n\t\t\t\t\tfileEntry.getTitle(), fileEntry.getTitle(),\n\t\t\t\t\tfileEntry.getDescription(), null, true,\n\t\t\t\t\tis, fileEntry.getSize(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileVersion latestFileVersion =\n\t\t\t\t\texistingFileEntry.getLatestFileVersion();\n\n\t\t\t\tDLAppLocalServiceUtil.updateAsset(\n\t\t\t\t\tuserId, existingFileEntry, latestFileVersion,\n\t\t\t\t\tassetCategoryIds, assetTagNames);\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tFileEntry.class);\n\n\t\t\t\tindexer.reindex(existingFileEntry);\n\n\t\t\t\timportedFileEntry = existingFileEntry;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitleWithExtension, fileEntry.getDescription(), null,\n\t\t\t\t\tis, fileEntry.getSize(), serviceContext);\n\t\t\t}\n\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\tString title = fileEntry.getTitle();\n\n\t\t\t\tString[] titleParts = title.split(\"\\\\.\", 2);\n\n\t\t\t\ttitle = titleParts[0] + PwdGenerator.getPassword();\n\n\t\t\t\tif (titleParts.length > 1) {\n\t\t\t\t\ttitle += StringPool.PERIOD + titleParts[1];\n\t\t\t\t}\n\n\t\t\t\tif (!title.endsWith(StringPool.PERIOD + extension)) {\n\t\t\t\t\ttitle += StringPool.PERIOD + extension;\n\t\t\t\t}\n\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitle, fileEntry.getDescription(), null,\n\t\t\t\t\tis, fileEntry.getSize(), serviceContext);\n\t\t\t}\n\t\t}\n\n\t\tMap<Long, Long> fileEntryPKs =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFileEntry.class);\n\n\t\tfileEntryPKs.put(\n\t\t\tfileEntry.getFileEntryId(), importedFileEntry.getFileEntryId());\n\n\t\tMap<String, String> fileEntryTitles =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFileEntry.class.getName() + \".title\");\n\n\t\tfileEntryTitles.put(fileEntry.getTitle(), importedFileEntry.getTitle());\n\n\t\tString lockKey = String.valueOf(fileEntry.getFileEntryId());\n\n\t\tString newLockKey = String.valueOf(importedFileEntry.getFileEntryId());\n\n\t\tportletDataContext.importLocks(FileEntry.class, lockKey, newLockKey);\n\n\t\tportletDataContext.importPermissions(\n\t\t\tFileEntry.class, fileEntry.getFileEntryId(),\n\t\t\timportedFileEntry.getFileEntryId());\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\tportletDataContext.importComments(\n\t\t\t\tFileEntry.class, fileEntry.getFileEntryId(),\n\t\t\t\timportedFileEntry.getFileEntryId(),\n\t\t\t\tportletDataContext.getScopeGroupId());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tportletDataContext.importRatingsEntries(\n\t\t\t\tFileEntry.class, fileEntry.getFileEntryId(),\n\t\t\t\timportedFileEntry.getFileEntryId());\n\t\t}\n\t}","commit_id":"d404d5cba1b7dd9e5c6b9cb1a9665be69413b8a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void importImage(\n\t\t\tPortletDataContext portletDataContext, IGImage image,\n\t\t\tString binPath)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(image.getUserUuid());\n\n\t\tMap<Long, Long> folderPKs =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tIGFolder.class);\n\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, image.getFolderId(), image.getFolderId());\n\n\t\tFile imageFile = null;\n\n\t\tbyte[] bytes = portletDataContext.getZipEntryAsByteArray(binPath);\n\n\t\tif (bytes == null) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find image file for image \" + image.getImageId());\n\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\timageFile = File.createTempFile(\n\t\t\t\tString.valueOf(image.getPrimaryKey()),\n\t\t\t\tStringPool.PERIOD + image.getImageType());\n\n\t\t\tFileUtil.write(imageFile, bytes);\n\t\t}\n\n\t\tlong[] assetCategoryIds = null;\n\t\tString[] assetTagNames = null;\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\tassetCategoryIds = portletDataContext.getAssetCategoryIds(\n\t\t\t\tIGImage.class, image.getImageId());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = portletDataContext.getAssetTagNames(\n\t\t\t\tIGImage.class, image.getImageId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(image.getCreateDate());\n\t\tserviceContext.setModifiedDate(image.getModifiedDate());\n\n\t\tif ((folderId != IGFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == image.getFolderId())) {\n\n\t\t\tString path = getImportFolderPath(portletDataContext, folderId);\n\n\t\t\tIGFolder folder = (IGFolder)portletDataContext.getZipEntryAsObject(\n\t\t\t\tpath);\n\n\t\t\timportFolder(portletDataContext, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, image.getFolderId(), image.getFolderId());\n\t\t}\n\n\t\tIGImage importedImage = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tIGImage existingImage = IGImageUtil.fetchByUUID_G(\n\t\t\t\timage.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingImage == null) {\n\t\t\t\tString imageName = image.getName();\n\n\t\t\t\tIGImage existingNameImage = getImage(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), image.getFolderId(),\n\t\t\t\t\timageName, image.getImageType());\n\n\t\t\t\tif (existingNameImage != null) {\n\t\t\t\t\tif (portletDataContext.\n\t\t\t\t\t\t\tisDataStrategyMirrorWithOverwritting()) {\n\n\t\t\t\t\t\tIGImageLocalServiceUtil.deleteIGImage(\n\t\t\t\t\t\t\texistingNameImage);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tString originalName = imageName;\n\n\t\t\t\t\t\tfor (int i = 1;; i++) {\n\t\t\t\t\t\t\timageName = originalName + StringPool.SPACE + i;\n\n\t\t\t\t\t\t\texistingNameImage = getImage(\n\t\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\t\t\t\timage.getFolderId(), imageName,\n\t\t\t\t\t\t\t\timage.getImageType());\n\n\t\t\t\t\t\t\tif (existingNameImage == null) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tserviceContext.setUuid(image.getUuid());\n\n\t\t\t\timportedImage = IGImageLocalServiceUtil.addImage(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\timageName, image.getDescription(), imageFile,\n\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedImage = IGImageLocalServiceUtil.updateImage(\n\t\t\t\t\tuserId, existingImage.getImageId(),\n\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\timage.getName(), image.getDescription(), imageFile,\n\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString name = image.getName();\n\n\t\t\ttry {\n\t\t\t\timportedImage = IGImageLocalServiceUtil.addImage(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\tname, image.getDescription(), imageFile,\n\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t}\n\t\t\tcatch (DuplicateImageNameException dine) {\n\t\t\t\tString[] nameParts = name.split(\"\\\\.\", 2);\n\n\t\t\t\tname = nameParts[0] + PwdGenerator.getPassword();\n\n\t\t\t\tif (nameParts.length > 1) {\n\t\t\t\t\tname += StringPool.PERIOD + nameParts[1];\n\t\t\t\t}\n\n\t\t\t\timportedImage = IGImageLocalServiceUtil.addImage(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\tname, image.getDescription(), imageFile,\n\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t}\n\t\t}\n\n\t\tportletDataContext.importPermissions(\n\t\t\tIGImage.class, image.getImageId(), importedImage.getImageId());\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tportletDataContext.importRatingsEntries(\n\t\t\t\tIGImage.class, image.getImageId(), importedImage.getImageId());\n\t\t}\n\n\t\tMap<Long, Long> igImagePKs =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tIGImage.class);\n\n\t\tigImagePKs.put(image.getImageId(), importedImage.getImageId());\n\t}","id":97966,"modified_method":"protected static void importImage(\n\t\t\tPortletDataContext portletDataContext, IGImage image,\n\t\t\tString binPath)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(image.getUserUuid());\n\n\t\tMap<Long, Long> folderPKs =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tIGFolder.class);\n\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, image.getFolderId(), image.getFolderId());\n\n\t\tboolean performDirectBinaryImport = MapUtil.getBoolean(\n\t\t\tportletDataContext.getParameterMap(),\n\t\t\tPortletDataHandlerKeys.PERFORM_DIRECT_BINARY_IMPORT);\n\n\t\tFile imageFile = null;\n\n\t\tbyte[] bytes = null;\n\n\t\tif (Validator.isNull(binPath) && performDirectBinaryImport) {\n\t\t\tImage largeImage = ImageUtil.findByPrimaryKey(\n\t\t\t\timage.getLargeImageId());\n\n\t\t\tbytes = largeImage.getTextObj();\n\t\t}\n\t\telse {\n\t\t\tbytes = portletDataContext.getZipEntryAsByteArray(binPath);\n\t\t}\n\n\t\tif (bytes == null) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find image file for image \" + image.getImageId());\n\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\timageFile = File.createTempFile(\n\t\t\t\tString.valueOf(image.getPrimaryKey()),\n\t\t\t\tStringPool.PERIOD + image.getImageType());\n\n\t\t\tFileUtil.write(imageFile, bytes);\n\t\t}\n\n\t\tlong[] assetCategoryIds = null;\n\t\tString[] assetTagNames = null;\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\tassetCategoryIds = portletDataContext.getAssetCategoryIds(\n\t\t\t\tIGImage.class, image.getImageId());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = portletDataContext.getAssetTagNames(\n\t\t\t\tIGImage.class, image.getImageId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(image.getCreateDate());\n\t\tserviceContext.setModifiedDate(image.getModifiedDate());\n\n\t\tif ((folderId != IGFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == image.getFolderId())) {\n\n\t\t\tString path = getImportFolderPath(portletDataContext, folderId);\n\n\t\t\tIGFolder folder = (IGFolder)portletDataContext.getZipEntryAsObject(\n\t\t\t\tpath);\n\n\t\t\timportFolder(portletDataContext, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, image.getFolderId(), image.getFolderId());\n\t\t}\n\n\t\tIGImage importedImage = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tIGImage existingImage = IGImageUtil.fetchByUUID_G(\n\t\t\t\timage.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingImage == null) {\n\t\t\t\tString imageName = image.getName();\n\n\t\t\t\tIGImage existingNameImage = getImage(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), image.getFolderId(),\n\t\t\t\t\timageName, image.getImageType());\n\n\t\t\t\tif (existingNameImage != null) {\n\t\t\t\t\tif (portletDataContext.\n\t\t\t\t\t\t\tisDataStrategyMirrorWithOverwritting()) {\n\n\t\t\t\t\t\tIGImageLocalServiceUtil.deleteIGImage(\n\t\t\t\t\t\t\texistingNameImage);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tString originalName = imageName;\n\n\t\t\t\t\t\tfor (int i = 1;; i++) {\n\t\t\t\t\t\t\timageName = originalName + StringPool.SPACE + i;\n\n\t\t\t\t\t\t\texistingNameImage = getImage(\n\t\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\t\t\t\timage.getFolderId(), imageName,\n\t\t\t\t\t\t\t\timage.getImageType());\n\n\t\t\t\t\t\t\tif (existingNameImage == null) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tserviceContext.setUuid(image.getUuid());\n\n\t\t\t\timportedImage = IGImageLocalServiceUtil.addImage(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\timageName, image.getDescription(), imageFile,\n\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedImage = IGImageLocalServiceUtil.updateImage(\n\t\t\t\t\tuserId, existingImage.getImageId(),\n\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\timage.getName(), image.getDescription(), imageFile,\n\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString name = image.getName();\n\n\t\t\ttry {\n\t\t\t\timportedImage = IGImageLocalServiceUtil.addImage(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\tname, image.getDescription(), imageFile,\n\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t}\n\t\t\tcatch (DuplicateImageNameException dine) {\n\t\t\t\tString[] nameParts = name.split(\"\\\\.\", 2);\n\n\t\t\t\tname = nameParts[0] + PwdGenerator.getPassword();\n\n\t\t\t\tif (nameParts.length > 1) {\n\t\t\t\t\tname += StringPool.PERIOD + nameParts[1];\n\t\t\t\t}\n\n\t\t\t\timportedImage = IGImageLocalServiceUtil.addImage(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\tname, image.getDescription(), imageFile,\n\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t}\n\t\t}\n\n\t\tportletDataContext.importPermissions(\n\t\t\tIGImage.class, image.getImageId(), importedImage.getImageId());\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tportletDataContext.importRatingsEntries(\n\t\t\t\tIGImage.class, image.getImageId(), importedImage.getImageId());\n\t\t}\n\n\t\tMap<Long, Long> igImagePKs =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tIGImage.class);\n\n\t\tigImagePKs.put(image.getImageId(), importedImage.getImageId());\n\t}","commit_id":"d404d5cba1b7dd9e5c6b9cb1a9665be69413b8a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void exportImage(\n\t\t\tPortletDataContext portletDataContext, Element foldersElement,\n\t\t\tElement imagesElement, IGImage image, boolean checkDateRange)\n\t\tthrows Exception {\n\n\t\tif (checkDateRange &&\n\t\t\t!portletDataContext.isWithinDateRange(image.getModifiedDate())) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (foldersElement != null) {\n\t\t\texportParentFolder(\n\t\t\t\tportletDataContext, foldersElement, image.getFolderId());\n\t\t}\n\n\t\tString path = getImagePath(portletDataContext, image);\n\n\t\tif (portletDataContext.isPathNotProcessed(path)) {\n\t\t\tElement imageElement = imagesElement.addElement(\"image\");\n\n\t\t\timageElement.addAttribute(\"path\", path);\n\t\t\timageElement.addAttribute(\n\t\t\t\t\"bin-path\", getImageBinPath(portletDataContext, image));\n\n\t\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\t\t_NAMESPACE, \"categories\")) {\n\n\t\t\t\tportletDataContext.addAssetCategories(\n\t\t\t\t\tIGImage.class, image.getImageId());\n\t\t\t}\n\n\t\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tportletDataContext.addRatingsEntries(\n\t\t\t\t\tIGImage.class, image.getImageId());\n\t\t\t}\n\n\t\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\tportletDataContext.addAssetTags(\n\t\t\t\t\tIGImage.class, image.getImageId());\n\t\t\t}\n\n\t\t\timage.setUserUuid(image.getUserUuid());\n\n\t\t\tImage largeImage = ImageUtil.findByPrimaryKey(\n\t\t\t\timage.getLargeImageId());\n\n\t\t\timage.setImageType(largeImage.getType());\n\n\t\t\tportletDataContext.addPermissions(\n\t\t\t\tIGImage.class, image.getImageId());\n\n\t\t\tportletDataContext.addZipEntry(\n\t\t\t\tgetImageBinPath(portletDataContext, image),\n\t\t\t\tlargeImage.getTextObj());\n\n\t\t\tportletDataContext.addZipEntry(path, image);\n\t\t}\n\t}","id":97967,"modified_method":"public static void exportImage(\n\t\t\tPortletDataContext portletDataContext, Element foldersElement,\n\t\t\tElement imagesElement, IGImage image, boolean checkDateRange)\n\t\tthrows Exception {\n\n\t\tif (checkDateRange &&\n\t\t\t!portletDataContext.isWithinDateRange(image.getModifiedDate())) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (foldersElement != null) {\n\t\t\texportParentFolder(\n\t\t\t\tportletDataContext, foldersElement, image.getFolderId());\n\t\t}\n\n\t\tString path = getImagePath(portletDataContext, image);\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tElement imageElement = imagesElement.addElement(\"image\");\n\n\t\timageElement.addAttribute(\"path\", path);\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\t_NAMESPACE, \"categories\")) {\n\n\t\t\tportletDataContext.addAssetCategories(\n\t\t\t\tIGImage.class, image.getImageId());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tportletDataContext.addRatingsEntries(\n\t\t\t\tIGImage.class, image.getImageId());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tportletDataContext.addAssetTags(\n\t\t\t\tIGImage.class, image.getImageId());\n\t\t}\n\n\t\timage.setUserUuid(image.getUserUuid());\n\n\t\tImage largeImage = ImageUtil.findByPrimaryKey(\n\t\t\timage.getLargeImageId());\n\n\t\timage.setImageType(largeImage.getType());\n\n\t\tportletDataContext.addPermissions(\n\t\t\tIGImage.class, image.getImageId());\n\n\t\tboolean performDirectBinaryImport = MapUtil.getBoolean(\n\t\t\tportletDataContext.getParameterMap(),\n\t\t\tPortletDataHandlerKeys.PERFORM_DIRECT_BINARY_IMPORT);\n\n\t\tif (!performDirectBinaryImport) {\n\t\t\tString binPath = getImageBinPath(portletDataContext, image);\n\n\t\t\timageElement.addAttribute(\"bin-path\", binPath);\n\n\t\t\tportletDataContext.addZipEntry(binPath, largeImage.getTextObj());\n\t\t}\n\n\t\tportletDataContext.addZipEntry(path, image);\n\t}","commit_id":"d404d5cba1b7dd9e5c6b9cb1a9665be69413b8a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void publishLayouts(\n\t\t\tlong userId, long sourceGroupId, long targetGroupId,\n\t\t\tboolean privateLayout, long[] layoutIds,\n\t\t\tMap<String, String[]> parameterMap, Date startDate, Date endDate)\n\t\tthrows Exception {\n\n\t\tFile file = LayoutLocalServiceUtil.exportLayoutsAsFile(\n\t\t\tsourceGroupId, privateLayout, layoutIds, parameterMap, startDate,\n\t\t\tendDate);\n\n\t\ttry {\n\t\t\tLayoutLocalServiceUtil.importLayouts(\n\t\t\t\tuserId, targetGroupId, privateLayout, parameterMap, file);\n\t\t}\n\t\tfinally {\n\t\t\tfile.delete();\n\t\t}\n\t}","id":97968,"modified_method":"public void publishLayouts(\n\t\t\tlong userId, long sourceGroupId, long targetGroupId,\n\t\t\tboolean privateLayout, long[] layoutIds,\n\t\t\tMap<String, String[]> parameterMap, Date startDate, Date endDate)\n\t\tthrows Exception {\n\n\t\tparameterMap.put(\n\t\t\tPortletDataHandlerKeys.PERFORM_DIRECT_BINARY_IMPORT,\n\t\t\tnew String[] {String.valueOf(true)});\n\n\t\tFile file = LayoutLocalServiceUtil.exportLayoutsAsFile(\n\t\t\tsourceGroupId, privateLayout, layoutIds, parameterMap, startDate,\n\t\t\tendDate);\n\n\t\ttry {\n\t\t\tLayoutLocalServiceUtil.importLayouts(\n\t\t\t\tuserId, targetGroupId, privateLayout, parameterMap, file);\n\t\t}\n\t\tfinally {\n\t\t\tfile.delete();\n\t\t}\n\t}","commit_id":"d404d5cba1b7dd9e5c6b9cb1a9665be69413b8a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Get list of regions of BAM file that may contain SAMRecords for the given range\n     * @param referenceIndex sequence of desired SAMRecords\n     * @param startPos 1-based start of the desired interval, inclusive\n     * @param endPos 1-based end of the desired interval, inclusive\n     * @return array of pairs of virtual file positions.  Each pair is the first and last\n     * virtual file position in a range that can be scanned to find SAMRecords that overlap the given\n     * positions. The last position in each pair is a virtual file pointer to the first SAMRecord beyond\n     * the range that may contain the indicated SAMRecords.\n     */\n    long[] getFilePointersContaining(final int referenceIndex, final int startPos, final int endPos) {\n        List<Bin> bins = getBinsContaining(referenceIndex,startPos,endPos);\n        // System.out.println(\"# Sequence target TID: \" + referenceIndex);\n        if (bins.size() == 0) {\n            return null;\n        }\n\n        List<Chunk> chunkList = new ArrayList<Chunk>();\n        for(Bin bin: bins)\n            chunkList.addAll(binToChunks.get(bin));\n\n        if (chunkList.isEmpty()) {\n            return null;\n        }\n\n        final int start = (startPos <= 0) ? 0 : startPos-1;\n        final int regionLinearBin = start >> BAM_LIDX_SHIFT;\n        // System.out.println(\"# regionLinearBin: \" + regionLinearBin);\n        LinearIndex index = referenceToLinearIndices.get(referenceIndex);\n        long minimumOffset = 0;\n        if (regionLinearBin < index.indexEntries.length)\n            minimumOffset = index.indexEntries[regionLinearBin];\n        chunkList = optimizeChunkList(chunkList, minimumOffset);\n        return convertToArray(chunkList);\n    }","id":97969,"modified_method":"/**\n     * Get list of regions of BAM file that may contain SAMRecords for the given range\n     * @param referenceIndex sequence of desired SAMRecords\n     * @param startPos 1-based start of the desired interval, inclusive\n     * @param endPos 1-based end of the desired interval, inclusive\n     * @return array of pairs of virtual file positions.  Each pair is the first and last\n     * virtual file position in a range that can be scanned to find SAMRecords that overlap the given\n     * positions. The last position in each pair is a virtual file pointer to the first SAMRecord beyond\n     * the range that may contain the indicated SAMRecords.\n     */\n    long[] getFilePointersContaining(final int referenceIndex, final int startPos, final int endPos) {\n        List<Bin> bins = getBinsContaining(referenceIndex,startPos,endPos);\n        // System.out.println(\"# Sequence target TID: \" + referenceIndex);\n        if (bins == null) {\n            return null;\n        }\n\n        List<Chunk> chunkList = new ArrayList<Chunk>();\n        for(Bin bin: bins)\n            chunkList.addAll(binToChunks.get(bin));\n\n        if (chunkList.isEmpty()) {\n            return null;\n        }\n\n        final int start = (startPos <= 0) ? 0 : startPos-1;\n        final int regionLinearBin = start >> BAM_LIDX_SHIFT;\n        // System.out.println(\"# regionLinearBin: \" + regionLinearBin);\n        LinearIndex index = referenceToLinearIndices.get(referenceIndex);\n        long minimumOffset = 0;\n        if (regionLinearBin < index.indexEntries.length)\n            minimumOffset = index.indexEntries[regionLinearBin];\n        chunkList = optimizeChunkList(chunkList, minimumOffset);\n        return convertToArray(chunkList);\n    }","commit_id":"77af5822d47cd26b68593002b7118f02705fdde2","url":"https://github.com/broadgsa/gatk"},{"original_method":"SAMRecord getNextRecord()\n            throws IOException {\n            while (true) {\n                // Advance to next file block if necessary\n                while (mCompressedInputStream.getFilePointer() > mFilePointerLimit) {\n                    if (mFilePointers == null ||\n                        mFilePointerIndex >= mFilePointers.length) {\n                        return null;\n                    }\n                    final long startOffset = mFilePointers[mFilePointerIndex++];\n                    final long endOffset = mFilePointers[mFilePointerIndex++];\n                    mCompressedInputStream.seek(startOffset);\n                    mFilePointerLimit = endOffset;\n                }\n                // Pull next record from stream\n                return super.getNextRecord();\n            }\n        }","id":97970,"modified_method":"SAMRecord getNextRecord()\n            throws IOException {\n            while (true) {\n                // Advance to next file block if necessary\n                while (mCompressedInputStream.getFilePointer() >= mFilePointerLimit) {\n                    if (mFilePointers == null ||\n                        mFilePointerIndex >= mFilePointers.length) {\n                        return null;\n                    }\n                    final long startOffset = mFilePointers[mFilePointerIndex++];\n                    final long endOffset = mFilePointers[mFilePointerIndex++];\n                    mCompressedInputStream.seek(startOffset);\n                    mFilePointerLimit = endOffset;\n                }\n                // Pull next record from stream\n                return super.getNextRecord();\n            }\n        }","commit_id":"77af5822d47cd26b68593002b7118f02705fdde2","url":"https://github.com/broadgsa/gatk"},{"original_method":"public List<Chunk> getFilePointersBounding(Bin bin) {\n        return Chunk.toChunkList(getFileIndex().getFilePointersBounding(bin));\n    }","id":97971,"modified_method":"public List<Chunk> getFilePointersBounding(final String sequence, final int start, final int end) {\n        final SAMFileHeader fileHeader = getFileHeader();\n        long[] filePointers = null;\n        int referenceIndex = fileHeader.getSequenceIndex(sequence);\n        if (referenceIndex != -1) {\n            final BAMFileIndex2 fileIndex = getFileIndex();\n            filePointers = fileIndex.getFilePointersContaining(referenceIndex,start,end);\n        }\n        return (filePointers != null) ? Chunk.toChunkList(filePointers) : Collections.<Chunk>emptyList();\n    }","commit_id":"77af5822d47cd26b68593002b7118f02705fdde2","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Gets the file pointers bounded by this bin, grouped by the reader of origination.\n     * @param bin The bin for which to load data.\n     * @return A map of the file pointers bounding the bin.\n     */\n    public Map<SAMFileReader2,List<Chunk>> getFilePointersBounding(final Bin bin) {\n        Map<SAMFileReader2,List<Chunk>> filePointers = new HashMap<SAMFileReader2,List<Chunk>>();\n        for(SAMFileReader reader: headerMerger.getReaders()) {\n            SAMFileReader2 reader2 = (SAMFileReader2)reader;\n            filePointers.put(reader2,reader2.getFilePointersBounding(bin));\n        }\n        return filePointers;\n    }","id":97972,"modified_method":"/**\n     * Gets the file pointers bounded by this bin, grouped by the reader of origination.\n     * @param locus The loci for which to load data.\n     * @return A map of the file pointers bounding the bin.\n     */\n    public Map<SAMFileReader2,List<Chunk>> getFilePointersBounding(GenomeLoc locus) {\n        Map<SAMFileReader2,List<Chunk>> filePointers = new HashMap<SAMFileReader2,List<Chunk>>();\n        for(SAMFileReader reader: headerMerger.getReaders()) {\n            SAMFileReader2 reader2 = (SAMFileReader2)reader;\n            filePointers.put(reader2,reader2.getFilePointersBounding(locus.getContig(),(int)locus.getStart(),(int)locus.getStop()));\n        }\n        return filePointers;\n    }","commit_id":"77af5822d47cd26b68593002b7118f02705fdde2","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * construct the shard strategy from a seq dictionary, a shard size, and and genomeLocs\n     * @param dataSource Data source from which to load index data.\n     * @param locations List of locations for which to load data.\n     */\n    IndexDelimitedLocusShardStrategy(SAMDataSource dataSource, GenomeLocSortedSet locations) {\n        if(!(dataSource instanceof BlockDrivenSAMDataSource))\n            throw new StingException(\"Cannot power an IndexDelimitedLocusShardStrategy with this data source.\");\n\n        blockDrivenDataSource = (BlockDrivenSAMDataSource)dataSource;\n        final int deepestBinLevel = blockDrivenDataSource.getNumIndexLevels()-1;\n\n        // Create a list of contig name -> genome loc, sorted in INSERTION ORDER.\n        LinkedHashMap<String,List<GenomeLoc>> locationToReference = new LinkedHashMap<String,List<GenomeLoc>>();\n        for(GenomeLoc location: locations) {\n            if(!locationToReference.containsKey(location.getContig()))\n                locationToReference.put(location.getContig(),new ArrayList<GenomeLoc>());\n            locationToReference.get(location.getContig()).add(location);\n        }\n\n        // Group the loci by bin, sorted in the order in which bins appear in the file.  Only use the smallest bins in the set.\n        for(String contig: locationToReference.keySet()) {\n            SortedMap<Bin,List<GenomeLoc>> bins = new TreeMap<Bin,List<GenomeLoc>>();\n            for(GenomeLoc location: locationToReference.get(contig)) {\n                List<Bin> binsForLocation = blockDrivenDataSource.getOverlappingBins(location);\n                for(Bin bin: binsForLocation) {\n                    if(blockDrivenDataSource.getLevelForBin(bin) == deepestBinLevel) {\n                        if(!bins.containsKey(bin))\n                            bins.put(bin,new ArrayList<GenomeLoc>());\n                        bins.get(bin).add(location);\n                    }\n                }\n            }\n            for(SortedMap.Entry<Bin,List<GenomeLoc>> entry: bins.entrySet())\n                filePointers.add(new FilePointer(entry.getKey(),entry.getValue()));\n        }\n\n        filePointerIterator = filePointers.iterator();\n    }","id":97973,"modified_method":"/**\n     * construct the shard strategy from a seq dictionary, a shard size, and and genomeLocs\n     * @param dataSource Data source from which to load index data.\n     * @param locations List of locations for which to load data.\n     */\n    IndexDelimitedLocusShardStrategy(SAMDataSource dataSource, GenomeLocSortedSet locations) {\n        if(!(dataSource instanceof BlockDrivenSAMDataSource))\n            throw new StingException(\"Cannot power an IndexDelimitedLocusShardStrategy with this data source.\");\n\n        blockDrivenDataSource = (BlockDrivenSAMDataSource)dataSource;\n        final int deepestBinLevel = blockDrivenDataSource.getNumIndexLevels()-1;\n\n        // Create a list of contig name -> genome loc, sorted in INSERTION ORDER.\n        LinkedHashMap<String,List<GenomeLoc>> locationToReference = new LinkedHashMap<String,List<GenomeLoc>>();\n        for(GenomeLoc location: locations) {\n            if(!locationToReference.containsKey(location.getContig()))\n                locationToReference.put(location.getContig(),new ArrayList<GenomeLoc>());\n            locationToReference.get(location.getContig()).add(location);\n        }\n\n        for(String contig: locationToReference.keySet()) {\n            // Gather bins for the given loci, splitting loci as necessary so that each falls into exactly one lowest-level bin.\n            SortedMap<Bin,List<GenomeLoc>> bins = new TreeMap<Bin,List<GenomeLoc>>();\n            for(GenomeLoc location: locationToReference.get(contig)) {\n                List<Bin> binsForLocation = blockDrivenDataSource.getOverlappingBins(location);\n                for(Bin bin: binsForLocation) {\n                    if(blockDrivenDataSource.getLevelForBin(bin) == deepestBinLevel) {\n                        final int firstLoc = blockDrivenDataSource.getFirstLocusInBin(bin);\n                        final int lastLoc = blockDrivenDataSource.getLastLocusInBin(bin);\n                        if(!bins.containsKey(bin))\n                            bins.put(bin,new ArrayList<GenomeLoc>());\n                        bins.get(bin).add(GenomeLocParser.createGenomeLoc(location.getContig(),\n                                                                          Math.max(location.getStart(),firstLoc),\n                                                                          Math.min(location.getStop(),lastLoc)));\n                    }\n                }\n            }\n\n            // Add a record of the new bin structure.\n            for(SortedMap.Entry<Bin,List<GenomeLoc>> entry: bins.entrySet()) {\n                Collections.sort(entry.getValue());                \n                filePointers.add(new FilePointer(entry.getKey(),entry.getValue()));\n            }\n        }\n\n        filePointerIterator = filePointers.iterator();\n    }","commit_id":"77af5822d47cd26b68593002b7118f02705fdde2","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * gets the next Shard\n     *\n     * @return the next shard\n     */\n    public IndexDelimitedLocusShard next() {\n        FilePointer nextFilePointer = filePointerIterator.next();\n        Map<SAMFileReader2,List<Chunk>> chunksBounding = blockDrivenDataSource.getFilePointersBounding(nextFilePointer.bin);\n        return new IndexDelimitedLocusShard(nextFilePointer.locations,chunksBounding,Shard.ShardType.LOCUS_INTERVAL);\n    }","id":97974,"modified_method":"/**\n     * gets the next Shard\n     *\n     * @return the next shard\n     */\n    public IndexDelimitedLocusShard next() {\n        FilePointer nextFilePointer = filePointerIterator.next();\n        String contig = null;\n        long start = Long.MAX_VALUE, stop = 0;\n        for(GenomeLoc loc: nextFilePointer.locations) {\n            contig = loc.getContig();\n            start = Math.min(loc.getStart(),start);\n            stop = Math.max(loc.getStop(),stop);\n        }\n        Map<SAMFileReader2,List<Chunk>> chunksBounding = blockDrivenDataSource.getFilePointersBounding(GenomeLocParser.createGenomeLoc(contig,start,stop));\n        return new IndexDelimitedLocusShard(nextFilePointer.locations,chunksBounding,Shard.ShardType.LOCUS_INTERVAL);\n    }","commit_id":"77af5822d47cd26b68593002b7118f02705fdde2","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Gets the level associated with the given bin number.\n     * @param bin The bin for which to determine the level.\n     * @return the level associated with the given bin number.\n     */\n    public int getLevelForBin(final Bin bin) {\n        BAMFileIndex2 fileIndex = (BAMFileIndex2)JVMUtils.getFieldValue(getField(\"mFileIndex\"),this);\n        if(fileIndex == null)\n            throw new SAMException(\"Unable to determine number of index levels; BAM file index is not present.\");\n        return fileIndex.getLevelForBinNumber(bin.binNumber);\n    }","id":97975,"modified_method":"/**\n     * Gets the level associated with the given bin number.\n     * @param bin The bin for which to determine the level.\n     * @return the level associated with the given bin number.\n     */\n    public int getLevelForBin(final Bin bin) {\n        final BAMFileIndex2 fileIndex = (BAMFileIndex2)JVMUtils.getFieldValue(getField(\"mFileIndex\"),this);\n        if(fileIndex == null)\n            throw new SAMException(\"Unable to determine number of index levels; BAM file index is not present.\");\n        return fileIndex.getLevelForBinNumber(bin.binNumber);\n    }","commit_id":"77af5822d47cd26b68593002b7118f02705fdde2","url":"https://github.com/broadgsa/gatk"},{"original_method":"private File findIndexFileFromParent(File bamFile) {\n        try {\n            Method method = getClass().getSuperclass().getDeclaredMethod(\"findIndexFile\",File.class);\n            method.setAccessible(true);\n            return (File)method.invoke(this,bamFile);\n        }\n        catch(IllegalAccessException ex) {\n            throw new StingException(\"Unable to run method findIndexFile\",ex);\n        }\n        catch(InvocationTargetException ex) {\n            throw new StingException(\"Unable to run method findIndexFile\",ex);\n        }\n        catch(NoSuchMethodException ex) {\n            throw new StingException(\"Unable to run method findIndexFile\",ex);\n        }\n\n    }","id":97976,"modified_method":"public List<Chunk> getFilePointersBounding(final String sequence, final int start, final int end) {\n        // TODO: Add sanity checks so that we're not doing this against an unsupported BAM file.\n        BAMFileReader2 reader = (BAMFileReader2)JVMUtils.getFieldValue(getField(\"mReader\"),this);\n        return reader.getFilePointersBounding(sequence,start,end);\n    }","commit_id":"77af5822d47cd26b68593002b7118f02705fdde2","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Get the number of levels employed by this index.\n     * @return Number of levels in this index.\n     */\n    public int getNumIndexLevels() {\n        BAMFileIndex2 fileIndex = (BAMFileIndex2)JVMUtils.getFieldValue(getField(\"mFileIndex\"),this);\n        if(fileIndex == null)\n            throw new SAMException(\"Unable to determine number of index levels; BAM file index is not present.\");\n        return fileIndex.getNumIndexLevels();\n    }","id":97977,"modified_method":"/**\n     * Get the number of levels employed by this index.\n     * @return Number of levels in this index.\n     */\n    public int getNumIndexLevels() {\n        final BAMFileIndex2 fileIndex = (BAMFileIndex2)JVMUtils.getFieldValue(getField(\"mFileIndex\"),this);\n        if(fileIndex == null)\n            throw new SAMException(\"Unable to determine number of index levels; BAM file index is not present.\");\n        return fileIndex.getNumIndexLevels();\n    }","commit_id":"77af5822d47cd26b68593002b7118f02705fdde2","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static String getVirtualFileFqn(@NotNull VirtualFile virtualFile, @NotNull Project project) {\n    final LogicalRoot logicalRoot = LogicalRootsManager.getLogicalRootsManager(project).findLogicalRoot(virtualFile);\n    if (logicalRoot != null && logicalRoot.getVirtualFile() != null) {\n      return ObjectUtils.assertNotNull(VfsUtilCore.getRelativePath(virtualFile, logicalRoot.getVirtualFile(), '/'));\n    }\n\n    final VirtualFile contentRoot = ProjectRootManager.getInstance(project).getFileIndex().getContentRootForFile(virtualFile);\n    if (contentRoot != null) {\n      return ObjectUtils.assertNotNull(VfsUtilCore.getRelativePath(virtualFile, contentRoot, '/'));\n    }\n    return virtualFile.getPath();\n  }","id":97978,"modified_method":"private static String getVirtualFileFqn(@NotNull VirtualFile virtualFile, @NotNull Project project) {\n    final LogicalRoot logicalRoot = LogicalRootsManager.getLogicalRootsManager(project).findLogicalRoot(virtualFile);\n    VirtualFile logicalRootFile = logicalRoot != null ? logicalRoot.getVirtualFile() : null; \n    if (logicalRootFile != null && !virtualFile.equals(logicalRootFile)) {\n      return ObjectUtils.assertNotNull(VfsUtilCore.getRelativePath(virtualFile, logicalRootFile, '/'));\n    }\n\n    VirtualFile outerMostRoot = null;\n    VirtualFile each = virtualFile;\n    ProjectFileIndex index = ProjectRootManager.getInstance(project).getFileIndex();\n    while (each != null && (each = index.getContentRootForFile(each)) != null) {\n      outerMostRoot = each;\n      each = each.getParent();\n    }\n\n    if (outerMostRoot != null && !outerMostRoot.equals(virtualFile)) {\n      return ObjectUtils.assertNotNull(VfsUtilCore.getRelativePath(virtualFile, outerMostRoot, '/'));\n    }\n\n    return virtualFile.getPath();\n  }","commit_id":"f226b597e4154d4f53e88d3475cb9fabeb440866","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private AsteriskOriginator buildOriginator(List<Argument> arguments) throws AsteriskOriginatorException {\n        AsteriskOriginator ao = new AsteriskOriginator();\n        for (Argument arg : arguments) {\n            if (NotificationManager.PARAM_WORK_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_WORK_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_HOME_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_HOME_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_MOBILE_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_MOBILE_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_SUBJECT.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_SUBJECT => \" + arg.getValue());\n                ao.setSubject(arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NOTIFY_SUBJECT, arg.getValue());\n            } else if (NotificationManager.PARAM_TEXT_MSG.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_TEXT_MSG => \" + arg.getValue());\n                ao.setMessageText(arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NOTIFY_BODY, arg.getValue());\n            } else if (NotificationManager.PARAM_TUI_PIN.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_TUI_PIN => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_USER_PIN, arg.getValue());\n            } else if (NotificationManager.PARAM_DESTINATION.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_DESTINATION => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_USERNAME, arg.getValue());\n            } else if (NotificationManager.PARAM_NODE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_NODE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODEID, arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODELABEL, Notifd.getInstance().getNodeDao().get(arg.getValue()).getLabel());\n            } else if (NotificationManager.PARAM_INTERFACE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_INTERFACE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_INTERFACE, arg.getValue());\n            } else if (NotificationManager.PARAM_SERVICE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_SERVICE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_SERVICE, arg.getValue());\n            } else {\n                log().debug(\"Unconsumed arg: \" + String.valueOf(arg.getSwitch()) + \" => \" + String.valueOf(arg.getValue()));\n            }\n        }\n        return ao;\n    }","id":97979,"modified_method":"private AsteriskOriginator buildOriginator(List<Argument> arguments) throws AsteriskOriginatorException {\n        AsteriskOriginator ao = new AsteriskOriginator();\n        for (Argument arg : arguments) {\n            if (NotificationManager.PARAM_WORK_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_WORK_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_HOME_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_HOME_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_MOBILE_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_MOBILE_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_SUBJECT.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_SUBJECT => \" + arg.getValue());\n                ao.setSubject(arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NOTIFY_SUBJECT, arg.getValue());\n            } else if (NotificationManager.PARAM_TEXT_MSG.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_TEXT_MSG => \" + arg.getValue());\n                ao.setMessageText(arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NOTIFY_BODY, arg.getValue());\n            } else if (NotificationManager.PARAM_TUI_PIN.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_TUI_PIN => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_USER_PIN, arg.getValue());\n            } else if (NotificationManager.PARAM_DESTINATION.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_DESTINATION => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_USERNAME, arg.getValue());\n            } else if (NotificationManager.PARAM_NODE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_NODE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODEID, arg.getValue());\n                try {\n                    ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODELABEL, Notifd.getInstance().getNodeDao().get(arg.getValue()).getLabel());\n                } catch (Exception e) {\n                    ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODELABEL, null);\n                }\n            } else if (NotificationManager.PARAM_INTERFACE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_INTERFACE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_INTERFACE, arg.getValue());\n            } else if (NotificationManager.PARAM_SERVICE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_SERVICE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_SERVICE, arg.getValue());\n            } else {\n                log().debug(\"Unconsumed arg: \" + String.valueOf(arg.getSwitch()) + \" => \" + String.valueOf(arg.getValue()));\n            }\n        }\n        return ao;\n    }","commit_id":"58595ca65eade688ade15c2a9783bc396c2e9ece","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void sayNode() throws AgiException {\n        String nodeID = null;\n        String nodeLabel = null;\n        nodeID = getVariable(VAR_OPENNMS_NODEID);\n        nodeLabel = getVariable(VAR_OPENNMS_NODELABEL);\n        \n        \n        if (! \"\".equals(nodeLabel)) {\n            log().debug(\"Reading node label to user: \" + nodeLabel);\n            streamFileInterruptible(\"node\");\n            sayAlphaInterruptible(nodeLabel);\n        } else if (!\"\".equals(nodeID)) {\n            log().debug(\"Reading node ID to user: \" + nodeID);\n            streamFileInterruptible(\"node\");\n            streamFileInterruptible(\"number\");\n            sayDigitsInterruptible(nodeID);\n        } else {\n            log().debug(\"No node label or node ID available\");\n        }\n    }","id":97980,"modified_method":"public void sayNode() throws AgiException {\n        String nodeID = null;\n        String nodeLabel = null;\n        nodeID = getVariable(VAR_OPENNMS_NODEID);\n        nodeLabel = getVariable(VAR_OPENNMS_NODELABEL);\n        \n        \n        if (! \"\".equals(nodeLabel)) {\n            log().debug(\"Reading node label to user: \" + nodeLabel);\n            streamFileInterruptible(\"node\");\n            try {\n                streamFileInterruptible(nodeLabel.toLowerCase());\n            } catch (AgiException e) {\n                sayAlphaInterruptible(nodeLabel);\n            }\n        } else if (!\"\".equals(nodeID)) {\n            log().debug(\"Reading node ID to user: \" + nodeID);\n            streamFileInterruptible(\"node\");\n            streamFileInterruptible(\"number\");\n            sayDigitsInterruptible(nodeID);\n        } else {\n            log().debug(\"No node label or node ID available\");\n        }\n    }","commit_id":"58595ca65eade688ade15c2a9783bc396c2e9ece","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void sayServiceName() throws AgiException {\n        String svcName = null;\n        svcName = getVariable(\"OPENNMS_SERVICE\");\n        \n        if ((svcName != null) && (!\"\".equals(svcName))) {\n            log().debug(\"Reading service name to user: \" + svcName);\n            streamFile(\"service\");\n            sayAlpha(svcName);\n        } else {\n            log().debug(\"No service name available\");\n        }\n    }","id":97981,"modified_method":"public void sayServiceName() throws AgiException {\n        String svcName = null;\n        svcName = getVariable(\"OPENNMS_SERVICE\");\n        \n        if ((svcName != null) && (!\"\".equals(svcName))) {\n            log().debug(\"Reading service name to user: \" + svcName);\n            streamFileInterruptible(\"service\");\n            try {\n                streamFileInterruptible(svcName.toLowerCase());\n            } catch (AgiException e) {\n                sayAlphaInterruptible(svcName);\n            }\n        } else {\n            log().debug(\"No service name available\");\n        }\n    }","commit_id":"58595ca65eade688ade15c2a9783bc396c2e9ece","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void sayIpAddr() throws AgiException {\n        String ipAddr = null;\n        ipAddr = getVariable(VAR_OPENNMS_INTERFACE);\n        \n        if ((ipAddr != null) && (!\"\".equals(ipAddr))) {\n            log().debug(\"Reading IP address to user: \" + ipAddr);\n            streamFile(\"letters/i\");\n            streamFile(\"letters/p\");\n            streamFile(\"address\");\n            sayIpAddressInterruptible(ipAddr);\n        }\n    }","id":97982,"modified_method":"public void sayIpAddr() throws AgiException {\n        String ipAddr = null;\n        ipAddr = getVariable(VAR_OPENNMS_INTERFACE);\n        \n        if ((ipAddr != null) && (!\"\".equals(ipAddr))) {\n            log().debug(\"Reading IP address to user: \" + ipAddr);\n            streamFileInterruptible(\"letters/i\");\n            streamFileInterruptible(\"letters/p\");\n            streamFileInterruptible(\"address\");\n            sayIpAddressInterruptible(ipAddr);\n        }\n    }","commit_id":"58595ca65eade688ade15c2a9783bc396c2e9ece","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private AsteriskOriginator buildOriginator(List<Argument> arguments) throws AsteriskOriginatorException {\n        AsteriskOriginator ao = new AsteriskOriginator();\n        for (Argument arg : arguments) {\n            if (NotificationManager.PARAM_WORK_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_WORK_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_HOME_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_HOME_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_MOBILE_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_MOBILE_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_SUBJECT.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_SUBJECT => \" + arg.getValue());\n                ao.setSubject(arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NOTIFY_SUBJECT, arg.getValue());\n            } else if (NotificationManager.PARAM_TEXT_MSG.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_TEXT_MSG => \" + arg.getValue());\n                ao.setMessageText(arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NOTIFY_BODY, arg.getValue());\n            } else if (NotificationManager.PARAM_TUI_PIN.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_TUI_PIN => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_USER_PIN, arg.getValue());\n            } else if (NotificationManager.PARAM_DESTINATION.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_DESTINATION => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_USERNAME, arg.getValue());\n            } else if (NotificationManager.PARAM_NODE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_NODE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODEID, arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODELABEL, Notifd.getInstance().getNodeDao().get(arg.getValue()).getLabel());\n            } else if (NotificationManager.PARAM_INTERFACE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_INTERFACE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_INTERFACE, arg.getValue());\n            } else if (NotificationManager.PARAM_SERVICE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_SERVICE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_SERVICE, arg.getValue());\n            } else {\n                log().debug(\"Unconsumed arg: \" + String.valueOf(arg.getSwitch()) + \" => \" + String.valueOf(arg.getValue()));\n            }\n        }\n        return ao;\n    }","id":97983,"modified_method":"private AsteriskOriginator buildOriginator(List<Argument> arguments) throws AsteriskOriginatorException {\n        AsteriskOriginator ao = new AsteriskOriginator();\n        for (Argument arg : arguments) {\n            if (NotificationManager.PARAM_WORK_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_WORK_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_HOME_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_HOME_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_MOBILE_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_MOBILE_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_SUBJECT.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_SUBJECT => \" + arg.getValue());\n                ao.setSubject(arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NOTIFY_SUBJECT, arg.getValue());\n            } else if (NotificationManager.PARAM_TEXT_MSG.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_TEXT_MSG => \" + arg.getValue());\n                ao.setMessageText(arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NOTIFY_BODY, arg.getValue());\n            } else if (NotificationManager.PARAM_TUI_PIN.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_TUI_PIN => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_USER_PIN, arg.getValue());\n            } else if (NotificationManager.PARAM_DESTINATION.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_DESTINATION => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_USERNAME, arg.getValue());\n            } else if (NotificationManager.PARAM_NODE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_NODE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODEID, arg.getValue());\n                try {\n                    ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODELABEL, Notifd.getInstance().getNodeDao().get(arg.getValue()).getLabel());\n                } catch (Exception e) {\n                    ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODELABEL, null);\n                }\n            } else if (NotificationManager.PARAM_INTERFACE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_INTERFACE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_INTERFACE, arg.getValue());\n            } else if (NotificationManager.PARAM_SERVICE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_SERVICE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_SERVICE, arg.getValue());\n            } else {\n                log().debug(\"Unconsumed arg: \" + String.valueOf(arg.getSwitch()) + \" => \" + String.valueOf(arg.getValue()));\n            }\n        }\n        return ao;\n    }","commit_id":"2af9bb7ec85ef985a54608a9f0629f5c7cbf8f2e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void sayNode() throws AgiException {\n        String nodeID = null;\n        String nodeLabel = null;\n        nodeID = getVariable(VAR_OPENNMS_NODEID);\n        nodeLabel = getVariable(VAR_OPENNMS_NODELABEL);\n        \n        \n        if (! \"\".equals(nodeLabel)) {\n            log().debug(\"Reading node label to user: \" + nodeLabel);\n            streamFileInterruptible(\"node\");\n            sayAlphaInterruptible(nodeLabel);\n        } else if (!\"\".equals(nodeID)) {\n            log().debug(\"Reading node ID to user: \" + nodeID);\n            streamFileInterruptible(\"node\");\n            streamFileInterruptible(\"number\");\n            sayDigitsInterruptible(nodeID);\n        } else {\n            log().debug(\"No node label or node ID available\");\n        }\n    }","id":97984,"modified_method":"public void sayNode() throws AgiException {\n        String nodeID = null;\n        String nodeLabel = null;\n        nodeID = getVariable(VAR_OPENNMS_NODEID);\n        nodeLabel = getVariable(VAR_OPENNMS_NODELABEL);\n        \n        \n        if (! \"\".equals(nodeLabel)) {\n            log().debug(\"Reading node label to user: \" + nodeLabel);\n            streamFileInterruptible(\"node\");\n            try {\n                streamFileInterruptible(nodeLabel.toLowerCase());\n            } catch (AgiException e) {\n                sayAlphaInterruptible(nodeLabel);\n            }\n        } else if (!\"\".equals(nodeID)) {\n            log().debug(\"Reading node ID to user: \" + nodeID);\n            streamFileInterruptible(\"node\");\n            streamFileInterruptible(\"number\");\n            sayDigitsInterruptible(nodeID);\n        } else {\n            log().debug(\"No node label or node ID available\");\n        }\n    }","commit_id":"2af9bb7ec85ef985a54608a9f0629f5c7cbf8f2e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void sayServiceName() throws AgiException {\n        String svcName = null;\n        svcName = getVariable(\"OPENNMS_SERVICE\");\n        \n        if ((svcName != null) && (!\"\".equals(svcName))) {\n            log().debug(\"Reading service name to user: \" + svcName);\n            streamFile(\"service\");\n            sayAlpha(svcName);\n        } else {\n            log().debug(\"No service name available\");\n        }\n    }","id":97985,"modified_method":"public void sayServiceName() throws AgiException {\n        String svcName = null;\n        svcName = getVariable(\"OPENNMS_SERVICE\");\n        \n        if ((svcName != null) && (!\"\".equals(svcName))) {\n            log().debug(\"Reading service name to user: \" + svcName);\n            streamFileInterruptible(\"service\");\n            try {\n                streamFileInterruptible(svcName.toLowerCase());\n            } catch (AgiException e) {\n                sayAlphaInterruptible(svcName);\n            }\n        } else {\n            log().debug(\"No service name available\");\n        }\n    }","commit_id":"2af9bb7ec85ef985a54608a9f0629f5c7cbf8f2e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void sayIpAddr() throws AgiException {\n        String ipAddr = null;\n        ipAddr = getVariable(VAR_OPENNMS_INTERFACE);\n        \n        if ((ipAddr != null) && (!\"\".equals(ipAddr))) {\n            log().debug(\"Reading IP address to user: \" + ipAddr);\n            streamFile(\"letters/i\");\n            streamFile(\"letters/p\");\n            streamFile(\"address\");\n            sayIpAddressInterruptible(ipAddr);\n        }\n    }","id":97986,"modified_method":"public void sayIpAddr() throws AgiException {\n        String ipAddr = null;\n        ipAddr = getVariable(VAR_OPENNMS_INTERFACE);\n        \n        if ((ipAddr != null) && (!\"\".equals(ipAddr))) {\n            log().debug(\"Reading IP address to user: \" + ipAddr);\n            streamFileInterruptible(\"letters/i\");\n            streamFileInterruptible(\"letters/p\");\n            streamFileInterruptible(\"address\");\n            sayIpAddressInterruptible(ipAddr);\n        }\n    }","commit_id":"2af9bb7ec85ef985a54608a9f0629f5c7cbf8f2e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private AsteriskOriginator buildOriginator(List<Argument> arguments) throws AsteriskOriginatorException {\n        AsteriskOriginator ao = new AsteriskOriginator();\n        for (Argument arg : arguments) {\n            if (NotificationManager.PARAM_WORK_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_WORK_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_HOME_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_HOME_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_MOBILE_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_MOBILE_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_SUBJECT.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_SUBJECT => \" + arg.getValue());\n                ao.setSubject(arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NOTIFY_SUBJECT, arg.getValue());\n            } else if (NotificationManager.PARAM_TEXT_MSG.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_TEXT_MSG => \" + arg.getValue());\n                ao.setMessageText(arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NOTIFY_BODY, arg.getValue());\n            } else if (NotificationManager.PARAM_TUI_PIN.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_TUI_PIN => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_USER_PIN, arg.getValue());\n            } else if (NotificationManager.PARAM_DESTINATION.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_DESTINATION => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_USERNAME, arg.getValue());\n            } else if (NotificationManager.PARAM_NODE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_NODE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODEID, arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODELABEL, Notifd.getInstance().getNodeDao().get(arg.getValue()).getLabel());\n            } else if (NotificationManager.PARAM_INTERFACE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_INTERFACE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_INTERFACE, arg.getValue());\n            } else if (NotificationManager.PARAM_SERVICE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_SERVICE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_SERVICE, arg.getValue());\n            } else {\n                log().debug(\"Unconsumed arg: \" + String.valueOf(arg.getSwitch()) + \" => \" + String.valueOf(arg.getValue()));\n            }\n        }\n        return ao;\n    }","id":97987,"modified_method":"private AsteriskOriginator buildOriginator(List<Argument> arguments) throws AsteriskOriginatorException {\n        AsteriskOriginator ao = new AsteriskOriginator();\n        for (Argument arg : arguments) {\n            if (NotificationManager.PARAM_WORK_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_WORK_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_HOME_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_HOME_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_MOBILE_PHONE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_MOBILE_PHONE => \" + arg.getValue());\n                ao.setLegAExtension(arg.getValue());\n            } else if (NotificationManager.PARAM_SUBJECT.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_SUBJECT => \" + arg.getValue());\n                ao.setSubject(arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NOTIFY_SUBJECT, arg.getValue());\n            } else if (NotificationManager.PARAM_TEXT_MSG.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_TEXT_MSG => \" + arg.getValue());\n                ao.setMessageText(arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NOTIFY_BODY, arg.getValue());\n            } else if (NotificationManager.PARAM_TUI_PIN.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_TUI_PIN => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_USER_PIN, arg.getValue());\n            } else if (NotificationManager.PARAM_DESTINATION.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_DESTINATION => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_USERNAME, arg.getValue());\n            } else if (NotificationManager.PARAM_NODE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_NODE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODEID, arg.getValue());\n                try {\n                    ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODELABEL, Notifd.getInstance().getNodeDao().get(arg.getValue()).getLabel());\n                } catch (Exception e) {\n                    ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_NODELABEL, null);\n                }\n            } else if (NotificationManager.PARAM_INTERFACE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_INTERFACE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_INTERFACE, arg.getValue());\n            } else if (NotificationManager.PARAM_SERVICE.equals(arg.getSwitch())) {\n                log().debug(\"Found: PARAM_SERVICE => \" + arg.getValue());\n                ao.setChannelVariable(BaseOnmsAgiScript.VAR_OPENNMS_SERVICE, arg.getValue());\n            } else {\n                log().debug(\"Unconsumed arg: \" + String.valueOf(arg.getSwitch()) + \" => \" + String.valueOf(arg.getValue()));\n            }\n        }\n        return ao;\n    }","commit_id":"8f3ee75d5e9c2568005d094b748c56fb7a6bdd42","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void sayIpAddr() throws AgiException {\n        String ipAddr = null;\n        ipAddr = getVariable(VAR_OPENNMS_INTERFACE);\n        \n        if ((ipAddr != null) && (!\"\".equals(ipAddr))) {\n            log().debug(\"Reading IP address to user: \" + ipAddr);\n            streamFile(\"letters/i\");\n            streamFile(\"letters/p\");\n            streamFile(\"address\");\n            sayIpAddressInterruptible(ipAddr);\n        }\n    }","id":97988,"modified_method":"public void sayIpAddr() throws AgiException {\n        String ipAddr = null;\n        ipAddr = getVariable(VAR_OPENNMS_INTERFACE);\n        \n        if ((ipAddr != null) && (!\"\".equals(ipAddr))) {\n            log().debug(\"Reading IP address to user: \" + ipAddr);\n            streamFileInterruptible(\"letters/i\");\n            streamFileInterruptible(\"letters/p\");\n            streamFileInterruptible(\"address\");\n            sayIpAddressInterruptible(ipAddr);\n        }\n    }","commit_id":"8f3ee75d5e9c2568005d094b748c56fb7a6bdd42","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void sayServiceName() throws AgiException {\n        String svcName = null;\n        svcName = getVariable(\"OPENNMS_SERVICE\");\n        \n        if ((svcName != null) && (!\"\".equals(svcName))) {\n            log().debug(\"Reading service name to user: \" + svcName);\n            streamFile(\"service\");\n            sayAlpha(svcName);\n        } else {\n            log().debug(\"No service name available\");\n        }\n    }","id":97989,"modified_method":"public void sayServiceName() throws AgiException {\n        String svcName = null;\n        svcName = getVariable(\"OPENNMS_SERVICE\");\n        \n        if ((svcName != null) && (!\"\".equals(svcName))) {\n            log().debug(\"Reading service name to user: \" + svcName);\n            streamFileInterruptible(\"service\");\n            try {\n                streamFileInterruptible(svcName.toLowerCase());\n            } catch (AgiException e) {\n                sayAlphaInterruptible(svcName);\n            }\n        } else {\n            log().debug(\"No service name available\");\n        }\n    }","commit_id":"8f3ee75d5e9c2568005d094b748c56fb7a6bdd42","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void sayNode() throws AgiException {\n        String nodeID = null;\n        String nodeLabel = null;\n        nodeID = getVariable(VAR_OPENNMS_NODEID);\n        nodeLabel = getVariable(VAR_OPENNMS_NODELABEL);\n        \n        \n        if (! \"\".equals(nodeLabel)) {\n            log().debug(\"Reading node label to user: \" + nodeLabel);\n            streamFileInterruptible(\"node\");\n            sayAlphaInterruptible(nodeLabel);\n        } else if (!\"\".equals(nodeID)) {\n            log().debug(\"Reading node ID to user: \" + nodeID);\n            streamFileInterruptible(\"node\");\n            streamFileInterruptible(\"number\");\n            sayDigitsInterruptible(nodeID);\n        } else {\n            log().debug(\"No node label or node ID available\");\n        }\n    }","id":97990,"modified_method":"public void sayNode() throws AgiException {\n        String nodeID = null;\n        String nodeLabel = null;\n        nodeID = getVariable(VAR_OPENNMS_NODEID);\n        nodeLabel = getVariable(VAR_OPENNMS_NODELABEL);\n        \n        \n        if (! \"\".equals(nodeLabel)) {\n            log().debug(\"Reading node label to user: \" + nodeLabel);\n            streamFileInterruptible(\"node\");\n            try {\n                streamFileInterruptible(nodeLabel.toLowerCase());\n            } catch (AgiException e) {\n                sayAlphaInterruptible(nodeLabel);\n            }\n        } else if (!\"\".equals(nodeID)) {\n            log().debug(\"Reading node ID to user: \" + nodeID);\n            streamFileInterruptible(\"node\");\n            streamFileInterruptible(\"number\");\n            sayDigitsInterruptible(nodeID);\n        } else {\n            log().debug(\"No node label or node ID available\");\n        }\n    }","commit_id":"8f3ee75d5e9c2568005d094b748c56fb7a6bdd42","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void startJettyInternal() {\n        ProgressLoggerFactory progressLoggerFactory = getServices().get(ProgressLoggerFactory.class);\n        ProgressLogger progressLogger = progressLoggerFactory.newOperation(AbstractJettyRunTask.class);\n        progressLogger.setDescription(\"Start Jetty server\");\n        progressLogger.setShortDescription(\"Starting Jetty\");\n        progressLogger.started();\n        try {\n            setServer(createServer());\n\n            applyJettyXml();\n\n            JettyPluginServer plugin = getServer();\n\n            Object[] configuredConnectors = getConnectors();\n\n            plugin.setConnectors(configuredConnectors);\n            Object[] connectors = plugin.getConnectors();\n\n            if (connectors == null || connectors.length == 0) {\n                configuredConnectors = new Object[]{plugin.createDefaultConnector(getHttpPort())};\n                plugin.setConnectors(configuredConnectors);\n            }\n\n            //set up a RequestLog if one is provided\n            if (getRequestLog() != null) {\n                getServer().setRequestLog(getRequestLog());\n            }\n\n            //set up the webapp and any context provided\n            getServer().configureHandlers();\n            configureWebApplication();\n            getServer().addWebApplication(webAppConfig);\n\n            // set up security realms\n            Object[] configuredRealms = getUserRealms();\n            for (int i = 0; (configuredRealms != null) && i < configuredRealms.length; i++) {\n                logger.debug(configuredRealms[i].getClass().getName() + \": \" + configuredRealms[i].toString());\n            }\n\n            plugin.setUserRealms(configuredRealms);\n\n            //do any other configuration required by the\n            //particular Jetty version\n            finishConfigurationBeforeStart();\n\n            // start Jetty\n            server.start();\n\n            if (daemon) {\n                return;\n            }\n\n            if (getStopPort() != null && getStopPort() > 0 && getStopKey() != null) {\n                Monitor monitor = new Monitor(getStopPort(), getStopKey(), (Server) server.getProxiedObject());\n                monitor.start();\n            }\n\n            // start the scanner thread (if necessary) on the main webapp\n            configureScanner();\n            startScanner();\n\n            // start the new line scanner thread if necessary\n            startConsoleScanner();\n\n        } catch (Exception e) {\n            throw new GradleException(\"Could not start the Jetty server.\", e);\n        } finally {\n            progressLogger.completed();\n        }\n\n        progressLogger = progressLoggerFactory.newOperation(AbstractJettyRunTask.class);\n        progressLogger.setDescription(String.format(\"Run Jetty at http://localhost:%d/%s\", getHttpPort(), getContextPath()));\n        progressLogger.setShortDescription(String.format(\"Running at http://localhost:%d/%s\", getHttpPort(), getContextPath()));\n        progressLogger.started();\n        try {\n            // keep the thread going if not in daemon mode\n            server.join();\n        } catch (Exception e) {\n            throw new GradleException(\"Failed to wait for the Jetty server to stop.\", e);\n        } finally {\n            progressLogger.completed();\n        }\n    }","id":97991,"modified_method":"public void startJettyInternal() {\n        ProgressLoggerFactory progressLoggerFactory = getServices().get(ProgressLoggerFactory.class);\n        ProgressLogger progressLogger = progressLoggerFactory.newOperation(AbstractJettyRunTask.class)\n                .start(\"Start Jetty server\", \"Starting Jetty\");\n        try {\n            setServer(createServer());\n\n            applyJettyXml();\n\n            JettyPluginServer plugin = getServer();\n\n            Object[] configuredConnectors = getConnectors();\n\n            plugin.setConnectors(configuredConnectors);\n            Object[] connectors = plugin.getConnectors();\n\n            if (connectors == null || connectors.length == 0) {\n                configuredConnectors = new Object[]{plugin.createDefaultConnector(getHttpPort())};\n                plugin.setConnectors(configuredConnectors);\n            }\n\n            //set up a RequestLog if one is provided\n            if (getRequestLog() != null) {\n                getServer().setRequestLog(getRequestLog());\n            }\n\n            //set up the webapp and any context provided\n            getServer().configureHandlers();\n            configureWebApplication();\n            getServer().addWebApplication(webAppConfig);\n\n            // set up security realms\n            Object[] configuredRealms = getUserRealms();\n            for (int i = 0; (configuredRealms != null) && i < configuredRealms.length; i++) {\n                logger.debug(configuredRealms[i].getClass().getName() + \": \" + configuredRealms[i].toString());\n            }\n\n            plugin.setUserRealms(configuredRealms);\n\n            //do any other configuration required by the\n            //particular Jetty version\n            finishConfigurationBeforeStart();\n\n            // start Jetty\n            server.start();\n\n            if (daemon) {\n                return;\n            }\n\n            if (getStopPort() != null && getStopPort() > 0 && getStopKey() != null) {\n                Monitor monitor = new Monitor(getStopPort(), getStopKey(), (Server) server.getProxiedObject());\n                monitor.start();\n            }\n\n            // start the scanner thread (if necessary) on the main webapp\n            configureScanner();\n            startScanner();\n\n            // start the new line scanner thread if necessary\n            startConsoleScanner();\n\n        } catch (Exception e) {\n            throw new GradleException(\"Could not start the Jetty server.\", e);\n        } finally {\n            progressLogger.completed();\n        }\n\n        progressLogger = progressLoggerFactory.newOperation(AbstractJettyRunTask.class)\n                .start(String.format(\"Run Jetty at http://localhost:%d/%s\", getHttpPort(), getContextPath()),\n                        String.format(\"Running at http://localhost:%d/%s\", getHttpPort(), getContextPath()));\n        try {\n            // keep the thread going if not in daemon mode\n            server.join();\n        } catch (Exception e) {\n            throw new GradleException(\"Failed to wait for the Jetty server to stop.\", e);\n        } finally {\n            progressLogger.completed();\n        }\n    }","commit_id":"5c6806366e737d24ede7c88ac4e0fe24385e30a3","url":"https://github.com/gradle/gradle"},{"original_method":"public void beforeEvaluate(String projectPath) {\n        if (configurationProgress != null) {\n            ProgressLogger logger = progressLoggerFactory.newOperation(BuildProgressLogger.class);\n            logger.setDescription(\"Configuring project \" + projectPath);\n            logger.setShortDescription(projectPath.equals(\":\") ? \"root project\" : projectPath);\n            logger.started();\n            projectConfigurationProgress.put(projectPath, logger);\n        }\n    }","id":97992,"modified_method":"public void beforeEvaluate(String projectPath) {\n        if (configurationProgress != null) {\n            ProgressLogger logger = progressLoggerFactory.newOperation(BuildProgressLogger.class)\n                    .start(\"Configuring project \" + projectPath, projectPath.equals(\":\") ? \"root project\" : projectPath);\n            projectConfigurationProgress.put(projectPath, logger);\n        }\n    }","commit_id":"5c6806366e737d24ede7c88ac4e0fe24385e30a3","url":"https://github.com/gradle/gradle"},{"original_method":"public void graphPopulated(int totalTasks) {\n        configurationProgress.completed();\n        configurationProgress = null;\n\n        buildProgress.completed(\"Task graph ready\");\n\n        buildProgress = progressLoggerFactory.newOperation(BuildProgressLogger.class);\n        buildProgressFormatter = new PercentageProgressFormatter(\"Building\", totalTasks);\n        buildProgress.setDescription(\"Execute tasks\");\n        buildProgress.setShortDescription(buildProgressFormatter.getProgress());\n        buildProgress.started();\n    }","id":97993,"modified_method":"public void graphPopulated(int totalTasks) {\n        configurationProgress.completed();\n        configurationProgress = null;\n\n        buildProgress.completed(\"Task graph ready\");\n\n        buildProgressFormatter = new PercentageProgressFormatter(\"Building\", totalTasks);\n        buildProgress = progressLoggerFactory.newOperation(BuildProgressLogger.class)\n                .start(\"Execute tasks\", buildProgressFormatter.getProgress());\n    }","commit_id":"5c6806366e737d24ede7c88ac4e0fe24385e30a3","url":"https://github.com/gradle/gradle"},{"original_method":"public void buildStarted() {\n        buildProgress = progressLoggerFactory.newOperation(BuildProgressLogger.class);\n        buildProgress.setDescription(\"Initialize build\");\n        buildProgress.setShortDescription(\"Configuring\");\n        buildProgress.started();\n    }","id":97994,"modified_method":"public void buildStarted() {\n        buildProgress = progressLoggerFactory.newOperation(BuildProgressLogger.class)\n                .start(\"Initialize build\", \"Configuring\");\n    }","commit_id":"5c6806366e737d24ede7c88ac4e0fe24385e30a3","url":"https://github.com/gradle/gradle"},{"original_method":"public void projectsLoaded(int totalProjects) {\n        configurationProgressFormatter = new SimpleProgressFormatter(totalProjects, \"projects\");\n        configurationProgress = progressLoggerFactory.newOperation(BuildProgressLogger.class);\n        configurationProgress.setDescription(\"Configure projects\");\n        configurationProgress.setShortDescription(configurationProgressFormatter.getProgress());\n        configurationProgress.started();\n    }","id":97995,"modified_method":"public void projectsLoaded(int totalProjects) {\n        configurationProgressFormatter = new SimpleProgressFormatter(totalProjects, \"projects\");\n        configurationProgress = progressLoggerFactory.newOperation(BuildProgressLogger.class)\n                .start(\"Configure projects\", configurationProgressFormatter.getProgress());\n    }","commit_id":"5c6806366e737d24ede7c88ac4e0fe24385e30a3","url":"https://github.com/gradle/gradle"},{"original_method":"public void beforeResolve(ResolvableDependencies dependencies) {\n        LinkedList<ProgressLogger> loggers = progressLoggers.get();\n        progressLoggers.set(loggers);\n        ProgressLogger logger = loggerFactory.newOperation(DependencyResolutionLogger.class);\n        logger.setDescription(String.format(\"Resolve %s\", dependencies));\n        logger.setShortDescription(String.format(\"Resolving %s\", dependencies));\n        logger.started();\n        loggers.add(logger);\n    }","id":97996,"modified_method":"public void beforeResolve(ResolvableDependencies dependencies) {\n        LinkedList<ProgressLogger> loggers = progressLoggers.get();\n        progressLoggers.set(loggers);\n        ProgressLogger logger = loggerFactory.newOperation(DependencyResolutionLogger.class)\n                .start(String.format(\"Resolve %s\", dependencies), String.format(\"Resolving %s\", dependencies));\n        loggers.add(logger);\n    }","commit_id":"5c6806366e737d24ede7c88ac4e0fe24385e30a3","url":"https://github.com/gradle/gradle"},{"original_method":"@TaskAction\n    public void stop() {\n        if (getStopPort() == null) {\n            throw new InvalidUserDataException(\"Please specify a valid port\");\n        }\n        if (getStopKey() == null) {\n            throw new InvalidUserDataException(\"Please specify a valid stopKey\");\n        }\n\n        ProgressLogger progressLogger = getServices().get(ProgressLoggerFactory.class).newOperation(JettyStop.class);\n        progressLogger.setDescription(\"Stop Jetty server\");\n        progressLogger.setShortDescription(\"Stopping Jetty\");\n        progressLogger.started();\n        try {\n            Socket s = new Socket(InetAddress.getByName(\"127.0.0.1\"), getStopPort());\n            s.setSoLinger(false, 0);\n\n            OutputStream out = s.getOutputStream();\n            out.write((getStopKey() + \"\\r\\nstop\\r\\n\").getBytes());\n            out.flush();\n            s.close();\n        } catch (ConnectException e) {\n            logger.info(\"Jetty not running!\");\n        } catch (Exception e) {\n            logger.error(\"Exception during stopping\", e);\n        } finally {\n            progressLogger.completed();\n        }\n    }","id":97997,"modified_method":"@TaskAction\n    public void stop() {\n        if (getStopPort() == null) {\n            throw new InvalidUserDataException(\"Please specify a valid port\");\n        }\n        if (getStopKey() == null) {\n            throw new InvalidUserDataException(\"Please specify a valid stopKey\");\n        }\n\n        ProgressLogger progressLogger = getServices().get(ProgressLoggerFactory.class).newOperation(JettyStop.class)\n                .start(\"Stop Jetty server\", \"Stopping Jetty\");\n        try {\n            Socket s = new Socket(InetAddress.getByName(\"127.0.0.1\"), getStopPort());\n            s.setSoLinger(false, 0);\n\n            OutputStream out = s.getOutputStream();\n            out.write((getStopKey() + \"\\r\\nstop\\r\\n\").getBytes());\n            out.flush();\n            s.close();\n        } catch (ConnectException e) {\n            logger.info(\"Jetty not running!\");\n        } catch (Exception e) {\n            logger.error(\"Exception during stopping\", e);\n        } finally {\n            progressLogger.completed();\n        }\n    }","commit_id":"5c6806366e737d24ede7c88ac4e0fe24385e30a3","url":"https://github.com/gradle/gradle"},{"original_method":"private static Runnable createOverrideRunnable(final Editor editor, final PsiFile file, final Project project) {\n    return () -> {\n      PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n      final PsiAnonymousClass\n        aClass = PsiTreeUtil.findElementOfClassAtOffset(file, editor.getCaretModel().getOffset(), PsiAnonymousClass.class, false);\n      if (aClass == null) return;\n      CommandProcessor.getInstance().executeCommand(project, () -> {\n        final Collection<CandidateInfo> candidatesToImplement = OverrideImplementExploreUtil.getMethodsToOverrideImplement(aClass, true);\n        for (Iterator<CandidateInfo> iterator = candidatesToImplement.iterator(); iterator.hasNext(); ) {\n          final CandidateInfo candidate = iterator.next();\n          final PsiElement element = candidate.getElement();\n          if (element instanceof PsiMethod && ((PsiMethod)element).hasModifierProperty(PsiModifier.DEFAULT)) {\n            iterator.remove();\n          }\n        }\n        boolean invokeOverride = candidatesToImplement.isEmpty();\n        if (invokeOverride) {\n          OverrideImplementUtil.chooseAndOverrideOrImplementMethods(project, editor, aClass, false);\n        }\n        else {\n          ApplicationManager.getApplication().runWriteAction(() -> {\n            try {\n              List<PsiMethod> methods = OverrideImplementUtil.overrideOrImplementMethodCandidates(aClass, candidatesToImplement, false);\n              List<PsiGenerationInfo<PsiMethod>> prototypes = OverrideImplementUtil.convert2GenerationInfos(methods);\n              List<PsiGenerationInfo<PsiMethod>> resultMembers =\n                GenerateMembersUtil.insertMembersBeforeAnchor(aClass, null, prototypes);\n              resultMembers.get(0).positionCaret(editor, true);\n            }\n            catch (IncorrectOperationException ioe) {\n              LOG.error(ioe);\n            }\n          });\n        }\n      }, getCommandName(), getCommandName(), UndoConfirmationPolicy.DEFAULT, editor.getDocument());\n    };\n  }","id":97998,"modified_method":"private static Runnable createOverrideRunnable(final Editor editor, final PsiFile file, final Project project) {\n    return () -> {\n      TemplateManager.getInstance(project).finishTemplate(editor);\n\n      PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n      final PsiAnonymousClass\n        aClass = PsiTreeUtil.findElementOfClassAtOffset(file, editor.getCaretModel().getOffset(), PsiAnonymousClass.class, false);\n      if (aClass == null) return;\n      CommandProcessor.getInstance().executeCommand(project, () -> {\n        final Collection<CandidateInfo> candidatesToImplement = OverrideImplementExploreUtil.getMethodsToOverrideImplement(aClass, true);\n        for (Iterator<CandidateInfo> iterator = candidatesToImplement.iterator(); iterator.hasNext(); ) {\n          final CandidateInfo candidate = iterator.next();\n          final PsiElement element = candidate.getElement();\n          if (element instanceof PsiMethod && ((PsiMethod)element).hasModifierProperty(PsiModifier.DEFAULT)) {\n            iterator.remove();\n          }\n        }\n        boolean invokeOverride = candidatesToImplement.isEmpty();\n        if (invokeOverride) {\n          OverrideImplementUtil.chooseAndOverrideOrImplementMethods(project, editor, aClass, false);\n        }\n        else {\n          ApplicationManager.getApplication().runWriteAction(() -> {\n            try {\n              List<PsiMethod> methods = OverrideImplementUtil.overrideOrImplementMethodCandidates(aClass, candidatesToImplement, false);\n              List<PsiGenerationInfo<PsiMethod>> prototypes = OverrideImplementUtil.convert2GenerationInfos(methods);\n              List<PsiGenerationInfo<PsiMethod>> resultMembers =\n                GenerateMembersUtil.insertMembersBeforeAnchor(aClass, null, prototypes);\n              resultMembers.get(0).positionCaret(editor, true);\n            }\n            catch (IncorrectOperationException ioe) {\n              LOG.error(ioe);\n            }\n          });\n        }\n      }, getCommandName(), getCommandName(), UndoConfirmationPolicy.DEFAULT, editor.getDocument());\n    };\n  }","commit_id":"877358aea3bb24a8b7c862cf51555c31258ff16f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void handleInsert(InsertionContext context) {\n    final Document document = context.getDocument();\n    final PsiFile file = context.getFile();\n    final PsiMethod method = getObject();\n\n    final LookupElement[] allItems = context.getElements();\n    final boolean overloadsMatter = allItems.length == 1 && getUserData(JavaCompletionUtil.FORCE_SHOW_SIGNATURE_ATTR) == null;\n    final boolean hasParams = MethodParenthesesHandler.hasParams(this, allItems, overloadsMatter, method);\n    JavaCompletionUtil.insertParentheses(context, this, overloadsMatter, hasParams);\n\n    final int startOffset = context.getStartOffset();\n    final OffsetKey refStart = context.trackOffset(startOffset, true);\n    if (shouldInsertTypeParameters() && mayNeedTypeParameters(context.getFile().findElementAt(context.getStartOffset()))) {\n      qualifyMethodCall(file, startOffset, document);\n      insertExplicitTypeParameters(context, refStart);\n    }\n    else if (myHelper != null) {\n      context.commitDocument();\n      importOrQualify(document, file, method, startOffset);\n    }\n\n    final PsiType type = method.getReturnType();\n    if (context.getCompletionChar() == '!' && type != null && PsiType.BOOLEAN.isAssignableFrom(type)) {\n      context.setAddCompletionChar(false);\n      context.commitDocument();\n      final int offset = context.getOffset(refStart);\n      final PsiMethodCallExpression methodCall = PsiTreeUtil.findElementOfClassAtOffset(file, offset, PsiMethodCallExpression.class, false);\n      if (methodCall != null) {\n        FeatureUsageTracker.getInstance().triggerFeatureUsed(CodeCompletionFeatures.EXCLAMATION_FINISH);\n        document.insertString(methodCall.getTextRange().getStartOffset(), \"!\");\n      }\n    }\n\n    if (hasParams && Registry.is(\"java.completion.argument.live.template\")) {\n      startArgumentLiveTemplate(context, method);\n    }\n  }","id":97999,"modified_method":"@Override\n  public void handleInsert(InsertionContext context) {\n    final Document document = context.getDocument();\n    final PsiFile file = context.getFile();\n    final PsiMethod method = getObject();\n\n    final LookupElement[] allItems = context.getElements();\n    final boolean overloadsMatter = allItems.length == 1 && getUserData(JavaCompletionUtil.FORCE_SHOW_SIGNATURE_ATTR) == null;\n    final boolean hasParams = MethodParenthesesHandler.hasParams(this, allItems, overloadsMatter, method);\n    JavaCompletionUtil.insertParentheses(context, this, overloadsMatter, hasParams);\n\n    final int startOffset = context.getStartOffset();\n    final OffsetKey refStart = context.trackOffset(startOffset, true);\n    if (shouldInsertTypeParameters() && mayNeedTypeParameters(context.getFile().findElementAt(context.getStartOffset()))) {\n      qualifyMethodCall(file, startOffset, document);\n      insertExplicitTypeParameters(context, refStart);\n    }\n    else if (myHelper != null) {\n      context.commitDocument();\n      importOrQualify(document, file, method, startOffset);\n    }\n\n    final PsiType type = method.getReturnType();\n    if (context.getCompletionChar() == '!' && type != null && PsiType.BOOLEAN.isAssignableFrom(type)) {\n      context.setAddCompletionChar(false);\n      context.commitDocument();\n      final int offset = context.getOffset(refStart);\n      final PsiMethodCallExpression methodCall = PsiTreeUtil.findElementOfClassAtOffset(file, offset, PsiMethodCallExpression.class, false);\n      if (methodCall != null) {\n        FeatureUsageTracker.getInstance().triggerFeatureUsed(CodeCompletionFeatures.EXCLAMATION_FINISH);\n        document.insertString(methodCall.getTextRange().getStartOffset(), \"!\");\n      }\n    }\n\n    if (hasParams && context.getCompletionChar() != Lookup.COMPLETE_STATEMENT_SELECT_CHAR && Registry.is(\"java.completion.argument.live.template\")) {\n      startArgumentLiveTemplate(context, method);\n    }\n  }","commit_id":"877358aea3bb24a8b7c862cf51555c31258ff16f","url":"https://github.com/JetBrains/intellij-community"}]