[{"original_method":"/**\n\t * Concrete subclasses can override this to provide custom lookup behaviour for <code>CrossReference<\/code>. This\n\t * implementation delegates to the injected LinkingService\n\t * \n\t * @return a list of <code>ICompletionProposal<\/code> matching the given assignment\n\t */\n\tprotected List<? extends ICompletionProposal> lookupCrossReference(CrossReference crossReference, EObject model,\n\t\t\tString prefix, int offset) {\n\n\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\tif (linkingCandidatesService != null) {\n\t\t\t\n\t\t\tfinal XtextResource xtextResource = (XtextResource) model.eResource();\n\t\t\tfinal ParserRule containingParserRule = GrammarUtil.containingParserRule(crossReference);\n\t\t\tfinal EClass eClass = xtextResource.getElementFactory().getEClass(GrammarUtil.getReturnTypeName(containingParserRule));\n\t\t\tfinal EReference ref = GrammarUtil.getReference(crossReference, eClass);\n\t\t\tfinal Iterable<IScopedElement> candidates = linkingCandidatesService.getLinkingCandidates(model, ref);\n\t\t\tfinal String trimmedPrefix = prefix.trim();\n\t\t\tfor (IScopedElement candidate : candidates) {\n\t\t\t\tif (isCandidateMatchingPrefix(model, ref, candidate, trimmedPrefix)) {\n\t\t\t\t\tcompletionProposalList.add(createCompletionProposal(crossReference, model, candidate.name(), offset));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","id":28000,"modified_method":"/**\n\t * Concrete subclasses can override this to provide custom lookup behaviour for <code>CrossReference<\/code>. This\n\t * implementation delegates to the injected LinkingService\n\t * \n\t * @return a list of <code>ICompletionProposal<\/code> matching the given assignment\n\t */\n\tprotected List<? extends ICompletionProposal> lookupCrossReference(CrossReference crossReference, EObject model,\n\t\t\tString prefix, int offset) {\n\n\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\tif (linkingCandidatesService != null) {\n\t\t\t\n\t\t\tXtextResource xtextResource = (XtextResource) model.eResource();\n\t\t\t\n\t\t\tParserRule containingParserRule = GrammarUtil.containingParserRule(crossReference);\n\t\t\t\n\t\t\tEClass eClass = xtextResource.getElementFactory().\n\t\t\t\tgetEClass(GrammarUtil.getReturnTypeName(containingParserRule));\n\t\t\t\n\t\t\tEReference ref = GrammarUtil.getReference(crossReference, eClass);\n\t\t\t\n\t\t\tIterable<IScopedElement> candidates = linkingCandidatesService.getLinkingCandidates(model, ref);\n\t\t\t\n\t\t\tString trimmedPrefix = prefix.trim();\n\t\t\t\n\t\t\tfor (IScopedElement candidate : candidates) {\n\t\t\t\tif (isCandidateMatchingPrefix(model, ref, candidate, trimmedPrefix)) {\n\t\t\t\t\tcompletionProposalList.add(\n\t\t\t\t\t\t\tcreateCompletionProposal(crossReference, model, candidate.name(), offset));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","commit_id":"4bd4ea7235426493ff54cd717baeb0def4cc6abb","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Concrete subclasses can override this for custom sort and filter behavior. Gets called after all completion\n\t * proposals have been collected.\n\t * \n\t * The default behavior of this implementation is to sort duplicates and to trim matching\n\t * <code>ICompletionProposal#displayString<\/code> with matching prefix values.\n\t * \n\t * @see #sortAndFilter(List, EObject, String, IDocument, int, AbstractNode, LeafNode)\n\t */\n\tprotected List<? extends ICompletionProposal> doSortAndFilter(\n\t\t\tList<? extends ICompletionProposal> completionProposalList, EObject model, String prefix,\n\t\t\tIDocument document, int offset) {\n\n\t\tMap<String, ICompletionProposal> displayString2ICompletionProposalMap = new HashMap<String, ICompletionProposal>();\n\n\t\tfor (Iterator<? extends ICompletionProposal> iterator = completionProposalList.iterator(); iterator.hasNext();) {\n\n\t\t\tICompletionProposal completionProposal = iterator.next();\n\n\t\t\t// filter duplicate displayString\n\t\t\tif (!displayString2ICompletionProposalMap.containsKey(completionProposal.getDisplayString())) {\n\n\t\t\t\tdisplayString2ICompletionProposalMap.put(completionProposal.getDisplayString(), completionProposal);\n\n\t\t\t\tif (model != null) {\n\n\t\t\t\t\t// filter by prefix \n\t\t\t\t\t// TODO: this works only if we have access to the corresponding grammarelement \n\t\t\t\t\tif (completionProposal instanceof XtextCompletionProposal) {\n\n\t\t\t\t\t\tXtextCompletionProposal xtextCompletionProposal = (XtextCompletionProposal) completionProposal;\n\n\t\t\t\t\t\tAbstractElement abstractElement = null;\n\n\t\t\t\t\t\tif (xtextCompletionProposal.getAbstractElement() instanceof Keyword ||\n\t\t\t\t\t\t\txtextCompletionProposal.getAbstractElement() instanceof CrossReference) {\n\t\t\t\t\t\t\tabstractElement = GrammarUtil.containingAssignment(xtextCompletionProposal.getAbstractElement());\n\t\t\t\t\t\t} \n\t\t\t\t\t\t\n\t\t\t\t\t\tif (null==abstractElement) {\n\t\t\t\t\t\t\tabstractElement = xtextCompletionProposal.getAbstractElement();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tCompositeNode rootNode = NodeUtil.getRootNode(model);\n\n\t\t\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\n\t\t\t\t\t\tLeafNode currentLeafNode = ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\n\t\t\t\t\t\tEObject grammarElement =  GrammarUtil.containingAssignment(currentLeafNode.getGrammarElement());\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (null==grammarElement) {\n\t\t\t\t\t\t\tgrammarElement = currentLeafNode.getGrammarElement();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tboolean atTheEndOfTheLastCompleteNode = currentLeafNode == lastCompleteNode;\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean candidateToCompare \t\t\t= false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// means if we are at the end of a complete token we want to filter only equal grammarelements (not the 'next' ones)\n\t\t\t\t\t\tif (atTheEndOfTheLastCompleteNode && abstractElement.equals(grammarElement)) {\n\t\t\t\t\t\t\tcandidateToCompare = true;\n\t\t\t\t\t\t} else if (!atTheEndOfTheLastCompleteNode ) {\n\t\t\t\t\t\t\tcandidateToCompare = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( candidateToCompare && (!\"\".equals(prefix.trim()) && !completionProposal.getDisplayString().toUpperCase().startsWith(prefix.toUpperCase()))) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"filter completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"filter duplicate completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t}\n\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","id":28001,"modified_method":"/**\n\t * Concrete subclasses can override this for custom sort and filter behavior. Called right after all completion\n\t * proposals have been collected.\n\t * \n\t * The default behavior of this implementation is to sort duplicates and to trim matching\n\t * <code>ICompletionProposal#displayString<\/code> with matching prefix values.\n\t * \n\t * @see #sortAndFilter(List, EObject, String, IDocument, int, AbstractNode, LeafNode)\n\t */\n\tprotected List<? extends ICompletionProposal> doSortAndFilter(\n\t\t\tList<? extends ICompletionProposal> completionProposalList, EObject model, String prefix,\n\t\t\tIDocument document, int offset) {\n\n\t\tMap<String, ICompletionProposal> displayString2ICompletionProposalMap = new HashMap<String, ICompletionProposal>();\n\n\t\tfor (Iterator<? extends ICompletionProposal> iterator = completionProposalList.iterator(); iterator.hasNext();) {\n\n\t\t\tICompletionProposal completionProposal = iterator.next();\n\n\t\t\t// filter duplicate\n\t\t\tif (!displayString2ICompletionProposalMap.containsKey(completionProposal.getDisplayString())) {\n\n\t\t\t\tdisplayString2ICompletionProposalMap.put(completionProposal.getDisplayString(), completionProposal);\n\n\t\t\t\t// filter by prefix \n\t\t\t\tif (isFiltered(model, prefix, completionProposal)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"filter completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\titerator.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"filter duplicate completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t}\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\n\t\tCollections.sort(completionProposalList, PROPOSAL_COMPARATOR);\n\t\t\n\t\treturn completionProposalList;\n\t}","commit_id":"4bd4ea7235426493ff54cd717baeb0def4cc6abb","url":"https://github.com/eclipse/xtext"},{"original_method":"protected String calculatePrefix(ITextViewer viewer, final int offset, LeafNode currentLeafNode) {\n\n\t\tif (currentLeafNode == null)\n\t\t\treturn \"\";\n\n\t\tString prefix = \"\";\n\t\tStyledText textWidget = viewer.getTextWidget();\n\t\tif (textWidget.getCharCount() > 0) {\n\t\t\tint boundedOffset = Math.min(offset, textWidget.getCharCount()) - 1;\n\t\t\tif (currentLeafNode.getTotalOffset() <= boundedOffset)\n\t\t\t\tprefix = textWidget.getText(currentLeafNode.getTotalOffset(), boundedOffset);\n\t\t}\n\n\t\t// if cursor is behind a complete keyword, accept any input => empty\n\t\t// prefix\n\t\t// TODO: Find a way to distinguish between keywords like \"+\" or \"-\" and\n\t\t// \"extends\" or \"class\"\n\t\t// in the latter case, the prefix \"\" would not always be sufficient\n\t\tif (currentLeafNode.getGrammarElement() instanceof Keyword && currentLeafNode.getText().equals(prefix)) {\n\t\t\tprefix = \"\";\n\t\t}\n\n\t\treturn prefix;\n\t}","id":28002,"modified_method":"protected String calculatePrefix(ITextViewer viewer, final int offset, AbstractNode abstractNode) {\n\n\t\tif (abstractNode == null)\n\t\t\treturn \"\";\n\n\t\tString prefix = \"\";\n\t\tStyledText textWidget = viewer.getTextWidget();\n\t\tif (textWidget.getCharCount() > 0) {\n\t\t\tint boundedOffset = Math.min(offset, textWidget.getCharCount()) - 1;\n\t\t\tif (abstractNode.getTotalOffset() <= boundedOffset)\n\t\t\t\tprefix = textWidget.getText(abstractNode.getTotalOffset(), boundedOffset);\n\t\t}\n\n\t\t// if cursor is behind a complete keyword, accept any input => empty\n\t\t// prefix\n\t\t// TODO: Find a way to distinguish between keywords like \"+\" or \"-\" and\n\t\t// \"extends\" or \"class\"\n\t\t// in the latter case, the prefix \"\" would not always be sufficient\n\t\tif (abstractNode.getGrammarElement() instanceof Keyword && (abstractNode instanceof LeafNode  && ((LeafNode)abstractNode).getText().equals(prefix))) {\n\t\t\tprefix = \"\";\n\t\t}\n\n\t\treturn prefix;\n\t}","commit_id":"4bd4ea7235426493ff54cd717baeb0def4cc6abb","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * computes the possible grammar elements following the one at the given offset and calls the respective methods on\n\t * the proposal provider.\n\t */\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, final int offset) {\n\n\t\tICompletionProposal[] completionProposals = null;\n\n\t\tif (proposalProvider != null) {\n\n\t\t\tIDocument document = viewer.getDocument();\n\n\t\t\tif (document instanceof IXtextDocument) {\n\n\t\t\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\t\t\tIXtextDocument xtextDocument = (IXtextDocument) document;\n\n\t\t\t\tCompositeNode rootNode = xtextDocument.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\t\t\treturn parseResult.getRootNode();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tAssert.isNotNull(rootNode);\n\n\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\n\t\t\t\tLeafNode currentLeafNode = ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\n\t\t\t\tString prefix = calculatePrefix(viewer, offset, currentLeafNode);\n\n\t\t\t\tEObject model = lastCompleteNode instanceof AbstractNode ? NodeUtil\n\t\t\t\t\t\t.getNearestSemanticObject((AbstractNode) lastCompleteNode) : lastCompleteNode;\n\n\t\t\t\tSet<AbstractElement> nextValidElementSet = new LinkedHashSet<AbstractElement>();\n\t\t\t\t/**\n\t\t\t\t * in case of a crossreference which isnt linked already we evaluate it again and delegate to\n\t\t\t\t * proposalProvider (again)\n\t\t\t\t */\n\t\t\t\tif (lastCompleteNode.getGrammarElement() instanceof CrossReference && !isLinked(lastCompleteNode)) {\n\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement());\n\t\t\t\t\tnextValidElementSet.addAll(ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode,\n\t\t\t\t\t\t\toffset));\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * in case of 'at-the-end' of the previous,completed element we evaluate it again for\n\t\t\t\t * 'right-to-left-backtracking' cases (e.g. for keyword 'kind' kind>|< |=cursorpos)\n\t\t\t\t */\n\t\t\t\telse if (currentLeafNode == lastCompleteNode) {\n\t\t\t\t\tAssignment containingAssignment = GrammarUtil.containingAssignment(lastCompleteNode.getGrammarElement());\n\t\t\t\t\t\n\t\t\t\t\tif (lastCompleteNode.getGrammarElement() instanceof RuleCall && containingAssignment!=null) {\n\t\t\t\t\t\tnextValidElementSet.add(containingAssignment);\n\t\t\t\t\t\tnextValidElementSet.addAll(ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextValidElementSet = ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset);\n\t\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnextValidElementSet = ParseTreeUtil\n\t\t\t\t\t\t\t.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset);\n\t\t\t\t}\n\n\t\t\t\tProposalProviderInvokerSwitch proposalProviderInvokerSwitch = new ProposalProviderInvokerSwitch(model,\n\t\t\t\t\t\tdocument, offset, prefix, proposalProvider);\n\n\t\t\t\tfor (List<EObject> resolvedElementOrRuleList : new ProposalCandidateResolverSwitch(nextValidElementSet)) {\n\n\t\t\t\t\tList<ICompletionProposal> collectedCompletionProposalList = proposalProviderInvokerSwitch\n\t\t\t\t\t\t\t.collectCompletionProposalList(resolvedElementOrRuleList);\n\n\t\t\t\t\tcompletionProposalList.addAll(collectedCompletionProposalList);\n\t\t\t\t}\n\t\t\t\tif (completionProposalList != null) {\n\t\t\t\t\tList<? extends ICompletionProposal> processedCompletionProposalList = proposalProvider\n\t\t\t\t\t\t\t.sortAndFilter(completionProposalList, model, prefix, document, offset);\n\t\t\t\t\tcompletionProposals = processedCompletionProposalList.toArray(new ICompletionProposal[] {});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposals;\n\t}","id":28003,"modified_method":"/**\n\t * computes the possible grammar elements following the one at the given offset and calls the respective methods on\n\t * the proposal provider.\n\t */\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, final int offset) {\n\n\t\tICompletionProposal[] completionProposals = null;\n\n\t\tIDocument document = viewer.getDocument();\n\n\t\tif (document instanceof IXtextDocument) {\n\n\t\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\t\tIXtextDocument xtextDocument = (IXtextDocument) document;\n\n\t\t\tCompositeNode rootNode = xtextDocument.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\t\treturn parseResult.getRootNode();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tAssert.isNotNull(rootNode);\n\n\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\n\t\t\tAbstractNode currentNode = ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\n\t\t\tString prefix = calculatePrefix(viewer, offset, currentNode);\n\n\t\t\tEObject model = lastCompleteNode instanceof AbstractNode ? NodeUtil\n\t\t\t\t\t.getNearestSemanticObject((AbstractNode) lastCompleteNode) : lastCompleteNode;\n\t\t\t\t\t\n\t\t\taddOrReplaceCaContextAdapter(model, new ContentAssistContextAdapter(rootNode,currentNode,lastCompleteNode,offset,prefix));\n\n\t\t\tSet<AbstractElement> nextValidElementSet = new LinkedHashSet<AbstractElement>();\n\t\t\t/**\n\t\t\t * in case of a crossreference which isnt linked properly we evaluate or propose it again\n\t\t\t */\n\t\t\tif (lastCompleteNode.getGrammarElement() instanceof CrossReference && !isLinked(lastCompleteNode)) {\n\t\t\t\tnextValidElementSet.add(getAbstractElement(lastCompleteNode));\n\t\t\t\tnextValidElementSet.addAll(ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode,\n\t\t\t\t\t\toffset));\n\t\t\t}\n\t\t\t/**\n\t\t\t * in case of 'at-the-end' of the previous,completed element we evaluate it again for \n\t\t\t * 'right-to-left-backtracking' cases (e.g. for keyword 'kind' kind>|< |=cursorpos)\n\t\t\t */\n\t\t\telse if (lastCompleteNode == currentNode) {\n\t\t\t\t\n\t\t\t\tAssignment containingAssignment = GrammarUtil\n\t\t\t\t\t\t.containingAssignment(lastCompleteNode.getGrammarElement());\n\n\t\t\t\tif (lastCompleteNode.getGrammarElement() instanceof RuleCall && containingAssignment != null) {\n\t\t\t\t\tnextValidElementSet.add(containingAssignment);\n\t\t\t\t\tnextValidElementSet.addAll(ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode,\n\t\t\t\t\t\t\toffset));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnextValidElementSet = ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset);\n\t\t\t\t\tnextValidElementSet.add(getAbstractElement(lastCompleteNode));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnextValidElementSet = ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset);\n\t\t\t}\n\n\t\t\tProposalProviderInvokerSwitch proposalProviderInvokerSwitch = new ProposalProviderInvokerSwitch(model,\n\t\t\t\t\tdocument, offset, prefix, proposalProvider);\n\n\t\t\tfor (List<EObject> resolvedElementOrRuleList : new ProposalCandidateResolverSwitch(nextValidElementSet)) {\n\n\t\t\t\tList<ICompletionProposal> collectedCompletionProposalList = proposalProviderInvokerSwitch\n\t\t\t\t\t\t.collectCompletionProposalList(resolvedElementOrRuleList);\n\n\t\t\t\tcompletionProposalList.addAll(collectedCompletionProposalList);\n\t\t\t}\n\t\t\t\n\t\t\tif (completionProposalList != null) {\n\t\t\t\tList<? extends ICompletionProposal> processedCompletionProposalList = proposalProvider.sortAndFilter(\n\t\t\t\t\t\tcompletionProposalList, model, prefix, document, offset);\n\t\t\t\tcompletionProposals = processedCompletionProposalList.toArray(\n\t\t\t\t\t\tnew ICompletionProposal[processedCompletionProposalList.size()]);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\treturn completionProposals;\n\t}","commit_id":"4bd4ea7235426493ff54cd717baeb0def4cc6abb","url":"https://github.com/eclipse/xtext"},{"original_method":"public Boolean exec(XtextResource resource) throws Exception {\n\t\t\t// select text fragment in editor and wait until outline syncs\n\t\t\teditor.selectAndReveal(offset, length);\n\t\t\tsleep(1000);\n\n\t\t\t// obtain selected model element in editor\n\t\t\tIStructuredSelection selection = (IStructuredSelection) outlinePage.getSelection();\n\t\t\tURI uri = (URI) selection.getFirstElement();\n\t\t\tList<EObject> contents = EcoreUtil2.eAllContentsAsList(resource);\n\t\t\tEObject objInEditor = contents.get(elementIndex);\n\n\t\t\t// just debugging purposes\n\t\t\tLeafNode currentEditorNode = getCurrentEditorNode();\n\t\t\tSystem.out.println(\"Selection [\" + offset + \";\" + length + \"] yields node text [\"\n\t\t\t\t\t+ currentEditorNode.getText() + \"]\");\n\n\t\t\t// obtain selected model element in outline\n\t\t\tEObject objInOutline = resource.getEObject(uri.fragment());\n\n\t\t\t// they must be equal\n\t\t\treturn Boolean.valueOf(objInEditor.equals(objInOutline));\n\t\t}","id":28004,"modified_method":"public Boolean exec(XtextResource resource) throws Exception {\n\t\t\t// select text fragment in editor and wait until outline syncs\n\t\t\teditor.selectAndReveal(offset, length);\n\t\t\tsleep(1000);\n\n\t\t\t// obtain selected model element in editor\n\t\t\tIStructuredSelection selection = (IStructuredSelection) outlinePage.getSelection();\n\t\t\tURI uri = (URI) selection.getFirstElement();\n\t\t\tList<EObject> contents = EcoreUtil2.eAllContentsAsList(resource);\n\t\t\tEObject objInEditor = contents.get(elementIndex);\n\n\t\t\t// just debugging purposes\n\t\t\tAbstractNode currentEditorNode = getCurrentEditorNode();\n\t\t\tif (currentEditorNode instanceof LeafNode) {\n\t\t\t\tSystem.out.println(\"Selection [\" + offset + \";\" + length + \"] yields node text [\"\n\t\t\t\t\t\t+ ((LeafNode)currentEditorNode).getText() + \"]\");\n\t\t\t}\n\t\t\t\n\n\t\t\t// obtain selected model element in outline\n\t\t\tEObject objInOutline = resource.getEObject(uri.fragment());\n\n\t\t\t// they must be equal\n\t\t\treturn Boolean.valueOf(objInEditor.equals(objInOutline));\n\t\t}","commit_id":"4bd4ea7235426493ff54cd717baeb0def4cc6abb","url":"https://github.com/eclipse/xtext"},{"original_method":"protected LeafNode getCurrentEditorNode() {\n\t\tXtextDocument document = (XtextDocument) editor.getDocument();\n\n\t\tITextSelection selection = (ITextSelection) editor.getSelectionProvider().getSelection();\n\t\tassertNotNull(selection);\n\n\t\tint offset = selection.getOffset();\n\t\tSystem.out.println(\"OFFSET: \" + offset);\n\n\t\tCompositeNode rootNode = document.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\treturn parseResult.getRootNode();\n\t\t\t}\n\t\t});\n\t\tAssert.isNotNull(rootNode);\n\n\t\tLeafNode currentNodeByOffset = ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\t\treturn currentNodeByOffset;\n\t}","id":28005,"modified_method":"protected AbstractNode getCurrentEditorNode() {\n\t\tXtextDocument document = (XtextDocument) editor.getDocument();\n\n\t\tITextSelection selection = (ITextSelection) editor.getSelectionProvider().getSelection();\n\t\tassertNotNull(selection);\n\n\t\tint offset = selection.getOffset();\n\t\tSystem.out.println(\"OFFSET: \" + offset);\n\n\t\tCompositeNode rootNode = document.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\treturn parseResult.getRootNode();\n\t\t\t}\n\t\t});\n\t\tAssert.isNotNull(rootNode);\n\n\t\treturn  ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\t}","commit_id":"4bd4ea7235426493ff54cd717baeb0def4cc6abb","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * \n\t * @param contextNode\n\t *            the node representing the 'scope' of the current lookup\n\t * @param offsetPosition\n\t *            the text position within the the current sentence\n\t * \n\t * @return the node element that starts at or spans across the provided position\n\t */\n\tpublic static final LeafNode getCurrentNodeByOffset(AbstractNode contextNode, int offsetPosition) {\n\n\t\tassertParameterNotNull(contextNode, \"contextNode\");\n\n\t\tLeafNode leafNode = null;\n\n\t\tEList<LeafNode> leafNodes = contextNode.getLeafNodes();\n\t\tfor (Iterator<LeafNode> iterator = leafNodes.iterator(); iterator.hasNext() && leafNode==null;) {\n\t\t\tLeafNode childNode = iterator.next();\n\t\t\tif (childNode.getTotalOffset() <= offsetPosition && offsetPosition <= childNode.getTotalOffset() + childNode.getTotalLength()) {\n\t\t\t\tleafNode = (LeafNode) childNode;\n\t\t\t}\n\t\t}\n\n\t\treturn leafNode;\n\t}","id":28006,"modified_method":"/**\n\t * \n\t * @param contextNode\n\t *            the node representing the 'scope' of the current lookup\n\t * @param offsetPosition\n\t *            the text position within the the current sentence\n\t * \n\t * @return the node element that starts at or spans across the provided position\n\t */\n\tpublic static final AbstractNode getCurrentNodeByOffset(AbstractNode contextNode, int offsetPosition) {\n\n\t\tassertParameterNotNull(contextNode, \"contextNode\");\n\t\t\n\t\tAbstractNode result = contextNode;\n\n\t\tTreeIterator<EObject> allContentsTreeIterator = EcoreUtil.getRootContainer(contextNode).eAllContents();\n\n\t\twhile (allContentsTreeIterator.hasNext()) {\n\t\t\t\n\t\t\tEObject eObject = allContentsTreeIterator.next(); \n\t\t\t\n\t\t\tif (eObject instanceof AbstractNode) {\n\t\t\t\t\n\t\t\t\tAbstractNode abstractNode = (AbstractNode) eObject;\n\t\t\t\n\t\t\t\tif ((abstractNode.getTotalOffset() + abstractNode.getTotalLength())<offsetPosition ) {\n\t\t\t\t\tallContentsTreeIterator.prune();\n\t\t\t\t} else if (abstractNode.getTotalOffset() <= offsetPosition && \n\t\t\t\t\t\t           \t\t  offsetPosition <= abstractNode.getTotalOffset() + abstractNode.getTotalLength()) {\n\t\t\t\t\tif (abstractNode.getTotalLength() > 0 \n\t\t\t\t\t\t\t|| (result==null || result.getTotalLength()==0)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (abstractNode instanceof LeafNode && \n\t\t\t\t\t\t\t\tabstractNode.getTotalOffset()==offsetPosition && ((LeafNode)abstractNode).isHidden()) {\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult = abstractNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (abstractNode.getTotalOffset() > offsetPosition ) {\n\t\t\t\t\tbreak;\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null==result ? contextNode : result;\n\t}","commit_id":"4bd4ea7235426493ff54cd717baeb0def4cc6abb","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testGetCurrentNodeByOffset() throws Exception {\n\n\t\tString text = \"spielplatz 1 \\\"junit\\\" { kin  \";\n\t\tCompositeNode rootNode = getRootNode(text);\n\t\tLeafNode currentNodeByOffset = ParseTreeUtil.getCurrentNodeByOffset(rootNode, 26);\n\t\tassertEquals(\"expect leafnode with text 'kin'\", currentNodeByOffset.getText(), \"kin\");\n\n\t\ttext = \"spielplatz 1 \\\"junit\\\" { kind (\";\n\t\trootNode = getRootNode(text);\n\t\tcurrentNodeByOffset = ParseTreeUtil.getCurrentNodeByOffset(rootNode, text.length());\n\t\tassertEquals(\"expect leafnode with text '('\", currentNodeByOffset.getText(), \"(\");\n\n\t\ttext = \"spielplatz 1 \\\"junit\\\" { kind (  \";\n\t\trootNode = getRootNode(text);\n\t\tcurrentNodeByOffset = ParseTreeUtil.getCurrentNodeByOffset(rootNode, text.length());\n\t\tassertEquals(\"expect leafnode with WS text '__'\", currentNodeByOffset.getText(), \"  \");\n\n\t\ttext = \"spielplatz 1 \\\"junit\\\" { kind (\";\n\t\trootNode = getRootNode(text);\n\t\tcurrentNodeByOffset = ParseTreeUtil.getCurrentNodeByOffset(rootNode, text.length() - 1);\n\t\tassertEquals(\"expect leafnode with WS text '_'\", currentNodeByOffset.getText(), \" \");\n\n\t\ttext = \"spielplatz 1 \\\"junit\\\" { kind (\";\n\t\trootNode = getRootNode(text);\n\t\tcurrentNodeByOffset = ParseTreeUtil.getCurrentNodeByOffset(rootNode, 0);\n\t\tassertEquals(\"expect leafnode with WS text 'spielplatz'\", currentNodeByOffset.getText(), \"spielplatz\");\n\n\t}","id":28007,"modified_method":"public void testGetCurrentNodeByOffset() throws Exception {\n\n\t\tString text = \"spielplatz 1 \\\"junit\\\" { kin  \";\n\t\tCompositeNode rootNode = getRootNode(text);\n\t\tLeafNode currentNodeByOffset = (LeafNode) ParseTreeUtil.getCurrentNodeByOffset(rootNode, 26);\n\t\tassertEquals(\"expect leafnode with text 'kin'\", currentNodeByOffset.getText(), \"kin\");\n\n\t\ttext = \"spielplatz 1 \\\"junit\\\" { kind (\";\n\t\trootNode = getRootNode(text);\n\t\tcurrentNodeByOffset = (LeafNode) ParseTreeUtil.getCurrentNodeByOffset(rootNode, text.length());\n\t\tassertEquals(\"expect leafnode with text '('\", currentNodeByOffset.getText(), \"(\");\n\n\t\ttext = \"spielplatz 1 \\\"junit\\\" { kind (  \";\n\t\trootNode = getRootNode(text);\n\t\tcurrentNodeByOffset = (LeafNode) ParseTreeUtil.getCurrentNodeByOffset(rootNode, text.length());\n\t\tassertEquals(\"expect leafnode with WS text '__'\", currentNodeByOffset.getText(), \"  \");\n\n\t\ttext = \"spielplatz 1 \\\"junit\\\" { kind (\";\n\t\trootNode = getRootNode(text);\n\t\tcurrentNodeByOffset = (LeafNode) ParseTreeUtil.getCurrentNodeByOffset(rootNode, text.length() - 1);\n\t\tassertEquals(\"expect leafnode with '('\", currentNodeByOffset.getText(), \"(\");\n\n\t\ttext = \"spielplatz 1 \\\"junit\\\" { kind (\";\n\t\trootNode = getRootNode(text);\n\t\tcurrentNodeByOffset = (LeafNode) ParseTreeUtil.getCurrentNodeByOffset(rootNode, 0);\n\t\tassertEquals(\"expect leafnode with WS text 'spielplatz'\", currentNodeByOffset.getText(), \"spielplatz\");\n\n\t}","commit_id":"4bd4ea7235426493ff54cd717baeb0def4cc6abb","url":"https://github.com/eclipse/xtext"},{"original_method":"public void apply(ITextViewer viewer, char trigger, int stateMask,\n\t\t\tint offset) {\n\n\t\ttry {\n\t\t\t\n\t\t\tIDocument document = viewer.getDocument();\n\t\t\t\n\t\t\tint offsetToApply = this.offset;\n\n\t\t\tif (model != null) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tCompositeNode parserNode = NodeUtil.getRootNode(model);\n\t\t\t\t\n\t\t\t\tLeafNode currentLeafNode=ParseTreeUtil.getCurrentNodeByOffset(parserNode, offset);\n\t\t\t\t\n\t\t\t\tboolean isCursorAtTheEndOfTheLastElement = offset == (currentLeafNode.getTotalOffset() + currentLeafNode\n\t\t\t\t\t\t.getTotalLength());\n\t\t\t\t\n\t\t\t\tif ((currentLeafNode.isHidden() && !\"\".equals(currentLeafNode.getText().trim()))\n\t\t\t\t\t\t|| isCursorAtTheEndOfTheLastElement) {\n\t\t\t\t\tif (getDisplayString().toUpperCase().startsWith(currentLeafNode.getText().toUpperCase())) {\n\t\t\t\t\t\toffsetToApply-=currentLeafNode.getText().trim().length();\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\t\n\t\t\t\tif (!currentLeafNode.isHidden() && \n\t\t\t\t\t\tisCursorAtTheEndOfTheLastElement && \n\t\t\t\t\t\toffsetToApply==offset) {\n\n\t\t\t\t\tif (currentLeafNode.getGrammarElement() instanceof CrossReference\n\t\t\t\t\t\t\t&& abstractElement instanceof CrossReference) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\t\t\t\t\telse if (currentLeafNode.getGrammarElement() instanceof RuleCall\n\t\t\t\t\t\t\t&& currentLeafNode.getGrammarElement().eContainer() instanceof Assignment\n\t\t\t\t\t\t\t&& abstractElement instanceof Assignment) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\t\t\t\t\telse if (!GrammarUtil.containingParserRule(abstractElement).equals(GrammarUtil.containingParserRule(currentLeafNode.getGrammarElement()))) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t\n\t\t\tdocument.replace(offsetToApply, offset != offsetToApply ? offset\n\t\t\t\t\t- offsetToApply : 0, getText());\n\n\t\t} catch (BadLocationException e) {\n\t\t\tlogger.error(e);\n\t\t}\n\t}","id":28008,"modified_method":"public void apply(ITextViewer viewer, char trigger, int stateMask,\n\t\t\tint offset) {\n\n\t\ttry {\n\t\t\t\n\t\t\tIDocument document = viewer.getDocument();\n\t\t\t\n\t\t\tif (model != null) {\n\t\t\t\t\n\t\t\t\tContentAssistContextAdapter contentAssistContextAdapter = getContextAdapater();\n\t\t\t\t\n\t\t\t\tAbstractNode abstractNode = contentAssistContextAdapter.getCurrentNode();\n\t\t\t\t\n\t\t\t\tif (abstractNode instanceof LeafNode) {\n\t\t\t\t\t\n\t\t\t\t\tLeafNode currentLeafNode = (LeafNode) abstractNode;\n\t\t\t\t\t\n\t\t\t\t\tif (getDisplayString().toUpperCase().startsWith(currentLeafNode.getText().toUpperCase())) {\n\t\t\t\t\t\tsetText(getText().substring(this.offset - currentLeafNode.getTotalOffset()));\n\t\t\t\t\t} else if (contentAssistContextAdapter.isCusorAtEndOfLastCompleteNode()) {\n\n\t\t\t\t\t\tif (currentLeafNode.getGrammarElement() instanceof CrossReference\n\t\t\t\t\t\t\t\t&& abstractElement instanceof CrossReference) {\n\t\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (currentLeafNode.getGrammarElement() instanceof RuleCall\n\t\t\t\t\t\t\t\t&& currentLeafNode.getGrammarElement().eContainer() instanceof Assignment\n\t\t\t\t\t\t\t\t&& abstractElement instanceof Assignment) {\n\t\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!GrammarUtil.containingParserRule(abstractElement).equals(\n\t\t\t\t\t\t\t\t  GrammarUtil.containingParserRule(currentLeafNode.getGrammarElement()))) {\n\t\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t}\n\t\t\t\n\t\t\tdocument.replace(this.offset, document.getLength()<(this.offset+getText().length()) ? 0:getText().length() , getText());\n\n\t\t} catch (BadLocationException e) {\n\t\t\tlogger.error(e);\n\t\t}\n\t}","commit_id":"4bd4ea7235426493ff54cd717baeb0def4cc6abb","url":"https://github.com/eclipse/xtext"},{"original_method":"public void initialize() {\n        Disruptor<MessageEvent> disruptor = new Disruptor<MessageEvent>(\n                MessageEvent.EVENT_FACTORY,\n                executor,\n                new MultiThreadedClaimStrategy(server.getConfiguration().getRingSize()),\n                server.getConfiguration().getProcessorWaitStrategy()\n        );\n        \n        LOG.info(\"Initialized OutputBuffer with ring size <{}> \"\n                + \"and wait strategy <{}>.\", server.getConfiguration().getRingSize(),\n                server.getConfiguration().getProcessorWaitStrategy().getClass().getSimpleName());\n\n        OutputBufferProcessor[] processors = new OutputBufferProcessor[server.getConfiguration().getOutputBufferProcessors()];\n        \n        for (int i = 0; i < server.getConfiguration().getOutputBufferProcessors(); i++) {\n            processors[i] = new OutputBufferProcessor(this.server, i, server.getConfiguration().getOutputBufferProcessors());\n        }\n        \n        disruptor.handleEventsWith(processors);\n        \n        ringBuffer = disruptor.start();\n    }","id":28009,"modified_method":"public void initialize() {\n        Disruptor disruptor = new Disruptor<MessageEvent>(\n                MessageEvent.EVENT_FACTORY,\n                server.getConfiguration().getRingSize(),\n                executor,\n                ProducerType.MULTI,\n                server.getConfiguration().getProcessorWaitStrategy()\n        );\n        \n        LOG.info(\"Initialized OutputBuffer with ring size <{}> \"\n                + \"and wait strategy <{}>.\", server.getConfiguration().getRingSize(),\n                server.getConfiguration().getProcessorWaitStrategy().getClass().getSimpleName());\n\n        OutputBufferProcessor[] processors = new OutputBufferProcessor[server.getConfiguration().getOutputBufferProcessors()];\n        \n        for (int i = 0; i < server.getConfiguration().getOutputBufferProcessors(); i++) {\n            processors[i] = new OutputBufferProcessor(this.server, i, server.getConfiguration().getOutputBufferProcessors());\n        }\n        \n        disruptor.handleEventsWith(processors);\n        \n        ringBuffer = disruptor.start();\n    }","commit_id":"57ad943502103a60cc415081574c0efa37fab39e","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public void initialize() {\n        Disruptor<MessageEvent> disruptor = new Disruptor<MessageEvent>(\n                MessageEvent.EVENT_FACTORY,\n                executor,\n                new MultiThreadedClaimStrategy(server.getConfiguration().getRingSize()),\n                server.getConfiguration().getProcessorWaitStrategy()\n        );\n        \n        LOG.info(\"Initialized ProcessBuffer with ring size <{}> \"\n                + \"and wait strategy <{}>.\", server.getConfiguration().getRingSize(),\n                server.getConfiguration().getProcessorWaitStrategy().getClass().getSimpleName());\n\n        ProcessBufferProcessor[] processors = new ProcessBufferProcessor[server.getConfiguration().getProcessBufferProcessors()];\n        \n        for (int i = 0; i < server.getConfiguration().getProcessBufferProcessors(); i++) {\n            processors[i] = new ProcessBufferProcessor(this.server, i, server.getConfiguration().getProcessBufferProcessors());\n        }\n        \n        disruptor.handleEventsWith(processors);\n        \n        ringBuffer = disruptor.start();\n    }","id":28010,"modified_method":"public void initialize() {\n        Disruptor disruptor = new Disruptor<MessageEvent>(\n                MessageEvent.EVENT_FACTORY,\n                server.getConfiguration().getRingSize(),\n                executor,\n                ProducerType.MULTI,\n                server.getConfiguration().getProcessorWaitStrategy()\n        );\n        \n        LOG.info(\"Initialized ProcessBuffer with ring size <{}> \"\n                + \"and wait strategy <{}>.\", server.getConfiguration().getRingSize(),\n                server.getConfiguration().getProcessorWaitStrategy().getClass().getSimpleName());\n\n        ProcessBufferProcessor[] processors = new ProcessBufferProcessor[server.getConfiguration().getProcessBufferProcessors()];\n        \n        for (int i = 0; i < server.getConfiguration().getProcessBufferProcessors(); i++) {\n            processors[i] = new ProcessBufferProcessor(this.server, i, server.getConfiguration().getProcessBufferProcessors());\n        }\n        \n        disruptor.handleEventsWith(processors);\n        \n        ringBuffer = disruptor.start();\n    }","commit_id":"57ad943502103a60cc415081574c0efa37fab39e","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private Map<String, Object> buffers() {\n        Map<String, Object> buffers = Maps.newHashMap();\n        Map<String, Object> input = Maps.newHashMap();\n        Map<String, Object> output = Maps.newHashMap();\n\n        int ringSize = configuration.getRingSize();\n\n        BufferWatermark pWm = new BufferWatermark(ringSize, new AtomicLong(processBuffer.size()));\n        input.put(\"utilization_percent\", pWm.getUtilizationPercentage());\n        input.put(\"utilization\", pWm.getUtilization());\n\n        BufferWatermark oWm = new BufferWatermark(ringSize, new AtomicLong(outputBuffer.size()));\n        output.put(\"utilization_percent\", oWm.getUtilizationPercentage());\n        output.put(\"utilization\", oWm.getUtilization());\n\n        buffers.put(\"input\", input);\n        buffers.put(\"output\", output);\n\n        return buffers;\n    }","id":28011,"modified_method":"private Map<String, Object> buffers() {\n        Map<String, Object> buffers = Maps.newHashMap();\n        Map<String, Object> input = Maps.newHashMap();\n        Map<String, Object> output = Maps.newHashMap();\n\n        int ringSize = configuration.getRingSize();\n\n        final long inputSize = processBuffer.size();\n        final float inputUtil = inputSize/ringSize*100;\n        input.put(\"utilization_percent\", inputUtil);\n        input.put(\"utilization\", inputSize);\n\n        final long outputSize = outputBuffer.size();\n        final float outputUtil = outputSize/ringSize*100;\n        output.put(\"utilization_percent\", outputUtil);\n        output.put(\"utilization\", outputSize);\n\n        buffers.put(\"input\", input);\n        buffers.put(\"output\", output);\n\n        return buffers;\n    }","commit_id":"baad4c4f94fe66c72a339fe25b77cf92c85c1378","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private Map<String, Object> buffers() {\n        Map<String, Object> buffers = Maps.newHashMap();\n        Map<String, Object> input = Maps.newHashMap();\n\n        BufferWatermark pWm = new BufferWatermark(\n                configuration.getRingSize(),\n                new AtomicLong(processBuffer.size())\n        );\n\n        input.put(\"utilization_percent\", pWm.getUtilizationPercentage());\n        input.put(\"utilization\", pWm.getUtilization());\n\n        buffers.put(\"input\", input);\n\n        return buffers;\n    }","id":28012,"modified_method":"private Map<String, Object> buffers() {\n        Map<String, Object> buffers = Maps.newHashMap();\n        Map<String, Object> input = Maps.newHashMap();\n\n        final int ringSize = configuration.getRingSize();\n        final long inputSize = processBuffer.size();\n        final long inputUtil = inputSize/ringSize*100;\n\n        input.put(\"utilization_percent\", inputUtil);\n        input.put(\"utilization\", inputSize);\n\n        buffers.put(\"input\", input);\n\n        return buffers;\n    }","commit_id":"baad4c4f94fe66c72a339fe25b77cf92c85c1378","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\r\n     * Constructs an OptionalTextBox with the given caption on the check.<p>\r\n     * \r\n     */\r\n    public CmsCheckboxWidget() {\r\n\r\n        // Place the check above the text box using a vertical panel.\r\n        VerticalPanel panel = new VerticalPanel();\r\n        // adds the checkbot to the panel. \r\n        panel.add(m_checkbox);\r\n\r\n        // Set the check box's caption, and check it by default.\r\n        m_checkbox.setChecked(true);\r\n        m_checkbox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {\r\n\r\n            public void onValueChange(ValueChangeEvent<Boolean> event) {\r\n\r\n                if (Boolean.parseBoolean(m_checkbox.getFormValueAsString())) {\r\n                    getParent().getElement().addClassName(I_LayoutBundle.INSTANCE.form().inActive());\r\n                } else {\r\n                    getParent().getElement().removeClassName(I_LayoutBundle.INSTANCE.form().inActive());\r\n                }\r\n                fireChangeEvent();\r\n\r\n            }\r\n\r\n        });\r\n        // All composites must call initWidget() in their constructors.\r\n        initWidget(panel);\r\n\r\n    }","id":28013,"modified_method":"/**\r\n     * Constructs an OptionalTextBox with the given caption on the check.<p>\r\n     * \r\n     */\r\n    public CmsCheckboxWidget() {\r\n\r\n        SimplePanel panel = new SimplePanel();\r\n        // adds the checkbox to the panel. \r\n        panel.add(m_checkbox);\r\n\r\n        // Set the check box's caption, and check it by default.\r\n        m_checkbox.setChecked(true);\r\n        m_checkbox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {\r\n\r\n            public void onValueChange(ValueChangeEvent<Boolean> event) {\r\n\r\n                if (Boolean.parseBoolean(m_checkbox.getFormValueAsString())) {\r\n                    getParent().getElement().addClassName(I_LayoutBundle.INSTANCE.form().inActive());\r\n                } else {\r\n                    getParent().getElement().removeClassName(I_LayoutBundle.INSTANCE.form().inActive());\r\n                }\r\n                fireChangeEvent();\r\n\r\n            }\r\n\r\n        });\r\n        // All composites must call initWidget() in their constructors.\r\n        initWidget(panel);\r\n\r\n    }","commit_id":"eeabe6dc3847dcdf0c8b98556411379e204ff240","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Creates a new display widget.<p>\r\n     * @param config \r\n     */\r\n    public CmsTextboxWidget(String config) {\r\n\r\n        if ((config != \"\") || (config != null)) {\r\n            parseConfig(config);\r\n        }\r\n        m_fadePanel.addDomHandler(new ClickHandler() {\r\n\r\n            public void onClick(ClickEvent event) {\r\n\r\n                m_textbox.setFocus(true);\r\n                m_textbox.setCursorPos(m_textbox.getText().length());\r\n            }\r\n        }, ClickEvent.getType());\r\n        m_fadePanel.setStyleName(I_CmsInputLayoutBundle.INSTANCE.inputCss().fader());\r\n        m_textbox.addFocusHandler(new FocusHandler() {\r\n\r\n            public void onFocus(FocusEvent event) {\r\n\r\n                m_mainPanel.remove(m_fadePanel);\r\n                setTitle(\"\");\r\n\r\n            }\r\n        });\r\n        m_mainPanel.getElement().getStyle().setMarginRight(12, Unit.PX);\r\n        m_mainPanel.add(m_textbox);\r\n        m_mainPanel.add(m_fadePanel);\r\n\r\n        m_textbox.setStyleName(I_CmsLayoutBundle.INSTANCE.widgetCss().textBox());\r\n        m_textbox.addValueChangeHandler(new ValueChangeHandler<String>() {\r\n\r\n            public void onValueChange(ValueChangeEvent<String> event) {\r\n\r\n                fireChangeEvent();\r\n\r\n            }\r\n        });\r\n        m_textbox.addBlurHandler(new BlurHandler() {\r\n\r\n            public void onBlur(BlurEvent event) {\r\n\r\n                m_mainPanel.add(m_fadePanel);\r\n                setTitle(m_textbox.getText());\r\n            }\r\n        });\r\n        initWidget(m_mainPanel);\r\n        addStyleName(I_CmsLayoutBundle.INSTANCE.widgetCss().inputField());\r\n    }","id":28014,"modified_method":"/**\r\n     * Creates a new display widget.<p>\r\n     * @param config \r\n     */\r\n    public CmsTextboxWidget(String config) {\r\n\r\n        m_mainPanel = uiBinder.createAndBindUi(this);\r\n        initWidget(m_mainPanel);\r\n        if ((config != \"\") || (config != null)) {\r\n            parseConfig(config);\r\n        }\r\n    }","commit_id":"eeabe6dc3847dcdf0c8b98556411379e204ff240","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Default constructor.\n     * \n     * @param uploadUrl the url to be set for 'action' attribute of the internal form\n     * @param submitCompleteHandler the {@link SubmitCompleteHandler} for handling the form submit complete event\n     */\n    public FileImportTab(String uploadUrl, SubmitCompleteHandler submitCompleteHandler)\n    {\n        // Main container panel.\n        FlowPanel mainPanel = new FlowPanel();\n\n        // Info label.\n        Panel infoLabel = new FlowPanel();\n        infoLabel.setStyleName(\"xInfoLabel\");\n        infoLabel.add(new InlineLabel(Strings.INSTANCE.importerFileTabInfoLabel()));\n        InlineLabel mandatoryLabel = new InlineLabel(Strings.INSTANCE.mandatory());\n        mandatoryLabel.addStyleName(\"xMandatory\");\n        infoLabel.add(mandatoryLabel);\n        mainPanel.add(infoLabel);\n\n        Label helpLabel = new Label(Strings.INSTANCE.importerFileTabHelpLabel());\n        helpLabel.setStyleName(\"xHelpLabel\");\n        mainPanel.add(helpLabel);\n\n        // Form panel.\n        formPanel = new FormPanel();\n        formPanel.setAction(uploadUrl);\n        formPanel.setEncoding(FormPanel.ENCODING_MULTIPART);\n        formPanel.setMethod(FormPanel.METHOD_POST);\n        fileUpload = new FileUpload();\n        fileUpload.setName(\"filepath\");\n        formPanel.add(fileUpload);\n        formPanel.addSubmitCompleteHandler(submitCompleteHandler);\n        mainPanel.add(formPanel);\n\n        // Finalize.\n        initWidget(mainPanel);\n    }","id":28015,"modified_method":"/**\n     * Default constructor.\n     * \n     * @param isOpenOfficeServerConnected if the OpenOffice server is available to handle file imports.\n     * @param uploadUrl the url to be set for 'action' attribute of the internal form\n     * @param submitCompleteHandler the {@link SubmitCompleteHandler} for handling the form submit complete event\n     */\n    public FileImportTab(boolean isOpenOfficeServerConnected, String uploadUrl,\n        SubmitCompleteHandler submitCompleteHandler)\n    {\n        // Main container panel.\n        FlowPanel mainPanel = new FlowPanel();\n\n        if (!isOpenOfficeServerConnected) {\n            Label featureNotAvailableLabel = new Label(Strings.INSTANCE.importerFileTabNotAvailableLabel());\n            featureNotAvailableLabel.setStyleName(HELP_LABEL_STYLE);\n            mainPanel.add(featureNotAvailableLabel);\n        } else {\n            // Info label.\n            Panel infoLabel = new FlowPanel();\n            infoLabel.setStyleName(\"xInfoLabel\");\n            infoLabel.add(new InlineLabel(Strings.INSTANCE.importerFileTabInfoLabel()));\n            InlineLabel mandatoryLabel = new InlineLabel(Strings.INSTANCE.mandatory());\n            mandatoryLabel.addStyleName(\"xMandatory\");\n            infoLabel.add(mandatoryLabel);\n            mainPanel.add(infoLabel);\n\n            Label helpLabel = new Label(Strings.INSTANCE.importerFileTabHelpLabel());\n            helpLabel.setStyleName(HELP_LABEL_STYLE);\n            mainPanel.add(helpLabel);\n\n            // Form panel.\n            formPanel = new FormPanel();\n            formPanel.setAction(uploadUrl);\n            formPanel.setEncoding(FormPanel.ENCODING_MULTIPART);\n            formPanel.setMethod(FormPanel.METHOD_POST);\n            fileUpload = new FileUpload();\n            fileUpload.setName(\"filepath\");\n            formPanel.add(fileUpload);\n            formPanel.addSubmitCompleteHandler(submitCompleteHandler);\n            mainPanel.add(formPanel);\n        }\n\n        // Finalize.\n        initWidget(mainPanel);\n    }","commit_id":"3acab6980a977319a75700f683676fbc4fb4c6d8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Prepares the cleaning parameters map.\n     * \n     * @return a {@link Map} with cleaning parameters for office importer.\n     */\n    private Map<String, String> getCleaningParams()\n    {\n        Map<String, String> params = new HashMap<String, String>();\n        if (buttonPanel.getFilterStylesCheckBox().getValue()) {\n            params.put(\"filterStyles\", \"strict\");\n        }\n        // For Office2007: Office2007 generates an xhtml document (when copied) which has attributes and tags of\n        // several namespaces. But the document itself doesn't contain the namespace definitions, which causes\n        // the HTMLCleaner (the DomSerializer) to fail while performing it's operations. As a workaround we\n        // force HTMLCleaner to avoid parsing of namespace information.\n        params.put(\"namespacesAware\", \"false\");\n        return params;\n    }","id":28016,"modified_method":"/**\n     * Prepares the cleaning parameters map.\n     * \n     * @return a {@link Map} with cleaning parameters for office importer.\n     */\n    private Map<String, String> getCleaningParams()\n    {\n        Map<String, String> params = new HashMap<String, String>();\n        if (buttonPanel.getFilterStylesCheckBox().getValue()) {\n            params.put(\"filterStyles\", \"strict\");\n        }\n        // For Office2007: Office2007 generates an xhtml document (when copied) which has attributes and tags of\n        // several namespaces. But the document itself doesn't contain the namespace definitions, which causes\n        // the HTMLCleaner (the DomSerializer) to fail while performing it's operations. As a workaround we\n        // force HTMLCleaner to avoid parsing of namespace information.\n        params.put(\"namespacesAware\", Boolean.toString(false));\n        return params;\n    }","commit_id":"3acab6980a977319a75700f683676fbc4fb4c6d8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Default constructor.\n     * \n     * @param space current space.\n     * @param page current page.\n     */\n    public ImporterDialog(String space, String page)\n    {\n        // Dialog box.\n        super(false, true);\n        getDialog().setIcon(Images.INSTANCE.importer().createImage());\n        getDialog().setCaption(Strings.INSTANCE.importerCaption());\n        addStyleName(\"xImporterDialog\");\n        getHeader().clear();\n\n        this.fullPageName = space + \".\" + page;\n\n        // Main container panel.\n        mainPanel = new FlowPanel();\n        mainPanel.addStyleName(\"xImporterPanel\");\n\n        // Tab panel.\n        tabPanel = new TabPanel();\n        TabPanelSelector tabPanelSelector = new TabPanelSelector();\n        tabPanel.addBeforeSelectionHandler(tabPanelSelector);\n        tabPanel.addSelectionHandler(tabPanelSelector);\n        clipboardImportTab = new ClipboardImportTab();\n        tabPanel.add(clipboardImportTab, Strings.INSTANCE.importerClipboardTabCaption());\n        String uploadUrl = \"../../upload/\" + space + \"/\" + page;\n        fileImportTab = new FileImportTab(uploadUrl, this);\n        tabPanel.add(fileImportTab, Strings.INSTANCE.importerFileTabCaption());\n        tabPanel.selectTab(0);\n        tabPanel.addStyleName(\"xImporterTabPanel\");\n        mainPanel.add(tabPanel);\n\n        // Button panel.\n        buttonPanel = new ButtonPanel(this);\n        getFooter().add(buttonPanel);\n\n        getBody().add(mainPanel);\n    }","id":28017,"modified_method":"/**\n     * Default constructor.\n     * \n     * @param wysiwygConfig the wysiwyg configuration object.\n     */\n    public ImporterDialog(Config wysiwygConfig)\n    {\n        // Dialog box.\n        super(false, true);\n        getDialog().setIcon(Images.INSTANCE.importer().createImage());\n        getDialog().setCaption(Strings.INSTANCE.importerCaption());\n        addStyleName(\"xImporterDialog\");\n        getHeader().clear();\n\n        // Read current wysiwyg configuration.\n        String currentSpace = wysiwygConfig.getParameter(\"space\", \"Main\");\n        String currentPage = wysiwygConfig.getParameter(\"page\", \"WebHome\");\n        boolean openOfficeServerConnected =\n            wysiwygConfig.getParameter(\"openofficeServerConnected\", \"false\").equals(\"true\");\n\n        this.fullPageName = currentSpace + \".\" + currentPage;\n\n        // Main container panel.\n        mainPanel = new FlowPanel();\n        mainPanel.addStyleName(\"xImporterPanel\");\n\n        // Tab panel.\n        tabPanel = new TabPanel();\n        TabPanelSelector tabPanelSelector = new TabPanelSelector();\n        tabPanel.addBeforeSelectionHandler(tabPanelSelector);\n        tabPanel.addSelectionHandler(tabPanelSelector);\n        clipboardImportTab = new ClipboardImportTab();\n        tabPanel.add(clipboardImportTab, Strings.INSTANCE.importerClipboardTabCaption());\n        String uploadUrl = \"../../upload/\" + currentSpace + \"/\" + currentPage;\n        fileImportTab = new FileImportTab(openOfficeServerConnected, uploadUrl, this);\n        tabPanel.add(fileImportTab, Strings.INSTANCE.importerFileTabCaption());\n        tabPanel.selectTab(0);\n        tabPanel.addStyleName(\"xImporterTabPanel\");\n        mainPanel.add(tabPanel);\n\n        // Button panel.\n        buttonPanel = new ButtonPanel(this);\n        getFooter().add(buttonPanel);\n\n        getBody().add(mainPanel);\n    }","commit_id":"3acab6980a977319a75700f683676fbc4fb4c6d8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return The importer dialog instance.\n     */\n    private ImporterDialog getImporterDialog()\n    {\n        if (null == importerDialog) {\n            importerDialog =\n                new ImporterDialog(getConfig().getParameter(\"space\", \"Main\"), getConfig().getParameter(\"page\",\n                    \"WebHome\"));\n            saveRegistration(importerDialog.addCloseHandler(this));\n        }\n        return importerDialog;\n    }","id":28018,"modified_method":"/**\n     * @return The importer dialog instance.\n     */\n    private ImporterDialog getImporterDialog()\n    {\n        if (null == importerDialog) {            \n            importerDialog = new ImporterDialog(getConfig());\n            saveRegistration(importerDialog.addCloseHandler(this));\n        }\n        return importerDialog;\n    }","commit_id":"3acab6980a977319a75700f683676fbc4fb4c6d8","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n   public void setValue(TransUnit value, boolean fireEvents)\n   {\n      sourcePanelContainer.resizeRows(value.getSources().size());\n      sourcePanelList.clear();\n\n      int rowIndex = 0;\n      for (String source : value.getSources())\n      {\n         SourcePanel sourcePanel = new SourcePanel();\n         sourcePanel.setValue(source, value.getSourceComment(), value.isPlural());\n         sourcePanelContainer.setWidget(rowIndex, 0, sourcePanel);\n         sourcePanelList.add(sourcePanel);\n         rowIndex++;\n      }\n   }","id":28019,"modified_method":"@Override\n   public void setValue(TransUnit value, boolean fireEvents)\n   {\n      transUnitDetailsPanel.setDetails(value);\n      sourcePanelContainer.resizeRows(value.getSources().size());\n      sourcePanelList.clear();\n\n      int rowIndex = 0;\n      for (String source : value.getSources())\n      {\n         SourcePanel sourcePanel = new SourcePanel();\n         sourcePanel.setValue(source, value.getSourceComment(), value.isPlural());\n         sourcePanelContainer.setWidget(rowIndex, 0, sourcePanel);\n         sourcePanelList.add(sourcePanel);\n         rowIndex++;\n      }\n   }","commit_id":"667c08ef40b47991fc1a53efe59515c43e142938","url":"https://github.com/zanata/zanata-server"},{"original_method":"public TableEditorTableDefinition(final NavigationMessages messages, final RedirectingCachedTableModel<TransUnit> tableModel, final SourceContentsPresenter sourceContentsPresenter, boolean isReadOnly, TargetContentsPresenter targetContentsPresenter)\n   {\n      this.isReadOnly = isReadOnly;\n      this.sourceContentsPresenter = sourceContentsPresenter;\n      this.targetContentsPresenter = targetContentsPresenter;\n      setRowRenderer(rowRenderer);\n      sourceColumnDefinition.setCellRenderer(sourceCellRenderer);\n      targetColumnDefinition.setCellRenderer(targetCellRenderer);\n\n      CancelCallback<TransUnit> cancelCallBack = new CancelCallback<TransUnit>()\n      {\n         @Override\n         public void onCancel(TransUnit cellValue)\n         {\n            tableModel.onCancel(cellValue);\n         }\n      };\n      EditRowCallback transValueCallBack = new EditRowCallback()\n      {\n         @Override\n         public void gotoNextRow()\n         {\n            tableModel.gotoNextRow();\n         }\n\n         @Override\n         public void gotoPrevRow()\n         {\n            tableModel.gotoPrevRow();\n         }\n\n         @Override\n         public void gotoFirstRow()\n         {\n            tableModel.gotoFirstRow();\n         }\n\n         @Override\n         public void gotoLastRow()\n         {\n            tableModel.gotoLastRow();\n         }\n\n         @Override\n         public void gotoNextFuzzyNewRow()\n         {\n            tableModel.gotoNextFuzzyNew();\n         }\n\n         @Override\n         public void gotoPrevFuzzyNewRow()\n         {\n            tableModel.gotoPrevFuzzyNew();\n         }\n\n         @Override\n         public void gotoNextFuzzyRow()\n         {\n            tableModel.gotoNextFuzzy();\n         }\n\n         @Override\n         public void gotoPrevFuzzyRow()\n         {\n            tableModel.gotoPrevFuzzy();\n         }\n\n         @Override\n         public void gotoNextNewRow()\n         {\n            tableModel.gotoNextNew();\n         }\n\n         @Override\n         public void gotoCurrentRow(boolean andEdit)\n         {\n            tableModel.gotoCurrentRow(andEdit);\n         }\n\n         @Override\n         public void gotoPrevNewRow()\n         {\n            tableModel.gotoPrevNew();\n         }\n\n         public void setRowValueOverride(int row, TransUnit targetCell)\n         {\n            tableModel.setRowValueOverride(row, targetCell);\n         }\n      };\n      this.targetCellEditor = new InlineTargetCellEditor(cancelCallBack, transValueCallBack, isReadOnly, targetContentsPresenter);\n      this.transUnitDetailsContent = new TransUnitDetailsPanel(messages.transUnitDetailsHeading());\n      targetColumnDefinition.setCellEditor(targetCellEditor);\n\n      addColumnDefinition(sourceColumnDefinition);\n      addColumnDefinition(targetColumnDefinition);\n   }","id":28020,"modified_method":"public TableEditorTableDefinition(final NavigationMessages messages, final RedirectingCachedTableModel<TransUnit> tableModel, final SourceContentsPresenter sourceContentsPresenter, boolean isReadOnly, TargetContentsPresenter targetContentsPresenter)\n   {\n      this.isReadOnly = isReadOnly;\n      this.sourceContentsPresenter = sourceContentsPresenter;\n      this.targetContentsPresenter = targetContentsPresenter;\n      setRowRenderer(rowRenderer);\n      sourceColumnDefinition.setCellRenderer(sourceCellRenderer);\n      targetColumnDefinition.setCellRenderer(targetCellRenderer);\n\n      CancelCallback<TransUnit> cancelCallBack = new CancelCallback<TransUnit>()\n      {\n         @Override\n         public void onCancel(TransUnit cellValue)\n         {\n            tableModel.onCancel(cellValue);\n         }\n      };\n      EditRowCallback transValueCallBack = new EditRowCallback()\n      {\n         @Override\n         public void gotoNextRow()\n         {\n            tableModel.gotoNextRow();\n         }\n\n         @Override\n         public void gotoPrevRow()\n         {\n            tableModel.gotoPrevRow();\n         }\n\n         @Override\n         public void gotoFirstRow()\n         {\n            tableModel.gotoFirstRow();\n         }\n\n         @Override\n         public void gotoLastRow()\n         {\n            tableModel.gotoLastRow();\n         }\n\n         @Override\n         public void gotoNextFuzzyNewRow()\n         {\n            tableModel.gotoNextFuzzyNew();\n         }\n\n         @Override\n         public void gotoPrevFuzzyNewRow()\n         {\n            tableModel.gotoPrevFuzzyNew();\n         }\n\n         @Override\n         public void gotoNextFuzzyRow()\n         {\n            tableModel.gotoNextFuzzy();\n         }\n\n         @Override\n         public void gotoPrevFuzzyRow()\n         {\n            tableModel.gotoPrevFuzzy();\n         }\n\n         @Override\n         public void gotoNextNewRow()\n         {\n            tableModel.gotoNextNew();\n         }\n\n         @Override\n         public void gotoCurrentRow(boolean andEdit)\n         {\n            tableModel.gotoCurrentRow(andEdit);\n         }\n\n         @Override\n         public void gotoPrevNewRow()\n         {\n            tableModel.gotoPrevNew();\n         }\n\n         public void setRowValueOverride(int row, TransUnit targetCell)\n         {\n            tableModel.setRowValueOverride(row, targetCell);\n         }\n      };\n      this.targetCellEditor = new InlineTargetCellEditor(cancelCallBack, transValueCallBack, isReadOnly, targetContentsPresenter);\n//      this.transUnitDetailsContent = new TransUnitDetailsPanel(messages.transUnitDetailsHeading());\n      targetColumnDefinition.setCellEditor(targetCellEditor);\n\n      addColumnDefinition(sourceColumnDefinition);\n      addColumnDefinition(targetColumnDefinition);\n   }","commit_id":"667c08ef40b47991fc1a53efe59515c43e142938","url":"https://github.com/zanata/zanata-server"},{"original_method":"public TransUnitDetailsPanel(String header)\n   {\n      initWidget(uiBinder.createAndBindUi(this));\n      headerLabel.setText(header);\n   }","id":28021,"modified_method":"@Inject\n   public TransUnitDetailsPanel(TableEditorMessages messages)\n   {\n      this.messages = messages;\n      initWidget(uiBinder.createAndBindUi(this));\n      headerLabel.setText(messages.transUnitDetailsHeading());\n   }","commit_id":"667c08ef40b47991fc1a53efe59515c43e142938","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setDetails(TransUnit transUnit)\n   {\n      resIdLabel.setText(\"Resource ID: \");\n      resId.setText(transUnit.getResId());\n      \n      String context = transUnit.getMsgContext();\n\n      if (context == null)\n      {\n         msgContextPanel.setVisible(false);\n      }\n      else\n      {\n         msgContextLabel.setText(\"Message Context: \");\n         msgContext.setText(context);\n         \n         msgContextPanel.setVisible(true);\n      }\n\n\n      sourceCommentLabel.setText(\"Source Comment: \");\n      sourceComment.setText(transUnit.getSourceComment());\n      String person = transUnit.getLastModifiedBy();\n      if (person != null && !person.isEmpty())\n      {\n         lastModifiedByLabel.setText(\"Last Modified By:\");\n         lastModifiedBy.setText(person);\n         lastModifiedTimeLabel.setText(\"Last Modified Time:\");\n         lastModifiedTime.setText(transUnit.getLastModifiedTime());\n      }\n      else\n      {\n         lastModifiedByLabel.setText(\"\");\n         lastModifiedBy.setText(\"\");\n         lastModifiedTimeLabel.setText(\"\");\n         lastModifiedTime.setText(\"\");\n      }\n\n      expand();\n   }","id":28022,"modified_method":"public void setDetails(TransUnit transUnit)\n   {\n      resIdLabel.setText(\"Resource ID: \");\n      resId.setText(transUnit.getResId());\n      \n      String context = transUnit.getMsgContext();\n\n      if (context == null)\n      {\n         msgContextPanel.setVisible(false);\n      }\n      else\n      {\n         msgContextLabel.setText(\"Message Context: \");\n         msgContext.setText(context);\n         \n         msgContextPanel.setVisible(true);\n      }\n\n\n      sourceCommentLabel.setText(\"Source Comment: \");\n      sourceComment.setText(transUnit.getSourceComment());\n      String person = transUnit.getLastModifiedBy();\n      if (person != null && !person.isEmpty())\n      {\n         lastModifiedByLabel.setText(\"Last Modified By:\");\n         lastModifiedBy.setText(person);\n         lastModifiedTimeLabel.setText(\"Last Modified Time:\");\n         lastModifiedTime.setText(transUnit.getLastModifiedTime());\n      }\n      else\n      {\n         lastModifiedByLabel.setText(\"\");\n         lastModifiedBy.setText(\"\");\n         lastModifiedTimeLabel.setText(\"\");\n         lastModifiedTime.setText(\"\");\n      }\n\n      if (!Strings.isNullOrEmpty(context) || !Strings.isNullOrEmpty(transUnit.getSourceComment()))\n      {\n         headerLabel.setText(messages.transUnitDetailsHeadingWithInfo(transUnit.getRowIndex(), transUnit.getId().toString(), \"(I)\"));\n      }\n      else\n      {\n         headerLabel.setText(messages.transUnitDetailsHeadingWithInfo(transUnit.getRowIndex(), transUnit.getId().toString(), \"\"));\n      }\n//      expand();\n      collapse();\n   }","commit_id":"667c08ef40b47991fc1a53efe59515c43e142938","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Sets window size and position.\n     */\n    private void setSizeAndLocation()\n    {\n        ConfigurationService configService =\n            UtilActivator.getConfigurationService();\n\n        String className = this.getClass().getName().replaceAll(\"\\\\$\", \"_\");\n        \n        String widthString = configService.getString(\n            className + \".width\");\n\n        String heightString = configService.getString(\n            className + \".height\");\n\n        String xString = configService.getString(\n            className + \".x\");\n\n        String yString = configService.getString(\n            className + \".y\");\n\n        int width = 0;\n        int height = 0;\n        \n        if(widthString != null && heightString != null)\n        {   \n            width = new Integer(widthString).intValue();\n            height = new Integer(heightString).intValue();\n            \n            if(width > 0 && height > 0)\n                this.setSize(width, height);\n        }\n        \n        if(xString != null && yString != null)\n        {\n            this.setLocation(new Integer(xString).intValue(),\n                new Integer(yString).intValue());\n        }\n        else {\n            this.setCenterLocation();\n        }\n    }","id":28023,"modified_method":"/**\n     * Sets window size and position.\n     */\n    private void setSizeAndLocation()\n    {\n        ConfigurationService config = UtilActivator.getConfigurationService();\n        String className = this.getClass().getName().replaceAll(\"\\\\$\", \"_\");\n        \n        int width = config.getInt(className + \".width\", 0);\n        int height = config.getInt(className + \".height\", 0);\n\n        String xString = config.getString(className + \".x\");\n        String yString = config.getString(className + \".y\");\n\n        if(width > 0 && height > 0)\n            this.setSize(width, height);\n        \n        if(xString != null && yString != null)\n            this.setLocation(\n                    Integer.parseInt(xString),\n                    Integer.parseInt(yString));\n        else\n            this.setCenterLocation();\n    }","commit_id":"148a0b486af7d0702d9ac05c88eee51193b053b9","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Positions this window in the center of the screen.\n     */\n    private void setCenterLocation()\n    {\n        this.setLocation(\n                Toolkit.getDefaultToolkit().getScreenSize().width/2\n                    - this.getWidth()/2,\n                Toolkit.getDefaultToolkit().getScreenSize().height/2\n                    - this.getHeight()/2\n                );\n    }","id":28024,"modified_method":"/**\n     * Positions this window in the center of the screen.\n     */\n    private void setCenterLocation()\n    {\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n\n        this.setLocation(\n                screenSize.width/2 - this.getWidth()/2,\n                screenSize.height/2 - this.getHeight()/2);\n    }","commit_id":"148a0b486af7d0702d9ac05c88eee51193b053b9","url":"https://github.com/jitsi/jitsi"},{"original_method":"static void saveSizeAndLocation(Component component)\n        throws PropertyVetoException\n    {\n        ConfigurationService config = UtilActivator.getConfigurationService();\n        String className = component.getClass().getName().replaceAll(\"\\\\$\", \"_\");\n\n        config.setProperty(className + \".width\", component.getWidth());\n        config.setProperty(className + \".height\", component.getHeight());\n        config.setProperty(className + \".x\", component.getX());\n        config.setProperty(className + \".y\", component.getY());\n    }","id":28025,"modified_method":"/**\n     * Saves the size and the location of a specific <tt>Component<\/tt> through\n     * the <tt>ConfigurationService<\/tt>.\n     *\n     * @param component the <tt>Component<\/tt> which is to have its size and\n     * location saved through the <tt>ConfigurationService<\/tt>\n     * @throws PropertyVetoException if the <tt>ConfigurationService<\/tt> does\n     * not accept the saving because of objections from its\n     * <tt>PropertyVetoListener<\/tt>s.\n     */\n    static void saveSizeAndLocation(Component component)\n        throws PropertyVetoException\n    {\n        Map<String, Object> props = new HashMap<String, Object>();\n        String className\n            = component.getClass().getName().replaceAll(\"\\\\$\", \"_\");\n\n        props.put(className + \".width\", component.getWidth());\n        props.put(className + \".height\", component.getHeight());\n        props.put(className + \".x\", component.getX());\n        props.put(className + \".y\", component.getY());\n        UtilActivator.getConfigurationService().setProperties(props);\n    }","commit_id":"148a0b486af7d0702d9ac05c88eee51193b053b9","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Saves the size and the location of this frame through the\n     * <tt>ConfigurationService<\/tt>.\n     */\n    private void saveSizeAndLocation()\n    {\n        try\n        {\n            saveSizeAndLocation(this);\n        }\n        catch (PropertyVetoException e1)\n        {\n            logger.error(\"The proposed property change \"\n                + \"represents an unacceptable value\");\n        }\n    }","id":28026,"modified_method":"/**\n     * Saves the size and the location of this frame through the\n     * <tt>ConfigurationService<\/tt>.\n     */\n    private void saveSizeAndLocation()\n    {\n        try\n        {\n            saveSizeAndLocation(this);\n        }\n        catch (PropertyVetoException e)\n        {\n            logger\n                .error(\n                    \"Saving the size and the location properties failed\",\n                    e);\n        }\n    }","commit_id":"148a0b486af7d0702d9ac05c88eee51193b053b9","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void centerMarkerLocation() {\n\t\tcentered = true;\n\t\tshowOnMap(menu.getLatLon(), true, false, true, false);\n\t}","id":28027,"modified_method":"public void centerMarkerLocation() {\n\t\tcentered = true;\n\t\tshowOnMap(menu.getLatLon(), true, true, false);\n\t}","commit_id":"0cd09d4eef0fd03c1daea7f5893154e616b3d429","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private LatLon getAdjustedMarkerLocation(int y, LatLon reqMarkerLocation, boolean center) {\n\t\tdouble markerLat = reqMarkerLocation.getLatitude();\n\t\tdouble markerLon = reqMarkerLocation.getLongitude();\n\t\tRotatedTileBox box = map.getCurrentRotatedTileBox().copy();\n\n\t\tLatLon latlon;\n\t\tif (center) {\n\t\t\tlatlon = reqMarkerLocation;\n\t\t} else {\n\t\t\tlatlon = mapCenter;\n\t\t}\n\t\tif (menu.isLandscapeLayout()) {\n\t\t\tint markerX = (int)box.getPixXFromLatLon(markerLat, markerLon);\n\t\t\tint x = dpToPx(menu.getLandscapeWidthDp());\n\t\t\tif (markerX - markerPaddingXPx < x || markerX > origMarkerX) {\n\t\t\t\tint dx = (x + markerPaddingXPx) - markerX;\n\t\t\t\tint dy = 0;\n\t\t\t\tQuadPoint cp = box.getCenterPixelPoint();\n\t\t\t\tif (center) {\n\t\t\t\t\tint markerY = (int)box.getPixYFromLatLon(markerLat, markerLon);\n\t\t\t\t\tdy = (int)cp.y - markerY;\n\t\t\t\t}\n\t\t\t\tif (dx > 0 || center) {\n\t\t\t\t\tlatlon = box.getLatLonFromPixel(cp.x - dx, cp.y - dy);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint markerY = (int)box.getPixYFromLatLon(markerLat, markerLon);\n\t\t\tif (markerY + markerPaddingPx > y || markerY < origMarkerY) {\n\t\t\t\tint dx = 0;\n\t\t\t\tint dy = markerY - (y - markerPaddingPx);\n\t\t\t\tif (markerY - dy <= origMarkerY) {\n\t\t\t\t\tQuadPoint cp = box.getCenterPixelPoint();\n\t\t\t\t\tif (center) {\n\t\t\t\t\t\tint markerX = (int)box.getPixXFromLatLon(markerLat, markerLon);\n\t\t\t\t\t\tdx = markerX - (int)cp.x;\n\t\t\t\t\t}\n\t\t\t\t\tlatlon = box.getLatLonFromPixel(cp.x + dx, cp.y + dy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn latlon;\n\t}","id":28028,"modified_method":"private LatLon getAdjustedMarkerLocation(int y, LatLon reqMarkerLocation, boolean center) {\n\t\tdouble markerLat = reqMarkerLocation.getLatitude();\n\t\tdouble markerLon = reqMarkerLocation.getLongitude();\n\t\tRotatedTileBox box = map.getCurrentRotatedTileBox().copy();\n\t\tbox.setCenterLocation(0.5f, map.getMapPosition() == OsmandSettings.BOTTOM_CONSTANT ? 0.15f : 0.5f);\n\t\tint markerMapCenterX = (int)box.getPixXFromLatLon(mapCenter.getLatitude(), mapCenter.getLongitude());\n\t\tint markerMapCenterY = (int)box.getPixYFromLatLon(mapCenter.getLatitude(), mapCenter.getLongitude());\n\t\tfloat cpyOrig = box.getCenterPixelPoint().y;\n\n\t\tbox.setCenterLocation(0.5f, 0.5f);\n\t\tint markerX = (int)box.getPixXFromLatLon(markerLat, markerLon);\n\t\tint markerY = (int)box.getPixYFromLatLon(markerLat, markerLon);\n\t\tQuadPoint cp = box.getCenterPixelPoint();\n\t\tfloat cpx = cp.x;\n\t\tfloat cpy = cp.y;\n\n\t\tfloat cpyDelta = menu.isLandscapeLayout() ? 0 : cpyOrig - cpy;\n\n\t\tmarkerY += cpyDelta;\n\t\ty += cpyDelta;\n\t\tfloat origMarkerY = this.origMarkerY + cpyDelta;\n\n\t\tLatLon latlon;\n\t\tif (center) {\n\t\t\tlatlon = reqMarkerLocation;\n\t\t} else {\n\t\t\tlatlon = box.getLatLonFromPixel(markerMapCenterX, markerMapCenterY);\n\t\t}\n\t\tif (menu.isLandscapeLayout()) {\n\t\t\tint x = dpToPx(menu.getLandscapeWidthDp());\n\t\t\tif (markerX - markerPaddingXPx < x || markerX > origMarkerX) {\n\t\t\t\tint dx = (x + markerPaddingXPx) - markerX;\n\t\t\t\tint dy = 0;\n\t\t\t\tif (center) {\n\t\t\t\t\tdy = (int)cpy - markerY;\n\t\t\t\t} else {\n\t\t\t\t\tcpy = cpyOrig;\n\t\t\t\t}\n\t\t\t\tif (dx > 0 || center) {\n\t\t\t\t\tlatlon = box.getLatLonFromPixel(cpx - dx, cpy - dy);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (markerY + markerPaddingPx > y || markerY < origMarkerY) {\n\t\t\t\tint dx = 0;\n\t\t\t\tint dy = markerY - (y - markerPaddingPx);\n\t\t\t\tif (markerY - dy <= origMarkerY) {\n\t\t\t\t\tif (center) {\n\t\t\t\t\t\tdx = markerX - (int)cpx;\n\t\t\t\t\t}\n\t\t\t\t\tlatlon = box.getLatLonFromPixel(cpx + dx, cpy + dy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn latlon;\n\t}","commit_id":"0cd09d4eef0fd03c1daea7f5893154e616b3d429","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void adjustMapPosition(int y, boolean animated, boolean center) {\n\t\tLatLon latlon = getAdjustedMarkerLocation(y, menu.getLatLon(), center);\n\n\t\tif (map.getLatitude() == latlon.getLatitude() && map.getLongitude() == latlon.getLongitude()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (animated) {\n\t\t\tshowOnMap(latlon, false, true, true, true);\n\t\t} else {\n\t\t\tmap.setLatLon(latlon.getLatitude(), latlon.getLongitude());\n\t\t}\n\t}","id":28029,"modified_method":"private void adjustMapPosition(int y, boolean animated, boolean center) {\n\t\tLatLon latlon = getAdjustedMarkerLocation(y, menu.getLatLon(), center);\n\n\t\tif (map.getLatitude() == latlon.getLatitude() && map.getLongitude() == latlon.getLongitude()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (animated) {\n\t\t\tshowOnMap(latlon, false, true, true);\n\t\t} else {\n\t\t\tmap.setLatLon(latlon.getLatitude(), latlon.getLongitude());\n\t\t}\n\t}","commit_id":"0cd09d4eef0fd03c1daea7f5893154e616b3d429","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void showOnMap(LatLon latLon, boolean updateCoords, boolean ignoreCoef, boolean needMove, boolean alreadyAdjusted) {\n\t\tAnimateDraggingMapThread thread = map.getAnimatedDraggingThread();\n\t\tint fZoom = map.getZoom();\n\t\tdouble flat = latLon.getLatitude();\n\t\tdouble flon = latLon.getLongitude();\n\n\t\tRotatedTileBox cp = map.getCurrentRotatedTileBox().copy();\n\t\tif (ignoreCoef) {\n\t\t\tcp.setCenterLocation(0.5f, 0.5f);\n\t\t} else {\n\t\t\tcp.setCenterLocation(0.5f, map.getMapPosition() == OsmandSettings.BOTTOM_CONSTANT ? 0.15f : 0.5f);\n\t\t}\n\t\tcp.setLatLonCenter(flat, flon);\n\t\tflat = cp.getLatFromPixel(cp.getPixWidth() / 2, cp.getPixHeight() / 2);\n\t\tflon = cp.getLonFromPixel(cp.getPixWidth() / 2, cp.getPixHeight() / 2);\n\n\t\tif (updateCoords) {\n\t\t\tmapCenter = new LatLon(flat, flon);\n\t\t\tmenu.setMapCenter(mapCenter);\n\t\t\torigMarkerX = cp.getCenterPixelX();\n\t\t\torigMarkerY = cp.getCenterPixelY();\n\t\t}\n\n\t\tif (!alreadyAdjusted) {\n\t\t\tLatLon adjustedLatLon = getAdjustedMarkerLocation(getPosY(), new LatLon(flat, flon), true);\n\t\t\tflat = adjustedLatLon.getLatitude();\n\t\t\tflon = adjustedLatLon.getLongitude();\n\t\t}\n\n\t\tif (needMove) {\n\t\t\tthread.startMoving(flat, flon, fZoom, true);\n\t\t}\n\t}","id":28030,"modified_method":"private void showOnMap(LatLon latLon, boolean updateCoords, boolean needMove, boolean alreadyAdjusted) {\n\t\tAnimateDraggingMapThread thread = map.getAnimatedDraggingThread();\n\t\tint fZoom = map.getZoom();\n\t\tdouble flat = latLon.getLatitude();\n\t\tdouble flon = latLon.getLongitude();\n\n\t\tRotatedTileBox cp = map.getCurrentRotatedTileBox().copy();\n\t\tcp.setCenterLocation(0.5f, map.getMapPosition() == OsmandSettings.BOTTOM_CONSTANT ? 0.15f : 0.5f);\n\t\tcp.setLatLonCenter(flat, flon);\n\t\tflat = cp.getLatFromPixel(cp.getPixWidth() / 2, cp.getPixHeight() / 2);\n\t\tflon = cp.getLonFromPixel(cp.getPixWidth() / 2, cp.getPixHeight() / 2);\n\n\t\tif (updateCoords) {\n\t\t\tmapCenter = new LatLon(flat, flon);\n\t\t\tmenu.setMapCenter(mapCenter);\n\t\t\torigMarkerX = cp.getCenterPixelX();\n\t\t\torigMarkerY = cp.getCenterPixelY();\n\t\t}\n\n\t\tif (!alreadyAdjusted) {\n\t\t\tLatLon adjustedLatLon = getAdjustedMarkerLocation(getPosY(), new LatLon(flat, flon), true);\n\t\t\tflat = adjustedLatLon.getLatitude();\n\t\t\tflon = adjustedLatLon.getLongitude();\n\t\t}\n\n\t\tif (needMove) {\n\t\t\tthread.startMoving(flat, flon, fZoom, true);\n\t\t}\n\t}","commit_id":"0cd09d4eef0fd03c1daea7f5893154e616b3d429","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public PointEditor(MapActivity mapActivity) {\n\t\tthis.app = mapActivity.getMyApplication();\n\t\tthis.mapActivity = mapActivity;\n\t\tportraitMode = AndroidUiHelper.isOrientationPortrait(mapActivity);\n\t\tlargeDevice = AndroidUiHelper.isXLargeDevice(mapActivity);\n\t\tupdateNightMode();\n\t}","id":28031,"modified_method":"public PointEditor(MapActivity mapActivity) {\n\t\tthis.app = mapActivity.getMyApplication();\n\t\tthis.mapActivity = mapActivity;\n\t\tlargeDevice = AndroidUiHelper.isXLargeDevice(mapActivity);\n\t\tupdateLandscapePortrait();\n\t\tupdateNightMode();\n\t}","commit_id":"0cd09d4eef0fd03c1daea7f5893154e616b3d429","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@TargetApi(Build.VERSION_CODES.HONEYCOMB)\n\t@Override\n\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\n\t\t\t\t\t\t\t Bundle savedInstanceState) {\n\n\t\tgetActivity().findViewById(R.id.MapHudButtonsOverlay).setVisibility(View.INVISIBLE);\n\n\t\tview = inflater.inflate(R.layout.point_editor_fragment, container, false);\n\n\t\tgetEditor().updateNightMode();\n\t\tif (getEditor().isLandscapeLayout()) {\n\t\t\tAndroidUtils.setBackground(view.getContext(), view, !getEditor().isLight(),\n\t\t\t\t\tR.drawable.bg_left_menu_light, R.drawable.bg_left_menu_dark);\n\t\t} else {\n\t\t\tAndroidUtils.setBackground(view.getContext(), view.findViewById(R.id.title_view), !getEditor().isLight(),\n\t\t\t\t\tR.drawable.bg_point_editor_view_light, R.drawable.bg_point_editor_view_dark);\n\t\t}\n\n\t\tView editorScrollView = view.findViewById(R.id.editor_scroll_view);\n\t\tif (editorScrollView != null) {\n\t\t\tif (getEditor().isLight()) {\n\t\t\t\teditorScrollView.setBackgroundColor(getResources().getColor(R.color.ctx_menu_info_view_bg_light));\n\t\t\t} else {\n\t\t\t\teditorScrollView.setBackgroundColor(getResources().getColor(R.color.ctx_menu_info_view_bg_dark));\n\t\t\t}\n\t\t}\n\t\tView descriptionInfoView = view.findViewById(R.id.description_info_view);\n\t\tif (descriptionInfoView != null) {\n\t\t\tif (getEditor().isLight()) {\n\t\t\t\tdescriptionInfoView.setBackgroundColor(getResources().getColor(R.color.ctx_menu_info_view_bg_light));\n\t\t\t} else {\n\t\t\t\tdescriptionInfoView.setBackgroundColor(getResources().getColor(R.color.ctx_menu_info_view_bg_dark));\n\t\t\t}\n\t\t}\n\n\t\tToolbar toolbar = (Toolbar) view.findViewById(R.id.toolbar);\n\t\ttoolbar.setTitle(getToolbarTitle());\n\t\ttoolbar.setNavigationIcon(getMyApplication().getIconsCache().getIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha));\n\t\ttoolbar.setTitleTextColor(getResources().getColor(getResIdFromAttribute(getMapActivity(), R.attr.pstsTextColor)));\n\t\ttoolbar.setNavigationOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tdismiss();\n\t\t\t}\n\t\t});\n\n\t\tButton saveButton = (Button) toolbar.findViewById(R.id.save_button);\n\t\tsaveButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tsavePressed();\n\t\t\t}\n\t\t});\n\n\t\tImageButton okButton = (ImageButton) toolbar.findViewById(R.id.ok_button);\n\t\tokButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tsavePressed();\n\t\t\t}\n\t\t});\n\n\t\tImageButton deleteButton = (ImageButton) toolbar.findViewById(R.id.delete_button);\n\t\tdeleteButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tdeletePressed();\n\t\t\t}\n\t\t});\n\n\t\tif (getEditor().isNew()) {\n\t\t\tokButton.setVisibility(View.GONE);\n\t\t\tdeleteButton.setVisibility(View.GONE);\n\t\t} else {\n\t\t\tsaveButton.setVisibility(View.GONE);\n\t\t}\n\n\t\tTextView headerCaption = (TextView) view.findViewById(R.id.header_caption);\n\t\tAndroidUtils.setTextPrimaryColor(view.getContext(), headerCaption, !getEditor().isLight());\n\t\theaderCaption.setText(getHeaderCaption());\n\t\tTextView nameCaption = (TextView) view.findViewById(R.id.name_caption);\n\t\tAndroidUtils.setTextSecondaryColor(view.getContext(), nameCaption, !getEditor().isLight());\n\t\tnameCaption.setText(getNameCaption());\n\t\tTextView categoryCaption = (TextView) view.findViewById(R.id.category_caption);\n\t\tAndroidUtils.setTextSecondaryColor(view.getContext(), categoryCaption, !getEditor().isLight());\n\t\tcategoryCaption.setText(getCategoryCaption());\n\n\t\tnameEdit = (EditText) view.findViewById(R.id.name_edit);\n\t\tAndroidUtils.setTextPrimaryColor(view.getContext(), nameEdit, !getEditor().isLight());\n\t\tAndroidUtils.setHintTextSecondaryColor(view.getContext(), nameEdit, !getEditor().isLight());\n\t\tnameEdit.setText(getNameInitValue());\n\t\tAutoCompleteTextViewEx categoryEdit = (AutoCompleteTextViewEx) view.findViewById(R.id.category_edit);\n\t\tAndroidUtils.setTextPrimaryColor(view.getContext(), categoryEdit, !getEditor().isLight());\n\t\tcategoryEdit.setText(getCategoryInitValue());\n\t\tcategoryEdit.setFocusable(false);\n\t\tcategoryEdit.setOnTouchListener(new View.OnTouchListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onTouch(final View v, MotionEvent event) {\n\t\t\t\tif (event.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\tDialogFragment dialogFragment =\n\t\t\t\t\t\t\tSelectCategoryDialogFragment.createInstance(getEditor().getFragmentTag());\n\t\t\t\t\tdialogFragment.show(getChildFragmentManager(), SelectCategoryDialogFragment.TAG);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\tEditText descriptionEdit = (EditText) view.findViewById(R.id.description_edit);\n\t\tAndroidUtils.setTextPrimaryColor(view.getContext(), descriptionEdit, !getEditor().isLight());\n\t\tAndroidUtils.setHintTextSecondaryColor(view.getContext(), descriptionEdit, !getEditor().isLight());\n\t\tif (getDescriptionInitValue() != null) {\n\t\t\tdescriptionEdit.setText(getDescriptionInitValue());\n\t\t}\n\n\t\tImageView nameImage = (ImageView) view.findViewById(R.id.name_image);\n\t\tnameImage.setImageDrawable(getNameIcon());\n\t\tImageView categoryImage = (ImageView) view.findViewById(R.id.category_image);\n\t\tcategoryImage.setImageDrawable(getCategoryIcon());\n\n\t\tImageView descriptionImage = (ImageView) view.findViewById(R.id.description_image);\n\t\tdescriptionImage.setImageDrawable(getRowIcon(R.drawable.ic_action_note_dark));\n\n\t\trunLayoutListener();\n\n\t\treturn view;\n\t}","id":28032,"modified_method":"@TargetApi(Build.VERSION_CODES.HONEYCOMB)\n\t@Override\n\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\n\t\t\t\t\t\t\t Bundle savedInstanceState) {\n\n\t\tgetActivity().findViewById(R.id.MapHudButtonsOverlay).setVisibility(View.INVISIBLE);\n\n\t\tview = inflater.inflate(R.layout.point_editor_fragment, container, false);\n\n\t\tgetEditor().updateLandscapePortrait();\n\t\tgetEditor().updateNightMode();\n\n\t\tif (getEditor().isLandscapeLayout()) {\n\t\t\tAndroidUtils.setBackground(view.getContext(), view, !getEditor().isLight(),\n\t\t\t\t\tR.drawable.bg_left_menu_light, R.drawable.bg_left_menu_dark);\n\t\t} else {\n\t\t\tAndroidUtils.setBackground(view.getContext(), view.findViewById(R.id.title_view), !getEditor().isLight(),\n\t\t\t\t\tR.drawable.bg_point_editor_view_light, R.drawable.bg_point_editor_view_dark);\n\t\t}\n\n\t\tView editorScrollView = view.findViewById(R.id.editor_scroll_view);\n\t\tif (editorScrollView != null) {\n\t\t\tif (getEditor().isLight()) {\n\t\t\t\teditorScrollView.setBackgroundColor(getResources().getColor(R.color.ctx_menu_info_view_bg_light));\n\t\t\t} else {\n\t\t\t\teditorScrollView.setBackgroundColor(getResources().getColor(R.color.ctx_menu_info_view_bg_dark));\n\t\t\t}\n\t\t}\n\t\tView descriptionInfoView = view.findViewById(R.id.description_info_view);\n\t\tif (descriptionInfoView != null) {\n\t\t\tif (getEditor().isLight()) {\n\t\t\t\tdescriptionInfoView.setBackgroundColor(getResources().getColor(R.color.ctx_menu_info_view_bg_light));\n\t\t\t} else {\n\t\t\t\tdescriptionInfoView.setBackgroundColor(getResources().getColor(R.color.ctx_menu_info_view_bg_dark));\n\t\t\t}\n\t\t}\n\n\t\tToolbar toolbar = (Toolbar) view.findViewById(R.id.toolbar);\n\t\ttoolbar.setTitle(getToolbarTitle());\n\t\ttoolbar.setNavigationIcon(getMyApplication().getIconsCache().getIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha));\n\t\ttoolbar.setTitleTextColor(getResources().getColor(getResIdFromAttribute(getMapActivity(), R.attr.pstsTextColor)));\n\t\ttoolbar.setNavigationOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tdismiss();\n\t\t\t}\n\t\t});\n\n\t\tButton saveButton = (Button) toolbar.findViewById(R.id.save_button);\n\t\tsaveButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tsavePressed();\n\t\t\t}\n\t\t});\n\n\t\tImageButton okButton = (ImageButton) toolbar.findViewById(R.id.ok_button);\n\t\tokButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tsavePressed();\n\t\t\t}\n\t\t});\n\n\t\tImageButton deleteButton = (ImageButton) toolbar.findViewById(R.id.delete_button);\n\t\tdeleteButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tdeletePressed();\n\t\t\t}\n\t\t});\n\n\t\tif (getEditor().isNew()) {\n\t\t\tokButton.setVisibility(View.GONE);\n\t\t\tdeleteButton.setVisibility(View.GONE);\n\t\t} else {\n\t\t\tsaveButton.setVisibility(View.GONE);\n\t\t}\n\n\t\tTextView headerCaption = (TextView) view.findViewById(R.id.header_caption);\n\t\tAndroidUtils.setTextPrimaryColor(view.getContext(), headerCaption, !getEditor().isLight());\n\t\theaderCaption.setText(getHeaderCaption());\n\t\tTextView nameCaption = (TextView) view.findViewById(R.id.name_caption);\n\t\tAndroidUtils.setTextSecondaryColor(view.getContext(), nameCaption, !getEditor().isLight());\n\t\tnameCaption.setText(getNameCaption());\n\t\tTextView categoryCaption = (TextView) view.findViewById(R.id.category_caption);\n\t\tAndroidUtils.setTextSecondaryColor(view.getContext(), categoryCaption, !getEditor().isLight());\n\t\tcategoryCaption.setText(getCategoryCaption());\n\n\t\tnameEdit = (EditText) view.findViewById(R.id.name_edit);\n\t\tAndroidUtils.setTextPrimaryColor(view.getContext(), nameEdit, !getEditor().isLight());\n\t\tAndroidUtils.setHintTextSecondaryColor(view.getContext(), nameEdit, !getEditor().isLight());\n\t\tnameEdit.setText(getNameInitValue());\n\t\tAutoCompleteTextViewEx categoryEdit = (AutoCompleteTextViewEx) view.findViewById(R.id.category_edit);\n\t\tAndroidUtils.setTextPrimaryColor(view.getContext(), categoryEdit, !getEditor().isLight());\n\t\tcategoryEdit.setText(getCategoryInitValue());\n\t\tcategoryEdit.setFocusable(false);\n\t\tcategoryEdit.setOnTouchListener(new View.OnTouchListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onTouch(final View v, MotionEvent event) {\n\t\t\t\tif (event.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\tDialogFragment dialogFragment =\n\t\t\t\t\t\t\tSelectCategoryDialogFragment.createInstance(getEditor().getFragmentTag());\n\t\t\t\t\tdialogFragment.show(getChildFragmentManager(), SelectCategoryDialogFragment.TAG);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\tEditText descriptionEdit = (EditText) view.findViewById(R.id.description_edit);\n\t\tAndroidUtils.setTextPrimaryColor(view.getContext(), descriptionEdit, !getEditor().isLight());\n\t\tAndroidUtils.setHintTextSecondaryColor(view.getContext(), descriptionEdit, !getEditor().isLight());\n\t\tif (getDescriptionInitValue() != null) {\n\t\t\tdescriptionEdit.setText(getDescriptionInitValue());\n\t\t}\n\n\t\tImageView nameImage = (ImageView) view.findViewById(R.id.name_image);\n\t\tnameImage.setImageDrawable(getNameIcon());\n\t\tImageView categoryImage = (ImageView) view.findViewById(R.id.category_image);\n\t\tcategoryImage.setImageDrawable(getCategoryIcon());\n\n\t\tImageView descriptionImage = (ImageView) view.findViewById(R.id.description_image);\n\t\tdescriptionImage.setImageDrawable(getRowIcon(R.drawable.ic_action_note_dark));\n\n\t\trunLayoutListener();\n\n\t\treturn view;\n\t}","commit_id":"0cd09d4eef0fd03c1daea7f5893154e616b3d429","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n     * Sets window size and position.\n     */\n    private void setSizeAndLocation()\n    {\n        ConfigurationService configService\n            = GuiActivator.getConfigurationService();\n\n        String className = this.getClass().getName();\n        \n        String width = configService.getString(\n            className + \".width\");\n\n        String height = configService.getString(\n            className + \".height\");\n\n        String x = configService.getString(\n            className + \".x\");\n\n        String y = configService.getString(\n            className + \".y\");\n\n        if(width != null && height != null)\n            this.setSize(new Integer(width).intValue(),\n                    new Integer(height).intValue());            \n\n        if(x != null && y != null)\n            this.setLocation(new Integer(x).intValue(),\n                    new Integer(y).intValue());\n        else {            \n            this.setCenterLocation();\n        }\n    }","id":28033,"modified_method":"/**\n     * Sets window size and position.\n     */\n    private void setSizeAndLocation()\n    {\n        ConfigurationService configService\n            = GuiActivator.getConfigurationService();\n\n        String className = this.getClass().getName();\n        \n        String widthString = configService.getString(\n            className + \".width\");\n\n        String heightString = configService.getString(\n            className + \".height\");\n\n        String xString = configService.getString(\n            className + \".x\");\n\n        String yString = configService.getString(\n            className + \".y\");\n\n        int width = 0;\n        int height = 0;\n        \n        if(widthString != null && heightString != null)\n        {   \n            width = new Integer(width).intValue();\n            height = new Integer(height).intValue();\n            \n            if(width > 0 && height > 0)\n                this.setSize(width, height);\n        }\n        \n        if(xString != null && yString != null)\n        {   \n            this.setLocation(new Integer(xString).intValue(),\n                new Integer(yString).intValue());\n        }        \n        else {            \n            this.setCenterLocation();\n        }\n    }","commit_id":"30047d06f6d88469806ed029dccd357405de4dba","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets window size and position.\n     */\n    public void setSizeAndLocation() {\n        ConfigurationService configService\n            = GuiActivator.getConfigurationService();\n\n        String className = this.getClass().getName();\n        \n        String width = configService.getString(\n            className + \".width\");\n\n        String height = configService.getString(\n            className + \".height\");\n\n        String x = configService.getString(\n            className + \".x\");\n\n        String y = configService.getString(\n            className + \".y\");\n\n        if(width != null && height != null)\n            this.setSize(new Integer(width).intValue(),\n                    new Integer(height).intValue());            \n\n        if(x != null && y != null)\n            this.setLocation(new Integer(x).intValue(),\n                    new Integer(y).intValue());\n        else\n            this.setCenterLocation();\n    }","id":28034,"modified_method":"/**\n     * Sets window size and position.\n     */\n    public void setSizeAndLocation() {\n        ConfigurationService configService\n            = GuiActivator.getConfigurationService();\n\n        String className = this.getClass().getName();\n        \n        String widthString = configService.getString(\n            className + \".width\");\n\n        String heightString = configService.getString(\n            className + \".height\");\n\n        String xString = configService.getString(\n            className + \".x\");\n\n        String yString = configService.getString(\n            className + \".y\");\n\n        int width = 0;\n        int height = 0;\n        \n        if(widthString != null && heightString != null)\n        {   \n            width = new Integer(width).intValue();\n            height = new Integer(height).intValue();\n            \n            if(width > 0 && height > 0)\n                this.setSize(width, height);\n        }\n        \n        if(xString != null && yString != null)\n        {   \n            this.setLocation(new Integer(xString).intValue(),\n                new Integer(yString).intValue());\n        }        \n        else {            \n            this.setCenterLocation();\n        }\n    }","commit_id":"30047d06f6d88469806ed029dccd357405de4dba","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void testSurefirePlugin()\n        throws Exception\n    {\n        MavenSession session = createMavenSession( getProject( \"project-with-inheritance\" ) );\n        String goal = \"test\";\n\n        Plugin plugin = new Plugin();\n        plugin.setGroupId( \"org.apache.maven.plugins\" );\n        plugin.setArtifactId( \"maven-surefire-plugin\" );\n        plugin.setVersion( \"2.4.2\" );\n\n        // The project has already been fully interpolated so getting the raw mojoDescriptor is not going to have the processes configuration.\n        MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, session.getCurrentProject(), session.getLocalRepository() );        \n        assertPluginDescriptor( mojoDescriptor, \"org.apache.maven.plugins\", \"maven-surefire-plugin\", \"2.4.2\" );\n        \n        System.out.println( session.getCurrentProject().getBuild().getPluginsAsMap() );\n        \n        Xpp3Dom configuration = (Xpp3Dom) session.getCurrentProject().getBuild().getPluginsAsMap().get( plugin.getKey() ).getExecutions().get( 0 ).getConfiguration();\n        MojoExecution mojoExecution = new MojoExecution( mojoDescriptor, configuration );\n        pluginManager.executeMojo( session, mojoExecution );\n    }","id":28035,"modified_method":"public void testSurefirePlugin()\n        throws Exception\n    {\n        MavenSession session = createMavenSession( getProject( \"project-with-inheritance\" ) );\n        String goal = \"test\";\n\n        Plugin plugin = new Plugin();\n        plugin.setGroupId( \"org.apache.maven.plugins\" );\n        plugin.setArtifactId( \"maven-surefire-plugin\" );\n        plugin.setVersion( \"2.4.2\" );\n\n        // The project has already been fully interpolated so getting the raw mojoDescriptor is not going to have the processes configuration.\n        MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, session.getLocalRepository(), session.getCurrentProject().getRemoteArtifactRepositories() );        \n        assertPluginDescriptor( mojoDescriptor, \"org.apache.maven.plugins\", \"maven-surefire-plugin\", \"2.4.2\" );\n        \n        System.out.println( session.getCurrentProject().getBuild().getPluginsAsMap() );\n        \n        Xpp3Dom configuration = (Xpp3Dom) session.getCurrentProject().getBuild().getPluginsAsMap().get( plugin.getKey() ).getExecutions().get( 0 ).getConfiguration();\n        MojoExecution mojoExecution = new MojoExecution( mojoDescriptor, configuration );\n        pluginManager.executeMojo( session, mojoExecution );\n    }","commit_id":"97f00265c8e25d9bac8601a4eecbfa8d7c10677d","url":"https://github.com/apache/maven"},{"original_method":"public void testPluginLoading()\n        throws Exception\n    {\n        MavenSession session = createMavenSession( getProject( \"project-with-inheritance\" ) );       \n        Plugin plugin = new Plugin();\n        plugin.setGroupId( \"org.codehaus.plexus\" );\n        plugin.setArtifactId( \"plexus-component-metadata\" );\n        plugin.setVersion( plexusVersion );\n        PluginDescriptor pluginDescriptor = pluginManager.loadPlugin( plugin, session.getCurrentProject(), session.getLocalRepository() );\n        assertNotNull( pluginDescriptor );\n        assertNotNull( pluginDescriptor.getClassRealm() );\n    }","id":28036,"modified_method":"public void testPluginLoading()\n        throws Exception\n    {\n        MavenSession session = createMavenSession( getProject( \"project-with-inheritance\" ) );       \n        Plugin plugin = new Plugin();\n        plugin.setGroupId( \"org.codehaus.plexus\" );\n        plugin.setArtifactId( \"plexus-component-metadata\" );\n        plugin.setVersion( plexusVersion );\n        PluginDescriptor pluginDescriptor = pluginManager.loadPlugin( plugin, session.getLocalRepository(), session.getCurrentProject().getRemoteArtifactRepositories() );\n        assertNotNull( pluginDescriptor );\n        assertNotNull( pluginDescriptor.getClassRealm() );\n    }","commit_id":"97f00265c8e25d9bac8601a4eecbfa8d7c10677d","url":"https://github.com/apache/maven"},{"original_method":"public void testMojoDescriptorRetrieval()\n        throws Exception\n    {\n        MavenSession session = createMavenSession( getProject( \"project-with-inheritance\" ) );       \n        String goal = \"generate-metadata\";\n        Plugin plugin = new Plugin();\n        plugin.setGroupId( \"org.codehaus.plexus\" );\n        plugin.setArtifactId( \"plexus-component-metadata\" );\n        plugin.setVersion( plexusVersion );\n        \n        MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, session.getCurrentProject(), session.getLocalRepository() );        \n        assertNotNull( mojoDescriptor );\n        assertEquals( \"generate-metadata\", mojoDescriptor.getGoal() );\n        assertNotNull( mojoDescriptor.getRealm() );\n        \n        PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();\n        assertNotNull( pluginDescriptor );\n        assertEquals( \"org.codehaus.plexus\", pluginDescriptor.getGroupId() );\n        assertEquals( \"plexus-component-metadata\", pluginDescriptor.getArtifactId() );\n        assertEquals( plexusVersion, pluginDescriptor.getVersion() );\n        assertNotNull( pluginDescriptor.getClassRealm() );\n    }","id":28037,"modified_method":"public void testMojoDescriptorRetrieval()\n        throws Exception\n    {\n        MavenSession session = createMavenSession( getProject( \"project-with-inheritance\" ) );       \n        String goal = \"generate-metadata\";\n        Plugin plugin = new Plugin();\n        plugin.setGroupId( \"org.codehaus.plexus\" );\n        plugin.setArtifactId( \"plexus-component-metadata\" );\n        plugin.setVersion( plexusVersion );\n        \n        MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, session.getLocalRepository(), session.getCurrentProject().getRemoteArtifactRepositories() );        \n        assertNotNull( mojoDescriptor );\n        assertEquals( \"generate-metadata\", mojoDescriptor.getGoal() );\n        assertNotNull( mojoDescriptor.getRealm() );\n        \n        PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();\n        assertNotNull( pluginDescriptor );\n        assertEquals( \"org.codehaus.plexus\", pluginDescriptor.getGroupId() );\n        assertEquals( \"plexus-component-metadata\", pluginDescriptor.getArtifactId() );\n        assertEquals( plexusVersion, pluginDescriptor.getVersion() );\n        assertNotNull( pluginDescriptor.getClassRealm() );\n    }","commit_id":"97f00265c8e25d9bac8601a4eecbfa8d7c10677d","url":"https://github.com/apache/maven"},{"original_method":"public static Scope forInterface(SNode interfaceNode, SNode... extendsInterfaces) {\n    return new InstanceMethodDeclarationScope(interfaceNode, Sequence.fromArray(extendsInterfaces));\n  }","id":28038,"modified_method":"public static Scope forInterface(SNode interfaceNode, SNode... extendsInterfaces) {\n    return new InstanceMethodDeclarationScope(interfaceNode, Sequence.fromIterable(Sequence.fromArray(extendsInterfaces)).concat(Sequence.fromIterable(Sequence.fromArray(new SNode[]{SNodeOperations.getNode(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)\", \"~Object\")}))));\n  }","commit_id":"35f19e163a2e35d913b927a40ae1245807bcf777","url":"https://github.com/JetBrains/MPS"},{"original_method":"public JSONServiceAction() {\n\t\t_invalidClassNames.addAll(\n\t\t\tListUtil.fromArray(PropsValues.JSON_SERVICE_INVALID_CLASS_NAMES));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tfor (String invalidClassName : _invalidClassNames) {\n\t\t\t\t_log.debug(\"Invalid class name \" + invalidClassName);\n\t\t\t}\n\t\t}\n\t}","id":28039,"modified_method":"public JSONServiceAction() {\n\t\t_invalidClassNames = SetUtil.fromArray(\n\t\t\tPropsValues.JSON_SERVICE_INVALID_CLASS_NAMES);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tfor (String invalidClassName : _invalidClassNames) {\n\t\t\t\t_log.debug(\"Invalid class name \" + invalidClassName);\n\t\t\t}\n\t\t}\n\t}","commit_id":"c59a21db54e3c1f252c543c464c40f5c332656f7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void doInit() {\n    try {\n      Object inst = new FacetManifest();\n      Class<?> mf = inst.getClass();\n      Facets_CustomApplicationPlugin.this.manifest = inst;\n      Method mth = mf.getMethod(\"registerFacets\", FacetRegistry.class);\n      mth.invoke(inst, FacetRegistry.getInstance());\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }","id":28040,"modified_method":"public void doInit() {\n    try {\n      org.apache.log4j.Logger.getLogger(\"jetbrains.mps.make\").setLevel(Level.INFO);\n      Object inst = new FacetManifest();\n      Class<?> mf = inst.getClass();\n      Facets_CustomApplicationPlugin.this.manifest = inst;\n      Method mth = mf.getMethod(\"registerFacets\", FacetRegistry.class);\n      mth.invoke(inst, FacetRegistry.getInstance());\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }","commit_id":"e60a2df0a536eff4d748445ece680a4779fdd008","url":"https://github.com/JetBrains/MPS"},{"original_method":"public IJob createJob() {\n      return new IJob() {\n        public IResult execute(Iterable<IResource> input, IMonitor monitor) {\n          Iterable<IResource> _output_ixz87t_a0a = null;\n          switch (0) {\n            case 0:\n              GenerationSettings settings = GenerationSettings.getInstance();\n              if (settings.isSaveTransientModels()) {\n                switch (monitor.<SaveTransient_Option>relayQuery(new SaveTransientModels_Query())) {\n                  case SAVE_ixz87t_a0a0a:\n                    System.out.println(\"Yes\");\n                    break;\n                  case DONT_SAVE_ixz87t_b0a0a:\n                    System.out.println(\"No\");\n                    break;\n                  case BUGGER_OFF_ixz87t_c0a0a:\n                    System.out.println(\"Piss off\");\n                    break;\n                  default:\n                    return new IResult.FAILURE(_output_ixz87t_a0a);\n                }\n                return new IResult.SUCCESS(_output_ixz87t_a0a);\n              }\n            default:\n              return new IResult.SUCCESS(_output_ixz87t_a0a);\n          }\n        }\n      };\n    }","id":28041,"modified_method":"public IJob createJob() {\n      return new IJob() {\n        public IResult execute(Iterable<IResource> input, IMonitor monitor) {\n          Iterable<IResource> _output_ixz87t_a0a = null;\n          switch (0) {\n            case 0:\n              GenerationSettings settings = GenerationSettings.getInstance();\n              if (settings.isSaveTransientModels()) {\n                System.out.println(\"Configuring...\");\n                switch (monitor.<SaveTransient_Option>relayQuery(new SaveTransientModels_Query())) {\n                  case SAVE_ixz87t_a0a0a:\n                    System.out.println(\"Yes\");\n                    break;\n                  case DONT_SAVE_ixz87t_b0a0a:\n                    System.out.println(\"No\");\n                    break;\n                  case BUGGER_OFF_ixz87t_c0a0a:\n                    System.out.println(\"Piss off\");\n                    break;\n                  default:\n                    return new IResult.FAILURE(_output_ixz87t_a0a);\n                }\n                return new IResult.SUCCESS(_output_ixz87t_a0a);\n              }\n            default:\n              return new IResult.SUCCESS(_output_ixz87t_a0a);\n          }\n        }\n      };\n    }","commit_id":"e60a2df0a536eff4d748445ece680a4779fdd008","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Iterable<SaveTransient_Option> options() {\n    return Sequence.fromArray(SaveTransient_Option.class.getEnumConstants());\n  }","id":28042,"modified_method":"public Iterable<SaveTransient_Option> options() {\n    return Sequence.fromIterable(Sequence.fromArray(SaveTransient_Option.class.getEnumConstants())).cut(1);\n  }","commit_id":"e60a2df0a536eff4d748445ece680a4779fdd008","url":"https://github.com/JetBrains/MPS"},{"original_method":"public IResult execute(IMonitor monit) {\n    validate();\n    if (!(isValid())) {\n      LOG.error(\"attempt to execute invalid script\");\n      throw new IllegalStateException(\"invalid script\");\n    }\n    final CompositeResult results = new CompositeResult();\n    Iterable<ITarget> toExecute = targetRange.targetAndSortedPrecursors(defaultTargetName);\n    for (ITarget trg : Sequence.fromIterable(toExecute)) {\n      Iterable<IResource> input = Sequence.fromIterable(targetRange.immediatePrecursors(trg.getName())).select(new ISelector<ITarget, IResult>() {\n        public IResult select(ITarget t) {\n          return results.getResult(t.getName());\n        }\n      }).translate(new ITranslator2<IResult, IResource>() {\n        public Iterable<IResource> translate(IResult r) {\n          return r.output();\n        }\n      });\n      IJob job = trg.createJob();\n      IResult jr = job.execute(input, monit);\n      results.addResult(trg.getName(), jr);\n      if (!(jr.isSucessful()) || monit.pleaseStop()) {\n        return results;\n      }\n    }\n    return results;\n  }","id":28043,"modified_method":"public IResult execute(IMonitor monit) {\n    validate();\n    if (!(isValid())) {\n      LOG.error(\"attempt to execute invalid script\");\n      throw new IllegalStateException(\"invalid script\");\n    }\n    LOG.info(\"Beginning to execute script\");\n    final CompositeResult results = new CompositeResult();\n    Iterable<ITarget> toExecute = targetRange.targetAndSortedPrecursors(defaultTargetName);\n    for (ITarget trg : Sequence.fromIterable(toExecute)) {\n      LOG.info(\"Executing \" + trg.getName());\n      Iterable<IResource> input = Sequence.fromIterable(targetRange.immediatePrecursors(trg.getName())).select(new ISelector<ITarget, IResult>() {\n        public IResult select(ITarget t) {\n          return results.getResult(t.getName());\n        }\n      }).translate(new ITranslator2<IResult, IResource>() {\n        public Iterable<IResource> translate(IResult r) {\n          return r.output();\n        }\n      });\n      IJob job = trg.createJob();\n      IResult jr = job.execute(input, monit);\n      results.addResult(trg.getName(), jr);\n      if (!(jr.isSucessful()) || monit.pleaseStop()) {\n        LOG.info((jr.isSucessful() ?\n          \"Stop requested\" :\n          \"Execution failed\"\n        ));\n        break;\n      }\n    }\n    LOG.info(\"Finished executing script\");\n    return results;\n  }","commit_id":"e60a2df0a536eff4d748445ece680a4779fdd008","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void test_make() throws Exception {\n    ScriptBuilder scb = new ScriptBuilder();\n    scb.withFacets(Sequence.fromIterable(Sequence.fromArray(facets)).select(new ISelector<IFacet, IFacet.Name>() {\n      public IFacet.Name select(IFacet f) {\n        return f.getName();\n      }\n    }));\n    scb.withTarget(new ITarget.Name(\"make\"));\n    IScript sc = scb.toScript();\n    Assert.assertNotNull(sc);\n    Assert.assertTrue(sc.isValid());\n    List<ITarget.Name> expected = ListSequence.fromListAndArray(new ArrayList<ITarget.Name>(), new ITarget.Name(\"gen\"), new ITarget.Name(\"textgen\"), new ITarget.Name(\"make\"));\n    Assert.assertSame(ListSequence.fromList(expected).count(), Sequence.fromIterable(sc.allTargets()).count());\n    for (ITarget t : Sequence.fromIterable(sc.allTargets())) {\n      Assert.assertEquals(ListSequence.fromList(expected).removeElementAt(0), t.getName());\n    }\n  }","id":28044,"modified_method":"public void test_make() throws Exception {\n    ScriptBuilder scb = new ScriptBuilder();\n    scb.withFacets(Sequence.fromIterable(Sequence.fromArray(facets)).select(new ISelector<IFacet, IFacet.Name>() {\n      public IFacet.Name select(IFacet f) {\n        return f.getName();\n      }\n    }));\n    scb.withTarget(new ITarget.Name(\"make\"));\n    IScript sc = scb.toScript();\n    Assert.assertNotNull(sc);\n    Assert.assertTrue(sc.isValid());\n    List<ITarget.Name> expected = ListSequence.fromListAndArray(new ArrayList<ITarget.Name>(), new ITarget.Name(\"cfg\"), new ITarget.Name(\"gen\"), new ITarget.Name(\"textgen\"), new ITarget.Name(\"make\"));\n    Utils.assertSameSequence(expected, Sequence.fromIterable(sc.allTargets()).select(new ISelector<ITarget, ITarget.Name>() {\n      public ITarget.Name select(ITarget t) {\n        return t.getName();\n      }\n    }));\n  }","commit_id":"e60a2df0a536eff4d748445ece680a4779fdd008","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final IFacet fmake = Mockups.facet(context, \"Make\");\n    final ITarget tmake = Mockups.target(context, \"make\", new ITarget.Name(\"make\"));\n    final IFacet fgen = Mockups.facet(context, \"Gen\");\n    final ITarget tgen = Mockups.target(context, \"gen\", new ITarget.Name(\"gen\"));\n    final IFacet ftextgen = Mockups.facet(context, \"Textgen\");\n    final ITarget ttextgen = Mockups.target(context, \"textgen\", new ITarget.Name(\"textgen\"));\n    context.checking(new Expectations() {\n      {\n        atLeast(1).of(fmake).targets();\n        will(returnValue(Sequence.fromArray(new ITarget[]{tmake})));\n\n        atLeast(1).of(fgen).required();\n        will(returnValue(Sequence.fromArray(new IFacet.Name[]{fmake.getName()})));\n        atLeast(1).of(fgen).targets();\n        will(returnValue(Sequence.fromArray(new ITarget[]{tgen})));\n\n        allowing(tgen).before();\n        will(returnValue(Sequence.fromArray(new ITarget.Name[]{new ITarget.Name(\"make\")})));\n\n        atLeast(1).of(ftextgen).required();\n        will(returnValue(Sequence.fromArray(new IFacet.Name[]{fmake.getName(), fgen.getName()})));\n        atLeast(1).of(ftextgen).targets();\n        will(returnValue(Sequence.fromArray(new ITarget[]{ttextgen})));\n\n        allowing(ttextgen).before();\n        will(returnValue(Sequence.fromArray(new ITarget.Name[]{new ITarget.Name(\"make\")})));\n        allowing(ttextgen).after();\n        will(returnValue(Sequence.fromArray(new ITarget.Name[]{new ITarget.Name(\"gen\")})));\n      }\n    });\n    FacetRegistry.getInstance().register(fmake);\n    FacetRegistry.getInstance().register(fgen);\n    FacetRegistry.getInstance().register(ftextgen);\n    Mockups.allowing(context, fmake);\n    Mockups.allowing(context, fgen);\n    Mockups.allowing(context, ftextgen);\n    this.facets = new IFacet[]{fmake, fgen, ftextgen};\n    Mockups.allowing(context, tmake);\n    Mockups.allowing(context, tgen);\n    Mockups.allowing(context, ttextgen);\n  }","id":28045,"modified_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final IFacet fmake = Mockups.facet(context, \"Make\");\n    final ITarget tmake = Mockups.target(context, \"make\", new ITarget.Name(\"make\"));\n    final IFacet fgen = Mockups.facet(context, \"Gen\");\n    final ITarget tgen = Mockups.target(context, \"gen\", new ITarget.Name(\"gen\"));\n    final ITarget tcfg = Mockups.target(context, \"cfg\", new ITarget.Name(\"cfg\"));\n    final IFacet ftextgen = Mockups.facet(context, \"Textgen\");\n    final ITarget ttextgen = Mockups.target(context, \"textgen\", new ITarget.Name(\"textgen\"));\n    context.checking(new Expectations() {\n      {\n        atLeast(1).of(fmake).targets();\n        will(returnValue(Sequence.fromArray(new ITarget[]{tmake})));\n\n        atLeast(1).of(fgen).required();\n        will(returnValue(Sequence.fromArray(new IFacet.Name[]{fmake.getName()})));\n        atLeast(1).of(fgen).targets();\n        will(returnValue(Sequence.fromArray(new ITarget[]{tgen, tcfg})));\n\n        allowing(tgen).before();\n        will(returnValue(Sequence.fromArray(new ITarget.Name[]{new ITarget.Name(\"make\")})));\n        allowing(tgen).after();\n        will(returnValue(Sequence.fromArray(new ITarget.Name[]{new ITarget.Name(\"cfg\")})));\n\n        atLeast(1).of(ftextgen).required();\n        will(returnValue(Sequence.fromArray(new IFacet.Name[]{fmake.getName(), fgen.getName()})));\n        atLeast(1).of(ftextgen).targets();\n        will(returnValue(Sequence.fromArray(new ITarget[]{ttextgen})));\n\n        allowing(ttextgen).before();\n        will(returnValue(Sequence.fromArray(new ITarget.Name[]{new ITarget.Name(\"make\")})));\n        allowing(ttextgen).after();\n        will(returnValue(Sequence.fromArray(new ITarget.Name[]{new ITarget.Name(\"gen\")})));\n      }\n    });\n    FacetRegistry.getInstance().register(fmake);\n    FacetRegistry.getInstance().register(fgen);\n    FacetRegistry.getInstance().register(ftextgen);\n    Mockups.allowing(context, fmake);\n    Mockups.allowing(context, fgen);\n    Mockups.allowing(context, ftextgen);\n    this.facets = new IFacet[]{fmake, fgen, ftextgen};\n    Mockups.allowing(context, tmake);\n    Mockups.allowing(context, tgen);\n    Mockups.allowing(context, tcfg);\n    Mockups.allowing(context, ttextgen);\n  }","commit_id":"e60a2df0a536eff4d748445ece680a4779fdd008","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void test_gen() throws Exception {\n    ScriptBuilder scb = new ScriptBuilder();\n    scb.withFacets(Sequence.fromIterable(Sequence.fromArray(facets)).select(new ISelector<IFacet, IFacet.Name>() {\n      public IFacet.Name select(IFacet f) {\n        return f.getName();\n      }\n    }));\n    scb.withTarget(new ITarget.Name(\"gen\"));\n    IScript sc = scb.toScript();\n    Assert.assertNotNull(sc);\n    Assert.assertTrue(sc.isValid());\n    List<ITarget.Name> expected = ListSequence.fromListAndArray(new ArrayList<ITarget.Name>(), new ITarget.Name(\"gen\"), new ITarget.Name(\"textgen\"), new ITarget.Name(\"make\"));\n    Assert.assertSame(ListSequence.fromList(expected).count(), Sequence.fromIterable(sc.allTargets()).count());\n    for (ITarget t : Sequence.fromIterable(sc.allTargets())) {\n      Assert.assertEquals(ListSequence.fromList(expected).removeElementAt(0), t.getName());\n    }\n  }","id":28046,"modified_method":"public void test_gen() throws Exception {\n    ScriptBuilder scb = new ScriptBuilder();\n    scb.withFacets(Sequence.fromIterable(Sequence.fromArray(facets)).select(new ISelector<IFacet, IFacet.Name>() {\n      public IFacet.Name select(IFacet f) {\n        return f.getName();\n      }\n    }));\n    scb.withTarget(new ITarget.Name(\"gen\"));\n    IScript sc = scb.toScript();\n    Assert.assertNotNull(sc);\n    Assert.assertTrue(sc.isValid());\n    List<ITarget.Name> expected = ListSequence.fromListAndArray(new ArrayList<ITarget.Name>(), new ITarget.Name(\"cfg\"), new ITarget.Name(\"gen\"), new ITarget.Name(\"textgen\"), new ITarget.Name(\"make\"));\n    Utils.assertSameSequence(expected, Sequence.fromIterable(sc.allTargets()).select(new ISelector<ITarget, ITarget.Name>() {\n      public ITarget.Name select(ITarget t) {\n        return t.getName();\n      }\n    }));\n  }","commit_id":"e60a2df0a536eff4d748445ece680a4779fdd008","url":"https://github.com/JetBrains/MPS"},{"original_method":"public <T extends IOption> T relayQuery(IQuery<T> query, IOperationContext context) {\n    String[] options = Sequence.fromIterable(query.options()).select(new ISelector<T, String>() {\n      public String select(T o) {\n        return o.getText();\n      }\n    }).toGenericArray(String.class);\n    int res = JOptionPane.showOptionDialog(context.getMainFrame(), query.getText(), query.getName().toString(), JOptionPane.DEFAULT_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, null);\n    if (res == JOptionPane.CLOSED_OPTION) {\n      return null;\n    }\n    return ListSequence.fromList(Sequence.fromIterable(query.options()).toListSequence()).getElement(res);\n  }","id":28047,"modified_method":"public <T extends IOption> T relayQuery(IQuery<T> query, IOperationContext context) {\n    String[] options = Sequence.fromIterable(query.options()).select(new ISelector<T, String>() {\n      public String select(T o) {\n        return o.getText();\n      }\n    }).toGenericArray(String.class);\n    int res = JOptionPane.showOptionDialog(context.getMainFrame(), query.getText(), query.getName().toString(), JOptionPane.DEFAULT_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, null);\n    if (res == JOptionPane.CLOSED_OPTION) {\n      return query.voidOption();\n    }\n    return ListSequence.fromList(Sequence.fromIterable(query.options()).toListSequence()).getElement(res);\n  }","commit_id":"e60a2df0a536eff4d748445ece680a4779fdd008","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected User updateUser(\n\t\t\tlong companyId, LDAPUser ldapUser, User user, String password,\n\t\t\tString modifiedDate)\n\t\tthrows Exception {\n\n\t\tDate ldapUserModifiedDate = null;\n\n\t\ttry {\n\t\t\tif (Validator.isNull(modifiedDate)) {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"LDAP entry never modified, skipping user \" +\n\t\t\t\t\t\t\tuser.getEmailAddress());\n\t\t\t\t}\n\n\t\t\t\treturn user;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tldapUserModifiedDate = LDAPUtil.parseDate(modifiedDate);\n\t\t\t}\n\n\t\t\tif (ldapUserModifiedDate.equals(user.getModifiedDate()) &&\n\t\t\t\tldapUser.isAutoPassword()) {\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"User is already synchronized, skipping user \" +\n\t\t\t\t\t\t\tuser.getEmailAddress());\n\t\t\t\t}\n\n\t\t\t\treturn user;\n\t\t\t}\n\t\t}\n\t\tcatch (ParseException pe) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Unable to parse LDAP modify timestamp \" + modifiedDate,\n\t\t\t\t\tpe);\n\t\t\t}\n\t\t}\n\n\t\tboolean passwordReset = ldapUser.isPasswordReset();\n\n\t\tif (PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.LDAP_EXPORT_ENABLED,\n\t\t\t\tPropsValues.LDAP_EXPORT_ENABLED)) {\n\n\t\t\tpasswordReset = user.isPasswordReset();\n\t\t}\n\n\t\tif (Validator.isNull(ldapUser.getScreenName())) {\n\t\t\tldapUser.setAutoScreenName(true);\n\t\t}\n\n\t\tif (ldapUser.isAutoScreenName()) {\n\t\t\tScreenNameGenerator screenNameGenerator =\n\t\t\t\tScreenNameGeneratorFactory.getInstance();\n\n\t\t\tldapUser.setScreenName(\n\t\t\t\tscreenNameGenerator.generate(\n\t\t\t\t\tcompanyId, user.getUserId(), ldapUser.getEmailAddress()));\n\t\t}\n\n\t\tCalendar birthdayCal = CalendarFactoryUtil.getCalendar();\n\n\t\tbirthdayCal.setTime(user.getContact().getBirthday());\n\n\t\tint birthdayMonth = birthdayCal.get(Calendar.MONTH);\n\t\tint birthdayDay = birthdayCal.get(Calendar.DAY_OF_MONTH);\n\t\tint birthdayYear = birthdayCal.get(Calendar.YEAR);\n\n\t\tif (PropsValues.LDAP_IMPORT_USER_PASSWORD_ENABLED) {\n\t\t\tUserLocalServiceUtil.updatePassword(\n\t\t\t\tuser.getUserId(), password, password, passwordReset, true);\n\t\t}\n\n\t\tSet<String> ldapAttributesIgnore = new HashSet<String>();\n\n\t\tldapAttributesIgnore.addAll(\n\t\t\tListUtil.fromArray(PropsValues.LDAP_USER_IGNORE_ATTRIBUTES));\n\n\t\tContact contact = user.getContact();\n\n\t\tfor (String attribute : ldapAttributesIgnore) {\n\t\t\tObject obj = BeanPropertiesUtil.getObjectSilent(user, attribute);\n\n\t\t\tif (obj == null) {\n\t\t\t\tobj = BeanPropertiesUtil.getObjectSilent(contact, attribute);\n\t\t\t}\n\n\t\t\tif (obj != null) {\n\t\t\t\tBeanPropertiesUtil.setProperty(ldapUser, attribute, obj);\n\t\t\t}\n\t\t}\n\n\t\tuser = UserLocalServiceUtil.updateUser(\n\t\t\tuser.getUserId(), password, StringPool.BLANK, StringPool.BLANK,\n\t\t\tpasswordReset, ldapUser.getReminderQueryQuestion(),\n\t\t\tldapUser.getReminderQueryAnswer(), ldapUser.getScreenName(),\n\t\t\tldapUser.getEmailAddress(), ldapUser.getFacebookId(),\n\t\t\tldapUser.getOpenId(), ldapUser.getLanguageId(),\n\t\t\tldapUser.getTimeZoneId(), ldapUser.getGreeting(),\n\t\t\tldapUser.getComments(), ldapUser.getFirstName(),\n\t\t\tldapUser.getMiddleName(), ldapUser.getLastName(),\n\t\t\tldapUser.getPrefixId(), ldapUser.getSuffixId(), ldapUser.isMale(),\n\t\t\tbirthdayMonth, birthdayDay, birthdayYear, ldapUser.getSmsSn(),\n\t\t\tldapUser.getAimSn(), ldapUser.getFacebookSn(), ldapUser.getIcqSn(),\n\t\t\tldapUser.getJabberSn(), ldapUser.getMsnSn(),\n\t\t\tldapUser.getMySpaceSn(), ldapUser.getSkypeSn(),\n\t\t\tldapUser.getTwitterSn(), ldapUser.getYmSn(), ldapUser.getJobTitle(),\n\t\t\tldapUser.getGroupIds(), ldapUser.getOrganizationIds(),\n\t\t\tldapUser.getRoleIds(), ldapUser.getUserGroupRoles(),\n\t\t\tldapUser.getUserGroupIds(), ldapUser.getServiceContext());\n\n\t\tif (ldapUserModifiedDate != null) {\n\t\t\tuser = UserLocalServiceUtil.updateModifiedDate(\n\t\t\t\tuser.getUserId(), ldapUserModifiedDate);\n\t\t}\n\n\t\treturn user;\n\t}","id":28048,"modified_method":"protected User updateUser(\n\t\t\tlong companyId, LDAPUser ldapUser, User user, String password,\n\t\t\tString modifiedDate)\n\t\tthrows Exception {\n\n\t\tDate ldapUserModifiedDate = null;\n\n\t\ttry {\n\t\t\tif (Validator.isNull(modifiedDate)) {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"LDAP entry never modified, skipping user \" +\n\t\t\t\t\t\t\tuser.getEmailAddress());\n\t\t\t\t}\n\n\t\t\t\treturn user;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tldapUserModifiedDate = LDAPUtil.parseDate(modifiedDate);\n\t\t\t}\n\n\t\t\tif (ldapUserModifiedDate.equals(user.getModifiedDate()) &&\n\t\t\t\tldapUser.isAutoPassword()) {\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"User is already synchronized, skipping user \" +\n\t\t\t\t\t\t\tuser.getEmailAddress());\n\t\t\t\t}\n\n\t\t\t\treturn user;\n\t\t\t}\n\t\t}\n\t\tcatch (ParseException pe) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Unable to parse LDAP modify timestamp \" + modifiedDate,\n\t\t\t\t\tpe);\n\t\t\t}\n\t\t}\n\n\t\tboolean passwordReset = ldapUser.isPasswordReset();\n\n\t\tif (PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.LDAP_EXPORT_ENABLED,\n\t\t\t\tPropsValues.LDAP_EXPORT_ENABLED)) {\n\n\t\t\tpasswordReset = user.isPasswordReset();\n\t\t}\n\n\t\tif (Validator.isNull(ldapUser.getScreenName())) {\n\t\t\tldapUser.setAutoScreenName(true);\n\t\t}\n\n\t\tif (ldapUser.isAutoScreenName()) {\n\t\t\tScreenNameGenerator screenNameGenerator =\n\t\t\t\tScreenNameGeneratorFactory.getInstance();\n\n\t\t\tldapUser.setScreenName(\n\t\t\t\tscreenNameGenerator.generate(\n\t\t\t\t\tcompanyId, user.getUserId(), ldapUser.getEmailAddress()));\n\t\t}\n\n\t\tCalendar birthdayCal = CalendarFactoryUtil.getCalendar();\n\n\t\tbirthdayCal.setTime(user.getContact().getBirthday());\n\n\t\tint birthdayMonth = birthdayCal.get(Calendar.MONTH);\n\t\tint birthdayDay = birthdayCal.get(Calendar.DAY_OF_MONTH);\n\t\tint birthdayYear = birthdayCal.get(Calendar.YEAR);\n\n\t\tif (PropsValues.LDAP_IMPORT_USER_PASSWORD_ENABLED) {\n\t\t\tUserLocalServiceUtil.updatePassword(\n\t\t\t\tuser.getUserId(), password, password, passwordReset, true);\n\t\t}\n\n\t\tContact contact = user.getContact();\n\n\t\tSet<String> ldapIgnoreAttributes = SetUtil.fromArray(\n\t\t\tPropsValues.LDAP_USER_IGNORE_ATTRIBUTES);\n\n\t\tfor (String attribute : ldapIgnoreAttributes) {\n\t\t\tObject value = BeanPropertiesUtil.getObjectSilent(user, attribute);\n\n\t\t\tif (value == null) {\n\t\t\t\tvalue = BeanPropertiesUtil.getObjectSilent(contact, attribute);\n\t\t\t}\n\n\t\t\tif (value != null) {\n\t\t\t\tBeanPropertiesUtil.setProperty(ldapUser, attribute, value);\n\t\t\t}\n\t\t}\n\n\t\tuser = UserLocalServiceUtil.updateUser(\n\t\t\tuser.getUserId(), password, StringPool.BLANK, StringPool.BLANK,\n\t\t\tpasswordReset, ldapUser.getReminderQueryQuestion(),\n\t\t\tldapUser.getReminderQueryAnswer(), ldapUser.getScreenName(),\n\t\t\tldapUser.getEmailAddress(), ldapUser.getFacebookId(),\n\t\t\tldapUser.getOpenId(), ldapUser.getLanguageId(),\n\t\t\tldapUser.getTimeZoneId(), ldapUser.getGreeting(),\n\t\t\tldapUser.getComments(), ldapUser.getFirstName(),\n\t\t\tldapUser.getMiddleName(), ldapUser.getLastName(),\n\t\t\tldapUser.getPrefixId(), ldapUser.getSuffixId(), ldapUser.isMale(),\n\t\t\tbirthdayMonth, birthdayDay, birthdayYear, ldapUser.getSmsSn(),\n\t\t\tldapUser.getAimSn(), ldapUser.getFacebookSn(), ldapUser.getIcqSn(),\n\t\t\tldapUser.getJabberSn(), ldapUser.getMsnSn(),\n\t\t\tldapUser.getMySpaceSn(), ldapUser.getSkypeSn(),\n\t\t\tldapUser.getTwitterSn(), ldapUser.getYmSn(), ldapUser.getJobTitle(),\n\t\t\tldapUser.getGroupIds(), ldapUser.getOrganizationIds(),\n\t\t\tldapUser.getRoleIds(), ldapUser.getUserGroupRoles(),\n\t\t\tldapUser.getUserGroupIds(), ldapUser.getServiceContext());\n\n\t\tif (ldapUserModifiedDate != null) {\n\t\t\tuser = UserLocalServiceUtil.updateModifiedDate(\n\t\t\t\tuser.getUserId(), ldapUserModifiedDate);\n\t\t}\n\n\t\treturn user;\n\t}","commit_id":"56249988cdb6909b32a10d0244a79d58166e1cf5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public createInteractionDomain(Interaction ci, int i, int j) {\n    _ci = ci; _i = i; _j = j;\n    Log.info(\"Creating interaction features between \" + _ci.source._names[_i] + \" and \" + _ci.source._names[_j]);\n  }","id":28049,"modified_method":"public createInteractionDomain(int i, int j) { _i = i; _j = j; }","commit_id":"951089810437a0cdab593aa0ad6fba315be5ecb0","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n    public void map(Chunk[] cs) {\n      // find unique interaction domain\n      for (int r = 0; r < cs[0]._len; r++) {\n        final long a = cs[_i].isNA0(r) ? Integer.MIN_VALUE : cs[_i].at80(r);\n        final long b = cs[_j].isNA0(r) ? Integer.MIN_VALUE : cs[_j].at80(r);\n\n        // enum levels must fit into int\n        assert((int)a == a);\n        assert((int)b == b);\n\n        // key: combine both ints into a long\n        final long ab = (a << 32) | (b & 0xFFFFFFFL);\n\n//        Log.info(\"Looking up position of \" + ab + \" in domain\");\n//        Log.info(\"This long should be in the keys:\");\n//        Log.info(Arrays.toString(_keys));\n\n        // linear search in sorted array of factor levels (descending by occurrence), should be fastest for most small domains\n        int level = -1;\n        for (int i = 0; i < _keys.length; ++i) {\n          if (ab == _keys[i]) {\n            level = i;\n            break;\n          }\n        }\n\n        if (level >= 0)\n          cs[cs.length-1].set0(r, level);\n        else\n          cs[cs.length-1].setNA0(r);\n\n      }\n//    Log.info(\"Collected hash table\");\n//    Log.info(java.util.Arrays.deepToString(_hm.entrySet().toArray()));\n    }","id":28050,"modified_method":"@Override\n    public void map(Chunk[] cs) {\n      // find unique interaction domain\n      for (int r = 0; r < cs[0]._len; r++) {\n        final int a = cs[_i].isNA0(r) ? _missing : (int)cs[_i].at80(r);\n        final int b = cs[_j].isNA0(r) ? _missing : (int)cs[_j].at80(r);\n\n        // key: combine both ints into a long\n        final long ab = ((long)a << 32) | (b & 0xFFFFFFFFL);\n        assert a == (int)(ab >> 32);\n        assert b == (int)ab;\n\n        // linear search in sorted array of factor levels (descending by occurrence), should be fastest for most small domains\n        int level = -1;\n        for (int i = 0; i < _keys.length; ++i) {\n          if (ab == _keys[i]) {\n            level = i;\n            break;\n          }\n        }\n        if (level == -1) {\n          level = _fr.lastVec().domain().length-1;\n          assert _fr.lastVec().domain()[level] == _other;\n        }\n\n        cs[cs.length - 1].set0(r, level);\n\n      }\n    }","commit_id":"951089810437a0cdab593aa0ad6fba315be5ecb0","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n  public void map(Chunk[] cs) {\n    _hm = new Utils.IcedHashMap<Utils.IcedLong, Utils.IcedLong>();\n    // find unique interaction domain\n    for (int r = 0; r < cs[0]._len; r++) {\n      long a = cs[_i].isNA0(r) ? Integer.MIN_VALUE : cs[_i].at80(r);\n      long b = cs[_j].isNA0(r) ? Integer.MIN_VALUE : cs[_j].at80(r);\n\n      // enum levels must fit into int\n      assert((int)a == a);\n      assert((int)b == b);\n\n      // key: combine both ints into a long\n      long ab = (a << 32) | (b & 0xFFFFFFFL);\n\n      // add key to hash map, and count occurrences (for pruning)\n      Utils.IcedLong AB = new Utils.IcedLong(ab);\n      if (_hm.containsKey(AB)) {\n        _hm.put(AB, new Utils.IcedLong(_hm.get(AB)._val + 1));\n      } else {\n        _hm.put(AB, new Utils.IcedLong(1));\n      }\n    }\n  }","id":28051,"modified_method":"@Override\n  public void map(Chunk[] cs) {\n    _unsortedMap = new Utils.IcedHashMap<IcedLong, IcedLong>();\n    // find unique interaction domain\n    for (int r = 0; r < cs[0]._len; r++) {\n      int a = cs[_i].isNA0(r) ? _missing : (int)cs[_i].at80(r);\n      int b = cs[_j].isNA0(r) ? _missing : (int)cs[_j].at80(r);\n\n      // key: combine both ints into a long\n      long ab = ((long)a << 32) | (b & 0xFFFFFFFFL);\n      assert a == (int)(ab >> 32);\n      assert b == (int)ab;\n\n      // add key to hash map, and count occurrences (for pruning)\n      IcedLong AB = new IcedLong(ab);\n      if (_unsortedMap.containsKey(AB)) {\n        _unsortedMap.put(AB, new IcedLong(_unsortedMap.get(AB)._val + 1));\n      } else {\n        _unsortedMap.put(AB, new IcedLong(1));\n      }\n    }\n  }","commit_id":"951089810437a0cdab593aa0ad6fba315be5ecb0","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n  public void compute2() {\n    // base frame - same as source\n    _out = new Frame(Key.make(_ci.target), _ci.source.names(), _ci.source.vecs());\n\n//    for (int i=1; i<_ci.factors.length; ++i) {\n      int idx1 = _ci.factors[0];\n      int idx2 = _ci.factors[1];\n\n      // Pass 1: compute unique domains of all interaction features\n      createInteractionDomain pass1 = new createInteractionDomain(_ci, idx1, idx2).doAll(_out);\n      String[] domain = pass1._domain;\n\n      // Create a new Vec based on the domain\n      Vec interaction = _out.anyVec().makeZero(domain);\n      String name = _ci.source._names[idx1] + \"_\" + _ci.source._names[idx2];\n      _out.add(name, interaction);\n\n      // Create array of enum pairs, in the same (sorted) order as in the _domain map -> for linear lookup\n      long[] keys = new long[pass1._tm.size()];\n      int pos = 0;\n      for (long k : pass1._tm.keySet()) {\n        keys[pos++] = k;\n      }\n\n      // Pass 2: fill Vec values\n      new fillInteractionEnums(idx1, idx2, keys).doAll(_out);\n//    }\n\n    _out.delete_and_lock(_job);\n    tryComplete();\n  }","id":28052,"modified_method":"@Override\n  public void compute2() {\n    // base frame - same as source\n    DKV.remove(Key.make(_ci.target));//shouldn't be needed, but this avoids missing chunk issues\n    _out = new Frame(Key.make(_ci.target), _ci.source.names().clone(), _ci.source.vecs().clone());\n    _out.delete_and_lock(_job);\n\n    int idx1 = _ci.factors[0];\n    Vec tmp = null;\n    for (int i=1; i<_ci.factors.length; ++i) {\n      if (i>1) {\n        idx1 = _out.find(tmp);\n        assert idx1 >= 0;\n      }\n      int idx2 = _ci.factors[i];\n//      Log.info(\"Combining columns \" + idx1 + \" and \" + idx2);\n\n      // Pass 1: compute unique domains of all interaction features\n      createInteractionDomain pass1 = new createInteractionDomain(idx1, idx2).doAll(_out);\n\n      // Create a new Vec based on the domain\n      _out.add(_out._names[idx1] + \"_\" + _out._names[idx2], _out.anyVec().makeZero(makeDomain(pass1._unsortedMap, idx1, idx2)));\n      _out.update(_job);\n\n      // Create array of enum pairs, in the same (sorted) order as in the _domain map -> for linear lookup\n      // Note: \"other\" is not mapped in keys, so keys.length can be 1 less than domain.length\n      long[] keys = new long[_sortedMap.size()];\n      int pos = 0;\n      for (long k : _sortedMap.keySet()) {\n        keys[pos++] = k;\n      }\n      assert(_out.lastVec().domain().length == keys.length || _out.lastVec().domain().length == keys.length + 1); // domain might contain _other\n\n      // Pass 2: fill Vec values\n      new fillInteractionEnums(idx1, idx2, keys).doAll(_out);\n      tmp = _out.lastVec();\n\n      // remove temporary vec\n      if (i>1) {\n        final int idx = _out.vecs().length-2; //second-last vec\n//        Log.info(\"Removing column \" + _out._names[idx]);\n        _out.remove(idx);\n        _out.update(_job);\n      }\n    }\n    tryComplete();\n  }","commit_id":"951089810437a0cdab593aa0ad6fba315be5ecb0","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n  public void onCompletion(CountedCompleter caller) {\n    _out.update(_job);\n    _out.unlock(_job);\n  }","id":28053,"modified_method":"@Override\n  public void onCompletion(CountedCompleter caller) {\n    _out.update(_job);\n    Log.info(\"Created interaction feature \" + _out.names()[_out.names().length-1]\n            + \" (order: \" + _ci.factors.length + \") with \" + _out.lastVec().domain().length + \" factor levels.\");\n    _out.unlock(_job);\n  }","commit_id":"951089810437a0cdab593aa0ad6fba315be5ecb0","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n  public void reduce(createInteractionDomain mrt) {\n    // get all entries from mrt._hm, and put them into this._hm\n    mrt._hm.putAll(_hm);\n    mrt._hm.clear();\n//    Log.info(\"Merged hash tables\");\n//    Log.info(java.util.Arrays.deepToString(_hm.entrySet().toArray()));\n  }","id":28054,"modified_method":"@Override\n  public void reduce(createInteractionDomain mrt) {\n    assert(mrt._unsortedMap != null);\n    assert(_unsortedMap != null);\n    Utils.IcedHashMap third = new Utils.IcedHashMap<IcedLong, IcedLong>();\n    third.putAll(mrt._unsortedMap);\n    third.putAll(_unsortedMap);\n    _unsortedMap = third;\n    mrt._unsortedMap = null;\n//    Log.info(\"Merged hash tables\");\n//    Log.info(java.util.Arrays.deepToString(_unsortedMap.entrySet().toArray()));\n  }","commit_id":"951089810437a0cdab593aa0ad6fba315be5ecb0","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n     * Computes the distance between this lat/lon and another point on the earth.\n     * Uses spherical law of cosines formula, not Haversine.\n     * @param other the other point.\n     * @return distance in metres.\n     */\n    public double greatCircleDistance(LatLon other) {\n        return (Math.acos(\n                Math.sin(Math.toRadians(lat())) * Math.sin(Math.toRadians(other.lat())) +\n                Math.cos(Math.toRadians(lat()))*Math.cos(Math.toRadians(other.lat())) *\n                Math.cos(Math.toRadians(other.lon()-lon()))) * 6378135);\n    }","id":28055,"modified_method":"/**\n     * Computes the distance between this lat/lon and another point on the earth.\n     * Uses Haversine formular.\n     * @param other the other point.\n     * @return distance in metres.\n     */\n    public double greatCircleDistance(LatLon other) {\n        double R = 6378135;\n        double sinHalfLat = sin(toRadians(other.lat() - this.lat()) / 2);\n        double sinHalfLon = sin(toRadians(other.lon() - this.lon()) / 2);\n        double d = 2 * R * asin(\n                            sqrt(sinHalfLat*sinHalfLat + \n                            cos(toRadians(this.lat()))*cos(toRadians(other.lat()))*sinHalfLon*sinHalfLon));\n        // For points opposite to each other on the sphere, \n        // rounding errors could make the argument of asin greater than 1\n        // (This should almost never happen.)\n        if (java.lang.Double.isNaN(d)) {\n            System.err.println(\"Error: NaN in greatCircleDistance\");\n            d = PI * R;\n        }\n        return d;\n    }","commit_id":"32398fa4a561b125998fd823902a79529d415f42","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n  public EditorNotificationPanel createNotificationPanel(@NotNull VirtualFile file, @NotNull FileEditor fileEditor) {\n    if (file.getFileType() == JavaClassFileType.INSTANCE) return null;\n\n    final PsiFile psiFile = PsiManager.getInstance(myProject).findFile(file);\n    if (psiFile == null) {\n      return null;\n    }\n\n    if (psiFile.getLanguage() != JavaLanguage.INSTANCE) {\n      return null;\n    }\n\n    Module module = ModuleUtilCore.findModuleForPsiElement(psiFile);\n    if (module == null) {\n      return null;\n    }\n\n    Sdk sdk = ModuleRootManager.getInstance(module).getSdk();\n    if (sdk != null) {\n      return null;\n    }\n\n    return createPanel(myProject, psiFile);\n  }","id":28056,"modified_method":"@Override\n  public EditorNotificationPanel createNotificationPanel(@NotNull VirtualFile file, @NotNull FileEditor fileEditor) {\n    if (file.getFileType() != JavaClassFileType.INSTANCE) {\n      PsiFile psiFile = PsiManager.getInstance(myProject).findFile(file);\n      if (psiFile != null) {\n        if (psiFile.getLanguage() == JavaLanguage.INSTANCE) {\n          Module module = ModuleUtilCore.findModuleForPsiElement(psiFile);\n          if (module != null && !module.isDisposed()) {\n            Sdk sdk = ModuleRootManager.getInstance(module).getSdk();\n            if (sdk == null) {\n              return createPanel(myProject, psiFile);\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"ac82a13fbc52fc4efa0c6a0ee4d4ce0f9c0e9667","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static EditorNotificationPanel createPanel(@NotNull final Project project, @NotNull final PsiFile file) {\n    final EditorNotificationPanel panel = new EditorNotificationPanel();\n    panel.setText(ProjectBundle.message(\"project.sdk.not.defined\"));\n    panel.createActionLabel(ProjectBundle.message(\"project.sdk.setup\"), new Runnable() {\n      @Override\n      public void run() {\n        final Sdk projectSdk = ProjectSettingsService.getInstance(project).chooseAndSetSdk();\n        if (projectSdk == null) return;\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            final Module module = ModuleUtilCore.findModuleForPsiElement(file);\n            if (module != null) {\n              ModuleRootModificationUtil.setSdkInherited(module);\n            }\n          }\n        });\n      }\n    });\n    return panel;\n  }","id":28057,"modified_method":"@NotNull\n  private static EditorNotificationPanel createPanel(@NotNull Project project, @NotNull PsiFile file) {\n    EditorNotificationPanel panel = new EditorNotificationPanel();\n    panel.setText(ProjectBundle.message(\"project.sdk.not.defined\"));\n    panel.createActionLabel(ProjectBundle.message(\"project.sdk.setup\"), () -> {\n      Sdk projectSdk = ProjectSettingsService.getInstance(project).chooseAndSetSdk();\n      if (projectSdk != null) {\n        Module module = ModuleUtilCore.findModuleForPsiElement(file);\n        if (module != null) {\n          WriteAction.run(() -> ModuleRootModificationUtil.setSdkInherited(module));\n        }\n      }\n    });\n    return panel;\n  }","commit_id":"ac82a13fbc52fc4efa0c6a0ee4d4ce0f9c0e9667","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private EditorNotificationPanel createNotificationPanel(final Module module) {\n        final EditorNotificationPanel answer = new EditorNotificationPanel();\n\n        answer.setText(\"Kotlin runtime library is not configured for module '\" + module.getName() + \"'\");\n        answer.createActionLabel(\"Setup Kotlin Runtime\", new Runnable() {\n            @Override\n            public void run() {\n\n                ApplicationManager.getApplication().runWriteAction(new Runnable() {\n                    @Override\n                    public void run() {\n                        Library library = findOrCreateRuntimeLibrary(module);\n                        if (library != null) {\n                            ModifiableRootModel model = ModuleRootManager.getInstance(module).getModifiableModel();\n                            if (model.findLibraryOrderEntry(library) == null) {\n                                model.addLibraryEntry(library);\n                                model.commit();\n                            }\n                            SwingUtilities.invokeLater(new Runnable() {\n                                @Override\n                                public void run() {\n                                    EditorNotifications.getInstance(myProject).updateAllNotifications();\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n        });\n\n        return answer;\n    }","id":28058,"modified_method":"private EditorNotificationPanel createNotificationPanel(final Module module) {\n        final EditorNotificationPanel answer = new EditorNotificationPanel();\n\n        answer.setText(\"Kotlin is not configured for module '\" + module.getName() + \"'\");\n        answer.createActionLabel(\"Set Up module '\" + module.getName() + \"' as JVM Kotlin module\", new Runnable() {\n            @Override\n            public void run() {\n                setUpKotlinRuntime(module);\n            }\n        });\n\n        answer.createActionLabel(\"Set Up module '\" + module.getName() + \"' as JavaScript Kotlin module\", new Runnable() {\n            @Override\n            public void run() {\n                setUpJSModule(module);\n            }\n        });\n\n        return answer;\n    }","commit_id":"0cdf8263426a1b9ef38e0df410eb9f3dd9134b74","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void createIndicationFile(@NotNull File file) {\n        try {\n            FileUtil.writeToFile(file, PathUtil.JS_LIB_JAR_NAME);\n        }\n        catch (IOException e) {\n            notifyFailure(\"Failed to write file \" + file.getName());\n        }\n    }","id":28059,"modified_method":"private static void createIndicationFile(@NotNull File file) {\n        try {\n            FileUtil.writeToFile(file, \"lib/\" + PathUtil.JS_LIB_JAR_NAME);\n        }\n        catch (IOException e) {\n            notifyFailure(\"Failed to write file \" + file.getName());\n        }\n    }","commit_id":"0cdf8263426a1b9ef38e0df410eb9f3dd9134b74","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void actionPerformed(AnActionEvent event) {\n        Project project = event.getProject();\n        if (project == null) {\n            notifyFailure(\"Internal error: Project not found.\");\n            return;\n        }\n\n        File jsLibPath = PathUtil.getDefaultJsLibPath();\n        if (jsLibPath == null) {\n            notifyFailure(\"JavaScript library not found. Make sure plugin is installed properly.\");\n            return;\n        }\n\n        File rootDir = getRootDir(project);\n        if (!rootDir.isDirectory()) {\n            notifyFailure(\"Internal error: Broken content root.\");\n            return;\n        }\n\n        if (!copyJsLib(jsLibPath, rootDir)) return;\n\n        File file = new File(rootDir, JsModuleDetector.INDICATION_FILE_NAME);\n        if (file.exists()) {\n            notifyInfo(\"File \" + file.getName() + \" already exists.\");\n            return;\n        }\n\n        createIndicationFile(file);\n\n        refreshRootDir(project);\n    }","id":28060,"modified_method":"@Override\n    public void actionPerformed(AnActionEvent event) {\n        if (event == null) {\n            return;\n        }\n        doSetUpModule(event.getProject());\n    }","commit_id":"0cdf8263426a1b9ef38e0df410eb9f3dd9134b74","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean copyJsLib(@NotNull File jsLibPath, @NotNull File rootDir) {\n        try {\n            copyFileToDir(jsLibPath, rootDir);\n        }\n        catch (IOException e) {\n            notifyFailure(\"Failed to copy file: \" + e.getMessage());\n            return false;\n        }\n        return true;\n    }","id":28061,"modified_method":"private static boolean copyJsLib(@NotNull File jsLibPath, @NotNull File rootDir) {\n        try {\n            copyFileToDir(jsLibPath, new File(rootDir, \"lib\"));\n        }\n        catch (IOException e) {\n            notifyFailure(\"Failed to copy file: \" + e.getMessage());\n            return false;\n        }\n        return true;\n    }","commit_id":"0cdf8263426a1b9ef38e0df410eb9f3dd9134b74","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void refreshRootDir(@NotNull Project project) {\n        getContentRoot(project).refresh(true, false);\n    }","id":28062,"modified_method":"private static void refreshRootDir(@NotNull Project project) {\n        getContentRoot(project).refresh(false, false);\n    }","commit_id":"0cdf8263426a1b9ef38e0df410eb9f3dd9134b74","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private EditorNotificationPanel createNotificationPanel(final Module module) {\n        final EditorNotificationPanel answer = new EditorNotificationPanel();\n\n        answer.setText(\"Kotlin runtime library is not configured for module '\" + module.getName() + \"'\");\n        answer.createActionLabel(\"Setup Kotlin Runtime\", new Runnable() {\n            @Override\n            public void run() {\n\n                ApplicationManager.getApplication().runWriteAction(new Runnable() {\n                    @Override\n                    public void run() {\n                        Library library = findOrCreateRuntimeLibrary(module);\n                        if (library != null) {\n                            ModifiableRootModel model = ModuleRootManager.getInstance(module).getModifiableModel();\n                            model.addLibraryEntry(library);\n                            model.commit();\n                        }\n                    }\n                });\n            }\n        });\n\n        return answer;\n    }","id":28063,"modified_method":"private EditorNotificationPanel createNotificationPanel(final Module module) {\n        final EditorNotificationPanel answer = new EditorNotificationPanel();\n\n        answer.setText(\"Kotlin runtime library is not configured for module '\" + module.getName() + \"'\");\n        answer.createActionLabel(\"Setup Kotlin Runtime\", new Runnable() {\n            @Override\n            public void run() {\n\n                ApplicationManager.getApplication().runWriteAction(new Runnable() {\n                    @Override\n                    public void run() {\n                        Library library = findOrCreateRuntimeLibrary(module);\n                        if (library != null) {\n                            ModifiableRootModel model = ModuleRootManager.getInstance(module).getModifiableModel();\n                            model.addLibraryEntry(library);\n                            model.commit();\n                            SwingUtilities.invokeLater(new Runnable() {\n                                @Override\n                                public void run() {\n                                    EditorNotifications.getInstance(myProject).updateAllNotifications();\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n        });\n\n        return answer;\n    }","commit_id":"43e9fad2ae51449c5cfb2e3c3af616254bb3fca7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public ConfigureKotlinLibraryNotificationProvider(Project project, final EditorNotifications notifications) {\n        myProject = project;\n        project.getMessageBus().connect(project).subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootListener() {\n            @Override\n            public void beforeRootsChange(ModuleRootEvent event) {\n            }\n\n            @Override\n            public void rootsChanged(ModuleRootEvent event) {\n                notifications.updateAllNotifications();\n            }\n        });\n    }","id":28064,"modified_method":"public ConfigureKotlinLibraryNotificationProvider(Project project) {\n        myProject = project;\n    }","commit_id":"43e9fad2ae51449c5cfb2e3c3af616254bb3fca7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n\tprotected long addBaseModel(long containerModelId) throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tserviceContext.setCommand(Constants.ADD);\n\t\tserviceContext.setLayoutFullURL(\"http://localhost\");\n\n\t\tBookmarksEntry entry = BookmarksEntryLocalServiceUtil.addEntry(\n\t\t\tTestPropsValues.getUserId(), group.getGroupId(), containerModelId,\n\t\t\tServiceTestUtil.randomString(), \"http://localhost\",\n\t\t\tStringPool.BLANK, serviceContext);\n\n\t\treturn entry.getEntryId();\n\t}","id":28065,"modified_method":"@Override\n\tprotected long addBaseModel(long containerModelId) throws Exception {\n\t\tBookmarksEntry entry = BookmarksTestUtil.addEntry(\n\t\t\tcontainerModelId, true,\n\t\t\tServiceTestUtil.getServiceContext(group.getGroupId()));\n\n\t\treturn entry.getEntryId();\n\t}","commit_id":"1d597d2e2e0d11ed7ab45ee1c04dd703b10c6935","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected long addContainerModel(long containerModelId) throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tBookmarksFolder folder = BookmarksFolderLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), containerModelId,\n\t\t\tServiceTestUtil.randomString(), StringPool.BLANK, serviceContext);\n\n\t\treturn folder.getFolderId();\n\t}","id":28066,"modified_method":"@Override\n\tprotected long addContainerModel(long containerModelId) throws Exception {\n\t\tBookmarksFolder folder = BookmarksTestUtil.addFolder(\n\t\t\tcontainerModelId, ServiceTestUtil.randomString(),\n\t\t\tServiceTestUtil.getServiceContext(group.getGroupId()));\n\n\t\treturn folder.getFolderId();\n\t}","commit_id":"1d597d2e2e0d11ed7ab45ee1c04dd703b10c6935","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected long updateEntry(long baseModelId) throws Exception {\n\t\tBookmarksEntry entry = BookmarksEntryLocalServiceUtil.getEntry(\n\t\t\tbaseModelId);\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tserviceContext.setCommand(Constants.UPDATE);\n\t\tserviceContext.setLayoutFullURL(\"http://localhost\");\n\n\t\tentry = BookmarksEntryLocalServiceUtil.updateEntry(\n\t\t\tTestPropsValues.getUserId(), baseModelId, entry.getGroupId(),\n\t\t\tentry.getFolderId(), ServiceTestUtil.randomString(), entry.getUrl(),\n\t\t\tentry.getDescription(), serviceContext);\n\n\t\treturn entry.getEntryId();\n\t}","id":28067,"modified_method":"@Override\n\tprotected long updateEntry(long baseModelId) throws Exception {\n\t\tBookmarksEntry entry = BookmarksEntryLocalServiceUtil.getEntry(\n\t\t\tbaseModelId);\n\n\t\tentry = BookmarksTestUtil.updateEntry(entry);\n\n\t\treturn entry.getEntryId();\n\t}","commit_id":"1d597d2e2e0d11ed7ab45ee1c04dd703b10c6935","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static BookmarksEntry addEntry(\n\t\t\tlong folderId, boolean approved, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tboolean workflowEnabled = WorkflowThreadLocal.isEnabled();\n\n\t\ttry {\n\t\t\tWorkflowThreadLocal.setEnabled(true);\n\n\t\t\tString name = \"Test Entry\";\n\t\t\tString url = \"http://www.liferay.com\";\n\t\t\tString description = \"This is a test entry.\";\n\n\t\t\tserviceContext = (ServiceContext)serviceContext.clone();\n\n\t\t\tserviceContext.setAddGroupPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\n\t\t\tBookmarksEntry entry = BookmarksEntryServiceUtil.addEntry(\n\t\t\t\tserviceContext.getScopeGroupId(), folderId, name, url,\n\t\t\t\tdescription, serviceContext);\n\n\t\t\tif (approved) {\n\t\t\t\tentry.setStatus(WorkflowConstants.STATUS_APPROVED);\n\n\t\t\t\tentry = BookmarksEntryServiceUtil.updateEntry(\n\t\t\t\t\tentry.getEntryId(), serviceContext.getScopeGroupId(),\n\t\t\t\t\tentry.getFolderId(), entry.getName(), entry.getUrl(),\n\t\t\t\t\tentry.getUrl(), serviceContext);\n\t\t\t}\n\n\t\t\treturn entry;\n\t\t}\n\t\tfinally {\n\t\t\tWorkflowThreadLocal.setEnabled(workflowEnabled);\n\t\t}\n\t}","id":28068,"modified_method":"public static BookmarksEntry addEntry(\n\t\t\tlong folderId, boolean approved, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tboolean workflowEnabled = WorkflowThreadLocal.isEnabled();\n\n\t\ttry {\n\t\t\tWorkflowThreadLocal.setEnabled(true);\n\n\t\t\tString name = \"Test Entry\";\n\t\t\tString url = \"http://www.liferay.com\";\n\t\t\tString description = \"This is a test entry.\";\n\n\t\t\tserviceContext = (ServiceContext)serviceContext.clone();\n\n\t\t\tserviceContext.setAddGroupPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\n\t\t\tBookmarksEntry entry = BookmarksEntryServiceUtil.addEntry(\n\t\t\t\tserviceContext.getScopeGroupId(), folderId, name, url,\n\t\t\t\tdescription, serviceContext);\n\n\t\t\tserviceContext.setCommand(Constants.ADD);\n\t\t\tserviceContext.setLayoutFullURL(\"http://localhost\");\n\n\t\t\tif (approved) {\n\t\t\t\tentry.setStatus(WorkflowConstants.STATUS_APPROVED);\n\n\t\t\t\tentry = BookmarksEntryServiceUtil.updateEntry(\n\t\t\t\t\tentry.getEntryId(), serviceContext.getScopeGroupId(),\n\t\t\t\t\tentry.getFolderId(), entry.getName(), entry.getUrl(),\n\t\t\t\t\tentry.getUrl(), serviceContext);\n\t\t\t}\n\n\t\t\treturn entry;\n\t\t}\n\t\tfinally {\n\t\t\tWorkflowThreadLocal.setEnabled(workflowEnabled);\n\t\t}\n\t}","commit_id":"1d597d2e2e0d11ed7ab45ee1c04dd703b10c6935","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void subscribeToContainer() throws Exception {\n\t\tBookmarksFolderLocalServiceUtil.subscribeFolder(\n\t\t\tTestPropsValues.getUserId(), group.getGroupId(),\n\t\t\t_folder.getFolderId());\n\t}","id":28069,"modified_method":"@Override\n\tprotected void subscribeToContainer() throws Exception {\n\t\tBookmarksFolderLocalServiceUtil.subscribeFolder(\n\t\t\tuser.getUserId(), group.getGroupId(), _folder.getFolderId());\n\t}","commit_id":"1d597d2e2e0d11ed7ab45ee1c04dd703b10c6935","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected BaseModel<?> updateBaseModel(BaseModel<?> baseModel)\n\t\tthrows Exception {\n\n\t\tBookmarksEntry entry = (BookmarksEntry)baseModel;\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tserviceContext.setCommand(Constants.UPDATE);\n\t\tserviceContext.setLayoutFullURL(\"http://localhost\");\n\n\t\treturn BookmarksEntryLocalServiceUtil.updateEntry(\n\t\t\tTestPropsValues.getUserId(), entry.getEntryId(), entry.getGroupId(),\n\t\t\tentry.getFolderId(), ServiceTestUtil.randomString(), entry.getUrl(),\n\t\t\tentry.getDescription(), serviceContext);\n\t}","id":28070,"modified_method":"@Override\n\tprotected BaseModel<?> updateBaseModel(BaseModel<?> baseModel)\n\t\tthrows Exception {\n\n\t\treturn BookmarksTestUtil.updateEntry((BookmarksEntry)baseModel);\n\t}","commit_id":"1d597d2e2e0d11ed7ab45ee1c04dd703b10c6935","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected BaseModel<?> addBaseModel() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tserviceContext.setCommand(Constants.ADD);\n\t\tserviceContext.setLayoutFullURL(\"http://localhost\");\n\n\t\treturn BookmarksEntryLocalServiceUtil.addEntry(\n\t\t\tTestPropsValues.getUserId(), group.getGroupId(),\n\t\t\t_folder.getFolderId(), ServiceTestUtil.randomString(),\n\t\t\t\"http://localhost\",\tStringPool.BLANK, serviceContext);\n\t}","id":28071,"modified_method":"@Override\n\tprotected BaseModel<?> addBaseModel() throws Exception {\n\t\treturn BookmarksTestUtil.addEntry(\n\t\t\t_folder.getFolderId(), true,\n\t\t\tServiceTestUtil.getServiceContext(group.getGroupId()));\n\t}","commit_id":"1d597d2e2e0d11ed7ab45ee1c04dd703b10c6935","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void addContainerModel() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\t_folder = BookmarksFolderLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(),\n\t\t\tBookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID,\n\t\t\tServiceTestUtil.randomString(), StringPool.BLANK, serviceContext);\n\t}","id":28072,"modified_method":"@Override\n\tprotected void addContainerModel() throws Exception {\n\t\t_folder = BookmarksTestUtil.addFolder(\n\t\t\tgroup.getGroupId(), ServiceTestUtil.randomString());\n\t}","commit_id":"1d597d2e2e0d11ed7ab45ee1c04dd703b10c6935","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static FileEntry addFileEntry(\n\t\t\tlong groupId, long folderId, String mimeType, String sourceFileName,\n\t\t\tString title, byte[] bytes, int workflowAction)\n\t\tthrows Exception {\n\n\t\tString description = StringPool.BLANK;\n\t\tString changeLog = StringPool.BLANK;\n\n\t\tif ((bytes == null) && Validator.isNotNull(sourceFileName)) {\n\t\t\tbytes = _CONTENT.getBytes();\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setScopeGroupId(groupId);\n\t\tserviceContext.setWorkflowAction(workflowAction);\n\n\t\treturn DLAppLocalServiceUtil.addFileEntry(\n\t\t\tTestPropsValues.getUserId(), groupId, folderId, sourceFileName,\n\t\t\tmimeType, title, description, changeLog, bytes, serviceContext);\n\t}","id":28073,"modified_method":"public static FileEntry addFileEntry(\n\t\t\tlong groupId, long folderId, String mimeType, String sourceFileName,\n\t\t\tString title, byte[] bytes, int workflowAction)\n\t\tthrows Exception {\n\n\t\treturn addFileEntry(\n\t\t\tTestPropsValues.getUserId(), groupId, folderId, mimeType,\n\t\t\tsourceFileName, title, bytes, workflowAction);\n\t}","commit_id":"28103b5d70d705a44e59b4fa70d83db4919d14ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFindByAnyImageId() throws Exception {\n\t\tDLFileEntry dlFileEntry = DLFileEntryFinderUtil.findByAnyImageId(6789);\n\n\t\tAssert.assertEquals(dlFileEntry.getTitle(), \"FE1.txt\");\n\t}","id":28074,"modified_method":"@Test\n\tpublic void testFindByAnyImageId() throws Exception {\n\t\tDLFileEntry dlFileEntry = DLFileEntryFinderUtil.findByAnyImageId(\n\t\t\t_SMALL_IMAGE_ID);\n\n\t\tAssert.assertEquals(dlFileEntry.getTitle(), \"FE1.txt\");\n\t}","commit_id":"28103b5d70d705a44e59b4fa70d83db4919d14ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFindByG_U_F_M() throws Exception {\n\t\tQueryDefinition queryDefinition = new QueryDefinition();\n\n\t\tqueryDefinition.setStatus(WorkflowConstants.STATUS_IN_TRASH, true);\n\n\t\tList<DLFileEntry> list = doFindBy_G_U_F_M(\n\t\t\tfalse, _TEXT_PLAIN, queryDefinition);\n\n\t\tAssert.assertEquals(list.size(), 1);\n\n\t\tDLFileEntry dlFileEntry = list.get(0);\n\n\t\tAssert.assertEquals(dlFileEntry.getTitle(), \"FE1.txt\");\n\n\t\tqueryDefinition.setStatus(WorkflowConstants.STATUS_ANY);\n\n\t\tlist =  doFindBy_G_U_F_M(true, _TEXT_PLAIN, queryDefinition);\n\n\t\tAssert.assertEquals(list.size(), 1);\n\n\t\tdlFileEntry = list.get(0);\n\n\t\tAssert.assertEquals(dlFileEntry.getDescription(), \"FE3.txt\");\n\n\t\tqueryDefinition.setStatus(WorkflowConstants.STATUS_APPROVED);\n\n\t\tlist =  doFindBy_G_U_F_M(true, null, queryDefinition);\n\n\t\tAssert.assertEquals(list.size(), 1);\n\n\t\tdlFileEntry = list.get(0);\n\n\t\tAssert.assertEquals(dlFileEntry.getTitle(), \"FE2.pdf\");\n\n\t}","id":28075,"modified_method":"@Test\n\tpublic void testFindByG_U_F_M() throws Exception {\n\t\tQueryDefinition queryDefinition = new QueryDefinition();\n\n\t\tqueryDefinition.setStatus(WorkflowConstants.STATUS_IN_TRASH, true);\n\n\t\tList<DLFileEntry> fileEntries = doFindBy_G_U_F_M(\n\t\t\tfalse, _TEXT_PLAIN, queryDefinition);\n\n\t\tAssert.assertEquals(fileEntries.size(), 1);\n\n\t\tDLFileEntry dlFileEntry = fileEntries.get(0);\n\n\t\tAssert.assertEquals(dlFileEntry.getTitle(), \"FE1.txt\");\n\n\t\tqueryDefinition.setStatus(WorkflowConstants.STATUS_ANY);\n\n\t\tfileEntries = doFindBy_G_U_F_M(true, _TEXT_PLAIN, queryDefinition);\n\n\t\tAssert.assertEquals(fileEntries.size(), 1);\n\n\t\tdlFileEntry = fileEntries.get(0);\n\n\t\tAssert.assertEquals(dlFileEntry.getDescription(), \"FE3.txt\");\n\n\t\tqueryDefinition.setStatus(WorkflowConstants.STATUS_APPROVED);\n\n\t\tfileEntries = doFindBy_G_U_F_M(true, null, queryDefinition);\n\n\t\tAssert.assertEquals(fileEntries.size(), 1);\n\n\t\tdlFileEntry = fileEntries.get(0);\n\n\t\tAssert.assertEquals(dlFileEntry.getTitle(), \"FE2.pdf\");\n\t}","commit_id":"28103b5d70d705a44e59b4fa70d83db4919d14ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\t_group = ServiceTestUtil.addGroup();\n\n\t\t_folder = DLAppLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(),\n\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID, \"Folder A\", \"\",\n\t\t\tServiceTestUtil.getServiceContext(_group.getGroupId()));\n\n\t\tDLAppLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(),\n\t\t\t_folder.getFolderId(), \"Folder B\", \"\",\n\t\t\tServiceTestUtil.getServiceContext(_group.getGroupId()));\n\n\t\tFolder folder = DLAppLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(),\n\t\t\t_folder.getFolderId(), \"Folder C\", \"\",\n\t\t\tServiceTestUtil.getServiceContext(_group.getGroupId()));\n\n\t\tDLAppServiceUtil.moveFolderToTrash(folder.getFolderId());\n\n\t\tFileEntry fileEntry = DLAppTestUtil.addFileEntry(\n\t\t\t_group.getGroupId(), _folder.getFolderId(), false, \"FE1.txt\",\n\t\t\t\"FE1.txt\");\n\n\t\tDLFileEntry dlFileEntry =\n\t\t\t((LiferayFileEntry)fileEntry).getDLFileEntry();\n\n\t\tdlFileEntry.setUserId(1234);\n\t\tdlFileEntry.setSmallImageId(6789);\n\t\tdlFileEntry.setExtraSettings(\"Extra Settings\");\n\n\t\tdlFileEntry = DLFileEntryLocalServiceUtil.updateDLFileEntry(\n\t\t\tdlFileEntry);\n\n\t\t_fileVersion = dlFileEntry.getFileVersion();\n\n\t\t_fileVersion.setUserId(1234);\n\t\t_fileVersion.setStatus(WorkflowConstants.STATUS_APPROVED);\n\n\t\tDLFileVersionLocalServiceUtil.updateDLFileVersion(_fileVersion);\n\n\t\tDLAppTestUtil.addFileEntry(\n\t\t\t_group.getGroupId(), _folder.getFolderId(),\n\t\t\tContentTypes.APPLICATION_PDF, \"FE2.pdf\", \"FE2.pdf\");\n\n\t\tfileEntry = DLAppTestUtil.addFileEntry(\n\t\t\t_group.getGroupId(), _folder.getFolderId(), false, \"FE3.txt\",\n\t\t\t\"FE3.txt\");\n\n\t\tfileEntry = DLAppTestUtil.updateFileEntry(\n\t\t\t_group.getGroupId(), fileEntry.getFileEntryId(), \"FE3.txt\",\n\t\t\t\"FE3.txt\");\n\n\t\tdlFileEntry = ((LiferayFileEntry)fileEntry).getDLFileEntry();\n\n\t\tdlFileEntry.setDescription(\"FE3.txt\");\n\n\t\tDLFileEntryLocalServiceUtil.updateDLFileEntry(dlFileEntry);\n\n\t\tFinderCacheUtil.clearCache();\n\n\t\tLiferayFileVersion fileVersion =\n\t\t\t(LiferayFileVersion)fileEntry.getFileVersion();\n\n\t\tDLFileVersion dlFileVersion = (DLFileVersion)fileVersion.getModel();\n\n\t\tdlFileVersion.setExtraSettings(\"Extra Settings\");\n\n\t\tDLFileVersionLocalServiceUtil.updateDLFileVersion(dlFileVersion);\n\n\t\tDLAppServiceUtil.moveFileEntryToTrash(fileEntry.getFileEntryId());\n\t}","id":28076,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\t_group = ServiceTestUtil.addGroup();\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\t_group.getGroupId());\n\n\t\t_folder = DLAppLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(),\n\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID, \"Folder A\",\n\t\t\tStringPool.BLANK, serviceContext);\n\n\t\tDLAppLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(),\n\t\t\t_folder.getFolderId(), \"Folder B\", StringPool.BLANK,\n\t\t\tserviceContext);\n\n\t\tFolder folder = DLAppLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(),\n\t\t\t_folder.getFolderId(), \"Folder C\", StringPool.BLANK,\n\t\t\tserviceContext);\n\n\t\tDLAppServiceUtil.moveFolderToTrash(folder.getFolderId());\n\n\t\tUser user = ServiceTestUtil.addUser(\n\t\t\tServiceTestUtil.randomString(), _group.getGroupId());\n\n\t\tFileEntry fileEntry = DLAppTestUtil.addFileEntry(\n\t\t\tuser.getUserId(), _group.getGroupId(), _folder.getFolderId(),\n\t\t\tContentTypes.TEXT_PLAIN, \"FE1.txt\", \"FE1.txt\", null,\n\t\t\tWorkflowConstants.ACTION_PUBLISH);\n\n\t\tDLFileEntry dlFileEntry =\n\t\t\t((LiferayFileEntry)fileEntry).getDLFileEntry();\n\n\t\tdlFileEntry.setSmallImageId(_SMALL_IMAGE_ID);\n\t\tdlFileEntry.setExtraSettings(\"Extra Settings\");\n\n\t\tdlFileEntry = DLFileEntryLocalServiceUtil.updateDLFileEntry(\n\t\t\tdlFileEntry);\n\n\t\t_fileVersion = dlFileEntry.getFileVersion();\n\n\t\t_fileVersion.setStatus(WorkflowConstants.STATUS_APPROVED);\n\n\t\tDLFileVersionLocalServiceUtil.updateDLFileVersion(_fileVersion);\n\n\t\tDLAppTestUtil.addFileEntry(\n\t\t\t_group.getGroupId(), _folder.getFolderId(),\n\t\t\tContentTypes.APPLICATION_PDF, \"FE2.pdf\", \"FE2.pdf\");\n\n\t\tfileEntry = DLAppTestUtil.addFileEntry(\n\t\t\t_group.getGroupId(), _folder.getFolderId(), false, \"FE3.txt\",\n\t\t\t\"FE3.txt\");\n\n\t\tfileEntry = DLAppTestUtil.updateFileEntry(\n\t\t\t_group.getGroupId(), fileEntry.getFileEntryId(), \"FE3.txt\",\n\t\t\t\"FE3.txt\");\n\n\t\tdlFileEntry = ((LiferayFileEntry)fileEntry).getDLFileEntry();\n\n\t\tdlFileEntry.setDescription(\"FE3.txt\");\n\n\t\tDLFileEntryLocalServiceUtil.updateDLFileEntry(dlFileEntry);\n\n\t\tDLFileVersion dlFileVersion = dlFileEntry.getFileVersion();\n\n\t\tdlFileVersion.setExtraSettings(\"Extra Settings\");\n\n\t\tDLFileVersionLocalServiceUtil.updateDLFileVersion(dlFileVersion);\n\n\t\tFinderCacheUtil.clearCache();\n\n\t\tDLAppServiceUtil.moveFileEntryToTrash(fileEntry.getFileEntryId());\n\t}","commit_id":"28103b5d70d705a44e59b4fa70d83db4919d14ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFindByMisversioned() throws Exception {\n\t\t_fileVersion.setFileEntryId(1111);\n\n\t\tDLFileVersionLocalServiceUtil.updateDLFileVersion(_fileVersion);\n\n\t\tList<DLFileEntry> list = DLFileEntryFinderUtil.findByMisversioned();\n\n\t\tAssert.assertEquals(list.size(), 1);\n\n\t\tDLFileEntry dlFileEntry = list.get(0);\n\n\t\tAssert.assertEquals(dlFileEntry.getTitle(), \"FE1.txt\");\n\t}","id":28077,"modified_method":"@Test\n\tpublic void testFindByMisversioned() throws Exception {\n\t\t_fileVersion.setFileEntryId(1111);\n\n\t\tDLFileVersionLocalServiceUtil.updateDLFileVersion(_fileVersion);\n\n\t\tList<DLFileEntry> fileEntries =\n\t\t\tDLFileEntryFinderUtil.findByMisversioned();\n\n\t\tAssert.assertEquals(fileEntries.size(), 1);\n\n\t\tDLFileEntry dlFileEntry = fileEntries.get(0);\n\n\t\tAssert.assertEquals(dlFileEntry.getTitle(), \"FE1.txt\");\n\t}","commit_id":"28103b5d70d705a44e59b4fa70d83db4919d14ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFindByNoAssets() throws Exception {\n\t\tAssetEntryLocalServiceUtil.deleteEntry(\n\t\t\tDLFileEntry.class.getName(), _fileVersion.getFileEntryId());\n\n\t\tAssetEntryLocalServiceUtil.fetchEntry(\n\t\t\tDLFileEntry.class.getName(), _fileVersion.getFileEntryId());\n\n\t\tList<DLFileEntry> list = DLFileEntryFinderUtil.findByNoAssets();\n\n\t\tAssert.assertEquals(list.size(), 1);\n\n\t\tDLFileEntry dlFileEntry = list.get(0);\n\n\t\tAssert.assertEquals(dlFileEntry.getTitle(), \"FE1.txt\");\n\t}","id":28078,"modified_method":"@Test\n\tpublic void testFindByNoAssets() throws Exception {\n\t\tAssetEntryLocalServiceUtil.deleteEntry(\n\t\t\tDLFileEntry.class.getName(), _fileVersion.getFileEntryId());\n\n\t\tAssetEntryLocalServiceUtil.fetchEntry(\n\t\t\tDLFileEntry.class.getName(), _fileVersion.getFileEntryId());\n\n\t\tList<DLFileEntry> fileEntries = DLFileEntryFinderUtil.findByNoAssets();\n\n\t\tAssert.assertEquals(fileEntries.size(), 1);\n\n\t\tDLFileEntry dlFileEntry = fileEntries.get(0);\n\n\t\tAssert.assertEquals(dlFileEntry.getTitle(), \"FE1.txt\");\n\t}","commit_id":"28103b5d70d705a44e59b4fa70d83db4919d14ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\t_group = ServiceTestUtil.addGroup();\n\n\t\t_folder = DLAppLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(),\n\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID, \"Folder A\", \"\",\n\t\t\tServiceTestUtil.getServiceContext(_group.getGroupId()));\n\n\t\tDLAppLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(),\n\t\t\t_folder.getFolderId(), \"Folder B\", \"\",\n\t\t\tServiceTestUtil.getServiceContext(_group.getGroupId()));\n\n\t\tFolder folder = DLAppLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(),\n\t\t\t_folder.getFolderId(), \"Folder C\", \"\",\n\t\t\tServiceTestUtil.getServiceContext(_group.getGroupId()));\n\n\t\tDLAppServiceUtil.moveFolderToTrash(folder.getFolderId());\n\n\t\tFileEntry fileEntry = DLAppTestUtil.addFileEntry(\n\t\t\t_group.getGroupId(), _folder.getFolderId(), false, \"FE1.txt\",\n\t\t\t\"FE1.txt\");\n\n\t\t_fileShortcut = DLAppTestUtil.addDLFileShortcut(\n\t\t\t_group.getGroupId(), fileEntry);\n\n\t\tDLAppTestUtil.addFileEntry(\n\t\t\t_group.getGroupId(), _folder.getFolderId(),\n\t\t\tContentTypes.APPLICATION_PDF, \"FE2.pdf\", \"FE2.pdf\");\n\n\t\tfileEntry = DLAppTestUtil.addFileEntry(\n\t\t\t_group.getGroupId(), _folder.getFolderId(), false, \"FE3.txt\",\n\t\t\t\"FE3.txt\");\n\n\t\tDLAppServiceUtil.moveFileEntryToTrash(fileEntry.getFileEntryId());\n\t}","id":28079,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\t_group = ServiceTestUtil.addGroup();\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\t_group.getGroupId());\n\n\t\t_folder = DLAppLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(),\n\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID, \"Folder A\",\n\t\t\tStringPool.BLANK, serviceContext);\n\n\t\tDLAppLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(),\n\t\t\t_folder.getFolderId(), \"Folder B\", StringPool.BLANK,\n\t\t\tserviceContext);\n\n\t\tFolder folder = DLAppLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), _group.getGroupId(),\n\t\t\t_folder.getFolderId(), \"Folder C\", StringPool.BLANK,\n\t\t\tserviceContext);\n\n\t\tDLAppServiceUtil.moveFolderToTrash(folder.getFolderId());\n\n\t\tFileEntry fileEntry = DLAppTestUtil.addFileEntry(\n\t\t\t_group.getGroupId(), _folder.getFolderId(), false, \"FE1.txt\",\n\t\t\t\"FE1.txt\");\n\n\t\t_fileShortcut = DLAppTestUtil.addDLFileShortcut(\n\t\t\t_group.getGroupId(), fileEntry);\n\n\t\tDLAppTestUtil.addFileEntry(\n\t\t\t_group.getGroupId(), _folder.getFolderId(),\n\t\t\tContentTypes.APPLICATION_PDF, \"FE2.pdf\", \"FE2.pdf\");\n\n\t\tfileEntry = DLAppTestUtil.addFileEntry(\n\t\t\t_group.getGroupId(), _folder.getFolderId(), false, \"FE3.txt\",\n\t\t\t\"FE3.txt\");\n\n\t\tDLAppServiceUtil.moveFileEntryToTrash(fileEntry.getFileEntryId());\n\t}","commit_id":"28103b5d70d705a44e59b4fa70d83db4919d14ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFindF_FE_FS_ByG_F() throws Exception {\n\n\t\tQueryDefinition queryDefinition = new QueryDefinition();\n\n\t\tqueryDefinition.setStatus(WorkflowConstants.STATUS_APPROVED);\n\n\t\tList<?> list = DLFolderFinderUtil.filterFindF_FE_FS_ByG_F_M_M(\n\t\t\t_group.getGroupId(), _folder.getFolderId(),\n\t\t\tnew String[] {ContentTypes.TEXT_PLAIN}, false, queryDefinition);\n\n\t\tAssert.assertEquals(list.size(), 3);\n\n\t\tfor (Object obj : list) {\n\t\t\tif (obj instanceof DLFolder) {\n\t\t\t\tAssert.assertEquals(((DLFolder)obj).getName(), \"Folder B\");\n\t\t\t}\n\t\t\telse if (obj instanceof DLFileEntry) {\n\t\t\t\tAssert.assertEquals(((DLFileEntry)obj).getTitle(), \"FE1.txt\");\n\t\t\t}\n\t\t\telse if (obj instanceof DLFileShortcut) {\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t((DLFileShortcut)obj).getFileShortcutId(),\n\t\t\t\t\t_fileShortcut.getFileShortcutId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tAssert.fail(\"Invalid model returned: \" + obj.getClass());\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}","id":28080,"modified_method":"@Test\n\tpublic void testFindF_FE_FS_ByG_F() throws Exception {\n\t\tQueryDefinition queryDefinition = new QueryDefinition();\n\n\t\tqueryDefinition.setStatus(WorkflowConstants.STATUS_APPROVED);\n\n\t\tList results = DLFolderFinderUtil.filterFindF_FE_FS_ByG_F_M_M(\n\t\t\t_group.getGroupId(), _folder.getFolderId(),\n\t\t\tnew String[] {ContentTypes.TEXT_PLAIN}, false, queryDefinition);\n\n\t\tAssert.assertEquals(results.size(), 3);\n\n\t\tfor (Object result : results) {\n\t\t\tif (result instanceof DLFolder) {\n\t\t\t\tDLFolder dlFolder = (DLFolder)result;\n\n\t\t\t\tAssert.assertEquals(dlFolder.getName(), \"Folder B\");\n\t\t\t}\n\t\t\telse if (result instanceof DLFileEntry) {\n\t\t\t\tDLFileEntry dlFileEntry = (DLFileEntry)result;\n\n\t\t\t\tAssert.assertEquals(dlFileEntry.getTitle(), \"FE1.txt\");\n\t\t\t}\n\t\t\telse if (result instanceof DLFileShortcut) {\n\t\t\t\tDLFileShortcut fileShortcut = (DLFileShortcut)result;\n\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\tfileShortcut.getFileShortcutId(),\n\t\t\t\t\t_fileShortcut.getFileShortcutId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tAssert.fail(\"Invalid model returned: \" + result.getClass());\n\t\t\t}\n\t\t}\n\t}","commit_id":"28103b5d70d705a44e59b4fa70d83db4919d14ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n   * @return true iff fromType can be casted to toType\n   */\n  public static boolean areTypesConvertible(@NotNull PsiType fromType, @NotNull PsiType toType) {\n    if (isPrimitiveAndNotNull(fromType) || isPrimitiveAndNotNull(toType)) {\n      if (isVoidType(fromType) || isVoidType(toType)) return false;\n      final int fromTypeRank = getTypeRank(fromType);\n      final int toTypeRank = getTypeRank(toType);\n      return fromTypeRank == toTypeRank ||\n             fromTypeRank <= MAX_NUMERIC_RANK && toTypeRank <= MAX_NUMERIC_RANK;\n    }\n\n    //type can be casted via widening reference conversion\n    if (toType.isAssignableFrom(fromType)) return true;\n\n    if (isNullType(fromType) || isNullType(toType)) return true;\n\n    // or narrowing reference conversion\n    return isNarrowingReferenceConversionAllowed(fromType, toType);\n  }","id":28081,"modified_method":"/**\n   * @return true iff fromType can be casted to toType\n   */\n  public static boolean areTypesConvertible(@NotNull PsiType fromType, @NotNull PsiType toType) {\n    final boolean fromIsPrimitive = isPrimitiveAndNotNull(fromType);\n    final boolean toIsPrimitive = isPrimitiveAndNotNull(toType);\n    if (fromIsPrimitive || toIsPrimitive) {\n      if (isVoidType(fromType) || isVoidType(toType)) return false;\n      final int fromTypeRank = getTypeRank(fromType);\n      final int toTypeRank = getTypeRank(toType);\n      if (!toIsPrimitive) return fromTypeRank == toTypeRank;\n      if (!fromIsPrimitive) {\n        if (fromTypeRank == toTypeRank) return true;\n        return fromTypeRank <= MAX_NUMERIC_RANK && toTypeRank <= MAX_NUMERIC_RANK && fromTypeRank < toTypeRank;\n      }\n      return fromTypeRank == toTypeRank ||\n             fromTypeRank <= MAX_NUMERIC_RANK && toTypeRank <= MAX_NUMERIC_RANK;\n    }\n\n    //type can be casted via widening reference conversion\n    if (toType.isAssignableFrom(fromType)) return true;\n\n    if (isNullType(fromType) || isNullType(toType)) return true;\n\n    // or narrowing reference conversion\n    return isNarrowingReferenceConversionAllowed(fromType, toType);\n  }","commit_id":"0baf099ee0da291e62b8f8fd97d3692b274676f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiBinaryExpression)){\n            return false;\n        }\n        if(ErrorUtil.containsError(element)){\n            return false;\n        }\n        final PsiBinaryExpression expression = (PsiBinaryExpression) element;\n        final PsiJavaToken sign = expression.getOperationSign();\n        final IElementType tokenType = sign.getTokenType();\n        if(!tokenType.equals(JavaTokenType.EQEQ) &&\n                !tokenType.equals(JavaTokenType.NE)){\n            return false;\n        }\n        final PsiExpression lhs = expression.getLOperand();\n        final PsiExpression rhs = expression.getROperand();\n        if(rhs == null){\n            return false;\n        }\n        return BoolUtils.isBooleanLiteral(lhs) ||\n                BoolUtils.isBooleanLiteral(rhs);\n    }","id":28082,"modified_method":"public boolean satisfiedBy(PsiElement element){\n\t\tif(!(element instanceof PsiBinaryExpression)){\n\t\t\treturn false;\n\t\t}\n\t\tfinal PsiBinaryExpression expression = (PsiBinaryExpression) element;\n\t\tfinal PsiType type = expression.getType();\n\t\tif (!PsiType.BOOLEAN.equals(type)){\n\t\t\treturn false;\n\t\t}\n\t\tfinal PsiJavaToken sign = expression.getOperationSign();\n\t\tfinal IElementType tokenType = sign.getTokenType();\n\t\tif(!tokenType.equals(JavaTokenType.EQEQ) &&\n\t\t\t\t!tokenType.equals(JavaTokenType.NE)){\n\t\t\treturn false;\n\t\t}\n\t\tfinal PsiExpression lhs = expression.getLOperand();\n\t\tfinal PsiExpression rhs = expression.getROperand();\n\t\tif(rhs == null){\n\t\t\treturn false;\n\t\t}\n\t\tif (!BoolUtils.isBooleanLiteral(lhs) &&\n\t\t\t\t!BoolUtils.isBooleanLiteral(rhs)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !ErrorUtil.containsError(element);\n\t}","commit_id":"98ab5a6985e6da9d25cae3a37d988edab0f3fd62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiBinaryExpression)){\n            return false;\n        }\n        if(ErrorUtil.containsError(element)){\n            return false;\n        }\n        final PsiBinaryExpression expression = (PsiBinaryExpression) element;\n\n        final PsiExpression lhs = expression.getLOperand();\n        final PsiExpression rhs = expression.getROperand();\n        if(rhs == null){\n            return false;\n        }\n        return ComparisonUtils.isComparison((PsiExpression) element);\n    }","id":28083,"modified_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiBinaryExpression)){\n            return false;\n        }\n        final PsiBinaryExpression expression = (PsiBinaryExpression) element;\n        final PsiExpression rhs = expression.getROperand();\n        if(rhs == null){\n            return false;\n        }\n\t    if (!ComparisonUtils.isComparison((PsiExpression)element)) {\n\t\t    return false;\n\t    }\n\t    return !ErrorUtil.containsError(element);\n    }","commit_id":"98ab5a6985e6da9d25cae3a37d988edab0f3fd62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiBinaryExpression)){\n            return false;\n        }\n        if(ErrorUtil.containsError(element)){\n            return false;\n        }\n        final PsiBinaryExpression expression = (PsiBinaryExpression) element;\n        final PsiJavaToken sign = expression.getOperationSign();\n        final IElementType tokenType = sign.getTokenType();\n        return tokenType.equals(JavaTokenType.ANDAND) ||\n                tokenType.equals(JavaTokenType.OROR);\n    }","id":28084,"modified_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiBinaryExpression)){\n            return false;\n        }\n        final PsiBinaryExpression expression = (PsiBinaryExpression) element;\n        final PsiJavaToken sign = expression.getOperationSign();\n        final IElementType tokenType = sign.getTokenType();\n\t    if (!tokenType.equals(JavaTokenType.ANDAND) &&\n\t\t\t    !tokenType.equals(JavaTokenType.OROR)) {\n\t\t    return false;\n\t    }\n\t    return !ErrorUtil.containsError(element);\n    }","commit_id":"98ab5a6985e6da9d25cae3a37d988edab0f3fd62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiBinaryExpression)){\n            return false;\n        }\n        if(ErrorUtil.containsError(element)){\n            return false;\n        }\n        final PsiBinaryExpression expression = (PsiBinaryExpression) element;\n        final PsiJavaToken sign = expression.getOperationSign();\n        final IElementType tokenType = sign.getTokenType();\n        if(!tokenType.equals(JavaTokenType.NE) &&\n                !tokenType.equals(JavaTokenType.EQEQ)){\n            return false;\n        }\n        final PsiExpression lhs = expression.getLOperand();\n\t    final String lhsText = lhs.getText();\n\t    if (PsiKeyword.NULL.equals(lhsText)) {\n\t\t    return false;\n\t    }\n        final PsiType lhsType = lhs.getType();\n        if(lhsType == null){\n            return false;\n        }\n        final PsiExpression rhs = expression.getROperand();\n        if(rhs == null){\n            return false;\n        }\n\t    final String rhsText = rhs.getText();\n\t    if (PsiKeyword.NULL.equals(rhsText)) {\n\t\t    return false;\n\t    }\n        final PsiType rhsType = rhs.getType();\n        if(rhsType == null){\n            return false;\n        }\n        return !TypeConversionUtil.isPrimitiveAndNotNull(lhsType) &&\n                !TypeConversionUtil.isPrimitiveAndNotNull(rhsType);\n    }","id":28085,"modified_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiBinaryExpression)){\n            return false;\n        }\n        final PsiBinaryExpression expression = (PsiBinaryExpression) element;\n        final PsiJavaToken sign = expression.getOperationSign();\n        final IElementType tokenType = sign.getTokenType();\n        if(!tokenType.equals(JavaTokenType.NE) &&\n                !tokenType.equals(JavaTokenType.EQEQ)){\n            return false;\n        }\n        final PsiExpression lhs = expression.getLOperand();\n\t    final String lhsText = lhs.getText();\n\t    if (PsiKeyword.NULL.equals(lhsText)) {\n\t\t    return false;\n\t    }\n        final PsiType lhsType = lhs.getType();\n        if(lhsType == null){\n            return false;\n        }\n        final PsiExpression rhs = expression.getROperand();\n        if(rhs == null){\n            return false;\n        }\n\t    final String rhsText = rhs.getText();\n\t    if (PsiKeyword.NULL.equals(rhsText)) {\n\t\t    return false;\n\t    }\n        final PsiType rhsType = rhs.getType();\n        if(rhsType == null){\n            return false;\n        }\n\t    if (TypeConversionUtil.isPrimitiveAndNotNull(lhsType) ||\n\t\t\t    TypeConversionUtil.isPrimitiveAndNotNull(rhsType)) {\n\t\t    return false;\n\t    }\n\t    return !ErrorUtil.containsError(element);\n    }","commit_id":"98ab5a6985e6da9d25cae3a37d988edab0f3fd62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static SNode _quotation_createNode_ce40do_a01a8(Object parameter_1, Object parameter_2) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_3 = null;\n    SNode quotedNode_4 = null;\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    SNode quotedNode_7 = null;\n    SNode quotedNode_8 = null;\n    SNode quotedNode_9 = null;\n    SNode quotedNode_10 = null;\n    SNode quotedNode_11 = null;\n    SNode quotedNode_12 = null;\n    SNode quotedNode_13 = null;\n    SNode quotedNode_14 = null;\n    SNode quotedNode_15 = null;\n    SNode quotedNode_16 = null;\n    SNode quotedNode_17 = null;\n    SNode quotedNode_18 = null;\n    SNode quotedNode_19 = null;\n    SNode quotedNode_20 = null;\n    SNode quotedNode_21 = null;\n    SNode quotedNode_22 = null;\n    SNode quotedNode_23 = null;\n    SNode quotedNode_24 = null;\n    SNode quotedNode_25 = null;\n    SNode quotedNode_26 = null;\n    SNode quotedNode_27 = null;\n    SNode quotedNode_28 = null;\n    SNode quotedNode_29 = null;\n    SNode quotedNode_30 = null;\n    SNode quotedNode_31 = null;\n    SNode quotedNode_32 = null;\n    SNode quotedNode_33 = null;\n    SNode quotedNode_34 = null;\n    SNode quotedNode_35 = null;\n    SNode quotedNode_36 = null;\n    SNode quotedNode_37 = null;\n    SNode quotedNode_38 = null;\n    SNode quotedNode_39 = null;\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, \"jetbrains.mps.baseLanguage.structure.BlockStatement\"), null, null, false);\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\"), null, null, false);\n    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7f0L, \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\"), null, null, false);\n    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7efL, \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_8, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), \"models\");\n    quotedNode_11 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_17 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x10a2d94c0cdL, \"jetbrains.mps.lang.smodel.structure.SModelType\"), null, null, false);\n    quotedNode_11.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_17);\n    quotedNode_8.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"), quotedNode_11);\n    quotedNode_12 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940dabe4aL, \"jetbrains.mps.baseLanguage.structure.CastExpression\"), null, null, false);\n    quotedNode_18 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_24 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x10a2d94c0cdL, \"jetbrains.mps.lang.smodel.structure.SModelType\"), null, null, false);\n    quotedNode_18.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_24);\n    quotedNode_12.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940dabe4aL, 0xf940dabe4bL, \"type\"), quotedNode_18);\n    quotedNode_19 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, \"jetbrains.mps.baseLanguage.structure.DotExpression\"), null, null, false);\n    quotedNode_25 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, \"jetbrains.mps.baseLanguage.structure.VariableReference\"), null, null, false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_25, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, \"variableDeclaration\"), (SNode) parameter_1);\n    quotedNode_19.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, \"operand\"), quotedNode_25);\n    quotedNode_26 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x118154a6332L, \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\"), null, null, false);\n    quotedNode_26.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, \"baseMethodDeclaration\"), SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, \"baseMethodDeclaration\"), quotedNode_26, facade.createModelReference(\"8865b7a8-5271-43d3-884c-6fd1d9cfdd34/f:java_stub#8865b7a8-5271-43d3-884c-6fd1d9cfdd34#org.jetbrains.mps.openapi.module(MPS.OpenAPI/org.jetbrains.mps.openapi.module@java_stub)\"), facade.createNodeId(\"~SModule.getModels():java.lang.Iterable\")));\n    quotedNode_19.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, \"operation\"), quotedNode_26);\n    quotedNode_12.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940dabe4aL, 0xf940dabe4cL, \"expression\"), quotedNode_19);\n    quotedNode_8.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37a7f6eL, 0xf8c37f506eL, \"initializer\"), quotedNode_12);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7f0L, 0xf8cc67c7f1L, \"localVariableDeclaration\"), quotedNode_8);\n    quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"), quotedNode_5);\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7f0L, \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\"), null, null, false);\n    quotedNode_9 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7efL, \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_9, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), \"nodes\");\n    quotedNode_13 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_20 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, \"jetbrains.mps.lang.smodel.structure.SNodeType\"), null, null, false);\n    quotedNode_20.setReference(MetaAdapterFactory.getReferenceLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, 0x1090e46ca51L, \"concept\"), SReference.create(MetaAdapterFactory.getReferenceLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, 0x1090e46ca51L, \"concept\"), quotedNode_20, facade.createModelReference(\"r:00000000-0000-4000-0000-011c895902ca(jetbrains.mps.baseLanguage.structure)\"), facade.createNodeId(\"1068390468198\")));\n    quotedNode_13.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_20);\n    quotedNode_9.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"), quotedNode_13);\n    quotedNode_14 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, \"jetbrains.mps.baseLanguage.structure.DotExpression\"), null, null, false);\n    quotedNode_21 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, \"jetbrains.mps.baseLanguage.structure.VariableReference\"), null, null, false);\n    quotedNode_14.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, \"operand\"), quotedNode_21);\n    quotedNode_22 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x117d06362dcL, \"jetbrains.mps.baseLanguage.collections.structure.TranslateOperation\"), null, null, false);\n    quotedNode_27 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, \"jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral\"), null, null, false);\n    quotedNode_30 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\"), null, null, false);\n    quotedNode_34 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b213L, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\"), null, null, false);\n    quotedNode_36 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, \"jetbrains.mps.baseLanguage.structure.DotExpression\"), null, null, false);\n    quotedNode_37 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, \"jetbrains.mps.baseLanguage.structure.VariableReference\"), null, null, false);\n    quotedNode_36.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, \"operand\"), quotedNode_37);\n    quotedNode_38 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x110b8590897L, \"jetbrains.mps.lang.smodel.structure.Model_NodesOperation\"), null, null, false);\n    quotedNode_39 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x1120c45902cL, \"jetbrains.mps.lang.smodel.structure.RefConcept_Reference\"), null, null, false);\n    quotedNode_39.setReference(MetaAdapterFactory.getReferenceLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x1120c45902cL, 0x1120c45d024L, \"conceptDeclaration\"), SReference.create(MetaAdapterFactory.getReferenceLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x1120c45902cL, 0x1120c45d024L, \"conceptDeclaration\"), quotedNode_39, facade.createModelReference(\"r:00000000-0000-4000-0000-011c895902ca(jetbrains.mps.baseLanguage.structure)\"), facade.createNodeId(\"1068390468198\")));\n    quotedNode_38.addChild(MetaAdapterFactory.getContainmentLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x110b8590897L, 0x1869004155f6ce22L, \"conceptArgument\"), quotedNode_39);\n    quotedNode_36.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, \"operation\"), quotedNode_38);\n    quotedNode_34.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b213L, 0xf8cc56b214L, \"expression\"), quotedNode_36);\n    quotedNode_30.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"), quotedNode_34);\n    quotedNode_27.addChild(MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf0522fL, \"body\"), quotedNode_30);\n    quotedNode_31 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x118374464e4L, \"jetbrains.mps.baseLanguage.collections.structure.SmartClosureParameterDeclaration\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_31, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), \"model\");\n    quotedNode_35 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x431d52a5d09a4ea9L, \"jetbrains.mps.baseLanguage.structure.UndefinedType\"), null, null, false);\n    quotedNode_31.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"), quotedNode_35);\n    quotedNode_27.addChild(MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf02c34L, \"parameter\"), quotedNode_31);\n    quotedNode_22.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x1188372895aL, 0x11883748452L, \"closure\"), quotedNode_27);\n    quotedNode_14.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, \"operation\"), quotedNode_22);\n    quotedNode_9.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37a7f6eL, 0xf8c37f506eL, \"initializer\"), quotedNode_14);\n    quotedNode_6.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7f0L, 0xf8cc67c7f1L, \"localVariableDeclaration\"), quotedNode_9);\n    quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"), quotedNode_6);\n    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b213L, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\"), null, null, false);\n    quotedNode_10 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, \"jetbrains.mps.baseLanguage.structure.DotExpression\"), null, null, false);\n    quotedNode_15 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, \"jetbrains.mps.baseLanguage.structure.VariableReference\"), null, null, false);\n    quotedNode_10.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, \"operand\"), quotedNode_15);\n    quotedNode_16 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x1188e700c31L, \"jetbrains.mps.baseLanguage.collections.structure.VisitAllOperation\"), null, null, false);\n    quotedNode_23 = (SNode) parameter_2;\n    if (quotedNode_23 != null) {\n      quotedNode_16.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x1188372895aL, 0x11883748452L, \"closure\"), HUtil.copyIfNecessary(quotedNode_23));\n    }\n    quotedNode_10.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, \"operation\"), quotedNode_16);\n    quotedNode_7.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b213L, 0xf8cc56b214L, \"expression\"), quotedNode_10);\n    quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"), quotedNode_7);\n    quotedNode_3.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\"), quotedNode_4);\n    quotedNode_15.setReferenceTarget(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, \"variableDeclaration\"), quotedNode_9);\n    quotedNode_21.setReferenceTarget(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, \"variableDeclaration\"), quotedNode_8);\n    quotedNode_37.setReferenceTarget(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, \"variableDeclaration\"), quotedNode_31);\n    return quotedNode_3;\n  }","id":28086,"modified_method":"private static SNode _quotation_createNode_ce40do_a01a8(Object parameter_1, Object parameter_2, Object parameter_3, Object parameter_4) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_5 = null;\n    SNode quotedNode_6 = null;\n    SNode quotedNode_7 = null;\n    SNode quotedNode_8 = null;\n    SNode quotedNode_9 = null;\n    SNode quotedNode_10 = null;\n    SNode quotedNode_11 = null;\n    SNode quotedNode_12 = null;\n    SNode quotedNode_13 = null;\n    SNode quotedNode_14 = null;\n    SNode quotedNode_15 = null;\n    SNode quotedNode_16 = null;\n    SNode quotedNode_17 = null;\n    SNode quotedNode_18 = null;\n    SNode quotedNode_19 = null;\n    SNode quotedNode_20 = null;\n    SNode quotedNode_21 = null;\n    SNode quotedNode_22 = null;\n    SNode quotedNode_23 = null;\n    SNode quotedNode_24 = null;\n    SNode quotedNode_25 = null;\n    SNode quotedNode_26 = null;\n    SNode quotedNode_27 = null;\n    SNode quotedNode_28 = null;\n    SNode quotedNode_29 = null;\n    SNode quotedNode_30 = null;\n    SNode quotedNode_31 = null;\n    SNode quotedNode_32 = null;\n    SNode quotedNode_33 = null;\n    SNode quotedNode_34 = null;\n    SNode quotedNode_35 = null;\n    SNode quotedNode_36 = null;\n    SNode quotedNode_37 = null;\n    SNode quotedNode_38 = null;\n    SNode quotedNode_39 = null;\n    SNode quotedNode_40 = null;\n    SNode quotedNode_41 = null;\n    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, \"jetbrains.mps.baseLanguage.structure.BlockStatement\"), null, null, false);\n    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\"), null, null, false);\n    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7f0L, \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\"), null, null, false);\n    quotedNode_10 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7efL, \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_10, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), \"models\");\n    quotedNode_13 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_19 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x10a2d94c0cdL, \"jetbrains.mps.lang.smodel.structure.SModelType\"), null, null, false);\n    quotedNode_13.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_19);\n    quotedNode_10.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"), quotedNode_13);\n    quotedNode_14 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940dabe4aL, \"jetbrains.mps.baseLanguage.structure.CastExpression\"), null, null, false);\n    quotedNode_20 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_26 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x10a2d94c0cdL, \"jetbrains.mps.lang.smodel.structure.SModelType\"), null, null, false);\n    quotedNode_20.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_26);\n    quotedNode_14.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940dabe4aL, 0xf940dabe4bL, \"type\"), quotedNode_20);\n    quotedNode_21 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, \"jetbrains.mps.baseLanguage.structure.DotExpression\"), null, null, false);\n    quotedNode_27 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, \"jetbrains.mps.baseLanguage.structure.VariableReference\"), null, null, false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_27, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, \"variableDeclaration\"), (SNode) parameter_1);\n    quotedNode_21.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, \"operand\"), quotedNode_27);\n    quotedNode_28 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x118154a6332L, \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\"), null, null, false);\n    quotedNode_28.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, \"baseMethodDeclaration\"), SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, \"baseMethodDeclaration\"), quotedNode_28, facade.createModelReference(\"8865b7a8-5271-43d3-884c-6fd1d9cfdd34/f:java_stub#8865b7a8-5271-43d3-884c-6fd1d9cfdd34#org.jetbrains.mps.openapi.module(MPS.OpenAPI/org.jetbrains.mps.openapi.module@java_stub)\"), facade.createNodeId(\"~SModule.getModels():java.lang.Iterable\")));\n    quotedNode_21.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, \"operation\"), quotedNode_28);\n    quotedNode_14.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940dabe4aL, 0xf940dabe4cL, \"expression\"), quotedNode_21);\n    quotedNode_10.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37a7f6eL, 0xf8c37f506eL, \"initializer\"), quotedNode_14);\n    quotedNode_7.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7f0L, 0xf8cc67c7f1L, \"localVariableDeclaration\"), quotedNode_10);\n    quotedNode_6.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"), quotedNode_7);\n    quotedNode_8 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7f0L, \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\"), null, null, false);\n    quotedNode_11 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7efL, \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_11, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), \"nodes\");\n    quotedNode_15 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, \"jetbrains.mps.baseLanguage.collections.structure.SequenceType\"), null, null, false);\n    quotedNode_22 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, \"jetbrains.mps.lang.smodel.structure.SNodeType\"), null, null, false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_22, MetaAdapterFactory.getReferenceLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, 0x1090e46ca51L, \"concept\"), (SNode) parameter_2);\n    quotedNode_15.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"), quotedNode_22);\n    quotedNode_11.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"), quotedNode_15);\n    quotedNode_16 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, \"jetbrains.mps.baseLanguage.structure.DotExpression\"), null, null, false);\n    quotedNode_23 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, \"jetbrains.mps.baseLanguage.structure.VariableReference\"), null, null, false);\n    quotedNode_16.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, \"operand\"), quotedNode_23);\n    quotedNode_24 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x117d06362dcL, \"jetbrains.mps.baseLanguage.collections.structure.TranslateOperation\"), null, null, false);\n    quotedNode_29 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, \"jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral\"), null, null, false);\n    quotedNode_32 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\"), null, null, false);\n    quotedNode_36 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b213L, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\"), null, null, false);\n    quotedNode_38 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, \"jetbrains.mps.baseLanguage.structure.DotExpression\"), null, null, false);\n    quotedNode_39 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, \"jetbrains.mps.baseLanguage.structure.VariableReference\"), null, null, false);\n    quotedNode_38.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, \"operand\"), quotedNode_39);\n    quotedNode_40 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x110b8590897L, \"jetbrains.mps.lang.smodel.structure.Model_NodesOperation\"), null, null, false);\n    quotedNode_41 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x1120c45902cL, \"jetbrains.mps.lang.smodel.structure.RefConcept_Reference\"), null, null, false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_41, MetaAdapterFactory.getReferenceLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x1120c45902cL, 0x1120c45d024L, \"conceptDeclaration\"), (SNode) parameter_3);\n    quotedNode_40.addChild(MetaAdapterFactory.getContainmentLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x110b8590897L, 0x1869004155f6ce22L, \"conceptArgument\"), quotedNode_41);\n    quotedNode_38.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, \"operation\"), quotedNode_40);\n    quotedNode_36.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b213L, 0xf8cc56b214L, \"expression\"), quotedNode_38);\n    quotedNode_32.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"), quotedNode_36);\n    quotedNode_29.addChild(MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf0522fL, \"body\"), quotedNode_32);\n    quotedNode_33 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x118374464e4L, \"jetbrains.mps.baseLanguage.collections.structure.SmartClosureParameterDeclaration\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_33, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), \"model\");\n    quotedNode_37 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x431d52a5d09a4ea9L, \"jetbrains.mps.baseLanguage.structure.UndefinedType\"), null, null, false);\n    quotedNode_33.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"), quotedNode_37);\n    quotedNode_29.addChild(MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf02c34L, \"parameter\"), quotedNode_33);\n    quotedNode_24.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x1188372895aL, 0x11883748452L, \"closure\"), quotedNode_29);\n    quotedNode_16.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, \"operation\"), quotedNode_24);\n    quotedNode_11.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37a7f6eL, 0xf8c37f506eL, \"initializer\"), quotedNode_16);\n    quotedNode_8.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc67c7f0L, 0xf8cc67c7f1L, \"localVariableDeclaration\"), quotedNode_11);\n    quotedNode_6.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"), quotedNode_8);\n    quotedNode_9 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b213L, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\"), null, null, false);\n    quotedNode_12 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, \"jetbrains.mps.baseLanguage.structure.DotExpression\"), null, null, false);\n    quotedNode_17 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, \"jetbrains.mps.baseLanguage.structure.VariableReference\"), null, null, false);\n    quotedNode_12.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, \"operand\"), quotedNode_17);\n    quotedNode_18 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x1188e700c31L, \"jetbrains.mps.baseLanguage.collections.structure.VisitAllOperation\"), null, null, false);\n    quotedNode_25 = (SNode) parameter_4;\n    if (quotedNode_25 != null) {\n      quotedNode_18.addChild(MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x1188372895aL, 0x11883748452L, \"closure\"), HUtil.copyIfNecessary(quotedNode_25));\n    }\n    quotedNode_12.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, \"operation\"), quotedNode_18);\n    quotedNode_9.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b213L, 0xf8cc56b214L, \"expression\"), quotedNode_12);\n    quotedNode_6.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"), quotedNode_9);\n    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc092b6b77L, 0xfc092b6b78L, \"statements\"), quotedNode_6);\n    quotedNode_17.setReferenceTarget(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, \"variableDeclaration\"), quotedNode_11);\n    quotedNode_23.setReferenceTarget(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, \"variableDeclaration\"), quotedNode_10);\n    quotedNode_39.setReferenceTarget(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, \"variableDeclaration\"), quotedNode_33);\n    return quotedNode_5;\n  }","commit_id":"02d3091554958da871402e07201e43210fada61a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode _quotation_createNode_ce40do_a0d0i() {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_1 = null;\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    SNode quotedNode_4 = null;\n    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, \"jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral\"), null, null, false);\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e94L, \"jetbrains.mps.baseLanguage.structure.ParameterDeclaration\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_2, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), \"node\");\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, \"jetbrains.mps.lang.smodel.structure.SNodeType\"), null, null, false);\n    quotedNode_4.setReference(MetaAdapterFactory.getReferenceLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, 0x1090e46ca51L, \"concept\"), SReference.create(MetaAdapterFactory.getReferenceLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, 0x1090e46ca51L, \"concept\"), quotedNode_4, facade.createModelReference(\"r:00000000-0000-4000-0000-011c895902ca(jetbrains.mps.baseLanguage.structure)\"), facade.createNodeId(\"1068390468198\")));\n    quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"), quotedNode_4);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf02c34L, \"parameter\"), quotedNode_2);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\"), null, null, false);\n    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf0522fL, \"body\"), quotedNode_3);\n    return quotedNode_1;\n  }","id":28087,"modified_method":"private static SNode _quotation_createNode_ce40do_a0d0i(Object parameter_1) {\n    PersistenceFacade facade = PersistenceFacade.getInstance();\n    SNode quotedNode_2 = null;\n    SNode quotedNode_3 = null;\n    SNode quotedNode_4 = null;\n    SNode quotedNode_5 = null;\n    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, \"jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral\"), null, null, false);\n    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e94L, \"jetbrains.mps.baseLanguage.structure.ParameterDeclaration\"), null, null, false);\n    SNodeAccessUtil.setProperty(quotedNode_3, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"), \"node\");\n    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, \"jetbrains.mps.lang.smodel.structure.SNodeType\"), null, null, false);\n    SNodeAccessUtil.setReferenceTarget(quotedNode_5, MetaAdapterFactory.getReferenceLink(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x108f968b3caL, 0x1090e46ca51L, \"concept\"), (SNode) parameter_1);\n    quotedNode_3.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, \"type\"), quotedNode_5);\n    quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf02c34L, \"parameter\"), quotedNode_3);\n    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, \"jetbrains.mps.baseLanguage.structure.StatementList\"), null, null, false);\n    quotedNode_2.addChild(MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf0522fL, \"body\"), quotedNode_4);\n    return quotedNode_2;\n  }","commit_id":"02d3091554958da871402e07201e43210fada61a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode replaceExactInstances(SNode oldConcept, SNode newConcept, MigrationScriptBuilder builder) {\n    SNode oldNode = _quotation_createNode_ce40do_a0a0i();\n    SNode newNode = _quotation_createNode_ce40do_a0b0i(newConcept);\n\n    SNode moveConceptMemberInstancesStatements = _quotation_createNode_ce40do_a0d0i();\n    SNode nodeParameter = ListSequence.fromList(SLinkOperations.getChildren(moveConceptMemberInstancesStatements, MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf02c34L, \"parameter\"))).first();\n    {\n      Iterator<SNode> oldProp_it = ListSequence.fromList(SLinkOperations.getChildren(oldConcept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, \"propertyDeclaration\"))).iterator();\n      Iterator<SNode> newProp_it = ListSequence.fromList(SLinkOperations.getChildren(newConcept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, \"propertyDeclaration\"))).iterator();\n      SNode oldProp_var;\n      SNode newProp_var;\n      while (oldProp_it.hasNext() && newProp_it.hasNext()) {\n        oldProp_var = oldProp_it.next();\n        newProp_var = newProp_it.next();\n        ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(moveConceptMemberInstancesStatements, MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf0522fL, \"body\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(_quotation_createNode_ce40do_a0a0a5a8(nodeParameter, oldProp_var, oldConcept, newConcept, newProp_var));\n      }\n    }\n    {\n      Iterator<SNode> oldLink_it = ListSequence.fromList(SLinkOperations.getChildren(oldConcept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\"))).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"reference\", \"reference\");\n        }\n      }).iterator();\n      Iterator<SNode> newLink_it = ListSequence.fromList(SLinkOperations.getChildren(newConcept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\"))).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"reference\", \"reference\");\n        }\n      }).iterator();\n      SNode oldLink_var;\n      SNode newLink_var;\n      while (oldLink_it.hasNext() && newLink_it.hasNext()) {\n        oldLink_var = oldLink_it.next();\n        newLink_var = newLink_it.next();\n        ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(moveConceptMemberInstancesStatements, MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf0522fL, \"body\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(_quotation_createNode_ce40do_a0a0a6a8(nodeParameter, oldConcept, oldLink_var, newConcept, newLink_var));\n      }\n    }\n    {\n      Iterator<SNode> oldLink_it = ListSequence.fromList(SLinkOperations.getChildren(oldConcept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\"))).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"aggregation\", \"reference\");\n        }\n      }).iterator();\n      Iterator<SNode> newLink_it = ListSequence.fromList(SLinkOperations.getChildren(newConcept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\"))).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"aggregation\", \"reference\");\n        }\n      }).iterator();\n      SNode oldLink_var;\n      SNode newLink_var;\n      while (oldLink_it.hasNext() && newLink_it.hasNext()) {\n        oldLink_var = oldLink_it.next();\n        newLink_var = newLink_it.next();\n        ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(moveConceptMemberInstancesStatements, MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf0522fL, \"body\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(_quotation_createNode_ce40do_a0a0a7a8(nodeParameter, oldConcept, oldLink_var, newConcept, newLink_var));\n      }\n    }\n    ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(moveConceptMemberInstancesStatements, MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf0522fL, \"body\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(_quotation_createNode_ce40do_a0a8a8(nodeParameter, newConcept, nodeParameter, oldConcept));\n\n    return _quotation_createNode_ce40do_a01a8(builder.getExecuteMethodModuleParameter(), moveConceptMemberInstancesStatements);\n  }","id":28088,"modified_method":"public static SNode replaceExactInstances(SNode oldConcept, SNode newConcept, MigrationScriptBuilder builder) {\n    SNode oldNode = _quotation_createNode_ce40do_a0a0i();\n    SNode newNode = _quotation_createNode_ce40do_a0b0i(newConcept);\n\n    SNode moveConceptMemberInstancesStatements = _quotation_createNode_ce40do_a0d0i(oldConcept);\n    SNode nodeParameter = ListSequence.fromList(SLinkOperations.getChildren(moveConceptMemberInstancesStatements, MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf02c34L, \"parameter\"))).first();\n    {\n      Iterator<SNode> oldProp_it = ListSequence.fromList(SLinkOperations.getChildren(oldConcept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, \"propertyDeclaration\"))).iterator();\n      Iterator<SNode> newProp_it = ListSequence.fromList(SLinkOperations.getChildren(newConcept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, \"propertyDeclaration\"))).iterator();\n      SNode oldProp_var;\n      SNode newProp_var;\n      while (oldProp_it.hasNext() && newProp_it.hasNext()) {\n        oldProp_var = oldProp_it.next();\n        newProp_var = newProp_it.next();\n        ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(moveConceptMemberInstancesStatements, MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf0522fL, \"body\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(_quotation_createNode_ce40do_a0a0a5a8(nodeParameter, oldProp_var, oldConcept, newConcept, newProp_var));\n      }\n    }\n    {\n      Iterator<SNode> oldLink_it = ListSequence.fromList(SLinkOperations.getChildren(oldConcept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\"))).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"reference\", \"reference\");\n        }\n      }).iterator();\n      Iterator<SNode> newLink_it = ListSequence.fromList(SLinkOperations.getChildren(newConcept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\"))).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"reference\", \"reference\");\n        }\n      }).iterator();\n      SNode oldLink_var;\n      SNode newLink_var;\n      while (oldLink_it.hasNext() && newLink_it.hasNext()) {\n        oldLink_var = oldLink_it.next();\n        newLink_var = newLink_it.next();\n        ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(moveConceptMemberInstancesStatements, MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf0522fL, \"body\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(_quotation_createNode_ce40do_a0a0a6a8(nodeParameter, oldConcept, oldLink_var, newConcept, newLink_var));\n      }\n    }\n    {\n      Iterator<SNode> oldLink_it = ListSequence.fromList(SLinkOperations.getChildren(oldConcept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\"))).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"aggregation\", \"reference\");\n        }\n      }).iterator();\n      Iterator<SNode> newLink_it = ListSequence.fromList(SLinkOperations.getChildren(newConcept, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\"))).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"aggregation\", \"reference\");\n        }\n      }).iterator();\n      SNode oldLink_var;\n      SNode newLink_var;\n      while (oldLink_it.hasNext() && newLink_it.hasNext()) {\n        oldLink_var = oldLink_it.next();\n        newLink_var = newLink_it.next();\n        ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(moveConceptMemberInstancesStatements, MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf0522fL, \"body\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(_quotation_createNode_ce40do_a0a0a7a8(nodeParameter, oldConcept, oldLink_var, newConcept, newLink_var));\n      }\n    }\n    ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(moveConceptMemberInstancesStatements, MetaAdapterFactory.getContainmentLink(0xfd3920347849419dL, 0x907112563d152375L, 0x1174bed3125L, 0x1174bf0522fL, \"body\")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, 0xf8cc6bf961L, \"statement\"))).addElement(_quotation_createNode_ce40do_a0a8a8(nodeParameter, newConcept, nodeParameter, oldConcept));\n\n    return _quotation_createNode_ce40do_a01a8(builder.getExecuteMethodModuleParameter(), oldConcept, oldConcept, moveConceptMemberInstancesStatements);\n  }","commit_id":"02d3091554958da871402e07201e43210fada61a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public boolean isInContext(@NotNull PsiFile file, int offset) {\n        return PsiUtilBase.getLanguageAtOffset(file, offset).isKindOf(JetLanguage.INSTANCE);\n    }","id":28089,"modified_method":"@Override\n    public boolean isInContext(@NotNull PsiFile file, int offset) {\n        if (PsiUtilBase.getLanguageAtOffset(file, offset).isKindOf(JetLanguage.INSTANCE)) {\n            PsiElement element = file.findElementAt(offset);\n            if (element instanceof PsiWhiteSpace) {\n\n            }\n            return element != null && isInContext(element);\n        }\n\n        return false;\n    }","commit_id":"150d856ff1239eb6dc545df8941d1717dba83772","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JetTemplateContextType() {\n        super(\"KOTLIN\", \"Kotlin\", EverywhereContextType.class);\n    }","id":28090,"modified_method":"protected JetTemplateContextType(@NotNull @NonNls String id, @NotNull String presentableName, @Nullable Class<? extends TemplateContextType> baseContextType) {\n        super(id, presentableName, baseContextType);\n    }","commit_id":"150d856ff1239eb6dc545df8941d1717dba83772","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void paintIcon(Component c, Graphics g, int x, int y) {\n      g.setColor(ICON_BACKGROUND_COLOR);\n      g.fillRect(x, y, getIconWidth(), getIconHeight());\n      g.setColor(JBColor.GRAY);\n      g.drawRect(x, y, getIconWidth(), getIconHeight());\n      myIcon.paintIcon(c, g, x, y);\n    }","id":28091,"modified_method":"@Override\n    public void paintIcon(Component c, Graphics g, int x, int y) {\n      Graphics2D g2 = (Graphics2D)g.create();\n      try {\n        Color gutterBackground = EditorColors.GUTTER_BACKGROUND.getDefaultColor();\n        g2.setColor(gutterBackground);\n        g2.fillRoundRect(x, y, getIconWidth(), getIconHeight(), 4, 4);\n        myIcon.paintIcon(c, g2, x, y);\n      } finally {\n        g2.dispose();\n      }\n    }","commit_id":"03153e629c2f3392a103aa9a4117deca2eb31d85","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void paintChildren(Graphics g) {\n    super.paintChildren(g);\n    if (isToDrawCombo()) {\n      myComboIcon.paintIcon(this, g);\n    }\n  }","id":28092,"modified_method":"@Override\n  protected void paintChildren(Graphics g) {\n    super.paintChildren(g);\n    if (isToDrawCombo()) {\n      myComboIcon.paintIcon(this, g);\n      g.setColor(new Color(255, 255, 255, 100));\n      int x = myComboIcon.getIconRec().x - 3;\n      int yTop = myComboIcon.getIconRec().y;\n      int yBottom = yTop + myComboIcon.getIconHeight();\n      g.drawLine(x, yTop + 1, x, yBottom - 3);\n\n    }\n  }","commit_id":"a9cef6f8aaeb524f25c35e3f455879403bdb8d61","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void showPopup() {\n    final ContentManager manager = myUi.myManager;\n    BaseListPopupStep step = new BaseListPopupStep<Content>(null, manager.getContents()) {\n      @Override\n      public PopupStep onChosen(Content selectedValue, boolean finalChoice) {\n        manager.setSelectedContent(selectedValue);\n        return FINAL_CHOICE;\n      }\n\n      @NotNull\n      @Override\n      public String getTextFor(Content value) {\n        return value.getDisplayName();\n      }\n\n      @Override\n      public Icon getIconFor(Content aValue) {\n        return aValue.getIcon();\n      }\n\n      @Override\n      public boolean isMnemonicsNavigationEnabled() {\n        return true;\n      }\n    };\n\n    step.setDefaultOptionIndex(Arrays.asList(manager.getContents()).indexOf(manager.getSelectedContent()));\n\n    ListPopup popup = JBPopupFactory.getInstance().createListPopup(step);\n    popup.setMinimumSize(new Dimension(getPreferredSize().width, 0));\n    popup.showUnderneathOf(this);\n  }","id":28093,"modified_method":"private void showPopup() {\n    if (!isToDrawCombo()) return;\n\n    final ContentManager manager = myUi.myManager;\n    BaseListPopupStep step = new BaseListPopupStep<Content>(null, manager.getContents()) {\n      @Override\n      public PopupStep onChosen(Content selectedValue, boolean finalChoice) {\n        manager.setSelectedContent(selectedValue);\n        return FINAL_CHOICE;\n      }\n\n      @NotNull\n      @Override\n      public String getTextFor(Content value) {\n        return value.getDisplayName();\n      }\n\n      @Override\n      public Icon getIconFor(Content aValue) {\n        return aValue.getIcon();\n      }\n\n      @Override\n      public boolean isMnemonicsNavigationEnabled() {\n        return true;\n      }\n    };\n\n    step.setDefaultOptionIndex(Arrays.asList(manager.getContents()).indexOf(manager.getSelectedContent()));\n\n    ListPopup popup = JBPopupFactory.getInstance().createListPopup(step);\n    popup.setMinimumSize(new Dimension(getPreferredSize().width, 0));\n    popup.showUnderneathOf(this);\n  }","commit_id":"a9cef6f8aaeb524f25c35e3f455879403bdb8d61","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MenuElement[] getPath() {\n    MenuSelectionManager menuselectionmanager = MenuSelectionManager.defaultManager();\n    MenuElement amenuelement[] = menuselectionmanager.getSelectedPath();\n    int i1 = amenuelement.length;\n    if (i1 == 0){\n      return new MenuElement[0];\n    }\n    java.awt.Container container = menuItem.getParent();\n    MenuElement amenuelement1[];\n    if (amenuelement[i1 - 1].getComponent() == container){\n      amenuelement1 = new MenuElement[i1 + 1];\n      System.arraycopy(amenuelement, 0, amenuelement1, 0, i1);\n      amenuelement1[i1] = menuItem;\n    }\n    else{\n      int j1;\n      for(j1 = amenuelement.length - 1; j1 >= 0; j1--){\n        if (amenuelement[j1].getComponent() == container){\n          break;\n        }\n      }\n      amenuelement1 = new MenuElement[j1 + 2];\n      System.arraycopy(amenuelement, 0, amenuelement1, 0, j1 + 1);\n      amenuelement1[j1 + 1] = menuItem;\n    }\n    return amenuelement1;\n  }","id":28094,"modified_method":"public MenuElement[] getPath() {\n    MenuSelectionManager menuselectionmanager = MenuSelectionManager.defaultManager();\n    MenuElement amenuelement[] = menuselectionmanager.getSelectedPath();\n    int i1 = amenuelement.length;\n    if (i1 == 0){\n      return new MenuElement[0];\n    }\n    Container container = menuItem.getParent();\n    MenuElement amenuelement1[];\n    if (amenuelement[i1 - 1].getComponent() == container){\n      amenuelement1 = new MenuElement[i1 + 1];\n      System.arraycopy(amenuelement, 0, amenuelement1, 0, i1);\n      amenuelement1[i1] = menuItem;\n    }\n    else{\n      int j1;\n      for(j1 = amenuelement.length - 1; j1 >= 0; j1--){\n        if (amenuelement[j1].getComponent() == container){\n          break;\n        }\n      }\n      amenuelement1 = new MenuElement[j1 + 2];\n      System.arraycopy(amenuelement, 0, amenuelement1, 0, j1 + 1);\n      amenuelement1[j1 + 1] = menuItem;\n    }\n    return amenuelement1;\n  }","commit_id":"6441cc5b19582572a5b4310a1c3143b5871b0b97","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void paint(Graphics g, JComponent comp) {\n    UIUtil.applyRenderingHints(g);\n    JMenu jMenu = (JMenu)comp;\n    ButtonModel buttonmodel = jMenu.getModel();\n    int mnemonicIndex = jMenu.getDisplayedMnemonicIndex();\n    Icon icon = getIcon();\n    Icon allowedIcon = getAllowedIcon();\n    Insets insets = comp.getInsets();\n    resetRects();\n    ourViewRect.setBounds(0, 0, jMenu.getWidth(), jMenu.getHeight());\n    ourViewRect.x += insets.left;\n    ourViewRect.y += insets.top;\n    ourViewRect.width -= insets.right + ourViewRect.x;\n    ourViewRect.height -= insets.bottom + ourViewRect.y;\n    Font font = g.getFont();\n    Font font1 = comp.getFont();\n    g.setFont(font1);\n    FontMetrics fontmetrics = g.getFontMetrics(font1);\n    String s1 = layoutMenuItem(\n      fontmetrics,\n      jMenu.getText(),\n      icon,\n      allowedIcon,\n      arrowIcon,\n      jMenu.getVerticalAlignment(),\n      jMenu.getHorizontalAlignment(),\n      jMenu.getVerticalTextPosition(),\n      jMenu.getHorizontalTextPosition(),\n      ourViewRect,\n      ourIconRect,\n      ourTextRect,\n      ourAcceleratorRect,\n      ourCheckIconRect,\n      ourArrowIconRect,\n      jMenu.getText() != null ? defaultTextIconGap : 0,\n      defaultTextIconGap\n    );\n    Color color2 = g.getColor();\n    if (comp.isOpaque()){\n      g.setColor(jMenu.getBackground());\n      g.fillRect(0, 0, jMenu.getWidth(), jMenu.getHeight());\n      if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n        if (UIUtil.isUnderAquaLookAndFeel()) {\n           SELECTED_BACKGROUND_PAINTER.paintBorder(comp, g, 0, 0, jMenu.getWidth(), jMenu.getHeight());\n        } else {\n          g.setColor(selectionBackground);\n          if (allowedIcon != null) {\n            g.fillRect(k, 0, jMenu.getWidth() - k, jMenu.getHeight());\n          }\n          else {\n            g.fillRect(0, 0, jMenu.getWidth(), jMenu.getHeight());\n            g.setColor(selectionBackground);\n          }\n        }\n      }\n      g.setColor(color2);\n    }\n    if (allowedIcon != null){\n      if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n        g.setColor(selectionForeground);\n      }\n      else{\n        g.setColor(jMenu.getForeground());\n      }\n      if (useCheckAndArrow()){\n        allowedIcon.paintIcon(comp, g, ourCheckIconRect.x, ourCheckIconRect.y);\n      }\n      g.setColor(color2);\n      if (menuItem.isArmed()){\n        drawIconBorder(g);\n      }\n    }\n    if (icon != null){\n      if (!buttonmodel.isEnabled()){\n        icon = jMenu.getDisabledIcon();\n      }\n      else\n        if (buttonmodel.isPressed() && buttonmodel.isArmed()){\n          icon = jMenu.getPressedIcon();\n          if (icon == null){\n            icon = jMenu.getIcon();\n          }\n        }\n      if (icon != null){\n        icon.paintIcon(comp, g, ourIconRect.x, ourIconRect.y);\n      }\n    }\n    if (s1 != null && s1.length() > 0){\n      if (buttonmodel.isEnabled()){\n        if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n          g.setColor(selectionForeground);\n        }\n        else{\n          g.setColor(jMenu.getForeground());\n        }\n        BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x, ourTextRect.y + fontmetrics.getAscent());\n      }\n      else {\n        final Object disabledForeground = UIUtil.getMenuItemDisabledForeground();\n        if (disabledForeground instanceof Color){\n          g.setColor((Color)disabledForeground);\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x, ourTextRect.y + fontmetrics.getAscent());\n        }\n        else{\n          g.setColor(jMenu.getBackground().brighter());\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x, ourTextRect.y + fontmetrics.getAscent());\n          g.setColor(jMenu.getBackground().darker());\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x - 1, (ourTextRect.y + fontmetrics.getAscent()) - 1);\n        }\n      }\n    }\n    if (arrowIcon != null){\n      if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n        g.setColor(selectionForeground);\n      }\n      if (useCheckAndArrow()){\n        try {\n          if (UIUtil.isUnderAquaLookAndFeel() && buttonmodel.isSelected() && INVERTED_ARROW_ICON != null) {\n            INVERTED_ARROW_ICON.paintIcon(comp, g, ourArrowIconRect.x, ourArrowIconRect.y);\n          } else arrowIcon.paintIcon(comp, g, ourArrowIconRect.x, ourArrowIconRect.y);\n        }\n        catch (NullPointerException npe) {\n          // GTKIconFactory$MenuArrowIcon.paintIcon since it doesn't expect to be given a null instead of SynthContext\n          // http://www.jetbrains.net/jira/browse/IDEADEV-22360\n        }\n      }\n    }\n    g.setColor(color2);\n    g.setFont(font);\n  }","id":28095,"modified_method":"public void paint(Graphics g, JComponent comp) {\n    UIUtil.applyRenderingHints(g);\n    JMenu jMenu = (JMenu)comp;\n    ButtonModel buttonmodel = jMenu.getModel();\n    int mnemonicIndex = jMenu.getDisplayedMnemonicIndex();\n    Icon icon = getIcon();\n    Icon allowedIcon = getAllowedIcon();\n    Insets insets = comp.getInsets();\n    resetRects();\n    ourViewRect.setBounds(0, 0, jMenu.getWidth(), jMenu.getHeight());\n    ourViewRect.x += insets.left;\n    ourViewRect.y += insets.top;\n    ourViewRect.width -= insets.right + ourViewRect.x;\n    ourViewRect.height -= insets.bottom + ourViewRect.y;\n    Font font = g.getFont();\n    Font font1 = comp.getFont();\n    g.setFont(font1);\n    FontMetrics fontmetrics = g.getFontMetrics(font1);\n    String s1 = layoutMenuItem(\n      fontmetrics,\n      jMenu.getText(),\n      icon,\n      allowedIcon,\n      arrowIcon,\n      jMenu.getVerticalAlignment(),\n      jMenu.getHorizontalAlignment(),\n      jMenu.getVerticalTextPosition(),\n      jMenu.getHorizontalTextPosition(),\n      ourViewRect,\n      ourIconRect,\n      ourTextRect,\n      ourAcceleratorRect,\n      ourCheckIconRect,\n      ourArrowIconRect,\n      jMenu.getText() != null ? defaultTextIconGap : 0,\n      defaultTextIconGap\n    );\n    Color color2 = g.getColor();\n    if (comp.isOpaque()){\n      g.setColor(jMenu.getBackground());\n      g.fillRect(0, 0, jMenu.getWidth(), jMenu.getHeight());\n      if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n        if (UIUtil.isUnderAquaLookAndFeel()) {\n           SELECTED_BACKGROUND_PAINTER.paintBorder(comp, g, 0, 0, jMenu.getWidth(), jMenu.getHeight());\n        } else {\n          g.setColor(selectionBackground);\n          if (allowedIcon != null) {\n            g.fillRect(k, 0, jMenu.getWidth() - k, jMenu.getHeight());\n          }\n          else {\n            g.fillRect(0, 0, jMenu.getWidth(), jMenu.getHeight());\n            g.setColor(selectionBackground);\n          }\n        }\n      }\n      g.setColor(color2);\n    }\n    if (allowedIcon != null){\n      if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n        g.setColor(selectionForeground);\n      }\n      else{\n        g.setColor(jMenu.getForeground());\n      }\n      if (useCheckAndArrow()){\n        allowedIcon.paintIcon(comp, g, ourCheckIconRect.x, ourCheckIconRect.y);\n      }\n      g.setColor(color2);\n      if (menuItem.isArmed()){\n        drawIconBorder(g);\n      }\n    }\n    if (icon != null){\n      if (!buttonmodel.isEnabled()){\n        icon = jMenu.getDisabledIcon();\n      }\n      else\n        if (buttonmodel.isPressed() && buttonmodel.isArmed()){\n          icon = jMenu.getPressedIcon();\n          if (icon == null){\n            icon = jMenu.getIcon();\n          }\n        }\n      if (icon != null){\n        icon.paintIcon(comp, g, ourIconRect.x, ourIconRect.y);\n      }\n    }\n    if (s1 != null && s1.length() > 0){\n      if (buttonmodel.isEnabled()){\n        if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n          g.setColor(selectionForeground);\n        }\n        else{\n          g.setColor(jMenu.getForeground());\n        }\n        BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x, ourTextRect.y + fontmetrics.getAscent());\n      }\n      else {\n        final Object disabledForeground = UIUtil.getMenuItemDisabledForeground();\n        if (disabledForeground instanceof Color){\n          g.setColor((Color)disabledForeground);\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x, ourTextRect.y + fontmetrics.getAscent());\n        }\n        else{\n          g.setColor(jMenu.getBackground().brighter());\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x, ourTextRect.y + fontmetrics.getAscent());\n          g.setColor(jMenu.getBackground().darker());\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x - 1, (ourTextRect.y + fontmetrics.getAscent()) - 1);\n        }\n      }\n    }\n    if (arrowIcon != null){\n      if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n        g.setColor(selectionForeground);\n      }\n      if (useCheckAndArrow()){\n        try {\n          if (SystemInfo.isMac && INVERTED_ARROW_ICON != null && (buttonmodel.isArmed() || buttonmodel.isSelected()) && UIUtil.isUnderAquaLookAndFeel()) {\n            INVERTED_ARROW_ICON.paintIcon(comp, g, ourArrowIconRect.x, ourArrowIconRect.y);\n          } else if (SystemInfo.isMac && DISABLED_ARROW_ICON != null && !buttonmodel.isEnabled() && UIUtil.isUnderAquaLookAndFeel()) {\n            DISABLED_ARROW_ICON.paintIcon(comp, g, ourArrowIconRect.x, ourArrowIconRect.y);\n          } else arrowIcon.paintIcon(comp, g, ourArrowIconRect.x, ourArrowIconRect.y);\n        }\n        catch (NullPointerException npe) {\n          // GTKIconFactory$MenuArrowIcon.paintIcon since it doesn't expect to be given a null instead of SynthContext\n          // http://www.jetbrains.net/jira/browse/IDEADEV-22360\n        }\n      }\n    }\n    g.setColor(color2);\n    g.setFont(font);\n  }","commit_id":"6441cc5b19582572a5b4310a1c3143b5871b0b97","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Sets current LAF. The method doesn't update component hierarchy.\n   */\n  public void setCurrentLookAndFeel(UIManager.LookAndFeelInfo lookAndFeelInfo){\n    if(findLaf(lookAndFeelInfo.getClassName())==null){\n      LOG.error(\"unknown LookAndFeel : \"+lookAndFeelInfo);\n      return;\n    }\n\n    // Set L&F\n\n    if(IDEA_LAF_CLASSNAME.equals(lookAndFeelInfo.getClassName())){ // that is IDEA default LAF\n      IdeaLaf laf=new IdeaLaf();\n      IdeaLaf.setCurrentTheme(new IdeaBlueMetalTheme());\n      try {\n        UIManager.setLookAndFeel(laf);\n      } catch (Exception exc) {\n        Messages.showMessageDialog(\n          IdeBundle.message(\"error.cannot.set.look.and.feel\", lookAndFeelInfo.getName()),\n          CommonBundle.getErrorTitle(),\n          Messages.getErrorIcon()\n        );\n        return;\n      }\n    }else{ // non default LAF\n      try {\n        LookAndFeel laf=((LookAndFeel)Class.forName(lookAndFeelInfo.getClassName()).newInstance());\n        if(laf instanceof MetalLookAndFeel){\n          MetalLookAndFeel.setCurrentTheme(new DefaultMetalTheme());\n        }\n        UIManager.setLookAndFeel(laf);\n      } catch(Exception exc) {\n        Messages.showMessageDialog(\n          IdeBundle.message(\"error.cannot.set.look.and.feel\", lookAndFeelInfo.getName()),\n          CommonBundle.getErrorTitle(),\n          Messages.getErrorIcon()\n        );\n        return;\n      }\n    }\n    myCurrentLaf=lookAndFeelInfo;\n\n    // The following code is a trick! By default Swing uses lightweight and \"medium\" weight\n    // popups to show JPopupMenu. The code below force the creation of real heavyweight menus.\n    // It dramatically increases speed of popups.\n\n    //noinspection HardCodedStringLiteral\n    String popupWeight=System.getProperty(\"idea.popup.weight\");\n    if(popupWeight==null){ // use defaults if popup weight isn't specified\n      if(SystemInfo.isWindows){\n        popupWeight=HEAVY_WEIGHT_POPUP;\n      }else{ // UNIXes (Linux and MAC) go here\n        popupWeight=MEDIUM_WEIGHT_POPUP;\n      }\n    } else if (!HEAVY_WEIGHT_POPUP.equals(popupWeight) && !MEDIUM_WEIGHT_POPUP.equals(popupWeight)) {\n      throw new IllegalStateException(\"unknown value of property -Didea.popup.weight: \" + popupWeight);\n    }\n\n    if (SystemInfo.isMacOSLeopard) {\n      // Force heavy weight popups under Leopard, otherwise they don't have shadow or any kind of border.\n      popupWeight = HEAVY_WEIGHT_POPUP;\n    }\n\n    popupWeight = popupWeight.trim();\n\n    PopupFactory popupFactory;\n    final PopupFactory oldFactory = PopupFactory.getSharedInstance();\n    if (!(oldFactory instanceof OurPopupFactory)) {\n      popupFactory = new OurPopupFactory() {\n        public Popup getPopup(\n          Component owner,\n          Component contents,\n          int x,\n          int y\n        ) throws IllegalArgumentException {\n          final Point point = fixPopupLocation(contents, x, y);\n\n          final int popupType = PopupUtil.getPopupType(this);\n          if (popupType >= 0) {\n            PopupUtil.setPopupType(oldFactory, popupType);\n          }\n\n          return oldFactory.getPopup(owner, contents, point.x, point.y);\n        }\n      };\n\n      PopupUtil.setPopupType(popupFactory, HEAVY_WEIGHT_POPUP.equals(popupWeight) ? 2 : 1);\n      PopupFactory.setSharedInstance(popupFactory);\n    }\n\n    // update ui for popup menu to get round corners\n    if (UIUtil.isUnderAquaLookAndFeel()) {\n      final UIDefaults uiDefaults = UIManager.getLookAndFeelDefaults();\n      uiDefaults.put(\"PopupMenuUI\", MacPopupMenuUI.class.getCanonicalName());\n      final Icon icon = getAquaMenuInvertedIcon();\n      if (icon != null) {\n        uiDefaults.put(\"Menu.invertedArrowIcon\", icon);\n      }\n    }\n  }","id":28096,"modified_method":"/**\n   * Sets current LAF. The method doesn't update component hierarchy.\n   */\n  public void setCurrentLookAndFeel(UIManager.LookAndFeelInfo lookAndFeelInfo){\n    if(findLaf(lookAndFeelInfo.getClassName())==null){\n      LOG.error(\"unknown LookAndFeel : \"+lookAndFeelInfo);\n      return;\n    }\n\n    // Set L&F\n\n    if(IDEA_LAF_CLASSNAME.equals(lookAndFeelInfo.getClassName())){ // that is IDEA default LAF\n      IdeaLaf laf=new IdeaLaf();\n      IdeaLaf.setCurrentTheme(new IdeaBlueMetalTheme());\n      try {\n        UIManager.setLookAndFeel(laf);\n      } catch (Exception exc) {\n        Messages.showMessageDialog(\n          IdeBundle.message(\"error.cannot.set.look.and.feel\", lookAndFeelInfo.getName()),\n          CommonBundle.getErrorTitle(),\n          Messages.getErrorIcon()\n        );\n        return;\n      }\n    }else{ // non default LAF\n      try {\n        LookAndFeel laf=((LookAndFeel)Class.forName(lookAndFeelInfo.getClassName()).newInstance());\n        if(laf instanceof MetalLookAndFeel){\n          MetalLookAndFeel.setCurrentTheme(new DefaultMetalTheme());\n        }\n        UIManager.setLookAndFeel(laf);\n      } catch(Exception exc) {\n        Messages.showMessageDialog(\n          IdeBundle.message(\"error.cannot.set.look.and.feel\", lookAndFeelInfo.getName()),\n          CommonBundle.getErrorTitle(),\n          Messages.getErrorIcon()\n        );\n        return;\n      }\n    }\n    myCurrentLaf=lookAndFeelInfo;\n\n    // The following code is a trick! By default Swing uses lightweight and \"medium\" weight\n    // popups to show JPopupMenu. The code below force the creation of real heavyweight menus.\n    // It dramatically increases speed of popups.\n\n    //noinspection HardCodedStringLiteral\n    String popupWeight=System.getProperty(\"idea.popup.weight\");\n    if(popupWeight==null){ // use defaults if popup weight isn't specified\n      if(SystemInfo.isWindows){\n        popupWeight=HEAVY_WEIGHT_POPUP;\n      }else{ // UNIXes (Linux and MAC) go here\n        popupWeight=MEDIUM_WEIGHT_POPUP;\n      }\n    } else if (!HEAVY_WEIGHT_POPUP.equals(popupWeight) && !MEDIUM_WEIGHT_POPUP.equals(popupWeight)) {\n      throw new IllegalStateException(\"unknown value of property -Didea.popup.weight: \" + popupWeight);\n    }\n\n    if (SystemInfo.isMacOSLeopard) {\n      // Force heavy weight popups under Leopard, otherwise they don't have shadow or any kind of border.\n      popupWeight = HEAVY_WEIGHT_POPUP;\n    }\n\n    popupWeight = popupWeight.trim();\n\n    PopupFactory popupFactory;\n    final PopupFactory oldFactory = PopupFactory.getSharedInstance();\n    if (!(oldFactory instanceof OurPopupFactory)) {\n      popupFactory = new OurPopupFactory() {\n        public Popup getPopup(\n          Component owner,\n          Component contents,\n          int x,\n          int y\n        ) throws IllegalArgumentException {\n          final Point point = fixPopupLocation(contents, x, y);\n\n          final int popupType = PopupUtil.getPopupType(this);\n          if (popupType >= 0) {\n            PopupUtil.setPopupType(oldFactory, popupType);\n          }\n\n          return oldFactory.getPopup(owner, contents, point.x, point.y);\n        }\n      };\n\n      PopupUtil.setPopupType(popupFactory, HEAVY_WEIGHT_POPUP.equals(popupWeight) ? 2 : 1);\n      PopupFactory.setSharedInstance(popupFactory);\n    }\n\n    // update ui for popup menu to get round corners\n    if (UIUtil.isUnderAquaLookAndFeel()) {\n      final UIDefaults uiDefaults = UIManager.getLookAndFeelDefaults();\n      uiDefaults.put(\"PopupMenuUI\", MacPopupMenuUI.class.getCanonicalName());\n      uiDefaults.put(\"Menu.invertedArrowIcon\", getAquaMenuInvertedIcon());\n      uiDefaults.put(\"Menu.disabledArrowIcon\", getAquaMenuDisabledIcon());\n    }\n  }","commit_id":"6441cc5b19582572a5b4310a1c3143b5871b0b97","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void paint(Graphics g, JComponent comp) {\n    UIUtil.applyRenderingHints(g);\n    JMenuItem jmenuitem = (JMenuItem)comp;\n    ButtonModel buttonmodel = jmenuitem.getModel();\n    int mnemonicIndex = jmenuitem.getDisplayedMnemonicIndex();\n    Icon icon1 = getIcon();\n    Icon icon2 = getAllowedIcon();\n    int j1 = jmenuitem.getWidth();\n    int k1 = jmenuitem.getHeight();\n    Insets insets = comp.getInsets();\n    initBounds();\n    f.setBounds(0, 0, j1, k1);\n    f.x += insets.left;\n    f.y += insets.top;\n    f.width -= insets.right + f.x;\n    f.height -= insets.bottom + f.y;\n    Font font = g.getFont();\n    Font font1 = comp.getFont();\n    g.setFont(font1);\n    FontMetrics fontmetrics = g.getFontMetrics(font1);\n    FontMetrics fontmetrics1 = g.getFontMetrics(acceleratorFont);\n    String keyStrokeText;\n    if (jmenuitem instanceof ActionMenuItem) {\n      keyStrokeText = ((ActionMenuItem)jmenuitem).getFirstShortcutText();\n    }else{\n      keyStrokeText = getKeyStrokeText(jmenuitem.getAccelerator());\n    }\n    String s1 = layoutMenuItem(fontmetrics, jmenuitem.getText(), fontmetrics1, keyStrokeText, icon1, icon2, arrowIcon, jmenuitem.getVerticalAlignment(), jmenuitem.getHorizontalAlignment(), jmenuitem.getVerticalTextPosition(), jmenuitem.getHorizontalTextPosition(), f, l, j, c, h, d, jmenuitem.getText() != null ? defaultTextIconGap : 0, defaultTextIconGap);\n    Color color2 = g.getColor();\n    if (comp.isOpaque()){\n      g.setColor(jmenuitem.getBackground());\n      g.fillRect(0, 0, j1, k1);\n      if (buttonmodel.isArmed() || (comp instanceof JMenu) && buttonmodel.isSelected()){\n        g.setColor(selectionBackground);\n        if (icon2 != null){\n          g.fillRect(k, 0, j1 - k, k1);\n        }\n        else{\n          g.fillRect(0, 0, j1, k1);\n          //graphics.setColor(BegResources.q);\n          //graphics.drawLine(0, 0, 0, k1);\n          g.setColor(selectionBackground);\n        }\n        //graphics.setColor(BegResources.r);\n        //graphics.drawLine(j1 - 1, 0, j1 - 1, k1);\n      }\n      g.setColor(color2);\n    }\n    if (icon2 != null){\n      if (buttonmodel.isArmed() || (comp instanceof JMenu) && buttonmodel.isSelected()){\n        g.setColor(selectionForeground);\n      }\n      else{\n        g.setColor(jmenuitem.getForeground());\n      }\n      if (useCheckAndArrow()){\n        icon2.paintIcon(comp, g, h.x, h.y);\n      }\n      g.setColor(color2);\n      if (menuItem.isArmed()){\n        drawIconBorder(g);\n      }\n    }\n    if (icon1 != null){\n      if (!buttonmodel.isEnabled()){\n        icon1 = jmenuitem.getDisabledIcon();\n      }\n      else\n        if (buttonmodel.isPressed() && buttonmodel.isArmed()){\n          icon1 = jmenuitem.getPressedIcon();\n          if (icon1 == null){\n            icon1 = jmenuitem.getIcon();\n          }\n        }\n      if (icon1 != null){\n        icon1.paintIcon(comp, g, l.x, l.y);\n      }\n    }\n    if (s1 != null && s1.length() > 0){\n      if (buttonmodel.isEnabled()){\n        if (buttonmodel.isArmed() || (comp instanceof JMenu) && buttonmodel.isSelected()){\n          g.setColor(selectionForeground);\n        }\n        else{\n          g.setColor(jmenuitem.getForeground());\n        }\n        BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, j.x, j.y + fontmetrics.getAscent());\n      }\n      else {\n        final Object disabledForeground = UIUtil.getMenuItemDisabledForegroundObject();\n        if (disabledForeground instanceof Color){\n          g.setColor((Color)disabledForeground);\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, j.x, j.y + fontmetrics.getAscent());\n        }\n        else{\n          g.setColor(jmenuitem.getBackground().brighter());\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, j.x, j.y + fontmetrics.getAscent());\n          g.setColor(jmenuitem.getBackground().darker());\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, j.x - 1, (j.y + fontmetrics.getAscent()) - 1);\n        }\n      }\n    }\n    if (keyStrokeText != null && !keyStrokeText.equals(\"\")){\n      g.setFont(acceleratorFont);\n      if (buttonmodel.isEnabled()){\n        if (buttonmodel.isArmed() || (comp instanceof JMenu) && buttonmodel.isSelected()){\n          g.setColor(acceleratorSelectionForeground);\n        }\n        else{\n          g.setColor(acceleratorForeground);\n        }\n        BasicGraphicsUtils.drawString(g, keyStrokeText, 0, c.x, c.y + fontmetrics.getAscent());\n      }\n      else\n        if (disabledForeground != null){\n          g.setColor(disabledForeground);\n          BasicGraphicsUtils.drawString(g, keyStrokeText, 0, c.x, c.y + fontmetrics.getAscent());\n        }\n        else{\n          g.setColor(jmenuitem.getBackground().brighter());\n          BasicGraphicsUtils.drawString(g, keyStrokeText, 0, c.x, c.y + fontmetrics.getAscent());\n          g.setColor(jmenuitem.getBackground().darker());\n          BasicGraphicsUtils.drawString(g, keyStrokeText, 0, c.x - 1, (c.y + fontmetrics.getAscent()) - 1);\n        }\n    }\n    if (arrowIcon != null){\n      if (buttonmodel.isArmed() || (comp instanceof JMenu) && buttonmodel.isSelected()){\n        g.setColor(selectionForeground);\n      }\n      if (useCheckAndArrow()){\n        arrowIcon.paintIcon(comp, g, d.x, d.y);\n      }\n    }\n    g.setColor(color2);\n    g.setFont(font);\n  }","id":28097,"modified_method":"public void paint(Graphics g, JComponent comp) {\n    UIUtil.applyRenderingHints(g);\n    JMenuItem jmenuitem = (JMenuItem)comp;\n    ButtonModel buttonmodel = jmenuitem.getModel();\n    int mnemonicIndex = jmenuitem.getDisplayedMnemonicIndex();\n    Icon icon1 = getIcon();\n    Icon icon2 = getAllowedIcon();\n    int j1 = jmenuitem.getWidth();\n    int k1 = jmenuitem.getHeight();\n    Insets insets = comp.getInsets();\n    initBounds();\n    f.setBounds(0, 0, j1, k1);\n    f.x += insets.left;\n    f.y += insets.top;\n    f.width -= insets.right + f.x;\n    f.height -= insets.bottom + f.y;\n    Font font = g.getFont();\n    Font font1 = comp.getFont();\n    g.setFont(font1);\n    FontMetrics fontmetrics = g.getFontMetrics(font1);\n    FontMetrics fontmetrics1 = g.getFontMetrics(acceleratorFont);\n    String keyStrokeText;\n    if (jmenuitem instanceof ActionMenuItem) {\n      keyStrokeText = ((ActionMenuItem)jmenuitem).getFirstShortcutText();\n    }else{\n      keyStrokeText = getKeyStrokeText(jmenuitem.getAccelerator());\n    }\n    String s1 = layoutMenuItem(fontmetrics, jmenuitem.getText(), fontmetrics1, keyStrokeText, icon1, icon2, arrowIcon, jmenuitem.getVerticalAlignment(), jmenuitem.getHorizontalAlignment(), jmenuitem.getVerticalTextPosition(), jmenuitem.getHorizontalTextPosition(), f, l, j, c, h, d, jmenuitem.getText() != null ? defaultTextIconGap : 0, defaultTextIconGap);\n    Color color2 = g.getColor();\n    if (comp.isOpaque()){\n      g.setColor(jmenuitem.getBackground());\n      g.fillRect(0, 0, j1, k1);\n      if (buttonmodel.isArmed() || (comp instanceof JMenu) && buttonmodel.isSelected()){\n        if (UIUtil.isUnderAquaLookAndFeel()) {\n          SELECTED_BACKGROUND_PAINTER.paintBorder(comp, g, 0, 0, j1, k1);\n        } else {\n          g.setColor(selectionBackground);\n          if (icon2 != null){\n            g.fillRect(k, 0, j1 - k, k1);\n          }\n          else{\n            g.fillRect(0, 0, j1, k1);\n            //graphics.setColor(BegResources.q);\n            //graphics.drawLine(0, 0, 0, k1);\n            g.setColor(selectionBackground);\n          }\n          //graphics.setColor(BegResources.r);\n          //graphics.drawLine(j1 - 1, 0, j1 - 1, k1);\n        }\n      }\n      g.setColor(color2);\n    }\n    if (icon2 != null){\n      if (buttonmodel.isArmed() || (comp instanceof JMenu) && buttonmodel.isSelected()){\n        g.setColor(selectionForeground);\n      }\n      else{\n        g.setColor(jmenuitem.getForeground());\n      }\n      if (useCheckAndArrow()){\n        icon2.paintIcon(comp, g, h.x, h.y);\n      }\n      g.setColor(color2);\n      if (menuItem.isArmed()){\n        drawIconBorder(g);\n      }\n    }\n    if (icon1 != null){\n      if (!buttonmodel.isEnabled()){\n        icon1 = jmenuitem.getDisabledIcon();\n      }\n      else\n        if (buttonmodel.isPressed() && buttonmodel.isArmed()){\n          icon1 = jmenuitem.getPressedIcon();\n          if (icon1 == null){\n            icon1 = jmenuitem.getIcon();\n          }\n        }\n      if (icon1 != null){\n        icon1.paintIcon(comp, g, l.x, l.y);\n      }\n    }\n    if (s1 != null && s1.length() > 0){\n      if (buttonmodel.isEnabled()){\n        if (buttonmodel.isArmed() || (comp instanceof JMenu) && buttonmodel.isSelected()){\n          g.setColor(selectionForeground);\n        }\n        else{\n          g.setColor(jmenuitem.getForeground());\n        }\n        BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, j.x, j.y + fontmetrics.getAscent());\n      }\n      else {\n        final Object disabledForeground = UIUtil.getMenuItemDisabledForegroundObject();\n        if (disabledForeground instanceof Color){\n          g.setColor((Color)disabledForeground);\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, j.x, j.y + fontmetrics.getAscent());\n        }\n        else{\n          g.setColor(jmenuitem.getBackground().brighter());\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, j.x, j.y + fontmetrics.getAscent());\n          g.setColor(jmenuitem.getBackground().darker());\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, j.x - 1, (j.y + fontmetrics.getAscent()) - 1);\n        }\n      }\n    }\n    if (keyStrokeText != null && !keyStrokeText.equals(\"\")){\n      g.setFont(acceleratorFont);\n      if (buttonmodel.isEnabled()){\n        if (UIUtil.isUnderAquaLookAndFeel() && (buttonmodel.isArmed() || (comp instanceof JMenu) && buttonmodel.isSelected())) {\n          g.setColor(selectionForeground);\n        }\n        else {\n          if (buttonmodel.isArmed() || (comp instanceof JMenu) && buttonmodel.isSelected()) {\n            g.setColor(acceleratorSelectionForeground);\n          }\n          else {\n            g.setColor(acceleratorForeground);\n          }\n        }\n        BasicGraphicsUtils.drawString(g, keyStrokeText, 0, c.x, c.y + fontmetrics.getAscent());\n      }\n      else\n        if (disabledForeground != null){\n          g.setColor(disabledForeground);\n          BasicGraphicsUtils.drawString(g, keyStrokeText, 0, c.x, c.y + fontmetrics.getAscent());\n        }\n        else{\n          g.setColor(jmenuitem.getBackground().brighter());\n          BasicGraphicsUtils.drawString(g, keyStrokeText, 0, c.x, c.y + fontmetrics.getAscent());\n          g.setColor(jmenuitem.getBackground().darker());\n          BasicGraphicsUtils.drawString(g, keyStrokeText, 0, c.x - 1, (c.y + fontmetrics.getAscent()) - 1);\n        }\n    }\n    if (arrowIcon != null){\n      if (buttonmodel.isArmed() || (comp instanceof JMenu) && buttonmodel.isSelected()){\n        g.setColor(selectionForeground);\n      }\n      if (useCheckAndArrow()){\n        arrowIcon.paintIcon(comp, g, d.x, d.y);\n      }\n    }\n    g.setColor(color2);\n    g.setFont(font);\n  }","commit_id":"a5cbc1988bcbded3efbc2d0ed4c28f1c858b3255","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void paint(Graphics g, JComponent comp) {\n    UIUtil.applyRenderingHints(g);\n    JMenu jMenu = (JMenu)comp;\n    ButtonModel buttonmodel = jMenu.getModel();\n    int mnemonicIndex = jMenu.getDisplayedMnemonicIndex();\n    Icon icon = getIcon();\n    Icon allowedIcon = getAllowedIcon();\n    Insets insets = comp.getInsets();\n    resetRects();\n    ourViewRect.setBounds(0, 0, jMenu.getWidth(), jMenu.getHeight());\n    ourViewRect.x += insets.left;\n    ourViewRect.y += insets.top;\n    ourViewRect.width -= insets.right + ourViewRect.x;\n    ourViewRect.height -= insets.bottom + ourViewRect.y;\n    Font font = g.getFont();\n    Font font1 = comp.getFont();\n    g.setFont(font1);\n    FontMetrics fontmetrics = g.getFontMetrics(font1);\n    String s1 = layoutMenuItem(\n      fontmetrics,\n      jMenu.getText(),\n      icon,\n      allowedIcon,\n      arrowIcon,\n      jMenu.getVerticalAlignment(),\n      jMenu.getHorizontalAlignment(),\n      jMenu.getVerticalTextPosition(),\n      jMenu.getHorizontalTextPosition(),\n      ourViewRect,\n      ourIconRect,\n      ourTextRect,\n      ourAcceleratorRect,\n      ourCheckIconRect,\n      ourArrowIconRect,\n      jMenu.getText() != null ? defaultTextIconGap : 0,\n      defaultTextIconGap\n    );\n    Color color2 = g.getColor();\n    if (comp.isOpaque()){\n      g.setColor(jMenu.getBackground());\n      g.fillRect(0, 0, jMenu.getWidth(), jMenu.getHeight());\n      if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n        g.setColor(selectionBackground);\n        if (allowedIcon != null){\n          g.fillRect(k, 0, jMenu.getWidth() - k, jMenu.getHeight());\n        }else{\n          g.fillRect(0, 0, jMenu.getWidth(), jMenu.getHeight());\n          g.setColor(selectionBackground);\n        }\n      }\n      g.setColor(color2);\n    }\n    if (allowedIcon != null){\n      if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n        g.setColor(selectionForeground);\n      }\n      else{\n        g.setColor(jMenu.getForeground());\n      }\n      if (useCheckAndArrow()){\n        allowedIcon.paintIcon(comp, g, ourCheckIconRect.x, ourCheckIconRect.y);\n      }\n      g.setColor(color2);\n      if (menuItem.isArmed()){\n        drawIconBorder(g);\n      }\n    }\n    if (icon != null){\n      if (!buttonmodel.isEnabled()){\n        icon = jMenu.getDisabledIcon();\n      }\n      else\n        if (buttonmodel.isPressed() && buttonmodel.isArmed()){\n          icon = jMenu.getPressedIcon();\n          if (icon == null){\n            icon = jMenu.getIcon();\n          }\n        }\n      if (icon != null){\n        icon.paintIcon(comp, g, ourIconRect.x, ourIconRect.y);\n      }\n    }\n    if (s1 != null && s1.length() > 0){\n      if (buttonmodel.isEnabled()){\n        if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n          g.setColor(selectionForeground);\n        }\n        else{\n          g.setColor(jMenu.getForeground());\n        }\n        BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x, ourTextRect.y + fontmetrics.getAscent());\n      }\n      else {\n        final Object disabledForeground = UIUtil.getMenuItemDisabledForeground();\n        if (disabledForeground instanceof Color){\n          g.setColor((Color)disabledForeground);\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x, ourTextRect.y + fontmetrics.getAscent());\n        }\n        else{\n          g.setColor(jMenu.getBackground().brighter());\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x, ourTextRect.y + fontmetrics.getAscent());\n          g.setColor(jMenu.getBackground().darker());\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x - 1, (ourTextRect.y + fontmetrics.getAscent()) - 1);\n        }\n      }\n    }\n    if (arrowIcon != null){\n      if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n        g.setColor(selectionForeground);\n      }\n      if (useCheckAndArrow()){\n        try {\n          arrowIcon.paintIcon(comp, g, ourArrowIconRect.x, ourArrowIconRect.y);\n        }\n        catch (NullPointerException npe) {\n          // GTKIconFactory$MenuArrowIcon.paintIcon since it doesn't expect to be given a null instead of SynthContext\n          // http://www.jetbrains.net/jira/browse/IDEADEV-22360\n        }\n      }\n    }\n    g.setColor(color2);\n    g.setFont(font);\n  }","id":28098,"modified_method":"public void paint(Graphics g, JComponent comp) {\n    UIUtil.applyRenderingHints(g);\n    JMenu jMenu = (JMenu)comp;\n    ButtonModel buttonmodel = jMenu.getModel();\n    int mnemonicIndex = jMenu.getDisplayedMnemonicIndex();\n    Icon icon = getIcon();\n    Icon allowedIcon = getAllowedIcon();\n    Insets insets = comp.getInsets();\n    resetRects();\n    ourViewRect.setBounds(0, 0, jMenu.getWidth(), jMenu.getHeight());\n    ourViewRect.x += insets.left;\n    ourViewRect.y += insets.top;\n    ourViewRect.width -= insets.right + ourViewRect.x;\n    ourViewRect.height -= insets.bottom + ourViewRect.y;\n    Font font = g.getFont();\n    Font font1 = comp.getFont();\n    g.setFont(font1);\n    FontMetrics fontmetrics = g.getFontMetrics(font1);\n    String s1 = layoutMenuItem(\n      fontmetrics,\n      jMenu.getText(),\n      icon,\n      allowedIcon,\n      arrowIcon,\n      jMenu.getVerticalAlignment(),\n      jMenu.getHorizontalAlignment(),\n      jMenu.getVerticalTextPosition(),\n      jMenu.getHorizontalTextPosition(),\n      ourViewRect,\n      ourIconRect,\n      ourTextRect,\n      ourAcceleratorRect,\n      ourCheckIconRect,\n      ourArrowIconRect,\n      jMenu.getText() != null ? defaultTextIconGap : 0,\n      defaultTextIconGap\n    );\n    Color color2 = g.getColor();\n    if (comp.isOpaque()){\n      g.setColor(jMenu.getBackground());\n      g.fillRect(0, 0, jMenu.getWidth(), jMenu.getHeight());\n      if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n        if (UIUtil.isUnderAquaLookAndFeel()) {\n           SELECTED_BACKGROUND_PAINTER.paintBorder(comp, g, 0, 0, jMenu.getWidth(), jMenu.getHeight());\n        } else {\n          g.setColor(selectionBackground);\n          if (allowedIcon != null) {\n            g.fillRect(k, 0, jMenu.getWidth() - k, jMenu.getHeight());\n          }\n          else {\n            g.fillRect(0, 0, jMenu.getWidth(), jMenu.getHeight());\n            g.setColor(selectionBackground);\n          }\n        }\n      }\n      g.setColor(color2);\n    }\n    if (allowedIcon != null){\n      if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n        g.setColor(selectionForeground);\n      }\n      else{\n        g.setColor(jMenu.getForeground());\n      }\n      if (useCheckAndArrow()){\n        allowedIcon.paintIcon(comp, g, ourCheckIconRect.x, ourCheckIconRect.y);\n      }\n      g.setColor(color2);\n      if (menuItem.isArmed()){\n        drawIconBorder(g);\n      }\n    }\n    if (icon != null){\n      if (!buttonmodel.isEnabled()){\n        icon = jMenu.getDisabledIcon();\n      }\n      else\n        if (buttonmodel.isPressed() && buttonmodel.isArmed()){\n          icon = jMenu.getPressedIcon();\n          if (icon == null){\n            icon = jMenu.getIcon();\n          }\n        }\n      if (icon != null){\n        icon.paintIcon(comp, g, ourIconRect.x, ourIconRect.y);\n      }\n    }\n    if (s1 != null && s1.length() > 0){\n      if (buttonmodel.isEnabled()){\n        if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n          g.setColor(selectionForeground);\n        }\n        else{\n          g.setColor(jMenu.getForeground());\n        }\n        BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x, ourTextRect.y + fontmetrics.getAscent());\n      }\n      else {\n        final Object disabledForeground = UIUtil.getMenuItemDisabledForeground();\n        if (disabledForeground instanceof Color){\n          g.setColor((Color)disabledForeground);\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x, ourTextRect.y + fontmetrics.getAscent());\n        }\n        else{\n          g.setColor(jMenu.getBackground().brighter());\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x, ourTextRect.y + fontmetrics.getAscent());\n          g.setColor(jMenu.getBackground().darker());\n          BasicGraphicsUtils.drawStringUnderlineCharAt(g, s1, mnemonicIndex, ourTextRect.x - 1, (ourTextRect.y + fontmetrics.getAscent()) - 1);\n        }\n      }\n    }\n    if (arrowIcon != null){\n      if (buttonmodel.isArmed() || buttonmodel.isSelected()){\n        g.setColor(selectionForeground);\n      }\n      if (useCheckAndArrow()){\n        try {\n          if (UIUtil.isUnderAquaLookAndFeel() && buttonmodel.isSelected() && INVERTED_ARROW_ICON != null) {\n            INVERTED_ARROW_ICON.paintIcon(comp, g, ourArrowIconRect.x, ourArrowIconRect.y);\n          } else arrowIcon.paintIcon(comp, g, ourArrowIconRect.x, ourArrowIconRect.y);\n        }\n        catch (NullPointerException npe) {\n          // GTKIconFactory$MenuArrowIcon.paintIcon since it doesn't expect to be given a null instead of SynthContext\n          // http://www.jetbrains.net/jira/browse/IDEADEV-22360\n        }\n      }\n    }\n    g.setColor(color2);\n    g.setFont(font);\n  }","commit_id":"a5cbc1988bcbded3efbc2d0ed4c28f1c858b3255","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Sets current LAF. The method doesn't update component hierarchy.\n   */\n  public void setCurrentLookAndFeel(UIManager.LookAndFeelInfo lookAndFeelInfo){\n    if(findLaf(lookAndFeelInfo.getClassName())==null){\n      LOG.error(\"unknown LookAndFeel : \"+lookAndFeelInfo);\n      return;\n    }\n\n    // Set L&F\n\n    if(IDEA_LAF_CLASSNAME.equals(lookAndFeelInfo.getClassName())){ // that is IDEA default LAF\n      IdeaLaf laf=new IdeaLaf();\n      IdeaLaf.setCurrentTheme(new IdeaBlueMetalTheme());\n      try {\n        UIManager.setLookAndFeel(laf);\n      } catch (Exception exc) {\n        Messages.showMessageDialog(\n          IdeBundle.message(\"error.cannot.set.look.and.feel\", lookAndFeelInfo.getName()),\n          CommonBundle.getErrorTitle(),\n          Messages.getErrorIcon()\n        );\n        return;\n      }\n    }else{ // non default LAF\n      try {\n        LookAndFeel laf=((LookAndFeel)Class.forName(lookAndFeelInfo.getClassName()).newInstance());\n        if(laf instanceof MetalLookAndFeel){\n          MetalLookAndFeel.setCurrentTheme(new DefaultMetalTheme());\n        }\n        UIManager.setLookAndFeel(laf);\n      } catch(Exception exc) {\n        Messages.showMessageDialog(\n          IdeBundle.message(\"error.cannot.set.look.and.feel\", lookAndFeelInfo.getName()),\n          CommonBundle.getErrorTitle(),\n          Messages.getErrorIcon()\n        );\n        return;\n      }\n    }\n    myCurrentLaf=lookAndFeelInfo;\n\n    // The following code is a trick! By default Swing uses lightweight and \"medium\" weight\n    // popups to show JPopupMenu. The code below force the creation of real heavyweight menus.\n    // It dramatically increases speed of popups.\n\n    //noinspection HardCodedStringLiteral\n    String popupWeight=System.getProperty(\"idea.popup.weight\");\n    if(popupWeight==null){ // use defaults if popup weight isn't specified\n      if(SystemInfo.isWindows){\n        popupWeight=HEAVY_WEIGHT_POPUP;\n      }else{ // UNIXes (Linux and MAC) go here\n        popupWeight=MEDIUM_WEIGHT_POPUP;\n      }\n    }\n\n    if (SystemInfo.isMacOSLeopard) {\n      // Force heavy weight popups under Leopard, otherwise they don't have shadow or any kind of border.\n      popupWeight = HEAVY_WEIGHT_POPUP;\n    }\n\n    popupWeight = popupWeight.trim();\n\n    PopupFactory popupFactory;\n\n    if(HEAVY_WEIGHT_POPUP.equals(popupWeight)){\n      popupFactory=new PopupFactory(){\n        public Popup getPopup(\n          Component owner,\n          Component contents,\n          int x,\n          int y\n        ) throws IllegalArgumentException{\n          final Point point = fixPopupLocation(contents, x, y);\n          return new Popup(owner,contents,point.x,point.y){};\n        }\n      };\n    }else if(MEDIUM_WEIGHT_POPUP.equals(popupWeight)){\n      popupFactory=new PopupFactory() {\n\n        public Popup getPopup(final Component owner, final Component contents, final int x, final int y) throws IllegalArgumentException {\n          return createPopup(owner, contents, x, y);\n        }\n\n        private Popup createPopup(final Component owner, final Component contents, final int x, final int y) {\n          final Point point = fixPopupLocation(contents, x, y);\n          final Popup popup = super.getPopup(owner, contents, point.x, point.y);\n          return popup;\n        }\n      };\n    }else{\n      throw new IllegalStateException(\"unknown value of property -Didea.popup.weight: \"+popupWeight);\n    }\n    PopupFactory.setSharedInstance(popupFactory);\n  }","id":28099,"modified_method":"/**\n   * Sets current LAF. The method doesn't update component hierarchy.\n   */\n  public void setCurrentLookAndFeel(UIManager.LookAndFeelInfo lookAndFeelInfo){\n    if(findLaf(lookAndFeelInfo.getClassName())==null){\n      LOG.error(\"unknown LookAndFeel : \"+lookAndFeelInfo);\n      return;\n    }\n\n    // Set L&F\n\n    if(IDEA_LAF_CLASSNAME.equals(lookAndFeelInfo.getClassName())){ // that is IDEA default LAF\n      IdeaLaf laf=new IdeaLaf();\n      IdeaLaf.setCurrentTheme(new IdeaBlueMetalTheme());\n      try {\n        UIManager.setLookAndFeel(laf);\n      } catch (Exception exc) {\n        Messages.showMessageDialog(\n          IdeBundle.message(\"error.cannot.set.look.and.feel\", lookAndFeelInfo.getName()),\n          CommonBundle.getErrorTitle(),\n          Messages.getErrorIcon()\n        );\n        return;\n      }\n    }else{ // non default LAF\n      try {\n        LookAndFeel laf=((LookAndFeel)Class.forName(lookAndFeelInfo.getClassName()).newInstance());\n        if(laf instanceof MetalLookAndFeel){\n          MetalLookAndFeel.setCurrentTheme(new DefaultMetalTheme());\n        }\n        UIManager.setLookAndFeel(laf);\n      } catch(Exception exc) {\n        Messages.showMessageDialog(\n          IdeBundle.message(\"error.cannot.set.look.and.feel\", lookAndFeelInfo.getName()),\n          CommonBundle.getErrorTitle(),\n          Messages.getErrorIcon()\n        );\n        return;\n      }\n    }\n    myCurrentLaf=lookAndFeelInfo;\n\n    // The following code is a trick! By default Swing uses lightweight and \"medium\" weight\n    // popups to show JPopupMenu. The code below force the creation of real heavyweight menus.\n    // It dramatically increases speed of popups.\n\n    //noinspection HardCodedStringLiteral\n    String popupWeight=System.getProperty(\"idea.popup.weight\");\n    if(popupWeight==null){ // use defaults if popup weight isn't specified\n      if(SystemInfo.isWindows){\n        popupWeight=HEAVY_WEIGHT_POPUP;\n      }else{ // UNIXes (Linux and MAC) go here\n        popupWeight=MEDIUM_WEIGHT_POPUP;\n      }\n    }\n\n    if (SystemInfo.isMacOSLeopard) {\n      // Force heavy weight popups under Leopard, otherwise they don't have shadow or any kind of border.\n      popupWeight = HEAVY_WEIGHT_POPUP;\n    }\n\n    popupWeight = popupWeight.trim();\n\n    PopupFactory popupFactory;\n\n    final PopupFactory oldFactory = PopupFactory.getSharedInstance();\n    if(HEAVY_WEIGHT_POPUP.equals(popupWeight)){\n      popupFactory=new PopupFactory(){\n        public Popup getPopup(\n          Component owner,\n          Component contents,\n          int x,\n          int y\n        ) throws IllegalArgumentException{\n          final Point point = fixPopupLocation(contents, x, y);\n          return oldFactory.getPopup(owner, contents, point.x, point.y);\n        }\n      };\n    }else if(MEDIUM_WEIGHT_POPUP.equals(popupWeight)){\n      popupFactory=new PopupFactory() {\n\n        public Popup getPopup(final Component owner, final Component contents, final int x, final int y) throws IllegalArgumentException {\n          return createPopup(owner, contents, x, y);\n        }\n\n        private Popup createPopup(final Component owner, final Component contents, final int x, final int y) {\n          final Point point = fixPopupLocation(contents, x, y);\n          return oldFactory.getPopup(owner, contents, point.x, point.y);\n        }\n      };\n    }else{\n      throw new IllegalStateException(\"unknown value of property -Didea.popup.weight: \"+popupWeight);\n    }\n    PopupFactory.setSharedInstance(popupFactory);\n\n    // update ui for popup menu to get round corners\n    if (UIUtil.isUnderAquaLookAndFeel()) {\n      final UIDefaults uiDefaults = UIManager.getLookAndFeelDefaults();\n      uiDefaults.put(\"PopupMenuUI\", MacPopupMenuUI.class.getCanonicalName());\n      final Icon icon = getAquaMenuInvertedIcon();\n      if (icon != null) {\n        uiDefaults.put(\"Menu.invertedArrowIcon\", icon);\n      }\n    }\n  }","commit_id":"a5cbc1988bcbded3efbc2d0ed4c28f1c858b3255","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static BufferedImage createShadow(final JComponent c, final int width, final int height, boolean isPopup) {\n    final GraphicsConfiguration graphicsConfiguration = GraphicsEnvironment.getLocalGraphicsEnvironment().\n        getDefaultScreenDevice().getDefaultConfiguration();\n\n    final BufferedImage image = graphicsConfiguration.createCompatibleImage(width, height, Transparency.TRANSLUCENT);\n    final Graphics2D g = image.createGraphics();\n\n    final Icon topLeft = isPopup ? POPUP_TOP_LEFT : TOP_LEFT;\n    final Icon topRight = isPopup ? POPUP_TOP_RIGHT : TOP_RIGHT;\n    final Icon bottom = isPopup ? POPUP_BOTTOM : BOTTOM;\n    final Icon top = isPopup ? POPUP_TOP : TOP;\n    final Icon bottomRight = isPopup ? POPUP_BOTTOM_RIGHT : BOTTOM_RIGHT;\n    final Icon bottomLeft = isPopup ? POPUP_BOTTOM_LEFT : BOTTOM_LEFT;\n    final Icon left = isPopup ? POPUP_LEFT : LEFT;\n    final Icon right = isPopup ? POPUP_RIGHT : RIGHT;\n    final int sideSize = isPopup ? POPUP_SIDE_SIZE : SIDE_SIZE;\n    final int bottomSize = isPopup ? POPUP_BOTTOM_SIZE : BOTTOM_SIZE;\n\n\n    topLeft.paintIcon(c, g, 0, 0);\n    topRight.paintIcon(c, g, width - sideSize * 2, 0);\n\n    for (int _x = sideSize * 2; _x < width - sideSize * 2; _x ++) {\n      top.paintIcon(c, g, _x, 0);\n    }\n\n    for (int _x = bottomSize * 2; _x < width - bottomSize * 2; _x ++) {\n      bottom.paintIcon(c, g, _x, height - bottomSize);\n    }\n\n    for (int _y = sideSize * 2; _y < height - bottomSize * 2; _y ++) {\n      left.paintIcon(c, g, 0, _y);\n      right.paintIcon(c, g, width - sideSize, _y);\n    }\n\n    bottomRight.paintIcon(c, g, width - bottomSize * 2, height - bottomSize * 2);\n    bottomLeft.paintIcon(c, g, 0, height - bottomSize * 2);\n\n    g.dispose();\n    return image;\n  }","id":28100,"modified_method":"public static BufferedImage createShadow(final JComponent c, final int width, final int height, boolean isPopup) {\n    final GraphicsConfiguration graphicsConfiguration = GraphicsEnvironment.getLocalGraphicsEnvironment().\n      getDefaultScreenDevice().getDefaultConfiguration();\n\n    final BufferedImage image = graphicsConfiguration.createCompatibleImage(width, height, Transparency.TRANSLUCENT);\n    final Graphics2D g = image.createGraphics();\n\n    final Icon topLeft = isPopup ? POPUP_TOP_LEFT : TOP_LEFT;\n    final Icon topRight = isPopup ? POPUP_TOP_RIGHT : TOP_RIGHT;\n    final Icon bottom = isPopup ? POPUP_BOTTOM : BOTTOM;\n    final Icon top = isPopup ? POPUP_TOP : TOP;\n    final Icon bottomRight = isPopup ? POPUP_BOTTOM_RIGHT : BOTTOM_RIGHT;\n    final Icon bottomLeft = isPopup ? POPUP_BOTTOM_LEFT : BOTTOM_LEFT;\n    final Icon left = isPopup ? POPUP_LEFT : LEFT;\n    final Icon right = isPopup ? POPUP_RIGHT : RIGHT;\n    final int sideSize = isPopup ? POPUP_SIDE_SIZE : SIDE_SIZE;\n    final int bottomSize = isPopup ? POPUP_BOTTOM_SIZE : BOTTOM_SIZE;\n\n\n    topLeft.paintIcon(c, g, 0, 0);\n    topRight.paintIcon(c, g, width - topRight.getIconWidth(), 0);\n    bottomRight.paintIcon(c, g, width - bottomRight.getIconWidth(), height - bottomRight.getIconHeight());\n    bottomLeft.paintIcon(c, g, 0, height - bottomLeft.getIconHeight());\n\n    for (int _x = topLeft.getIconWidth(); _x < width - topRight.getIconWidth(); _x++) {\n      top.paintIcon(c, g, _x, 0);\n    }\n    for (int _x = bottomLeft.getIconWidth(); _x < width - bottomLeft.getIconWidth(); _x++) {\n      bottom.paintIcon(c, g, _x, height - bottomSize);\n    }\n    for (int _y = topLeft.getIconHeight(); _y < height - bottomLeft.getIconHeight(); _y++) {\n      left.paintIcon(c, g, 0, _y);\n    }\n    for (int _y = topRight.getIconHeight(); _y < height - bottomRight.getIconHeight(); _y++) {\n      right.paintIcon(c, g, width - sideSize, _y);\n    }\n\n    g.dispose();\n    return image;\n  }","commit_id":"e878bbbbf22e67dbd9f50ab3bd0b517ce3c88015","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected int doWork() {\n\n        // Prepare the sort ordering w.r.t. the sequence dictionary\n        final ReferenceSequenceFile refFile = ReferenceSequenceFileFactory.getReferenceSequenceFile(REF_FILE_ARG);\n        List<SAMSequenceRecord> refContigs = refFile.getSequenceDictionary();\n        HashMap<String, Integer> refContigOrdering = new HashMap<String, Integer>();\n\n        int i = 0;\n        for ( SAMSequenceRecord contig : refContigs ) {\n            System.out.println(contig.getSequenceName());\n            refContigOrdering.put(contig.getSequenceName(), i);\n            i++;\n        }\n        GenomeLoc.setContigOrdering(refContigOrdering);\n\n        Class rodClass = Types.get(ROD_TYPE.toLowerCase());\n\n        ReferenceOrderedData rod = new ReferenceOrderedData(new File(ROD_FILE), rodClass );\n        try {\n            rod.validateFile();\n        } catch ( Exception e ) {\n            //System.out.println(\"Validation failure: \" + e);\n            e.printStackTrace();\n        }\n\n        ArrayList<ReferenceOrderedDatum> rodData = rod.readAll();\n        System.out.printf(\"Read %d elements from %s%n\", rodData.size(), ROD_FILE);\n        ReferenceOrderedData.sortRODDataInMemory(rodData);\n        try {\n            ReferenceOrderedData.write(rodData, new File(OUTPUT_FILE));\n         } catch ( IOException e ) {\n            //System.out.println(\"Validation failure: \" + e);\n            e.printStackTrace();\n        }\n\n        System.out.printf(\"Validating output file %s%n\", rodData.size(), OUTPUT_FILE);\n        ReferenceOrderedData outputRod = new ReferenceOrderedData(new File(OUTPUT_FILE), rodClass );\n        try {\n            outputRod.validateFile();\n            //outputRod.hasSameContents(ROD_FILE);\n        } catch ( Exception e ) {\n            //System.out.println(\"Validation failure: \" + e);\n            e.printStackTrace();\n        }        \n\n        return 0;\n    }","id":28101,"modified_method":"protected int doWork() {\n\n        // Prepare the sort ordering w.r.t. the sequence dictionary\n        final ReferenceSequenceFile refFile = ReferenceSequenceFileFactory.getReferenceSequenceFile(REF_FILE_ARG);\n        List<SAMSequenceRecord> refContigs = refFile.getSequenceDictionary().getSequences();\n        HashMap<String, Integer> refContigOrdering = new HashMap<String, Integer>();\n\n        int i = 0;\n        for ( SAMSequenceRecord contig : refContigs ) {\n            System.out.println(contig.getSequenceName());\n            refContigOrdering.put(contig.getSequenceName(), i);\n            i++;\n        }\n        GenomeLoc.setContigOrdering(refContigOrdering);\n\n        Class rodClass = Types.get(ROD_TYPE.toLowerCase());\n\n        ReferenceOrderedData rod = new ReferenceOrderedData(new File(ROD_FILE), rodClass );\n        try {\n            rod.validateFile();\n        } catch ( Exception e ) {\n            //System.out.println(\"Validation failure: \" + e);\n            e.printStackTrace();\n        }\n\n        ArrayList<ReferenceOrderedDatum> rodData = rod.readAll();\n        System.out.printf(\"Read %d elements from %s%n\", rodData.size(), ROD_FILE);\n        ReferenceOrderedData.sortRODDataInMemory(rodData);\n        try {\n            ReferenceOrderedData.write(rodData, new File(OUTPUT_FILE));\n         } catch ( IOException e ) {\n            //System.out.println(\"Validation failure: \" + e);\n            e.printStackTrace();\n        }\n\n        System.out.printf(\"Validating output file %s%n\", rodData.size(), OUTPUT_FILE);\n        ReferenceOrderedData outputRod = new ReferenceOrderedData(new File(OUTPUT_FILE), rodClass );\n        try {\n            outputRod.validateFile();\n            //outputRod.hasSameContents(ROD_FILE);\n        } catch ( Exception e ) {\n            //System.out.println(\"Validation failure: \" + e);\n            e.printStackTrace();\n        }        \n\n        return 0;\n    }","commit_id":"1fcf4c0cbf0661b5fb4f80dbe4e43570ce43d19a","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static boolean setupRefContigOrdering(final ReferenceSequenceFile refFile) {\n        List<SAMSequenceRecord> refContigs = refFile.getSequenceDictionary();\n        HashMap<String, Integer> refContigOrdering = new HashMap<String, Integer>();\n\n        if ( refContigs != null ) {\n            int i = 0;\n            System.out.printf(\"Prepared reference sequence contig dictionary%n  order ->\");\n            for ( SAMSequenceRecord contig : refContigs ) {\n                System.out.printf(\" %s\", contig.getSequenceName());\n                refContigOrdering.put(contig.getSequenceName(), i);\n                i++;\n            }\n            System.out.printf(\"%n  Total elements -> %d%n\", refContigOrdering.size());\n        }\n        \n        GenomeLoc.setContigOrdering(refContigOrdering);\n        return refContigs != null;\n    }","id":28102,"modified_method":"public static boolean setupRefContigOrdering(final ReferenceSequenceFile refFile) {\n        List<SAMSequenceRecord> refContigs = refFile.getSequenceDictionary().getSequences();\n        HashMap<String, Integer> refContigOrdering = new HashMap<String, Integer>();\n\n        if ( refContigs != null ) {\n            int i = 0;\n            System.out.printf(\"Prepared reference sequence contig dictionary%n  order ->\");\n            for ( SAMSequenceRecord contig : refContigs ) {\n                System.out.printf(\" %s\", contig.getSequenceName());\n                refContigOrdering.put(contig.getSequenceName(), i);\n                i++;\n            }\n            System.out.printf(\"%n  Total elements -> %d%n\", refContigOrdering.size());\n        }\n        \n        GenomeLoc.setContigOrdering(refContigOrdering);\n        return refContigs != null;\n    }","commit_id":"1fcf4c0cbf0661b5fb4f80dbe4e43570ce43d19a","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Get the sharding strategy given a driving data source.\n     *\n     * @param walker            Walker for which to infer sharding strategy.\n     * @param drivingDataSource Data on which to shard.\n     * @param intervals         Intervals to use when limiting sharding.\n     * @param maxIterations     the maximum number of iterations to run through\n     * @return Sharding strategy for this driving data source.\n     */\n    protected ShardStrategy getShardStrategy(Walker walker,\n                                             ReferenceSequenceFile drivingDataSource,\n                                             GenomeLocSortedSet intervals,\n                                             Integer maxIterations,\n                                             ValidationExclusion exclusions) {\n        // Use monolithic sharding if no index is present.  Monolithic sharding is always required for the original\n        // sharding system; it's required with the new sharding system only for locus walkers.\n        if(readsDataSource != null && !readsDataSource.hasIndex() ) { \n            if(!exclusions.contains(ValidationExclusion.TYPE.ALLOW_UNINDEXED_BAM) || intervals != null)\n                throw new StingException(\"The GATK cannot currently process unindexed BAM files without the -U ALLOW_UNINDEXED_BAM, or with unindexed BAM files with the -L option\");\n\n            Shard.ShardType shardType;\n            if(walker instanceof LocusWalker) {\n                if(readsDataSource != null && readsDataSource.getSortOrder() != SAMFileHeader.SortOrder.coordinate)\n                    Utils.scareUser(\"Locus walkers can only walk over coordinate-sorted data.  Please resort your input BAM file.\");                \n                shardType = Shard.ShardType.LOCUS;\n            }\n            else if(walker instanceof ReadWalker || walker instanceof DuplicateWalker || walker instanceof ReadPairWalker)\n                shardType = Shard.ShardType.READ;\n            else\n                throw new StingException(\"The GATK cannot currently process unindexed BAM files\");\n\n            return new MonolithicShardStrategy(shardType,drivingDataSource.getSequenceDictionary());\n        }\n\n        ShardStrategy shardStrategy = null;\n        ShardStrategyFactory.SHATTER_STRATEGY shardType;\n\n        long SHARD_SIZE = 100000L;\n\n        if (walker instanceof LocusWalker) {\n            if (walker instanceof RodWalker) SHARD_SIZE *= 1000;\n\n            if (intervals != null && !intervals.isEmpty()) {\n                if(readsDataSource != null && readsDataSource.getSortOrder() != SAMFileHeader.SortOrder.coordinate)\n                    Utils.scareUser(\"Locus walkers can only walk over coordinate-sorted data.  Please resort your input BAM file.\");\n\n                shardStrategy = ShardStrategyFactory.shatter(readsDataSource,\n                        referenceDataSource.getReference(),\n                        ShardStrategyFactory.SHATTER_STRATEGY.LOCUS_EXPERIMENTAL,\n                        drivingDataSource.getSequenceDictionary(),\n                        SHARD_SIZE,\n                        intervals, maxIterations);\n            } else\n                shardStrategy = ShardStrategyFactory.shatter(readsDataSource,\n                        referenceDataSource.getReference(),\n                        ShardStrategyFactory.SHATTER_STRATEGY.LOCUS_EXPERIMENTAL,\n                        drivingDataSource.getSequenceDictionary(),\n                        SHARD_SIZE, maxIterations);\n        } else if (walker instanceof ReadWalker ||\n                walker instanceof DuplicateWalker) {\n            shardType = ShardStrategyFactory.SHATTER_STRATEGY.READS_EXPERIMENTAL;\n\n            if (intervals != null && !intervals.isEmpty()) {\n                shardStrategy = ShardStrategyFactory.shatter(readsDataSource,\n                        referenceDataSource.getReference(),\n                        shardType,\n                        drivingDataSource.getSequenceDictionary(),\n                        SHARD_SIZE,\n                        intervals, maxIterations);\n            } else {\n                shardStrategy = ShardStrategyFactory.shatter(readsDataSource,\n                        referenceDataSource.getReference(),\n                        shardType,\n                        drivingDataSource.getSequenceDictionary(),\n                        SHARD_SIZE, maxIterations);\n            }\n        } else if (walker instanceof ReadPairWalker) {\n            if(readsDataSource != null && readsDataSource.getSortOrder() != SAMFileHeader.SortOrder.queryname)\n                Utils.scareUser(\"Read pair walkers can only walk over query name-sorted data.  Please resort your input BAM file.\");            \n            if(intervals != null && !intervals.isEmpty())\n                Utils.scareUser(\"Pairs traversal cannot be used in conjunction with intervals.\");\n\n            shardStrategy = ShardStrategyFactory.shatter(readsDataSource,\n                    referenceDataSource.getReference(),\n                    ShardStrategyFactory.SHATTER_STRATEGY.READS_EXPERIMENTAL,\n                    drivingDataSource.getSequenceDictionary(),\n                    SHARD_SIZE, maxIterations);\n        } else\n            throw new StingException(\"Unable to support walker of type\" + walker.getClass().getName());\n\n        return shardStrategy;\n    }","id":28103,"modified_method":"/**\n     * Get the sharding strategy given a driving data source.\n     *\n     * @param walker            Walker for which to infer sharding strategy.\n     * @param drivingDataSource Data on which to shard.\n     * @param intervals         Intervals to use when limiting sharding.\n     * @param maxIterations     the maximum number of iterations to run through\n     * @return Sharding strategy for this driving data source.\n     */\n    protected ShardStrategy getShardStrategy(Walker walker,\n                                             ReferenceSequenceFile drivingDataSource,\n                                             GenomeLocSortedSet intervals,\n                                             Integer maxIterations,\n                                             ValidationExclusion exclusions) {\n        // Use monolithic sharding if no index is present.  Monolithic sharding is always required for the original\n        // sharding system; it's required with the new sharding system only for locus walkers.\n        if(readsDataSource != null && !readsDataSource.hasIndex() ) { \n            if(!exclusions.contains(ValidationExclusion.TYPE.ALLOW_UNINDEXED_BAM))\n                throw new StingException(\"The GATK cannot currently process unindexed BAM files without the -U ALLOW_UNINDEXED_BAM\");\n            if(intervals != null && WalkerManager.getWalkerDataSource(walker) != DataSource.REFERENCE)\n                throw new StingException(\"Cannot shard input by interval when walker is not driven by reference.\");\n\n            Shard.ShardType shardType;\n            if(walker instanceof LocusWalker) {\n                if(readsDataSource != null && readsDataSource.getSortOrder() != SAMFileHeader.SortOrder.coordinate)\n                    Utils.scareUser(\"Locus walkers can only walk over coordinate-sorted data.  Please resort your input BAM file.\");                \n                shardType = Shard.ShardType.LOCUS;\n            }\n            else if(walker instanceof ReadWalker || walker instanceof DuplicateWalker || walker instanceof ReadPairWalker)\n                shardType = Shard.ShardType.READ;\n            else\n                throw new StingException(\"The GATK cannot currently process unindexed BAM files\");\n\n            List<GenomeLoc> region;\n            if(intervals != null)\n                region = intervals.toList();\n            else {\n                region = new ArrayList<GenomeLoc>();\n                for(SAMSequenceRecord sequenceRecord: drivingDataSource.getSequenceDictionary().getSequences())\n                    region.add(GenomeLocParser.createGenomeLoc(sequenceRecord.getSequenceName(),1,sequenceRecord.getSequenceLength()));\n            }\n\n            return new MonolithicShardStrategy(shardType,region);\n        }\n\n        ShardStrategy shardStrategy = null;\n        ShardStrategyFactory.SHATTER_STRATEGY shardType;\n\n        long SHARD_SIZE = 100000L;\n\n        if (walker instanceof LocusWalker) {\n            if (walker instanceof RodWalker) SHARD_SIZE *= 1000;\n\n            if (intervals != null && !intervals.isEmpty()) {\n                if(readsDataSource != null && readsDataSource.getSortOrder() != SAMFileHeader.SortOrder.coordinate)\n                    Utils.scareUser(\"Locus walkers can only walk over coordinate-sorted data.  Please resort your input BAM file.\");\n\n                shardStrategy = ShardStrategyFactory.shatter(readsDataSource,\n                        referenceDataSource.getReference(),\n                        ShardStrategyFactory.SHATTER_STRATEGY.LOCUS_EXPERIMENTAL,\n                        drivingDataSource.getSequenceDictionary(),\n                        SHARD_SIZE,\n                        intervals, maxIterations);\n            } else\n                shardStrategy = ShardStrategyFactory.shatter(readsDataSource,\n                        referenceDataSource.getReference(),\n                        ShardStrategyFactory.SHATTER_STRATEGY.LOCUS_EXPERIMENTAL,\n                        drivingDataSource.getSequenceDictionary(),\n                        SHARD_SIZE, maxIterations);\n        } else if (walker instanceof ReadWalker ||\n                walker instanceof DuplicateWalker) {\n            shardType = ShardStrategyFactory.SHATTER_STRATEGY.READS_EXPERIMENTAL;\n\n            if (intervals != null && !intervals.isEmpty()) {\n                shardStrategy = ShardStrategyFactory.shatter(readsDataSource,\n                        referenceDataSource.getReference(),\n                        shardType,\n                        drivingDataSource.getSequenceDictionary(),\n                        SHARD_SIZE,\n                        intervals, maxIterations);\n            } else {\n                shardStrategy = ShardStrategyFactory.shatter(readsDataSource,\n                        referenceDataSource.getReference(),\n                        shardType,\n                        drivingDataSource.getSequenceDictionary(),\n                        SHARD_SIZE, maxIterations);\n            }\n        } else if (walker instanceof ReadPairWalker) {\n            if(readsDataSource != null && readsDataSource.getSortOrder() != SAMFileHeader.SortOrder.queryname)\n                Utils.scareUser(\"Read pair walkers can only walk over query name-sorted data.  Please resort your input BAM file.\");            \n            if(intervals != null && !intervals.isEmpty())\n                Utils.scareUser(\"Pairs traversal cannot be used in conjunction with intervals.\");\n\n            shardStrategy = ShardStrategyFactory.shatter(readsDataSource,\n                    referenceDataSource.getReference(),\n                    ShardStrategyFactory.SHATTER_STRATEGY.READS_EXPERIMENTAL,\n                    drivingDataSource.getSequenceDictionary(),\n                    SHARD_SIZE, maxIterations);\n        } else\n            throw new StingException(\"Unable to support walker of type\" + walker.getClass().getName());\n\n        return shardStrategy;\n    }","commit_id":"120f90da5b400826e99005ed9b3bc8d6afb0cab0","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a new shard strategy for shards of the given type.\n     * @param shardType The shard type.\n     */\n    public MonolithicShardStrategy(final Shard.ShardType shardType, final SAMSequenceDictionary sequenceDictionary) {\n        shard = new MonolithicShard(shardType,sequenceDictionary);\n    }","id":28104,"modified_method":"/**\n     * Create a new shard strategy for shards of the given type.\n     * @param shardType The shard type.\n     */\n    public MonolithicShardStrategy(final Shard.ShardType shardType, final List<GenomeLoc> region) {\n        shard = new MonolithicShard(shardType,region);\n    }","commit_id":"120f90da5b400826e99005ed9b3bc8d6afb0cab0","url":"https://github.com/broadgsa/gatk"},{"original_method":"public boolean openNewFile()\r\n\t{\r\n\t\tif(data.writer!=null) return true;\r\n\t\tboolean retval=false;\r\n\t\t\r\n\t\ttry {\r\n         \r\n\t\t\tString filename = buildFilename();\r\n\t\t\tcreateParentFolder(filename);\r\n\t\t\tif (meta.AddToResult()) {\r\n\t\t\t\t// Add this to the result file names...\r\n\t\t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(filename, getTransMeta()), getTransMeta().getName(), getStepname());\r\n\t\t\t\tresultFile.setComment(BaseMessages.getString(PKG, \"JsonOutput.ResultFilenames.Comment\"));\r\n\t            addResultFile(resultFile);\r\n\t\t\t}\r\n\r\n            OutputStream outputStream;\r\n            OutputStream fos = KettleVFS.getOutputStream(filename, getTransMeta(), meta.isFileAppended());\r\n            outputStream=fos;\r\n\r\n            if (!Const.isEmpty(meta.getEncoding())) {\r\n                data.writer = new OutputStreamWriter(new BufferedOutputStream(outputStream, 5000), environmentSubstitute(meta.getEncoding()));\r\n            } else {\r\n                data.writer = new OutputStreamWriter(new BufferedOutputStream(outputStream, 5000));\r\n            }\r\n            \r\n            if(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"JsonOutput.FileOpened\", filename));\r\n            \r\n            data.splitnr++;\r\n\t\t\t\r\n\t\t\tretval=true;\r\n            \r\n\t\t} catch(Exception e) {\r\n\t\t\tlogError(BaseMessages.getString(PKG, \"JsonOutput.Error.OpeningFile\", e.toString()));\r\n\t\t}\r\n\r\n\t\treturn retval;\r\n\t}","id":28105,"modified_method":"public boolean openNewFile()\r\n\t{\r\n\t\tif(data.writer!=null) return true;\r\n\t\tboolean retval=false;\r\n\t\t\r\n\t\ttry {\r\n         \r\n\t\t  if (meta.isServletOutput()) {\r\n\t\t    data.writer = getTrans().getServletPrintWriter();\r\n\t\t  } else {\r\n  \t\t\tString filename = buildFilename();\r\n  \t\t\tcreateParentFolder(filename);\r\n  \t\t\tif (meta.AddToResult()) {\r\n  \t\t\t\t// Add this to the result file names...\r\n  \t\t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(filename, getTransMeta()), getTransMeta().getName(), getStepname());\r\n  \t\t\t\tresultFile.setComment(BaseMessages.getString(PKG, \"JsonOutput.ResultFilenames.Comment\"));\r\n  \t            addResultFile(resultFile);\r\n  \t\t\t}\r\n  \r\n              OutputStream outputStream;\r\n              OutputStream fos = KettleVFS.getOutputStream(filename, getTransMeta(), meta.isFileAppended());\r\n              outputStream=fos;\r\n  \r\n              if (!Const.isEmpty(meta.getEncoding())) {\r\n                  data.writer = new OutputStreamWriter(new BufferedOutputStream(outputStream, 5000), environmentSubstitute(meta.getEncoding()));\r\n              } else {\r\n                  data.writer = new OutputStreamWriter(new BufferedOutputStream(outputStream, 5000));\r\n              }\r\n              \r\n              if(log.isDetailed()) logDetailed(BaseMessages.getString(PKG, \"JsonOutput.FileOpened\", filename));\r\n              \r\n              data.splitnr++;\r\n\t\t  }\r\n\t\t\t\r\n\t\t\tretval=true;\r\n            \r\n\t\t} catch(Exception e) {\r\n\t\t\tlogError(BaseMessages.getString(PKG, \"JsonOutput.Error.OpeningFile\", e.toString()));\r\n\t\t}\r\n\r\n\t\treturn retval;\r\n\t}","commit_id":"6616135e75db58916e0f787593602e3aa6f6865a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\r\n    {\r\n        meta=(JsonOutputMeta)smi;\r\n        data=(JsonOutputData)sdi;\r\n        if(super.init(smi, sdi)) {\r\n        \t\r\n        \tdata.writeToFile = (meta.getOperationType() != JsonOutputMeta.OPERATION_TYPE_OUTPUT_VALUE);\r\n        \tdata.outputValue = (meta.getOperationType() != JsonOutputMeta.OPERATION_TYPE_WRITE_TO_FILE);\r\n        \t\r\n        \tif(data.outputValue) {\r\n        \t\t// We need to have output field name\r\n        \t\tif(Const.isEmpty(environmentSubstitute(meta.getOutputValue()))) {\r\n        \t\t\tlogError(BaseMessages.getString(PKG, \"JsonOutput.Error.MissingOutputFieldName\"));\r\n    \t\t\t\tstopAll();\r\n    \t\t\t\tsetErrors(1);\r\n        \t\t\treturn false;\r\n        \t\t}\r\n        \t}\r\n        \tif(data.writeToFile) {\r\n        \t\t// We need to have output field name\r\n        \t\tif(Const.isEmpty(meta.getFileName())) {\r\n        \t\t\tlogError(BaseMessages.getString(PKG, \"JsonOutput.Error.MissingTargetFilename\"));\r\n    \t\t\t\tstopAll();\r\n    \t\t\t\tsetErrors(1);\r\n        \t\t\treturn false;\r\n        \t\t}\r\n        \t\tif(!meta.isDoNotOpenNewFileInit()) {\r\n\t\t\t\t\tif (!openNewFile()) {\r\n\t\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"JsonOutput.Error.OpenNewFile\", buildFilename()));\r\n\t\t\t\t\t\tstopAll();\r\n\t\t\t\t\t\tsetErrors(1);\r\n\t        \t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n        \t\t\r\n\r\n        \t}\r\n            data.realBlocName = Const.NVL(environmentSubstitute(meta.getJsonBloc()), \"\");\r\n            data.nrRowsInBloc = Const.toInt(environmentSubstitute(meta.getNrRowsInBloc()), 0);\r\n        \treturn true;\r\n        }\r\n\r\n\r\n        return false;\r\n    }","id":28106,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\r\n    {\r\n        meta=(JsonOutputMeta)smi;\r\n        data=(JsonOutputData)sdi;\r\n        if(super.init(smi, sdi)) {\r\n        \t\r\n        \tdata.writeToFile = (meta.getOperationType() != JsonOutputMeta.OPERATION_TYPE_OUTPUT_VALUE);\r\n        \tdata.outputValue = (meta.getOperationType() != JsonOutputMeta.OPERATION_TYPE_WRITE_TO_FILE);\r\n        \t\r\n        \tif(data.outputValue) {\r\n        \t\t// We need to have output field name\r\n        \t\tif(Const.isEmpty(environmentSubstitute(meta.getOutputValue()))) {\r\n        \t\t\tlogError(BaseMessages.getString(PKG, \"JsonOutput.Error.MissingOutputFieldName\"));\r\n    \t\t\t\tstopAll();\r\n    \t\t\t\tsetErrors(1);\r\n        \t\t\treturn false;\r\n        \t\t}\r\n        \t}\r\n        \tif(data.writeToFile) {\r\n        \t\t// We need to have output field name\r\n        \t\tif(!meta.isServletOutput() && Const.isEmpty(meta.getFileName())) {\r\n        \t\t\tlogError(BaseMessages.getString(PKG, \"JsonOutput.Error.MissingTargetFilename\"));\r\n    \t\t\t\tstopAll();\r\n    \t\t\t\tsetErrors(1);\r\n        \t\t\treturn false;\r\n        \t\t}\r\n        \t\tif(!meta.isDoNotOpenNewFileInit()) {\r\n\t\t\t\t\tif (!openNewFile()) {\r\n\t\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"JsonOutput.Error.OpenNewFile\", buildFilename()));\r\n\t\t\t\t\t\tstopAll();\r\n\t\t\t\t\t\tsetErrors(1);\r\n\t        \t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n        \t\t\r\n\r\n        \t}\r\n            data.realBlocName = Const.NVL(environmentSubstitute(meta.getJsonBloc()), \"\");\r\n            data.nrRowsInBloc = Const.toInt(environmentSubstitute(meta.getNrRowsInBloc()), 0);\r\n        \treturn true;\r\n        }\r\n\r\n\r\n        return false;\r\n    }","commit_id":"6616135e75db58916e0f787593602e3aa6f6865a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\r\n    {\r\n        Shell parent = getParent();\r\n        Display display = parent.getDisplay();\r\n\r\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n        props.setLook(shell);\r\n        setShellImage(shell, input);\r\n\r\n        ModifyListener lsMod = new ModifyListener() \r\n        {\r\n            public void modifyText(ModifyEvent e) \r\n            {\r\n                input.setChanged();\r\n            }\r\n        };\r\n        changed = input.hasChanged();\r\n        \r\n        FormLayout formLayout = new FormLayout ();\r\n        formLayout.marginWidth  = Const.FORM_MARGIN;\r\n        formLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n        shell.setLayout(formLayout);\r\n        shell.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.DialogTitle\"));\r\n        \r\n        int middle = props.getMiddlePct();\r\n        int margin = Const.MARGIN;\r\n\r\n        // Stepname line\r\n        wlStepname=new Label(shell, SWT.RIGHT);\r\n        wlStepname.setText(BaseMessages.getString(PKG, \"System.Label.StepName\"));\r\n        props.setLook(wlStepname);\r\n        fdlStepname=new FormData();\r\n        fdlStepname.left  = new FormAttachment(0, 0);\r\n        fdlStepname.top   = new FormAttachment(0, margin);\r\n        fdlStepname.right = new FormAttachment(middle, -margin);\r\n        wlStepname.setLayoutData(fdlStepname);\r\n        wStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n        wStepname.setText(stepname);\r\n        props.setLook(wStepname);\r\n        wStepname.addModifyListener(lsMod);\r\n        fdStepname=new FormData();\r\n        fdStepname.left = new FormAttachment(middle, 0);\r\n        fdStepname.top  = new FormAttachment(0, margin);\r\n        fdStepname.right= new FormAttachment(100, 0);\r\n        wStepname.setLayoutData(fdStepname);\r\n\r\n        wTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n        props.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n        \r\n        //////////////////////////\r\n        // START OF General TAB///\r\n        ///\r\n        wGeneralTab=new CTabItem(wTabFolder, SWT.NONE);\r\n        wGeneralTab.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.GeneralTab.TabTitle\"));\r\n        \r\n\r\n        FormLayout GeneralLayout = new FormLayout ();\r\n        GeneralLayout.marginWidth  = 3;\r\n        GeneralLayout.marginHeight = 3;\r\n        \r\n        Composite wGeneralComp = new Composite(wTabFolder, SWT.NONE);\r\n        props.setLook(wGeneralComp);\r\n        wGeneralComp.setLayout(GeneralLayout);\r\n\r\n        // Operation\r\n\t\twlOperation=new Label(wGeneralComp, SWT.RIGHT);\r\n\t\twlOperation.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.Operation.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlOperation);\r\n\t\tfdlOperation=new FormData();\r\n\t\tfdlOperation.left = new FormAttachment(0, 0);\r\n\t\tfdlOperation.right= new FormAttachment(middle, -margin);\r\n\t\tfdlOperation.top  = new FormAttachment(wNrRowsInBloc, margin);\r\n\t\twlOperation.setLayoutData(fdlOperation);\r\n\t\t\r\n\t\twOperation=new CCombo(wGeneralComp, SWT.BORDER | SWT.READ_ONLY);\r\n \t\tprops.setLook(wOperation);\r\n \t\twOperation.addModifyListener(lsMod);\r\n\t\tfdOperation=new FormData();\r\n\t\tfdOperation.left = new FormAttachment(middle, 0);\r\n\t\tfdOperation.top  = new FormAttachment(wNrRowsInBloc, margin);\r\n\t\tfdOperation.right= new FormAttachment(100, -margin);\r\n\t\twOperation.setLayoutData(fdOperation);\r\n\t\twOperation.setItems(JsonOutputMeta.operationTypeDesc);\r\n\t\twOperation.addSelectionListener(new SelectionAdapter()\r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e)\r\n\t\t\t{\r\n\t\t\t\tupdateOperation();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t});\r\n       \r\n\r\n    \t\r\n\t\t// Connection grouping?\r\n\t\t// ////////////////////////\r\n\t\t// START OF Settings GROUP\r\n\t\t// \r\n\r\n\t\twSettings = new Group(wGeneralComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wSettings);\r\n\t\twSettings.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.Group.Settings.Label\"));\r\n\t\t\r\n\t\tFormLayout groupFileLayout = new FormLayout();\r\n\t\tgroupFileLayout.marginWidth = 10;\r\n\t\tgroupFileLayout.marginHeight = 10;\r\n\t\twSettings.setLayout(groupFileLayout);\r\n\t\t\r\n\r\n        wlBlocName=new Label(wSettings, SWT.RIGHT);\r\n        wlBlocName.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.BlocName.Label\"));\r\n        props.setLook(wlBlocName);\r\n        fdlBlocName=new FormData();\r\n        fdlBlocName.left = new FormAttachment(0, 0);\r\n        fdlBlocName.top  = new FormAttachment(wOperation, margin);\r\n        fdlBlocName.right= new FormAttachment(middle, -margin);\r\n        wlBlocName.setLayoutData(fdlBlocName);\r\n        wBlocName=new TextVar(transMeta, wSettings, SWT.BORDER | SWT.READ_ONLY);\r\n        wBlocName.setEditable(true);\r\n        props.setLook(wBlocName);\r\n        wBlocName.addModifyListener(lsMod);\r\n        fdBlocName=new FormData();\r\n        fdBlocName.left = new FormAttachment(middle, 0);\r\n        fdBlocName.top  = new FormAttachment(wOperation, margin);\r\n        fdBlocName.right= new FormAttachment(100, 0);\r\n        wBlocName.setLayoutData(fdBlocName);\r\n        \r\n        wlNrRowsInBloc=new Label(wSettings, SWT.RIGHT);\r\n        wlNrRowsInBloc.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.NrRowsInBloc.Label\"));\r\n        props.setLook(wlNrRowsInBloc);\r\n        fdlNrRowsInBloc=new FormData();\r\n        fdlNrRowsInBloc.left = new FormAttachment(0, 0);\r\n        fdlNrRowsInBloc.top  = new FormAttachment(wBlocName, margin);\r\n        fdlNrRowsInBloc.right= new FormAttachment(middle, -margin);\r\n        wlNrRowsInBloc.setLayoutData(fdlNrRowsInBloc);\r\n        wNrRowsInBloc=new TextVar(transMeta, wSettings, SWT.BORDER | SWT.READ_ONLY);\r\n        wNrRowsInBloc.setToolTipText(BaseMessages.getString(PKG, \"JsonOutputDialog.NrRowsInBloc.ToolTip\"));\r\n        wNrRowsInBloc.setEditable(true);\r\n        props.setLook(wNrRowsInBloc);\r\n        wNrRowsInBloc.addModifyListener(lsMod);\r\n        fdNrRowsInBloc=new FormData();\r\n        fdNrRowsInBloc.left = new FormAttachment(middle, 0);\r\n        fdNrRowsInBloc.top  = new FormAttachment(wBlocName, margin);\r\n        fdNrRowsInBloc.right= new FormAttachment(100, 0);\r\n        wNrRowsInBloc.setLayoutData(fdNrRowsInBloc);\r\n        \r\n        wlOutputValue=new Label(wSettings, SWT.RIGHT);\r\n        wlOutputValue.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.OutputValue.Label\"));\r\n        props.setLook(wlOutputValue);\r\n        fdlOutputValue=new FormData();\r\n        fdlOutputValue.left = new FormAttachment(0, 0);\r\n        fdlOutputValue.top  = new FormAttachment(wNrRowsInBloc, margin);\r\n        fdlOutputValue.right= new FormAttachment(middle, -margin);\r\n        wlOutputValue.setLayoutData(fdlOutputValue);\r\n        wOutputValue=new TextVar(transMeta, wSettings, SWT.BORDER | SWT.READ_ONLY);\r\n        wOutputValue.setEditable(true);\r\n        props.setLook(wOutputValue);\r\n        wOutputValue.addModifyListener(lsMod);\r\n        fdOutputValue=new FormData();\r\n        fdOutputValue.left = new FormAttachment(middle, 0);\r\n        fdOutputValue.top  = new FormAttachment(wNrRowsInBloc, margin);\r\n        fdOutputValue.right= new FormAttachment(100, 0);\r\n        wOutputValue.setLayoutData(fdOutputValue);\r\n\r\n\t\r\n\t\tfdSettings = new FormData();\r\n\t\tfdSettings.left = new FormAttachment(0, margin);\r\n\t\tfdSettings.top = new FormAttachment(wOperation, 2*margin);\r\n\t\tfdSettings.right = new FormAttachment(100, -margin);\r\n\t\twSettings.setLayoutData(fdSettings);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF Settings GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\r\n    \t\r\n\t\t// Connection grouping?\r\n\t\t// ////////////////////////\r\n\t\t// START OF FileName GROUP\r\n\t\t// \r\n\r\n\t\twFileName = new Group(wGeneralComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wFileName);\r\n\t\twFileName.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.Group.File.Label\"));\r\n\t\t\r\n\t\tFormLayout groupfilenameayout = new FormLayout();\r\n\t\tgroupfilenameayout.marginWidth = 10;\r\n\t\tgroupfilenameayout.marginHeight = 10;\r\n\t\twFileName.setLayout(groupfilenameayout);\r\n\t\t\r\n\t\t\r\n\t\t// Filename line\r\n\t\twlFilename=new Label(wFileName, SWT.RIGHT);\r\n\t\twlFilename.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.Filename.Label\"));\r\n \t\tprops.setLook(wlFilename);\r\n\t\tfdlFilename=new FormData();\r\n\t\tfdlFilename.left = new FormAttachment(0, 0);\r\n\t\tfdlFilename.top  = new FormAttachment(wSettings, margin);\r\n\t\tfdlFilename.right= new FormAttachment(middle, -margin);\r\n\t\twlFilename.setLayoutData(fdlFilename);\r\n\r\n\t\twbFilename=new Button(wFileName, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbFilename);\r\n\t\twbFilename.setText(BaseMessages.getString(PKG, \"System.Button.Browse\"));\r\n\t\tfdbFilename=new FormData();\r\n\t\tfdbFilename.right= new FormAttachment(100, 0);\r\n\t\tfdbFilename.top  = new FormAttachment(wSettings, 0);\r\n\t\twbFilename.setLayoutData(fdbFilename);\r\n\t\twbFilename.addSelectionListener\r\n\t\t(\r\n\t\t\tnew SelectionAdapter()\r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.SAVE);\r\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.js\", \"*.JS\", \"*\"});\r\n\t\t\t\t\tif (wFilename.getText()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdialog.setFileName(transMeta.environmentSubstitute(wFilename.getText()));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdialog.setFilterNames(new String[] {BaseMessages.getString(PKG, \"System.FileType.TextFiles\"), BaseMessages.getString(PKG, \"System.FileType.CSVFiles\"), BaseMessages.getString(PKG, \"System.FileType.AllFiles\")});\r\n\t\t\t\t\tif (dialog.open()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tString extension = wExtension.getText();\r\n\t\t\t\t\t\tif ( extension != null && dialog.getFileName() != null &&\r\n\t\t\t\t\t\t\t\tdialog.getFileName().endsWith(\".\" + extension) )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// The extension is filled in and matches the end \r\n\t\t\t\t\t\t\t// of the selected file => Strip off the extension.\r\n\t\t\t\t\t\t\tString fileName = dialog.getFileName();\r\n\t\t\t\t\t\t    wFilename.setText(dialog.getFilterPath()+System.getProperty(\"file.separator\")+\r\n\t\t\t\t\t\t    \t\t          fileName.substring(0, fileName.length() - (extension.length()+1)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t    wFilename.setText(dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\twFilename=new TextVar(transMeta, wFileName, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wFilename);\r\n\t\twFilename.addModifyListener(lsMod);\r\n\t\tfdFilename=new FormData();\r\n\t\tfdFilename.left = new FormAttachment(middle, 0);\r\n\t\tfdFilename.top  = new FormAttachment(wOutputValue, margin);\r\n\t\tfdFilename.right= new FormAttachment(wbFilename, -margin);\r\n\t\twFilename.setLayoutData(fdFilename);\r\n\t\t\r\n\t\t\r\n\t\t// Append to end of file?\r\n\t\twlAppend=new Label(wFileName, SWT.RIGHT);\r\n\t\twlAppend.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.Append.Label\"));\r\n \t\tprops.setLook(wlAppend);\r\n\t\tfdlAppend=new FormData();\r\n\t\tfdlAppend.left = new FormAttachment(0, 0);\r\n\t\tfdlAppend.top  = new FormAttachment(wFilename, margin);\r\n\t\tfdlAppend.right= new FormAttachment(middle, -margin);\r\n\t\twlAppend.setLayoutData(fdlAppend);\r\n\t\twAppend=new Button(wFileName, SWT.CHECK);\r\n\t\twAppend.setToolTipText(BaseMessages.getString(PKG, \"JsonOutputDialog.Append.Tooltip\"));\r\n \t\tprops.setLook(wAppend);\r\n\t\tfdAppend=new FormData();\r\n\t\tfdAppend.left = new FormAttachment(middle, 0);\r\n\t\tfdAppend.top  = new FormAttachment(wFilename, margin);\r\n\t\tfdAppend.right= new FormAttachment(100, 0);\r\n\t\twAppend.setLayoutData(fdAppend);\r\n\t\twAppend.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t// Create Parent Folder\r\n\t\twlCreateParentFolder=new Label(wFileName, SWT.RIGHT);\r\n\t\twlCreateParentFolder.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.CreateParentFolder.Label\"));\r\n \t\tprops.setLook(wlCreateParentFolder);\r\n\t\tfdlCreateParentFolder=new FormData();\r\n\t\tfdlCreateParentFolder.left = new FormAttachment(0, 0);\r\n\t\tfdlCreateParentFolder.top  = new FormAttachment(wAppend, margin);\r\n\t\tfdlCreateParentFolder.right= new FormAttachment(middle, -margin);\r\n\t\twlCreateParentFolder.setLayoutData(fdlCreateParentFolder);\r\n\t\twCreateParentFolder=new Button(wFileName, SWT.CHECK );\r\n\t\twCreateParentFolder.setToolTipText(BaseMessages.getString(PKG, \"JsonOutputDialog.CreateParentFolder.Tooltip\"));\r\n \t\tprops.setLook(wCreateParentFolder);\r\n\t\tfdCreateParentFolder=new FormData();\r\n\t\tfdCreateParentFolder.left = new FormAttachment(middle, 0);\r\n\t\tfdCreateParentFolder.top  = new FormAttachment(wAppend, margin);\r\n\t\tfdCreateParentFolder.right= new FormAttachment(100, 0);\r\n\t\twCreateParentFolder.setLayoutData(fdCreateParentFolder);\r\n\t\twCreateParentFolder.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\r\n\t\t// Open new File at Init\r\n\t\twlDoNotOpenNewFileInit=new Label(wFileName, SWT.RIGHT);\r\n\t\twlDoNotOpenNewFileInit.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.DoNotOpenNewFileInit.Label\"));\r\n \t\tprops.setLook(wlDoNotOpenNewFileInit);\r\n\t\tfdlDoNotOpenNewFileInit=new FormData();\r\n\t\tfdlDoNotOpenNewFileInit.left = new FormAttachment(0, 0);\r\n\t\tfdlDoNotOpenNewFileInit.top  = new FormAttachment(wCreateParentFolder, margin);\r\n\t\tfdlDoNotOpenNewFileInit.right= new FormAttachment(middle, -margin);\r\n\t\twlDoNotOpenNewFileInit.setLayoutData(fdlDoNotOpenNewFileInit);\r\n\t\twDoNotOpenNewFileInit=new Button(wFileName, SWT.CHECK );\r\n\t\twDoNotOpenNewFileInit.setToolTipText(BaseMessages.getString(PKG, \"JsonOutputDialog.DoNotOpenNewFileInit.Tooltip\"));\r\n \t\tprops.setLook(wDoNotOpenNewFileInit);\r\n\t\tfdDoNotOpenNewFileInit=new FormData();\r\n\t\tfdDoNotOpenNewFileInit.left = new FormAttachment(middle, 0);\r\n\t\tfdDoNotOpenNewFileInit.top  = new FormAttachment(wCreateParentFolder, margin);\r\n\t\tfdDoNotOpenNewFileInit.right= new FormAttachment(100, 0);\r\n\t\twDoNotOpenNewFileInit.setLayoutData(fdDoNotOpenNewFileInit);\r\n\t\twDoNotOpenNewFileInit.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t\r\n\t\t// Extension line\r\n\t\twlExtension=new Label(wFileName, SWT.RIGHT);\r\n\t\twlExtension.setText(BaseMessages.getString(PKG, \"System.Label.Extension\"));\r\n \t\tprops.setLook(wlExtension);\r\n\t\tfdlExtension=new FormData();\r\n\t\tfdlExtension.left = new FormAttachment(0, 0);\r\n\t\tfdlExtension.top  = new FormAttachment(wDoNotOpenNewFileInit, margin);\r\n\t\tfdlExtension.right= new FormAttachment(middle, -margin);\r\n\t\twlExtension.setLayoutData(fdlExtension);\r\n\t\t\r\n\t\twExtension=new TextVar(transMeta, wFileName, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wExtension);\r\n \t\twExtension.addModifyListener(lsMod);\r\n \t\tfdExtension=new FormData();\r\n\t\tfdExtension.left = new FormAttachment(middle, 0);\r\n\t\tfdExtension.top  = new FormAttachment(wDoNotOpenNewFileInit, margin);\r\n\t\tfdExtension.right= new FormAttachment(100, -margin);\r\n\t\twExtension.setLayoutData(fdExtension);\r\n\t\t\r\n\r\n        wlEncoding=new Label(wFileName, SWT.RIGHT);\r\n        wlEncoding.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.Encoding.Label\"));\r\n        props.setLook(wlEncoding);\r\n        fdlEncoding=new FormData();\r\n        fdlEncoding.left = new FormAttachment(0, 0);\r\n        fdlEncoding.top  = new FormAttachment(wExtension, margin);\r\n        fdlEncoding.right= new FormAttachment(middle, -margin);\r\n        wlEncoding.setLayoutData(fdlEncoding);\r\n        wEncoding=new ComboVar(transMeta, wFileName, SWT.BORDER | SWT.READ_ONLY);\r\n        wEncoding.setEditable(true);\r\n        props.setLook(wEncoding);\r\n        wEncoding.addModifyListener(lsMod);\r\n        fdEncoding=new FormData();\r\n        fdEncoding.left = new FormAttachment(middle, 0);\r\n        fdEncoding.top  = new FormAttachment(wExtension, margin);\r\n        fdEncoding.right= new FormAttachment(100, 0);\r\n        wEncoding.setLayoutData(fdEncoding);\r\n        wEncoding.addFocusListener(new FocusListener()\r\n            {\r\n                public void focusLost(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                }\r\n            \r\n                public void focusGained(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                    Cursor busy = new Cursor(shell.getDisplay(), SWT.CURSOR_WAIT);\r\n                    shell.setCursor(busy);\r\n                    setEncodings();\r\n                    shell.setCursor(null);\r\n                    busy.dispose();\r\n                }\r\n            }\r\n        );\r\n\t\r\n\t\t// Create multi-part file?\r\n\t\twlAddDate=new Label(wFileName, SWT.RIGHT);\r\n\t\twlAddDate.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.AddDate.Label\"));\r\n \t\tprops.setLook(wlAddDate);\r\n\t\tfdlAddDate=new FormData();\r\n\t\tfdlAddDate.left = new FormAttachment(0, 0);\r\n\t\tfdlAddDate.top  = new FormAttachment(wEncoding, margin);\r\n\t\tfdlAddDate.right= new FormAttachment(middle, -margin);\r\n\t\twlAddDate.setLayoutData(fdlAddDate);\r\n\t\twAddDate=new Button(wFileName, SWT.CHECK);\r\n \t\tprops.setLook(wAddDate);\r\n\t\tfdAddDate=new FormData();\r\n\t\tfdAddDate.left = new FormAttachment(middle, 0);\r\n\t\tfdAddDate.top  = new FormAttachment(wEncoding, margin);\r\n\t\tfdAddDate.right= new FormAttachment(100, 0);\r\n\t\twAddDate.setLayoutData(fdAddDate);\r\n\t\twAddDate.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t// Create multi-part file?\r\n\t\twlAddTime=new Label(wFileName, SWT.RIGHT);\r\n\t\twlAddTime.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.AddTime.Label\"));\r\n \t\tprops.setLook(wlAddTime);\r\n\t\tfdlAddTime=new FormData();\r\n\t\tfdlAddTime.left = new FormAttachment(0, 0);\r\n\t\tfdlAddTime.top  = new FormAttachment(wAddDate, margin);\r\n\t\tfdlAddTime.right= new FormAttachment(middle, -margin);\r\n\t\twlAddTime.setLayoutData(fdlAddTime);\r\n\t\twAddTime=new Button(wFileName, SWT.CHECK);\r\n \t\tprops.setLook(wAddTime);\r\n\t\tfdAddTime=new FormData();\r\n\t\tfdAddTime.left = new FormAttachment(middle, 0);\r\n\t\tfdAddTime.top  = new FormAttachment(wAddDate, margin);\r\n\t\tfdAddTime.right= new FormAttachment(100, 0);\r\n\t\twAddTime.setLayoutData(fdAddTime);\r\n\t\twAddTime.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\r\n\t\t\r\n\r\n\t\twbShowFiles=new Button(wFileName, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbShowFiles);\r\n\t\twbShowFiles.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.ShowFiles.Button\"));\r\n\t\tfdbShowFiles=new FormData();\r\n\t\tfdbShowFiles.left = new FormAttachment(middle, 0);\r\n\t\tfdbShowFiles.top  = new FormAttachment(wAddTime, margin*2);\r\n\t\twbShowFiles.setLayoutData(fdbShowFiles);\r\n\t\twbShowFiles.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tJsonOutputMeta tfoi = new JsonOutputMeta();\r\n\t\t\t\t\tgetInfo(tfoi);\r\n\t\t\t\t\tString files[] = tfoi.getFiles(transMeta.environmentSubstitute(wFilename.getText()));\r\n\t\t\t\t\tif (files!=null && files.length>0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, files, \r\n\t\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"JsonOutputDialog.SelectOutputFiles.DialogTitle\"), \r\n\t\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"JsonOutputDialog.SelectOutputFiles.DialogMessage\"));\r\n\t\t\t\t\t\tesd.setViewOnly();\r\n\t\t\t\t\t\tesd.open();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\r\n\t\t\t\t\t\tmb.setMessage(BaseMessages.getString(PKG, \"JsonOutputDialog.NoFilesFound.DialogMessage\"));\r\n\t\t\t\t\t\tmb.setText(BaseMessages.getString(PKG, \"System.DialogTitle.Error\"));\r\n\t\t\t\t\t\tmb.open(); \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\r\n\t\t\r\n\t\t// Add File to the result files name\r\n\t\twlAddToResult=new Label(wFileName, SWT.RIGHT);\r\n\t\twlAddToResult.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.AddFileToResult.Label\"));\r\n\t\tprops.setLook(wlAddToResult);\r\n\t\tfdlAddToResult=new FormData();\r\n\t\tfdlAddToResult.left  = new FormAttachment(0, 0);\r\n\t\tfdlAddToResult.top   = new FormAttachment(wbShowFiles, margin);\r\n\t\tfdlAddToResult.right = new FormAttachment(middle, -margin);\r\n\t\twlAddToResult.setLayoutData(fdlAddToResult);\r\n\t\twAddToResult=new Button(wFileName, SWT.CHECK);\r\n\t\twAddToResult.setToolTipText(BaseMessages.getString(PKG, \"JsonOutputDialog.AddFileToResult.Tooltip\"));\r\n \t\tprops.setLook(wAddToResult);\r\n\t\tfdAddToResult=new FormData();\r\n\t\tfdAddToResult.left  = new FormAttachment(middle, 0);\r\n\t\tfdAddToResult.top   = new FormAttachment(wbShowFiles, margin);\r\n\t\tfdAddToResult.right = new FormAttachment(100, 0);\r\n\t\twAddToResult.setLayoutData(fdAddToResult);\r\n\t\tSelectionAdapter lsSelR = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent arg0)\r\n            {\r\n                input.setChanged();\r\n            }\r\n        };\r\n\t\twAddToResult.addSelectionListener(lsSelR);\r\n\r\n\r\n\t\t\r\n\t\t\r\n\t\tfdFileName = new FormData();\r\n\t\tfdFileName.left = new FormAttachment(0, margin);\r\n\t\tfdFileName.top = new FormAttachment(wSettings, 2*margin);\r\n\t\tfdFileName.right = new FormAttachment(100, -margin);\r\n\t\twFileName.setLayoutData(fdFileName);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF FileName GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\r\n        \r\n        \r\n\r\n        fdGeneralComp = new FormData();\r\n        fdGeneralComp.left  = new FormAttachment(0, 0);\r\n        fdGeneralComp.top   = new FormAttachment(wStepname, margin);\r\n        fdGeneralComp.right = new FormAttachment(100, 0);\r\n        fdGeneralComp.bottom= new FormAttachment(100, 0);\r\n        wGeneralComp.setLayoutData(fdGeneralComp);\r\n\r\n        wGeneralComp.layout();\r\n        wGeneralTab.setControl(wGeneralComp);\r\n        \r\n        /////////////////////////////////////////////////////////////\r\n        /// END OF General TAB\r\n        /////////////////////////////////////////////////////////////\r\n\r\n        // Fields tab...\r\n        //\r\n        wFieldsTab = new CTabItem(wTabFolder, SWT.NONE);\r\n        wFieldsTab.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.FieldsTab.TabTitle\"));\r\n        \r\n        FormLayout fieldsLayout = new FormLayout ();\r\n        fieldsLayout.marginWidth  = Const.FORM_MARGIN;\r\n        fieldsLayout.marginHeight = Const.FORM_MARGIN;\r\n        \r\n        Composite wFieldsComp = new Composite(wTabFolder, SWT.NONE);\r\n        wFieldsComp.setLayout(fieldsLayout);\r\n        props.setLook(wFieldsComp);\r\n\r\n        wGet=new Button(wFieldsComp, SWT.PUSH);\r\n        wGet.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.Get.Button\"));\r\n        wGet.setToolTipText(BaseMessages.getString(PKG, \"JsonOutputDialog.Get.Tooltip\"));\r\n\r\n\r\n        setButtonPositions(new Button[] { wGet}, margin, null);\r\n\r\n        final int FieldsRows=input.getOutputFields().length;\r\n        \r\n        colinf=new ColumnInfo[]\r\n        {\r\n            new ColumnInfo(BaseMessages.getString(PKG, \"JsonOutputDialog.Fieldname.Column\"),   ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"\" }, false),\r\n            new ColumnInfo(BaseMessages.getString(PKG, \"JsonOutputDialog.ElementName.Column\"), ColumnInfo.COLUMN_TYPE_TEXT,   false),\r\n         };\r\n        colinf[1].setUsingVariables(true);\r\n        wFields=new TableView(transMeta, wFieldsComp, \r\n                              SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, \r\n                              colinf, \r\n                              FieldsRows,  \r\n                              lsMod,\r\n                              props\r\n                              );\r\n\r\n        fdFields=new FormData();\r\n        fdFields.left  = new FormAttachment(0, 0);\r\n        fdFields.top   = new FormAttachment(0, 0);\r\n        fdFields.right = new FormAttachment(100, 0);\r\n        fdFields.bottom= new FormAttachment(wGet, -margin);\r\n        wFields.setLayoutData(fdFields);\r\n        \r\n\t\t  // \r\n        // Search the fields in the background\r\n\t\t\r\n        final Runnable runnable = new Runnable()\r\n        {\r\n            public void run()\r\n            {\r\n                StepMeta stepMeta = transMeta.findStep(stepname);\r\n                if (stepMeta!=null)\r\n                {\r\n                    try\r\n                    {\r\n                    \tRowMetaInterface row = transMeta.getPrevStepFields(stepMeta);\r\n                       \r\n                        // Remember these fields...\r\n                        for (int i=0;i<row.size();i++)\r\n                        {\r\n                            inputFields.put(row.getValueMeta(i).getName(), Integer.valueOf(i));\r\n                        }\r\n                        setComboBoxes();\r\n                    }\r\n                    catch(KettleException e)\r\n                    {\r\n                    \tlogError( BaseMessages.getString(PKG, \"System.Dialog.GetFieldsFailed.Message\"));\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        new Thread(runnable).start();\r\n\r\n        fdFieldsComp=new FormData();\r\n        fdFieldsComp.left  = new FormAttachment(0, 0);\r\n        fdFieldsComp.top   = new FormAttachment(0, 0);\r\n        fdFieldsComp.right = new FormAttachment(100, 0);\r\n        fdFieldsComp.bottom= new FormAttachment(100, 0);\r\n        wFieldsComp.setLayoutData(fdFieldsComp);\r\n        \r\n        wFieldsComp.layout();\r\n        wFieldsTab.setControl(wFieldsComp);\r\n        \r\n        fdTabFolder = new FormData();\r\n        fdTabFolder.left  = new FormAttachment(0, 0);\r\n        fdTabFolder.top   = new FormAttachment(wStepname, margin);\r\n        fdTabFolder.right = new FormAttachment(100, 0);\r\n        fdTabFolder.bottom= new FormAttachment(100, -50);\r\n        wTabFolder.setLayoutData(fdTabFolder);\r\n        \r\n        wOK=new Button(shell, SWT.PUSH);\r\n        wOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\r\n        \r\n        wCancel=new Button(shell, SWT.PUSH);\r\n        wCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\"));\r\n\r\n        setButtonPositions(new Button[] { wOK, wCancel }, margin, wTabFolder);\r\n\r\n        // Add listeners\r\n        lsOK       = new Listener() { public void handleEvent(Event e) { ok();       } };\r\n        lsGet      = new Listener() { public void handleEvent(Event e) { get();      } };\r\n        lsCancel   = new Listener() { public void handleEvent(Event e) { cancel();   } };\r\n        \r\n        wOK.addListener    (SWT.Selection, lsOK    );\r\n        wGet.addListener   (SWT.Selection, lsGet   );\r\n        wCancel.addListener(SWT.Selection, lsCancel);\r\n        \r\n        lsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n        \r\n        wStepname.addSelectionListener( lsDef );\r\n        // Detect X or ALT-F4 or something that kills this window...\r\n        shell.addShellListener( new ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\r\n\r\n        lsResize = new Listener() \r\n        {\r\n            public void handleEvent(Event event) \r\n            {\r\n                Point size = shell.getSize();\r\n                wFields.setSize(size.x-10, size.y-50);\r\n                wFields.table.setSize(size.x-10, size.y-50);\r\n                wFields.redraw();\r\n            }\r\n        };\r\n        shell.addListener(SWT.Resize, lsResize);\r\n\r\n        wTabFolder.setSelection(0);\r\n        \r\n        // Set the shell size, based upon previous time...\r\n        setSize();\r\n        \r\n        getData();\r\n        updateOperation();\r\n        input.setChanged(changed);\r\n        \r\n        shell.open();\r\n        while (!shell.isDisposed())\r\n        {\r\n                if (!display.readAndDispatch()) display.sleep();\r\n        }\r\n        return stepname;\r\n    }","id":28107,"modified_method":"public String open()\r\n    {\r\n        Shell parent = getParent();\r\n        Display display = parent.getDisplay();\r\n\r\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n        props.setLook(shell);\r\n        setShellImage(shell, input);\r\n\r\n        ModifyListener lsMod = new ModifyListener() \r\n        {\r\n            public void modifyText(ModifyEvent e) \r\n            {\r\n                input.setChanged();\r\n            }\r\n        };\r\n        changed = input.hasChanged();\r\n        \r\n        FormLayout formLayout = new FormLayout ();\r\n        formLayout.marginWidth  = Const.FORM_MARGIN;\r\n        formLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n        shell.setLayout(formLayout);\r\n        shell.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.DialogTitle\"));\r\n        \r\n        int middle = props.getMiddlePct();\r\n        int margin = Const.MARGIN;\r\n\r\n        // Stepname line\r\n        wlStepname=new Label(shell, SWT.RIGHT);\r\n        wlStepname.setText(BaseMessages.getString(PKG, \"System.Label.StepName\"));\r\n        props.setLook(wlStepname);\r\n        fdlStepname=new FormData();\r\n        fdlStepname.left  = new FormAttachment(0, 0);\r\n        fdlStepname.top   = new FormAttachment(0, margin);\r\n        fdlStepname.right = new FormAttachment(middle, -margin);\r\n        wlStepname.setLayoutData(fdlStepname);\r\n        wStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n        wStepname.setText(stepname);\r\n        props.setLook(wStepname);\r\n        wStepname.addModifyListener(lsMod);\r\n        fdStepname=new FormData();\r\n        fdStepname.left = new FormAttachment(middle, 0);\r\n        fdStepname.top  = new FormAttachment(0, margin);\r\n        fdStepname.right= new FormAttachment(100, 0);\r\n        wStepname.setLayoutData(fdStepname);\r\n\r\n        wTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n        props.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n        \r\n        //////////////////////////\r\n        // START OF General TAB///\r\n        ///\r\n        wGeneralTab=new CTabItem(wTabFolder, SWT.NONE);\r\n        wGeneralTab.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.GeneralTab.TabTitle\"));\r\n        \r\n\r\n        FormLayout GeneralLayout = new FormLayout ();\r\n        GeneralLayout.marginWidth  = 3;\r\n        GeneralLayout.marginHeight = 3;\r\n        \r\n        Composite wGeneralComp = new Composite(wTabFolder, SWT.NONE);\r\n        props.setLook(wGeneralComp);\r\n        wGeneralComp.setLayout(GeneralLayout);\r\n\r\n        // Operation\r\n\t\twlOperation=new Label(wGeneralComp, SWT.RIGHT);\r\n\t\twlOperation.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.Operation.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlOperation);\r\n\t\tfdlOperation=new FormData();\r\n\t\tfdlOperation.left = new FormAttachment(0, 0);\r\n\t\tfdlOperation.right= new FormAttachment(middle, -margin);\r\n\t\tfdlOperation.top  = new FormAttachment(wNrRowsInBloc, margin);\r\n\t\twlOperation.setLayoutData(fdlOperation);\r\n\t\t\r\n\t\twOperation=new CCombo(wGeneralComp, SWT.BORDER | SWT.READ_ONLY);\r\n \t\tprops.setLook(wOperation);\r\n \t\twOperation.addModifyListener(lsMod);\r\n\t\tfdOperation=new FormData();\r\n\t\tfdOperation.left = new FormAttachment(middle, 0);\r\n\t\tfdOperation.top  = new FormAttachment(wNrRowsInBloc, margin);\r\n\t\tfdOperation.right= new FormAttachment(100, -margin);\r\n\t\twOperation.setLayoutData(fdOperation);\r\n\t\twOperation.setItems(JsonOutputMeta.operationTypeDesc);\r\n\t\twOperation.addSelectionListener(new SelectionAdapter()\r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e)\r\n\t\t\t{\r\n\t\t\t\tupdateOperation();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t});\r\n       \r\n\r\n    \t\r\n\t\t// Connection grouping?\r\n\t\t// ////////////////////////\r\n\t\t// START OF Settings GROUP\r\n\t\t// \r\n\r\n\t\twSettings = new Group(wGeneralComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wSettings);\r\n\t\twSettings.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.Group.Settings.Label\"));\r\n\t\t\r\n\t\tFormLayout groupFileLayout = new FormLayout();\r\n\t\tgroupFileLayout.marginWidth = 10;\r\n\t\tgroupFileLayout.marginHeight = 10;\r\n\t\twSettings.setLayout(groupFileLayout);\r\n\t\t\r\n\r\n        wlBlocName=new Label(wSettings, SWT.RIGHT);\r\n        wlBlocName.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.BlocName.Label\"));\r\n        props.setLook(wlBlocName);\r\n        fdlBlocName=new FormData();\r\n        fdlBlocName.left = new FormAttachment(0, 0);\r\n        fdlBlocName.top  = new FormAttachment(wOperation, margin);\r\n        fdlBlocName.right= new FormAttachment(middle, -margin);\r\n        wlBlocName.setLayoutData(fdlBlocName);\r\n        wBlocName=new TextVar(transMeta, wSettings, SWT.BORDER | SWT.READ_ONLY);\r\n        wBlocName.setEditable(true);\r\n        props.setLook(wBlocName);\r\n        wBlocName.addModifyListener(lsMod);\r\n        fdBlocName=new FormData();\r\n        fdBlocName.left = new FormAttachment(middle, 0);\r\n        fdBlocName.top  = new FormAttachment(wOperation, margin);\r\n        fdBlocName.right= new FormAttachment(100, 0);\r\n        wBlocName.setLayoutData(fdBlocName);\r\n        \r\n        wlNrRowsInBloc=new Label(wSettings, SWT.RIGHT);\r\n        wlNrRowsInBloc.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.NrRowsInBloc.Label\"));\r\n        props.setLook(wlNrRowsInBloc);\r\n        fdlNrRowsInBloc=new FormData();\r\n        fdlNrRowsInBloc.left = new FormAttachment(0, 0);\r\n        fdlNrRowsInBloc.top  = new FormAttachment(wBlocName, margin);\r\n        fdlNrRowsInBloc.right= new FormAttachment(middle, -margin);\r\n        wlNrRowsInBloc.setLayoutData(fdlNrRowsInBloc);\r\n        wNrRowsInBloc=new TextVar(transMeta, wSettings, SWT.BORDER | SWT.READ_ONLY);\r\n        wNrRowsInBloc.setToolTipText(BaseMessages.getString(PKG, \"JsonOutputDialog.NrRowsInBloc.ToolTip\"));\r\n        wNrRowsInBloc.setEditable(true);\r\n        props.setLook(wNrRowsInBloc);\r\n        wNrRowsInBloc.addModifyListener(lsMod);\r\n        fdNrRowsInBloc=new FormData();\r\n        fdNrRowsInBloc.left = new FormAttachment(middle, 0);\r\n        fdNrRowsInBloc.top  = new FormAttachment(wBlocName, margin);\r\n        fdNrRowsInBloc.right= new FormAttachment(100, 0);\r\n        wNrRowsInBloc.setLayoutData(fdNrRowsInBloc);\r\n        \r\n        wlOutputValue=new Label(wSettings, SWT.RIGHT);\r\n        wlOutputValue.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.OutputValue.Label\"));\r\n        props.setLook(wlOutputValue);\r\n        fdlOutputValue=new FormData();\r\n        fdlOutputValue.left = new FormAttachment(0, 0);\r\n        fdlOutputValue.top  = new FormAttachment(wNrRowsInBloc, margin);\r\n        fdlOutputValue.right= new FormAttachment(middle, -margin);\r\n        wlOutputValue.setLayoutData(fdlOutputValue);\r\n        wOutputValue=new TextVar(transMeta, wSettings, SWT.BORDER | SWT.READ_ONLY);\r\n        wOutputValue.setEditable(true);\r\n        props.setLook(wOutputValue);\r\n        wOutputValue.addModifyListener(lsMod);\r\n        fdOutputValue=new FormData();\r\n        fdOutputValue.left = new FormAttachment(middle, 0);\r\n        fdOutputValue.top  = new FormAttachment(wNrRowsInBloc, margin);\r\n        fdOutputValue.right= new FormAttachment(100, 0);\r\n        wOutputValue.setLayoutData(fdOutputValue);\r\n\r\n\t\r\n\t\tfdSettings = new FormData();\r\n\t\tfdSettings.left = new FormAttachment(0, margin);\r\n\t\tfdSettings.top = new FormAttachment(wOperation, 2*margin);\r\n\t\tfdSettings.right = new FormAttachment(100, -margin);\r\n\t\twSettings.setLayoutData(fdSettings);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF Settings GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\r\n    \t\r\n\t\t// Connection grouping?\r\n\t\t// ////////////////////////\r\n\t\t// START OF FileName GROUP\r\n\t\t// \r\n\r\n\t\twFileName = new Group(wGeneralComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wFileName);\r\n\t\twFileName.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.Group.File.Label\"));\r\n\t\t\r\n\t\tFormLayout groupfilenameayout = new FormLayout();\r\n\t\tgroupfilenameayout.marginWidth = 10;\r\n\t\tgroupfilenameayout.marginHeight = 10;\r\n\t\twFileName.setLayout(groupfilenameayout);\r\n\t\t\r\n\t\t\r\n\t\t// Filename line\r\n\t\twlFilename=new Label(wFileName, SWT.RIGHT);\r\n\t\twlFilename.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.Filename.Label\"));\r\n \t\tprops.setLook(wlFilename);\r\n\t\tfdlFilename=new FormData();\r\n\t\tfdlFilename.left = new FormAttachment(0, 0);\r\n\t\tfdlFilename.top  = new FormAttachment(wSettings, margin);\r\n\t\tfdlFilename.right= new FormAttachment(middle, -margin);\r\n\t\twlFilename.setLayoutData(fdlFilename);\r\n\r\n\t\twbFilename=new Button(wFileName, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbFilename);\r\n\t\twbFilename.setText(BaseMessages.getString(PKG, \"System.Button.Browse\"));\r\n\t\tfdbFilename=new FormData();\r\n\t\tfdbFilename.right= new FormAttachment(100, 0);\r\n\t\tfdbFilename.top  = new FormAttachment(wSettings, 0);\r\n\t\twbFilename.setLayoutData(fdbFilename);\r\n\t\twbFilename.addSelectionListener\r\n\t\t(\r\n\t\t\tnew SelectionAdapter()\r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.SAVE);\r\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.js\", \"*.JS\", \"*\"});\r\n\t\t\t\t\tif (wFilename.getText()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdialog.setFileName(transMeta.environmentSubstitute(wFilename.getText()));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdialog.setFilterNames(new String[] {BaseMessages.getString(PKG, \"System.FileType.TextFiles\"), BaseMessages.getString(PKG, \"System.FileType.CSVFiles\"), BaseMessages.getString(PKG, \"System.FileType.AllFiles\")});\r\n\t\t\t\t\tif (dialog.open()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tString extension = wExtension.getText();\r\n\t\t\t\t\t\tif ( extension != null && dialog.getFileName() != null &&\r\n\t\t\t\t\t\t\t\tdialog.getFileName().endsWith(\".\" + extension) )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// The extension is filled in and matches the end \r\n\t\t\t\t\t\t\t// of the selected file => Strip off the extension.\r\n\t\t\t\t\t\t\tString fileName = dialog.getFileName();\r\n\t\t\t\t\t\t    wFilename.setText(dialog.getFilterPath()+System.getProperty(\"file.separator\")+\r\n\t\t\t\t\t\t    \t\t          fileName.substring(0, fileName.length() - (extension.length()+1)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t    wFilename.setText(dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\twFilename=new TextVar(transMeta, wFileName, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wFilename);\r\n\t\twFilename.addModifyListener(lsMod);\r\n\t\tfdFilename=new FormData();\r\n\t\tfdFilename.left = new FormAttachment(middle, 0);\r\n\t\tfdFilename.top  = new FormAttachment(wOutputValue, margin);\r\n\t\tfdFilename.right= new FormAttachment(wbFilename, -margin);\r\n\t\twFilename.setLayoutData(fdFilename);\r\n\t\t\r\n\t\t\r\n\t\t// Append to end of file?\r\n\t\twlAppend=new Label(wFileName, SWT.RIGHT);\r\n\t\twlAppend.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.Append.Label\"));\r\n \t\tprops.setLook(wlAppend);\r\n\t\tfdlAppend=new FormData();\r\n\t\tfdlAppend.left = new FormAttachment(0, 0);\r\n\t\tfdlAppend.top  = new FormAttachment(wFilename, margin);\r\n\t\tfdlAppend.right= new FormAttachment(middle, -margin);\r\n\t\twlAppend.setLayoutData(fdlAppend);\r\n\t\twAppend=new Button(wFileName, SWT.CHECK);\r\n\t\twAppend.setToolTipText(BaseMessages.getString(PKG, \"JsonOutputDialog.Append.Tooltip\"));\r\n \t\tprops.setLook(wAppend);\r\n\t\tfdAppend=new FormData();\r\n\t\tfdAppend.left = new FormAttachment(middle, 0);\r\n\t\tfdAppend.top  = new FormAttachment(wFilename, margin);\r\n\t\tfdAppend.right= new FormAttachment(100, 0);\r\n\t\twAppend.setLayoutData(fdAppend);\r\n\t\twAppend.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t// Create Parent Folder\r\n\t\twlCreateParentFolder=new Label(wFileName, SWT.RIGHT);\r\n\t\twlCreateParentFolder.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.CreateParentFolder.Label\"));\r\n \t\tprops.setLook(wlCreateParentFolder);\r\n\t\tfdlCreateParentFolder=new FormData();\r\n\t\tfdlCreateParentFolder.left = new FormAttachment(0, 0);\r\n\t\tfdlCreateParentFolder.top  = new FormAttachment(wAppend, margin);\r\n\t\tfdlCreateParentFolder.right= new FormAttachment(middle, -margin);\r\n\t\twlCreateParentFolder.setLayoutData(fdlCreateParentFolder);\r\n\t\twCreateParentFolder=new Button(wFileName, SWT.CHECK );\r\n\t\twCreateParentFolder.setToolTipText(BaseMessages.getString(PKG, \"JsonOutputDialog.CreateParentFolder.Tooltip\"));\r\n \t\tprops.setLook(wCreateParentFolder);\r\n\t\tfdCreateParentFolder=new FormData();\r\n\t\tfdCreateParentFolder.left = new FormAttachment(middle, 0);\r\n\t\tfdCreateParentFolder.top  = new FormAttachment(wAppend, margin);\r\n\t\tfdCreateParentFolder.right= new FormAttachment(100, 0);\r\n\t\twCreateParentFolder.setLayoutData(fdCreateParentFolder);\r\n\t\twCreateParentFolder.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\r\n\t\t// Open new File at Init\r\n\t\twlDoNotOpenNewFileInit=new Label(wFileName, SWT.RIGHT);\r\n\t\twlDoNotOpenNewFileInit.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.DoNotOpenNewFileInit.Label\"));\r\n \t\tprops.setLook(wlDoNotOpenNewFileInit);\r\n\t\tfdlDoNotOpenNewFileInit=new FormData();\r\n\t\tfdlDoNotOpenNewFileInit.left = new FormAttachment(0, 0);\r\n\t\tfdlDoNotOpenNewFileInit.top  = new FormAttachment(wCreateParentFolder, margin);\r\n\t\tfdlDoNotOpenNewFileInit.right= new FormAttachment(middle, -margin);\r\n\t\twlDoNotOpenNewFileInit.setLayoutData(fdlDoNotOpenNewFileInit);\r\n\t\twDoNotOpenNewFileInit=new Button(wFileName, SWT.CHECK );\r\n\t\twDoNotOpenNewFileInit.setToolTipText(BaseMessages.getString(PKG, \"JsonOutputDialog.DoNotOpenNewFileInit.Tooltip\"));\r\n \t\tprops.setLook(wDoNotOpenNewFileInit);\r\n\t\tfdDoNotOpenNewFileInit=new FormData();\r\n\t\tfdDoNotOpenNewFileInit.left = new FormAttachment(middle, 0);\r\n\t\tfdDoNotOpenNewFileInit.top  = new FormAttachment(wCreateParentFolder, margin);\r\n\t\tfdDoNotOpenNewFileInit.right= new FormAttachment(100, 0);\r\n\t\twDoNotOpenNewFileInit.setLayoutData(fdDoNotOpenNewFileInit);\r\n\t\twDoNotOpenNewFileInit.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t\r\n\t\t// Extension line\r\n\t\twlExtension=new Label(wFileName, SWT.RIGHT);\r\n\t\twlExtension.setText(BaseMessages.getString(PKG, \"System.Label.Extension\"));\r\n \t\tprops.setLook(wlExtension);\r\n\t\tfdlExtension=new FormData();\r\n\t\tfdlExtension.left = new FormAttachment(0, 0);\r\n\t\tfdlExtension.top  = new FormAttachment(wDoNotOpenNewFileInit, margin);\r\n\t\tfdlExtension.right= new FormAttachment(middle, -margin);\r\n\t\twlExtension.setLayoutData(fdlExtension);\r\n\t\t\r\n\t\twExtension=new TextVar(transMeta, wFileName, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wExtension);\r\n \t\twExtension.addModifyListener(lsMod);\r\n \t\tfdExtension=new FormData();\r\n\t\tfdExtension.left = new FormAttachment(middle, 0);\r\n\t\tfdExtension.top  = new FormAttachment(wDoNotOpenNewFileInit, margin);\r\n\t\tfdExtension.right= new FormAttachment(100, -margin);\r\n\t\twExtension.setLayoutData(fdExtension);\r\n\t\t\r\n\r\n        wlEncoding=new Label(wFileName, SWT.RIGHT);\r\n        wlEncoding.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.Encoding.Label\"));\r\n        props.setLook(wlEncoding);\r\n        fdlEncoding=new FormData();\r\n        fdlEncoding.left = new FormAttachment(0, 0);\r\n        fdlEncoding.top  = new FormAttachment(wExtension, margin);\r\n        fdlEncoding.right= new FormAttachment(middle, -margin);\r\n        wlEncoding.setLayoutData(fdlEncoding);\r\n        wEncoding=new ComboVar(transMeta, wFileName, SWT.BORDER | SWT.READ_ONLY);\r\n        wEncoding.setEditable(true);\r\n        props.setLook(wEncoding);\r\n        wEncoding.addModifyListener(lsMod);\r\n        fdEncoding=new FormData();\r\n        fdEncoding.left = new FormAttachment(middle, 0);\r\n        fdEncoding.top  = new FormAttachment(wExtension, margin);\r\n        fdEncoding.right= new FormAttachment(100, 0);\r\n        wEncoding.setLayoutData(fdEncoding);\r\n        wEncoding.addFocusListener(new FocusListener()\r\n            {\r\n                public void focusLost(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                }\r\n            \r\n                public void focusGained(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                    Cursor busy = new Cursor(shell.getDisplay(), SWT.CURSOR_WAIT);\r\n                    shell.setCursor(busy);\r\n                    setEncodings();\r\n                    shell.setCursor(null);\r\n                    busy.dispose();\r\n                }\r\n            }\r\n        );\r\n\r\n    // Output to servlet (browser, ws)\r\n    //\r\n    wlServletOutput=new Label(wFileName, SWT.RIGHT);\r\n    wlServletOutput.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.ServletOutput.Label\"));\r\n    props.setLook(wlServletOutput);\r\n    fdlServletOutput=new FormData();\r\n    fdlServletOutput.left = new FormAttachment(0, 0);\r\n    fdlServletOutput.top  = new FormAttachment(wEncoding, margin);\r\n    fdlServletOutput.right= new FormAttachment(middle, -margin);\r\n    wlServletOutput.setLayoutData(fdlServletOutput);\r\n    wServletOutput=new Button(wFileName, SWT.CHECK);\r\n    wServletOutput.setToolTipText(BaseMessages.getString(PKG, \"JsonOutputDialog.ServletOutput.Tooltip\"));\r\n    props.setLook(wServletOutput);\r\n    fdServletOutput=new FormData();\r\n    fdServletOutput.left = new FormAttachment(middle, 0);\r\n    fdServletOutput.top  = new FormAttachment(wEncoding, margin);\r\n    fdServletOutput.right= new FormAttachment(100, 0);\r\n    wServletOutput.setLayoutData(fdServletOutput);\r\n    wServletOutput.addSelectionListener(new SelectionAdapter() \r\n      {\r\n        public void widgetSelected(SelectionEvent e) \r\n        {\r\n          input.setChanged();\r\n          setFlagsServletOption();\r\n        }\r\n      }\r\n    );\r\n\r\n        \r\n\t\t// Create multi-part file?\r\n\t\twlAddDate=new Label(wFileName, SWT.RIGHT);\r\n\t\twlAddDate.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.AddDate.Label\"));\r\n \t\tprops.setLook(wlAddDate);\r\n\t\tfdlAddDate=new FormData();\r\n\t\tfdlAddDate.left = new FormAttachment(0, 0);\r\n\t\tfdlAddDate.top  = new FormAttachment(wServletOutput, margin);\r\n\t\tfdlAddDate.right= new FormAttachment(middle, -margin);\r\n\t\twlAddDate.setLayoutData(fdlAddDate);\r\n\t\twAddDate=new Button(wFileName, SWT.CHECK);\r\n \t\tprops.setLook(wAddDate);\r\n\t\tfdAddDate=new FormData();\r\n\t\tfdAddDate.left = new FormAttachment(middle, 0);\r\n\t\tfdAddDate.top  = new FormAttachment(wServletOutput, margin);\r\n\t\tfdAddDate.right= new FormAttachment(100, 0);\r\n\t\twAddDate.setLayoutData(fdAddDate);\r\n\t\twAddDate.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t// Create multi-part file?\r\n\t\twlAddTime=new Label(wFileName, SWT.RIGHT);\r\n\t\twlAddTime.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.AddTime.Label\"));\r\n \t\tprops.setLook(wlAddTime);\r\n\t\tfdlAddTime=new FormData();\r\n\t\tfdlAddTime.left = new FormAttachment(0, 0);\r\n\t\tfdlAddTime.top  = new FormAttachment(wAddDate, margin);\r\n\t\tfdlAddTime.right= new FormAttachment(middle, -margin);\r\n\t\twlAddTime.setLayoutData(fdlAddTime);\r\n\t\twAddTime=new Button(wFileName, SWT.CHECK);\r\n \t\tprops.setLook(wAddTime);\r\n\t\tfdAddTime=new FormData();\r\n\t\tfdAddTime.left = new FormAttachment(middle, 0);\r\n\t\tfdAddTime.top  = new FormAttachment(wAddDate, margin);\r\n\t\tfdAddTime.right= new FormAttachment(100, 0);\r\n\t\twAddTime.setLayoutData(fdAddTime);\r\n\t\twAddTime.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\r\n\t\t\r\n\r\n\t\twbShowFiles=new Button(wFileName, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbShowFiles);\r\n\t\twbShowFiles.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.ShowFiles.Button\"));\r\n\t\tfdbShowFiles=new FormData();\r\n\t\tfdbShowFiles.left = new FormAttachment(middle, 0);\r\n\t\tfdbShowFiles.top  = new FormAttachment(wAddTime, margin*2);\r\n\t\twbShowFiles.setLayoutData(fdbShowFiles);\r\n\t\twbShowFiles.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tJsonOutputMeta tfoi = new JsonOutputMeta();\r\n\t\t\t\t\tgetInfo(tfoi);\r\n\t\t\t\t\tString files[] = tfoi.getFiles(transMeta.environmentSubstitute(wFilename.getText()));\r\n\t\t\t\t\tif (files!=null && files.length>0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, files, \r\n\t\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"JsonOutputDialog.SelectOutputFiles.DialogTitle\"), \r\n\t\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"JsonOutputDialog.SelectOutputFiles.DialogMessage\"));\r\n\t\t\t\t\t\tesd.setViewOnly();\r\n\t\t\t\t\t\tesd.open();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\r\n\t\t\t\t\t\tmb.setMessage(BaseMessages.getString(PKG, \"JsonOutputDialog.NoFilesFound.DialogMessage\"));\r\n\t\t\t\t\t\tmb.setText(BaseMessages.getString(PKG, \"System.DialogTitle.Error\"));\r\n\t\t\t\t\t\tmb.open(); \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\r\n\t\t\r\n\t\t// Add File to the result files name\r\n\t\twlAddToResult=new Label(wFileName, SWT.RIGHT);\r\n\t\twlAddToResult.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.AddFileToResult.Label\"));\r\n\t\tprops.setLook(wlAddToResult);\r\n\t\tfdlAddToResult=new FormData();\r\n\t\tfdlAddToResult.left  = new FormAttachment(0, 0);\r\n\t\tfdlAddToResult.top   = new FormAttachment(wbShowFiles, margin);\r\n\t\tfdlAddToResult.right = new FormAttachment(middle, -margin);\r\n\t\twlAddToResult.setLayoutData(fdlAddToResult);\r\n\t\twAddToResult=new Button(wFileName, SWT.CHECK);\r\n\t\twAddToResult.setToolTipText(BaseMessages.getString(PKG, \"JsonOutputDialog.AddFileToResult.Tooltip\"));\r\n \t\tprops.setLook(wAddToResult);\r\n\t\tfdAddToResult=new FormData();\r\n\t\tfdAddToResult.left  = new FormAttachment(middle, 0);\r\n\t\tfdAddToResult.top   = new FormAttachment(wbShowFiles, margin);\r\n\t\tfdAddToResult.right = new FormAttachment(100, 0);\r\n\t\twAddToResult.setLayoutData(fdAddToResult);\r\n\t\tSelectionAdapter lsSelR = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent arg0)\r\n            {\r\n                input.setChanged();\r\n            }\r\n        };\r\n\t\twAddToResult.addSelectionListener(lsSelR);\r\n\r\n\r\n\t\t\r\n\t\t\r\n\t\tfdFileName = new FormData();\r\n\t\tfdFileName.left = new FormAttachment(0, margin);\r\n\t\tfdFileName.top = new FormAttachment(wSettings, 2*margin);\r\n\t\tfdFileName.right = new FormAttachment(100, -margin);\r\n\t\twFileName.setLayoutData(fdFileName);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF FileName GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\r\n        \r\n        \r\n\r\n        fdGeneralComp = new FormData();\r\n        fdGeneralComp.left  = new FormAttachment(0, 0);\r\n        fdGeneralComp.top   = new FormAttachment(wStepname, margin);\r\n        fdGeneralComp.right = new FormAttachment(100, 0);\r\n        fdGeneralComp.bottom= new FormAttachment(100, 0);\r\n        wGeneralComp.setLayoutData(fdGeneralComp);\r\n\r\n        wGeneralComp.layout();\r\n        wGeneralTab.setControl(wGeneralComp);\r\n        \r\n        /////////////////////////////////////////////////////////////\r\n        /// END OF General TAB\r\n        /////////////////////////////////////////////////////////////\r\n\r\n        // Fields tab...\r\n        //\r\n        wFieldsTab = new CTabItem(wTabFolder, SWT.NONE);\r\n        wFieldsTab.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.FieldsTab.TabTitle\"));\r\n        \r\n        FormLayout fieldsLayout = new FormLayout ();\r\n        fieldsLayout.marginWidth  = Const.FORM_MARGIN;\r\n        fieldsLayout.marginHeight = Const.FORM_MARGIN;\r\n        \r\n        Composite wFieldsComp = new Composite(wTabFolder, SWT.NONE);\r\n        wFieldsComp.setLayout(fieldsLayout);\r\n        props.setLook(wFieldsComp);\r\n\r\n        wGet=new Button(wFieldsComp, SWT.PUSH);\r\n        wGet.setText(BaseMessages.getString(PKG, \"JsonOutputDialog.Get.Button\"));\r\n        wGet.setToolTipText(BaseMessages.getString(PKG, \"JsonOutputDialog.Get.Tooltip\"));\r\n\r\n\r\n        setButtonPositions(new Button[] { wGet}, margin, null);\r\n\r\n        final int FieldsRows=input.getOutputFields().length;\r\n        \r\n        colinf=new ColumnInfo[]\r\n        {\r\n            new ColumnInfo(BaseMessages.getString(PKG, \"JsonOutputDialog.Fieldname.Column\"),   ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"\" }, false),\r\n            new ColumnInfo(BaseMessages.getString(PKG, \"JsonOutputDialog.ElementName.Column\"), ColumnInfo.COLUMN_TYPE_TEXT,   false),\r\n         };\r\n        colinf[1].setUsingVariables(true);\r\n        wFields=new TableView(transMeta, wFieldsComp, \r\n                              SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, \r\n                              colinf, \r\n                              FieldsRows,  \r\n                              lsMod,\r\n                              props\r\n                              );\r\n\r\n        fdFields=new FormData();\r\n        fdFields.left  = new FormAttachment(0, 0);\r\n        fdFields.top   = new FormAttachment(0, 0);\r\n        fdFields.right = new FormAttachment(100, 0);\r\n        fdFields.bottom= new FormAttachment(wGet, -margin);\r\n        wFields.setLayoutData(fdFields);\r\n        \r\n\t\t  // \r\n        // Search the fields in the background\r\n\t\t\r\n        final Runnable runnable = new Runnable()\r\n        {\r\n            public void run()\r\n            {\r\n                StepMeta stepMeta = transMeta.findStep(stepname);\r\n                if (stepMeta!=null)\r\n                {\r\n                    try\r\n                    {\r\n                    \tRowMetaInterface row = transMeta.getPrevStepFields(stepMeta);\r\n                       \r\n                        // Remember these fields...\r\n                        for (int i=0;i<row.size();i++)\r\n                        {\r\n                            inputFields.put(row.getValueMeta(i).getName(), Integer.valueOf(i));\r\n                        }\r\n                        setComboBoxes();\r\n                    }\r\n                    catch(KettleException e)\r\n                    {\r\n                    \tlogError( BaseMessages.getString(PKG, \"System.Dialog.GetFieldsFailed.Message\"));\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        new Thread(runnable).start();\r\n\r\n        fdFieldsComp=new FormData();\r\n        fdFieldsComp.left  = new FormAttachment(0, 0);\r\n        fdFieldsComp.top   = new FormAttachment(0, 0);\r\n        fdFieldsComp.right = new FormAttachment(100, 0);\r\n        fdFieldsComp.bottom= new FormAttachment(100, 0);\r\n        wFieldsComp.setLayoutData(fdFieldsComp);\r\n        \r\n        wFieldsComp.layout();\r\n        wFieldsTab.setControl(wFieldsComp);\r\n        \r\n        fdTabFolder = new FormData();\r\n        fdTabFolder.left  = new FormAttachment(0, 0);\r\n        fdTabFolder.top   = new FormAttachment(wStepname, margin);\r\n        fdTabFolder.right = new FormAttachment(100, 0);\r\n        fdTabFolder.bottom= new FormAttachment(100, -50);\r\n        wTabFolder.setLayoutData(fdTabFolder);\r\n        \r\n        wOK=new Button(shell, SWT.PUSH);\r\n        wOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\r\n        \r\n        wCancel=new Button(shell, SWT.PUSH);\r\n        wCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\"));\r\n\r\n        setButtonPositions(new Button[] { wOK, wCancel }, margin, wTabFolder);\r\n\r\n        // Add listeners\r\n        lsOK       = new Listener() { public void handleEvent(Event e) { ok();       } };\r\n        lsGet      = new Listener() { public void handleEvent(Event e) { get();      } };\r\n        lsCancel   = new Listener() { public void handleEvent(Event e) { cancel();   } };\r\n        \r\n        wOK.addListener    (SWT.Selection, lsOK    );\r\n        wGet.addListener   (SWT.Selection, lsGet   );\r\n        wCancel.addListener(SWT.Selection, lsCancel);\r\n        \r\n        lsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n        \r\n        wStepname.addSelectionListener( lsDef );\r\n        // Detect X or ALT-F4 or something that kills this window...\r\n        shell.addShellListener( new ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\r\n\r\n        lsResize = new Listener() \r\n        {\r\n            public void handleEvent(Event event) \r\n            {\r\n                Point size = shell.getSize();\r\n                wFields.setSize(size.x-10, size.y-50);\r\n                wFields.table.setSize(size.x-10, size.y-50);\r\n                wFields.redraw();\r\n            }\r\n        };\r\n        shell.addListener(SWT.Resize, lsResize);\r\n\r\n        wTabFolder.setSelection(0);\r\n        \r\n        // Set the shell size, based upon previous time...\r\n        setSize();\r\n        \r\n        getData();\r\n        updateOperation();\r\n        input.setChanged(changed);\r\n        \r\n        shell.open();\r\n        while (!shell.isDisposed())\r\n        {\r\n                if (!display.readAndDispatch()) display.sleep();\r\n        }\r\n        return stepname;\r\n    }","commit_id":"6616135e75db58916e0f787593602e3aa6f6865a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getInfo(JsonOutputMeta tfoi)\r\n    {\r\n    \ttfoi.setJsonBloc(wBlocName.getText() );\r\n    \ttfoi.setNrRowsInBloc(wNrRowsInBloc.getText() );\r\n        tfoi.setEncoding( wEncoding.getText() );\r\n        tfoi.setOutputValue(wOutputValue.getText() );\r\n        tfoi.setOperationType(JsonOutputMeta.getOperationTypeByDesc(wOperation.getText()));\r\n        tfoi.setCreateParentFolder(wCreateParentFolder.getSelection() );\r\n        tfoi.setFileName( wFilename.getText() );\r\n        tfoi.setExtension(wExtension.getText() );\r\n\t\ttfoi.setFileAppended(wAppend.getSelection() );;\r\n\t\ttfoi.setDateInFilename( wAddDate.getSelection() );\r\n\t\ttfoi.setTimeInFilename( wAddTime.getSelection() );\r\n\t\t\r\n\t\ttfoi.setEncoding( wEncoding.getText() );\r\n\t\ttfoi.setAddToResult( wAddToResult.getSelection() );\r\n\t\ttfoi.setDoNotOpenNewFileInit( wDoNotOpenNewFileInit.getSelection() );\r\n\t\t\r\n        int nrfields = wFields.nrNonEmpty();\r\n\r\n        tfoi.allocate(nrfields);\r\n        \r\n        for (int i=0;i<nrfields;i++)\r\n        {\r\n            JsonOutputField field = new JsonOutputField();\r\n            \r\n            TableItem item = wFields.getNonEmpty(i);\r\n            field.setFieldName( item.getText(1) );\r\n            field.setElementName( item.getText(2) );\r\n            tfoi.getOutputFields()[i]  = field;\r\n        }\r\n    }","id":28108,"modified_method":"private void getInfo(JsonOutputMeta jsometa) {\r\n      jsometa.setJsonBloc(wBlocName.getText());\r\n      jsometa.setNrRowsInBloc(wNrRowsInBloc.getText());\r\n      jsometa.setEncoding(wEncoding.getText());\r\n      jsometa.setOutputValue(wOutputValue.getText());\r\n      jsometa.setOperationType(JsonOutputMeta.getOperationTypeByDesc(wOperation.getText()));\r\n      jsometa.setCreateParentFolder(wCreateParentFolder.getSelection());\r\n      jsometa.setFileName(wFilename.getText());\r\n      jsometa.setExtension(wExtension.getText());\r\n      jsometa.setServletOutput(wServletOutput.getSelection());\r\n      jsometa.setFileAppended(wAppend.getSelection());\r\n\r\n      jsometa.setDateInFilename(wAddDate.getSelection());\r\n      jsometa.setTimeInFilename(wAddTime.getSelection());\r\n  \r\n      jsometa.setEncoding(wEncoding.getText());\r\n      jsometa.setAddToResult(wAddToResult.getSelection());\r\n      jsometa.setDoNotOpenNewFileInit(wDoNotOpenNewFileInit.getSelection());\r\n  \r\n      int nrfields = wFields.nrNonEmpty();\r\n  \r\n      jsometa.allocate(nrfields);\r\n  \r\n      for (int i = 0; i < nrfields; i++) {\r\n        JsonOutputField field = new JsonOutputField();\r\n  \r\n        TableItem item = wFields.getNonEmpty(i);\r\n        field.setFieldName(item.getText(1));\r\n        field.setElementName(item.getText(2));\r\n        jsometa.getOutputFields()[i] = field;\r\n      }\r\n    }","commit_id":"6616135e75db58916e0f787593602e3aa6f6865a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void updateOperation()\r\n    {\r\n    \tboolean activeFile= JsonOutputMeta.getOperationTypeByDesc(wOperation.getText())!=JsonOutputMeta.OPERATION_TYPE_OUTPUT_VALUE;\r\n    \twlFilename.setEnabled(activeFile);\r\n    \twFilename.setEnabled(activeFile);\r\n    \twbFilename.setEnabled(activeFile);\r\n    \twlExtension.setEnabled(activeFile);\r\n    \twExtension.setEnabled(activeFile);\r\n    \twlEncoding.setEnabled(activeFile);\r\n    \twEncoding.setEnabled(activeFile);\r\n    \twlAppend.setEnabled(activeFile);\r\n    \twAppend.setEnabled(activeFile);\r\n    \twlCreateParentFolder.setEnabled(activeFile);\r\n    \twCreateParentFolder.setEnabled(activeFile);\r\n    \twlDoNotOpenNewFileInit.setEnabled(activeFile);\r\n    \twDoNotOpenNewFileInit.setEnabled(activeFile);\r\n    \twlAddDate.setEnabled(activeFile);\r\n    \twAddDate.setEnabled(activeFile);\r\n    \twlAddTime.setEnabled(activeFile);\r\n    \twAddTime.setEnabled(activeFile);\r\n    \twlAddToResult.setEnabled(activeFile);\r\n    \twAddToResult.setEnabled(activeFile);\r\n    \twbShowFiles.setEnabled(activeFile);\r\n\r\n    \tboolean activeOutputValue= JsonOutputMeta.getOperationTypeByDesc(wOperation.getText())!=JsonOutputMeta.OPERATION_TYPE_WRITE_TO_FILE;\r\n    \t\r\n    \twlOutputValue.setEnabled(activeOutputValue);\r\n    \twOutputValue.setEnabled(activeOutputValue);\r\n    }","id":28109,"modified_method":"private void updateOperation()\r\n    {\r\n      int opType = JsonOutputMeta.getOperationTypeByDesc(wOperation.getText());\r\n    \tboolean activeFile= opType!=JsonOutputMeta.OPERATION_TYPE_OUTPUT_VALUE;\r\n    \t\r\n    \twlFilename.setEnabled(activeFile);\r\n    \twFilename.setEnabled(activeFile);\r\n    \twbFilename.setEnabled(activeFile);\r\n    \twlExtension.setEnabled(activeFile);\r\n    \twExtension.setEnabled(activeFile);\r\n    \twlEncoding.setEnabled(activeFile);\r\n    \twEncoding.setEnabled(activeFile);\r\n    \twlAppend.setEnabled(activeFile);\r\n    \twAppend.setEnabled(activeFile);\r\n    \twlCreateParentFolder.setEnabled(activeFile);\r\n    \twCreateParentFolder.setEnabled(activeFile);\r\n    \twlDoNotOpenNewFileInit.setEnabled(activeFile);\r\n    \twDoNotOpenNewFileInit.setEnabled(activeFile);\r\n    \twlAddDate.setEnabled(activeFile);\r\n    \twAddDate.setEnabled(activeFile);\r\n    \twlAddTime.setEnabled(activeFile);\r\n    \twAddTime.setEnabled(activeFile);\r\n    \twlAddToResult.setEnabled(activeFile);\r\n    \twAddToResult.setEnabled(activeFile);\r\n    \twbShowFiles.setEnabled(activeFile);\r\n    \t\r\n    \twlServletOutput.setEnabled(opType==JsonOutputMeta.OPERATION_TYPE_WRITE_TO_FILE || opType==JsonOutputMeta.OPERATION_TYPE_BOTH);\r\n      wServletOutput.setEnabled(opType==JsonOutputMeta.OPERATION_TYPE_WRITE_TO_FILE || opType==JsonOutputMeta.OPERATION_TYPE_BOTH);\r\n    \t\r\n    \tboolean activeOutputValue= JsonOutputMeta.getOperationTypeByDesc(wOperation.getText())!=JsonOutputMeta.OPERATION_TYPE_WRITE_TO_FILE;\r\n    \t\r\n    \twlOutputValue.setEnabled(activeOutputValue);\r\n    \twOutputValue.setEnabled(activeOutputValue);\r\n    \t\r\n    \tsetFlagsServletOption();\r\n    }","commit_id":"6616135e75db58916e0f787593602e3aa6f6865a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\r\n     * Copy information from the meta-data input to the dialog fields.\r\n     */ \r\n    public void getData()\r\n    {\r\n        if (input.getJsonBloc()      != null) wBlocName.setText(input.getJsonBloc());\r\n        if (input.getNrRowsInBloc()      != null) wNrRowsInBloc.setText(input.getNrRowsInBloc());\r\n        if (input.getEncoding()      != null) wEncoding.setText(input.getEncoding());\r\n        if (input.getOutputValue()     != null) wOutputValue.setText(input.getOutputValue());\r\n\t\twOperation.setText(JsonOutputMeta.getOperationTypeDesc(input.getOperationType()));\r\n\t\tif (input.getFileName()  != null) wFilename.setText(input.getFileName());\r\n\t\twCreateParentFolder.setSelection(input.isCreateParentFolder());\r\n\t\tif (input.getExtension() != null) \r\n\t\t{\r\n\t\t\twExtension.setText(input.getExtension());\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\twExtension.setText(\"js\");\r\n\t\t}\r\n\t\t\r\n\t\twAddDate.setSelection(input.isDateInFilename());\r\n\t\twAddTime.setSelection(input.isTimeInFilename());\r\n\t\twAppend.setSelection(input.isFileAppended());\r\n        \r\n        if (input.getEncoding()  !=null) wEncoding.setText(input.getEncoding());\r\n        wAddToResult.setSelection( input.AddToResult() );\r\n        wDoNotOpenNewFileInit.setSelection( input.isDoNotOpenNewFileInit() );\r\n        \r\n        \r\n        if(isDebug()) logDebug(BaseMessages.getString(PKG, \"JsonOutputDialog.Log.GettingFieldsInfo\"));\r\n        \r\n        for (int i=0;i<input.getOutputFields().length;i++)\r\n        {\r\n            JsonOutputField field = input.getOutputFields()[i];\r\n\r\n            TableItem item = wFields.table.getItem(i);\r\n            if (field.getFieldName()!=null) item.setText(1, field.getFieldName());\r\n            if (field.getElementName()!=null) item.setText(2, field.getElementName());\r\n        }\r\n        \r\n        wFields.optWidth(true);\r\n        wStepname.selectAll();\r\n    }","id":28110,"modified_method":"/**\r\n   * Copy information from the meta-data input to the dialog fields.\r\n   */\r\n  public void getData() {\r\n    wBlocName.setText(Const.NVL(input.getJsonBloc(), \"\"));\r\n    wNrRowsInBloc.setText(Const.NVL(input.getNrRowsInBloc(), \"\"));\r\n    wEncoding.setText(Const.NVL(input.getEncoding(), \"\"));\r\n    wOutputValue.setText(Const.NVL(input.getOutputValue(), \"\"));\r\n    wOperation.setText(JsonOutputMeta.getOperationTypeDesc(input.getOperationType()));\r\n    wFilename.setText(Const.NVL(input.getFileName(), \"\"));\r\n    wCreateParentFolder.setSelection(input.isCreateParentFolder());\r\n    wExtension.setText(Const.NVL(input.getExtension(), \"js\"));\r\n    wServletOutput.setSelection(input.isServletOutput());\r\n    setFlagsServletOption();\r\n\r\n    wAddDate.setSelection(input.isDateInFilename());\r\n    wAddTime.setSelection(input.isTimeInFilename());\r\n    wAppend.setSelection(input.isFileAppended());\r\n\r\n    wEncoding.setText(Const.NVL(input.getEncoding(), \"\"));\r\n    wAddToResult.setSelection(input.AddToResult());\r\n    wDoNotOpenNewFileInit.setSelection(input.isDoNotOpenNewFileInit());\r\n\r\n    if (isDebug())\r\n      logDebug(BaseMessages.getString(PKG, \"JsonOutputDialog.Log.GettingFieldsInfo\"));\r\n\r\n    for (int i = 0; i < input.getOutputFields().length; i++) {\r\n      JsonOutputField field = input.getOutputFields()[i];\r\n\r\n      TableItem item = wFields.table.getItem(i);\r\n      item.setText(1, Const.NVL(field.getFieldName(), \"\"));\r\n      item.setText(2, Const.NVL(field.getElementName(), \"\"));\r\n    }\r\n\r\n    wFields.optWidth(true);\r\n    wStepname.selectAll();\r\n  }","commit_id":"6616135e75db58916e0f787593602e3aa6f6865a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, ObjectId id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException {\r\n        try\r\n        {\r\n            outputValue     =      rep.getStepAttributeString (id_step, \"outputValue\"); //$NON-NLS-1$\r\n            jsonBloc   =      rep.getStepAttributeString (id_step, \"jsonBloc\"); //$NON-NLS-1$\r\n            nrRowsInBloc   =      rep.getStepAttributeString (id_step, \"nrRowsInBloc\"); //$NON-NLS-1$\r\n            \r\n            operationType = getOperationTypeByCode(Const.NVL(rep.getStepAttributeString(id_step, \"operation_type\"), \"\"));\r\n\t\t\tencoding        =      rep.getStepAttributeString (id_step, \"encoding\");\r\n\t\t\tAddToResult     =      rep.getStepAttributeBoolean(id_step, \"addtoresult\"); \r\n\t\t\t\r\n\t\t\tfileName        =      rep.getStepAttributeString (id_step, \"file_name\");    \r\n\t\t\textension       =      rep.getStepAttributeString (id_step, \"file_extention\");\r\n\t\t\tfileAppended          =      rep.getStepAttributeBoolean(id_step, \"file_append\");\r\n\t\t\tstepNrInFilename      =      rep.getStepAttributeBoolean(id_step, \"file_add_stepnr\");\r\n\t\t\tpartNrInFilename      =      rep.getStepAttributeBoolean(id_step, \"file_add_partnr\");\r\n\t\t\tdateInFilename        =      rep.getStepAttributeBoolean(id_step, \"file_add_date\");\r\n\t\t\ttimeInFilename        =      rep.getStepAttributeBoolean(id_step, \"file_add_time\");\r\n\t\t\tcreateparentfolder        =      rep.getStepAttributeBoolean(id_step, \"create_parent_folder\");\r\n\t\t\tDoNotOpenNewFileInit          =      rep.getStepAttributeBoolean(id_step, \"DoNotOpenNewFileInit\");\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n            int nrfields = rep.countNrStepAttributes(id_step, \"field_name\"); //$NON-NLS-1$\r\n            \r\n            allocate(nrfields);\r\n            \r\n            for (int i=0;i<nrfields;i++)\r\n            {\r\n                outputFields[i] = new JsonOutputField();\r\n\r\n                outputFields[i].setFieldName(       rep.getStepAttributeString (id_step, i, \"field_name\") ); //$NON-NLS-1$\r\n                outputFields[i].setElementName(     rep.getStepAttributeString (id_step, i, \"field_element\") ); //$NON-NLS-1$ \r\n            }       \r\n        }\r\n        catch(Exception e)\r\n        {\r\n            throw new KettleException(\"Unexpected error reading step information from the repository\", e); //$NON-NLS-1$\r\n        }\r\n    }","id":28111,"modified_method":"public void readRep(Repository rep, ObjectId id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException {\r\n        try\r\n        {\r\n            outputValue     =      rep.getStepAttributeString (id_step, \"outputValue\"); //$NON-NLS-1$\r\n            jsonBloc   =      rep.getStepAttributeString (id_step, \"jsonBloc\"); //$NON-NLS-1$\r\n            nrRowsInBloc   =      rep.getStepAttributeString (id_step, \"nrRowsInBloc\"); //$NON-NLS-1$\r\n            \r\n            operationType = getOperationTypeByCode(Const.NVL(rep.getStepAttributeString(id_step, \"operation_type\"), \"\"));\r\n\t\t\tencoding        =      rep.getStepAttributeString (id_step, \"encoding\");\r\n\t\t\tAddToResult     =      rep.getStepAttributeBoolean(id_step, \"addtoresult\"); \r\n\t\t\t\r\n\t\t\tfileName        =      rep.getStepAttributeString (id_step, \"file_name\");    \r\n\t\t\textension       =      rep.getStepAttributeString (id_step, \"file_extention\");\r\n\t\t\tfileAppended          =      rep.getStepAttributeBoolean(id_step, \"file_append\");\r\n\t\t\tstepNrInFilename      =      rep.getStepAttributeBoolean(id_step, \"file_add_stepnr\");\r\n\t\t\tpartNrInFilename      =      rep.getStepAttributeBoolean(id_step, \"file_add_partnr\");\r\n\t\t\tdateInFilename        =      rep.getStepAttributeBoolean(id_step, \"file_add_date\");\r\n\t\t\ttimeInFilename        =      rep.getStepAttributeBoolean(id_step, \"file_add_time\");\r\n\t\t\tcreateparentfolder        =      rep.getStepAttributeBoolean(id_step, \"create_parent_folder\");\r\n\t\t\tDoNotOpenNewFileInit          =      rep.getStepAttributeBoolean(id_step, \"DoNotOpenNewFileInit\");\r\n      servletOutput =      rep.getStepAttributeBoolean (id_step, \"file_servlet_output\");  \r\n\r\n\t\t\t\r\n\t\t\t\r\n            int nrfields = rep.countNrStepAttributes(id_step, \"field_name\"); //$NON-NLS-1$\r\n            \r\n            allocate(nrfields);\r\n            \r\n            for (int i=0;i<nrfields;i++)\r\n            {\r\n                outputFields[i] = new JsonOutputField();\r\n\r\n                outputFields[i].setFieldName(       rep.getStepAttributeString (id_step, i, \"field_name\") ); //$NON-NLS-1$\r\n                outputFields[i].setElementName(     rep.getStepAttributeString (id_step, i, \"field_element\") ); //$NON-NLS-1$ \r\n            }       \r\n        }\r\n        catch(Exception e)\r\n        {\r\n            throw new KettleException(\"Unexpected error reading step information from the repository\", e); //$NON-NLS-1$\r\n        }\r\n    }","commit_id":"6616135e75db58916e0f787593602e3aa6f6865a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode) throws KettleXMLException\r\n    {\r\n        try\r\n        {\r\n            outputValue      = XMLHandler.getTagValue(stepnode, \"outputValue\"); //$NON-NLS-1$\r\n            jsonBloc    = XMLHandler.getTagValue(stepnode, \"jsonBloc\"); //$NON-NLS-1$\r\n            nrRowsInBloc= XMLHandler.getTagValue(stepnode, \"nrRowsInBloc\"); //$NON-NLS-1$\r\n            operationType = getOperationTypeByCode(Const.NVL(XMLHandler.getTagValue(stepnode,\t\"operation_type\"), \"\"));\r\n            \r\n\t\t\tencoding         = XMLHandler.getTagValue(stepnode, \"encoding\");\r\n\t\t\tAddToResult = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"AddToResult\"));\r\n\t\t\tfileName  = XMLHandler.getTagValue(stepnode, \"file\", \"name\");\r\n\t\t\tcreateparentfolder =\"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"create_parent_folder\"));\r\n\t\t\textension = XMLHandler.getTagValue(stepnode, \"file\", \"extention\");\r\n\t\t\tfileAppended    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"append\"));\r\n\t\t\tstepNrInFilename     = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"split\"));\r\n\t\t\tpartNrInFilename     = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"haspartno\"));\r\n\t\t\tdateInFilename  = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_date\"));\r\n\t\t\ttimeInFilename  = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_time\"));\r\n\t\t\tDoNotOpenNewFileInit    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"DoNotOpenNewFileInit\"));\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tNode fields = XMLHandler.getSubNode(stepnode, \"fields\"); //$NON-NLS-1$\r\n            int nrfields= XMLHandler.countNodes(fields, \"field\"); //$NON-NLS-1$\r\n    \r\n            allocate(nrfields);\r\n            \r\n            for (int i=0;i<nrfields;i++)\r\n            {\r\n                Node fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i); //$NON-NLS-1$\r\n            \r\n                outputFields[i] = new JsonOutputField();\r\n                outputFields[i].setFieldName( XMLHandler.getTagValue(fnode, \"name\") ); //$NON-NLS-1$\r\n                outputFields[i].setElementName( XMLHandler.getTagValue(fnode, \"element\") ); //$NON-NLS-1$\r\n            }\r\n        }\r\n        catch(Exception e)\r\n        {\r\n            throw new KettleXMLException(\"Unable to load step info from XML\", e); //$NON-NLS-1$\r\n        }\r\n    }","id":28112,"modified_method":"private void readData(Node stepnode) throws KettleXMLException\r\n    {\r\n        try\r\n        {\r\n            outputValue      = XMLHandler.getTagValue(stepnode, \"outputValue\"); //$NON-NLS-1$\r\n            jsonBloc    = XMLHandler.getTagValue(stepnode, \"jsonBloc\"); //$NON-NLS-1$\r\n            nrRowsInBloc= XMLHandler.getTagValue(stepnode, \"nrRowsInBloc\"); //$NON-NLS-1$\r\n            operationType = getOperationTypeByCode(Const.NVL(XMLHandler.getTagValue(stepnode,\t\"operation_type\"), \"\"));\r\n            \r\n\t\t\tencoding         = XMLHandler.getTagValue(stepnode, \"encoding\");\r\n\t\t\tAddToResult = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"AddToResult\"));\r\n\t\t\tfileName  = XMLHandler.getTagValue(stepnode, \"file\", \"name\");\r\n\t\t\tcreateparentfolder =\"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"create_parent_folder\"));\r\n\t\t\textension = XMLHandler.getTagValue(stepnode, \"file\", \"extention\");\r\n\t\t\tfileAppended    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"append\"));\r\n\t\t\tstepNrInFilename     = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"split\"));\r\n\t\t\tpartNrInFilename     = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"haspartno\"));\r\n\t\t\tdateInFilename  = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_date\"));\r\n\t\t\ttimeInFilename  = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_time\"));\r\n\t\t\tDoNotOpenNewFileInit    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"DoNotOpenNewFileInit\"));\r\n      servletOutput         = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"servlet_output\"));\r\n\t\t\t\r\n\t\t\tNode fields = XMLHandler.getSubNode(stepnode, \"fields\"); //$NON-NLS-1$\r\n            int nrfields= XMLHandler.countNodes(fields, \"field\"); //$NON-NLS-1$\r\n    \r\n            allocate(nrfields);\r\n            \r\n            for (int i=0;i<nrfields;i++)\r\n            {\r\n                Node fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i); //$NON-NLS-1$\r\n            \r\n                outputFields[i] = new JsonOutputField();\r\n                outputFields[i].setFieldName( XMLHandler.getTagValue(fnode, \"name\") ); //$NON-NLS-1$\r\n                outputFields[i].setElementName( XMLHandler.getTagValue(fnode, \"element\") ); //$NON-NLS-1$\r\n            }\r\n        }\r\n        catch(Exception e)\r\n        {\r\n            throw new KettleXMLException(\"Unable to load step info from XML\", e); //$NON-NLS-1$\r\n        }\r\n    }","commit_id":"6616135e75db58916e0f787593602e3aa6f6865a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, ObjectId id_transformation, ObjectId id_step) throws KettleException\r\n    {\r\n        try\r\n        {\r\n            rep.saveStepAttribute(id_transformation, id_step, \"outputValue\",          outputValue); //$NON-NLS-1$\r\n            rep.saveStepAttribute(id_transformation, id_step, \"jsonBloc\", jsonBloc); //$NON-NLS-1$\r\n            rep.saveStepAttribute(id_transformation, id_step, \"nrRowsInBloc\", nrRowsInBloc); //$NON-NLS-1$\r\n            \r\n            rep.saveStepAttribute(id_transformation, id_step, \"operation_type\", getOperationTypeCode(operationType));\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"encoding\",         encoding);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"addtoresult\",        AddToResult);\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_name\",        fileName);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_extention\",   extension);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_append\",      fileAppended);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_stepnr\",  stepNrInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_partnr\",  partNrInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_date\",    dateInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_time\",    timeInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"create_parent_folder\",    createparentfolder);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"DoNotOpenNewFileInit\",      DoNotOpenNewFileInit);\r\n\t\t\t\r\n            for (int i=0;i<outputFields.length;i++)\r\n            {\r\n                JsonOutputField field = outputFields[i];\r\n                \r\n                rep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",      field.getFieldName()); //$NON-NLS-1$\r\n                rep.saveStepAttribute(id_transformation, id_step, i, \"field_element\",   field.getElementName()); //$NON-NLS-1$\r\n            }\r\n        }\r\n        catch(Exception e)\r\n        {\r\n            throw new KettleException(\"Unable to save step information to the repository for id_step=\"+id_step, e); //$NON-NLS-1$\r\n        }\r\n    }","id":28113,"modified_method":"public void saveRep(Repository rep, ObjectId id_transformation, ObjectId id_step) throws KettleException\r\n    {\r\n        try\r\n        {\r\n            rep.saveStepAttribute(id_transformation, id_step, \"outputValue\",          outputValue); //$NON-NLS-1$\r\n            rep.saveStepAttribute(id_transformation, id_step, \"jsonBloc\", jsonBloc); //$NON-NLS-1$\r\n            rep.saveStepAttribute(id_transformation, id_step, \"nrRowsInBloc\", nrRowsInBloc); //$NON-NLS-1$\r\n            \r\n            rep.saveStepAttribute(id_transformation, id_step, \"operation_type\", getOperationTypeCode(operationType));\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"encoding\",         encoding);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"addtoresult\",        AddToResult);\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_name\",        fileName);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_extention\",   extension);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_append\",      fileAppended);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_stepnr\",  stepNrInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_partnr\",  partNrInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_date\",    dateInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_time\",    timeInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"create_parent_folder\",    createparentfolder);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"DoNotOpenNewFileInit\",      DoNotOpenNewFileInit);\r\n      rep.saveStepAttribute(id_transformation, id_step, \"file_servlet_output\",  servletOutput);\r\n\r\n            for (int i=0;i<outputFields.length;i++)\r\n            {\r\n                JsonOutputField field = outputFields[i];\r\n                \r\n                rep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",      field.getFieldName()); //$NON-NLS-1$\r\n                rep.saveStepAttribute(id_transformation, id_step, i, \"field_element\",   field.getElementName()); //$NON-NLS-1$\r\n            }\r\n        }\r\n        catch(Exception e)\r\n        {\r\n            throw new KettleException(\"Unable to save step information to the repository for id_step=\"+id_step, e); //$NON-NLS-1$\r\n        }\r\n    }","commit_id":"6616135e75db58916e0f787593602e3aa6f6865a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\r\n    {\r\n        StringBuffer retval=new StringBuffer(500);\r\n        \r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"outputValue\",  outputValue)); //$NON-NLS-1$ //$NON-NLS-2$\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"jsonBloc\",  jsonBloc)); //$NON-NLS-1$ //$NON-NLS-2$\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"nrRowsInBloc\",  nrRowsInBloc)); //$NON-NLS-1$ //$NON-NLS-2$\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"operation_type\",getOperationTypeCode(operationType)));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"encoding\",  encoding));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"addtoresult\",      AddToResult));\r\n\t\tretval.append(\"    <file>\"+Const.CR);\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"name\",       fileName));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"extention\",  extension));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"append\",     fileAppended));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"split\",      stepNrInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"haspartno\",  partNrInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_date\",   dateInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_time\",   timeInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"create_parent_folder\",   createparentfolder));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"DoNotOpenNewFileInit\",     DoNotOpenNewFileInit));\r\n\t\tretval.append(\"      <\/file>\"+Const.CR);\r\n        \r\n        retval.append(\"    <fields>\").append(Const.CR); //$NON-NLS-1$\r\n        for (int i=0;i<outputFields.length;i++)\r\n        {\r\n            JsonOutputField field = outputFields[i];\r\n            \r\n            if (field.getFieldName()!=null && field.getFieldName().length()!=0)\r\n            {\r\n                retval.append(\"      <field>\").append(Const.CR); //$NON-NLS-1$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"name\",      field.getFieldName())); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"element\",   field.getElementName())); //$NON-NLS-1$ //$NON-NLS-2$retval.append(\"        <\/field>\").append(Const.CR); //$NON-NLS-1$\r\n                retval.append(\"    <\/field>\"+Const.CR); //$NON-NLS-1$\r\n            }\r\n        }\r\n        retval.append(\"    <\/fields>\").append(Const.CR); //$NON-NLS-1$\r\n        return retval.toString();\r\n    }","id":28114,"modified_method":"public String getXML()\r\n    {\r\n        StringBuffer retval=new StringBuffer(500);\r\n        \r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"outputValue\",  outputValue)); //$NON-NLS-1$ //$NON-NLS-2$\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"jsonBloc\",  jsonBloc)); //$NON-NLS-1$ //$NON-NLS-2$\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"nrRowsInBloc\",  nrRowsInBloc)); //$NON-NLS-1$ //$NON-NLS-2$\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"operation_type\",getOperationTypeCode(operationType)));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"encoding\",  encoding));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"addtoresult\",      AddToResult));\r\n\t\tretval.append(\"    <file>\"+Const.CR);\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"name\",       fileName));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"extention\",  extension));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"append\",     fileAppended));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"split\",      stepNrInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"haspartno\",  partNrInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_date\",   dateInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_time\",   timeInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"create_parent_folder\",   createparentfolder));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"DoNotOpenNewFileInit\",     DoNotOpenNewFileInit));\r\n    retval.append(\"      \").append(XMLHandler.addTagValue(\"servlet_output\", servletOutput));\r\n\t\tretval.append(\"      <\/file>\"+Const.CR);\r\n        \r\n        retval.append(\"    <fields>\").append(Const.CR); //$NON-NLS-1$\r\n        for (int i=0;i<outputFields.length;i++)\r\n        {\r\n            JsonOutputField field = outputFields[i];\r\n            \r\n            if (field.getFieldName()!=null && field.getFieldName().length()!=0)\r\n            {\r\n                retval.append(\"      <field>\").append(Const.CR); //$NON-NLS-1$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"name\",      field.getFieldName())); //$NON-NLS-1$ //$NON-NLS-2$\r\n                retval.append(\"        \").append(XMLHandler.addTagValue(\"element\",   field.getElementName())); //$NON-NLS-1$ //$NON-NLS-2$retval.append(\"        <\/field>\").append(Const.CR); //$NON-NLS-1$\r\n                retval.append(\"    <\/field>\"+Const.CR); //$NON-NLS-1$\r\n            }\r\n        }\r\n        retval.append(\"    <\/fields>\").append(Const.CR); //$NON-NLS-1$\r\n        return retval.toString();\r\n    }","commit_id":"6616135e75db58916e0f787593602e3aa6f6865a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init( StepMetaInterface smi, StepDataInterface sdi ) {\n    meta = (ValidatorMeta) smi;\n    data = (ValidatorData) sdi;\n\n    if ( super.init( smi, sdi ) ) {\n      // initialize arrays of validation data\n      data.constantsMeta = new ValueMetaInterface[meta.getValidations().size()];\n      data.minimumValueAsString = new String[meta.getValidations().size()];\n      data.maximumValueAsString = new String[meta.getValidations().size()];\n      data.fieldsMinimumLengthAsInt = new int[meta.getValidations().size()];\n      data.fieldsMaximumLengthAsInt = new int[meta.getValidations().size()];\n      data.minimumValue = new Object[meta.getValidations().size()];\n      data.maximumValue = new Object[meta.getValidations().size()];\n      data.listValues = new Object[meta.getValidations().size()][];\n      data.errorCode = new String[meta.getValidations().size()];\n      data.errorDescription = new String[meta.getValidations().size()];\n      data.conversionMask = new String[meta.getValidations().size()];\n      data.decimalSymbol = new String[meta.getValidations().size()];\n      data.groupingSymbol = new String[meta.getValidations().size()];\n      data.maximumLength = new String[meta.getValidations().size()];\n      data.minimumLength = new String[meta.getValidations().size()];\n      data.startString = new String[meta.getValidations().size()];\n      data.endString = new String[meta.getValidations().size()];\n      data.startStringNotAllowed = new String[meta.getValidations().size()];\n      data.endStringNotAllowed = new String[meta.getValidations().size()];\n      data.regularExpression = new String[meta.getValidations().size()];\n      data.regularExpressionNotAllowed = new String[meta.getValidations().size()];\n      data.patternExpected = new Pattern[meta.getValidations().size()];\n      data.patternDisallowed = new Pattern[meta.getValidations().size()];\n\n      for ( int i = 0; i < meta.getValidations().size(); i++ ) {\n\n        Validation field = meta.getValidations().get( i );\n        try {\n          data.constantsMeta[i] = ValueMetaFactory.createValueMeta( field.getFieldName(), field.getDataType() );\n          data.constantsMeta[i].setConversionMask( field.getConversionMask() );\n          data.constantsMeta[i].setDecimalSymbol( field.getDecimalSymbol() );\n          data.constantsMeta[i].setGroupingSymbol( field.getGroupingSymbol() );\n          data.errorCode[i] = environmentSubstitute( Const.NVL( field.getErrorCode(), \"\" ) );\n          data.errorDescription[i] = environmentSubstitute( Const.NVL( field.getErrorDescription(), \"\" ) );\n          data.conversionMask[i] = environmentSubstitute( Const.NVL( field.getConversionMask(), \"\" ) );\n          data.decimalSymbol[i] = environmentSubstitute( Const.NVL( field.getDecimalSymbol(), \"\" ) );\n          data.groupingSymbol[i] = environmentSubstitute( Const.NVL( field.getGroupingSymbol(), \"\" ) );\n          data.maximumLength[i] = environmentSubstitute( Const.NVL( field.getMaximumLength(), \"\" ) );\n          data.minimumLength[i] = environmentSubstitute( Const.NVL( field.getMinimumLength(), \"\" ) );\n          data.maximumValueAsString[i] = environmentSubstitute( Const.NVL( field.getMaximumValue(), \"\" ) );\n          data.minimumValueAsString[i] = environmentSubstitute( Const.NVL( field.getMinimumValue(), \"\" ) );\n          data.startString[i] = environmentSubstitute( Const.NVL( field.getStartString(), \"\" ) );\n          data.endString[i] = environmentSubstitute( Const.NVL( field.getEndString(), \"\" ) );\n          data.startStringNotAllowed[i] = environmentSubstitute( Const.NVL( field.getStartStringNotAllowed(), \"\" ) );\n          data.endStringNotAllowed[i] = environmentSubstitute( Const.NVL( field.getEndStringNotAllowed(), \"\" ) );\n          data.regularExpression[i] = environmentSubstitute( Const.NVL( field.getRegularExpression(), \"\" ) );\n          data.regularExpressionNotAllowed[i] =\n              environmentSubstitute( Const.NVL( field.getRegularExpressionNotAllowed(), \"\" ) );\n\n          ValueMetaInterface stringMeta =\n              ValueMetaFactory.cloneValueMeta( data.constantsMeta[i], ValueMetaInterface.TYPE_STRING );\n          data.minimumValue[i] =\n              Const.isEmpty( data.minimumValueAsString[i] ) ? null : data.constantsMeta[i].convertData( stringMeta,\n                  data.minimumValueAsString[i] );\n          data.maximumValue[i] =\n              Const.isEmpty( data.maximumValueAsString[i] ) ? null : data.constantsMeta[i].convertData( stringMeta,\n                  data.maximumValueAsString[i] );\n\n          try {\n            data.fieldsMinimumLengthAsInt[i] = Integer.valueOf( Const.NVL( data.minimumLength[i], \"-1\" ) );\n          } catch ( NumberFormatException nfe ) {\n            throw new KettleValueException( \"Caught a number format exception converting minimum length with value \"\n                + data.minimumLength[i] + \" to an int.\", nfe );\n          }\n\n          try {\n            data.fieldsMaximumLengthAsInt[i] = Integer.valueOf( Const.NVL( data.maximumLength[i], \"-1\" ) );\n          } catch ( NumberFormatException nfe ) {\n            throw new KettleValueException( \"Caught a number format exception converting minimum length with value \"\n                + data.maximumLength[i] + \" to an int.\", nfe );\n          }\n\n          int listSize = field.getAllowedValues() != null ? field.getAllowedValues().length : 0;\n          data.listValues[i] = new Object[listSize];\n          for ( int s = 0; s < listSize; s++ ) {\n            data.listValues[i][s] =\n                Const.isEmpty( field.getAllowedValues()[s] ) ? null : data.constantsMeta[i].convertData( stringMeta,\n                    environmentSubstitute( field.getAllowedValues()[s] ) );\n          }\n        } catch ( KettleException e ) {\n          if ( field.getDataType() == ValueMetaInterface.TYPE_NONE ) {\n            logError( BaseMessages.getString( PKG, \"Validator.Exception.SpecifyDataType\" ), e );\n          } else {\n            logError( BaseMessages.getString( PKG, \"Validator.Exception.DataConversionErrorEncountered\" ), e );\n          }\n          return false;\n        }\n\n        if ( !Const.isEmpty( data.regularExpression[i] ) ) {\n          data.patternExpected[i] = Pattern.compile( field.getRegularExpression() );\n        }\n        if ( !Const.isEmpty( data.regularExpressionNotAllowed[i] ) ) {\n          data.patternDisallowed[i] = Pattern.compile( field.getRegularExpressionNotAllowed() );\n        }\n\n      }\n\n      return true;\n    }\n    return false;\n  }","id":28115,"modified_method":"public boolean init( StepMetaInterface smi, StepDataInterface sdi ) {\n    meta = (ValidatorMeta) smi;\n    data = (ValidatorData) sdi;\n\n    if ( super.init( smi, sdi ) ) {\n      // initialize arrays of validation data\n      data.constantsMeta = new ValueMetaInterface[meta.getValidations().size()];\n      data.minimumValueAsString = new String[meta.getValidations().size()];\n      data.maximumValueAsString = new String[meta.getValidations().size()];\n      data.fieldsMinimumLengthAsInt = new int[meta.getValidations().size()];\n      data.fieldsMaximumLengthAsInt = new int[meta.getValidations().size()];\n      data.minimumValue = new Object[meta.getValidations().size()];\n      data.maximumValue = new Object[meta.getValidations().size()];\n      data.listValues = new Object[meta.getValidations().size()][];\n      data.errorCode = new String[meta.getValidations().size()];\n      data.errorDescription = new String[meta.getValidations().size()];\n      data.conversionMask = new String[meta.getValidations().size()];\n      data.decimalSymbol = new String[meta.getValidations().size()];\n      data.groupingSymbol = new String[meta.getValidations().size()];\n      data.maximumLength = new String[meta.getValidations().size()];\n      data.minimumLength = new String[meta.getValidations().size()];\n      data.startString = new String[meta.getValidations().size()];\n      data.endString = new String[meta.getValidations().size()];\n      data.startStringNotAllowed = new String[meta.getValidations().size()];\n      data.endStringNotAllowed = new String[meta.getValidations().size()];\n      data.regularExpression = new String[meta.getValidations().size()];\n      data.regularExpressionNotAllowed = new String[meta.getValidations().size()];\n      data.patternExpected = new Pattern[meta.getValidations().size()];\n      data.patternDisallowed = new Pattern[meta.getValidations().size()];\n\n      for ( int i = 0; i < meta.getValidations().size(); i++ ) {\n\n        Validation field = meta.getValidations().get( i );\n        try {\n          data.constantsMeta[i] = createValueMeta( field.getFieldName(), field.getDataType() );\n          data.constantsMeta[i].setConversionMask( field.getConversionMask() );\n          data.constantsMeta[i].setDecimalSymbol( field.getDecimalSymbol() );\n          data.constantsMeta[i].setGroupingSymbol( field.getGroupingSymbol() );\n          data.errorCode[i] = environmentSubstitute( Const.NVL( field.getErrorCode(), \"\" ) );\n          data.errorDescription[i] = environmentSubstitute( Const.NVL( field.getErrorDescription(), \"\" ) );\n          data.conversionMask[i] = environmentSubstitute( Const.NVL( field.getConversionMask(), \"\" ) );\n          data.decimalSymbol[i] = environmentSubstitute( Const.NVL( field.getDecimalSymbol(), \"\" ) );\n          data.groupingSymbol[i] = environmentSubstitute( Const.NVL( field.getGroupingSymbol(), \"\" ) );\n          data.maximumLength[i] = environmentSubstitute( Const.NVL( field.getMaximumLength(), \"\" ) );\n          data.minimumLength[i] = environmentSubstitute( Const.NVL( field.getMinimumLength(), \"\" ) );\n          data.maximumValueAsString[i] = environmentSubstitute( Const.NVL( field.getMaximumValue(), \"\" ) );\n          data.minimumValueAsString[i] = environmentSubstitute( Const.NVL( field.getMinimumValue(), \"\" ) );\n          data.startString[i] = environmentSubstitute( Const.NVL( field.getStartString(), \"\" ) );\n          data.endString[i] = environmentSubstitute( Const.NVL( field.getEndString(), \"\" ) );\n          data.startStringNotAllowed[i] = environmentSubstitute( Const.NVL( field.getStartStringNotAllowed(), \"\" ) );\n          data.endStringNotAllowed[i] = environmentSubstitute( Const.NVL( field.getEndStringNotAllowed(), \"\" ) );\n          data.regularExpression[i] = environmentSubstitute( Const.NVL( field.getRegularExpression(), \"\" ) );\n          data.regularExpressionNotAllowed[i] =\n              environmentSubstitute( Const.NVL( field.getRegularExpressionNotAllowed(), \"\" ) );\n\n          ValueMetaInterface stringMeta =\n              cloneValueMeta( data.constantsMeta[i], ValueMetaInterface.TYPE_STRING );\n          data.minimumValue[i] =\n              Const.isEmpty( data.minimumValueAsString[i] ) ? null : data.constantsMeta[i].convertData( stringMeta,\n                  data.minimumValueAsString[i] );\n          data.maximumValue[i] =\n              Const.isEmpty( data.maximumValueAsString[i] ) ? null : data.constantsMeta[i].convertData( stringMeta,\n                  data.maximumValueAsString[i] );\n\n          try {\n            data.fieldsMinimumLengthAsInt[i] = Integer.valueOf( Const.NVL( data.minimumLength[i], \"-1\" ) );\n          } catch ( NumberFormatException nfe ) {\n            throw new KettleValueException( \"Caught a number format exception converting minimum length with value \"\n                + data.minimumLength[i] + \" to an int.\", nfe );\n          }\n\n          try {\n            data.fieldsMaximumLengthAsInt[i] = Integer.valueOf( Const.NVL( data.maximumLength[i], \"-1\" ) );\n          } catch ( NumberFormatException nfe ) {\n            throw new KettleValueException( \"Caught a number format exception converting minimum length with value \"\n                + data.maximumLength[i] + \" to an int.\", nfe );\n          }\n\n          int listSize = field.getAllowedValues() != null ? field.getAllowedValues().length : 0;\n          data.listValues[i] = new Object[listSize];\n          for ( int s = 0; s < listSize; s++ ) {\n            data.listValues[i][s] =\n                Const.isEmpty( field.getAllowedValues()[s] ) ? null : data.constantsMeta[i].convertData( stringMeta,\n                    environmentSubstitute( field.getAllowedValues()[s] ) );\n          }\n        } catch ( KettleException e ) {\n          if ( field.getDataType() == ValueMetaInterface.TYPE_NONE ) {\n            logError( BaseMessages.getString( PKG, \"Validator.Exception.SpecifyDataType\" ), e );\n          } else {\n            logError( BaseMessages.getString( PKG, \"Validator.Exception.DataConversionErrorEncountered\" ), e );\n          }\n          return false;\n        }\n\n        if ( !Const.isEmpty( data.regularExpression[i] ) ) {\n          data.patternExpected[i] = Pattern.compile( data.regularExpression[i] );\n        }\n        if ( !Const.isEmpty( data.regularExpressionNotAllowed[i] ) ) {\n          data.patternDisallowed[i] = Pattern.compile( data.regularExpressionNotAllowed[i] );\n        }\n\n      }\n\n      return true;\n    }\n    return false;\n  }","commit_id":"57d868336e01b8e733c4f65c69f0e49f5a561ad3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * @param inputRowMeta\n   *          the input row metadata\n   * @param r\n   *          the input row (data)\n   * @throws KettleValidatorException\n   *           in case there is a validation error, details are stored in the exception.\n   */\n  private List<KettleValidatorException> validateFields( RowMetaInterface inputRowMeta, Object[] r )\n    throws KettleValidatorException, KettleValueException {\n    List<KettleValidatorException> exceptions = new ArrayList<KettleValidatorException>();\n\n    for ( int i = 0; i < meta.getValidations().size(); i++ ) {\n      Validation field = meta.getValidations().get( i );\n\n      int valueIndex = data.fieldIndexes[i];\n      ValueMetaInterface validatorMeta = data.constantsMeta[i];\n\n      ValueMetaInterface valueMeta = inputRowMeta.getValueMeta( valueIndex );\n      Object valueData = r[valueIndex];\n\n      // Check for null\n      //\n      boolean isNull = valueMeta.isNull( valueData );\n      if ( !field.isNullAllowed() && isNull ) {\n        KettleValidatorException exception =\n            new KettleValidatorException( this, field, KettleValidatorException.ERROR_NULL_VALUE_NOT_ALLOWED,\n                BaseMessages.getString( PKG, \"Validator.Exception.NullNotAllowed\", field.getFieldName(), inputRowMeta\n                    .getString( r ) ), field.getFieldName() );\n        exceptions.add( exception );\n        if ( !meta.isValidatingAll() ) {\n          return exceptions;\n        }\n      }\n\n      if ( field.isOnlyNullAllowed() && !isNull ) {\n        KettleValidatorException exception =\n            new KettleValidatorException( this, field, KettleValidatorException.ERROR_ONLY_NULL_VALUE_ALLOWED,\n                BaseMessages.getString( PKG, \"Validator.Exception.OnlyNullAllowed\", field.getFieldName(), inputRowMeta\n                    .getString( r ) ), field.getFieldName() );\n        exceptions.add( exception );\n        if ( !meta.isValidatingAll() ) {\n          return exceptions;\n        }\n      }\n\n      // Check the data type!\n      //\n      if ( field.isDataTypeVerified() && field.getDataType() != ValueMetaInterface.TYPE_NONE ) {\n\n        // Same data type?\n        //\n        if ( field.getDataType() != valueMeta.getType() ) {\n          KettleValidatorException exception =\n              new KettleValidatorException( this, field, KettleValidatorException.ERROR_UNEXPECTED_DATA_TYPE,\n                  BaseMessages.getString( PKG, \"Validator.Exception.UnexpectedDataType\", field.getFieldName(),\n                      valueMeta.toStringMeta(), validatorMeta.toStringMeta() ), field.getFieldName() );\n          exceptions.add( exception );\n          if ( !meta.isValidatingAll() ) {\n            return exceptions;\n          }\n        }\n      }\n\n      // Check various things if the value is not null..\n      //\n      if ( !isNull ) {\n\n        if ( data.fieldsMinimumLengthAsInt[i] >= 0 || data.fieldsMaximumLengthAsInt[i] >= 0\n            || data.minimumValue[i] != null || data.maximumValue[i] != null || data.listValues[i].length > 0\n            || field.isSourcingValues() || !Const.isEmpty( data.startString[i] ) || !Const.isEmpty( data.endString[i] )\n            || !Const.isEmpty( data.startStringNotAllowed[i] ) || !Const.isEmpty( data.endStringNotAllowed[i] )\n            || field.isOnlyNumericAllowed() || data.patternExpected[i] != null || data.patternDisallowed[i] != null ) {\n\n          String stringValue = valueMeta.getString( valueData );\n          int stringLength = stringValue.length();\n\n          // Minimum length\n          //\n          // if (field.getMinimumLength()>=0 && stringValue.length()<field.getMinimumLength() ) {\n          if ( data.fieldsMinimumLengthAsInt[i] >= 0 && stringLength < data.fieldsMinimumLengthAsInt[i] ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_SHORTER_THAN_MINIMUM_LENGTH,\n                    BaseMessages.getString( PKG, \"Validator.Exception.ShorterThanMininumLength\", field.getFieldName(),\n                        valueMeta.getString( valueData ), Integer.toString( stringValue.length() ), field\n                            .getMinimumLength() ), field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // Maximum length\n          //\n          // if (field.getMaximumLength()>=0 && stringValue.length()>field.getMaximumLength() ) {\n          if ( data.fieldsMaximumLengthAsInt[i] >= 0 && stringLength > data.fieldsMaximumLengthAsInt[i] ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_LONGER_THAN_MAXIMUM_LENGTH,\n                    BaseMessages.getString( PKG, \"Validator.Exception.LongerThanMaximumLength\", field.getFieldName(),\n                        valueMeta.getString( valueData ), Integer.toString( stringValue.length() ), field\n                            .getMaximumLength() ), field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // Minimal value\n          //\n          if ( data.minimumValue[i] != null && valueMeta.compare( valueData, validatorMeta, data.minimumValue[i] ) < 0 ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_LOWER_THAN_ALLOWED_MINIMUM,\n                    BaseMessages.getString( PKG, \"Validator.Exception.LowerThanMinimumValue\", field.getFieldName(),\n                        valueMeta.getString( valueData ), data.constantsMeta[i].getString( data.minimumValue[i] ) ),\n                    field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // Maximum value\n          //\n          if ( data.maximumValue[i] != null && valueMeta.compare( valueData, validatorMeta, data.maximumValue[i] ) > 0 ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_HIGHER_THAN_ALLOWED_MAXIMUM,\n                    BaseMessages.getString( PKG, \"Validator.Exception.HigherThanMaximumValue\", field.getFieldName(),\n                        valueMeta.getString( valueData ), data.constantsMeta[i].getString( data.maximumValue[i] ) ),\n                    field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // In list?\n          //\n          if ( field.isSourcingValues() || data.listValues[i].length > 0 ) {\n            boolean found = false;\n            for ( Object object : data.listValues[i] ) {\n              if ( object != null && data.listValues[i] != null\n                  && valueMeta.compare( valueData, validatorMeta, object ) == 0 ) {\n                found = true;\n              }\n            }\n            if ( !found ) {\n              KettleValidatorException exception =\n                  new KettleValidatorException( this, field, KettleValidatorException.ERROR_VALUE_NOT_IN_LIST,\n                      BaseMessages.getString( PKG, \"Validator.Exception.NotInList\", field.getFieldName(), valueMeta\n                          .getString( valueData ) ), field.getFieldName() );\n              exceptions.add( exception );\n              if ( !meta.isValidatingAll() ) {\n                return exceptions;\n              }\n            }\n          }\n\n          // Numeric data or strings with only\n          if ( field.isOnlyNumericAllowed() ) {\n            if ( valueMeta.isNumeric() || !containsOnlyDigits( valueMeta.getString( valueData ) ) ) {\n              KettleValidatorException exception =\n                  new KettleValidatorException( this, field, KettleValidatorException.ERROR_NON_NUMERIC_DATA,\n                      BaseMessages.getString( PKG, \"Validator.Exception.NonNumericDataNotAllowed\",\n                          field.getFieldName(), valueMeta.toStringMeta() ), field.getFieldName() );\n              exceptions.add( exception );\n              if ( !meta.isValidatingAll() ) {\n                return exceptions;\n              }\n            }\n          }\n\n          // Does not start with string value\n          //\n          if ( !Const.isEmpty( data.startString[i] ) && !stringValue.startsWith( data.startString[i] ) ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_DOES_NOT_START_WITH_STRING,\n                    BaseMessages.getString( PKG, \"Validator.Exception.DoesNotStartWithString\", field.getFieldName(),\n                        valueMeta.getString( valueData ), field.getStartString() ), field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // Ends with string value\n          //\n          if ( !Const.isEmpty( data.endString[i] ) && !stringValue.endsWith( data.endString[i] ) ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_DOES_NOT_END_WITH_STRING,\n                    BaseMessages.getString( PKG, \"Validator.Exception.DoesNotStartWithString\", field.getFieldName(),\n                        valueMeta.getString( valueData ), field.getEndString() ), field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // Starts with string value\n          //\n          if ( !Const.isEmpty( data.startStringNotAllowed[i] )\n              && stringValue.startsWith( data.startStringNotAllowed[i] ) ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_STARTS_WITH_STRING,\n                    BaseMessages.getString( PKG, \"Validator.Exception.StartsWithString\", field.getFieldName(),\n                        valueMeta.getString( valueData ), field.getStartStringNotAllowed() ), field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // Ends with string value\n          //\n          if ( !Const.isEmpty( data.endStringNotAllowed[i] ) && stringValue.endsWith( data.endStringNotAllowed[i] ) ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_ENDS_WITH_STRING,\n                    BaseMessages.getString( PKG, \"Validator.Exception.EndsWithString\", field.getFieldName(), valueMeta\n                        .getString( valueData ), field.getEndStringNotAllowed() ), field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // Matching regular expression allowed?\n          //\n          if ( data.patternExpected[i] != null ) {\n            Matcher matcher = data.patternExpected[i].matcher( stringValue );\n            if ( !matcher.matches() ) {\n              KettleValidatorException exception =\n                  new KettleValidatorException( this, field,\n                      KettleValidatorException.ERROR_MATCHING_REGULAR_EXPRESSION_EXPECTED, BaseMessages.getString( PKG,\n                          \"Validator.Exception.MatchingRegExpExpected\", field.getFieldName(), valueMeta\n                              .getString( valueData ), field.getRegularExpression() ), field.getFieldName() );\n              exceptions.add( exception );\n              if ( !meta.isValidatingAll() ) {\n                return exceptions;\n              }\n            }\n          }\n\n          // Matching regular expression NOT allowed?\n          //\n          if ( data.patternDisallowed[i] != null ) {\n            Matcher matcher = data.patternDisallowed[i].matcher( stringValue );\n            if ( matcher.matches() ) {\n              KettleValidatorException exception =\n                  new KettleValidatorException( this, field,\n                      KettleValidatorException.ERROR_MATCHING_REGULAR_EXPRESSION_NOT_ALLOWED, BaseMessages.getString(\n                          PKG, \"Validator.Exception.MatchingRegExpNotAllowed\", field.getFieldName(), valueMeta\n                              .getString( valueData ), field.getRegularExpressionNotAllowed() ), field.getFieldName() );\n              exceptions.add( exception );\n              if ( !meta.isValidatingAll() ) {\n                return exceptions;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return exceptions;\n  }","id":28116,"modified_method":"/**\n   * @param inputRowMeta\n   *          the input row metadata\n   * @param r\n   *          the input row (data)\n   * @throws KettleValidatorException\n   *           in case there is a validation error, details are stored in the exception.\n   */\n  private List<KettleValidatorException> validateFields( RowMetaInterface inputRowMeta, Object[] r )\n    throws KettleValidatorException, KettleValueException {\n    List<KettleValidatorException> exceptions = new ArrayList<KettleValidatorException>();\n\n    for ( int i = 0; i < meta.getValidations().size(); i++ ) {\n      Validation field = meta.getValidations().get( i );\n\n      int valueIndex = data.fieldIndexes[i];\n      ValueMetaInterface validatorMeta = data.constantsMeta[i];\n\n      ValueMetaInterface valueMeta = inputRowMeta.getValueMeta( valueIndex );\n      Object valueData = r[valueIndex];\n\n      // Check for null\n      //\n      boolean isNull = valueMeta.isNull( valueData );\n      if ( !field.isNullAllowed() && isNull ) {\n        KettleValidatorException exception =\n            new KettleValidatorException( this, field, KettleValidatorException.ERROR_NULL_VALUE_NOT_ALLOWED,\n                BaseMessages.getString( PKG, \"Validator.Exception.NullNotAllowed\", field.getFieldName(), inputRowMeta\n                    .getString( r ) ), field.getFieldName() );\n        exceptions.add( exception );\n        if ( !meta.isValidatingAll() ) {\n          return exceptions;\n        }\n      }\n\n      if ( field.isOnlyNullAllowed() && !isNull ) {\n        KettleValidatorException exception =\n            new KettleValidatorException( this, field, KettleValidatorException.ERROR_ONLY_NULL_VALUE_ALLOWED,\n                BaseMessages.getString( PKG, \"Validator.Exception.OnlyNullAllowed\", field.getFieldName(), inputRowMeta\n                    .getString( r ) ), field.getFieldName() );\n        exceptions.add( exception );\n        if ( !meta.isValidatingAll() ) {\n          return exceptions;\n        }\n      }\n\n      // Check the data type!\n      //\n      if ( field.isDataTypeVerified() && field.getDataType() != ValueMetaInterface.TYPE_NONE ) {\n\n        // Same data type?\n        //\n        if ( field.getDataType() != valueMeta.getType() ) {\n          KettleValidatorException exception =\n              new KettleValidatorException( this, field, KettleValidatorException.ERROR_UNEXPECTED_DATA_TYPE,\n                  BaseMessages.getString( PKG, \"Validator.Exception.UnexpectedDataType\", field.getFieldName(),\n                      valueMeta.toStringMeta(), validatorMeta.toStringMeta() ), field.getFieldName() );\n          exceptions.add( exception );\n          if ( !meta.isValidatingAll() ) {\n            return exceptions;\n          }\n        }\n      }\n\n      // Check various things if the value is not null..\n      //\n      if ( !isNull ) {\n\n        if ( data.fieldsMinimumLengthAsInt[i] >= 0 || data.fieldsMaximumLengthAsInt[i] >= 0\n            || data.minimumValue[i] != null || data.maximumValue[i] != null || data.listValues[i].length > 0\n            || field.isSourcingValues() || !Const.isEmpty( data.startString[i] ) || !Const.isEmpty( data.endString[i] )\n            || !Const.isEmpty( data.startStringNotAllowed[i] ) || !Const.isEmpty( data.endStringNotAllowed[i] )\n            || field.isOnlyNumericAllowed() || data.patternExpected[i] != null || data.patternDisallowed[i] != null ) {\n\n          String stringValue = valueMeta.getString( valueData );\n          int stringLength = stringValue.length();\n\n          // Minimum length\n          //\n          // if (field.getMinimumLength()>=0 && stringValue.length()<field.getMinimumLength() ) {\n          if ( data.fieldsMinimumLengthAsInt[i] >= 0 && stringLength < data.fieldsMinimumLengthAsInt[i] ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_SHORTER_THAN_MINIMUM_LENGTH,\n                    BaseMessages.getString( PKG, \"Validator.Exception.ShorterThanMininumLength\", field.getFieldName(),\n                        valueMeta.getString( valueData ), Integer.toString( stringValue.length() ), field\n                            .getMinimumLength() ), field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // Maximum length\n          //\n          // if (field.getMaximumLength()>=0 && stringValue.length()>field.getMaximumLength() ) {\n          if ( data.fieldsMaximumLengthAsInt[i] >= 0 && stringLength > data.fieldsMaximumLengthAsInt[i] ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_LONGER_THAN_MAXIMUM_LENGTH,\n                    BaseMessages.getString( PKG, \"Validator.Exception.LongerThanMaximumLength\", field.getFieldName(),\n                        valueMeta.getString( valueData ), Integer.toString( stringValue.length() ), field\n                            .getMaximumLength() ), field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // Minimal value\n          //\n          if ( data.minimumValue[i] != null && valueMeta.compare( valueData, validatorMeta, data.minimumValue[i] ) < 0 ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_LOWER_THAN_ALLOWED_MINIMUM,\n                    BaseMessages.getString( PKG, \"Validator.Exception.LowerThanMinimumValue\", field.getFieldName(),\n                        valueMeta.getString( valueData ), data.constantsMeta[i].getString( data.minimumValue[i] ) ),\n                    field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // Maximum value\n          //\n          if ( data.maximumValue[i] != null && valueMeta.compare( valueData, validatorMeta, data.maximumValue[i] ) > 0 ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_HIGHER_THAN_ALLOWED_MAXIMUM,\n                    BaseMessages.getString( PKG, \"Validator.Exception.HigherThanMaximumValue\", field.getFieldName(),\n                        valueMeta.getString( valueData ), data.constantsMeta[i].getString( data.maximumValue[i] ) ),\n                    field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // In list?\n          //\n          if ( field.isSourcingValues() || data.listValues[i].length > 0 ) {\n            boolean found = false;\n            for ( Object object : data.listValues[i] ) {\n              if ( object != null && data.listValues[i] != null\n                  && valueMeta.compare( valueData, validatorMeta, object ) == 0 ) {\n                found = true;\n              }\n            }\n            if ( !found ) {\n              KettleValidatorException exception =\n                  new KettleValidatorException( this, field, KettleValidatorException.ERROR_VALUE_NOT_IN_LIST,\n                      BaseMessages.getString( PKG, \"Validator.Exception.NotInList\", field.getFieldName(), valueMeta\n                          .getString( valueData ) ), field.getFieldName() );\n              exceptions.add( exception );\n              if ( !meta.isValidatingAll() ) {\n                return exceptions;\n              }\n            }\n          }\n\n          // Numeric data or strings with only\n          if ( field.isOnlyNumericAllowed() ) {\n            if ( valueMeta.isNumeric() || !containsOnlyDigits( valueMeta.getString( valueData ) ) ) {\n              KettleValidatorException exception =\n                  new KettleValidatorException( this, field, KettleValidatorException.ERROR_NON_NUMERIC_DATA,\n                      BaseMessages.getString( PKG, \"Validator.Exception.NonNumericDataNotAllowed\",\n                          field.getFieldName(), valueMeta.toStringMeta() ), field.getFieldName() );\n              exceptions.add( exception );\n              if ( !meta.isValidatingAll() ) {\n                return exceptions;\n              }\n            }\n          }\n\n          // Does not start with string value\n          //\n          if ( !Const.isEmpty( data.startString[i] ) && !stringValue.startsWith( data.startString[i] ) ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_DOES_NOT_START_WITH_STRING,\n                    BaseMessages.getString( PKG, \"Validator.Exception.DoesNotStartWithString\", field.getFieldName(),\n                        valueMeta.getString( valueData ), field.getStartString() ), field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // Ends with string value\n          //\n          if ( !Const.isEmpty( data.endString[i] ) && !stringValue.endsWith( data.endString[i] ) ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_DOES_NOT_END_WITH_STRING,\n                    BaseMessages.getString( PKG, \"Validator.Exception.DoesNotStartWithString\", field.getFieldName(),\n                        valueMeta.getString( valueData ), field.getEndString() ), field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // Starts with string value\n          //\n          if ( !Const.isEmpty( data.startStringNotAllowed[i] )\n              && stringValue.startsWith( data.startStringNotAllowed[i] ) ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_STARTS_WITH_STRING,\n                    BaseMessages.getString( PKG, \"Validator.Exception.StartsWithString\", field.getFieldName(),\n                        valueMeta.getString( valueData ), field.getStartStringNotAllowed() ), field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // Ends with string value\n          //\n          if ( !Const.isEmpty( data.endStringNotAllowed[i] ) && stringValue.endsWith( data.endStringNotAllowed[i] ) ) {\n            KettleValidatorException exception =\n                new KettleValidatorException( this, field, KettleValidatorException.ERROR_ENDS_WITH_STRING,\n                    BaseMessages.getString( PKG, \"Validator.Exception.EndsWithString\", field.getFieldName(), valueMeta\n                        .getString( valueData ), field.getEndStringNotAllowed() ), field.getFieldName() );\n            exceptions.add( exception );\n            if ( !meta.isValidatingAll() ) {\n              return exceptions;\n            }\n          }\n\n          // Matching regular expression allowed?\n          //\n          if ( data.patternExpected[i] != null ) {\n            Matcher matcher = data.patternExpected[i].matcher( stringValue );\n            if ( !matcher.matches() ) {\n              KettleValidatorException exception =\n                  new KettleValidatorException( this, field,\n                      KettleValidatorException.ERROR_MATCHING_REGULAR_EXPRESSION_EXPECTED, BaseMessages.getString( PKG,\n                          \"Validator.Exception.MatchingRegExpExpected\", field.getFieldName(), valueMeta\n                              .getString( valueData ), data.regularExpression[i] ), field.getFieldName() );\n              exceptions.add( exception );\n              if ( !meta.isValidatingAll() ) {\n                return exceptions;\n              }\n            }\n          }\n\n          // Matching regular expression NOT allowed?\n          //\n          if ( data.patternDisallowed[i] != null ) {\n            Matcher matcher = data.patternDisallowed[i].matcher( stringValue );\n            if ( matcher.matches() ) {\n              KettleValidatorException exception =\n                  new KettleValidatorException( this, field,\n                      KettleValidatorException.ERROR_MATCHING_REGULAR_EXPRESSION_NOT_ALLOWED, BaseMessages.getString(\n                          PKG, \"Validator.Exception.MatchingRegExpNotAllowed\", field.getFieldName(), valueMeta\n                              .getString( valueData ), data.regularExpressionNotAllowed[i] ), field.getFieldName() );\n              exceptions.add( exception );\n              if ( !meta.isValidatingAll() ) {\n                return exceptions;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return exceptions;\n  }","commit_id":"57d868336e01b8e733c4f65c69f0e49f5a561ad3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Process a single row.  In our case, we send one row of data to a piece of transformation.\n     * In the transformation, we look up the MappingInput step to send our rows to it.\n     * As a consequence, for the time being, there can only be one MappingInput and one MappingOutput step in the Mapping.\n     */\n\tpublic boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(MappingMeta)smi;\n\t\tdata=(MappingData)sdi;\n\n\t\tRow r=getRow();    // get row, set busy!\n\t\tif (r==null)       // no more input to be expected...\n\t\t{\n            // Signal output done to the mapping input step in the mapping...\n\t\t\tdata.mappingInput.setOutputDone();\n            \n\t\t\t// The wait for mapping input is over...\n            data.mappingInput.setFinished(); \n            \n\t\t\treturn false;\n\t\t}\n        \n        //\n        // OK, we have a row.\n        // We need to \"give\" this row to the running mapping (sub-transformation).\n        // We do this by looking up the MappingInput step in the transformation.\n        // We give the row to this step ...\n        //\n        \n        data.mappingInput.putRow(r);     // copy row to possible alternate rowset(s) in the mapping.\n        \n        if ((linesRead>0) && (linesRead%Const.ROWS_UPDATE)==0) logBasic(\"Linenr \"+linesRead);\n\n        //\n        // The problem now is to get a row back from the mapping...\n        // This transformed row we need to send to the next step.\n        // Well actually this is not done here but in the mapping.  See init()\n        //\n\t\treturn true;\n\t}","id":28117,"modified_method":"/**\n     * Process a single row.  In our case, we send one row of data to a piece of transformation.\n     * In the transformation, we look up the MappingInput step to send our rows to it.\n     * As a consequence, for the time being, there can only be one MappingInput and one MappingOutput step in the Mapping.\n     */\n\tpublic boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(MappingMeta)smi;\n\t\tdata=(MappingData)sdi;\n\n\t\tRow r=getRow();    // get row, set busy!\n\t\tif (r==null)       // no more input to be expected...\n\t\t{\n            // Signal output done to the mapping input step in the mapping...\n\t\t\tdata.mappingInput.setOutputDone();\n            \n\t\t\t// The wait for mapping input is over...\n            data.mappingInput.setFinished(); \n            \n\t\t\treturn false;\n\t\t}\n        \n        //\n        // OK, we have a row.\n        // We need to \"give\" this row to the running mapping (sub-transformation).\n        // We do this by looking up the MappingInput step in the transformation.\n        // We give the row to this step ...\n        //\n        // Before we can send out this data, we need to convert field-names and actually do the field mapping\n\t\t// This means that we're renaming fields in case they are not the same.\n\t\t// They will stay renamed even after the mapping step.\n\t\t// \n\t\tif (first)\n\t\t{\n\t\t\tfirst=false;\n\t\t\tdata.renameFieldIndexes = new ArrayList();\n\t\t\tdata.renameFieldNames   = new ArrayList();\n\t\t\t\n\t\t\tfor (int i=0;i<meta.getInputField().length;i++)\n\t\t\t{\n\t\t\t\tif (meta.getInputField()[i]!=null && meta.getInputField()[i].length()>0)\n\t\t\t\t{\n\t\t\t\t\tif (meta.getInputMapping()[i]!=null && meta.getInputMapping()[i].length()>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!meta.getInputField()[i].equals(meta.getInputMapping()[i])) // rename these!\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint idx = r.searchValueIndex(meta.getInputField()[i]);\n\t\t\t\t\t\t\tif (idx<0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlogError(\"Mapping target field [\"+meta.getInputField()[i]+\"] is not present in the input rows!\");\n\t\t\t\t\t\t\t\tsetErrors(1);\n\t\t\t\t\t\t\t\tstopAll();\n\t\t\t\t\t\t\t\tdata.trans.stopAll();\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdata.renameFieldIndexes.add(new Integer(idx));\n\t\t\t\t\t\t\tdata.renameFieldNames.add(meta.getInputMapping()[i]);\n\t\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(\"#\"+data.renameFieldIndexes.size()+\" : index=\"+i+\", new name=\"+meta.getInputMapping()[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlogError(\"Mapping target field #\"+i+\" is not specified for input [\"+meta.getInputField()[i]+\"]!\");\n\t\t\t\t\t\tsetErrors(1);\n\t\t\t\t\t\tstopAll();\n\t\t\t\t\t\tdata.trans.stopAll();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlogError(\"Input field #\"+i+\" is not specified!\");\n\t\t\t\t\tsetErrors(1);\n\t\t\t\t\tstopAll();\n\t\t\t\t\tdata.trans.stopAll();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} // end of first block\n\t\t\n\t\tfor (int i=0;i<data.renameFieldIndexes.size();i++)\n\t\t{\n\t\t\tint idx = ((Integer)data.renameFieldIndexes.get(i)).intValue();\n\t\t\tString newName = (String)data.renameFieldNames.get(i);\n\t\t\tr.getValue(idx).setName(newName);\n\t\t}\n\t\t\n        data.mappingInput.putRow(r);     // copy row to possible alternate rowset(s) in the mapping.\n        \n        if ((linesRead>0) && (linesRead%Const.ROWS_UPDATE)==0) logBasic(\"Linenr \"+linesRead);\n\n        //\n        // The problem now is to get a row back from the mapping...\n        // This transformed row we need to send to the next step.\n        // Well actually this is not done here but in the mapping output.  See init()\n        //\n\t\treturn true;\n\t}","commit_id":"38cb7824ef0129db944fdafaa58947e3759039ee","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void run()\n\t{\n\t\ttry\n\t\t{\n\t\t\tlogBasic(\"Starting to run...\");\n\t\t\twhile (processRow(meta, data) && !isStopped());\n            \n            // Close the running transformation\n            if (data.trans!=null)\n            {\n                // Wait until the child transformation has finished.\n                data.trans.waitUntilFinished();\n                \n                // store some logging, close shop.\n                data.trans.endProcessing(\"end\");\n            }\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tlogError(\"Unexpected error in '\"+debug+\"' : \"+e.toString());\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t}\n\t\tfinally\n\t\t{\n            \n\t\t\tdispose(meta, data);\n\t\t\tlogSummary();\n\t\t\tmarkStop();\n\t\t}\n\t}","id":28118,"modified_method":"public void run()\n\t{\n\t\ttry\n\t\t{\n\t\t\tlogBasic(\"Starting to run...\");\n\t\t\twhile (processRow(meta, data) && !isStopped());\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tlogError(\"Unexpected error in '\"+debug+\"' : \"+e.toString());\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t\tdata.trans.stopAll();\n\t\t}\n\t\tfinally\n\t\t{\n            // Close the running transformation\n            if (data.trans!=null)\n            {\n                // Wait until the child transformation has finished.\n                data.trans.waitUntilFinished();\n                \n                // store some logging, close shop.\n                try\n                {\n\t                data.trans.endProcessing(\"end\");\n                }\n                catch(KettleException e)\n                {\n                \tlog.logError(toString(), \"Unable to log end of transformation: \"+e.toString());\n                }\n                \n        \t\t// See if there was an error in the sub-transformation, in that case, flag error etc.\n        \t\tif (data.trans.getErrors()>0)\n        \t\t{\n        \t\t\tlogError(\"An error occurred in the sub-transformation, halting processing\");\n        \t\t\tsetErrors(1);\n        \t\t}\n            }\n            \n\t\t\tdispose(meta, data);\n\t\t\tlogSummary();\n\t\t\tmarkStop();\n\t\t}\n\t}","commit_id":"38cb7824ef0129db944fdafaa58947e3759039ee","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getInput()\n    {\n        // Get the fields from the mapping...\n        if (mappingTransMeta!=null)\n        {\n            StepMeta inputStepMeta  = mappingTransMeta.getMappingInputStep();\n            \n            if (inputStepMeta!=null)\n            {\n                MappingInputMeta mappingInputMeta = (MappingInputMeta) inputStepMeta.getStepMetaInterface();\n                \n                System.out.println(\"Getting input fields... (\"+mappingInputMeta.getFieldName().length+\")\");\n                for (int i=0;i<mappingInputMeta.getFieldName().length;i++)\n                {\n                    TableItem item = new TableItem(wInputFields.table, SWT.NONE);\n                    item.setText(2, mappingInputMeta.getFieldName()[i]);\n                }\n                \n                wInputFields.removeEmptyRows();\n                wInputFields.setRowNums();\n                wInputFields.optWidth(true);\n            }\n            else\n            {\n                MessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n                mb.setMessage(\"You need to add a MappingInput step to the selected mapping (sub-transformation)!\");\n                mb.setText(\"Sorry\");\n                mb.open();\n            }\n        }\n        else\n        {\n            MessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n            mb.setMessage(\"Sorry, no mapping is specified, I can't get the input fields!\");\n            mb.setText(\"Sorry\");\n            mb.open();\n        }\n    }","id":28119,"modified_method":"private void getInput()\n    {\n        // Get the fields from the mapping...\n        if (mappingTransMeta!=null)\n        {\n            StepMeta inputStepMeta  = mappingTransMeta.getMappingInputStep();\n            \n            if (inputStepMeta!=null)\n            {\n                MappingInputMeta mappingInputMeta = (MappingInputMeta) inputStepMeta.getStepMetaInterface();\n                \n                String[] source = mappingInputMeta.getFieldName();\n                \n                Row prev = null;\n                try\n                {\n                \tprev=transMeta.getPrevStepFields(stepname);\n                }\n                catch(KettleException e)\n                {\n                \tnew ErrorDialog(shell, props, \"Error getting previous fields\", \"There was an error getting the fields entering this step\", e);\n                }\n                \n                if (prev!=null)\n                {\n\t                String[] target = prev.getFieldNames();\n\t                \n\t                EnterMappingDialog dialog = new EnterMappingDialog(shell, source, target);\n\t                List mappings = dialog.open();\n\t                if (mappings!=null)\n\t                {\n\t                \tfor (int i=0;i<mappings.size();i++)\n\t                \t{\n\t                \t\tTableItem item = new TableItem(wInputFields.table, SWT.NONE);\n\t                \t\tSourceToTargetMapping mapping = (SourceToTargetMapping) mappings.get(i);\n\t                \t\titem.setText(2, mapping.getSourceString(source));\n\t                \t\titem.setText(1, mapping.getTargetString(target));\n\t                \t}\n\t                }\n                }\n                else\n                {\n\t                log.logDetailed(stepname, \"Getting input fields... (\"+source.length+\")\");\n\t                for (int i=0;i<source.length;i++)\n\t                {\n\t                    TableItem item = new TableItem(wInputFields.table, SWT.NONE);\n\t                    item.setText(2, source[i]);\n\t                }\n                }\n                wInputFields.removeEmptyRows();\n                wInputFields.setRowNums();\n                wInputFields.optWidth(true);\n            }\n            else\n            {\n                MessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n                mb.setMessage(\"You need to add a MappingInput step to the selected mapping (sub-transformation)!\");\n                mb.setText(\"Sorry\");\n                mb.open();\n            }\n        }\n        else\n        {\n            MessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n            mb.setMessage(\"Sorry, no mapping is specified, I can't get the input fields!\");\n            mb.setText(\"Sorry\");\n            mb.open();\n        }\n    }","commit_id":"38cb7824ef0129db944fdafaa58947e3759039ee","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getOutput()\n    {\n        // Get the fields from the mapping...\n        if (mappingTransMeta!=null)\n        {\n            StepMeta outputStepMeta  = mappingTransMeta.getMappingOutputStep();\n            \n            if (outputStepMeta!=null)\n            {\n                MappingOutputMeta mappingOutputMeta = (MappingOutputMeta) outputStepMeta.getStepMetaInterface();\n                System.out.println(\"Getting input fields... (\"+mappingOutputMeta.getFieldName().length+\")\");\n\n                for (int i=0;i<mappingOutputMeta.getFieldName().length;i++)\n                {\n                    if (mappingOutputMeta.getFieldAdded()[i]) // We can only map added fields!\n                    {\n                        TableItem item = new TableItem(wOutputFields.table, SWT.NONE);\n                        item.setText(1, mappingOutputMeta.getFieldName()[i]);\n                    }\n                }\n                \n                wOutputFields.removeEmptyRows();\n                wOutputFields.setRowNums();\n                wOutputFields.optWidth(true);\n            }\n            else\n            {\n                MessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n                mb.setMessage(\"You need to add a MappingOutput step to the selected mapping (sub-transformation)!\");\n                mb.setText(\"Sorry\");\n                mb.open();\n            }\n        }\n        else\n        {\n            MessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n            mb.setMessage(\"Sorry, no mapping is specified, I can't get the output fields!\");\n            mb.setText(\"Sorry\");\n            mb.open();\n        }\n    }","id":28120,"modified_method":"private void getOutput()\n    {\n        // Get the fields from the mapping...\n        if (mappingTransMeta!=null)\n        {\n            StepMeta outputStepMeta  = mappingTransMeta.getMappingOutputStep();\n            \n            if (outputStepMeta!=null)\n            {\n                MappingOutputMeta mappingOutputMeta = (MappingOutputMeta) outputStepMeta.getStepMetaInterface();\n                System.out.println(\"Getting input fields... (\"+mappingOutputMeta.getFieldName().length+\")\");\n\n                for (int i=0;i<mappingOutputMeta.getFieldName().length;i++)\n                {\n                    if (mappingOutputMeta.getFieldAdded()[i]) // We can only map added fields!\n                    {\n                        TableItem item = new TableItem(wOutputFields.table, SWT.NONE);\n                        item.setText(1, mappingOutputMeta.getFieldName()[i]);\n                        item.setText(2, mappingOutputMeta.getFieldName()[i]);\n                    }\n                }\n                \n                wOutputFields.removeEmptyRows();\n                wOutputFields.setRowNums();\n                wOutputFields.optWidth(true);\n            }\n            else\n            {\n                MessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n                mb.setMessage(\"You need to add a MappingOutput step to the selected mapping (sub-transformation)!\");\n                mb.setText(\"Sorry\");\n                mb.open();\n            }\n        }\n        else\n        {\n            MessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n            mb.setMessage(\"Sorry, no mapping is specified, I can't get the output fields!\");\n            mb.setText(\"Sorry\");\n            mb.open();\n        }\n    }","commit_id":"38cb7824ef0129db944fdafaa58947e3759039ee","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void check(ArrayList remarks, StepMeta stepinfo, Row prev, String input[], String output[], Row info)\n\t{\n\t\tCheckResult cr;\n\t\tif (prev==null || prev.size()==0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_WARNING, \"Not receiving any fields from previous steps!\", stepinfo);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"Step is connected to previous one, receiving \"+prev.size()+\" fields\", stepinfo);\n\t\t\tremarks.add(cr);\n\t\t}\n\n        // See if we have input streams leading to this step!\n        if (mappingTransMeta!=null)\n        {\n            cr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"A mapping (transformation) is specified.\", stepinfo);\n            remarks.add(cr);\n        }\n        else\n        {\n            cr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"No mapping is specified!\", stepinfo);\n            remarks.add(cr);\n        }\n\n\t\t// See if we have input streams leading to this step!\n\t\tif (input.length>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"Step is receiving info from other steps.\", stepinfo);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"No input received from other steps!\", stepinfo);\n\t\t\tremarks.add(cr);\n\t\t}\n        \n        // TODO: add code for mapping translation, verify correctness.\n\t}","id":28121,"modified_method":"public void check(ArrayList remarks, StepMeta stepinfo, Row prev, String input[], String output[], Row info)\n\t{\n\t\tCheckResult cr;\n\t\tif (prev==null || prev.size()==0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_WARNING, \"Not receiving any fields from previous steps!\", stepinfo);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"Step is connected to previous one, receiving \"+prev.size()+\" fields\", stepinfo);\n\t\t\tremarks.add(cr);\n\t\t}\n\n\t\t// See if we have input streams leading to this step!\n\t\tif (input.length>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"Step is receiving info from other steps.\", stepinfo);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"No input received from other steps!\", stepinfo);\n\t\t\tremarks.add(cr);\n\t\t}\n        \n    \t// Change the names of the fields if this is required by the mapping.\n    \tfor (int i=0;i<inputField.length;i++)\n\t\t{\n\t\t\tif (inputField[i]!=null && inputField[i].length()>0)\n\t\t\t{\n\t\t\t\tif (inputMapping[i]!=null && inputMapping[i].length()>0)\n\t\t\t\t{\n\t\t\t\t\tif (!inputField[i].equals(inputMapping[i])) // rename these!\n\t\t\t\t\t{\n\t\t\t\t\t\tint idx = prev.searchValueIndex(inputField[i]);\n\t\t\t\t\t\tif (idx<0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"Mapping target field [\"+inputField[i]+\"] is not present in the input rows!\", stepinfo);\n\t\t\t\t\t\t\tremarks.add(cr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"Mapping target field #\"+i+\" is not specified for input [\"+inputField[i]+\"]!\", stepinfo);\n\t\t\t\t\tremarks.add(cr);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"Input field #\"+i+\" is not specified!\", stepinfo);\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t}\n\n    \t// Then check the fields that get added to the row.\n    \t// \n        if (mappingTransMeta!=null)\n        {\n            cr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"A mapping (transformation) is specified.\", stepinfo);\n            remarks.add(cr);\n\n            StepMeta stepMeta = mappingTransMeta.getMappingOutputStep();\n            \n            if (stepMeta!=null)\n            {\n\t            // See which fields are coming out of the mapping output step of the sub-transformation\n\t            // For these fields we check the existance\n\t            //\n\t            Row fields = null;\n\t            try\n\t            {\n\t            \tfields = mappingTransMeta.getStepFields(stepMeta);\n\t\n\t            \tboolean allOK = true;\n\t                \n\t                // Check the fields...\n\t                for (int i=0;i<outputMapping.length;i++)\n\t                {\n\t                    Value v = fields.searchValue(outputMapping[i]);\n\t                    if (v==null) // Not found!\n\t                    {\n\t                        cr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"Mapping output field specified couldn't be found in the mapping: \"+outputMapping[i], stepinfo);\n\t                        remarks.add(cr);\n\t                        allOK=false;\n\t                    }\n\t                }\n\t                \n\t                if (allOK)\n\t                {\n\t                    cr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"All output mapping fields could be found in the mapping.\", stepinfo);\n\t                    remarks.add(cr);\n\t                }\n\t            }\n\t            catch(KettleStepException e)\n\t            {\n\t                cr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"Unable to get the step output fields for mapping output step [\"+stepMeta.getName()+\"]\", stepinfo);\n\t                remarks.add(cr);\n\t            }\n            }\n            else\n            {\n                cr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"No mapping output step was specified in the mapping!\", stepinfo);\n                remarks.add(cr);\n            }\n        }\n        else\n        {\n            cr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"There is no mapping specified!\", stepinfo);\n            remarks.add(cr);\n        }\n\t}","commit_id":"38cb7824ef0129db944fdafaa58947e3759039ee","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, long id_transformation, long id_step) throws KettleException\n    {\n        if (mappingTransMeta!=null)\n        {\n            if (mappingTransMeta.getFilename()!=null)\n            {\n                rep.saveStepAttribute(id_transformation, id_step, \"filename\", mappingTransMeta.getFilename());\n            }\n            else\n            {\n                rep.saveStepAttribute(id_transformation, id_step, \"trans_name\", mappingTransMeta.getName());\n                if (mappingTransMeta.getDirectory()!=null)\n                {\n                    rep.saveStepAttribute(id_transformation, id_step, \"directory_path\", mappingTransMeta.getDirectory().getPath());\n                }\n            }\n        }\n        \n        for (int i=0;i<inputField.length;i++)\n        {\n            rep.saveStepAttribute(id_transformation, id_step, i, \"input_field\",   inputField[i]);\n            rep.saveStepAttribute(id_transformation, id_step, i, \"input_mapping\", inputMapping[i]);\n        }\n        \n        for (int i=0;i<outputField.length;i++)\n        {\n            rep.saveStepAttribute(id_transformation, id_step, i, \"output_field\",   outputField[i]);\n            rep.saveStepAttribute(id_transformation, id_step, i, \"output_mapping\", outputMapping[i]);\n        }\n    }","id":28122,"modified_method":"public void saveRep(Repository rep, long id_transformation, long id_step) throws KettleException\n    {\n        if (mappingTransMeta!=null)\n        {\n            if (mappingTransMeta.getFilename()!=null)\n            {\n                rep.saveStepAttribute(id_transformation, id_step, \"filename\", mappingTransMeta.getFilename());\n            }\n            else\n            {\n                rep.saveStepAttribute(id_transformation, id_step, \"trans_name\", mappingTransMeta.getName());\n                if (mappingTransMeta.getDirectory()!=null)\n                {\n                    rep.saveStepAttribute(id_transformation, id_step, \"directory_path\", mappingTransMeta.getDirectory().getPath());\n                }\n            }\n        }\n        \n        if (inputField!=null)\n        for (int i=0;i<inputField.length;i++)\n        {\n            rep.saveStepAttribute(id_transformation, id_step, i, \"input_field\",   inputField[i]);\n            rep.saveStepAttribute(id_transformation, id_step, i, \"input_mapping\", inputMapping[i]);\n        }\n        \n        if (outputField!=null)\n        for (int i=0;i<outputField.length;i++)\n        {\n            rep.saveStepAttribute(id_transformation, id_step, i, \"output_field\",   outputField[i]);\n            rep.saveStepAttribute(id_transformation, id_step, i, \"output_mapping\", outputMapping[i]);\n        }\n    }","commit_id":"38cb7824ef0129db944fdafaa58947e3759039ee","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Row getFields(Row r, String name, Row info) throws KettleStepException\n    {\n        if (mappingTransMeta!=null)\n        {\n            StepMeta stepMeta = mappingTransMeta.getMappingOutputStep();\n            \n            stepMeta.getStepMetaInterface().getFields(r, name, info);\n\n            // Change the output fields that are specified...\n            for (int i=0;i<outputMapping.length;i++)\n            {\n                Value v = r.searchValue(outputMapping[i]);\n                if (v!=null)\n                {\n                    v.setName(outputField[i]);\n                    v.setOrigin(name);\n                }\n                else\n                {\n                    throw new KettleStepException(\"Mapping output field specified couldn't be found: \"+outputMapping[i]);\n                }\n            }\n            \n            return r;\n        }\n        else\n        {\n            throw new KettleStepException(\"Unable to get fields from Mapping: no mapping is selected.\");\n        }\n    }","id":28123,"modified_method":"public Row getFields(Row r, String name, Row info) throws KettleStepException\n    {\n    \t// Change the names of the fields if this is required by the mapping.\n    \tfor (int i=0;i<inputField.length;i++)\n\t\t{\n\t\t\tif (inputField[i]!=null && inputField[i].length()>0)\n\t\t\t{\n\t\t\t\tif (inputMapping[i]!=null && inputMapping[i].length()>0)\n\t\t\t\t{\n\t\t\t\t\tif (!inputField[i].equals(inputMapping[i])) // rename these!\n\t\t\t\t\t{\n\t\t\t\t\t\tint idx = r.searchValueIndex(inputField[i]);\n\t\t\t\t\t\tif (idx<0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new KettleStepException(\"Mapping target field [\"+inputField[i]+\"] is not present in the input rows!\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr.getValue(idx).setName(inputMapping[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthrow new KettleStepException(\"Mapping target field #\"+i+\" is not specified for input [\"+inputField[i]+\"]!\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(\"Input field #\"+i+\" is not specified!\");\n\t\t\t}\n\t\t}\n\n    \t// Then see which fields get added to the row.\n    \t// \n        if (mappingTransMeta!=null)\n        {\n            StepMeta stepMeta = mappingTransMeta.getMappingOutputStep();\n            \n            stepMeta.getStepMetaInterface().getFields(r, name, info);\n\n            // Change the output fields that are specified...\n            for (int i=0;i<outputMapping.length;i++)\n            {\n                Value v = r.searchValue(outputMapping[i]);\n                if (v!=null)\n                {\n                    v.setName(outputField[i]);\n                    v.setOrigin(name);\n                }\n                else\n                {\n                    throw new KettleStepException(\"Mapping output field specified couldn't be found: \"+outputMapping[i]);\n                }\n            }\n            \n            return r;\n        }\n        else\n        {\n            throw new KettleStepException(\"Unable to get fields from Mapping: no mapping is selected.\");\n        }\n    }","commit_id":"38cb7824ef0129db944fdafaa58947e3759039ee","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public synchronized void setConnectorStep(Mapping mapping)\n    {\n        data.mapping = mapping;\n    }","id":28124,"modified_method":"public void setConnectorStep(Mapping mapping)\n    {\n        data.mapping = mapping;\n    }","commit_id":"38cb7824ef0129db944fdafaa58947e3759039ee","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(SetVariableMeta)smi;\n\t\tdata=(SetVariableData)sdi;\n\t\t\n\t    // Get one row from one of the rowsets...\n        //\n\t\tObject[] rowData = getRow();\n\t\tif (rowData==null)  // means: no more input to be expected...\n\t\t{\n            logBasic(\"Finished after \"+linesWritten+\" rows.\");\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (first)\n\t\t{\n\t\t    first=false;\n\t\t    \n\t\t    data.outputMeta = getInputRowMeta().clone();\n            \n            logBasic(\"Setting environment variables...\");\n\n            for (int i=0;i<meta.getFieldName().length;i++)\n            {\n                // Set the appropriate environment variable\r\n            \t//\r\n            \tint index = data.outputMeta.indexOfValue(meta.getFieldName()[i]);\r\n            \tif (index<0)\r\n            \t{\r\n            \t\tthrow new KettleException(\"Unable to find field [\"+meta.getFieldName()[i]+\"] in input row\");\r\n            \t}\r\n            \tValueMetaInterface valueMeta = data.outputMeta.getValueMeta(index);\r\n            \tObject valueData = rowData[index];\r\n            \t\n            \tString value = valueMeta.getCompatibleString(valueData);\r\n            \tif (value==null) value=\"\";\n                \n                String varname = meta.getVariableName()[i];\n                \n                if (Const.isEmpty(varname))\n                {\n                    if (Const.isEmpty(value))\n                    {\n                        throw new KettleException(\"Variable name nor value was specified on line #\"+(i+1));\n                    }\n                    else\n                    {\n                        throw new KettleException(\"There was no variable name specified for value [\"+value+\"]\");\n                    }\n                }\n                \r\n                VariableSpace transVariableSpace = null;\r\n                Job parentJob = null;\n                // OK, where do we set this value...\n                switch(meta.getVariableType()[i])\n                {\n                case SetVariableMeta.VARIABLE_TYPE_JVM: \n                    System.setProperty(varname, value);\r\n                    \r\n                    setVariable(varname, value);\r\n\r\n                    // Set variable in the transformation\r\n                    //\r\n                    transVariableSpace = getTrans();  \r\n                    transVariableSpace.setVariable(varname, value);\r\n\r\n                    parentJob = getTrans().getParentJob();\r\n                    while (parentJob!=null)\r\n                    {                           \r\n                        parentJob.setVariable(varname, value);\r\n                        parentJob = parentJob.getParentJob();\r\n                    }\r\n                    \n                    break;\n                case SetVariableMeta.VARIABLE_TYPE_ROOT_JOB:\n                    {\n                        setVariable(varname, value);\n\n                        // Set variable in the transformation\n                        //\n                        transVariableSpace = getTrans();  \n                        transVariableSpace.setVariable(varname, value);\n\r\n                        // Comments by SB\n                        // VariableSpace rootJob = null;\n                        parentJob = getTrans().getParentJob();\n                        while (parentJob!=null)\n                        {                           \n                            parentJob.setVariable(varname, value);\n                            //rootJob = parentJob;\n                            parentJob = parentJob.getParentJob();\n                        }\n                        // OK, we have the rootjob, set the variable on it...\n                        //if (rootJob==null)\n                        //{\n                        //   throw new KettleStepException(\"Can't set variable [\"+varname+\"] on root job: the root job is not available (meaning: not even the parent job)\");\n                        //}\r\n                        //  Comment: why throw an exception on this?\n                    }\n                    break;\n                case SetVariableMeta.VARIABLE_TYPE_GRAND_PARENT_JOB:\n                    {\n                    \t// Set variable in this step\n                    \t//\n                        setVariable(varname, value); \n                        \n                        // Set variable in the transformation\n                        //\n                        transVariableSpace = getTrans();  \n                        transVariableSpace.setVariable(varname, value);\n                        \n                        // Set the variable in the parent job \n                        //\n                        parentJob = getTrans().getParentJob();\n                        if (parentJob!=null)\n                        {\n                        \tparentJob.setVariable(varname, value);\n                        }\n                        else\n                        {\n                        \tthrow new KettleStepException(\"Can't set variable [\"+varname+\"] on parent job: the parent job is not available\");\n                        }\n\n                        // Set the variable on the grand-parent job\n                        //\n                        VariableSpace gpJob = getTrans().getParentJob().getParentJob();\n                        if (gpJob!=null)\n                        {\n                            gpJob.setVariable(varname, value);\n                        }\n                        else\n                        {\n                            throw new KettleStepException(\"Can't set variable [\"+varname+\"] on grand parent job: the grand parent job is not available\");\n                        }\n                        \n                    }\n                case SetVariableMeta.VARIABLE_TYPE_PARENT_JOB:\n                    {                        \n                    \t// Set variable in this step\n                    \t//\n                        setVariable(varname, value); \n                        \n                        // Set variable in the transformation\n                        //\n                        transVariableSpace = getTrans();  \n                        transVariableSpace.setVariable(varname, value);\n                        \n                        // Set the variable in the parent job \n                        //\n                        parentJob = getTrans().getParentJob();\n                        if (parentJob!=null)\n                        {\n                        \tparentJob.setVariable(varname, value);\n                        }\n                        else\n                        {\n                        \tthrow new KettleStepException(\"Can't set variable [\"+varname+\"] on parent job: the parent job is not available\");\n                        }\n                    }\n                }               \n                \n                logBasic(\"Set variable \"+meta.getVariableName()[i]+\" to value [\"+value+\"]\");\n            }\n            \n            putRow(data.outputMeta, rowData);\n            return true;\t\t}\n\n        throw new KettleStepException(Messages.getString(\"SetVariable.RuntimeError.MoreThanOneRowReceived.SETVARIABLE0007\"));\n\t}","id":28125,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(SetVariableMeta)smi;\n\t\tdata=(SetVariableData)sdi;\n\t\t\n\t    // Get one row from one of the rowsets...\n        //\n\t\tObject[] rowData = getRow();\n\t\tif (rowData==null)  // means: no more input to be expected...\n\t\t{\r\n\t\t\tif (first)\r\n\t\t\t{\r\n\t\t\t\t// We do not received any row !!\r\n\t\t\t\tlogBasic(Messages.getString(\"SetVariable.Log.NoInputRowSetDefault\"));\r\n\t\t\t\tfor (int i=0;i<meta.getFieldName().length;i++)\r\n\t\t        {\r\n\t\t\t\t\tif(!Const.isEmpty(meta.getDefaultValue()[i])) setValue(rowData,i,true); \r\n\t\t        }\r\n\t\t\t}\r\n\t\t\n            logBasic(\"Finished after \"+linesWritten+\" rows.\");\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (first)\n\t\t{\n\t\t    first=false;\n\t\t    \n\t\t    data.outputMeta = getInputRowMeta().clone();\n            \n            logBasic(Messages.getString(\"SetVariable.Log.SettingVar\"));\r\n\r\n            for (int i=0;i<meta.getFieldName().length;i++)\r\n            {\r\n            \tsetValue(rowData,i,false);  \r\n            }\n           \n            putRow(data.outputMeta, rowData);\n            return true;\t\t\r\n         }\n\n        throw new KettleStepException(Messages.getString(\"SetVariable.RuntimeError.MoreThanOneRowReceived.SETVARIABLE0007\"));\n\t}","commit_id":"0144ebfd18649a7b85849e0129f3cec7cf4ff923","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tNode fields = XMLHandler.getSubNode(stepnode, \"fields\"); //$NON-NLS-1$\n\t\t\tint count= XMLHandler.countNodes(fields, \"field\"); //$NON-NLS-1$\n\t\t\t\n\t\t\tallocate(count);\n\t\t\t\t\t\n\t\t\tfor (int i=0;i<count;i++)\n\t\t\t{\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i); //$NON-NLS-1$\n\t\t\t\t\n\t\t\t\tfieldName[i]  = XMLHandler.getTagValue(fnode, \"field_name\"); //$NON-NLS-1$\n\t\t\t\tvariableName[i] = XMLHandler.getTagValue(fnode, \"variable_name\"); //$NON-NLS-1$\n                variableType[i] = getVariableType(XMLHandler.getTagValue(fnode, \"variable_type\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(Messages.getString(\"SetVariableMeta.RuntimeError.UnableToReadXML.SETVARIABLE0004\"), e); //$NON-NLS-1$\n\t\t}\n\t}","id":28126,"modified_method":"private void readData(Node stepnode)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tNode fields = XMLHandler.getSubNode(stepnode, \"fields\"); //$NON-NLS-1$\n\t\t\tint count= XMLHandler.countNodes(fields, \"field\"); //$NON-NLS-1$\n\t\t\t\n\t\t\tallocate(count);\n\t\t\t\t\t\n\t\t\tfor (int i=0;i<count;i++)\n\t\t\t{\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i); //$NON-NLS-1$\n\t\t\t\t\n\t\t\t\tfieldName[i]  = XMLHandler.getTagValue(fnode, \"field_name\"); //$NON-NLS-1$\n\t\t\t\tvariableName[i] = XMLHandler.getTagValue(fnode, \"variable_name\"); //$NON-NLS-1$\n                variableType[i] = getVariableType(XMLHandler.getTagValue(fnode, \"variable_type\")); //$NON-NLS-1$\r\n                defaultValue[i]  = XMLHandler.getTagValue(fnode, \"default_value\"); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(Messages.getString(\"SetVariableMeta.RuntimeError.UnableToReadXML.SETVARIABLE0004\"), e); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"0144ebfd18649a7b85849e0129f3cec7cf4ff923","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, long id_step, List<DatabaseMeta> databases, Map<String, Counter> counters)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tint nrfields = rep.countNrStepAttributes(id_step, \"field_name\"); //$NON-NLS-1$\n\t\t\t\n\t\t\tallocate(nrfields);\n\t\n\t\t\tfor (int i=0;i<nrfields;i++)\n\t\t\t{\n\t\t\t\tfieldName[i] =          rep.getStepAttributeString(id_step, i, \"field_name\"); //$NON-NLS-1$\n\t\t\t\tvariableName[i] = \t\trep.getStepAttributeString(id_step, i, \"variable_name\"); //$NON-NLS-1$\n                variableType[i] = getVariableType(rep.getStepAttributeString(id_step, i, \"variable_type\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"SetVariableMeta.RuntimeError.UnableToReadRepository.SETVARIABLE0005\"), e); //$NON-NLS-1$\n\t\t}\n\t}","id":28127,"modified_method":"public void readRep(Repository rep, long id_step, List<DatabaseMeta> databases, Map<String, Counter> counters)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tint nrfields = rep.countNrStepAttributes(id_step, \"field_name\"); //$NON-NLS-1$\n\t\t\t\n\t\t\tallocate(nrfields);\n\t\n\t\t\tfor (int i=0;i<nrfields;i++)\n\t\t\t{\n\t\t\t\tfieldName[i] =          rep.getStepAttributeString(id_step, i, \"field_name\"); //$NON-NLS-1$\n\t\t\t\tvariableName[i] = \t\trep.getStepAttributeString(id_step, i, \"variable_name\"); //$NON-NLS-1$\n                variableType[i] = getVariableType(rep.getStepAttributeString(id_step, i, \"variable_type\")); //$NON-NLS-1$\n                defaultValue[i] = \t\trep.getStepAttributeString(id_step, i, \"default_value\");\r\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"SetVariableMeta.RuntimeError.UnableToReadRepository.SETVARIABLE0005\"), e); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"0144ebfd18649a7b85849e0129f3cec7cf4ff923","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\n\t{\n        StringBuffer retval = new StringBuffer(150);\n\n\t\tretval.append(\"    <fields>\").append(Const.CR); //$NON-NLS-1$\n\t\t\n\t\tfor (int i=0;i<fieldName.length;i++)\n\t\t{\n\t\t\tretval.append(\"      <field>\").append(Const.CR); //$NON-NLS-1$\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"field_name\", fieldName[i])); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"variable_name\", variableName[i])); //$NON-NLS-1$ //$NON-NLS-2$\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"variable_type\", getVariableTypeCode(variableType[i]))); //$NON-NLS-1$\n\t\t\tretval.append(\"        <\/field>\").append(Const.CR); //$NON-NLS-1$\n\t\t}\n\t\tretval.append(\"      <\/fields>\").append(Const.CR); //$NON-NLS-1$\n\n\t\treturn retval.toString();\n\t}","id":28128,"modified_method":"public String getXML()\n\t{\n        StringBuffer retval = new StringBuffer(150);\n\n\t\tretval.append(\"    <fields>\").append(Const.CR); //$NON-NLS-1$\n\t\t\n\t\tfor (int i=0;i<fieldName.length;i++)\n\t\t{\n\t\t\tretval.append(\"      <field>\").append(Const.CR); //$NON-NLS-1$\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"field_name\", fieldName[i])); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"variable_name\", variableName[i])); //$NON-NLS-1$ //$NON-NLS-2$\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"variable_type\", getVariableTypeCode(variableType[i]))); //$NON-NLS-1$\n            retval.append(\"        \").append(XMLHandler.addTagValue(\"default_value\", defaultValue[i]));\r\n            retval.append(\"        <\/field>\").append(Const.CR); //$NON-NLS-1$\n\t\t}\n\t\tretval.append(\"      <\/fields>\").append(Const.CR); //$NON-NLS-1$\n\n\t\treturn retval.toString();\n\t}","commit_id":"0144ebfd18649a7b85849e0129f3cec7cf4ff923","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDefault()\n\t{\n\t\tint count=0;\n\t\t\n\t\tallocate(count);\n\n\t\tfor (int i=0;i<count;i++)\n\t\t{\n\t\t\tfieldName[i] = \"field\"+i; //$NON-NLS-1$\n\t\t\tvariableName[i] = \"\"; //$NON-NLS-1$\n            variableType[i] = VARIABLE_TYPE_JVM;\n\t\t}\n\t}","id":28129,"modified_method":"public void setDefault()\n\t{\n\t\tint count=0;\n\t\t\n\t\tallocate(count);\n\n\t\tfor (int i=0;i<count;i++)\n\t\t{\n\t\t\tfieldName[i] = \"field\"+i; //$NON-NLS-1$\n\t\t\tvariableName[i] = \"\"; //$NON-NLS-1$\n            variableType[i] = VARIABLE_TYPE_JVM;\r\n            defaultValue[i]=\"\";\n\t\t}\n\t}","commit_id":"0144ebfd18649a7b85849e0129f3cec7cf4ff923","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, long id_transformation, long id_step)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tfor (int i=0;i<fieldName.length;i++)\n\t\t\t{\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",      fieldName[i]); //$NON-NLS-1$\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"variable_name\",     variableName[i]); //$NON-NLS-1$\n                rep.saveStepAttribute(id_transformation, id_step, i, \"variable_type\",   getVariableTypeCode(variableType[i])); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"SetVariableMeta.RuntimeError.UnableToSaveRepository.SETVARIABLE0006\", \"\"+id_step), e); //$NON-NLS-1$\n\t\t}\n\n\t}","id":28130,"modified_method":"public void saveRep(Repository rep, long id_transformation, long id_step)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tfor (int i=0;i<fieldName.length;i++)\n\t\t\t{\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",      fieldName[i]); //$NON-NLS-1$\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"variable_name\",     variableName[i]); //$NON-NLS-1$\n                rep.saveStepAttribute(id_transformation, id_step, i, \"variable_type\",   getVariableTypeCode(variableType[i])); //$NON-NLS-1$\n                rep.saveStepAttribute(id_transformation, id_step, i, \"default_value\",     defaultValue[i]);\r\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"SetVariableMeta.RuntimeError.UnableToSaveRepository.SETVARIABLE0006\", \"\"+id_step), e); //$NON-NLS-1$\n\t\t}\n\n\t}","commit_id":"0144ebfd18649a7b85849e0129f3cec7cf4ff923","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void allocate(int count)\n\t{\n\t\tfieldName  = new String[count];\n\t\tvariableName = new String[count];\n        variableType = new int[count];\n\t}","id":28131,"modified_method":"public void allocate(int count)\n\t{\n\t\tfieldName  = new String[count];\n\t\tvariableName = new String[count];\n        variableType = new int[count];\r\n        defaultValue  = new String[count];\n\t}","commit_id":"0144ebfd18649a7b85849e0129f3cec7cf4ff923","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    protected void releaseMBeanServers() {\n        List<MBeanServer> servers =\n            (List<MBeanServer>)MBeanServerFactory.findMBeanServer(null);\n\n        for (MBeanServer server : servers) {\n            MBeanServerFactory.releaseMBeanServer(server);\n        }\n    }","id":28132,"modified_method":"@SuppressWarnings(\"unchecked\")\n    protected void releaseMBeanServers() {\n        List<MBeanServer> servers = MBeanServerFactory.findMBeanServer(null);\n\n        for (MBeanServer server : servers) {\n            MBeanServerFactory.releaseMBeanServer(server);\n        }\n    }","commit_id":"56f33d66dfe1c3c48d3917795fa72c0cf9f05b80","url":"https://github.com/apache/camel"},{"original_method":"public void testQueryMbeans() throws Exception {\n        assertEquals(1, mbsc.queryNames(new ObjectName(\"org.apache.camel\" + \":type=routes,*\"), null).size());\n        assertEquals(1, mbsc.queryNames(new ObjectName(\"org.apache.camel\" + \":type=processors,*\"), null).size());\n    }","id":28133,"modified_method":"public void testQueryMbeans() throws Exception {\n        int routes = mbsc.queryNames(new ObjectName(\"org.apache.camel\" + \":type=routes,*\"), null).size();\n        int processors = mbsc.queryNames(new ObjectName(\"org.apache.camel\" + \":type=processors,*\"), null).size();\n\n        assertTrue(\"Should contain routes\", routes > 0);\n        assertTrue(\"Should contain processors\", processors > 0);\n    }","commit_id":"56f33d66dfe1c3c48d3917795fa72c0cf9f05b80","url":"https://github.com/apache/camel"},{"original_method":"protected void verifyCounter(MBeanServerConnection beanServer, ObjectName name) throws Exception {\n        Set<ObjectName> s = beanServer.queryNames(name, null);\n        assertEquals(\"Found mbeans: \" + s, 1, s.size());\n\n        Iterator<ObjectName> iter = s.iterator();\n        ObjectName pcob = (ObjectName)iter.next();\n\n        Long valueofNumExchanges = (Long)beanServer.getAttribute(pcob, \"ExchangesTotal\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            valueofNumExchanges);\n        assertEquals(Long.valueOf(1), valueofNumExchanges);\n\n        Long valueofNumCompleted = (Long)beanServer.getAttribute(pcob, \"ExchangesCompleted\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            valueofNumCompleted);\n        assertEquals(Long.valueOf(1), valueofNumCompleted);\n\n        Long valueofNumFailed = (Long)beanServer.getAttribute(pcob, \"ExchangesFailed\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            valueofNumFailed);\n        assertEquals(Long.valueOf(0), valueofNumFailed);\n\n        Long valueofMinProcessingTime = (Long)beanServer.getAttribute(pcob, \"MinProcessingTime\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            valueofMinProcessingTime);\n        assertTrue(valueofMinProcessingTime >= 0);\n\n        Long valueofMaxProcessingTime = (Long)beanServer.getAttribute(pcob, \"MaxProcessingTime\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            valueofMaxProcessingTime);\n        assertTrue(valueofMaxProcessingTime >= 0);\n\n        Long valueofMeanProcessingTime = (Long)beanServer.getAttribute(pcob, \"MeanProcessingTime\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            valueofMeanProcessingTime);\n        assertTrue(valueofMeanProcessingTime >= valueofMinProcessingTime\n            && valueofMeanProcessingTime <= valueofMaxProcessingTime);\n\n        Long totalProcessingTime = (Long)beanServer.getAttribute(pcob, \"TotalProcessingTime\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            totalProcessingTime);\n        assertTrue(totalProcessingTime >= 0);\n\n        Long lastProcessingTime = (Long)beanServer.getAttribute(pcob, \"LastProcessingTime\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            lastProcessingTime);\n        assertTrue(lastProcessingTime >= 0);\n\n        assertNotNull(\"Expected first completion time to be available\",\n            beanServer.getAttribute(pcob, \"FirstExchangeCompletedTimestamp\"));\n\n        assertNotNull(\"Expected last completion time to be available\",\n            beanServer.getAttribute(pcob, \"LastExchangeCompletedTimestamp\"));\n    }","id":28134,"modified_method":"protected void verifyCounter(MBeanServerConnection beanServer, ObjectName name) throws Exception {\n        Set<ObjectName> s = beanServer.queryNames(name, null);\n        assertEquals(\"Found mbeans: \" + s, 1, s.size());\n\n        Iterator<ObjectName> iter = s.iterator();\n        ObjectName pcob = iter.next();\n\n        Long valueofNumExchanges = (Long)beanServer.getAttribute(pcob, \"ExchangesTotal\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            valueofNumExchanges);\n        assertEquals(Long.valueOf(1), valueofNumExchanges);\n\n        Long valueofNumCompleted = (Long)beanServer.getAttribute(pcob, \"ExchangesCompleted\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            valueofNumCompleted);\n        assertEquals(Long.valueOf(1), valueofNumCompleted);\n\n        Long valueofNumFailed = (Long)beanServer.getAttribute(pcob, \"ExchangesFailed\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            valueofNumFailed);\n        assertEquals(Long.valueOf(0), valueofNumFailed);\n\n        Long valueofMinProcessingTime = (Long)beanServer.getAttribute(pcob, \"MinProcessingTime\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            valueofMinProcessingTime);\n        assertTrue(valueofMinProcessingTime >= 0);\n\n        Long valueofMaxProcessingTime = (Long)beanServer.getAttribute(pcob, \"MaxProcessingTime\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            valueofMaxProcessingTime);\n        assertTrue(valueofMaxProcessingTime >= 0);\n\n        Long valueofMeanProcessingTime = (Long)beanServer.getAttribute(pcob, \"MeanProcessingTime\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            valueofMeanProcessingTime);\n        assertTrue(valueofMeanProcessingTime >= valueofMinProcessingTime\n            && valueofMeanProcessingTime <= valueofMaxProcessingTime);\n\n        Long totalProcessingTime = (Long)beanServer.getAttribute(pcob, \"TotalProcessingTime\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            totalProcessingTime);\n        assertTrue(totalProcessingTime >= 0);\n\n        Long lastProcessingTime = (Long)beanServer.getAttribute(pcob, \"LastProcessingTime\");\n        assertNotNull(\"Expected attribute found. MBean registered under a \"\n            + \"'<domain>:name=Stats,*' key must be of type PerformanceCounter.class\",\n            lastProcessingTime);\n        assertTrue(lastProcessingTime >= 0);\n\n        assertNotNull(\"Expected first completion time to be available\",\n            beanServer.getAttribute(pcob, \"FirstExchangeCompletedTimestamp\"));\n\n        assertNotNull(\"Expected last completion time to be available\",\n            beanServer.getAttribute(pcob, \"LastExchangeCompletedTimestamp\"));\n    }","commit_id":"56f33d66dfe1c3c48d3917795fa72c0cf9f05b80","url":"https://github.com/apache/camel"},{"original_method":"protected void releaseMBeanServers() {\n        for (MBeanServer server : (List<MBeanServer>)MBeanServerFactory.findMBeanServer(null)) {\n            MBeanServerFactory.releaseMBeanServer(server);\n        }\n    }","id":28135,"modified_method":"protected void releaseMBeanServers() {\n        for (MBeanServer server : MBeanServerFactory.findMBeanServer(null)) {\n            MBeanServerFactory.releaseMBeanServer(server);\n        }\n    }","commit_id":"56f33d66dfe1c3c48d3917795fa72c0cf9f05b80","url":"https://github.com/apache/camel"},{"original_method":"/**\n\t * @see org.apache.wicket.IInitializer#init(org.apache.wicket.Application)\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void init(org.apache.wicket.Application application)\n\t{\n\t\ttry\n\t\t{\n\t\t\tString name = application.getName();\n\n\t\t\tString agentId = System.getProperty(\"wicket.mbean.server.agentid\");\n\t\t\tif (agentId != null)\n\t\t\t{\n\t\t\t\tArrayList<MBeanServer> mbeanServers = (ArrayList<MBeanServer>)MBeanServerFactory\n\t\t\t\t\t\t.findMBeanServer(agentId);\n\t\t\t\tif (!mbeanServers.isEmpty())\n\t\t\t\t{\n\t\t\t\t\tmbeanServer = mbeanServers.get(0); // get first\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlog.error(\"unable to find mbean server with agent id \" + agentId);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mbeanServer == null)\n\t\t\t{\n\t\t\t\tString impl = System.getProperty(\"wicket.mbean.server.class\");\n\t\t\t\tif (impl != null)\n\t\t\t\t{\n\t\t\t\t\tArrayList<MBeanServer> mbeanServers = (ArrayList<MBeanServer>)MBeanServerFactory\n\t\t\t\t\t\t\t.findMBeanServer(null);\n\t\t\t\t\tif (!mbeanServers.isEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (MBeanServer mbs : mbeanServers)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (mbs.getClass().getName().equals(impl))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmbeanServer = mbs;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (mbeanServer == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.error(\"unable to find mbean server of type \" + impl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mbeanServer == null)\n\t\t\t{\n\t\t\t\tmbeanServer = ManagementFactory.getPlatformMBeanServer();\n\t\t\t\t// never null\n\t\t\t}\n\n\t\t\tlog.info(\"registering Wicket mbeans with server \" + mbeanServer);\n\n\t\t\t// register top level application object, but first check whether\n\t\t\t// multiple instances of the same application (name) are running and\n\t\t\t// if so adjust the name\n\t\t\tString domain = \"org.apache.wicket.app.\" + name;\n\t\t\tObjectName appBeanName = new ObjectName(domain + \":type=Application\");\n\t\t\tString tempDomain = domain;\n\t\t\tint i = 0;\n\t\t\twhile (mbeanServer.isRegistered(appBeanName))\n\t\t\t{\n\t\t\t\ttempDomain = name + \"-\" + i++;\n\t\t\t\tappBeanName = new ObjectName(tempDomain + \":type=Application\");\n\t\t\t}\n\t\t\tdomain = tempDomain;\n\n\t\t\tApplication appBean = new Application(application);\n\t\t\tregister(appBean, appBeanName);\n\n\t\t\tregister(new ApplicationSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=ApplicationSettings\"));\n\t\t\tregister(new DebugSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=DebugSettings\"));\n\t\t\tregister(new MarkupSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=MarkupSettings\"));\n\t\t\tregister(new ResourceSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=ResourceSettings\"));\n\t\t\tregister(new PageSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=PageSettings\"));\n\t\t\tregister(new RequestCycleSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=RequestCycleSettings\"));\n\t\t\tregister(new SecuritySettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=SecuritySettings\"));\n\t\t\tregister(new SessionSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=SessionSettings\"));\n\t\t\tregister(new CookieValuePersisterSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=CookieValuePersisterSettings\"));\n\n\t\t\tRequestLogger sessionsBean = new RequestLogger(application);\n\t\t\tObjectName sessionsBeanName = new ObjectName(domain + \":type=RequestLogger\");\n\t\t\tregister(sessionsBean, sessionsBeanName);\n\t\t}\n\t\tcatch (MalformedObjectNameException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(e);\n\t\t}\n\t\tcatch (InstanceAlreadyExistsException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(e);\n\t\t}\n\t\tcatch (MBeanRegistrationException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(e);\n\t\t}\n\t\tcatch (NotCompliantMBeanException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(e);\n\t\t}\n\t}","id":28136,"modified_method":"/**\n\t * @see org.apache.wicket.IInitializer#init(org.apache.wicket.Application)\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void init(org.apache.wicket.Application application)\n\t{\n\t\ttry\n\t\t{\n\t\t\tString name = application.getName();\n\n\t\t\tString agentId = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tagentId = System.getProperty(\"wicket.mbean.server.agentid\");\n\t\t\t}\n\t\t\tcatch (SecurityException e)\n\t\t\t{\n\t\t\t\t// Ignore - we're not allowed to read this property.\n\t\t\t\tlog\n\t\t\t\t\t\t.warn(\"not allowed to read property wicket.mbean.server.agentid due to security settings; ignoring\");\n\t\t\t}\n\t\t\tif (agentId != null)\n\t\t\t{\n\t\t\t\tArrayList<MBeanServer> mbeanServers = MBeanServerFactory.findMBeanServer(agentId);\n\t\t\t\tif (!mbeanServers.isEmpty())\n\t\t\t\t{\n\t\t\t\t\tmbeanServer = mbeanServers.get(0); // get first\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlog.error(\"unable to find mbean server with agent id \" + agentId);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mbeanServer == null)\n\t\t\t{\n\t\t\t\tString impl = null;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tSystem.getProperty(\"wicket.mbean.server.class\");\n\t\t\t\t}\n\t\t\t\tcatch (SecurityException e)\n\t\t\t\t{\n\t\t\t\t\t// Ignore - we're not allowed to read this property.\n\t\t\t\t\tlog\n\t\t\t\t\t\t\t.warn(\"not allowed to read property wicket.mbean.server.class due to security settings; ignoring\");\n\t\t\t\t}\n\t\t\t\tif (impl != null)\n\t\t\t\t{\n\t\t\t\t\tArrayList<MBeanServer> mbeanServers = MBeanServerFactory.findMBeanServer(null);\n\t\t\t\t\tif (!mbeanServers.isEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (MBeanServer mbs : mbeanServers)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (mbs.getClass().getName().equals(impl))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmbeanServer = mbs;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (mbeanServer == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.error(\"unable to find mbean server of type \" + impl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mbeanServer == null)\n\t\t\t{\n\t\t\t\tmbeanServer = ManagementFactory.getPlatformMBeanServer();\n\t\t\t\t// never null\n\t\t\t}\n\n\t\t\tlog.info(\"registering Wicket mbeans with server \" + mbeanServer);\n\n\t\t\t// register top level application object, but first check whether\n\t\t\t// multiple instances of the same application (name) are running and\n\t\t\t// if so adjust the name\n\t\t\tString domain = \"org.apache.wicket.app.\" + name;\n\t\t\tObjectName appBeanName = new ObjectName(domain + \":type=Application\");\n\t\t\tString tempDomain = domain;\n\t\t\tint i = 0;\n\t\t\twhile (mbeanServer.isRegistered(appBeanName))\n\t\t\t{\n\t\t\t\ttempDomain = name + \"-\" + i++;\n\t\t\t\tappBeanName = new ObjectName(tempDomain + \":type=Application\");\n\t\t\t}\n\t\t\tdomain = tempDomain;\n\n\t\t\tApplication appBean = new Application(application);\n\t\t\tregister(appBean, appBeanName);\n\n\t\t\tregister(new ApplicationSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=ApplicationSettings\"));\n\t\t\tregister(new DebugSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=DebugSettings\"));\n\t\t\tregister(new MarkupSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=MarkupSettings\"));\n\t\t\tregister(new ResourceSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=ResourceSettings\"));\n\t\t\tregister(new PageSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=PageSettings\"));\n\t\t\tregister(new RequestCycleSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=RequestCycleSettings\"));\n\t\t\tregister(new SecuritySettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=SecuritySettings\"));\n\t\t\tregister(new SessionSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=SessionSettings\"));\n\t\t\tregister(new CookieValuePersisterSettings(application), new ObjectName(domain +\n\t\t\t\t\t\":type=Application,name=CookieValuePersisterSettings\"));\n\n\t\t\tRequestLogger sessionsBean = new RequestLogger(application);\n\t\t\tObjectName sessionsBeanName = new ObjectName(domain + \":type=RequestLogger\");\n\t\t\tregister(sessionsBean, sessionsBeanName);\n\t\t}\n\t\tcatch (MalformedObjectNameException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(e);\n\t\t}\n\t\tcatch (InstanceAlreadyExistsException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(e);\n\t\t}\n\t\tcatch (MBeanRegistrationException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(e);\n\t\t}\n\t\tcatch (NotCompliantMBeanException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(e);\n\t\t}\n\t}","commit_id":"cd3d93f11db928f570b1fe15c18b763dd1dff328","url":"https://github.com/apache/wicket"},{"original_method":"protected void releaseMBeanServers() {\n        List<MBeanServer> servers =\n            (List<MBeanServer>)MBeanServerFactory.findMBeanServer(null);\n\n        for (MBeanServer server : servers) {\n            MBeanServerFactory.releaseMBeanServer(server);\n        }\n    }","id":28137,"modified_method":"protected void releaseMBeanServers() {\n        List<MBeanServer> servers = MBeanServerFactory.findMBeanServer(null);\n\n        for (MBeanServer server : servers) {\n            MBeanServerFactory.releaseMBeanServer(server);\n        }\n    }","commit_id":"fb348e1d00072638024cdfc3ebe31d854a6910cc","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void setUp() throws Exception {\n        releaseMBeanServers();\n        super.setUp();\n        mbsc = getMBeanConnection();\n    }","id":28138,"modified_method":"@Override\n    public void setUp() throws Exception {\n        enableJMX();\n        releaseMBeanServers();\n        super.setUp();\n        mbsc = getMBeanConnection();\n    }","commit_id":"fb348e1d00072638024cdfc3ebe31d854a6910cc","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void tearDown() throws Exception {\n        releaseMBeanServers();\n        mbsc = null;\n        super.tearDown();\n    }","id":28139,"modified_method":"@Override\n    public void tearDown() throws Exception {\n        releaseMBeanServers();\n        mbsc = null;\n        super.tearDown();\n        disableJMX();\n    }","commit_id":"fb348e1d00072638024cdfc3ebe31d854a6910cc","url":"https://github.com/apache/camel"},{"original_method":"public synchronized MBeanContainer getMbContainer() {\n        // If null, provide the default implementation.\n        if (mbContainer == null) {\n            MBeanServer mbs = null;\n            \n            final ManagementStrategy mStrategy = \n                this.getCamelContext().getManagementStrategy();\n            final ManagementAgent mAgent = mStrategy.getManagementAgent();\n            if (mAgent != null) {\n                mbs = mAgent.getMBeanServer();\n            }\n            \n            if (mbs != null) {\n                mbContainer = new MBeanContainer(mbs);\n                startMbContainer();\n            } else {\n                LOG.warn(\"JMX disabled in Camel Context.  The Camel Context takes precedent and JMX will not be enabled in Jetty.\");\n            }\n        }\n        \n        return this.mbContainer;\n    }","id":28140,"modified_method":"public synchronized MBeanContainer getMbContainer() {\n        // If null, provide the default implementation.\n        if (mbContainer == null) {\n            MBeanServer mbs = null;\n            \n            final ManagementStrategy mStrategy = this.getCamelContext().getManagementStrategy();\n            final ManagementAgent mAgent = mStrategy.getManagementAgent();\n            if (mAgent != null) {\n                mbs = mAgent.getMBeanServer();\n            }\n            \n            if (mbs != null) {\n                mbContainer = new MBeanContainer(mbs);\n                startMbContainer();\n            } else {\n                LOG.warn(\"JMX disabled in CamelContext. Jetty JMX extensions will remain disabled.\");\n            }\n        }\n        \n        return this.mbContainer;\n    }","commit_id":"fb348e1d00072638024cdfc3ebe31d854a6910cc","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Starts {@link #mbContainer} and registers the\n     * container with itself as a managed bean logging an error\n     * if there is a problem starting the container.  Does nothing\n     * if {@link #mbContainer} is {@code null}.\n     */\n    protected void startMbContainer() {\n        if (mbContainer != null && !mbContainer.isStarted()) {\n            try {\n                mbContainer.start();\n                // Publish the container itself for consistency with\n                // traditional embedded Jetty configurations.\n                mbContainer.addBean(mbContainer);\n            } catch (Exception e) {\n                LOG.warn(\"Could not start Jetty MBeanContainer.  Jetty JMX extensions will remain disabled.\", e);\n            }\n        }\n    }","id":28141,"modified_method":"/**\n     * Starts {@link #mbContainer} and registers the container with itself as a managed bean\n     * logging an error if there is a problem starting the container.\n     * Does nothing if {@link #mbContainer} is {@code null}.\n     */\n    protected void startMbContainer() {\n        if (mbContainer != null && !mbContainer.isStarted()) {\n            try {\n                mbContainer.start();\n                // Publish the container itself for consistency with\n                // traditional embedded Jetty configurations.\n                mbContainer.addBean(mbContainer);\n            } catch (Throwable e) {\n                LOG.warn(\"Could not start Jetty MBeanContainer. Jetty JMX extensions will remain disabled.\", e);\n            }\n        }\n    }","commit_id":"fb348e1d00072638024cdfc3ebe31d854a6910cc","url":"https://github.com/apache/camel"},{"original_method":"private void enableJmx(Server server) {\n        MBeanContainer containerToRegister = getMbContainer();\n        if (containerToRegister != null) {\n            server.getContainer().addEventListener(containerToRegister);\n            // Since we may have many Servers running, don't tie the MBeanContainer\n            // to a Server lifecycle or we end up closing it while it is still in use.\n            //server.addBean(mbContainer);\n        }\n    }","id":28142,"modified_method":"private void enableJmx(Server server) {\n        MBeanContainer containerToRegister = getMbContainer();\n        if (containerToRegister != null) {\n            LOG.info(\"Jetty JMX Extensions is enabled\");\n            server.getContainer().addEventListener(containerToRegister);\n            // Since we may have many Servers running, don't tie the MBeanContainer\n            // to a Server lifecycle or we end up closing it while it is still in use.\n            //server.addBean(mbContainer);\n        }\n    }","commit_id":"fb348e1d00072638024cdfc3ebe31d854a6910cc","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Disconnects the URL specified on the endpoint from the specified processor.\n     */\n    @Override\n    public void disconnect(HttpConsumer consumer) throws Exception {\n        // If the connector is not needed anymore then stop it\n        HttpEndpoint endpoint = consumer.getEndpoint();\n        String connectorKey = getConnectorKey(endpoint);\n        \n        synchronized (CONNECTORS) {\n            ConnectorRef connectorRef = CONNECTORS.get(connectorKey);\n            if (connectorRef != null) {\n                connectorRef.servlet.disconnect(consumer);\n                if (connectorRef.decrement() == 0) {\n                    connectorRef.server.removeConnector(connectorRef.connector);\n                    connectorRef.connector.stop();\n                    connectorRef.server.stop();\n                    CONNECTORS.remove(connectorKey);\n                    // Camel controls the lifecycle of these entities so remove the\n                    // registered MBeans when Camel is done with the managed objects.\n                    MBeanContainer containerToClean = getMbContainer(); \n                    if (containerToClean != null) {\n                        containerToClean.removeBean(connectorRef.server);\n                        containerToClean.removeBean(connectorRef.connector);\n                    }\n                }\n            }\n        }\n    }","id":28143,"modified_method":"/**\n     * Disconnects the URL specified on the endpoint from the specified processor.\n     */\n    @Override\n    public void disconnect(HttpConsumer consumer) throws Exception {\n        // If the connector is not needed anymore then stop it\n        HttpEndpoint endpoint = consumer.getEndpoint();\n        String connectorKey = getConnectorKey(endpoint);\n        \n        synchronized (CONNECTORS) {\n            ConnectorRef connectorRef = CONNECTORS.get(connectorKey);\n            if (connectorRef != null) {\n                connectorRef.servlet.disconnect(consumer);\n                if (connectorRef.decrement() == 0) {\n                    connectorRef.server.removeConnector(connectorRef.connector);\n                    connectorRef.connector.stop();\n                    connectorRef.server.stop();\n                    CONNECTORS.remove(connectorKey);\n                    // Camel controls the lifecycle of these entities so remove the\n                    // registered MBeans when Camel is done with the managed objects.\n                    if (mbContainer != null) {\n                        mbContainer.removeBean(connectorRef.server);\n                        mbContainer.removeBean(connectorRef.connector);\n                    }\n                }\n            }\n        }\n    }","commit_id":"fb348e1d00072638024cdfc3ebe31d854a6910cc","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Connects the URL specified on the endpoint to the specified processor.\n     */\n    @Override\n    public void connect(HttpConsumer consumer) throws Exception {\n        // Make sure that there is a connector for the requested endpoint.\n        JettyHttpEndpoint endpoint = (JettyHttpEndpoint)consumer.getEndpoint();\n        String connectorKey = getConnectorKey(endpoint);\n\n        synchronized (CONNECTORS) {\n            ConnectorRef connectorRef = CONNECTORS.get(connectorKey);\n            if (connectorRef == null) {\n                Connector connector;\n                if (\"https\".equals(endpoint.getProtocol())) {\n                    connector = getSslSocketConnector(endpoint.getPort());\n                } else {\n                    connector = new SelectChannelConnector();\n                }\n                connector.setPort(endpoint.getPort());\n                connector.setHost(endpoint.getHttpUri().getHost());\n                if (\"localhost\".equalsIgnoreCase(endpoint.getHttpUri().getHost())) {\n                    LOG.warn(\"You use localhost interface! It means that no external connections will be available. Don't you want to use 0.0.0.0 instead (all network interfaces)?\");\n                }\n                Server server = createServer();\n                if (endpoint.isEnableJmx()) {\n                    enableJmx(server);\n                }\n                server.addConnector(connector);\n\n                connectorRef = new ConnectorRef(server, connector, createServletForConnector(server, connector, endpoint.getHandlers()));\n                connectorRef.server.start();\n                \n                CONNECTORS.put(connectorKey, connectorRef);\n                \n            } else {\n                // ref track the connector\n                connectorRef.increment();\n            }\n            // check the session support\n            if (endpoint.isSessionSupport()) {                \n                enableSessionSupport(connectorRef.server);\n            }\n            connectorRef.servlet.connect(consumer);\n        }\n    }","id":28144,"modified_method":"/**\n     * Connects the URL specified on the endpoint to the specified processor.\n     */\n    @Override\n    public void connect(HttpConsumer consumer) throws Exception {\n        // Make sure that there is a connector for the requested endpoint.\n        JettyHttpEndpoint endpoint = (JettyHttpEndpoint)consumer.getEndpoint();\n        String connectorKey = getConnectorKey(endpoint);\n\n        synchronized (CONNECTORS) {\n            ConnectorRef connectorRef = CONNECTORS.get(connectorKey);\n            if (connectorRef == null) {\n                Connector connector;\n                if (\"https\".equals(endpoint.getProtocol())) {\n                    connector = getSslSocketConnector(endpoint.getPort());\n                } else {\n                    connector = new SelectChannelConnector();\n                }\n                connector.setPort(endpoint.getPort());\n                connector.setHost(endpoint.getHttpUri().getHost());\n                if (\"localhost\".equalsIgnoreCase(endpoint.getHttpUri().getHost())) {\n                    LOG.warn(\"You use localhost interface! It means that no external connections will be available.\"\n                            + \" Don't you want to use 0.0.0.0 instead (all network interfaces)? \" + endpoint);\n                }\n                Server server = createServer();\n                if (endpoint.isEnableJmx()) {\n                    enableJmx(server);\n                }\n                server.addConnector(connector);\n\n                connectorRef = new ConnectorRef(server, connector, createServletForConnector(server, connector, endpoint.getHandlers()));\n                connectorRef.server.start();\n                \n                CONNECTORS.put(connectorKey, connectorRef);\n                \n            } else {\n                // ref track the connector\n                connectorRef.increment();\n            }\n            // check the session support\n            if (endpoint.isSessionSupport()) {                \n                enableSessionSupport(connectorRef.server);\n            }\n            connectorRef.servlet.connect(consumer);\n        }\n    }","commit_id":"fb348e1d00072638024cdfc3ebe31d854a6910cc","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * An event was received from the layer below. Usually the current layer will want to examine\n     * the event type and - depending on its type - perform some computation\n     * (e.g. removing headers from a MSG event type, or updating the internal membership list\n     * when receiving a VIEW_CHANGE event).\n     * Finally the event is either a) discarded, or b) an event is sent down\n     * the stack using <code>PassDown<\/code> or c) the event (or another event) is sent up\n     * the stack using <code>PassUp<\/code>.\n     * <p/>\n     * For the PING protocol, the Up operation does the following things.\n     * 1. If the event is a Event.MSG then PING will inspect the message header.\n     * If the header is null, PING simply passes up the event\n     * If the header is PingHeader.GET_MBRS_REQ then the PING protocol\n     * will PassDown a PingRequest message\n     * If the header is PingHeader.GET_MBRS_RSP we will add the message to the initial members\n     * vector and wake up any waiting threads.\n     * 2. If the event is Event.SET_LOCAL_ADDR we will simple set the local address of this protocol\n     * 3. For all other messages we simple pass it up to the protocol above\n     *\n     * @param evt - the event that has been sent from the layer below\n     */\n\n    public Object up(Event evt) {\n        Message msg, rsp_msg;\n        PingHeader rsp_hdr;\n        PingRsp rsp;\n        Address coord;\n\n        switch(evt.getType()) {\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            PingHeader hdr=(PingHeader)msg.getHeader(getName());\n            if(hdr == null) {\n                passUp(evt);\n                return;\n            }\n\n            switch(hdr.type) {\n\n            case PingHeader.GET_MBRS_REQ:   // return Rsp(local_addr, coord)\n                if(local_addr != null && msg.getSrc() != null && local_addr.equals(msg.getSrc())) {\n                    return;\n                }\n                synchronized(members) {\n                    coord=!members.isEmpty()? (Address)members.firstElement() : local_addr;\n                }\n\n                PingRsp ping_rsp=new PingRsp(local_addr, coord, is_server);\n                rsp_msg=new Message(msg.getSrc(), null, null);\n                rsp_msg.setFlag(Message.OOB);\n                rsp_hdr=new PingHeader(PingHeader.GET_MBRS_RSP, ping_rsp);\n                rsp_msg.putHeader(getName(), rsp_hdr);\n                if(trace)\n                    log.trace(\"received GET_MBRS_REQ from \" + msg.getSrc() + \", sending response \" + rsp_hdr);\n                passDown(new Event(Event.MSG, rsp_msg));\n                return;\n\n            case PingHeader.GET_MBRS_RSP:   // add response to vector and notify waiting thread\n                rsp=hdr.arg;\n\n                if(trace)\n                    log.trace(\"received GET_MBRS_RSP, rsp=\" + rsp);\n                ping_waiter.addResponse(rsp);\n                return;\n\n            default:\n                if(warn) log.warn(\"got PING header with unknown type (\" + hdr.type + ')');\n                return;\n            }\n\n\n        case Event.SET_LOCAL_ADDRESS:\n            passUp(evt);\n            local_addr=(Address)evt.getArg();\n            localAddressSet(local_addr);\n            break;\n\n        case Event.CONNECT_OK:\n            handleConnectOK();\n            passUp(evt);\n            break;\n\n        default:\n            passUp(evt);            // Pass up to the layer above us\n            break;\n        }\n    }","id":28145,"modified_method":"/**\n     * An event was received from the layer below. Usually the current layer will want to examine\n     * the event type and - depending on its type - perform some computation\n     * (e.g. removing headers from a MSG event type, or updating the internal membership list\n     * when receiving a VIEW_CHANGE event).\n     * Finally the event is either a) discarded, or b) an event is sent down\n     * the stack using <code>PassDown<\/code> or c) the event (or another event) is sent up\n     * the stack using <code>PassUp<\/code>.\n     * <p/>\n     * For the PING protocol, the Up operation does the following things.\n     * 1. If the event is a Event.MSG then PING will inspect the message header.\n     * If the header is null, PING simply passes up the event\n     * If the header is PingHeader.GET_MBRS_REQ then the PING protocol\n     * will PassDown a PingRequest message\n     * If the header is PingHeader.GET_MBRS_RSP we will add the message to the initial members\n     * vector and wake up any waiting threads.\n     * 2. If the event is Event.SET_LOCAL_ADDR we will simple set the local address of this protocol\n     * 3. For all other messages we simple pass it up to the protocol above\n     *\n     * @param evt - the event that has been sent from the layer below\n     */\n\n    public Object up(Event evt) {\n        Message msg, rsp_msg;\n        PingHeader rsp_hdr;\n        PingRsp rsp;\n        Address coord;\n\n        switch(evt.getType()) {\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            PingHeader hdr=(PingHeader)msg.getHeader(getName());\n            if(hdr == null) {\n                return passUp(evt);\n            }\n\n            switch(hdr.type) {\n\n            case PingHeader.GET_MBRS_REQ:   // return Rsp(local_addr, coord)\n                if(local_addr != null && msg.getSrc() != null && local_addr.equals(msg.getSrc())) {\n                    return null;\n                }\n                synchronized(members) {\n                    coord=!members.isEmpty()? (Address)members.firstElement() : local_addr;\n                }\n\n                PingRsp ping_rsp=new PingRsp(local_addr, coord, is_server);\n                rsp_msg=new Message(msg.getSrc(), null, null);\n                rsp_msg.setFlag(Message.OOB);\n                rsp_hdr=new PingHeader(PingHeader.GET_MBRS_RSP, ping_rsp);\n                rsp_msg.putHeader(getName(), rsp_hdr);\n                if(trace)\n                    log.trace(\"received GET_MBRS_REQ from \" + msg.getSrc() + \", sending response \" + rsp_hdr);\n                passDown(new Event(Event.MSG, rsp_msg));\n                return null;\n\n            case PingHeader.GET_MBRS_RSP:   // add response to vector and notify waiting thread\n                rsp=hdr.arg;\n\n                if(trace)\n                    log.trace(\"received GET_MBRS_RSP, rsp=\" + rsp);\n                ping_waiter.addResponse(rsp);\n                return null;\n\n            default:\n                if(warn) log.warn(\"got PING header with unknown type (\" + hdr.type + ')');\n                return null;\n            }\n\n\n        case Event.SET_LOCAL_ADDRESS:\n            passUp(evt);\n            local_addr=(Address)evt.getArg();\n            localAddressSet(local_addr);\n            break;\n\n        case Event.CONNECT_OK:\n            handleConnectOK();\n            passUp(evt);\n            break;\n\n        default:\n            passUp(evt);            // Pass up to the layer above us\n            break;\n        }\n\n        return null;\n    }","commit_id":"bf09e1661b9e9c097f2efc3a456f66118d128893","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * An event is to be sent down the stack. The layer may want to examine its type and perform\n     * some action on it, depending on the event's type. If the event is a message MSG, then\n     * the layer may need to add a header to it (or do nothing at all) before sending it down\n     * the stack using <code>PassDown<\/code>. In case of a GET_ADDRESS event (which tries to\n     * retrieve the stack's address from one of the bottom layers), the layer may need to send\n     * a new response event back up the stack using <code>passUp()<\/code>.\n     * The PING protocol is interested in several different down events,\n     * Event.FIND_INITIAL_MBRS - sent by the GMS layer and expecting a GET_MBRS_OK\n     * Event.TMP_VIEW and Event.VIEW_CHANGE - a view change event\n     * Event.BECOME_SERVER - called after client has joined and is fully working group member\n     * Event.CONNECT, Event.DISCONNECT.\n     */\n    public Object down(Event evt) {\n\n        switch(evt.getType()) {\n\n        case Event.FIND_INITIAL_MBRS:   // sent by GMS layer, pass up a GET_MBRS_OK event\n            // sends the GET_MBRS_REQ to all members, waits 'timeout' ms or until 'num_initial_members' have been retrieved\n            num_discovery_requests++;\n            ping_waiter.start();\n            break;\n\n        case Event.TMP_VIEW:\n        case Event.VIEW_CHANGE:\n            Vector tmp;\n            if((tmp=((View)evt.getArg()).getMembers()) != null) {\n                synchronized(members) {\n                    members.clear();\n                    members.addAll(tmp);\n                }\n            }\n            passDown(evt);\n            break;\n\n        case Event.BECOME_SERVER: // called after client has joined and is fully working group member\n            passDown(evt);\n            is_server=true;\n            break;\n\n        case Event.CONNECT:\n            group_addr=(String)evt.getArg();\n            passDown(evt);\n            handleConnect();\n            break;\n\n        case Event.DISCONNECT:\n            handleDisconnect();\n            passDown(evt);\n            break;\n\n        default:\n            passDown(evt);          // Pass on to the layer below us\n            break;\n        }\n    }","id":28146,"modified_method":"/**\n     * An event is to be sent down the stack. The layer may want to examine its type and perform\n     * some action on it, depending on the event's type. If the event is a message MSG, then\n     * the layer may need to add a header to it (or do nothing at all) before sending it down\n     * the stack using <code>PassDown<\/code>. In case of a GET_ADDRESS event (which tries to\n     * retrieve the stack's address from one of the bottom layers), the layer may need to send\n     * a new response event back up the stack using <code>passUp()<\/code>.\n     * The PING protocol is interested in several different down events,\n     * Event.FIND_INITIAL_MBRS - sent by the GMS layer and expecting a GET_MBRS_OK\n     * Event.TMP_VIEW and Event.VIEW_CHANGE - a view change event\n     * Event.BECOME_SERVER - called after client has joined and is fully working group member\n     * Event.CONNECT, Event.DISCONNECT.\n     */\n    public Object down(Event evt) {\n\n        switch(evt.getType()) {\n\n        case Event.FIND_INITIAL_MBRS:   // sent by GMS layer, pass up a GET_MBRS_OK event\n            // sends the GET_MBRS_REQ to all members, waits 'timeout' ms or until 'num_initial_members' have been retrieved\n            num_discovery_requests++;\n            ping_waiter.start();\n            return null;\n\n        case Event.TMP_VIEW:\n        case Event.VIEW_CHANGE:\n            Vector tmp;\n            if((tmp=((View)evt.getArg()).getMembers()) != null) {\n                synchronized(members) {\n                    members.clear();\n                    members.addAll(tmp);\n                }\n            }\n            return passDown(evt);\n\n        case Event.BECOME_SERVER: // called after client has joined and is fully working group member\n            passDown(evt);\n            is_server=true;\n            return null;\n\n        case Event.CONNECT:\n            group_addr=(String)evt.getArg();\n            Object ret=passDown(evt);\n            handleConnect();\n            return ret;\n\n        case Event.DISCONNECT:\n            handleDisconnect();\n            return passDown(evt);\n\n        default:\n            return passDown(evt);          // Pass on to the layer below us\n        }\n    }","commit_id":"bf09e1661b9e9c097f2efc3a456f66118d128893","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Caller by the layer above this layer. Usually we just put this Message\n     * into the send queue and let one or more worker threads handle it. A worker thread\n     * then removes the Message from the send queue, performs a conversion and adds the\n     * modified Message to the send queue of the layer below it, by calling Down).\n     */\n    public Object down(Event evt) {\n        if(trace)\n            log.trace(\"event is \" + evt + \", group_addr=\" + group_addr +\n                      \", time is \" + System.currentTimeMillis() + \", hdrs: \" + Util.printEvent(evt));\n\n        switch(evt.getType()) {\n\n        case Event.MSG:\n            Message msg=(Message)evt.getArg();\n            Message rsp=msg.copy();\n            if(rsp.getSrc() == null)\n                rsp.setSrc(local_addr);\n\n            //dest_addr=msg.getDest();\n            //rsp.setDest(local_addr);\n            //rsp.setSrc(dest_addr != null ? dest_addr : local_addr);\n            up(new Event(Event.MSG, rsp));\n            break;\n\n        case Event.GET_LOCAL_ADDRESS:   // return local address -> Event(SET_LOCAL_ADDRESS, local)\n            passUp(new Event(Event.SET_LOCAL_ADDRESS, local_addr));\n            break;\n\n        case Event.CONNECT:\n            group_addr=(String)evt.getArg();\n            passUp(new Event(Event.CONNECT_OK));\n            break;\n\n        case Event.DISCONNECT:\n            passUp(new Event(Event.DISCONNECT_OK));\n            break;\n\n        case Event.PERF:\n            passUp(evt);\n            break;\n        }\n    }","id":28147,"modified_method":"/**\n     * Caller by the layer above this layer. Usually we just put this Message\n     * into the send queue and let one or more worker threads handle it. A worker thread\n     * then removes the Message from the send queue, performs a conversion and adds the\n     * modified Message to the send queue of the layer below it, by calling Down).\n     */\n    public Object down(Event evt) {\n        if(trace)\n            log.trace(\"event is \" + evt + \", group_addr=\" + group_addr +\n                      \", time is \" + System.currentTimeMillis() + \", hdrs: \" + Util.printEvent(evt));\n\n        switch(evt.getType()) {\n\n        case Event.MSG:\n            Message msg=(Message)evt.getArg();\n            Message rsp=msg.copy();\n            if(rsp.getSrc() == null)\n                rsp.setSrc(local_addr);\n\n            //dest_addr=msg.getDest();\n            //rsp.setDest(local_addr);\n            //rsp.setSrc(dest_addr != null ? dest_addr : local_addr);\n            up(new Event(Event.MSG, rsp));\n            break;\n\n        case Event.GET_LOCAL_ADDRESS:   // return local address -> Event(SET_LOCAL_ADDRESS, local)\n            passUp(new Event(Event.SET_LOCAL_ADDRESS, local_addr));\n            break;\n\n        case Event.CONNECT:\n            group_addr=(String)evt.getArg();\n            passUp(new Event(Event.CONNECT_OK));\n            break;\n\n        case Event.DISCONNECT:\n            passUp(new Event(Event.DISCONNECT_OK));\n            break;\n\n        case Event.PERF:\n            passUp(evt);\n            break;\n        }\n        return null;\n    }","commit_id":"bf09e1661b9e9c097f2efc3a456f66118d128893","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                passUp(evt);\n                break;\n\n            case Event.FIND_INITIAL_MBRS_OK:\n                find_promise.setResult(evt.getArg());\n                passUp(evt); // could be needed by GMS\n                break;\n\n            default:\n                passUp(evt);            // Pass up to the layer above us\n                break;\n        }\n    }","id":28148,"modified_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                return passUp(evt);\n\n            case Event.FIND_INITIAL_MBRS_OK:\n                find_promise.setResult(evt.getArg());\n                return passUp(evt); // could be needed by GMS\n\n            default:\n                return passUp(evt);            // Pass up to the layer above us\n        }\n    }","commit_id":"bf09e1661b9e9c097f2efc3a456f66118d128893","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                CoordAnnouncement hdr=(CoordAnnouncement)msg.removeHeader(getName());\n                if(hdr != null) {\n                    if(hdr.coord_addr != null && is_coord) {\n                        boolean contains;\n                        contains=announcements.contains(hdr.coord_addr);\n                        announcements.add(hdr.coord_addr);\n                        if(log.isDebugEnabled()) {\n                            if(contains)\n                                log.debug(\"discarded duplicate announcement: \" + hdr.coord_addr +\n                                          \", announcements=\" + announcements);\n                            else\n                                log.debug(\"received announcement: \" + hdr.coord_addr + \", announcements=\" + announcements);\n                        }\n\n                        if(announcements.size() > 1 && is_coord) {\n                            processAnnouncements();\n                        }\n                    }\n                }\n                else\n                    passUp(evt);\n                break;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                passUp(evt);\n                break;\n\n            default:\n                passUp(evt);            // Pass up to the layer above us\n                break;\n        }\n    }","id":28149,"modified_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                CoordAnnouncement hdr=(CoordAnnouncement)msg.removeHeader(getName());\n                if(hdr != null) {\n                    if(hdr.coord_addr != null && is_coord) {\n                        boolean contains;\n                        contains=announcements.contains(hdr.coord_addr);\n                        announcements.add(hdr.coord_addr);\n                        if(log.isDebugEnabled()) {\n                            if(contains)\n                                log.debug(\"discarded duplicate announcement: \" + hdr.coord_addr +\n                                        \", announcements=\" + announcements);\n                            else\n                                log.debug(\"received announcement: \" + hdr.coord_addr + \", announcements=\" + announcements);\n                        }\n\n                        if(announcements.size() > 1 && is_coord) {\n                            processAnnouncements();\n                        }\n                    }\n                    return null;\n                }\n                else\n                    return passUp(evt);\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                break;\n        }\n\n        return passUp(evt);\n    }","commit_id":"bf09e1661b9e9c097f2efc3a456f66118d128893","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        Vector tmp;\n        Address coord;\n\n        switch(evt.getType()) {\n\n            case Event.VIEW_CHANGE:\n                passDown(evt);\n                tmp=((View)evt.getArg()).getMembers();\n                mbrs.clear();\n                mbrs.addAll(tmp);\n                coord=(Address)mbrs.elementAt(0);\n                if(coord.equals(local_addr)) {\n                    if(is_coord == false) {\n                        is_coord=true;\n                        startCoordAnnouncerTask();\n                    }\n                }\n                else {\n                    if(is_coord == true) {\n                        is_coord=false;\n                        stopCoordAnnouncerTask();\n                    }\n                }\n                break;\n\n            default:\n                passDown(evt);          // Pass on to the layer below us\n                break;\n        }\n    }","id":28150,"modified_method":"public Object down(Event evt) {\n        Vector tmp;\n        Address coord;\n\n        switch(evt.getType()) {\n\n            case Event.VIEW_CHANGE:\n                passDown(evt);\n                tmp=((View)evt.getArg()).getMembers();\n                mbrs.clear();\n                mbrs.addAll(tmp);\n                coord=(Address)mbrs.elementAt(0);\n                if(coord.equals(local_addr)) {\n                    if(is_coord == false) {\n                        is_coord=true;\n                        startCoordAnnouncerTask();\n                    }\n                }\n                else {\n                    if(is_coord == true) {\n                        is_coord=false;\n                        stopCoordAnnouncerTask();\n                    }\n                }\n                break;\n        }\n        return passDown(evt);\n    }","commit_id":"bf09e1661b9e9c097f2efc3a456f66118d128893","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        if(is_coord == true && evt.getType() == Event.MSG && local_addr != null) {\n            Message msg=(Message)evt.getArg();\n            Address dest=msg.getDest();\n            if(dest == null || dest.isMulticastAddress()) {\n                msg.putHeader(getName(), new MergefastHeader(local_addr));\n            }\n        }\n\n        if(evt.getType() == Event.VIEW_CHANGE) {\n            handleViewChange((View)evt.getArg());\n        }\n\n        passDown(evt);\n    }","id":28151,"modified_method":"public Object down(Event evt) {\n        if(is_coord == true && evt.getType() == Event.MSG && local_addr != null) {\n            Message msg=(Message)evt.getArg();\n            Address dest=msg.getDest();\n            if(dest == null || dest.isMulticastAddress()) {\n                msg.putHeader(getName(), new MergefastHeader(local_addr));\n            }\n        }\n\n        if(evt.getType() == Event.VIEW_CHANGE) {\n            handleViewChange((View)evt.getArg());\n        }\n\n        return passDown(evt);\n    }","commit_id":"bf09e1661b9e9c097f2efc3a456f66118d128893","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        if(evt.getType() == Event.CONFIG) {\n            if(bind_addr == null) {\n                Map config=(Map)evt.getArg();\n                bind_addr=(InetAddress)config.get(\"bind_addr\");\n            }\n            passUp(evt);\n            return;\n        }\n        super.up(evt);\n    }","id":28152,"modified_method":"public Object up(Event evt) {\n        if(evt.getType() == Event.CONFIG) {\n            if(bind_addr == null) {\n                Map config=(Map)evt.getArg();\n                bind_addr=(InetAddress)config.get(\"bind_addr\");\n            }\n            return passUp(evt);\n        }\n        return super.up(evt);\n    }","commit_id":"bf09e1661b9e9c097f2efc3a456f66118d128893","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                Header hdr=(Header)msg.getHeader(name);\n                Address sender=msg.getSrc();\n                if(hdr != null) {\n                    switch(hdr.type) {\n                        case Header.CREDIT_REQUEST:\n                            handleCreditRequest(sender);\n                            break;\n                        case Header.REPLENISH:\n                            handleCreditResponse(sender);\n                            break;\n                        default:\n                            if(log.isErrorEnabled())\n                                log.error(\"unknown header type \" + hdr.type);\n                            break;\n                    }\n                    return; // we don't pass the request further up\n                }\n\n                Address dest=msg.getDest();\n                if(dest != null && !dest.isMulticastAddress()) // we don't handle unicast messages\n                    break;\n\n                handleMessage(msg, sender);\n                break;\n\n            case Event.VIEW_CHANGE:\n                handleViewChange((View)evt.getArg());\n                break;\n\n            case Event.SUSPECT:\n                handleSuspect((Address)evt.getArg());\n                break;\n        }\n        passUp(evt);\n    }","id":28153,"modified_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                Header hdr=(Header)msg.getHeader(name);\n                Address sender=msg.getSrc();\n                if(hdr != null) {\n                    switch(hdr.type) {\n                        case Header.CREDIT_REQUEST:\n                            handleCreditRequest(sender);\n                            break;\n                        case Header.REPLENISH:\n                            handleCreditResponse(sender);\n                            break;\n                        default:\n                            if(log.isErrorEnabled())\n                                log.error(\"unknown header type \" + hdr.type);\n                            break;\n                    }\n                    return null; // we don't pass the request further up\n                }\n\n                Address dest=msg.getDest();\n                if(dest != null && !dest.isMulticastAddress()) // we don't handle unicast messages\n                    break;\n\n                handleMessage(msg, sender);\n                break;\n\n            case Event.VIEW_CHANGE:\n                handleViewChange((View)evt.getArg());\n                break;\n\n            case Event.SUSPECT:\n                handleSuspect((Address)evt.getArg());\n                break;\n        }\n        return passUp(evt);\n    }","commit_id":"ccb78b58157b0d675d6996637f5b00a8035736dc","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                Address dest=msg.getDest();\n                if(dest != null && !dest.isMulticastAddress()) // only handle multicast messages\n                    break;\n\n                boolean send_credit_request=false;\n                lock.lock();\n                try {\n                    while(curr_credits_available <=0 && running) {\n                        if(trace)\n                            log.trace(\"blocking (current credits=\" + curr_credits_available + \")\");\n                        try {\n                            num_blockings++;\n                            credits_available.await(); // will be signalled when we have credit responses from all members\n                        }\n                        catch(InterruptedException e) {\n                            if(warn)\n                                log.warn(\"thread was interrupted\", e);\n                            Thread.currentThread().interrupt(); // pass the exception on to the  caller\n                            return;\n                        }\n                    }\n\n                    // when we get here, curr_credits_available is guaranteed to be > 0\n                    int len=msg.getLength();\n                    num_bytes_sent+=len;\n                    curr_credits_available-=len; // we'll block on insufficient credits on the next down() call\n                    if(curr_credits_available <=0) {\n                        pending_creditors.clear();\n                        synchronized(members) {\n                            pending_creditors.addAll(members);\n                        }\n                        send_credit_request=true;\n                    }\n                }\n                finally {\n                    lock.unlock();\n                }\n\n                // we don't need to protect send_credit_request because a thread above either (a) decrements the credits\n                // by the msg length and sets send_credit_request to true or (b) blocks because there are no credits\n                // available. So only 1 thread can ever set send_credit_request at any given time\n                if(send_credit_request) {\n                    if(trace)\n                        log.trace(\"sending credit request to group\");\n                    start=System.nanoTime(); // only 1 thread is here at any given time\n                    passDown(evt);       // send the message before the credit request\n                    sendCreditRequest(); // do this outside of the lock\n                    return;\n                }\n                break;\n\n            case Event.VIEW_CHANGE:\n                handleViewChange((View)evt.getArg());\n                break;\n\n            case Event.SUSPECT:\n                handleSuspect((Address)evt.getArg());\n                break;\n        }\n\n        passDown(evt);\n    }","id":28154,"modified_method":"public Object down(Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                Address dest=msg.getDest();\n                if(dest != null && !dest.isMulticastAddress()) // only handle multicast messages\n                    break;\n\n                boolean send_credit_request=false;\n                lock.lock();\n                try {\n                    while(curr_credits_available <=0 && running) {\n                        if(trace)\n                            log.trace(\"blocking (current credits=\" + curr_credits_available + \")\");\n                        try {\n                            num_blockings++;\n                            credits_available.await(); // will be signalled when we have credit responses from all members\n                        }\n                        catch(InterruptedException e) {\n                            if(warn)\n                                log.warn(\"thread was interrupted\", e);\n                            Thread.currentThread().interrupt(); // pass the exception on to the  caller\n                            return null;\n                        }\n                    }\n\n                    // when we get here, curr_credits_available is guaranteed to be > 0\n                    int len=msg.getLength();\n                    num_bytes_sent+=len;\n                    curr_credits_available-=len; // we'll block on insufficient credits on the next down() call\n                    if(curr_credits_available <=0) {\n                        pending_creditors.clear();\n                        synchronized(members) {\n                            pending_creditors.addAll(members);\n                        }\n                        send_credit_request=true;\n                    }\n                }\n                finally {\n                    lock.unlock();\n                }\n\n                // we don't need to protect send_credit_request because a thread above either (a) decrements the credits\n                // by the msg length and sets send_credit_request to true or (b) blocks because there are no credits\n                // available. So only 1 thread can ever set send_credit_request at any given time\n                if(send_credit_request) {\n                    if(trace)\n                        log.trace(\"sending credit request to group\");\n                    start=System.nanoTime(); // only 1 thread is here at any given time\n                    Object ret=passDown(evt);       // send the message before the credit request\n                    sendCreditRequest(); // do this outside of the lock\n                    return ret;\n                }\n                break;\n\n            case Event.VIEW_CHANGE:\n                handleViewChange((View)evt.getArg());\n                break;\n\n            case Event.SUSPECT:\n                handleSuspect((Address)evt.getArg());\n                break;\n        }\n\n        return passDown(evt);\n    }","commit_id":"ccb78b58157b0d675d6996637f5b00a8035736dc","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean setProperties(Properties props) {\n        String     str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"name\");\n        if(str != null) {\n            name=str;\n            props.remove(\"name\");\n        }\n\n        if(props.size() > 0) {\n            log.error(\"DUMMY.setProperties(): these properties are not recognized: \" + props);\n\n            return false;\n        }\n        return true;\n    }","id":28155,"modified_method":"public boolean setProperties(Properties props) {\n        String     str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"name\");\n        if(str != null) {\n            name=str;\n            props.remove(\"name\");\n        }\n\n        if(!props.isEmpty()) {\n            log.error(\"DUMMY.setProperties(): these properties are not recognized: \" + props);\n\n            return false;\n        }\n        return true;\n    }","commit_id":"ccb78b58157b0d675d6996637f5b00a8035736dc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds upcoming messages to the <code>messages List<\\code> where the <code>messagesHandler<\\code>\n     * retrieves them.\n     */\n\n    public Object up(Event evt) {\n        Message msg;\n\n        switch (evt.getType()) {\n\n\tcase Event.MSG:\n            msg=(Message)evt.getArg();\n            // Do something with the event, e.g. extract the message and remove a header.\n            // Optionally pass up\n            messages.add(msg);\n            return;\n        }\n\n        passUp(evt);            // Pass up to the layer above us\n    }","id":28156,"modified_method":"/**\n     * Adds upcoming messages to the <code>messages List<\\code> where the <code>messagesHandler<\\code>\n     * retrieves them.\n     */\n\n    public Object up(Event evt) {\n        Message msg;\n\n        switch (evt.getType()) {\n\n            case Event.MSG:\n                msg=(Message)evt.getArg();\n                // Do something with the event, e.g. extract the message and remove a header.\n                // Optionally pass up\n                messages.add(msg);\n                return null;\n        }\n\n        return passUp(evt);            // Pass up to the layer above us\n    }","commit_id":"ccb78b58157b0d675d6996637f5b00a8035736dc","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes a random chosen message from the <code>messages List<\\code> if there\n     * are less than 10 messages in the List it waits some time to ensure to chose from\n     * a set of messages > 1.\n     */\n\n    public void run() {\n        Message msg;\n        while (messagesHandler != null) {\n            if ( messages.size() > 0 ) {\n                msg = (Message) messages.remove(rnd(messages.size()));\n                passUp(new Event(Event.MSG,msg));\n            }\n            if (messages.size() < 5) {\n                try {\n                    Thread.sleep(300); /** @todo make this time user configurable */\n                }\n                catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        }// while\n        // PassUp remaining messages\n        Iterator iter = messages.iterator();\n        while (iter.hasNext()) {\n            msg = (Message) iter.next();\n            passUp(new Event(Event.MSG,msg));\n        }\n    }","id":28157,"modified_method":"/**\n     * Removes a random chosen message from the <code>messages List<\\code> if there\n     * are less than 10 messages in the List it waits some time to ensure to chose from\n     * a set of messages > 1.\n     */\n\n    public void run() {\n        Message msg;\n        while (messagesHandler != null) {\n            if (!messages.isEmpty()) {\n                msg = (Message) messages.remove(rnd(messages.size()));\n                passUp(new Event(Event.MSG,msg));\n            }\n            if (messages.size() < 5) {\n                try {\n                    Thread.sleep(300); /** @todo make this time user configurable */\n                }\n                catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        }// while\n        // PassUp remaining messages\n        Iterator iter = messages.iterator();\n        while (iter.hasNext()) {\n            msg = (Message) iter.next();\n            passUp(new Event(Event.MSG,msg));\n        }\n    }","commit_id":"ccb78b58157b0d675d6996637f5b00a8035736dc","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean setProperties(Properties props) {\n        String str;\n        long[] tmp;\n\n        super.setProperties(props);\n        str=props.getProperty(\"print_local_addr\");\n        if(str != null) {\n            print_local_addr=Boolean.valueOf(str).booleanValue();\n            props.remove(\"print_local_addr\");\n        }\n\n        str=props.getProperty(\"timeout\");\n        if(str != null) {\n            tmp=Util.parseCommaDelimitedLongs(str);\n            props.remove(\"timeout\");\n            if(tmp != null && tmp.length > 0)\n                timeout=tmp;\n        }\n\n        str=props.getProperty(\"max_xmits\");\n        if(str != null) {\n            max_xmits=Integer.parseInt(str);\n            props.remove(\"max_xmits\");\n        }\n\n\n        if(props.size() > 0) {\n            log.error(\"SMACK.setProperties(): the following properties are not recognized: \" + props);\n\n            return false;\n        }\n        return true;\n    }","id":28158,"modified_method":"public boolean setProperties(Properties props) {\n        String str;\n        long[] tmp;\n\n        super.setProperties(props);\n        str=props.getProperty(\"print_local_addr\");\n        if(str != null) {\n            print_local_addr=Boolean.valueOf(str).booleanValue();\n            props.remove(\"print_local_addr\");\n        }\n\n        str=props.getProperty(\"timeout\");\n        if(str != null) {\n            tmp=Util.parseCommaDelimitedLongs(str);\n            props.remove(\"timeout\");\n            if(tmp != null && tmp.length > 0)\n                timeout=tmp;\n        }\n\n        str=props.getProperty(\"max_xmits\");\n        if(str != null) {\n            max_xmits=Integer.parseInt(str);\n            props.remove(\"max_xmits\");\n        }\n\n\n        if(!props.isEmpty()) {\n            log.error(\"SMACK.setProperties(): the following properties are not recognized: \" + props);\n            return false;\n        }\n        return true;\n    }","commit_id":"ccb78b58157b0d675d6996637f5b00a8035736dc","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Address sender;\n\n        switch(evt.getType()) {\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                addMember(local_addr);\n                if(print_local_addr) {\n                    System.out.println(\"\\n-------------------------------------------------------\\n\" +\n                                       \"GMS: address is \" + local_addr +\n                                       \"\\n-------------------------------------------------------\");\n                }\n                break;\n\n            case Event.CONNECT_OK:\n                passUp(evt);\n                sender_win=new AckMcastSenderWindow(this, timeout);\n\n                // send join announcement\n                Message join_msg=new Message();\n                join_msg.putHeader(name, new SmackHeader(SmackHeader.JOIN_ANNOUNCEMENT, -1));\n                passDown(new Event(Event.MSG, join_msg));\n                return;\n\n            case Event.SUSPECT:\n\n                    if(log.isInfoEnabled()) log.info(\"removing suspected member \" + evt.getArg());\n                removeMember((Address)evt.getArg());\n                break;\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg(), tmp_msg;\n                if(msg == null) break;\n                sender=msg.getSrc();\n                SmackHeader hdr=(SmackHeader)msg.removeHeader(name);\n                if(hdr == null) // is probably a unicast message\n                    break;\n                switch(hdr.type) {\n                    case SmackHeader.MCAST: // send an ack, then pass up (if not already received)\n                        Long tmp_seqno;\n                        AckReceiverWindow win;\n                        Message ack_msg=new Message(sender);\n\n                        ack_msg.putHeader(name, new SmackHeader(SmackHeader.ACK, hdr.seqno));\n                        passDown(new Event(Event.MSG, ack_msg));\n\n                        tmp_seqno=new Long(hdr.seqno);\n\n                        if(trace)\n                            log.trace(\"received #\" + tmp_seqno + \" from \" + sender);\n\n                        win=(AckReceiverWindow)receivers.get(sender);\n                        if(win == null) {\n                            addMember(sender);\n                            win=new AckReceiverWindow(hdr.seqno);\n                            receivers.put(sender, win);\n                        }\n                        boolean added=win.add(hdr.seqno, msg);\n                        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n                        // http://jira.jboss.com/jira/browse/JGRP-379\n                        if(msg.isFlagSet(Message.OOB) && added) {\n                            passUp(new Event(Event.MSG, msg));\n                        }\n\n                        // now remove as many messages as possible\n                        while((tmp_msg=win.remove()) != null) {\n                            // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                            if(tmp_msg.isFlagSet(Message.OOB)) {\n                                continue;\n                            }\n\n                            passUp(new Event(Event.MSG, tmp_msg));\n                        }\n                        return;\n\n                    case SmackHeader.ACK:\n                        addMember(msg.getSrc());\n                        sender_win.ack(hdr.seqno, msg.getSrc());\n                        sender_win.clearStableMessages();\n                        if(trace)\n                            log.trace(\"received ack for #\" + hdr.seqno + \" from \" + msg.getSrc());\n                        return;\n\n                    case SmackHeader.JOIN_ANNOUNCEMENT:\n\n                            if(log.isInfoEnabled()) log.info(\"received join announcement by \" + msg.getSrc());\n\n                        if(!containsMember(sender)) {\n                            Message join_rsp=new Message(sender);\n                            join_rsp.putHeader(name, new SmackHeader(SmackHeader.JOIN_ANNOUNCEMENT, -1));\n                            passDown(new Event(Event.MSG, join_rsp));\n                        }\n                        addMember(sender);\n                        return;\n\n                    case SmackHeader.LEAVE_ANNOUNCEMENT:\n\n                            if(log.isInfoEnabled()) log.info(\"received leave announcement by \" + msg.getSrc());\n\n                        removeMember(sender);\n                        return;\n\n                    default:\n                        if(warn) log.warn(\"detected SmackHeader with invalid type: \" + hdr);\n                        break;\n                }\n                break;\n        }\n\n        passUp(evt);\n    }","id":28159,"modified_method":"public Object up(Event evt) {\n        Address sender;\n\n        switch(evt.getType()) {\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                addMember(local_addr);\n                if(print_local_addr) {\n                    System.out.println(\"\\n-------------------------------------------------------\\n\" +\n                                       \"GMS: address is \" + local_addr +\n                                       \"\\n-------------------------------------------------------\");\n                }\n                break;\n\n            case Event.CONNECT_OK:\n                Object ret=passUp(evt);\n                sender_win=new AckMcastSenderWindow(this, timeout);\n\n                // send join announcement\n                Message join_msg=new Message();\n                join_msg.putHeader(name, new SmackHeader(SmackHeader.JOIN_ANNOUNCEMENT, -1));\n                passDown(new Event(Event.MSG, join_msg));\n                return ret;\n\n            case Event.SUSPECT:\n                if(log.isInfoEnabled()) log.info(\"removing suspected member \" + evt.getArg());\n                removeMember((Address)evt.getArg());\n                break;\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg(), tmp_msg;\n                if(msg == null) break;\n                sender=msg.getSrc();\n                SmackHeader hdr=(SmackHeader)msg.getHeader(name);\n                if(hdr == null) // is probably a unicast message\n                    break;\n                switch(hdr.type) {\n                    case SmackHeader.MCAST: // send an ack, then pass up (if not already received)\n                        Long tmp_seqno;\n                        AckReceiverWindow win;\n                        Message ack_msg=new Message(sender);\n\n                        ack_msg.putHeader(name, new SmackHeader(SmackHeader.ACK, hdr.seqno));\n                        passDown(new Event(Event.MSG, ack_msg));\n\n                        tmp_seqno=new Long(hdr.seqno);\n\n                        if(trace)\n                            log.trace(\"received #\" + tmp_seqno + \" from \" + sender);\n\n                        win=(AckReceiverWindow)receivers.get(sender);\n                        if(win == null) {\n                            addMember(sender);\n                            win=new AckReceiverWindow(hdr.seqno);\n                            receivers.put(sender, win);\n                        }\n                        boolean added=win.add(hdr.seqno, msg);\n                        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n                        // http://jira.jboss.com/jira/browse/JGRP-379\n                        if(msg.isFlagSet(Message.OOB) && added) {\n                            passUp(new Event(Event.MSG, msg));\n                        }\n\n                        // now remove as many messages as possible\n                        while((tmp_msg=win.remove()) != null) {\n                            // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                            if(tmp_msg.isFlagSet(Message.OOB)) {\n                                continue;\n                            }\n\n                            passUp(new Event(Event.MSG, tmp_msg));\n                        }\n                        return null;\n\n                    case SmackHeader.ACK:\n                        addMember(msg.getSrc());\n                        sender_win.ack(hdr.seqno, msg.getSrc());\n                        sender_win.clearStableMessages();\n                        if(trace)\n                            log.trace(\"received ack for #\" + hdr.seqno + \" from \" + msg.getSrc());\n                        return null;\n\n                    case SmackHeader.JOIN_ANNOUNCEMENT:\n\n                            if(log.isInfoEnabled()) log.info(\"received join announcement by \" + msg.getSrc());\n\n                        if(!containsMember(sender)) {\n                            Message join_rsp=new Message(sender);\n                            join_rsp.putHeader(name, new SmackHeader(SmackHeader.JOIN_ANNOUNCEMENT, -1));\n                            passDown(new Event(Event.MSG, join_rsp));\n                        }\n                        addMember(sender);\n                        return null;\n\n                    case SmackHeader.LEAVE_ANNOUNCEMENT:\n                        if(log.isInfoEnabled()) log.info(\"received leave announcement by \" + msg.getSrc());\n                        removeMember(sender);\n                        return null;\n\n                    default:\n                        if(warn) log.warn(\"detected SmackHeader with invalid type: \" + hdr);\n                        break;\n                }\n                break;\n        }\n\n        return passUp(evt);\n    }","commit_id":"ccb78b58157b0d675d6996637f5b00a8035736dc","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        Message leave_msg;\n\n        switch(evt.getType()) {\n\n            case Event.DISCONNECT:\n                leave_msg=new Message();\n                leave_msg.putHeader(name, new SmackHeader(SmackHeader.LEAVE_ANNOUNCEMENT, -1));\n                passDown(new Event(Event.MSG, leave_msg));\n                // passUp(new Event(Event.DISCONNECT_OK));\n                break;\n\n            case Event.CONNECT:\n                //passUp(new Event(Event.CONNECT_OK));\n\n                // Do not send JOIN_ANOUNCEMENT here, don't know yet if the transport is OK.\n                // Send it later when handling CONNECT_OK from below\n\n//                 sender_win=new AckMcastSenderWindow(this, timeout);\n//                 // send join announcement\n//                 Message join_msg=new Message();\n//                 join_msg.putHeader(name, new SmackHeader(SmackHeader.JOIN_ANNOUNCEMENT, -1));\n//                 passDown(new Event(Event.MSG, join_msg));\n//                 return;\n\n                break;\n\n\n// add a header with the current sequence number and increment seqno\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                if(msg == null) break;\n                if(msg.getDest() == null || msg.getDest().isMulticastAddress()) {\n                    msg.putHeader(name, new SmackHeader(SmackHeader.MCAST, seqno));\n                    sender_win.add(seqno, msg, (Vector)members.clone());\n                    if(trace) log.trace(\"sending mcast #\" + seqno);\n                    seqno++;\n                }\n                break;\n        }\n\n        passDown(evt);\n    }","id":28160,"modified_method":"public Object down(Event evt) {\n        Message leave_msg;\n\n        switch(evt.getType()) {\n\n            case Event.DISCONNECT:\n                leave_msg=new Message();\n                leave_msg.putHeader(name, new SmackHeader(SmackHeader.LEAVE_ANNOUNCEMENT, -1));\n                passDown(new Event(Event.MSG, leave_msg));\n                // passUp(new Event(Event.DISCONNECT_OK));\n                break;\n\n            case Event.CONNECT:\n                //passUp(new Event(Event.CONNECT_OK));\n\n                // Do not send JOIN_ANOUNCEMENT here, don't know yet if the transport is OK.\n                // Send it later when handling CONNECT_OK from below\n\n//                 sender_win=new AckMcastSenderWindow(this, timeout);\n//                 // send join announcement\n//                 Message join_msg=new Message();\n//                 join_msg.putHeader(name, new SmackHeader(SmackHeader.JOIN_ANNOUNCEMENT, -1));\n//                 passDown(new Event(Event.MSG, join_msg));\n//                 return;\n\n                break;\n\n\n// add a header with the current sequence number and increment seqno\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                if(msg == null) break;\n                if(msg.getDest() == null || msg.getDest().isMulticastAddress()) {\n                    msg.putHeader(name, new SmackHeader(SmackHeader.MCAST, seqno));\n                    sender_win.add(seqno, msg, (Vector)members.clone());\n                    if(trace) log.trace(\"sending mcast #\" + seqno);\n                    seqno++;\n                }\n                break;\n        }\n\n        return passDown(evt);\n    }","commit_id":"ccb78b58157b0d675d6996637f5b00a8035736dc","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Header  h;\n        Message msg;\n        int     type;\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n            h=msg.removeHeader(name);\n            if(h != null && h instanceof BshHeader) {\n                type=((BshHeader)h).type;\n                switch(type) {\n                    case BshHeader.REQ:\n                        handleRequest(msg.getSrc(), msg.getBuffer());\n                        return;\n                    case BshHeader.RSP:\n                        msg.putHeader(name, h);\n                        passUp(evt);\n                        return;\n                    case BshHeader.DESTROY_INTERPRETER:\n                        destroyInterpreter();\n                        return;\n                    default:\n                        if(log.isErrorEnabled()) log.error(\"header type was not REQ as expected\" +\n                                    \" (was \" + type + ')');\n                        return;\n                }\n            }\n        }\n        passUp(evt);\n    }","id":28161,"modified_method":"public Object up(Event evt) {\n        Header  h;\n        Message msg;\n        int     type;\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n            h=msg.getHeader(name);\n            if(h instanceof BshHeader) {\n                type=((BshHeader)h).type;\n                switch(type) {\n                    case BshHeader.REQ:\n                        handleRequest(msg.getSrc(), msg.getBuffer());\n                        return null;\n                    case BshHeader.RSP:\n                        msg.putHeader(name, h);\n                        passUp(evt);\n                        return null;\n                    case BshHeader.DESTROY_INTERPRETER:\n                        destroyInterpreter();\n                        return null;\n                    default:\n                        if(log.isErrorEnabled()) log.error(\"header type was not REQ as expected (was \" + type + ')');\n                        return null;\n                }\n            }\n        }\n        return passUp(evt);\n    }","commit_id":"6d0265cd6eb22110a1fbbec49f60ee90286a12d0","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n            StringBuffer sb=new StringBuffer();\n            if(type == REQ)\n                sb.append(\"REQ\");\n            else\n                if(type == RSP)\n                    sb.append(\"RSP\");\n                else\n                    if(type == DESTROY_INTERPRETER)\n                        sb.append(\"DESTROY_INTERPRETER\");\n                    else\n                        sb.append(\"<unknown type>\");\n            return sb.toString();\n        }","id":28162,"modified_method":"public String toString() {\n            StringBuilder sb=new StringBuilder();\n            if(type == REQ)\n                sb.append(\"REQ\");\n            else\n                if(type == RSP)\n                    sb.append(\"RSP\");\n                else\n                    if(type == DESTROY_INTERPRETER)\n                        sb.append(\"DESTROY_INTERPRETER\");\n                    else\n                        sb.append(\"<unknown type>\");\n            return sb.toString();\n        }","commit_id":"6d0265cd6eb22110a1fbbec49f60ee90286a12d0","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Message msg;\n        double r;\n\n        if(evt.getType() == Event.SET_LOCAL_ADDRESS)\n            localAddress=(Address)evt.getArg();\n\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n            if(up > 0) {\n                r=Math.random();\n                if(r < up) {\n                    if(excludeItself && msg.getSrc().equals(localAddress)) {\n                        if(log.isTraceEnabled()) log.trace(\"excluding itself\");\n                    }\n                    else {\n                        if(log.isTraceEnabled()) log.trace(\"dropping message\");\n                        num_up++;\n                        return;\n                    }\n                }\n            }\n        }\n\n\n        passUp(evt);\n    }","id":28163,"modified_method":"public Object up(Event evt) {\n        Message msg;\n        double r;\n\n        if(evt.getType() == Event.SET_LOCAL_ADDRESS)\n            localAddress=(Address)evt.getArg();\n\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n            if(up > 0) {\n                r=Math.random();\n                if(r < up) {\n                    if(excludeItself && msg.getSrc().equals(localAddress)) {\n                        if(log.isTraceEnabled()) log.trace(\"excluding itself\");\n                    }\n                    else {\n                        if(log.isTraceEnabled()) log.trace(\"dropping message\");\n                        num_up++;\n                        return null;\n                    }\n                }\n            }\n        }\n\n        return passUp(evt);\n    }","commit_id":"6d0265cd6eb22110a1fbbec49f60ee90286a12d0","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean setProperties(Properties props) {\n        String str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"up\");\n        if(str != null) {\n            up=Double.parseDouble(str);\n            props.remove(\"up\");\n        }\n\n        str=props.getProperty(\"down\");\n        if(str != null) {\n            down=Double.parseDouble(str);\n            props.remove(\"down\");\n        }\n\n        str=props.getProperty(\"excludeitself\");\n        if(str != null) {\n            excludeItself=Boolean.valueOf(str).booleanValue();\n            props.remove(\"excludeitself\");\n        }\n\n\n        if(props.size() > 0) {\n            log.error(\"DISCARD.setProperties(): these properties are not recognized: \" + props);\n\n            return false;\n        }\n        return true;\n    }","id":28164,"modified_method":"public boolean setProperties(Properties props) {\n        String str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"up\");\n        if(str != null) {\n            up=Double.parseDouble(str);\n            props.remove(\"up\");\n        }\n\n        str=props.getProperty(\"down\");\n        if(str != null) {\n            down=Double.parseDouble(str);\n            props.remove(\"down\");\n        }\n\n        str=props.getProperty(\"excludeitself\");\n        if(str != null) {\n            excludeItself=Boolean.valueOf(str).booleanValue();\n            props.remove(\"excludeitself\");\n        }\n\n\n        if(!props.isEmpty()) {\n            log.error(\"DISCARD.setProperties(): these properties are not recognized: \" + props);\n            return false;\n        }\n        return true;\n    }","commit_id":"6d0265cd6eb22110a1fbbec49f60ee90286a12d0","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        Message msg;\n        double r;\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n\n            if(down > 0) {\n                r=Math.random();\n                if(r < down) {\n                    if(excludeItself && msg.getSrc().equals(localAddress)) {\n                        if(log.isTraceEnabled()) log.trace(\"excluding itself\");\n                    }\n                    else {\n                        if(log.isTraceEnabled())\n                            log.trace(\"dropping message\");\n                        num_down++;\n                        return;\n                    }\n                }\n            }\n\n        }\n        passDown(evt);\n    }","id":28165,"modified_method":"public Object down(Event evt) {\n        Message msg;\n        double r;\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n\n            if(down > 0) {\n                r=Math.random();\n                if(r < down) {\n                    if(excludeItself && msg.getSrc().equals(localAddress)) {\n                        if(log.isTraceEnabled()) log.trace(\"excluding itself\");\n                    }\n                    else {\n                        if(log.isTraceEnabled())\n                            log.trace(\"dropping message\");\n                        num_down++;\n                        return null;\n                    }\n                }\n            }\n        }\n\n        return passDown(evt);\n    }","commit_id":"6d0265cd6eb22110a1fbbec49f60ee90286a12d0","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * <b>Callback<\/b>. Called by superclass when event may be handled.<p> <b>Do not use <code>PassUp<\/code> in this\n     * method as the event is passed up by default by the superclass after this method returns !<\/b>\n     */\n    public Object up(Event evt) {\n        NakAckHeader hdr;\n        Message msg;\n        Digest digest;\n\n        switch(evt.getType()) {\n\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            hdr=(NakAckHeader)msg.getHeader(name);\n            if(hdr == null)\n                break;  // pass up (e.g. unicast msg)\n\n            // discard messages while not yet server (i.e., until JOIN has returned)\n            if(!is_server) {\n                if(trace)\n                    log.trace(\"message was discarded (not yet server)\");\n                return;\n            }\n\n            // Changed by bela Jan 29 2003: we must not remove the header, otherwise\n            // further xmit requests will fail !\n            //hdr=(NakAckHeader)msg.removeHeader(getName());\n\n            switch(hdr.type) {\n\n            case NakAckHeader.MSG:\n                handleMessage(msg, hdr);\n                return;        // transmitter passes message up for us !\n\n            case NakAckHeader.XMIT_REQ:\n                if(hdr.range == null) {\n                    if(log.isErrorEnabled()) {\n                        log.error(\"XMIT_REQ: range of xmit msg is null; discarding request from \" + msg.getSrc());\n                    }\n                    return;\n                }\n                handleXmitReq(msg.getSrc(), hdr.range.low, hdr.range.high, hdr.sender);\n                return;\n\n            case NakAckHeader.XMIT_RSP:\n                if(trace)\n                    log.trace(\"received missing messages \" + hdr.range);\n                handleXmitRsp(msg);\n                return;\n\n            default:\n                if(log.isErrorEnabled()) {\n                    log.error(\"NakAck header type \" + hdr.type + \" not known !\");\n                }\n                return;\n            }\n\n        case Event.STABLE:  // generated by STABLE layer. Delete stable messages passed in arg\n            stable((Digest)evt.getArg());\n            return;  // do not pass up further (Bela Aug 7 2001)\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address)evt.getArg();\n            break;\n\n        case Event.CONFIG:\n            passUp(evt);\n            if(log.isDebugEnabled()) {\n                log.debug(\"received CONFIG event: \" + evt.getArg());\n            }\n            handleConfigEvent((HashMap)evt.getArg());\n            return;\n        }\n        passUp(evt);\n    }","id":28166,"modified_method":"/**\n     * <b>Callback<\/b>. Called by superclass when event may be handled.<p> <b>Do not use <code>PassUp<\/code> in this\n     * method as the event is passed up by default by the superclass after this method returns !<\/b>\n     */\n    public Object up(Event evt) {\n        NakAckHeader hdr;\n        Message msg;\n\n        switch(evt.getType()) {\n\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            hdr=(NakAckHeader)msg.getHeader(name);\n            if(hdr == null)\n                break;  // pass up (e.g. unicast msg)\n\n            // discard messages while not yet server (i.e., until JOIN has returned)\n            if(!is_server) {\n                if(trace)\n                    log.trace(\"message was discarded (not yet server)\");\n                return null;\n            }\n\n            // Changed by bela Jan 29 2003: we must not remove the header, otherwise\n            // further xmit requests will fail !\n            //hdr=(NakAckHeader)msg.removeHeader(getName());\n\n            switch(hdr.type) {\n\n            case NakAckHeader.MSG:\n                handleMessage(msg, hdr);\n                return null;        // transmitter passes message up for us !\n\n            case NakAckHeader.XMIT_REQ:\n                if(hdr.range == null) {\n                    if(log.isErrorEnabled()) {\n                        log.error(\"XMIT_REQ: range of xmit msg is null; discarding request from \" + msg.getSrc());\n                    }\n                    return null;\n                }\n                handleXmitReq(msg.getSrc(), hdr.range.low, hdr.range.high, hdr.sender);\n                return null;\n\n            case NakAckHeader.XMIT_RSP:\n                if(trace)\n                    log.trace(\"received missing messages \" + hdr.range);\n                handleXmitRsp(msg);\n                return null;\n\n            default:\n                if(log.isErrorEnabled()) {\n                    log.error(\"NakAck header type \" + hdr.type + \" not known !\");\n                }\n                return null;\n            }\n\n        case Event.STABLE:  // generated by STABLE layer. Delete stable messages passed in arg\n            stable((Digest)evt.getArg());\n            return null;  // do not pass up further (Bela Aug 7 2001)\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address)evt.getArg();\n            break;\n\n        case Event.CONFIG:\n            passUp(evt);\n            if(log.isDebugEnabled()) {\n                log.debug(\"received CONFIG event: \" + evt.getArg());\n            }\n            handleConfigEvent((HashMap)evt.getArg());\n            return null;\n        }\n        return passUp(evt);\n    }","commit_id":"9329d5a9b67047c027f722cefa3725f21f56257e","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        PbcastHeader hdr;\n        Message m, copy;\n        View v;\n        Vector mbrs;\n        Address key;\n        NakReceiverWindow win;\n\n\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                m=(Message) evt.getArg();\n                if(m.getDest() != null && !m.getDest().isMulticastAddress()) {\n                    break; // unicast address: not null and not mcast, pass down unchanged\n                }\n                else {      // multicast address\n                    hdr=new PbcastHeader(PbcastHeader.MCAST_MSG, seqno);\n                    m.putHeader(getName(), hdr);\n\n                    // put message in NakReceiverWindow (to be on the safe side if we don't receive it ...)\n                    synchronized(digest) {\n                        win=(NakReceiverWindow) digest.get(local_addr);\n                        if(win == null) {\n                            if(log.isInfoEnabled()) log.info(\"NakReceiverWindow for sender \" + local_addr +\n                                                        \" not found. Creating new NakReceiverWindow starting at seqno=\" + seqno);\n                            win=new NakReceiverWindow(local_addr, seqno);\n                            digest.put(local_addr, win);\n                        }\n                        copy=m.copy();\n                        copy.setSrc(local_addr);\n                        win.add(seqno, copy);\n                    }\n                    seqno++;\n                    break;\n                }\n\n            case Event.SET_DIGEST:\n                setDigest((Digest) evt.getArg());\n                return;  // don't pass down\n\n            case Event.GET_DIGEST:  // don't pass down\n                passUp(new Event(Event.GET_DIGEST_OK, getDigest()));\n                return;\n\n            case Event.GET_DIGEST_STATE:  // don't pass down\n                return getDigest();\n\n            case Event.VIEW_CHANGE:\n                v=(View) evt.getArg();\n                if(v == null) {\n                    if(log.isErrorEnabled()) log.error(\"view is null !\");\n                    break;\n                }\n                mbrs=v.getMembers();\n\n                // update internal membership list\n                synchronized(members) {\n                    members.removeAllElements();\n                    for(int i=0; i < mbrs.size(); i++)\n                        members.addElement(mbrs.elementAt(i));\n                }\n\n                // delete all members in digest that are not in new membership list\n                if(mbrs.size() > 0) {\n                    synchronized(digest) {\n                        for(Enumeration e=digest.keys(); e.hasMoreElements();) {\n                            key=(Address) e.nextElement();\n                            if(!mbrs.contains(key)) {\n                                win=(NakReceiverWindow) digest.get(key);\n                                win.reset();\n                                digest.remove(key);\n                            }\n                        }\n                    }\n                }\n\n                // add all members from new membership list that are not yet in digest\n                for(int i=0; i < mbrs.size(); i++) {\n                    key=(Address) mbrs.elementAt(i);\n                    if(!digest.containsKey(key)) {\n                        digest.put(key, new NakReceiverWindow(key, 1));\n                    }\n                }\n\n                if(dynamic) {\n                    gossip_interval=computeGossipInterval(members.size(), desired_avg_gossip);\n\n                        if(log.isInfoEnabled()) log.info(\"VIEW_CHANGE: gossip_interval=\" + gossip_interval);\n                    if(gossip_thread != null) {\n                        skip_sleep=true;\n                        gossip_thread.interrupt(); // wake up and sleep according to the new gossip_interval\n                    }\n                }\n\n                startGossipThread();  // will only be started if not yet running\n                startGossipHandler();\n                break;\n\n            case Event.BECOME_SERVER:\n                operational=true;\n                break;\n        }\n\n        passDown(evt);\n    }","id":28167,"modified_method":"public Object down(Event evt) {\n        PbcastHeader hdr;\n        Message m, copy;\n        View v;\n        Vector mbrs;\n        Address key;\n        NakReceiverWindow win;\n\n\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                m=(Message) evt.getArg();\n                if(m.getDest() != null && !m.getDest().isMulticastAddress()) {\n                    break; // unicast address: not null and not mcast, pass down unchanged\n                }\n                else {      // multicast address\n                    hdr=new PbcastHeader(PbcastHeader.MCAST_MSG, seqno);\n                    m.putHeader(getName(), hdr);\n\n                    // put message in NakReceiverWindow (to be on the safe side if we don't receive it ...)\n                    synchronized(digest) {\n                        win=(NakReceiverWindow) digest.get(local_addr);\n                        if(win == null) {\n                            if(log.isInfoEnabled()) log.info(\"NakReceiverWindow for sender \" + local_addr +\n                                                        \" not found. Creating new NakReceiverWindow starting at seqno=\" + seqno);\n                            win=new NakReceiverWindow(local_addr, seqno);\n                            digest.put(local_addr, win);\n                        }\n                        copy=m.copy();\n                        copy.setSrc(local_addr);\n                        win.add(seqno, copy);\n                    }\n                    seqno++;\n                    break;\n                }\n\n            case Event.SET_DIGEST:\n                setDigest((Digest) evt.getArg());\n                return null;  // don't pass down\n\n            case Event.GET_DIGEST:  // don't pass down\n                passUp(new Event(Event.GET_DIGEST_OK, getDigest()));\n                return null;\n\n            case Event.GET_DIGEST_STATE:  // don't pass down\n                return getDigest();\n\n            case Event.VIEW_CHANGE:\n                v=(View) evt.getArg();\n                if(v == null) {\n                    if(log.isErrorEnabled()) log.error(\"view is null !\");\n                    break;\n                }\n                mbrs=v.getMembers();\n\n                // update internal membership list\n                synchronized(members) {\n                    members.removeAllElements();\n                    for(int i=0; i < mbrs.size(); i++)\n                        members.addElement(mbrs.elementAt(i));\n                }\n\n                // delete all members in digest that are not in new membership list\n                if(!mbrs.isEmpty()) {\n                    synchronized(digest) {\n                        for(Enumeration e=digest.keys(); e.hasMoreElements();) {\n                            key=(Address) e.nextElement();\n                            if(!mbrs.contains(key)) {\n                                win=(NakReceiverWindow) digest.get(key);\n                                win.reset();\n                                digest.remove(key);\n                            }\n                        }\n                    }\n                }\n\n                // add all members from new membership list that are not yet in digest\n                for(int i=0; i < mbrs.size(); i++) {\n                    key=(Address) mbrs.elementAt(i);\n                    if(!digest.containsKey(key)) {\n                        digest.put(key, new NakReceiverWindow(key, 1));\n                    }\n                }\n\n                if(dynamic) {\n                    gossip_interval=computeGossipInterval(members.size(), desired_avg_gossip);\n\n                        if(log.isInfoEnabled()) log.info(\"VIEW_CHANGE: gossip_interval=\" + gossip_interval);\n                    if(gossip_thread != null) {\n                        skip_sleep=true;\n                        gossip_thread.interrupt(); // wake up and sleep according to the new gossip_interval\n                    }\n                }\n\n                startGossipThread();  // will only be started if not yet running\n                startGossipHandler();\n                break;\n\n            case Event.BECOME_SERVER:\n                operational=true;\n                break;\n        }\n\n        return passDown(evt);\n    }","commit_id":"9329d5a9b67047c027f722cefa3725f21f56257e","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Setup the Protocol instance acording to the configuration string */\n    public boolean setProperties(Properties props) {super.setProperties(props);\n        String str;\n\n        str=props.getProperty(\"dynamic\");\n        if(str != null) {\n            dynamic=Boolean.valueOf(str).booleanValue();\n            props.remove(\"dynamic\");\n        }\n\n        str=props.getProperty(\"shun\");\n        if(str != null) {\n            shun=Boolean.valueOf(str).booleanValue();\n            props.remove(\"shun\");\n        }\n\n        str=props.getProperty(\"gossip_interval\");\n        if(str != null) {\n            gossip_interval=Long.parseLong(str);\n            props.remove(\"gossip_interval\");\n        }\n\n        str=props.getProperty(\"mcast_gossip\");\n        if(str != null) {\n            mcast_gossip=Boolean.valueOf(str).booleanValue();\n            props.remove(\"mcast_gossip\");\n        }\n\n        str=props.getProperty(\"subset\");\n        if(str != null) {\n            subset=Double.parseDouble(str);\n            props.remove(\"subset\");\n        }\n\n        str=props.getProperty(\"desired_avg_gossip\");\n        if(str != null) {\n            desired_avg_gossip=Long.parseLong(str);\n            props.remove(\"desired_avg_gossip\");\n        }\n\n        str=props.getProperty(\"max_queue\");\n        if(str != null) {\n            max_queue=Integer.parseInt(str);\n            props.remove(\"max_queue\");\n        }\n\n        str=props.getProperty(\"max_gossip_cache\");\n        if(str != null) {\n            max_gossip_cache=Integer.parseInt(str);\n            props.remove(\"max_gossip_cache\");\n        }\n\n        str=props.getProperty(\"gc_lag\");\n        if(str != null) {\n            gc_lag=Integer.parseInt(str);\n            props.remove(\"gc_lag\");\n        }\n\n        if(props.size() > 0) {\n            log.error(\"PBCAST.setProperties(): the following properties are not recognized: \" + props);\n            \n            return false;\n        }\n        return true;\n    }","id":28168,"modified_method":"/** Setup the Protocol instance acording to the configuration string */\n    public boolean setProperties(Properties props) {super.setProperties(props);\n        String str;\n\n        str=props.getProperty(\"dynamic\");\n        if(str != null) {\n            dynamic=Boolean.valueOf(str).booleanValue();\n            props.remove(\"dynamic\");\n        }\n\n        str=props.getProperty(\"shun\");\n        if(str != null) {\n            shun=Boolean.valueOf(str).booleanValue();\n            props.remove(\"shun\");\n        }\n\n        str=props.getProperty(\"gossip_interval\");\n        if(str != null) {\n            gossip_interval=Long.parseLong(str);\n            props.remove(\"gossip_interval\");\n        }\n\n        str=props.getProperty(\"mcast_gossip\");\n        if(str != null) {\n            mcast_gossip=Boolean.valueOf(str).booleanValue();\n            props.remove(\"mcast_gossip\");\n        }\n\n        str=props.getProperty(\"subset\");\n        if(str != null) {\n            subset=Double.parseDouble(str);\n            props.remove(\"subset\");\n        }\n\n        str=props.getProperty(\"desired_avg_gossip\");\n        if(str != null) {\n            desired_avg_gossip=Long.parseLong(str);\n            props.remove(\"desired_avg_gossip\");\n        }\n\n        str=props.getProperty(\"max_queue\");\n        if(str != null) {\n            max_queue=Integer.parseInt(str);\n            props.remove(\"max_queue\");\n        }\n\n        str=props.getProperty(\"max_gossip_cache\");\n        if(str != null) {\n            max_gossip_cache=Integer.parseInt(str);\n            props.remove(\"max_gossip_cache\");\n        }\n\n        str=props.getProperty(\"gc_lag\");\n        if(str != null) {\n            gc_lag=Integer.parseInt(str);\n            props.remove(\"gc_lag\");\n        }\n\n        if(!props.isEmpty()) {\n            log.error(\"PBCAST.setProperties(): the following properties are not recognized: \" + props);\n            return false;\n        }\n        return true;\n    }","commit_id":"9329d5a9b67047c027f722cefa3725f21f56257e","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Message m;\n        PbcastHeader hdr;\n        Address sender=null;\n\n        switch(evt.getType()) {\n            case Event.MSG:\n                m=(Message) evt.getArg();\n                if(m.getDest() != null && !m.getDest().isMulticastAddress()) {\n                    if(!(m.getHeader(getName()) instanceof PbcastHeader))\n                        break; // unicast address: not null and not mcast, pass up unchanged\n                }\n\n                // discard all multicast messages until we become operational (transition from joiner to member)\n                if(!operational) {\n\n                        if(log.isInfoEnabled()) log.info(\"event was discarded as I'm not yet operational. Event: \" +\n                                                  Util.printEvent(evt));\n                    return;  // don't pass up\n                }\n\n                if(m.getHeader(getName()) instanceof PbcastHeader)\n                    hdr=(PbcastHeader) m.getHeader(getName());\n                else {\n                    sender=m.getSrc();\n                    if(log.isErrorEnabled()) log.error(\"PbcastHeader expected, but received header of type \" +\n                            m.getHeader(getName()).getClass().getName() + \" from \" + sender +\n                            \". Passing event up unchanged\");\n                    break;\n                }\n\n                switch(hdr.type) {\n                    case PbcastHeader.MCAST_MSG:  // messages are handled directly (high priority)\n                        handleUpMessage(m, hdr);\n                        return;\n\n                        // all other requests are put in the bounded gossip queue (discarded if full). this helps to ensure\n                        // that no 'gossip storms' will occur (overflowing the buffers and the network)\n                    case PbcastHeader.GOSSIP:\n                    case PbcastHeader.XMIT_REQ:\n                    case PbcastHeader.XMIT_RSP:\n                    case PbcastHeader.NOT_MEMBER:\n                        try {\n                            if(gossip_queue.size() >= max_queue) {\n\n                                    if(warn) log.warn(\"gossip request \" +\n                                                              PbcastHeader.type2String(hdr.type) + \" discarded because \" +\n                                                              \"gossip_queue is full (number of elements=\" + gossip_queue.size() + ')');\n                                return;\n                            }\n                            gossip_queue.add(new GossipEntry(hdr, m.getSrc(), m.getBuffer()));\n                        }\n                        catch(Exception ex) {\n                            if(warn) log.warn(\"exception adding request to gossip_queue, details=\" + ex);\n                        }\n                        return;\n\n                    default:\n                        if(log.isErrorEnabled()) log.error(\"type (\" + hdr.type + \") of PbcastHeader not known !\");\n                        return;\n                }\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address) evt.getArg();\n                break;  // pass up\n        }\n\n        passUp(evt);  // pass up by default\n    }","id":28169,"modified_method":"public Object up(Event evt) {\n        Message m;\n        PbcastHeader hdr;\n        Address sender=null;\n\n        switch(evt.getType()) {\n            case Event.MSG:\n                m=(Message) evt.getArg();\n                if(m.getDest() != null && !m.getDest().isMulticastAddress()) {\n                    if(!(m.getHeader(getName()) instanceof PbcastHeader))\n                        break; // unicast address: not null and not mcast, pass up unchanged\n                }\n\n                // discard all multicast messages until we become operational (transition from joiner to member)\n                if(!operational) {\n                    if(log.isInfoEnabled()) log.info(\"event was discarded as I'm not yet operational. Event: \" +\n                            Util.printEvent(evt));\n                    return null;  // don't pass up\n                }\n\n                if(m.getHeader(getName()) instanceof PbcastHeader)\n                    hdr=(PbcastHeader) m.getHeader(getName());\n                else {\n                    sender=m.getSrc();\n                    if(log.isErrorEnabled()) log.error(\"PbcastHeader expected, but received header of type \" +\n                            m.getHeader(getName()).getClass().getName() + \" from \" + sender +\n                            \". Passing event up unchanged\");\n                    break;\n                }\n\n                switch(hdr.type) {\n                    case PbcastHeader.MCAST_MSG:  // messages are handled directly (high priority)\n                        handleUpMessage(m, hdr);\n                        return null;\n\n                        // all other requests are put in the bounded gossip queue (discarded if full). this helps to ensure\n                        // that no 'gossip storms' will occur (overflowing the buffers and the network)\n                    case PbcastHeader.GOSSIP:\n                    case PbcastHeader.XMIT_REQ:\n                    case PbcastHeader.XMIT_RSP:\n                    case PbcastHeader.NOT_MEMBER:\n                        try {\n                            if(gossip_queue.size() >= max_queue) {\n                                if(warn) log.warn(\"gossip request \" +\n                                        PbcastHeader.type2String(hdr.type) + \" discarded because \" +\n                                        \"gossip_queue is full (number of elements=\" + gossip_queue.size() + ')');\n                                return null;\n                            }\n                            gossip_queue.add(new GossipEntry(hdr, m.getSrc(), m.getBuffer()));\n                        }\n                        catch(Exception ex) {\n                            if(warn) log.warn(\"exception adding request to gossip_queue, details=\" + ex);\n                        }\n                        return null;\n\n                    default:\n                        if(log.isErrorEnabled()) log.error(\"type (\" + hdr.type + \") of PbcastHeader not known !\");\n                        return null;\n                }\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address) evt.getArg();\n                break;  // pass up\n        }\n\n        return passUp(evt);  // pass up by default\n    }","commit_id":"9329d5a9b67047c027f722cefa3725f21f56257e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * An event is to be sent down the stack. The layer may want to examine its type and perform\n     * some action on it, depending on the event's type. If the event is a message MSG, then\n     * the layer may need to add a header to it (or do nothing at all) before sending it down\n     * the stack using <code>PassDown<\/code>. In case of a GET_ADDRESS event (which tries to\n     * retrieve the stack's address from one of the bottom layers), the layer may need to send\n     * a new response event back up the stack using <code>passUp()<\/code>.\n     * The PING protocol is interested in several different down events,\n     * Event.FIND_INITIAL_MBRS - sent by the GMS layer and expecting a GET_MBRS_OK\n     * Event.TMP_VIEW and Event.VIEW_CHANGE - a view change event\n     * Event.BECOME_SERVER - called after client has joined and is fully working group member\n     * Event.CONNECT, Event.DISCONNECT.\n     */\n    public Object down(Event evt) {\n\n        switch(evt.getType()) {\n\n        case Event.FIND_INITIAL_MBRS:   // sent by GMS layer, pass up a GET_MBRS_OK event\n            // sends the GET_MBRS_REQ to all members, waits 'timeout' ms or until 'num_initial_members' have been retrieved\n            num_discovery_requests++;\n            ping_waiter.start();\n            break;\n\n        case Event.TMP_VIEW:\n        case Event.VIEW_CHANGE:\n            Vector tmp;\n            if((tmp=((View)evt.getArg()).getMembers()) != null) {\n                synchronized(members) {\n                    members.clear();\n                    members.addAll(tmp);\n                }\n            }\n            passDown(evt);\n            break;\n\n        case Event.BECOME_SERVER: // called after client has joined and is fully working group member\n            passDown(evt);\n            is_server=true;\n            break;\n\n        case Event.CONNECT:\n            group_addr=(String)evt.getArg();\n            passDown(evt);\n            handleConnect();\n            break;\n\n        case Event.DISCONNECT:\n            handleDisconnect();\n            passDown(evt);\n            break;\n\n        default:\n            passDown(evt);          // Pass on to the layer below us\n            break;\n        }\n    }","id":28170,"modified_method":"/**\n     * An event is to be sent down the stack. The layer may want to examine its type and perform\n     * some action on it, depending on the event's type. If the event is a message MSG, then\n     * the layer may need to add a header to it (or do nothing at all) before sending it down\n     * the stack using <code>PassDown<\/code>. In case of a GET_ADDRESS event (which tries to\n     * retrieve the stack's address from one of the bottom layers), the layer may need to send\n     * a new response event back up the stack using <code>passUp()<\/code>.\n     * The PING protocol is interested in several different down events,\n     * Event.FIND_INITIAL_MBRS - sent by the GMS layer and expecting a GET_MBRS_OK\n     * Event.TMP_VIEW and Event.VIEW_CHANGE - a view change event\n     * Event.BECOME_SERVER - called after client has joined and is fully working group member\n     * Event.CONNECT, Event.DISCONNECT.\n     */\n    public Object down(Event evt) {\n\n        switch(evt.getType()) {\n\n        case Event.FIND_INITIAL_MBRS:   // sent by GMS layer, pass up a GET_MBRS_OK event\n            // sends the GET_MBRS_REQ to all members, waits 'timeout' ms or until 'num_initial_members' have been retrieved\n            num_discovery_requests++;\n            ping_waiter.start();\n            return null;\n\n        case Event.TMP_VIEW:\n        case Event.VIEW_CHANGE:\n            Vector tmp;\n            if((tmp=((View)evt.getArg()).getMembers()) != null) {\n                synchronized(members) {\n                    members.clear();\n                    members.addAll(tmp);\n                }\n            }\n            return passDown(evt);\n\n        case Event.BECOME_SERVER: // called after client has joined and is fully working group member\n            passDown(evt);\n            is_server=true;\n            return null;\n\n        case Event.CONNECT:\n            group_addr=(String)evt.getArg();\n            Object ret=passDown(evt);\n            handleConnect();\n            return ret;\n\n        case Event.DISCONNECT:\n            handleDisconnect();\n            return passDown(evt);\n\n        default:\n            return passDown(evt);          // Pass on to the layer below us\n        }\n    }","commit_id":"71858a495b75a79e5a3b6e8a8f895a16a5e67c72","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * An event was received from the layer below. Usually the current layer will want to examine\n     * the event type and - depending on its type - perform some computation\n     * (e.g. removing headers from a MSG event type, or updating the internal membership list\n     * when receiving a VIEW_CHANGE event).\n     * Finally the event is either a) discarded, or b) an event is sent down\n     * the stack using <code>PassDown<\/code> or c) the event (or another event) is sent up\n     * the stack using <code>PassUp<\/code>.\n     * <p/>\n     * For the PING protocol, the Up operation does the following things.\n     * 1. If the event is a Event.MSG then PING will inspect the message header.\n     * If the header is null, PING simply passes up the event\n     * If the header is PingHeader.GET_MBRS_REQ then the PING protocol\n     * will PassDown a PingRequest message\n     * If the header is PingHeader.GET_MBRS_RSP we will add the message to the initial members\n     * vector and wake up any waiting threads.\n     * 2. If the event is Event.SET_LOCAL_ADDR we will simple set the local address of this protocol\n     * 3. For all other messages we simple pass it up to the protocol above\n     *\n     * @param evt - the event that has been sent from the layer below\n     */\n\n    public Object up(Event evt) {\n        Message msg, rsp_msg;\n        PingHeader rsp_hdr;\n        PingRsp rsp;\n        Address coord;\n\n        switch(evt.getType()) {\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            PingHeader hdr=(PingHeader)msg.getHeader(getName());\n            if(hdr == null) {\n                passUp(evt);\n                return;\n            }\n\n            switch(hdr.type) {\n\n            case PingHeader.GET_MBRS_REQ:   // return Rsp(local_addr, coord)\n                if(local_addr != null && msg.getSrc() != null && local_addr.equals(msg.getSrc())) {\n                    return;\n                }\n                synchronized(members) {\n                    coord=!members.isEmpty()? (Address)members.firstElement() : local_addr;\n                }\n\n                PingRsp ping_rsp=new PingRsp(local_addr, coord, is_server);\n                rsp_msg=new Message(msg.getSrc(), null, null);\n                rsp_msg.setFlag(Message.OOB);\n                rsp_hdr=new PingHeader(PingHeader.GET_MBRS_RSP, ping_rsp);\n                rsp_msg.putHeader(getName(), rsp_hdr);\n                if(trace)\n                    log.trace(\"received GET_MBRS_REQ from \" + msg.getSrc() + \", sending response \" + rsp_hdr);\n                passDown(new Event(Event.MSG, rsp_msg));\n                return;\n\n            case PingHeader.GET_MBRS_RSP:   // add response to vector and notify waiting thread\n                rsp=hdr.arg;\n\n                if(trace)\n                    log.trace(\"received GET_MBRS_RSP, rsp=\" + rsp);\n                ping_waiter.addResponse(rsp);\n                return;\n\n            default:\n                if(warn) log.warn(\"got PING header with unknown type (\" + hdr.type + ')');\n                return;\n            }\n\n\n        case Event.SET_LOCAL_ADDRESS:\n            passUp(evt);\n            local_addr=(Address)evt.getArg();\n            localAddressSet(local_addr);\n            break;\n\n        case Event.CONNECT_OK:\n            handleConnectOK();\n            passUp(evt);\n            break;\n\n        default:\n            passUp(evt);            // Pass up to the layer above us\n            break;\n        }\n    }","id":28171,"modified_method":"/**\n     * An event was received from the layer below. Usually the current layer will want to examine\n     * the event type and - depending on its type - perform some computation\n     * (e.g. removing headers from a MSG event type, or updating the internal membership list\n     * when receiving a VIEW_CHANGE event).\n     * Finally the event is either a) discarded, or b) an event is sent down\n     * the stack using <code>PassDown<\/code> or c) the event (or another event) is sent up\n     * the stack using <code>PassUp<\/code>.\n     * <p/>\n     * For the PING protocol, the Up operation does the following things.\n     * 1. If the event is a Event.MSG then PING will inspect the message header.\n     * If the header is null, PING simply passes up the event\n     * If the header is PingHeader.GET_MBRS_REQ then the PING protocol\n     * will PassDown a PingRequest message\n     * If the header is PingHeader.GET_MBRS_RSP we will add the message to the initial members\n     * vector and wake up any waiting threads.\n     * 2. If the event is Event.SET_LOCAL_ADDR we will simple set the local address of this protocol\n     * 3. For all other messages we simple pass it up to the protocol above\n     *\n     * @param evt - the event that has been sent from the layer below\n     */\n\n    public Object up(Event evt) {\n        Message msg, rsp_msg;\n        PingHeader rsp_hdr;\n        PingRsp rsp;\n        Address coord;\n\n        switch(evt.getType()) {\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            PingHeader hdr=(PingHeader)msg.getHeader(getName());\n            if(hdr == null) {\n                return passUp(evt);\n            }\n\n            switch(hdr.type) {\n\n            case PingHeader.GET_MBRS_REQ:   // return Rsp(local_addr, coord)\n                if(local_addr != null && msg.getSrc() != null && local_addr.equals(msg.getSrc())) {\n                    return null;\n                }\n                synchronized(members) {\n                    coord=!members.isEmpty()? (Address)members.firstElement() : local_addr;\n                }\n\n                PingRsp ping_rsp=new PingRsp(local_addr, coord, is_server);\n                rsp_msg=new Message(msg.getSrc(), null, null);\n                rsp_msg.setFlag(Message.OOB);\n                rsp_hdr=new PingHeader(PingHeader.GET_MBRS_RSP, ping_rsp);\n                rsp_msg.putHeader(getName(), rsp_hdr);\n                if(trace)\n                    log.trace(\"received GET_MBRS_REQ from \" + msg.getSrc() + \", sending response \" + rsp_hdr);\n                passDown(new Event(Event.MSG, rsp_msg));\n                return null;\n\n            case PingHeader.GET_MBRS_RSP:   // add response to vector and notify waiting thread\n                rsp=hdr.arg;\n\n                if(trace)\n                    log.trace(\"received GET_MBRS_RSP, rsp=\" + rsp);\n                ping_waiter.addResponse(rsp);\n                return null;\n\n            default:\n                if(warn) log.warn(\"got PING header with unknown type (\" + hdr.type + ')');\n                return null;\n            }\n\n\n        case Event.SET_LOCAL_ADDRESS:\n            passUp(evt);\n            local_addr=(Address)evt.getArg();\n            localAddressSet(local_addr);\n            break;\n\n        case Event.CONNECT_OK:\n            handleConnectOK();\n            passUp(evt);\n            break;\n\n        default:\n            passUp(evt);            // Pass up to the layer above us\n            break;\n        }\n\n        return null;\n    }","commit_id":"71858a495b75a79e5a3b6e8a8f895a16a5e67c72","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Caller by the layer above this layer. Usually we just put this Message\n     * into the send queue and let one or more worker threads handle it. A worker thread\n     * then removes the Message from the send queue, performs a conversion and adds the\n     * modified Message to the send queue of the layer below it, by calling Down).\n     */\n    public Object down(Event evt) {\n        if(trace)\n            log.trace(\"event is \" + evt + \", group_addr=\" + group_addr +\n                      \", time is \" + System.currentTimeMillis() + \", hdrs: \" + Util.printEvent(evt));\n\n        switch(evt.getType()) {\n\n        case Event.MSG:\n            Message msg=(Message)evt.getArg();\n            Message rsp=msg.copy();\n            if(rsp.getSrc() == null)\n                rsp.setSrc(local_addr);\n\n            //dest_addr=msg.getDest();\n            //rsp.setDest(local_addr);\n            //rsp.setSrc(dest_addr != null ? dest_addr : local_addr);\n            up(new Event(Event.MSG, rsp));\n            break;\n\n        case Event.GET_LOCAL_ADDRESS:   // return local address -> Event(SET_LOCAL_ADDRESS, local)\n            passUp(new Event(Event.SET_LOCAL_ADDRESS, local_addr));\n            break;\n\n        case Event.CONNECT:\n            group_addr=(String)evt.getArg();\n            passUp(new Event(Event.CONNECT_OK));\n            break;\n\n        case Event.DISCONNECT:\n            passUp(new Event(Event.DISCONNECT_OK));\n            break;\n\n        case Event.PERF:\n            passUp(evt);\n            break;\n        }\n    }","id":28172,"modified_method":"/**\n     * Caller by the layer above this layer. Usually we just put this Message\n     * into the send queue and let one or more worker threads handle it. A worker thread\n     * then removes the Message from the send queue, performs a conversion and adds the\n     * modified Message to the send queue of the layer below it, by calling Down).\n     */\n    public Object down(Event evt) {\n        if(trace)\n            log.trace(\"event is \" + evt + \", group_addr=\" + group_addr +\n                      \", time is \" + System.currentTimeMillis() + \", hdrs: \" + Util.printEvent(evt));\n\n        switch(evt.getType()) {\n\n        case Event.MSG:\n            Message msg=(Message)evt.getArg();\n            Message rsp=msg.copy();\n            if(rsp.getSrc() == null)\n                rsp.setSrc(local_addr);\n\n            //dest_addr=msg.getDest();\n            //rsp.setDest(local_addr);\n            //rsp.setSrc(dest_addr != null ? dest_addr : local_addr);\n            up(new Event(Event.MSG, rsp));\n            break;\n\n        case Event.GET_LOCAL_ADDRESS:   // return local address -> Event(SET_LOCAL_ADDRESS, local)\n            passUp(new Event(Event.SET_LOCAL_ADDRESS, local_addr));\n            break;\n\n        case Event.CONNECT:\n            group_addr=(String)evt.getArg();\n            passUp(new Event(Event.CONNECT_OK));\n            break;\n\n        case Event.DISCONNECT:\n            passUp(new Event(Event.DISCONNECT_OK));\n            break;\n\n        case Event.PERF:\n            passUp(evt);\n            break;\n        }\n        return null;\n    }","commit_id":"71858a495b75a79e5a3b6e8a8f895a16a5e67c72","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                passUp(evt);\n                break;\n\n            case Event.FIND_INITIAL_MBRS_OK:\n                find_promise.setResult(evt.getArg());\n                passUp(evt); // could be needed by GMS\n                break;\n\n            default:\n                passUp(evt);            // Pass up to the layer above us\n                break;\n        }\n    }","id":28173,"modified_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                return passUp(evt);\n\n            case Event.FIND_INITIAL_MBRS_OK:\n                find_promise.setResult(evt.getArg());\n                return passUp(evt); // could be needed by GMS\n\n            default:\n                return passUp(evt);            // Pass up to the layer above us\n        }\n    }","commit_id":"71858a495b75a79e5a3b6e8a8f895a16a5e67c72","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                CoordAnnouncement hdr=(CoordAnnouncement)msg.removeHeader(getName());\n                if(hdr != null) {\n                    if(hdr.coord_addr != null && is_coord) {\n                        boolean contains;\n                        contains=announcements.contains(hdr.coord_addr);\n                        announcements.add(hdr.coord_addr);\n                        if(log.isDebugEnabled()) {\n                            if(contains)\n                                log.debug(\"discarded duplicate announcement: \" + hdr.coord_addr +\n                                          \", announcements=\" + announcements);\n                            else\n                                log.debug(\"received announcement: \" + hdr.coord_addr + \", announcements=\" + announcements);\n                        }\n\n                        if(announcements.size() > 1 && is_coord) {\n                            processAnnouncements();\n                        }\n                    }\n                }\n                else\n                    passUp(evt);\n                break;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                passUp(evt);\n                break;\n\n            default:\n                passUp(evt);            // Pass up to the layer above us\n                break;\n        }\n    }","id":28174,"modified_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                CoordAnnouncement hdr=(CoordAnnouncement)msg.removeHeader(getName());\n                if(hdr != null) {\n                    if(hdr.coord_addr != null && is_coord) {\n                        boolean contains;\n                        contains=announcements.contains(hdr.coord_addr);\n                        announcements.add(hdr.coord_addr);\n                        if(log.isDebugEnabled()) {\n                            if(contains)\n                                log.debug(\"discarded duplicate announcement: \" + hdr.coord_addr +\n                                        \", announcements=\" + announcements);\n                            else\n                                log.debug(\"received announcement: \" + hdr.coord_addr + \", announcements=\" + announcements);\n                        }\n\n                        if(announcements.size() > 1 && is_coord) {\n                            processAnnouncements();\n                        }\n                    }\n                    return null;\n                }\n                else\n                    return passUp(evt);\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                break;\n        }\n\n        return passUp(evt);\n    }","commit_id":"71858a495b75a79e5a3b6e8a8f895a16a5e67c72","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        Vector tmp;\n        Address coord;\n\n        switch(evt.getType()) {\n\n            case Event.VIEW_CHANGE:\n                passDown(evt);\n                tmp=((View)evt.getArg()).getMembers();\n                mbrs.clear();\n                mbrs.addAll(tmp);\n                coord=(Address)mbrs.elementAt(0);\n                if(coord.equals(local_addr)) {\n                    if(is_coord == false) {\n                        is_coord=true;\n                        startCoordAnnouncerTask();\n                    }\n                }\n                else {\n                    if(is_coord == true) {\n                        is_coord=false;\n                        stopCoordAnnouncerTask();\n                    }\n                }\n                break;\n\n            default:\n                passDown(evt);          // Pass on to the layer below us\n                break;\n        }\n    }","id":28175,"modified_method":"public Object down(Event evt) {\n        Vector tmp;\n        Address coord;\n\n        switch(evt.getType()) {\n\n            case Event.VIEW_CHANGE:\n                passDown(evt);\n                tmp=((View)evt.getArg()).getMembers();\n                mbrs.clear();\n                mbrs.addAll(tmp);\n                coord=(Address)mbrs.elementAt(0);\n                if(coord.equals(local_addr)) {\n                    if(is_coord == false) {\n                        is_coord=true;\n                        startCoordAnnouncerTask();\n                    }\n                }\n                else {\n                    if(is_coord == true) {\n                        is_coord=false;\n                        stopCoordAnnouncerTask();\n                    }\n                }\n                break;\n        }\n        return passDown(evt);\n    }","commit_id":"71858a495b75a79e5a3b6e8a8f895a16a5e67c72","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        if(is_coord == true && evt.getType() == Event.MSG && local_addr != null) {\n            Message msg=(Message)evt.getArg();\n            Address dest=msg.getDest();\n            if(dest == null || dest.isMulticastAddress()) {\n                msg.putHeader(getName(), new MergefastHeader(local_addr));\n            }\n        }\n\n        if(evt.getType() == Event.VIEW_CHANGE) {\n            handleViewChange((View)evt.getArg());\n        }\n\n        passDown(evt);\n    }","id":28176,"modified_method":"public Object down(Event evt) {\n        if(is_coord == true && evt.getType() == Event.MSG && local_addr != null) {\n            Message msg=(Message)evt.getArg();\n            Address dest=msg.getDest();\n            if(dest == null || dest.isMulticastAddress()) {\n                msg.putHeader(getName(), new MergefastHeader(local_addr));\n            }\n        }\n\n        if(evt.getType() == Event.VIEW_CHANGE) {\n            handleViewChange((View)evt.getArg());\n        }\n\n        return passDown(evt);\n    }","commit_id":"71858a495b75a79e5a3b6e8a8f895a16a5e67c72","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        if(evt.getType() == Event.CONFIG) {\n            if(bind_addr == null) {\n                Map config=(Map)evt.getArg();\n                bind_addr=(InetAddress)config.get(\"bind_addr\");\n            }\n            passUp(evt);\n            return;\n        }\n        super.up(evt);\n    }","id":28177,"modified_method":"public Object up(Event evt) {\n        if(evt.getType() == Event.CONFIG) {\n            if(bind_addr == null) {\n                Map config=(Map)evt.getArg();\n                bind_addr=(InetAddress)config.get(\"bind_addr\");\n            }\n            return passUp(evt);\n        }\n        return super.up(evt);\n    }","commit_id":"71858a495b75a79e5a3b6e8a8f895a16a5e67c72","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n            StringBuffer sb=new StringBuffer();\n            if(type == REQ)\n                sb.append(\"REQ\");\n            else\n                if(type == RSP)\n                    sb.append(\"RSP\");\n                else\n                    if(type == DESTROY_INTERPRETER)\n                        sb.append(\"DESTROY_INTERPRETER\");\n                    else\n                        sb.append(\"<unknown type>\");\n            return sb.toString();\n        }","id":28178,"modified_method":"public String toString() {\n            StringBuilder sb=new StringBuilder();\n            if(type == REQ)\n                sb.append(\"REQ\");\n            else\n                if(type == RSP)\n                    sb.append(\"RSP\");\n                else\n                    if(type == DESTROY_INTERPRETER)\n                        sb.append(\"DESTROY_INTERPRETER\");\n                    else\n                        sb.append(\"<unknown type>\");\n            return sb.toString();\n        }","commit_id":"761a6eed6d07a538027b1914495ee97eefbca38a","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Header  h;\n        Message msg;\n        int     type;\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n            h=msg.removeHeader(name);\n            if(h != null && h instanceof BshHeader) {\n                type=((BshHeader)h).type;\n                switch(type) {\n                    case BshHeader.REQ:\n                        handleRequest(msg.getSrc(), msg.getBuffer());\n                        return;\n                    case BshHeader.RSP:\n                        msg.putHeader(name, h);\n                        passUp(evt);\n                        return;\n                    case BshHeader.DESTROY_INTERPRETER:\n                        destroyInterpreter();\n                        return;\n                    default:\n                        if(log.isErrorEnabled()) log.error(\"header type was not REQ as expected\" +\n                                    \" (was \" + type + ')');\n                        return;\n                }\n            }\n        }\n        passUp(evt);\n    }","id":28179,"modified_method":"public Object up(Event evt) {\n        Header  h;\n        Message msg;\n        int     type;\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n            h=msg.getHeader(name);\n            if(h instanceof BshHeader) {\n                type=((BshHeader)h).type;\n                switch(type) {\n                    case BshHeader.REQ:\n                        handleRequest(msg.getSrc(), msg.getBuffer());\n                        return null;\n                    case BshHeader.RSP:\n                        msg.putHeader(name, h);\n                        passUp(evt);\n                        return null;\n                    case BshHeader.DESTROY_INTERPRETER:\n                        destroyInterpreter();\n                        return null;\n                    default:\n                        if(log.isErrorEnabled()) log.error(\"header type was not REQ as expected (was \" + type + ')');\n                        return null;\n                }\n            }\n        }\n        return passUp(evt);\n    }","commit_id":"761a6eed6d07a538027b1914495ee97eefbca38a","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean setProperties(Properties props) {\n        String str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"up\");\n        if(str != null) {\n            up=Double.parseDouble(str);\n            props.remove(\"up\");\n        }\n\n        str=props.getProperty(\"down\");\n        if(str != null) {\n            down=Double.parseDouble(str);\n            props.remove(\"down\");\n        }\n\n        str=props.getProperty(\"excludeitself\");\n        if(str != null) {\n            excludeItself=Boolean.valueOf(str).booleanValue();\n            props.remove(\"excludeitself\");\n        }\n\n\n        if(props.size() > 0) {\n            log.error(\"DISCARD.setProperties(): these properties are not recognized: \" + props);\n\n            return false;\n        }\n        return true;\n    }","id":28180,"modified_method":"public boolean setProperties(Properties props) {\n        String str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"up\");\n        if(str != null) {\n            up=Double.parseDouble(str);\n            props.remove(\"up\");\n        }\n\n        str=props.getProperty(\"down\");\n        if(str != null) {\n            down=Double.parseDouble(str);\n            props.remove(\"down\");\n        }\n\n        str=props.getProperty(\"excludeitself\");\n        if(str != null) {\n            excludeItself=Boolean.valueOf(str).booleanValue();\n            props.remove(\"excludeitself\");\n        }\n\n\n        if(!props.isEmpty()) {\n            log.error(\"DISCARD.setProperties(): these properties are not recognized: \" + props);\n            return false;\n        }\n        return true;\n    }","commit_id":"761a6eed6d07a538027b1914495ee97eefbca38a","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        Message msg;\n        double r;\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n\n            if(down > 0) {\n                r=Math.random();\n                if(r < down) {\n                    if(excludeItself && msg.getSrc().equals(localAddress)) {\n                        if(log.isTraceEnabled()) log.trace(\"excluding itself\");\n                    }\n                    else {\n                        if(log.isTraceEnabled())\n                            log.trace(\"dropping message\");\n                        num_down++;\n                        return;\n                    }\n                }\n            }\n\n        }\n        passDown(evt);\n    }","id":28181,"modified_method":"public Object down(Event evt) {\n        Message msg;\n        double r;\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n\n            if(down > 0) {\n                r=Math.random();\n                if(r < down) {\n                    if(excludeItself && msg.getSrc().equals(localAddress)) {\n                        if(log.isTraceEnabled()) log.trace(\"excluding itself\");\n                    }\n                    else {\n                        if(log.isTraceEnabled())\n                            log.trace(\"dropping message\");\n                        num_down++;\n                        return null;\n                    }\n                }\n            }\n        }\n\n        return passDown(evt);\n    }","commit_id":"761a6eed6d07a538027b1914495ee97eefbca38a","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Message msg;\n        double r;\n\n        if(evt.getType() == Event.SET_LOCAL_ADDRESS)\n            localAddress=(Address)evt.getArg();\n\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n            if(up > 0) {\n                r=Math.random();\n                if(r < up) {\n                    if(excludeItself && msg.getSrc().equals(localAddress)) {\n                        if(log.isTraceEnabled()) log.trace(\"excluding itself\");\n                    }\n                    else {\n                        if(log.isTraceEnabled()) log.trace(\"dropping message\");\n                        num_up++;\n                        return;\n                    }\n                }\n            }\n        }\n\n\n        passUp(evt);\n    }","id":28182,"modified_method":"public Object up(Event evt) {\n        Message msg;\n        double r;\n\n        if(evt.getType() == Event.SET_LOCAL_ADDRESS)\n            localAddress=(Address)evt.getArg();\n\n\n        if(evt.getType() == Event.MSG) {\n            msg=(Message)evt.getArg();\n            if(up > 0) {\n                r=Math.random();\n                if(r < up) {\n                    if(excludeItself && msg.getSrc().equals(localAddress)) {\n                        if(log.isTraceEnabled()) log.trace(\"excluding itself\");\n                    }\n                    else {\n                        if(log.isTraceEnabled()) log.trace(\"dropping message\");\n                        num_up++;\n                        return null;\n                    }\n                }\n            }\n        }\n\n        return passUp(evt);\n    }","commit_id":"761a6eed6d07a538027b1914495ee97eefbca38a","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * <b>Callback<\/b>. Called by superclass when event may be handled.<p> <b>Do not use <code>PassUp<\/code> in this\n     * method as the event is passed up by default by the superclass after this method returns !<\/b>\n     */\n    public Object up(Event evt) {\n        NakAckHeader hdr;\n        Message msg;\n        Digest digest;\n\n        switch(evt.getType()) {\n\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            hdr=(NakAckHeader)msg.getHeader(name);\n            if(hdr == null)\n                break;  // pass up (e.g. unicast msg)\n\n            // discard messages while not yet server (i.e., until JOIN has returned)\n            if(!is_server) {\n                if(trace)\n                    log.trace(\"message was discarded (not yet server)\");\n                return;\n            }\n\n            // Changed by bela Jan 29 2003: we must not remove the header, otherwise\n            // further xmit requests will fail !\n            //hdr=(NakAckHeader)msg.removeHeader(getName());\n\n            switch(hdr.type) {\n\n            case NakAckHeader.MSG:\n                handleMessage(msg, hdr);\n                return;        // transmitter passes message up for us !\n\n            case NakAckHeader.XMIT_REQ:\n                if(hdr.range == null) {\n                    if(log.isErrorEnabled()) {\n                        log.error(\"XMIT_REQ: range of xmit msg is null; discarding request from \" + msg.getSrc());\n                    }\n                    return;\n                }\n                handleXmitReq(msg.getSrc(), hdr.range.low, hdr.range.high, hdr.sender);\n                return;\n\n            case NakAckHeader.XMIT_RSP:\n                if(trace)\n                    log.trace(\"received missing messages \" + hdr.range);\n                handleXmitRsp(msg);\n                return;\n\n            default:\n                if(log.isErrorEnabled()) {\n                    log.error(\"NakAck header type \" + hdr.type + \" not known !\");\n                }\n                return;\n            }\n\n        case Event.STABLE:  // generated by STABLE layer. Delete stable messages passed in arg\n            stable((Digest)evt.getArg());\n            return;  // do not pass up further (Bela Aug 7 2001)\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address)evt.getArg();\n            break;\n\n        case Event.CONFIG:\n            passUp(evt);\n            if(log.isDebugEnabled()) {\n                log.debug(\"received CONFIG event: \" + evt.getArg());\n            }\n            handleConfigEvent((HashMap)evt.getArg());\n            return;\n        }\n        passUp(evt);\n    }","id":28183,"modified_method":"/**\n     * <b>Callback<\/b>. Called by superclass when event may be handled.<p> <b>Do not use <code>PassUp<\/code> in this\n     * method as the event is passed up by default by the superclass after this method returns !<\/b>\n     */\n    public Object up(Event evt) {\n        NakAckHeader hdr;\n        Message msg;\n\n        switch(evt.getType()) {\n\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            hdr=(NakAckHeader)msg.getHeader(name);\n            if(hdr == null)\n                break;  // pass up (e.g. unicast msg)\n\n            // discard messages while not yet server (i.e., until JOIN has returned)\n            if(!is_server) {\n                if(trace)\n                    log.trace(\"message was discarded (not yet server)\");\n                return null;\n            }\n\n            // Changed by bela Jan 29 2003: we must not remove the header, otherwise\n            // further xmit requests will fail !\n            //hdr=(NakAckHeader)msg.removeHeader(getName());\n\n            switch(hdr.type) {\n\n            case NakAckHeader.MSG:\n                handleMessage(msg, hdr);\n                return null;        // transmitter passes message up for us !\n\n            case NakAckHeader.XMIT_REQ:\n                if(hdr.range == null) {\n                    if(log.isErrorEnabled()) {\n                        log.error(\"XMIT_REQ: range of xmit msg is null; discarding request from \" + msg.getSrc());\n                    }\n                    return null;\n                }\n                handleXmitReq(msg.getSrc(), hdr.range.low, hdr.range.high, hdr.sender);\n                return null;\n\n            case NakAckHeader.XMIT_RSP:\n                if(trace)\n                    log.trace(\"received missing messages \" + hdr.range);\n                handleXmitRsp(msg);\n                return null;\n\n            default:\n                if(log.isErrorEnabled()) {\n                    log.error(\"NakAck header type \" + hdr.type + \" not known !\");\n                }\n                return null;\n            }\n\n        case Event.STABLE:  // generated by STABLE layer. Delete stable messages passed in arg\n            stable((Digest)evt.getArg());\n            return null;  // do not pass up further (Bela Aug 7 2001)\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address)evt.getArg();\n            break;\n\n        case Event.CONFIG:\n            passUp(evt);\n            if(log.isDebugEnabled()) {\n                log.debug(\"received CONFIG event: \" + evt.getArg());\n            }\n            handleConfigEvent((HashMap)evt.getArg());\n            return null;\n        }\n        return passUp(evt);\n    }","commit_id":"c945218c0df0801093c033d8f526d514e286c241","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Setup the Protocol instance acording to the configuration string */\n    public boolean setProperties(Properties props) {super.setProperties(props);\n        String str;\n\n        str=props.getProperty(\"dynamic\");\n        if(str != null) {\n            dynamic=Boolean.valueOf(str).booleanValue();\n            props.remove(\"dynamic\");\n        }\n\n        str=props.getProperty(\"shun\");\n        if(str != null) {\n            shun=Boolean.valueOf(str).booleanValue();\n            props.remove(\"shun\");\n        }\n\n        str=props.getProperty(\"gossip_interval\");\n        if(str != null) {\n            gossip_interval=Long.parseLong(str);\n            props.remove(\"gossip_interval\");\n        }\n\n        str=props.getProperty(\"mcast_gossip\");\n        if(str != null) {\n            mcast_gossip=Boolean.valueOf(str).booleanValue();\n            props.remove(\"mcast_gossip\");\n        }\n\n        str=props.getProperty(\"subset\");\n        if(str != null) {\n            subset=Double.parseDouble(str);\n            props.remove(\"subset\");\n        }\n\n        str=props.getProperty(\"desired_avg_gossip\");\n        if(str != null) {\n            desired_avg_gossip=Long.parseLong(str);\n            props.remove(\"desired_avg_gossip\");\n        }\n\n        str=props.getProperty(\"max_queue\");\n        if(str != null) {\n            max_queue=Integer.parseInt(str);\n            props.remove(\"max_queue\");\n        }\n\n        str=props.getProperty(\"max_gossip_cache\");\n        if(str != null) {\n            max_gossip_cache=Integer.parseInt(str);\n            props.remove(\"max_gossip_cache\");\n        }\n\n        str=props.getProperty(\"gc_lag\");\n        if(str != null) {\n            gc_lag=Integer.parseInt(str);\n            props.remove(\"gc_lag\");\n        }\n\n        if(props.size() > 0) {\n            log.error(\"PBCAST.setProperties(): the following properties are not recognized: \" + props);\n            \n            return false;\n        }\n        return true;\n    }","id":28184,"modified_method":"/** Setup the Protocol instance acording to the configuration string */\n    public boolean setProperties(Properties props) {super.setProperties(props);\n        String str;\n\n        str=props.getProperty(\"dynamic\");\n        if(str != null) {\n            dynamic=Boolean.valueOf(str).booleanValue();\n            props.remove(\"dynamic\");\n        }\n\n        str=props.getProperty(\"shun\");\n        if(str != null) {\n            shun=Boolean.valueOf(str).booleanValue();\n            props.remove(\"shun\");\n        }\n\n        str=props.getProperty(\"gossip_interval\");\n        if(str != null) {\n            gossip_interval=Long.parseLong(str);\n            props.remove(\"gossip_interval\");\n        }\n\n        str=props.getProperty(\"mcast_gossip\");\n        if(str != null) {\n            mcast_gossip=Boolean.valueOf(str).booleanValue();\n            props.remove(\"mcast_gossip\");\n        }\n\n        str=props.getProperty(\"subset\");\n        if(str != null) {\n            subset=Double.parseDouble(str);\n            props.remove(\"subset\");\n        }\n\n        str=props.getProperty(\"desired_avg_gossip\");\n        if(str != null) {\n            desired_avg_gossip=Long.parseLong(str);\n            props.remove(\"desired_avg_gossip\");\n        }\n\n        str=props.getProperty(\"max_queue\");\n        if(str != null) {\n            max_queue=Integer.parseInt(str);\n            props.remove(\"max_queue\");\n        }\n\n        str=props.getProperty(\"max_gossip_cache\");\n        if(str != null) {\n            max_gossip_cache=Integer.parseInt(str);\n            props.remove(\"max_gossip_cache\");\n        }\n\n        str=props.getProperty(\"gc_lag\");\n        if(str != null) {\n            gc_lag=Integer.parseInt(str);\n            props.remove(\"gc_lag\");\n        }\n\n        if(!props.isEmpty()) {\n            log.error(\"PBCAST.setProperties(): the following properties are not recognized: \" + props);\n            return false;\n        }\n        return true;\n    }","commit_id":"c945218c0df0801093c033d8f526d514e286c241","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        PbcastHeader hdr;\n        Message m, copy;\n        View v;\n        Vector mbrs;\n        Address key;\n        NakReceiverWindow win;\n\n\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                m=(Message) evt.getArg();\n                if(m.getDest() != null && !m.getDest().isMulticastAddress()) {\n                    break; // unicast address: not null and not mcast, pass down unchanged\n                }\n                else {      // multicast address\n                    hdr=new PbcastHeader(PbcastHeader.MCAST_MSG, seqno);\n                    m.putHeader(getName(), hdr);\n\n                    // put message in NakReceiverWindow (to be on the safe side if we don't receive it ...)\n                    synchronized(digest) {\n                        win=(NakReceiverWindow) digest.get(local_addr);\n                        if(win == null) {\n                            if(log.isInfoEnabled()) log.info(\"NakReceiverWindow for sender \" + local_addr +\n                                                        \" not found. Creating new NakReceiverWindow starting at seqno=\" + seqno);\n                            win=new NakReceiverWindow(local_addr, seqno);\n                            digest.put(local_addr, win);\n                        }\n                        copy=m.copy();\n                        copy.setSrc(local_addr);\n                        win.add(seqno, copy);\n                    }\n                    seqno++;\n                    break;\n                }\n\n            case Event.SET_DIGEST:\n                setDigest((Digest) evt.getArg());\n                return;  // don't pass down\n\n            case Event.GET_DIGEST:  // don't pass down\n                passUp(new Event(Event.GET_DIGEST_OK, getDigest()));\n                return;\n\n            case Event.GET_DIGEST_STATE:  // don't pass down\n                return getDigest();\n\n            case Event.VIEW_CHANGE:\n                v=(View) evt.getArg();\n                if(v == null) {\n                    if(log.isErrorEnabled()) log.error(\"view is null !\");\n                    break;\n                }\n                mbrs=v.getMembers();\n\n                // update internal membership list\n                synchronized(members) {\n                    members.removeAllElements();\n                    for(int i=0; i < mbrs.size(); i++)\n                        members.addElement(mbrs.elementAt(i));\n                }\n\n                // delete all members in digest that are not in new membership list\n                if(mbrs.size() > 0) {\n                    synchronized(digest) {\n                        for(Enumeration e=digest.keys(); e.hasMoreElements();) {\n                            key=(Address) e.nextElement();\n                            if(!mbrs.contains(key)) {\n                                win=(NakReceiverWindow) digest.get(key);\n                                win.reset();\n                                digest.remove(key);\n                            }\n                        }\n                    }\n                }\n\n                // add all members from new membership list that are not yet in digest\n                for(int i=0; i < mbrs.size(); i++) {\n                    key=(Address) mbrs.elementAt(i);\n                    if(!digest.containsKey(key)) {\n                        digest.put(key, new NakReceiverWindow(key, 1));\n                    }\n                }\n\n                if(dynamic) {\n                    gossip_interval=computeGossipInterval(members.size(), desired_avg_gossip);\n\n                        if(log.isInfoEnabled()) log.info(\"VIEW_CHANGE: gossip_interval=\" + gossip_interval);\n                    if(gossip_thread != null) {\n                        skip_sleep=true;\n                        gossip_thread.interrupt(); // wake up and sleep according to the new gossip_interval\n                    }\n                }\n\n                startGossipThread();  // will only be started if not yet running\n                startGossipHandler();\n                break;\n\n            case Event.BECOME_SERVER:\n                operational=true;\n                break;\n        }\n\n        passDown(evt);\n    }","id":28185,"modified_method":"public Object down(Event evt) {\n        PbcastHeader hdr;\n        Message m, copy;\n        View v;\n        Vector mbrs;\n        Address key;\n        NakReceiverWindow win;\n\n\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                m=(Message) evt.getArg();\n                if(m.getDest() != null && !m.getDest().isMulticastAddress()) {\n                    break; // unicast address: not null and not mcast, pass down unchanged\n                }\n                else {      // multicast address\n                    hdr=new PbcastHeader(PbcastHeader.MCAST_MSG, seqno);\n                    m.putHeader(getName(), hdr);\n\n                    // put message in NakReceiverWindow (to be on the safe side if we don't receive it ...)\n                    synchronized(digest) {\n                        win=(NakReceiverWindow) digest.get(local_addr);\n                        if(win == null) {\n                            if(log.isInfoEnabled()) log.info(\"NakReceiverWindow for sender \" + local_addr +\n                                                        \" not found. Creating new NakReceiverWindow starting at seqno=\" + seqno);\n                            win=new NakReceiverWindow(local_addr, seqno);\n                            digest.put(local_addr, win);\n                        }\n                        copy=m.copy();\n                        copy.setSrc(local_addr);\n                        win.add(seqno, copy);\n                    }\n                    seqno++;\n                    break;\n                }\n\n            case Event.SET_DIGEST:\n                setDigest((Digest) evt.getArg());\n                return null;  // don't pass down\n\n            case Event.GET_DIGEST:  // don't pass down\n                passUp(new Event(Event.GET_DIGEST_OK, getDigest()));\n                return null;\n\n            case Event.GET_DIGEST_STATE:  // don't pass down\n                return getDigest();\n\n            case Event.VIEW_CHANGE:\n                v=(View) evt.getArg();\n                if(v == null) {\n                    if(log.isErrorEnabled()) log.error(\"view is null !\");\n                    break;\n                }\n                mbrs=v.getMembers();\n\n                // update internal membership list\n                synchronized(members) {\n                    members.removeAllElements();\n                    for(int i=0; i < mbrs.size(); i++)\n                        members.addElement(mbrs.elementAt(i));\n                }\n\n                // delete all members in digest that are not in new membership list\n                if(!mbrs.isEmpty()) {\n                    synchronized(digest) {\n                        for(Enumeration e=digest.keys(); e.hasMoreElements();) {\n                            key=(Address) e.nextElement();\n                            if(!mbrs.contains(key)) {\n                                win=(NakReceiverWindow) digest.get(key);\n                                win.reset();\n                                digest.remove(key);\n                            }\n                        }\n                    }\n                }\n\n                // add all members from new membership list that are not yet in digest\n                for(int i=0; i < mbrs.size(); i++) {\n                    key=(Address) mbrs.elementAt(i);\n                    if(!digest.containsKey(key)) {\n                        digest.put(key, new NakReceiverWindow(key, 1));\n                    }\n                }\n\n                if(dynamic) {\n                    gossip_interval=computeGossipInterval(members.size(), desired_avg_gossip);\n\n                        if(log.isInfoEnabled()) log.info(\"VIEW_CHANGE: gossip_interval=\" + gossip_interval);\n                    if(gossip_thread != null) {\n                        skip_sleep=true;\n                        gossip_thread.interrupt(); // wake up and sleep according to the new gossip_interval\n                    }\n                }\n\n                startGossipThread();  // will only be started if not yet running\n                startGossipHandler();\n                break;\n\n            case Event.BECOME_SERVER:\n                operational=true;\n                break;\n        }\n\n        return passDown(evt);\n    }","commit_id":"c945218c0df0801093c033d8f526d514e286c241","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Message m;\n        PbcastHeader hdr;\n        Address sender=null;\n\n        switch(evt.getType()) {\n            case Event.MSG:\n                m=(Message) evt.getArg();\n                if(m.getDest() != null && !m.getDest().isMulticastAddress()) {\n                    if(!(m.getHeader(getName()) instanceof PbcastHeader))\n                        break; // unicast address: not null and not mcast, pass up unchanged\n                }\n\n                // discard all multicast messages until we become operational (transition from joiner to member)\n                if(!operational) {\n\n                        if(log.isInfoEnabled()) log.info(\"event was discarded as I'm not yet operational. Event: \" +\n                                                  Util.printEvent(evt));\n                    return;  // don't pass up\n                }\n\n                if(m.getHeader(getName()) instanceof PbcastHeader)\n                    hdr=(PbcastHeader) m.getHeader(getName());\n                else {\n                    sender=m.getSrc();\n                    if(log.isErrorEnabled()) log.error(\"PbcastHeader expected, but received header of type \" +\n                            m.getHeader(getName()).getClass().getName() + \" from \" + sender +\n                            \". Passing event up unchanged\");\n                    break;\n                }\n\n                switch(hdr.type) {\n                    case PbcastHeader.MCAST_MSG:  // messages are handled directly (high priority)\n                        handleUpMessage(m, hdr);\n                        return;\n\n                        // all other requests are put in the bounded gossip queue (discarded if full). this helps to ensure\n                        // that no 'gossip storms' will occur (overflowing the buffers and the network)\n                    case PbcastHeader.GOSSIP:\n                    case PbcastHeader.XMIT_REQ:\n                    case PbcastHeader.XMIT_RSP:\n                    case PbcastHeader.NOT_MEMBER:\n                        try {\n                            if(gossip_queue.size() >= max_queue) {\n\n                                    if(warn) log.warn(\"gossip request \" +\n                                                              PbcastHeader.type2String(hdr.type) + \" discarded because \" +\n                                                              \"gossip_queue is full (number of elements=\" + gossip_queue.size() + ')');\n                                return;\n                            }\n                            gossip_queue.add(new GossipEntry(hdr, m.getSrc(), m.getBuffer()));\n                        }\n                        catch(Exception ex) {\n                            if(warn) log.warn(\"exception adding request to gossip_queue, details=\" + ex);\n                        }\n                        return;\n\n                    default:\n                        if(log.isErrorEnabled()) log.error(\"type (\" + hdr.type + \") of PbcastHeader not known !\");\n                        return;\n                }\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address) evt.getArg();\n                break;  // pass up\n        }\n\n        passUp(evt);  // pass up by default\n    }","id":28186,"modified_method":"public Object up(Event evt) {\n        Message m;\n        PbcastHeader hdr;\n        Address sender=null;\n\n        switch(evt.getType()) {\n            case Event.MSG:\n                m=(Message) evt.getArg();\n                if(m.getDest() != null && !m.getDest().isMulticastAddress()) {\n                    if(!(m.getHeader(getName()) instanceof PbcastHeader))\n                        break; // unicast address: not null and not mcast, pass up unchanged\n                }\n\n                // discard all multicast messages until we become operational (transition from joiner to member)\n                if(!operational) {\n                    if(log.isInfoEnabled()) log.info(\"event was discarded as I'm not yet operational. Event: \" +\n                            Util.printEvent(evt));\n                    return null;  // don't pass up\n                }\n\n                if(m.getHeader(getName()) instanceof PbcastHeader)\n                    hdr=(PbcastHeader) m.getHeader(getName());\n                else {\n                    sender=m.getSrc();\n                    if(log.isErrorEnabled()) log.error(\"PbcastHeader expected, but received header of type \" +\n                            m.getHeader(getName()).getClass().getName() + \" from \" + sender +\n                            \". Passing event up unchanged\");\n                    break;\n                }\n\n                switch(hdr.type) {\n                    case PbcastHeader.MCAST_MSG:  // messages are handled directly (high priority)\n                        handleUpMessage(m, hdr);\n                        return null;\n\n                        // all other requests are put in the bounded gossip queue (discarded if full). this helps to ensure\n                        // that no 'gossip storms' will occur (overflowing the buffers and the network)\n                    case PbcastHeader.GOSSIP:\n                    case PbcastHeader.XMIT_REQ:\n                    case PbcastHeader.XMIT_RSP:\n                    case PbcastHeader.NOT_MEMBER:\n                        try {\n                            if(gossip_queue.size() >= max_queue) {\n                                if(warn) log.warn(\"gossip request \" +\n                                        PbcastHeader.type2String(hdr.type) + \" discarded because \" +\n                                        \"gossip_queue is full (number of elements=\" + gossip_queue.size() + ')');\n                                return null;\n                            }\n                            gossip_queue.add(new GossipEntry(hdr, m.getSrc(), m.getBuffer()));\n                        }\n                        catch(Exception ex) {\n                            if(warn) log.warn(\"exception adding request to gossip_queue, details=\" + ex);\n                        }\n                        return null;\n\n                    default:\n                        if(log.isErrorEnabled()) log.error(\"type (\" + hdr.type + \") of PbcastHeader not known !\");\n                        return null;\n                }\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address) evt.getArg();\n                break;  // pass up\n        }\n\n        return passUp(evt);  // pass up by default\n    }","commit_id":"c945218c0df0801093c033d8f526d514e286c241","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                Address dest=msg.getDest();\n                if(dest != null && !dest.isMulticastAddress()) // only handle multicast messages\n                    break;\n\n                boolean send_credit_request=false;\n                lock.lock();\n                try {\n                    while(curr_credits_available <=0 && running) {\n                        if(trace)\n                            log.trace(\"blocking (current credits=\" + curr_credits_available + \")\");\n                        try {\n                            num_blockings++;\n                            credits_available.await(); // will be signalled when we have credit responses from all members\n                        }\n                        catch(InterruptedException e) {\n                            if(warn)\n                                log.warn(\"thread was interrupted\", e);\n                            Thread.currentThread().interrupt(); // pass the exception on to the  caller\n                            return;\n                        }\n                    }\n\n                    // when we get here, curr_credits_available is guaranteed to be > 0\n                    int len=msg.getLength();\n                    num_bytes_sent+=len;\n                    curr_credits_available-=len; // we'll block on insufficient credits on the next down() call\n                    if(curr_credits_available <=0) {\n                        pending_creditors.clear();\n                        synchronized(members) {\n                            pending_creditors.addAll(members);\n                        }\n                        send_credit_request=true;\n                    }\n                }\n                finally {\n                    lock.unlock();\n                }\n\n                // we don't need to protect send_credit_request because a thread above either (a) decrements the credits\n                // by the msg length and sets send_credit_request to true or (b) blocks because there are no credits\n                // available. So only 1 thread can ever set send_credit_request at any given time\n                if(send_credit_request) {\n                    if(trace)\n                        log.trace(\"sending credit request to group\");\n                    start=System.nanoTime(); // only 1 thread is here at any given time\n                    passDown(evt);       // send the message before the credit request\n                    sendCreditRequest(); // do this outside of the lock\n                    return;\n                }\n                break;\n\n            case Event.VIEW_CHANGE:\n                handleViewChange((View)evt.getArg());\n                break;\n\n            case Event.SUSPECT:\n                handleSuspect((Address)evt.getArg());\n                break;\n        }\n\n        passDown(evt);\n    }","id":28187,"modified_method":"public Object down(Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                Address dest=msg.getDest();\n                if(dest != null && !dest.isMulticastAddress()) // only handle multicast messages\n                    break;\n\n                boolean send_credit_request=false;\n                lock.lock();\n                try {\n                    while(curr_credits_available <=0 && running) {\n                        if(trace)\n                            log.trace(\"blocking (current credits=\" + curr_credits_available + \")\");\n                        try {\n                            num_blockings++;\n                            credits_available.await(); // will be signalled when we have credit responses from all members\n                        }\n                        catch(InterruptedException e) {\n                            if(warn)\n                                log.warn(\"thread was interrupted\", e);\n                            Thread.currentThread().interrupt(); // pass the exception on to the  caller\n                            return null;\n                        }\n                    }\n\n                    // when we get here, curr_credits_available is guaranteed to be > 0\n                    int len=msg.getLength();\n                    num_bytes_sent+=len;\n                    curr_credits_available-=len; // we'll block on insufficient credits on the next down() call\n                    if(curr_credits_available <=0) {\n                        pending_creditors.clear();\n                        synchronized(members) {\n                            pending_creditors.addAll(members);\n                        }\n                        send_credit_request=true;\n                    }\n                }\n                finally {\n                    lock.unlock();\n                }\n\n                // we don't need to protect send_credit_request because a thread above either (a) decrements the credits\n                // by the msg length and sets send_credit_request to true or (b) blocks because there are no credits\n                // available. So only 1 thread can ever set send_credit_request at any given time\n                if(send_credit_request) {\n                    if(trace)\n                        log.trace(\"sending credit request to group\");\n                    start=System.nanoTime(); // only 1 thread is here at any given time\n                    Object ret=passDown(evt);       // send the message before the credit request\n                    sendCreditRequest(); // do this outside of the lock\n                    return ret;\n                }\n                break;\n\n            case Event.VIEW_CHANGE:\n                handleViewChange((View)evt.getArg());\n                break;\n\n            case Event.SUSPECT:\n                handleSuspect((Address)evt.getArg());\n                break;\n        }\n\n        return passDown(evt);\n    }","commit_id":"6466d1657be2fbf93519d81155a90602cca24185","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                Header hdr=(Header)msg.getHeader(name);\n                Address sender=msg.getSrc();\n                if(hdr != null) {\n                    switch(hdr.type) {\n                        case Header.CREDIT_REQUEST:\n                            handleCreditRequest(sender);\n                            break;\n                        case Header.REPLENISH:\n                            handleCreditResponse(sender);\n                            break;\n                        default:\n                            if(log.isErrorEnabled())\n                                log.error(\"unknown header type \" + hdr.type);\n                            break;\n                    }\n                    return; // we don't pass the request further up\n                }\n\n                Address dest=msg.getDest();\n                if(dest != null && !dest.isMulticastAddress()) // we don't handle unicast messages\n                    break;\n\n                handleMessage(msg, sender);\n                break;\n\n            case Event.VIEW_CHANGE:\n                handleViewChange((View)evt.getArg());\n                break;\n\n            case Event.SUSPECT:\n                handleSuspect((Address)evt.getArg());\n                break;\n        }\n        passUp(evt);\n    }","id":28188,"modified_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                Header hdr=(Header)msg.getHeader(name);\n                Address sender=msg.getSrc();\n                if(hdr != null) {\n                    switch(hdr.type) {\n                        case Header.CREDIT_REQUEST:\n                            handleCreditRequest(sender);\n                            break;\n                        case Header.REPLENISH:\n                            handleCreditResponse(sender);\n                            break;\n                        default:\n                            if(log.isErrorEnabled())\n                                log.error(\"unknown header type \" + hdr.type);\n                            break;\n                    }\n                    return null; // we don't pass the request further up\n                }\n\n                Address dest=msg.getDest();\n                if(dest != null && !dest.isMulticastAddress()) // we don't handle unicast messages\n                    break;\n\n                handleMessage(msg, sender);\n                break;\n\n            case Event.VIEW_CHANGE:\n                handleViewChange((View)evt.getArg());\n                break;\n\n            case Event.SUSPECT:\n                handleSuspect((Address)evt.getArg());\n                break;\n        }\n        return passUp(evt);\n    }","commit_id":"6466d1657be2fbf93519d81155a90602cca24185","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean setProperties(Properties props) {\n        String     str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"name\");\n        if(str != null) {\n            name=str;\n            props.remove(\"name\");\n        }\n\n        if(props.size() > 0) {\n            log.error(\"DUMMY.setProperties(): these properties are not recognized: \" + props);\n\n            return false;\n        }\n        return true;\n    }","id":28189,"modified_method":"public boolean setProperties(Properties props) {\n        String     str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"name\");\n        if(str != null) {\n            name=str;\n            props.remove(\"name\");\n        }\n\n        if(!props.isEmpty()) {\n            log.error(\"DUMMY.setProperties(): these properties are not recognized: \" + props);\n\n            return false;\n        }\n        return true;\n    }","commit_id":"6466d1657be2fbf93519d81155a90602cca24185","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes a random chosen message from the <code>messages List<\\code> if there\n     * are less than 10 messages in the List it waits some time to ensure to chose from\n     * a set of messages > 1.\n     */\n\n    public void run() {\n        Message msg;\n        while (messagesHandler != null) {\n            if ( messages.size() > 0 ) {\n                msg = (Message) messages.remove(rnd(messages.size()));\n                passUp(new Event(Event.MSG,msg));\n            }\n            if (messages.size() < 5) {\n                try {\n                    Thread.sleep(300); /** @todo make this time user configurable */\n                }\n                catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        }// while\n        // PassUp remaining messages\n        Iterator iter = messages.iterator();\n        while (iter.hasNext()) {\n            msg = (Message) iter.next();\n            passUp(new Event(Event.MSG,msg));\n        }\n    }","id":28190,"modified_method":"/**\n     * Removes a random chosen message from the <code>messages List<\\code> if there\n     * are less than 10 messages in the List it waits some time to ensure to chose from\n     * a set of messages > 1.\n     */\n\n    public void run() {\n        Message msg;\n        while (messagesHandler != null) {\n            if (!messages.isEmpty()) {\n                msg = (Message) messages.remove(rnd(messages.size()));\n                passUp(new Event(Event.MSG,msg));\n            }\n            if (messages.size() < 5) {\n                try {\n                    Thread.sleep(300); /** @todo make this time user configurable */\n                }\n                catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        }// while\n        // PassUp remaining messages\n        Iterator iter = messages.iterator();\n        while (iter.hasNext()) {\n            msg = (Message) iter.next();\n            passUp(new Event(Event.MSG,msg));\n        }\n    }","commit_id":"6466d1657be2fbf93519d81155a90602cca24185","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds upcoming messages to the <code>messages List<\\code> where the <code>messagesHandler<\\code>\n     * retrieves them.\n     */\n\n    public Object up(Event evt) {\n        Message msg;\n\n        switch (evt.getType()) {\n\n\tcase Event.MSG:\n            msg=(Message)evt.getArg();\n            // Do something with the event, e.g. extract the message and remove a header.\n            // Optionally pass up\n            messages.add(msg);\n            return;\n        }\n\n        passUp(evt);            // Pass up to the layer above us\n    }","id":28191,"modified_method":"/**\n     * Adds upcoming messages to the <code>messages List<\\code> where the <code>messagesHandler<\\code>\n     * retrieves them.\n     */\n\n    public Object up(Event evt) {\n        Message msg;\n\n        switch (evt.getType()) {\n\n            case Event.MSG:\n                msg=(Message)evt.getArg();\n                // Do something with the event, e.g. extract the message and remove a header.\n                // Optionally pass up\n                messages.add(msg);\n                return null;\n        }\n\n        return passUp(evt);            // Pass up to the layer above us\n    }","commit_id":"6466d1657be2fbf93519d81155a90602cca24185","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        Message leave_msg;\n\n        switch(evt.getType()) {\n\n            case Event.DISCONNECT:\n                leave_msg=new Message();\n                leave_msg.putHeader(name, new SmackHeader(SmackHeader.LEAVE_ANNOUNCEMENT, -1));\n                passDown(new Event(Event.MSG, leave_msg));\n                // passUp(new Event(Event.DISCONNECT_OK));\n                break;\n\n            case Event.CONNECT:\n                //passUp(new Event(Event.CONNECT_OK));\n\n                // Do not send JOIN_ANOUNCEMENT here, don't know yet if the transport is OK.\n                // Send it later when handling CONNECT_OK from below\n\n//                 sender_win=new AckMcastSenderWindow(this, timeout);\n//                 // send join announcement\n//                 Message join_msg=new Message();\n//                 join_msg.putHeader(name, new SmackHeader(SmackHeader.JOIN_ANNOUNCEMENT, -1));\n//                 passDown(new Event(Event.MSG, join_msg));\n//                 return;\n\n                break;\n\n\n// add a header with the current sequence number and increment seqno\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                if(msg == null) break;\n                if(msg.getDest() == null || msg.getDest().isMulticastAddress()) {\n                    msg.putHeader(name, new SmackHeader(SmackHeader.MCAST, seqno));\n                    sender_win.add(seqno, msg, (Vector)members.clone());\n                    if(trace) log.trace(\"sending mcast #\" + seqno);\n                    seqno++;\n                }\n                break;\n        }\n\n        passDown(evt);\n    }","id":28192,"modified_method":"public Object down(Event evt) {\n        Message leave_msg;\n\n        switch(evt.getType()) {\n\n            case Event.DISCONNECT:\n                leave_msg=new Message();\n                leave_msg.putHeader(name, new SmackHeader(SmackHeader.LEAVE_ANNOUNCEMENT, -1));\n                passDown(new Event(Event.MSG, leave_msg));\n                // passUp(new Event(Event.DISCONNECT_OK));\n                break;\n\n            case Event.CONNECT:\n                //passUp(new Event(Event.CONNECT_OK));\n\n                // Do not send JOIN_ANOUNCEMENT here, don't know yet if the transport is OK.\n                // Send it later when handling CONNECT_OK from below\n\n//                 sender_win=new AckMcastSenderWindow(this, timeout);\n//                 // send join announcement\n//                 Message join_msg=new Message();\n//                 join_msg.putHeader(name, new SmackHeader(SmackHeader.JOIN_ANNOUNCEMENT, -1));\n//                 passDown(new Event(Event.MSG, join_msg));\n//                 return;\n\n                break;\n\n\n// add a header with the current sequence number and increment seqno\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                if(msg == null) break;\n                if(msg.getDest() == null || msg.getDest().isMulticastAddress()) {\n                    msg.putHeader(name, new SmackHeader(SmackHeader.MCAST, seqno));\n                    sender_win.add(seqno, msg, (Vector)members.clone());\n                    if(trace) log.trace(\"sending mcast #\" + seqno);\n                    seqno++;\n                }\n                break;\n        }\n\n        return passDown(evt);\n    }","commit_id":"6466d1657be2fbf93519d81155a90602cca24185","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Address sender;\n\n        switch(evt.getType()) {\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                addMember(local_addr);\n                if(print_local_addr) {\n                    System.out.println(\"\\n-------------------------------------------------------\\n\" +\n                                       \"GMS: address is \" + local_addr +\n                                       \"\\n-------------------------------------------------------\");\n                }\n                break;\n\n            case Event.CONNECT_OK:\n                passUp(evt);\n                sender_win=new AckMcastSenderWindow(this, timeout);\n\n                // send join announcement\n                Message join_msg=new Message();\n                join_msg.putHeader(name, new SmackHeader(SmackHeader.JOIN_ANNOUNCEMENT, -1));\n                passDown(new Event(Event.MSG, join_msg));\n                return;\n\n            case Event.SUSPECT:\n\n                    if(log.isInfoEnabled()) log.info(\"removing suspected member \" + evt.getArg());\n                removeMember((Address)evt.getArg());\n                break;\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg(), tmp_msg;\n                if(msg == null) break;\n                sender=msg.getSrc();\n                SmackHeader hdr=(SmackHeader)msg.removeHeader(name);\n                if(hdr == null) // is probably a unicast message\n                    break;\n                switch(hdr.type) {\n                    case SmackHeader.MCAST: // send an ack, then pass up (if not already received)\n                        Long tmp_seqno;\n                        AckReceiverWindow win;\n                        Message ack_msg=new Message(sender);\n\n                        ack_msg.putHeader(name, new SmackHeader(SmackHeader.ACK, hdr.seqno));\n                        passDown(new Event(Event.MSG, ack_msg));\n\n                        tmp_seqno=new Long(hdr.seqno);\n\n                        if(trace)\n                            log.trace(\"received #\" + tmp_seqno + \" from \" + sender);\n\n                        win=(AckReceiverWindow)receivers.get(sender);\n                        if(win == null) {\n                            addMember(sender);\n                            win=new AckReceiverWindow(hdr.seqno);\n                            receivers.put(sender, win);\n                        }\n                        boolean added=win.add(hdr.seqno, msg);\n                        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n                        // http://jira.jboss.com/jira/browse/JGRP-379\n                        if(msg.isFlagSet(Message.OOB) && added) {\n                            passUp(new Event(Event.MSG, msg));\n                        }\n\n                        // now remove as many messages as possible\n                        while((tmp_msg=win.remove()) != null) {\n                            // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                            if(tmp_msg.isFlagSet(Message.OOB)) {\n                                continue;\n                            }\n\n                            passUp(new Event(Event.MSG, tmp_msg));\n                        }\n                        return;\n\n                    case SmackHeader.ACK:\n                        addMember(msg.getSrc());\n                        sender_win.ack(hdr.seqno, msg.getSrc());\n                        sender_win.clearStableMessages();\n                        if(trace)\n                            log.trace(\"received ack for #\" + hdr.seqno + \" from \" + msg.getSrc());\n                        return;\n\n                    case SmackHeader.JOIN_ANNOUNCEMENT:\n\n                            if(log.isInfoEnabled()) log.info(\"received join announcement by \" + msg.getSrc());\n\n                        if(!containsMember(sender)) {\n                            Message join_rsp=new Message(sender);\n                            join_rsp.putHeader(name, new SmackHeader(SmackHeader.JOIN_ANNOUNCEMENT, -1));\n                            passDown(new Event(Event.MSG, join_rsp));\n                        }\n                        addMember(sender);\n                        return;\n\n                    case SmackHeader.LEAVE_ANNOUNCEMENT:\n\n                            if(log.isInfoEnabled()) log.info(\"received leave announcement by \" + msg.getSrc());\n\n                        removeMember(sender);\n                        return;\n\n                    default:\n                        if(warn) log.warn(\"detected SmackHeader with invalid type: \" + hdr);\n                        break;\n                }\n                break;\n        }\n\n        passUp(evt);\n    }","id":28193,"modified_method":"public Object up(Event evt) {\n        Address sender;\n\n        switch(evt.getType()) {\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                addMember(local_addr);\n                if(print_local_addr) {\n                    System.out.println(\"\\n-------------------------------------------------------\\n\" +\n                                       \"GMS: address is \" + local_addr +\n                                       \"\\n-------------------------------------------------------\");\n                }\n                break;\n\n            case Event.CONNECT_OK:\n                Object ret=passUp(evt);\n                sender_win=new AckMcastSenderWindow(this, timeout);\n\n                // send join announcement\n                Message join_msg=new Message();\n                join_msg.putHeader(name, new SmackHeader(SmackHeader.JOIN_ANNOUNCEMENT, -1));\n                passDown(new Event(Event.MSG, join_msg));\n                return ret;\n\n            case Event.SUSPECT:\n                if(log.isInfoEnabled()) log.info(\"removing suspected member \" + evt.getArg());\n                removeMember((Address)evt.getArg());\n                break;\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg(), tmp_msg;\n                if(msg == null) break;\n                sender=msg.getSrc();\n                SmackHeader hdr=(SmackHeader)msg.getHeader(name);\n                if(hdr == null) // is probably a unicast message\n                    break;\n                switch(hdr.type) {\n                    case SmackHeader.MCAST: // send an ack, then pass up (if not already received)\n                        Long tmp_seqno;\n                        AckReceiverWindow win;\n                        Message ack_msg=new Message(sender);\n\n                        ack_msg.putHeader(name, new SmackHeader(SmackHeader.ACK, hdr.seqno));\n                        passDown(new Event(Event.MSG, ack_msg));\n\n                        tmp_seqno=new Long(hdr.seqno);\n\n                        if(trace)\n                            log.trace(\"received #\" + tmp_seqno + \" from \" + sender);\n\n                        win=(AckReceiverWindow)receivers.get(sender);\n                        if(win == null) {\n                            addMember(sender);\n                            win=new AckReceiverWindow(hdr.seqno);\n                            receivers.put(sender, win);\n                        }\n                        boolean added=win.add(hdr.seqno, msg);\n                        // message is passed up if OOB. Later, when remove() is called, we discard it. This affects ordering !\n                        // http://jira.jboss.com/jira/browse/JGRP-379\n                        if(msg.isFlagSet(Message.OOB) && added) {\n                            passUp(new Event(Event.MSG, msg));\n                        }\n\n                        // now remove as many messages as possible\n                        while((tmp_msg=win.remove()) != null) {\n                            // discard OOB msg as it has already been delivered (http://jira.jboss.com/jira/browse/JGRP-379)\n                            if(tmp_msg.isFlagSet(Message.OOB)) {\n                                continue;\n                            }\n\n                            passUp(new Event(Event.MSG, tmp_msg));\n                        }\n                        return null;\n\n                    case SmackHeader.ACK:\n                        addMember(msg.getSrc());\n                        sender_win.ack(hdr.seqno, msg.getSrc());\n                        sender_win.clearStableMessages();\n                        if(trace)\n                            log.trace(\"received ack for #\" + hdr.seqno + \" from \" + msg.getSrc());\n                        return null;\n\n                    case SmackHeader.JOIN_ANNOUNCEMENT:\n\n                            if(log.isInfoEnabled()) log.info(\"received join announcement by \" + msg.getSrc());\n\n                        if(!containsMember(sender)) {\n                            Message join_rsp=new Message(sender);\n                            join_rsp.putHeader(name, new SmackHeader(SmackHeader.JOIN_ANNOUNCEMENT, -1));\n                            passDown(new Event(Event.MSG, join_rsp));\n                        }\n                        addMember(sender);\n                        return null;\n\n                    case SmackHeader.LEAVE_ANNOUNCEMENT:\n                        if(log.isInfoEnabled()) log.info(\"received leave announcement by \" + msg.getSrc());\n                        removeMember(sender);\n                        return null;\n\n                    default:\n                        if(warn) log.warn(\"detected SmackHeader with invalid type: \" + hdr);\n                        break;\n                }\n                break;\n        }\n\n        return passUp(evt);\n    }","commit_id":"6466d1657be2fbf93519d81155a90602cca24185","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean setProperties(Properties props) {\n        String str;\n        long[] tmp;\n\n        super.setProperties(props);\n        str=props.getProperty(\"print_local_addr\");\n        if(str != null) {\n            print_local_addr=Boolean.valueOf(str).booleanValue();\n            props.remove(\"print_local_addr\");\n        }\n\n        str=props.getProperty(\"timeout\");\n        if(str != null) {\n            tmp=Util.parseCommaDelimitedLongs(str);\n            props.remove(\"timeout\");\n            if(tmp != null && tmp.length > 0)\n                timeout=tmp;\n        }\n\n        str=props.getProperty(\"max_xmits\");\n        if(str != null) {\n            max_xmits=Integer.parseInt(str);\n            props.remove(\"max_xmits\");\n        }\n\n\n        if(props.size() > 0) {\n            log.error(\"SMACK.setProperties(): the following properties are not recognized: \" + props);\n\n            return false;\n        }\n        return true;\n    }","id":28194,"modified_method":"public boolean setProperties(Properties props) {\n        String str;\n        long[] tmp;\n\n        super.setProperties(props);\n        str=props.getProperty(\"print_local_addr\");\n        if(str != null) {\n            print_local_addr=Boolean.valueOf(str).booleanValue();\n            props.remove(\"print_local_addr\");\n        }\n\n        str=props.getProperty(\"timeout\");\n        if(str != null) {\n            tmp=Util.parseCommaDelimitedLongs(str);\n            props.remove(\"timeout\");\n            if(tmp != null && tmp.length > 0)\n                timeout=tmp;\n        }\n\n        str=props.getProperty(\"max_xmits\");\n        if(str != null) {\n            max_xmits=Integer.parseInt(str);\n            props.remove(\"max_xmits\");\n        }\n\n\n        if(!props.isEmpty()) {\n            log.error(\"SMACK.setProperties(): the following properties are not recognized: \" + props);\n            return false;\n        }\n        return true;\n    }","commit_id":"6466d1657be2fbf93519d81155a90602cca24185","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void updateContinuations(boolean remove) {\n\n        modifyList(remove);\n        \n        if (jmsConfig.getMaxSuspendedContinuations() < 0\n            || jmsListener.getCacheLevel() >= DefaultMessageListenerContainer.CACHE_CONSUMER) {\n            return;\n        }\n        \n        // throttle the flow if there're too many continuation instances in memory\n        if (remove && !BOGUS_MESSAGE_SELECTOR.equals(currentMessageSelector)) {\n            LOG.fine(\"A number of continuations has dropped below the limit of \"\n                     + jmsConfig.getMaxSuspendedContinuations()\n                     + \", resetting JMS MessageSelector to \" + currentMessageSelector);\n            jmsListener.setMessageSelector(currentMessageSelector);\n            currentMessageSelector = BOGUS_MESSAGE_SELECTOR;\n        } else if (!remove && continuations.size() >= jmsConfig.getMaxSuspendedContinuations()) {\n            currentMessageSelector = jmsListener.getMessageSelector();\n            if (!BOGUS_MESSAGE_SELECTOR.equals(currentMessageSelector)) {\n                LOG.fine(\"A number of continuations has reached the limit of \"\n                         + jmsConfig.getMaxSuspendedContinuations()\n                         + \", setting JMS MessageSelector to \" + BOGUS_MESSAGE_SELECTOR);\n                jmsListener.setMessageSelector(BOGUS_MESSAGE_SELECTOR);\n                \n            }\n        }\n\n    }","id":28195,"modified_method":"protected void updateContinuations(boolean remove) {\n\n        if (jmsConfig.getMaxSuspendedContinuations() < 0\n            || jmsListener.getCacheLevel() >= DefaultMessageListenerContainer.CACHE_CONSUMER) {\n            modifyList(remove);\n            return;\n        }\n        \n        // throttle the flow if there're too many continuation instances in memory\n        synchronized (continuations) {\n            modifyList(remove);\n            if (remove && !BOGUS_MESSAGE_SELECTOR.equals(currentMessageSelector)) {\n                jmsListener.setMessageSelector(currentMessageSelector);\n                currentMessageSelector = BOGUS_MESSAGE_SELECTOR;\n            } else if (!remove && continuations.size() >= jmsConfig.getMaxSuspendedContinuations()) {\n                currentMessageSelector = jmsListener.getMessageSelector();\n                if (!BOGUS_MESSAGE_SELECTOR.equals(currentMessageSelector)) {\n                    jmsListener.setMessageSelector(BOGUS_MESSAGE_SELECTOR);\n                    \n                }\n            }\n        }\n\n    }","commit_id":"bd23bcdc5d03267e3e4edee739f5eced0986f3b8","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Create and start listener using configuration information from jmsConfig. Uses\n     * resolveOrCreateDestination to determine the destination for the listener.\n     * \n     * @param jmsConfig configuration information\n     * @param listenerHandler object to be called when a message arrives\n     * @param destinationName null for temp dest or a destination name\n     * @param messageSelectorPrefix prefix for the messageselector\n     * @return\n     */\n    public static DefaultMessageListenerContainer createJmsListener(JMSConfiguration jmsConfig,\n                                                                    MessageListener listenerHandler,\n                                                                    String destinationName, \n                                                                    String messageSelectorPrefix,\n                                                                    boolean userCID) {\n        DefaultMessageListenerContainer jmsListener = jmsConfig.isUseJms11()\n            ? new DefaultMessageListenerContainer() : new DefaultMessageListenerContainer102();\n        jmsListener.setConcurrentConsumers(jmsConfig.getConcurrentConsumers());\n        jmsListener.setMaxConcurrentConsumers(jmsConfig.getMaxConcurrentConsumers());\n        jmsListener.setPubSubDomain(jmsConfig.isPubSubDomain());\n        jmsListener.setPubSubNoLocal(jmsConfig.isPubSubNoLocal());\n        jmsListener.setAutoStartup(true);\n        jmsListener.setConnectionFactory(jmsConfig.getOrCreateWrappedConnectionFactory());\n        jmsListener.setMessageSelector(jmsConfig.getMessageSelector());\n        //jmsListener.setSubscriptionDurable(jmsConfig.isSubscriptionDurable());\n        jmsListener.setDurableSubscriptionName(jmsConfig.getDurableSubscriptionName());\n        jmsListener.setSessionTransacted(jmsConfig.isSessionTransacted());\n        jmsListener.setTransactionManager(jmsConfig.getTransactionManager());\n        jmsListener.setMessageListener(listenerHandler);\n        if (jmsConfig.getRecoveryInterval() != JMSConfiguration.DEFAULT_VALUE) {\n            jmsListener.setRecoveryInterval(jmsConfig.getRecoveryInterval());\n        }\n        if (jmsConfig.getCacheLevelName() != null && (jmsConfig.getCacheLevelName().trim().length() > 0)) {\n            jmsListener.setCacheLevelName(jmsConfig.getCacheLevelName());\n        } else if (jmsConfig.getCacheLevel() != JMSConfiguration.DEFAULT_VALUE) {\n            jmsListener.setCacheLevel(jmsConfig.getCacheLevel());\n        }\n        if (jmsListener.getCacheLevel() >= DefaultMessageListenerContainer.CACHE_CONSUMER\n            && jmsConfig.getMaxSuspendedContinuations() > 0) {\n            LOG.info(\"maxSuspendedContinuations value will be ignored - \"\n                     + \", please set cacheLevel to the value less than \"\n                     + \" org.springframework.jms.listener.DefaultMessageListenerContainer.CACHE_CONSUMER\");\n        }\n        String staticSelectorPrefix = jmsConfig.getConduitSelectorPrefix();\n        if (!userCID && messageSelectorPrefix != null && jmsConfig.isUseConduitIdSelector()) {\n            jmsListener.setMessageSelector(\"JMSCorrelationID LIKE '\" \n                                        + staticSelectorPrefix \n                                        + messageSelectorPrefix + \"%'\");\n        } else if (staticSelectorPrefix.length() > 0) {\n            jmsListener.setMessageSelector(\"JMSCorrelationID LIKE '\" \n                                        + staticSelectorPrefix +  \"%'\");\n        }\n        if (jmsConfig.getDestinationResolver() != null) {\n            jmsListener.setDestinationResolver(jmsConfig.getDestinationResolver());\n        }\n        if (jmsConfig.getTaskExecutor() != null) {\n            jmsListener.setTaskExecutor(jmsConfig.getTaskExecutor());\n        } else {\n            SimpleAsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor();\n            taskExecutor.setConcurrencyLimit(jmsConfig.getMaxConcurrentTasks());\n            jmsListener.setTaskExecutor(taskExecutor);\n        }\n        if (jmsConfig.isAutoResolveDestination()) {\n            jmsListener.setDestinationName(destinationName);\n        } else {\n            JmsTemplate jmsTemplate = createJmsTemplate(jmsConfig, null);\n            Destination dest = JMSFactory.resolveOrCreateDestination(jmsTemplate, destinationName, jmsConfig\n                .isPubSubDomain());\n            jmsListener.setDestination(dest);\n        }\n        jmsListener.initialize();\n        return jmsListener;\n    }","id":28196,"modified_method":"/**\n     * Create and start listener using configuration information from jmsConfig. Uses\n     * resolveOrCreateDestination to determine the destination for the listener.\n     * \n     * @param jmsConfig configuration information\n     * @param listenerHandler object to be called when a message arrives\n     * @param destinationName null for temp dest or a destination name\n     * @param messageSelectorPrefix prefix for the messageselector\n     * @return\n     */\n    public static DefaultMessageListenerContainer createJmsListener(JMSConfiguration jmsConfig,\n                                                                    MessageListener listenerHandler,\n                                                                    String destinationName, \n                                                                    String messageSelectorPrefix,\n                                                                    boolean userCID) {\n        DefaultMessageListenerContainer jmsListener = jmsConfig.isUseJms11()\n            ? new DefaultMessageListenerContainer() : new DefaultMessageListenerContainer102();\n        jmsListener.setConcurrentConsumers(jmsConfig.getConcurrentConsumers());\n        jmsListener.setMaxConcurrentConsumers(jmsConfig.getMaxConcurrentConsumers());\n        jmsListener.setPubSubDomain(jmsConfig.isPubSubDomain());\n        jmsListener.setPubSubNoLocal(jmsConfig.isPubSubNoLocal());\n        jmsListener.setAutoStartup(true);\n        jmsListener.setConnectionFactory(jmsConfig.getOrCreateWrappedConnectionFactory());\n        jmsListener.setMessageSelector(jmsConfig.getMessageSelector());\n        //jmsListener.setSubscriptionDurable(jmsConfig.isSubscriptionDurable());\n        jmsListener.setDurableSubscriptionName(jmsConfig.getDurableSubscriptionName());\n        jmsListener.setSessionTransacted(jmsConfig.isSessionTransacted());\n        jmsListener.setTransactionManager(jmsConfig.getTransactionManager());\n        jmsListener.setMessageListener(listenerHandler);\n        if (jmsConfig.getRecoveryInterval() != JMSConfiguration.DEFAULT_VALUE) {\n            jmsListener.setRecoveryInterval(jmsConfig.getRecoveryInterval());\n        }\n        if (jmsConfig.getCacheLevelName() != null && (jmsConfig.getCacheLevelName().trim().length() > 0)) {\n            jmsListener.setCacheLevelName(jmsConfig.getCacheLevelName());\n        } else if (jmsConfig.getCacheLevel() != JMSConfiguration.DEFAULT_VALUE) {\n            jmsListener.setCacheLevel(jmsConfig.getCacheLevel());\n        }\n        if (jmsListener.getCacheLevel() >= DefaultMessageListenerContainer.CACHE_CONSUMER\n            && jmsConfig.getMaxSuspendedContinuations() > 0) {\n            LOG.info(\"maxSuspendedContinuations value will be ignored - \"\n                     + \", please set cacheLevel to the value less than \"\n                     + \" org.springframework.jms.listener.DefaultMessageListenerContainer.CACHE_CONSUMER\");\n        }\n        String staticSelectorPrefix = jmsConfig.getConduitSelectorPrefix();\n        if (!userCID && messageSelectorPrefix != null && jmsConfig.isUseConduitIdSelector()) {\n            jmsListener.setMessageSelector(\"JMSCorrelationID LIKE '\" \n                                        + staticSelectorPrefix \n                                        + messageSelectorPrefix + \"%'\");\n        } else if (staticSelectorPrefix.length() > 0) {\n            jmsListener.setMessageSelector(\"JMSCorrelationID LIKE '\" \n                                        + staticSelectorPrefix +  \"%'\");\n        }\n        if (jmsConfig.getDestinationResolver() != null) {\n            jmsListener.setDestinationResolver(jmsConfig.getDestinationResolver());\n        }\n        if (jmsConfig.getTaskExecutor() != null) {\n            jmsListener.setTaskExecutor(jmsConfig.getTaskExecutor());\n        } \n        \n        if (jmsConfig.isAutoResolveDestination()) {\n            jmsListener.setDestinationName(destinationName);\n        } else {\n            JmsTemplate jmsTemplate = createJmsTemplate(jmsConfig, null);\n            Destination dest = JMSFactory.resolveOrCreateDestination(jmsTemplate, destinationName, jmsConfig\n                .isPubSubDomain());\n            jmsListener.setDestination(dest);\n        }\n        jmsListener.initialize();\n        return jmsListener;\n    }","commit_id":"bd23bcdc5d03267e3e4edee739f5eced0986f3b8","url":"https://github.com/apache/cxf"},{"original_method":"public static void registerQuickFixActions(PsiMethodCallExpression methodCall, PsiExpressionList list, HighlightInfo highlightInfo) {\n    PsiMethod method = (PsiMethod)methodCall.getMethodExpression().resolve();\n    PsiExpression[] expressions = list.getExpressions();\n    if (method == null || method.getParameterList() == null || method.getParameterList().getParameters().length != expressions.length) return;\n    for (int i = 0; i < expressions.length; i++) {\n      PsiExpression expression = expressions[i];\n      PsiParameter parameter = method.getParameterList().getParameters()[i];\n      PsiType expressionType = expression.getType();\n      PsiType parameterType = parameter.getType();\n      if (expressionType == null || expressionType instanceof PsiPrimitiveType || TypeConversionUtil.isNullType(expressionType) || expressionType instanceof PsiArrayType ) continue;\n      if (parameterType == null || parameterType instanceof PsiPrimitiveType || TypeConversionUtil.isNullType(parameterType) || parameterType instanceof PsiArrayType ) continue;\n      if (parameterType.isAssignableFrom(expressionType)) continue;\n      PsiClass parameterClass = PsiUtil.resolveClassInType(parameterType);\n      PsiClass expressionClass = PsiUtil.resolveClassInType(expressionType);\n      if (parameterClass == null || expressionClass == null) continue;\n      if (parameterClass.isInheritor(expressionClass, true)) continue;\n      QuickFixAction.registerQuickFixAction(highlightInfo, new ChangeParameterClassFix(expressionClass, (PsiClassType)parameterType));\n    }\n  }","id":28197,"modified_method":"public static void registerQuickFixActions(PsiMethodCallExpression methodCall, PsiExpressionList list, HighlightInfo highlightInfo) {\n    PsiMethod method = (PsiMethod)methodCall.getMethodExpression().resolve();\n    PsiExpression[] expressions = list.getExpressions();\n    if (method == null || method.getParameterList().getParameters().length != expressions.length) return;\n    for (int i = 0; i < expressions.length; i++) {\n      PsiExpression expression = expressions[i];\n      PsiParameter parameter = method.getParameterList().getParameters()[i];\n      PsiType expressionType = expression.getType();\n      PsiType parameterType = parameter.getType();\n      if (expressionType == null || expressionType instanceof PsiPrimitiveType || TypeConversionUtil.isNullType(expressionType) || expressionType instanceof PsiArrayType ) continue;\n      if (parameterType instanceof PsiPrimitiveType || TypeConversionUtil.isNullType(parameterType) || parameterType instanceof PsiArrayType ) continue;\n      if (parameterType.isAssignableFrom(expressionType)) continue;\n      PsiClass parameterClass = PsiUtil.resolveClassInType(parameterType);\n      PsiClass expressionClass = PsiUtil.resolveClassInType(expressionType);\n      if (parameterClass == null || expressionClass == null) continue;\n      if (parameterClass.isInheritor(expressionClass, true)) continue;\n      QuickFixAction.registerQuickFixAction(highlightInfo, new ChangeParameterClassFix(expressionClass, (PsiClassType)parameterType));\n    }\n  }","commit_id":"1544fa4ac14bc8021310a4faf88af0164837cac8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static ProblemDescriptor[] createDescription(DataFlowRunner runner, InspectionManager manager) {\n    HashSet<Instruction>[] constConditions = runner.getConstConditionalExpressions();\n    HashSet<Instruction> trueSet = constConditions[0];\n    HashSet<Instruction> falseSet = constConditions[1];\n    Set<Instruction> npeSet = runner.getNPEInstructions();\n    Set<Instruction> cceSet = runner.getCCEInstructions();\n    Set<Instruction> redundantInstanceofs = runner.getRedundantInstanceofs();\n\n    ArrayList<Instruction> allProblems = new ArrayList<Instruction>();\n    allProblems.addAll(trueSet);\n    allProblems.addAll(falseSet);\n    allProblems.addAll(npeSet);\n    allProblems.addAll(cceSet);\n    allProblems.addAll(redundantInstanceofs);\n\n    Collections.sort(allProblems, new Comparator() {\n      public int compare(Object o1, Object o2) {\n        int i1 = ((Instruction)o1).getIndex();\n        int i2 = ((Instruction)o2).getIndex();\n\n        if (i1 == i2) return 0;\n        if (i1 > i2) return 1;\n\n        return -1;\n      }\n    });\n\n    ArrayList<ProblemDescriptor> descriptions = new ArrayList<ProblemDescriptor>(allProblems.size());\n    HashSet<PsiElement> reportedAnchors = new HashSet<PsiElement>();\n\n    for (Instruction instruction : allProblems) {\n      if (instruction instanceof MethodCallInstruction) {\n        MethodCallInstruction mcInstruction = (MethodCallInstruction)instruction;\n        if (mcInstruction.getCallExpression() instanceof PsiMethodCallExpression) {\n          PsiMethodCallExpression callExpression = (PsiMethodCallExpression)mcInstruction.getCallExpression();\n          LocalQuickFix[] fix = createNPEFixes(callExpression.getMethodExpression().getQualifierExpression());\n\n          descriptions.add(manager.createProblemDescriptor(mcInstruction.getCallExpression(),\n                                                           InspectionsBundle.message(\"dataflow.message.npe.method.invocation\"),\n                                                           fix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n        }\n      }\n      else if (instruction instanceof FieldReferenceInstruction) {\n        FieldReferenceInstruction frInstruction = (FieldReferenceInstruction)instruction;\n        PsiElement elementToAssert = frInstruction.getElementToAssert();\n        PsiExpression expression = frInstruction.getExpression();\n        if (expression instanceof PsiArrayAccessExpression) {\n          LocalQuickFix[] fix = createNPEFixes((PsiExpression)elementToAssert);\n          descriptions.add(manager.createProblemDescriptor(expression,\n                                                           InspectionsBundle.message(\"dataflow.message.npe.array.access\"),\n                                                           fix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n        }\n        else {\n          LocalQuickFix[] fix = createNPEFixes((PsiExpression)elementToAssert);\n          descriptions.add(manager.createProblemDescriptor(expression,\n                                                           InspectionsBundle.message(\"dataflow.message.npe.field.access\"),\n                                                           fix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n        }\n      }\n      else if (instruction instanceof TypeCastInstruction) {\n        TypeCastInstruction tcInstruction = (TypeCastInstruction)instruction;\n        PsiTypeCastExpression typeCast = tcInstruction.getCastExpression();\n        descriptions.add(manager.createProblemDescriptor(typeCast.getCastType(),\n                                                         InspectionsBundle.message(\"dataflow.message.cce\", typeCast.getOperand().getText()),\n                                                         (LocalQuickFix [])null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n      }\n      else if (instruction instanceof BranchingInstruction) {\n        PsiElement psiAnchor = ((BranchingInstruction)instruction).getPsiAnchor();\n        if (instruction instanceof BinopInstruction && ((BinopInstruction)instruction).isInstanceofRedundant()) {\n          if (((BinopInstruction)instruction).canBeNull()) {\n            descriptions.add(manager.createProblemDescriptor(psiAnchor,\n                                                             InspectionsBundle.message(\"dataflow.message.redundant.instanceof\"),\n                                                             new RedundantInstanceofFix(),\n                                                             ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n          }\n          else {\n            final LocalQuickFix localQuickFix = createSimplifyBooleanExpressionFix(psiAnchor, true);\n            descriptions.add(manager.createProblemDescriptor(psiAnchor,\n                                                             InspectionsBundle.message(\"dataflow.message.constant.condition\",\n                                                                                       Boolean.toString(true)),\n                                                             localQuickFix,\n                                                             ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n          }\n        }\n        else if (psiAnchor instanceof PsiSwitchLabelStatement) {\n          if (falseSet.contains(instruction)) {\n            descriptions.add(manager.createProblemDescriptor(psiAnchor,\n                                                             InspectionsBundle.message(\"dataflow.message.unreachable.switch.label\"),\n                                                             (LocalQuickFix [])null,\n                                                             ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n          }\n        }\n        else if (psiAnchor != null) {\n          if (!reportedAnchors.contains(psiAnchor)) {\n            if (onTheLeftSideOfConditionalAssignemnt(psiAnchor)) {\n              descriptions.add(manager.createProblemDescriptor(psiAnchor, InspectionsBundle.message(\n                \"dataflow.message.pointless.assignment.expression\", Boolean.toString(trueSet.contains(instruction))),\n                                                                          (LocalQuickFix)null,\n                                                                          ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n            }\n            else {\n              final LocalQuickFix localQuickFix = createSimplifyBooleanExpressionFix(psiAnchor, trueSet.contains(instruction));\n              descriptions.add(manager.createProblemDescriptor(psiAnchor,\n                                                               InspectionsBundle.message(\"dataflow.message.constant.condition\",\n                                                                                         Boolean.toString(trueSet.contains(instruction))),\n                                                               localQuickFix,\n                                                               ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n            }\n            reportedAnchors.add(psiAnchor);\n          }\n        }\n      }\n    }\n\n    Set<PsiExpression> exprs = runner.getNullableArguments();\n    for (PsiExpression expr : exprs) {\n      final String text = isNullLiteralExpression(expr)\n                          ? InspectionsBundle.message(\"dataflow.message.passing.null.argument\")\n                          : InspectionsBundle.message(\"dataflow.message.passing.nullable.argument\");\n\n      descriptions.add(manager.createProblemDescriptor(expr, text, (LocalQuickFix [])null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n    }\n\n    exprs = runner.getNullableAssignments();\n    for (PsiExpression expr : exprs) {\n      final String text = isNullLiteralExpression(expr)\n                              ? InspectionsBundle.message(\"dataflow.message.assigning.null\")\n                              : InspectionsBundle.message(\"dataflow.message.assigning.nullable\");\n      descriptions.add(manager.createProblemDescriptor(expr, text, (LocalQuickFix [])null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n    }\n\n    final HashSet<PsiReturnStatement> statements = runner.getNullableReturns();\n    for (PsiReturnStatement statement : statements) {\n      final PsiExpression expr = statement.getReturnValue();\n      if (runner.isInNotNullMethod()) {\n        final String text = isNullLiteralExpression(expr)\n                                ? InspectionsBundle.message(\"dataflow.message.return.null.from.notnull\")\n                                : InspectionsBundle.message(\"dataflow.message.return.nullable.from.notnull\");\n        descriptions.add(manager.createProblemDescriptor(expr, text, (LocalQuickFix [])null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n      }\n      else if (AnnotationUtil.isAnnotatingApplicable(statement)) {\n        final String text = isNullLiteralExpression(expr)\n                                ? InspectionsBundle.message(\"dataflow.message.return.null.from.notnullable\")\n                                : InspectionsBundle.message(\"dataflow.message.return.nullable.from.notnullable\");\n        descriptions.add(manager.createProblemDescriptor(expr, text,\n                                                         new AnnotateMethodFix(AnnotationUtil.NULLABLE),\n                                                         ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n\n      }\n    }\n\n    return descriptions.toArray(new ProblemDescriptor[descriptions.size()]);\n  }","id":28198,"modified_method":"private static ProblemDescriptor[] createDescription(DataFlowRunner runner, InspectionManager manager) {\n    HashSet<Instruction>[] constConditions = runner.getConstConditionalExpressions();\n    HashSet<Instruction> trueSet = constConditions[0];\n    HashSet<Instruction> falseSet = constConditions[1];\n    Set<Instruction> npeSet = runner.getNPEInstructions();\n    Set<Instruction> cceSet = runner.getCCEInstructions();\n    Set<Instruction> redundantInstanceofs = runner.getRedundantInstanceofs();\n\n    ArrayList<Instruction> allProblems = new ArrayList<Instruction>();\n    allProblems.addAll(trueSet);\n    allProblems.addAll(falseSet);\n    allProblems.addAll(npeSet);\n    allProblems.addAll(cceSet);\n    allProblems.addAll(redundantInstanceofs);\n\n    Collections.sort(allProblems, new Comparator() {\n      public int compare(Object o1, Object o2) {\n        int i1 = ((Instruction)o1).getIndex();\n        int i2 = ((Instruction)o2).getIndex();\n\n        if (i1 == i2) return 0;\n        if (i1 > i2) return 1;\n\n        return -1;\n      }\n    });\n\n    ArrayList<ProblemDescriptor> descriptions = new ArrayList<ProblemDescriptor>(allProblems.size());\n    HashSet<PsiElement> reportedAnchors = new HashSet<PsiElement>();\n\n    for (Instruction instruction : allProblems) {\n      if (instruction instanceof MethodCallInstruction) {\n        MethodCallInstruction mcInstruction = (MethodCallInstruction)instruction;\n        if (mcInstruction.getCallExpression() instanceof PsiMethodCallExpression) {\n          PsiMethodCallExpression callExpression = (PsiMethodCallExpression)mcInstruction.getCallExpression();\n          LocalQuickFix[] fix = createNPEFixes(callExpression.getMethodExpression().getQualifierExpression());\n\n          descriptions.add(manager.createProblemDescriptor(mcInstruction.getCallExpression(),\n                                                           InspectionsBundle.message(\"dataflow.message.npe.method.invocation\"),\n                                                           fix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n        }\n      }\n      else if (instruction instanceof FieldReferenceInstruction) {\n        FieldReferenceInstruction frInstruction = (FieldReferenceInstruction)instruction;\n        PsiElement elementToAssert = frInstruction.getElementToAssert();\n        PsiExpression expression = frInstruction.getExpression();\n        if (expression instanceof PsiArrayAccessExpression) {\n          LocalQuickFix[] fix = createNPEFixes((PsiExpression)elementToAssert);\n          descriptions.add(manager.createProblemDescriptor(expression,\n                                                           InspectionsBundle.message(\"dataflow.message.npe.array.access\"),\n                                                           fix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n        }\n        else {\n          LocalQuickFix[] fix = createNPEFixes((PsiExpression)elementToAssert);\n          descriptions.add(manager.createProblemDescriptor(expression,\n                                                           InspectionsBundle.message(\"dataflow.message.npe.field.access\"),\n                                                           fix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n        }\n      }\n      else if (instruction instanceof TypeCastInstruction) {\n        TypeCastInstruction tcInstruction = (TypeCastInstruction)instruction;\n        PsiTypeCastExpression typeCast = tcInstruction.getCastExpression();\n        descriptions.add(manager.createProblemDescriptor(typeCast.getCastType(),\n                                                         InspectionsBundle.message(\"dataflow.message.cce\", typeCast.getOperand().getText()),\n                                                         (LocalQuickFix [])null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n      }\n      else if (instruction instanceof BranchingInstruction) {\n        PsiElement psiAnchor = ((BranchingInstruction)instruction).getPsiAnchor();\n        if (instruction instanceof BinopInstruction && ((BinopInstruction)instruction).isInstanceofRedundant()) {\n          if (((BinopInstruction)instruction).canBeNull()) {\n            descriptions.add(manager.createProblemDescriptor(psiAnchor,\n                                                             InspectionsBundle.message(\"dataflow.message.redundant.instanceof\"),\n                                                             new RedundantInstanceofFix(),\n                                                             ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n          }\n          else {\n            final LocalQuickFix localQuickFix = createSimplifyBooleanExpressionFix(psiAnchor, true);\n            descriptions.add(manager.createProblemDescriptor(psiAnchor,\n                                                             InspectionsBundle.message(\"dataflow.message.constant.condition\",\n                                                                                       Boolean.toString(true)),\n                                                             localQuickFix,\n                                                             ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n          }\n        }\n        else if (psiAnchor instanceof PsiSwitchLabelStatement) {\n          if (falseSet.contains(instruction)) {\n            descriptions.add(manager.createProblemDescriptor(psiAnchor,\n                                                             InspectionsBundle.message(\"dataflow.message.unreachable.switch.label\"),\n                                                             (LocalQuickFix [])null,\n                                                             ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n          }\n        }\n        else if (psiAnchor != null) {\n          if (!reportedAnchors.contains(psiAnchor)) {\n            if (onTheLeftSideOfConditionalAssignemnt(psiAnchor)) {\n              descriptions.add(manager.createProblemDescriptor(psiAnchor, InspectionsBundle.message(\n                \"dataflow.message.pointless.assignment.expression\", Boolean.toString(trueSet.contains(instruction))),\n                                                                          (LocalQuickFix)null,\n                                                                          ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n            }\n            else {\n              final LocalQuickFix localQuickFix = createSimplifyBooleanExpressionFix(psiAnchor, trueSet.contains(instruction));\n              descriptions.add(manager.createProblemDescriptor(psiAnchor,\n                                                               InspectionsBundle.message(\"dataflow.message.constant.condition\",\n                                                                                         Boolean.toString(trueSet.contains(instruction))),\n                                                               localQuickFix,\n                                                               ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n            }\n            reportedAnchors.add(psiAnchor);\n          }\n        }\n      }\n    }\n\n    Set<PsiExpression> exprs = runner.getNullableArguments();\n    for (PsiExpression expr : exprs) {\n      final String text = isNullLiteralExpression(expr)\n                          ? InspectionsBundle.message(\"dataflow.message.passing.null.argument\")\n                          : InspectionsBundle.message(\"dataflow.message.passing.nullable.argument\");\n      LocalQuickFix[] fixes = createNPEFixes(expr);\n      descriptions.add(manager.createProblemDescriptor(expr, text, fixes, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n    }\n\n    exprs = runner.getNullableAssignments();\n    for (PsiExpression expr : exprs) {\n      final String text = isNullLiteralExpression(expr)\n                              ? InspectionsBundle.message(\"dataflow.message.assigning.null\")\n                              : InspectionsBundle.message(\"dataflow.message.assigning.nullable\");\n      descriptions.add(manager.createProblemDescriptor(expr, text, (LocalQuickFix [])null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n    }\n\n    final HashSet<PsiReturnStatement> statements = runner.getNullableReturns();\n    for (PsiReturnStatement statement : statements) {\n      final PsiExpression expr = statement.getReturnValue();\n      if (runner.isInNotNullMethod()) {\n        final String text = isNullLiteralExpression(expr)\n                                ? InspectionsBundle.message(\"dataflow.message.return.null.from.notnull\")\n                                : InspectionsBundle.message(\"dataflow.message.return.nullable.from.notnull\");\n        descriptions.add(manager.createProblemDescriptor(expr, text, (LocalQuickFix [])null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n      }\n      else if (AnnotationUtil.isAnnotatingApplicable(statement)) {\n        final String text = isNullLiteralExpression(expr)\n                                ? InspectionsBundle.message(\"dataflow.message.return.null.from.notnullable\")\n                                : InspectionsBundle.message(\"dataflow.message.return.nullable.from.notnullable\");\n        descriptions.add(manager.createProblemDescriptor(expr, text,\n                                                         new AnnotateMethodFix(AnnotationUtil.NULLABLE),\n                                                         ProblemHighlightType.GENERIC_ERROR_OR_WARNING));\n\n      }\n    }\n\n    return descriptions.toArray(new ProblemDescriptor[descriptions.size()]);\n  }","commit_id":"1544fa4ac14bc8021310a4faf88af0164837cac8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void invokeImpl () {\n    if (!CodeInsightUtil.prepareFileForWrite(myClass.getContainingFile())) return;\n    PsiReferenceList extendsList = !(myClass instanceof PsiTypeParameter) &&\n                                   myClass.isInterface() != myClassToExtendFrom.isInterface() ?\n                                   myClass.getImplementsList() : myClass.getExtendsList();\n    PsiReferenceList otherList = extendsList == myClass.getImplementsList() ?\n                                 myClass.getExtendsList() : myClass.getImplementsList();\n    try {\n      modifyList(extendsList, myToAdd, -1);\n      modifyList(otherList, !myToAdd, -1);\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":28199,"modified_method":"protected void invokeImpl () {\n    if (!CodeInsightUtil.prepareFileForWrite(myClass.getContainingFile())) return;\n    PsiReferenceList extendsList = !(myClass instanceof PsiTypeParameter) &&\n                                   myClass.isInterface() != myClassToExtendFrom.isInterface() ?\n                                   myClass.getImplementsList() : myClass.getExtendsList();\n    PsiReferenceList otherList = extendsList == myClass.getImplementsList() ?\n                                 myClass.getExtendsList() : myClass.getImplementsList();\n    try {\n      if (extendsList != null) {\n        modifyList(extendsList, myToAdd, -1);\n      }\n      if (otherList != null) {\n        modifyList(otherList, !myToAdd, -1);\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"1544fa4ac14bc8021310a4faf88af0164837cac8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public StopServiceResponseType stopService( StopServiceType request ) {\n    StopServiceResponseType reply = request.getReply( );\n    for ( ServiceInfoType serviceInfo : request.getServices( ) ) {\n      try {\n        Component comp = Components.lookup( serviceInfo.getType( ) );\n        ServiceConfiguration service = comp.lookupServiceConfiguration( serviceInfo.getName( ) );\n        if ( service.isVmLocal( ) ) {\n          try {\n            comp.stopTransition( service ).get( );\n          } catch ( IllegalStateException ex ) {\n            LOG.error( ex, ex );\n            return reply.markFailed( );\n          } catch ( ExecutionException ex ) {\n            LOG.error( ex, ex );\n            return reply.markFailed( );\n          } catch ( InterruptedException ex ) {\n            LOG.error( ex, ex );\n            return reply.markFailed( );\n          }\n        }\n      } catch ( NoSuchElementException ex ) {\n        LOG.error( ex, ex );\n        return reply.markFailed( );\n      }\n    }\n    return reply;\n  }","id":28200,"modified_method":"public StopServiceResponseType stopService( StopServiceType request ) throws Throwable {\n    StopServiceResponseType reply = request.getReply( );\n    for ( ServiceInfoType serviceInfo : request.getServices( ) ) {\n      try {\n        Component comp = Components.lookup( serviceInfo.getType( ) );\n        ServiceConfiguration service = comp.lookupServiceConfiguration( serviceInfo.getName( ) );\n        if ( service.isVmLocal( ) ) {\n          try {\n            comp.stopTransition( service ).get( );\n            reply.getServices( ).add( serviceInfo );\n          } catch ( IllegalStateException ex ) {\n            LOG.error( ex, ex );\n            throw ex;\n          } catch ( ExecutionException ex ) {\n            LOG.error( ex , ex );\n            throw ex.getCause( );\n          } catch ( InterruptedException ex ) {\n            LOG.error( ex , ex );\n            Thread.currentThread( ).interrupt( );\n            throw ex;\n          }\n        }\n      } catch ( NoSuchElementException ex ) {\n        LOG.error( ex, ex );\n        throw ex;\n      }\n    }\n    return reply;\n  }","commit_id":"e53538e80f86698894d556aeff8dc09492621850","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public EnableServiceResponseType enableService( EnableServiceType request ) {\n    EnableServiceResponseType reply = request.getReply( );\n    for ( ServiceInfoType serviceInfo : request.getServices( ) ) {\n      try {\n        Component comp = Components.lookup( serviceInfo.getType( ) );\n        ServiceConfiguration service = comp.lookupServiceConfiguration( serviceInfo.getName( ) );\n        if ( service.isVmLocal( ) ) {\n          try {\n            comp.enableTransition( service );\n          } catch ( IllegalStateException ex ) {\n            LOG.error( ex, ex );\n            return reply.markFailed( );\n          }\n        }\n      } catch ( NoSuchElementException ex ) {\n        LOG.error( ex, ex );\n        return reply.markFailed( );\n      }\n    }\n    return reply;\n  }","id":28201,"modified_method":"public EnableServiceResponseType enableService( EnableServiceType request ) throws Throwable {\n    EnableServiceResponseType reply = request.getReply( );\n    for ( ServiceInfoType serviceInfo : request.getServices( ) ) {\n      try {\n        Component comp = Components.lookup( serviceInfo.getType( ) );\n        ServiceConfiguration service = comp.lookupServiceConfiguration( serviceInfo.getName( ) );\n        if ( service.isVmLocal( ) ) {\n          try {\n            comp.enableTransition( service ).get( );\n            reply.getServices( ).add( serviceInfo );\n          } catch ( IllegalStateException ex ) {\n            LOG.error( ex, ex );\n            throw ex;\n          } catch ( ExecutionException ex ) {\n            LOG.error( ex , ex );\n            throw ex.getCause( );\n          } catch ( InterruptedException ex ) {\n            LOG.error( ex , ex );\n            Thread.currentThread( ).interrupt( );\n            throw ex;\n          }\n        }\n      } catch ( NoSuchElementException ex ) {\n        LOG.error( ex, ex );\n        throw ex;\n      }\n    }\n    return reply;\n  }","commit_id":"e53538e80f86698894d556aeff8dc09492621850","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DisableServiceResponseType disableService( DisableServiceType request ) {\n    DisableServiceResponseType reply = request.getReply( );\n    for ( ServiceInfoType serviceInfo : request.getServices( ) ) {\n      try {\n        Component c = Components.lookup( serviceInfo.getType( ) );\n        for ( ServiceConfiguration config : c.lookupServiceConfigurations( ) ) {\n          String partition = config.getPartition( );\n          String name = config.getName( );\n          if ( partition.equals( serviceInfo.getPartition( ) ) && name.equals( serviceInfo.getName( ) ) ) {\n            if ( Component.State.ENABLED.equals( config.lookupState( ) ) ) {\n              try {\n                c.disableTransition( config ).get( );\n                reply.getServices( ).add( serviceInfo );\n              } catch ( ExecutionException ex ) {\n                LOG.error( ex, ex );\n                return reply.markFailed( );\n              } catch ( InterruptedException ex ) {\n                LOG.error( ex, ex );\n                return reply.markFailed( );\n              }\n            } else {\n              LOG.error( \"Attempt to DISABLE a service which is not currently ENABLED: \" + config.toString( ) );\n              return reply.markFailed( );\n            }\n          }\n        }\n      } catch ( NoSuchElementException ex ) {\n        Exceptions.trace( \"Failed to lookup component of type: \" + serviceInfo.getType( ), ex );\n        return reply.markFailed( );\n      }\n    }\n    return reply;\n  }","id":28202,"modified_method":"public DisableServiceResponseType disableService( DisableServiceType request ) throws Throwable {\n    DisableServiceResponseType reply = request.getReply( );\n    for ( ServiceInfoType serviceInfo : request.getServices( ) ) {\n      try {\n        Component comp = Components.lookup( serviceInfo.getType( ) );\n        ServiceConfiguration service = comp.lookupServiceConfiguration( serviceInfo.getName( ) );\n        if ( service.isVmLocal( ) ) {\n          try {\n            comp.disableTransition( service ).get( );\n            reply.getServices( ).add( serviceInfo );\n          } catch ( IllegalStateException ex ) {\n            LOG.error( ex, ex );\n            throw ex;\n          } catch ( ExecutionException ex ) {\n            LOG.error( ex , ex );\n            throw ex.getCause( );\n          } catch ( InterruptedException ex ) {\n            LOG.error( ex , ex );\n            Thread.currentThread( ).interrupt( );\n            throw ex;\n          }\n        }\n      } catch ( NoSuchElementException ex ) {\n        LOG.error( ex, ex );\n        throw ex;\n      }\n    }\n    return reply;\n  }","commit_id":"e53538e80f86698894d556aeff8dc09492621850","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public StartServiceResponseType startService( StartServiceType request ) throws ServiceRegistrationException {\n    StartServiceResponseType reply = request.getReply( );\n    for ( ServiceInfoType serviceInfo : request.getServices( ) ) {\n      try {\n        Component comp = Components.lookup( serviceInfo.getType( ) );\n        ServiceConfiguration service = comp.lookupServiceConfiguration( serviceInfo.getName( ) );\n        if ( service.isVmLocal( ) ) {\n          try {\n            comp.startTransition( service );\n          } catch ( IllegalStateException ex ) {\n            LOG.error( ex, ex );\n            throw ex;\n          }\n        }\n      } catch ( NoSuchElementException ex ) {\n        LOG.error( ex, ex );\n        throw ex;\n      }\n    }\n    return reply;\n  }","id":28203,"modified_method":"public StartServiceResponseType startService( StartServiceType request ) throws Throwable {\n    StartServiceResponseType reply = request.getReply( );\n    for ( ServiceInfoType serviceInfo : request.getServices( ) ) {\n      try {\n        Component comp = Components.lookup( serviceInfo.getType( ) );\n        ServiceConfiguration service = comp.lookupServiceConfiguration( serviceInfo.getName( ) );\n        if ( service.isVmLocal( ) ) {\n          try {\n            comp.startTransition( service ).get( );\n            reply.getServices( ).add( serviceInfo );\n          } catch ( IllegalStateException ex ) {\n            LOG.error( ex, ex );\n            throw ex;\n          } catch ( ExecutionException ex ) {\n            LOG.error( ex , ex );\n            throw ex.getCause( );\n          } catch ( InterruptedException ex ) {\n            LOG.error( ex , ex );\n            Thread.currentThread( ).interrupt( );\n            throw ex;\n          }\n        }\n      } catch ( NoSuchElementException ex ) {\n        LOG.error( ex, ex );\n        throw ex;\n      }\n    }\n    return reply;\n  }","commit_id":"e53538e80f86698894d556aeff8dc09492621850","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ModifyServiceResponseType modifyService( ModifyServiceType request ) {\n    ModifyServiceResponseType reply = request.getReply( );\n    TransitionName transition = TransitionName.valueOf( request.getState( ).toUpperCase( ) );\n    for ( Component comp : Components.list( ) ) {\n      ServiceConfiguration a;\n      try {\n        a = comp.lookupServiceConfiguration( request.getName( ) );\n      } catch ( Exception ex1 ) {\n        continue;\n      }\n      Component.State serviceState = a.lookupState( );\n      reply.set_return( true );\n      try {\n        switch ( transition ) {\n          case DISABLE:\n            switch ( a.lookupState( ) ) {\n              case ENABLED:\n                comp.disableTransition( a ).get( );\n                break;\n              default:\n                return reply;\n            }\n            break;\n          case ENABLE:\n            switch ( a.lookupState( ) ) {\n              case INITIALIZED:\n              case PRIMORDIAL:\n              case BROKEN:\n              case LOADED:\n              case STOPPED:\n              case DISABLED:\n              case NOTREADY:\n                comp.enableTransition( a ).get( );\n                break;\n              case ENABLED:\n              default:\n                return reply;\n            }\n            break;\n          case STOP:\n            switch ( a.lookupState( ) ) {\n              case ENABLED:\n                comp.disableTransition( a ).get( );\n              case INITIALIZED:\n              case PRIMORDIAL:\n              case BROKEN:\n              case STOPPED:\n              case LOADED:\n              case DISABLED:\n              case NOTREADY:\n                comp.stopTransition( a ).get( );\n                break;\n              default:\n                return reply;\n            }\n            break;\n          case START:\n            switch ( a.lookupState( ) ) {\n              case INITIALIZED:\n              case PRIMORDIAL:\n              case BROKEN:\n              case STOPPED:\n              case LOADED:\n              case DISABLED:\n              case NOTREADY:\n                comp.startTransition( a ).get( );\n                break;\n              case ENABLED:\n              default:\n                return reply;\n            }\n            break;\n          case RESTART:\n            switch ( a.lookupState( ) ) {\n              case ENABLED:\n                comp.disableTransition( a ).get( );\n              case DISABLED:\n              case NOTREADY:\n                comp.stopTransition( a ).get( );\n              case INITIALIZED:\n              case PRIMORDIAL:\n              case BROKEN:\n              case LOADED:\n              default:\n                comp.startTransition( a ).get( );\n                break;\n            }\n            break;\n        }\n      } catch ( Exception ex ) {\n        LOG.error( ex, ex );\n        return reply.markFailed( );\n      }\n    }\n    return reply;\n  }","id":28204,"modified_method":"public ModifyServiceResponseType modifyService( ModifyServiceType request ) throws Exception {\n    ModifyServiceResponseType reply = request.getReply( );\n    TransitionName transition = TransitionName.valueOf( request.getState( ).toUpperCase( ) );\n    for ( Component comp : Components.list( ) ) {\n      ServiceConfiguration a;\n      try {\n        a = comp.lookupServiceConfiguration( request.getName( ) );\n      } catch ( Exception ex1 ) {\n        continue;\n      }\n      Component.State serviceState = a.lookupState( );\n      reply.set_return( true );\n      try {\n        switch ( transition ) {\n          case DISABLE:\n            switch ( a.lookupState( ) ) {\n              case ENABLED:\n                comp.disableTransition( a ).get( );\n                break;\n              default:\n                return reply;\n            }\n            break;\n          case ENABLE:\n            switch ( a.lookupState( ) ) {\n              case INITIALIZED:\n              case PRIMORDIAL:\n              case BROKEN:\n              case LOADED:\n              case STOPPED:\n              case DISABLED:\n              case NOTREADY:\n                comp.enableTransition( a ).get( );\n                break;\n              case ENABLED:\n              default:\n                return reply;\n            }\n            break;\n          case STOP:\n            switch ( a.lookupState( ) ) {\n              case ENABLED:\n                comp.disableTransition( a ).get( );\n              case INITIALIZED:\n              case PRIMORDIAL:\n              case BROKEN:\n              case STOPPED:\n              case LOADED:\n              case DISABLED:\n              case NOTREADY:\n                comp.stopTransition( a ).get( );\n                break;\n              default:\n                return reply;\n            }\n            break;\n          case START:\n            switch ( a.lookupState( ) ) {\n              case INITIALIZED:\n              case PRIMORDIAL:\n              case BROKEN:\n              case STOPPED:\n              case LOADED:\n              case DISABLED:\n              case NOTREADY:\n                comp.startTransition( a ).get( );\n                break;\n              case ENABLED:\n              default:\n                return reply;\n            }\n            break;\n          case RESTART:\n            switch ( a.lookupState( ) ) {\n              case ENABLED:\n                comp.disableTransition( a ).get( );\n              case DISABLED:\n              case NOTREADY:\n                comp.stopTransition( a ).get( );\n              case INITIALIZED:\n              case PRIMORDIAL:\n              case BROKEN:\n              case LOADED:\n              default:\n                comp.startTransition( a ).get( );\n                break;\n            }\n            break;\n        }\n      } catch ( Exception ex ) {\n        LOG.error( ex, ex );\n        throw ex;\n      }\n    }\n    return reply;\n  }","commit_id":"e53538e80f86698894d556aeff8dc09492621850","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static boolean testLocal( String address ) {\n    if( address == null ) return true;\n    InetAddress addr;\n    try {\n      addr = InetAddress.getByName( address );\n      return testLocal( addr );\n    } catch ( UnknownHostException e ) {\n      LOG.error( e.getMessage( ), e );\n      return false;\n    }\n  }","id":28205,"modified_method":"public static boolean testLocal( String address ) {\n    if( address == null ) return true;\n    InetAddress addr;\n    try {\n      addr = InetAddress.getByName( address );\n      return testLocal( addr );\n    } catch ( UnknownHostException e ) {\n      LOG.error( e.getMessage( ) );\n      return address.endsWith( \"Internal\" );\n    }\n  }","commit_id":"e53538e80f86698894d556aeff8dc09492621850","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * Builds a Service instance for this component using the provided service\n   * configuration.\n   * \n   * @return Service instance of the service\n   * @throws ServiceRegistrationException\n   */\n  public CheckedListenableFuture<Component> loadService( final ServiceConfiguration config ) throws ServiceRegistrationException {\n    Service service = new Service( this, config );\n    this.setupService( service );\n    if ( service.isLocal( ) ) { \n      if( State.INITIALIZED.equals( this.getState( ) ) ) {\n        try {\n          return this.stateMachine.transition( Transition.LOADING );\n        } catch ( Throwable ex ) {\n          throw new ServiceRegistrationException( \"Failed to load service: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else if( State.LOADED.equals( this.getState( ) ) ) {\n        return new TransitionFuture<Component>( this );\n      } else {\n        return new TransitionFuture<Component>( this );\n      }\n    } else {\n      return new TransitionFuture<Component>( this );\n      //TODO:GRZE:ASAP handle loadService\n    }\n  }","id":28206,"modified_method":"/**\n   * Builds a Service instance for this component using the provided service\n   * configuration.\n   * \n   * @return Service instance of the service\n   * @throws ServiceRegistrationException\n   */\n  public CheckedListenableFuture<Component> loadService( final ServiceConfiguration config ) throws ServiceRegistrationException {\n    Service service = new Service( this, config );\n    this.setupService( service );\n    if ( service.isLocal( ) ) { \n      if( State.INITIALIZED.equals( this.getState( ) ) ) {\n        try {\n          return this.stateMachine.transition( Transition.LOADING );\n        } catch ( Throwable ex ) {\n          throw new ServiceRegistrationException( \"Failed to load service: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else if( State.LOADED.equals( this.getState( ) ) ) {\n        return Futures.predestinedFuture( this )\n;\n      } else {\n        return Futures.predestinedFuture( this )\n;\n      }\n    } else {\n      return Futures.predestinedFuture( this )\n;\n      //TODO:GRZE:ASAP handle loadService\n    }\n  }","commit_id":"8fc5846bda66f0ca6e1173ff388a0c9c57e751f0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CheckedListenableFuture<Component> destroyService( final ServiceConfiguration config ) throws ServiceRegistrationException {\n    Service remove = this.lookupServiceByHost( config.getHostName( ) );\n    if ( remove == null ) {\n      throw new ServiceRegistrationException( \"Failed to find service corresponding to: \" + config );\n    } else {\n      Service service = this.services.remove( remove.getName( ) );\n      if ( config.isLocal( ) ) {\n        if ( State.STOPPED.ordinal( ) < this.stateMachine.getState( ).ordinal( ) ) {\n          this.stopService( config ); \n        }\n        this.localService.set( null );\n        try {\n          EventRecord.caller( Component.class, EventType.COMPONENT_SERVICE_DESTROY, this.getName( ), service.getName( ), service.getUri( ).toString( ) ).info( );\n          return this.stateMachine.transition( Transition.DESTROYING );\n        } catch ( Throwable ex ) {\n          throw new ServiceRegistrationException( \"Failed to destroy service: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else {\n        return new TransitionFuture<Component>( this );\n      }\n    }\n  }","id":28207,"modified_method":"public CheckedListenableFuture<Component> destroyService( final ServiceConfiguration config ) throws ServiceRegistrationException {\n    Service remove = this.lookupServiceByHost( config.getHostName( ) );\n    if ( remove == null ) {\n      throw new ServiceRegistrationException( \"Failed to find service corresponding to: \" + config );\n    } else {\n      Service service = this.services.remove( remove.getName( ) );\n      if ( config.isLocal( ) ) {\n        if ( State.STOPPED.ordinal( ) < this.stateMachine.getState( ).ordinal( ) ) {\n          this.stopService( config ); \n        }\n        this.localService.set( null );\n        try {\n          EventRecord.caller( Component.class, EventType.COMPONENT_SERVICE_DESTROY, this.getName( ), service.getName( ), service.getUri( ).toString( ) ).info( );\n          return this.stateMachine.transition( Transition.DESTROYING );\n        } catch ( Throwable ex ) {\n          throw new ServiceRegistrationException( \"Failed to destroy service: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else {\n        return Futures.predestinedFuture( this )\n;\n      }\n    }\n  }","commit_id":"8fc5846bda66f0ca6e1173ff388a0c9c57e751f0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CheckedListenableFuture<Component> startService( final ServiceConfiguration config ) throws ServiceRegistrationException {\n    EventRecord.caller( Component.class, EventType.COMPONENT_SERVICE_START, this.getName( ), config.getName( ), config.getUri( ).toString( ) ).info( );\n    if ( config.isLocal( ) ) {\n      this.stateMachine.setGoal( State.DISABLED );\n      if ( this.inState( State.LOADED ) ) {\n        try {\n          final CheckedListenableFuture<Component> future = new TransitionFuture<Component>( );\n          this.stateMachine.transition( Transition.STARTING ).addListener( new Runnable( ) {\n            @Override\n            public void run( ) {\n              try {\n                Component.this.stateMachine.transition( State.DISABLED );\n                future.set( Component.this );\n              } catch ( Throwable ex ) {\n                Exceptions.trace( new ServiceRegistrationException( \"Failed to mark service disabled: \" + config + \" because of: \" + ex.getMessage( ), ex ) );\n                future.setException( ex );\n              }\n            }\n          } );\n          return future;\n        } catch ( Throwable ex ) {\n          throw new ServiceRegistrationException( \"Failed to start service: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else if ( this.inState( State.NOTREADY ) ) {\n        try {\n          return this.stateMachine.transition( State.DISABLED );\n        } catch ( Throwable ex ) {\n          throw new ServiceRegistrationException( \"Failed to mark service disabled: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else {\n        return new TransitionFuture<Component>( this );\n      }\n    } else {\n      this.getBuilder( ).fireStart( config );\n      return new TransitionFuture<Component>( this );\n    }\n  }","id":28208,"modified_method":"public CheckedListenableFuture<Component> startService( final ServiceConfiguration config ) throws ServiceRegistrationException {\n    EventRecord.caller( Component.class, EventType.COMPONENT_SERVICE_START, this.getName( ), config.getName( ), config.getUri( ).toString( ) ).info( );\n    if ( config.isLocal( ) ) {\n      this.stateMachine.setGoal( State.DISABLED );\n      if ( this.inState( State.LOADED ) ) {\n        try {\n          final CheckedListenableFuture<Component> future = new TransitionFuture<Component>( );\n          this.stateMachine.transition( Transition.STARTING ).addListener( new Runnable( ) {\n            @Override\n            public void run( ) {\n              try {\n                Component.this.stateMachine.transition( State.DISABLED );\n                future.set( Component.this );\n              } catch ( Throwable ex ) {\n                Exceptions.trace( new ServiceRegistrationException( \"Failed to mark service disabled: \" + config + \" because of: \" + ex.getMessage( ), ex ) );\n                future.setException( ex );\n              }\n            }\n          } );\n          return future;\n        } catch ( Throwable ex ) {\n          throw new ServiceRegistrationException( \"Failed to start service: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else if ( this.inState( State.NOTREADY ) ) {\n        try {\n          return this.stateMachine.transition( State.DISABLED );\n        } catch ( Throwable ex ) {\n          throw new ServiceRegistrationException( \"Failed to mark service disabled: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else {\n        return Futures.predestinedFuture( this )\n;\n      }\n    } else {\n      this.getBuilder( ).fireStart( config );\n      return Futures.predestinedFuture( this )\n;\n    }\n  }","commit_id":"8fc5846bda66f0ca6e1173ff388a0c9c57e751f0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CheckedListenableFuture<Component> stopService( final ServiceConfiguration config ) throws ServiceRegistrationException {\n    EventRecord.caller( Component.class, EventType.COMPONENT_SERVICE_STOPPED, this.getName( ), config.getName( ), config.getUri( ).toString( ) ).info( );\n    if ( config.isLocal( ) ) {\n      if ( State.ENABLED.equals( this.stateMachine.getState( ) ) ) {\n        try {\n          final CheckedListenableFuture<Component> future = new TransitionFuture<Component>( );\n          this.stateMachine.transition( State.DISABLED ).addListener( new Runnable( ) {\n            @Override\n            public void run( ) {\n              try {\n                DispatcherFactory.remove( Component.this.services.get( config ) );\n                Component.this.stateMachine.transition( State.STOPPED );\n                future.set( Component.this );\n              } catch ( Throwable ex ) {\n                Exceptions.trace( new ServiceRegistrationException( \"Failed to stop service: \" + config + \" because of: \" + ex.getMessage( ), ex ) );\n                future.setException( ex );\n              }\n            }\n          }, Threads.currentThreadExecutor( ) );\n          return future;\n        } catch ( Throwable ex ) {\n          throw new ServiceRegistrationException( \"Failed to disable service: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else if ( State.DISABLED.equals( this.stateMachine.getState( ) ) || State.NOTREADY.equals( this.stateMachine.getState( ) ) ) {\n        try {\n          DispatcherFactory.remove( Component.this.services.get( config ) );\n          return Component.this.stateMachine.transition( State.STOPPED );\n        } catch ( Throwable ex ) {\n          throw new ServiceRegistrationException( \"Failed to stop service: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else {\n        return new TransitionFuture<Component>( this );\n      }\n    } else {\n      this.getBuilder( ).fireStop( config );\n      return new TransitionFuture<Component>( this );\n    }\n  }","id":28209,"modified_method":"public CheckedListenableFuture<Component> stopService( final ServiceConfiguration config ) throws ServiceRegistrationException {\n    EventRecord.caller( Component.class, EventType.COMPONENT_SERVICE_STOPPED, this.getName( ), config.getName( ), config.getUri( ).toString( ) ).info( );\n    if ( config.isLocal( ) ) {\n      if ( State.ENABLED.equals( this.stateMachine.getState( ) ) ) {\n        try {\n          final CheckedListenableFuture<Component> future = new TransitionFuture<Component>( );\n          this.stateMachine.transition( State.DISABLED ).addListener( new Runnable( ) {\n            @Override\n            public void run( ) {\n              try {\n                DispatcherFactory.remove( Component.this.services.get( config ) );\n                Component.this.stateMachine.transition( State.STOPPED );\n                future.set( Component.this );\n              } catch ( Throwable ex ) {\n                Exceptions.trace( new ServiceRegistrationException( \"Failed to stop service: \" + config + \" because of: \" + ex.getMessage( ), ex ) );\n                future.setException( ex );\n              }\n            }\n          }, Threads.currentThreadExecutor( ) );\n          return future;\n        } catch ( Throwable ex ) {\n          throw new ServiceRegistrationException( \"Failed to disable service: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else if ( State.DISABLED.equals( this.stateMachine.getState( ) ) || State.NOTREADY.equals( this.stateMachine.getState( ) ) ) {\n        try {\n          DispatcherFactory.remove( Component.this.services.get( config ) );\n          return Component.this.stateMachine.transition( State.STOPPED );\n        } catch ( Throwable ex ) {\n          throw new ServiceRegistrationException( \"Failed to stop service: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else {\n        return Futures.predestinedFuture( this )\n;\n      }\n    } else {\n      this.getBuilder( ).fireStop( config );\n      return Futures.predestinedFuture( this )\n;\n    }\n  }","commit_id":"8fc5846bda66f0ca6e1173ff388a0c9c57e751f0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private Runnable getCheckRunner( ) {\n    return new Runnable( ) {\n      @Override\n      public void run( ) {\n        if ( !Component.this.stateMachine.isBusy( ) ) {\n          try {\n            Component.this.runChecks( );\n          } catch ( Throwable ex ) {\n            LOG.debug( \"CheckRunner caught an exception: \" + ex );\n          }\n        }\n      }\n    };\n  }","id":28210,"modified_method":"private Runnable getCheckRunner( ) {\n    return new Runnable( ) {\n      @Override\n      public void run( ) {\n        try {\n          if ( Component.this.isAvailableLocally( ) && Component.this.getState( ).ordinal( ) > State.STOPPED.ordinal( ) ) {\n            Component.this.stateMachine.transitionSelf( );\n          }\n        } catch ( Throwable ex ) {\n          LOG.debug( \"CheckRunner caught an exception: \" + ex );\n        }\n      }\n    };\n  }","commit_id":"8fc5846bda66f0ca6e1173ff388a0c9c57e751f0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n    public void fireEvent( Event event ) {\n      if ( event instanceof Hertz ) {\n        for ( final Component c : Components.list( ) ) {\n          if ( Component.State.STOPPED.ordinal( ) < c.getState( ).ordinal( ) && c.isAvailableLocally( ) ) {\n            if( Component.State.ENABLED.equals( c.stateMachine.getGoal( ) ) && Component.State.NOTREADY.equals( c.getState( ) ) ) {\n              Threads.lookup( Empyrean.class.getName( ) ).submit( c.getCheckRunner( ) );\n            } else if( Component.State.ENABLED.equals( c.stateMachine.getGoal( ) ) && Component.State.DISABLED.equals( c.getState( ) ) ) {\n              try {\n                c.enableService( c.getLocalService( ).getServiceConfiguration( ) );\n              } catch ( ServiceRegistrationException ex ) {\n                LOG.error( ex );\n              }\n            }//more checks here soon.\n          }\n        }\n      }\n    }","id":28211,"modified_method":"@Override\n    public void fireEvent( Event event ) {\n      if ( event instanceof Hertz ) {\n        for ( final Component c : Components.list( ) ) {\n          if ( Component.State.STOPPED.ordinal( ) < c.getState( ).ordinal( ) && c.isAvailableLocally( ) ) {\n            if( !c.stateMachine.isBusy( ) && Component.State.ENABLED.equals( c.stateMachine.getGoal( ) ) && Component.State.NOTREADY.equals( c.getState( ) ) ) {\n              Threads.lookup( Empyrean.class.getName( ) ).submit( c.getCheckRunner( ) );\n            } else if( Component.State.ENABLED.equals( c.stateMachine.getGoal( ) ) && Component.State.DISABLED.equals( c.getState( ) ) ) {\n              c.enableTransition( c.getLocalService( ).getServiceConfiguration( ) );\n            }\n          }\n        }\n      }\n    }","commit_id":"8fc5846bda66f0ca6e1173ff388a0c9c57e751f0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CheckedListenableFuture<Component> enableService( final ServiceConfiguration config ) throws ServiceRegistrationException {\n    EventRecord.caller( Component.class, EventType.COMPONENT_SERVICE_ENABLED, this.getName( ), config.getName( ), config.getUri( ).toString( ) ).info( );\n    if ( config.isLocal( ) ) {\n      this.stateMachine.setGoal( State.ENABLED );\n      if ( State.NOTREADY.equals( this.stateMachine.getState( ) ) ) {\n        try {\n          final CheckedListenableFuture<Component> future = new TransitionFuture<Component>( );\n          return this.stateMachine.transition( Transition.READY_CHECK ).addListener( new Callable<Component>( ) {\n            @Override\n            public Component call( ) {\n              try {\n                Component.this.stateMachine.transition( State.ENABLED );\n              } catch ( Throwable ex ) {\n                Exceptions.trace( new ServiceRegistrationException( \"Failed to mark service enabled: \" + config + \" because of: \" + ex.getMessage( ), ex ) );\n              }\n              return Component.this;\n            }\n          } );\n        } catch ( Throwable ex ) {\n          throw new ServiceRegistrationException( \"Failed to perform ready-check for service: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else if ( State.DISABLED.equals( this.stateMachine.getState( ) ) ) {\n        try {\n          return Component.this.stateMachine.transition( State.ENABLED );\n        } catch ( Throwable ex ) {\n          throw  new ServiceRegistrationException( \"Failed to mark service enabled: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else {\n        return new TransitionFuture<Component>( this );\n      }\n    } else {\n      this.getBuilder( ).fireEnable( config );\n      return new TransitionFuture<Component>( this );\n    }\n  }","id":28212,"modified_method":"public CheckedListenableFuture<Component> enableService( final ServiceConfiguration config ) throws ServiceRegistrationException {\n    EventRecord.caller( Component.class, EventType.COMPONENT_SERVICE_ENABLED, this.getName( ), config.getName( ), config.getUri( ).toString( ) ).info( );\n    if ( config.isLocal( ) ) {\n      this.stateMachine.setGoal( State.ENABLED );\n      if ( State.NOTREADY.equals( this.stateMachine.getState( ) ) ) {\n        try {\n          final CheckedListenableFuture<Component> future = new TransitionFuture<Component>( );\n          return this.stateMachine.transition( Transition.READY_CHECK ).addListener( new Callable<Component>( ) {\n            @Override\n            public Component call( ) {\n              try {\n                Component.this.stateMachine.transition( State.ENABLED );\n              } catch ( Throwable ex ) {\n                Exceptions.trace( new ServiceRegistrationException( \"Failed to mark service enabled: \" + config + \" because of: \" + ex.getMessage( ), ex ) );\n              }\n              return Component.this;\n            }\n          } );\n        } catch ( Throwable ex ) {\n          throw new ServiceRegistrationException( \"Failed to perform ready-check for service: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else if ( State.DISABLED.equals( this.stateMachine.getState( ) ) ) {\n        try {\n          return Component.this.stateMachine.transition( State.ENABLED );\n        } catch ( Throwable ex ) {\n          throw  new ServiceRegistrationException( \"Failed to mark service enabled: \" + config + \" because of: \" + ex.getMessage( ), ex );\n        }\n      } else {\n        return Futures.predestinedFuture( this );\n      }\n    } else {\n      this.getBuilder( ).fireEnable( config );\n      return Futures.predestinedFuture( this );\n    }\n  }","commit_id":"8fc5846bda66f0ca6e1173ff388a0c9c57e751f0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CheckedListenableFuture<Component> disableService( ServiceConfiguration config ) throws ServiceRegistrationException {\n    EventRecord.caller( Component.class, EventType.COMPONENT_SERVICE_DISABLED, this.getName( ), config.getName( ), config.getUri( ).toString( ) ).info( );\n    if ( config.isLocal( ) ) {\n      try {\n        return this.stateMachine.transition( State.DISABLED );\n      } catch ( Throwable ex ) {\n        throw new ServiceRegistrationException( \"Failed to disable service: \" + config + \" because of: \" + ex.getMessage( ), ex );\n      }\n    } else {\n      this.getBuilder( ).fireDisable( config );\n      return new TransitionFuture<Component>( this );\n    }\n  }","id":28213,"modified_method":"public CheckedListenableFuture<Component> disableService( ServiceConfiguration config ) throws ServiceRegistrationException {\n    EventRecord.caller( Component.class, EventType.COMPONENT_SERVICE_DISABLED, this.getName( ), config.getName( ), config.getUri( ).toString( ) ).info( );\n    if ( config.isLocal( ) ) {\n      try {\n        return this.stateMachine.transition( State.DISABLED );\n      } catch ( Throwable ex ) {\n        throw new ServiceRegistrationException( \"Failed to disable service: \" + config + \" because of: \" + ex.getMessage( ), ex );\n      }\n    } else {\n      this.getBuilder( ).fireDisable( config );\n      return Futures.predestinedFuture( this )\n;\n    }\n  }","commit_id":"8fc5846bda66f0ca6e1173ff388a0c9c57e751f0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static boolean register( final Component component, String partition, String name, String hostName, Integer port ) throws ServiceRegistrationException {\n    final ServiceBuilder builder = component.getBuilder( );\n    LOG.info( \"Using builder: \" + builder.getClass( ).getSimpleName( ) + \" for: \" + name + \"@\" + hostName + \":\" + port );\n    if ( !builder.checkAdd( null, name, hostName, port ) ) {\n      LOG.info( builder.getClass( ).getSimpleName( ) + \": checkAdd failed.\" );\n      return false;\n    }\n    try {\n      final ServiceConfiguration newComponent = builder.add( partition, name, hostName, port );\n      try {\n        component.enableTransition( newComponent ); \n      } catch ( Exception ex ) {\n        LOG.error( ex, ex );\n      }\n      return true;\n    } catch ( Throwable e ) {\n      LOG.info( builder.getClass( ).getSimpleName( ) + \": add failed.\" );\n      LOG.info( e.getMessage( ) );\n      LOG.error( e, e );\n      throw new ServiceRegistrationException( builder.getClass( ).getSimpleName( ) + \": add failed with message: \" + e.getMessage( ), e );\n    }\n  }","id":28214,"modified_method":"public static boolean register( final Component component, String partition, String name, String hostName, Integer port ) throws ServiceRegistrationException {\n    final ServiceBuilder builder = component.getBuilder( );\n    partition = (partition != null ? partition : name);\n    LOG.info( \"Using builder: \" + builder.getClass( ).getSimpleName( ) + \" for: \" + partition + \".\" + name + \"@\" + hostName + \":\" + port );\n    if ( !builder.checkAdd( partition, name, hostName, port ) ) {\n      LOG.info( builder.getClass( ).getSimpleName( ) + \": checkAdd failed.\" );\n      return false;\n    }\n    try {\n      final ServiceConfiguration newComponent = builder.add( partition, name, hostName, port );\n      try {\n        component.enableTransition( newComponent ).get( ); \n      } catch ( Throwable ex ) {\n        LOG.error( ex, ex );\n      }\n      return true;\n    } catch ( Throwable e ) {\n      LOG.info( builder.getClass( ).getSimpleName( ) + \": add failed.\" );\n      LOG.info( e.getMessage( ) );\n      LOG.error( e, e );\n      throw new ServiceRegistrationException( builder.getClass( ).getSimpleName( ) + \": add failed with message: \" + e.getMessage( ), e );\n    }\n  }","commit_id":"8fc5846bda66f0ca6e1173ff388a0c9c57e751f0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void transitionSelf( ) {\n    try {\n      if( State.NOTREADY.equals( this.getState( ) ) ) {//this is a special case of a transition which does not return to itself on a successful check\n        this.transition( State.DISABLED );\n      } else { \n        this.transition( this.getState( ) );\n      }\n    } catch ( IllegalStateException ex ) {\n      LOG.error( Exceptions.filterStackTrace( ex ) );\n    } catch ( NoSuchElementException ex ) {\n      LOG.error( Exceptions.filterStackTrace( ex ) );\n    } catch ( ExistingTransitionException ex ) {\n      LOG.error( Exceptions.filterStackTrace( ex ) );\n    }\n  }","id":28215,"modified_method":"public CheckedListenableFuture<Component> transitionSelf( ) {\n    try {\n      if( this.checkTransition( Transition.READY_CHECK ) ) {//this is a special case of a transition which does not return to itself on a successful check\n        return this.transition( Transition.READY_CHECK );\n      } else { \n        return this.transition( this.getState( ) );\n      }\n    } catch ( IllegalStateException ex ) {\n      LOG.error( Exceptions.filterStackTrace( ex ) );\n    } catch ( NoSuchElementException ex ) {\n      LOG.error( Exceptions.filterStackTrace( ex ) );\n    } catch ( ExistingTransitionException ex ) {\n      LOG.error( Exceptions.filterStackTrace( ex ) );\n    }\n    return Futures.predestinedFuture( this.parent );\n  }","commit_id":"8fc5846bda66f0ca6e1173ff388a0c9c57e751f0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public final void fireEvent( Event event ) {\n    if ( event instanceof LifecycleEvent ) {\n      super.fireLifecycleEvent( event );\n    } else if ( event instanceof Hertz ) {\n      ServiceConfiguration config = this.getServiceConfiguration( );\n      if ( Component.State.STOPPED.ordinal( ) < config.lookupState( ).ordinal( ) ) {\n        try {\n          Threads.lookup( Empyrean.class ).submit( new Runnable( ) {\n            @Override\n            public void run( ) {\n              try {\n                if ( BasicService.this.stateMachine.getState( ).ordinal( ) > State.STOPPED.ordinal( ) ) {\n                  BasicService.this.stateMachine.transition( BasicService.this.stateMachine.getState( ) );\n                }\n              } catch ( Throwable ex ) {\n                LOG.debug( \"CheckRunner caught an exception: \" + ex );\n              }\n            }\n          } ).get( );\n        } catch ( InterruptedException ex ) {\n          config.error( ex );\n          config.lookupService( ).setGoal( Component.State.DISABLED );\n        } catch ( ExecutionException ex ) {\n          config.error( ex.getCause( ) );\n          config.lookupService( ).setGoal( Component.State.DISABLED );\n        }\n        if ( Component.State.ENABLED.equals( config.lookupService( ).getGoal( ) ) && Component.State.DISABLED.isIn( config ) ) {\n          config.lookupComponent( ).enableTransition( config );\n        } else if ( Component.State.DISABLED.equals( config.lookupService( ).getGoal( ) ) && Component.State.ENABLED.isIn( config ) ) {\n          config.lookupComponent( ).disableTransition( config );\n        }\n      }\n    }\n  }","id":28216,"modified_method":"@Override\n  public final void fireEvent( Event event ) {\n    if ( event instanceof LifecycleEvent ) {\n      super.fireLifecycleEvent( event );\n    } else if ( event instanceof Hertz && Bootstrap.isFinished( ) ) {\n      ServiceConfiguration config = this.getServiceConfiguration( );\n      if ( Component.State.STOPPED.ordinal( ) < config.lookupState( ).ordinal( ) ) {\n        try {\n          Threads.lookup( Empyrean.class ).submit( new Runnable( ) {\n            @Override\n            public void run( ) {\n              try {\n                if ( BasicService.this.stateMachine.getState( ).ordinal( ) > State.STOPPED.ordinal( ) ) {\n                  BasicService.this.stateMachine.transition( BasicService.this.stateMachine.getState( ) );\n                }\n              } catch ( Throwable ex ) {\n                LOG.debug( \"CheckRunner caught an exception: \" + ex );\n              }\n            }\n          } ).get( );\n        } catch ( InterruptedException ex ) {\n          config.error( ex );\n          config.lookupService( ).setGoal( Component.State.DISABLED );\n        } catch ( ExecutionException ex ) {\n          config.error( ex.getCause( ) );\n          config.lookupService( ).setGoal( Component.State.DISABLED );\n        }\n        if ( Component.State.ENABLED.equals( config.lookupService( ).getGoal( ) ) && Component.State.DISABLED.isIn( config ) ) {\n          config.lookupComponent( ).enableTransition( config );\n        } else if ( Component.State.DISABLED.equals( config.lookupService( ).getGoal( ) ) && Component.State.ENABLED.isIn( config ) ) {\n          config.lookupComponent( ).disableTransition( config );\n        }\n      }\n    }\n  }","commit_id":"b7b1749cd3e13294aedb9cc156e131e7687d3af0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static boolean register( final Component component, String part, String name, String hostName, Integer port ) throws ServiceRegistrationException {\n    final ServiceBuilder builder = component.getBuilder( );\n    String partition = part;\n\n    if( !component.getComponentId( ).isPartitioned( ) ) {\n      partition = name;\n    } else if( component.getComponentId( ).isCloudLocal( ) ) {\n      partition = Components.lookup( Eucalyptus.class ).getComponentId( ).name( );\n    } else if( partition == null ) {\n      LOG.error( \"BUG: Provided partition is null.  Using the service name as the partition name for the time being.\" );\n      partition = name;\n    }\n\n    LOG.info( \"Using builder: \" + builder.getClass( ).getSimpleName( ) + \" for: \" + partition + \".\" + name + \"@\" + hostName + \":\" + port );\n    if ( !builder.checkAdd( partition, name, hostName, port ) ) {\n      LOG.info( builder.getClass( ).getSimpleName( ) + \": checkAdd failed.\" );\n      return false;\n    }\n\n    try {\n      final ServiceConfiguration newComponent = builder.add( partition, name, hostName, port );\n      try {\n        component.enableTransition( newComponent ); \n      } catch ( Throwable ex ) {\n        builder.remove( newComponent );\n        LOG.info( builder.getClass( ).getSimpleName( ) + \": enable failed because of: \" + ex.getMessage( ) );\n        throw Exceptions.filterStackTrace( ex );\n      }\n      return true;\n    } catch ( Throwable e ) {\n      e = Exceptions.filterStackTrace( e );\n      LOG.info( builder.getClass( ).getSimpleName( ) + \": add failed because of: \" + e.getMessage( ) );\n      LOG.error( e, e );\n      throw new ServiceRegistrationException( builder.getClass( ).getSimpleName( ) + \": add failed with message: \" + e.getMessage( ), e );\n    }\n  }","id":28217,"modified_method":"public static boolean register( final Component component, String part, String name, String hostName, Integer port ) throws ServiceRegistrationException {\n    final ServiceBuilder builder = component.getBuilder( );\n    String partition = part;\n\n    if( !component.getComponentId( ).isPartitioned( ) ) {\n      partition = name;\n    } else if( component.getComponentId( ).isCloudLocal( ) ) {\n      partition = Components.lookup( Eucalyptus.class ).getComponentId( ).name( );\n    } else if( partition == null ) {\n      LOG.error( \"BUG: Provided partition is null.  Using the service name as the partition name for the time being.\" );\n      partition = name;\n    }\n\n    LOG.info( \"Using builder: \" + builder.getClass( ).getSimpleName( ) + \" for: \" + partition + \".\" + name + \"@\" + hostName + \":\" + port );\n    if ( !builder.checkAdd( partition, name, hostName, port ) ) {\n      LOG.info( builder.getClass( ).getSimpleName( ) + \": checkAdd failed.\" );\n      return false;\n    }\n\n    try {\n      final ServiceConfiguration newComponent = builder.add( partition, name, hostName, port );\n      try {\n        component.startTransition( newComponent ).get( ); \n        component.enableTransition( newComponent ).get( ); \n      } catch ( Throwable ex ) {\n        builder.remove( newComponent );\n        LOG.info( builder.getClass( ).getSimpleName( ) + \": enable failed because of: \" + ex.getMessage( ) );\n        throw Exceptions.filterStackTrace( ex );\n      }\n      return true;\n    } catch ( Throwable e ) {\n      e = Exceptions.filterStackTrace( e );\n      LOG.info( builder.getClass( ).getSimpleName( ) + \": add failed because of: \" + e.getMessage( ) );\n      LOG.error( e, e );\n      throw new ServiceRegistrationException( builder.getClass( ).getSimpleName( ) + \": add failed with message: \" + e.getMessage( ), e );\n    }\n  }","commit_id":"b7b1749cd3e13294aedb9cc156e131e7687d3af0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"static final CheckedListenableFuture<ServiceConfiguration> enableTransitionChain( final ServiceConfiguration config ) {\n    if ( !State.ENABLED.equals( config.lookupState( ) ) ) {\n      CheckedListenableFuture<ServiceConfiguration> transitionResult = null;\n      try {\n        Callable<CheckedListenableFuture<ServiceConfiguration>> transition = Automata.sequenceTransitions( config, Component.State.DISABLED, Component.State.ENABLED );\n        Future<CheckedListenableFuture<ServiceConfiguration>> result = Threads.lookup( Empyrean.class ).submit( transition );\n        transitionResult = result.get( );\n      } catch ( InterruptedException ex ) {\n        LOG.error( ex, ex );\n        transitionResult = Futures.predestinedFailedFuture( ex );\n      } catch ( ExecutionException ex ) {\n        LOG.error( ex.getCause( ), ex.getCause( ) );\n        transitionResult = Futures.predestinedFailedFuture( ex.getCause( ) );\n      }\n      return transitionResult;\n    } else {\n      return Futures.predestinedFuture( config );\n    }\n  }","id":28218,"modified_method":"static final CheckedListenableFuture<ServiceConfiguration> enableTransitionChain( final ServiceConfiguration config ) {\n    if ( !State.ENABLED.equals( config.lookupState( ) ) ) {\n      CheckedListenableFuture<ServiceConfiguration> transitionResult = null;\n      try {\n        Callable<CheckedListenableFuture<ServiceConfiguration>> transition = Automata.sequenceTransitions( config, Component.State.INITIALIZED,\n                                                                                                           Component.State.LOADED,\n                                                                                                           Component.State.NOTREADY, Component.State.DISABLED,\n                                                                                                           Component.State.DISABLED, Component.State.ENABLED );\n        Future<CheckedListenableFuture<ServiceConfiguration>> result = Threads.lookup( Empyrean.class ).submit( transition );\n        transitionResult = result.get( );\n      } catch ( InterruptedException ex ) {\n        LOG.error( ex, ex );\n        transitionResult = Futures.predestinedFailedFuture( ex );\n      } catch ( ExecutionException ex ) {\n        LOG.error( ex.getCause( ), ex.getCause( ) );\n        transitionResult = Futures.predestinedFailedFuture( ex.getCause( ) );\n      }\n      return transitionResult;\n    } else {\n      return Futures.predestinedFuture( config );\n    }\n  }","commit_id":"b7b1749cd3e13294aedb9cc156e131e7687d3af0","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@NotNull\n  final AttributeChildInvocationHandler getAttributeChild(final AttributeChildDescriptionImpl description) {\n    checkIsValid();\n    final EvaluatedXmlName evaluatedXmlName = createEvaluatedXmlName(description.getXmlName());\n    final XmlTag tag = getXmlTag();\n    \n    if (tag != null) {\n      // TODO: this seems ugly\n      String ns = evaluatedXmlName.getNamespace(tag, getFile());\n      final XmlAttribute attribute = tag.getAttribute(description.getXmlName().getLocalName(), ns.equals(tag.getNamespace())? null:ns);\n      \n      if (attribute != null) {\n        final AttributeChildInvocationHandler semElement =\n          myManager.getSemService().getSemElement(DomManagerImpl.DOM_ATTRIBUTE_HANDLER_KEY, attribute);\n        if (semElement == null) {\n          myManager.getSemService().getSemElement(DomManagerImpl.DOM_ATTRIBUTE_HANDLER_KEY, attribute);\n        }\n        return semElement;\n      }\n    }\n    return new AttributeChildInvocationHandler(evaluatedXmlName, description, myManager, new VirtualDomParentStrategy(this));\n  }","id":28219,"modified_method":"@NotNull\n  final AttributeChildInvocationHandler getAttributeChild(final AttributeChildDescriptionImpl description) {\n    checkIsValid();\n    final EvaluatedXmlName evaluatedXmlName = createEvaluatedXmlName(description.getXmlName());\n    final XmlTag tag = getXmlTag();\n    \n    if (tag != null) {\n      // TODO: this seems ugly\n      String ns = evaluatedXmlName.getNamespace(tag, getFile());\n      final XmlAttribute attribute = tag.getAttribute(description.getXmlName().getLocalName(), ns.equals(tag.getNamespace())? null:ns);\n      \n      if (attribute != null) {\n        return myManager.getSemService().getSemElement(DomManagerImpl.DOM_ATTRIBUTE_HANDLER_KEY, attribute);\n      }\n    }\n    return new AttributeChildInvocationHandler(evaluatedXmlName, description, myManager, new VirtualDomParentStrategy(this));\n  }","commit_id":"ace443f67ade6066399ed3f813121ca7c00bf868","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  final IndexedElementInvocationHandler getFixedChild(final Pair<FixedChildDescriptionImpl, Integer> info) {\n    final FixedChildDescriptionImpl description = info.first;\n    final EvaluatedXmlName evaluatedXmlName = createEvaluatedXmlName(description.getXmlName());\n    final XmlTag tag = getXmlTag();\n    final int index = info.second;\n    if (tag != null) {\n      if (!tag.isValid()) {\n        throw new PsiInvalidElementAccessException(tag);\n      }\n      final XmlTag[] subTags = tag.getSubTags();\n      for (int i = 0, subTagsLength = subTags.length; i < subTagsLength; i++) {\n        XmlTag xmlTag = subTags[i];\n        if (!xmlTag.isValid()) {\n          throw new PsiInvalidElementAccessException(xmlTag,\n                                                     \"invalid children of valid tag: \" + tag.getText() + \"; subtag=\" + xmlTag + \"; index=\" + i);\n        }\n      }\n      final List<XmlTag> tags = DomImplUtil.findSubTags(subTags, evaluatedXmlName, getFile());\n      if (tags.size() > index) {\n        return myManager.getSemService().getSemElement(DomManagerImpl.DOM_INDEXED_HANDLER_KEY, tags.get(index));\n      }\n    }\n    return new IndexedElementInvocationHandler(evaluatedXmlName, description, index, new VirtualDomParentStrategy(this), myManager, \"\");\n  }","id":28220,"modified_method":"@NotNull\n  final IndexedElementInvocationHandler getFixedChild(final Pair<FixedChildDescriptionImpl, Integer> info) {\n    final FixedChildDescriptionImpl description = info.first;\n    final EvaluatedXmlName evaluatedXmlName = createEvaluatedXmlName(description.getXmlName());\n    final XmlTag tag = getXmlTag();\n    final int index = info.second;\n    if (tag != null) {\n      if (!tag.isValid()) {\n        throw new PsiInvalidElementAccessException(tag);\n      }\n      final XmlTag[] subTags = tag.getSubTags();\n      for (int i = 0, subTagsLength = subTags.length; i < subTagsLength; i++) {\n        XmlTag xmlTag = subTags[i];\n        if (!xmlTag.isValid()) {\n          throw new PsiInvalidElementAccessException(xmlTag,\n                                                     \"invalid children of valid tag: \" + tag.getText() + \"; subtag=\" + xmlTag + \"; index=\" + i);\n        }\n      }\n      final List<XmlTag> tags = DomImplUtil.findSubTags(subTags, evaluatedXmlName, getFile());\n      if (tags.size() > index) {\n        final XmlTag child = tags.get(index);\n        final IndexedElementInvocationHandler semElement = myManager.getSemService().getSemElement(DomManagerImpl.DOM_INDEXED_HANDLER_KEY, child);\n        if (semElement == null) {\n          final IndexedElementInvocationHandler take2 = myManager.getSemService().getSemElement(DomManagerImpl.DOM_INDEXED_HANDLER_KEY, child);\n          throw new AssertionError(\"No DOM at XML. Parent=\" + tag + \"; child=\" + child + \"; index=\" + index+ \"; second attempt=\" + take2);\n\n        }\n        return semElement;\n      }\n    }\n    return new IndexedElementInvocationHandler(evaluatedXmlName, description, index, new VirtualDomParentStrategy(this), myManager, \"\");\n  }","commit_id":"95be9bd14e469a2cde38cedf27fcfc248b4e09dd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  final AttributeChildInvocationHandler getAttributeChild(final AttributeChildDescriptionImpl description) {\n    final EvaluatedXmlName evaluatedXmlName = createEvaluatedXmlName(description.getXmlName());\n    if (myStub != null && description.isStubbed()) {\n      AttributeStub stub = myStub.getAttributeStub(description.getXmlName());\n      StubParentStrategy strategy = StubParentStrategy.createAttributeStrategy(stub, myStub);\n      return new AttributeChildInvocationHandler(evaluatedXmlName, description, myManager, strategy, stub);\n    }\n    final XmlTag tag = getXmlTag();\n    \n    if (tag != null) {\n      // TODO: this seems ugly\n      String ns = evaluatedXmlName.getNamespace(tag, getFile());\n      final XmlAttribute attribute = tag.getAttribute(description.getXmlName().getLocalName(), ns.equals(tag.getNamespace())? null:ns);\n      \n      if (attribute != null) {\n        LOG.assertTrue(attribute.isValid());\n        return myManager.getSemService().getSemElement(DomManagerImpl.DOM_ATTRIBUTE_HANDLER_KEY, attribute);\n      }\n    }\n    return new AttributeChildInvocationHandler(evaluatedXmlName, description, myManager, new VirtualDomParentStrategy(this), null);\n  }","id":28221,"modified_method":"@NotNull\n  final AttributeChildInvocationHandler getAttributeChild(final AttributeChildDescriptionImpl description) {\n    final EvaluatedXmlName evaluatedXmlName = createEvaluatedXmlName(description.getXmlName());\n    if (myStub != null && description.isStubbed()) {\n      AttributeStub stub = myStub.getAttributeStub(description.getXmlName());\n      StubParentStrategy strategy = StubParentStrategy.createAttributeStrategy(stub, myStub);\n      return new AttributeChildInvocationHandler(evaluatedXmlName, description, myManager, strategy, stub);\n    }\n    final XmlTag tag = getXmlTag();\n    \n    if (tag != null) {\n      // TODO: this seems ugly\n      String ns = evaluatedXmlName.getNamespace(tag, getFile());\n      final XmlAttribute attribute = tag.getAttribute(description.getXmlName().getLocalName(), ns.equals(tag.getNamespace())? null:ns);\n      \n      if (attribute != null) {\n        PsiUtilCore.ensureValid(attribute);\n        AttributeChildInvocationHandler semElement =\n          myManager.getSemService().getSemElement(DomManagerImpl.DOM_ATTRIBUTE_HANDLER_KEY, attribute);\n        if (semElement == null) {\n          final AttributeChildInvocationHandler take2 = myManager.getSemService().getSemElement(DomManagerImpl.DOM_ATTRIBUTE_HANDLER_KEY, attribute);\n          throw new AssertionError(\"No DOM at XML. Parent=\" + tag + \"; attribute=\" + attribute + \"; second attempt=\" + take2);\n        }\n        return semElement;\n      }\n    }\n    return new AttributeChildInvocationHandler(evaluatedXmlName, description, myManager, new VirtualDomParentStrategy(this), null);\n  }","commit_id":"402901981283ae95c2455d35b6c70cc10441399c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public Result calculateResult(@NotNull Expression[] params, ExpressionContext context) {\n        AnonymousTemplateEditingListener.registerListener(context.getEditor(), context.getProject());\n\n        PsiNamedElement[] vars = getSupertypes(params, context);\n        if (vars == null || vars.length == 0) return null;\n        return new JetPsiElementResult(vars[0]);\n    }","id":28222,"modified_method":"@Override\n    public Result calculateResult(@NotNull Expression[] params, ExpressionContext context) {\n        Editor editor = context.getEditor();\n        if (editor != null) {\n            AnonymousTemplateEditingListener.registerListener(editor, context.getProject());\n        }\n\n        PsiNamedElement[] vars = getSupertypes(params, context);\n        if (vars == null || vars.length == 0) return null;\n        return new JetPsiElementResult(vars[0]);\n    }","commit_id":"0febe3322bdd003bbf43cb311d0067e297846ef4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void doInitialise() throws InitialisationException {\n        super.doInitialise();\n\n        axisTransportProtocols = new HashMap();\n\n        for (Iterator iterator = supportedSchemes.iterator(); iterator.hasNext();) {\n            String s = (String) iterator.next();\n            if(!(s.equalsIgnoreCase(\"http\") || s.equalsIgnoreCase(\"https\") || s.equalsIgnoreCase(\"servlet\"))) {\n                axisTransportProtocols.put(s, MuleTransport.class);\n            }\n            registerSupportedProtocol(s);\n        }\n\n        MuleManager.getInstance().registerListener(this);\n\n        if (serverConfig == null)\n            serverConfig = DEFAULT_MULE_AXIS_SERVER_CONFIG;\n        if (clientConfig == null)\n            clientConfig = DEFAULT_MULE_AXIS_CLIENT_CONFIG;\n        serverProvider = createAxisProvider(serverConfig);\n        clientProvider = createAxisProvider(clientConfig);\n\n        // Create the AxisServer\n        axisServer = new AxisServer(serverProvider);\n        axisServer.setOption(\"axis.doAutoTypes\", new Boolean(doAutoTypes));\n\n        // Register the Mule service serverProvider\n        WSDDProvider.registerProvider(QNAME_MULE_PROVIDER, new WSDDJavaMuleProvider(this));\n\n        try {\n            registerTransportTypes();\n        } catch (ClassNotFoundException e) {\n            throw new InitialisationException(new org.mule.config.i18n.Message(Messages.CANT_LOAD_X_FROM_CLASSPATH_FILE, e.getMessage()), e, this);\n        }\n\n        //Overload the UrlHandlers provided by Axis so Mule can use its transports to move\n        //Soap messages around\n        String handlerPkgs = System.getProperty(\"java.protocol.handler.pkgs\", null);\n        if(handlerPkgs!=null) {\n            if(!handlerPkgs.endsWith(\"|\")) handlerPkgs += \"|\";\n            handlerPkgs = \"org.mule.providers.soap.axis.transport|\" + handlerPkgs;\n            System.setProperty(\"java.protocol.handler.pkgs\", handlerPkgs);\n            logger.debug(\"Setting java.protocol.handler.pkgs to: \" + handlerPkgs);\n        }\n\n        try {\n            registerTypes((TypeMappingRegistryImpl)axisServer.getTypeMappingRegistry(), beanTypes);\n        } catch (ClassNotFoundException e) {\n            throw new InitialisationException(e, this);\n        }\n    }","id":28223,"modified_method":"public void doInitialise() throws InitialisationException {\n        super.doInitialise();\n\n        axisTransportProtocols = new HashMap();\n\n        for (Iterator iterator = supportedSchemes.iterator(); iterator.hasNext();) {\n            String s = (String) iterator.next();\n            if(!(s.equalsIgnoreCase(\"http\") || s.equalsIgnoreCase(\"https\") || s.equalsIgnoreCase(\"servlet\"))) {\n                axisTransportProtocols.put(s, MuleTransport.class);\n            }\n            registerSupportedProtocol(s);\n        }\n\n        try {\n            MuleManager.getInstance().registerListener(this);\n        } catch (NotificationException nex) {\n            throw new InitialisationException(nex, this);\n        }\n\n        if (serverConfig == null)\n            serverConfig = DEFAULT_MULE_AXIS_SERVER_CONFIG;\n        if (clientConfig == null)\n            clientConfig = DEFAULT_MULE_AXIS_CLIENT_CONFIG;\n        serverProvider = createAxisProvider(serverConfig);\n        clientProvider = createAxisProvider(clientConfig);\n\n        // Create the AxisServer\n        axisServer = new AxisServer(serverProvider);\n        axisServer.setOption(\"axis.doAutoTypes\", new Boolean(doAutoTypes));\n\n        // Register the Mule service serverProvider\n        WSDDProvider.registerProvider(QNAME_MULE_PROVIDER, new WSDDJavaMuleProvider(this));\n\n        try {\n            registerTransportTypes();\n        } catch (ClassNotFoundException e) {\n            throw new InitialisationException(new org.mule.config.i18n.Message(Messages.CANT_LOAD_X_FROM_CLASSPATH_FILE, e.getMessage()), e, this);\n        }\n\n        //Overload the UrlHandlers provided by Axis so Mule can use its transports to move\n        //Soap messages around\n        String handlerPkgs = System.getProperty(\"java.protocol.handler.pkgs\", null);\n        if(handlerPkgs!=null) {\n            if(!handlerPkgs.endsWith(\"|\")) handlerPkgs += \"|\";\n            handlerPkgs = \"org.mule.providers.soap.axis.transport|\" + handlerPkgs;\n            System.setProperty(\"java.protocol.handler.pkgs\", handlerPkgs);\n            logger.debug(\"Setting java.protocol.handler.pkgs to: \" + handlerPkgs);\n        }\n\n        try {\n            registerTypes((TypeMappingRegistryImpl)axisServer.getTypeMappingRegistry(), beanTypes);\n        } catch (ClassNotFoundException e) {\n            throw new InitialisationException(e, this);\n        }\n    }","commit_id":"36c4457c9d8293962ea8e90b724741a887b7a98e","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doInitialise() throws InitialisationException\n    {\n        super.doInitialise();\n        MuleManager.getInstance().registerListener(this, getName());\n    }","id":28224,"modified_method":"public void doInitialise() throws InitialisationException\n    {\n        super.doInitialise();\n        try {\n            MuleManager.getInstance().registerListener(this, getName());\n        } catch (NotificationException nex) {\n            throw new InitialisationException(nex, this);\n        }\n    }","commit_id":"b2a29f36d597dff89ed868e021ce496c2931f08c","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Connection createConnection() throws NamingException, JMSException, InitialisationException\n    {\n        Connection connection = null;\n        if (connectionFactory == null) {\n            connectionFactory = createConnectionFactory();\n        }\n        if (connectionFactory != null && connectionFactory instanceof XAConnectionFactory) {\n            if (MuleManager.getInstance().getTransactionManager() != null) {\n                connectionFactory = new ConnectionFactoryWrapper(connectionFactory,\n                                                                 MuleManager.getInstance().getTransactionManager());\n            }\n        }\n\n        if (username != null) {\n            connection = jmsSupport.createConnection(connectionFactory, username, password);\n        } else {\n            connection = jmsSupport.createConnection(connectionFactory);\n        }\n\n        if (clientId != null) {\n            connection.setClientID(getClientId());\n        }\n        return connection;\n    }","id":28225,"modified_method":"protected Connection createConnection() throws NamingException, JMSException, InitialisationException\n    {\n        Connection connection;\n        if (connectionFactory == null) {\n            connectionFactory = createConnectionFactory();\n        }\n        if (connectionFactory != null && connectionFactory instanceof XAConnectionFactory) {\n            if (MuleManager.getInstance().getTransactionManager() != null) {\n                connectionFactory = new ConnectionFactoryWrapper(connectionFactory,\n                                                                 MuleManager.getInstance().getTransactionManager());\n            }\n        }\n\n        if (username != null) {\n            connection = jmsSupport.createConnection(connectionFactory, username, password);\n        } else {\n            connection = jmsSupport.createConnection(connectionFactory);\n        }\n\n        if (clientId != null) {\n            connection.setClientID(getClientId());\n        }\n        return connection;\n    }","commit_id":"b2a29f36d597dff89ed868e021ce496c2931f08c","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Hits subset(\n\t\t\tSolrQuery solrQuery, Query query, QueryConfig queryConfig,\n\t\t\tQueryResponse queryResponse, boolean allResults)\n\t\tthrows Exception {\n\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tHits hits = new HitsImpl();\n\n\t\tSolrDocumentList solrDocumentList = queryResponse.getResults();\n\n\t\tlong total = solrDocumentList.getNumFound();\n\n\t\tif (allResults && (total > 0)) {\n\t\t\tsolrQuery.setRows((int)total);\n\n\t\t\tqueryResponse = _solrServer.query(solrQuery);\n\n\t\t\treturn subset(solrQuery, query, queryConfig, queryResponse, false);\n\t\t}\n\n\t\tList<Document> documents = new ArrayList<Document>();\n\t\tList<Float> scores = new ArrayList<Float>();\n\t\tList<String> snippets = new ArrayList<String>();\n\n\t\tfloat maxScore = -1;\n\t\tSet<String> queryTerms = new HashSet<String>();\n\t\tint subsetTotal = 0;\n\n\t\tfor (SolrDocument solrDocument : solrDocumentList) {\n\t\t\tDocument document = new DocumentImpl();\n\n\t\t\tCollection<String> names = solrDocument.getFieldNames();\n\n\t\t\tfor (String name : names) {\n\t\t\t\tCollection<Object> fieldValues = solrDocument.getFieldValues(\n\t\t\t\t\tname);\n\n\t\t\t\tField field = new Field(\n\t\t\t\t\tname,\n\t\t\t\t\tArrayUtil.toStringArray(\n\t\t\t\t\t\tfieldValues.toArray(new Object[fieldValues.size()])));\n\n\t\t\t\tdocument.add(field);\n\t\t\t}\n\n\t\t\tdocuments.add(document);\n\n\t\t\tString snippet = StringPool.BLANK;\n\n\t\t\tif (queryConfig.isHighlightEnabled()) {\n\t\t\t\tsnippet = getSnippet(\n\t\t\t\t\tsolrDocument, queryConfig, queryTerms,\n\t\t\t\t\tqueryResponse.getHighlighting(), Field.CONTENT);\n\n\t\t\t\tif (Validator.isNull(snippet)) {\n\t\t\t\t\tsnippet = getSnippet(\n\t\t\t\t\t\tsolrDocument, queryConfig, queryTerms,\n\t\t\t\t\t\tqueryResponse.getHighlighting(), Field.TITLE);\n\t\t\t\t}\n\n\t\t\t\tif (Validator.isNotNull(snippet)) {\n\t\t\t\t\tsnippets.add(snippet);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (queryConfig.isScoreEnabled()) {\n\t\t\t\tfloat score = GetterUtil.getFloat(\n\t\t\t\t\tString.valueOf(solrDocument.getFieldValue(\"score\")));\n\n\t\t\t\tif (score > maxScore) {\n\t\t\t\t\tmaxScore = score;\n\t\t\t\t}\n\n\t\t\t\tscores.add(score);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscores.add(maxScore);\n\t\t\t}\n\n\t\t\tsubsetTotal++;\n\t\t}\n\n\t\thits.setDocs(documents.toArray(new Document[subsetTotal]));\n\t\thits.setLength((int)total);\n\t\thits.setQuery(query);\n\t\thits.setQueryTerms(queryTerms.toArray(new String[queryTerms.size()]));\n\n\t\tFloat[] scoresArray = scores.toArray(new Float[subsetTotal]);\n\n\t\tif (queryConfig.isScoreEnabled() && (subsetTotal > 0) &&\n\t\t\t(maxScore > 0)) {\n\n\t\t\tfor (int i = 0; i < scoresArray.length; i++) {\n\t\t\t\tscoresArray[i] = scoresArray[i] / maxScore;\n\t\t\t}\n\t\t}\n\n\t\thits.setScores(scoresArray);\n\n\t\tfloat searchTime =\n\t\t\t(float)(System.currentTimeMillis() - startTime) / Time.SECOND;\n\n\t\thits.setSearchTime(searchTime);\n\t\thits.setSnippets(snippets.toArray(new String[subsetTotal]));\n\t\thits.setStart(startTime);\n\n\t\treturn hits;\n\t}","id":28226,"modified_method":"protected Hits subset(\n\t\t\tSolrQuery solrQuery, Query query, QueryConfig queryConfig,\n\t\t\tQueryResponse queryResponse, boolean allResults)\n\t\tthrows Exception {\n\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tHits hits = new HitsImpl();\n\n\t\tSolrDocumentList solrDocumentList = queryResponse.getResults();\n\n\t\tlong total = solrDocumentList.getNumFound();\n\n\t\tif (allResults && (total > 0)) {\n\t\t\tsolrQuery.setRows((int)total);\n\n\t\t\tqueryResponse = _solrServer.query(solrQuery);\n\n\t\t\treturn subset(solrQuery, query, queryConfig, queryResponse, false);\n\t\t}\n\n\t\tList<Document> documents = new ArrayList<Document>();\n\t\tList<Float> scores = new ArrayList<Float>();\n\t\tList<String> snippets = new ArrayList<String>();\n\n\t\tfloat maxScore = -1;\n\t\tSet<String> queryTerms = new HashSet<String>();\n\t\tint subsetTotal = 0;\n\n\t\tfor (SolrDocument solrDocument : solrDocumentList) {\n\t\t\tDocument document = new DocumentImpl();\n\n\t\t\tCollection<String> names = solrDocument.getFieldNames();\n\n\t\t\tfor (String name : names) {\n\t\t\t\tCollection<Object> fieldValues = solrDocument.getFieldValues(\n\t\t\t\t\tname);\n\n\t\t\t\tField field = new Field(\n\t\t\t\t\tname,\n\t\t\t\t\tArrayUtil.toStringArray(\n\t\t\t\t\t\tfieldValues.toArray(new Object[fieldValues.size()])));\n\n\t\t\t\tdocument.add(field);\n\t\t\t}\n\n\t\t\tdocuments.add(document);\n\n\t\t\tString snippet = StringPool.BLANK;\n\n\t\t\tif (queryConfig.isHighlightEnabled()) {\n\t\t\t\tsnippet = getSnippet(\n\t\t\t\t\tsolrDocument, queryConfig, queryTerms,\n\t\t\t\t\tqueryResponse.getHighlighting(), Field.CONTENT);\n\n\t\t\t\tif (Validator.isNull(snippet)) {\n\t\t\t\t\tsnippet = getSnippet(\n\t\t\t\t\t\tsolrDocument, queryConfig, queryTerms,\n\t\t\t\t\t\tqueryResponse.getHighlighting(), Field.TITLE);\n\t\t\t\t}\n\n\t\t\t\tif (Validator.isNotNull(snippet)) {\n\t\t\t\t\tsnippets.add(snippet);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (queryConfig.isScoreEnabled()) {\n\t\t\t\tfloat score = GetterUtil.getFloat(\n\t\t\t\t\tString.valueOf(solrDocument.getFieldValue(\"score\")));\n\n\t\t\t\tif (score > maxScore) {\n\t\t\t\t\tmaxScore = score;\n\t\t\t\t}\n\n\t\t\t\tscores.add(score);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscores.add(maxScore);\n\t\t\t}\n\n\t\t\tsubsetTotal++;\n\t\t}\n\n\t\thits.setDocs(documents.toArray(new Document[subsetTotal]));\n\t\thits.setLength((int)total);\n\t\thits.setQuery(query);\n\t\thits.setQueryTerms(queryTerms.toArray(new String[queryTerms.size()]));\n\n\t\tFloat[] scoresArray = scores.toArray(new Float[subsetTotal]);\n\n\t\tif (queryConfig.isScoreEnabled() && (subsetTotal > 0) &&\n\t\t\t(maxScore > 0)) {\n\n\t\t\tfor (int i = 0; i < scoresArray.length; i++) {\n\t\t\t\tscoresArray[i] = scoresArray[i] / maxScore;\n\t\t\t}\n\t\t}\n\n\t\thits.setScores(scoresArray);\n\n\t\thits.setSearchTime(queryResponse.getQTime());\n\t\thits.setSnippets(snippets.toArray(new String[subsetTotal]));\n\t\thits.setStart(startTime);\n\n\t\treturn hits;\n\t}","commit_id":"3458b2093179ead76d3d204e1aa2ee6d85648e16","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic Hits search(SearchContext searchContext, Query query)\n\t\tthrows SearchException {\n\n\t\ttry {\n\t\t\treturn doSearch(searchContext, query);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tif (!_swallowException) {\n\t\t\t\tthrow new SearchException(e.getMessage());\n\t\t\t}\n\n\t\t\treturn new HitsImpl();\n\t\t}\n\t}","id":28227,"modified_method":"@Override\n\tpublic Hits search(SearchContext searchContext, Query query)\n\t\tthrows SearchException {\n\n\t\tStopWatch stopWatch = new StopWatch();\n\n\t\tstopWatch.start();\n\n\t\ttry {\n\t\t\tSolrQuery solrQuery = new SolrQuery();\n\n\t\t\tQueryResponse queryResponse = doSearch(\n\t\t\t\tsolrQuery, searchContext, query);\n\n\t\t\tHits hits = processQueryResponse(\n\t\t\t\tsolrQuery, queryResponse, searchContext, query);\n\n\t\t\thits.setStart(stopWatch.getStartTime());\n\n\t\t\treturn hits;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\n\t\t\tif (!_swallowException) {\n\t\t\t\tthrow new SearchException(e.getMessage());\n\t\t\t}\n\n\t\t\treturn new HitsImpl();\n\t\t}\n\t\tfinally {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\tstopWatch.stop();\n\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Searching \" + query.toString() + \" took \" +\n\t\t\t\t\t\tstopWatch.getTime() + \" ms\");\n\t\t\t}\n\t\t}\n\t}","commit_id":"3458b2093179ead76d3d204e1aa2ee6d85648e16","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected Hits doSearch(SearchContext searchContext, Query query)\n\t\tthrows Exception {\n\n\t\tSolrQuery solrQuery = new SolrQuery();\n\n\t\tQueryConfig queryConfig = query.getQueryConfig();\n\n\t\taddFacets(solrQuery, searchContext);\n\t\taddHighlights(solrQuery, queryConfig);\n\t\taddPagination(\n\t\t\tsolrQuery, searchContext.getStart(), searchContext.getEnd());\n\t\taddSelectedFields(solrQuery, queryConfig);\n\t\taddSort(solrQuery, searchContext.getSorts());\n\n\t\tsolrQuery.setIncludeScore(queryConfig.isScoreEnabled());\n\n\t\ttranslateQuery(searchContext, query, solrQuery);\n\n\t\tQueryResponse queryResponse = _solrServer.query(solrQuery, METHOD.POST);\n\n\t\tboolean allResults = false;\n\n\t\tif (solrQuery.getRows() == 0) {\n\t\t\tallResults = true;\n\t\t}\n\n\t\tupdateFacetCollectors(queryResponse, searchContext);\n\n\t\treturn subset(\n\t\t\tsolrQuery, query, query.getQueryConfig(), queryResponse,\n\t\t\tallResults);\n\t}","id":28228,"modified_method":"protected QueryResponse doSearch(\n\t\t\tSolrQuery solrQuery, SearchContext searchContext, Query query)\n\t\tthrows Exception {\n\n\t\tQueryConfig queryConfig = query.getQueryConfig();\n\n\t\taddFacets(solrQuery, searchContext);\n\t\taddHighlights(solrQuery, queryConfig);\n\t\taddPagination(\n\t\t\tsolrQuery, searchContext.getStart(), searchContext.getEnd());\n\t\taddSelectedFields(solrQuery, queryConfig);\n\t\taddSort(solrQuery, searchContext.getSorts());\n\n\t\tsolrQuery.setIncludeScore(queryConfig.isScoreEnabled());\n\n\t\ttranslateQuery(searchContext, query, solrQuery);\n\n\t\treturn _solrServer.query(solrQuery, METHOD.POST);\n\t}","commit_id":"3458b2093179ead76d3d204e1aa2ee6d85648e16","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n  public void start( AcceptsOneWidget container, EventBus eventBus ) {\n    this.container = container;\n    // Hide detail view at the beginning\n    this.clientFactory.getShellView( ).hideDetail( );\n    this.clientFactory.getShellView( ).getDetailView( ).setPresenter( this );\n    \n    this.clientFactory.getShellView( ).getContentView( ).setContentTitle( getTitle( ) );\n    \n    // Show loading first\n    LoadingAnimationView view = this.clientFactory.getLoadingAnimationView( );\n    container.setWidget( view );\n    \n    LOG.log( Level.INFO, \"Search \" + getTitle( ) + \": \" + place.getSearch( ) );\n    // At the beginning, don't sort\n    doSearch( place.getSearch( ), new SearchRange( 0, pageSize, -1/*sortField*/, true ) );\n  }","id":28229,"modified_method":"@Override\n  public void start( AcceptsOneWidget container, EventBus eventBus ) {\n    this.container = container;\n    // Hide detail view at the beginning\n    this.clientFactory.getShellView( ).hideDetail( );\n    this.clientFactory.getShellView( ).getDetailView( ).setPresenter( this );\n    \n    this.clientFactory.getShellView( ).getContentView( ).setContentTitle( getTitle( ) );\n    \n    // Show loading first\n    LoadingAnimationView view = this.clientFactory.getLoadingAnimationView( );\n    container.setWidget( view );\n    \n    LOG.log( Level.INFO, \"Search \" + getTitle( ) + \": \" + place.getSearch( ) );\n    // At the beginning, don't sort\n    range = new SearchRange( 0, pageSize, -1/*sortField*/, true );\n    doSearch( place.getSearch( ), range );\n  }","commit_id":"c41c4f13b795aca829a8155b69e45b1f089093ef","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void createAccount( ) {\n    if ( createAccountDialog == null ) {\n      createAccountDialog = new DialogBox( );\n      createAccountDialog.setText( \"Create a new account\" );\n      createAccountDialog.setWidget( this.clientFactory.getCreateAccountView( ) );\n      createAccountDialog.setGlassEnabled( true );\n    }\n    this.clientFactory.getCreateAccountView( ).init( );\n    this.clientFactory.getCreateAccountView( ).setPresenter( this );\n    createAccountDialog.center( );\n    createAccountDialog.show( );\n  }","id":28230,"modified_method":"@Override\n  public void onCreateAccount( ) {\n    if ( createAccountDialog == null ) {\n      createAccountDialog = new DialogBox( );\n      createAccountDialog.setText( \"Create a new account\" );\n      createAccountDialog.setWidget( this.clientFactory.getCreateAccountView( ) );\n      createAccountDialog.setGlassEnabled( true );\n    }\n    this.clientFactory.getCreateAccountView( ).init( );\n    this.clientFactory.getCreateAccountView( ).setPresenter( this );\n    createAccountDialog.center( );\n    createAccountDialog.show( );\n  }","commit_id":"c41c4f13b795aca829a8155b69e45b1f089093ef","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void createAccount( String value ) {\n    this.clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.LOADING, \"Creating account \" + value + \" ...\", 2000 );\n    this.createAccountDialog.hide( );\n  }","id":28231,"modified_method":"@Override\n  public void doCreateAccount( final String value ) {\n    this.clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.LOADING, \"Creating account \" + value + \" ...\", 0 );\n    this.createAccountDialog.hide( );\n    \n    this.clientFactory.getBackendService( ).createAccount( this.clientFactory.getLocalSession( ).getSession( ), value, new AsyncCallback<Void>( ) {\n\n      @Override\n      public void onFailure( Throwable caught ) {\n        String error = \"Failed to create account \" + value + \": \" + caught.getMessage( );\n        clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.ERROR, error, 60000 );\n        clientFactory.getShellView( ).getLogView( ).log( LogType.ERROR, error );\n      }\n\n      @Override\n      public void onSuccess( Void arg0 ) {\n        clientFactory.getShellView( ).getFooterView( ).showStatus( StatusType.NONE, \"Account \" + value + \" created\", 60000 );\n        doSearch( place.getSearch( ), range );\n      }\n      \n    } );\n  }","commit_id":"c41c4f13b795aca829a8155b69e45b1f089093ef","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static List<SearchResultRow> searchKeys( SearchQuery query ) throws EucalyptusServiceException {\n    List<SearchResultRow> results = Lists.newArrayList( );\n    try {\n      if ( query.hasOnlySingle( USERID ) ) {\n        // Optimization for a single user's keys\n        User user = Accounts.lookupUserById( query.getSingle( USERID ).getValue( ) );\n        Account account = user.getAccount( );\n        for ( AccessKey key : user.getKeys( ) ) {\n          results.add( serializeKey( key, account, user ) );\n        }\n      } else {\n        for ( Account account : getAccounts( query ) ) {\n          for ( User user : account.getUsers( ) ) {\n            for ( AccessKey key : user.getKeys( ) ) {\n              if ( keyMatchQuery( key, query ) ) {\n                results.add( serializeKey( key, account, user ) );\n              }\n            }\n          }\n        }\n      }\n    } catch ( Exception e ) {\n      LOG.error( \"Failed to get keys\", e );\n      LOG.debug( e, e );\n      throw new EucalyptusServiceException( \"Failed to get keys for query: \" + query );      \n    }    \n    return results;    \n  }","id":28232,"modified_method":"public static List<SearchResultRow> searchKeys( SearchQuery query ) throws EucalyptusServiceException {\n    List<SearchResultRow> results = Lists.newArrayList( );\n    try {\n      if ( query.hasOnlySingle( USERID ) ) {\n        // Optimization for a single user's keys\n        User user = Accounts.lookupUserById( query.getSingle( USERID ).getValue( ) );\n        Account account = user.getAccount( );\n        for ( AccessKey key : user.getKeys( ) ) {\n          results.add( serializeKey( key, account, user ) );\n        }\n      } else {\n        for ( Account account : getAccounts( query ) ) {\n          for ( User user : account.getUsers( ) ) {\n            for ( AccessKey key : user.getKeys( ) ) {\n              if ( keyMatchQuery( key, query ) ) {\n                results.add( serializeKey( key, account, user ) );\n              }\n            }\n          }\n        }\n      }\n    } catch ( Exception e ) {\n      LOG.error( \"Failed to get keys\", e );\n      LOG.debug( e, e );\n      throw new EucalyptusServiceException( \"Failed to get keys for query \" + query + \": \" + e.getMessage( ) );      \n    }    \n    return results;    \n  }","commit_id":"c41c4f13b795aca829a8155b69e45b1f089093ef","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void displayData( SearchResult result ) {\n    for ( SearchResultRow row : result.getRows( ) ) {\n      LOG.log( Level.INFO, \"Row: \" + row );\n    }\n    if ( this.view == null ) {\n      showView( result );\n    } else {\n      this.view.setData( result );\n    }\n  }","id":28233,"modified_method":"private void displayData( SearchResult result ) {\n    cache.update( result );\n    \n    for ( SearchResultRow row : result.getRows( ) ) {\n      LOG.log( Level.INFO, \"Row: \" + row );\n    }\n    if ( this.view == null ) {\n      showView( result );\n    }\n    this.view.showSearchResult( result );\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void handleRangeChange( SearchRange range ) {\n    LOG.log( Level.INFO, \"Account search range change: \" + range );\n    doSearch( this.search, range );\n  }","id":28234,"modified_method":"@Override\n  public void handleRangeChange( SearchRange range ) {\n    LOG.log( Level.INFO, \"Account search range change: \" + range );\n    SearchResult result = cache.lookup( range );\n    if ( result != null ) {\n      // Use the cached result if search range does not change\n      displayData( result );\n    } else {\n      doSearch( this.search, range );\n    }\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void start( AcceptsOneWidget container, EventBus eventBus ) {\n    this.container = container;\n    // Set title\n    this.clientFactory.getShellView( ).getContentView( ).setContentTitle( TITLE );\n    // Show loading first\n    LoadingAnimationView view = this.clientFactory.getLoadingAnimationView( );\n    container.setWidget( view );\n    // Start a search\n    this.search = URL.decode( place.getSearch( ) );\n    doSearch( search, new SearchRange( 0, pageSize ) );\n  }","id":28235,"modified_method":"@Override\n  public void start( AcceptsOneWidget container, EventBus eventBus ) {\n    this.container = container;\n    // Set title\n    this.clientFactory.getShellView( ).getContentView( ).setContentTitle( TITLE );\n    // Show loading first\n    LoadingAnimationView view = this.clientFactory.getLoadingAnimationView( );\n    container.setWidget( view );\n    // Start a search\n    doSearch( search, new SearchRange( 0, pageSize ) );\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void doSearch( String search, SearchRange range ) {    \n    this.clientFactory.getBackendService( ).lookupAccount( this.clientFactory.getLocalSession( ).getSession( ), search, range,\n                                                           new AsyncCallback<SearchResult>( ) {\n      \n      @Override\n      public void onFailure( Throwable caught ) {\n        LOG.log( Level.WARNING, \"Search failed: \" + caught );\n        displayData( null );\n      }\n      \n      @Override\n      public void onSuccess( SearchResult result ) {\n        LOG.log( Level.INFO, \"Search success:\" + result.getLength( ) );\n        displayData( result );\n      }\n      \n    } );\n  }","id":28236,"modified_method":"private void doSearch( String search, SearchRange range ) {    \n    this.clientFactory.getBackendService( ).lookupAccount( this.clientFactory.getLocalSession( ).getSession( ), search, range,\n                                                           new AsyncCallback<SearchResult>( ) {\n      \n      @Override\n      public void onFailure( Throwable caught ) {\n        LOG.log( Level.WARNING, \"Search failed: \" + caught );\n        displayData( null );\n      }\n      \n      @Override\n      public void onSuccess( SearchResult result ) {\n        LOG.log( Level.INFO, \"Search success:\" + result.length( ) );\n        displayData( result );\n      }\n      \n    } );\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public AccountActivity( AccountPlace place, ClientFactory clientFactory ) {\n    this.place = place;\n    this.clientFactory = clientFactory;\n    this.pageSize = this.clientFactory.getSessionData( ).getIntProperty( SessionData.SEARCH_RESULT_PAGE_SIZE, DEFAULT_PAGE_SIZE );\n  }","id":28237,"modified_method":"public AccountActivity( AccountPlace place, ClientFactory clientFactory ) {\n    this.place = place;\n    this.search = URL.decode( place.getSearch( ) );\n    this.clientFactory = clientFactory;\n    this.pageSize = this.clientFactory.getSessionData( ).getIntProperty( SessionData.SEARCH_RESULT_PAGE_SIZE, DEFAULT_PAGE_SIZE );\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void showView( SearchResult result ) {    \n    this.view = this.clientFactory.getAccountView( );\n    this.view.setPresenter( this );\n    container.setWidget( this.view );\n    if ( result != null ) {\n      this.view.initializeTable( pageSize, result.getDescs( ), this );\n    }\n  }","id":28238,"modified_method":"private void showView( SearchResult result ) {    \n    this.view = this.clientFactory.getAccountView( );\n    this.view.setPresenter( this );\n    container.setWidget( this.view );\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void setData( SearchResult data ) {\n    table.setData( data );\n  }","id":28239,"modified_method":"@Override\n  public void showSearchResult( SearchResult result ) {\n    if ( this.table == null ) {\n      initializeTable( this.presenter.getPageSize( ), result.getDescs( ) );\n    }\n    table.setData( result );\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void initializeTable( int pageSize,  ArrayList<SearchResultFieldDesc> fieldDescs, SearchResultRangeChangeHandler changeHandler ) {\n    tablePanel.clear( );\n    final MultiSelectionModel<SearchResultRow> selectionModel = new MultiSelectionModel<SearchResultRow>( SearchResultRow.KEY_PROVIDER );\n    selectionModel.addSelectionChangeHandler( new Handler( ) {\n      @Override\n      public void onSelectionChange( SelectionChangeEvent event ) {\n        Set<SearchResultRow> rows = selectionModel.getSelectedSet( );\n        LOG.log( Level.INFO, \"Selection changed: \" + rows );\n        presenter.onSelectionChange( rows );\n      }\n    } );\n    /*\n    final SingleSelectionModel<SearchResultRow> selectionModel = new SingleSelectionModel<SearchResultRow>( SearchResultRow.KEY_PROVIDER );\n    selectionModel.addSelectionChangeHandler( new Handler( ) {\n      @Override\n      public void onSelectionChange( SelectionChangeEvent event ) {\n        SearchResultRow row = selectionModel.getSelectedObject( );\n        LOG.log( Level.INFO, \"Selection changed: \" + row );\n      }\n    } );\n    */    \n    table = new SearchResultTable( pageSize, fieldDescs, changeHandler, selectionModel );\n    tablePanel.add( table );\n    table.load( );\n  }","id":28240,"modified_method":"public void initializeTable( int pageSize,  ArrayList<SearchResultFieldDesc> fieldDescs ) {\n    tablePanel.clear( );\n    final MultiSelectionModel<SearchResultRow> selectionModel = new MultiSelectionModel<SearchResultRow>( SearchResultRow.KEY_PROVIDER );\n    selectionModel.addSelectionChangeHandler( new Handler( ) {\n      @Override\n      public void onSelectionChange( SelectionChangeEvent event ) {\n        Set<SearchResultRow> rows = selectionModel.getSelectedSet( );\n        LOG.log( Level.INFO, \"Selection changed: \" + rows );\n        presenter.onSelectionChange( rows );\n      }\n    } );\n    /*\n    final SingleSelectionModel<SearchResultRow> selectionModel = new SingleSelectionModel<SearchResultRow>( SearchResultRow.KEY_PROVIDER );\n    selectionModel.addSelectionChangeHandler( new Handler( ) {\n      @Override\n      public void onSelectionChange( SelectionChangeEvent event ) {\n        SearchResultRow row = selectionModel.getSelectedObject( );\n        LOG.log( Level.INFO, \"Selection changed: \" + row );\n      }\n    } );\n    */    \n    table = new SearchResultTable( pageSize, fieldDescs, this.presenter, selectionModel );\n    tablePanel.add( table );\n    table.load( );\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void doSearch( String query ) {\n    LOG.log( Level.INFO, \"'service' new search: \" + query );\n  }","id":28241,"modified_method":"private void doSearch( String query, SearchRange range ) {\n    LOG.log( Level.INFO, \"'service' new search: \" + query );\n    this.clientFactory.getBackendService( ).lookupConfiguration( this.clientFactory.getLocalSession( ).getSession( ), query, range, new AsyncCallback<SearchResult>( ) {\n\n      @Override\n      public void onFailure( Throwable cause ) {\n        LOG.log( Level.WARNING, \"Failed to get configurations: \" + cause );\n        displayData( null );\n      }\n\n      @Override\n      public void onSuccess( SearchResult result ) {\n        displayData( result );\n      }\n      \n    } );\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ConfigActivity( ConfigPlace place, ClientFactory clientFactory ) {\n    this.place = place;\n    this.clientFactory = clientFactory;\n  }","id":28242,"modified_method":"public ConfigActivity( ConfigPlace place, ClientFactory clientFactory ) {\n    this.place = place;\n    this.search = URL.decode( place.getSearch( ) );\n    this.clientFactory = clientFactory;\n    this.pageSize = this.clientFactory.getSessionData( ).getIntProperty( SessionData.SEARCH_RESULT_PAGE_SIZE, DEFAULT_PAGE_SIZE );    \n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void start( AcceptsOneWidget container, EventBus eventBus ) {\n    this.clientFactory.getShellView( ).getContentView( ).setContentTitle( TITLE );\n    // Show loading first\n    LoadingAnimationView view = this.clientFactory.getLoadingAnimationView( );\n    container.setWidget( view );\n    doSearch( URL.decode( place.getSearch( ) ) );\n  }","id":28243,"modified_method":"@Override\n  public void start( AcceptsOneWidget container, EventBus eventBus ) {\n    this.container = container;\n    this.clientFactory.getShellView( ).getContentView( ).setContentTitle( TITLE );\n    // Show loading first\n    LoadingAnimationView view = this.clientFactory.getLoadingAnimationView( );\n    container.setWidget( view );\n    doSearch( URL.decode( place.getSearch( ) ), new SearchRange( 0, pageSize ) );\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public SearchResult lookupConfiguration( Session session, String search, SearchRange range ) throws EucalyptusServiceException {\n    verifySession( session );\n    return null;\n  }","id":28244,"modified_method":"@Override\n  public SearchResult lookupConfiguration( Session session, String search, SearchRange range ) throws EucalyptusServiceException {\n    verifySession( session );\n    SearchResult result = new SearchResult( );\n    result.setDescs( ConfigurationWebBackend.COMMON_CONFIG_FIELD_DESCS );\n    result.addRow( ConfigurationWebBackend.getCloudConfiguration( ) );\n    result.addRows( ConfigurationWebBackend.getClusterConfigurations( ) );\n    result.addRows( ConfigurationWebBackend.getStorageConfiguration( ) );\n    result.addRows( ConfigurationWebBackend.getWalrusConfiguration( ) );\n    return result;\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public SearchResult lookupAccount( Session session, String search, SearchRange range ) throws EucalyptusServiceException {\n    verifySession( session );\n    \n    System.out.println( \"New search: \" + range );\n    \n    final int sortField = range.getSortField( );\n    final boolean ascending = range.isAscending( );\n    Collections.sort( DATA, new Comparator<SearchResultRow>( ) {\n      @Override\n      public int compare( SearchResultRow r1, SearchResultRow r2 ) {\n        if ( r1 == r2 ) {\n          return 0;\n        }\n        // Compare the name columns.\n        int diff = -1;\n        if ( r1 != null ) {\n          diff = ( r2 != null ) ? r1.getField( sortField ).compareTo( r2.getField( sortField ) ) : 1;\n        }\n        return ascending ? diff : -diff;\n      }\n    } );\n    int resultLength = Math.min( range.getLength( ), DATA.size( ) - range.getStart( ) );\n    SearchResult result = new SearchResult( DATA.size( ), range.getStart( ), resultLength );\n    result.setDescs( FIELDS );\n    result.setRows( DATA.subList( range.getStart( ), range.getStart( ) + resultLength ) );\n    \n    for ( SearchResultRow row : result.getRows( ) ) {\n      System.out.println( \"Row: \" + row );\n    }\n    \n    return result;\n  }","id":28245,"modified_method":"@Override\n  public SearchResult lookupAccount( Session session, String search, SearchRange range ) throws EucalyptusServiceException {\n    verifySession( session );\n    \n    System.out.println( \"New search: \" + range );\n    \n    final int sortField = range.getSortField( );\n    final boolean ascending = range.isAscending( );\n    Collections.sort( DATA, new Comparator<SearchResultRow>( ) {\n      @Override\n      public int compare( SearchResultRow r1, SearchResultRow r2 ) {\n        if ( r1 == r2 ) {\n          return 0;\n        }\n        // Compare the name columns.\n        int diff = -1;\n        if ( r1 != null ) {\n          diff = ( r2 != null ) ? r1.getField( sortField ).compareTo( r2.getField( sortField ) ) : 1;\n        }\n        return ascending ? diff : -diff;\n      }\n    } );\n    int resultLength = Math.min( range.getLength( ), DATA.size( ) - range.getStart( ) );\n    SearchResult result = new SearchResult( DATA.size( ), range );\n    result.setDescs( FIELDS );\n    result.setRows( DATA.subList( range.getStart( ), range.getStart( ) + resultLength ) );\n    \n    for ( SearchResultRow row : result.getRows( ) ) {\n      System.out.println( \"Row: \" + row );\n    }\n    \n    return result;\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public SearchResult lookupAccount( Session session, String search, SearchRange range ) throws EucalyptusServiceException {\n    System.out.println( \"New search: \" + range );\n    \n    final int sortField = range.getSortField( );\n    final boolean ascending = range.isAscending( );\n    Collections.sort( DATA, new Comparator<SearchResultRow>( ) {\n      @Override\n      public int compare( SearchResultRow r1, SearchResultRow r2 ) {\n        if ( r1 == r2 ) {\n          return 0;\n        }\n        // Compare the name columns.\n        int diff = -1;\n        if ( r1 != null ) {\n          diff = ( r2 != null ) ? r1.getField( sortField ).compareTo( r2.getField( sortField ) ) : 1;\n        }\n        return ascending ? diff : -diff;\n      }\n    } );\n    int resultLength = Math.min( range.getLength( ), DATA.size( ) - range.getStart( ) );\n    SearchResult result = new SearchResult( DATA.size( ), range.getStart( ), resultLength );\n    result.setDescs( FIELDS );\n    result.setRows( DATA.subList( range.getStart( ), range.getStart( ) + resultLength ) );\n    \n    for ( SearchResultRow row : result.getRows( ) ) {\n      System.out.println( \"Row: \" + row );\n    }\n    \n    return result;\n  }","id":28246,"modified_method":"@Override\n  public SearchResult lookupAccount( Session session, String search, SearchRange range ) throws EucalyptusServiceException {\n    System.out.println( \"New search: \" + range );\n    \n    final int sortField = range.getSortField( );\n    final boolean ascending = range.isAscending( );\n    Collections.sort( DATA, new Comparator<SearchResultRow>( ) {\n      @Override\n      public int compare( SearchResultRow r1, SearchResultRow r2 ) {\n        if ( r1 == r2 ) {\n          return 0;\n        }\n        // Compare the name columns.\n        int diff = -1;\n        if ( r1 != null ) {\n          diff = ( r2 != null ) ? r1.getField( sortField ).compareTo( r2.getField( sortField ) ) : 1;\n        }\n        return ascending ? diff : -diff;\n      }\n    } );\n    int resultLength = Math.min( range.getLength( ), DATA.size( ) - range.getStart( ) );\n    SearchResult result = new SearchResult( DATA.size( ), range );\n    result.setDescs( FIELDS );\n    result.setRows( DATA.subList( range.getStart( ), range.getStart( ) + resultLength ) );\n    \n    for ( SearchResultRow row : result.getRows( ) ) {\n      System.out.println( \"Row: \" + row );\n    }\n    \n    return result;\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public int getLength( ) {\n    return length;\n  }","id":28247,"modified_method":"/**\n   * @return the actual length.\n   */\n  public int length( ) {\n    return this.rows.size( );\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public SearchResult( int totalSize, int start, int length ) {\n    this.totalSize = totalSize;\n    this.start = start;\n    this.length = length;\n  }","id":28248,"modified_method":"public SearchResult( int totalSize, SearchRange range ) {\n    this.totalSize = totalSize;\n    this.range = range;\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void setData( SearchResult data ) {    \n    if ( cellTable != null ) {\n      cellTable.setRowCount( data.getTotalSize( ), true );\n      //cellTable.setVisibleRange( data.getStart( ), data.getLength( ) );\n      cellTable.setRowData( data.getStart( ), data.getRows( ) );\n    }\n  }","id":28249,"modified_method":"public void setData( SearchResult data ) {    \n    if ( cellTable != null ) {\n      cellTable.setRowCount( data.getTotalSize( ), true );\n      //cellTable.setVisibleRange( data.getStart( ), data.getLength( ) );\n      cellTable.setRowData( data.getRange( ).getStart( ), data.getRows( ) );\n    }\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void buildTable( int pageSize ) {\n    CellTable.Resources resources = GWT.create( TableResources.class );\n    \n    cellTable = new CellTable<SearchResultRow>( pageSize, resources );\n    cellTable.setWidth( \"100%\", true );\n    // Initialize columns\n    for ( int i = 0; i < this.fieldDescs.size( ); i++ ) {\n      SearchResultFieldDesc desc = this.fieldDescs.get( i );\n      final int index = i;\n      TextColumn<SearchResultRow> col = new TextColumn<SearchResultRow>( ) {\n        @Override\n        public String getValue( SearchResultRow data ) {\n          if ( data == null ) {\n            return \"\";\n          } else {\n            return data.getField( index );\n          }\n        }\n      };\n      col.setSortable( desc.getSortable( ) );\n      cellTable.addColumn( col, desc.getTitle( ) );\n      cellTable.setColumnWidth( col, desc.getWidth( ) );\n      tableColIdx.add( i );\n    }\n    \n    cellTable.setSelectionModel( selectionModel );\n  }","id":28250,"modified_method":"private void buildTable( int pageSize ) {\n    CellTable.Resources resources = GWT.create( TableResources.class );\n    \n    cellTable = new CellTable<SearchResultRow>( pageSize, resources );\n    cellTable.setWidth( \"100%\", true );\n    // Initialize columns\n    for ( int i = 0; i < this.fieldDescs.size( ); i++ ) {\n      SearchResultFieldDesc desc = this.fieldDescs.get( i );\n      if ( desc.getTableDisplay( ) != TableDisplay.MANDATORY ) {\n        continue;\n      }\n      final int index = i;\n      TextColumn<SearchResultRow> col = new TextColumn<SearchResultRow>( ) {\n        @Override\n        public String getValue( SearchResultRow data ) {\n          if ( data == null ) {\n            return \"\";\n          } else {\n            return data.getField( index );\n          }\n        }\n      };\n      col.setSortable( desc.getSortable( ) );\n      cellTable.addColumn( col, desc.getTitle( ) );\n      cellTable.setColumnWidth( col, desc.getWidth( ) );\n      tableColIdx.add( i );\n    }\n    \n    cellTable.setSelectionModel( selectionModel );\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void load( ) {\n    cellTable.getColumnSortList( ).push( cellTable.getColumn( 0 ) );\n    \n    AsyncDataProvider<SearchResultRow> dataProvider = new AsyncDataProvider<SearchResultRow>( ) {\n      @Override\n      protected void onRangeChanged( HasData<SearchResultRow> display ) {\n        SearchRange sr = new SearchRange( );\n        Range range = display.getVisibleRange( );\n        if ( range != null ) {\n          sr.setStart( range.getStart( ) );\n          sr.setLength( range.getLength( ) );\n        }\n        if ( cellTable.getColumnSortList( ) != null ) {\n          ColumnSortInfo sort = cellTable.getColumnSortList( ).get( 0 );\n          if ( sort != null ) {\n            sr.setSortField( tableColIdx.get( cellTable.getColumnIndex( ( Column<SearchResultRow, ?> ) sort.getColumn( ) ) ) );\n            sr.setAscending( sort.isAscending( ) );\n          }\n        }\n        changeHandler.handleRangeChange( sr );\n      }\n    };\n    dataProvider.addDataDisplay( cellTable );\n    \n    AsyncHandler sortHandler = new AsyncHandler( cellTable );\n    cellTable.addColumnSortHandler( sortHandler );    \n  }","id":28251,"modified_method":"public void load( ) {\n    AsyncDataProvider<SearchResultRow> dataProvider = new AsyncDataProvider<SearchResultRow>( ) {\n      @Override\n      protected void onRangeChanged( HasData<SearchResultRow> display ) {\n        SearchRange sr = new SearchRange( );\n        Range range = display.getVisibleRange( );\n        if ( range != null ) {\n          sr.setStart( range.getStart( ) );\n          sr.setLength( range.getLength( ) );\n        }\n        ColumnSortList sortList = cellTable.getColumnSortList( );\n        if ( sortList != null && sortList.size( ) > 0 ) {\n          ColumnSortInfo sort = sortList.get( 0 );\n          if ( sort != null ) {\n            sr.setSortField( tableColIdx.get( cellTable.getColumnIndex( ( Column<SearchResultRow, ?> ) sort.getColumn( ) ) ) );\n            sr.setAscending( sort.isAscending( ) );\n          }\n        }\n        changeHandler.handleRangeChange( sr );\n      }\n    };\n    dataProvider.addDataDisplay( cellTable );\n    \n    AsyncHandler sortHandler = new AsyncHandler( cellTable );\n    cellTable.addColumnSortHandler( sortHandler );    \n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public SearchResultTable( int pageSize, ArrayList<SearchResultFieldDesc> fieldDescs, SearchResultRangeChangeHandler changeHandler, SelectionModel<SearchResultRow> selectionModel ) {\n    this.changeHandler = changeHandler;\n    this.fieldDescs = fieldDescs;\n    this.selectionModel = selectionModel;\n    \n    buildTable( pageSize );\n    buildPager( );\n    \n    initWidget( uiBinder.createAndBindUi( this ) );\n    \n    if ( selectionModel instanceof MultiSelectionModel ) {\n      this.tip.setText( MULTI_SELECTION_TIP );\n    }\n  }","id":28252,"modified_method":"public SearchResultTable( int pageSize, ArrayList<SearchResultFieldDesc> fieldDescs, SearchRangeChangeHandler changeHandler, SelectionModel<SearchResultRow> selectionModel ) {\n    this.changeHandler = changeHandler;\n    this.fieldDescs = fieldDescs;\n    this.selectionModel = selectionModel;\n    \n    buildTable( pageSize );\n    buildPager( );\n    \n    initWidget( uiBinder.createAndBindUi( this ) );\n    \n    if ( selectionModel instanceof MultiSelectionModel ) {\n      this.tip.setText( MULTI_SELECTION_TIP );\n    }\n  }","commit_id":"9e2f3e35c3943796fbcf37b8bafb5d174efa3fad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@NotNull\n  public List<Library> chooseElements() {\n    final FileChooserDescriptor chooserDescriptor;\n    final List<Pair<LibraryRootsComponentDescriptor, FileChooserDescriptor>> descriptors = new ArrayList<Pair<LibraryRootsComponentDescriptor, FileChooserDescriptor>>();\n    for (LibraryRootsComponentDescriptor componentDescriptor : myLibraryTypes.keySet()) {\n      descriptors.add(Pair.create(componentDescriptor, componentDescriptor.createAttachFilesChooserDescriptor()));\n    }\n    if (descriptors.size() == 1) {\n      chooserDescriptor = descriptors.get(0).getSecond();\n    }\n    else {\n      chooserDescriptor = new FileChooserDescriptor(true, true, true, false, true, false) {\n        @Override\n        public boolean isFileSelectable(VirtualFile file) {\n          for (Pair<LibraryRootsComponentDescriptor, FileChooserDescriptor> pair : descriptors) {\n            if (pair.getSecond().isFileSelectable(file)) {\n              return true;\n            }\n          }\n          return false;\n        }\n\n        @Override\n        public boolean isFileVisible(VirtualFile file, boolean showHiddenFiles) {\n          for (Pair<LibraryRootsComponentDescriptor, FileChooserDescriptor> pair : descriptors) {\n            if (pair.getSecond().isFileVisible(file, showHiddenFiles)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      };\n    }\n    chooserDescriptor.putUserData(LangDataKeys.MODULE_CONTEXT, myModule);\n\n    final VirtualFile[] files = FileChooser.chooseFiles(myParentComponent, chooserDescriptor, myModule.getProject().getBaseDir());\n    if (files.length == 0) return Collections.emptyList();\n\n    List<LibraryRootsComponentDescriptor> suitableDescriptors = new ArrayList<LibraryRootsComponentDescriptor>();\n    for (Pair<LibraryRootsComponentDescriptor, FileChooserDescriptor> pair : descriptors) {\n      if (acceptAll(pair.getSecond(), files)) {\n        suitableDescriptors.add(pair.getFirst());\n      }\n    }\n\n    final LibraryRootsComponentDescriptor rootsComponentDescriptor;\n    LibraryType libraryType = null;\n    if (suitableDescriptors.size() == 1) {\n      rootsComponentDescriptor = suitableDescriptors.get(0);\n      libraryType = myLibraryTypes.get(rootsComponentDescriptor);\n    }\n    else {\n      rootsComponentDescriptor = myDefaultDescriptor;\n    }\n    List<OrderRoot> chosenRoots = RootDetectionUtil.detectRoots(Arrays.asList(files), myParentComponent, myModule.getProject(),\n                                                                rootsComponentDescriptor.getRootDetectors(), true);\n\n    final List<OrderRoot> roots = filterAlreadyAdded(chosenRoots);\n    if (roots.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    final List<Library> addedLibraries = new ArrayList<Library>();\n    boolean onlyClasses = true;\n    for (OrderRoot root : roots) {\n      onlyClasses &= root.getType() == OrderRootType.CLASSES;\n    }\n    if (onlyClasses) {\n      for (OrderRoot root : roots) {\n        addedLibraries.add(createLibraryFromRoots(Collections.singletonList(root), libraryType));\n      }\n    }\n    else {\n      addedLibraries.add(createLibraryFromRoots(roots, libraryType));\n    }\n    return addedLibraries;\n  }","id":28253,"modified_method":"@NotNull\n  public List<Library> chooseElements() {\n    final FileChooserDescriptor chooserDescriptor;\n    final List<Pair<LibraryRootsComponentDescriptor, FileChooserDescriptor>> descriptors = new ArrayList<Pair<LibraryRootsComponentDescriptor, FileChooserDescriptor>>();\n    for (LibraryRootsComponentDescriptor componentDescriptor : myLibraryTypes.keySet()) {\n      descriptors.add(Pair.create(componentDescriptor, componentDescriptor.createAttachFilesChooserDescriptor()));\n    }\n    if (descriptors.size() == 1) {\n      chooserDescriptor = descriptors.get(0).getSecond();\n    }\n    else {\n      chooserDescriptor = new FileChooserDescriptor(true, true, true, false, true, false) {\n        @Override\n        public boolean isFileSelectable(VirtualFile file) {\n          for (Pair<LibraryRootsComponentDescriptor, FileChooserDescriptor> pair : descriptors) {\n            if (pair.getSecond().isFileSelectable(file)) {\n              return true;\n            }\n          }\n          return false;\n        }\n\n        @Override\n        public boolean isFileVisible(VirtualFile file, boolean showHiddenFiles) {\n          for (Pair<LibraryRootsComponentDescriptor, FileChooserDescriptor> pair : descriptors) {\n            if (pair.getSecond().isFileVisible(file, showHiddenFiles)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      };\n    }\n    chooserDescriptor.putUserData(LangDataKeys.MODULE_CONTEXT, myModule);\n\n    final VirtualFile[] files = FileChooser.chooseFiles(myParentComponent, chooserDescriptor, myModule.getProject().getBaseDir());\n    if (files.length == 0) return Collections.emptyList();\n\n    List<LibraryRootsComponentDescriptor> suitableDescriptors = new ArrayList<LibraryRootsComponentDescriptor>();\n    for (Pair<LibraryRootsComponentDescriptor, FileChooserDescriptor> pair : descriptors) {\n      if (acceptAll(pair.getSecond(), files)) {\n        suitableDescriptors.add(pair.getFirst());\n      }\n    }\n\n    final LibraryRootsComponentDescriptor rootsComponentDescriptor;\n    LibraryType libraryType = null;\n    if (suitableDescriptors.size() == 1) {\n      rootsComponentDescriptor = suitableDescriptors.get(0);\n      libraryType = myLibraryTypes.get(rootsComponentDescriptor);\n    }\n    else {\n      rootsComponentDescriptor = myDefaultDescriptor;\n    }\n    List<OrderRoot> chosenRoots = RootDetectionUtil.detectRoots(Arrays.asList(files), myParentComponent, myModule.getProject(),\n                                                                rootsComponentDescriptor);\n\n    final List<OrderRoot> roots = filterAlreadyAdded(chosenRoots);\n    if (roots.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    final List<Library> addedLibraries = new ArrayList<Library>();\n    boolean onlyClasses = true;\n    for (OrderRoot root : roots) {\n      onlyClasses &= root.getType() == OrderRootType.CLASSES;\n    }\n    if (onlyClasses) {\n      for (OrderRoot root : roots) {\n        addedLibraries.add(createLibraryFromRoots(Collections.singletonList(root), libraryType));\n      }\n    }\n    else {\n      addedLibraries.add(createLibraryFromRoots(roots, libraryType));\n    }\n    return addedLibraries;\n  }","commit_id":"a0552e9d11d7cc97ae2c3ecc5b61d9744ede51b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public VirtualFileCheckedTreeNode(SuggestedChildRootInfo rootInfo, String rootType) {\n      super(rootInfo);\n      myFile = rootInfo.getSuggestedRoot();\n      myRootType = rootType;\n    }","id":28254,"modified_method":"public VirtualFileCheckedTreeNode(SuggestedChildRootInfo rootInfo, String rootType) {\n      super(rootInfo);\n      myFile = rootInfo.getSuggestedRoot().getFile();\n      myRootType = rootType;\n    }","commit_id":"a0552e9d11d7cc97ae2c3ecc5b61d9744ede51b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static CheckedTreeNode createTree(List<SuggestedChildRootInfo> suggestedRoots) {\n    TObjectIntHashMap<VirtualFile> rootTypesCount = new TObjectIntHashMap<VirtualFile>();\n    for (SuggestedChildRootInfo suggestedRoot : suggestedRoots) {\n      final VirtualFile root = suggestedRoot.getSuggestedRoot();\n      if (!rootTypesCount.containsKey(root)) {\n        rootTypesCount.put(root, 0);\n      }\n      rootTypesCount.increment(root);\n    }\n\n    CheckedTreeNode root = new CheckedTreeNode(null);\n    Map<VirtualFile, CheckedTreeNode> rootCandidateNodes = new HashMap<VirtualFile, CheckedTreeNode>();\n    for (SuggestedChildRootInfo rootInfo : suggestedRoots) {\n      final VirtualFile rootCandidate = rootInfo.getRootCandidate();\n      CheckedTreeNode parent = rootCandidateNodes.get(rootCandidate);\n      if (parent == null) {\n        parent = new VirtualFileCheckedTreeNode(rootCandidate);\n        rootCandidateNodes.put(rootCandidate, parent);\n        root.add(parent);\n      }\n      final String rootType = rootTypesCount.get(rootInfo.getSuggestedRoot()) > 1 ? rootInfo.getDetector().getPresentableRootTypeName() : null;\n      parent.add(new VirtualFileCheckedTreeNode(rootInfo, rootType));\n    }\n    return root;\n  }","id":28255,"modified_method":"private static CheckedTreeNode createTree(List<SuggestedChildRootInfo> suggestedRoots) {\n    TObjectIntHashMap<VirtualFile> rootTypesCount = new TObjectIntHashMap<VirtualFile>();\n    for (SuggestedChildRootInfo suggestedRoot : suggestedRoots) {\n      final VirtualFile root = suggestedRoot.getSuggestedRoot().getFile();\n      if (!rootTypesCount.containsKey(root)) {\n        rootTypesCount.put(root, 0);\n      }\n      rootTypesCount.increment(root);\n    }\n\n    CheckedTreeNode root = new CheckedTreeNode(null);\n    Map<VirtualFile, CheckedTreeNode> rootCandidateNodes = new HashMap<VirtualFile, CheckedTreeNode>();\n    for (SuggestedChildRootInfo rootInfo : suggestedRoots) {\n      final VirtualFile rootCandidate = rootInfo.getRootCandidate();\n      CheckedTreeNode parent = rootCandidateNodes.get(rootCandidate);\n      if (parent == null) {\n        parent = new VirtualFileCheckedTreeNode(rootCandidate);\n        rootCandidateNodes.put(rootCandidate, parent);\n        root.add(parent);\n      }\n      final String rootType = rootTypesCount.get(rootInfo.getSuggestedRoot().getFile()) > 1 ? rootInfo.getRootTypeName() : null;\n      parent.add(new VirtualFileCheckedTreeNode(rootInfo, rootType));\n    }\n    return root;\n  }","commit_id":"a0552e9d11d7cc97ae2c3ecc5b61d9744ede51b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AttachFilesAction(List<? extends RootDetector> detectors, String title) {\n      super(title);\n      myDetectors = detectors;\n    }","id":28256,"modified_method":"public AttachFilesAction(String title) {\n      super(title);\n    }","commit_id":"a0552e9d11d7cc97ae2c3ecc5b61d9744ede51b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void init(AbstractTreeStructure treeStructure) {\n    myTree = new Tree(new DefaultTreeModel(new DefaultMutableTreeNode()));\n    myTree.setRootVisible(false);\n    myTree.setShowsRootHandles(true);\n    new LibraryRootsTreeSpeedSearch(myTree);\n    myTree.setCellRenderer(new LibraryTreeRenderer());\n    myTreeBuilder = new LibraryTableTreeBuilder(myTree, (DefaultTreeModel)myTree.getModel(), treeStructure);\n    myTreePanel.setLayout(new BorderLayout());\n\n    ToolbarDecorator toolbarDecorator = ToolbarDecorator.createDecorator(myTree).disableUpDownActions().disableAddAction()\n      .setRemoveActionName(ProjectBundle.message(\"library.detach.action\"))\n      .setRemoveAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          final Object[] selectedElements = getSelectedElements();\n          if (selectedElements.length == 0) {\n            return;\n          }\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              for (Object selectedElement : selectedElements) {\n                if (selectedElement instanceof ItemElement) {\n                  final ItemElement itemElement = (ItemElement)selectedElement;\n                  getLibraryEditor().removeRoot(itemElement.getUrl(), itemElement.getRootType());\n                }\n                else if (selectedElement instanceof OrderRootTypeElement) {\n                  final OrderRootType rootType = ((OrderRootTypeElement)selectedElement).getOrderRootType();\n                  final String[] urls = getLibraryEditor().getUrls(rootType);\n                  for (String url : urls) {\n                    getLibraryEditor().removeRoot(url, rootType);\n                  }\n                }\n              }\n            }\n          });\n          librariesChanged(true);\n        }\n      });\n\n    final List<? extends RootDetector> detectors = myDescriptor.getRootDetectors();\n    toolbarDecorator.setAddAction(new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        final AnAction[] children = getActions();\n        if (children.length == 0) return;\n        final DefaultActionGroup actions = new DefaultActionGroup(children);\n        JBPopupFactory.getInstance().createActionGroupPopup(null, actions,\n                                                            DataManager.getInstance().getDataContext(button.getContextComponent()),\n                                                            JBPopupFactory.ActionSelectionAid.SPEEDSEARCH, true)\n          .show(button.getPreferredPopupPoint());\n      }\n\n      private AnAction[] getActions() {\n        List<AnAction> actions = new ArrayList<AnAction>();\n        if (!detectors.isEmpty()) {\n          actions.add(new AttachFilesAction(detectors, ProjectBundle.message(\"button.text.attach.files\")));\n        }\n        for (AttachRootButtonDescriptor descriptor : myDescriptor.createAttachButtons()) {\n          actions.add(new AttachItemAction(descriptor, descriptor.getButtonText()));\n        }\n        return actions.toArray(new AnAction[actions.size()]);\n      }\n    });\n\n\n\n    myTreePanel.add(toolbarDecorator.createPanel(), BorderLayout.CENTER);\n    ToolbarDecorator.findRemoveButton(myTreePanel).addCustomUpdater(new AnActionButtonUpdater() {\n      @Override\n      public boolean isEnabled(AnActionEvent e) {\n        final Object[] selectedElements = getSelectedElements();\n        for (Object element : selectedElements) {\n          if (element instanceof ItemElement) {\n            return true;\n          }\n          if (element instanceof OrderRootTypeElement && getLibraryEditor().getUrls(((OrderRootTypeElement)element).getOrderRootType()).length > 0) {\n            return true;\n          }\n        }\n        return false;\n      }\n    });\n\n    Disposer.register(this, myTreeBuilder);\n  }","id":28257,"modified_method":"private void init(AbstractTreeStructure treeStructure) {\n    myTree = new Tree(new DefaultTreeModel(new DefaultMutableTreeNode()));\n    myTree.setRootVisible(false);\n    myTree.setShowsRootHandles(true);\n    new LibraryRootsTreeSpeedSearch(myTree);\n    myTree.setCellRenderer(new LibraryTreeRenderer());\n    myTreeBuilder = new LibraryTableTreeBuilder(myTree, (DefaultTreeModel)myTree.getModel(), treeStructure);\n    myTreePanel.setLayout(new BorderLayout());\n\n    ToolbarDecorator toolbarDecorator = ToolbarDecorator.createDecorator(myTree).disableUpDownActions().disableAddAction()\n      .setRemoveActionName(ProjectBundle.message(\"library.detach.action\"))\n      .setRemoveAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          final Object[] selectedElements = getSelectedElements();\n          if (selectedElements.length == 0) {\n            return;\n          }\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              for (Object selectedElement : selectedElements) {\n                if (selectedElement instanceof ItemElement) {\n                  final ItemElement itemElement = (ItemElement)selectedElement;\n                  getLibraryEditor().removeRoot(itemElement.getUrl(), itemElement.getRootType());\n                }\n                else if (selectedElement instanceof OrderRootTypeElement) {\n                  final OrderRootType rootType = ((OrderRootTypeElement)selectedElement).getOrderRootType();\n                  final String[] urls = getLibraryEditor().getUrls(rootType);\n                  for (String url : urls) {\n                    getLibraryEditor().removeRoot(url, rootType);\n                  }\n                }\n              }\n            }\n          });\n          librariesChanged(true);\n        }\n      });\n\n    toolbarDecorator.setAddAction(new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        final AnAction[] children = getActions();\n        if (children.length == 0) return;\n        final DefaultActionGroup actions = new DefaultActionGroup(children);\n        JBPopupFactory.getInstance().createActionGroupPopup(null, actions,\n                                                            DataManager.getInstance().getDataContext(button.getContextComponent()),\n                                                            JBPopupFactory.ActionSelectionAid.SPEEDSEARCH, true)\n          .show(button.getPreferredPopupPoint());\n      }\n\n      private AnAction[] getActions() {\n        List<AnAction> actions = new ArrayList<AnAction>();\n        actions.add(new AttachFilesAction(ProjectBundle.message(\"button.text.attach.files\")));\n        for (AttachRootButtonDescriptor descriptor : myDescriptor.createAttachButtons()) {\n          actions.add(new AttachItemAction(descriptor, descriptor.getButtonText()));\n        }\n        return actions.toArray(new AnAction[actions.size()]);\n      }\n    });\n\n\n\n    myTreePanel.add(toolbarDecorator.createPanel(), BorderLayout.CENTER);\n    ToolbarDecorator.findRemoveButton(myTreePanel).addCustomUpdater(new AnActionButtonUpdater() {\n      @Override\n      public boolean isEnabled(AnActionEvent e) {\n        final Object[] selectedElements = getSelectedElements();\n        for (Object element : selectedElements) {\n          if (element instanceof ItemElement) {\n            return true;\n          }\n          if (element instanceof OrderRootTypeElement && getLibraryEditor().getUrls(((OrderRootTypeElement)element).getOrderRootType()).length > 0) {\n            return true;\n          }\n        }\n        return false;\n      }\n    });\n\n    Disposer.register(this, myTreeBuilder);\n  }","commit_id":"a0552e9d11d7cc97ae2c3ecc5b61d9744ede51b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected List<OrderRoot> selectRoots(@Nullable VirtualFile initialSelection) {\n      final FileChooserDescriptor chooserDescriptor = myDescriptor.createAttachFilesChooserDescriptor();\n      final String name = getLibraryEditor().getName();\n      chooserDescriptor.setTitle(StringUtil.isEmpty(name) ? ProjectBundle.message(\"library.attach.files.action\")\n                                                          : ProjectBundle.message(\"library.attach.files.to.library.action\", name));\n      chooserDescriptor.setDescription(ProjectBundle.message(\"library.attach.files.description\"));\n      if (myContextModule != null) {\n        chooserDescriptor.putUserData(LangDataKeys.MODULE_CONTEXT, myContextModule);\n      }\n      final VirtualFile[] files = FileChooser.chooseFiles(myPanel, chooserDescriptor, initialSelection);\n      if (files.length == 0) return Collections.emptyList();\n\n      return RootDetectionUtil.detectRoots(Arrays.asList(files), myPanel, myProject, myDetectors, true);\n    }","id":28258,"modified_method":"@Override\n    protected List<OrderRoot> selectRoots(@Nullable VirtualFile initialSelection) {\n      final FileChooserDescriptor chooserDescriptor = myDescriptor.createAttachFilesChooserDescriptor();\n      final String name = getLibraryEditor().getName();\n      chooserDescriptor.setTitle(StringUtil.isEmpty(name) ? ProjectBundle.message(\"library.attach.files.action\")\n                                                          : ProjectBundle.message(\"library.attach.files.to.library.action\", name));\n      chooserDescriptor.setDescription(ProjectBundle.message(\"library.attach.files.description\"));\n      if (myContextModule != null) {\n        chooserDescriptor.putUserData(LangDataKeys.MODULE_CONTEXT, myContextModule);\n      }\n      final VirtualFile[] files = FileChooser.chooseFiles(myPanel, chooserDescriptor, initialSelection);\n      if (files.length == 0) return Collections.emptyList();\n\n      return RootDetectionUtil.detectRoots(Arrays.asList(files), myPanel, myProject, myDescriptor);\n    }","commit_id":"a0552e9d11d7cc97ae2c3ecc5b61d9744ede51b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Provides root detectors for 'Attach Files' button. They will be used to automatically assign {@link OrderRootType}s for selected files.\n   * Also these detectors are used when a new library is created so the list must not be empty.\n   *\n   * @return non-empty list of {@link RootDetector}'s implementations\n   */\n  @NotNull\n  public abstract List<? extends RootDetector> getRootDetectors();","id":28259,"modified_method":"/**\n   * Provides separate detectors for root types supported by the library type.\n   *\n   * @return non-empty list of {@link RootDetector}'s implementations\n   */\n  @NotNull\n  public abstract List<? extends RootDetector> getRootDetectors();","commit_id":"a0552e9d11d7cc97ae2c3ecc5b61d9744ede51b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public NewLibraryConfiguration createLibraryFromFiles(@NotNull LibraryRootsComponentDescriptor descriptor,\n                                                        @NotNull JComponent parentComponent,\n                                                        @Nullable VirtualFile contextDirectory,\n                                                        LibraryType<?> type,\n                                                        final Project project) {\n    final List<? extends RootDetector> rootDetectors = descriptor.getRootDetectors();\n    final List<OrderRoot> roots;\n    if (!rootDetectors.isEmpty()) {\n      final FileChooserDescriptor chooserDescriptor = descriptor.createAttachFilesChooserDescriptor();\n      chooserDescriptor.setTitle(\"Select Library Files\");\n      final VirtualFile[] rootCandidates = FileChooser.chooseFiles(parentComponent, chooserDescriptor, contextDirectory);\n      if (rootCandidates.length == 0) {\n        return null;\n      }\n\n      roots = RootDetectionUtil.detectRoots(Arrays.asList(rootCandidates), parentComponent, project, rootDetectors, true);\n      if (roots.isEmpty()) return null;\n    }\n    else {\n      roots = Collections.emptyList();\n    }\n    String name = suggestLibraryName(roots);\n    return doCreate(type, name, roots);\n  }","id":28260,"modified_method":"@Override\n  public NewLibraryConfiguration createLibraryFromFiles(@NotNull LibraryRootsComponentDescriptor descriptor,\n                                                        @NotNull JComponent parentComponent,\n                                                        @Nullable VirtualFile contextDirectory,\n                                                        LibraryType<?> type,\n                                                        final Project project) {\n    final FileChooserDescriptor chooserDescriptor = descriptor.createAttachFilesChooserDescriptor();\n    chooserDescriptor.setTitle(\"Select Library Files\");\n    final VirtualFile[] rootCandidates = FileChooser.chooseFiles(parentComponent, chooserDescriptor, contextDirectory);\n    if (rootCandidates.length == 0) {\n      return null;\n    }\n\n    final List<OrderRoot> roots = RootDetectionUtil.detectRoots(Arrays.asList(rootCandidates), parentComponent, project, descriptor);\n    if (roots.isEmpty()) return null;\n    String name = suggestLibraryName(roots);\n    return doCreate(type, name, roots);\n  }","commit_id":"a0552e9d11d7cc97ae2c3ecc5b61d9744ede51b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final Project project = getEventProject(e);\n    if (project == null) return;\n\n    final List<VirtualFile> jars = getRoots(e);\n    if (jars.isEmpty()) return;\n\n    final List<OrderRoot> roots = RootDetectionUtil.detectRoots(jars, null, project, new DefaultLibraryRootsComponentDescriptor().getRootDetectors(), true);\n    new CreateLibraryFromFilesDialog(project, roots).show();\n  }","id":28261,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final Project project = getEventProject(e);\n    if (project == null) return;\n\n    final List<VirtualFile> jars = getRoots(e);\n    if (jars.isEmpty()) return;\n\n    final List<OrderRoot> roots = RootDetectionUtil.detectRoots(jars, null, project, new DefaultLibraryRootsComponentDescriptor());\n    new CreateLibraryFromFilesDialog(project, roots).show();\n  }","commit_id":"a0552e9d11d7cc97ae2c3ecc5b61d9744ede51b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * This method takes a candidates for the project root, then scans the candidates and\n   * if multiple candidates or non root source directories are found whithin some\n   * directories, it shows a dialog that allows selecting or deselecting them.\n   * @param parent a parent parent or project\n   * @param rootCandidates a candidates for roots\n   * @return a array of source folders or empty array if non was selected or dialog was canceled.\n   */\n  public static VirtualFile[] scanAndSelectDetectedJavaSourceRoots(Component parentComponent, final VirtualFile[] rootCandidates) {\n    final List<OrderRoot> orderRoots = RootDetectionUtil.detectRoots(Arrays.asList(rootCandidates), parentComponent, null,\n                                                                     Collections.singletonList(JAVA_SOURCE_ROOT_DETECTOR), false);\n    final List<VirtualFile> result = new ArrayList<VirtualFile>();\n    for (OrderRoot root : orderRoots) {\n      result.add(root.getFile());\n    }\n    return VfsUtil.toVirtualFileArray(result);\n  }","id":28262,"modified_method":"/**\n   * This method takes a candidates for the project root, then scans the candidates and\n   * if multiple candidates or non root source directories are found whithin some\n   * directories, it shows a dialog that allows selecting or deselecting them.\n   * @param parent a parent parent or project\n   * @param rootCandidates a candidates for roots\n   * @return a array of source folders or empty array if non was selected or dialog was canceled.\n   */\n  public static VirtualFile[] scanAndSelectDetectedJavaSourceRoots(Component parentComponent, final VirtualFile[] rootCandidates) {\n    final List<OrderRoot> orderRoots = RootDetectionUtil.detectRoots(Arrays.asList(rootCandidates), parentComponent, null,\n                                                                     new LibraryRootsDetectorImpl(Collections.singletonList(JAVA_SOURCE_ROOT_DETECTOR)),\n                                                                     new OrderRootType[0]);\n    final List<VirtualFile> result = new ArrayList<VirtualFile>();\n    for (OrderRoot root : orderRoots) {\n      result.add(root.getFile());\n    }\n    return VfsUtil.toVirtualFileArray(result);\n  }","commit_id":"a0552e9d11d7cc97ae2c3ecc5b61d9744ede51b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static List<OrderRoot> detectRoots(@NotNull final Collection<VirtualFile> rootCandidates,\n                                            @Nullable Component parentComponent,\n                                            @Nullable Project project,\n                                            @NotNull final List<? extends RootDetector> detectors,\n                                            boolean allowUserToSelectRootTypeIfNothingIsDetected) {\n    LOG.assertTrue(!detectors.isEmpty());\n    final List<OrderRoot> result = new ArrayList<OrderRoot>();\n    final List<SuggestedChildRootInfo> suggestedRoots = new ArrayList<SuggestedChildRootInfo>();\n    new Task.Modal(project, \"Scanning for Roots\", true) {\n      @Override\n      public void run(@NotNull ProgressIndicator indicator) {\n        try {\n          for (RootDetector detector : detectors) {\n            for (VirtualFile rootCandidate : rootCandidates) {\n              final Collection<VirtualFile> roots = detector.detectRoots(rootCandidate, indicator);\n              final VirtualFile first = ContainerUtil.getFirstItem(roots);\n              if (first != null && roots.size() == 1 && first.equals(rootCandidate)) {\n                result.add(new OrderRoot(first, detector.getRootType(), detector.isJarDirectory()));\n              }\n              else {\n                for (VirtualFile root : roots) {\n                  suggestedRoots.add(new SuggestedChildRootInfo(detector, rootCandidate, root));\n                }\n              }\n            }\n          }\n        }\n        catch (ProcessCanceledException ignored) {\n        }\n      }\n    }.queue();\n\n    if (!suggestedRoots.isEmpty()) {\n      final DetectedRootsChooserDialog dialog = parentComponent != null\n                                                ? new DetectedRootsChooserDialog(parentComponent, suggestedRoots)\n                                                : new DetectedRootsChooserDialog(project, suggestedRoots);\n      dialog.show();\n      if (!dialog.isOK()) {\n        return Collections.emptyList();\n      }\n      for (SuggestedChildRootInfo rootInfo : dialog.getChosenRoots()) {\n        result\n          .add(new OrderRoot(rootInfo.getSuggestedRoot(), rootInfo.getDetector().getRootType(), rootInfo.getDetector().isJarDirectory()));\n      }\n    }\n\n    if (result.isEmpty() && allowUserToSelectRootTypeIfNothingIsDetected) {\n      List<RootDetector> sortedDetectors = new ArrayList<RootDetector>(detectors);\n      Collections.sort(sortedDetectors, new Comparator<RootDetector>() {\n        @Override\n        public int compare(final RootDetector o1, final RootDetector o2) {\n          return o1.getPresentableRootTypeName().compareToIgnoreCase(o2.getPresentableRootTypeName());\n        }\n      });\n\n      List<String> names = new ArrayList<String>();\n      for (RootDetector detector : sortedDetectors) {\n        names.add(detector.getPresentableRootTypeName());\n      }\n      final int i = Messages.showChooseDialog(\"Choose category for selected files:\", \"Attach Files\",\n                                              ArrayUtil.toStringArray(names), names.get(0), null);\n      if (i != -1) {\n        final RootDetector detector = sortedDetectors.get(i);\n        for (VirtualFile candidate : rootCandidates) {\n          result.add(new OrderRoot(candidate, detector.getRootType(), detector.isJarDirectory()));\n        }\n      }\n    }\n    return result;\n  }","id":28263,"modified_method":"@NotNull\n  public static List<OrderRoot> detectRoots(@NotNull final Collection<VirtualFile> rootCandidates,\n                                            @Nullable Component parentComponent,\n                                            @Nullable Project project,\n                                            @NotNull final LibraryRootsComponentDescriptor rootsComponentDescriptor) {\n    return detectRoots(rootCandidates, parentComponent, project, rootsComponentDescriptor.getRootsDetector(),\n                       rootsComponentDescriptor.getRootTypes());\n  }","commit_id":"a0552e9d11d7cc97ae2c3ecc5b61d9744ede51b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"SuggestedChildRootInfo(RootDetector detector, VirtualFile rootCandidate, VirtualFile suggestedRoot) {\n    myDetector = detector;\n    myRootCandidate = rootCandidate;\n    mySuggestedRoot = suggestedRoot;\n  }","id":28264,"modified_method":"SuggestedChildRootInfo(VirtualFile rootCandidate, OrderRoot suggestedRoot, String rootTypeName) {\n    myRootCandidate = rootCandidate;\n    mySuggestedRoot = suggestedRoot;\n    myRootTypeName = rootTypeName;\n  }","commit_id":"a0552e9d11d7cc97ae2c3ecc5b61d9744ede51b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public VirtualFile getSuggestedRoot() {\n    return mySuggestedRoot;\n  }","id":28265,"modified_method":"public OrderRoot getSuggestedRoot() {\n    return mySuggestedRoot;\n  }","commit_id":"a0552e9d11d7cc97ae2c3ecc5b61d9744ede51b6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tprotected Map<String, List<StagedModel>> addDependentStagedModels(\n\t\tGroup group) throws Exception {\n\n\t\tBookmarksFolder folder = BookmarksTestUtil.addFolder(\n\t\t\tgroup.getGroupId(), \"Test Parent Folder\");\n\n\t\tHashMap<String, List<StagedModel>> relatedStagedModels =\n\t\t\tnew HashMap<String, List<StagedModel>>();\n\n\t\tList<StagedModel> relatedFolderModels = new ArrayList<StagedModel>();\n\n\t\trelatedFolderModels.add(folder);\n\n\t\trelatedStagedModels.put(\n\t\t\tBookmarksFolder.class.getName(), relatedFolderModels);\n\n\t\treturn relatedStagedModels;\n\t}","id":28266,"modified_method":"@Override\n\tprotected Map<String, List<StagedModel>> addDependentStagedModels(\n\t\tGroup group) throws Exception {\n\n\t\tList<StagedModel> dependentStagedFolderModels =\n\t\t\tnew ArrayList<StagedModel>();\n\n\t\tdependentStagedFolderModels.add(\n\t\t\tBookmarksTestUtil.addFolder(\n\t\t\t\tgroup.getGroupId(), \"Test Parent Folder\"));\n\n\t\tHashMap<String, List<StagedModel>> dependentStagedModels =\n\t\t\tnew HashMap<String, List<StagedModel>>();\n\n\t\tdependentStagedModels.put(\n\t\t\tBookmarksFolder.class.getName(), dependentStagedFolderModels);\n\n\t\treturn dependentStagedModels;\n\t}","commit_id":"246cdb2500a09fe6536e1284384325667d3b385b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Map<String, List<StagedModel>> addDependentStagedModels(\n\t\t\tGroup group)\n\t\tthrows Exception {\n\n\t\tBookmarksFolder folder = BookmarksTestUtil.addFolder(\n\t\t\tgroup.getGroupId(), \"Test Folder\");\n\n\t\tHashMap<String, List<StagedModel>> relatedStagedModels =\n\t\t\tnew HashMap<String, List<StagedModel>>();\n\n\t\tList<StagedModel> relatedFolderModels = new ArrayList<StagedModel>();\n\n\t\trelatedFolderModels.add(folder);\n\n\t\trelatedStagedModels.put(\n\t\t\tBookmarksFolder.class.getName(), relatedFolderModels);\n\n\t\treturn relatedStagedModels;\n\t}","id":28267,"modified_method":"protected Map<String, List<StagedModel>> addDependentStagedModels(\n\t\t\tGroup group)\n\t\tthrows Exception {\n\n\t\tList<StagedModel> dependentStagedFolderModels =\n\t\t\tnew ArrayList<StagedModel>();\n\n\t\tdependentStagedFolderModels.add(\n\t\t\tBookmarksTestUtil.addFolder(group.getGroupId(), \"Test Folder\"));\n\n\t\tHashMap<String, List<StagedModel>> dependentStagedModels =\n\t\t\tnew HashMap<String, List<StagedModel>>();\n\n\t\tdependentStagedModels.put(\n\t\t\tBookmarksFolder.class.getName(), dependentStagedFolderModels);\n\n\t\treturn dependentStagedModels;\n\t}","commit_id":"45221f42a1f58a61a847767d096a837eb1de97de","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected StagedModel addStagedModel(\n\t\t\tGroup group, Map<String, List<StagedModel>> relatedStagedModels)\n\t\tthrows Exception {\n\n\t\tList<StagedModel> folderList = relatedStagedModels.get(\n\t\t\tBookmarksFolder.class.getName());\n\n\t\tBookmarksFolder folder = (BookmarksFolder)folderList.get(0);\n\n\t\treturn BookmarksTestUtil.addEntry(\n\t\t\tgroup.getGroupId(), folder.getFolderId(), true);\n\t}","id":28268,"modified_method":"protected StagedModel addStagedModel(\n\t\t\tGroup group, Map<String, List<StagedModel>> dependentStagedModels)\n\t\tthrows Exception {\n\n\t\tList<StagedModel> folderList = dependentStagedModels.get(\n\t\t\tBookmarksFolder.class.getName());\n\n\t\tBookmarksFolder folder = (BookmarksFolder)folderList.get(0);\n\n\t\treturn BookmarksTestUtil.addEntry(\n\t\t\tgroup.getGroupId(), folder.getFolderId(), true);\n\t}","commit_id":"45221f42a1f58a61a847767d096a837eb1de97de","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Delete all messages <= seqno (they are stable, that is, have been\n     * received at all members). Stop when a number > seqno is encountered\n     * (all messages are ordered on seqnos).\n     */\n    public void stable(long seqno) {\n        lock.writeLock();\n        try {\n            // we need to remove all seqnos *including* seqno: because headMap() *excludes* seqno, we\n            // simply increment it, so we have to correct behavior\n            SortedMap m=delivered_msgs.headMap(new Long(seqno +1));\n            if(m.size() > 0)\n                lowest_seen=Math.max(lowest_seen, ((Long)m.lastKey()).longValue());\n            m.clear(); // removes entries from delivered_msgs\n        }\n        finally {\n            lock.writeUnlock();\n        }\n    }","id":28269,"modified_method":"/**\n     * Delete all messages <= seqno (they are stable, that is, have been\n     * received at all members). Stop when a number > seqno is encountered\n     * (all messages are ordered on seqnos).\n     */\n    public void stable(long seqno) {\n        try {\n            lock.writeLock().acquire();\n            try {\n                // we need to remove all seqnos *including* seqno: because headMap() *excludes* seqno, we\n                // simply increment it, so we have to correct behavior\n                SortedMap m=delivered_msgs.headMap(new Long(seqno +1));\n                if(m.size() > 0)\n                    lowest_seen=Math.max(lowest_seen, ((Long)m.lastKey()).longValue());\n                m.clear(); // removes entries from delivered_msgs\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n        }\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Find all messages between 'low' and 'high' (including 'low' and\n     * 'high') that have a null msg.\n     * Return them as a list of longs\n     *\n     * @return List<Long>. A list of seqnos, sorted in ascending order.\n     * E.g. [1, 4, 7, 8]\n     */\n    public List getMissingMessages(long low, long high) {\n        List retval=new List();\n        // long my_high;\n\n        if(low > high) {\n            if(log.isErrorEnabled()) log.error(\"invalid range: low (\" + low +\n                    \") is higher than high (\" + high + ')');\n            return null;\n        }\n\n        lock.readLock();\n        try {\n\n            // my_high=Math.max(head - 1, 0);\n            // check only received messages, because delivered messages *must* have a non-null msg\n            SortedMap m=received_msgs.subMap(new Long(low), new Long(high+1));\n            for(Iterator it=m.keySet().iterator(); it.hasNext();) {\n                retval.add(it.next());\n            }\n\n//            if(received_msgs.size() > 0) {\n//                entry=(Entry)received_msgs.peek();\n//                if(entry != null) my_high=entry.seqno;\n//            }\n//            for(long i=my_high + 1; i <= high; i++)\n//                retval.add(new Long(i));\n\n            return retval;\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28270,"modified_method":"/**\n     * Find all messages between 'low' and 'high' (including 'low' and\n     * 'high') that have a null msg.\n     * Return them as a list of longs\n     *\n     * @return List<Long>. A list of seqnos, sorted in ascending order.\n     * E.g. [1, 4, 7, 8]\n     */\n    public List getMissingMessages(long low, long high) {\n        List retval=new List();\n        // long my_high;\n\n        if(low > high) {\n            if(log.isErrorEnabled()) log.error(\"invalid range: low (\" + low +\n                    \") is higher than high (\" + high + ')');\n            return null;\n        }\n\n        try {\n            lock.readLock().acquire();\n            try {\n\n                // my_high=Math.max(head - 1, 0);\n                // check only received messages, because delivered messages *must* have a non-null msg\n                SortedMap m=received_msgs.subMap(new Long(low), new Long(high+1));\n                for(Iterator it=m.keySet().iterator(); it.hasNext();) {\n                    retval.add(it.next());\n                }\n\n//            if(received_msgs.size() > 0) {\n//                entry=(Entry)received_msgs.peek();\n//                if(entry != null) my_high=entry.seqno;\n//            }\n//            for(long i=my_high + 1; i <= high; i++)\n//                retval.add(new Long(i));\n\n                return retval;\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return null;\n        }\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds a message according to its sequence number (ordered).\n     * <p>\n     * Variables <code>head<\/code> and <code>tail<\/code> mark the start and\n     * end of the messages received, but not delivered yet. When a message is\n     * received, if its seqno is smaller than <code>head<\/code>, it is\n     * discarded (already received). If it is bigger than <code>tail<\/code>,\n     * we advance <code>tail<\/code> and add empty elements. If it is between\n     * <code>head<\/code> and <code>tail<\/code>, we set the corresponding\n     * missing (or already present) element. If it is equal to\n     * <code>tail<\/code>, we advance the latter by 1 and add the message\n     * (default case).\n     */\n    public void add(long seqno, Message msg) {\n        long old_tail;\n\n        lock.writeLock();\n        try {\n            old_tail=tail;\n            if(seqno < head) {\n                if(log.isTraceEnabled())\n                    log.trace(\"seqno \" + seqno + \" is smaller than \" + head + \"); discarding message\");\n                return;\n            }\n\n            // add at end (regular expected msg)\n            if(seqno == tail) {\n                received_msgs.put(new Long(seqno), msg);\n                tail++;\n            }\n            // gap detected\n            // i. add placeholders, creating gaps\n            // ii. add real msg\n            // iii. tell retransmitter to retrieve missing msgs\n            else if(seqno > tail) {\n                for(long i=tail; i < seqno; i++) {\n                    received_msgs.put(new Long(i), null);\n                    // XmitEntry xmit_entry=new XmitEntry();\n                    //xmits.put(new Long(i), xmit_entry);\n                    tail++;\n                }\n                received_msgs.put(new Long(seqno), msg);\n                tail=seqno + 1;\n                if(retransmitter != null) {\n                    retransmitter.add(old_tail, seqno - 1);\n                }\n                // finally received missing message\n            }\n            else if(seqno < tail) {\n                if(log.isTraceEnabled())\n                    log.trace(\"added missing msg \" + msg.getSrc() + '#' + seqno);\n\n                Object val=received_msgs.get(new Long(seqno));\n                if(val == null) {\n                    // only set message if not yet received (bela July 23 2003)\n                    received_msgs.put(new Long(seqno), msg);\n\n                    //XmitEntry xmit_entry=(XmitEntry)xmits.get(new Long(seqno));\n                    //if(xmit_entry != null)\n                    //  xmit_entry.received=System.currentTimeMillis();\n                    //long xmit_diff=xmit_entry == null? -1 : xmit_entry.received - xmit_entry.created;\n                    //NAKACK.addXmitResponse(msg.getSrc(), seqno);\n                    if(retransmitter != null) retransmitter.remove(seqno);\n                }\n            }\n            updateLowestSeen();\n            updateHighestSeen();\n        }\n        finally {\n            lock.writeUnlock();\n        }\n    }","id":28271,"modified_method":"/**\n     * Adds a message according to its sequence number (ordered).\n     * <p>\n     * Variables <code>head<\/code> and <code>tail<\/code> mark the start and\n     * end of the messages received, but not delivered yet. When a message is\n     * received, if its seqno is smaller than <code>head<\/code>, it is\n     * discarded (already received). If it is bigger than <code>tail<\/code>,\n     * we advance <code>tail<\/code> and add empty elements. If it is between\n     * <code>head<\/code> and <code>tail<\/code>, we set the corresponding\n     * missing (or already present) element. If it is equal to\n     * <code>tail<\/code>, we advance the latter by 1 and add the message\n     * (default case).\n     */\n    public void add(long seqno, Message msg) {\n        long old_tail;\n\n        try {\n            lock.writeLock().acquire();\n            try {\n                old_tail=tail;\n                if(seqno < head) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"seqno \" + seqno + \" is smaller than \" + head + \"); discarding message\");\n                    return;\n                }\n\n                // add at end (regular expected msg)\n                if(seqno == tail) {\n                    received_msgs.put(new Long(seqno), msg);\n                    tail++;\n                }\n                // gap detected\n                // i. add placeholders, creating gaps\n                // ii. add real msg\n                // iii. tell retransmitter to retrieve missing msgs\n                else if(seqno > tail) {\n                    for(long i=tail; i < seqno; i++) {\n                        received_msgs.put(new Long(i), null);\n                        // XmitEntry xmit_entry=new XmitEntry();\n                        //xmits.put(new Long(i), xmit_entry);\n                        tail++;\n                    }\n                    received_msgs.put(new Long(seqno), msg);\n                    tail=seqno + 1;\n                    if(retransmitter != null) {\n                        retransmitter.add(old_tail, seqno - 1);\n                    }\n                    // finally received missing message\n                }\n                else if(seqno < tail) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"added missing msg \" + msg.getSrc() + '#' + seqno);\n\n                    Object val=received_msgs.get(new Long(seqno));\n                    if(val == null) {\n                        // only set message if not yet received (bela July 23 2003)\n                        received_msgs.put(new Long(seqno), msg);\n\n                        //XmitEntry xmit_entry=(XmitEntry)xmits.get(new Long(seqno));\n                        //if(xmit_entry != null)\n                        //  xmit_entry.received=System.currentTimeMillis();\n                        //long xmit_diff=xmit_entry == null? -1 : xmit_entry.received - xmit_entry.created;\n                        //NAKACK.addXmitResponse(msg.getSrc(), seqno);\n                        if(retransmitter != null) retransmitter.remove(seqno);\n                    }\n                }\n                updateLowestSeen();\n                updateHighestSeen();\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n        }\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the highest deliverable seqno, e.g. for 1,2,3,5,6 it would\n     * be 3.\n     *\n     * @see NakReceiverWindow#getHighestReceived\n     */\n    public long getHighestSeen() {\n        lock.readLock();\n        try {\n            return (highest_seen);\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28272,"modified_method":"/**\n     * Returns the highest deliverable seqno, e.g. for 1,2,3,5,6 it would\n     * be 3.\n     *\n     * @see NakReceiverWindow#getHighestReceived\n     */\n    public long getHighestSeen() {\n        try {\n            lock.readLock().acquire();\n            try {\n                return (highest_seen);\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return -1;\n        }\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Reset the retransmitter and the nak window<br>\n     */\n    public void reset() {\n        lock.writeLock();\n        try {\n            if(retransmitter != null)\n                retransmitter.reset();\n            _reset();\n        }\n        finally {\n            lock.writeUnlock();\n        }\n    }","id":28273,"modified_method":"/**\n     * Reset the retransmitter and the nak window<br>\n     */\n    public void reset() {\n        try {\n            lock.writeLock().acquire();\n            try {\n                if(retransmitter != null)\n                    retransmitter.reset();\n                _reset();\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n        }\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Return a list of all messages for which there is a seqno in\n     * <code>missing_msgs<\/code>. The seqnos of the argument list are\n     * supposed to be in ascending order\n     * @param missing_msgs A List<Long> of seqnos\n     * @return List<Message>\n     */\n    public List getMessagesInList(List missing_msgs) {\n        List ret=new List();\n\n        if(missing_msgs == null) {\n            if(log.isErrorEnabled()) log.error(\"argument list is null\");\n            return ret;\n        }\n\n        lock.readLock();\n        try {\n            Long seqno;\n            Message msg;\n            for(Enumeration en=missing_msgs.elements(); en.hasMoreElements();) {\n                seqno=(Long)en.nextElement();\n                msg=(Message)delivered_msgs.get(seqno);\n                if(msg != null)\n                    ret.add(msg.copy());\n                msg=(Message)received_msgs.get(seqno);\n                if(msg != null)\n                    ret.add(msg.copy());\n            }\n            return ret;\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28274,"modified_method":"/**\n     * Return a list of all messages for which there is a seqno in\n     * <code>missing_msgs<\/code>. The seqnos of the argument list are\n     * supposed to be in ascending order\n     * @param missing_msgs A List<Long> of seqnos\n     * @return List<Message>\n     */\n    public List getMessagesInList(List missing_msgs) {\n        List ret=new List();\n\n        if(missing_msgs == null) {\n            if(log.isErrorEnabled()) log.error(\"argument list is null\");\n            return ret;\n        }\n\n        try {\n            lock.readLock().acquire();\n            try {\n                Long seqno;\n                Message msg;\n                for(Enumeration en=missing_msgs.elements(); en.hasMoreElements();) {\n                    seqno=(Long)en.nextElement();\n                    msg=(Message)delivered_msgs.get(seqno);\n                    if(msg != null)\n                        ret.add(msg.copy());\n                    msg=(Message)received_msgs.get(seqno);\n                    if(msg != null)\n                        ret.add(msg.copy());\n                }\n                return ret;\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return null;\n        }\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n        StringBuffer sb=new StringBuffer();\n        lock.readLock();\n        try {\n            sb.append(\"received_msgs: \" + printReceivedMessages());\n            sb.append(\", delivered_msgs: \" + printDeliveredMessages());\n        }\n        finally {\n            lock.readUnlock();\n        }\n\n        return sb.toString();\n    }","id":28275,"modified_method":"public String toString() {\n        StringBuffer sb=new StringBuffer();\n        try {\n            lock.readLock().acquire();\n            try {\n                sb.append(\"received_msgs: \" + printReceivedMessages());\n                sb.append(\", delivered_msgs: \" + printDeliveredMessages());\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return \"\";\n        }\n\n        return sb.toString();\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the first entry (with the lowest seqno) from the received_msgs map if its associated message is not\n     * null, otherwise returns null. The entry is then added to delivered_msgs. If a bounded buffer is used: if message\n     * is not null: return it, else remove null messages until number of received messages drops below max size\n     * of bounded buffer\n     */\n   /* public Message remove() {\n        Message retval=null;\n        Object key;\n\n        lock.writeLock();\n        try {\n            if(received_msgs.size() > 0) {\n\n                if(log.isTraceEnabled())\n                    log.trace(\"received msgs=\" + received_msgs.size() + \"max_xmit_buf_size=\" + max_xmit_buf_size);\n\n                if(max_xmit_buf_size > 0 && received_msgs.size() > max_xmit_buf_size)\n                    return removeBounded();\n                key=received_msgs.firstKey();\n                retval=(Message)received_msgs.get(key);\n                if(retval != null) {\n                    received_msgs.remove(key);       // move from received_msgs to ...\n                    if(discard_delivered_msgs == false) {\n                        delivered_msgs.put(key, retval); // delivered_msgs\n                    }\n                    head++;\n                }\n            }\n            return retval;\n        }\n        finally {\n            lock.writeUnlock();\n        }\n    }*/\n\n\n     public Message remove() {\n        Message retval=null;\n        Long    key;\n        boolean bounded_buffer_enabled=max_xmit_buf_size > 0;\n\n        lock.writeLock();\n        try {\n            while(received_msgs.size() > 0) {\n                if(log.isTraceEnabled())\n                    log.trace(\"received msgs=\" + received_msgs.size() + \", max_xmit_buf_size=\" + max_xmit_buf_size);\n\n                key=(Long)received_msgs.firstKey();\n                retval=(Message)received_msgs.get(key);\n                if(retval != null) { // message exists and is ready for delivery\n                    received_msgs.remove(key);       // move from received_msgs to ...\n                    if(discard_delivered_msgs == false) {\n                        delivered_msgs.put(key, retval); // delivered_msgs\n                    }\n                    head++;  // is removed from retransmitter somewhere else (when missing message is received)\n                    return retval;\n                }\n                else { // message has not yet been received (gap in the message sequence stream)\n                    if(bounded_buffer_enabled && received_msgs.size() > max_xmit_buf_size) {\n                        received_msgs.remove(key);       // move from received_msgs to ...\n                        head++;\n                        retransmitter.remove(key.longValue());\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            return retval;\n        }\n        finally {\n            lock.writeUnlock();\n        }\n    }","id":28276,"modified_method":"public Message remove() {\n        Message retval=null;\n        Long    key;\n        boolean bounded_buffer_enabled=max_xmit_buf_size > 0;\n\n        try {\n            lock.writeLock().acquire();\n            try {\n                while(received_msgs.size() > 0) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"received msgs=\" + received_msgs.size() + \", max_xmit_buf_size=\" + max_xmit_buf_size);\n\n                    key=(Long)received_msgs.firstKey();\n                    retval=(Message)received_msgs.get(key);\n                    if(retval != null) { // message exists and is ready for delivery\n                        received_msgs.remove(key);       // move from received_msgs to ...\n                        if(discard_delivered_msgs == false) {\n                            delivered_msgs.put(key, retval); // delivered_msgs\n                        }\n                        head++;  // is removed from retransmitter somewhere else (when missing message is received)\n                        return retval;\n                    }\n                    else { // message has not yet been received (gap in the message sequence stream)\n                        if(bounded_buffer_enabled && received_msgs.size() > max_xmit_buf_size) {\n                            received_msgs.remove(key);       // move from received_msgs to ...\n                            head++;\n                            retransmitter.remove(key.longValue());\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n                return retval;\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n            return null;\n        }\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the highest sequence number received so far (which may be\n     * higher than the highest seqno <em>delivered<\/em> so far, e.g. for\n     * 1,2,3,5,6 it would be 6\n     *\n     * @see NakReceiverWindow#getHighestSeen\n     */\n    public long getHighestReceived() {\n        lock.readLock();\n        try {\n            return Math.max(tail - 1, -1);\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28277,"modified_method":"/**\n     * Returns the highest sequence number received so far (which may be\n     * higher than the highest seqno <em>delivered<\/em> so far, e.g. for\n     * 1,2,3,5,6 it would be 6\n     *\n     * @see NakReceiverWindow#getHighestSeen\n     */\n    public long getHighestReceived() {\n        try {\n            lock.readLock().acquire();\n            try {\n                return Math.max(tail - 1, -1);\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return -1;\n        }\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Stop the retransmitter and reset the nak window<br>\n     */\n    public void destroy() {\n        lock.writeLock();\n        try {\n            if(retransmitter != null)\n                retransmitter.stop();\n            _reset();\n        }\n        finally {\n            lock.writeUnlock();\n        }\n    }","id":28278,"modified_method":"/**\n     * Stop the retransmitter and reset the nak window<br>\n     */\n    public void destroy() {\n        try {\n            lock.writeLock().acquire();\n            try {\n                if(retransmitter != null)\n                    retransmitter.stop();\n                _reset();\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n        }\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Return all messages m for which the following holds:\n     * m > lower && m <= upper (excluding lower, including upper). Check both\n     * <code>received_msgs<\/code> and <code>delivered_msgs<\/code>.\n     */\n    public List getMessagesInRange(long lower, long upper) {\n        List retval=new List();\n\n        lock.readLock();\n        try {\n            // check received messages\n            SortedMap m=received_msgs.subMap(new Long(lower +1), new Long(upper +1));\n            for(Iterator it=m.values().iterator(); it.hasNext();) {\n                retval.add(it.next());\n            }\n\n            m=delivered_msgs.subMap(new Long(lower +1), new Long(upper +1));\n            for(Iterator it=m.values().iterator(); it.hasNext();) {\n                retval.add(((Message)it.next()).copy());\n            }\n            return retval;\n\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28279,"modified_method":"/**\n     * Return all messages m for which the following holds:\n     * m > lower && m <= upper (excluding lower, including upper). Check both\n     * <code>received_msgs<\/code> and <code>delivered_msgs<\/code>.\n     */\n    public List getMessagesInRange(long lower, long upper) {\n        List retval=new List();\n\n        try {\n            lock.readLock().acquire();\n            try {\n                // check received messages\n                SortedMap m=received_msgs.subMap(new Long(lower +1), new Long(upper +1));\n                for(Iterator it=m.values().iterator(); it.hasNext();) {\n                    retval.add(it.next());\n                }\n\n                m=delivered_msgs.subMap(new Long(lower +1), new Long(upper +1));\n                for(Iterator it=m.values().iterator(); it.hasNext();) {\n                    retval.add(((Message)it.next()).copy());\n                }\n                return retval;\n\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return null;\n        }\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Return messages that are higher than <code>seqno<\/code> (excluding\n     * <code>seqno<\/code>). Check both received <em>and<\/em> delivered\n     * messages.\n     * @return List<Message>. All messages that have a seqno greater than <code>seqno<\/code>\n     */\n    public List getMessagesHigherThan(long seqno) {\n        List retval=new List();\n\n        lock.readLock();\n        try {\n            // check received messages\n            SortedMap m=received_msgs.tailMap(new Long(seqno+1));\n            for(Iterator it=m.values().iterator(); it.hasNext();) {\n                retval.add((it.next()));\n            }\n\n            // we retrieve all msgs whose seqno is strictly greater than seqno (tailMap() *includes* seqno,\n            // but we need to exclude seqno, that's why we increment it\n            m=delivered_msgs.tailMap(new Long(seqno +1));\n            for(Iterator it=m.values().iterator(); it.hasNext();) {\n                retval.add(((Message)it.next()).copy());\n            }\n            return (retval);\n\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28280,"modified_method":"/**\n     * Return messages that are higher than <code>seqno<\/code> (excluding\n     * <code>seqno<\/code>). Check both received <em>and<\/em> delivered\n     * messages.\n     * @return List<Message>. All messages that have a seqno greater than <code>seqno<\/code>\n     */\n    public List getMessagesHigherThan(long seqno) {\n        List retval=new List();\n\n        try {\n            lock.readLock().acquire();\n            try {\n                // check received messages\n                SortedMap m=received_msgs.tailMap(new Long(seqno+1));\n                for(Iterator it=m.values().iterator(); it.hasNext();) {\n                    retval.add((it.next()));\n                }\n\n                // we retrieve all msgs whose seqno is strictly greater than seqno (tailMap() *includes* seqno,\n                // but we need to exclude seqno, that's why we increment it\n                m=delivered_msgs.tailMap(new Long(seqno +1));\n                for(Iterator it=m.values().iterator(); it.hasNext();) {\n                    retval.add(((Message)it.next()).copy());\n                }\n                return (retval);\n\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return null;\n        }\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"public int size() {\n        lock.readLock();\n        try {\n            return received_msgs.size();\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28281,"modified_method":"public int size() {\n        boolean acquired=false;\n        try {\n            lock.readLock().acquire();\n            acquired=true;\n        }\n        catch(InterruptedException e) {}\n        try {\n            return received_msgs.size();\n        }\n        finally {\n            if(acquired)\n                lock.readLock().release();\n        }\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * @return the lowest sequence number of a message that has been\n     * delivered or is a candidate for delivery (by the next call to\n     * <code>remove()<\/code>)\n     */\n    public long getLowestSeen() {\n        lock.readLock();\n        try {\n            return (lowest_seen);\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28282,"modified_method":"/**\n     * @return the lowest sequence number of a message that has been\n     * delivered or is a candidate for delivery (by the next call to\n     * <code>remove()<\/code>)\n     */\n    public long getLowestSeen() {\n        try {\n            lock.readLock().acquire();\n            try {\n                return (lowest_seen);\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return -1;\n        }\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * @return the highest sequence number of a message consumed by the\n     * application (by <code>remove()<\/code>)\n     */\n    public long getHighestDelivered() {\n        lock.readLock();\n        try {\n            return (Math.max(head - 1, -1));\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28283,"modified_method":"/**\n     * @return the highest sequence number of a message consumed by the\n     * application (by <code>remove()<\/code>)\n     */\n    public long getHighestDelivered() {\n        try {\n            lock.readLock().acquire();\n            try {\n                return (Math.max(head - 1, -1));\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return -1;\n        }\n    }","commit_id":"4e1dbd3be8c101b11a7d71c10863c080614dad06","url":"https://github.com/belaban/JGroups"},{"original_method":"public int size() {\n        lock.readLock();\n        try {\n            return received_msgs.size();\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28284,"modified_method":"public int size() {\n        boolean acquired=false;\n        try {\n            lock.readLock().acquire();\n            acquired=true;\n        }\n        catch(InterruptedException e) {}\n        try {\n            return received_msgs.size();\n        }\n        finally {\n            if(acquired)\n                lock.readLock().release();\n        }\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Find all messages between 'low' and 'high' (including 'low' and\n     * 'high') that have a null msg.\n     * Return them as a list of longs\n     *\n     * @return List<Long>. A list of seqnos, sorted in ascending order.\n     * E.g. [1, 4, 7, 8]\n     */\n    public List getMissingMessages(long low, long high) {\n        List retval=new List();\n        // long my_high;\n\n        if(low > high) {\n            if(log.isErrorEnabled()) log.error(\"invalid range: low (\" + low +\n                    \") is higher than high (\" + high + ')');\n            return null;\n        }\n\n        lock.readLock();\n        try {\n\n            // my_high=Math.max(head - 1, 0);\n            // check only received messages, because delivered messages *must* have a non-null msg\n            SortedMap m=received_msgs.subMap(new Long(low), new Long(high+1));\n            for(Iterator it=m.keySet().iterator(); it.hasNext();) {\n                retval.add(it.next());\n            }\n\n//            if(received_msgs.size() > 0) {\n//                entry=(Entry)received_msgs.peek();\n//                if(entry != null) my_high=entry.seqno;\n//            }\n//            for(long i=my_high + 1; i <= high; i++)\n//                retval.add(new Long(i));\n\n            return retval;\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28285,"modified_method":"/**\n     * Find all messages between 'low' and 'high' (including 'low' and\n     * 'high') that have a null msg.\n     * Return them as a list of longs\n     *\n     * @return List<Long>. A list of seqnos, sorted in ascending order.\n     * E.g. [1, 4, 7, 8]\n     */\n    public List getMissingMessages(long low, long high) {\n        List retval=new List();\n        // long my_high;\n\n        if(low > high) {\n            if(log.isErrorEnabled()) log.error(\"invalid range: low (\" + low +\n                    \") is higher than high (\" + high + ')');\n            return null;\n        }\n\n        try {\n            lock.readLock().acquire();\n            try {\n\n                // my_high=Math.max(head - 1, 0);\n                // check only received messages, because delivered messages *must* have a non-null msg\n                SortedMap m=received_msgs.subMap(new Long(low), new Long(high+1));\n                for(Iterator it=m.keySet().iterator(); it.hasNext();) {\n                    retval.add(it.next());\n                }\n\n//            if(received_msgs.size() > 0) {\n//                entry=(Entry)received_msgs.peek();\n//                if(entry != null) my_high=entry.seqno;\n//            }\n//            for(long i=my_high + 1; i <= high; i++)\n//                retval.add(new Long(i));\n\n                return retval;\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return null;\n        }\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Return a list of all messages for which there is a seqno in\n     * <code>missing_msgs<\/code>. The seqnos of the argument list are\n     * supposed to be in ascending order\n     * @param missing_msgs A List<Long> of seqnos\n     * @return List<Message>\n     */\n    public List getMessagesInList(List missing_msgs) {\n        List ret=new List();\n\n        if(missing_msgs == null) {\n            if(log.isErrorEnabled()) log.error(\"argument list is null\");\n            return ret;\n        }\n\n        lock.readLock();\n        try {\n            Long seqno;\n            Message msg;\n            for(Enumeration en=missing_msgs.elements(); en.hasMoreElements();) {\n                seqno=(Long)en.nextElement();\n                msg=(Message)delivered_msgs.get(seqno);\n                if(msg != null)\n                    ret.add(msg.copy());\n                msg=(Message)received_msgs.get(seqno);\n                if(msg != null)\n                    ret.add(msg.copy());\n            }\n            return ret;\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28286,"modified_method":"/**\n     * Return a list of all messages for which there is a seqno in\n     * <code>missing_msgs<\/code>. The seqnos of the argument list are\n     * supposed to be in ascending order\n     * @param missing_msgs A List<Long> of seqnos\n     * @return List<Message>\n     */\n    public List getMessagesInList(List missing_msgs) {\n        List ret=new List();\n\n        if(missing_msgs == null) {\n            if(log.isErrorEnabled()) log.error(\"argument list is null\");\n            return ret;\n        }\n\n        try {\n            lock.readLock().acquire();\n            try {\n                Long seqno;\n                Message msg;\n                for(Enumeration en=missing_msgs.elements(); en.hasMoreElements();) {\n                    seqno=(Long)en.nextElement();\n                    msg=(Message)delivered_msgs.get(seqno);\n                    if(msg != null)\n                        ret.add(msg.copy());\n                    msg=(Message)received_msgs.get(seqno);\n                    if(msg != null)\n                        ret.add(msg.copy());\n                }\n                return ret;\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return null;\n        }\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Stop the retransmitter and reset the nak window<br>\n     */\n    public void destroy() {\n        lock.writeLock();\n        try {\n            if(retransmitter != null)\n                retransmitter.stop();\n            _reset();\n        }\n        finally {\n            lock.writeUnlock();\n        }\n    }","id":28287,"modified_method":"/**\n     * Stop the retransmitter and reset the nak window<br>\n     */\n    public void destroy() {\n        try {\n            lock.writeLock().acquire();\n            try {\n                if(retransmitter != null)\n                    retransmitter.stop();\n                _reset();\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n        }\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the highest deliverable seqno, e.g. for 1,2,3,5,6 it would\n     * be 3.\n     *\n     * @see NakReceiverWindow#getHighestReceived\n     */\n    public long getHighestSeen() {\n        lock.readLock();\n        try {\n            return (highest_seen);\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28288,"modified_method":"/**\n     * Returns the highest deliverable seqno, e.g. for 1,2,3,5,6 it would\n     * be 3.\n     *\n     * @see NakReceiverWindow#getHighestReceived\n     */\n    public long getHighestSeen() {\n        try {\n            lock.readLock().acquire();\n            try {\n                return (highest_seen);\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return -1;\n        }\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Return all messages m for which the following holds:\n     * m > lower && m <= upper (excluding lower, including upper). Check both\n     * <code>received_msgs<\/code> and <code>delivered_msgs<\/code>.\n     */\n    public List getMessagesInRange(long lower, long upper) {\n        List retval=new List();\n\n        lock.readLock();\n        try {\n            // check received messages\n            SortedMap m=received_msgs.subMap(new Long(lower +1), new Long(upper +1));\n            for(Iterator it=m.values().iterator(); it.hasNext();) {\n                retval.add(it.next());\n            }\n\n            m=delivered_msgs.subMap(new Long(lower +1), new Long(upper +1));\n            for(Iterator it=m.values().iterator(); it.hasNext();) {\n                retval.add(((Message)it.next()).copy());\n            }\n            return retval;\n\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28289,"modified_method":"/**\n     * Return all messages m for which the following holds:\n     * m > lower && m <= upper (excluding lower, including upper). Check both\n     * <code>received_msgs<\/code> and <code>delivered_msgs<\/code>.\n     */\n    public List getMessagesInRange(long lower, long upper) {\n        List retval=new List();\n\n        try {\n            lock.readLock().acquire();\n            try {\n                // check received messages\n                SortedMap m=received_msgs.subMap(new Long(lower +1), new Long(upper +1));\n                for(Iterator it=m.values().iterator(); it.hasNext();) {\n                    retval.add(it.next());\n                }\n\n                m=delivered_msgs.subMap(new Long(lower +1), new Long(upper +1));\n                for(Iterator it=m.values().iterator(); it.hasNext();) {\n                    retval.add(((Message)it.next()).copy());\n                }\n                return retval;\n\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return null;\n        }\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds a message according to its sequence number (ordered).\n     * <p>\n     * Variables <code>head<\/code> and <code>tail<\/code> mark the start and\n     * end of the messages received, but not delivered yet. When a message is\n     * received, if its seqno is smaller than <code>head<\/code>, it is\n     * discarded (already received). If it is bigger than <code>tail<\/code>,\n     * we advance <code>tail<\/code> and add empty elements. If it is between\n     * <code>head<\/code> and <code>tail<\/code>, we set the corresponding\n     * missing (or already present) element. If it is equal to\n     * <code>tail<\/code>, we advance the latter by 1 and add the message\n     * (default case).\n     */\n    public void add(long seqno, Message msg) {\n        long old_tail;\n\n        lock.writeLock();\n        try {\n            old_tail=tail;\n            if(seqno < head) {\n                if(log.isTraceEnabled())\n                    log.trace(\"seqno \" + seqno + \" is smaller than \" + head + \"); discarding message\");\n                return;\n            }\n\n            // add at end (regular expected msg)\n            if(seqno == tail) {\n                received_msgs.put(new Long(seqno), msg);\n                tail++;\n            }\n            // gap detected\n            // i. add placeholders, creating gaps\n            // ii. add real msg\n            // iii. tell retransmitter to retrieve missing msgs\n            else if(seqno > tail) {\n                for(long i=tail; i < seqno; i++) {\n                    received_msgs.put(new Long(i), null);\n                    // XmitEntry xmit_entry=new XmitEntry();\n                    //xmits.put(new Long(i), xmit_entry);\n                    tail++;\n                }\n                received_msgs.put(new Long(seqno), msg);\n                tail=seqno + 1;\n                if(retransmitter != null) {\n                    retransmitter.add(old_tail, seqno - 1);\n                }\n                // finally received missing message\n            }\n            else if(seqno < tail) {\n                if(log.isTraceEnabled())\n                    log.trace(\"added missing msg \" + msg.getSrc() + '#' + seqno);\n\n                Object val=received_msgs.get(new Long(seqno));\n                if(val == null) {\n                    // only set message if not yet received (bela July 23 2003)\n                    received_msgs.put(new Long(seqno), msg);\n\n                    //XmitEntry xmit_entry=(XmitEntry)xmits.get(new Long(seqno));\n                    //if(xmit_entry != null)\n                    //  xmit_entry.received=System.currentTimeMillis();\n                    //long xmit_diff=xmit_entry == null? -1 : xmit_entry.received - xmit_entry.created;\n                    //NAKACK.addXmitResponse(msg.getSrc(), seqno);\n                    if(retransmitter != null) retransmitter.remove(seqno);\n                }\n            }\n            updateLowestSeen();\n            updateHighestSeen();\n        }\n        finally {\n            lock.writeUnlock();\n        }\n    }","id":28290,"modified_method":"/**\n     * Adds a message according to its sequence number (ordered).\n     * <p>\n     * Variables <code>head<\/code> and <code>tail<\/code> mark the start and\n     * end of the messages received, but not delivered yet. When a message is\n     * received, if its seqno is smaller than <code>head<\/code>, it is\n     * discarded (already received). If it is bigger than <code>tail<\/code>,\n     * we advance <code>tail<\/code> and add empty elements. If it is between\n     * <code>head<\/code> and <code>tail<\/code>, we set the corresponding\n     * missing (or already present) element. If it is equal to\n     * <code>tail<\/code>, we advance the latter by 1 and add the message\n     * (default case).\n     */\n    public void add(long seqno, Message msg) {\n        long old_tail;\n\n        try {\n            lock.writeLock().acquire();\n            try {\n                old_tail=tail;\n                if(seqno < head) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"seqno \" + seqno + \" is smaller than \" + head + \"); discarding message\");\n                    return;\n                }\n\n                // add at end (regular expected msg)\n                if(seqno == tail) {\n                    received_msgs.put(new Long(seqno), msg);\n                    tail++;\n                }\n                // gap detected\n                // i. add placeholders, creating gaps\n                // ii. add real msg\n                // iii. tell retransmitter to retrieve missing msgs\n                else if(seqno > tail) {\n                    for(long i=tail; i < seqno; i++) {\n                        received_msgs.put(new Long(i), null);\n                        // XmitEntry xmit_entry=new XmitEntry();\n                        //xmits.put(new Long(i), xmit_entry);\n                        tail++;\n                    }\n                    received_msgs.put(new Long(seqno), msg);\n                    tail=seqno + 1;\n                    if(retransmitter != null) {\n                        retransmitter.add(old_tail, seqno - 1);\n                    }\n                    // finally received missing message\n                }\n                else if(seqno < tail) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"added missing msg \" + msg.getSrc() + '#' + seqno);\n\n                    Object val=received_msgs.get(new Long(seqno));\n                    if(val == null) {\n                        // only set message if not yet received (bela July 23 2003)\n                        received_msgs.put(new Long(seqno), msg);\n\n                        //XmitEntry xmit_entry=(XmitEntry)xmits.get(new Long(seqno));\n                        //if(xmit_entry != null)\n                        //  xmit_entry.received=System.currentTimeMillis();\n                        //long xmit_diff=xmit_entry == null? -1 : xmit_entry.received - xmit_entry.created;\n                        //NAKACK.addXmitResponse(msg.getSrc(), seqno);\n                        if(retransmitter != null) retransmitter.remove(seqno);\n                    }\n                }\n                updateLowestSeen();\n                updateHighestSeen();\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n        }\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the highest sequence number received so far (which may be\n     * higher than the highest seqno <em>delivered<\/em> so far, e.g. for\n     * 1,2,3,5,6 it would be 6\n     *\n     * @see NakReceiverWindow#getHighestSeen\n     */\n    public long getHighestReceived() {\n        lock.readLock();\n        try {\n            return Math.max(tail - 1, -1);\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28291,"modified_method":"/**\n     * Returns the highest sequence number received so far (which may be\n     * higher than the highest seqno <em>delivered<\/em> so far, e.g. for\n     * 1,2,3,5,6 it would be 6\n     *\n     * @see NakReceiverWindow#getHighestSeen\n     */\n    public long getHighestReceived() {\n        try {\n            lock.readLock().acquire();\n            try {\n                return Math.max(tail - 1, -1);\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return -1;\n        }\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * @return the highest sequence number of a message consumed by the\n     * application (by <code>remove()<\/code>)\n     */\n    public long getHighestDelivered() {\n        lock.readLock();\n        try {\n            return (Math.max(head - 1, -1));\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28292,"modified_method":"/**\n     * @return the highest sequence number of a message consumed by the\n     * application (by <code>remove()<\/code>)\n     */\n    public long getHighestDelivered() {\n        try {\n            lock.readLock().acquire();\n            try {\n                return (Math.max(head - 1, -1));\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return -1;\n        }\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Delete all messages <= seqno (they are stable, that is, have been\n     * received at all members). Stop when a number > seqno is encountered\n     * (all messages are ordered on seqnos).\n     */\n    public void stable(long seqno) {\n        lock.writeLock();\n        try {\n            // we need to remove all seqnos *including* seqno: because headMap() *excludes* seqno, we\n            // simply increment it, so we have to correct behavior\n            SortedMap m=delivered_msgs.headMap(new Long(seqno +1));\n            if(m.size() > 0)\n                lowest_seen=Math.max(lowest_seen, ((Long)m.lastKey()).longValue());\n            m.clear(); // removes entries from delivered_msgs\n        }\n        finally {\n            lock.writeUnlock();\n        }\n    }","id":28293,"modified_method":"/**\n     * Delete all messages <= seqno (they are stable, that is, have been\n     * received at all members). Stop when a number > seqno is encountered\n     * (all messages are ordered on seqnos).\n     */\n    public void stable(long seqno) {\n        try {\n            lock.writeLock().acquire();\n            try {\n                // we need to remove all seqnos *including* seqno: because headMap() *excludes* seqno, we\n                // simply increment it, so we have to correct behavior\n                SortedMap m=delivered_msgs.headMap(new Long(seqno +1));\n                if(m.size() > 0)\n                    lowest_seen=Math.max(lowest_seen, ((Long)m.lastKey()).longValue());\n                m.clear(); // removes entries from delivered_msgs\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n        }\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * @return the lowest sequence number of a message that has been\n     * delivered or is a candidate for delivery (by the next call to\n     * <code>remove()<\/code>)\n     */\n    public long getLowestSeen() {\n        lock.readLock();\n        try {\n            return (lowest_seen);\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28294,"modified_method":"/**\n     * @return the lowest sequence number of a message that has been\n     * delivered or is a candidate for delivery (by the next call to\n     * <code>remove()<\/code>)\n     */\n    public long getLowestSeen() {\n        try {\n            lock.readLock().acquire();\n            try {\n                return (lowest_seen);\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return -1;\n        }\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Reset the retransmitter and the nak window<br>\n     */\n    public void reset() {\n        lock.writeLock();\n        try {\n            if(retransmitter != null)\n                retransmitter.reset();\n            _reset();\n        }\n        finally {\n            lock.writeUnlock();\n        }\n    }","id":28295,"modified_method":"/**\n     * Reset the retransmitter and the nak window<br>\n     */\n    public void reset() {\n        try {\n            lock.writeLock().acquire();\n            try {\n                if(retransmitter != null)\n                    retransmitter.reset();\n                _reset();\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n        }\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the first entry (with the lowest seqno) from the received_msgs map if its associated message is not\n     * null, otherwise returns null. The entry is then added to delivered_msgs. If a bounded buffer is used: if message\n     * is not null: return it, else remove null messages until number of received messages drops below max size\n     * of bounded buffer\n     */\n   /* public Message remove() {\n        Message retval=null;\n        Object key;\n\n        lock.writeLock();\n        try {\n            if(received_msgs.size() > 0) {\n\n                if(log.isTraceEnabled())\n                    log.trace(\"received msgs=\" + received_msgs.size() + \"max_xmit_buf_size=\" + max_xmit_buf_size);\n\n                if(max_xmit_buf_size > 0 && received_msgs.size() > max_xmit_buf_size)\n                    return removeBounded();\n                key=received_msgs.firstKey();\n                retval=(Message)received_msgs.get(key);\n                if(retval != null) {\n                    received_msgs.remove(key);       // move from received_msgs to ...\n                    if(discard_delivered_msgs == false) {\n                        delivered_msgs.put(key, retval); // delivered_msgs\n                    }\n                    head++;\n                }\n            }\n            return retval;\n        }\n        finally {\n            lock.writeUnlock();\n        }\n    }*/\n\n\n     public Message remove() {\n        Message retval=null;\n        Long    key;\n        boolean bounded_buffer_enabled=max_xmit_buf_size > 0;\n\n        lock.writeLock();\n        try {\n            while(received_msgs.size() > 0) {\n                if(log.isTraceEnabled())\n                    log.trace(\"received msgs=\" + received_msgs.size() + \", max_xmit_buf_size=\" + max_xmit_buf_size);\n\n                key=(Long)received_msgs.firstKey();\n                retval=(Message)received_msgs.get(key);\n                if(retval != null) { // message exists and is ready for delivery\n                    received_msgs.remove(key);       // move from received_msgs to ...\n                    if(discard_delivered_msgs == false) {\n                        delivered_msgs.put(key, retval); // delivered_msgs\n                    }\n                    head++;  // is removed from retransmitter somewhere else (when missing message is received)\n                    return retval;\n                }\n                else { // message has not yet been received (gap in the message sequence stream)\n                    if(bounded_buffer_enabled && received_msgs.size() > max_xmit_buf_size) {\n                        received_msgs.remove(key);       // move from received_msgs to ...\n                        head++;\n                        retransmitter.remove(key.longValue());\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            return retval;\n        }\n        finally {\n            lock.writeUnlock();\n        }\n    }","id":28296,"modified_method":"public Message remove() {\n        Message retval=null;\n        Long    key;\n        boolean bounded_buffer_enabled=max_xmit_buf_size > 0;\n\n        try {\n            lock.writeLock().acquire();\n            try {\n                while(received_msgs.size() > 0) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"received msgs=\" + received_msgs.size() + \", max_xmit_buf_size=\" + max_xmit_buf_size);\n\n                    key=(Long)received_msgs.firstKey();\n                    retval=(Message)received_msgs.get(key);\n                    if(retval != null) { // message exists and is ready for delivery\n                        received_msgs.remove(key);       // move from received_msgs to ...\n                        if(discard_delivered_msgs == false) {\n                            delivered_msgs.put(key, retval); // delivered_msgs\n                        }\n                        head++;  // is removed from retransmitter somewhere else (when missing message is received)\n                        return retval;\n                    }\n                    else { // message has not yet been received (gap in the message sequence stream)\n                        if(bounded_buffer_enabled && received_msgs.size() > max_xmit_buf_size) {\n                            received_msgs.remove(key);       // move from received_msgs to ...\n                            head++;\n                            retransmitter.remove(key.longValue());\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n                return retval;\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n            return null;\n        }\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n        StringBuffer sb=new StringBuffer();\n        lock.readLock();\n        try {\n            sb.append(\"received_msgs: \" + printReceivedMessages());\n            sb.append(\", delivered_msgs: \" + printDeliveredMessages());\n        }\n        finally {\n            lock.readUnlock();\n        }\n\n        return sb.toString();\n    }","id":28297,"modified_method":"public String toString() {\n        StringBuffer sb=new StringBuffer();\n        try {\n            lock.readLock().acquire();\n            try {\n                sb.append(\"received_msgs: \" + printReceivedMessages());\n                sb.append(\", delivered_msgs: \" + printDeliveredMessages());\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return \"\";\n        }\n\n        return sb.toString();\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Return messages that are higher than <code>seqno<\/code> (excluding\n     * <code>seqno<\/code>). Check both received <em>and<\/em> delivered\n     * messages.\n     * @return List<Message>. All messages that have a seqno greater than <code>seqno<\/code>\n     */\n    public List getMessagesHigherThan(long seqno) {\n        List retval=new List();\n\n        lock.readLock();\n        try {\n            // check received messages\n            SortedMap m=received_msgs.tailMap(new Long(seqno+1));\n            for(Iterator it=m.values().iterator(); it.hasNext();) {\n                retval.add((it.next()));\n            }\n\n            // we retrieve all msgs whose seqno is strictly greater than seqno (tailMap() *includes* seqno,\n            // but we need to exclude seqno, that's why we increment it\n            m=delivered_msgs.tailMap(new Long(seqno +1));\n            for(Iterator it=m.values().iterator(); it.hasNext();) {\n                retval.add(((Message)it.next()).copy());\n            }\n            return (retval);\n\n        }\n        finally {\n            lock.readUnlock();\n        }\n    }","id":28298,"modified_method":"/**\n     * Return messages that are higher than <code>seqno<\/code> (excluding\n     * <code>seqno<\/code>). Check both received <em>and<\/em> delivered\n     * messages.\n     * @return List<Message>. All messages that have a seqno greater than <code>seqno<\/code>\n     */\n    public List getMessagesHigherThan(long seqno) {\n        List retval=new List();\n\n        try {\n            lock.readLock().acquire();\n            try {\n                // check received messages\n                SortedMap m=received_msgs.tailMap(new Long(seqno+1));\n                for(Iterator it=m.values().iterator(); it.hasNext();) {\n                    retval.add((it.next()));\n                }\n\n                // we retrieve all msgs whose seqno is strictly greater than seqno (tailMap() *includes* seqno,\n                // but we need to exclude seqno, that's why we increment it\n                m=delivered_msgs.tailMap(new Long(seqno +1));\n                for(Iterator it=m.values().iterator(); it.hasNext();) {\n                    retval.add(((Message)it.next()).copy());\n                }\n                return (retval);\n\n            }\n            finally {\n                lock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring read lock\", e);\n            return null;\n        }\n    }","commit_id":"deecca280b6c206c1afee11bddb8d4f53110cff8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Handle the stop() method travelling down the stack.\n\t * <p>\n\t * The local addr is set to null, since after a Start->Stop->Start\n\t * sequence this member's addr is not guaranteed to be the same\n\t *\n\t */\n    public void stop() {\n        // *** Get an exclusive lock\n        try {\n            stateLock.writeLock(); \n            try {\n                state = NULL_STATE;\n                retransmitter.reset();\n                reqTbl.clear();\n                upTbl.clear();\n                addr = null;\n                \n                // *** Revoke the exclusive lock\n            }\n            finally {\n                stateLock.writeUnlock();\n            }\n        }\n        catch(RWLock.IntException ex) {\n            if(log.isErrorEnabled()) log.error(ex.getMessage());\n        }\n    }","id":28299,"modified_method":"/**\n     * Handle the stop() method travelling down the stack.\n     * <p/>\n     * The local addr is set to null, since after a Start->Stop->Start\n     * sequence this member's addr is not guaranteed to be the same\n     */\n    public void stop() {\n        try {\n            stateLock.writeLock().acquire();\n            try {\n                state=NULL_STATE;\n                retransmitter.reset();\n                reqTbl.clear();\n                upTbl.clear();\n                addr=null;\n            }\n            finally {\n                stateLock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(e.getMessage());\n        }\n    }","commit_id":"c266d56a93f7ed68da4a60d2ac9fcb2ec5453252","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Resend the bcast request with the given localSeqID\n\t *\n\t * @param seqID the local sequence id of the\n\t */\n\tprivate void _retransmitBcastRequest(long seqID) {\n\t\t// *** Get a shared lock\n\t\ttry { stateLock.readLock(); try {\n\n\t\tif(log.isInfoEnabled()) log.info(\"Retransmit BCAST_REQ[\" + seqID + ']');\n\t\t_transmitBcastRequest(seqID);\n\n\t\t// ** Revoke the shared lock\n\t\t} finally { stateLock.readUnlock(); }\n\t\t} catch(RWLock.IntException ex) {\n\t\tif(log.isErrorEnabled()) log.error(ex.getMessage());\n\t\t}\n\t}","id":28300,"modified_method":"/**\n     * Resend the bcast request with the given localSeqID\n     *\n     * @param seqID the local sequence id of the\n     */\n    private void _retransmitBcastRequest(long seqID) {\n        // *** Get a shared lock\n        try {\n            stateLock.readLock().acquire();\n            try {\n                if(log.isInfoEnabled()) log.info(\"Retransmit BCAST_REQ[\" + seqID + ']');\n                _transmitBcastRequest(seqID);\n            }\n            finally {\n                stateLock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring a read lock\", e);\n        }\n    }","commit_id":"c266d56a93f7ed68da4a60d2ac9fcb2ec5453252","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * A MSG event travelling down the stack. Forward unicast messages, treat\n\t * specially the broadcast messages.<br>\n\t *\n\t * If in <code>BLOCK<\/code> state, i.e. it has replied to a\n\t * <code>BLOCk_OK<\/code> and hasn't yet received a\n\t * <code>VIEW_CHANGE<\/code> event, messages are discarded<br>\n\t *\n\t * If in <code>FLUSH<\/code> state, forward unicast but queue broadcasts\n\t *\n\t * @param event the MSG event\n\t * @return true if event should travel further down\n\t */\n\tprivate boolean _downMsg(Event event) {\n\t\tMessage msg;\n\n\t\t// *** Get a shared lock\n\t\ttry { stateLock.readLock(); try {\n\n\t\t// i. Discard all msgs, if in NULL_STATE\n\t\t// ii. Discard all msgs, if blocked\n\t\tif (state == NULL_STATE) {\n\t\t\tif(log.isErrorEnabled()) log.error(\"Discard msg in NULL_STATE\");\n\t\t\treturn(false);\n\t\t}\n\t\tif (state == BLOCK) {\n\t\t\tif(log.isErrorEnabled()) log.error(\"Blocked, discard msg\");\n\t\t\treturn(false);\n\t\t}\n\n\t\tmsg = (Message)event.getArg();\n\t\tif (msg.getDest() == null) {\n\t\t\t_sendBcastRequest(msg);\n\t\t\treturn(false);\n\t\t} else {\n\t\t\tmsg = _sendUcast(msg);\n\t\t\tevent.setArg(msg);\n\t\t}\n\n\t\t// ** Revoke the shared lock\n\t\t} finally { stateLock.readUnlock(); }\n\t\t} catch(RWLock.IntException ex) {\n\t\tif(log.isErrorEnabled()) log.error(ex.getMessage());\n\t\t}\n\n\t\treturn(true);\n\t}","id":28301,"modified_method":"/**\n     * A MSG event travelling down the stack. Forward unicast messages, treat\n     * specially the broadcast messages.<br>\n     * <p/>\n     * If in <code>BLOCK<\/code> state, i.e. it has replied to a\n     * <code>BLOCk_OK<\/code> and hasn't yet received a\n     * <code>VIEW_CHANGE<\/code> event, messages are discarded<br>\n     * <p/>\n     * If in <code>FLUSH<\/code> state, forward unicast but queue broadcasts\n     *\n     * @param event the MSG event\n     * @return true if event should travel further down\n     */\n    private boolean _downMsg(Event event) {\n        Message msg;\n\n        // *** Get a shared lock\n        try {\n            stateLock.readLock().acquire();\n            try {\n\n                // i. Discard all msgs, if in NULL_STATE\n                // ii. Discard all msgs, if blocked\n                if(state == NULL_STATE) {\n                    if(log.isErrorEnabled()) log.error(\"Discard msg in NULL_STATE\");\n                    return (false);\n                }\n                if(state == BLOCK) {\n                    if(log.isErrorEnabled()) log.error(\"Blocked, discard msg\");\n                    return (false);\n                }\n\n                msg=(Message)event.getArg();\n                if(msg.getDest() == null) {\n                    _sendBcastRequest(msg);\n                    return (false);\n                }\n                else {\n                    msg=_sendUcast(msg);\n                    event.setArg(msg);\n                }\n\n                // ** Revoke the shared lock\n            }\n            finally {\n                stateLock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(e.getMessage());\n        }\n\n        return (true);\n    }","commit_id":"c266d56a93f7ed68da4a60d2ac9fcb2ec5453252","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Prepare for a VIEW_CHANGE: switch to flushing state\n\t *\n\t * @return true if the event is to be forwarded further up\n\t */\n\tprivate boolean _upBlock() {\n\t\t// *** Get an exclusive lock\n\t\ttry { stateLock.writeLock(); try {\n\n\t\tstate = FLUSH;\n\n\t\t// *** Revoke the exclusive lock\n\t\t} finally { stateLock.writeUnlock(); }\n\t\t} catch(RWLock.IntException ex) {\n\t\tif(log.isErrorEnabled()) log.error(ex.getMessage());\n\t\t}\n\n\t\treturn(true);\n\t}","id":28302,"modified_method":"/**\n     * Prepare for a VIEW_CHANGE: switch to flushing state\n     *\n     * @return true if the event is to be forwarded further up\n     */\n    private boolean _upBlock() {\n        // *** Get an exclusive lock\n        try {\n            stateLock.writeLock().acquire();\n            try {\n                state=FLUSH;\n                // *** Revoke the exclusive lock\n            }\n            finally {\n                stateLock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring the write lock\", e);\n        }\n\n        return (true);\n    }","commit_id":"c266d56a93f7ed68da4a60d2ac9fcb2ec5453252","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Handle view changes\n\t *\n\t * param event the VIEW_CHANGE event\n\t * @return true if the event should be forwarded to the layer above\n\t */\n\tprivate boolean _upViewChange(Event event) {\n\t\tObject oldSequencerAddr;\n\n\t\t// *** Get an exclusive lock\n\t\ttry { stateLock.writeLock(); try {\n\n\t\tstate = RUN;\n\n\t\t// i. See if this member is the sequencer\n\t\t// ii. If this is the sequencer, reset the sequencer's sequence ID\n\t\t// iii. Reset the last received sequence ID\n\t\t//\n\t\t// iv. Replay undelivered bcasts: Put all the undelivered bcasts\n\t\t// sent by us back to the req queue and discard the rest\n\t\toldSequencerAddr = sequencerAddr;\n\t\tsequencerAddr   =\n\t\t\t(Address)((View)event.getArg()).getMembers().elementAt(0);\n\t\tif (addr.equals(sequencerAddr)) {\n\t\t\tsequencerSeqID = NULL_ID;\n\t\t\tif ((oldSequencerAddr == null) ||\n\t\t\t\t(!addr.equals(oldSequencerAddr)))\n\t\t\t\tif(log.isInfoEnabled()) log.info(\"I'm the new sequencer\");\n\t\t}\n\t\tseqID = NULL_ID;\n\t\t_replayBcast();\n\n\t\t// *** Revoke the exclusive lock\n\t\t} finally { stateLock.writeUnlock(); }\n\t\t} catch(RWLock.IntException ex) {\n\t\tif(log.isErrorEnabled()) log.error(ex.getMessage());\n\t\t}\n\n\t\treturn(true);\n\t}","id":28303,"modified_method":"/**\n     * Handle view changes\n     * <p/>\n     * param event the VIEW_CHANGE event\n     *\n     * @return true if the event should be forwarded to the layer above\n     */\n    private boolean _upViewChange(Event event) {\n        Object oldSequencerAddr;\n\n        // *** Get an exclusive lock\n        try {\n            stateLock.writeLock().acquire();\n            try {\n\n                state=RUN;\n\n                // i. See if this member is the sequencer\n                // ii. If this is the sequencer, reset the sequencer's sequence ID\n                // iii. Reset the last received sequence ID\n                //\n                // iv. Replay undelivered bcasts: Put all the undelivered bcasts\n                // sent by us back to the req queue and discard the rest\n                oldSequencerAddr=sequencerAddr;\n                sequencerAddr=\n                        (Address)((View)event.getArg()).getMembers().elementAt(0);\n                if(addr.equals(sequencerAddr)) {\n                    sequencerSeqID=NULL_ID;\n                    if((oldSequencerAddr == null) ||\n                            (!addr.equals(oldSequencerAddr)))\n                        if(log.isInfoEnabled()) log.info(\"I'm the new sequencer\");\n                }\n                seqID=NULL_ID;\n                _replayBcast();\n\n                // *** Revoke the exclusive lock\n            }\n            finally {\n                stateLock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(e.getMessage());\n        }\n\n        return (true);\n    }","commit_id":"c266d56a93f7ed68da4a60d2ac9fcb2ec5453252","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Set the address of this group member\n\t *\n\t * @param event the SET_LOCAL_ADDRESS event\n\t * @return true if event should be forwarded further up\n\t */\n\tprivate boolean _upSetLocalAddress(Event event) {\n\t\t// *** Get an exclusive lock\n\t\ttry { stateLock.writeLock(); try {\n\n\t\taddr  = (Address)event.getArg();\n\n\t\t// *** Revoke the exclusive lock\n\t\t} finally { stateLock.writeUnlock(); }\n\t\t} catch(RWLock.IntException ex) {\n\t\tif(log.isErrorEnabled()) log.error(ex.getMessage());\n\t\t}\n\t\treturn(true);\n\t}","id":28304,"modified_method":"/**\n     * Set the address of this group member\n     *\n     * @param event the SET_LOCAL_ADDRESS event\n     * @return true if event should be forwarded further up\n     */\n    private boolean _upSetLocalAddress(Event event) {\n        // *** Get an exclusive lock\n        try {\n            stateLock.writeLock().acquire();\n            try {\n                addr=(Address)event.getArg();\n            }\n            finally {\n                stateLock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(e.getMessage());\n        }\n        return (true);\n    }","commit_id":"c266d56a93f7ed68da4a60d2ac9fcb2ec5453252","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Blocking confirmed - No messages should come from above until a\n\t * VIEW_CHANGE event is received. Switch to blocking state.\n\t *\n\t * @return true if event should travel further down\n\t */\n\tprivate boolean _downBlockOk() {\n\t\t// *** Get an exclusive lock\n\t\ttry { stateLock.writeLock(); try {\n\n\t\tstate = BLOCK;\n\n\t\t// *** Revoke the exclusive lock\n\t\t} finally { stateLock.writeUnlock(); }\n\t\t} catch(RWLock.IntException ex) {\n\t\tif(log.isErrorEnabled()) log.error(ex.getMessage());\n\t\t}\n\n\t\treturn(true);\n\t}","id":28305,"modified_method":"/**\n     * Blocking confirmed - No messages should come from above until a\n     * VIEW_CHANGE event is received. Switch to blocking state.\n     *\n     * @return true if event should travel further down\n     */\n    private boolean _downBlockOk() {\n        // *** Get an exclusive lock\n        try {\n            stateLock.writeLock().acquire();\n            try {\n                state=BLOCK;\n            }\n            finally {\n                stateLock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(e.getMessage());\n        }\n\n        return (true);\n    }","commit_id":"c266d56a93f7ed68da4a60d2ac9fcb2ec5453252","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Handle an up MSG event\n\t *\n\t * @param event the MSG event\n\t * @return true if the event is to be forwarded further up\n\t */\n\tprivate boolean _upMsg(Event event) {\n\t\tMessage msg;\n\t\tObject  obj;\n\t\tHeader  header;\n\n\t\t// *** Get a shared lock\n\t\ttry { stateLock.readLock(); try {\n\n\t\t// If NULL_STATE, shouldn't receive any msg on the up queue!\n\t\tif (state == NULL_STATE) {\n\t\t\tif(log.isErrorEnabled()) log.error(\"Up msg in NULL_STATE\");\n\t\t\treturn(false);\n\t\t}\n\n\t\t// Peek the header:\n\t\t//\n\t\t// (UCAST) A unicast message - Send up the stack\n\t\t// (BCAST) A broadcast message - Handle specially\n\t\t// (REQ) A broadcast request - Handle specially\n\t\t// (REP) A broadcast reply from the sequencer - Handle specially\n\t\tmsg = (Message)event.getArg();\n\t\tif (!((obj = msg.getHeader(getName())) instanceof TOTAL.Header)) {\n\t\t\tif(log.isErrorEnabled()) log.error(\"No TOTAL.Header found\");\n\t\t\treturn(false);\n\t\t}\n\t\theader = (Header)obj;\n\n\t\tswitch(header.type) {\n\t\tcase Header.UCAST:\n\t\t\t_recvUcast(msg);\n\t\t\treturn(true);\n\t\tcase Header.BCAST:\n\t\t\t_recvBcast(msg);\n\t\t\treturn(false);\n\t\tcase Header.REQ:\n\t\t\t_recvBcastRequest(msg);\n\t\t\treturn(false);\n\t\tcase Header.REP:\n\t\t\t_recvBcastReply(header);\n\t\t\treturn(false);\n\t\tdefault:\n\t\t\tif(log.isErrorEnabled()) log.error(\"Unknown header type\");\n\t\t\treturn(false);\n\t\t}\n\n\t\t// ** Revoke the shared lock\n\t\t} finally { stateLock.readUnlock(); }\n\t\t} catch(RWLock.IntException ex) {\n\t\tif(log.isErrorEnabled()) log.error(ex.getMessage());\n\t\t}\n\n\t\treturn(true);\n\t}","id":28306,"modified_method":"/**\n     * Handle an up MSG event\n     *\n     * @param event the MSG event\n     * @return true if the event is to be forwarded further up\n     */\n    private boolean _upMsg(Event event) {\n        Message msg;\n        Object obj;\n        Header header;\n\n        // *** Get a shared lock\n        try {\n            stateLock.readLock().acquire();\n            try {\n\n                // If NULL_STATE, shouldn't receive any msg on the up queue!\n                if(state == NULL_STATE) {\n                    if(log.isErrorEnabled()) log.error(\"Up msg in NULL_STATE\");\n                    return (false);\n                }\n\n                // Peek the header:\n                //\n                // (UCAST) A unicast message - Send up the stack\n                // (BCAST) A broadcast message - Handle specially\n                // (REQ) A broadcast request - Handle specially\n                // (REP) A broadcast reply from the sequencer - Handle specially\n                msg=(Message)event.getArg();\n                if(!((obj=msg.getHeader(getName())) instanceof TOTAL.Header)) {\n                    if(log.isErrorEnabled()) log.error(\"No TOTAL.Header found\");\n                    return (false);\n                }\n                header=(Header)obj;\n\n                switch(header.type) {\n                case Header.UCAST:\n                    _recvUcast(msg);\n                    return (true);\n                case Header.BCAST:\n                    _recvBcast(msg);\n                    return (false);\n                case Header.REQ:\n                    _recvBcastRequest(msg);\n                    return (false);\n                case Header.REP:\n                    _recvBcastReply(header);\n                    return (false);\n                default:\n                    if(log.isErrorEnabled()) log.error(\"Unknown header type\");\n                    return (false);\n                }\n\n                // ** Revoke the shared lock\n            }\n            finally {\n                stateLock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            if(log.isErrorEnabled()) log.error(e.getMessage());\n        }\n\n        return (true);\n    }","commit_id":"c266d56a93f7ed68da4a60d2ac9fcb2ec5453252","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Handle an up MSG event\n\t *\n\t * @param event the MSG event\n\t * @return true if the event is to be forwarded further up\n\t */\n\tprivate boolean _upMsg(Event event) {\n\t\tMessage msg;\n\t\tObject  obj;\n\t\tHeader  header;\n\n\t\t// *** Get a shared lock\n\t\ttry { stateLock.readLock(); try {\n\n\t\t// If NULL_STATE, shouldn't receive any msg on the up queue!\n\t\tif (state == NULL_STATE) {\n\t\t\tif(log.isErrorEnabled()) log.error(\"Up msg in NULL_STATE\");\n\t\t\treturn(false);\n\t\t}\n\n\t\t// Peek the header:\n\t\t//\n\t\t// (UCAST) A unicast message - Send up the stack\n\t\t// (BCAST) A broadcast message - Handle specially\n\t\t// (REQ) A broadcast request - Handle specially\n\t\t// (REP) A broadcast reply from the sequencer - Handle specially\n\t\tmsg = (Message)event.getArg();\n\t\tif (!((obj = msg.getHeader(getName())) instanceof TOTAL.Header)) {\n\t\t\tif(log.isErrorEnabled()) log.error(\"No TOTAL.Header found\");\n\t\t\treturn(false);\n\t\t}\n\t\theader = (Header)obj;\n\n\t\tswitch(header.type) {\n\t\tcase Header.UCAST:\n\t\t\t_recvUcast(msg);\n\t\t\treturn(true);\n\t\tcase Header.BCAST:\n\t\t\t_recvBcast(msg);\n\t\t\treturn(false);\n\t\tcase Header.REQ:\n\t\t\t_recvBcastRequest(msg);\n\t\t\treturn(false);\n\t\tcase Header.REP:\n\t\t\t_recvBcastReply(header);\n\t\t\treturn(false);\n\t\tdefault:\n\t\t\tif(log.isErrorEnabled()) log.error(\"Unknown header type\");\n\t\t\treturn(false);\n\t\t}\n\n\t\t// ** Revoke the shared lock\n\t\t} finally { stateLock.readUnlock(); }\n\t\t} catch(RWLock.IntException ex) {\n\t\tif(log.isErrorEnabled()) log.error(ex.getMessage());\n\t\t}\n\n\t\treturn(true);\n\t}","id":28307,"modified_method":"/**\n     * Handle an up MSG event\n     *\n     * @param event the MSG event\n     * @return true if the event is to be forwarded further up\n     */\n    private boolean _upMsg(Event event) {\n        Message msg;\n        Object obj;\n        Header header;\n\n        // *** Get a shared lock\n        try {\n            stateLock.readLock().acquire();\n            try {\n\n                // If NULL_STATE, shouldn't receive any msg on the up queue!\n                if(state == NULL_STATE) {\n                    if(log.isErrorEnabled()) log.error(\"Up msg in NULL_STATE\");\n                    return (false);\n                }\n\n                // Peek the header:\n                //\n                // (UCAST) A unicast message - Send up the stack\n                // (BCAST) A broadcast message - Handle specially\n                // (REQ) A broadcast request - Handle specially\n                // (REP) A broadcast reply from the sequencer - Handle specially\n                msg=(Message)event.getArg();\n                if(!((obj=msg.getHeader(getName())) instanceof TOTAL.Header)) {\n                    if(log.isErrorEnabled()) log.error(\"No TOTAL.Header found\");\n                    return (false);\n                }\n                header=(Header)obj;\n\n                switch(header.type) {\n                case Header.UCAST:\n                    _recvUcast(msg);\n                    return (true);\n                case Header.BCAST:\n                    _recvBcast(msg);\n                    return (false);\n                case Header.REQ:\n                    _recvBcastRequest(msg);\n                    return (false);\n                case Header.REP:\n                    _recvBcastReply(header);\n                    return (false);\n                default:\n                    if(log.isErrorEnabled()) log.error(\"Unknown header type\");\n                    return (false);\n                }\n\n                // ** Revoke the shared lock\n            }\n            finally {\n                stateLock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            if(log.isErrorEnabled()) log.error(e.getMessage());\n        }\n\n        return (true);\n    }","commit_id":"a091e13570cc7a40ee18d09c9583925fbf76f38e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Blocking confirmed - No messages should come from above until a\n\t * VIEW_CHANGE event is received. Switch to blocking state.\n\t *\n\t * @return true if event should travel further down\n\t */\n\tprivate boolean _downBlockOk() {\n\t\t// *** Get an exclusive lock\n\t\ttry { stateLock.writeLock(); try {\n\n\t\tstate = BLOCK;\n\n\t\t// *** Revoke the exclusive lock\n\t\t} finally { stateLock.writeUnlock(); }\n\t\t} catch(RWLock.IntException ex) {\n\t\tif(log.isErrorEnabled()) log.error(ex.getMessage());\n\t\t}\n\n\t\treturn(true);\n\t}","id":28308,"modified_method":"/**\n     * Blocking confirmed - No messages should come from above until a\n     * VIEW_CHANGE event is received. Switch to blocking state.\n     *\n     * @return true if event should travel further down\n     */\n    private boolean _downBlockOk() {\n        // *** Get an exclusive lock\n        try {\n            stateLock.writeLock().acquire();\n            try {\n                state=BLOCK;\n            }\n            finally {\n                stateLock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(e.getMessage());\n        }\n\n        return (true);\n    }","commit_id":"a091e13570cc7a40ee18d09c9583925fbf76f38e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Handle view changes\n\t *\n\t * param event the VIEW_CHANGE event\n\t * @return true if the event should be forwarded to the layer above\n\t */\n\tprivate boolean _upViewChange(Event event) {\n\t\tObject oldSequencerAddr;\n\n\t\t// *** Get an exclusive lock\n\t\ttry { stateLock.writeLock(); try {\n\n\t\tstate = RUN;\n\n\t\t// i. See if this member is the sequencer\n\t\t// ii. If this is the sequencer, reset the sequencer's sequence ID\n\t\t// iii. Reset the last received sequence ID\n\t\t//\n\t\t// iv. Replay undelivered bcasts: Put all the undelivered bcasts\n\t\t// sent by us back to the req queue and discard the rest\n\t\toldSequencerAddr = sequencerAddr;\n\t\tsequencerAddr   =\n\t\t\t(Address)((View)event.getArg()).getMembers().elementAt(0);\n\t\tif (addr.equals(sequencerAddr)) {\n\t\t\tsequencerSeqID = NULL_ID;\n\t\t\tif ((oldSequencerAddr == null) ||\n\t\t\t\t(!addr.equals(oldSequencerAddr)))\n\t\t\t\tif(log.isInfoEnabled()) log.info(\"I'm the new sequencer\");\n\t\t}\n\t\tseqID = NULL_ID;\n\t\t_replayBcast();\n\n\t\t// *** Revoke the exclusive lock\n\t\t} finally { stateLock.writeUnlock(); }\n\t\t} catch(RWLock.IntException ex) {\n\t\tif(log.isErrorEnabled()) log.error(ex.getMessage());\n\t\t}\n\n\t\treturn(true);\n\t}","id":28309,"modified_method":"/**\n     * Handle view changes\n     * <p/>\n     * param event the VIEW_CHANGE event\n     *\n     * @return true if the event should be forwarded to the layer above\n     */\n    private boolean _upViewChange(Event event) {\n        Object oldSequencerAddr;\n\n        // *** Get an exclusive lock\n        try {\n            stateLock.writeLock().acquire();\n            try {\n\n                state=RUN;\n\n                // i. See if this member is the sequencer\n                // ii. If this is the sequencer, reset the sequencer's sequence ID\n                // iii. Reset the last received sequence ID\n                //\n                // iv. Replay undelivered bcasts: Put all the undelivered bcasts\n                // sent by us back to the req queue and discard the rest\n                oldSequencerAddr=sequencerAddr;\n                sequencerAddr=\n                        (Address)((View)event.getArg()).getMembers().elementAt(0);\n                if(addr.equals(sequencerAddr)) {\n                    sequencerSeqID=NULL_ID;\n                    if((oldSequencerAddr == null) ||\n                            (!addr.equals(oldSequencerAddr)))\n                        if(log.isInfoEnabled()) log.info(\"I'm the new sequencer\");\n                }\n                seqID=NULL_ID;\n                _replayBcast();\n\n                // *** Revoke the exclusive lock\n            }\n            finally {\n                stateLock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(e.getMessage());\n        }\n\n        return (true);\n    }","commit_id":"a091e13570cc7a40ee18d09c9583925fbf76f38e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Prepare for a VIEW_CHANGE: switch to flushing state\n\t *\n\t * @return true if the event is to be forwarded further up\n\t */\n\tprivate boolean _upBlock() {\n\t\t// *** Get an exclusive lock\n\t\ttry { stateLock.writeLock(); try {\n\n\t\tstate = FLUSH;\n\n\t\t// *** Revoke the exclusive lock\n\t\t} finally { stateLock.writeUnlock(); }\n\t\t} catch(RWLock.IntException ex) {\n\t\tif(log.isErrorEnabled()) log.error(ex.getMessage());\n\t\t}\n\n\t\treturn(true);\n\t}","id":28310,"modified_method":"/**\n     * Prepare for a VIEW_CHANGE: switch to flushing state\n     *\n     * @return true if the event is to be forwarded further up\n     */\n    private boolean _upBlock() {\n        // *** Get an exclusive lock\n        try {\n            stateLock.writeLock().acquire();\n            try {\n                state=FLUSH;\n                // *** Revoke the exclusive lock\n            }\n            finally {\n                stateLock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring the write lock\", e);\n        }\n\n        return (true);\n    }","commit_id":"a091e13570cc7a40ee18d09c9583925fbf76f38e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Handle the stop() method travelling down the stack.\n\t * <p>\n\t * The local addr is set to null, since after a Start->Stop->Start\n\t * sequence this member's addr is not guaranteed to be the same\n\t *\n\t */\n    public void stop() {\n        // *** Get an exclusive lock\n        try {\n            stateLock.writeLock(); \n            try {\n                state = NULL_STATE;\n                retransmitter.reset();\n                reqTbl.clear();\n                upTbl.clear();\n                addr = null;\n                \n                // *** Revoke the exclusive lock\n            }\n            finally {\n                stateLock.writeUnlock();\n            }\n        }\n        catch(RWLock.IntException ex) {\n            if(log.isErrorEnabled()) log.error(ex.getMessage());\n        }\n    }","id":28311,"modified_method":"/**\n     * Handle the stop() method travelling down the stack.\n     * <p/>\n     * The local addr is set to null, since after a Start->Stop->Start\n     * sequence this member's addr is not guaranteed to be the same\n     */\n    public void stop() {\n        try {\n            stateLock.writeLock().acquire();\n            try {\n                state=NULL_STATE;\n                retransmitter.reset();\n                reqTbl.clear();\n                upTbl.clear();\n                addr=null;\n            }\n            finally {\n                stateLock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(e.getMessage());\n        }\n    }","commit_id":"a091e13570cc7a40ee18d09c9583925fbf76f38e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Resend the bcast request with the given localSeqID\n\t *\n\t * @param seqID the local sequence id of the\n\t */\n\tprivate void _retransmitBcastRequest(long seqID) {\n\t\t// *** Get a shared lock\n\t\ttry { stateLock.readLock(); try {\n\n\t\tif(log.isInfoEnabled()) log.info(\"Retransmit BCAST_REQ[\" + seqID + ']');\n\t\t_transmitBcastRequest(seqID);\n\n\t\t// ** Revoke the shared lock\n\t\t} finally { stateLock.readUnlock(); }\n\t\t} catch(RWLock.IntException ex) {\n\t\tif(log.isErrorEnabled()) log.error(ex.getMessage());\n\t\t}\n\t}","id":28312,"modified_method":"/**\n     * Resend the bcast request with the given localSeqID\n     *\n     * @param seqID the local sequence id of the\n     */\n    private void _retransmitBcastRequest(long seqID) {\n        // *** Get a shared lock\n        try {\n            stateLock.readLock().acquire();\n            try {\n                if(log.isInfoEnabled()) log.info(\"Retransmit BCAST_REQ[\" + seqID + ']');\n                _transmitBcastRequest(seqID);\n            }\n            finally {\n                stateLock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring a read lock\", e);\n        }\n    }","commit_id":"a091e13570cc7a40ee18d09c9583925fbf76f38e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * A MSG event travelling down the stack. Forward unicast messages, treat\n\t * specially the broadcast messages.<br>\n\t *\n\t * If in <code>BLOCK<\/code> state, i.e. it has replied to a\n\t * <code>BLOCk_OK<\/code> and hasn't yet received a\n\t * <code>VIEW_CHANGE<\/code> event, messages are discarded<br>\n\t *\n\t * If in <code>FLUSH<\/code> state, forward unicast but queue broadcasts\n\t *\n\t * @param event the MSG event\n\t * @return true if event should travel further down\n\t */\n\tprivate boolean _downMsg(Event event) {\n\t\tMessage msg;\n\n\t\t// *** Get a shared lock\n\t\ttry { stateLock.readLock(); try {\n\n\t\t// i. Discard all msgs, if in NULL_STATE\n\t\t// ii. Discard all msgs, if blocked\n\t\tif (state == NULL_STATE) {\n\t\t\tif(log.isErrorEnabled()) log.error(\"Discard msg in NULL_STATE\");\n\t\t\treturn(false);\n\t\t}\n\t\tif (state == BLOCK) {\n\t\t\tif(log.isErrorEnabled()) log.error(\"Blocked, discard msg\");\n\t\t\treturn(false);\n\t\t}\n\n\t\tmsg = (Message)event.getArg();\n\t\tif (msg.getDest() == null) {\n\t\t\t_sendBcastRequest(msg);\n\t\t\treturn(false);\n\t\t} else {\n\t\t\tmsg = _sendUcast(msg);\n\t\t\tevent.setArg(msg);\n\t\t}\n\n\t\t// ** Revoke the shared lock\n\t\t} finally { stateLock.readUnlock(); }\n\t\t} catch(RWLock.IntException ex) {\n\t\tif(log.isErrorEnabled()) log.error(ex.getMessage());\n\t\t}\n\n\t\treturn(true);\n\t}","id":28313,"modified_method":"/**\n     * A MSG event travelling down the stack. Forward unicast messages, treat\n     * specially the broadcast messages.<br>\n     * <p/>\n     * If in <code>BLOCK<\/code> state, i.e. it has replied to a\n     * <code>BLOCk_OK<\/code> and hasn't yet received a\n     * <code>VIEW_CHANGE<\/code> event, messages are discarded<br>\n     * <p/>\n     * If in <code>FLUSH<\/code> state, forward unicast but queue broadcasts\n     *\n     * @param event the MSG event\n     * @return true if event should travel further down\n     */\n    private boolean _downMsg(Event event) {\n        Message msg;\n\n        // *** Get a shared lock\n        try {\n            stateLock.readLock().acquire();\n            try {\n\n                // i. Discard all msgs, if in NULL_STATE\n                // ii. Discard all msgs, if blocked\n                if(state == NULL_STATE) {\n                    if(log.isErrorEnabled()) log.error(\"Discard msg in NULL_STATE\");\n                    return (false);\n                }\n                if(state == BLOCK) {\n                    if(log.isErrorEnabled()) log.error(\"Blocked, discard msg\");\n                    return (false);\n                }\n\n                msg=(Message)event.getArg();\n                if(msg.getDest() == null) {\n                    _sendBcastRequest(msg);\n                    return (false);\n                }\n                else {\n                    msg=_sendUcast(msg);\n                    event.setArg(msg);\n                }\n\n                // ** Revoke the shared lock\n            }\n            finally {\n                stateLock.readLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(e.getMessage());\n        }\n\n        return (true);\n    }","commit_id":"a091e13570cc7a40ee18d09c9583925fbf76f38e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Set the address of this group member\n\t *\n\t * @param event the SET_LOCAL_ADDRESS event\n\t * @return true if event should be forwarded further up\n\t */\n\tprivate boolean _upSetLocalAddress(Event event) {\n\t\t// *** Get an exclusive lock\n\t\ttry { stateLock.writeLock(); try {\n\n\t\taddr  = (Address)event.getArg();\n\n\t\t// *** Revoke the exclusive lock\n\t\t} finally { stateLock.writeUnlock(); }\n\t\t} catch(RWLock.IntException ex) {\n\t\tif(log.isErrorEnabled()) log.error(ex.getMessage());\n\t\t}\n\t\treturn(true);\n\t}","id":28314,"modified_method":"/**\n     * Set the address of this group member\n     *\n     * @param event the SET_LOCAL_ADDRESS event\n     * @return true if event should be forwarded further up\n     */\n    private boolean _upSetLocalAddress(Event event) {\n        // *** Get an exclusive lock\n        try {\n            stateLock.writeLock().acquire();\n            try {\n                addr=(Address)event.getArg();\n            }\n            finally {\n                stateLock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(e.getMessage());\n        }\n        return (true);\n    }","commit_id":"a091e13570cc7a40ee18d09c9583925fbf76f38e","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        Permanent permanent = ((ZoneChangeEvent)event).getTarget();\r\n        if (permanent != null) {\r\n            MageInt toughness = permanent.getToughness();\r\n            Player player = (Player)this.getValue(\"player\");\r\n            player.gainLife(toughness.getValue(), game);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":28315,"modified_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        Permanent permanent = ((ZoneChangeEvent)event).getTarget();\r\n        if (permanent != null) {\r\n            MageInt toughness = permanent.getToughness();\r\n            Player player = game.getPlayer(source.getControllerId());\r\n            if (player != null) {\r\n                player.gainLife(toughness.getValue(), game);\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"6c1b686bce4b99d9ab2e03773e2dec5435f2131b","url":"https://github.com/magefree/mage"},{"original_method":"public SyphonSoulEffect() {\r\n        super(Constants.Outcome.Damage);\r\n        staticText = \"{this} deals 2 damage to each other player. You gain life equal to the damage dealt this way\";\r\n    }","id":28316,"modified_method":"public SyphonSoulEffect() {\r\n        super(Outcome.Damage);\r\n        staticText = \"{this} deals 2 damage to each other player. You gain life equal to the damage dealt this way\";\r\n    }","commit_id":"c709d862ae09fa149b885d402f671d44a791325c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        int loseLife = 0;\r\n        for (UUID opponentId : game.getOpponents(source.getControllerId())) {\r\n            loseLife += game.getPlayer(opponentId).loseLife(2, game);\r\n        }\r\n        if (loseLife > 0)\r\n            game.getPlayer(source.getControllerId()).gainLife(loseLife, game);\r\n        return true;\r\n    }","id":28317,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        int damageDealt = 0;\r\n        for (UUID playerId : game.getPlayerList()) {\r\n            if (!playerId.equals(source.getControllerId())) {\r\n                damageDealt += game.getPlayer(playerId).damage(2, source.getSourceId(), game, false, true);\r\n            }\r\n        }\r\n        if (damageDealt > 0) {\r\n            game.getPlayer(source.getControllerId()).gainLife(damageDealt, game);\r\n        }\r\n        return true;\r\n    }","commit_id":"c709d862ae09fa149b885d402f671d44a791325c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player you = game.getPlayer(source.getControllerId());\r\n        if (you != null && you.searchLibrary(target, game)) {\r\n            if (target.getTargets().size() > 0) {\r\n                for (UUID cardId : target.getTargets()) {\r\n                    Card card = you.getLibrary().remove(cardId, game);\r\n                    if (card != null) {\r\n                        card.moveToExile(CardUtil.getCardExileZoneId(game, source), \"Endless Horizons\", source.getSourceId(), game);\r\n                    }\r\n                }\r\n                you.shuffleLibrary(game);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","id":28318,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player you = game.getPlayer(source.getControllerId());\r\n        if (you != null) {\r\n            if (you.searchLibrary(target, game)) {\r\n                UUID exileZone = CardUtil.getCardExileZoneId(game, source);\r\n                if (target.getTargets().size() > 0) {\r\n                    for (UUID cardId : target.getTargets()) {\r\n                        Card card = you.getLibrary().getCard(cardId, game);\r\n                        if (card != null) {\r\n                            card.moveToExile(exileZone, \"Endless Horizons\", source.getSourceId(), game);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            you.shuffleLibrary(game);\r\n            return true;\r\n\r\n        }\r\n        return false;\r\n    }","commit_id":"6388c939eebcda23f7406e6cf56412ce490768b7","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n        public boolean apply(Game game, Ability source) {\r\n            ExileZone exZone = game.getExile().getExileZone(CardUtil.getCardExileZoneId(game, source));\r\n            if (exZone != null) {\r\n                for (Card card : exZone.getCards(game)) {\r\n                    if (card != null\r\n                            && card.getOwnerId() == source.getControllerId()) {\r\n                        if (card.moveToZone(Zone.HAND, source.getId(), game, false)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }","id":28319,"modified_method":"@Override\r\n        public boolean apply(Game game, Ability source) {\r\n            ExileZone exZone = game.getExile().getExileZone(CardUtil.getCardExileZoneId(game, source));\r\n            if (exZone != null) {\r\n                for (Card card : exZone.getCards(game)) {\r\n                    if (card.getOwnerId() == source.getControllerId()) {\r\n                        card.moveToZone(Zone.HAND, source.getSourceId(), game, false);\r\n                        break; // only one\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }","commit_id":"6388c939eebcda23f7406e6cf56412ce490768b7","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        for (Permanent creature : game.getBattlefield().getAllActivePermanents(CardType.CREATURE)) {\r\n            if (creature != null) {\r\n                creature.moveToZone(Zone.LIBRARY, source.getId(), game, false);\r\n            }\r\n        }\r\n        return false;\r\n    }","id":28320,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        for (Permanent creature : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getSourceId(), game)) {\r\n            creature.moveToZone(Zone.LIBRARY, source.getSourceId(), game, false);\r\n        }\r\n        return false;\r\n    }","commit_id":"6388c939eebcda23f7406e6cf56412ce490768b7","url":"https://github.com/magefree/mage"},{"original_method":"public IdleThoughts(UUID ownerId) {\r\n        super(ownerId, 23, \"Idle Thoughts\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{3}{U}\");\r\n        this.expansionSetCode = \"EVE\";\r\n\r\n        this.color.setBlue(true);\r\n\r\n        // {2}: Draw a card if you have no cards in hand.\r\n        this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new IdleThoughtsEffect(), new ManaCostsImpl(\"{2}\")));\r\n    }","id":28321,"modified_method":"public IdleThoughts(UUID ownerId) {\r\n        super(ownerId, 23, \"Idle Thoughts\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{3}{U}\");\r\n        this.expansionSetCode = \"EVE\";\r\n\r\n        this.color.setBlue(true);\r\n\r\n        // {2}: Draw a card if you have no cards in hand.\r\n        this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new ConditionalOneShotEffect(\r\n                new DrawCardControllerEffect(2), new CardsInHandCondition(), \r\n                \"Draw a card if you have no cards in hand\"), new ManaCostsImpl(\"{{2}}\")));\r\n    }","commit_id":"6388c939eebcda23f7406e6cf56412ce490768b7","url":"https://github.com/magefree/mage"},{"original_method":"public KithkinZealot(UUID ownerId) {\r\n        super(ownerId, 9, \"Kithkin Zealot\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{W}\");\r\n        this.expansionSetCode = \"EVE\";\r\n        this.subtype.add(\"Kithkin\");\r\n        this.subtype.add(\"Cleric\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(3);\r\n\r\n        // When Kithkin Zealot enters the battlefield, you gain 1 life for each black and/or red permanent target opponent controls.\r\n        Ability ability = new EntersBattlefieldTriggeredAbility(new KithkinZealotEffect(), false);\r\n        ability.addTarget(new TargetOpponent());\r\n        this.addAbility(ability);\r\n\r\n    }","id":28322,"modified_method":"public KithkinZealot(UUID ownerId) {\r\n        super(ownerId, 9, \"Kithkin Zealot\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{W}\");\r\n        this.expansionSetCode = \"EVE\";\r\n        this.subtype.add(\"Kithkin\");\r\n        this.subtype.add(\"Cleric\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(3);\r\n\r\n        // When Kithkin Zealot enters the battlefield, you gain 1 life for each black and/or red permanent target opponent controls.\r\n        Ability ability = new EntersBattlefieldTriggeredAbility(new KithkinZealotEffect(), false);\r\n        ability.addTarget(new TargetOpponent(true));\r\n        this.addAbility(ability);\r\n    }","commit_id":"6388c939eebcda23f7406e6cf56412ce490768b7","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player you = game.getPlayer(source.getControllerId());\r\n        Player opponent = game.getPlayer(source.getFirstTarget());\r\n        FilterPermanent filter = new FilterPermanent();\r\n        filter.add(Predicates.or(\r\n                new ColorPredicate(ObjectColor.BLACK),\r\n                new ColorPredicate(ObjectColor.RED)));\r\n        if (opponent != null) {\r\n            int amount = game.getBattlefield().countAll(filter, opponent.getId(), game);\r\n            if (you != null) {\r\n                you.gainLife(amount, game);\r\n                return true;\r\n            }\r\n            \r\n        }\r\n        return false;\r\n    }","id":28323,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player you = game.getPlayer(source.getControllerId());\r\n        Player opponent = game.getPlayer(targetPointer.getFirst(game, source));\r\n\r\n        if (you!= null && opponent != null) {\r\n            int amount = game.getBattlefield().countAll(filter, opponent.getId(), game);\r\n            you.gainLife(amount, game);\r\n            return true;            \r\n        }\r\n        return false;\r\n    }","commit_id":"6388c939eebcda23f7406e6cf56412ce490768b7","url":"https://github.com/magefree/mage"},{"original_method":"public DiagnosticSink(CompileContext context, Set<File> tempRoots) {\n      myContext = context;\n      myTempRoots = tempRoots;\n    }","id":28324,"modified_method":"public DiagnosticSink(CompileContext context) {\n      myContext = context;\n    }","commit_id":"552a56a6bbc4746df1f168b380548628edf11208","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void javaFileLoaded(File file) {\n      if (JpsPathUtil.isUnder(myTempRoots, file)) {\n        myLoadedTempSources.add(file);\n      }\n    }","id":28325,"modified_method":"@Override\n    public void javaFileLoaded(File file) {\n    }","commit_id":"552a56a6bbc4746df1f168b380548628edf11208","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ExitCode compile(final CompileContext context,\n                           ModuleChunk chunk,\n                           DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder,\n                           Collection<File> files,\n                           OutputConsumer outputConsumer)\n    throws Exception {\n    ExitCode exitCode = ExitCode.NOTHING_DONE;\n\n    final boolean hasSourcesToCompile = !files.isEmpty();\n\n    if (!hasSourcesToCompile && !dirtyFilesHolder.hasRemovedFiles()) {\n      return exitCode;\n    }\n\n    final ProjectDescriptor pd = context.getProjectDescriptor();\n\n    JavaBuilderUtil.ensureModuleHasJdk(chunk.representativeTarget().getModule(), context, BUILDER_NAME);\n    final Collection<File> classpath = ProjectPaths.getCompilationClasspath(chunk, false/*context.isProjectRebuild()*/);\n    final Collection<File> platformCp = ProjectPaths.getPlatformCompilationClasspath(chunk, false/*context.isProjectRebuild()*/);\n\n    // begin compilation round\n    final Mappings delta = pd.dataManager.getMappings().createDelta();\n    final Callbacks.Backend mappingsCallback = delta.getCallback();\n    final OutputFilesSink outputSink = new OutputFilesSink(context, outputConsumer, mappingsCallback, chunk.getName());\n    try {\n      if (hasSourcesToCompile) {\n        final AtomicReference<String> ref = COMPILER_VERSION_INFO.get(context);\n        final String versionInfo = ref.getAndSet(null); // display compiler version info only once per compile session\n        if (versionInfo != null) {\n          LOG.info(versionInfo);\n          context.processMessage(new CompilerMessage(\"\", BuildMessage.Kind.INFO, versionInfo));\n        }\n        exitCode = ExitCode.OK;\n\n        final Set<File> srcPath = new HashSet<File>();\n        Set<File> tempRoots = null;\n        \n        final BuildRootIndex index = pd.getBuildRootIndex();\n        for (ModuleBuildTarget target : chunk.getTargets()) {\n          for (JavaSourceRootDescriptor rd : index.getTargetRoots(target, context)) {\n            srcPath.add(rd.root);\n            if (rd.isTemp) {\n              if (tempRoots == null) {\n                tempRoots = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);\n              }\n              tempRoots.add(rd.root);\n            }\n          }\n        }\n        final DiagnosticSink diagnosticSink = new DiagnosticSink(context, tempRoots == null? Collections.<File>emptySet() : tempRoots);\n        \n        final String chunkName = chunk.getName();\n        context.processMessage(new ProgressMessage(\"Parsing java... [\" + chunkName + \"]\"));\n\n        final int filesCount = files.size();\n        boolean compiledOk = true;\n        int tempRootsErrorCount = 0;\n        int tempRootsWarningCount = 0;\n        if (filesCount > 0) {\n          LOG.info(\"Compiling \" + filesCount + \" java files; module: \" + chunkName + (chunk.containsTests() ? \" (tests)\" : \"\"));\n          if (LOG.isDebugEnabled()) {\n            for (File file : files) {\n              LOG.debug(\"Compiling \" + file.getPath());\n            }\n            LOG.debug(\" classpath for \" + chunkName + \":\");\n            for (File file : classpath) {\n              LOG.debug(\"  \" + file.getAbsolutePath());\n            }\n            LOG.debug(\" platform classpath for \" + chunkName + \":\");\n            for (File file : platformCp) {\n              LOG.debug(\"  \" + file.getAbsolutePath());\n            }\n          }\n          try {\n            compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink);\n            if (compiledOk) {\n              final Collection<File> loadedTempFiles = diagnosticSink.getLoadedTempSources();\n              if (!loadedTempFiles.isEmpty()) {\n                // compile all implicitly loaded sources from temporary roots\n                final DiagnosticSink tempRootsSink = new DiagnosticSink(context, Collections.<File>emptySet());\n                compiledOk = compileJava(context, chunk, loadedTempFiles, classpath, platformCp, tempRoots, tempRootsSink, outputSink);\n                tempRootsErrorCount = tempRootsSink.getErrorCount();\n                tempRootsWarningCount = tempRootsSink.getWarningCount();\n              }\n            }\n          }\n          finally {\n            // heuristic: incorrect paths data recovery, so that the next make should not contain non-existing sources in 'recompile' list\n            for (File file : diagnosticSink.getFilesWithErrors()) {\n              if (!file.exists()) {\n                FSOperations.markDeleted(context, file);\n              }\n            }\n          }\n        }\n\n        context.checkCanceled();\n\n        if (!compiledOk && (diagnosticSink.getErrorCount() + tempRootsErrorCount) == 0) {\n          diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, \"Compilation failed: internal java compiler error\"));\n        }\n        final int totalErrorCount = diagnosticSink.getErrorCount() + tempRootsErrorCount;\n        if (!Utils.PROCEED_ON_ERROR_KEY.get(context, Boolean.FALSE) && totalErrorCount > 0) {\n          if (!compiledOk) {\n            diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.OTHER, \"Errors occurred while compiling module '\" + chunkName + \"'\"));\n          }\n          throw new StopBuildException(\n            \"Compilation failed: errors: \" + totalErrorCount + \"; warnings: \" + (diagnosticSink.getWarningCount() + tempRootsWarningCount)\n          );\n        }\n      }\n    }\n    finally {\n      if (JavaBuilderUtil.updateMappings(context, delta, dirtyFilesHolder, chunk, files, outputSink.getSuccessfullyCompiled())) {\n        exitCode = ExitCode.ADDITIONAL_PASS_REQUIRED;\n      }\n    }\n\n    return exitCode;\n  }","id":28326,"modified_method":"private ExitCode compile(final CompileContext context,\n                           ModuleChunk chunk,\n                           DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder,\n                           Collection<File> files,\n                           OutputConsumer outputConsumer)\n    throws Exception {\n    ExitCode exitCode = ExitCode.NOTHING_DONE;\n\n    final boolean hasSourcesToCompile = !files.isEmpty();\n\n    if (!hasSourcesToCompile && !dirtyFilesHolder.hasRemovedFiles()) {\n      return exitCode;\n    }\n\n    final ProjectDescriptor pd = context.getProjectDescriptor();\n\n    JavaBuilderUtil.ensureModuleHasJdk(chunk.representativeTarget().getModule(), context, BUILDER_NAME);\n    final Collection<File> classpath = ProjectPaths.getCompilationClasspath(chunk, false/*context.isProjectRebuild()*/);\n    final Collection<File> platformCp = ProjectPaths.getPlatformCompilationClasspath(chunk, false/*context.isProjectRebuild()*/);\n\n    // begin compilation round\n    final Mappings delta = pd.dataManager.getMappings().createDelta();\n    final Callbacks.Backend mappingsCallback = delta.getCallback();\n    final OutputFilesSink outputSink = new OutputFilesSink(context, outputConsumer, mappingsCallback, chunk.getName());\n    try {\n      if (hasSourcesToCompile) {\n        final AtomicReference<String> ref = COMPILER_VERSION_INFO.get(context);\n        final String versionInfo = ref.getAndSet(null); // display compiler version info only once per compile session\n        if (versionInfo != null) {\n          LOG.info(versionInfo);\n          context.processMessage(new CompilerMessage(\"\", BuildMessage.Kind.INFO, versionInfo));\n        }\n        exitCode = ExitCode.OK;\n\n        final Set<File> srcPath = new HashSet<File>();\n        final BuildRootIndex index = pd.getBuildRootIndex();\n        for (ModuleBuildTarget target : chunk.getTargets()) {\n          for (JavaSourceRootDescriptor rd : index.getTempTargetRoots(target, context)) {\n            srcPath.add(rd.root);\n          }\n        }\n        final DiagnosticSink diagnosticSink = new DiagnosticSink(context);\n        \n        final String chunkName = chunk.getName();\n        context.processMessage(new ProgressMessage(\"Parsing java... [\" + chunkName + \"]\"));\n\n        final int filesCount = files.size();\n        boolean compiledOk = true;\n        if (filesCount > 0) {\n          LOG.info(\"Compiling \" + filesCount + \" java files; module: \" + chunkName + (chunk.containsTests() ? \" (tests)\" : \"\"));\n          if (LOG.isDebugEnabled()) {\n            for (File file : files) {\n              LOG.debug(\"Compiling \" + file.getPath());\n            }\n            LOG.debug(\" classpath for \" + chunkName + \":\");\n            for (File file : classpath) {\n              LOG.debug(\"  \" + file.getAbsolutePath());\n            }\n            LOG.debug(\" platform classpath for \" + chunkName + \":\");\n            for (File file : platformCp) {\n              LOG.debug(\"  \" + file.getAbsolutePath());\n            }\n          }\n          try {\n            compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink);\n          }\n          finally {\n            // heuristic: incorrect paths data recovery, so that the next make should not contain non-existing sources in 'recompile' list\n            for (File file : diagnosticSink.getFilesWithErrors()) {\n              if (!file.exists()) {\n                FSOperations.markDeleted(context, file);\n              }\n            }\n          }\n        }\n\n        context.checkCanceled();\n\n        if (!compiledOk && diagnosticSink.getErrorCount() == 0) {\n          diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, \"Compilation failed: internal java compiler error\"));\n        }\n        if (!Utils.PROCEED_ON_ERROR_KEY.get(context, Boolean.FALSE) && diagnosticSink.getErrorCount() > 0) {\n          if (!compiledOk) {\n            diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.OTHER, \"Errors occurred while compiling module '\" + chunkName + \"'\"));\n          }\n          throw new StopBuildException(\n            \"Compilation failed: errors: \" + diagnosticSink.getErrorCount() + \"; warnings: \" + diagnosticSink.getWarningCount()\n          );\n        }\n      }\n    }\n    finally {\n      if (JavaBuilderUtil.updateMappings(context, delta, dirtyFilesHolder, chunk, files, outputSink.getSuccessfullyCompiled())) {\n        exitCode = ExitCode.ADDITIONAL_PASS_REQUIRED;\n      }\n    }\n\n    return exitCode;\n  }","commit_id":"552a56a6bbc4746df1f168b380548628edf11208","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Collection<String> prepareOptions(final Collection<String> options, boolean usingJavac) {\n    final List<String> result = new ArrayList<String>();\n    if (usingJavac) {\n      result.add(\"-Xprefer:source\"); \n      result.add(\"-implicit:none\"); // the option supported by javac only\n    }\n    else { // is Eclipse\n      result.add(\"-noExit\");\n    }\n    boolean skip = false;\n    for (String option : options) {\n      if (FILTERED_OPTIONS.contains(option)) {\n        skip = true;\n        continue;\n      }\n      if (!skip) {\n        if (!FILTERED_SINGLE_OPTIONS.contains(option)) {\n          result.add(option);\n        }\n      }\n      skip = false;\n    }\n    return result;\n  }","id":28327,"modified_method":"private static Collection<String> prepareOptions(final Collection<String> options, boolean usingJavac) {\n    final List<String> result = new ArrayList<String>();\n    if (usingJavac) {\n      result.add(\"-implicit:class\"); // the option supported by javac only\n    }\n    else { // is Eclipse\n      result.add(\"-noExit\");\n    }\n    boolean skip = false;\n    for (String option : options) {\n      if (FILTERED_OPTIONS.contains(option)) {\n        skip = true;\n        continue;\n      }\n      if (!skip) {\n        if (!FILTERED_SINGLE_OPTIONS.contains(option)) {\n          result.add(option);\n        }\n      }\n      skip = false;\n    }\n    return result;\n  }","commit_id":"552a56a6bbc4746df1f168b380548628edf11208","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean compile(Collection<String> options,\n                                final Collection<File> sources,\n                                Collection<File> classpath,\n                                Collection<File> platformClasspath,\n                                Collection<File> sourcePath,\n                                Map<File, Set<File>> outputDirToRoots,\n                                final DiagnosticOutputConsumer diagnosticConsumer,\n                                final OutputFileConsumer outputSink,\n                                CanceledStatus canceledStatus, boolean useEclipseCompiler) {\n    JavaCompiler compiler = null;\n    if (useEclipseCompiler) {\n      for (JavaCompiler javaCompiler : ServiceLoader.load(JavaCompiler.class)) {\n        compiler = javaCompiler;\n        break;\n      }\n      if (compiler == null) {\n        diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, \"Eclipse Batch Compiler was not found in classpath\"));\n        return false;\n      }\n    }\n\n    final boolean nowUsingJavac;\n    if (compiler == null) {\n      compiler = ToolProvider.getSystemJavaCompiler();\n      if (compiler == null) {\n        diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, \"System Java Compiler was not found in classpath\"));\n        return false;\n      }\n      nowUsingJavac = true;\n    }\n    else {\n      nowUsingJavac = false;\n    }\n\n    for (File outputDir : outputDirToRoots.keySet()) {\n      outputDir.mkdirs();\n    }\n    \n    final List<JavaSourceTransformer> transformers = getSourceTransformers();\n    transformers.add(new JavaSourceTransformer() { \n      // dummy transformer to notify about sources that were accessed during compilation \n      @Override\n      public CharSequence transform(File sourceFile, CharSequence content) throws TransformError {\n        diagnosticConsumer.javaFileLoaded(sourceFile);\n        return content;\n      }\n    });\n\n    final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, nowUsingJavac), transformers);\n\n    fileManager.handleOption(\"-bootclasspath\", Collections.singleton(\"\").iterator()); // this will clear cached stuff\n    fileManager.handleOption(\"-extdirs\", Collections.singleton(\"\").iterator()); // this will clear cached stuff\n    fileManager.handleOption(\"-endorseddirs\", Collections.singleton(\"\").iterator()); // this will clear cached stuff\n    final Collection<String> _options = prepareOptions(options, nowUsingJavac);\n\n    try {\n      fileManager.setOutputDirectories(outputDirToRoots);\n    }\n    catch (IOException e) {\n      fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n      return false;\n    }\n\n    if (!classpath.isEmpty()) {\n      try {\n        fileManager.setLocation(StandardLocation.CLASS_PATH, classpath);\n        if (!nowUsingJavac && !isOptionSet(options, \"-processorpath\")) {\n          // for non-javac file manager ensure annotation processor path defaults to classpath\n          fileManager.setLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH, classpath);\n        }\n      }\n      catch (IOException e) {\n        fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n        return false;\n      }\n    }\n    if (!platformClasspath.isEmpty()) {\n      try {\n        fileManager.setLocation(StandardLocation.PLATFORM_CLASS_PATH, buildPlatformClasspath(platformClasspath, _options));\n      }\n      catch (IOException e) {\n        fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n        return false;\n      }\n    }\n    try {\n    // ensure the source path is set;\n    // otherwise, if not set, javac attempts to search both classes and sources in classpath;\n    // so if some classpath jars contain sources, it will attempt to compile them\n      fileManager.setLocation(StandardLocation.SOURCE_PATH, sourcePath);\n    }\n    catch (IOException e) {\n      fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n      return false;\n    }\n\n    //noinspection IOResourceOpenedButNotSafelyClosed\n    final LineOutputWriter out = new LineOutputWriter() {\n      protected void lineAvailable(String line) {\n        if (nowUsingJavac) {\n          diagnosticConsumer.outputLineAvailable(line);\n        }\n        else {\n          // todo: filter too verbose eclipse output?\n        }\n      }\n    };\n\n    try {\n\n      // to be on the safe side, we'll have to apply all options _before_ calling any of manager's methods\n      // i.e. getJavaFileObjectsFromFiles()\n      // This way the manager will be properly initialized. Namely, the encoding will be set correctly\n      for (Iterator<String> iterator = _options.iterator(); iterator.hasNext(); ) {\n        fileManager.handleOption(iterator.next(), iterator);\n      }\n\n      final JavaCompiler.CompilationTask task = compiler.getTask(\n        out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources)\n      );\n\n      //if (!IS_VM_6_VERSION) { //todo!\n      //  // Do not add the processor for JDK 1.6 because of the bugs in javac\n      //  // The processor's presence may lead to NPE and resolve bugs in compiler\n      //  final JavacASTAnalyser analyzer = new JavacASTAnalyser(outConsumer, !annotationProcessingEnabled);\n      //  task.setProcessors(Collections.singleton(analyzer));\n      //}\n      return task.call();\n    }\n    catch(IllegalArgumentException e) {\n      diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, e.getMessage()));\n    }\n    catch (CompilationCanceledException ignored) {\n      diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.OTHER, \"Compilation was canceled\"));\n    }\n    finally {\n      fileManager.close();\n      if (nowUsingJavac) {\n        cleanupJavacNameTable();\n      }\n    }\n    return false;\n  }","id":28328,"modified_method":"public static boolean compile(Collection<String> options,\n                                final Collection<File> sources,\n                                Collection<File> classpath,\n                                Collection<File> platformClasspath,\n                                Collection<File> sourcePath,\n                                Map<File, Set<File>> outputDirToRoots,\n                                final DiagnosticOutputConsumer diagnosticConsumer,\n                                final OutputFileConsumer outputSink,\n                                CanceledStatus canceledStatus, boolean useEclipseCompiler) {\n    JavaCompiler compiler = null;\n    if (useEclipseCompiler) {\n      for (JavaCompiler javaCompiler : ServiceLoader.load(JavaCompiler.class)) {\n        compiler = javaCompiler;\n        break;\n      }\n      if (compiler == null) {\n        diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, \"Eclipse Batch Compiler was not found in classpath\"));\n        return false;\n      }\n    }\n\n    final boolean nowUsingJavac;\n    if (compiler == null) {\n      compiler = ToolProvider.getSystemJavaCompiler();\n      if (compiler == null) {\n        diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, \"System Java Compiler was not found in classpath\"));\n        return false;\n      }\n      nowUsingJavac = true;\n    }\n    else {\n      nowUsingJavac = false;\n    }\n\n    for (File outputDir : outputDirToRoots.keySet()) {\n      outputDir.mkdirs();\n    }\n    \n    final List<JavaSourceTransformer> transformers = getSourceTransformers();\n\n    final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, nowUsingJavac), transformers);\n\n    fileManager.handleOption(\"-bootclasspath\", Collections.singleton(\"\").iterator()); // this will clear cached stuff\n    fileManager.handleOption(\"-extdirs\", Collections.singleton(\"\").iterator()); // this will clear cached stuff\n    fileManager.handleOption(\"-endorseddirs\", Collections.singleton(\"\").iterator()); // this will clear cached stuff\n    final Collection<String> _options = prepareOptions(options, nowUsingJavac);\n\n    try {\n      fileManager.setOutputDirectories(outputDirToRoots);\n    }\n    catch (IOException e) {\n      fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n      return false;\n    }\n\n    if (!classpath.isEmpty()) {\n      try {\n        fileManager.setLocation(StandardLocation.CLASS_PATH, classpath);\n        if (!nowUsingJavac && !isOptionSet(options, \"-processorpath\")) {\n          // for non-javac file manager ensure annotation processor path defaults to classpath\n          fileManager.setLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH, classpath);\n        }\n      }\n      catch (IOException e) {\n        fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n        return false;\n      }\n    }\n    if (!platformClasspath.isEmpty()) {\n      try {\n        fileManager.setLocation(StandardLocation.PLATFORM_CLASS_PATH, buildPlatformClasspath(platformClasspath, _options));\n      }\n      catch (IOException e) {\n        fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n        return false;\n      }\n    }\n    try {\n    // ensure the source path is set;\n    // otherwise, if not set, javac attempts to search both classes and sources in classpath;\n    // so if some classpath jars contain sources, it will attempt to compile them\n      fileManager.setLocation(StandardLocation.SOURCE_PATH, sourcePath);\n    }\n    catch (IOException e) {\n      fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n      return false;\n    }\n\n    //noinspection IOResourceOpenedButNotSafelyClosed\n    final LineOutputWriter out = new LineOutputWriter() {\n      protected void lineAvailable(String line) {\n        if (nowUsingJavac) {\n          diagnosticConsumer.outputLineAvailable(line);\n        }\n        else {\n          // todo: filter too verbose eclipse output?\n        }\n      }\n    };\n\n    try {\n\n      // to be on the safe side, we'll have to apply all options _before_ calling any of manager's methods\n      // i.e. getJavaFileObjectsFromFiles()\n      // This way the manager will be properly initialized. Namely, the encoding will be set correctly\n      for (Iterator<String> iterator = _options.iterator(); iterator.hasNext(); ) {\n        fileManager.handleOption(iterator.next(), iterator);\n      }\n\n      final JavaCompiler.CompilationTask task = compiler.getTask(\n        out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources)\n      );\n\n      //if (!IS_VM_6_VERSION) { //todo!\n      //  // Do not add the processor for JDK 1.6 because of the bugs in javac\n      //  // The processor's presence may lead to NPE and resolve bugs in compiler\n      //  final JavacASTAnalyser analyzer = new JavacASTAnalyser(outConsumer, !annotationProcessingEnabled);\n      //  task.setProcessors(Collections.singleton(analyzer));\n      //}\n      return task.call();\n    }\n    catch(IllegalArgumentException e) {\n      diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, e.getMessage()));\n    }\n    catch (CompilationCanceledException ignored) {\n      diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.OTHER, \"Compilation was canceled\"));\n    }\n    finally {\n      fileManager.close();\n      if (nowUsingJavac) {\n        cleanupJavacNameTable();\n      }\n    }\n    return false;\n  }","commit_id":"552a56a6bbc4746df1f168b380548628edf11208","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<JavaSourceTransformer> getSourceTransformers() {\n    final Class<JavaSourceTransformer> transformerClass = JavaSourceTransformer.class;\n    final ServiceLoader<JavaSourceTransformer> loader = ServiceLoader.load(transformerClass, transformerClass.getClassLoader());\n    final List<JavaSourceTransformer> transformers = new ArrayList<JavaSourceTransformer>();\n    for (JavaSourceTransformer t : loader) {\n      transformers.add(t);\n    }\n    return transformers;\n  }","id":28329,"modified_method":"private static List<JavaSourceTransformer> getSourceTransformers() {\n    final Class<JavaSourceTransformer> transformerClass = JavaSourceTransformer.class;\n    final ServiceLoader<JavaSourceTransformer> loader = ServiceLoader.load(transformerClass, transformerClass.getClassLoader());\n    final List<JavaSourceTransformer> transformers = new SmartList<JavaSourceTransformer>();\n    for (JavaSourceTransformer t : loader) {\n      transformers.add(t);\n    }\n    return transformers;\n  }","commit_id":"552a56a6bbc4746df1f168b380548628edf11208","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testRecompileTwinDependencies() {\n    doTest().assertSuccessful();\n  }","id":28330,"modified_method":"public void testRecompileTwinDependencies() {\n    doTest().assertFailed();\n  }","commit_id":"552a56a6bbc4746df1f168b380548628edf11208","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ExitCode compile(final CompileContext context,\n                           ModuleChunk chunk,\n                           DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder,\n                           Collection<File> files,\n                           OutputConsumer outputConsumer)\n    throws Exception {\n    ExitCode exitCode = ExitCode.NOTHING_DONE;\n\n    final boolean hasSourcesToCompile = !files.isEmpty();\n\n    if (!hasSourcesToCompile && !dirtyFilesHolder.hasRemovedFiles()) {\n      return exitCode;\n    }\n\n    final ProjectDescriptor pd = context.getProjectDescriptor();\n\n    JavaBuilderUtil.ensureModuleHasJdk(chunk.representativeTarget().getModule(), context, BUILDER_NAME);\n    final Collection<File> classpath = ProjectPaths.getCompilationClasspath(chunk, false/*context.isProjectRebuild()*/);\n    final Collection<File> platformCp = ProjectPaths.getPlatformCompilationClasspath(chunk, false/*context.isProjectRebuild()*/);\n\n    // begin compilation round\n    final Mappings delta = pd.dataManager.getMappings().createDelta();\n    final Callbacks.Backend mappingsCallback = delta.getCallback();\n    final OutputFilesSink outputSink = new OutputFilesSink(context, outputConsumer, mappingsCallback, chunk.getName());\n    try {\n      if (hasSourcesToCompile) {\n        final AtomicReference<String> ref = COMPILER_VERSION_INFO.get(context);\n        final String versionInfo = ref.getAndSet(null); // display compiler version info only once per compile session\n        if (versionInfo != null) {\n          LOG.info(versionInfo);\n          context.processMessage(new CompilerMessage(\"\", BuildMessage.Kind.INFO, versionInfo));\n        }\n        exitCode = ExitCode.OK;\n\n        final Set<File> srcPath = new HashSet<File>();\n        Set<File> tempRoots = null;\n        \n        final BuildRootIndex index = pd.getBuildRootIndex();\n        for (ModuleBuildTarget target : chunk.getTargets()) {\n          for (JavaSourceRootDescriptor rd : index.getTargetRoots(target, context)) {\n            srcPath.add(rd.root);\n            if (rd.isTemp) {\n              if (tempRoots == null) {\n                tempRoots = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);\n              }\n              tempRoots.add(rd.root);\n            }\n          }\n        }\n        final DiagnosticSink diagnosticSink = new DiagnosticSink(context, tempRoots == null? Collections.<File>emptySet() : tempRoots);\n        \n        final String chunkName = chunk.getName();\n        context.processMessage(new ProgressMessage(\"Parsing java... [\" + chunkName + \"]\"));\n\n        final int filesCount = files.size();\n        boolean compiledOk = true;\n        if (filesCount > 0) {\n          LOG.info(\"Compiling \" + filesCount + \" java files; module: \" + chunkName + (chunk.containsTests() ? \" (tests)\" : \"\"));\n          if (LOG.isDebugEnabled()) {\n            for (File file : files) {\n              LOG.debug(\"Compiling \" + file.getPath());\n            }\n            LOG.debug(\" classpath for \" + chunkName + \":\");\n            for (File file : classpath) {\n              LOG.debug(\"  \" + file.getAbsolutePath());\n            }\n            LOG.debug(\" platform classpath for \" + chunkName + \":\");\n            for (File file : platformCp) {\n              LOG.debug(\"  \" + file.getAbsolutePath());\n            }\n          }\n          compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink);\n          if (compiledOk) {\n            final Collection<File> loadedTempFiles = diagnosticSink.getLoadedTempSources();\n            if (!loadedTempFiles.isEmpty()) {\n              // compile all implicitly loaded sources from temporary roots\n              compiledOk = compileJava(context, chunk, loadedTempFiles, classpath, platformCp, tempRoots, new DiagnosticSink(context, Collections.<File>emptySet()), outputSink);\n            }\n          }\n        }\n\n        context.checkCanceled();\n\n        if (!compiledOk && diagnosticSink.getErrorCount() == 0) {\n          diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, \"Compilation failed: internal java compiler error\"));\n        }\n        if (!Utils.PROCEED_ON_ERROR_KEY.get(context, Boolean.FALSE) && diagnosticSink.getErrorCount() > 0) {\n          if (!compiledOk) {\n            diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.OTHER, \"Errors occurred while compiling module '\" + chunkName + \"'\"));\n          }\n          throw new StopBuildException(\n            \"Compilation failed: errors: \" + diagnosticSink.getErrorCount() + \"; warnings: \" + diagnosticSink.getWarningCount()\n          );\n        }\n      }\n    }\n    finally {\n      if (JavaBuilderUtil.updateMappings(context, delta, dirtyFilesHolder, chunk, files, outputSink.getSuccessfullyCompiled())) {\n        exitCode = ExitCode.ADDITIONAL_PASS_REQUIRED;\n      }\n    }\n\n    return exitCode;\n  }","id":28331,"modified_method":"private ExitCode compile(final CompileContext context,\n                           ModuleChunk chunk,\n                           DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder,\n                           Collection<File> files,\n                           OutputConsumer outputConsumer)\n    throws Exception {\n    ExitCode exitCode = ExitCode.NOTHING_DONE;\n\n    final boolean hasSourcesToCompile = !files.isEmpty();\n\n    if (!hasSourcesToCompile && !dirtyFilesHolder.hasRemovedFiles()) {\n      return exitCode;\n    }\n\n    final ProjectDescriptor pd = context.getProjectDescriptor();\n\n    JavaBuilderUtil.ensureModuleHasJdk(chunk.representativeTarget().getModule(), context, BUILDER_NAME);\n    final Collection<File> classpath = ProjectPaths.getCompilationClasspath(chunk, false/*context.isProjectRebuild()*/);\n    final Collection<File> platformCp = ProjectPaths.getPlatformCompilationClasspath(chunk, false/*context.isProjectRebuild()*/);\n\n    // begin compilation round\n    final Mappings delta = pd.dataManager.getMappings().createDelta();\n    final Callbacks.Backend mappingsCallback = delta.getCallback();\n    final OutputFilesSink outputSink = new OutputFilesSink(context, outputConsumer, mappingsCallback, chunk.getName());\n    try {\n      if (hasSourcesToCompile) {\n        final AtomicReference<String> ref = COMPILER_VERSION_INFO.get(context);\n        final String versionInfo = ref.getAndSet(null); // display compiler version info only once per compile session\n        if (versionInfo != null) {\n          LOG.info(versionInfo);\n          context.processMessage(new CompilerMessage(\"\", BuildMessage.Kind.INFO, versionInfo));\n        }\n        exitCode = ExitCode.OK;\n\n        final Set<File> srcPath = new HashSet<File>();\n        Set<File> tempRoots = null;\n        \n        final BuildRootIndex index = pd.getBuildRootIndex();\n        for (ModuleBuildTarget target : chunk.getTargets()) {\n          for (JavaSourceRootDescriptor rd : index.getTargetRoots(target, context)) {\n            srcPath.add(rd.root);\n            if (rd.isTemp) {\n              if (tempRoots == null) {\n                tempRoots = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);\n              }\n              tempRoots.add(rd.root);\n            }\n          }\n        }\n        final DiagnosticSink diagnosticSink = new DiagnosticSink(context, tempRoots == null? Collections.<File>emptySet() : tempRoots);\n        \n        final String chunkName = chunk.getName();\n        context.processMessage(new ProgressMessage(\"Parsing java... [\" + chunkName + \"]\"));\n\n        final int filesCount = files.size();\n        boolean compiledOk = true;\n        int tempRootsErrorCount = 0;\n        int tempRootsWarningCount = 0;\n        if (filesCount > 0) {\n          LOG.info(\"Compiling \" + filesCount + \" java files; module: \" + chunkName + (chunk.containsTests() ? \" (tests)\" : \"\"));\n          if (LOG.isDebugEnabled()) {\n            for (File file : files) {\n              LOG.debug(\"Compiling \" + file.getPath());\n            }\n            LOG.debug(\" classpath for \" + chunkName + \":\");\n            for (File file : classpath) {\n              LOG.debug(\"  \" + file.getAbsolutePath());\n            }\n            LOG.debug(\" platform classpath for \" + chunkName + \":\");\n            for (File file : platformCp) {\n              LOG.debug(\"  \" + file.getAbsolutePath());\n            }\n          }\n          try {\n            compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink);\n            if (compiledOk) {\n              final Collection<File> loadedTempFiles = diagnosticSink.getLoadedTempSources();\n              if (!loadedTempFiles.isEmpty()) {\n                // compile all implicitly loaded sources from temporary roots\n                final DiagnosticSink tempRootsSink = new DiagnosticSink(context, Collections.<File>emptySet());\n                compiledOk = compileJava(context, chunk, loadedTempFiles, classpath, platformCp, tempRoots, tempRootsSink, outputSink);\n                tempRootsErrorCount = tempRootsSink.getErrorCount();\n                tempRootsWarningCount = tempRootsSink.getWarningCount();\n              }\n            }\n          }\n          finally {\n            // heuristic: incorrect paths data recovery, so that the next make should not contain non-existing sources in 'recompile' list\n            for (File file : diagnosticSink.getFilesWithErrors()) {\n              if (!file.exists()) {\n                FSOperations.markDeleted(context, file);\n              }\n            }\n          }\n        }\n\n        context.checkCanceled();\n\n        if (!compiledOk && (diagnosticSink.getErrorCount() + tempRootsErrorCount) == 0) {\n          diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, \"Compilation failed: internal java compiler error\"));\n        }\n        final int totalErrorCount = diagnosticSink.getErrorCount() + tempRootsErrorCount;\n        if (!Utils.PROCEED_ON_ERROR_KEY.get(context, Boolean.FALSE) && totalErrorCount > 0) {\n          if (!compiledOk) {\n            diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.OTHER, \"Errors occurred while compiling module '\" + chunkName + \"'\"));\n          }\n          throw new StopBuildException(\n            \"Compilation failed: errors: \" + totalErrorCount + \"; warnings: \" + (diagnosticSink.getWarningCount() + tempRootsWarningCount)\n          );\n        }\n      }\n    }\n    finally {\n      if (JavaBuilderUtil.updateMappings(context, delta, dirtyFilesHolder, chunk, files, outputSink.getSuccessfullyCompiled())) {\n        exitCode = ExitCode.ADDITIONAL_PASS_REQUIRED;\n      }\n    }\n\n    return exitCode;\n  }","commit_id":"21c7fa2be8f8fb3f4c9c5c7f24df66356339d80d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void report(Diagnostic<? extends JavaFileObject> diagnostic) {\n      final CompilerMessage.Kind kind;\n      switch (diagnostic.getKind()) {\n        case ERROR:\n          kind = BuildMessage.Kind.ERROR;\n          myErrorCount++;\n          break;\n        case MANDATORY_WARNING:\n        case WARNING:\n        case NOTE:\n          kind = BuildMessage.Kind.WARNING;\n          myWarningCount++;\n          break;\n        default:\n          kind = BuildMessage.Kind.INFO;\n      }\n      File sourceFile = null;\n      try {\n        // for eclipse compiler just an attempt to call getSource() may lead to an NPE,\n        // so calling this method under try/catch to avoid induced compiler errors\n        final JavaFileObject source = diagnostic.getSource();\n        sourceFile = source != null ? Utils.convertToFile(source.toUri()) : null;\n      }\n      catch (Exception e) {\n        LOG.info(e);\n      }\n      final String srcPath = sourceFile != null ? FileUtil.toSystemIndependentName(sourceFile.getPath()) : null;\n      String message = diagnostic.getMessage(Locale.US);\n      if (Utils.IS_TEST_MODE) {\n        LOG.info(message);\n      }\n      myContext.processMessage(\n        new CompilerMessage(BUILDER_NAME, kind, message, srcPath, diagnostic.getStartPosition(),\n                            diagnostic.getEndPosition(), diagnostic.getPosition(), diagnostic.getLineNumber(),\n                            diagnostic.getColumnNumber()));\n    }","id":28332,"modified_method":"public void report(Diagnostic<? extends JavaFileObject> diagnostic) {\n      final CompilerMessage.Kind kind;\n      switch (diagnostic.getKind()) {\n        case ERROR:\n          kind = BuildMessage.Kind.ERROR;\n          myErrorCount++;\n          break;\n        case MANDATORY_WARNING:\n        case WARNING:\n        case NOTE:\n          kind = BuildMessage.Kind.WARNING;\n          myWarningCount++;\n          break;\n        default:\n          kind = BuildMessage.Kind.INFO;\n      }\n      File sourceFile = null;\n      try {\n        // for eclipse compiler just an attempt to call getSource() may lead to an NPE,\n        // so calling this method under try/catch to avoid induced compiler errors\n        final JavaFileObject source = diagnostic.getSource();\n        sourceFile = source != null ? Utils.convertToFile(source.toUri()) : null;\n      }\n      catch (Exception e) {\n        LOG.info(e);\n      }\n      final String srcPath;\n      if (sourceFile != null) {\n        myFilesWithErrors.add(sourceFile);\n        srcPath = FileUtil.toSystemIndependentName(sourceFile.getPath());\n      }\n      else {\n        srcPath = null;\n      }\n      String message = diagnostic.getMessage(Locale.US);\n      if (Utils.IS_TEST_MODE) {\n        LOG.info(message);\n      }\n      myContext.processMessage(new CompilerMessage(\n        BUILDER_NAME, kind, message, srcPath, diagnostic.getStartPosition(),\n        diagnostic.getEndPosition(), diagnostic.getPosition(), diagnostic.getLineNumber(),\n        diagnostic.getColumnNumber()\n      ));\n    }","commit_id":"21c7fa2be8f8fb3f4c9c5c7f24df66356339d80d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        selenium.click(\"link=Distributed Map\");\n        waitForPageToLoad();\n    }","id":28333,"modified_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        clickAndWait(\"link=Distributed Map\");\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t   * <p>areEqual<\/p>\n\t   *\n\t   * @param aThis a float.\n\t   * @param aThat a float.\n\t   * @return a boolean.\n\t   */\n\t  static public boolean areEqual(float aThis, float aThat){\n\t\t  return Float.valueOf(aThis) == Float.valueOf(aThat);\n\t  }","id":28334,"modified_method":"/**\n\t   * <p>areEqual<\/p>\n\t   *\n\t   * @param aThis a float.\n\t   * @param aThat a float.\n\t   * @return a boolean.\n\t   */\n\t  static public boolean areEqual(float aThis, float aThat){\n\t\t  return areEqual(Float.valueOf(aThis), Float.valueOf(aThat));\n\t  }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t   * <p>areEqual<\/p>\n\t   *\n\t   * @param aThis a double.\n\t   * @param aThat a double.\n\t   * @return a boolean.\n\t   */\n\t  static public boolean areEqual(double aThis, double aThat){\n\t\t  return Double.valueOf(aThis) == Double.valueOf(aThat);\n\t  }","id":28335,"modified_method":"/**\n\t   * <p>areEqual<\/p>\n\t   *\n\t   * @param aThis a double.\n\t   * @param aThat a double.\n\t   * @return a boolean.\n\t   */\n\t  static public boolean areEqual(double aThis, double aThat){\n\t\t  return areEqual(Double.valueOf(aThis), Double.valueOf(aThat));\n\t  }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private List<KscReportDetail> convertJsArrayToList(JsArray<KscReportDetail> kscReportDetails) {\n        List<KscReportDetail> m_list = new ArrayList<KscReportDetail>();\n        \n        for(int i = 0; i < kscReportDetails.length(); i++) {\n            m_list.add(kscReportDetails.get(i));\n        }\n        return m_list;\n    }","id":28336,"modified_method":"private List<KscReportDetail> convertJsArrayToList(JsArray<KscReportDetail> kscReportDetails) {\n        List<KscReportDetail> m_list = new ArrayList<KscReportDetail>();\n        \n        if (kscReportDetails != null) {\n            for(int i = 0; i < kscReportDetails.length(); i++) {\n                m_list.add(kscReportDetails.get(i));\n            }\n        }\n        return m_list;\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void waitForPageToLoad() {\n        selenium.waitForPageToLoad(LOAD_TIMEOUT);\n    }","id":28337,"modified_method":"protected void waitForPageToLoad() {\n        selenium.waitForPageToLoad(String.valueOf(LOAD_TIMEOUT));\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void clickAndWait(final String pattern) {\n        selenium.click(pattern);\n        waitForPageToLoad();\n    }","id":28338,"modified_method":"protected void clickAndWait(final String pattern) {\n        LOG.debug(\"clickAndWait({})\", pattern);\n        selenium.click(pattern);\n        waitForPageToLoad();\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        final String logLevel = System.getProperty(\"org.opennms.smoketest.logLevel\", \"DEBUG\");\n        MockLogAppender.setupLogging(true, logLevel);\n\n        // Google Chrome if chrome driver property is set\n        final String chromeDriverLocation = System.getProperty(\"webdriver.chrome.driver\");\n        if (chromeDriverLocation != null) {\n            final File chromeDriverFile = new File(chromeDriverLocation);\n            if (chromeDriverFile.exists() && chromeDriverFile.canExecute()) {\n                System.err.println(\"using chrome driver\");\n                m_driver = new ChromeDriver();\n            }\n        }\n        \n        // otherwise, PhantomJS or Firefox\n        if (m_driver == null) {\n            final File phantomJS = new File(\"/usr/local/bin/phantomjs\");\n            if (phantomJS.exists()) {\n                final DesiredCapabilities caps = new DesiredCapabilities();\n                caps.setCapability(PhantomJSDriverService.PHANTOMJS_EXECUTABLE_PATH_PROPERTY, \"/usr/local/bin/phantomjs\");\n                \n                m_driver = new PhantomJSDriver(caps);\n            } else {\n                m_driver = new FirefoxDriver();\n            }\n        }\n\n        selenium = new WebDriverBackedSelenium(m_driver, BASE_URL);\n        selenium.open(\"/opennms/login.jsp\");\n        selenium.type(\"name=j_username\", \"admin\");\n        selenium.type(\"name=j_password\", \"admin\");\n        selenium.click(\"name=Login\");\n        waitForPageToLoad();\n    }","id":28339,"modified_method":"@Before\n    public void setUp() throws Exception {\n        final String logLevel = System.getProperty(\"org.opennms.smoketest.logLevel\", \"DEBUG\");\n        MockLogAppender.setupLogging(true, logLevel);\n\n        final String driverClass = System.getProperty(\"webdriver.class\");\n        if (driverClass != null) {\n            m_driver = (WebDriver)Class.forName(driverClass).newInstance();\n        }\n\n        // otherwise, PhantomJS if found, or fall back to Firefox\n        if (m_driver == null) {\n            if (usePhantomJS) {\n                final File phantomJS = findPhantomJS();\n                if (phantomJS != null) {\n                    final DesiredCapabilities caps = new DesiredCapabilities();\n                    caps.setCapability(PhantomJSDriverService.PHANTOMJS_EXECUTABLE_PATH_PROPERTY, phantomJS.toString());\n                    m_driver = new PhantomJSDriver(caps);\n                }\n            }\n            if (m_driver == null) {\n                m_driver = new FirefoxDriver();\n            }\n        }\n\n        LOG.debug(\"Using driver: {}\", m_driver);\n\n        selenium = new WebDriverBackedSelenium(m_driver, BASE_URL);\n        selenium.open(\"/opennms/login.jsp\");\n        selenium.type(\"name=j_username\", \"admin\");\n        selenium.type(\"name=j_password\", \"admin\");\n        selenium.click(\"name=Login\");\n        waitForPageToLoad();\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void goBack() {\n        LogUtils.warnf(this, \"goBack() is not supported on Safari!\");\n        selenium.goBack();\n        waitForPageToLoad();\n    }","id":28340,"modified_method":"protected void goBack() {\n        LOG.warn(\"goBack() is not supported on Safari!\");\n        selenium.goBack();\n        waitForPageToLoad();\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void waitForText(final String expectedText, final long timeout, boolean failOnError) throws InterruptedException {\n        if (!selenium.isTextPresent(expectedText)) {\n            final long timeoutTime = System.currentTimeMillis() + timeout;\n            while (!selenium.isTextPresent(expectedText) && System.currentTimeMillis() <= timeoutTime) {\n                Thread.sleep(timeout / 10);\n            }\n        }\n        try {\n            assertTrue(\"Expected text not found: \" + expectedText, selenium.isTextPresent(expectedText));\n        } catch (final AssertionError e) {\n            if (failOnError) {\n                throw e;\n            } else {\n                LogUtils.errorf(\"Failed to find text %s after %d milliseconds.\", expectedText, timeout);\n                LogUtils.errorf(\"Page body was:\\n%s\", selenium.getBodyText());\n            }\n        }\n    }","id":28341,"modified_method":"protected void waitForText(final String expectedText, final long timeout, boolean failOnError) throws InterruptedException {\n        LOG.debug(\"waitForText({}, {}, {})\", new Object[] { expectedText, timeout, failOnError });\n        if (!selenium.isTextPresent(expectedText)) {\n            final long timeoutTime = System.currentTimeMillis() + timeout;\n            while (!selenium.isTextPresent(expectedText) && System.currentTimeMillis() <= timeoutTime) {\n                Thread.sleep(timeout / 10);\n            }\n        }\n        try {\n            assertTrue(\"Expected text not found: \" + expectedText, selenium.isTextPresent(expectedText));\n        } catch (final AssertionError e) {\n            if (failOnError) {\n                throw e;\n            } else {\n                LOG.error(\"Failed to find text {} after {} milliseconds.\", expectedText, timeout);\n                LOG.error(\"Page body was:\\n{}\", selenium.getBodyText());\n            }\n        }\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void clickAndVerifyText(final String pattern, final String expectedText) {\n        clickAndWait(pattern);\n        assertTrue(\"'\" + expectedText + \" must exist in page\", selenium.isTextPresent(expectedText));\n    }","id":28342,"modified_method":"protected void clickAndVerifyText(final String pattern, final String expectedText) {\n        LOG.debug(\"clickAndVerifyText({}, {})\", pattern, expectedText);\n        clickAndWait(pattern);\n        assertTrue(\"'\" + expectedText + \" must exist in page\", selenium.isTextPresent(expectedText));\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void frontPage() throws Exception {\n        selenium.open(\"/opennms/index.jsp\");\n        waitForPageToLoad();\n    }","id":28343,"modified_method":"protected void frontPage() throws Exception {\n        selenium.open(\"/opennms/\");\n        waitForPageToLoad();\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void waitForHtmlSource(final String expectedText, final long timeout, boolean failOnError) throws InterruptedException {\n        if (!selenium.getHtmlSource().contains(expectedText)) {\n            final long timeoutTime = System.currentTimeMillis() + timeout;\n            while (!selenium.getHtmlSource().contains(expectedText) && System.currentTimeMillis() <= timeoutTime) {\n                Thread.sleep(timeout / 10);\n            }\n        }\n        try {\n            assertTrue(\"HTML source not found: \" + expectedText, selenium.getHtmlSource().contains(expectedText));\n        } catch (final AssertionError e) {\n            if (failOnError) {\n                throw e;\n            } else {\n                LogUtils.errorf(\"Failed to find text %s after %d milliseconds.\", expectedText, timeout);\n                LogUtils.errorf(\"Page body was:\\n%s\", selenium.getBodyText());\n            }\n        }\n    }","id":28344,"modified_method":"protected void waitForHtmlSource(final String expectedText, final long timeout, boolean failOnError) throws InterruptedException {\n        LOG.debug(\"waitForHtmlSource({}, {}, {})\", new Object[] { expectedText, timeout, failOnError });\n        if (!selenium.getHtmlSource().contains(expectedText)) {\n            final long timeoutTime = System.currentTimeMillis() + timeout;\n            while (!selenium.getHtmlSource().contains(expectedText) && System.currentTimeMillis() <= timeoutTime) {\n                Thread.sleep(timeout / 10);\n            }\n        }\n        try {\n            assertTrue(\"HTML source not found: \" + expectedText, selenium.getHtmlSource().contains(expectedText));\n        } catch (final AssertionError e) {\n            if (failOnError) {\n                throw e;\n            } else {\n                LOG.error(\"Failed to find text {} after {} milliseconds.\", expectedText, timeout);\n                LOG.error(\"Page body was:\\n{}\", selenium.getBodyText());\n            }\n        }\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n     public void testAllFormsArePresent() {\n        assertTrue(selenium.isElementPresent(\"css=input[type=submit]\"));\n        assertTrue(selenium.isElementPresent(\"//input[@value='KSC Reports']\"));\n     }","id":28345,"modified_method":"@Test\n     public void testAllFormsArePresent() throws InterruptedException {\n        waitForElement(\"css=input[type=submit]\");\n        waitForElement(\"//input[@value='KSC Reports']\");\n     }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n        selenium.click(\"link=Reports\");\n        waitForPageToLoad();\n    }","id":28346,"modified_method":"@Before\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n        reportsPage();\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        assertTrue(selenium.isTextPresent(\"Reports\"));\n        assertTrue(selenium.isTextPresent(\"Descriptions\"));\n        assertTrue(selenium.isTextPresent(\"Key SNMP Customized\"));\n        assertTrue(selenium.isTextPresent(\"Name contains\"));\n    }","id":28347,"modified_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        waitForText(\"Reports\");\n        waitForText(\"Descriptions\");\n        waitForText(\"Key SNMP Customized\");\n        waitForText(\"Name contains\");\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Ignore\n     @Test\n     public void testDownloadSampleReport() {\n    \t selenium.click(\"link=Database Reports\");\n         assertTrue(selenium.isElementPresent(\"link=Online reports\"));\n    \t selenium.click(\"link=Online reports\");\n    \t assertTrue(selenium.isTextPresent(\"Kochwurst sample JasperReport\"));\n    \t selenium.click(\"link=execute\");\n    \t selenium.click(\"id=run\");\n    \t selenium.waitForPageToLoad(\"300000\");\n    \t selenium.goBack();\n     }","id":28348,"modified_method":"@Ignore\n     @Test\n     public void testDownloadSampleReport() throws InterruptedException {\n         clickAndWait(\"link=Database Reports\");\n         waitForElement(\"link=Online reports\");\n    \t clickAndWait(\"link=Online reports\");\n    \t waitForText(\"Kochwurst sample JasperReport\");\n    \t clickAndWait(\"link=execute\");\n    \t selenium.click(\"id=run\");\n    \t selenium.waitForPageToLoad(\"300000\");\n     }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n      public void testAllLinks() {\n        selenium.click(\"link=Resource Graphs\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Standard Resource\"));\n        assertTrue(selenium.isTextPresent(\"Performance Reports\"));\n        assertTrue(selenium.isTextPresent(\"Custom Resource\"));\n        assertTrue(selenium.isTextPresent(\"Performance Reports\"));\n        assertTrue(selenium.isTextPresent(\"Network Performance Data\"));\n        assertTrue(selenium.isTextPresent(\"The Standard Performance\"));\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n        selenium.click(\"link=KSC Performance, Nodes, Domains\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Customized Reports\"));\n        assertTrue(\"no Node SNMP Interface Reports found, content is: \" + selenium.getHtmlSource(), selenium.isTextPresent(\"Node SNMP Interface Reports\"));\n        assertTrue(selenium.isTextPresent(\"Descriptions\"));\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n        selenium.click(\"link=Database Reports\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Database Reports\"));\n        assertTrue(selenium.isTextPresent(\"Descriptions\"));\n        assertTrue(selenium.isTextPresent(\"You may run or schedule\"));\n        assertTrue(selenium.isElementPresent(\"link=List reports\"));\n        assertTrue(selenium.isElementPresent(\"link=View and manage pre-run reports\"));\n        assertTrue(selenium.isElementPresent(\"link=Manage the batch report schedule\"));\n        selenium.goBack();\n        \n        waitForPageToLoad();\n        selenium.click(\"link=Statistics Reports\");\n        waitForPageToLoad();\n        assertEquals(\"Statistics Reports List | OpenNMS Web Console\", selenium.getTitle());\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n        selenium.click(\"css=strong\");\n        waitForPageToLoad();\n        selenium.type(\"id=input_j_username\", \"admin\");\n        selenium.type(\"name=j_password\", \"admin\");\n        selenium.click(\"name=Login\");\n        waitForPageToLoad();\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n        selenium.click(\"css=strong\");\n        waitForPageToLoad();\n    }","id":28349,"modified_method":"@Test\n      public void testAllLinks() throws Exception {\n        clickAndWait(\"link=Resource Graphs\");\n        waitForText(\"Standard Resource\");\n        waitForText(\"Performance Reports\");\n        waitForText(\"Custom Resource\");\n        waitForText(\"Performance Reports\");\n        waitForText(\"Network Performance Data\");\n        waitForText(\"The Standard Performance\");\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=KSC Performance, Nodes, Domains\");\n        waitForText(\"Customized Reports\");\n        waitForText(\"Node & Domain Interface Reports\");\n        waitForText(\"Descriptions\");\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=Database Reports\");\n        waitForText(\"Database Reports\");\n        waitForText(\"Descriptions\");\n        waitForText(\"You may run or schedule\");\n        waitForElement(\"link=List reports\");\n        waitForElement(\"link=View and manage pre-run reports\");\n        waitForElement(\"link=Manage the batch report schedule\");\n\n        reportsPage();\n        clickAndWait(\"link=Statistics Reports\");\n        assertEquals(\"Statistics Reports List | OpenNMS Web Console\", selenium.getTitle());\n        clickAndWait(\"link=Log out\");\n        clickAndWait(\"css=strong\");\n        selenium.type(\"id=input_j_username\", \"admin\");\n        selenium.type(\"name=j_password\", \"admin\");\n        clickAndWait(\"name=Login\");\n        clickAndWait(\"link=Log out\");\n        clickAndWait(\"css=strong\");\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinksArePresent() {\n        assertTrue(selenium.isElementPresent(\"link=Resource Graphs\"));\n        assertTrue(selenium.isElementPresent(\"link=KSC Performance, Nodes, Domains\"));\n        assertTrue(selenium.isElementPresent(\"link=Database Reports\"));\n        assertTrue(selenium.isElementPresent(\"link=Statistics Reports\"));\n    }","id":28350,"modified_method":"@Test\n    public void testAllLinksArePresent() throws InterruptedException {\n        waitForElement(\"link=Resource Graphs\");\n        waitForElement(\"link=KSC Performance, Nodes, Domains\");\n        waitForElement(\"link=Database Reports\");\n        waitForElement(\"link=Statistics Reports\");\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        assertTrue(selenium.isTextPresent(\"Commercial Support\"));\n        assertTrue(selenium.isTextPresent(\"About\"));\n        assertTrue(selenium.isTextPresent(\"Other Support Options\"));\n    }","id":28351,"modified_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        waitForText(\"Commercial Support\");\n        waitForText(\"About\");\n        waitForText(\"Other Support Options\");\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        selenium.click(\"link=Support\");\n        waitForPageToLoad();\n    }","id":28352,"modified_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n    \tsupportPage();\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinks() {\n        selenium.click(\"link=About the OpenNMS Web Console\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"OpenNMS Web Console\"));\n        assertTrue(selenium.isTextPresent(\"License and Copyright\"));\n        assertTrue(selenium.isTextPresent(\"OSI Certified Open Source Software\"));\n        assertTrue(selenium.isTextPresent(\"Version:\"));\n        selenium.goBack();\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"//a[@href='http://www.opennms.org/documentation/ReleaseNotesStable.html#whats-new']\"));\n        assertTrue(selenium.isElementPresent(\"//a[@href='http://www.opennms.org/wiki/']\"));\n        selenium.click(\"link=Generate a System Report\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Plugins\"));\n        assertTrue(selenium.isTextPresent(\"Report Type\"));\n        assertTrue(selenium.isElementPresent(\"name=formatter\"));\n        assertEquals(\"\", selenium.getValue(\"css=input[type=submit]\"));\n        assertTrue(selenium.isTextPresent(\"Output\"));\n        assertTrue(selenium.isTextPresent(\"Choose which plugins to enable:\"));\n        selenium.goBack();\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"//a[@href='http://issues.opennms.org/']\"));\n        assertTrue(selenium.isElementPresent(\"//a[@href='irc://irc.freenode.net/%23opennms']\"));\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28353,"modified_method":"@Test\n    public void testAllLinks() throws Exception {\n        clickAndWait(\"link=About the OpenNMS Web Console\");\n        waitForText(\"OpenNMS Web Console\");\n        waitForText(\"License and Copyright\");\n        waitForText(\"OSI Certified Open Source Software\");\n        waitForText(\"Version:\");\n\n        supportPage();\n        waitForElement(\"//a[@href='http://www.opennms.org/documentation/ReleaseNotesStable.html#whats-new']\");\n        waitForElement(\"//a[@href='http://www.opennms.org/wiki/']\");\n\n        clickAndWait(\"link=Generate a System Report\");\n        waitForText(\"Plugins\");\n        waitForText(\"Report Type\");\n        waitForElement(\"name=formatter\");\n        assertEquals(\"\", selenium.getValue(\"css=input[type=submit]\"));\n        waitForText(\"Output\");\n        waitForText(\"Choose which plugins to enable:\");\n\n        supportPage();\n        waitForElement(\"//a[@href='http://issues.opennms.org/']\");\n        waitForElement(\"//a[@href='irc://irc.freenode.net/%23opennms']\");\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinksArePresent() {\t\t\n        assertTrue(selenium.isElementPresent(\"link=About the OpenNMS Web Console\"));\n        assertTrue(selenium.isElementPresent(\"link=Release Notes\"));\n        assertTrue(selenium.isElementPresent(\"link=Online Documentation\"));\n        assertTrue(selenium.isElementPresent(\"link=Generate a System Report\"));\n        assertTrue(selenium.isElementPresent(\"link=Open a Bug or Enhancement Request\"));\n        assertTrue(selenium.isElementPresent(\"link=Chat with Developers on IRC\"));\n        assertTrue(selenium.isElementPresent(\"link=the OpenNMS.com support page\"));\n    }","id":28354,"modified_method":"@Test\n    public void testAllLinksArePresent() throws InterruptedException {\t\t\n        waitForElement(\"link=About the OpenNMS Web Console\");\n        waitForElement(\"link=Release Notes\");\n        waitForElement(\"link=Online Documentation\");\n        waitForElement(\"link=Generate a System Report\");\n        waitForElement(\"link=Open a Bug or Enhancement Request\");\n        waitForElement(\"link=Chat with Developers on IRC\");\n        waitForElement(\"link=the OpenNMS.com support page\");\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllFormsArePresent() {\n        assertTrue(selenium.isTextPresent(\"Username:\"));\n        assertTrue(selenium.isTextPresent(\"Password:\"));\n        assertTrue(selenium.isElementPresent(\"css=input[type=reset]\"));\n        assertEquals(\"Log In\", selenium.getValue(\"css=input[type=submit]\"));\n    }","id":28355,"modified_method":"@Test\n    public void testAllFormsArePresent() throws InterruptedException {\n        waitForText(\"Username:\");\n        waitForText(\"Password:\");\n        waitForElement(\"css=input[type=reset]\");\n        assertEquals(\"Log In\", selenium.getValue(\"css=input[type=submit]\"));\n    }","commit_id":"ea24b79a9babb3be2ce3988fa973264c645b980e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void setupProvisioningGroup() throws Exception {\n        selenium.open(\"/opennms/admin/node/add.htm\");\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n        selenium.click(\"link=Manage Provisioning Requisitions\");\n        waitForPageToLoad();\n        selenium.type(\"css=form[name=takeAction] > input[name=groupName]\", \"test\");\n        selenium.click(\"css=input[type=submit]\");\n        waitForPageToLoad();\n        selenium.click(\"//input[@value='Synchronize']\");\n        waitForPageToLoad();\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28356,"modified_method":"@Test\n    public void setupProvisioningGroup() throws Exception {\n        selenium.open(\"/opennms/admin/node/add.htm\");\n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=Manage Provisioning Requisitions\");\n        selenium.type(\"css=form[name=takeAction] > input[name=groupName]\", \"test\");\n        clickAndWait(\"css=input[type=submit]\");\n        clickAndWait(\"//input[@value='Synchronize']\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        selenium.click(\"link=Add Node\");\n        waitForPageToLoad();\n    }","id":28357,"modified_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        clickAndWait(\"link=Add Node\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAddNodePage() throws Exception {\n\n        assertTrue(selenium.isTextPresent(\"Category:\"));\n        assertEquals(\"Provision\", selenium.getValue(\"css=input[type=submit]\"));\n        assertTrue(selenium.isElementPresent(\"css=input[type=reset]\"));\n        assertTrue(selenium.isTextPresent(\"Enable Password:\"));\n        assertTrue(selenium.isTextPresent(\"Node Quick-Add\"));\n        assertTrue(selenium.isTextPresent(\"CLI Authentication Parameters (optional)\"));\n        assertTrue(selenium.isTextPresent(\"SNMP Parameters (optional)\"));\n        assertTrue(selenium.isTextPresent(\"Surveillance Category Memberships (optional)\"));\n        assertTrue(selenium.isTextPresent(\"Basic Attributes (required)\"));\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28358,"modified_method":"@Test\n    public void testAddNodePage() throws Exception {\n\n        waitForText(\"Category:\");\n        assertEquals(\"Provision\", selenium.getValue(\"css=input[type=submit]\"));\n        waitForElement(\"css=input[type=reset]\");\n        waitForText(\"Enable Password:\");\n        waitForText(\"Node Quick-Add\");\n        waitForText(\"CLI Authentication Parameters (optional)\");\n        waitForText(\"SNMP Parameters (optional)\");\n        waitForText(\"Surveillance Category Memberships (optional)\");\n        waitForText(\"Basic Attributes (required)\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testLinkGroupThree() throws Exception {\n        selenium.click(\"link=Add Interface for Scanning\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Enter IP address\"));\n        assertTrue(selenium.isTextPresent(\"Add Interface\"));\n        assertTrue(selenium.isTextPresent(\"valid IP address\"));\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n        selenium.click(\"link=Manage Provisioning Requisitions\");\n        waitForPageToLoad();\n        assertEquals(\"Add New Requisition\", selenium.getValue(\"css=input[type=submit]\"));\n        assertEquals(\"Edit Default Foreign Source Definition\", selenium.getValue(\"css=input[type=button]\"));\n        assertEquals(\"Reset Default Foreign Source Definition\", selenium.getValue(\"//input[@value='Reset Default Foreign Source Definition']\"));\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n        selenium.click(\"link=Import and Export Asset Information\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Import and Export Assets\"));\n        assertTrue(selenium.isTextPresent(\"Importing Asset Information\"));\n        assertTrue(selenium.isTextPresent(\"Exporting Asset Information\"));\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n        selenium.click(\"link=Manage Surveillance Categories\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Surveillance Categories\"));\n        assertTrue(selenium.isTextPresent(\"Category\"));\n        assertEquals(\"Add New Category\", selenium.getValue(\"css=input[type=submit]\"));\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n        selenium.click(\"link=Delete Nodes\");\n        waitForPageToLoad();\n        long endTime = System.currentTimeMillis() + 30000;\n        while(System.currentTimeMillis() < endTime){\n            if(\"Delete Nodes | Admin | OpenNMS Web Console\".equals(selenium.getTitle())){\n                break;\n            }\n            if(endTime - System.currentTimeMillis() < 5000){\n                fail (\"25 second timeout trying to reach \\\"Admin/Delete Nodes\\\" Page\");\n            }\n        }\n        assertTrue(selenium.isTextPresent(\"Delete Nodes\"));\n        assertEquals(\"Delete Nodes | Admin | OpenNMS Web Console\", selenium.getTitle());\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n    }","id":28359,"modified_method":"@Test\n    public void testLinkGroupThree() throws Exception {\n        clickAndWait(\"link=Add Interface for Scanning\");\n        waitForText(\"Enter IP address\");\n        waitForText(\"Add Interface\");\n        waitForText(\"valid IP address\");\n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=Manage Provisioning Requisitions\");\n        assertEquals(\"Add New Requisition\", selenium.getValue(\"css=input[type=submit]\"));\n        assertEquals(\"Edit Default Foreign Source Definition\", selenium.getValue(\"css=input[type=button]\"));\n        assertEquals(\"Reset Default Foreign Source Definition\", selenium.getValue(\"//input[@value='Reset Default Foreign Source Definition']\"));\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=Import and Export Asset Information\");\n        waitForText(\"Import and Export Assets\");\n        waitForText(\"Importing Asset Information\");\n        waitForText(\"Exporting Asset Information\");\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=Manage Surveillance Categories\");\n        waitForText(\"Surveillance Categories\");\n        waitForText(\"Category\");\n        assertEquals(\"Add New Category\", selenium.getValue(\"css=input[type=submit]\"));\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=Delete Nodes\");\n        long endTime = System.currentTimeMillis() + 30000;\n        while(System.currentTimeMillis() < endTime){\n            if(\"Delete Nodes | Admin | OpenNMS Web Console\".equals(selenium.getTitle())){\n                break;\n            }\n            if(endTime - System.currentTimeMillis() < 5000){\n                fail (\"25 second timeout trying to reach \\\"Admin/Delete Nodes\\\" Page\");\n            }\n        }\n        waitForText(\"Delete Nodes\");\n        assertEquals(\"Delete Nodes | Admin | OpenNMS Web Console\", selenium.getTitle());\n        clickAndWait(\"link=Admin\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinksArePresent() throws Exception  {\n\n        assertTrue(selenium.isElementPresent(\"link=Configure Users, Groups and On-Call Roles\"));\n        assertTrue(selenium.isElementPresent(\"link=System Information\"));\n        assertTrue(selenium.isElementPresent(\"link=Instrumentation Log Reader\"));\n        assertTrue(selenium.isElementPresent(\"link=Configure Discovery\"));\n        assertTrue(selenium.isElementPresent(\"link=Configure SNMP Community Names by IP\"));\n        assertTrue(selenium.isElementPresent(\"link=Configure SNMP Data Collection per Interface\"));\n        assertTrue(selenium.isElementPresent(\"link=Manage and Unmanage Interfaces and Services\"));\n        assertTrue(selenium.isElementPresent(\"link=Manage Thresholds\"));\n        assertTrue(selenium.isElementPresent(\"link=Configure Notifications\"));\n        assertTrue(selenium.isElementPresent(\"link=Scheduled Outages\"));\n        assertTrue(selenium.isElementPresent(\"link=Add Interface for Scanning\"));\n        assertTrue(selenium.isElementPresent(\"link=Manage Provisioning Requisitions\"));\n        assertTrue(selenium.isElementPresent(\"link=Import and Export Asset Information\"));\n        assertTrue(selenium.isElementPresent(\"link=Manage Surveillance Categories\"));\n        assertTrue(selenium.isElementPresent(\"link=Delete Nodes\"));\n        assertTrue(selenium.isElementPresent(\"link=Manage Applications\"));\n        assertTrue(selenium.isElementPresent(\"link=Manage Location Monitors\"));\n        assertTrue(selenium.isElementPresent(\"link=the OpenNMS wiki\"));\n    }","id":28360,"modified_method":"@Test\n    public void testAllLinksArePresent() throws Exception  {\n\n        waitForElement(\"link=Configure Users, Groups and On-Call Roles\");\n        waitForElement(\"link=System Information\");\n        waitForElement(\"link=Instrumentation Log Reader\");\n        waitForElement(\"link=Configure Discovery\");\n        waitForElement(\"link=Configure SNMP Community Names by IP\");\n        waitForElement(\"link=Configure SNMP Data Collection per Interface\");\n        waitForElement(\"link=Manage and Unmanage Interfaces and Services\");\n        waitForElement(\"link=Manage Thresholds\");\n        waitForElement(\"link=Configure Notifications\");\n        waitForElement(\"link=Scheduled Outages\");\n        waitForElement(\"link=Add Interface for Scanning\");\n        waitForElement(\"link=Manage Provisioning Requisitions\");\n        waitForElement(\"link=Import and Export Asset Information\");\n        waitForElement(\"link=Manage Surveillance Categories\");\n        waitForElement(\"link=Delete Nodes\");\n        waitForElement(\"link=Manage Applications\");\n        waitForElement(\"link=Manage Location Monitors\");\n        waitForElement(\"link=the OpenNMS wiki\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testLinkGroupOne() throws Exception {\n        selenium.click(\"link=Configure Users, Groups and On-Call Roles\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Users and Groups\"));\n        assertTrue(selenium.isTextPresent(\"Users\"));\n        assertTrue(selenium.isTextPresent(\"Groups\"));\n        assertTrue(selenium.isTextPresent(\"Roles\"));\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n        selenium.click(\"link=System Information\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"OpenNMS Configuration\"));\n        assertTrue(selenium.isTextPresent(\"System Configuration\"));\n        assertTrue(selenium.isTextPresent(\"Reports directory:\"));\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n    }","id":28361,"modified_method":"@Test\n    public void testLinkGroupOne() throws Exception {\n        clickAndWait(\"link=Configure Users, Groups and On-Call Roles\");\n        waitForText(\"Users and Groups\");\n        waitForText(\"Users\");\n        waitForText(\"Groups\");\n        waitForText(\"Roles\");\n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=System Information\");\n        waitForText(\"OpenNMS Configuration\");\n        waitForText(\"System Configuration\");\n        waitForText(\"Reports directory:\");\n        clickAndWait(\"link=Admin\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testLinkGroupTwo() throws Exception {\n        selenium.click(\"link=Configure Discovery\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"General settings\"));\n        assertTrue(selenium.isTextPresent(\"Specifics\"));\n        assertTrue(selenium.isTextPresent(\"Include URLs\"));\n        assertTrue(selenium.isTextPresent(\"Include Ranges\"));\n        assertTrue(selenium.isTextPresent(\"Exclude Ranges\"));\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n        selenium.click(\"link=Configure SNMP Community Names by IP\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Please enter an IP or a range of IPs and the read community string below\"));\n        assertTrue(selenium.isTextPresent(\"Updating SNMP Community Names\"));\n        assertTrue(selenium.isTextPresent(\"optimize this list\"));\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n        selenium.click(\"link=Configure SNMP Data Collection per Interface\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Manage SNMP Data Collection per Interface\"));\n        assertTrue(selenium.isTextPresent(\"datacollection-config.xml file\"));\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n        selenium.click(\"link=Manage and Unmanage Interfaces and Services\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Manage and Unmanage Interfaces and Services\"));\n        assertTrue(selenium.isTextPresent(\"unchecked meaning\"));\n        assertTrue(selenium.isTextPresent(\"mark each service\"));\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n        selenium.click(\"link=Manage Thresholds\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Threshold Configuration\"));\n        assertTrue(selenium.isTextPresent(\"Name\"));\n        assertTrue(selenium.isTextPresent(\"RRD Repository\"));\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n        selenium.click(\"link=Configure Notifications\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Configure Notifications\"));\n        assertTrue(selenium.isTextPresent(\"Event Notifications\"));\n        assertTrue(selenium.isTextPresent(\"Destination Paths\"));\n        assertTrue(selenium.isTextPresent(\"Path Outages\"));\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n        selenium.click(\"link=Scheduled Outages\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Affects...\"));\n        assertTrue(selenium.isTextPresent(\"Notifications\"));\n        assertTrue(selenium.isTextPresent(\"Data collection\"));\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n    }","id":28362,"modified_method":"@Test\n    public void testLinkGroupTwo() throws Exception {\n        clickAndWait(\"link=Configure Discovery\");\n        waitForText(\"General settings\");\n        waitForText(\"Specifics\");\n        waitForText(\"Include URLs\");\n        waitForText(\"Include Ranges\");\n        waitForText(\"Exclude Ranges\");\n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=Configure SNMP Community Names by IP\");\n        waitForText(\"Please enter an IP or a range of IPs and the read community string below\");\n        waitForText(\"Updating SNMP Community Names\");\n        waitForText(\"optimize this list\");\n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=Configure SNMP Data Collection per Interface\");\n        waitForText(\"Manage SNMP Data Collection per Interface\");\n        waitForText(\"datacollection-config.xml file\");\n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=Manage and Unmanage Interfaces and Services\");\n        waitForText(\"Manage and Unmanage Interfaces and Services\");\n        waitForText(\"unchecked meaning\");\n        waitForText(\"mark each service\");\n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=Manage Thresholds\");\n        waitForText(\"Threshold Configuration\");\n        waitForText(\"Name\");\n        waitForText(\"RRD Repository\");\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=Configure Notifications\");\n        waitForText(\"Configure Notifications\");\n        waitForText(\"Event Notifications\");\n        waitForText(\"Destination Paths\");\n        waitForText(\"Path Outages\");\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=Scheduled Outages\");\n        waitForText(\"Affects...\");\n        waitForText(\"Notifications\");\n        waitForText(\"Data collection\");\n        clickAndWait(\"link=Admin\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        assertTrue(selenium.isTextPresent(\"OpenNMS System\"));\n        assertTrue(selenium.isTextPresent(\"Operations\"));\n        assertTrue(selenium.isTextPresent(\"Nodes\"));\n        assertTrue(selenium.isTextPresent(\"Distributed Monitoring\"));\n        assertTrue(selenium.isTextPresent(\"Descriptions\"));\n        assertTrue(selenium.isTextPresent(\"Scheduled Outages: Add\"));\n        assertTrue(selenium.isTextPresent(\"Notification Status:\"));\n    }","id":28363,"modified_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        waitForText(\"OpenNMS System\");\n        waitForText(\"Operations\");\n        waitForText(\"Nodes\");\n        waitForText(\"Distributed Monitoring\");\n        waitForText(\"Descriptions\");\n        waitForText(\"Scheduled Outages: Add\");\n        waitForText(\"Notification Status:\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testLinkGroupFour() throws Exception {\n        selenium.click(\"link=Manage Applications\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Applications\"));\n        assertTrue(selenium.isTextPresent(\"Edit\"));\n        assertEquals(\"Add New Application\", selenium.getValue(\"css=input[type=submit]\"));\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n        selenium.click(\"link=Manage Location Monitors\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Distributed Poller Status\"));\n        assertTrue(selenium.isTextPresent(\"Hostname\"));\n        assertEquals(\"Resume All\", selenium.getValue(\"//input[@value='Resume All']\"));\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n    }","id":28364,"modified_method":"@Test\n    public void testLinkGroupFour() throws Exception {\n        clickAndWait(\"link=Manage Applications\");\n        waitForText(\"Applications\");\n        waitForText(\"Edit\");\n        assertEquals(\"Add New Application\", selenium.getValue(\"css=input[type=submit]\"));\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=Manage Location Monitors\");\n        waitForText(\"Distributed Poller Status\");\n        waitForText(\"Hostname\");\n        assertEquals(\"Resume All\", selenium.getValue(\"//input[@value='Resume All']\"));\n        clickAndWait(\"link=Admin\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n    }","id":28365,"modified_method":"@Before\n    public void setUp() throws Exception {\n        super.setUp();\n        clickAndWait(\"link=Admin\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testLinkGroupFive() throws Exception {\n        assertTrue(selenium.isElementPresent(\"//a[@href='http://www.opennms.org']\"));\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28366,"modified_method":"@Test\n    public void testLinkGroupFive() throws Exception {\n        waitForElement(\"//a[@href='http://www.opennms.org']\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAlarmLink() throws Exception {\n        createAlarm();\n        selenium.click(\"link=All alarms (summary)\");\n        waitForPageToLoad();\n\n        final int sleepTime = 5000; // 5 seconds\n        final long end = System.currentTimeMillis() + 300000; // 5 minutes\n        while (!hasAlarmDetailLink() && (System.currentTimeMillis() < end)) {\n            Thread.sleep(sleepTime);\n            selenium.refresh();\n            waitForPageToLoad();\n        }\n\n        assertTrue(hasAlarmDetailLink());\n\n        assertTrue(selenium.isTextPresent(\"alarm is outstanding\"));\n        assertTrue(selenium.isElementPresent(\"//input[@value='Go']\"));\n        assertTrue(selenium.isElementPresent(\"css=input[type='submit']\"));\n        assertTrue(hasAlarmDetailLink());\n        selenium.click(\"//a[contains(@href,'alarm/detail.htm')]\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Severity\"));\n        assertTrue(selenium.isTextPresent(\"Ticket State\"));\n        assertTrue(selenium.isTextPresent(\"Acknowledgment and Severity Actions\"));\n    }","id":28367,"modified_method":"@Test\n    public void testAlarmLink() throws Exception {\n        createAlarm();\n        clickAndWait(\"link=All alarms (summary)\");\n\n        final int sleepTime = 5000; // 5 seconds\n        final long end = System.currentTimeMillis() + 300000; // 5 minutes\n        while (!hasAlarmDetailLink() && (System.currentTimeMillis() < end)) {\n            Thread.sleep(sleepTime);\n            selenium.refresh();\n            waitForPageToLoad();\n        }\n\n        assertTrue(hasAlarmDetailLink());\n\n        waitForText(\"alarm is outstanding\");\n        waitForElement(\"//input[@value='Go']\");\n        waitForElement(\"css=input[type='submit']\");\n        assertTrue(hasAlarmDetailLink());\n        clickAndWait(\"//a[contains(@href,'alarm/detail.htm')]\");\n        waitForText(\"Severity\");\n        waitForText(\"Ticket State\");\n        waitForText(\"Acknowledgment and Severity Actions\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinks(){\n        selenium.click(\"link=All alarms (summary)\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"alarm is outstanding\"));\n        assertTrue(selenium.isElementPresent(\"//input[@value='Go']\"));\n        assertTrue(selenium.isElementPresent(\"css=input[type='submit']\"));\n        selenium.click(\"css=a[title='Alarms System Page']\");\n        waitForPageToLoad();\n        selenium.click(\"link=All alarms (detail)\");\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"link=First Event Time\"));\n        assertTrue(selenium.isElementPresent(\"link=Last Event Time\"));\n        assertTrue(selenium.isElementPresent(\"css=input[type='reset']\"));\n        assertTrue(selenium.isTextPresent(\"Ack\"));\n        selenium.click(\"css=a[title='Alarms System Page']\");\n        waitForPageToLoad();\n        selenium.click(\"link=Advanced Search\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Alarm Text Contains:\"));\n        assertTrue(selenium.isTextPresent(\"Advanced Alarm Search\"));\n        selenium.open(\"/opennms/alarm/advsearch.jsp\");\n        assertTrue(selenium.isTextPresent(\"Advanced Alarm Search page\"));\n        assertTrue(selenium.isElementPresent(\"css=input[type='submit']\"));\n        assertTrue(selenium.isElementPresent(\"name=beforefirsteventtimemonth\"));\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n    }","id":28368,"modified_method":"@Test\n    public void testAllLinks() throws InterruptedException{\n        clickAndWait(\"link=All alarms (summary)\");\n        waitForText(\"alarm is outstanding\");\n        waitForElement(\"//input[@value='Go']\");\n        waitForElement(\"css=input[type='submit']\");\n        clickAndWait(\"css=a[title='Alarms System Page']\");\n        clickAndWait(\"link=All alarms (detail)\");\n        waitForElement(\"link=First Event Time\");\n        waitForElement(\"link=Last Event Time\");\n        waitForElement(\"css=input[type='reset']\");\n        waitForText(\"Ack\");\n        clickAndWait(\"css=a[title='Alarms System Page']\");\n        clickAndWait(\"link=Advanced Search\");\n        waitForText(\"Alarm Text Contains:\");\n        waitForText(\"Advanced Alarm Search\");\n        selenium.open(\"/opennms/alarm/advsearch.jsp\");\n        waitForText(\"Advanced Alarm Search page\");\n        waitForElement(\"css=input[type='submit']\");\n        waitForElement(\"name=beforefirsteventtimemonth\");\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        super.setUp();\n        selenium.click(\"link=Alarms\");\n        waitForPageToLoad();\n    }","id":28369,"modified_method":"@Before\n    public void setUp() throws Exception {\n        super.setUp();\n        clickAndWait(\"link=Alarms\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllTextIsPresent() {\n        assertTrue(selenium.isTextPresent(\"Alarm Queries\"));\n        assertTrue(selenium.isTextPresent(\"Outstanding and acknowledged alarms\"));\n        assertTrue(selenium.isTextPresent(\"To view acknowledged alarms\"));\n        assertTrue(selenium.isElementPresent(\"css=input[type=submit]\"));\n        assertTrue(selenium.isTextPresent(\"Alarm ID:\"));\n    }","id":28370,"modified_method":"@Test\n    public void testAllTextIsPresent() throws InterruptedException {\n        waitForText(\"Alarm Queries\");\n        waitForText(\"Outstanding and acknowledged alarms\");\n        waitForText(\"To view acknowledged alarms\");\n        waitForElement(\"css=input[type=submit]\");\n        waitForText(\"Alarm ID:\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinksArePresent() { \n        assertTrue(selenium.isElementPresent(\"link=All alarms (summary)\"));\n        assertTrue(selenium.isElementPresent(\"link=All alarms (detail)\"));\n        assertTrue(selenium.isElementPresent(\"link=Advanced Search\"));\n    }","id":28371,"modified_method":"@Test\n    public void testAllLinksArePresent() throws InterruptedException { \n        waitForElement(\"link=All alarms (summary)\");\n        waitForElement(\"link=All alarms (detail)\");\n        waitForElement(\"link=Advanced Search\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinks() {\n        selenium.click(\"link=All nodes with asset info\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Assets\"));\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28372,"modified_method":"@Test\n    public void testAllLinks() throws InterruptedException {\n        clickAndWait(\"link=All nodes with asset info\");\n        waitForText(\"Assets\");\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        selenium.click(\"link=Assets\");\n        waitForPageToLoad();\n    }","id":28373,"modified_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        clickAndWait(\"link=Assets\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test \n    public void testAllLinksArePresent() {\n        assertTrue(selenium.isElementPresent(\"css=input[type=submit]\"));\n        assertTrue(selenium.isElementPresent(\"name=searchvalue\"));\n        assertTrue(selenium.isElementPresent(\"link=All nodes with asset info\"));\n    }","id":28374,"modified_method":"@Test \n    public void testAllLinksArePresent() throws InterruptedException {\n        waitForElement(\"css=input[type=submit]\");\n        waitForElement(\"name=searchvalue\");\n        waitForElement(\"link=All nodes with asset info\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllTextIsPresent() { \n        assertTrue(selenium.isTextPresent(\"Search Asset Information\"));\n        assertTrue(selenium.isTextPresent(\"Assets Inventory\"));\n        assertTrue(selenium.isTextPresent(\"nter the data by hand\"));\n        assertTrue(selenium.isTextPresent(\"Assets with asset numbers\"));\n        assertTrue(selenium.isTextPresent(\"Assets in category\"));\n    }","id":28375,"modified_method":"@Test\n    public void testAllTextIsPresent() throws InterruptedException { \n        waitForText(\"Search Asset Information\");\n        waitForText(\"Assets Inventory\");\n        waitForText(\"nter the data by hand\");\n        waitForText(\"Assets with asset numbers\");\n        waitForText(\"Assets in category\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testChartsPage() throws Exception {\n        assertTrue(selenium.isTextPresent(\"Charts\"));\n        assertTrue(selenium.isElementPresent(\"css=img[alt=sample-bar-chart]\"));\n        assertTrue(selenium.isElementPresent(\"css=img[alt=sample-bar-chart2]\"));\n        assertTrue(selenium.isElementPresent(\"css=img[alt=sample-bar-chart3]\"));\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28376,"modified_method":"@Test\n    public void testChartsPage() throws Exception {\n        waitForText(\"Charts\");\n        waitForElement(\"css=img[alt=sample-bar-chart]\");\n        waitForElement(\"css=img[alt=sample-bar-chart2]\");\n        waitForElement(\"css=img[alt=sample-bar-chart3]\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        selenium.click(\"link=Charts\");\n        waitForPageToLoad();\n    }","id":28377,"modified_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        clickAndWait(\"link=Charts\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDashboardPage() throws Exception {\n        assertTrue(selenium.isTextPresent(\"Alarms\"));\n        assertTrue(selenium.isTextPresent(\"Notifications\"));\n        assertTrue(selenium.isTextPresent(\"Node Status\"));\n        assertTrue(selenium.isTextPresent(\"Resource Graphs\"));\n        assertTrue(selenium.isTextPresent(\"24 Hour Availability\"));\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28378,"modified_method":"@Test\n    public void testDashboardPage() throws Exception {\n        waitForText(\"Alarms\");\n        waitForText(\"Notifications\");\n        waitForText(\"Node Status\");\n        waitForText(\"Resource Graphs\");\n        waitForText(\"24 Hour Availability\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        selenium.click(\"link=Dashboard\");\n        waitForPageToLoad();\n    }","id":28379,"modified_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        clickAndWait(\"link=Dashboard\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n    \tselenium.click(\"//a[@href='maps.htm']\");\n    \twaitForPageToLoad();\n        selenium.click(\"//div[@id='content']//a[contains(@href,'RemotePollerMap')]\");\n        waitForPageToLoad();\n    }","id":28380,"modified_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n    \tclickAndWait(\"//a[@href='maps.htm']\");\n        clickAndWait(\"//div[@id='content']//a[contains(@href,'RemotePollerMap')]\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test \n    public void testAllLinks() {\n        selenium.click(\"link=All events\");\n        waitForPageToLoad();\n        assertFalse(selenium.isTextPresent(\"Ack\"));\n        assertTrue(selenium.isTextPresent(\"Event(s) outstanding\"));\n        assertTrue(selenium.isTextPresent(\"Event Text\"));\n        assertTrue(selenium.isElementPresent(\"link=Interface\"));\n        selenium.click(\"css=a[title='Events System Page']\");\n        waitForPageToLoad();\n        selenium.click(\"link=Advanced Search\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Advanced Event Search\"));\n        assertTrue(selenium.isTextPresent(\"Searching Instructions\"));\n        assertTrue(selenium.isTextPresent(\"Advanced Event Search\"));\n        assertTrue(selenium.isElementPresent(\"name=usebeforetime\"));\n        assertTrue(selenium.isElementPresent(\"name=limit\"));\n        assertTrue(selenium.isElementPresent(\"css=input[type='submit']\"));\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28381,"modified_method":"@Test \n    public void testAllLinks() throws InterruptedException {\n        clickAndWait(\"link=All events\");\n        assertFalse(selenium.isTextPresent(\"Ack\"));\n        waitForText(\"Event(s) outstanding\");\n        waitForText(\"Event Text\");\n        waitForElement(\"link=Interface\");\n        clickAndWait(\"css=a[title='Events System Page']\");\n        clickAndWait(\"link=Advanced Search\");\n        waitForText(\"Advanced Event Search\");\n        waitForText(\"Searching Instructions\");\n        waitForText(\"Advanced Event Search\");\n        waitForElement(\"name=usebeforetime\");\n        waitForElement(\"name=limit\");\n        waitForElement(\"css=input[type='submit']\");\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        selenium.click(\"link=Events\");\n        waitForPageToLoad();\n    }","id":28382,"modified_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        clickAndWait(\"link=Events\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllTextIsPresent() throws Exception {       \n        assertTrue(selenium.isTextPresent(\"Event Queries\"));\n        assertTrue(selenium.isTextPresent(\"Outstanding and acknowledged events\"));\n        assertTrue(selenium.isTextPresent(\"hit [Enter]\"));\n        assertTrue(selenium.isTextPresent(\"Event ID:\"));\n    }","id":28383,"modified_method":"@Test\n    public void testAllTextIsPresent() throws Exception {       \n        waitForText(\"Event Queries\");\n        waitForText(\"Outstanding and acknowledged events\");\n        waitForText(\"hit [Enter]\");\n        waitForText(\"Event ID:\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinksArePresent() {\n        assertEquals(\"Get details\", selenium.getValue(\"css=input[type='submit']\"));\n        assertTrue(selenium.isElementPresent(\"link=All events\"));\n        assertTrue(selenium.isElementPresent(\"link=Advanced Search\"));\n    }","id":28384,"modified_method":"@Test\n    public void testAllLinksArePresent() throws InterruptedException {\n        assertEquals(\"Get details\", selenium.getValue(\"css=input[type='submit']\"));\n        waitForElement(\"link=All events\");\n        waitForElement(\"link=Advanced Search\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        super.setUp();\n        selenium.open(\"/opennms/admin/index.jsp\");\n        waitForPageToLoad();\n        selenium.click(\"link=Instrumentation Log Reader\");\n        waitForPageToLoad();\n    }","id":28385,"modified_method":"@Before\n    public void setUp() throws Exception {\n        super.setUp();\n        selenium.open(\"/opennms/admin/index.jsp\");\n        waitForPageToLoad();\n        clickAndWait(\"link=Instrumentation Log Reader\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSortingLinks() {\n        selenium.click(\"link=Collections\");\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"link=Collections ^\"));\n        selenium.click(\"link=Collections ^\");\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"link=Collections v\"));\n        selenium.click(\"link=Average Successful Collection Time\");\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"link=Average Successful Collection Time ^\"));\n        selenium.click(\"link=Average Successful Collection Time ^\");\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"link=Average Successful Collection Time v\"));\n        selenium.click(\"link=Average Persistence Time\");\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"link=Average Persistence Time ^\"));\n        selenium.click(\"link=Average Persistence Time ^\");\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"link=Average Persistence Time v\"));\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28386,"modified_method":"@Test\n    public void testSortingLinks() throws InterruptedException {\n        clickAndWait(\"link=Collections\");\n        waitForElement(\"link=Collections ^\");\n        clickAndWait(\"link=Collections ^\");\n        waitForElement(\"link=Collections v\");\n        clickAndWait(\"link=Average Successful Collection Time\");\n        waitForElement(\"link=Average Successful Collection Time ^\");\n        clickAndWait(\"link=Average Successful Collection Time ^\");\n        waitForElement(\"link=Average Successful Collection Time v\");\n        clickAndWait(\"link=Average Persistence Time\");\n        waitForElement(\"link=Average Persistence Time ^\");\n        clickAndWait(\"link=Average Persistence Time ^\");\n        waitForElement(\"link=Average Persistence Time v\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testInstrumentationLogReaderPage() throws Exception {\n        selenium.type(\"name=searchString\", \"test\");\n        selenium.click(\"css=input[type=submit]\");\n        waitForPageToLoad();\n        assertEquals(\"test\", selenium.getValue(\"name=searchString\"));\n        selenium.click(\"css=form > input[type=submit]\");\n        waitForPageToLoad();\n        assertEquals(\"\", selenium.getValue(\"name=searchString\"));\n        assertTrue(selenium.isTextPresent(\"Service\"));\n        assertTrue(selenium.isTextPresent(\"Threads Used:\"));\n        assertTrue(selenium.isElementPresent(\"link=Collections\"));\n        assertTrue(selenium.isElementPresent(\"link=Average Collection Time\"));\n        assertTrue(selenium.isElementPresent(\"link=Unsuccessful Percentage\"));\n        assertTrue(selenium.isElementPresent(\"link=Average Persistence Time\"));\n    }","id":28387,"modified_method":"@Test\n    public void testInstrumentationLogReaderPage() throws Exception {\n        selenium.type(\"name=searchString\", \"test\");\n        clickAndWait(\"css=input[type=submit]\");\n        assertEquals(\"test\", selenium.getValue(\"name=searchString\"));\n        clickAndWait(\"css=form > input[type=submit]\");\n        assertEquals(\"\", selenium.getValue(\"name=searchString\"));\n        waitForText(\"Service\");\n        waitForText(\"Threads Used:\");\n        waitForElement(\"link=Collections\");\n        waitForElement(\"link=Average Collection Time\");\n        waitForElement(\"link=Unsuccessful Percentage\");\n        waitForElement(\"link=Average Persistence Time\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testMapPage() throws Exception {\n        assertTrue(selenium.isElementPresent(\"id=mainSvgDocument\"));\n        assertTrue(selenium.isTextPresent(\"Network Topology Maps\"));\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28388,"modified_method":"@Test\n    public void testMapPage() throws Exception {\n        waitForElement(\"id=mainSvgDocument\");\n        waitForText(\"Network Topology Maps\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        selenium.click(\"//a[@href='maps.htm']\");\n        waitForPageToLoad();\n        selenium.click(\"//div[@id='content']//a[contains(@href,'map/index.jsp')]\");\n        waitForPageToLoad();\n    }","id":28389,"modified_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        clickAndWait(\"//a[@href='maps.htm']\");\n        clickAndWait(\"//div[@id='content']//a[contains(@href,'map/index.jsp')]\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinksArePresent() {\n        assertTrue(\"Could not find nodeList.htm link\", selenium.isElementPresent(\"//a[@href='element/nodeList.htm?listInterfaces=true']\"));\n    }","id":28390,"modified_method":"@Test\n    public void testAllLinksArePresent() throws InterruptedException {\n        waitForElement(\"//a[@href='element/nodeList.htm?listInterfaces=true']\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinks() {\n        selenium.click(\"link=Show interfaces\");\n        waitForPageToLoad();\n        assertTrue(\"Could not find string 'interfaces' in response\", selenium.isTextPresent(\"interfaces\"));\n    }","id":28391,"modified_method":"@Test\n    public void testAllLinks() throws InterruptedException {\n        clickAndWait(\"link=Show interfaces\");\n        waitForText(\"interfaces\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        selenium.click(\"link=Node List\");\n        waitForPageToLoad();\n    }","id":28392,"modified_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        clickAndWait(\"link=Node List\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinksArePresent() {\n        assertTrue(selenium.isElementPresent(\"link=Your outstanding notices\"));\n        assertTrue(selenium.isElementPresent(\"link=All outstanding notices\"));\n        assertTrue(selenium.isElementPresent(\"link=All acknowledged notices\"));\n    }","id":28393,"modified_method":"@Test\n    public void testAllLinksArePresent() throws InterruptedException {\n        waitForElement(\"link=Your outstanding notices\");\n        waitForElement(\"link=All outstanding notices\");\n        waitForElement(\"link=All acknowledged notices\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinks() {\n        selenium.click(\"link=Your outstanding notices\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"admin was notified\"));\n        assertTrue(selenium.isElementPresent(\"link=[Remove all]\"));\n        assertTrue(selenium.isElementPresent(\"link=Sent Time\"));\n        assertTrue(selenium.isElementPresent(\"//input[@value='Acknowledge Notices']\"));\n        selenium.click(\"link=Notices\");\n        waitForPageToLoad();\n        selenium.click(\"link=All outstanding notices\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"only outstanding notices\"));\n        assertTrue(selenium.isElementPresent(\"link=Respond Time\"));\n        assertTrue(selenium.isElementPresent(\"css=input[type=button]\"));\n        selenium.click(\"link=Notices\");\n        waitForPageToLoad();\n        selenium.click(\"link=All acknowledged notices\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"only acknowledged notices\"));\n        assertTrue(selenium.isElementPresent(\"link=Node\"));\n        assertTrue(selenium.isElementPresent(\"css=input[type=submit]\"));\n        selenium.click(\"link=Notices\");\n        waitForPageToLoad();\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28394,"modified_method":"@Test\n    public void testAllLinks() throws InterruptedException {\n        clickAndWait(\"link=Your outstanding notices\");\n        waitForText(\"admin was notified\");\n        waitForElement(\"link=[Remove all]\");\n        waitForElement(\"link=Sent Time\");\n        waitForElement(\"//input[@value='Acknowledge Notices']\");\n        clickAndWait(\"link=Notices\");\n        clickAndWait(\"link=All outstanding notices\");\n        waitForText(\"only outstanding notices\");\n        waitForElement(\"link=Respond Time\");\n        waitForElement(\"css=input[type=button]\");\n        clickAndWait(\"link=Notices\");\n        clickAndWait(\"link=All acknowledged notices\");\n        waitForText(\"only acknowledged notices\");\n        waitForElement(\"link=Node\");\n        waitForElement(\"css=input[type=submit]\");\n        clickAndWait(\"link=Notices\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test \n    public void testAllFormsArePresent() {\n        assertTrue(selenium.isElementPresent(\"css=input[type=submit]\"));\n        assertTrue(selenium.isElementPresent(\"//input[@value='Get details']\"));\n    }","id":28395,"modified_method":"@Test \n    public void testAllFormsArePresent() throws InterruptedException {\n        waitForElement(\"css=input[type=submit]\");\n        waitForElement(\"//input[@value='Get details']\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        selenium.click(\"link=Notifications\");\n        waitForPageToLoad();\n    }","id":28396,"modified_method":"@Before\n    public void setUp() throws Exception {\n        super.setUp();\n        clickAndWait(\"link=Notifications\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        assertTrue(selenium.isTextPresent(\"Notification queries\"));\n        assertTrue(selenium.isTextPresent(\"Outstanding and Acknowledged Notices\"));\n        assertTrue(selenium.isTextPresent(\"Notification Escalation\"));\n        assertTrue(selenium.isTextPresent(\"Check your outstanding notices\"));\n        assertTrue(selenium.isTextPresent(\"Once a notice is sent\"));\n        assertTrue(selenium.isTextPresent(\"User:\"));\n        assertTrue(selenium.isTextPresent(\"Notice:\"));\n    }","id":28397,"modified_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        waitForText(\"Notification queries\");\n        waitForText(\"Outstanding and Acknowledged Notices\");\n        waitForText(\"Notification Escalation\");\n        waitForText(\"Check your outstanding notices\");\n        waitForText(\"Once a notice is sent\");\n        waitForText(\"User:\");\n        waitForText(\"Notice:\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void waitForText(final String expectedText, final long timeout) throws InterruptedException {\n        final long timeoutTime = System.currentTimeMillis() + timeout;\n        while (!selenium.isTextPresent(expectedText) && System.currentTimeMillis() <= timeoutTime) {\n            Thread.sleep(timeout / 10);\n        }\n        assertTrue(selenium.isTextPresent(expectedText));\n    }","id":28398,"modified_method":"protected void waitForText(final String expectedText, final long timeout) throws InterruptedException {\n        if (!selenium.isTextPresent(expectedText)) {\n            final long timeoutTime = System.currentTimeMillis() + timeout;\n            while (!selenium.isTextPresent(expectedText) && System.currentTimeMillis() <= timeoutTime) {\n                Thread.sleep(timeout / 10);\n            }\n        }\n        try {\n            assertTrue(selenium.isTextPresent(expectedText));\n        } catch (final AssertionError e) {\n            LogUtils.errorf(this, \"Failed to find text %s after %d milliseconds.\", expectedText, timeout);\n            LogUtils.errorf(this, \"Page body was:\\n%s\", selenium.getBodyText());\n        }\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinksArePresent() {\n        assertTrue(selenium.isElementPresent(\"link=Current outages\"));\n        assertTrue(selenium.isElementPresent(\"link=All outages\"));\n    }","id":28399,"modified_method":"@Test\n    public void testAllLinksArePresent() throws InterruptedException {\n        waitForElement(\"link=Current outages\");\n        waitForElement(\"link=All outages\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        selenium.click(\"link=Outages\");\n        waitForPageToLoad();\n    }","id":28400,"modified_method":"@Before\n    public void setUp() throws Exception {\n        super.setUp();\n        clickAndWait(\"link=Outages\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinks() {\n        selenium.click(\"link=Current outages\");\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"name=outtype\"));\n        assertTrue(selenium.isElementPresent(\"css=input[type='submit']\"));\n        assertTrue(selenium.isElementPresent(\"link=Interface\"));\n        selenium.click(\"css=a[title='Outages System Page']\");\n        waitForPageToLoad();\n        selenium.click(\"link=All outages\");\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"name=outtype\"));\n        assertTrue(selenium.isTextPresent(\"Current Resolved Both Current & Resolved\"));\n        assertTrue(selenium.isTextPresent(\"Interface\"));\n        selenium.click(\"css=a[title='Outages System Page']\");\n        waitForPageToLoad();\n        selenium.click(\"css=input[type='submit']\");\n        assertEquals(\"Please enter a valid outage ID.\", selenium.getAlert());\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28401,"modified_method":"@Test\n    public void testAllLinks() throws InterruptedException {\n        clickAndWait(\"link=Current outages\");\n        waitForElement(\"name=outtype\");\n        waitForElement(\"css=input[type='submit']\");\n        waitForElement(\"link=Interface\");\n        clickAndWait(\"css=a[title='Outages System Page']\");\n        clickAndWait(\"link=All outages\");\n        waitForElement(\"name=outtype\");\n        waitForText(\"Current Resolved Both Current & Resolved\");\n        waitForText(\"Interface\");\n        clickAndWait(\"css=a[title='Outages System Page']\");\n        clickAndWait(\"css=input[type='submit']\");\n        assertEquals(\"Please enter a valid outage ID.\", selenium.getAlert());\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        assertTrue(selenium.isTextPresent(\"Outage Menu\"));\n        assertTrue(selenium.isTextPresent(\"Outages and Service Level Availability\"));\n        assertTrue(selenium.isTextPresent(\"Outage ID\"));\n        assertTrue(selenium.isTextPresent(\"create notifications\"));\n    }","id":28402,"modified_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        waitForText(\"Outage Menu\");\n        waitForText(\"Outages and Service Level Availability\");\n        waitForText(\"Outage ID\");\n        waitForText(\"create notifications\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        selenium.click(\"link=Path Outages\");\n        waitForPageToLoad();\n    }","id":28403,"modified_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        clickAndWait(\"link=Path Outages\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testPathOutagesPage() throws Exception {\n        assertTrue(selenium.isTextPresent(\"All path outages\"));\n        assertTrue(selenium.isTextPresent(\"Critical Path IP\"));\n        assertTrue(selenium.isTextPresent(\"# of Nodes\"));\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28404,"modified_method":"@Test\n    public void testPathOutagesPage() throws Exception {\n        waitForText(\"All path outages\");\n        waitForText(\"Critical Path IP\");\n        waitForText(\"# of Nodes\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Ignore\n     @Test\n     public void testDownloadSampleReport() {\n    \t selenium.click(\"link=Database Reports\");\n         assertTrue(selenium.isElementPresent(\"link=Online reports\"));\n    \t selenium.click(\"link=Online reports\");\n    \t assertTrue(selenium.isTextPresent(\"Kochwurst sample JasperReport\"));\n    \t selenium.click(\"link=execute\");\n    \t selenium.click(\"id=run\");\n    \t selenium.waitForPageToLoad(\"300000\");\n    \t selenium.goBack();\n     }","id":28405,"modified_method":"@Ignore\n     @Test\n     public void testDownloadSampleReport() throws InterruptedException {\n    \t clickAndWait(\"link=Database Reports\");\n         waitForElement(\"link=Online reports\");\n    \t clickAndWait(\"link=Online reports\");\n    \t waitForText(\"Kochwurst sample JasperReport\");\n    \t clickAndWait(\"link=execute\");\n    \t selenium.click(\"id=run\");\n    \t selenium.waitForPageToLoad(\"300000\");\n    \t goBack();\n     }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n      public void testAllLinks() {\n        selenium.click(\"link=Resource Graphs\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Standard Resource\"));\n        assertTrue(selenium.isTextPresent(\"Performance Reports\"));\n        assertTrue(selenium.isTextPresent(\"Custom Resource\"));\n        assertTrue(selenium.isTextPresent(\"Performance Reports\"));\n        assertTrue(selenium.isTextPresent(\"Network Performance Data\"));\n        assertTrue(selenium.isTextPresent(\"The Standard Performance\"));\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n        selenium.click(\"link=KSC Performance, Nodes, Domains\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Customized Reports\"));\n        assertTrue(\"no Node & Domain Interface Reports found, content is: \" + selenium.getHtmlSource(), selenium.isTextPresent(\"Node & Domain Interface Reports\"));\n        assertTrue(selenium.isTextPresent(\"Descriptions\"));\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n        selenium.click(\"link=Database Reports\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Database Reports\"));\n        assertTrue(selenium.isTextPresent(\"Descriptions\"));\n        assertTrue(selenium.isTextPresent(\"You may run or schedule\"));\n        assertTrue(selenium.isElementPresent(\"link=List reports\"));\n        assertTrue(selenium.isElementPresent(\"link=View and manage pre-run reports\"));\n        assertTrue(selenium.isElementPresent(\"link=Manage the batch report schedule\"));\n        selenium.goBack();\n        \n        waitForPageToLoad();\n        selenium.click(\"link=Statistics Reports\");\n        waitForPageToLoad();\n        assertEquals(\"Statistics Reports List | OpenNMS Web Console\", selenium.getTitle());\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n        selenium.click(\"css=strong\");\n        waitForPageToLoad();\n        selenium.type(\"id=input_j_username\", \"admin\");\n        selenium.type(\"name=j_password\", \"admin\");\n        selenium.click(\"name=Login\");\n        waitForPageToLoad();\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n        selenium.click(\"css=strong\");\n        waitForPageToLoad();\n    }","id":28406,"modified_method":"@Test\n      public void testAllLinks() throws InterruptedException {\n        clickAndWait(\"link=Resource Graphs\");\n        waitForText(\"Standard Resource\");\n        waitForText(\"Performance Reports\");\n        waitForText(\"Custom Resource\");\n        waitForText(\"Performance Reports\");\n        waitForText(\"Network Performance Data\");\n        waitForText(\"The Standard Performance\");\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=KSC Performance, Nodes, Domains\");\n        waitForText(\"Customized Reports\");\n        waitForText(\"Node & Domain Interface Reports\");\n        waitForText(\"Descriptions\");\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=Database Reports\");\n        waitForText(\"Database Reports\");\n        waitForText(\"Descriptions\");\n        waitForText(\"You may run or schedule\");\n        waitForElement(\"link=List reports\");\n        waitForElement(\"link=View and manage pre-run reports\");\n        waitForElement(\"link=Manage the batch report schedule\");\n        goBack();\n        \n        clickAndWait(\"link=Statistics Reports\");\n        assertEquals(\"Statistics Reports List | OpenNMS Web Console\", selenium.getTitle());\n        clickAndWait(\"link=Log out\");\n        clickAndWait(\"css=strong\");\n        selenium.type(\"id=input_j_username\", \"admin\");\n        selenium.type(\"name=j_password\", \"admin\");\n        clickAndWait(\"name=Login\");\n        clickAndWait(\"link=Log out\");\n        clickAndWait(\"css=strong\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        assertTrue(selenium.isTextPresent(\"Reports\"));\n        assertTrue(selenium.isTextPresent(\"Descriptions\"));\n        assertTrue(selenium.isTextPresent(\"Key SNMP Customized\"));\n        assertTrue(selenium.isTextPresent(\"Name contains\"));\n    }","id":28407,"modified_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        waitForText(\"Reports\");\n        waitForText(\"Descriptions\");\n        waitForText(\"Key SNMP Customized\");\n        waitForText(\"Name contains\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n     public void testAllFormsArePresent() {\n        assertTrue(selenium.isElementPresent(\"css=input[type=submit]\"));\n        assertTrue(selenium.isElementPresent(\"//input[@value='KSC Reports']\"));\n     }","id":28408,"modified_method":"@Test\n     public void testAllFormsArePresent() throws InterruptedException {\n        waitForElement(\"css=input[type=submit]\");\n        waitForElement(\"//input[@value='KSC Reports']\");\n     }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinksArePresent() {\n        assertTrue(selenium.isElementPresent(\"link=Resource Graphs\"));\n        assertTrue(selenium.isElementPresent(\"link=KSC Performance, Nodes, Domains\"));\n        assertTrue(selenium.isElementPresent(\"link=Database Reports\"));\n        assertTrue(selenium.isElementPresent(\"link=Statistics Reports\"));\n    }","id":28409,"modified_method":"@Test\n    public void testAllLinksArePresent() throws InterruptedException {\n        waitForElement(\"link=Resource Graphs\");\n        waitForElement(\"link=KSC Performance, Nodes, Domains\");\n        waitForElement(\"link=Database Reports\");\n        waitForElement(\"link=Statistics Reports\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n        selenium.click(\"link=Reports\");\n        waitForPageToLoad();\n    }","id":28410,"modified_method":"@Before\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n        clickAndWait(\"link=Reports\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinks() throws InterruptedException {\n        clickAndWait(\"link=All nodes\");\n        waitForText(\"Nodes\", LOAD_TIMEOUT);\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=All nodes and their interfaces\");\n        assertTrue(selenium.isTextPresent(\"Nodes and their interfaces\"));\n        assertTrue(selenium.isElementPresent(\"link=Hide interfaces\"));\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=All nodes with asset info\");\n        assertTrue(selenium.isTextPresent(\"Assets\"));\n    }","id":28411,"modified_method":"@Test\n    public void testAllLinks() throws InterruptedException {\n        clickAndWait(\"link=All nodes\");\n        waitForText(\"Nodes\", LOAD_TIMEOUT);\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=All nodes and their interfaces\");\n        waitForText(\"Nodes and their interfaces\");\n        waitForElement(\"link=Hide interfaces\");\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=All nodes with asset info\");\n        waitForText(\"Assets\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test \n    public void testAllFormsArePresent() {\n        assertTrue(selenium.isElementPresent(\"css=input[type=submit]\"));\n        assertEquals(\"Search\", selenium.getValue(\"css=input[type=submit]\"));\n    }","id":28412,"modified_method":"@Test \n    public void testAllFormsArePresent() throws InterruptedException {\n        waitForElement(\"css=input[type=submit]\");\n        assertEquals(\"Search\", selenium.getValue(\"css=input[type=submit]\"));\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinksArePresent() {\n        assertTrue(selenium.isElementPresent(\"link=All nodes\"));\n        assertTrue(selenium.isElementPresent(\"link=All nodes and their interfaces\"));\n        assertTrue(selenium.isElementPresent(\"link=All nodes with asset info\"));\n    }","id":28413,"modified_method":"@Test\n    public void testAllLinksArePresent() throws InterruptedException {\n        waitForElement(\"link=All nodes\");\n        waitForElement(\"link=All nodes and their interfaces\");\n        waitForElement(\"link=All nodes with asset info\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        assertTrue(selenium.isTextPresent(\"Search for Nodes\"));\n        assertTrue(selenium.isTextPresent(\"Search Asset Information\"));\n        assertTrue(selenium.isTextPresent(\"Search Options\"));\n        assertTrue(selenium.isTextPresent(\"MAC Address\"));\n    }","id":28414,"modified_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        waitForText(\"Search for Nodes\");\n        waitForText(\"Search Asset Information\");\n        waitForText(\"Search Options\");\n        waitForText(\"MAC Address\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        super.setUp();\n        selenium.click(\"link=Search\");\n        waitForPageToLoad();\n    }","id":28415,"modified_method":"@Before\n    public void setUp() throws Exception {\n        super.setUp();\n        clickAndWait(\"link=Search\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test  \n    public void testCreateGroup() {\n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=Configure Users, Groups and On-Call Roles\");\n        clickAndWait(\"link=Configure Groups\");\n        clickAndWait(\"link=Add new group\");\n        selenium.type(\"id=groupName\", \"SmokeTestGroup\");\n        selenium.type(\"id=groupComment\", \"Test\");\n        clickAndWait(\"id=doOK\");\n        clickAndWait(\"name=finish\");\n        clickAndWait(\"//div[@id='content']/form/table/tbody/tr[4]/td[2]/a/img\");\n        selenium.addSelection(\"name=availableUsers\", \"label=SmokeTestUser\");\n        selenium.click(\"xpath=/html/body/div[2]/form/table[2]/tbody/tr[2]/td/table/tbody/tr[2]/td/p/input[2]\");\n        clickAndWait(\"name=finish\");\n        clickAndWait(\"link=SmokeTestGroup\");\n        assertTrue(selenium.isTextPresent(\"SmokeTestUser\"));\n    }","id":28416,"modified_method":"@Test  \n    public void testCreateGroup() throws InterruptedException {\n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=Configure Users, Groups and On-Call Roles\");\n        clickAndWait(\"link=Configure Groups\");\n        clickAndWait(\"link=Add new group\");\n        selenium.type(\"id=groupName\", \"SmokeTestGroup\");\n        selenium.type(\"id=groupComment\", \"Test\");\n        clickAndWait(\"id=doOK\");\n        clickAndWait(\"name=finish\");\n        clickAndWait(\"//div[@id='content']/form/table/tbody/tr[4]/td[2]/a/img\");\n        selenium.addSelection(\"name=availableUsers\", \"label=SmokeTestUser\");\n        selenium.click(\"xpath=/html/body/div[2]/form/table[2]/tbody/tr[2]/td/table/tbody/tr[2]/td/p/input[2]\");\n        clickAndWait(\"name=finish\");\n        clickAndWait(\"link=SmokeTestGroup\");\n        waitForText(\"SmokeTestUser\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testProvisioningGroupWasCreated() throws InterruptedException {\n        clickAndWait(\"link=Node List\");\n        if(selenium.isElementPresent(\"link=localNode\")) {\n            // if there's more than 1 node discovered, it will give a list\n            clickAndWait(\"link=localNode\");\n        }\n        // otherwise it will go straight to the only node's page\n\n        if(selenium.isElementPresent(\"link=ICMP\")){\n            clickAndWait(\"link=ICMP\");\n            assertTrue(\"Managed text not found\", selenium.isTextPresent(\"regexp:(Managed|Not Monitored)\"));\n            assertTrue(\"IP text not found\", selenium.isTextPresent(\"regexp:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0*1\"));\n            assertTrue(\"localNode text not found\", selenium.isTextPresent(\"localNode\"));\n        } else {\n            fail(\"Neither of the links were found. Printing page source: \" + selenium.getHtmlSource());\n        }\n    }","id":28417,"modified_method":"@Test\n    public void testProvisioningGroupWasCreated() throws InterruptedException {\n        clickAndWait(\"link=Node List\");\n        if(selenium.isElementPresent(\"link=localNode\")) {\n            // if there's more than 1 node discovered, it will give a list\n            clickAndWait(\"link=localNode\");\n        }\n        // otherwise it will go straight to the only node's page\n\n        if(selenium.isElementPresent(\"link=ICMP\")){\n            clickAndWait(\"link=ICMP\");\n            waitForText(\"regexp:(Managed|Not Monitored)\");\n            waitForText(\"regexp:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0*1\");\n            waitForText(\"localNode\");\n        } else {\n            fail(\"Neither of the links were found. Printing page source: \" + selenium.getHtmlSource());\n        }\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllTopLevelLinks() throws InterruptedException {\n        clickAndWait(\"link=Node List\");\n        long endTime = System.currentTimeMillis() + 60000;\n        while(System.currentTimeMillis() < endTime){\n            if(selenium.isTextPresent(\"Availability\") || selenium.isElementPresent(\"link=localNode\")){\n                break;\n            }\n            selenium.refresh();\n            waitForPageToLoad();\n            if(endTime - System.currentTimeMillis() < 5000){\n                fail (\"55 second timeout trying to reach \\\"Node List/localNode\\\" Page\");\n            }\n        }\n        clickAndWait(\"link=Search\");\n        assertTrue(selenium.isTextPresent(\"Search for Nodes\"));\n        assertTrue(selenium.isTextPresent(\"Search Asset Information\"));\n        assertTrue(selenium.isTextPresent(\"Search Options\"));\n        assertTrue(selenium.isElementPresent(\"link=All nodes with asset info\"));\n        clickAndWait(\"link=Outages\");\n        assertTrue(selenium.isElementPresent(\"link=Current outages\"));\n        assertTrue(selenium.isTextPresent(\"Outages and Service Level Availability\"));\n        assertTrue(selenium.isTextPresent(\"Outage Menu\"));\n        clickAndWait(\"link=Path Outages\");\n        assertTrue(selenium.isTextPresent(\"All path outages\"));\n        assertTrue(selenium.isTextPresent(\"Critical Path Service\"));\n        clickAndWait(\"link=Dashboard\");\n        assertTrue(selenium.isTextPresent(\"Node Status\"));\n        assertTrue(selenium.isTextPresent(\"24 Hour Availability\"));\n        clickAndWait(\"link=Alarms\");\n        assertTrue(selenium.isTextPresent(\"Alarm Queries\"));\n        assertTrue(selenium.isTextPresent(\"Outstanding and acknowledged alarms\"));\n        assertTrue(selenium.isTextPresent(\"Alarm ID:\"));\n        clickAndWait(\"link=Events\");\n        assertTrue(selenium.isTextPresent(\"Event Queries\"));\n        assertTrue(selenium.isTextPresent(\"Outstanding and acknowledged events\"));     \n        clickAndWait(\"link=Notifications\");\n        assertTrue(selenium.isTextPresent(\"Notification queries\"));\n        assertTrue(selenium.isTextPresent(\"Outstanding and Acknowledged Notices\"));\n        assertTrue(selenium.isTextPresent(\"Notification Escalation\"));\n        clickAndWait(\"link=Assets\");\n        assertTrue(selenium.isTextPresent(\"Search Asset Information\"));\n        assertTrue(selenium.isTextPresent(\"Assets with asset numbers\"));\n        assertTrue(selenium.isTextPresent(\"Assets Inventory\"));\n        clickAndWait(\"link=Reports\");\n        assertTrue(selenium.isTextPresent(\"Reports\"));\n        assertTrue(selenium.isTextPresent(\"Descriptions\"));\n        clickAndWait(\"link=Charts\");\n        selenium.click(\"link=Surveillance\");\n        waitForText(\"Surveillance View:\", LOAD_TIMEOUT);\n\n        assertTrue(selenium.isTextPresent(\"Routers\"));\n        assertTrue(selenium.isTextPresent(\"Surveillance View: default\"));\n        clickAndWait(\"//a[@href='maps.htm']\");\n        clickAndWait(\"//div[@id='content']//a[contains(@href,'RemotePollerMap')]\");\n        assertTrue(selenium.isElementPresent(\"link=Applications\"));\n        goBack();\n        clickAndWait(\"link=Add Node\");\n        assertTrue(selenium.isTextPresent(\"Node Quick-Add\"));\n        assertTrue(selenium.isTextPresent(\"CLI Authentication Parameters\"));\n        clickAndWait(\"link=Admin\");\n        assertTrue(selenium.isTextPresent(\"OpenNMS System\"));\n        assertTrue(selenium.isTextPresent(\"Operations\"));\n        assertTrue(selenium.isTextPresent(\"Nodes\"));\n        assertTrue(selenium.isTextPresent(\"Distributed Monitoring\"));\n        assertTrue(selenium.isTextPresent(\"Descriptions\"));\n    }","id":28418,"modified_method":"@Test\n    public void testAllTopLevelLinks() throws InterruptedException {\n        clickAndWait(\"link=Node List\");\n        long endTime = System.currentTimeMillis() + 60000;\n        while(System.currentTimeMillis() < endTime){\n            if(selenium.isTextPresent(\"Availability\") || selenium.isElementPresent(\"link=localNode\")){\n                break;\n            }\n            selenium.refresh();\n            waitForPageToLoad();\n            if(endTime - System.currentTimeMillis() < 5000){\n                fail (\"55 second timeout trying to reach \\\"Node List/localNode\\\" Page\");\n            }\n        }\n        clickAndWait(\"link=Search\");\n        waitForText(\"Search for Nodes\");\n        waitForText(\"Search Asset Information\");\n        waitForText(\"Search Options\");\n        waitForText(\"link=All nodes with asset info\");\n        clickAndWait(\"link=Outages\");\n        waitForElement(\"link=Current outages\");\n        waitForText(\"Outages and Service Level Availability\");\n        waitForText(\"Outage Menu\");\n        clickAndWait(\"link=Path Outages\");\n        waitForText(\"All path outages\");\n        waitForText(\"Critical Path Service\");\n        clickAndWait(\"link=Dashboard\");\n        waitForText(\"Node Status\");\n        waitForText(\"24 Hour Availability\");\n        clickAndWait(\"link=Alarms\");\n        waitForText(\"Alarm Queries\");\n        waitForText(\"Outstanding and acknowledged alarms\");\n        waitForText(\"Alarm ID:\");\n        clickAndWait(\"link=Events\");\n        waitForText(\"Event Queries\");\n        waitForText(\"Outstanding and acknowledged events\");\n        clickAndWait(\"link=Notifications\");\n        waitForText(\"Notification queries\");\n        waitForText(\"Outstanding and Acknowledged Notices\");\n        waitForText(\"Notification Escalation\");\n        clickAndWait(\"link=Assets\");\n        waitForText(\"Search Asset Information\");\n        waitForText(\"Assets with asset numbers\");\n        waitForText(\"Assets Inventory\");\n        clickAndWait(\"link=Reports\");\n        waitForText(\"Reports\");\n        waitForText(\"Descriptions\");\n        clickAndWait(\"link=Charts\");\n        selenium.click(\"link=Surveillance\");\n        waitForText(\"Surveillance View:\", LOAD_TIMEOUT);\n\n        waitForText(\"Routers\");\n        waitForText(\"Surveillance View: default\");\n        clickAndWait(\"//a[@href='maps.htm']\");\n        clickAndWait(\"//div[@id='content']//a[contains(@href,'RemotePollerMap')]\");\n        waitForElement(\"link=Applications\");\n        goBack();\n        clickAndWait(\"link=Add Node\");\n        waitForText(\"Node Quick-Add\");\n        waitForText(\"CLI Authentication Parameters\");\n        clickAndWait(\"link=Admin\");\n        waitForText(\"OpenNMS System\");\n        waitForText(\"Operations\");\n        waitForText(\"Nodes\");\n        waitForText(\"Distributed Monitoring\");\n        waitForText(\"Descriptions\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testCreateUser() { \n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=Configure Users, Groups and On-Call Roles\");\n        clickAndWait(\"link=Configure Users\");\n        clickAndWait(\"link=Add New User\");\n        selenium.type(\"id=userID\", \"SmokeTestUser\");\n        selenium.type(\"id=pass1\", \"SmokeTestPassword\");\n        selenium.type(\"id=pass2\", \"SmokeTestPassword\");\n        clickAndWait(\"id=doOK\");\n        clickAndWait(\"id=saveUserButton\");\n        assertTrue(selenium.isElementPresent(\"id=users(SmokeTestUser).doDetails\"));\n    }","id":28419,"modified_method":"@Test\n    public void testCreateUser() throws InterruptedException { \n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=Configure Users, Groups and On-Call Roles\");\n        clickAndWait(\"link=Configure Users\");\n        clickAndWait(\"link=Add New User\");\n        selenium.type(\"id=userID\", \"SmokeTestUser\");\n        selenium.type(\"id=pass1\", \"SmokeTestPassword\");\n        selenium.type(\"id=pass2\", \"SmokeTestPassword\");\n        clickAndWait(\"id=doOK\");\n        clickAndWait(\"id=saveUserButton\");\n        waitForElement(\"id=users(SmokeTestUser).doDetails\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllFormsArePresent() {\n        assertTrue(selenium.isTextPresent(\"Username:\"));\n        assertTrue(selenium.isTextPresent(\"Password:\"));\n        assertTrue(selenium.isElementPresent(\"css=input[type=reset]\"));\n        assertEquals(\"Log In\", selenium.getValue(\"css=input[type=submit]\"));\n    }","id":28420,"modified_method":"@Test\n    public void testAllFormsArePresent() throws InterruptedException {\n        waitForText(\"Username:\");\n        waitForText(\"Password:\");\n        waitForElement(\"css=input[type=reset]\");\n        assertEquals(\"Log In\", selenium.getValue(\"css=input[type=submit]\"));\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinks() {\n        clickAndWait(\"link=About the OpenNMS Web Console\");\n        assertTrue(selenium.isTextPresent(\"OpenNMS Web Console\"));\n        assertTrue(selenium.isTextPresent(\"License and Copyright\"));\n        assertTrue(selenium.isTextPresent(\"OSI Certified Open Source Software\"));\n        assertTrue(selenium.isTextPresent(\"Version:\"));\n        goBack();\n        assertTrue(selenium.isElementPresent(\"//a[@href='http://www.opennms.org/documentation/ReleaseNotesStable.html#whats-new']\"));\n        assertTrue(selenium.isElementPresent(\"//a[@href='http://www.opennms.org/wiki/']\"));\n\n        clickAndWait(\"link=Generate a System Report\");\n        assertTrue(selenium.isTextPresent(\"Plugins\"));\n        assertTrue(selenium.isTextPresent(\"Report Type\"));\n        assertTrue(selenium.isElementPresent(\"name=formatter\"));\n        assertEquals(\"\", selenium.getValue(\"css=input[type=submit]\"));\n        assertTrue(selenium.isTextPresent(\"Output\"));\n        assertTrue(selenium.isTextPresent(\"Choose which plugins to enable:\"));\n        goBack();\n        assertTrue(selenium.isElementPresent(\"//a[@href='http://issues.opennms.org/']\"));\n        assertTrue(selenium.isElementPresent(\"//a[@href='irc://irc.freenode.net/%23opennms']\"));\n    }","id":28421,"modified_method":"@Test\n    public void testAllLinks() throws InterruptedException {\n        clickAndWait(\"link=About the OpenNMS Web Console\");\n        waitForText(\"OpenNMS Web Console\");\n        waitForText(\"License and Copyright\");\n        waitForText(\"OSI Certified Open Source Software\");\n        waitForText(\"Version:\");\n        goBack();\n        waitForElement(\"//a[@href='http://www.opennms.org/documentation/ReleaseNotesStable.html#whats-new']\");\n        waitForElement(\"//a[@href='http://www.opennms.org/wiki/']\");\n\n        clickAndWait(\"link=Generate a System Report\");\n        waitForText(\"Plugins\");\n        waitForText(\"Report Type\");\n        waitForElement(\"name=formatter\");\n        assertEquals(\"\", selenium.getValue(\"css=input[type=submit]\"));\n        waitForText(\"Output\");\n        waitForText(\"Choose which plugins to enable:\");\n        goBack();\n        waitForElement(\"//a[@href='http://issues.opennms.org/']\");\n        waitForElement(\"//a[@href='irc://irc.freenode.net/%23opennms']\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinksArePresent() {\t\t\n        assertTrue(selenium.isElementPresent(\"link=About the OpenNMS Web Console\"));\n        assertTrue(selenium.isElementPresent(\"link=Release Notes\"));\n        assertTrue(selenium.isElementPresent(\"link=Online Documentation\"));\n        assertTrue(selenium.isElementPresent(\"link=Generate a System Report\"));\n        assertTrue(selenium.isElementPresent(\"link=Open a Bug or Enhancement Request\"));\n        assertTrue(selenium.isElementPresent(\"link=Chat with Developers on IRC\"));\n        assertTrue(selenium.isElementPresent(\"link=the OpenNMS.com support page\"));\n    }","id":28422,"modified_method":"@Test\n    public void testAllLinksArePresent() throws InterruptedException {\t\t\n        waitForElement(\"link=About the OpenNMS Web Console\");\n        waitForElement(\"link=Release Notes\");\n        waitForElement(\"link=Online Documentation\");\n        waitForElement(\"link=Generate a System Report\");\n        waitForElement(\"link=Open a Bug or Enhancement Request\");\n        waitForElement(\"link=Chat with Developers on IRC\");\n        waitForElement(\"link=the OpenNMS.com support page\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        assertTrue(selenium.isTextPresent(\"Commercial Support\"));\n        assertTrue(selenium.isTextPresent(\"About\"));\n        assertTrue(selenium.isTextPresent(\"Other Support Options\"));\n    }","id":28423,"modified_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        waitForText(\"Commercial Support\");\n        waitForText(\"About\");\n        waitForText(\"Other Support Options\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        super.setUp();\n        selenium.click(\"link=Surveillance\");\n        waitForPageToLoad();\n    }","id":28424,"modified_method":"@Before\n    public void setUp() throws Exception {\n        super.setUp();\n        clickAndWait(\"link=Surveillance\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSurveillancePage() throws Exception {\n        waitForText(\"Surveillance View:\", LOAD_TIMEOUT);\n        assertTrue(selenium.isTextPresent(\"Routers\"));\n        assertTrue(selenium.isTextPresent(\"Nodes Down\"));\n        assertTrue(selenium.isTextPresent(\"DEV\"));\n    }","id":28425,"modified_method":"@Test\n    public void testSurveillancePage() throws Exception {\n        waitForText(\"Surveillance View:\");\n        waitForText(\"Routers\");\n        waitForText(\"Nodes Down\");\n        waitForText(\"DEV\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test \n    public void testAllLinksArePresent() {\n        assertTrue(selenium.isElementPresent(\"link=Change Password\"));\n    }","id":28426,"modified_method":"@Test \n    public void testAllLinksArePresent() throws InterruptedException {\n        waitForElement(\"link=Change Password\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        assertTrue(selenium.isTextPresent(\"User Account Self-Service\"));\n        assertTrue(selenium.isTextPresent(\"Account Self-Service Options\"));\n        assertTrue(selenium.isTextPresent(\"require further\"));\n    }","id":28427,"modified_method":"@Test\n    public void testAllTextIsPresent() throws Exception {\n        waitForText(\"User Account Self-Service\");\n        waitForText(\"Account Self-Service Options\");\n        waitForText(\"require further\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinks() {\n        selenium.click(\"link=Change Password\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Please enter the old and new passwords and confirm.\"));\n        assertTrue(selenium.isTextPresent(\"Current Password\"));\n        assertTrue(selenium.isElementPresent(\"link=Cancel\"));\n    }","id":28428,"modified_method":"@Test\n    public void testAllLinks() throws InterruptedException {\n        clickAndWait(\"link=Change Password\");\n        waitForText(\"Please enter the old and new passwords and confirm.\");\n        waitForText(\"Current Password\");\n        waitForElement(\"link=Cancel\");\n    }","commit_id":"4e21b459d0967ff087ae3a85a01464a2190f4305","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testHeaderMenuLinks() throws Exception {\n        clickAndWait(\"link=Node List\");\n        clickAndVerifyText(\"link=Search\", \"Search for Nodes\");\n        clickAndVerifyText(\"link=Outages\", \"Outage Menu\");\n        clickAndVerifyText(\"link=Path Outages\", \"All path outages\");\n        clickAndWait(\"link=Dashboard\");\n        waitForText(\"Surveillance View:\", LOAD_TIMEOUT);\n        clickAndVerifyText(\"link=Events\", \"Event Queries\");\n        clickAndVerifyText(\"link=Alarms\", \"Alarm Queries\");\n        clickAndVerifyText(\"link=Notifications\", \"Notification queries\");\n        clickAndVerifyText(\"link=Assets\", \"Search Asset Information\");\n        clickAndVerifyText(\"link=Reports\", \"Resource Graphs\");\n        clickAndVerifyText(\"link=Charts\", \"/ Charts\");\n        clickAndWait(\"link=Surveillance\");\n        assertTrue(selenium.isTextPresent(\"Surveillance View:\") || selenium.isTextPresent(\"Finding status for nodes\"));\n        clickAndWait(\"link=Distributed Status\");\n        assertTrue(selenium.isTextPresent(\"Distributed Poller Status Summary\") || selenium.isTextPresent(\"No applications have been defined for this system\"));\n        clickAndVerifyText(\"//a[@href='maps.htm']\", \"OpenNMS Maps\");\n        clickAndVerifyText(\"//div[@id='content']//a[contains(text(), 'Distributed')]\", \"clear selected tags\");\n        goBack();\n\n        // the vaadin apps are finicky\n        clickAndWait(\"//div[@id='content']//a[contains(text(), 'Topology')]\");\n        Thread.sleep(1000);\n        assertTrue(selenium.getHtmlSource().contains(\"vaadin.initApplication(\\\"opennmstopology\"));\n        handleVaadinErrorButtons();\n        goBack();\n        goBack();\n\n        clickAndVerifyText(\"//a[@href='maps.htm']\", \"OpenNMS Maps\");\n        clickAndWait(\"//div[@id='content']//a[contains(text(), 'Geographical')]\");\n        Thread.sleep(1000);\n        assertTrue(selenium.getHtmlSource().contains(\"vaadin.initApplication(\\\"opennmsnodemaps\"));\n        handleVaadinErrorButtons();\n\n        clickAndVerifyText(\"//a[@href='maps.htm']\", \"OpenNMS Maps\");\n        clickAndWait(\"//div[@id='content']//a[contains(text(), 'SVG')]\");\n        waitForText(\"/ Network Topology Maps\", LOAD_TIMEOUT);\n\n        clickAndVerifyText(\"link=Add Node\", \"Community String:\");\n        clickAndVerifyText(\"link=Admin\", \"Configure Users, Groups and On-Call Roles\");\n        clickAndVerifyText(\"link=Support\", \"Enter your OpenNMS Group commercial support login\");\n    }","id":28429,"modified_method":"@Test\n    public void testHeaderMenuLinks() throws Exception {\n        clickAndWait(\"link=Node List\");\n        clickAndVerifyText(\"link=Search\", \"Search for Nodes\");\n        clickAndVerifyText(\"link=Outages\", \"Outage Menu\");\n        clickAndVerifyText(\"link=Path Outages\", \"All path outages\");\n        clickAndWait(\"link=Dashboard\");\n        waitForText(\"Surveillance View:\", LOAD_TIMEOUT);\n        clickAndVerifyText(\"link=Events\", \"Event Queries\");\n        clickAndVerifyText(\"link=Alarms\", \"Alarm Queries\");\n        clickAndVerifyText(\"link=Notifications\", \"Notification queries\");\n        clickAndVerifyText(\"link=Assets\", \"Search Asset Information\");\n        clickAndVerifyText(\"link=Reports\", \"Resource Graphs\");\n        clickAndVerifyText(\"link=Charts\", \"/ Charts\");\n        clickAndVerifyText(\"link=Surveillance\", \"/ Surveillance\");\n        clickAndWait(\"link=Distributed Status\");\n        assertTrue(selenium.isTextPresent(\"Distributed Poller Status Summary\") || selenium.isTextPresent(\"No applications have been defined for this system\"));\n        clickAndVerifyText(\"//a[@href='maps.htm']\", \"OpenNMS Maps\");\n        clickAndVerifyText(\"//div[@id='content']//a[contains(text(), 'Distributed')]\", \"clear selected tags\");\n        goBack();\n\n        // the vaadin apps are finicky\n        clickAndWait(\"//div[@id='content']//a[contains(text(), 'Topology')]\");\n        Thread.sleep(1000);\n        assertTrue(selenium.getHtmlSource().contains(\"vaadin.initApplication(\\\"opennmstopology\"));\n        handleVaadinErrorButtons();\n        goBack();\n        goBack();\n\n        clickAndVerifyText(\"//a[@href='maps.htm']\", \"OpenNMS Maps\");\n        clickAndWait(\"//div[@id='content']//a[contains(text(), 'Geographical')]\");\n        Thread.sleep(1000);\n        assertTrue(selenium.getHtmlSource().contains(\"vaadin.initApplication(\\\"opennmsnodemaps\"));\n        handleVaadinErrorButtons();\n\n        clickAndVerifyText(\"//a[@href='maps.htm']\", \"OpenNMS Maps\");\n        clickAndWait(\"//div[@id='content']//a[contains(text(), 'SVG')]\");\n        waitForText(\"/ Network Topology Maps\", LOAD_TIMEOUT);\n\n        clickAndVerifyText(\"link=Add Node\", \"Community String:\");\n        clickAndVerifyText(\"link=Admin\", \"Configure Users, Groups and On-Call Roles\");\n        clickAndVerifyText(\"link=Support\", \"Enter your OpenNMS Group commercial support login\");\n    }","commit_id":"e9ad52e1e38d6d5797f78221cf333821ad95c206","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@After\n    public void tearDown() throws Exception {\n        if (selenium != null) selenium.stop();\n    }","id":28430,"modified_method":"@After\n    public void tearDown() throws Exception {\n        clickAndWait(\"link=Log out\");\n        if (selenium != null) selenium.stop();\n    }","commit_id":"e9ad52e1e38d6d5797f78221cf333821ad95c206","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n     public void testAllLinks() {\n        selenium.click(\"link=All nodes\");\n        waitForPageToLoad();\n        long endTime = System.currentTimeMillis() + 30000;\n        while(System.currentTimeMillis() < endTime){\n            if(selenium.isTextPresent(\"Nodes\")){\n                break;\n            }\n            if(endTime - System.currentTimeMillis() < 5000){\n                fail (\"25 second timeout trying to reach \\\"Search/All nodes\\\" Page\");\n            }\n        }\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n        selenium.click(\"link=All nodes and their interfaces\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Nodes and their interfaces\"));\n        assertTrue(selenium.isElementPresent(\"link=Hide interfaces\"));\n        selenium.click(\"//div[@id='content']/div/h2/a[2]\");\n        waitForPageToLoad();\n        selenium.click(\"link=All nodes with asset info\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Assets\"));\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28431,"modified_method":"@Test\n    public void testAllLinks() throws InterruptedException {\n        clickAndWait(\"link=All nodes\");\n        waitForText(\"Nodes\", LOAD_TIMEOUT);\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=All nodes and their interfaces\");\n        assertTrue(selenium.isTextPresent(\"Nodes and their interfaces\"));\n        assertTrue(selenium.isElementPresent(\"link=Hide interfaces\"));\n        clickAndWait(\"//div[@id='content']/div/h2/a[2]\");\n        clickAndWait(\"link=All nodes with asset info\");\n        assertTrue(selenium.isTextPresent(\"Assets\"));\n    }","commit_id":"e9ad52e1e38d6d5797f78221cf333821ad95c206","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testCreateUser() { \n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n        selenium.click(\"link=Configure Users, Groups and On-Call Roles\");\n        waitForPageToLoad();\n        selenium.click(\"link=Configure Users\");\n        waitForPageToLoad();\n        selenium.click(\"link=Add New User\");\n        waitForPageToLoad();\n        selenium.type(\"id=userID\", \"SmokeTestUser\");\n        selenium.type(\"id=pass1\", \"SmokeTestPassword\");\n        selenium.type(\"id=pass2\", \"SmokeTestPassword\");\n        selenium.click(\"id=doOK\");\n        waitForPageToLoad();\n        selenium.click(\"id=saveUserButton\");\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"id=users(SmokeTestUser).doDetails\"));\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28432,"modified_method":"@Test\n    public void testCreateUser() { \n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=Configure Users, Groups and On-Call Roles\");\n        clickAndWait(\"link=Configure Users\");\n        clickAndWait(\"link=Add New User\");\n        selenium.type(\"id=userID\", \"SmokeTestUser\");\n        selenium.type(\"id=pass1\", \"SmokeTestPassword\");\n        selenium.type(\"id=pass2\", \"SmokeTestPassword\");\n        clickAndWait(\"id=doOK\");\n        clickAndWait(\"id=saveUserButton\");\n        assertTrue(selenium.isElementPresent(\"id=users(SmokeTestUser).doDetails\"));\n    }","commit_id":"e9ad52e1e38d6d5797f78221cf333821ad95c206","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test  \n    public void testCreateGroup() {\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n        selenium.click(\"link=Configure Users, Groups and On-Call Roles\");\n        waitForPageToLoad();\n        selenium.click(\"link=Configure Groups\");\n        waitForPageToLoad();\n        selenium.click(\"link=Add new group\");\n        waitForPageToLoad();\n        selenium.type(\"id=groupName\", \"SmokeTestGroup\");\n        selenium.type(\"id=groupComment\", \"Test\");\n        selenium.click(\"id=doOK\");\n        waitForPageToLoad();\n        selenium.click(\"name=finish\");\n        waitForPageToLoad();\n        selenium.click(\"//div[@id='content']/form/table/tbody/tr[4]/td[2]/a/img\");\n        waitForPageToLoad();\n        selenium.addSelection(\"name=availableUsers\", \"label=SmokeTestUser\");\n        selenium.click(\"xpath=/html/body/div[2]/form/table[2]/tbody/tr[2]/td/table/tbody/tr[2]/td/p/input[2]\");\n        selenium.click(\"name=finish\");\n        waitForPageToLoad();\n        selenium.click(\"link=SmokeTestGroup\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"SmokeTestUser\"));\n    }","id":28433,"modified_method":"@Test  \n    public void testCreateGroup() {\n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=Configure Users, Groups and On-Call Roles\");\n        clickAndWait(\"link=Configure Groups\");\n        clickAndWait(\"link=Add new group\");\n        selenium.type(\"id=groupName\", \"SmokeTestGroup\");\n        selenium.type(\"id=groupComment\", \"Test\");\n        clickAndWait(\"id=doOK\");\n        clickAndWait(\"name=finish\");\n        clickAndWait(\"//div[@id='content']/form/table/tbody/tr[4]/td[2]/a/img\");\n        selenium.addSelection(\"name=availableUsers\", \"label=SmokeTestUser\");\n        selenium.click(\"xpath=/html/body/div[2]/form/table[2]/tbody/tr[2]/td/table/tbody/tr[2]/td/p/input[2]\");\n        clickAndWait(\"name=finish\");\n        clickAndWait(\"link=SmokeTestGroup\");\n        assertTrue(selenium.isTextPresent(\"SmokeTestUser\"));\n    }","commit_id":"e9ad52e1e38d6d5797f78221cf333821ad95c206","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testProvisioningGroupWasCreated() throws InterruptedException {\n        selenium.click(\"link=Node List\");\n        waitForPageToLoad();\n        if(selenium.isElementPresent(\"link=localNode\")) {\n            // if there's more than 1 node discovered, it will give a list\n            selenium.click(\"link=localNode\");\n            waitForPageToLoad();\n        }\n        // otherwise it will go straight to the only node's page\n\n        if(selenium.isElementPresent(\"link=ICMP\")){\n            selenium.click(\"link=ICMP\");\n            waitForPageToLoad();\n            assertTrue(\"Managed text not found\", selenium.isTextPresent(\"regexp:(Managed|Not Monitored)\"));\n            assertTrue(\"IP text not found\", selenium.isTextPresent(\"regexp:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0*1\"));\n            assertTrue(\"localNode text not found\", selenium.isTextPresent(\"localNode\"));\n        } else {\n            fail(\"Neither of the links were found. Printing page source: \" + selenium.getHtmlSource());\n        }\n    }","id":28434,"modified_method":"@Test\n    public void testProvisioningGroupWasCreated() throws InterruptedException {\n        clickAndWait(\"link=Node List\");\n        if(selenium.isElementPresent(\"link=localNode\")) {\n            // if there's more than 1 node discovered, it will give a list\n            clickAndWait(\"link=localNode\");\n        }\n        // otherwise it will go straight to the only node's page\n\n        if(selenium.isElementPresent(\"link=ICMP\")){\n            clickAndWait(\"link=ICMP\");\n            assertTrue(\"Managed text not found\", selenium.isTextPresent(\"regexp:(Managed|Not Monitored)\"));\n            assertTrue(\"IP text not found\", selenium.isTextPresent(\"regexp:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0+\\\\:0*1\"));\n            assertTrue(\"localNode text not found\", selenium.isTextPresent(\"localNode\"));\n        } else {\n            fail(\"Neither of the links were found. Printing page source: \" + selenium.getHtmlSource());\n        }\n    }","commit_id":"e9ad52e1e38d6d5797f78221cf333821ad95c206","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDeleteUsersAndGroups() {\n        waitForPageToLoad();\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n        selenium.click(\"link=Configure Users, Groups and On-Call Roles\");\n        waitForPageToLoad();\n        selenium.click(\"link=Configure Groups\");\n        waitForPageToLoad();\n        selenium.click(\"//div[@id='content']/form/table/tbody/tr[4]/td/a/img\");\n        selenium.click(\"link=Users and Groups\");\n        waitForPageToLoad();\n        selenium.click(\"link=Configure Users\");\n        waitForPageToLoad();\n        selenium.click(\"xpath=//html/body/div[2]/form/table/tbody/tr[2]/td/a/img\");  \n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28435,"modified_method":"@Test\n    public void testDeleteUsersAndGroups() {\n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=Configure Users, Groups and On-Call Roles\");\n        clickAndWait(\"link=Configure Groups\");\n        selenium.click(\"//div[@id='content']/form/table/tbody/tr[4]/td/a/img\");\n        clickAndWait(\"link=Users and Groups\");\n        clickAndWait(\"link=Configure Users\");\n        selenium.click(\"xpath=//html/body/div[2]/form/table/tbody/tr[2]/td/a/img\");  \n    }","commit_id":"e9ad52e1e38d6d5797f78221cf333821ad95c206","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testProvisioningGroupSetup() throws Exception {\n    \t\n        String groupName = \"SeleniumTestGroup\";\n\n        selenium.click(\"link=Admin\");\n\n        waitForPageToLoad();\n\n        selenium.click(\"link=Manage Provisioning Requisitions\");\n        waitForPageToLoad();\n\n        selenium.type(\"css=form[name=takeAction] > input[name=groupName]\", groupName);\n        selenium.click(\"css=input[type=submit]\");\n        waitForPageToLoad();\n\n        selenium.click(\"//a[contains(@href, 'editForeignSource(\\\"\"+ groupName+\"\\\")')]\");\n        waitForPageToLoad();\n        \n        selenium.click(\"//input[@value='Add Detector']\");\n        waitForPageToLoad();\n        \n        String detectorNode = setTreeFieldsAndSave(\"foreignSourceEditForm\", type(\"name\", \"HTTP-8080\"), select(\"pluginClass\", \"HTTP\"));\n        waitForPageToLoad();\n        \n        selenium.click(\"//a[contains(@href, '\"+detectorNode+\"') and text() = '[Add Parameter]']\");\n        waitForPageToLoad();\n        \n        setTreeFieldsAndSave(\"foreignSourceEditForm\", select(\"key\", \"port\"), type(\"value\", \"8080\"));\n        \n        waitForPageToLoad();\n        \n        selenium.click(\"//input[@value='Done']\");\n        waitForPageToLoad();\n\n        selenium.click(\"//a[contains(@href, '\" + groupName + \"') and contains(@href, 'editRequisition') and text() = 'Edit']\");\n        waitForPageToLoad();\n\n        selenium.click(\"//input[@value='Add Node']\");\n        waitForPageToLoad();\n        \n        String nodeForNode = setTreeFieldsAndSave(\"nodeEditForm\", type(\"nodeLabel\", \"localNode\"));\n        waitForPageToLoad();\n        \n        selenium.click(\"//a[contains(@href, '\" + nodeForNode + \"') and text() = '[Add Interface]']\");\n        waitForPageToLoad();\n\n        setTreeFieldsAndSave(\"nodeEditForm\", type(\"ipAddr\", \"::1\"));\n        waitForPageToLoad();\n\n        selenium.click(\"//a[text() = 'Add Service']\");\n        waitForPageToLoad();\n        \n        setTreeFieldsAndSave(\"nodeEditForm\", type(\"serviceName\", \"HTTP-8080\"));\n        waitForPageToLoad();\n\n        selenium.click(\"//input[@value='Done']\");\n        waitForPageToLoad();\n\n        selenium.click(\"//input[@value='Synchronize']\");\n        waitForPageToLoad();\n\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n        \n        // Yo dawg, I heard you liked hacks\n        Thread.sleep(10000);\n    }","id":28436,"modified_method":"@Test\n    public void testProvisioningGroupSetup() throws Exception {\n\n        String groupName = \"SeleniumTestGroup\";\n\n        clickAndWait(\"link=Admin\");\n\n        clickAndWait(\"link=Manage Provisioning Requisitions\");\n        waitForPageToLoad();\n\n        selenium.type(\"css=form[name=takeAction] > input[name=groupName]\", groupName);\n        clickAndWait(\"css=input[type=submit]\");\n        clickAndWait(\"//a[contains(@href, 'editForeignSource(\\\"\"+ groupName+\"\\\")')]\");\n        clickAndWait(\"//input[@value='Add Detector']\");\n\n        String detectorNode = setTreeFieldsAndSave(\"foreignSourceEditForm\", type(\"name\", \"HTTP-8080\"), select(\"pluginClass\", \"HTTP\"));\n        waitForPageToLoad();\n\n        clickAndWait(\"//a[contains(@href, '\"+detectorNode+\"') and text() = '[Add Parameter]']\");\n\n        setTreeFieldsAndSave(\"foreignSourceEditForm\", select(\"key\", \"port\"), type(\"value\", \"8080\"));\n        waitForPageToLoad();\n\n        clickAndWait(\"//input[@value='Done']\");\n        clickAndWait(\"//a[contains(@href, '\" + groupName + \"') and contains(@href, 'editRequisition') and text() = 'Edit']\");\n        clickAndWait(\"//input[@value='Add Node']\");\n        String nodeForNode = setTreeFieldsAndSave(\"nodeEditForm\", type(\"nodeLabel\", \"localNode\"));\n        waitForPageToLoad();\n\n        clickAndWait(\"//a[contains(@href, '\" + nodeForNode + \"') and text() = '[Add Interface]']\");\n        setTreeFieldsAndSave(\"nodeEditForm\", type(\"ipAddr\", \"::1\"));\n        waitForPageToLoad();\n\n        clickAndWait(\"//a[text() = 'Add Service']\");\n        setTreeFieldsAndSave(\"nodeEditForm\", type(\"serviceName\", \"HTTP-8080\"));\n        waitForPageToLoad();\n\n        clickAndWait(\"//input[@value='Done']\");\n        clickAndWait(\"//input[@value='Synchronize']\");\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n\n        // Yo dawg, I heard you liked hacks\n        Thread.sleep(10000);\n    }","commit_id":"e9ad52e1e38d6d5797f78221cf333821ad95c206","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDeleteProvisioningNodesAndGroups() throws Exception {\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n        selenium.click(\"link=Manage Provisioning Requisitions\");\n        waitForPageToLoad();\n        selenium.click(\"//input[@value='Delete Nodes']\");\n        waitForPageToLoad();\n        selenium.click(\"//input[@value='Synchronize']\");\n        waitForPageToLoad();\n        /*\n         *  we need to reload this page several times if the 'Delete Group' button doesn't exist\n         *  in case the nodes hadn't been deleted by the time the page was reloaded\n         */\n\n        long end = System.currentTimeMillis() + 300000;\n        while (!selenium.isElementPresent(\"//input[@value='Delete Requisition']\") && System.currentTimeMillis() < end) {\n        \t\n        \tThread.sleep(10000);\n        \t\n        \tif (System.currentTimeMillis() >= end) {\n        \t\tthrow new NoSuchElementException(\"Could not find the 'Delete Requisition' button after refreshing for 5 minutes\");\n        \t} else {\n        \t\tselenium.refresh();\n        \t\twaitForPageToLoad();\n        \t}\n        }        \n\n        selenium.click(\"//input[@value='Delete Requisition']\");\n        waitForPageToLoad();\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28437,"modified_method":"@Test\n    public void testDeleteProvisioningNodesAndGroups() throws Exception {\n        clickAndWait(\"link=Admin\");\n        clickAndWait(\"link=Manage Provisioning Requisitions\");\n        clickAndWait(\"//input[@value='Delete Nodes']\");\n        clickAndWait(\"//input[@value='Synchronize']\");\n\n        /*\n         *  we need to reload this page several times if the 'Delete Group' button doesn't exist\n         *  in case the nodes hadn't been deleted by the time the page was reloaded\n         */\n\n        long end = System.currentTimeMillis() + 300000;\n        while (!selenium.isElementPresent(\"//input[@value='Delete Requisition']\") && System.currentTimeMillis() < end) {\n\n            Thread.sleep(10000);\n\n            if (System.currentTimeMillis() >= end) {\n                throw new NoSuchElementException(\"Could not find the 'Delete Requisition' button after refreshing for 5 minutes\");\n            } else {\n                selenium.refresh();\n                waitForPageToLoad();\n            }\n        }        \n\n        clickAndWait(\"//input[@value='Delete Requisition']\");\n    }","commit_id":"e9ad52e1e38d6d5797f78221cf333821ad95c206","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllTopLevelLinks() throws InterruptedException {\n        selenium.click(\"link=Node List\");\n        waitForPageToLoad();\n        long endTime = System.currentTimeMillis() + 60000;\n        while(System.currentTimeMillis() < endTime){\n            if(selenium.isTextPresent(\"Availability\") || selenium.isElementPresent(\"link=localNode\")){\n                break;\n            }\n            selenium.refresh();\n            waitForPageToLoad();\n            if(endTime - System.currentTimeMillis() < 5000){\n                fail (\"55 second timeout trying to reach \\\"Node List/localNode\\\" Page\");\n            }\n        }\n        selenium.click(\"link=Search\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Search for Nodes\"));\n        assertTrue(selenium.isTextPresent(\"Search Asset Information\"));\n        assertTrue(selenium.isTextPresent(\"Search Options\"));\n        assertTrue(selenium.isElementPresent(\"link=All nodes with asset info\"));\n        selenium.click(\"link=Outages\");\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"link=Current outages\"));\n        assertTrue(selenium.isTextPresent(\"Outages and Service Level Availability\"));\n        assertTrue(selenium.isTextPresent(\"Outage Menu\"));\n        selenium.click(\"link=Path Outages\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"All path outages\"));\n        assertTrue(selenium.isTextPresent(\"Critical Path Service\"));\n        selenium.click(\"link=Dashboard\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Node Status\"));\n        assertTrue(selenium.isTextPresent(\"24 Hour Availability\"));\n        selenium.click(\"link=Alarms\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Alarm Queries\"));\n        assertTrue(selenium.isTextPresent(\"Outstanding and acknowledged alarms\"));\n        assertTrue(selenium.isTextPresent(\"Alarm ID:\"));\n        selenium.click(\"link=Events\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Event Queries\"));\n        assertTrue(selenium.isTextPresent(\"Outstanding and acknowledged events\"));     \n        selenium.click(\"link=Notifications\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Notification queries\"));\n        assertTrue(selenium.isTextPresent(\"Outstanding and Acknowledged Notices\"));\n        assertTrue(selenium.isTextPresent(\"Notification Escalation\"));\n        selenium.click(\"link=Assets\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Search Asset Information\"));\n        assertTrue(selenium.isTextPresent(\"Assets with asset numbers\"));\n        assertTrue(selenium.isTextPresent(\"Assets Inventory\"));\n        selenium.click(\"link=Reports\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Reports\"));\n        assertTrue(selenium.isTextPresent(\"Descriptions\"));\n        selenium.click(\"link=Charts\");\n        waitForPageToLoad();\n        selenium.click(\"link=Surveillance\");\n        endTime = System.currentTimeMillis() + 60000;\n        while(System.currentTimeMillis() < endTime){\n            if(selenium.isTextPresent(\"Surveillance View:\")){\n                break;\n            }\n        }\n        assertTrue(selenium.isTextPresent(\"Routers\"));\n        assertTrue(selenium.isTextPresent(\"Surveillance View: default\"));\n        selenium.click(\"//a[@href='maps.htm']\");\n        waitForPageToLoad();\n        selenium.click(\"//div[@id='content']//a[contains(@href,'RemotePollerMap')]\");\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"link=Applications\"));\n        selenium.goBack();\n        waitForPageToLoad();\n        selenium.click(\"link=Add Node\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Node Quick-Add\"));\n        assertTrue(selenium.isTextPresent(\"CLI Authentication Parameters\"));\n        selenium.click(\"link=Admin\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"OpenNMS System\"));\n        assertTrue(selenium.isTextPresent(\"Operations\"));\n        assertTrue(selenium.isTextPresent(\"Nodes\"));\n        assertTrue(selenium.isTextPresent(\"Distributed Monitoring\"));\n        assertTrue(selenium.isTextPresent(\"Descriptions\"));\n    }","id":28438,"modified_method":"@Test\n    public void testAllTopLevelLinks() throws InterruptedException {\n        clickAndWait(\"link=Node List\");\n        long endTime = System.currentTimeMillis() + 60000;\n        while(System.currentTimeMillis() < endTime){\n            if(selenium.isTextPresent(\"Availability\") || selenium.isElementPresent(\"link=localNode\")){\n                break;\n            }\n            selenium.refresh();\n            waitForPageToLoad();\n            if(endTime - System.currentTimeMillis() < 5000){\n                fail (\"55 second timeout trying to reach \\\"Node List/localNode\\\" Page\");\n            }\n        }\n        clickAndWait(\"link=Search\");\n        assertTrue(selenium.isTextPresent(\"Search for Nodes\"));\n        assertTrue(selenium.isTextPresent(\"Search Asset Information\"));\n        assertTrue(selenium.isTextPresent(\"Search Options\"));\n        assertTrue(selenium.isElementPresent(\"link=All nodes with asset info\"));\n        clickAndWait(\"link=Outages\");\n        assertTrue(selenium.isElementPresent(\"link=Current outages\"));\n        assertTrue(selenium.isTextPresent(\"Outages and Service Level Availability\"));\n        assertTrue(selenium.isTextPresent(\"Outage Menu\"));\n        clickAndWait(\"link=Path Outages\");\n        assertTrue(selenium.isTextPresent(\"All path outages\"));\n        assertTrue(selenium.isTextPresent(\"Critical Path Service\"));\n        clickAndWait(\"link=Dashboard\");\n        assertTrue(selenium.isTextPresent(\"Node Status\"));\n        assertTrue(selenium.isTextPresent(\"24 Hour Availability\"));\n        clickAndWait(\"link=Alarms\");\n        assertTrue(selenium.isTextPresent(\"Alarm Queries\"));\n        assertTrue(selenium.isTextPresent(\"Outstanding and acknowledged alarms\"));\n        assertTrue(selenium.isTextPresent(\"Alarm ID:\"));\n        clickAndWait(\"link=Events\");\n        assertTrue(selenium.isTextPresent(\"Event Queries\"));\n        assertTrue(selenium.isTextPresent(\"Outstanding and acknowledged events\"));     \n        clickAndWait(\"link=Notifications\");\n        assertTrue(selenium.isTextPresent(\"Notification queries\"));\n        assertTrue(selenium.isTextPresent(\"Outstanding and Acknowledged Notices\"));\n        assertTrue(selenium.isTextPresent(\"Notification Escalation\"));\n        clickAndWait(\"link=Assets\");\n        assertTrue(selenium.isTextPresent(\"Search Asset Information\"));\n        assertTrue(selenium.isTextPresent(\"Assets with asset numbers\"));\n        assertTrue(selenium.isTextPresent(\"Assets Inventory\"));\n        clickAndWait(\"link=Reports\");\n        assertTrue(selenium.isTextPresent(\"Reports\"));\n        assertTrue(selenium.isTextPresent(\"Descriptions\"));\n        clickAndWait(\"link=Charts\");\n        selenium.click(\"link=Surveillance\");\n        waitForText(\"Surveillance View:\", LOAD_TIMEOUT);\n\n        assertTrue(selenium.isTextPresent(\"Routers\"));\n        assertTrue(selenium.isTextPresent(\"Surveillance View: default\"));\n        clickAndWait(\"//a[@href='maps.htm']\");\n        clickAndWait(\"//div[@id='content']//a[contains(@href,'RemotePollerMap')]\");\n        assertTrue(selenium.isElementPresent(\"link=Applications\"));\n        goBack();\n        clickAndWait(\"link=Add Node\");\n        assertTrue(selenium.isTextPresent(\"Node Quick-Add\"));\n        assertTrue(selenium.isTextPresent(\"CLI Authentication Parameters\"));\n        clickAndWait(\"link=Admin\");\n        assertTrue(selenium.isTextPresent(\"OpenNMS System\"));\n        assertTrue(selenium.isTextPresent(\"Operations\"));\n        assertTrue(selenium.isTextPresent(\"Nodes\"));\n        assertTrue(selenium.isTextPresent(\"Distributed Monitoring\"));\n        assertTrue(selenium.isTextPresent(\"Descriptions\"));\n    }","commit_id":"e9ad52e1e38d6d5797f78221cf333821ad95c206","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n        selenium.click(\"link=Support\");\n        waitForPageToLoad();\n    }","id":28439,"modified_method":"@Before\n    public void setUp() throws Exception {\n    \tsuper.setUp();\n    \tclickAndWait(\"link=Support\");\n    }","commit_id":"e9ad52e1e38d6d5797f78221cf333821ad95c206","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAllLinks() {\n        selenium.click(\"link=About the OpenNMS Web Console\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"OpenNMS Web Console\"));\n        assertTrue(selenium.isTextPresent(\"License and Copyright\"));\n        assertTrue(selenium.isTextPresent(\"OSI Certified Open Source Software\"));\n        assertTrue(selenium.isTextPresent(\"Version:\"));\n        selenium.goBack();\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"//a[@href='http://www.opennms.org/documentation/ReleaseNotesStable.html#whats-new']\"));\n        assertTrue(selenium.isElementPresent(\"//a[@href='http://www.opennms.org/wiki/']\"));\n        selenium.click(\"link=Generate a System Report\");\n        waitForPageToLoad();\n        assertTrue(selenium.isTextPresent(\"Plugins\"));\n        assertTrue(selenium.isTextPresent(\"Report Type\"));\n        assertTrue(selenium.isElementPresent(\"name=formatter\"));\n        assertEquals(\"\", selenium.getValue(\"css=input[type=submit]\"));\n        assertTrue(selenium.isTextPresent(\"Output\"));\n        assertTrue(selenium.isTextPresent(\"Choose which plugins to enable:\"));\n        selenium.goBack();\n        waitForPageToLoad();\n        assertTrue(selenium.isElementPresent(\"//a[@href='http://issues.opennms.org/']\"));\n        assertTrue(selenium.isElementPresent(\"//a[@href='irc://irc.freenode.net/%23opennms']\"));\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28440,"modified_method":"@Test\n    public void testAllLinks() {\n        clickAndWait(\"link=About the OpenNMS Web Console\");\n        assertTrue(selenium.isTextPresent(\"OpenNMS Web Console\"));\n        assertTrue(selenium.isTextPresent(\"License and Copyright\"));\n        assertTrue(selenium.isTextPresent(\"OSI Certified Open Source Software\"));\n        assertTrue(selenium.isTextPresent(\"Version:\"));\n        goBack();\n        assertTrue(selenium.isElementPresent(\"//a[@href='http://www.opennms.org/documentation/ReleaseNotesStable.html#whats-new']\"));\n        assertTrue(selenium.isElementPresent(\"//a[@href='http://www.opennms.org/wiki/']\"));\n\n        clickAndWait(\"link=Generate a System Report\");\n        assertTrue(selenium.isTextPresent(\"Plugins\"));\n        assertTrue(selenium.isTextPresent(\"Report Type\"));\n        assertTrue(selenium.isElementPresent(\"name=formatter\"));\n        assertEquals(\"\", selenium.getValue(\"css=input[type=submit]\"));\n        assertTrue(selenium.isTextPresent(\"Output\"));\n        assertTrue(selenium.isTextPresent(\"Choose which plugins to enable:\"));\n        goBack();\n        assertTrue(selenium.isElementPresent(\"//a[@href='http://issues.opennms.org/']\"));\n        assertTrue(selenium.isElementPresent(\"//a[@href='irc://irc.freenode.net/%23opennms']\"));\n    }","commit_id":"e9ad52e1e38d6d5797f78221cf333821ad95c206","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSurveillancePage() throws Exception {\n        long endTime = System.currentTimeMillis() + 30000;\n        while(System.currentTimeMillis() < endTime){\n            if(selenium.isTextPresent(\"Surveillance View:\")){\n                break;\n            }\n            if(endTime - System.currentTimeMillis() < 5000){\n                fail (\"25 second timeout trying to reach \\\"Surveillance\\\" Page\");\n            }\n        }\n        assertTrue(selenium.isTextPresent(\"Routers\"));\n        assertTrue(selenium.isTextPresent(\"Nodes Down\"));\n        assertTrue(selenium.isTextPresent(\"DEV\"));\n        selenium.click(\"link=Log out\");\n        waitForPageToLoad();\n    }","id":28441,"modified_method":"@Test\n    public void testSurveillancePage() throws Exception {\n        waitForText(\"Surveillance View:\", LOAD_TIMEOUT);\n        assertTrue(selenium.isTextPresent(\"Routers\"));\n        assertTrue(selenium.isTextPresent(\"Nodes Down\"));\n        assertTrue(selenium.isTextPresent(\"DEV\"));\n    }","commit_id":"e9ad52e1e38d6d5797f78221cf333821ad95c206","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ModuleReference pluginRef = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"28f9e497-3b42-4291-aeba-0a1039153ab1\")).getModuleReference();\n      ModuleReference standaloneRef = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"ef7bf5ac-d06c-4342-b11d-e42104eb9343\")).getModuleReference();\n      for (IModule module : ListSequence.fromList(((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getProjectModules(IModule.class))) {\n        if (!(module.getUsedLanguagesReferences().contains(pluginRef))) {\n          continue;\n        }\n        if (module.getUsedLanguagesReferences().contains(standaloneRef)) {\n          continue;\n        }\n\n        for (SModelDescriptor model : ListSequence.fromList(module.getOwnModelDescriptors())) {\n          if (SModelStereotype.isStubModelStereotype(model.getStereotype())) {\n            continue;\n          }\n          if (!(model.getSModel().importedLanguages().contains(pluginRef))) {\n            continue;\n          }\n          if (model.getSModel().importedLanguages().contains(standaloneRef)) {\n            continue;\n          }\n          SModelOperations.createNewRootNode(((SModel) model.getSModel()), \"jetbrains.mps.lang.plugin.standalone.structure.StandalonePluginDescriptor\", null);\n          model.getSModel().addLanguage(standaloneRef);\n          model.getModule().addDependency(standaloneRef, false);\n        }\n      }\n      SModelRepository.getInstance().saveAll();\n      ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"AddPluginDependencies\", t);\n      }\n    }\n  }","id":28442,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ModuleReference standaloneRef = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"ef7bf5ac-d06c-4342-b11d-e42104eb9343\")).getModuleReference();\n      for (Language lang : ListSequence.fromList(((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getProjectModules(Language.class))) {\n        DefaultSModelDescriptor aspect = LanguageAspect.PLUGIN.get(lang);\n        if (aspect == null) {\n          continue;\n        }\n\n        lang.addDependency(standaloneRef, false);\n        SModel model = aspect.getSModel();\n        model.addLanguage(standaloneRef);\n        SModelOperations.createNewRootNode(model, \"jetbrains.mps.lang.plugin.standalone.structure.StandalonePluginDescriptor\", null);\n      }\n      SModelRepository.getInstance().saveAll();\n      ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"AddPluginDependencies\", t);\n      }\n    }\n  }","commit_id":"5d72f6b63be00ffaf966aa3bc39f30cf0a0286ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void saveUsedLanguages(Element rootElement, SModel sourceModel) {\n    for (Entry<SLanguage, Integer> language : sourceModel.usedLanguagesWithVersions().entrySet()) {\n      myHelper.addLanguage(IdHelper.getLanguageId(language.getKey()));\n      Element languageElem = new Element(ModelPersistence9.USED_LANGUAGE);\n      languageElem.setAttribute(ModelPersistence9.ID, IdHelper.getLanguageId(language.getKey()).serialize());\n      languageElem.setAttribute(ModelPersistence9.VERSION, Integer.toString(language.getValue()));\n      languageElem.setAttribute(ModelPersistence9.USE_INDEX, myHelper.getUsedLanguageIndex(IdHelper.getLanguageId(language.getKey())));\n      rootElement.addContent(languageElem);\n    }\n    for (Entry<SLanguage, Integer> language : sourceModel.implicitlyUsedLanguagesWithVersions().entrySet()) {\n      myHelper.addLanguage(IdHelper.getLanguageId(language.getKey()));\n      Element languageElem = new Element(ModelPersistence9.USED_LANGUAGE);\n      languageElem.setAttribute(ModelPersistence9.ID, IdHelper.getLanguageId(language.getKey()).serialize());\n      languageElem.setAttribute(ModelPersistence9.VERSION, Integer.toString(language.getValue()));\n      languageElem.setAttribute(ModelPersistence9.IMPLICIT, \"true\");\n      languageElem.setAttribute(ModelPersistence9.USE_INDEX, myHelper.getUsedLanguageIndex(IdHelper.getLanguageId(language.getKey())));\n      rootElement.addContent(languageElem);\n    }\n  }","id":28443,"modified_method":"private void saveUsedLanguages(Element rootElement, SModel sourceModel) {\n    Map<SLanguage, Integer> usedLangs = sourceModel.usedLanguagesWithVersions();\n    ArrayList<SLanguage> keys = new ArrayList<SLanguage>(usedLangs.keySet());\n    sortLanguages(keys);\n\n    for (SLanguage l : keys) {\n      myHelper.addLanguage(IdHelper.getLanguageId(l));\n      Element languageElem = new Element(ModelPersistence9.USED_LANGUAGE);\n      languageElem.setAttribute(ModelPersistence9.ID, IdHelper.getLanguageId(l).serialize());\n      languageElem.setAttribute(ModelPersistence9.VERSION, Integer.toString(usedLangs.get(l)));\n      languageElem.setAttribute(ModelPersistence9.USE_INDEX, myHelper.getUsedLanguageIndex(IdHelper.getLanguageId(l)));\n      rootElement.addContent(languageElem);\n    }\n\n    usedLangs = sourceModel.implicitlyUsedLanguagesWithVersions();\n    keys = new ArrayList<SLanguage>(usedLangs.keySet());\n    sortLanguages(keys);\n\n    for (SLanguage l : keys) {\n      myHelper.addLanguage(IdHelper.getLanguageId(l));\n      Element languageElem = new Element(ModelPersistence9.USED_LANGUAGE);\n      languageElem.setAttribute(ModelPersistence9.ID, IdHelper.getLanguageId(l).serialize());\n      languageElem.setAttribute(ModelPersistence9.VERSION, Integer.toString(usedLangs.get(l)));\n      languageElem.setAttribute(ModelPersistence9.IMPLICIT, \"true\");\n      languageElem.setAttribute(ModelPersistence9.USE_INDEX, myHelper.getUsedLanguageIndex(IdHelper.getLanguageId(l)));\n      rootElement.addContent(languageElem);\n    }\n  }","commit_id":"bd48f8a684a8fc89cda0de0e90af55320ea58c58","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void setPortletScope(\n\t\tPortletDataContext portletDataContext, Element portletElement) {\n\n\t\t// Portlet data scope\n\n\t\tString scopeLayoutUuid = GetterUtil.getString(\n\t\t\tportletElement.attributeValue(\"scope-layout-uuid\"));\n\t\tString scopeLayoutType = GetterUtil.getString(\n\t\t\tportletElement.attributeValue(\"scope-layout-type\"));\n\n\t\tportletDataContext.setScopeLayoutUuid(scopeLayoutUuid);\n\t\tportletDataContext.setScopeType(scopeLayoutType);\n\n\t\t// Layout scope\n\n\t\ttry {\n\t\t\tGroup scopeGroup = null;\n\n\t\t\tif (scopeLayoutType.equals(\"company\")) {\n\t\t\t\tscopeGroup = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\t\t\tportletDataContext.getCompanyId());\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(scopeLayoutUuid)) {\n\t\t\t\tboolean privateLayout = GetterUtil.getBoolean(\n\t\t\t\t\tportletElement.attributeValue(\"private-layout\"));\n\n\t\t\t\tLayout scopeLayout =\n\t\t\t\t\tLayoutLocalServiceUtil.getLayoutByUuidAndGroupId(\n\t\t\t\t\t\tscopeLayoutUuid, portletDataContext.getGroupId(),\n\t\t\t\t\t\tprivateLayout);\n\n\t\t\t\tif (scopeLayout.hasScopeGroup()) {\n\t\t\t\t\tscopeGroup = scopeLayout.getScopeGroup();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString name = String.valueOf(scopeLayout.getPlid());\n\n\t\t\t\t\tscopeGroup = GroupLocalServiceUtil.addGroup(\n\t\t\t\t\t\tportletDataContext.getUserId(null),\n\t\t\t\t\t\tGroupConstants.DEFAULT_PARENT_GROUP_ID,\n\t\t\t\t\t\tLayout.class.getName(), scopeLayout.getPlid(),\n\t\t\t\t\t\tGroupConstants.DEFAULT_LIVE_GROUP_ID, name, null, 0,\n\t\t\t\t\t\ttrue, GroupConstants.DEFAULT_MEMBERSHIP_RESTRICTION,\n\t\t\t\t\t\tnull, false, true, null);\n\t\t\t\t}\n\n\t\t\t\tGroup group = scopeLayout.getGroup();\n\n\t\t\t\tif (group.isStaged() && !group.isStagedRemotely()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tLayout oldLayout =\n\t\t\t\t\t\t\tLayoutLocalServiceUtil.getLayoutByUuidAndGroupId(\n\t\t\t\t\t\t\t\tscopeLayoutUuid,\n\t\t\t\t\t\t\t\tportletDataContext.getSourceGroupId(),\n\t\t\t\t\t\t\t\tprivateLayout);\n\n\t\t\t\t\t\tGroup oldScopeGroup = oldLayout.getScopeGroup();\n\n\t\t\t\t\t\tif (group.isStagingGroup()) {\n\t\t\t\t\t\t\tscopeGroup.setLiveGroupId(\n\t\t\t\t\t\t\t\toldScopeGroup.getGroupId());\n\n\t\t\t\t\t\t\tGroupLocalServiceUtil.updateGroup(scopeGroup);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\toldScopeGroup.setLiveGroupId(\n\t\t\t\t\t\t\t\tscopeGroup.getGroupId());\n\n\t\t\t\t\t\t\tGroupLocalServiceUtil.updateGroup(oldScopeGroup);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchLayoutException nsle) {\n\t\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t\t_log.warn(nsle);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (scopeGroup != null) {\n\t\t\t\tportletDataContext.setScopeGroupId(scopeGroup.getGroupId());\n\t\t\t}\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","id":28444,"modified_method":"protected void setPortletScope(\n\t\tPortletDataContext portletDataContext, Element portletElement) {\n\n\t\t// Portlet data scope\n\n\t\tString scopeLayoutUuid = GetterUtil.getString(\n\t\t\tportletElement.attributeValue(\"scope-layout-uuid\"));\n\t\tString scopeLayoutType = GetterUtil.getString(\n\t\t\tportletElement.attributeValue(\"scope-layout-type\"));\n\n\t\tportletDataContext.setScopeLayoutUuid(scopeLayoutUuid);\n\t\tportletDataContext.setScopeType(scopeLayoutType);\n\n\t\t// Layout scope\n\n\t\ttry {\n\t\t\tGroup scopeGroup = null;\n\n\t\t\tif (scopeLayoutType.equals(\"company\")) {\n\t\t\t\tscopeGroup = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\t\t\tportletDataContext.getCompanyId());\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(scopeLayoutUuid)) {\n\t\t\t\tboolean privateLayout = GetterUtil.getBoolean(\n\t\t\t\t\tportletElement.attributeValue(\"private-layout\"));\n\n\t\t\t\tLayout scopeLayout =\n\t\t\t\t\tLayoutLocalServiceUtil.getLayoutByUuidAndGroupId(\n\t\t\t\t\t\tscopeLayoutUuid, portletDataContext.getGroupId(),\n\t\t\t\t\t\tprivateLayout);\n\n\t\t\t\tif (scopeLayout.hasScopeGroup()) {\n\t\t\t\t\tscopeGroup = scopeLayout.getScopeGroup();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString name = String.valueOf(scopeLayout.getPlid());\n\n\t\t\t\t\tscopeGroup = GroupLocalServiceUtil.addGroup(\n\t\t\t\t\t\tportletDataContext.getUserId(null),\n\t\t\t\t\t\tGroupConstants.DEFAULT_PARENT_GROUP_ID,\n\t\t\t\t\t\tLayout.class.getName(), scopeLayout.getPlid(),\n\t\t\t\t\t\tGroupConstants.DEFAULT_LIVE_GROUP_ID, name, null, 0,\n\t\t\t\t\t\ttrue, GroupConstants.DEFAULT_MEMBERSHIP_RESTRICTION,\n\t\t\t\t\t\tnull, false, true, null);\n\t\t\t\t}\n\n\t\t\t\tGroup group = scopeLayout.getGroup();\n\n\t\t\t\tif (group.isStaged() && !group.isStagedRemotely()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tLayout oldLayout =\n\t\t\t\t\t\t\tLayoutLocalServiceUtil.getLayoutByUuidAndGroupId(\n\t\t\t\t\t\t\t\tscopeLayoutUuid,\n\t\t\t\t\t\t\t\tportletDataContext.getSourceGroupId(),\n\t\t\t\t\t\t\t\tprivateLayout);\n\n\t\t\t\t\t\tGroup oldScopeGroup = oldLayout.getScopeGroup();\n\n\t\t\t\t\t\tif (group.isStagingGroup()) {\n\t\t\t\t\t\t\tscopeGroup.setLiveGroupId(\n\t\t\t\t\t\t\t\toldScopeGroup.getGroupId());\n\n\t\t\t\t\t\t\tGroupLocalServiceUtil.updateGroup(scopeGroup);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\toldScopeGroup.setLiveGroupId(\n\t\t\t\t\t\t\t\tscopeGroup.getGroupId());\n\n\t\t\t\t\t\t\tGroupLocalServiceUtil.updateGroup(oldScopeGroup);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchLayoutException nsle) {\n\t\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t\t_log.warn(nsle);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (scopeGroup != null) {\n\t\t\t\tportletDataContext.setScopeGroupId(scopeGroup.getGroupId());\n\n\t\t\t\tMap<Long, Long> groupIds =\n\t\t\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\t\tGroup.class);\n\n\t\t\t\tlong oldScopeGroupId = GetterUtil.getLong(\n\t\t\t\t\tportletElement.attributeValue(\"scope-group-id\"));\n\n\t\t\t\tgroupIds.put(oldScopeGroupId, scopeGroup.getGroupId());\n\t\t\t}\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","commit_id":"3f2e311e6c75a2a36c7bb30cca83f7dbabd51352","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportPortlet(\n\t\t\tPortletDataContext portletDataContext, LayoutCache layoutCache,\n\t\t\tString portletId, Layout layout, Element parentElement,\n\t\t\tboolean exportPermissions, boolean exportPortletArchivedSetups,\n\t\t\tboolean exportPortletData, boolean exportPortletSetup,\n\t\t\tboolean exportPortletUserPreferences)\n\t\tthrows Exception {\n\n\t\tlong plid = PortletKeys.PREFS_OWNER_ID_DEFAULT;\n\t\tlong layoutId = LayoutConstants.DEFAULT_PARENT_LAYOUT_ID;\n\n\t\tif (layout != null) {\n\t\t\tplid = layout.getPlid();\n\t\t\tlayoutId = layout.getLayoutId();\n\t\t}\n\n\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\tportletDataContext.getCompanyId(), portletId);\n\n\t\tif (portlet == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Do not export portlet \" + portletId +\n\t\t\t\t\t\t\" because the portlet does not exist\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!portlet.isInstanceable() &&\n\t\t\t!portlet.isPreferencesUniquePerLayout() &&\n\t\t\tportletDataContext.hasNotUniquePerLayout(portletId)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.createDocument();\n\n\t\tElement portletElement = document.addElement(\"portlet\");\n\n\t\tportletElement.addAttribute(\"portlet-id\", portletId);\n\t\tportletElement.addAttribute(\n\t\t\t\"root-portlet-id\", PortletConstants.getRootPortletId(portletId));\n\t\tportletElement.addAttribute(\"old-plid\", String.valueOf(plid));\n\t\tportletElement.addAttribute(\n\t\t\t\"scope-layout-type\", portletDataContext.getScopeType());\n\t\tportletElement.addAttribute(\n\t\t\t\"scope-layout-uuid\", portletDataContext.getScopeLayoutUuid());\n\t\tportletElement.addAttribute(\n\t\t\t\"private-layout\", String.valueOf(layout.isPrivateLayout()));\n\n\t\t// Data\n\n\t\tif (exportPortletData) {\n\t\t\tjavax.portlet.PortletPreferences jxPortletPreferences =\n\t\t\t\tPortletPreferencesFactoryUtil.getStrictPortletSetup(\n\t\t\t\t\tlayout, portletId);\n\n\t\t\tif (!portlet.isPreferencesUniquePerLayout()) {\n\t\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\t\tsb.append(portletId);\n\t\t\t\tsb.append(StringPool.AT);\n\t\t\t\tsb.append(portletDataContext.getScopeType());\n\t\t\t\tsb.append(StringPool.AT);\n\t\t\t\tsb.append(portletDataContext.getScopeLayoutUuid());\n\n\t\t\t\tString dataKey = sb.toString();\n\n\t\t\t\tif (!portletDataContext.hasNotUniquePerLayout(dataKey)) {\n\t\t\t\t\tportletDataContext.putNotUniquePerLayout(dataKey);\n\n\t\t\t\t\texportPortletData(\n\t\t\t\t\t\tportletDataContext, portlet, layout,\n\t\t\t\t\t\tjxPortletPreferences, portletElement);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texportPortletData(\n\t\t\t\t\tportletDataContext, portlet, layout, jxPortletPreferences,\n\t\t\t\t\tportletElement);\n\t\t\t}\n\t\t}\n\n\t\t// Portlet preferences\n\n\t\tif (exportPortletSetup) {\n\n\t\t\t// Company\n\n\t\t\texportPortletPreferences(\n\t\t\t\tportletDataContext, portletDataContext.getCompanyId(),\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_COMPANY, false, layout, plid,\n\t\t\t\tportlet.getRootPortletId(), portletElement);\n\n\t\t\t// Group\n\n\t\t\texportPortletPreferences(\n\t\t\t\tportletDataContext, portletDataContext.getScopeGroupId(),\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_GROUP, false, layout,\n\t\t\t\tPortletKeys.PREFS_PLID_SHARED, portlet.getRootPortletId(),\n\t\t\t\tportletElement);\n\n\t\t\t// Layout\n\n\t\t\texportPortletPreferences(\n\t\t\t\tportletDataContext, PortletKeys.PREFS_OWNER_ID_DEFAULT,\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_LAYOUT, false, layout, plid,\n\t\t\t\tportletId, portletElement);\n\t\t}\n\n\t\t// Portlet user preferences\n\n\t\tif (exportPortletUserPreferences) {\n\t\t\tList<PortletPreferences> portletPreferencesList =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getPortletPreferences(\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_USER, plid, portletId);\n\n\t\t\tfor (PortletPreferences portletPreferences :\n\t\t\t\t\tportletPreferencesList) {\n\n\t\t\t\tboolean defaultUser = false;\n\n\t\t\t\tif (portletPreferences.getOwnerId() ==\n\t\t\t\t\t\tPortletKeys.PREFS_OWNER_ID_DEFAULT) {\n\n\t\t\t\t\tdefaultUser = true;\n\t\t\t\t}\n\n\t\t\t\texportPortletPreferences(\n\t\t\t\t\tportletDataContext, portletPreferences.getOwnerId(),\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_USER, defaultUser, layout,\n\t\t\t\t\tplid, portletId, portletElement);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tPortletPreferences groupPortletPreferences =\n\t\t\t\t\tPortletPreferencesLocalServiceUtil.getPortletPreferences(\n\t\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_GROUP,\n\t\t\t\t\t\tPortletKeys.PREFS_PLID_SHARED,\n\t\t\t\t\t\tportlet.getRootPortletId());\n\n\t\t\t\texportPortletPreference(\n\t\t\t\t\tportletDataContext, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_GROUP, false,\n\t\t\t\t\tgroupPortletPreferences, portlet.getRootPortletId(),\n\t\t\t\t\tPortletKeys.PREFS_PLID_SHARED, portletElement);\n\t\t\t}\n\t\t\tcatch (NoSuchPortletPreferencesException nsppe) {\n\t\t\t}\n\t\t}\n\n\t\t// Archived setups\n\n\t\tif (exportPortletArchivedSetups) {\n\t\t\tString rootPortletId = PortletConstants.getRootPortletId(portletId);\n\n\t\t\tList<PortletItem> portletItems =\n\t\t\t\tPortletItemLocalServiceUtil.getPortletItems(\n\t\t\t\t\tportletDataContext.getGroupId(), rootPortletId,\n\t\t\t\t\tPortletPreferences.class.getName());\n\n\t\t\tfor (PortletItem portletItem : portletItems) {\n\t\t\t\texportPortletPreferences(\n\t\t\t\t\tportletDataContext, portletItem.getPortletItemId(),\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_ARCHIVED, false, null, plid,\n\t\t\t\t\tportletItem.getPortletId(), portletElement);\n\t\t\t}\n\t\t}\n\n\t\t// Permissions\n\n\t\tif (exportPermissions) {\n\t\t\t_permissionExporter.exportPortletPermissions(\n\t\t\t\tportletDataContext, layoutCache, portletId, layout,\n\t\t\t\tportletElement);\n\t\t}\n\n\t\t// Zip\n\n\t\tStringBundler pathSB = new StringBundler(4);\n\n\t\tpathSB.append(\n\t\t\tExportImportPathUtil.getPortletPath(portletDataContext, portletId));\n\t\tpathSB.append(StringPool.SLASH);\n\t\tpathSB.append(plid);\n\t\tpathSB.append(\"/portlet.xml\");\n\n\t\tString path = pathSB.toString();\n\n\t\tElement element = parentElement.addElement(\"portlet\");\n\n\t\telement.addAttribute(\"portlet-id\", portletId);\n\t\telement.addAttribute(\"layout-id\", String.valueOf(layoutId));\n\t\telement.addAttribute(\"path\", path);\n\t\telement.addAttribute(\"portlet-data\", String.valueOf(exportPortletData));\n\n\t\tStringBundler configurationOptionsSB = new StringBundler(6);\n\n\t\tif (exportPortletSetup) {\n\t\t\tconfigurationOptionsSB.append(\"setup\");\n\t\t\tconfigurationOptionsSB.append(StringPool.COMMA);\n\t\t}\n\n\t\tif (exportPortletArchivedSetups) {\n\t\t\tconfigurationOptionsSB.append(\"archived-setups\");\n\t\t\tconfigurationOptionsSB.append(StringPool.COMMA);\n\t\t}\n\n\t\tif (exportPortletUserPreferences) {\n\t\t\tconfigurationOptionsSB.append(\"user-preferences\");\n\t\t\tconfigurationOptionsSB.append(StringPool.COMMA);\n\t\t}\n\n\t\tif (configurationOptionsSB.index() > 0) {\n\t\t\tconfigurationOptionsSB.setIndex(configurationOptionsSB.index() -1);\n\t\t}\n\n\t\telement.addAttribute(\n\t\t\t\"portlet-configuration\", configurationOptionsSB.toString());\n\n\t\tif (portletDataContext.isPathNotProcessed(path)) {\n\t\t\ttry {\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tpath, document.formattedString());\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(ioe.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tportletDataContext.addPrimaryKey(String.class, path);\n\t\t}\n\t}","id":28445,"modified_method":"protected void exportPortlet(\n\t\t\tPortletDataContext portletDataContext, LayoutCache layoutCache,\n\t\t\tString portletId, Layout layout, Element parentElement,\n\t\t\tboolean exportPermissions, boolean exportPortletArchivedSetups,\n\t\t\tboolean exportPortletData, boolean exportPortletSetup,\n\t\t\tboolean exportPortletUserPreferences)\n\t\tthrows Exception {\n\n\t\tlong plid = PortletKeys.PREFS_OWNER_ID_DEFAULT;\n\t\tlong layoutId = LayoutConstants.DEFAULT_PARENT_LAYOUT_ID;\n\n\t\tif (layout != null) {\n\t\t\tplid = layout.getPlid();\n\t\t\tlayoutId = layout.getLayoutId();\n\t\t}\n\n\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\tportletDataContext.getCompanyId(), portletId);\n\n\t\tif (portlet == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Do not export portlet \" + portletId +\n\t\t\t\t\t\t\" because the portlet does not exist\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!portlet.isInstanceable() &&\n\t\t\t!portlet.isPreferencesUniquePerLayout() &&\n\t\t\tportletDataContext.hasNotUniquePerLayout(portletId)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.createDocument();\n\n\t\tElement portletElement = document.addElement(\"portlet\");\n\n\t\tportletElement.addAttribute(\"portlet-id\", portletId);\n\t\tportletElement.addAttribute(\n\t\t\t\"root-portlet-id\", PortletConstants.getRootPortletId(portletId));\n\t\tportletElement.addAttribute(\"old-plid\", String.valueOf(plid));\n\t\tportletElement.addAttribute(\n\t\t\t\"scope-group-id\",\n\t\t\tString.valueOf(portletDataContext.getScopeGroupId()));\n\t\tportletElement.addAttribute(\n\t\t\t\"scope-layout-type\", portletDataContext.getScopeType());\n\t\tportletElement.addAttribute(\n\t\t\t\"scope-layout-uuid\", portletDataContext.getScopeLayoutUuid());\n\t\tportletElement.addAttribute(\n\t\t\t\"private-layout\", String.valueOf(layout.isPrivateLayout()));\n\n\t\t// Data\n\n\t\tif (exportPortletData) {\n\t\t\tjavax.portlet.PortletPreferences jxPortletPreferences =\n\t\t\t\tPortletPreferencesFactoryUtil.getStrictPortletSetup(\n\t\t\t\t\tlayout, portletId);\n\n\t\t\tif (!portlet.isPreferencesUniquePerLayout()) {\n\t\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\t\tsb.append(portletId);\n\t\t\t\tsb.append(StringPool.AT);\n\t\t\t\tsb.append(portletDataContext.getScopeType());\n\t\t\t\tsb.append(StringPool.AT);\n\t\t\t\tsb.append(portletDataContext.getScopeLayoutUuid());\n\n\t\t\t\tString dataKey = sb.toString();\n\n\t\t\t\tif (!portletDataContext.hasNotUniquePerLayout(dataKey)) {\n\t\t\t\t\tportletDataContext.putNotUniquePerLayout(dataKey);\n\n\t\t\t\t\texportPortletData(\n\t\t\t\t\t\tportletDataContext, portlet, layout,\n\t\t\t\t\t\tjxPortletPreferences, portletElement);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texportPortletData(\n\t\t\t\t\tportletDataContext, portlet, layout, jxPortletPreferences,\n\t\t\t\t\tportletElement);\n\t\t\t}\n\t\t}\n\n\t\t// Portlet preferences\n\n\t\tif (exportPortletSetup) {\n\n\t\t\t// Company\n\n\t\t\texportPortletPreferences(\n\t\t\t\tportletDataContext, portletDataContext.getCompanyId(),\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_COMPANY, false, layout, plid,\n\t\t\t\tportlet.getRootPortletId(), portletElement);\n\n\t\t\t// Group\n\n\t\t\texportPortletPreferences(\n\t\t\t\tportletDataContext, portletDataContext.getScopeGroupId(),\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_GROUP, false, layout,\n\t\t\t\tPortletKeys.PREFS_PLID_SHARED, portlet.getRootPortletId(),\n\t\t\t\tportletElement);\n\n\t\t\t// Layout\n\n\t\t\texportPortletPreferences(\n\t\t\t\tportletDataContext, PortletKeys.PREFS_OWNER_ID_DEFAULT,\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_LAYOUT, false, layout, plid,\n\t\t\t\tportletId, portletElement);\n\t\t}\n\n\t\t// Portlet user preferences\n\n\t\tif (exportPortletUserPreferences) {\n\t\t\tList<PortletPreferences> portletPreferencesList =\n\t\t\t\tPortletPreferencesLocalServiceUtil.getPortletPreferences(\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_USER, plid, portletId);\n\n\t\t\tfor (PortletPreferences portletPreferences :\n\t\t\t\t\tportletPreferencesList) {\n\n\t\t\t\tboolean defaultUser = false;\n\n\t\t\t\tif (portletPreferences.getOwnerId() ==\n\t\t\t\t\t\tPortletKeys.PREFS_OWNER_ID_DEFAULT) {\n\n\t\t\t\t\tdefaultUser = true;\n\t\t\t\t}\n\n\t\t\t\texportPortletPreferences(\n\t\t\t\t\tportletDataContext, portletPreferences.getOwnerId(),\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_USER, defaultUser, layout,\n\t\t\t\t\tplid, portletId, portletElement);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tPortletPreferences groupPortletPreferences =\n\t\t\t\t\tPortletPreferencesLocalServiceUtil.getPortletPreferences(\n\t\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_GROUP,\n\t\t\t\t\t\tPortletKeys.PREFS_PLID_SHARED,\n\t\t\t\t\t\tportlet.getRootPortletId());\n\n\t\t\t\texportPortletPreference(\n\t\t\t\t\tportletDataContext, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_GROUP, false,\n\t\t\t\t\tgroupPortletPreferences, portlet.getRootPortletId(),\n\t\t\t\t\tPortletKeys.PREFS_PLID_SHARED, portletElement);\n\t\t\t}\n\t\t\tcatch (NoSuchPortletPreferencesException nsppe) {\n\t\t\t}\n\t\t}\n\n\t\t// Archived setups\n\n\t\tif (exportPortletArchivedSetups) {\n\t\t\tString rootPortletId = PortletConstants.getRootPortletId(portletId);\n\n\t\t\tList<PortletItem> portletItems =\n\t\t\t\tPortletItemLocalServiceUtil.getPortletItems(\n\t\t\t\t\tportletDataContext.getGroupId(), rootPortletId,\n\t\t\t\t\tPortletPreferences.class.getName());\n\n\t\t\tfor (PortletItem portletItem : portletItems) {\n\t\t\t\texportPortletPreferences(\n\t\t\t\t\tportletDataContext, portletItem.getPortletItemId(),\n\t\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_ARCHIVED, false, null, plid,\n\t\t\t\t\tportletItem.getPortletId(), portletElement);\n\t\t\t}\n\t\t}\n\n\t\t// Permissions\n\n\t\tif (exportPermissions) {\n\t\t\t_permissionExporter.exportPortletPermissions(\n\t\t\t\tportletDataContext, layoutCache, portletId, layout,\n\t\t\t\tportletElement);\n\t\t}\n\n\t\t// Zip\n\n\t\tStringBundler pathSB = new StringBundler(4);\n\n\t\tpathSB.append(\n\t\t\tExportImportPathUtil.getPortletPath(portletDataContext, portletId));\n\t\tpathSB.append(StringPool.SLASH);\n\t\tpathSB.append(plid);\n\t\tpathSB.append(\"/portlet.xml\");\n\n\t\tString path = pathSB.toString();\n\n\t\tElement element = parentElement.addElement(\"portlet\");\n\n\t\telement.addAttribute(\"portlet-id\", portletId);\n\t\telement.addAttribute(\"layout-id\", String.valueOf(layoutId));\n\t\telement.addAttribute(\"path\", path);\n\t\telement.addAttribute(\"portlet-data\", String.valueOf(exportPortletData));\n\n\t\tStringBundler configurationOptionsSB = new StringBundler(6);\n\n\t\tif (exportPortletSetup) {\n\t\t\tconfigurationOptionsSB.append(\"setup\");\n\t\t\tconfigurationOptionsSB.append(StringPool.COMMA);\n\t\t}\n\n\t\tif (exportPortletArchivedSetups) {\n\t\t\tconfigurationOptionsSB.append(\"archived-setups\");\n\t\t\tconfigurationOptionsSB.append(StringPool.COMMA);\n\t\t}\n\n\t\tif (exportPortletUserPreferences) {\n\t\t\tconfigurationOptionsSB.append(\"user-preferences\");\n\t\t\tconfigurationOptionsSB.append(StringPool.COMMA);\n\t\t}\n\n\t\tif (configurationOptionsSB.index() > 0) {\n\t\t\tconfigurationOptionsSB.setIndex(configurationOptionsSB.index() -1);\n\t\t}\n\n\t\telement.addAttribute(\n\t\t\t\"portlet-configuration\", configurationOptionsSB.toString());\n\n\t\tif (portletDataContext.isPathNotProcessed(path)) {\n\t\t\ttry {\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tpath, document.formattedString());\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(ioe.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tportletDataContext.addPrimaryKey(String.class, path);\n\t\t}\n\t}","commit_id":"3f2e311e6c75a2a36c7bb30cca83f7dbabd51352","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected AssetCategory getAssetCategory(\n\t\t\tlong userId, long groupId, String name)\n\t\tthrows PortalException, SystemException {\n\n\t\tString assetVocabularyDefault = PropsUtil.get(\n\t\t\tPropsKeys.ASSET_VOCABULARY_DEFAULT);\n\n\t\tAssetVocabulary assetVocabulary = assetVocabularyPersistence.findByG_N(\n\t\t\tgroupId, assetVocabularyDefault);\n\n\t\tAssetCategory assetCategory = assetCategoryPersistence.fetchByP_N_V(\n\t\t\tAssetCategoryConstants.DEFAULT_PARENT_CATEGORY_ID, name,\n\t\t\tassetVocabulary.getVocabularyId());\n\n\t\tif (assetCategory != null) {\n\t\t\treturn assetCategory;\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setScopeGroupId(groupId);\n\t\tserviceContext.setUserId(userId);\n\n\t\treturn assetCategoryLocalService.addCategory(\n\t\t\tuserId, name, assetVocabulary.getVocabularyId(), serviceContext);\n\t}","id":28446,"modified_method":"protected AssetCategory getAssetCategory(\n\t\t\tlong userId, long groupId, String name)\n\t\tthrows PortalException, SystemException {\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setScopeGroupId(groupId);\n\t\tserviceContext.setUserId(userId);\n\n\t\tAssetVocabulary assetVocabulary = assetVocabularyPersistence.fetchByG_N(\n\t\t\tgroupId, _CALENDAR_VOCABULARY_NAME);\n\n\t\tif (assetVocabulary == null) {\n\t\t\tassetVocabulary = assetVocabularyLocalService.addVocabulary(\n\t\t\t\tuserId, _CALENDAR_VOCABULARY_NAME, serviceContext);\n\t\t}\n\n\t\tAssetCategory assetCategory = assetCategoryPersistence.fetchByP_N_V(\n\t\t\tAssetCategoryConstants.DEFAULT_PARENT_CATEGORY_ID, name,\n\t\t\tassetVocabulary.getVocabularyId());\n\n\t\tif (assetCategory != null) {\n\t\t\treturn assetCategory;\n\t\t}\n\n\t\treturn assetCategoryLocalService.addCategory(\n\t\t\tuserId, name, assetVocabulary.getVocabularyId(), serviceContext);\n\t}","commit_id":"a14ad0bd8e9c9f331e42eb24fc0e9969d5bb4325","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private void initReplayFactory()\n\t{\n\t\tDate replayDate = getTrans().getReplayDate();\n\t\tif (replayDate == null)\n\t\t\tdata.filePlayList = FilePlayListAll.INSTANCE;\n\t\telse\n\t\t\tdata.filePlayList = new FilePlayListReplay(replayDate, meta.getLineNumberFilesDestinationDirectory(), meta.getLineNumberFilesExtension(), meta.getErrorFilesDestinationDirectory(), meta\n\t\t\t\t\t.getErrorFilesExtension(), \"Latin1\");\n\t}","id":28447,"modified_method":"private void initReplayFactory()\n\t{\n\t\tDate replayDate = getTrans().getReplayDate();\n\t\tif (replayDate == null)\n\t\t\tdata.filePlayList = FilePlayListAll.INSTANCE;\n\t\telse\n\t\t\tdata.filePlayList = new FilePlayListReplay(replayDate, environmentSubstitute(meta.getLineNumberFilesDestinationDirectory()), meta.getLineNumberFilesExtension(), environmentSubstitute(meta.getErrorFilesDestinationDirectory()), meta\n\t\t\t\t\t.getErrorFilesExtension(), \"Latin1\");\n\t}","commit_id":"e0a3df35cfe4f021d73b0a5ba2bf6ecc80ba4fa9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void initErrorHandling()\n\t{\n\t\tList<FileErrorHandler> errorHandlers = new ArrayList<FileErrorHandler>(2);\n\n\t\tif (meta.getLineNumberFilesDestinationDirectory() != null)\n\t\t\terrorHandlers.add(new FileErrorHandlerContentLineNumber(getTrans().getCurrentDate(), meta.getLineNumberFilesDestinationDirectory(), meta.getLineNumberFilesExtension(), \"Latin1\", this));\n\t\tif (meta.getErrorFilesDestinationDirectory() != null)\n\t\t\terrorHandlers.add(new FileErrorHandlerMissingFiles(getTrans().getCurrentDate(), meta.getErrorFilesDestinationDirectory(), meta.getErrorFilesExtension(), \"Latin1\", this));\n\t\tdata.errorHandler = new CompositeFileErrorHandler(errorHandlers);\n\t}","id":28448,"modified_method":"private void initErrorHandling()\n\t{\n\t\tList<FileErrorHandler> errorHandlers = new ArrayList<FileErrorHandler>(2);\n\n\t\tif (meta.getLineNumberFilesDestinationDirectory() != null)\n\t\t\terrorHandlers.add(new FileErrorHandlerContentLineNumber(getTrans().getCurrentDate(), environmentSubstitute(meta.getLineNumberFilesDestinationDirectory()), meta.getLineNumberFilesExtension(), \"Latin1\", this));\n\t\tif (meta.getErrorFilesDestinationDirectory() != null)\n\t\t\terrorHandlers.add(new FileErrorHandlerMissingFiles(getTrans().getCurrentDate(), environmentSubstitute(meta.getErrorFilesDestinationDirectory()), meta.getErrorFilesExtension(), \"Latin1\", this));\n\t\tdata.errorHandler = new CompositeFileErrorHandler(errorHandlers);\n\t}","commit_id":"e0a3df35cfe4f021d73b0a5ba2bf6ecc80ba4fa9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void initErrorHandling() {\n    List<FileErrorHandler> dataErrorLineHandlers = new ArrayList<FileErrorHandler>( 2 );\n    if ( meta.getLineNumberFilesDestinationDirectory() != null ) {\n      dataErrorLineHandlers.add( new FileErrorHandlerContentLineNumber( getTrans().getCurrentDate(), meta\n          .getLineNumberFilesDestinationDirectory(), meta.getLineNumberFilesExtension(), meta.getEncoding(), this ) );\n    }\n    if ( meta.getErrorFilesDestinationDirectory() != null ) {\n      dataErrorLineHandlers.add( new FileErrorHandlerMissingFiles( getTrans().getCurrentDate(), meta\n          .getErrorFilesDestinationDirectory(), meta.getErrorLineFilesExtension(), meta.getEncoding(), this ) );\n    }\n    data.dataErrorLineHandler = new CompositeFileErrorHandler( dataErrorLineHandlers );\n  }","id":28449,"modified_method":"private void initErrorHandling() {\n    List<FileErrorHandler> dataErrorLineHandlers = new ArrayList<FileErrorHandler>( 2 );\n    if ( meta.getLineNumberFilesDestinationDirectory() != null ) {\n      dataErrorLineHandlers\n        .add( new FileErrorHandlerContentLineNumber( getTrans().getCurrentDate(), environmentSubstitute( meta\n          .getLineNumberFilesDestinationDirectory() ), meta.getLineNumberFilesExtension(), meta.getEncoding(), this ) );\n    }\n    if ( meta.getErrorFilesDestinationDirectory() != null ) {\n      dataErrorLineHandlers.add( new FileErrorHandlerMissingFiles( getTrans().getCurrentDate(), environmentSubstitute(\n        meta.getErrorFilesDestinationDirectory() ), meta.getErrorLineFilesExtension(), meta.getEncoding(), this ) );\n    }\n    data.dataErrorLineHandler = new CompositeFileErrorHandler( dataErrorLineHandlers );\n  }","commit_id":"7e649a26a628ad4aed1c40ae0af4a41b1c16372f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setFlags() {\n    boolean accept = wAccFilenames.getSelection();\n    wlPassThruFields.setEnabled( accept );\n    wPassThruFields.setEnabled( accept );\n    if ( !wAccFilenames.getSelection() ) {\n      wPassThruFields.setSelection( false );\n    }\n    wlAccField.setEnabled( accept );\n    wAccField.setEnabled( accept );\n    wlAccStep.setEnabled( accept );\n    wAccStep.setEnabled( accept );\n\n    wlFilename.setEnabled( !accept );\n    wbbFilename.setEnabled( !accept ); // Browse: add file or directory\n    wbdFilename.setEnabled( !accept ); // Delete\n    wbeFilename.setEnabled( !accept ); // Edit\n    wbaFilename.setEnabled( !accept ); // Add or change\n    wFilename.setEnabled( !accept );\n    wlFilenameList.setEnabled( !accept );\n    wFilenameList.setEnabled( !accept );\n    wlFilemask.setEnabled( !accept );\n    wFilemask.setEnabled( !accept );\n    wbShowFiles.setEnabled( !accept );\n\n    // Keep this one active: use the sample in the file list\n    // wPreview.setEnabled(!accept);\n\n    wFirst.setEnabled( !accept );\n    wFirstHeader.setEnabled( !accept );\n\n    wlInclFilenameField.setEnabled( wInclFilename.getSelection() );\n    wInclFilenameField.setEnabled( wInclFilename.getSelection() );\n\n    wlInclRownumField.setEnabled( wInclRownum.getSelection() );\n    wInclRownumField.setEnabled( wInclRownum.getSelection() );\n    wlRownumByFileField.setEnabled( wInclRownum.getSelection() );\n    wRownumByFile.setEnabled( wInclRownum.getSelection() );\n\n    // Error handling tab...\n    wlSkipErrorLines.setEnabled( wErrorIgnored.getSelection() );\n    wSkipBadFiles.setEnabled( wErrorIgnored.getSelection() );\n    wBadFileField.setEnabled( wErrorIgnored.getSelection() && wSkipBadFiles.getSelection() );\n    wBadFileMessageField.setEnabled( wErrorIgnored.getSelection() && wSkipBadFiles.getSelection() );\n    wSkipErrorLines.setEnabled( wErrorIgnored.getSelection() );\n    wlErrorCount.setEnabled( wErrorIgnored.getSelection() );\n    wErrorCount.setEnabled( wErrorIgnored.getSelection() );\n    wlErrorFields.setEnabled( wErrorIgnored.getSelection() );\n    wErrorFields.setEnabled( wErrorIgnored.getSelection() );\n    wlErrorText.setEnabled( wErrorIgnored.getSelection() );\n    wErrorText.setEnabled( wErrorIgnored.getSelection() );\n\n    wlWarnDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wWarnDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wlWarnExt.setEnabled( wErrorIgnored.getSelection() );\n    wWarnExt.setEnabled( wErrorIgnored.getSelection() );\n    wbbWarnDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wbvWarnDestDir.setEnabled( wErrorIgnored.getSelection() );\n\n    wlErrorDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wErrorDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wlErrorExt.setEnabled( wErrorIgnored.getSelection() );\n    wErrorExt.setEnabled( wErrorIgnored.getSelection() );\n    wbbErrorDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wbvErrorDestDir.setEnabled( wErrorIgnored.getSelection() );\n\n    wlLineNrDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wLineNrDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wlLineNrExt.setEnabled( wErrorIgnored.getSelection() );\n    wLineNrExt.setEnabled( wErrorIgnored.getSelection() );\n    wbbLineNrDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wbvLineNrDestDir.setEnabled( wErrorIgnored.getSelection() );\n\n    wlNrHeader.setEnabled( wHeader.getSelection() );\n    wNrHeader.setEnabled( wHeader.getSelection() );\n    wlNrFooter.setEnabled( wFooter.getSelection() );\n    wNrFooter.setEnabled( wFooter.getSelection() );\n    wlNrWraps.setEnabled( wWraps.getSelection() );\n    wNrWraps.setEnabled( wWraps.getSelection() );\n\n    wlNrLinesPerPage.setEnabled( wLayoutPaged.getSelection() );\n    wNrLinesPerPage.setEnabled( wLayoutPaged.getSelection() );\n    wlNrLinesDocHeader.setEnabled( wLayoutPaged.getSelection() );\n    wNrLinesDocHeader.setEnabled( wLayoutPaged.getSelection() );\n  }","id":28450,"modified_method":"public void setFlags() {\n    boolean accept = wAccFilenames.getSelection();\n    wlPassThruFields.setEnabled( accept );\n    wPassThruFields.setEnabled( accept );\n    if ( !wAccFilenames.getSelection() ) {\n      wPassThruFields.setSelection( false );\n    }\n    wlAccField.setEnabled( accept );\n    wAccField.setEnabled( accept );\n    wlAccStep.setEnabled( accept );\n    wAccStep.setEnabled( accept );\n\n    wlFilename.setEnabled( !accept );\n    wbbFilename.setEnabled( !accept ); // Browse: add file or directory\n    wbdFilename.setEnabled( !accept ); // Delete\n    wbeFilename.setEnabled( !accept ); // Edit\n    wbaFilename.setEnabled( !accept ); // Add or change\n    wFilename.setEnabled( !accept );\n    wlFilenameList.setEnabled( !accept );\n    wFilenameList.setEnabled( !accept );\n    wlFilemask.setEnabled( !accept );\n    wFilemask.setEnabled( !accept );\n    wbShowFiles.setEnabled( !accept );\n\n    // Keep this one active: use the sample in the file list\n    // wPreview.setEnabled(!accept);\n\n    wFirst.setEnabled( !accept );\n    wFirstHeader.setEnabled( !accept );\n\n    wlInclFilenameField.setEnabled( wInclFilename.getSelection() );\n    wInclFilenameField.setEnabled( wInclFilename.getSelection() );\n\n    wlInclRownumField.setEnabled( wInclRownum.getSelection() );\n    wInclRownumField.setEnabled( wInclRownum.getSelection() );\n    wlRownumByFileField.setEnabled( wInclRownum.getSelection() );\n    wRownumByFile.setEnabled( wInclRownum.getSelection() );\n\n    // Error handling tab...\n    wlSkipErrorLines.setEnabled( wErrorIgnored.getSelection() );\n    wSkipBadFiles.setEnabled( wErrorIgnored.getSelection() );\n    wBadFileField.setEnabled( wErrorIgnored.getSelection() && wSkipBadFiles.getSelection() );\n    wBadFileMessageField.setEnabled( wErrorIgnored.getSelection() && wSkipBadFiles.getSelection() );\n    wSkipErrorLines.setEnabled( wErrorIgnored.getSelection() );\n    wlErrorCount.setEnabled( wErrorIgnored.getSelection() );\n    wErrorCount.setEnabled( wErrorIgnored.getSelection() );\n    wlErrorFields.setEnabled( wErrorIgnored.getSelection() );\n    wErrorFields.setEnabled( wErrorIgnored.getSelection() );\n    wlErrorText.setEnabled( wErrorIgnored.getSelection() );\n    wErrorText.setEnabled( wErrorIgnored.getSelection() );\n\n    wlWarnDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wWarnDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wlWarnExt.setEnabled( wErrorIgnored.getSelection() );\n    wWarnExt.setEnabled( wErrorIgnored.getSelection() );\n    wbbWarnDestDir.setEnabled( wErrorIgnored.getSelection() );\n\n    wlErrorDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wErrorDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wlErrorExt.setEnabled( wErrorIgnored.getSelection() );\n    wErrorExt.setEnabled( wErrorIgnored.getSelection() );\n    wbbErrorDestDir.setEnabled( wErrorIgnored.getSelection() );\n\n    wlLineNrDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wLineNrDestDir.setEnabled( wErrorIgnored.getSelection() );\n    wlLineNrExt.setEnabled( wErrorIgnored.getSelection() );\n    wLineNrExt.setEnabled( wErrorIgnored.getSelection() );\n    wbbLineNrDestDir.setEnabled( wErrorIgnored.getSelection() );\n\n    wlNrHeader.setEnabled( wHeader.getSelection() );\n    wNrHeader.setEnabled( wHeader.getSelection() );\n    wlNrFooter.setEnabled( wFooter.getSelection() );\n    wNrFooter.setEnabled( wFooter.getSelection() );\n    wlNrWraps.setEnabled( wWraps.getSelection() );\n    wNrWraps.setEnabled( wWraps.getSelection() );\n\n    wlNrLinesPerPage.setEnabled( wLayoutPaged.getSelection() );\n    wNrLinesPerPage.setEnabled( wLayoutPaged.getSelection() );\n    wlNrLinesDocHeader.setEnabled( wLayoutPaged.getSelection() );\n    wNrLinesDocHeader.setEnabled( wLayoutPaged.getSelection() );\n  }","commit_id":"7e649a26a628ad4aed1c40ae0af4a41b1c16372f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void addErrorTab() {\n    // ////////////////////////\n    // START OF ERROR TAB ///\n    // /\n    wErrorTab = new CTabItem( wTabFolder, SWT.NONE );\n    wErrorTab.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.ErrorTab.TabTitle\" ) );\n\n    wErrorSComp = new ScrolledComposite( wTabFolder, SWT.V_SCROLL | SWT.H_SCROLL );\n    wErrorSComp.setLayout( new FillLayout() );\n\n    FormLayout errorLayout = new FormLayout();\n    errorLayout.marginWidth = 3;\n    errorLayout.marginHeight = 3;\n\n    wErrorComp = new Composite( wErrorSComp, SWT.NONE );\n    props.setLook( wErrorComp );\n    wErrorComp.setLayout( errorLayout );\n\n    // ERROR HANDLING...\n    // ErrorIgnored?\n    wlErrorIgnored = new Label( wErrorComp, SWT.RIGHT );\n    wlErrorIgnored.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.ErrorIgnored.Label\" ) );\n    props.setLook( wlErrorIgnored );\n    fdlErrorIgnored = new FormData();\n    fdlErrorIgnored.left = new FormAttachment( 0, 0 );\n    fdlErrorIgnored.top = new FormAttachment( 0, margin );\n    fdlErrorIgnored.right = new FormAttachment( middle, -margin );\n    wlErrorIgnored.setLayoutData( fdlErrorIgnored );\n    wErrorIgnored = new Button( wErrorComp, SWT.CHECK );\n    props.setLook( wErrorIgnored );\n    wErrorIgnored.setToolTipText( BaseMessages.getString( PKG, \"TextFileInputDialog.ErrorIgnored.Tooltip\" ) );\n    fdErrorIgnored = new FormData();\n    fdErrorIgnored.left = new FormAttachment( middle, 0 );\n    fdErrorIgnored.top = new FormAttachment( 0, margin );\n    wErrorIgnored.setLayoutData( fdErrorIgnored );\n\n    // Skip bad files?\n    wlSkipBadFiles = new Label( wErrorComp, SWT.RIGHT );\n    wlSkipBadFiles.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.SkipBadFiles.Label\" ) );\n    props.setLook( wlSkipBadFiles );\n    fdlSkipBadFiles = new FormData();\n    fdlSkipBadFiles.left = new FormAttachment( 0, 0 );\n    fdlSkipBadFiles.top = new FormAttachment( wErrorIgnored, margin );\n    fdlSkipBadFiles.right = new FormAttachment( middle, -margin );\n    wlSkipBadFiles.setLayoutData( fdlSkipBadFiles );\n    wSkipBadFiles = new Button( wErrorComp, SWT.CHECK );\n    props.setLook( wSkipBadFiles );\n    wSkipBadFiles.setToolTipText( BaseMessages.getString( PKG, \"TextFileInputDialog.SkipBadFiles.Tooltip\" ) );\n    fdSkipBadFiles = new FormData();\n    fdSkipBadFiles.left = new FormAttachment( middle, 0 );\n    fdSkipBadFiles.top = new FormAttachment( wErrorIgnored, margin );\n    wSkipBadFiles.setLayoutData( fdSkipBadFiles );\n\n    // field for rejected file\n    wlBadFileField = new Label( wErrorComp, SWT.RIGHT );\n    wlBadFileField.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.BadFileField.Label\" ) );\n    props.setLook( wlBadFileField );\n    fdlBadFileField = new FormData();\n    fdlBadFileField.left = new FormAttachment( 0, 0 );\n    fdlBadFileField.top = new FormAttachment( wSkipBadFiles, margin );\n    fdlBadFileField.right = new FormAttachment( middle, -margin );\n    wlBadFileField.setLayoutData( fdlBadFileField );\n    wBadFileField = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wBadFileField );\n    wBadFileField.addModifyListener( lsMod );\n    fdBadFileField = new FormData();\n    fdBadFileField.left = new FormAttachment( middle, 0 );\n    fdBadFileField.top = new FormAttachment( wSkipBadFiles, margin );\n    fdBadFileField.right = new FormAttachment( 100, 0 );\n    wBadFileField.setLayoutData( fdBadFileField );\n\n    // field for file error messsage\n    wlBadFileMessageField = new Label( wErrorComp, SWT.RIGHT );\n    wlBadFileMessageField.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.BadFileMessageField.Label\" ) );\n    props.setLook( wlBadFileMessageField );\n    fdlBadFileMessageField = new FormData();\n    fdlBadFileMessageField.left = new FormAttachment( 0, 0 );\n    fdlBadFileMessageField.top = new FormAttachment( wBadFileField, margin );\n    fdlBadFileMessageField.right = new FormAttachment( middle, -margin );\n    wlBadFileMessageField.setLayoutData( fdlBadFileMessageField );\n    wBadFileMessageField = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wBadFileMessageField );\n    wBadFileMessageField.addModifyListener( lsMod );\n    fdBadFileMessageField = new FormData();\n    fdBadFileMessageField.left = new FormAttachment( middle, 0 );\n    fdBadFileMessageField.top = new FormAttachment( wBadFileField, margin );\n    fdBadFileMessageField.right = new FormAttachment( 100, 0 );\n    wBadFileMessageField.setLayoutData( fdBadFileMessageField );\n\n    // Skip error lines?\n    wlSkipErrorLines = new Label( wErrorComp, SWT.RIGHT );\n    wlSkipErrorLines.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.SkipErrorLines.Label\" ) );\n    props.setLook( wlSkipErrorLines );\n    fdlSkipErrorLines = new FormData();\n    fdlSkipErrorLines.left = new FormAttachment( 0, 0 );\n    fdlSkipErrorLines.top = new FormAttachment( wBadFileMessageField, margin );\n    fdlSkipErrorLines.right = new FormAttachment( middle, -margin );\n    wlSkipErrorLines.setLayoutData( fdlSkipErrorLines );\n    wSkipErrorLines = new Button( wErrorComp, SWT.CHECK );\n    props.setLook( wSkipErrorLines );\n    wSkipErrorLines.setToolTipText( BaseMessages.getString( PKG, \"TextFileInputDialog.SkipErrorLines.Tooltip\" ) );\n    fdSkipErrorLines = new FormData();\n    fdSkipErrorLines.left = new FormAttachment( middle, 0 );\n    fdSkipErrorLines.top = new FormAttachment( wBadFileMessageField, margin );\n    wSkipErrorLines.setLayoutData( fdSkipErrorLines );\n\n    wlErrorCount = new Label( wErrorComp, SWT.RIGHT );\n    wlErrorCount.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.ErrorCount.Label\" ) );\n    props.setLook( wlErrorCount );\n    fdlErrorCount = new FormData();\n    fdlErrorCount.left = new FormAttachment( 0, 0 );\n    fdlErrorCount.top = new FormAttachment( wSkipErrorLines, margin );\n    fdlErrorCount.right = new FormAttachment( middle, -margin );\n    wlErrorCount.setLayoutData( fdlErrorCount );\n    wErrorCount = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wErrorCount );\n    wErrorCount.addModifyListener( lsMod );\n    fdErrorCount = new FormData();\n    fdErrorCount.left = new FormAttachment( middle, 0 );\n    fdErrorCount.top = new FormAttachment( wSkipErrorLines, margin );\n    fdErrorCount.right = new FormAttachment( 100, 0 );\n    wErrorCount.setLayoutData( fdErrorCount );\n\n    wlErrorFields = new Label( wErrorComp, SWT.RIGHT );\n    wlErrorFields.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.ErrorFields.Label\" ) );\n    props.setLook( wlErrorFields );\n    fdlErrorFields = new FormData();\n    fdlErrorFields.left = new FormAttachment( 0, 0 );\n    fdlErrorFields.top = new FormAttachment( wErrorCount, margin );\n    fdlErrorFields.right = new FormAttachment( middle, -margin );\n    wlErrorFields.setLayoutData( fdlErrorFields );\n    wErrorFields = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wErrorFields );\n    wErrorFields.addModifyListener( lsMod );\n    fdErrorFields = new FormData();\n    fdErrorFields.left = new FormAttachment( middle, 0 );\n    fdErrorFields.top = new FormAttachment( wErrorCount, margin );\n    fdErrorFields.right = new FormAttachment( 100, 0 );\n    wErrorFields.setLayoutData( fdErrorFields );\n\n    wlErrorText = new Label( wErrorComp, SWT.RIGHT );\n    wlErrorText.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.ErrorText.Label\" ) );\n    props.setLook( wlErrorText );\n    fdlErrorText = new FormData();\n    fdlErrorText.left = new FormAttachment( 0, 0 );\n    fdlErrorText.top = new FormAttachment( wErrorFields, margin );\n    fdlErrorText.right = new FormAttachment( middle, -margin );\n    wlErrorText.setLayoutData( fdlErrorText );\n    wErrorText = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wErrorText );\n    wErrorText.addModifyListener( lsMod );\n    fdErrorText = new FormData();\n    fdErrorText.left = new FormAttachment( middle, 0 );\n    fdErrorText.top = new FormAttachment( wErrorFields, margin );\n    fdErrorText.right = new FormAttachment( 100, 0 );\n    wErrorText.setLayoutData( fdErrorText );\n\n    // Bad lines files directory + extension\n    Control previous = wErrorText;\n\n    // BadDestDir line\n    wlWarnDestDir = new Label( wErrorComp, SWT.RIGHT );\n    wlWarnDestDir.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.WarnDestDir.Label\" ) );\n    props.setLook( wlWarnDestDir );\n    fdlWarnDestDir = new FormData();\n    fdlWarnDestDir.left = new FormAttachment( 0, 0 );\n    fdlWarnDestDir.top = new FormAttachment( previous, margin * 4 );\n    fdlWarnDestDir.right = new FormAttachment( middle, -margin );\n    wlWarnDestDir.setLayoutData( fdlWarnDestDir );\n\n    wbbWarnDestDir = new Button( wErrorComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbbWarnDestDir );\n    wbbWarnDestDir.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    wbbWarnDestDir.setToolTipText( BaseMessages.getString( PKG, \"System.Tooltip.BrowseForDir\" ) );\n    fdbBadDestDir = new FormData();\n    fdbBadDestDir.right = new FormAttachment( 100, 0 );\n    fdbBadDestDir.top = new FormAttachment( previous, margin * 4 );\n    wbbWarnDestDir.setLayoutData( fdbBadDestDir );\n\n    wbvWarnDestDir = new Button( wErrorComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbvWarnDestDir );\n    wbvWarnDestDir.setText( BaseMessages.getString( PKG, \"System.Button.Variable\" ) );\n    wbvWarnDestDir.setToolTipText( BaseMessages.getString( PKG, \"System.Tooltip.VariableToDir\" ) );\n    fdbvWarnDestDir = new FormData();\n    fdbvWarnDestDir.right = new FormAttachment( wbbWarnDestDir, -margin );\n    fdbvWarnDestDir.top = new FormAttachment( previous, margin * 4 );\n    wbvWarnDestDir.setLayoutData( fdbvWarnDestDir );\n\n    wWarnExt = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wWarnExt );\n    wWarnExt.addModifyListener( lsMod );\n    fdWarnDestExt = new FormData();\n    fdWarnDestExt.left = new FormAttachment( wbvWarnDestDir, -150 );\n    fdWarnDestExt.right = new FormAttachment( wbvWarnDestDir, -margin );\n    fdWarnDestExt.top = new FormAttachment( previous, margin * 4 );\n    wWarnExt.setLayoutData( fdWarnDestExt );\n\n    wlWarnExt = new Label( wErrorComp, SWT.RIGHT );\n    wlWarnExt.setText( BaseMessages.getString( PKG, \"System.Label.Extension\" ) );\n    props.setLook( wlWarnExt );\n    fdlWarnDestExt = new FormData();\n    fdlWarnDestExt.top = new FormAttachment( previous, margin * 4 );\n    fdlWarnDestExt.right = new FormAttachment( wWarnExt, -margin );\n    wlWarnExt.setLayoutData( fdlWarnDestExt );\n\n    wWarnDestDir = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wWarnDestDir );\n    wWarnDestDir.addModifyListener( lsMod );\n    fdBadDestDir = new FormData();\n    fdBadDestDir.left = new FormAttachment( middle, 0 );\n    fdBadDestDir.right = new FormAttachment( wlWarnExt, -margin );\n    fdBadDestDir.top = new FormAttachment( previous, margin * 4 );\n    wWarnDestDir.setLayoutData( fdBadDestDir );\n\n    // Listen to the Browse... button\n    wbbWarnDestDir\n        .addSelectionListener( DirectoryDialogButtonListenerFactory.getSelectionAdapter( shell, wWarnDestDir ) );\n\n    // Listen to the Variable... button\n    wbvWarnDestDir.addSelectionListener( VariableButtonListenerFactory.getSelectionAdapter( shell, wWarnDestDir,\n      transMeta ) );\n\n    // Whenever something changes, set the tooltip to the expanded version of the directory:\n    wWarnDestDir.addModifyListener( getModifyListenerTooltipText( wWarnDestDir ) );\n\n    // Error lines files directory + extension\n    previous = wWarnDestDir;\n\n    // ErrorDestDir line\n    wlErrorDestDir = new Label( wErrorComp, SWT.RIGHT );\n    wlErrorDestDir.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.ErrorDestDir.Label\" ) );\n    props.setLook( wlErrorDestDir );\n    fdlErrorDestDir = new FormData();\n    fdlErrorDestDir.left = new FormAttachment( 0, 0 );\n    fdlErrorDestDir.top = new FormAttachment( previous, margin );\n    fdlErrorDestDir.right = new FormAttachment( middle, -margin );\n    wlErrorDestDir.setLayoutData( fdlErrorDestDir );\n\n    wbbErrorDestDir = new Button( wErrorComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbbErrorDestDir );\n    wbbErrorDestDir.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    wbbErrorDestDir.setToolTipText( BaseMessages.getString( PKG, \"System.Tooltip.BrowseForDir\" ) );\n    fdbErrorDestDir = new FormData();\n    fdbErrorDestDir.right = new FormAttachment( 100, 0 );\n    fdbErrorDestDir.top = new FormAttachment( previous, margin );\n    wbbErrorDestDir.setLayoutData( fdbErrorDestDir );\n\n    wbvErrorDestDir = new Button( wErrorComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbvErrorDestDir );\n    wbvErrorDestDir.setText( BaseMessages.getString( PKG, \"System.Button.Variable\" ) );\n    wbvErrorDestDir.setToolTipText( BaseMessages.getString( PKG, \"System.Tooltip.VariableToDir\" ) );\n    fdbvErrorDestDir = new FormData();\n    fdbvErrorDestDir.right = new FormAttachment( wbbErrorDestDir, -margin );\n    fdbvErrorDestDir.left = new FormAttachment( wbvWarnDestDir, 0, SWT.LEFT );\n    fdbvErrorDestDir.top = new FormAttachment( previous, margin );\n    wbvErrorDestDir.setLayoutData( fdbvErrorDestDir );\n\n    wErrorExt = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wErrorExt );\n    wErrorExt.addModifyListener( lsMod );\n    fdErrorDestExt = new FormData();\n    fdErrorDestExt.left = new FormAttachment( wWarnExt, 0, SWT.LEFT );\n    fdErrorDestExt.right = new FormAttachment( wWarnExt, 0, SWT.RIGHT );\n    fdErrorDestExt.top = new FormAttachment( previous, margin );\n    wErrorExt.setLayoutData( fdErrorDestExt );\n\n    wlErrorExt = new Label( wErrorComp, SWT.RIGHT );\n    wlErrorExt.setText( BaseMessages.getString( PKG, \"System.Label.Extension\" ) );\n    props.setLook( wlErrorExt );\n    fdlErrorDestExt = new FormData();\n    fdlErrorDestExt.top = new FormAttachment( previous, margin );\n    fdlErrorDestExt.right = new FormAttachment( wErrorExt, -margin );\n    wlErrorExt.setLayoutData( fdlErrorDestExt );\n\n    wErrorDestDir = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wErrorDestDir );\n    wErrorDestDir.addModifyListener( lsMod );\n    fdErrorDestDir = new FormData();\n    fdErrorDestDir.left = new FormAttachment( middle, 0 );\n    fdErrorDestDir.right = new FormAttachment( wlErrorExt, -margin );\n    fdErrorDestDir.top = new FormAttachment( previous, margin );\n    wErrorDestDir.setLayoutData( fdErrorDestDir );\n\n    // Listen to the Browse... button\n    wbbErrorDestDir.addSelectionListener( DirectoryDialogButtonListenerFactory.getSelectionAdapter( shell,\n        wErrorDestDir ) );\n\n    // Listen to the Variable... button\n    wbvErrorDestDir.addSelectionListener( VariableButtonListenerFactory.getSelectionAdapter( shell, wErrorDestDir,\n        transMeta ) );\n\n    // Whenever something changes, set the tooltip to the expanded version of the directory:\n    wErrorDestDir.addModifyListener( getModifyListenerTooltipText( wErrorDestDir ) );\n\n    // Data Error lines files directory + extention\n    previous = wErrorDestDir;\n\n    // LineNrDestDir line\n    wlLineNrDestDir = new Label( wErrorComp, SWT.RIGHT );\n    wlLineNrDestDir.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.LineNrDestDir.Label\" ) );\n    props.setLook( wlLineNrDestDir );\n    fdlLineNrDestDir = new FormData();\n    fdlLineNrDestDir.left = new FormAttachment( 0, 0 );\n    fdlLineNrDestDir.top = new FormAttachment( previous, margin );\n    fdlLineNrDestDir.right = new FormAttachment( middle, -margin );\n    wlLineNrDestDir.setLayoutData( fdlLineNrDestDir );\n\n    wbbLineNrDestDir = new Button( wErrorComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbbLineNrDestDir );\n    wbbLineNrDestDir.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    wbbLineNrDestDir.setToolTipText( BaseMessages.getString( PKG, \"System.Tooltip.Browse\" ) );\n    fdbLineNrDestDir = new FormData();\n    fdbLineNrDestDir.right = new FormAttachment( 100, 0 );\n    fdbLineNrDestDir.top = new FormAttachment( previous, margin );\n    wbbLineNrDestDir.setLayoutData( fdbLineNrDestDir );\n\n    wbvLineNrDestDir = new Button( wErrorComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbvLineNrDestDir );\n    wbvLineNrDestDir.setText( BaseMessages.getString( PKG, \"System.Button.Variable\" ) );\n    wbvLineNrDestDir.setToolTipText( \"System.Tooltip.VariableToDir\" );\n    fdbvLineNrDestDir = new FormData();\n    fdbvLineNrDestDir.right = new FormAttachment( wbbLineNrDestDir, -margin );\n    fdbvLineNrDestDir.left = new FormAttachment( wbvErrorDestDir, 0, SWT.LEFT );\n    fdbvLineNrDestDir.top = new FormAttachment( previous, margin );\n    wbvLineNrDestDir.setLayoutData( fdbvLineNrDestDir );\n\n    wLineNrExt = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wLineNrExt );\n    wLineNrExt.addModifyListener( lsMod );\n    fdLineNrDestExt = new FormData();\n    fdLineNrDestExt.left = new FormAttachment( wErrorExt, 0, SWT.LEFT );\n    fdLineNrDestExt.right = new FormAttachment( wErrorExt, 0, SWT.RIGHT );\n    fdLineNrDestExt.top = new FormAttachment( previous, margin );\n    wLineNrExt.setLayoutData( fdLineNrDestExt );\n\n    wlLineNrExt = new Label( wErrorComp, SWT.RIGHT );\n    wlLineNrExt.setText( BaseMessages.getString( PKG, \"System.Label.Extension\" ) );\n    props.setLook( wlLineNrExt );\n    fdlLineNrDestExt = new FormData();\n    fdlLineNrDestExt.top = new FormAttachment( previous, margin );\n    fdlLineNrDestExt.right = new FormAttachment( wLineNrExt, -margin );\n    wlLineNrExt.setLayoutData( fdlLineNrDestExt );\n\n    wLineNrDestDir = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wLineNrDestDir );\n    wLineNrDestDir.addModifyListener( lsMod );\n    fdLineNrDestDir = new FormData();\n    fdLineNrDestDir.left = new FormAttachment( middle, 0 );\n    fdLineNrDestDir.right = new FormAttachment( wlLineNrExt, -margin );\n    fdLineNrDestDir.top = new FormAttachment( previous, margin );\n    wLineNrDestDir.setLayoutData( fdLineNrDestDir );\n\n    // Listen to the Browse... button\n    wbbLineNrDestDir.addSelectionListener( DirectoryDialogButtonListenerFactory.getSelectionAdapter( shell,\n        wLineNrDestDir ) );\n\n    // Listen to the Variable... button\n    wbvLineNrDestDir.addSelectionListener( VariableButtonListenerFactory.getSelectionAdapter( shell, wLineNrDestDir,\n        transMeta ) );\n\n    // Whenever something changes, set the tooltip to the expanded version of the directory:\n    wLineNrDestDir.addModifyListener( getModifyListenerTooltipText( wLineNrDestDir ) );\n\n    fdErrorComp = new FormData();\n    fdErrorComp.left = new FormAttachment( 0, 0 );\n    fdErrorComp.top = new FormAttachment( 0, 0 );\n    fdErrorComp.right = new FormAttachment( 100, 0 );\n    fdErrorComp.bottom = new FormAttachment( 100, 0 );\n    wErrorComp.setLayoutData( fdErrorComp );\n\n    wErrorComp.pack();\n    // What's the size:\n    Rectangle bounds = wErrorComp.getBounds();\n\n    wErrorSComp.setContent( wErrorComp );\n    wErrorSComp.setExpandHorizontal( true );\n    wErrorSComp.setExpandVertical( true );\n    wErrorSComp.setMinWidth( bounds.width );\n    wErrorSComp.setMinHeight( bounds.height );\n\n    wErrorTab.setControl( wErrorSComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF CONTENT TAB\n    // ///////////////////////////////////////////////////////////\n\n  }","id":28451,"modified_method":"private void addErrorTab() {\n    // ////////////////////////\n    // START OF ERROR TAB ///\n    // /\n    wErrorTab = new CTabItem( wTabFolder, SWT.NONE );\n    wErrorTab.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.ErrorTab.TabTitle\" ) );\n\n    wErrorSComp = new ScrolledComposite( wTabFolder, SWT.V_SCROLL | SWT.H_SCROLL );\n    wErrorSComp.setLayout( new FillLayout() );\n\n    FormLayout errorLayout = new FormLayout();\n    errorLayout.marginWidth = 3;\n    errorLayout.marginHeight = 3;\n\n    wErrorComp = new Composite( wErrorSComp, SWT.NONE );\n    props.setLook( wErrorComp );\n    wErrorComp.setLayout( errorLayout );\n\n    // ERROR HANDLING...\n    // ErrorIgnored?\n    wlErrorIgnored = new Label( wErrorComp, SWT.RIGHT );\n    wlErrorIgnored.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.ErrorIgnored.Label\" ) );\n    props.setLook( wlErrorIgnored );\n    fdlErrorIgnored = new FormData();\n    fdlErrorIgnored.left = new FormAttachment( 0, 0 );\n    fdlErrorIgnored.top = new FormAttachment( 0, margin );\n    fdlErrorIgnored.right = new FormAttachment( middle, -margin );\n    wlErrorIgnored.setLayoutData( fdlErrorIgnored );\n    wErrorIgnored = new Button( wErrorComp, SWT.CHECK );\n    props.setLook( wErrorIgnored );\n    wErrorIgnored.setToolTipText( BaseMessages.getString( PKG, \"TextFileInputDialog.ErrorIgnored.Tooltip\" ) );\n    fdErrorIgnored = new FormData();\n    fdErrorIgnored.left = new FormAttachment( middle, 0 );\n    fdErrorIgnored.top = new FormAttachment( 0, margin );\n    wErrorIgnored.setLayoutData( fdErrorIgnored );\n\n    // Skip bad files?\n    wlSkipBadFiles = new Label( wErrorComp, SWT.RIGHT );\n    wlSkipBadFiles.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.SkipBadFiles.Label\" ) );\n    props.setLook( wlSkipBadFiles );\n    fdlSkipBadFiles = new FormData();\n    fdlSkipBadFiles.left = new FormAttachment( 0, 0 );\n    fdlSkipBadFiles.top = new FormAttachment( wErrorIgnored, margin );\n    fdlSkipBadFiles.right = new FormAttachment( middle, -margin );\n    wlSkipBadFiles.setLayoutData( fdlSkipBadFiles );\n    wSkipBadFiles = new Button( wErrorComp, SWT.CHECK );\n    props.setLook( wSkipBadFiles );\n    wSkipBadFiles.setToolTipText( BaseMessages.getString( PKG, \"TextFileInputDialog.SkipBadFiles.Tooltip\" ) );\n    fdSkipBadFiles = new FormData();\n    fdSkipBadFiles.left = new FormAttachment( middle, 0 );\n    fdSkipBadFiles.top = new FormAttachment( wErrorIgnored, margin );\n    wSkipBadFiles.setLayoutData( fdSkipBadFiles );\n\n    // field for rejected file\n    wlBadFileField = new Label( wErrorComp, SWT.RIGHT );\n    wlBadFileField.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.BadFileField.Label\" ) );\n    props.setLook( wlBadFileField );\n    fdlBadFileField = new FormData();\n    fdlBadFileField.left = new FormAttachment( 0, 0 );\n    fdlBadFileField.top = new FormAttachment( wSkipBadFiles, margin );\n    fdlBadFileField.right = new FormAttachment( middle, -margin );\n    wlBadFileField.setLayoutData( fdlBadFileField );\n    wBadFileField = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wBadFileField );\n    wBadFileField.addModifyListener( lsMod );\n    fdBadFileField = new FormData();\n    fdBadFileField.left = new FormAttachment( middle, 0 );\n    fdBadFileField.top = new FormAttachment( wSkipBadFiles, margin );\n    fdBadFileField.right = new FormAttachment( 100, 0 );\n    wBadFileField.setLayoutData( fdBadFileField );\n\n    // field for file error messsage\n    wlBadFileMessageField = new Label( wErrorComp, SWT.RIGHT );\n    wlBadFileMessageField.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.BadFileMessageField.Label\" ) );\n    props.setLook( wlBadFileMessageField );\n    fdlBadFileMessageField = new FormData();\n    fdlBadFileMessageField.left = new FormAttachment( 0, 0 );\n    fdlBadFileMessageField.top = new FormAttachment( wBadFileField, margin );\n    fdlBadFileMessageField.right = new FormAttachment( middle, -margin );\n    wlBadFileMessageField.setLayoutData( fdlBadFileMessageField );\n    wBadFileMessageField = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wBadFileMessageField );\n    wBadFileMessageField.addModifyListener( lsMod );\n    fdBadFileMessageField = new FormData();\n    fdBadFileMessageField.left = new FormAttachment( middle, 0 );\n    fdBadFileMessageField.top = new FormAttachment( wBadFileField, margin );\n    fdBadFileMessageField.right = new FormAttachment( 100, 0 );\n    wBadFileMessageField.setLayoutData( fdBadFileMessageField );\n\n    // Skip error lines?\n    wlSkipErrorLines = new Label( wErrorComp, SWT.RIGHT );\n    wlSkipErrorLines.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.SkipErrorLines.Label\" ) );\n    props.setLook( wlSkipErrorLines );\n    fdlSkipErrorLines = new FormData();\n    fdlSkipErrorLines.left = new FormAttachment( 0, 0 );\n    fdlSkipErrorLines.top = new FormAttachment( wBadFileMessageField, margin );\n    fdlSkipErrorLines.right = new FormAttachment( middle, -margin );\n    wlSkipErrorLines.setLayoutData( fdlSkipErrorLines );\n    wSkipErrorLines = new Button( wErrorComp, SWT.CHECK );\n    props.setLook( wSkipErrorLines );\n    wSkipErrorLines.setToolTipText( BaseMessages.getString( PKG, \"TextFileInputDialog.SkipErrorLines.Tooltip\" ) );\n    fdSkipErrorLines = new FormData();\n    fdSkipErrorLines.left = new FormAttachment( middle, 0 );\n    fdSkipErrorLines.top = new FormAttachment( wBadFileMessageField, margin );\n    wSkipErrorLines.setLayoutData( fdSkipErrorLines );\n\n    wlErrorCount = new Label( wErrorComp, SWT.RIGHT );\n    wlErrorCount.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.ErrorCount.Label\" ) );\n    props.setLook( wlErrorCount );\n    fdlErrorCount = new FormData();\n    fdlErrorCount.left = new FormAttachment( 0, 0 );\n    fdlErrorCount.top = new FormAttachment( wSkipErrorLines, margin );\n    fdlErrorCount.right = new FormAttachment( middle, -margin );\n    wlErrorCount.setLayoutData( fdlErrorCount );\n    wErrorCount = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wErrorCount );\n    wErrorCount.addModifyListener( lsMod );\n    fdErrorCount = new FormData();\n    fdErrorCount.left = new FormAttachment( middle, 0 );\n    fdErrorCount.top = new FormAttachment( wSkipErrorLines, margin );\n    fdErrorCount.right = new FormAttachment( 100, 0 );\n    wErrorCount.setLayoutData( fdErrorCount );\n\n    wlErrorFields = new Label( wErrorComp, SWT.RIGHT );\n    wlErrorFields.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.ErrorFields.Label\" ) );\n    props.setLook( wlErrorFields );\n    fdlErrorFields = new FormData();\n    fdlErrorFields.left = new FormAttachment( 0, 0 );\n    fdlErrorFields.top = new FormAttachment( wErrorCount, margin );\n    fdlErrorFields.right = new FormAttachment( middle, -margin );\n    wlErrorFields.setLayoutData( fdlErrorFields );\n    wErrorFields = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wErrorFields );\n    wErrorFields.addModifyListener( lsMod );\n    fdErrorFields = new FormData();\n    fdErrorFields.left = new FormAttachment( middle, 0 );\n    fdErrorFields.top = new FormAttachment( wErrorCount, margin );\n    fdErrorFields.right = new FormAttachment( 100, 0 );\n    wErrorFields.setLayoutData( fdErrorFields );\n\n    wlErrorText = new Label( wErrorComp, SWT.RIGHT );\n    wlErrorText.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.ErrorText.Label\" ) );\n    props.setLook( wlErrorText );\n    fdlErrorText = new FormData();\n    fdlErrorText.left = new FormAttachment( 0, 0 );\n    fdlErrorText.top = new FormAttachment( wErrorFields, margin );\n    fdlErrorText.right = new FormAttachment( middle, -margin );\n    wlErrorText.setLayoutData( fdlErrorText );\n    wErrorText = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wErrorText );\n    wErrorText.addModifyListener( lsMod );\n    fdErrorText = new FormData();\n    fdErrorText.left = new FormAttachment( middle, 0 );\n    fdErrorText.top = new FormAttachment( wErrorFields, margin );\n    fdErrorText.right = new FormAttachment( 100, 0 );\n    wErrorText.setLayoutData( fdErrorText );\n\n    // Bad lines files directory + extension\n    Control previous = wErrorText;\n\n    // BadDestDir line\n    wlWarnDestDir = new Label( wErrorComp, SWT.RIGHT );\n    wlWarnDestDir.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.WarnDestDir.Label\" ) );\n    props.setLook( wlWarnDestDir );\n    fdlWarnDestDir = new FormData();\n    fdlWarnDestDir.left = new FormAttachment( 0, 0 );\n    fdlWarnDestDir.top = new FormAttachment( previous, margin * 4 );\n    fdlWarnDestDir.right = new FormAttachment( middle, -margin );\n    wlWarnDestDir.setLayoutData( fdlWarnDestDir );\n\n    wbbWarnDestDir = new Button( wErrorComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbbWarnDestDir );\n    wbbWarnDestDir.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    wbbWarnDestDir.setToolTipText( BaseMessages.getString( PKG, \"System.Tooltip.BrowseForDir\" ) );\n    fdbBadDestDir = new FormData();\n    fdbBadDestDir.right = new FormAttachment( 100, 0 );\n    fdbBadDestDir.top = new FormAttachment( previous, margin * 4 );\n    wbbWarnDestDir.setLayoutData( fdbBadDestDir );\n\n    wWarnExt = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wWarnExt );\n    wWarnExt.addModifyListener( lsMod );\n    fdWarnDestExt = new FormData();\n    fdWarnDestExt.left = new FormAttachment( wbbWarnDestDir, -150 );\n    fdWarnDestExt.right = new FormAttachment( wbbWarnDestDir, -margin );\n    fdWarnDestExt.top = new FormAttachment( previous, margin * 4 );\n    wWarnExt.setLayoutData( fdWarnDestExt );\n\n    wlWarnExt = new Label( wErrorComp, SWT.RIGHT );\n    wlWarnExt.setText( BaseMessages.getString( PKG, \"System.Label.Extension\" ) );\n    props.setLook( wlWarnExt );\n    fdlWarnDestExt = new FormData();\n    fdlWarnDestExt.top = new FormAttachment( previous, margin * 4 );\n    fdlWarnDestExt.right = new FormAttachment( wWarnExt, -margin );\n    wlWarnExt.setLayoutData( fdlWarnDestExt );\n\n    wWarnDestDir = new TextVar( transMeta, wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wWarnDestDir );\n    wWarnDestDir.addModifyListener( lsMod );\n    fdBadDestDir = new FormData();\n    fdBadDestDir.left = new FormAttachment( middle, 0 );\n    fdBadDestDir.right = new FormAttachment( wlWarnExt, -margin );\n    fdBadDestDir.top = new FormAttachment( previous, margin * 4 );\n    wWarnDestDir.setLayoutData( fdBadDestDir );\n\n    // Listen to the Browse... button\n    wbbWarnDestDir\n      .addSelectionListener(\n        DirectoryDialogButtonListenerFactory.getSelectionAdapter( shell, wWarnDestDir.getTextWidget() ) );\n\n    // Whenever something changes, set the tooltip to the expanded version of the directory:\n    wWarnDestDir.addModifyListener( getModifyListenerTooltipText( wWarnDestDir.getTextWidget() ) );\n\n    // Error lines files directory + extension\n    previous = wWarnDestDir;\n\n    // ErrorDestDir line\n    wlErrorDestDir = new Label( wErrorComp, SWT.RIGHT );\n    wlErrorDestDir.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.ErrorDestDir.Label\" ) );\n    props.setLook( wlErrorDestDir );\n    fdlErrorDestDir = new FormData();\n    fdlErrorDestDir.left = new FormAttachment( 0, 0 );\n    fdlErrorDestDir.top = new FormAttachment( previous, margin );\n    fdlErrorDestDir.right = new FormAttachment( middle, -margin );\n    wlErrorDestDir.setLayoutData( fdlErrorDestDir );\n\n    wbbErrorDestDir = new Button( wErrorComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbbErrorDestDir );\n    wbbErrorDestDir.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    wbbErrorDestDir.setToolTipText( BaseMessages.getString( PKG, \"System.Tooltip.BrowseForDir\" ) );\n    fdbErrorDestDir = new FormData();\n    fdbErrorDestDir.right = new FormAttachment( 100, 0 );\n    fdbErrorDestDir.top = new FormAttachment( previous, margin );\n    wbbErrorDestDir.setLayoutData( fdbErrorDestDir );\n\n    wErrorExt = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wErrorExt );\n    wErrorExt.addModifyListener( lsMod );\n    fdErrorDestExt = new FormData();\n    fdErrorDestExt.left = new FormAttachment( wWarnExt, 0, SWT.LEFT );\n    fdErrorDestExt.right = new FormAttachment( wWarnExt, 0, SWT.RIGHT );\n    fdErrorDestExt.top = new FormAttachment( previous, margin );\n    wErrorExt.setLayoutData( fdErrorDestExt );\n\n    wlErrorExt = new Label( wErrorComp, SWT.RIGHT );\n    wlErrorExt.setText( BaseMessages.getString( PKG, \"System.Label.Extension\" ) );\n    props.setLook( wlErrorExt );\n    fdlErrorDestExt = new FormData();\n    fdlErrorDestExt.top = new FormAttachment( previous, margin );\n    fdlErrorDestExt.right = new FormAttachment( wErrorExt, -margin );\n    wlErrorExt.setLayoutData( fdlErrorDestExt );\n\n    wErrorDestDir = new TextVar( transMeta, wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wErrorDestDir );\n    wErrorDestDir.addModifyListener( lsMod );\n    fdErrorDestDir = new FormData();\n    fdErrorDestDir.left = new FormAttachment( middle, 0 );\n    fdErrorDestDir.right = new FormAttachment( wlErrorExt, -margin );\n    fdErrorDestDir.top = new FormAttachment( previous, margin );\n    wErrorDestDir.setLayoutData( fdErrorDestDir );\n\n    // Listen to the Browse... button\n    wbbErrorDestDir.addSelectionListener( DirectoryDialogButtonListenerFactory.getSelectionAdapter( shell,\n        wErrorDestDir.getTextWidget() ) );\n\n    // Whenever something changes, set the tooltip to the expanded version of the directory:\n    wErrorDestDir.addModifyListener( getModifyListenerTooltipText( wErrorDestDir.getTextWidget() ) );\n\n    // Data Error lines files directory + extension\n    previous = wErrorDestDir;\n\n    // LineNrDestDir line\n    wlLineNrDestDir = new Label( wErrorComp, SWT.RIGHT );\n    wlLineNrDestDir.setText( BaseMessages.getString( PKG, \"TextFileInputDialog.LineNrDestDir.Label\" ) );\n    props.setLook( wlLineNrDestDir );\n    fdlLineNrDestDir = new FormData();\n    fdlLineNrDestDir.left = new FormAttachment( 0, 0 );\n    fdlLineNrDestDir.top = new FormAttachment( previous, margin );\n    fdlLineNrDestDir.right = new FormAttachment( middle, -margin );\n    wlLineNrDestDir.setLayoutData( fdlLineNrDestDir );\n\n    wbbLineNrDestDir = new Button( wErrorComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbbLineNrDestDir );\n    wbbLineNrDestDir.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    wbbLineNrDestDir.setToolTipText( BaseMessages.getString( PKG, \"System.Tooltip.Browse\" ) );\n    fdbLineNrDestDir = new FormData();\n    fdbLineNrDestDir.right = new FormAttachment( 100, 0 );\n    fdbLineNrDestDir.top = new FormAttachment( previous, margin );\n    wbbLineNrDestDir.setLayoutData( fdbLineNrDestDir );\n\n    wLineNrExt = new Text( wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wLineNrExt );\n    wLineNrExt.addModifyListener( lsMod );\n    fdLineNrDestExt = new FormData();\n    fdLineNrDestExt.left = new FormAttachment( wErrorExt, 0, SWT.LEFT );\n    fdLineNrDestExt.right = new FormAttachment( wErrorExt, 0, SWT.RIGHT );\n    fdLineNrDestExt.top = new FormAttachment( previous, margin );\n    wLineNrExt.setLayoutData( fdLineNrDestExt );\n\n    wlLineNrExt = new Label( wErrorComp, SWT.RIGHT );\n    wlLineNrExt.setText( BaseMessages.getString( PKG, \"System.Label.Extension\" ) );\n    props.setLook( wlLineNrExt );\n    fdlLineNrDestExt = new FormData();\n    fdlLineNrDestExt.top = new FormAttachment( previous, margin );\n    fdlLineNrDestExt.right = new FormAttachment( wLineNrExt, -margin );\n    wlLineNrExt.setLayoutData( fdlLineNrDestExt );\n\n    wLineNrDestDir = new TextVar( transMeta, wErrorComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wLineNrDestDir );\n    wLineNrDestDir.addModifyListener( lsMod );\n    fdLineNrDestDir = new FormData();\n    fdLineNrDestDir.left = new FormAttachment( middle, 0 );\n    fdLineNrDestDir.right = new FormAttachment( wlLineNrExt, -margin );\n    fdLineNrDestDir.top = new FormAttachment( previous, margin );\n    wLineNrDestDir.setLayoutData( fdLineNrDestDir );\n\n    // Listen to the Browse... button\n    wbbLineNrDestDir.addSelectionListener( DirectoryDialogButtonListenerFactory.getSelectionAdapter( shell,\n        wLineNrDestDir.getTextWidget() ) );\n\n    // Whenever something changes, set the tooltip to the expanded version of the directory:\n    wLineNrDestDir.addModifyListener( getModifyListenerTooltipText( wLineNrDestDir.getTextWidget() ) );\n\n    fdErrorComp = new FormData();\n    fdErrorComp.left = new FormAttachment( 0, 0 );\n    fdErrorComp.top = new FormAttachment( 0, 0 );\n    fdErrorComp.right = new FormAttachment( 100, 0 );\n    fdErrorComp.bottom = new FormAttachment( 100, 0 );\n    wErrorComp.setLayoutData( fdErrorComp );\n\n    wErrorComp.pack();\n    // What's the size:\n    Rectangle bounds = wErrorComp.getBounds();\n\n    wErrorSComp.setContent( wErrorComp );\n    wErrorSComp.setExpandHorizontal( true );\n    wErrorSComp.setExpandVertical( true );\n    wErrorSComp.setMinWidth( bounds.width );\n    wErrorSComp.setMinHeight( bounds.height );\n\n    wErrorTab.setControl( wErrorSComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF CONTENT TAB\n    // ///////////////////////////////////////////////////////////\n\n  }","commit_id":"7e649a26a628ad4aed1c40ae0af4a41b1c16372f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"void initFontList() {\n    if (monoFontList == null) {\n      Font[] list = Toolkit.getMonoFontList().toArray(new Font[0]);\n      fontSelectionBox.setModel(new DefaultComboBoxModel(list));\n      fontSelectionBox.setRenderer(new FontNamer());\n      // Preferred size just makes it extend to the container\n      //fontSelectionBox.setSize(fontSelectionBox.getPreferredSize());\n      // Minimum size is better, but cuts things off (on OS X), so we add 20\n      //Dimension minSize = fontSelectionBox.getMinimumSize();\n      //Dimension minSize = fontSelectionBox.getPreferredSize();\n      //fontSelectionBox.setSize(minSize.width + 20, minSize.height);\n      fontSelectionBox.setEnabled(true);\n      monoFontList = list;  // signal that we're finished\n    }\n  }","id":28452,"modified_method":"void initFontList() {\n    /*\n    if (monoFontList == null) {\n      monoFontList = Toolkit.getMonoFontList().toArray(new Font[0]);\n      fontSelectionBox.setModel(new DefaultComboBoxModel(monoFontList));\n      fontSelectionBox.setRenderer(new FontNamer());\n      \n      // Preferred size just makes it extend to the container\n      //fontSelectionBox.setSize(fontSelectionBox.getPreferredSize());\n      // Minimum size is better, but cuts things off (on OS X), so we add 20\n      //Dimension minSize = fontSelectionBox.getMinimumSize();\n      //Dimension minSize = fontSelectionBox.getPreferredSize();\n      //fontSelectionBox.setSize(minSize.width + 20, minSize.height);\n      fontSelectionBox.setEnabled(true);\n    }\n    */\n    if (monoFontFamilies == null) {\n      monoFontFamilies = Toolkit.getMonoFontFamilies();\n      fontSelectionBox.setModel(new DefaultComboBoxModel(monoFontFamilies));\n      String family = get(\"editor.font.family\");\n//      System.out.println(\"family is \" + family);\n//      System.out.println(\"font sel items = \" + fontSelectionBox.getItemCount());\n//      for (int i = 0; i < fontSelectionBox.getItemCount(); i++) {\n//        String item = (String) fontSelectionBox.getItemAt(i);\n//        if (fontSelectionBox.getItemAt(i) == family) {\n//          System.out.println(\"found at index \" + i);\n//        } else if (item.equals(family)) {\n//          System.out.println(\"equals at index \" + i);\n//        } else {\n//          System.out.println(\"nothing doing: \" + item);\n//        }\n//      }\n      // Set a reasonable default, in case selecting the family fails \n      fontSelectionBox.setSelectedItem(\"Monospaced\");\n      fontSelectionBox.setSelectedItem(family);\n      fontSelectionBox.setEnabled(true);\n    }\n  }","commit_id":"0fb0f5b2175b985ec3f64ee439a004ee4020d9fe","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Change internal settings based on what was chosen in the prefs,\n   * then send a message to the editor saying that it's time to do the same.\n   */\n  protected void applyFrame() {\n    setBoolean(\"editor.antialias\", editorAntialiasBox.isSelected()); //$NON-NLS-1$\n\n    setBoolean(\"export.delete_target_folder\", //$NON-NLS-1$\n               deletePreviousBox.isSelected());\n\n    boolean wine = whinyBox.isSelected();\n    setBoolean(\"header.hide.image\", wine); //$NON-NLS-1$\n    setBoolean(\"buttons.hide.image\", wine); //$NON-NLS-1$\n    // Could iterate through editors here and repaint them all, but probably \n    // requires a doLayout() call, and that may have different effects on\n    // each platform, and nobody wants to debug/support that.\n\n    // if the sketchbook path has changed, rebuild the menus\n    String oldPath = get(\"sketchbook.path\"); //$NON-NLS-1$\n    String newPath = sketchbookLocationField.getText();\n    if (!newPath.equals(oldPath)) {\n      base.setSketchbookFolder(new File(newPath));\n    }\n\n//    setBoolean(\"editor.external\", externalEditorBox.isSelected());\n    setBoolean(\"update.check\", checkUpdatesBox.isSelected()); //$NON-NLS-1$\n\n    int oldDisplayIndex = getInteger(\"run.display\"); //$NON-NLS-1$\n    int displayIndex = 0;\n    for (int d = 0; d < displaySelectionBox.getItemCount(); d++) {\n      if (displaySelectionBox.getSelectedIndex() == d) {\n        displayIndex = d;\n      }\n    }\n    if (oldDisplayIndex != displayIndex) {\n      setInteger(\"run.display\", displayIndex); //$NON-NLS-1$\n      for (Editor editor : base.getEditors()) {\n        editor.setSketchLocation(null);\n      }\n    }\n\n    setBoolean(\"run.options.memory\", memoryOverrideBox.isSelected()); //$NON-NLS-1$\n    int memoryMin = Preferences.getInteger(\"run.options.memory.initial\"); //$NON-NLS-1$\n    int memoryMax = Preferences.getInteger(\"run.options.memory.maximum\"); //$NON-NLS-1$\n    try {\n      memoryMax = Integer.parseInt(memoryField.getText().trim());\n      // make sure memory setting isn't too small\n      if (memoryMax < memoryMin) memoryMax = memoryMin;\n      setInteger(\"run.options.memory.maximum\", memoryMax); //$NON-NLS-1$\n    } catch (NumberFormatException e) {\n      System.err.println(\"Ignoring bad memory setting\");\n    }\n\n    /*\n      // was gonna use this to check memory settings,\n      // but it quickly gets much too messy\n    if (getBoolean(\"run.options.memory\")) {\n      Process process = Runtime.getRuntime().exec(new String[] {\n          \"java\", \"-Xms\" + memoryMin + \"m\", \"-Xmx\" + memoryMax + \"m\"\n        });\n      processInput = new SystemOutSiphon(process.getInputStream());\n      processError = new MessageSiphon(process.getErrorStream(), this);\n    }\n    */\n\n    /*\n    // If a change has been made between 32- and 64-bit, the libraries need\n    // to be reloaded so that their native paths are set correctly.\n    if (Base.isMacOS()) {\n      String oldBits = get(\"run.options.bits\"); //$NON-NLS-1$\n      String newBits = bitsThirtyTwoButton.isSelected() ? \"32\" : \"64\"; //$NON-NLS-1$ //$NON-NLS-2$\n      if (!oldBits.equals(newBits)) {\n        set(\"run.options.bits\", newBits); //$NON-NLS-1$\n        for (Mode m : base.getModeList()) {\n          m.rebuildLibraryList();\n        }\n      }\n    }\n    */\n\n    String newSizeText = fontSizeField.getText();\n    try {\n      int newSize = Integer.parseInt(newSizeText.trim());\n      String pieces[] = PApplet.split(get(\"editor.font\"), ','); //$NON-NLS-1$\n      pieces[2] = String.valueOf(newSize);\n      set(\"editor.font\", PApplet.join(pieces, ',')); //$NON-NLS-1$\n\n    } catch (Exception e) {\n      Base.log(\"ignoring invalid font size \" + newSizeText); //$NON-NLS-1$\n    }\n    \n    setBoolean(\"editor.input_method_support\", inputMethodBox.isSelected()); //$NON-NLS-1$\n\n    if (autoAssociateBox != null) {\n      setBoolean(\"platform.auto_file_type_associations\", //$NON-NLS-1$\n                 autoAssociateBox.isSelected());\n    }\n\n    for (Editor editor : base.getEditors()) {\n      editor.applyPreferences();\n    }\n  }","id":28453,"modified_method":"/**\n   * Change internal settings based on what was chosen in the prefs,\n   * then send a message to the editor saying that it's time to do the same.\n   */\n  protected void applyFrame() {\n    setBoolean(\"editor.antialias\", //$NON-NLS-1$\n               editorAntialiasBox.isSelected());\n\n    setBoolean(\"export.delete_target_folder\", //$NON-NLS-1$\n               deletePreviousBox.isSelected());\n\n    boolean wine = whinyBox.isSelected();\n    setBoolean(\"header.hide.image\", wine); //$NON-NLS-1$\n    setBoolean(\"buttons.hide.image\", wine); //$NON-NLS-1$\n    // Could iterate through editors here and repaint them all, but probably \n    // requires a doLayout() call, and that may have different effects on\n    // each platform, and nobody wants to debug/support that.\n\n    // if the sketchbook path has changed, rebuild the menus\n    String oldPath = get(\"sketchbook.path\"); //$NON-NLS-1$\n    String newPath = sketchbookLocationField.getText();\n    if (!newPath.equals(oldPath)) {\n      base.setSketchbookFolder(new File(newPath));\n    }\n\n//    setBoolean(\"editor.external\", externalEditorBox.isSelected());\n    setBoolean(\"update.check\", checkUpdatesBox.isSelected()); //$NON-NLS-1$\n\n    int oldDisplayIndex = getInteger(\"run.display\"); //$NON-NLS-1$\n    int displayIndex = 0;\n    for (int d = 0; d < displaySelectionBox.getItemCount(); d++) {\n      if (displaySelectionBox.getSelectedIndex() == d) {\n        displayIndex = d;\n      }\n    }\n    if (oldDisplayIndex != displayIndex) {\n      setInteger(\"run.display\", displayIndex); //$NON-NLS-1$\n      for (Editor editor : base.getEditors()) {\n        editor.setSketchLocation(null);\n      }\n    }\n\n    setBoolean(\"run.options.memory\", memoryOverrideBox.isSelected()); //$NON-NLS-1$\n    int memoryMin = Preferences.getInteger(\"run.options.memory.initial\"); //$NON-NLS-1$\n    int memoryMax = Preferences.getInteger(\"run.options.memory.maximum\"); //$NON-NLS-1$\n    try {\n      memoryMax = Integer.parseInt(memoryField.getText().trim());\n      // make sure memory setting isn't too small\n      if (memoryMax < memoryMin) memoryMax = memoryMin;\n      setInteger(\"run.options.memory.maximum\", memoryMax); //$NON-NLS-1$\n    } catch (NumberFormatException e) {\n      System.err.println(\"Ignoring bad memory setting\");\n    }\n\n    /*\n      // was gonna use this to check memory settings,\n      // but it quickly gets much too messy\n    if (getBoolean(\"run.options.memory\")) {\n      Process process = Runtime.getRuntime().exec(new String[] {\n          \"java\", \"-Xms\" + memoryMin + \"m\", \"-Xmx\" + memoryMax + \"m\"\n        });\n      processInput = new SystemOutSiphon(process.getInputStream());\n      processError = new MessageSiphon(process.getErrorStream(), this);\n    }\n    */\n\n    /*\n    // If a change has been made between 32- and 64-bit, the libraries need\n    // to be reloaded so that their native paths are set correctly.\n    if (Base.isMacOS()) {\n      String oldBits = get(\"run.options.bits\"); //$NON-NLS-1$\n      String newBits = bitsThirtyTwoButton.isSelected() ? \"32\" : \"64\"; //$NON-NLS-1$ //$NON-NLS-2$\n      if (!oldBits.equals(newBits)) {\n        set(\"run.options.bits\", newBits); //$NON-NLS-1$\n        for (Mode m : base.getModeList()) {\n          m.rebuildLibraryList();\n        }\n      }\n    }\n    */\n\n    //set(\"editor.font\", fontSelectionBox.getSelectedItem());\n    String fontFamily = (String) fontSelectionBox.getSelectedItem();\n        \n    String newSizeText = fontSizeField.getText();\n    try {\n      int newSize = Integer.parseInt(newSizeText.trim());\n      String pieces[] = PApplet.split(get(\"editor.font\"), ','); //$NON-NLS-1$\n      pieces[2] = String.valueOf(newSize);\n      set(\"editor.font\", PApplet.join(pieces, ',')); //$NON-NLS-1$\n\n    } catch (Exception e) {\n      Base.log(\"ignoring invalid font size \" + newSizeText); //$NON-NLS-1$\n    }\n    \n    setBoolean(\"editor.input_method_support\", inputMethodBox.isSelected()); //$NON-NLS-1$\n\n    if (autoAssociateBox != null) {\n      setBoolean(\"platform.auto_file_type_associations\", //$NON-NLS-1$\n                 autoAssociateBox.isSelected());\n    }\n\n    for (Editor editor : base.getEditors()) {\n      editor.applyPreferences();\n    }\n  }","commit_id":"0fb0f5b2175b985ec3f64ee439a004ee4020d9fe","url":"https://github.com/processing/processing"},{"original_method":"static public List<Font> getMonoFontList() {\n    GraphicsEnvironment ge =\n      GraphicsEnvironment.getLocalGraphicsEnvironment();\n    Font[] fonts = ge.getAllFonts();\n    ArrayList<Font> outgoing = new ArrayList<Font>();\n    // Using AffineTransform.getScaleInstance(100, 100) doesn't change sizes\n    FontRenderContext frc = \n      new FontRenderContext(new AffineTransform(),\n                            Preferences.getBoolean(\"editor.antialias\"), \n                            true);  // use fractional metrics \n    for (Font font : fonts) {\n      if (font.canDisplay('i') && font.canDisplay('M') &&\n          font.canDisplay(' ') && font.canDisplay('.')) {\n        \n        // The old method just returns 1 or 0, and using deriveFont(size)  \n        // is overkill. It also causes deprecation warnings\n//        @SuppressWarnings(\"deprecation\")\n//        FontMetrics fm = awtToolkit.getFontMetrics(font);\n        //FontMetrics fm = awtToolkit.getFontMetrics(font.deriveFont(24));\n//        System.out.println(fm.charWidth('i') + \" \" + fm.charWidth('M'));\n//        if (fm.charWidth('i') == fm.charWidth('M') &&\n//            fm.charWidth('M') == fm.charWidth(' ') && \n//            fm.charWidth(' ') == fm.charWidth('.')) {\n        double w = font.getStringBounds(\" \", frc).getWidth();\n        if (w == font.getStringBounds(\"i\", frc).getWidth() && \n            w == font.getStringBounds(\"M\", frc).getWidth() &&\n            w == font.getStringBounds(\".\", frc).getWidth()) {\n          outgoing.add(font);\n//          System.out.println(\"  good \" + w);\n        }\n      }\n    }\n    return outgoing;\n  }","id":28454,"modified_method":"static private List<Font> getMonoFontList() {\n    GraphicsEnvironment ge =\n      GraphicsEnvironment.getLocalGraphicsEnvironment();\n    Font[] fonts = ge.getAllFonts();\n    ArrayList<Font> outgoing = new ArrayList<Font>();\n    // Using AffineTransform.getScaleInstance(100, 100) doesn't change sizes\n    FontRenderContext frc = \n      new FontRenderContext(new AffineTransform(),\n                            Preferences.getBoolean(\"editor.antialias\"), \n                            true);  // use fractional metrics \n    for (Font font : fonts) {\n      if (font.getStyle() == Font.PLAIN &&\n          font.canDisplay('i') && font.canDisplay('M') &&\n          font.canDisplay(' ') && font.canDisplay('.')) {\n        \n        // The old method just returns 1 or 0, and using deriveFont(size)  \n        // is overkill. It also causes deprecation warnings\n//        @SuppressWarnings(\"deprecation\")\n//        FontMetrics fm = awtToolkit.getFontMetrics(font);\n        //FontMetrics fm = awtToolkit.getFontMetrics(font.deriveFont(24));\n//        System.out.println(fm.charWidth('i') + \" \" + fm.charWidth('M'));\n//        if (fm.charWidth('i') == fm.charWidth('M') &&\n//            fm.charWidth('M') == fm.charWidth(' ') && \n//            fm.charWidth(' ') == fm.charWidth('.')) {\n        double w = font.getStringBounds(\" \", frc).getWidth();\n        if (w == font.getStringBounds(\"i\", frc).getWidth() && \n            w == font.getStringBounds(\"M\", frc).getWidth() &&\n            w == font.getStringBounds(\".\", frc).getWidth()) {\n          \n//          //PApplet.printArray(font.getAvailableAttributes());\n//          Map<TextAttribute,?> attr = font.getAttributes();\n//          System.out.println(font.getFamily() + \" > \" + font.getName());\n//          System.out.println(font.getAttributes());\n//          System.out.println(\"  \" + attr.get(TextAttribute.WEIGHT));\n//          System.out.println(\"  \" + attr.get(TextAttribute.POSTURE));\n          \n          outgoing.add(font);\n//          System.out.println(\"  good \" + w);\n        }\n      }\n    }\n    return outgoing;\n  }","commit_id":"0fb0f5b2175b985ec3f64ee439a004ee4020d9fe","url":"https://github.com/processing/processing"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    final Presentation presentation = e.getPresentation();\n    presentation.setVisible(false);\n    final DataContext dataContext = e.getDataContext();\n    final PsiElement[] psiElements = LangDataKeys.PSI_ELEMENT_ARRAY.getData(dataContext);\n    if (psiElements != null) {\n      final Set<PsiElement> foundMembers = getPatternBasedProducer().collectTestMembers(psiElements, true);\n      if (foundMembers.isEmpty()) return;\n      final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n      if (project != null) {\n        final List<T> foundConfigurations = collectPatternConfigurations(foundMembers, project);\n        if (!foundConfigurations.isEmpty()) {\n          presentation.setVisible(true);\n          if (foundConfigurations.size() == 1) {\n            presentation.setText(\"Add to temp suite: \" + foundConfigurations.get(0).getName());\n          }\n        }\n      }\n    }\n  }","id":28455,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    final Presentation presentation = e.getPresentation();\n    presentation.setVisible(false);\n    final DataContext dataContext = e.getDataContext();\n    final PsiElement[] psiElements = LangDataKeys.PSI_ELEMENT_ARRAY.getData(dataContext);\n    if (psiElements != null) {\n      PsiElementProcessor.CollectElementsWithLimit<PsiElement> processor = new PsiElementProcessor.CollectElementsWithLimit<PsiElement>(2);\n      getPatternBasedProducer().collectTestMembers(psiElements, false, false, processor);\n      Collection<PsiElement> collection = processor.getCollection();\n      if (collection.isEmpty()) return;\n      final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n      if (project != null) {\n        final List<T> foundConfigurations = collectPatternConfigurations(collection, project);\n        if (!foundConfigurations.isEmpty()) {\n          presentation.setVisible(true);\n          if (foundConfigurations.size() == 1) {\n            presentation.setText(\"Add to temp suite: \" + foundConfigurations.get(0).getName());\n          }\n        }\n      }\n    }\n  }","commit_id":"564bdc40dcc0f92c0bf9c0446dca66803ff1ecd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<T> collectPatternConfigurations(Set<PsiElement> foundClasses, Project project) {\n    final List<RunConfiguration> configurations = RunManager.getInstance(project).getConfigurationsList(getConfigurationType());\n    final List<T> foundConfigurations = new ArrayList<T>();\n    for (RunConfiguration configuration : configurations) {\n      if (isPatternBasedConfiguration((T)configuration)) {\n        if (foundClasses.size() > 1 ||\n            !getPatterns((T)configuration).contains(AbstractPatternBasedConfigurationProducer.getQName(foundClasses.iterator().next()))) {\n          foundConfigurations.add((T)configuration);\n        }\n      }\n    }\n    return foundConfigurations;\n  }","id":28456,"modified_method":"private List<T> collectPatternConfigurations(Collection<PsiElement> foundClasses, Project project) {\n    final List<RunConfiguration> configurations = RunManager.getInstance(project).getConfigurationsList(getConfigurationType());\n    final List<T> foundConfigurations = new ArrayList<T>();\n    for (RunConfiguration configuration : configurations) {\n      if (isPatternBasedConfiguration((T)configuration)) {\n        if (foundClasses.size() > 1 ||\n            !getPatterns((T)configuration).contains(AbstractPatternBasedConfigurationProducer.getQName(foundClasses.iterator().next()))) {\n          foundConfigurations.add((T)configuration);\n        }\n      }\n    }\n    return foundConfigurations;\n  }","commit_id":"564bdc40dcc0f92c0bf9c0446dca66803ff1ecd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    final PsiElement[] psiElements = LangDataKeys.PSI_ELEMENT_ARRAY.getData(dataContext);\n    final Set<PsiElement> classes = getPatternBasedProducer().collectTestMembers(psiElements, true);\n\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    final List<T> patternConfigurations = collectPatternConfigurations(classes, project);\n    if (patternConfigurations.size() == 1) {\n      final T configuration = patternConfigurations.get(0);\n      for (PsiElement aClass : classes) {\n        getPatterns(configuration).add(AbstractPatternBasedConfigurationProducer.getQName(aClass));\n      }\n    } else {\n      JBPopupFactory.getInstance().createListPopup(new BaseListPopupStep<T>(\"Choose suite to add\", patternConfigurations) {\n        @Override\n        public PopupStep onChosen(T configuration, boolean finalChoice) {\n          for (PsiElement aClass : classes) {\n            getPatterns(configuration).add(AbstractPatternBasedConfigurationProducer.getQName(aClass));\n          }\n          return FINAL_CHOICE;\n        }\n\n        @Override\n        public Icon getIconFor(T configuration) {\n          return configuration.getIcon();\n        }\n\n        @NotNull\n        @Override\n        public String getTextFor(T value) {\n          return value.getName();\n        }\n      }).showInBestPositionFor(dataContext);\n    }\n  }","id":28457,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    final PsiElement[] psiElements = LangDataKeys.PSI_ELEMENT_ARRAY.getData(dataContext);\n    final LinkedHashSet<PsiElement> classes = new LinkedHashSet<PsiElement>();\n    PsiElementProcessor.CollectElements<PsiElement> processor = new PsiElementProcessor.CollectElements<PsiElement>(classes);\n    getPatternBasedProducer().collectTestMembers(psiElements, true, true, processor);\n\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    final List<T> patternConfigurations = collectPatternConfigurations(classes, project);\n    if (patternConfigurations.size() == 1) {\n      final T configuration = patternConfigurations.get(0);\n      for (PsiElement aClass : classes) {\n        getPatterns(configuration).add(AbstractPatternBasedConfigurationProducer.getQName(aClass));\n      }\n    } else {\n      JBPopupFactory.getInstance().createListPopup(new BaseListPopupStep<T>(\"Choose suite to add\", patternConfigurations) {\n        @Override\n        public PopupStep onChosen(T configuration, boolean finalChoice) {\n          for (PsiElement aClass : classes) {\n            getPatterns(configuration).add(AbstractPatternBasedConfigurationProducer.getQName(aClass));\n          }\n          return FINAL_CHOICE;\n        }\n\n        @Override\n        public Icon getIconFor(T configuration) {\n          return configuration.getIcon();\n        }\n\n        @NotNull\n        @Override\n        public String getTextFor(T value) {\n          return value.getName();\n        }\n      }).showInBestPositionFor(dataContext);\n    }\n  }","commit_id":"564bdc40dcc0f92c0bf9c0446dca66803ff1ecd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isMultipleElementsSelected(ConfigurationContext context) {\n    if (TestsUIUtil.isMultipleSelectionImpossible(context.getDataContext())) return false;\n    final LinkedHashSet<String> classes = new LinkedHashSet<String>();\n    final PsiElement[] elements = collectPatternElements(context, classes);\n    if (elements != null && collectTestMembers(elements, false).size() > 1) {\n      return true;\n    }\n    return false;\n  }","id":28458,"modified_method":"public boolean isMultipleElementsSelected(ConfigurationContext context) {\n    final DataContext dataContext = context.getDataContext();\n    if (TestsUIUtil.isMultipleSelectionImpossible(dataContext)) return false;\n    final LinkedHashSet<String> classes = new LinkedHashSet<String>();\n    final PsiElementProcessor.CollectElementsWithLimit<PsiElement> processor = new PsiElementProcessor.CollectElementsWithLimit<PsiElement>(2);\n    final PsiElement[] locationElements = collectLocationElements(classes, dataContext);\n    if (locationElements != null) {\n      collectTestMembers(locationElements, false, false, processor);\n    }\n    else {\n      collectContextElements(dataContext, false, false, classes, processor);\n    }\n    return processor.getCollection().size() > 1;\n  }","commit_id":"564bdc40dcc0f92c0bf9c0446dca66803ff1ecd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isConfiguredFromContext(ConfigurationContext context, Set<String> patterns) {\n    final LinkedHashSet<String> classes = new LinkedHashSet<String>();\n    collectPatternElements(context, classes);\n    if (Comparing.equal(classes, patterns)) {\n      return true;\n    }\n    return false;\n  }","id":28459,"modified_method":"public boolean isConfiguredFromContext(ConfigurationContext context, Set<String> patterns) {\n    final LinkedHashSet<String> classes = new LinkedHashSet<String>();\n    final DataContext dataContext = context.getDataContext();\n    final PsiElement[] locationElements = collectLocationElements(classes, dataContext);\n    if (locationElements == null) {\n      collectContextElements(dataContext, true, false, classes, new PsiElementProcessor.CollectElements<PsiElement>());\n    }\n    if (Comparing.equal(classes, patterns)) {\n      return true;\n    }\n    return false;\n  }","commit_id":"564bdc40dcc0f92c0bf9c0446dca66803ff1ecd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Set<PsiElement> collectTestMembers(PsiElement[] psiElements, boolean checkAbstract) {\n    final Set<PsiElement> foundMembers = new LinkedHashSet<PsiElement>();\n    for (PsiElement psiElement : psiElements) {\n      if (psiElement instanceof PsiClassOwner) {\n        final PsiClass[] classes = ((PsiClassOwner)psiElement).getClasses();\n        for (PsiClass aClass : classes) {\n          if (isTestClass(aClass)) {\n            foundMembers.add(aClass);\n          }\n        }\n      } else if (psiElement instanceof PsiClass) {\n        if (isTestClass((PsiClass)psiElement)) {\n          foundMembers.add(psiElement);\n        }\n      } else if (psiElement instanceof PsiMethod) {\n        if (isTestMethod(checkAbstract, psiElement)) {\n          foundMembers.add(psiElement);\n        }\n      } else if (psiElement instanceof PsiDirectory) {\n        final PsiPackage aPackage = JavaDirectoryService.getInstance().getPackage((PsiDirectory)psiElement);\n        if (aPackage != null) {\n          foundMembers.add(aPackage);\n        }\n      }\n    }\n    return foundMembers;\n  }","id":28460,"modified_method":"public void collectTestMembers(PsiElement[] psiElements,\n                                 boolean checkAbstract,\n                                 boolean checkIsTest,\n                                 PsiElementProcessor.CollectElements<PsiElement> collectingProcessor) {\n    for (PsiElement psiElement : psiElements) {\n      if (psiElement instanceof PsiClassOwner) {\n        final PsiClass[] classes = ((PsiClassOwner)psiElement).getClasses();\n        for (PsiClass aClass : classes) {\n          if ((!checkIsTest || isTestClass(aClass)) && !collectingProcessor.execute(aClass)) {\n            return;\n          }\n        }\n      } else if (psiElement instanceof PsiClass) {\n        if ((!checkIsTest || isTestClass((PsiClass)psiElement)) && !collectingProcessor.execute(psiElement)) {\n          return;\n        }\n      } else if (psiElement instanceof PsiMethod) {\n        if ((!checkIsTest || isTestMethod(checkAbstract, psiElement)) && !collectingProcessor.execute(psiElement)) {\n          return;\n        }\n      } else if (psiElement instanceof PsiDirectory) {\n        final PsiPackage aPackage = JavaDirectoryService.getInstance().getPackage((PsiDirectory)psiElement);\n        if (aPackage != null && !collectingProcessor.execute(aPackage)) {\n          return;\n        }\n      }\n    }\n  }","commit_id":"564bdc40dcc0f92c0bf9c0446dca66803ff1ecd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement checkPatterns(ConfigurationContext context, LinkedHashSet<String> classes) {\n    PsiElement[] elements = collectPatternElements(context, classes);\n    if (elements == null || collectTestMembers(elements, false).size() <= 1) {\n      return null;\n    }\n    return elements[0];\n  }","id":28461,"modified_method":"public PsiElement checkPatterns(ConfigurationContext context, LinkedHashSet<String> classes) {\n    PsiElement[] result;\n    final DataContext dataContext = context.getDataContext();\n    final PsiElement[] locationElements = collectLocationElements(classes, dataContext);\n    PsiElementProcessor.CollectElements<PsiElement> processor = new PsiElementProcessor.CollectElements<PsiElement>();\n    if (locationElements != null) {\n      collectTestMembers(locationElements, false, true, processor);\n      result = processor.toArray();\n    }\n    else if (collectContextElements(dataContext, true, true, classes, processor)) {\n      result = processor.toArray();\n    }\n    else {\n      return null;\n    }\n    if (result.length <= 1) {\n      return null;\n    }\n    return result[0];\n  }","commit_id":"564bdc40dcc0f92c0bf9c0446dca66803ff1ecd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PsiElement[] collectPatternElements(ConfigurationContext context, LinkedHashSet<String> classes) {\n    final DataContext dataContext = context.getDataContext();\n    final Location<?>[] locations = Location.DATA_KEYS.getData(dataContext);\n    if (locations != null) {\n      List<PsiElement> elements = new ArrayList<PsiElement>();\n      for (Location<?> location : locations) {\n        final PsiElement psiElement = location.getPsiElement();\n        classes.add(getQName(psiElement, location));\n        elements.add(psiElement);\n      }\n      return elements.toArray(new PsiElement[elements.size()]);\n    }\n    PsiElement[] elements = LangDataKeys.PSI_ELEMENT_ARRAY.getData(dataContext);\n    if (elements != null) {\n      for (PsiElement psiClass : collectTestMembers(elements, true)) {\n        classes.add(getQName(psiClass));\n      }\n      return elements;\n    } else {\n      final VirtualFile[] files = CommonDataKeys.VIRTUAL_FILE_ARRAY.getData(dataContext);\n      if (files != null) {\n        final List<PsiFile> psiFiles = new ArrayList<PsiFile>();\n        final PsiManager psiManager = PsiManager.getInstance(context.getProject());\n        for (VirtualFile file : files) {\n          final PsiFile psiFile = psiManager.findFile(file);\n          if (psiFile instanceof PsiClassOwner) {\n            for (PsiElement psiMember : collectTestMembers(((PsiClassOwner)psiFile).getClasses(), true)) {\n              classes.add(((PsiClass)psiMember).getQualifiedName());\n            }\n            psiFiles.add(psiFile);\n          }\n        }\n        return psiFiles.toArray(new PsiElement[psiFiles.size()]);\n      }\n    }\n    return null;\n  }","id":28462,"modified_method":"private static PsiElement[] collectLocationElements(LinkedHashSet<String> classes, DataContext dataContext) {\n    final Location<?>[] locations = Location.DATA_KEYS.getData(dataContext);\n    if (locations != null) {\n      List<PsiElement> elements = new ArrayList<PsiElement>();\n      for (Location<?> location : locations) {\n        final PsiElement psiElement = location.getPsiElement();\n        classes.add(getQName(psiElement, location));\n        elements.add(psiElement);\n      }\n      return elements.toArray(new PsiElement[elements.size()]);\n    }\n    return null;\n  }","commit_id":"564bdc40dcc0f92c0bf9c0446dca66803ff1ecd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean collectContextElements(DataContext dataContext,\n                                         boolean checkAbstract,\n                                         boolean checkIsTest, \n                                         LinkedHashSet<String> classes,\n                                         PsiElementProcessor.CollectElements<PsiElement> processor) {\n    PsiElement[] elements = LangDataKeys.PSI_ELEMENT_ARRAY.getData(dataContext);\n    if (elements != null) {\n      collectTestMembers(elements, checkAbstract, checkIsTest, processor);\n      for (PsiElement psiClass : processor.getCollection()) {\n        classes.add(getQName(psiClass));\n      }\n      return true;\n    }\n    else {\n      final PsiElement element = CommonDataKeys.PSI_ELEMENT.getData(dataContext);\n      final VirtualFile[] files = CommonDataKeys.VIRTUAL_FILE_ARRAY.getData(dataContext);\n      if (files != null) {\n        Project project = CommonDataKeys.PROJECT.getData(dataContext);\n        if (project != null) {\n          final PsiManager psiManager = PsiManager.getInstance(project);\n          for (VirtualFile file : files) {\n            final PsiFile psiFile = psiManager.findFile(file);\n            if (psiFile instanceof PsiClassOwner) {\n              PsiClass[] psiClasses = ((PsiClassOwner)psiFile).getClasses();\n              if (element != null && psiClasses.length > 0) {\n                for (PsiClass aClass : psiClasses) {\n                  if (PsiTreeUtil.isAncestor(aClass, element, false)) {\n                    psiClasses = new PsiClass[] {aClass};\n                    break;\n                  }\n                }\n              }\n              collectTestMembers(psiClasses, checkAbstract, checkIsTest, processor);\n              for (PsiElement psiMember : processor.getCollection()) {\n                classes.add(((PsiClass)psiMember).getQualifiedName());\n              }\n            }\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }","id":28463,"modified_method":"private boolean collectContextElements(DataContext dataContext,\n                                         boolean checkAbstract,\n                                         boolean checkIsTest, \n                                         LinkedHashSet<String> classes,\n                                         PsiElementProcessor.CollectElements<PsiElement> processor) {\n    PsiElement[] elements = LangDataKeys.PSI_ELEMENT_ARRAY.getData(dataContext);\n    if (elements != null) {\n      return collectTestMembers(elements, checkAbstract, checkIsTest, processor, classes);\n    }\n    else {\n      final Editor editor = CommonDataKeys.EDITOR.getData(dataContext);\n      if (editor != null) {\n        final List<Caret> allCarets = editor.getCaretModel().getAllCarets();\n        if (allCarets.size() > 1) {\n          final PsiFile editorFile = CommonDataKeys.PSI_FILE.getData(dataContext);\n          if (editorFile != null) {\n            final Set<PsiMethod> methods = new LinkedHashSet<PsiMethod>();\n            for (Caret caret : allCarets) {\n              ContainerUtil.addIfNotNull(methods, PsiTreeUtil.getParentOfType(editorFile.findElementAt(caret.getOffset()), PsiMethod.class));\n            }\n            if (!methods.isEmpty()) {\n              return collectTestMembers(methods.toArray(new PsiElement[0]), checkAbstract, checkIsTest, processor, classes);\n            }\n          }\n        }\n      }\n      final PsiElement element = CommonDataKeys.PSI_ELEMENT.getData(dataContext);\n      final VirtualFile[] files = CommonDataKeys.VIRTUAL_FILE_ARRAY.getData(dataContext);\n      if (files != null) {\n        Project project = CommonDataKeys.PROJECT.getData(dataContext);\n        if (project != null) {\n          final PsiManager psiManager = PsiManager.getInstance(project);\n          for (VirtualFile file : files) {\n            final PsiFile psiFile = psiManager.findFile(file);\n            if (psiFile instanceof PsiClassOwner) {\n              PsiClass[] psiClasses = ((PsiClassOwner)psiFile).getClasses();\n              if (element != null && psiClasses.length > 0) {\n                for (PsiClass aClass : psiClasses) {\n                  if (PsiTreeUtil.isAncestor(aClass, element, false)) {\n                    psiClasses = new PsiClass[] {aClass};\n                    break;\n                  }\n                }\n              }\n              collectTestMembers(psiClasses, checkAbstract, checkIsTest, processor);\n              for (PsiElement psiMember : processor.getCollection()) {\n                classes.add(((PsiClass)psiMember).getQualifiedName());\n              }\n            }\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }","commit_id":"1190715024dce3585c3dc679faebac78da72aa84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@PUT\n\t@Consumes({ MediaTypes.APPLICATION_FLIES_DOCUMENT_XML, MediaTypes.APPLICATION_FLIES_DOCUMENT_JSON,\n\t\t\t\tMediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })\n\t@Restrict(\"#{identity.loggedIn}\")\n\tpublic Response put(Document document) throws URISyntaxException {\n\t\t\n\t\tString hDocId = URIHelper.convertFromDocumentURIId(documentId);\n\n\t\tif(!document.getId().equals(hDocId)){\n\t\t\tResponse.notAcceptable(Collections.EMPTY_LIST).build();\n\t\t}\n\n\t\tHProjectContainer hProjectContainer = getContainerOrFail();\n\n\t\tHDocument hDoc = documentDAO.getByDocId(hProjectContainer, hDocId);\n\t\t\n\t\tif(hDoc == null) { // it's a create operation\n\t\t\thDoc = new HDocument(document);\n\t\t\thDoc.setRevision(1);\n\t\t\thProjectContainer.getDocuments().add(hDoc);\n\t\t\ttry{\n\t\t\t\tsession.flush();\n\t\t\t\tfor(Resource res : document.getResources()) {\n\t\t\t\t\tHResource hRes = HDocument.create(res);\n\t\t\t\t\thRes.setDocument(hDoc);\n\t\t\t\t\thDoc.getResourceTree().add(hRes);\n\t\t\t\t\tsession.flush();\n\t\t\t\t}\n\t\t\t\treturn Response.created( new URI(\"/d/\"+hDoc.getDocId())).build();\n\t\t\t}\n\t\t\tcatch(Exception e){\n\t\t\t\treturn Response.notAcceptable(Collections.EMPTY_LIST).build();\n\t\t\t}\n\t\t}\n\t\telse{ // it's an update operation\n\t\t\tif(!document.getName().equals(hDoc.getName()) ){\n\t\t\t\thDoc.setName(document.getName());\n\t\t\t}\n\t\t\ttry{\n\t\t\t\tsession.flush();\n\t\t\t\treturn Response.ok().build();\n\t\t\t}\n\t\t\tcatch(Exception e){\n\t\t\t\treturn Response.notAcceptable(Collections.EMPTY_LIST).build();\n\t\t\t}\n\t\t}\n\t\t\n\t}","id":28464,"modified_method":"@PUT\n\t@Consumes({ MediaTypes.APPLICATION_FLIES_DOCUMENT_XML, MediaTypes.APPLICATION_FLIES_DOCUMENT_JSON,\n\t\t\t\tMediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })\n\t@Restrict(\"#{identity.loggedIn}\")\n\tpublic Response put(Document document) throws URISyntaxException {\n\t\t\n\t\tString hDocId = URIHelper.convertFromDocumentURIId(documentId);\n\n\t\tif(!document.getId().equals(hDocId)){\n\t\t\tResponse.notAcceptable(Collections.EMPTY_LIST).build();\n\t\t}\n\n\t\tHProjectContainer hProjectContainer = getContainerOrFail();\n\n\t\tHDocument hDoc = documentDAO.getByDocId(hProjectContainer, hDocId);\n\t\t\n\t\tif(hDoc == null) { // it's a create operation\n\t\t\thDoc = new HDocument(document);\n\t\t\thDoc.setRevision(1);\n\t\t\thProjectContainer.getDocuments().put(hDoc.getDocId(), hDoc);\n\t\t\ttry{\n\t\t\t\tsession.flush();\n\t\t\t\tfor(Resource res : document.getResources()) {\n\t\t\t\t\tHResource hRes = HDocument.create(res);\n\t\t\t\t\thRes.setDocument(hDoc);\n\t\t\t\t\thDoc.getResourceTree().add(hRes);\n\t\t\t\t\tsession.flush();\n\t\t\t\t}\n\t\t\t\treturn Response.created( new URI(\"/d/\"+hDoc.getDocId())).build();\n\t\t\t}\n\t\t\tcatch(Exception e){\n\t\t\t\treturn Response.notAcceptable(Collections.EMPTY_LIST).build();\n\t\t\t}\n\t\t}\n\t\telse{ // it's an update operation\n\t\t\tif(!document.getName().equals(hDoc.getName()) ){\n\t\t\t\thDoc.setName(document.getName());\n\t\t\t}\n\t\t\ttry{\n\t\t\t\tsession.flush();\n\t\t\t\treturn Response.ok().build();\n\t\t\t}\n\t\t\tcatch(Exception e){\n\t\t\t\treturn Response.notAcceptable(Collections.EMPTY_LIST).build();\n\t\t\t}\n\t\t}\n\t\t\n\t}","commit_id":"8e8c39d1b6c0d3894cf18f0ad03e505c102d7fc7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void put(Documents docs) {\n    \tlog.info(\"HTTP PUT \"+documentsService.getRequest().getRequestURL()+\" :\\n\"+docs);\n    \tHProjectContainer hContainer = getContainer();\n    \tList<HDocument> hDocs = new ArrayList<HDocument>();\n    \tgetContainer().setDocuments(hDocs);\n    \tfor (Document doc: docs.getDocuments()) {\n\t\t\t// if doc already exists, load it and update it, but don't create it\n    \t\tHDocument hDoc = documentDAO.getByDocId(hContainer, doc.getId());\n    \t\tif (hDoc == null) {\n    \t\t\thDoc = new HDocument(doc);\n    \t\t\thDoc.setProject(hContainer);\n    \t\t}\n    \t\thDocs.add(hDoc);\n    \t\tsession.save(hDoc);\n    \t\tcopy(doc, hDoc, true);\n    \t}\n    \t// TODO ensure omitted docs get deleted by Hibernate\n    \tsession.flush();\n    }","id":28465,"modified_method":"public void put(Documents docs) {\n    \tlog.info(\"HTTP PUT \"+documentsService.getRequest().getRequestURL()+\" :\\n\"+docs);\n    \tHProjectContainer hContainer = getContainer();\n    \tfor (Document doc: docs.getDocuments()) {\n\t\t\t// if doc already exists, load it and update it, but don't create it\n    \t\tHDocument hDoc = documentDAO.getByDocId(hContainer, doc.getId());\n    \t\tif (hDoc == null) {\n    \t\t\thDoc = new HDocument(doc);\n    \t\t\thDoc.setProject(hContainer);\n    \t\t}\n    \t\thContainer.getDocuments().put(hDoc.getDocId(), hDoc);\n    \t\tsession.save(hDoc);\n    \t\tcopy(doc, hDoc, true);\n    \t}\n    \t// TODO ensure omitted docs get deleted by Hibernate\n    \tsession.flush();\n    }","commit_id":"8e8c39d1b6c0d3894cf18f0ad03e505c102d7fc7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void post(Documents docs) {\n    \tlog.info(\"HTTP POST \"+documentsService.getRequest().getRequestURL()+\" :\\n\"+docs);\n    \tHProjectContainer hContainer = getContainer();\n    \tfor (Document doc: docs.getDocuments()) {\n\t\t\t// if doc already exists, load it and update it, but don't create it\n    \t\tHDocument hDoc = documentDAO.getByDocId(hContainer, doc.getId());\n    \t\tif (hDoc == null) {\n    \t\t\thDoc = new HDocument(doc);\n    \t\t\thDoc.setProject(hContainer);\n    \t\t}\n    \t\tgetContainer().getDocuments().add(hDoc);\n    \t\tsession.save(hDoc);\n    \t\tcopy(doc, hDoc, false);\n    \t}\n    \tsession.flush();\n    }","id":28466,"modified_method":"public void post(Documents docs) {\n    \tlog.info(\"HTTP POST \"+documentsService.getRequest().getRequestURL()+\" :\\n\"+docs);\n    \tHProjectContainer hContainer = getContainer();\n    \tfor (Document doc: docs.getDocuments()) {\n\t\t\t// if doc already exists, load it and update it, but don't create it\n    \t\tHDocument hDoc = documentDAO.getByDocId(hContainer, doc.getId());\n    \t\tif (hDoc == null) {\n    \t\t\thDoc = new HDocument(doc);\n    \t\t\thDoc.setProject(hContainer);\n    \t\t}\n    \t\tgetContainer().getDocuments().put(hDoc.getDocId(), hDoc);\n    \t\tsession.save(hDoc);\n    \t\tcopy(doc, hDoc, false);\n    \t}\n    \tsession.flush();\n    }","commit_id":"8e8c39d1b6c0d3894cf18f0ad03e505c102d7fc7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public Documents get() {\n    \tlog.info(\"HTTP GET \"+documentsService.getRequest().getRequestURL());\n    \tList<HDocument> hdocs = getContainer().getDocuments();\n    \tDocuments result = new Documents();\n\t\n    \tfor (HDocument hDocument : hdocs) {\n    \t\tresult.getDocuments().add(hDocument.toDocument());\n    \t}\n    \tlog.info(\"HTTP GET result :\\n\"+result);\n    \treturn result;\n    }","id":28467,"modified_method":"public Documents get() {\n    \tlog.info(\"HTTP GET \"+documentsService.getRequest().getRequestURL());\n    \tCollection<HDocument> hdocs = getContainer().getDocuments().values();\n    \tDocuments result = new Documents();\n\t\n    \tfor (HDocument hDocument : hdocs) {\n    \t\tresult.getDocuments().add(hDocument.toDocument());\n    \t}\n    \tlog.info(\"HTTP GET result :\\n\"+result);\n    \treturn result;\n    }","commit_id":"8e8c39d1b6c0d3894cf18f0ad03e505c102d7fc7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void setDocuments(List<HDocument> documents) {\n\t\tthis.documents = documents;\n\t}","id":28468,"modified_method":"public void setDocuments(Map<String,HDocument> documents) {\n\t\tthis.documents = documents;\n\t}","commit_id":"8e8c39d1b6c0d3894cf18f0ad03e505c102d7fc7","url":"https://github.com/zanata/zanata-server"},{"original_method":"@IndexColumn(name=\"pos\",base=0,nullable=false)\n\t@JoinColumn(name=\"project_id\",nullable=false)\n\t@OneToMany(cascade=CascadeType.ALL)\n\t//@OnDelete(action=OnDeleteAction.CASCADE)\n\tpublic List<HDocument> getDocuments() {\n\t\tif(documents == null)\n\t\t\tdocuments = new ArrayList<HDocument>();\n\t\treturn documents;\n\t}","id":28469,"modified_method":"@OneToMany(mappedBy = \"project\", cascade=CascadeType.ALL)\n\t@MapKey(name=\"docId\")\n\tpublic Map<String, HDocument> getDocuments() {\n\t\tif(documents == null)\n\t\t\tdocuments = new HashMap<String,HDocument>();\n\t\treturn documents;\n\t}","commit_id":"8e8c39d1b6c0d3894cf18f0ad03e505c102d7fc7","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void loadTree() {\n\t\trootNode = new FolderNode(\"/\");\n\t\t\n\t\tList<HDocument> documents = getInstance().getDocuments();\n\t\tfor(HDocument doc : documents){\n\t\t\taddNode(doc);\n\t\t}\n\t}","id":28470,"modified_method":"private void loadTree() {\n\t\trootNode = new FolderNode(\"/\");\n\t\t\n\t\tfor(HDocument doc : getInstance().getDocuments().values()){\n\t\t\taddNode(doc);\n\t\t}\n\t}","commit_id":"8e8c39d1b6c0d3894cf18f0ad03e505c102d7fc7","url":"https://github.com/zanata/zanata-server"},{"original_method":"private static ProjectIteration toMini(org.fedorahosted.flies.core.model.HProjectIteration hibIt){\n\t\tProjectIteration it = new ProjectIteration();\n\t\tit.setId(hibIt.getSlug());\n\t\tit.setName(hibIt.getName());\n\t\tit.setSummary(hibIt.getDescription());\n\t\t\n\t\tfor(HDocument doc : hibIt.getContainer().getDocuments() ){\n\t\t\tit.getDocuments().add( \n\t\t\t\t\tnew Document(\n\t\t\t\t\t\t\tdoc.getDocId(),\n\t\t\t\t\t\t\tdoc.getName(),\n\t\t\t\t\t\t\tdoc.getPath(),\n\t\t\t\t\t\t\tdoc.getContentType(),\n\t\t\t\t\t\t\tdoc.getRevision(),\n\t\t\t\t\t\t\tdoc.getLocale()\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t}\n\t\t\n\t\treturn it;\n\n\t\t\n\t}","id":28471,"modified_method":"private static ProjectIteration toMini(org.fedorahosted.flies.core.model.HProjectIteration hibIt){\n\t\tProjectIteration it = new ProjectIteration();\n\t\tit.setId(hibIt.getSlug());\n\t\tit.setName(hibIt.getName());\n\t\tit.setSummary(hibIt.getDescription());\n\t\t\n\t\tfor(HDocument doc : hibIt.getContainer().getDocuments().values() ){\n\t\t\tit.getDocuments().add( \n\t\t\t\t\tnew Document(\n\t\t\t\t\t\t\tdoc.getDocId(),\n\t\t\t\t\t\t\tdoc.getName(),\n\t\t\t\t\t\t\tdoc.getPath(),\n\t\t\t\t\t\t\tdoc.getContentType(),\n\t\t\t\t\t\t\tdoc.getRevision(),\n\t\t\t\t\t\t\tdoc.getLocale()\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t}\n\t\t\n\t\treturn it;\n\n\t\t\n\t}","commit_id":"8e8c39d1b6c0d3894cf18f0ad03e505c102d7fc7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void initialize() {\n\t\tif(isConversationActive()) return;\n\t\t\n\t\tlog.info(\"Initializing workspace for '{0}'\", workspaceId);\n\t\tif(workspaceId == null){\n\t\t\tthrow new NoSuchWorkspaceException();\n\t\t}\n\t\telse{\n\t\t\tString [] ws = workspaceId.split(\"/\");\n\t\t\tif(ws.length != 2){\n\t\t\t\tthrow new NoSuchWorkspaceException(workspaceId);\n\t\t\t}\n\t\t\ttry{\n\t\t\t\tLong projectIterationId = Long.parseLong(ws[0]);\n\t\t\t\tString localeId = ws[1];\n\t\t\t\tprojectIteration = entityManager.find(HProjectIteration.class, projectIterationId);\n\t\t\t\tprojectContainer = projectIteration.getContainer();\n\t\t\t\t\n\t\t\t\tlog.info(\"Initializing targets\");\n\t\t\t\tlocale = new LocaleId(localeId);\n\n\t\t\t\tfor(HDocument doc : projectContainer.getDocuments() ){\n\t\t\t\t\tif(!doc.getTargets().containsKey(locale)){\n\t\t\t\t\t\tHDocumentTarget docTarget = new HDocumentTarget(doc, locale);\n\t\t\t\t\t\tentityManager.persist(docTarget);\n\t\t\t\t\t\tfor (HResource res : doc.getResources().values() ){\n\t\t\t\t\t\t\tif(res instanceof HTextFlow){\n\t\t\t\t\t\t\t\tHTextFlowTarget target = new HTextFlowTarget(docTarget, (HTextFlow) res);\n\t\t\t\t\t\t\t\ttarget.setContent(\"\");\n\t\t\t\t\t\t\t\tentityManager.persist(target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tHPerson translator = entityManager.find(HPerson.class, authenticatedAccount.getPerson().getId());\n\t\t\t\tgetWorkspace().registerTranslator(translator);\n\t\t\t}\n\t\t\tcatch(Exception e){\n\t\t\t\tthrow new NoSuchWorkspaceException(workspaceId);\n\t\t\t}\n\t\t}\n\t}","id":28472,"modified_method":"public void initialize() {\n\t\tif(isConversationActive()) return;\n\t\t\n\t\tlog.info(\"Initializing workspace for '{0}'\", workspaceId);\n\t\tif(workspaceId == null){\n\t\t\tthrow new NoSuchWorkspaceException();\n\t\t}\n\t\telse{\n\t\t\tString [] ws = workspaceId.split(\"/\");\n\t\t\tif(ws.length != 2){\n\t\t\t\tthrow new NoSuchWorkspaceException(workspaceId);\n\t\t\t}\n\t\t\ttry{\n\t\t\t\tLong projectIterationId = Long.parseLong(ws[0]);\n\t\t\t\tString localeId = ws[1];\n\t\t\t\tprojectIteration = entityManager.find(HProjectIteration.class, projectIterationId);\n\t\t\t\tprojectContainer = projectIteration.getContainer();\n\t\t\t\t\n\t\t\t\tlog.info(\"Initializing targets\");\n\t\t\t\tlocale = new LocaleId(localeId);\n\n\t\t\t\tfor(String docId : projectContainer.getDocuments().keySet() ){\n\t\t\t\t\tHDocument doc = projectContainer.getDocuments().get(docId);\n\t\t\t\t\tif(!doc.getTargets().containsKey(locale)){\n\t\t\t\t\t\tHDocumentTarget docTarget = new HDocumentTarget(doc, locale);\n\t\t\t\t\t\tentityManager.persist(docTarget);\n\t\t\t\t\t\tfor (HResource res : doc.getResources().values() ){\n\t\t\t\t\t\t\tif(res instanceof HTextFlow){\n\t\t\t\t\t\t\t\tHTextFlowTarget target = new HTextFlowTarget(docTarget, (HTextFlow) res);\n\t\t\t\t\t\t\t\ttarget.setContent(\"\");\n\t\t\t\t\t\t\t\tentityManager.persist(target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tHPerson translator = entityManager.find(HPerson.class, authenticatedAccount.getPerson().getId());\n\t\t\t\tgetWorkspace().registerTranslator(translator);\n\t\t\t}\n\t\t\tcatch(Exception e){\n\t\t\t\tthrow new NoSuchWorkspaceException(workspaceId);\n\t\t\t}\n\t\t}\n\t}","commit_id":"8e8c39d1b6c0d3894cf18f0ad03e505c102d7fc7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public synchronized Machine getMaster()\n    {\n        Machine result = super.getMaster();\n        if ( result != null )\n        {\n            setMasterChangeWatcher( result.getMachineId() );\n        }\n        return result;\n    }","id":28473,"modified_method":"public synchronized Machine getMaster()\n    {\n        Machine result = super.getMaster();\n        if ( result != null )\n        {\n            setDataChangeWatcher( MASTER_NOTIFY_CHILD, result.getMachineId() );\n            setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n        }\n        return result;\n    }","commit_id":"701f7f31513b8d498f7bf480038a607d64f0e182","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void process( WatchedEvent event )\n    {\n        String path = event.getPath();\n        System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n        if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n        {\n            keeperState = KeeperState.Expired;\n            zooKeeper = instantiateZooKeeper();\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n        {\n            sequenceNr = setup();\n            keeperState = KeeperState.SyncConnected;\n            if ( firstSyncConnected )\n            {\n                firstSyncConnected = false;\n            }\n            else\n            {\n                receiver.somethingIsWrong( new Exception() );\n            }\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n        {\n            keeperState = KeeperState.Disconnected;\n        }\n        else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n        {\n            // If my current master is the same as the master which this master-notify thingie\n            // says, just ignore it.\n//            System.out.println( \"NodeDataChanged (most likely master-notify)\" );\n//            Machine master = getMaster();\n//            if ( master != null && master.getMachineId() == getMasterNotifyId() )\n//            {\n//                System.out.println( \"...but no change, so just chill\" );\n//                return;\n//            }\n            \n            receiver.somethingIsWrong( new Exception() );\n        }\n    }","id":28474,"modified_method":"public void process( WatchedEvent event )\n    {\n        String path = event.getPath();\n        System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n        if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n        {\n            keeperState = KeeperState.Expired;\n            zooKeeper = instantiateZooKeeper();\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n        {\n            sequenceNr = setup();\n            keeperState = KeeperState.SyncConnected;\n            if ( firstSyncConnected )\n            {\n                firstSyncConnected = false;\n            }\n            else\n            {\n                receiver.somethingIsWrong( new Exception() );\n            }\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n        {\n            keeperState = KeeperState.Disconnected;\n        }\n        else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n        {\n            if ( path.contains( MASTER_NOTIFY_CHILD ) )\n            {\n                if ( super.getMaster().getMachineId() != machineId )\n                {\n                    return;\n                }\n            }\n            else if ( path.contains( MASTER_REBOUND_CHILD ) )\n            {\n                if ( super.getMaster().getMachineId() == machineId )\n                {\n                    return;\n                }\n            }\n            else\n            {\n                System.out.println( \"Unrecognized data change \" + path );\n                return;\n            }\n            receiver.somethingIsWrong( new Exception() );\n        }\n    }","commit_id":"701f7f31513b8d498f7bf480038a607d64f0e182","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void setMasterChangeWatcher( int currentMasterId )\n    {\n        try\n        {\n            String root = getRoot();\n            String path = root + \"/\" + MASTER_NOTIFY_CHILD;\n            byte[] data = null;\n            boolean exists = false;\n            try\n            { \n                data = zooKeeper.getData( path, true, null );\n                exists = true;\n                int id = ByteBuffer.wrap( data ).getInt();\n                if ( id == currentMasterId )\n                {\n                    return;\n                }\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() != KeeperException.Code.NONODE )\n                {\n                    throw new ZooKeeperException( \"Couldn't get master notify node\", e );\n                }\n            }\n            \n            // Didn't exist or has changed\n            try\n            {\n                data = new byte[4];\n                ByteBuffer.wrap( data ).putInt( currentMasterId );\n                if ( !exists )\n                {\n                    zooKeeper.create( path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, \n                            CreateMode.PERSISTENT );\n                }\n                else\n                {\n                    zooKeeper.setData( path, data, -1 );\n                }\n                System.out.println( \"master-notify set to \" + currentMasterId );\n                \n                // Add a watch for it\n                zooKeeper.getData( path, true, null );\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() != KeeperException.Code.NODEEXISTS )\n                {\n                    throw new ZooKeeperException( \"Couldn't set master notify node\", e );\n                }\n            }\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","id":28475,"modified_method":"protected void setDataChangeWatcher( String child, int currentMasterId )\n    {\n        try\n        {\n            String root = getRoot();\n            String path = root + \"/\" + child;\n            byte[] data = null;\n            boolean exists = false;\n            try\n            { \n                data = zooKeeper.getData( path, true, null );\n                exists = true;\n                int id = ByteBuffer.wrap( data ).getInt();\n                if ( currentMasterId == -1 || id == currentMasterId )\n                {\n                    return;\n                }\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() != KeeperException.Code.NONODE )\n                {\n                    throw new ZooKeeperException( \"Couldn't get master notify node\", e );\n                }\n            }\n            \n            // Didn't exist or has changed\n            try\n            {\n                data = new byte[4];\n                ByteBuffer.wrap( data ).putInt( currentMasterId );\n                if ( !exists )\n                {\n                    zooKeeper.create( path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, \n                            CreateMode.PERSISTENT );\n                }\n                else if ( currentMasterId != -1 )\n                {\n                    zooKeeper.setData( path, data, -1 );\n                }\n                System.out.println( child + \" set to \" + currentMasterId );\n                \n                // Add a watch for it\n                zooKeeper.getData( path, true, null );\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() != KeeperException.Code.NODEEXISTS )\n                {\n                    throw new ZooKeeperException( \"Couldn't set master notify node\", e );\n                }\n            }\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","commit_id":"701f7f31513b8d498f7bf480038a607d64f0e182","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ZooKeeperBroker( String storeDir, int machineId, String zooKeeperServers, \n            String haServer, ResponseReceiver receiver )\n    {\n        super( machineId );\n        this.haServer = haServer;\n        NeoStoreUtil store = new NeoStoreUtil( storeDir ); \n        this.zooClient = new ZooClient( zooKeeperServers, machineId, store.getCreationTime(),\n                store.getStoreId(), store.getLastCommittedTx(), receiver, haServer );\n    }","id":28476,"modified_method":"public ZooKeeperBroker( String storeDir, int machineId, String zooKeeperServers, \n            String haServer, ResponseReceiver receiver )\n    {\n        super( machineId );\n        this.machineId = machineId;\n        this.haServer = haServer;\n        NeoStoreUtil store = new NeoStoreUtil( storeDir ); \n        this.zooClient = new ZooClient( zooKeeperServers, machineId, store.getCreationTime(),\n                store.getStoreId(), store.getLastCommittedTx(), receiver, haServer );\n    }","commit_id":"701f7f31513b8d498f7bf480038a607d64f0e182","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Object instantiateMasterServer( GraphDatabaseService graphDb )\n    {\n        return new MasterServer( new MasterImpl( graphDb ),\n                Machine.splitIpAndPort( haServer ).other() );\n    }","id":28477,"modified_method":"public Object instantiateMasterServer( GraphDatabaseService graphDb )\n    {\n        MasterServer server = new MasterServer( new MasterImpl( graphDb ),\n                Machine.splitIpAndPort( haServer ).other() );\n        zooClient.setDataChangeWatcher( ZooClient.MASTER_REBOUND_CHILD, machineId );\n        return server;\n    }","commit_id":"701f7f31513b8d498f7bf480038a607d64f0e182","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized Machine getMaster()\n    {\n        Machine result = super.getMaster();\n        if ( result != null )\n        {\n            setMasterChangeWatcher( result.getMachineId() );\n        }\n        return result;\n    }","id":28478,"modified_method":"public synchronized Machine getMaster()\n    {\n        Machine result = super.getMaster();\n        if ( result != null )\n        {\n            setDataChangeWatcher( MASTER_NOTIFY_CHILD, result.getMachineId() );\n            setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n        }\n        return result;\n    }","commit_id":"2ce0d1e385dff1d66f7367b0252a591e1816ad04","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void process( WatchedEvent event )\n    {\n        String path = event.getPath();\n        System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n        if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n        {\n            keeperState = KeeperState.Expired;\n            zooKeeper = instantiateZooKeeper();\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n        {\n            sequenceNr = setup();\n            keeperState = KeeperState.SyncConnected;\n            if ( firstSyncConnected )\n            {\n                firstSyncConnected = false;\n            }\n            else\n            {\n                receiver.somethingIsWrong( new Exception() );\n            }\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n        {\n            keeperState = KeeperState.Disconnected;\n        }\n        else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n        {\n            // If my current master is the same as the master which this master-notify thingie\n            // says, just ignore it.\n//            System.out.println( \"NodeDataChanged (most likely master-notify)\" );\n//            Machine master = getMaster();\n//            if ( master != null && master.getMachineId() == getMasterNotifyId() )\n//            {\n//                System.out.println( \"...but no change, so just chill\" );\n//                return;\n//            }\n            \n            receiver.somethingIsWrong( new Exception() );\n        }\n    }","id":28479,"modified_method":"public void process( WatchedEvent event )\n    {\n        String path = event.getPath();\n        System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n        if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n        {\n            keeperState = KeeperState.Expired;\n            zooKeeper = instantiateZooKeeper();\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n        {\n            sequenceNr = setup();\n            keeperState = KeeperState.SyncConnected;\n            if ( firstSyncConnected )\n            {\n                firstSyncConnected = false;\n            }\n            else\n            {\n                receiver.somethingIsWrong( new Exception() );\n            }\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n        {\n            keeperState = KeeperState.Disconnected;\n        }\n        else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n        {\n            if ( path.contains( MASTER_NOTIFY_CHILD ) )\n            {\n                if ( super.getMaster().getMachineId() != machineId )\n                {\n                    return;\n                }\n            }\n            else if ( path.contains( MASTER_REBOUND_CHILD ) )\n            {\n                if ( super.getMaster().getMachineId() == machineId )\n                {\n                    return;\n                }\n            }\n            else\n            {\n                System.out.println( \"Unrecognized data change \" + path );\n                return;\n            }\n            receiver.somethingIsWrong( new Exception() );\n        }\n    }","commit_id":"2ce0d1e385dff1d66f7367b0252a591e1816ad04","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void setMasterChangeWatcher( int currentMasterId )\n    {\n        try\n        {\n            String root = getRoot();\n            String path = root + \"/\" + MASTER_NOTIFY_CHILD;\n            byte[] data = null;\n            boolean exists = false;\n            try\n            { \n                data = zooKeeper.getData( path, true, null );\n                exists = true;\n                int id = ByteBuffer.wrap( data ).getInt();\n                if ( id == currentMasterId )\n                {\n                    return;\n                }\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() != KeeperException.Code.NONODE )\n                {\n                    throw new ZooKeeperException( \"Couldn't get master notify node\", e );\n                }\n            }\n            \n            // Didn't exist or has changed\n            try\n            {\n                data = new byte[4];\n                ByteBuffer.wrap( data ).putInt( currentMasterId );\n                if ( !exists )\n                {\n                    zooKeeper.create( path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, \n                            CreateMode.PERSISTENT );\n                }\n                else\n                {\n                    zooKeeper.setData( path, data, -1 );\n                }\n                System.out.println( \"master-notify set to \" + currentMasterId );\n                \n                // Add a watch for it\n                zooKeeper.getData( path, true, null );\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() != KeeperException.Code.NODEEXISTS )\n                {\n                    throw new ZooKeeperException( \"Couldn't set master notify node\", e );\n                }\n            }\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","id":28480,"modified_method":"protected void setDataChangeWatcher( String child, int currentMasterId )\n    {\n        try\n        {\n            String root = getRoot();\n            String path = root + \"/\" + child;\n            byte[] data = null;\n            boolean exists = false;\n            try\n            { \n                data = zooKeeper.getData( path, true, null );\n                exists = true;\n                int id = ByteBuffer.wrap( data ).getInt();\n                if ( currentMasterId == -1 || id == currentMasterId )\n                {\n                    return;\n                }\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() != KeeperException.Code.NONODE )\n                {\n                    throw new ZooKeeperException( \"Couldn't get master notify node\", e );\n                }\n            }\n            \n            // Didn't exist or has changed\n            try\n            {\n                data = new byte[4];\n                ByteBuffer.wrap( data ).putInt( currentMasterId );\n                if ( !exists )\n                {\n                    zooKeeper.create( path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, \n                            CreateMode.PERSISTENT );\n                }\n                else if ( currentMasterId != -1 )\n                {\n                    zooKeeper.setData( path, data, -1 );\n                }\n                System.out.println( child + \" set to \" + currentMasterId );\n                \n                // Add a watch for it\n                zooKeeper.getData( path, true, null );\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() != KeeperException.Code.NODEEXISTS )\n                {\n                    throw new ZooKeeperException( \"Couldn't set master notify node\", e );\n                }\n            }\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","commit_id":"2ce0d1e385dff1d66f7367b0252a591e1816ad04","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ZooKeeperBroker( String storeDir, int machineId, String zooKeeperServers, \n            String haServer, ResponseReceiver receiver )\n    {\n        super( machineId );\n        this.haServer = haServer;\n        NeoStoreUtil store = new NeoStoreUtil( storeDir ); \n        this.zooClient = new ZooClient( zooKeeperServers, machineId, store.getCreationTime(),\n                store.getStoreId(), store.getLastCommittedTx(), receiver, haServer );\n    }","id":28481,"modified_method":"public ZooKeeperBroker( String storeDir, int machineId, String zooKeeperServers, \n            String haServer, ResponseReceiver receiver )\n    {\n        super( machineId );\n        this.machineId = machineId;\n        this.haServer = haServer;\n        NeoStoreUtil store = new NeoStoreUtil( storeDir ); \n        this.zooClient = new ZooClient( zooKeeperServers, machineId, store.getCreationTime(),\n                store.getStoreId(), store.getLastCommittedTx(), receiver, haServer );\n    }","commit_id":"2ce0d1e385dff1d66f7367b0252a591e1816ad04","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Object instantiateMasterServer( GraphDatabaseService graphDb )\n    {\n        return new MasterServer( new MasterImpl( graphDb ),\n                Machine.splitIpAndPort( haServer ).other() );\n    }","id":28482,"modified_method":"public Object instantiateMasterServer( GraphDatabaseService graphDb )\n    {\n        MasterServer server = new MasterServer( new MasterImpl( graphDb ),\n                Machine.splitIpAndPort( haServer ).other() );\n        zooClient.setDataChangeWatcher( ZooClient.MASTER_REBOUND_CHILD, machineId );\n        return server;\n    }","commit_id":"2ce0d1e385dff1d66f7367b0252a591e1816ad04","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void setMasterChangeWatcher( int currentMasterId )\n    {\n        try\n        {\n            String root = getRoot();\n            String path = root + \"/\" + MASTER_NOTIFY_CHILD;\n            byte[] data = null;\n            boolean exists = false;\n            try\n            { \n                data = zooKeeper.getData( path, true, null );\n                exists = true;\n                int id = ByteBuffer.wrap( data ).getInt();\n                if ( id == currentMasterId )\n                {\n                    return;\n                }\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() != KeeperException.Code.NONODE )\n                {\n                    throw new ZooKeeperException( \"Couldn't get master notify node\", e );\n                }\n            }\n            \n            // Didn't exist or has changed\n            try\n            {\n                data = new byte[4];\n                ByteBuffer.wrap( data ).putInt( currentMasterId );\n                if ( !exists )\n                {\n                    zooKeeper.create( path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, \n                            CreateMode.PERSISTENT );\n                }\n                else\n                {\n                    zooKeeper.setData( path, data, -1 );\n                }\n                System.out.println( \"master-notify set to \" + currentMasterId );\n                \n                // Add a watch for it\n                zooKeeper.getData( path, true, null );\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() != KeeperException.Code.NODEEXISTS )\n                {\n                    throw new ZooKeeperException( \"Couldn't set master notify node\", e );\n                }\n            }\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","id":28483,"modified_method":"protected void setDataChangeWatcher( String child, int currentMasterId )\n    {\n        try\n        {\n            String root = getRoot();\n            String path = root + \"/\" + child;\n            byte[] data = null;\n            boolean exists = false;\n            try\n            { \n                data = zooKeeper.getData( path, true, null );\n                exists = true;\n                int id = ByteBuffer.wrap( data ).getInt();\n                if ( currentMasterId == -1 || id == currentMasterId )\n                {\n                    return;\n                }\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() != KeeperException.Code.NONODE )\n                {\n                    throw new ZooKeeperException( \"Couldn't get master notify node\", e );\n                }\n            }\n            \n            // Didn't exist or has changed\n            try\n            {\n                data = new byte[4];\n                ByteBuffer.wrap( data ).putInt( currentMasterId );\n                if ( !exists )\n                {\n                    zooKeeper.create( path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, \n                            CreateMode.PERSISTENT );\n                }\n                else if ( currentMasterId != -1 )\n                {\n                    zooKeeper.setData( path, data, -1 );\n                }\n                System.out.println( child + \" set to \" + currentMasterId );\n                \n                // Add a watch for it\n                zooKeeper.getData( path, true, null );\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() != KeeperException.Code.NODEEXISTS )\n                {\n                    throw new ZooKeeperException( \"Couldn't set master notify node\", e );\n                }\n            }\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            throw new ZooKeeperException( \"Interrupted\", e );\n        }\n    }","commit_id":"b8c615fb1cc775d2063a8eb3f4fa74a2c0ff5b0c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void process( WatchedEvent event )\n    {\n        String path = event.getPath();\n        System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n        if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n        {\n            keeperState = KeeperState.Expired;\n            zooKeeper = instantiateZooKeeper();\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n        {\n            sequenceNr = setup();\n            keeperState = KeeperState.SyncConnected;\n            if ( firstSyncConnected )\n            {\n                firstSyncConnected = false;\n            }\n            else\n            {\n                receiver.somethingIsWrong( new Exception() );\n            }\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n        {\n            keeperState = KeeperState.Disconnected;\n        }\n        else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n        {\n            // If my current master is the same as the master which this master-notify thingie\n            // says, just ignore it.\n//            System.out.println( \"NodeDataChanged (most likely master-notify)\" );\n//            Machine master = getMaster();\n//            if ( master != null && master.getMachineId() == getMasterNotifyId() )\n//            {\n//                System.out.println( \"...but no change, so just chill\" );\n//                return;\n//            }\n            \n            receiver.somethingIsWrong( new Exception() );\n        }\n    }","id":28484,"modified_method":"public void process( WatchedEvent event )\n    {\n        String path = event.getPath();\n        System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n        if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n        {\n            keeperState = KeeperState.Expired;\n            zooKeeper = instantiateZooKeeper();\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n        {\n            sequenceNr = setup();\n            keeperState = KeeperState.SyncConnected;\n            if ( firstSyncConnected )\n            {\n                firstSyncConnected = false;\n            }\n            else\n            {\n                receiver.somethingIsWrong( new Exception() );\n            }\n        }\n        else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n        {\n            keeperState = KeeperState.Disconnected;\n        }\n        else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n        {\n            if ( path.contains( MASTER_NOTIFY_CHILD ) )\n            {\n                if ( super.getMaster().getMachineId() != machineId )\n                {\n                    return;\n                }\n            }\n            else if ( path.contains( MASTER_REBOUND_CHILD ) )\n            {\n                if ( super.getMaster().getMachineId() == machineId )\n                {\n                    return;\n                }\n            }\n            else\n            {\n                System.out.println( \"Unrecognized data change \" + path );\n                return;\n            }\n            receiver.somethingIsWrong( new Exception() );\n        }\n    }","commit_id":"b8c615fb1cc775d2063a8eb3f4fa74a2c0ff5b0c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized Machine getMaster()\n    {\n        Machine result = super.getMaster();\n        if ( result != null )\n        {\n            setMasterChangeWatcher( result.getMachineId() );\n        }\n        return result;\n    }","id":28485,"modified_method":"public synchronized Machine getMaster()\n    {\n        Machine result = super.getMaster();\n        if ( result != null )\n        {\n            setDataChangeWatcher( MASTER_NOTIFY_CHILD, result.getMachineId() );\n            setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n        }\n        return result;\n    }","commit_id":"b8c615fb1cc775d2063a8eb3f4fa74a2c0ff5b0c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Object instantiateMasterServer( GraphDatabaseService graphDb )\n    {\n        return new MasterServer( new MasterImpl( graphDb ),\n                Machine.splitIpAndPort( haServer ).other() );\n    }","id":28486,"modified_method":"public Object instantiateMasterServer( GraphDatabaseService graphDb )\n    {\n        MasterServer server = new MasterServer( new MasterImpl( graphDb ),\n                Machine.splitIpAndPort( haServer ).other() );\n        zooClient.setDataChangeWatcher( ZooClient.MASTER_REBOUND_CHILD, machineId );\n        return server;\n    }","commit_id":"b8c615fb1cc775d2063a8eb3f4fa74a2c0ff5b0c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ZooKeeperBroker( String storeDir, int machineId, String zooKeeperServers, \n            String haServer, ResponseReceiver receiver )\n    {\n        super( machineId );\n        this.haServer = haServer;\n        NeoStoreUtil store = new NeoStoreUtil( storeDir ); \n        this.zooClient = new ZooClient( zooKeeperServers, machineId, store.getCreationTime(),\n                store.getStoreId(), store.getLastCommittedTx(), receiver, haServer );\n    }","id":28487,"modified_method":"public ZooKeeperBroker( String storeDir, int machineId, String zooKeeperServers, \n            String haServer, ResponseReceiver receiver )\n    {\n        super( machineId );\n        this.machineId = machineId;\n        this.haServer = haServer;\n        NeoStoreUtil store = new NeoStoreUtil( storeDir ); \n        this.zooClient = new ZooClient( zooKeeperServers, machineId, store.getCreationTime(),\n                store.getStoreId(), store.getLastCommittedTx(), receiver, haServer );\n    }","commit_id":"b8c615fb1cc775d2063a8eb3f4fa74a2c0ff5b0c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private OFFER_STATUS tryOffer(final BlockOffer offer, final PeerNode pn, final OfferList offers) {\n    \tif(pn == null) return OFFER_STATUS.TRY_ANOTHER;\n    \tif(pn.getBootID() != offer.bootID) return OFFER_STATUS.TRY_ANOTHER;\n    \torigTag.addRoutedTo(pn, true);\n    \tMessage msg = DMT.createFNPGetOfferedKey(key, offer.authenticator, pubKey == null, uid);\n    \tmsg.addSubMessage(DMT.createFNPRealTimeFlag(realTimeFlag));\n    \ttry {\n    \t\tpn.sendSync(msg, this, realTimeFlag);\n\t\t} catch (NotConnectedException e2) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Disconnected: \"+pn+\" getting offer for \"+key);\n    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t} catch (SyncSendWaitedTooLongException e) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Took too long sending offer get to \"+pn+\" for \"+key);\n    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t}\n    \tMessageFilter mfRO = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPRejectedOverload);\n    \tMessageFilter mfGetInvalid = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPGetOfferedKeyInvalid);\n    \t// Wait for a response.\n    \tif(!isSSK) {\n    \t\t// Headers first, then block transfer.\n    \t\tMessageFilter mfDF = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPCHKDataFound);\n    \t\tMessage reply;\n\t\t\ttry {\n\t\t\t\treply = node.usm.waitFor(mfDF.or(mfRO.or(mfGetInvalid)), this);\n\t\t\t} catch (DisconnectedException e2) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Disconnected: \"+pn+\" getting offer for \"+key);\n\t    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t\t}\n    \t\tif(reply == null) {\n    \t\t\t// We gave it a chance, don't give it another.\n    \t\t\tLogger.warning(this, \"Timeout awaiting reply to offer request on \"+this+\" to \"+pn);\n    \t\t\t// Two stage timeout.\n    \t\t\tmfRO = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_LONG_TIMEOUT).setType(DMT.FNPRejectedOverload);\n    \t\t\tmfGetInvalid = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_LONG_TIMEOUT).setType(DMT.FNPGetOfferedKeyInvalid);\n    \t\t\tmfDF = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_LONG_TIMEOUT).setType(DMT.FNPCHKDataFound);\n    \t\t\ttry {\n\t\t\t\t\tnode.usm.addAsyncFilter(mfDF.or(mfRO.or(mfGetInvalid)), new SlowAsyncMessageFilterCallback() {\n\n\t\t\t\t\t\tpublic void onMatched(Message m) {\n\t\t\t\t\t\t\tOFFER_STATUS status = \n\t\t\t\t\t\t\t\thandleCHKOfferReply(m, pn, offer, null);\n\t\t\t\t\t\t\tif(status != OFFER_STATUS.FETCHING)\n\t\t\t\t\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\t\t\t\t// If FETCHING, the block transfer will unlock it.\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Forked get offered key due to two stage timeout completed with status \"+status+\" from message \"+m+\" for \"+RequestSender.this+\" to \"+pn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic boolean shouldTimeout() {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onTimeout() {\n\t\t\t\t\t\t\tLogger.error(this, \"Fatal timeout getting offered key from \"+pn+\" for \"+RequestSender.this);\n\t\t\t\t\t\t\tpn.fatalTimeout(origTag, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onDisconnect(PeerContext ctx) {\n\t\t\t\t\t\t\t// Ok.\n\t\t\t\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onRestarted(PeerContext ctx) {\n\t\t\t\t\t\t\t// Ok.\n\t\t\t\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic int getPriority() {\n\t\t\t\t\t\t\treturn NativeThread.HIGH_PRIORITY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}, this);\n\t\t\t\t\treturn OFFER_STATUS.TWO_STAGE_TIMEOUT;\n\t\t\t\t} catch (DisconnectedException e) {\n\t\t\t\t\t// Okay.\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Disconnected (2): \"+pn+\" getting offer for \"+key);\n\t\t    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t\t\t}\n    \t\t} else {\n    \t\t\treturn handleCHKOfferReply(reply, pn, offer, offers);\n    \t\t}\n    \t} else {\n    \t\t// Data, possibly followed by pubkey\n    \t\tMessageFilter mfAltDF = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPSSKDataFoundHeaders);\n    \t\tMessage reply;\n\t\t\ttry {\n\t\t\t\treply = node.usm.waitFor(mfRO.or(mfGetInvalid.or(mfAltDF)), this);\n\t\t\t} catch (DisconnectedException e) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Disconnected: \"+pn+\" getting offer for \"+key);\n\t\t\t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t\t}\n    \t\tif(reply == null) {\n    \t\t\t// We gave it a chance, don't give it another.\n    \t\t\tLogger.error(this, \"Timeout awaiting reply to offer request on \"+this+\" to \"+pn);\n    \t\t\t// FIXME bug #4613 consider two-stage timeout.\n    \t\t\tpn.fatalTimeout();\n\t\t\t\treturn OFFER_STATUS.TRY_ANOTHER;\n    \t\t} else {\n    \t\t\treturn handleSSKOfferReply(reply, pn, offer, offers);\n    \t\t}\n    \t}\n\t}","id":28488,"modified_method":"private OFFER_STATUS tryOffer(final BlockOffer offer, final PeerNode pn, final OfferList offers) {\n    \tif(pn == null) return OFFER_STATUS.TRY_ANOTHER;\n    \tif(pn.getBootID() != offer.bootID) return OFFER_STATUS.TRY_ANOTHER;\n    \torigTag.addRoutedTo(pn, true);\n    \tMessage msg = DMT.createFNPGetOfferedKey(key, offer.authenticator, pubKey == null, uid);\n    \tmsg.addSubMessage(DMT.createFNPRealTimeFlag(realTimeFlag));\n    \ttry {\n    \t\tpn.sendSync(msg, this, realTimeFlag);\n\t\t} catch (NotConnectedException e2) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Disconnected: \"+pn+\" getting offer for \"+key);\n    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t} catch (SyncSendWaitedTooLongException e) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Took too long sending offer get to \"+pn+\" for \"+key);\n    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t}\n    \tMessageFilter mfRO = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPRejectedOverload);\n    \tMessageFilter mfGetInvalid = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPGetOfferedKeyInvalid);\n    \t// Wait for a response.\n    \tif(!isSSK) {\n    \t\t// Headers first, then block transfer.\n    \t\tMessageFilter mfDF = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPCHKDataFound);\n    \t\tMessage reply;\n\t\t\ttry {\n\t\t\t\treply = node.usm.waitFor(mfDF.or(mfRO.or(mfGetInvalid)), this);\n\t\t\t} catch (DisconnectedException e2) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Disconnected: \"+pn+\" getting offer for \"+key);\n\t    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t\t}\n    \t\tif(reply == null) {\n    \t\t\t// We gave it a chance, don't give it another.\n    \t\t\tLogger.warning(this, \"Timeout awaiting reply to offer request on \"+this+\" to \"+pn);\n    \t\t\t// Two stage timeout.\n    \t\t\tmfRO = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_LONG_TIMEOUT).setType(DMT.FNPRejectedOverload);\n    \t\t\tmfGetInvalid = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_LONG_TIMEOUT).setType(DMT.FNPGetOfferedKeyInvalid);\n    \t\t\tmfDF = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_LONG_TIMEOUT).setType(DMT.FNPCHKDataFound);\n    \t\t\ttry {\n\t\t\t\t\tnode.usm.addAsyncFilter(mfDF.or(mfRO.or(mfGetInvalid)), new SlowAsyncMessageFilterCallback() {\n\n\t\t\t\t\t\tpublic void onMatched(Message m) {\n\t\t\t\t\t\t\tOFFER_STATUS status = \n\t\t\t\t\t\t\t\thandleCHKOfferReply(m, pn, offer, null);\n\t\t\t\t\t\t\tif(status != OFFER_STATUS.FETCHING)\n\t\t\t\t\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\t\t\t\t// If FETCHING, the block transfer will unlock it.\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Forked get offered key due to two stage timeout completed with status \"+status+\" from message \"+m+\" for \"+RequestSender.this+\" to \"+pn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic boolean shouldTimeout() {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onTimeout() {\n\t\t\t\t\t\t\tLogger.error(this, \"Fatal timeout getting offered key from \"+pn+\" for \"+RequestSender.this);\n\t\t\t\t\t\t\tpn.fatalTimeout(origTag, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onDisconnect(PeerContext ctx) {\n\t\t\t\t\t\t\t// Ok.\n\t\t\t\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onRestarted(PeerContext ctx) {\n\t\t\t\t\t\t\t// Ok.\n\t\t\t\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic int getPriority() {\n\t\t\t\t\t\t\treturn NativeThread.HIGH_PRIORITY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}, this);\n\t\t\t\t\treturn OFFER_STATUS.TWO_STAGE_TIMEOUT;\n\t\t\t\t} catch (DisconnectedException e) {\n\t\t\t\t\t// Okay.\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Disconnected (2): \"+pn+\" getting offer for \"+key);\n\t\t    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t\t\t}\n    \t\t} else {\n    \t\t\treturn handleCHKOfferReply(reply, pn, offer, offers);\n    \t\t}\n    \t} else {\n    \t\t// Data, possibly followed by pubkey\n    \t\tMessageFilter mfAltDF = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPSSKDataFoundHeaders);\n    \t\tMessage reply;\n\t\t\ttry {\n\t\t\t\treply = node.usm.waitFor(mfRO.or(mfGetInvalid.or(mfAltDF)), this);\n\t\t\t} catch (DisconnectedException e) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Disconnected: \"+pn+\" getting offer for \"+key);\n\t\t\t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t\t}\n    \t\tif(reply == null) {\n    \t\t\t// We gave it a chance, don't give it another.\n    \t\t\tLogger.warning(this, \"Timeout awaiting reply to offer request on \"+this+\" to \"+pn);\n    \t\t\t// Two stage timeout.\n    \t\t\tmfRO = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_LONG_TIMEOUT).setType(DMT.FNPRejectedOverload);\n    \t\t\tmfGetInvalid = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_LONG_TIMEOUT).setType(DMT.FNPGetOfferedKeyInvalid);\n    \t\t\tmfAltDF = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_LONG_TIMEOUT).setType(DMT.FNPSSKDataFoundHeaders);\n    \t\t\ttry {\n\t\t\t\t\tnode.usm.addAsyncFilter(mfAltDF.or(mfRO.or(mfGetInvalid)), new SlowAsyncMessageFilterCallback() {\n\n\t\t\t\t\t\tpublic void onMatched(Message m) {\n\t\t\t\t\t\t\tOFFER_STATUS status = \n\t\t\t\t\t\t\t\thandleSSKOfferReply(m, pn, offer, null);\n\t\t\t\t\t\t\tif(status != OFFER_STATUS.FETCHING)\n\t\t\t\t\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\t\t\t\t// If FETCHING, the block transfer will unlock it.\n\t\t\t\t\t\t\t// Actually that can't happen here anyway...\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Forked get offered key due to two stage timeout completed with status \"+status+\" from message \"+m+\" for \"+RequestSender.this+\" to \"+pn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic boolean shouldTimeout() {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onTimeout() {\n\t\t\t\t\t\t\tLogger.error(this, \"Fatal timeout getting offered key from \"+pn+\" for \"+RequestSender.this);\n\t\t\t\t\t\t\tpn.fatalTimeout(origTag, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onDisconnect(PeerContext ctx) {\n\t\t\t\t\t\t\t// Ok.\n\t\t\t\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onRestarted(PeerContext ctx) {\n\t\t\t\t\t\t\t// Ok.\n\t\t\t\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic int getPriority() {\n\t\t\t\t\t\t\treturn NativeThread.HIGH_PRIORITY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}, this);\n\t\t\t\t\treturn OFFER_STATUS.TWO_STAGE_TIMEOUT;\n\t\t\t\t} catch (DisconnectedException e) {\n\t\t\t\t\t// Okay.\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Disconnected (2): \"+pn+\" getting offer for \"+key);\n\t\t    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t\t\t}\n    \t\t} else {\n    \t\t\treturn handleSSKOfferReply(reply, pn, offer, offers);\n    \t\t}\n    \t}\n\t}","commit_id":"a6634a94fc4c1d45398beb920decace294592a48","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * <pre>\n     *          DynamicImport-Package ::= dynamic-description\n     *              ( ',' dynamic-description )*\n     *\n     *          dynamic-description::= wildcard-names ( ';' parameter )*\n     *          wildcard-names ::= wildcard-name ( ';' wildcard-name )*\n     *          wildcard-name ::= package-name\n     *                         | ( package-name '.*' ) // See 1.4.2\n     *                         | '*'\n     * <\/pre>\n     */\n    private void verifyDynamicImportPackage() {\n        verifyListHeader(\"DynamicImport-Package\", WILDCARDPACKAGE, true);\n        String dynamicImportPackage = get(\"DynamicImport-Package\");\n        if (dynamicImportPackage == null)\n            return;\n\n        Parameters map = main.getDynamicImportPackage();\n        for (String name : map.keySet()) {\n            name = name.trim();\n            if (!verify(name, WILDCARDPACKAGE))\n                error(\"DynamicImport-Package header contains an invalid package name: \" + name);\n\n            Map<String,String> sub = map.get(name);\n            if (r3 && sub.size() != 0) {\n                error(\"DynamicPackage-Import has attributes on import: \" + name\n                        + \". This is however, an <=R3 bundle and attributes on this header were introduced in R4. \");\n            }\n        }\n    }","id":28489,"modified_method":"/**\n\t * <pre>\n\t *          DynamicImport-Package ::= dynamic-description\n\t *              ( ',' dynamic-description )*\n\t *              \n\t *          dynamic-description::= wildcard-names ( ';' parameter )*\n\t *          wildcard-names ::= wildcard-name ( ';' wildcard-name )*\n\t *          wildcard-name ::= package-name \n\t *                         | ( package-name '.*' ) // See 1.4.2\n\t *                         | '*'\n\t * <\/pre>\n\t */\n\tprivate void verifyDynamicImportPackage() {\n\t\tverifyListHeader(Constants.DYNAMICIMPORT_PACKAGE, WILDCARDPACKAGE, true);\n\t\tString dynamicImportPackage = get(Constants.DYNAMICIMPORT_PACKAGE);\n\t\tif (dynamicImportPackage == null)\n\t\t\treturn;\n\n\t\tParameters map = main.getDynamicImportPackage();\n\t\tfor (String name : map.keySet()) {\n\t\t\tname = name.trim();\n\t\t\tif (!verify(name, WILDCARDPACKAGE))\n\t\t\t\terror(Constants.DYNAMICIMPORT_PACKAGE + \" header contains an invalid package name: \" + name);\n\n\t\t\tMap<String,String> sub = map.get(name);\n\t\t\tif (r3 && sub.size() != 0) {\n\t\t\t\terror(\"DynamicPackage-Import has attributes on import: \" + name\n\t\t\t\t\t\t+ \". This is however, an <=R3 bundle and attributes on this header were introduced in R4. \");\n\t\t\t}\n\t\t}\n\t}","commit_id":"5939d30917cae658ba054d604879ff3e65f916ea","url":"https://github.com/apache/felix"},{"original_method":"public void verify() throws Exception {\n        verifyHeaders();\n        verifyDirectives(\"Export-Package\", \"uses:|mandatory:|include:|exclude:|\" + IMPORT_DIRECTIVE, PACKAGEPATTERN,\n                \"package\");\n        verifyDirectives(\"Import-Package\", \"resolution:\", PACKAGEPATTERN, \"package\");\n        verifyDirectives(\"Require-Bundle\", \"visibility:|resolution:\", SYMBOLICNAME, \"bsn\");\n        verifyDirectives(\"Fragment-Host\", \"extension:\", SYMBOLICNAME, \"bsn\");\n        verifyDirectives(\"Provide-Capability\", \"effective:|uses:\", null, null);\n        verifyDirectives(\"Require-Capability\", \"effective:|resolution:|filter:\", null, null);\n        verifyDirectives(\"Bundle-SymbolicName\", \"singleton:|fragment-attachment:|mandatory:\", SYMBOLICNAME, \"bsn\");\n\n        verifyManifestFirst();\n        verifyActivator();\n        verifyActivationPolicy();\n        verifyComponent();\n        verifyNative();\n        verifyImports();\n        verifyExports();\n        verifyUnresolvedReferences();\n        verifySymbolicName();\n        verifyListHeader(\"Bundle-RequiredExecutionEnvironment\", EENAME, false);\n        verifyHeader(\"Bundle-ManifestVersion\", BUNDLEMANIFESTVERSION, false);\n        verifyHeader(\"Bundle-Version\", VERSION, true);\n        verifyListHeader(\"Bundle-Classpath\", FILE, false);\n        verifyDynamicImportPackage();\n        verifyBundleClasspath();\n        verifyUses();\n        if (usesRequire) {\n            if (!getErrors().isEmpty()) {\n                getWarnings()\n                        .add(0,\n                                \"Bundle uses Require Bundle, this can generate false errors because then not enough information is available without the required bundles\");\n            }\n        }\n\n        verifyRequirements();\n        verifyCapabilities();\n    }","id":28490,"modified_method":"public void verify() throws Exception {\n\t\tverifyHeaders();\n\t\tverifyDirectives(Constants.EXPORT_PACKAGE, \"uses:|mandatory:|include:|exclude:|\" + IMPORT_DIRECTIVE, PACKAGEPATTERN,\n\t\t\t\t\"package\");\n\t\tverifyDirectives(Constants.IMPORT_PACKAGE, \"resolution:\", PACKAGEPATTERN, \"package\");\n\t\tverifyDirectives(Constants.REQUIRE_BUNDLE, \"visibility:|resolution:\", SYMBOLICNAME, \"bsn\");\n\t\tverifyDirectives(Constants.FRAGMENT_HOST, \"extension:\", SYMBOLICNAME, \"bsn\");\n\t\tverifyDirectives(Constants.PROVIDE_CAPABILITY, \"effective:|uses:\", null, null);\n\t\tverifyDirectives(Constants.REQUIRE_CAPABILITY, \"effective:|resolution:|filter:\", null, null);\n\t\tverifyDirectives(Constants.BUNDLE_SYMBOLICNAME, \"singleton:|fragment-attachment:|mandatory:\", SYMBOLICNAME, \"bsn\");\n\n\t\tverifyManifestFirst();\n\t\tverifyActivator();\n\t\tverifyActivationPolicy();\n\t\tverifyComponent();\n\t\tverifyNative();\n\t\tverifyImports();\n\t\tverifyExports();\n\t\tverifyUnresolvedReferences();\n\t\tverifySymbolicName();\n\t\tverifyListHeader(Constants.BUNDLE_REQUIREDEXECUTIONENVIRONMENT, EENAME, false);\n\t\tverifyHeader(Constants.BUNDLE_MANIFESTVERSION, BUNDLEMANIFESTVERSION, false);\n\t\tverifyHeader(Constants.BUNDLE_VERSION, VERSION, true);\n\t\tverifyListHeader(Constants.BUNDLE_CLASSPATH, FILE, false);\n\t\tverifyDynamicImportPackage();\n\t\tverifyBundleClasspath();\n\t\tverifyUses();\n\t\tif (usesRequire) {\n\t\t\tif (!getErrors().isEmpty()) {\n\t\t\t\tgetWarnings()\n\t\t\t\t\t\t.add(0,\n\t\t\t\t\t\t\t\t\"Bundle uses Require Bundle, this can generate false errors because then not enough information is available without the required bundles\");\n\t\t\t}\n\t\t}\n\n\t\tverifyRequirements();\n\t\tverifyCapabilities();\n\t\tverifyMetaPersistence();\n\t\tverifyPathNames();\n\t}","commit_id":"5939d30917cae658ba054d604879ff3e65f916ea","url":"https://github.com/apache/felix"},{"original_method":"public void verifyNative() {\n        String nc = get(\"Bundle-NativeCode\");\n        doNative(nc);\n    }","id":28491,"modified_method":"public void verifyNative() {\n\t\tString nc = get(Constants.BUNDLE_NATIVECODE);\n\t\tdoNative(nc);\n\t}","commit_id":"5939d30917cae658ba054d604879ff3e65f916ea","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Check for unresolved imports. These are referrals that are not imported\n     * by the manifest and that are not part of our bundle class path. The are\n     * calculated by removing all the imported packages and contained from the\n     * referred packages.\n     */\n    private void verifyUnresolvedReferences() {\n        Set<PackageRef> unresolvedReferences = new TreeSet<PackageRef>(analyzer.getReferred().keySet());\n        unresolvedReferences.removeAll(analyzer.getImports().keySet());\n        unresolvedReferences.removeAll(analyzer.getContained().keySet());\n\n        // Remove any java.** packages.\n        for (Iterator<PackageRef> p = unresolvedReferences.iterator(); p.hasNext();) {\n            PackageRef pack = p.next();\n            if (pack.isJava())\n                p.remove();\n            else {\n                // Remove any dynamic imports\n                if (isDynamicImport(pack))\n                    p.remove();\n            }\n        }\n\n        if (!unresolvedReferences.isEmpty()) {\n            // Now we want to know the\n            // classes that are the culprits\n            Set<String> culprits = new HashSet<String>();\n            for (Clazz clazz : analyzer.getClassspace().values()) {\n                if (hasOverlap(unresolvedReferences, clazz.getReferred()))\n                    culprits.add(clazz.getAbsolutePath());\n            }\n\n            error(\"Unresolved references to %s by class(es) %s on the Bundle-Classpath: %s\", unresolvedReferences,\n                    culprits, analyzer.getBundleClasspath().keySet());\n        }\n    }","id":28492,"modified_method":"/**\n\t * Check for unresolved imports. These are referrals that are not imported\n\t * by the manifest and that are not part of our bundle class path. The are\n\t * calculated by removing all the imported packages and contained from the\n\t * referred packages.\n\t * @throws Exception \n\t */\n\tprivate void verifyUnresolvedReferences() throws Exception {\n\n\t\t//\n\t\t// If we're being called from the builder then this should\n\t\t// already have been done\n\t\t//\n\n\t\tif (isFrombuilder())\n\t\t\treturn;\n\n\t\tManifest m = analyzer.getJar().getManifest();\n\t\tif (m == null) {\n\t\t\terror(\"No manifest\");\n\t\t}\n\n\t\tDomain domain = Domain.domain(m);\n\t\t\n\t\tSet<PackageRef> unresolvedReferences = new TreeSet<PackageRef>(analyzer.getReferred().keySet());\n\t\tunresolvedReferences.removeAll(analyzer.getContained().keySet());\n\t\tfor ( String pname : domain.getImportPackage().keySet()) {\n\t\t\tPackageRef pref = analyzer.getPackageRef(pname);\n\t\t\tunresolvedReferences.remove(pref);\n\t\t}\n\n\t\t// Remove any java.** packages.\n\t\tfor (Iterator<PackageRef> p = unresolvedReferences.iterator(); p.hasNext();) {\n\t\t\tPackageRef pack = p.next();\n\t\t\tif (pack.isJava())\n\t\t\t\tp.remove();\n\t\t\telse {\n\t\t\t\t// Remove any dynamic imports\n\t\t\t\tif (isDynamicImport(pack))\n\t\t\t\t\tp.remove();\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// If there is a Require bundle, all bets are off and\n\t\t// we cannot verify anything\n\t\t//\n\n\t\tif (domain.getRequireBundle().isEmpty() && domain.get(\"ExtensionBundle-Activator\") == null\n\t\t\t\t&& (domain.getFragmentHost()== null || domain.getFragmentHost().getKey().equals(\"system.bundle\"))) {\n\n\t\t\tif (!unresolvedReferences.isEmpty()) {\n\t\t\t\t// Now we want to know the\n\t\t\t\t// classes that are the culprits\n\t\t\t\tSet<String> culprits = new HashSet<String>();\n\t\t\t\tfor (Clazz clazz : analyzer.getClassspace().values()) {\n\t\t\t\t\tif (hasOverlap(unresolvedReferences, clazz.getReferred()))\n\t\t\t\t\t\tculprits.add(clazz.getAbsolutePath());\n\t\t\t\t}\n\n\t\t\t\tif (analyzer instanceof Builder)\n\t\t\t\t\twarning(\"Unresolved references to %s by class(es) %s on the \" + Constants.BUNDLE_CLASSPATH + \": %s\",\n\t\t\t\t\t\t\tunresolvedReferences, culprits, analyzer.getBundleClasspath().keySet());\n\t\t\t\telse\n\t\t\t\t\terror(\"Unresolved references to %s by class(es) %s on the \" + Constants.BUNDLE_CLASSPATH + \": %s\",\n\t\t\t\t\t\t\tunresolvedReferences, culprits, analyzer.getBundleClasspath().keySet());\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (isPedantic())\n\t\t\twarning(\"Use of \" + Constants.REQUIRE_BUNDLE + \", ExtensionBundle-Activator, or a system bundle fragment makes it impossible to verify unresolved references\");\n\t}","commit_id":"5939d30917cae658ba054d604879ff3e65f916ea","url":"https://github.com/apache/felix"},{"original_method":"public void verifyBundleClasspath() {\n        Parameters bcp = main.getBundleClassPath();\n        if (bcp.isEmpty() || bcp.containsKey(\".\"))\n            return;\n\n        for (String path : bcp.keySet()) {\n            if (path.endsWith(\"/\"))\n                error(\"A Bundle-ClassPath entry must not end with '/': %s\", path);\n\n            if (dot.getDirectories().containsKey(path))\n                // We assume that any classes are in a directory\n                // and therefore do not care when the bundle is included\n                return;\n        }\n\n        for (String path : dot.getResources().keySet()) {\n            if (path.endsWith(\".class\")) {\n                warning(\"The Bundle-Classpath does not contain the actual bundle JAR (as specified with '.' in the Bundle-Classpath) but the JAR does contain classes. Is this intentional?\");\n                return;\n            }\n        }\n    }","id":28493,"modified_method":"public void verifyBundleClasspath() {\n\t\tParameters bcp = main.getBundleClassPath();\n\t\tif (bcp.isEmpty() || bcp.containsKey(\".\"))\n\t\t\treturn;\n\n\t\tfor (String path : bcp.keySet()) {\n\t\t\tif (path.endsWith(\"/\"))\n\t\t\t\terror(\"A \" + Constants.BUNDLE_CLASSPATH + \" entry must not end with '/': %s\", path);\n\n\t\t\tif (dot.getDirectories().containsKey(path))\n\t\t\t\t// We assume that any classes are in a directory\n\t\t\t\t// and therefore do not care when the bundle is included\n\t\t\t\treturn;\n\t\t}\n\n\t\tfor (String path : dot.getResources().keySet()) {\n\t\t\tif (path.endsWith(\".class\")) {\n\t\t\t\twarning(\"The \" + Constants.BUNDLE_CLASSPATH + \" does not contain the actual bundle JAR (as specified with '.' in the \" + Constants.BUNDLE_CLASSPATH + \") but the JAR does contain classes. Is this intentional?\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}","commit_id":"5939d30917cae658ba054d604879ff3e65f916ea","url":"https://github.com/apache/felix"},{"original_method":"public boolean verifyActivationPolicy(String policy) {\n        Parameters map = parseHeader(policy);\n        if (map.size() == 0)\n            warning(\"Bundle-ActivationPolicy is set but has no argument %s\", policy);\n        else if (map.size() > 1)\n            warning(\"Bundle-ActivationPolicy has too many arguments %s\", policy);\n        else {\n            Map<String,String> s = map.get(\"lazy\");\n            if (s == null)\n                warning(\"Bundle-ActivationPolicy set but is not set to lazy: %s\", policy);\n            else\n                return true;\n        }\n\n        return false;\n    }","id":28494,"modified_method":"public boolean verifyActivationPolicy(String policy) {\n\t\tParameters map = parseHeader(policy);\n\t\tif (map.size() == 0)\n\t\t\twarning(Constants.BUNDLE_ACTIVATIONPOLICY + \" is set but has no argument %s\", policy);\n\t\telse if (map.size() > 1)\n\t\t\twarning(Constants.BUNDLE_ACTIVATIONPOLICY + \" has too many arguments %s\", policy);\n\t\telse {\n\t\t\tMap<String,String> s = map.get(\"lazy\");\n\t\t\tif (s == null)\n\t\t\t\twarning(Constants.BUNDLE_ACTIVATIONPOLICY + \" set but is not set to lazy: %s\", policy);\n\t\t\telse\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"5939d30917cae658ba054d604879ff3e65f916ea","url":"https://github.com/apache/felix"},{"original_method":"private void verifyComponent() {\n        String serviceComponent = main.get(\"Service-Component\");\n        if (serviceComponent != null) {\n            Parameters map = parseHeader(serviceComponent);\n            for (String component : map.keySet()) {\n                if (component.indexOf(\"*\") < 0 && !dot.exists(component)) {\n                    error(\"Service-Component entry can not be located in JAR: \" + component);\n                } else {\n                    // validate component ...\n                }\n            }\n        }\n    }","id":28495,"modified_method":"private void verifyComponent() {\n\t\tString serviceComponent = main.get(Constants.SERVICE_COMPONENT);\n\t\tif (serviceComponent != null) {\n\t\t\tParameters map = parseHeader(serviceComponent);\n\t\t\tfor (String component : map.keySet()) {\n\t\t\t\tif (component.indexOf(\"*\") < 0 && !dot.exists(component)) {\n\t\t\t\t\terror(Constants.SERVICE_COMPONENT + \" entry can not be located in JAR: \" + component);\n\t\t\t\t} else {\n\t\t\t\t\t// validate component ...\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"5939d30917cae658ba054d604879ff3e65f916ea","url":"https://github.com/apache/felix"},{"original_method":"private void verifyActivator() throws Exception {\n        String bactivator = main.get(\"Bundle-Activator\");\n        if (bactivator != null) {\n            TypeRef ref = analyzer.getTypeRefFromFQN(bactivator);\n            if (analyzer.getClassspace().containsKey(ref))\n                return;\n\n            PackageRef packageRef = ref.getPackageRef();\n            if (packageRef.isDefaultPackage())\n                error(\"The Bundle Activator is not in the bundle and it is in the default package \");\n            else if (!analyzer.isImported(packageRef)) {\n                error(\"Bundle-Activator not found on the bundle class path nor in imports: \" + bactivator);\n            }\n        }\n    }","id":28496,"modified_method":"private void verifyActivator() throws Exception {\n\t\tString bactivator = main.get(Constants.BUNDLE_ACTIVATOR);\n\t\tif (bactivator != null) {\n\t\t\tTypeRef ref = analyzer.getTypeRefFromFQN(bactivator);\n\t\t\tif (analyzer.getClassspace().containsKey(ref))\n\t\t\t\treturn;\n\n\t\t\tPackageRef packageRef = ref.getPackageRef();\n\t\t\tif (packageRef.isDefaultPackage())\n\t\t\t\terror(\"The Bundle Activator is not in the bundle and it is in the default package \");\n\t\t\telse if (!analyzer.isImported(packageRef)) {\n\t\t\t\terror(Constants.BUNDLE_ACTIVATOR + \" not found on the bundle class path nor in imports: \" + bactivator);\n\t\t\t}\n\t\t}\n\t}","commit_id":"5939d30917cae658ba054d604879ff3e65f916ea","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @param p\n     * @param pack\n     */\n    private boolean isDynamicImport(PackageRef pack) {\n        if (dynamicImports == null)\n            dynamicImports = new Instructions(main.getDynamicImportPackage());\n\n        return dynamicImports.matches(pack.getFQN());\n    }","id":28497,"modified_method":"/**\n\t * @param p\n\t * @param pack\n\t */\n\tprivate boolean isDynamicImport(PackageRef pack) {\n\t\tif (dynamicImports == null)\n\t\t\tdynamicImports = new Instructions(main.getDynamicImportPackage());\n\n\t\tif (dynamicImports.isEmpty())\n\t\t\treturn false;\n\n\t\treturn dynamicImports.matches(pack.getFQN());\n\t}","commit_id":"5939d30917cae658ba054d604879ff3e65f916ea","url":"https://github.com/apache/felix"},{"original_method":"/** @return True if we successfully received the offer or failed fatally, or we started\n\t * to receive a block transfer asynchronously (in which case receivingAsync will be set,\n\t * and if it fails the whole request will fail). False if we should try the next offer \n\t * and/or normal fetches. */\n\tprivate OFFER_STATUS handleCHKOfferReply(Message reply, PeerNode pn, final BlockOffer offer, final OfferList offers) {\n\t\tif(reply.getSpec() == DMT.FNPRejectedOverload) {\n\t\t\t// Non-fatal, keep it.\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Node \"+pn+\" rejected FNPGetOfferedKey for \"+key+\" (expired=\"+offer.isExpired());\n\t\t\treturn OFFER_STATUS.KEEP;\n\t\t} else if(reply.getSpec() == DMT.FNPGetOfferedKeyInvalid) {\n\t\t\t// Fatal, delete it.\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Node \"+pn+\" rejected FNPGetOfferedKey as invalid with reason \"+reply.getShort(DMT.REASON));\n\t\t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t} else if(reply.getSpec() == DMT.FNPCHKDataFound) {\n\t\t\tfinalHeaders = ((ShortBuffer)reply.getObject(DMT.BLOCK_HEADERS)).getData();\n\t\t\t// Receive the data\n\t\t\t\n        \t// FIXME: Validate headers\n        \t\n        \tnode.addTransferringSender((NodeCHK)key, this);\n        \t\n        \ttry {\n        \t\t\n        \t\tprb = new PartiallyReceivedBlock(Node.PACKETS_IN_BLOCK, Node.PACKET_SIZE);\n        \t\t\n        \t\tsynchronized(this) {\n        \t\t\tnotifyAll();\n        \t\t}\n        \t\tfireCHKTransferBegins();\n\t\t\t\t\n        \t\tBlockReceiver br = new BlockReceiver(node.usm, pn, uid, prb, this, node.getTicker(), true, realTimeFlag, myTimeoutHandler);\n        \t\t\n       \t\t\tif(logMINOR) Logger.minor(this, \"Receiving data\");\n       \t\t\tfinal PeerNode p = pn;\n       \t\t\treceivingAsync = true;\n       \t\t\tbr.receive(new BlockReceiverCompletion() {\n       \t\t\t\t\n\t\t\t\t\tpublic void blockReceived(byte[] data) {\n        \t\t\t\tsynchronized(RequestSender.this) {\n        \t\t\t\t\ttransferringFrom = null;\n        \t\t\t\t}\n        \t\t\t\tnode.removeTransferringSender((NodeCHK)key, RequestSender.this);\n                \t\ttry {\n\t                \t\t// Received data\n\t               \t\t\tp.transferSuccess(realTimeFlag);\n\t                \t\tif(logMINOR) Logger.minor(this, \"Received data\");\n                \t\t\tverifyAndCommit(finalHeaders, data);\n\t                \t\tfinish(SUCCESS, p, true);\n\t                \t\tnode.nodeStats.successfulBlockReceive(realTimeFlag, source == null);\n                \t\t} catch (KeyVerifyException e1) {\n                \t\t\tLogger.normal(this, \"Got data but verify failed: \"+e1, e1);\n                \t\t\tfinish(GET_OFFER_VERIFY_FAILURE, p, true);\n                       \t\toffers.deleteLastOffer();\n                \t\t} catch (Throwable t) {\n                \t\t\tLogger.error(this, \"Failed on \"+this, t);\n                \t\t\tfinish(INTERNAL_ERROR, p, true);\n                \t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic void blockReceiveFailed(\n\t\t\t\t\t\t\tRetrievalException e) {\n        \t\t\t\tsynchronized(RequestSender.this) {\n        \t\t\t\t\ttransferringFrom = null;\n        \t\t\t\t}\n        \t\t\t\tnode.removeTransferringSender((NodeCHK)key, RequestSender.this);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (e.getReason()==RetrievalException.SENDER_DISCONNECTED)\n\t\t\t\t\t\t\t\tLogger.normal(this, \"Transfer failed (disconnect): \"+e, e);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t// A certain number of these are normal, it's better to track them through statistics than call attention to them in the logs.\n\t\t\t\t\t\t\t\tLogger.normal(this, \"Transfer for offer failed (\"+e.getReason()+\"/\"+RetrievalException.getErrString(e.getReason())+\"): \"+e+\" from \"+p, e);\n\t\t\t\t\t\t\tfinish(GET_OFFER_TRANSFER_FAILED, p, true);\n\t\t\t\t\t\t\t// Backoff here anyway - the node really ought to have it!\n\t\t\t\t\t\t\tp.transferFailed(\"RequestSenderGetOfferedTransferFailed\", realTimeFlag);\n\t\t\t\t\t\t\toffers.deleteLastOffer();\n\t\t    \t\t\t\tif(!prb.abortedLocally())\n\t\t    \t\t\t\t\tnode.nodeStats.failedBlockReceive(false, false, realTimeFlag, source == null);\n                \t\t} catch (Throwable t) {\n                \t\t\tLogger.error(this, \"Failed on \"+this, t);\n                \t\t\tfinish(INTERNAL_ERROR, p, true);\n                \t\t}\n\t\t\t\t\t}\n        \t\t\t\t\n        \t\t});\n        \t\treturn OFFER_STATUS.FETCHING;\n        \t} finally {\n        \t\tnode.removeTransferringSender((NodeCHK)key, this);\n        \t}\n\t\t} else {\n\t\t\t// Impossible.\n\t\t\tLogger.error(this, \"Unexpected reply to get offered key: \"+reply);\n\t\t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t}\n\t}","id":28498,"modified_method":"/** @return True if we successfully received the offer or failed fatally, or we started\n\t * to receive a block transfer asynchronously (in which case receivingAsync will be set,\n\t * and if it fails the whole request will fail). False if we should try the next offer \n\t * and/or normal fetches.\n\t * @param offers The list of offered keys. Only used if we complete asynchronously.\n\t * Null indicates this is a fork due to two stage timeout. \n\t * */\n\tprivate OFFER_STATUS handleCHKOfferReply(Message reply, final PeerNode pn, final BlockOffer offer, final OfferList offers) {\n\t\tif(reply.getSpec() == DMT.FNPRejectedOverload) {\n\t\t\t// Non-fatal, keep it.\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Node \"+pn+\" rejected FNPGetOfferedKey for \"+key+\" (expired=\"+offer.isExpired());\n\t\t\treturn OFFER_STATUS.KEEP;\n\t\t} else if(reply.getSpec() == DMT.FNPGetOfferedKeyInvalid) {\n\t\t\t// Fatal, delete it.\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Node \"+pn+\" rejected FNPGetOfferedKey as invalid with reason \"+reply.getShort(DMT.REASON));\n\t\t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t} else if(reply.getSpec() == DMT.FNPCHKDataFound) {\n\t\t\tfinalHeaders = ((ShortBuffer)reply.getObject(DMT.BLOCK_HEADERS)).getData();\n\t\t\t// Receive the data\n\t\t\t\n        \t// FIXME: Validate headers\n        \t\n        \tnode.addTransferringSender((NodeCHK)key, this);\n        \t\n        \ttry {\n        \t\t\n        \t\tprb = new PartiallyReceivedBlock(Node.PACKETS_IN_BLOCK, Node.PACKET_SIZE);\n        \t\t\n        \t\tsynchronized(this) {\n        \t\t\tnotifyAll();\n        \t\t}\n        \t\tfireCHKTransferBegins();\n\t\t\t\t\n        \t\tBlockReceiver br = new BlockReceiver(node.usm, pn, uid, prb, this, node.getTicker(), true, realTimeFlag, myTimeoutHandler);\n        \t\t\n       \t\t\tif(logMINOR) Logger.minor(this, \"Receiving data\");\n       \t\t\tfinal PeerNode p = pn;\n       \t\t\treceivingAsync = true;\n       \t\t\tbr.receive(new BlockReceiverCompletion() {\n       \t\t\t\t\n\t\t\t\t\tpublic void blockReceived(byte[] data) {\n        \t\t\t\tsynchronized(RequestSender.this) {\n        \t\t\t\t\ttransferringFrom = null;\n        \t\t\t\t}\n        \t\t\t\tnode.removeTransferringSender((NodeCHK)key, RequestSender.this);\n                \t\ttry {\n\t                \t\t// Received data\n\t               \t\t\tp.transferSuccess(realTimeFlag);\n\t                \t\tif(logMINOR) Logger.minor(this, \"Received data\");\n                \t\t\tverifyAndCommit(finalHeaders, data);\n\t                \t\tfinish(SUCCESS, p, true);\n\t                \t\tnode.nodeStats.successfulBlockReceive(realTimeFlag, source == null);\n                \t\t} catch (KeyVerifyException e1) {\n                \t\t\tLogger.normal(this, \"Got data but verify failed: \"+e1, e1);\n                \t\t\tif(offers != null) {\n                \t\t\t\tfinish(GET_OFFER_VERIFY_FAILURE, p, true);\n                \t\t\t\toffers.deleteLastOffer();\n                \t\t\t}\n                \t\t} catch (Throwable t) {\n                \t\t\tLogger.error(this, \"Failed on \"+this, t);\n                \t\t\tif(offers != null) {\n                \t\t\t\tfinish(INTERNAL_ERROR, p, true);\n                \t\t\t}\n                \t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic void blockReceiveFailed(\n\t\t\t\t\t\t\tRetrievalException e) {\n        \t\t\t\tsynchronized(RequestSender.this) {\n        \t\t\t\t\ttransferringFrom = null;\n        \t\t\t\t}\n        \t\t\t\tnode.removeTransferringSender((NodeCHK)key, RequestSender.this);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (e.getReason()==RetrievalException.SENDER_DISCONNECTED)\n\t\t\t\t\t\t\t\tLogger.normal(this, \"Transfer failed (disconnect): \"+e, e);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t// A certain number of these are normal, it's better to track them through statistics than call attention to them in the logs.\n\t\t\t\t\t\t\t\tLogger.normal(this, \"Transfer for offer failed (\"+e.getReason()+\"/\"+RetrievalException.getErrString(e.getReason())+\"): \"+e+\" from \"+p, e);\n\t\t\t\t\t\t\tif(offers != null) {\n\t\t\t\t\t\t\t\tfinish(GET_OFFER_TRANSFER_FAILED, p, true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Backoff here anyway - the node really ought to have it!\n\t\t\t\t\t\t\tp.transferFailed(\"RequestSenderGetOfferedTransferFailed\", realTimeFlag);\n\t\t\t\t\t\t\tif(offers != null) {\n\t\t\t\t\t\t\t\toffers.deleteLastOffer();\n\t\t\t\t\t\t\t}\n\t\t    \t\t\t\tif(!prb.abortedLocally())\n\t\t    \t\t\t\t\tnode.nodeStats.failedBlockReceive(false, false, realTimeFlag, source == null);\n                \t\t} catch (Throwable t) {\n                \t\t\tLogger.error(this, \"Failed on \"+this, t);\n                \t\t\tfinish(INTERNAL_ERROR, p, true);\n                \t\t}\n\t\t\t\t\t}\n        \t\t\t\t\n        \t\t});\n        \t\treturn OFFER_STATUS.FETCHING;\n        \t} finally {\n        \t\tnode.removeTransferringSender((NodeCHK)key, this);\n        \t}\n\t\t} else {\n\t\t\t// Impossible.\n\t\t\tLogger.error(this, \"Unexpected reply to get offered key: \"+reply);\n\t\t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t}\n\t}","commit_id":"661bafbf251089f9c8b613a9e25aaae8e8c459a7","url":"https://github.com/freenet/fred"},{"original_method":"private OFFER_STATUS tryOffer(BlockOffer offer, PeerNode pn, final OfferList offers) {\n    \tif(pn == null) return OFFER_STATUS.TRY_ANOTHER;\n    \tif(pn.getBootID() != offer.bootID) return OFFER_STATUS.TRY_ANOTHER;\n    \torigTag.addRoutedTo(pn, true);\n    \tMessage msg = DMT.createFNPGetOfferedKey(key, offer.authenticator, pubKey == null, uid);\n    \tmsg.addSubMessage(DMT.createFNPRealTimeFlag(realTimeFlag));\n    \ttry {\n    \t\tpn.sendSync(msg, this, realTimeFlag);\n\t\t} catch (NotConnectedException e2) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Disconnected: \"+pn+\" getting offer for \"+key);\n    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t} catch (SyncSendWaitedTooLongException e) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Took too long sending offer get to \"+pn+\" for \"+key);\n    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t}\n    \tMessageFilter mfRO = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPRejectedOverload);\n    \tMessageFilter mfGetInvalid = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPGetOfferedKeyInvalid);\n    \t// Wait for a response.\n    \tif(!isSSK) {\n    \t\t// Headers first, then block transfer.\n    \t\tMessageFilter mfDF = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPCHKDataFound);\n    \t\tMessage reply;\n\t\t\ttry {\n\t\t\t\treply = node.usm.waitFor(mfDF.or(mfRO.or(mfGetInvalid)), this);\n\t\t\t} catch (DisconnectedException e2) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Disconnected: \"+pn+\" getting offer for \"+key);\n\t    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t\t}\n    \t\tif(reply == null) {\n    \t\t\t// We gave it a chance, don't give it another.\n    \t\t\tLogger.error(this, \"Timeout awaiting reply to offer request on \"+this+\" to \"+pn);\n    \t\t\t// FIXME bug #4613 consider two-stage timeout.\n    \t\t\tpn.fatalTimeout(origTag, true);\n        \t\treturn OFFER_STATUS.TRY_ANOTHER;\n    \t\t} else {\n    \t\t\treturn handleCHKOfferReply(reply, pn, offer, offers);\n    \t\t}\n    \t} else {\n    \t\t// Data, possibly followed by pubkey\n    \t\tMessageFilter mfAltDF = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPSSKDataFoundHeaders);\n    \t\tMessage reply;\n\t\t\ttry {\n\t\t\t\treply = node.usm.waitFor(mfRO.or(mfGetInvalid.or(mfAltDF)), this);\n\t\t\t} catch (DisconnectedException e) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Disconnected: \"+pn+\" getting offer for \"+key);\n\t\t\t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t\t}\n    \t\tif(reply == null) {\n    \t\t\t// We gave it a chance, don't give it another.\n    \t\t\tLogger.error(this, \"Timeout awaiting reply to offer request on \"+this+\" to \"+pn);\n    \t\t\t// FIXME bug #4613 consider two-stage timeout.\n    \t\t\tpn.fatalTimeout();\n\t\t\t\treturn OFFER_STATUS.TRY_ANOTHER;\n    \t\t} else {\n    \t\t\treturn handleSSKOfferReply(reply, pn, offer, offers);\n    \t\t}\n    \t}\n\t}","id":28499,"modified_method":"private OFFER_STATUS tryOffer(final BlockOffer offer, final PeerNode pn, final OfferList offers) {\n    \tif(pn == null) return OFFER_STATUS.TRY_ANOTHER;\n    \tif(pn.getBootID() != offer.bootID) return OFFER_STATUS.TRY_ANOTHER;\n    \torigTag.addRoutedTo(pn, true);\n    \tMessage msg = DMT.createFNPGetOfferedKey(key, offer.authenticator, pubKey == null, uid);\n    \tmsg.addSubMessage(DMT.createFNPRealTimeFlag(realTimeFlag));\n    \ttry {\n    \t\tpn.sendSync(msg, this, realTimeFlag);\n\t\t} catch (NotConnectedException e2) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Disconnected: \"+pn+\" getting offer for \"+key);\n    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t} catch (SyncSendWaitedTooLongException e) {\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Took too long sending offer get to \"+pn+\" for \"+key);\n    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t}\n    \tMessageFilter mfRO = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPRejectedOverload);\n    \tMessageFilter mfGetInvalid = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPGetOfferedKeyInvalid);\n    \t// Wait for a response.\n    \tif(!isSSK) {\n    \t\t// Headers first, then block transfer.\n    \t\tMessageFilter mfDF = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPCHKDataFound);\n    \t\tMessage reply;\n\t\t\ttry {\n\t\t\t\treply = node.usm.waitFor(mfDF.or(mfRO.or(mfGetInvalid)), this);\n\t\t\t} catch (DisconnectedException e2) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Disconnected: \"+pn+\" getting offer for \"+key);\n\t    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t\t}\n    \t\tif(reply == null) {\n    \t\t\t// We gave it a chance, don't give it another.\n    \t\t\tLogger.warning(this, \"Timeout awaiting reply to offer request on \"+this+\" to \"+pn);\n    \t\t\t// Two stage timeout.\n    \t\t\tmfRO = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_LONG_TIMEOUT).setType(DMT.FNPRejectedOverload);\n    \t\t\tmfGetInvalid = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_LONG_TIMEOUT).setType(DMT.FNPGetOfferedKeyInvalid);\n    \t\t\tmfDF = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_LONG_TIMEOUT).setType(DMT.FNPCHKDataFound);\n    \t\t\ttry {\n\t\t\t\t\tnode.usm.addAsyncFilter(mfDF.or(mfRO.or(mfGetInvalid)), new SlowAsyncMessageFilterCallback() {\n\n\t\t\t\t\t\tpublic void onMatched(Message m) {\n\t\t\t\t\t\t\tOFFER_STATUS status = \n\t\t\t\t\t\t\t\thandleCHKOfferReply(m, pn, offer, null);\n\t\t\t\t\t\t\tif(status != OFFER_STATUS.FETCHING)\n\t\t\t\t\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\t\t\t\t// If FETCHING, the block transfer will unlock it.\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Forked get offered key due to two stage timeout completed with status \"+status+\" from message \"+m+\" for \"+RequestSender.this+\" to \"+pn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic boolean shouldTimeout() {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onTimeout() {\n\t\t\t\t\t\t\tLogger.error(this, \"Fatal timeout getting offered key from \"+pn+\" for \"+RequestSender.this);\n\t\t\t\t\t\t\tpn.fatalTimeout(origTag, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onDisconnect(PeerContext ctx) {\n\t\t\t\t\t\t\t// Ok.\n\t\t\t\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onRestarted(PeerContext ctx) {\n\t\t\t\t\t\t\t// Ok.\n\t\t\t\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic int getPriority() {\n\t\t\t\t\t\t\treturn NativeThread.HIGH_PRIORITY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}, this);\n\t\t\t\t\treturn OFFER_STATUS.TWO_STAGE_TIMEOUT;\n\t\t\t\t} catch (DisconnectedException e) {\n\t\t\t\t\t// Okay.\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Disconnected (2): \"+pn+\" getting offer for \"+key);\n\t\t    \t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t\t\t}\n    \t\t} else {\n    \t\t\treturn handleCHKOfferReply(reply, pn, offer, offers);\n    \t\t}\n    \t} else {\n    \t\t// Data, possibly followed by pubkey\n    \t\tMessageFilter mfAltDF = MessageFilter.create().setSource(pn).setField(DMT.UID, uid).setTimeout(GET_OFFER_TIMEOUT).setType(DMT.FNPSSKDataFoundHeaders);\n    \t\tMessage reply;\n\t\t\ttry {\n\t\t\t\treply = node.usm.waitFor(mfRO.or(mfGetInvalid.or(mfAltDF)), this);\n\t\t\t} catch (DisconnectedException e) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Disconnected: \"+pn+\" getting offer for \"+key);\n\t\t\t\treturn OFFER_STATUS.TRY_ANOTHER;\n\t\t\t}\n    \t\tif(reply == null) {\n    \t\t\t// We gave it a chance, don't give it another.\n    \t\t\tLogger.error(this, \"Timeout awaiting reply to offer request on \"+this+\" to \"+pn);\n    \t\t\t// FIXME bug #4613 consider two-stage timeout.\n    \t\t\tpn.fatalTimeout();\n\t\t\t\treturn OFFER_STATUS.TRY_ANOTHER;\n    \t\t} else {\n    \t\t\treturn handleSSKOfferReply(reply, pn, offer, offers);\n    \t\t}\n    \t}\n\t}","commit_id":"661bafbf251089f9c8b613a9e25aaae8e8c459a7","url":"https://github.com/freenet/fred"},{"original_method":"/** @return True if we successfully fetched an offered key or failed fatally, or if\n\t * we have started an asynchronous transfer, in which case we have set receivingAsync \n\t * and the request will fail if the transfer fails. False if we should proceed to a \n\t * normal fetch. */\n    private boolean tryOffers(final OfferList offers) {\n    \t\n        while(true) {\n        \t// Fetches valid offers, then expired ones. Expired offers don't count towards failures,\n        \t// but they're still worth trying.\n        \tBlockOffer offer = offers.getFirstOffer();\n        \tif(offer == null) {\n        \t\tif(logMINOR) Logger.minor(this, \"No more offers\");\n        \t\tbreak;\n        \t}\n        \tPeerNode pn = offer.getPeerNode();\n        \tOFFER_STATUS status = tryOffer(offer, pn, offers);\n\t\t\tswitch(status) {\n\t\t\tcase FATAL:\n\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\treturn true;\n\t\t\tcase FETCHING:\n\t\t\t\treturn true;\n\t\t\tcase KEEP:\n\t\t\t\toffers.keepLastOffer();\n\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\tcontinue;\n\t\t\tcase TRY_ANOTHER:\n\t\t\t\toffers.deleteLastOffer();\n\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\tcontinue;\n\t\t\t}\n        }\n        return false;\n    }","id":28500,"modified_method":"/** @return True if we successfully fetched an offered key or failed fatally, or if\n\t * we have started an asynchronous transfer, in which case we have set receivingAsync \n\t * and the request will fail if the transfer fails. False if we should proceed to a \n\t * normal fetch. */\n    private boolean tryOffers(final OfferList offers) {\n    \t\n        while(true) {\n        \t// Fetches valid offers, then expired ones. Expired offers don't count towards failures,\n        \t// but they're still worth trying.\n        \tBlockOffer offer = offers.getFirstOffer();\n        \tif(offer == null) {\n        \t\tif(logMINOR) Logger.minor(this, \"No more offers\");\n        \t\tbreak;\n        \t}\n        \tPeerNode pn = offer.getPeerNode();\n        \tOFFER_STATUS status = tryOffer(offer, pn, offers);\n\t\t\tswitch(status) {\n\t\t\tcase FATAL:\n\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\treturn true;\n\t\t\tcase TWO_STAGE_TIMEOUT:\n\t\t\t\toffers.deleteLastOffer();\n\t\t\t\tcontinue;\n\t\t\tcase FETCHING:\n\t\t\t\treturn true;\n\t\t\tcase KEEP:\n\t\t\t\toffers.keepLastOffer();\n\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\tcontinue;\n\t\t\tcase TRY_ANOTHER:\n\t\t\t\toffers.deleteLastOffer();\n\t\t\t\torigTag.removeFetchingOfferedKeyFrom(pn);\n\t\t\t\tcontinue;\n\t\t\t}\n        }\n        return false;\n    }","commit_id":"661bafbf251089f9c8b613a9e25aaae8e8c459a7","url":"https://github.com/freenet/fred"},{"original_method":"private jetbrains.mps.plugin.CompilationResult compile(Set<IModule> modules) {\n    boolean hasAnythingToCompile = false;\n\n    for (IModule m : modules) {\n      if (m.isCompileInMPS()) {\n        hasAnythingToCompile = true;\n      }\n    }\n\n    if (!hasAnythingToCompile) {\n      return new jetbrains.mps.plugin.CompilationResult(0, 0, false);\n    }\n\n    IClassPathItem classPathItems = computeDependenciesClassPath(modules);\n    JavaCompiler compiler = new JavaCompiler(classPathItems);\n\n    for (IModule m : modules) {\n      if (areClassesUpToDate(m)) {\n        continue;\n      }\n\n      if (!m.isCompileInMPS()) {\n        LOG.warning(\"Module which compiled in IDEA depend on module which has to be compiled in MPS:\" + m.getModuleFqName(), m);\n        continue;\n      }\n\n      ModuleSources sources = getModuleSources(m);\n\n      for (IFile f : sources.getFilesToDelete()) {\n        f.delete();\n      }\n\n      for (JavaFile f : sources.getFilesToCompile()) {\n        compiler.addSource(f.getClassName(), f.getContents());\n        myContainingModules.put(f.getClassName(), m);\n      }\n    }\n\n    compiler.compile();\n\n    int errorCount = 0;\n    int outputtedErrors = 0;\n\n    for (CompilationResult cr : compiler.getCompilationResults()) {\n      Set<String> classesWithErrors = new HashSet<String>();\n      if (cr.getErrors() != null) {\n        for (CategorizedProblem cp : cr.getErrors()) {\n          String fileName = new String(cp.getOriginatingFileName());\n          String fqName = fileName.substring(0, fileName.length() - MPSExtentions.DOT_JAVAFILE.length()).replace(File.separatorChar, '.');\n          classesWithErrors.add(fqName);\n\n          IModule containingModule = myContainingModules.get(fqName);\n          assert containingModule != null;\n          JavaFile javaFile = myModuleSources.get(containingModule).getJavaFile(fqName);\n\n          String messageStirng = new String(cp.getOriginatingFileName()) + \" : \" + cp.getMessage();\n          if (cp.isWarning()) {\n            LOG.warning(messageStirng + \" (line: \" + cp.getSourceLineNumber() + \")\", new FileWithPosition(javaFile.getFile(), cp.getSourceStart()));\n          } else {\n            if (outputtedErrors < MAX_ERRORS) {\n              outputtedErrors++;\n              LOG.error(messageStirng + \" (line: \" + cp.getSourceLineNumber() + \")\", new FileWithPosition(javaFile.getFile(), cp.getSourceStart()));\n            }\n          }\n        }\n\n        errorCount += cr.getErrors().length;\n      }\n\n      for (ClassFile cf : cr.getClassFiles()) {\n        String fqName = getName(cf.getCompoundName());\n        String containerClassName = fqName;\n        if (containerClassName.contains(\"$\")) {\n          int index = containerClassName.indexOf('$');\n          containerClassName = containerClassName.substring(0, index);\n        }\n        if (myContainingModules.containsKey(containerClassName)) {\n          IModule m = myContainingModules.get(containerClassName);\n          File classesGen = m.getClassesGen().toFile();\n          String packageName = NameUtil.namespaceFromLongName(fqName);\n          File outputDir = new File(classesGen + File.separator + packageName.replace('.', File.separatorChar));\n          if (!outputDir.exists()) {\n            if (!outputDir.mkdirs()) {\n              throw new RuntimeException(\"Can't create \" + outputDir.getPath() + \" directory\");\n            }\n          }\n          String className = NameUtil.shortNameFromLongName(fqName);\n          File output = new File(outputDir, className + \".class\");\n          if (!classesWithErrors.contains(fqName)) {\n            try {\n              FileOutputStream os = new FileOutputStream(output);\n              os.write(cf.getBytes());\n              os.close();\n            } catch (IOException e) {\n              LOG.error(\"Can't write to \" + output.getAbsolutePath());\n            }\n          } else {\n            if (output.exists() && !(output.delete())) {\n              LOG.error(\"Can't delete \" + output.getPath());\n            }\n          }\n        } else {\n          LOG.error(\"I don't know in which module's output path I should place class file for \" + fqName);\n        }\n      }\n    }\n\n    for (IModule module : modules) {\n      ModuleSources sources = getModuleSources(module);\n      for (ResourceFile toCopy : sources.getResourcesToCopy()) {\n        String fqName = toCopy.getPath();\n\n        fqName = fqName.substring(0, fqName.length() - toCopy.getFile().getName().length());\n        String path = fqName.replace('/', File.separatorChar) + toCopy.getFile().getName();\n\n        FileUtil.copyFile(\n          toCopy.getFile().toFile(),\n          module.getClassesGen().child(path).toFile()\n        );\n      }\n    }\n\n    for (IModule module : modules) {\n      module.updateClassPath();\n    }\n\n    return new jetbrains.mps.plugin.CompilationResult(errorCount, 0, false);\n  }","id":28501,"modified_method":"private jetbrains.mps.plugin.CompilationResult compile(Set<IModule> modules) {\n    boolean hasAnythingToCompile = false;\n\n    for (IModule m : modules) {\n      if (m.isCompileInMPS()) {\n        hasAnythingToCompile = true;\n      }\n    }\n\n    if (!hasAnythingToCompile) {\n      return new jetbrains.mps.plugin.CompilationResult(0, 0, false);\n    }\n\n    IClassPathItem classPathItems = computeDependenciesClassPath(modules);\n    JavaCompiler compiler = new JavaCompiler(classPathItems);\n\n    for (IModule m : modules) {\n      if (areClassesUpToDate(m)) {\n        continue;\n      }\n\n      if (!m.isCompileInMPS()) {\n        LOG.warning(\"Module which compiled in IDEA depend on module which has to be compiled in MPS:\" + m.getModuleFqName(), m);\n        continue;\n      }\n\n      ModuleSources sources = getModuleSources(m);\n\n      for (IFile f : sources.getFilesToDelete()) {\n        f.delete();\n      }\n\n      for (JavaFile f : sources.getFilesToCompile()) {\n        compiler.addSource(f.getClassName(), f.getContents());\n        myContainingModules.put(f.getClassName(), m);\n      }\n    }\n\n    compiler.compile();\n\n    int errorCount = 0;\n    int outputtedErrors = 0;\n\n    for (CompilationResult cr : compiler.getCompilationResults()) {\n      Set<String> classesWithErrors = new HashSet<String>();\n      if (cr.getErrors() != null) {\n        for (final CategorizedProblem cp : cr.getErrors()) {\n          String fileName = new String(cp.getOriginatingFileName());\n          final String fqName = fileName.substring(0, fileName.length() - MPSExtentions.DOT_JAVAFILE.length()).replace(File.separatorChar, '.');\n          classesWithErrors.add(fqName);\n\n          IModule containingModule = myContainingModules.get(fqName);\n          assert containingModule != null;\n          JavaFile javaFile = myModuleSources.get(containingModule).getJavaFile(fqName);\n\n          String messageStirng = new String(cp.getOriginatingFileName()) + \" : \" + cp.getMessage();\n\n          final SNode nodeToShow = getNodeByLine(cp, fqName);\n\n          if (cp.isWarning()) {\n            Object hintObject = nodeToShow;\n            if (hintObject == null) {\n              hintObject = new FileWithPosition(javaFile.getFile(), cp.getSourceStart());\n            }\n            LOG.warning(messageStirng + \" (line: \" + cp.getSourceLineNumber() + \")\", hintObject);\n          } else {\n            if (outputtedErrors < MAX_ERRORS) {\n              outputtedErrors++;\n              Object hintObject = nodeToShow;\n              if (hintObject == null) {\n                hintObject = new FileWithPosition(javaFile.getFile(), cp.getSourceStart());\n              }\n              LOG.warning(messageStirng + \" (line: \" + cp.getSourceLineNumber() + \")\", hintObject);\n            }\n          }\n        }\n\n        errorCount += cr.getErrors().length;\n      }\n\n      for (ClassFile cf : cr.getClassFiles()) {\n        String fqName = getName(cf.getCompoundName());\n        String containerClassName = fqName;\n        if (containerClassName.contains(\"$\")) {\n          int index = containerClassName.indexOf('$');\n          containerClassName = containerClassName.substring(0, index);\n        }\n        if (myContainingModules.containsKey(containerClassName)) {\n          IModule m = myContainingModules.get(containerClassName);\n          File classesGen = m.getClassesGen().toFile();\n          String packageName = NameUtil.namespaceFromLongName(fqName);\n          File outputDir = new File(classesGen + File.separator + packageName.replace('.', File.separatorChar));\n          if (!outputDir.exists()) {\n            if (!outputDir.mkdirs()) {\n              throw new RuntimeException(\"Can't create \" + outputDir.getPath() + \" directory\");\n            }\n          }\n          String className = NameUtil.shortNameFromLongName(fqName);\n          File output = new File(outputDir, className + \".class\");\n          if (!classesWithErrors.contains(fqName)) {\n            try {\n              FileOutputStream os = new FileOutputStream(output);\n              os.write(cf.getBytes());\n              os.close();\n            } catch (IOException e) {\n              LOG.error(\"Can't write to \" + output.getAbsolutePath());\n            }\n          } else {\n            if (output.exists() && !(output.delete())) {\n              LOG.error(\"Can't delete \" + output.getPath());\n            }\n          }\n        } else {\n          LOG.error(\"I don't know in which module's output path I should place class file for \" + fqName);\n        }\n      }\n    }\n\n    for (IModule module : modules) {\n      ModuleSources sources = getModuleSources(module);\n      for (ResourceFile toCopy : sources.getResourcesToCopy()) {\n        String fqName = toCopy.getPath();\n\n        fqName = fqName.substring(0, fqName.length() - toCopy.getFile().getName().length());\n        String path = fqName.replace('/', File.separatorChar) + toCopy.getFile().getName();\n\n        FileUtil.copyFile(\n          toCopy.getFile().toFile(),\n          module.getClassesGen().child(path).toFile()\n        );\n      }\n    }\n\n    for (IModule module : modules) {\n      module.updateClassPath();\n    }\n\n    return new jetbrains.mps.plugin.CompilationResult(errorCount, 0, false);\n  }","commit_id":"914bea83f2d26d88eab6196444be29b68f006366","url":"https://github.com/JetBrains/MPS"},{"original_method":"public RadTable(final Module module, final String id) {\n    super(module, JTable.class, id);\n    initDefaultModel();\n  }","id":28502,"modified_method":"public RadTable(final Module module, final Class componentClass, final String id) {\n    super(module, componentClass, id);\n    initDefaultModel();\n  }","commit_id":"5b90d3b94b925c89c73265b4a16876382c9d86f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static RadComponent createComponent(@NotNull final Module module,\n                                             @NotNull final LwComponent lwComponent,\n                                             @NotNull final ClassLoader loader) throws Exception{\n    // Id\n    final String id = lwComponent.getId();\n    final RadComponent component;\n    Class componentClass = null;\n\n    if (lwComponent instanceof LwNestedForm) {\n      LwNestedForm nestedForm = (LwNestedForm) lwComponent;\n      boolean recursiveNesting = false;\n      try {\n        Utils.validateNestedFormLoop(nestedForm.getFormFileName(), new PsiNestedFormLoader(module));\n      }\n      catch(RecursiveFormNestingException ex) {\n        recursiveNesting = true;\n      }\n      if (recursiveNesting) {\n        component = RadErrorComponent.create(\n          module,\n          id,\n          lwComponent.getComponentClassName(),\n          lwComponent.getErrorComponentProperties(), UIDesignerBundle.message(\"error.recursive.form.nesting\"));\n      }\n      else {\n        component = new RadNestedForm(module, nestedForm.getFormFileName(), id);\n      }\n    }\n    else {\n      if (lwComponent.getErrorComponentProperties() == null) {\n        componentClass = Class.forName(lwComponent.getComponentClassName(), true, loader);\n      }\n\n      if (lwComponent instanceof LwHSpacer) {\n        component = new RadHSpacer(module, id);\n      }\n      else if (lwComponent instanceof LwVSpacer) {\n        component = new RadVSpacer(module, id);\n      }\n      else if (lwComponent instanceof LwAtomicComponent) {\n        if (componentClass == null) {\n          component = createErrorComponent(module, id, lwComponent, loader);\n        }\n        else if (lwComponent.getComponentClassName().equals(JTable.class.getName())) {\n          component = new RadTable(module, id);\n        }\n        else {\n          RadComponent component1;\n          try {\n            component1 = new RadAtomicComponent(module, componentClass, id);\n          }\n          catch (final Exception exc) {\n            String errorDescription = MessageFormat.format(UIDesignerBundle.message(\"error.class.cannot.be.instantiated\"), lwComponent.getComponentClassName());\n            final String message = FormEditingUtil.getExceptionMessage(exc);\n            if (message != null) {\n              errorDescription += \": \" + message;\n            }\n            component1 = RadErrorComponent.create(\n              module,\n              id,\n              lwComponent.getComponentClassName(),\n              lwComponent.getErrorComponentProperties(),\n              errorDescription\n            );\n          }\n          component = component1;\n        }\n      }\n      else if (lwComponent instanceof LwScrollPane) {\n        component = new RadScrollPane(module, componentClass, id);\n      }\n      else if (lwComponent instanceof LwTabbedPane) {\n        component = new RadTabbedPane(module, componentClass, id);\n      }\n      else if (lwComponent instanceof LwSplitPane) {\n        component = new RadSplitPane(module, componentClass, id);\n      }\n      else if (lwComponent instanceof LwToolBar) {\n        component = new RadToolBar(module, componentClass, id);\n      }\n      else if (lwComponent instanceof LwContainer) {\n        final LwContainer lwContainer = (LwContainer)lwComponent;\n        LayoutManager layout = lwContainer.getLayout();\n        if (layout instanceof XYLayoutManager) {\n          // replace stub layout with the real one\n          final XYLayoutManagerImpl xyLayoutManager = new XYLayoutManagerImpl();\n          layout = xyLayoutManager;\n          xyLayoutManager.setPreferredSize(lwComponent.getBounds().getSize());\n        }\n        if (componentClass == null) {\n          component = createErrorComponent(module, id, lwComponent, loader);\n        }\n        else {\n          if (lwContainer instanceof LwRootContainer) {\n            component = new RadRootContainer(module, id);\n          }\n          else {\n            component = new RadContainer(module, componentClass, id);\n\n            String layoutManagerName = lwContainer.getLayoutManager();\n            if (layoutManagerName == null || layoutManagerName.length() == 0) {\n              if (layout instanceof XYLayoutManager) {\n                layoutManagerName = UIFormXmlConstants.LAYOUT_XY;\n              }\n              else {\n                layoutManagerName = UIFormXmlConstants.LAYOUT_INTELLIJ;\n              }\n            }\n            ((RadContainer) component).setLayoutManager(LayoutManagerRegistry.createLayoutManager(layoutManagerName));\n          }\n          ((RadContainer)component).setLayout(layout);\n        }\n      }\n      else {\n        throw new IllegalArgumentException(\"unexpected component: \" + lwComponent);\n      }\n    }\n\n    // binding\n    component.setBinding(lwComponent.getBinding());\n    component.setCustomCreate(lwComponent.isCustomCreate());\n    component.setDefaultBinding(lwComponent.isDefaultBinding());\n\n    // bounds\n    component.setBounds(lwComponent.getBounds());\n\n    // properties\n    final LwIntrospectedProperty[] properties = lwComponent.getAssignedIntrospectedProperties();\n    if (componentClass != null) {\n      final Palette palette = Palette.getInstance(module.getProject());\n      for (final LwIntrospectedProperty lwProperty : properties) {\n        final IntrospectedProperty property = palette.getIntrospectedProperty(component, lwProperty.getName());\n        if (property == null) {\n          continue;\n        }\n        component.loadLwProperty(lwComponent, lwProperty, property);\n      }\n    }\n\n    // GridConstraints\n    component.getConstraints().restore(lwComponent.getConstraints());\n\n    component.setCustomLayoutConstraints(lwComponent.getCustomLayoutConstraints());\n\n    HashMap clientProps = lwComponent.getDelegeeClientProperties();\n    for(Object o: clientProps.entrySet()) {\n      Map.Entry entry = (Map.Entry) o;\n      Object value = entry.getValue();\n      if (value instanceof StringDescriptor) {\n        value = ((StringDescriptor) value).getValue();\n      }\n      component.getDelegee().putClientProperty(entry.getKey(), value);\n    }\n\n    if (component instanceof RadContainer) {\n      final RadContainer container = (RadContainer)component;\n      //noinspection ConstantConditions\n      final LwContainer lwContainer = (LwContainer)lwComponent;\n\n      copyBorder(container, lwContainer);\n\n      // add children\n      for (int i=0; i < lwContainer.getComponentCount(); i++){\n        container.addComponent(createComponent(module, (LwComponent)lwContainer.getComponent(i), loader));\n      }\n    }\n\n    if (component instanceof RadRootContainer) {\n      final RadRootContainer radRootContainer = (RadRootContainer)component;\n      //noinspection ConstantConditions\n      final LwRootContainer lwRootContainer = (LwRootContainer)lwComponent;\n      radRootContainer.setClassToBind(lwRootContainer.getClassToBind());\n      radRootContainer.setMainComponentBinding(lwRootContainer.getMainComponentBinding());\n      radRootContainer.setButtonGroups(lwRootContainer.getButtonGroups());\n      radRootContainer.setInspectionSuppressions(lwRootContainer.getInspectionSuppressions());\n      radRootContainer.getDelegee().setBackground(Color.WHITE);\n    }\n\n    component.doneLoadingFromLw();\n    return component;\n  }","id":28503,"modified_method":"@NotNull\n  public static RadComponent createComponent(@NotNull final Module module,\n                                             @NotNull final LwComponent lwComponent,\n                                             @NotNull final ClassLoader loader) throws Exception{\n    // Id\n    final String id = lwComponent.getId();\n    final RadComponent component;\n    Class componentClass = null;\n\n    if (lwComponent instanceof LwNestedForm) {\n      LwNestedForm nestedForm = (LwNestedForm) lwComponent;\n      boolean recursiveNesting = false;\n      try {\n        Utils.validateNestedFormLoop(nestedForm.getFormFileName(), new PsiNestedFormLoader(module));\n      }\n      catch(RecursiveFormNestingException ex) {\n        recursiveNesting = true;\n      }\n      if (recursiveNesting) {\n        component = RadErrorComponent.create(\n          module,\n          id,\n          lwComponent.getComponentClassName(),\n          lwComponent.getErrorComponentProperties(), UIDesignerBundle.message(\"error.recursive.form.nesting\"));\n      }\n      else {\n        component = new RadNestedForm(module, nestedForm.getFormFileName(), id);\n      }\n    }\n    else {\n      if (lwComponent.getErrorComponentProperties() == null) {\n        componentClass = Class.forName(lwComponent.getComponentClassName(), true, loader);\n      }\n\n      if (lwComponent instanceof LwHSpacer) {\n        component = new RadHSpacer(module, id);\n      }\n      else if (lwComponent instanceof LwVSpacer) {\n        component = new RadVSpacer(module, id);\n      }\n      else if (lwComponent instanceof LwAtomicComponent) {\n        if (componentClass == null) {\n          component = createErrorComponent(module, id, lwComponent, loader);\n        }\n        else if (JTable.class.isAssignableFrom(componentClass)) {\n          component = new RadTable(module, componentClass, id);\n        }\n        else {\n          RadComponent component1;\n          try {\n            component1 = new RadAtomicComponent(module, componentClass, id);\n          }\n          catch (final Exception exc) {\n            String errorDescription = MessageFormat.format(UIDesignerBundle.message(\"error.class.cannot.be.instantiated\"), lwComponent.getComponentClassName());\n            final String message = FormEditingUtil.getExceptionMessage(exc);\n            if (message != null) {\n              errorDescription += \": \" + message;\n            }\n            component1 = RadErrorComponent.create(\n              module,\n              id,\n              lwComponent.getComponentClassName(),\n              lwComponent.getErrorComponentProperties(),\n              errorDescription\n            );\n          }\n          component = component1;\n        }\n      }\n      else if (lwComponent instanceof LwScrollPane) {\n        component = new RadScrollPane(module, componentClass, id);\n      }\n      else if (lwComponent instanceof LwTabbedPane) {\n        component = new RadTabbedPane(module, componentClass, id);\n      }\n      else if (lwComponent instanceof LwSplitPane) {\n        component = new RadSplitPane(module, componentClass, id);\n      }\n      else if (lwComponent instanceof LwToolBar) {\n        component = new RadToolBar(module, componentClass, id);\n      }\n      else if (lwComponent instanceof LwContainer) {\n        final LwContainer lwContainer = (LwContainer)lwComponent;\n        LayoutManager layout = lwContainer.getLayout();\n        if (layout instanceof XYLayoutManager) {\n          // replace stub layout with the real one\n          final XYLayoutManagerImpl xyLayoutManager = new XYLayoutManagerImpl();\n          layout = xyLayoutManager;\n          xyLayoutManager.setPreferredSize(lwComponent.getBounds().getSize());\n        }\n        if (componentClass == null) {\n          component = createErrorComponent(module, id, lwComponent, loader);\n        }\n        else {\n          if (lwContainer instanceof LwRootContainer) {\n            component = new RadRootContainer(module, id);\n          }\n          else {\n            component = new RadContainer(module, componentClass, id);\n\n            String layoutManagerName = lwContainer.getLayoutManager();\n            if (layoutManagerName == null || layoutManagerName.length() == 0) {\n              if (layout instanceof XYLayoutManager) {\n                layoutManagerName = UIFormXmlConstants.LAYOUT_XY;\n              }\n              else {\n                layoutManagerName = UIFormXmlConstants.LAYOUT_INTELLIJ;\n              }\n            }\n            ((RadContainer) component).setLayoutManager(LayoutManagerRegistry.createLayoutManager(layoutManagerName));\n          }\n          ((RadContainer)component).setLayout(layout);\n        }\n      }\n      else {\n        throw new IllegalArgumentException(\"unexpected component: \" + lwComponent);\n      }\n    }\n\n    // binding\n    component.setBinding(lwComponent.getBinding());\n    component.setCustomCreate(lwComponent.isCustomCreate());\n    component.setDefaultBinding(lwComponent.isDefaultBinding());\n\n    // bounds\n    component.setBounds(lwComponent.getBounds());\n\n    // properties\n    final LwIntrospectedProperty[] properties = lwComponent.getAssignedIntrospectedProperties();\n    if (componentClass != null) {\n      final Palette palette = Palette.getInstance(module.getProject());\n      for (final LwIntrospectedProperty lwProperty : properties) {\n        final IntrospectedProperty property = palette.getIntrospectedProperty(component, lwProperty.getName());\n        if (property == null) {\n          continue;\n        }\n        component.loadLwProperty(lwComponent, lwProperty, property);\n      }\n    }\n\n    // GridConstraints\n    component.getConstraints().restore(lwComponent.getConstraints());\n\n    component.setCustomLayoutConstraints(lwComponent.getCustomLayoutConstraints());\n\n    HashMap clientProps = lwComponent.getDelegeeClientProperties();\n    for(Object o: clientProps.entrySet()) {\n      Map.Entry entry = (Map.Entry) o;\n      Object value = entry.getValue();\n      if (value instanceof StringDescriptor) {\n        value = ((StringDescriptor) value).getValue();\n      }\n      component.getDelegee().putClientProperty(entry.getKey(), value);\n    }\n\n    if (component instanceof RadContainer) {\n      final RadContainer container = (RadContainer)component;\n      //noinspection ConstantConditions\n      final LwContainer lwContainer = (LwContainer)lwComponent;\n\n      copyBorder(container, lwContainer);\n\n      // add children\n      for (int i=0; i < lwContainer.getComponentCount(); i++){\n        container.addComponent(createComponent(module, (LwComponent)lwContainer.getComponent(i), loader));\n      }\n    }\n\n    if (component instanceof RadRootContainer) {\n      final RadRootContainer radRootContainer = (RadRootContainer)component;\n      //noinspection ConstantConditions\n      final LwRootContainer lwRootContainer = (LwRootContainer)lwComponent;\n      radRootContainer.setClassToBind(lwRootContainer.getClassToBind());\n      radRootContainer.setMainComponentBinding(lwRootContainer.getMainComponentBinding());\n      radRootContainer.setButtonGroups(lwRootContainer.getButtonGroups());\n      radRootContainer.setInspectionSuppressions(lwRootContainer.getInspectionSuppressions());\n      radRootContainer.getDelegee().setBackground(Color.WHITE);\n    }\n\n    component.doneLoadingFromLw();\n    return component;\n  }","commit_id":"5b90d3b94b925c89c73265b4a16876382c9d86f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LifecycleSupport()\r\n\t{\r\n\t\t// ResolverUtil<LifecycleListener> listeners = new ResolverUtil<LifecycleListener>();\r\n\t\t// listeners.find(new ResolverUtil.IsA(LifecycleListener.class), \"org.pentaho.di.core.lifecycle.pdi\");\r\n\t\t// Set<Class<? extends LifecycleListener>> listenerClasses = listeners.getClasses();\r\n\r\n\t\tlifeListeners = new HashSet<LifecycleListener>();\r\n\r\n        long startTime = System.currentTimeMillis();\r\n        AnnotationDB db = PluginRegistry.getAnnotationDB();\r\n        Set<String> classIndex = db.getClassIndex().keySet();\r\n\t\tClassPool classPool = ClassPool.getDefault();\r\n\t\tfor (String key : classIndex) {\r\n\t\t\tif (key.startsWith(\"org.pentaho.di.core.lifecycle.pdi\")) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tCtClass ctClass = classPool.get(key);\r\n\t\t\r\n\t\t\t\t\tCtClass[] interfaces = ctClass.getInterfaces();\r\n\t\t\t\t\tfor (CtClass interf : interfaces) {\r\n\t\t\t\t\t\tif (interf.getName().equals(LifecycleListener.class.getName())) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tClass<LifecycleListener> clazz = (Class<LifecycleListener>) Class.forName(ctClass.getName());\r\n\t\t\t\t\t\t\t\tlifeListeners.add( clazz.newInstance() );\r\n\t\t\t\t\t\t\t} catch(Exception e) {\r\n\t\t\t\t\t\t\t\tLogChannel.GENERAL.logDetailed(\"Unable to reach class \"+ctClass.getName()+\": \"+e.getMessage());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch(NotFoundException e) {\r\n\t\t\t\t\t// System.out.println(\"        - interfaces not found for class: \"+ctClass.getName());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tLogChannel.GENERAL.logBasic(\"Finished lifecycle listener scan in \"+(System.currentTimeMillis()-startTime)+\"ms.\");\r\n\r\n\t\t/*\r\n\t\tfor (Class<? extends LifecycleListener> clazz : listenerClasses)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tlifeListeners.add(clazz.newInstance());\r\n\t\t\t} \r\n\t\t\tcatch (Throwable e)\r\n\t\t\t{\r\n\t\t\t\tlog.logError(\"Unable to init listener:\" + e.getMessage(), new Object[] {});\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}*/\r\n\t}","id":28504,"modified_method":"public LifecycleSupport()\r\n\t{\r\n\t\t// ResolverUtil<LifecycleListener> listeners = new ResolverUtil<LifecycleListener>();\r\n\t\t// listeners.find(new ResolverUtil.IsA(LifecycleListener.class), \"org.pentaho.di.core.lifecycle.pdi\");\r\n\t\t// Set<Class<? extends LifecycleListener>> listenerClasses = listeners.getClasses();\r\n\r\n\t\tlifeListeners = new HashSet<LifecycleListener>();\r\n\r\n        long startTime = System.currentTimeMillis();\r\n        AnnotationDB db = PluginRegistry.getAnnotationDB();\r\n        Set<String> classIndex = db.getClassIndex().keySet();\r\n\t\tClassPool classPool = ClassPool.getDefault();\r\n\t\tfor (String key : classIndex) {\r\n\t\t\tif (key.startsWith(\"org.pentaho.di.core.lifecycle.pdi\")) {\r\n\t\t\t\ttry {\r\n\t\t\t\t  //TODO: uncomment once launcher.jar is fixed or removed\r\n//\t\t\t\t\tCtClass ctClass = classPool.get(key);\r\n//\t\t\r\n//\t\t\t\t\tCtClass[] interfaces = ctClass.getInterfaces();\r\n//\t\t\t\t\tfor (CtClass interf : interfaces) {\r\n//\t\t\t\t\t\tif (interf.getName().equals(LifecycleListener.class.getName())) {\r\n//\t\t\t\t\t\t\ttry {\r\n//\t\t\t\t\t\t\t\tClass<LifecycleListener> clazz = (Class<LifecycleListener>) Class.forName(ctClass.getName());\r\n//\t\t\t\t\t\t\t\tlifeListeners.add( clazz.newInstance() );\r\n//\t\t\t\t\t\t\t} catch(Exception e) {\r\n//\t\t\t\t\t\t\t\tLogChannel.GENERAL.logDetailed(\"Unable to reach class \"+ctClass.getName()+\": \"+e.getMessage());\r\n//\t\t\t\t\t\t\t}\r\n//\t\t\t\t\t\t}\r\n//\t\t\t\t\t}\r\n\t\t\t\t  \r\n\r\n          Class<?> clazz = (Class<?>) Class.forName(key);\r\n          if(LifecycleListener.class.isAssignableFrom(clazz)){\r\n            lifeListeners.add( (LifecycleListener) clazz.newInstance() );\r\n          }\r\n          \r\n//\t\t\t\t} catch(NotFoundException e) {\r\n//\t\t\t\t  System.out.println(e.getMessage());\r\n//\t\t\t\t  e.printStackTrace();\r\n\t\t\t\t\t// System.out.println(\"        - interfaces not found for class: \"+ctClass.getName());\r\n\t\t\t\t} catch (ClassNotFoundException e) {\r\n          // TODO Auto-generated catch block\r\n          e.printStackTrace();\r\n        } catch (InstantiationException e) {\r\n          // TODO Auto-generated catch block\r\n          e.printStackTrace();\r\n        } catch (IllegalAccessException e) {\r\n          // TODO Auto-generated catch block\r\n          e.printStackTrace();\r\n        }\r\n\t\t\t}\r\n\t\t}\r\n\t\tLogChannel.GENERAL.logBasic(\"Finished lifecycle listener scan in \"+(System.currentTimeMillis()-startTime)+\"ms.\");\r\n\r\n\t\t/*\r\n\t\tfor (Class<? extends LifecycleListener> clazz : listenerClasses)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tlifeListeners.add(clazz.newInstance());\r\n\t\t\t} \r\n\t\t\tcatch (Throwable e)\r\n\t\t\t{\r\n\t\t\t\tlog.logError(\"Unable to init listener:\" + e.getMessage(), new Object[] {});\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}*/\r\n\t}","commit_id":"2f94e7c2913c60c301a9801c653e529cf679c495","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * This method registers plugin types and loads their respective plugins \n\t * \n\t * @throws KettlePluginException\n\t */\n\tpublic static void init(PluginTypeInterface[] pluginTypes) throws KettlePluginException {\n\t\tPluginRegistry registry = getInstance();\n\t\t\n\t\ttry {\n\t\t\tannotationDB = new AnnotationDB();\n\t\t\tURL[] urls = ClasspathUrlFinder.findClassPaths();\n\t\t\tLogChannel.GENERAL.logDetailed(\"Found \"+urls.length+\" objects in the classpath.\");\n\t\t\tlong startScan = System.currentTimeMillis();\n\t\t\tannotationDB.scanArchives(urls);\n\t\t\t\n\t\t\t// This has something to do with the fact that we're using our own launcher\n\t\t\t// The class path of that thing is somehow picked up.  To be investigated!\n\t\t\t//\n\t\t\tFile kettleCore = new File(\"lib/kettle-core.jar\");\n\t\t\tif (kettleCore.exists()) {\n  \t\t\tannotationDB.scanArchives(kettleCore.toURI().toURL());\n  \t\t\tannotationDB.scanArchives(new File(\"lib/kettle-db.jar\").toURI().toURL());\n  \t\t\tannotationDB.scanArchives(new File(\"lib/kettle-engine.jar\").toURI().toURL());\n\t\t\t}\n\t\t\tLogChannel.GENERAL.logDetailed(\"Finished annotation scan in \"+(System.currentTimeMillis()-startScan)+\"ms.\");\n\t\t} catch(IOException e) {\n\t\t\tthrow new KettlePluginException(\"Unable to scan for annotations in the classpath\", e);\n\t\t}\n\t\t\n\t\tfor (PluginTypeInterface pluginType : pluginTypes) {\n\t\t\t// Register the plugin type \n\t\t\t//\n\t\t\tregistry.registerPluginType(pluginType.getClass());\n\t\t\t\n\t\t\t// Search plugins for this type...\n\t\t\t//\n\t\t\tlong startScan = System.currentTimeMillis();\n\t\t\tpluginType.searchPlugins();\n\t\t\t\n\t\t\tLogChannel.GENERAL.logDetailed(\"Registered \"+registry.getPlugins(pluginType.getClass()).size()+\" plugins of type '\"+pluginType.getName()+\"' in \"+(System.currentTimeMillis()-startScan)+\"ms.\");\n\t\t}\n\t}","id":28505,"modified_method":"/**\n\t * This method registers plugin types and loads their respective plugins \n\t * \n\t * @throws KettlePluginException\n\t */\n\tpublic static void init(PluginTypeInterface[] pluginTypes) throws KettlePluginException {\n\t\tPluginRegistry registry = getInstance();\n\t\t\n\t\ttry {\n\t\t\tannotationDB = new AnnotationDB();\n\t\t\tURL[] urls = ClasspathUrlFinder.findClassPaths();\n\t\t\t\n\t\t\tLogChannel.GENERAL.logDetailed(\"Found \"+urls.length+\" objects in the classpath.\");\n\t\t\tlong startScan = System.currentTimeMillis();\n\t\t\tannotationDB.scanArchives(urls);\n\t\t\t\n\t\t\t// This has something to do with the fact that we're using our own launcher\n\t\t\t// The class path of that thing is somehow picked up.  To be investigated!\n\t\t\t//\n\t\t\tFile kettleCore = new File(\"lib/kettle-core.jar\");\n\t\t\tif (kettleCore.exists()) {\n  \t\t\tannotationDB.scanArchives(kettleCore.toURI().toURL());\n  \t\t\tannotationDB.scanArchives(new File(\"lib/kettle-db.jar\").toURI().toURL());\n  \t\t\tannotationDB.scanArchives(new File(\"lib/kettle-engine.jar\").toURI().toURL());\n\t\t\t}\n\t\t\t\n\t\t\t// HACK!!\n\t\t\t// TODO: remove once launcher.jar is removed and or annotation scanning is resolved.\n\t\t\tFile agileBI = new File(\"plugins/spoon/agile-bi/lib/agile-bi-TRUNK-SNAPSHOT.jar\");\n\t\t\tif(agileBI.exists()){\n        annotationDB.scanArchives(agileBI.toURI().toURL());\n\t\t\t}\n\t\t\t\n\t\t\tLogChannel.GENERAL.logDetailed(\"Finished annotation scan in \"+(System.currentTimeMillis()-startScan)+\"ms.\");\n\t\t} catch(IOException e) {\n\t\t\tthrow new KettlePluginException(\"Unable to scan for annotations in the classpath\", e);\n\t\t}\n\t\t\n\t\tfor (PluginTypeInterface pluginType : pluginTypes) {\n\t\t\t// Register the plugin type \n\t\t\t//\n\t\t\tregistry.registerPluginType(pluginType.getClass());\n\t\t\t\n\t\t\t// Search plugins for this type...\n\t\t\t//\n\t\t\tlong startScan = System.currentTimeMillis();\n\t\t\tpluginType.searchPlugins();\n\t\t\t\n\t\t\tLogChannel.GENERAL.logDetailed(\"Registered \"+registry.getPlugins(pluginType.getClass()).size()+\" plugins of type '\"+pluginType.getName()+\"' in \"+(System.currentTimeMillis()-startScan)+\"ms.\");\n\t\t}\n\t}","commit_id":"2f94e7c2913c60c301a9801c653e529cf679c495","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Lookup all the {@link BlueprintCamelContext} in the {@link BlueprintContainer}.\n     *\n     * @param container the blueprint container, must be provided\n     * @return a set with the ids of the {@link BlueprintCamelContext}, never <tt>null<\/tt>, but can be empty set.\n     */\n    public static Set<String> lookupBlueprintCamelContext(BlueprintContainer container) {\n        Set<String> found = new LinkedHashSet<String>();\n        for (Object id : container.getComponentIds()) {\n            ComponentMetadata meta = container.getComponentMetadata(id.toString());\n\n            // must be extended meta, to see if its the blueprint camel context\n            if (meta instanceof ExtendedBeanMetadata) {\n                ExtendedBeanMetadata emata = (ExtendedBeanMetadata) meta;\n                if (emata.getRuntimeClass() != null && BlueprintCamelContext.class.getName().equals(emata.getRuntimeClass().getName())) {\n                    // okay we found a BlueprintCamelContext\n                    found.add(emata.getId());\n                }\n            }\n        }\n        return found;\n    }","id":28506,"modified_method":"/**\n     * Lookup all the {@link BlueprintCamelContext} in the {@link BlueprintContainer}.\n     *\n     * @param container the blueprint container, must be provided\n     * @return a set with the ids of the {@link BlueprintCamelContext}, never <tt>null<\/tt>, but can be empty set.\n     */\n    public static Set<String> lookupBlueprintCamelContext(BlueprintContainer container) {\n        Set<String> ids = new LinkedHashSet<String>();\n        for (Object id : container.getComponentIds()) {\n            ComponentMetadata meta = container.getComponentMetadata(id.toString());\n\n            // must be extended meta, to see if its the blueprint camel context\n            if (meta instanceof ExtendedBeanMetadata) {\n                Class<?> clazz = ((ExtendedBeanMetadata) meta).getRuntimeClass();\n                if (clazz != null && BlueprintCamelContext.class.isAssignableFrom(clazz)) {\n                    // okay we found a BlueprintCamelContext\n                    ids.add(meta.getId());\n                }\n            }\n        }\n        return ids;\n    }","commit_id":"6c584755087c75efa7e227f4b8a55e395dc3ea21","url":"https://github.com/apache/camel"},{"original_method":"/**\r\n   * Performs the path function.\r\n   * @param it item to be resolved\r\n   * @return resulting iterator\r\n   * @throws QueryException query exception\r\n   */\r\n  private Str path(final Item it) throws QueryException {\r\n    final TokenList tl = new TokenList();\r\n    ANode n = checkNode(it);\r\n    while(n.parent() != null) {\r\n      int i = 1;\r\n      final TokenBuilder tb = new TokenBuilder();\r\n      if(n.type == NodeType.ATT) {\r\n        tb.add('@');\r\n        final QNm qnm = n.qname();\r\n        final byte[] uri = qnm.uri();\r\n        if(uri.length != 0) tb.add('\"').add(uri).add(\"\\\":\");\r\n        tb.add(qnm.local());\r\n      } else if(n.type == NodeType.ELM) {\r\n        final QNm qnm = n.qname();\r\n        final AxisIter ai = n.precedingSibling();\r\n        for(ANode fs; (fs = ai.next()) != null;) if(fs.qname().eq(qnm)) i++;\r\n        tb.addExt(\"\\\"%\\\":%[%]\", qnm.uri(), qnm.local(), i);\r\n      } else if(n.type == NodeType.COM || n.type == NodeType.TXT) {\r\n        final AxisIter ai = n.precedingSibling();\r\n        for(ANode fs; (fs = ai.next()) != null;) if(fs.type == n.type) i++;\r\n        tb.addExt(n.type() + \"[%]\", i);\r\n      } else if(n.type == NodeType.PI) {\r\n        final QNm qnm = n.qname();\r\n        final AxisIter ai = n.precedingSibling();\r\n        for(ANode fs; (fs = ai.next()) != null;) {\r\n          if(fs.type == n.type && fs.qname().eq(qnm)) i++;\r\n        }\r\n        tb.addExt(\"%(\\\"%\\\")[%]\", n.type.string(), qnm.local(), i);\r\n      }\r\n      tl.add(tb.finish());\r\n      n = n.parent();\r\n    }\r\n    if(n.type != NodeType.DOC) IDDOC.thrw(input);\r\n\r\n    final TokenBuilder tb = new TokenBuilder();\r\n    for(int i = tl.size() - 1; i >= 0; --i) tb.add('/').add(tl.get(i));\r\n    return Str.get(tb.isEmpty() ? Token.SLASH : tb.finish());\r\n  }","id":28507,"modified_method":"/**\r\n   * Performs the path function.\r\n   * @param it item to be resolved\r\n   * @return resulting iterator\r\n   * @throws QueryException query exception\r\n   */\r\n  private Str path(final Item it) throws QueryException {\r\n    final TokenList tl = new TokenList();\r\n    ANode n = checkNode(it);\r\n    while(n.parent() != null) {\r\n      int i = 1;\r\n      final TokenBuilder tb = new TokenBuilder();\r\n      if(n.type == NodeType.ATT) {\r\n        tb.add('@');\r\n        final QNm qnm = n.qname();\r\n        final byte[] uri = qnm.uri();\r\n        if(uri.length != 0) tb.add(\"Q{\").add(qnm.uri()).add('}');\r\n        tb.add(qnm.local());\r\n      } else if(n.type == NodeType.ELM) {\r\n        final QNm qnm = n.qname();\r\n        final AxisIter ai = n.precedingSibling();\r\n        for(ANode fs; (fs = ai.next()) != null;) if(fs.qname().eq(qnm)) i++;\r\n        tb.add(\"Q{\").add(qnm.uri()).add('}').add(qnm.local());\r\n        tb.add('[').add(Integer.toString(i)).add(']');\r\n      } else if(n.type == NodeType.COM || n.type == NodeType.TXT) {\r\n        final AxisIter ai = n.precedingSibling();\r\n        for(ANode fs; (fs = ai.next()) != null;) if(fs.type == n.type) i++;\r\n        tb.addExt(n.type() + \"[%]\", i);\r\n      } else if(n.type == NodeType.PI) {\r\n        final QNm qnm = n.qname();\r\n        final AxisIter ai = n.precedingSibling();\r\n        for(ANode fs; (fs = ai.next()) != null;) {\r\n          if(fs.type == n.type && fs.qname().eq(qnm)) i++;\r\n        }\r\n        tb.add(n.type.string()).add(\"(\\\"\").add(qnm.local());\r\n        tb.add(\"\\\")[\").add(Integer.toString(i)).add(']');\r\n      }\r\n      tl.add(tb.finish());\r\n      n = n.parent();\r\n    }\r\n    if(n.type != NodeType.DOC) IDDOC.thrw(input);\r\n\r\n    final TokenBuilder tb = new TokenBuilder();\r\n    for(int i = tl.size() - 1; i >= 0; --i) tb.add('/').add(tl.get(i));\r\n    return Str.get(tb.isEmpty() ? Token.SLASH : tb.finish());\r\n  }","commit_id":"b7382c28655d0195819a6785e4a2656bade508f4","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Nonnull\n    private synchronized ChangeSet internalChange(NodeState root, ContentSession contentSession) {\n        ChangeSet changeSet = ChangeSet.local(previousRoot, root, contentSession);\n        previousRoot = root;\n        return changeSet;\n    }","id":28508,"modified_method":"private void internalChange(NodeState root, ContentSession contentSession) {\n        add(ChangeSet.local(previousRoot, root, contentSession));\n        previousRoot = root;\n    }","commit_id":"21208083a8f7c35d4ea9fc8ea842b9bf2af6cd48","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@CheckForNull\n    private synchronized ChangeSet externalChange(NodeState root) {\n        if (root != previousRoot) {\n            ChangeSet changeSet = ChangeSet.external(previousRoot, root);\n            previousRoot = root;\n            return changeSet;\n        }\n        return null;\n    }","id":28509,"modified_method":"private void externalChange(NodeState root) {\n        if (!root.equals(previousRoot)) {\n            add(ChangeSet.external(previousRoot, root));\n            previousRoot = root;\n        }\n    }","commit_id":"21208083a8f7c35d4ea9fc8ea842b9bf2af6cd48","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n         * Poll for changes reported to this listener.\n         * @return  {@code ChangeSet} of the changes or {@code null} if no changes occurred since\n         *          the last call to this method.\n         */\n        @CheckForNull\n        public ChangeSet getChanges() {\n            if (changeSets.isEmpty()) {\n                ChangeSet changeSet = externalChange(store.getRoot());\n                if (changeSet != null) {\n                    add(changeSet);\n                }\n            }\n            return changeSets.isEmpty() ? null : changeSets.remove();\n        }","id":28510,"modified_method":"/**\n         * Poll for changes reported to this listener.\n         * @return  {@code ChangeSet} of the changes or {@code null} if no changes occurred since\n         *          the last call to this method.\n         */\n        @CheckForNull\n        public ChangeSet getChanges() {\n            if (changeSets.isEmpty()) {\n                externalChange();\n            }\n            return changeSets.isEmpty() ? null : changeSets.remove();\n        }","commit_id":"21208083a8f7c35d4ea9fc8ea842b9bf2af6cd48","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void contentChanged(@Nonnull NodeState before, @Nonnull NodeState after, ContentSession contentSession) {\n        ChangeSet extChanges;\n        ChangeSet intChange;\n        synchronized (this) {\n            extChanges = externalChange(checkNotNull(before));\n            intChange = internalChange(checkNotNull(after), contentSession);\n        }\n        if (extChanges != null) {\n            add(extChanges);\n        }\n        add(intChange);\n    }","id":28511,"modified_method":"private synchronized void contentChanged(@Nonnull NodeState before, @Nonnull NodeState after,\n            ContentSession contentSession) {\n        externalChange(checkNotNull(before));\n        internalChange(checkNotNull(after), contentSession);\n    }","commit_id":"21208083a8f7c35d4ea9fc8ea842b9bf2af6cd48","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<Long> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socketWrapper;\n        inputBuffer.init(socketWrapper, endpoint);\n        outputBuffer.init(socketWrapper, endpoint);\n\n        // Error flag\n        error = false;\n        keepAlive = true;\n        comet = false;\n        openSocket = false;\n        sendfileInProgress = false;\n\n        int soTimeout = endpoint.getSoTimeout();\n\n        if (disableKeepAlive()) {\n            socketWrapper.setKeepAliveLeft(0);\n        }\n\n        boolean keptAlive = false;\n\n        long socketRef = socketWrapper.getSocket().longValue();\n\n        while (!error && keepAlive && !comet && !isAsync() && !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                if( !disableUploadTimeout && keptAlive && soTimeout > 0 ) {\n                    Socket.timeoutSet(socketRef, soTimeout * 1000);\n                }\n                if (!inputBuffer.parseRequestLine(keptAlive)) {\n                    // This means that no data is available right now\n                    // (long keepalive), so that the processor should be recycled\n                    // and the method should return true\n                    openSocket = true;\n                    if (endpoint.isPaused()) {\n                        // 503 - Service unavailable\n                        response.setStatus(503);\n                        adapter.log(request, response, 0);\n                        error = true;\n                    } else {\n                        break;\n                    }\n                }\n                if (!endpoint.isPaused()) {\n                    request.setStartTime(System.currentTimeMillis());\n                    keptAlive = true;\n                    if (!disableUploadTimeout) {\n                        Socket.timeoutSet(socketRef,\n                                connectionUploadTimeout * 1000);\n                    }\n                    inputBuffer.parseHeaders();\n                }\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (maxKeepAliveRequests == 1) {\n                keepAlive = false;\n            } else if (maxKeepAliveRequests > 0 &&\n                    socketWrapper.decrementKeepAlive() <= 0) {\n                keepAlive = false;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                (!isAsync() &&\n                                statusDropsConnection(response.getStatus()));\n                    }\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n\n            if (!isAsync() && !comet) {\n                if (error) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    inputBuffer.setSwallowInput(false);\n                }\n                endRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            if (!comet && !isAsync()) {\n                // Next request\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            if (breakKeepAliveLoop(socketWrapper)) {\n            \tbreak;\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (comet  || isAsync()) {\n            return SocketState.LONG;\n        } else {\n            if (sendfileInProgress) {\n                return SocketState.SENDFILE;\n            } else {\n                return (openSocket) ? SocketState.OPEN : SocketState.CLOSED;\n            }\n        }\n        \n    }","id":28512,"modified_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<Long> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socketWrapper;\n        inputBuffer.init(socketWrapper, endpoint);\n        outputBuffer.init(socketWrapper, endpoint);\n\n        // Error flag\n        error = false;\n        keepAlive = true;\n        comet = false;\n        openSocket = false;\n        sendfileInProgress = false;\n        readComplete = true;\n\n        int soTimeout = endpoint.getSoTimeout();\n\n        if (disableKeepAlive()) {\n            socketWrapper.setKeepAliveLeft(0);\n        }\n\n        boolean keptAlive = false;\n\n        long socketRef = socketWrapper.getSocket().longValue();\n\n        while (!error && keepAlive && !comet && !isAsync() && !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                if( !disableUploadTimeout && keptAlive && soTimeout > 0 ) {\n                    Socket.timeoutSet(socketRef, soTimeout * 1000);\n                }\n                if (!inputBuffer.parseRequestLine(keptAlive)) {\n                    // This means that no data is available right now\n                    // (long keepalive), so that the processor should be recycled\n                    // and the method should return true\n                    openSocket = true;\n                    if (endpoint.isPaused()) {\n                        // 503 - Service unavailable\n                        response.setStatus(503);\n                        adapter.log(request, response, 0);\n                        error = true;\n                    } else {\n                        break;\n                    }\n                }\n                if (!endpoint.isPaused()) {\n                    request.setStartTime(System.currentTimeMillis());\n                    keptAlive = true;\n                    if (!disableUploadTimeout) {\n                        Socket.timeoutSet(socketRef,\n                                connectionUploadTimeout * 1000);\n                    }\n                    inputBuffer.parseHeaders();\n                }\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (maxKeepAliveRequests == 1) {\n                keepAlive = false;\n            } else if (maxKeepAliveRequests > 0 &&\n                    socketWrapper.decrementKeepAlive() <= 0) {\n                keepAlive = false;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                (!isAsync() &&\n                                statusDropsConnection(response.getStatus()));\n                    }\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n\n            if (!isAsync() && !comet) {\n                if (error) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    inputBuffer.setSwallowInput(false);\n                }\n                endRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            if (!comet && !isAsync()) {\n                // Next request\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            if (breakKeepAliveLoop(socketWrapper)) {\n                break;\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (comet  || isAsync()) {\n            return SocketState.LONG;\n        } else {\n            if (sendfileInProgress) {\n                return SocketState.SENDFILE;\n            } else {\n                if (openSocket) {\n                    if (readComplete) {\n                        return SocketState.OPEN;\n                    } else {\n                        return SocketState.LONG;\n                    }\n                } else {\n                    return SocketState.CLOSED;\n                }\n            }\n        }\n    }","commit_id":"8c720fe30b6dcf98e53d1c53a67c7854ce3e016a","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<NioChannel> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socketWrapper;\n        inputBuffer.init(socketWrapper, endpoint);\n        outputBuffer.init(socketWrapper, endpoint);\n\n        // Error flag\n        error = false;\n        keepAlive = true;\n        comet = false;\n        openSocket = false;\n        sendfileInProgress = false;\n        \n        int soTimeout = endpoint.getSoTimeout();\n\n        if (disableKeepAlive()) {\n            socketWrapper.setKeepAliveLeft(0);\n        }\n\n        boolean keptAlive = false;\n        boolean readComplete = true;\n        \n        while (!error && keepAlive && !comet && !isAsync() && !endpoint.isPaused()) {\n            //always default to our soTimeout\n            socketWrapper.setTimeout(soTimeout);\n            // Parsing the request header\n            try {\n                if( !disableUploadTimeout && keptAlive && soTimeout > 0 ) {\n                    socketWrapper.getSocket().getIOChannel().socket().setSoTimeout(soTimeout);\n                }\n                if (!inputBuffer.parseRequestLine(keptAlive)) {\n                    // Haven't finished reading the request so keep the socket\n                    // open\n                    openSocket = true;\n                    // Check to see if we have read any of the request line yet\n                    if (inputBuffer.getParsingRequestLinePhase()<2) {\n                        // No data read, OK to recycle the processor\n                        // Continue to use keep alive timeout\n                        if (keepAliveTimeout>0) {\n                            socketWrapper.setTimeout(keepAliveTimeout);\n                        }\n                    } else {\n                        // Started to read request line. Need to keep processor\n                        // associated with socket\n                        readComplete = false;\n                    }\n                    if (endpoint.isPaused()) {\n                        // 503 - Service unavailable\n                        response.setStatus(503);\n                        adapter.log(request, response, 0);\n                        error = true;\n                    } else {\n                        break;\n                    }\n                }\n                if (!endpoint.isPaused()) {\n                    keptAlive = true;\n                    if ( !inputBuffer.parseHeaders() ) {\n                        //we've read part of the request, don't recycle it\n                        //instead associate it with the socket\n                        openSocket = true;\n                        readComplete = false;\n                        break;\n                    }\n                    request.setStartTime(System.currentTimeMillis());\n                    if (!disableUploadTimeout) { //only for body, not for request headers\n                        socketWrapper.getSocket().getIOChannel().socket().setSoTimeout(\n                                connectionUploadTimeout);\n                    }\n                }\n            } catch (IOException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), e);\n                }\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n            \n            if (maxKeepAliveRequests == 1) {\n                keepAlive = false;\n            } else if (maxKeepAliveRequests > 0 &&\n                    socketWrapper.decrementKeepAlive() <= 0) {\n                keepAlive = false;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                (!isAsync() &&\n                                statusDropsConnection(response.getStatus()));\n                    }\n                    // Comet support\n                    SelectionKey key = socketWrapper.getSocket().getIOChannel().keyFor(\n                            socketWrapper.getSocket().getPoller().getSelector());\n                    if (key != null) {\n                        NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment();\n                        if (attach != null)  {\n                            attach.setComet(comet);\n                            if (comet) {\n                                Integer comettimeout = (Integer) request.getAttribute(\"org.apache.tomcat.comet.timeout\");\n                                if (comettimeout != null) attach.setTimeout(comettimeout.longValue());\n                            }\n                        }\n                    }\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n\n            if (!isAsync() && !comet) {\n                if(error) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    inputBuffer.setSwallowInput(false);\n                }\n                endRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            if (!comet && !isAsync()) {\n                // Next request\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            if (breakKeepAliveLoop(socketWrapper)) {\n            \tbreak;\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (comet || isAsync()) {\n            return SocketState.LONG;\n        } else {\n            return (openSocket) ? (readComplete?SocketState.OPEN:SocketState.LONG) : SocketState.CLOSED;\n        }\n    }","id":28513,"modified_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<NioChannel> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socketWrapper;\n        inputBuffer.init(socketWrapper, endpoint);\n        outputBuffer.init(socketWrapper, endpoint);\n\n        // Error flag\n        error = false;\n        keepAlive = true;\n        comet = false;\n        openSocket = false;\n        sendfileInProgress = false;\n        readComplete = true;\n        \n        int soTimeout = endpoint.getSoTimeout();\n\n        if (disableKeepAlive()) {\n            socketWrapper.setKeepAliveLeft(0);\n        }\n\n        boolean keptAlive = false;\n        \n        while (!error && keepAlive && !comet && !isAsync() && !endpoint.isPaused()) {\n            //always default to our soTimeout\n            socketWrapper.setTimeout(soTimeout);\n            // Parsing the request header\n            try {\n                if( !disableUploadTimeout && keptAlive && soTimeout > 0 ) {\n                    socketWrapper.getSocket().getIOChannel().socket().setSoTimeout(soTimeout);\n                }\n                if (!inputBuffer.parseRequestLine(keptAlive)) {\n                    // Haven't finished reading the request so keep the socket\n                    // open\n                    openSocket = true;\n                    // Check to see if we have read any of the request line yet\n                    if (inputBuffer.getParsingRequestLinePhase()<2) {\n                        // No data read, OK to recycle the processor\n                        // Continue to use keep alive timeout\n                        if (keepAliveTimeout>0) {\n                            socketWrapper.setTimeout(keepAliveTimeout);\n                        }\n                    } else {\n                        // Started to read request line. Need to keep processor\n                        // associated with socket\n                        readComplete = false;\n                    }\n                    if (endpoint.isPaused()) {\n                        // 503 - Service unavailable\n                        response.setStatus(503);\n                        adapter.log(request, response, 0);\n                        error = true;\n                    } else {\n                        break;\n                    }\n                }\n                if (!endpoint.isPaused()) {\n                    keptAlive = true;\n                    if ( !inputBuffer.parseHeaders() ) {\n                        //we've read part of the request, don't recycle it\n                        //instead associate it with the socket\n                        openSocket = true;\n                        readComplete = false;\n                        break;\n                    }\n                    request.setStartTime(System.currentTimeMillis());\n                    if (!disableUploadTimeout) { //only for body, not for request headers\n                        socketWrapper.getSocket().getIOChannel().socket().setSoTimeout(\n                                connectionUploadTimeout);\n                    }\n                }\n            } catch (IOException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), e);\n                }\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n            \n            if (maxKeepAliveRequests == 1) {\n                keepAlive = false;\n            } else if (maxKeepAliveRequests > 0 &&\n                    socketWrapper.decrementKeepAlive() <= 0) {\n                keepAlive = false;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                (!isAsync() &&\n                                statusDropsConnection(response.getStatus()));\n                    }\n                    // Comet support\n                    SelectionKey key = socketWrapper.getSocket().getIOChannel().keyFor(\n                            socketWrapper.getSocket().getPoller().getSelector());\n                    if (key != null) {\n                        NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment();\n                        if (attach != null)  {\n                            attach.setComet(comet);\n                            if (comet) {\n                                Integer comettimeout = (Integer) request.getAttribute(\"org.apache.tomcat.comet.timeout\");\n                                if (comettimeout != null) attach.setTimeout(comettimeout.longValue());\n                            }\n                        }\n                    }\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n\n            if (!isAsync() && !comet) {\n                if(error) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    inputBuffer.setSwallowInput(false);\n                }\n                endRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            if (!comet && !isAsync()) {\n                // Next request\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            if (breakKeepAliveLoop(socketWrapper)) {\n                break;\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (comet || isAsync()) {\n            return SocketState.LONG;\n        } else {\n            if (sendfileInProgress) {\n                return SocketState.SENDFILE;\n            } else {\n                if (openSocket) {\n                    if (readComplete) {\n                        return SocketState.OPEN;\n                    } else {\n                        return SocketState.LONG;\n                    }\n                } else {\n                    return SocketState.CLOSED;\n                }\n            }\n        }\n    }","commit_id":"8c720fe30b6dcf98e53d1c53a67c7854ce3e016a","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<Socket> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the I/O\n        this.socket = socketWrapper;\n        inputBuffer.init(socketWrapper, endpoint);\n        outputBuffer.init(socketWrapper, endpoint);\n\n        // Error flag\n        error = false;\n        keepAlive = true;\n        comet = false;\n        openSocket = false;\n        sendfileInProgress = false;\n\n        int soTimeout = endpoint.getSoTimeout();\n\n        if (disableKeepAlive()) {\n            socketWrapper.setKeepAliveLeft(0);\n        }\n\n        boolean keptAlive = socketWrapper.isKeptAlive();\n\n        while (!error && keepAlive && !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                int standardTimeout = 0;\n                if (keptAlive) {\n                    if (keepAliveTimeout > 0) {\n                        standardTimeout = keepAliveTimeout;\n                    } else if (soTimeout > 0) {\n                        standardTimeout = soTimeout;\n                    }\n                }\n                /*\n                 * When there is no data in the buffer and this is not the first\n                 * request on this connection and timeouts are being used the\n                 * first read for this request may need a different timeout to\n                 * take account of time spent waiting for a processing thread.\n                 * \n                 * This is a little hacky but better than exposing the socket\n                 * and the timeout info to the InputBuffer\n                 */\n                if (inputBuffer.lastValid == 0 &&\n                        socketWrapper.getLastAccess() > -1 &&\n                        standardTimeout > 0) {\n\n                    long queueTime = System.currentTimeMillis() -\n                            socketWrapper.getLastAccess();\n                    int firstReadTimeout;\n                    if (queueTime >= standardTimeout) {\n                        // Queued for longer than timeout but there might be\n                        // data so use shortest possible timeout\n                        firstReadTimeout = 1;\n                    } else {\n                        // Cast is safe since queueTime must be less than\n                        // standardTimeout which is an int\n                        firstReadTimeout = standardTimeout - (int) queueTime;\n                    }\n                    socket.getSocket().setSoTimeout(firstReadTimeout);\n                    if (!inputBuffer.fill()) {\n                        throw new EOFException(sm.getString(\"iib.eof.error\"));\n                    }\n                }\n                if (standardTimeout > 0) {\n                    socket.getSocket().setSoTimeout(standardTimeout);\n                }\n\n                inputBuffer.parseRequestLine(false);\n                if (endpoint.isPaused()) {\n                    // 503 - Service unavailable\n                    response.setStatus(503);\n                    adapter.log(request, response, 0);\n                    error = true;\n                } else {\n                    request.setStartTime(System.currentTimeMillis());\n                    keptAlive = true;\n                    if (disableUploadTimeout) {\n                        socket.getSocket().setSoTimeout(soTimeout);\n                    } else {\n                        socket.getSocket().setSoTimeout(connectionUploadTimeout);\n                    }\n                    inputBuffer.parseHeaders();\n                }\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (maxKeepAliveRequests == 1) {\n                keepAlive = false;\n            } else if (maxKeepAliveRequests > 0 &&\n                    socketWrapper.decrementKeepAlive() <= 0) {\n                keepAlive = false;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                (!isAsync() &&\n                                statusDropsConnection(response.getStatus()));\n                    }\n\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n\n            if(!isAsync() && !comet) {\n                if (error) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    inputBuffer.setSwallowInput(false);\n                }\n                endRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            // Next request\n            if (!isAsync() || error) {\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            if (breakKeepAliveLoop(socketWrapper)) {\n            \tbreak;\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (isAsync()) {\n            return SocketState.LONG;\n        } else {\n            if (!keepAlive) {\n                return SocketState.CLOSED;\n            } else {\n                return SocketState.OPEN;\n            }\n        } \n    }","id":28514,"modified_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<Socket> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the I/O\n        this.socket = socketWrapper;\n        inputBuffer.init(socketWrapper, endpoint);\n        outputBuffer.init(socketWrapper, endpoint);\n\n        // Error flag\n        error = false;\n        keepAlive = true;\n        comet = false;\n        openSocket = false;\n        sendfileInProgress = false;\n        readComplete = true;\n\n        int soTimeout = endpoint.getSoTimeout();\n\n        if (disableKeepAlive()) {\n            socketWrapper.setKeepAliveLeft(0);\n        }\n\n        boolean keptAlive = socketWrapper.isKeptAlive();\n\n        while (!error && keepAlive && !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                int standardTimeout = 0;\n                if (keptAlive) {\n                    if (keepAliveTimeout > 0) {\n                        standardTimeout = keepAliveTimeout;\n                    } else if (soTimeout > 0) {\n                        standardTimeout = soTimeout;\n                    }\n                }\n                /*\n                 * When there is no data in the buffer and this is not the first\n                 * request on this connection and timeouts are being used the\n                 * first read for this request may need a different timeout to\n                 * take account of time spent waiting for a processing thread.\n                 * \n                 * This is a little hacky but better than exposing the socket\n                 * and the timeout info to the InputBuffer\n                 */\n                if (inputBuffer.lastValid == 0 &&\n                        socketWrapper.getLastAccess() > -1 &&\n                        standardTimeout > 0) {\n\n                    long queueTime = System.currentTimeMillis() -\n                            socketWrapper.getLastAccess();\n                    int firstReadTimeout;\n                    if (queueTime >= standardTimeout) {\n                        // Queued for longer than timeout but there might be\n                        // data so use shortest possible timeout\n                        firstReadTimeout = 1;\n                    } else {\n                        // Cast is safe since queueTime must be less than\n                        // standardTimeout which is an int\n                        firstReadTimeout = standardTimeout - (int) queueTime;\n                    }\n                    socket.getSocket().setSoTimeout(firstReadTimeout);\n                    if (!inputBuffer.fill()) {\n                        throw new EOFException(sm.getString(\"iib.eof.error\"));\n                    }\n                }\n                if (standardTimeout > 0) {\n                    socket.getSocket().setSoTimeout(standardTimeout);\n                }\n\n                inputBuffer.parseRequestLine(false);\n                if (endpoint.isPaused()) {\n                    // 503 - Service unavailable\n                    response.setStatus(503);\n                    adapter.log(request, response, 0);\n                    error = true;\n                } else {\n                    request.setStartTime(System.currentTimeMillis());\n                    keptAlive = true;\n                    if (disableUploadTimeout) {\n                        socket.getSocket().setSoTimeout(soTimeout);\n                    } else {\n                        socket.getSocket().setSoTimeout(connectionUploadTimeout);\n                    }\n                    inputBuffer.parseHeaders();\n                }\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (maxKeepAliveRequests == 1) {\n                keepAlive = false;\n            } else if (maxKeepAliveRequests > 0 &&\n                    socketWrapper.decrementKeepAlive() <= 0) {\n                keepAlive = false;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                (!isAsync() &&\n                                statusDropsConnection(response.getStatus()));\n                    }\n\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n\n            if(!isAsync() && !comet) {\n                if (error) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    inputBuffer.setSwallowInput(false);\n                }\n                endRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            // Next request\n            if (!isAsync() || error) {\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            if (breakKeepAliveLoop(socketWrapper)) {\n                break;\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (comet || isAsync()) {\n            return SocketState.LONG;\n        } else {\n            if (sendfileInProgress) {\n                return SocketState.SENDFILE;\n            } else {\n                if (openSocket) {\n                    if (readComplete) {\n                        return SocketState.OPEN;\n                    } else {\n                        return SocketState.LONG;\n                    }\n                } else {\n                    return SocketState.CLOSED;\n                }\n            }\n        }\n    }","commit_id":"8c720fe30b6dcf98e53d1c53a67c7854ce3e016a","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @throws IOException error during an I/O operation\n     */\n    public SocketState process(NioChannel socket)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socket;\n        readBuffer = socket.getBufHandler().getReadBuffer();\n        writeBuffer = socket.getBufHandler().getWriteBuffer();\n        \n        int soTimeout = -1;\n        final KeyAttachment ka = (KeyAttachment)socket.getAttachment(false);\n        if (keepAliveTimeout > 0) {\n            ka.setTimeout(soTimeout);\n        }\n\n        // Error flag\n        error = false;\n\n        while (!error && !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                // Set keep alive timeout if enabled\n                if (keepAliveTimeout > 0) {\n                    ka.setTimeout(keepAliveTimeout);\n                }\n                // Get first message of the request\n                if (!readMessage(requestHeaderMessage)) {\n                    // This means a connection timeout\n                    rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n                    break;\n                }\n                // Set back timeout if keep alive timeout is enabled\n                if (keepAliveTimeout > 0) {\n                    ka.setTimeout(soTimeout);\n                }\n                // Check message type, process right away and break if\n                // not regular request processing\n                int type = requestHeaderMessage.getByte();\n                if (type == Constants.JK_AJP13_CPING_REQUEST) {\n                    try {\n                        output(pongMessageArray, 0, pongMessageArray.length);\n                    } catch (IOException e) {\n                        error = true;\n                    }\n                    recycle();\n                    continue;\n                } else if(type != Constants.JK_AJP13_FORWARD_REQUEST) {\n                    // Usually the servlet didn't read the previous request body\n                    if(log.isDebugEnabled()) {\n                        log.debug(\"Unexpected message: \"+type);\n                    }\n                    recycle();\n                    continue;\n                }\n\n                request.setStartTime(System.currentTimeMillis());\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.debug(sm.getString(\"ajpprocessor.header.error\"), t);\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.debug(sm.getString(\"ajpprocessor.request.prepare\"), t);\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (endpoint.isPaused()) {\n                // 503 - Service unavailable\n                response.setStatus(503);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"ajpprocessor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n            \n            if (isAsync() && !error) {\n                break;\n            }\n\n            // Finish the response if not done yet\n            if (!finished) {\n                try {\n                    finish();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    error = true;\n                }\n            }\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n            recycle();\n        }\n        \n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (isAsync() && !error && !endpoint.isPaused()) {\n            return SocketState.LONG;\n        } else {\n            readBuffer = null;\n            writeBuffer = null;\n            return SocketState.CLOSED;\n        }\n        \n    }","id":28515,"modified_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @throws IOException error during an I/O operation\n     */\n    public SocketState process(NioChannel socket)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socket;\n        readBuffer = socket.getBufHandler().getReadBuffer();\n        writeBuffer = socket.getBufHandler().getWriteBuffer();\n        \n        int soTimeout = -1;\n        final KeyAttachment ka = (KeyAttachment)socket.getAttachment(false);\n        if (keepAliveTimeout > 0) {\n            ka.setTimeout(soTimeout);\n        }\n\n        // Error flag\n        error = false;\n\n        boolean keptAlive = false;\n\n        while (!error && !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                // Set keep alive timeout if enabled\n                if (keepAliveTimeout > 0) {\n                    ka.setTimeout(keepAliveTimeout);\n                }\n                // Get first message of the request\n                int bytesRead = readMessage(requestHeaderMessage, !keptAlive);\n                if (!keptAlive && bytesRead == 0) {\n                    // No bytes on a blocking read - connection timeout\n                    rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n                    break;\n                }\n                // Set back timeout if keep alive timeout is enabled\n                if (keepAliveTimeout > 0) {\n                    ka.setTimeout(soTimeout);\n                }\n                // Check message type, process right away and break if\n                // not regular request processing\n                int type = requestHeaderMessage.getByte();\n                if (type == Constants.JK_AJP13_CPING_REQUEST) {\n                    try {\n                        output(pongMessageArray, 0, pongMessageArray.length);\n                    } catch (IOException e) {\n                        error = true;\n                    }\n                    // Should be unnecessary but just in case...\n                    keptAlive = true;\n                    recycle();\n                    continue;\n                } else if(type != Constants.JK_AJP13_FORWARD_REQUEST) {\n                    // Usually the servlet didn't read the previous request body\n                    if(log.isDebugEnabled()) {\n                        log.debug(\"Unexpected message: \"+type);\n                    }\n                    // Should be unnecessary but just in case...\n                    keptAlive = true;\n                    recycle();\n                    continue;\n                }\n\n                request.setStartTime(System.currentTimeMillis());\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.debug(sm.getString(\"ajpprocessor.header.error\"), t);\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.debug(sm.getString(\"ajpprocessor.request.prepare\"), t);\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (endpoint.isPaused()) {\n                // 503 - Service unavailable\n                response.setStatus(503);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"ajpprocessor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n            \n            if (isAsync() && !error) {\n                break;\n            }\n\n            // Finish the response if not done yet\n            if (!finished) {\n                try {\n                    finish();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    error = true;\n                }\n            }\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n            keptAlive = true;\n            recycle();\n        }\n        \n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (!error && !endpoint.isPaused()) {\n            if (isAsync()) {\n                return SocketState.LONG;\n            } else {\n                return SocketState.OPEN;\n            }\n        } else {\n            readBuffer = null;\n            writeBuffer = null;\n            return SocketState.CLOSED;\n        }\n        \n    }","commit_id":"33f79423e529294ee7f8afd2b14e97d2e1fcf958","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Read at least the specified amount of bytes, and place them\n     * in the input buffer.\n     */\n    protected void read(byte[] buf, int pos, int n)\n        throws IOException {\n\n        int read = readBufferEnd - pos;\n        int res = 0;\n        while (read < n) {\n            res = readSocket(buf, read + pos, true);\n            if (res > 0) {\n                read += res;\n            } else {\n                throw new IOException(sm.getString(\"ajpprotocol.failedread\"));\n            }\n        }\n        readBufferEnd += read;\n    }","id":28516,"modified_method":"/**\n     * Read at least the specified amount of bytes, and place them\n     * in the input buffer.\n     */\n    protected int read(byte[] buf, int pos, int n, boolean block)\n        throws IOException {\n\n        int read = readBufferEnd - pos;\n        int res = 0;\n        while (read < n) {\n            res = readSocket(buf, read + pos, block);\n            if (res > 0) {\n                read += res;\n            } else {\n                throw new IOException(sm.getString(\"ajpprotocol.failedread\"));\n            }\n        }\n        readBufferEnd += read;\n        return read;\n    }","commit_id":"33f79423e529294ee7f8afd2b14e97d2e1fcf958","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Read an AJP message.\n     *\n     * @return true if the message has been read, false if the short read\n     *         didn't return anything\n     * @throws IOException any other failure, including incomplete reads\n     */\n    protected boolean readMessage(AjpMessage message)\n        throws IOException {\n\n        byte[] buf = message.getBuffer();\n        int headerLength = message.getHeaderLength();\n\n        read(buf, 0, headerLength);\n\n        int messageLength = message.processHeader();\n        if (messageLength < 0) {\n            // Invalid AJP header signature\n            // TODO: Throw some exception and close the connection to frontend.\n            return false;\n        }\n        else if (messageLength == 0) {\n            // Zero length message.\n            return true;\n        }\n        else {\n            if (messageLength > buf.length) {\n                // Message too long for the buffer\n                // Need to trigger a 400 response\n                throw new IllegalArgumentException(sm.getString(\n                        \"ajpprocessor.header.tooLong\",\n                        Integer.valueOf(messageLength),\n                        Integer.valueOf(buf.length)));\n            }\n            read(buf, headerLength, messageLength);\n            return true;\n        }\n    }","id":28517,"modified_method":"/**\n     * Read an AJP message.\n     *\n     * @return The number of bytes read\n     * @throws IOException any other failure, including incomplete reads\n     */\n    protected int readMessage(AjpMessage message, boolean block)\n        throws IOException {\n\n        byte[] buf = message.getBuffer();\n        int headerLength = message.getHeaderLength();\n\n        int bytesRead = read(buf, 0, headerLength, block);\n\n        int messageLength = message.processHeader();\n        if (messageLength < 0) {\n            // Invalid AJP header signature\n            throw new IOException(sm.getString(\"ajpmessage.invalidLength\",\n                    Integer.valueOf(messageLength)));\n        }\n        else if (messageLength == 0) {\n            // Zero length message.\n            return bytesRead;\n        }\n        else {\n            if (messageLength > buf.length) {\n                // Message too long for the buffer\n                // Need to trigger a 400 response\n                throw new IllegalArgumentException(sm.getString(\n                        \"ajpprocessor.header.tooLong\",\n                        Integer.valueOf(messageLength),\n                        Integer.valueOf(buf.length)));\n            }\n            bytesRead += read(buf, headerLength, messageLength, true);\n            return bytesRead;\n        }\n    }","commit_id":"33f79423e529294ee7f8afd2b14e97d2e1fcf958","url":"https://github.com/apache/tomcat"},{"original_method":"/** Receive a chunk of data. Called to implement the\n     *  'special' packet in ajp13 and to receive the data\n     *  after we send a GET_BODY packet\n     */\n    @Override\n    public boolean receive() throws IOException {\n\n        first = false;\n        bodyMessage.reset();\n        if (!readMessage(bodyMessage)) {\n            // Invalid message\n            return false;\n        }\n        // No data received.\n        if (bodyMessage.getLen() == 0) {\n            // just the header\n            // Don't mark 'end of stream' for the first chunk.\n            return false;\n        }\n        int blen = bodyMessage.peekInt();\n        if (blen == 0) {\n            return false;\n        }\n\n        bodyMessage.getBytes(bodyBytes);\n        empty = false;\n        return true;\n    }","id":28518,"modified_method":"/** Receive a chunk of data. Called to implement the\n     *  'special' packet in ajp13 and to receive the data\n     *  after we send a GET_BODY packet\n     */\n    @Override\n    public boolean receive() throws IOException {\n\n        first = false;\n        bodyMessage.reset();\n        \n        readMessage(bodyMessage, true);\n\n        // No data received.\n        if (bodyMessage.getLen() == 0) {\n            // just the header\n            // Don't mark 'end of stream' for the first chunk.\n            return false;\n        }\n        int blen = bodyMessage.peekInt();\n        if (blen == 0) {\n            return false;\n        }\n\n        bodyMessage.getBytes(bodyBytes);\n        empty = false;\n        return true;\n    }","commit_id":"33f79423e529294ee7f8afd2b14e97d2e1fcf958","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     */\n    public SocketState asyncDispatch(SocketStatus status) {\n\n        RequestInfo rp = request.getRequestProcessor();\n        final NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getAttachment(false);\n        try {\n            rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n            error = !adapter.asyncDispatch(request, response, status);\n            if (!error && attach != null &&\n                    asyncStateMachine.isAsyncDispatching()) {\n                long soTimeout = endpoint.getSoTimeout();\n                int keepAliveTimeout = endpoint.getKeepAliveTimeout();\n\n                //reset the timeout\n                if (keepAlive && keepAliveTimeout>0) {\n                    attach.setTimeout(keepAliveTimeout);\n                } else {\n                    attach.setTimeout(soTimeout);\n                }\n            }\n        } catch (InterruptedIOException e) {\n            error = true;\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.error(sm.getString(\"http11processor.request.process\"), t);\n            error = true;\n        } finally {\n            if (error) {\n                // 500 - Internal Server Error\n                response.setStatus(500);\n                adapter.log(request, response, 0);\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error) {\n            return SocketState.CLOSED;\n        } else if (!isAsync()) {\n            return (keepAlive)?SocketState.OPEN:SocketState.CLOSED;\n        } else {\n            return SocketState.LONG;\n        }\n    }","id":28519,"modified_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     */\n    public SocketState asyncDispatch(SocketStatus status) {\n\n        RequestInfo rp = request.getRequestProcessor();\n        final NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getAttachment(false);\n        try {\n            rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n            error = !adapter.asyncDispatch(request, response, status);\n            if (!error && attach != null &&\n                    asyncStateMachine.isAsyncDispatching()) {\n                long soTimeout = endpoint.getSoTimeout();\n                int keepAliveTimeout = endpoint.getKeepAliveTimeout();\n\n                //reset the timeout\n                if (keepAlive && keepAliveTimeout>0) {\n                    attach.setTimeout(keepAliveTimeout);\n                } else {\n                    attach.setTimeout(soTimeout);\n                }\n            }\n        } catch (InterruptedIOException e) {\n            error = true;\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.error(sm.getString(\"http11processor.request.process\"), t);\n            error = true;\n        } finally {\n            if (error) {\n                // 500 - Internal Server Error\n                response.setStatus(500);\n                adapter.log(request, response, 0);\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error) {\n            return SocketState.CLOSED;\n        } else if (isAsync()) {\n            return SocketState.LONG;\n        } else {\n            if (!keepAlive) {\n                return SocketState.CLOSED;\n            } else {\n                return SocketState.OPEN;\n            }\n        }\n    }","commit_id":"ff48512975f1fc1e5c71146d80212b9268204e7c","url":"https://github.com/apache/tomcat"},{"original_method":"private TreeModel build(final Set<PsiFile> files, boolean showProgress) {\n    if (files.size() == 1) {\n      myShowFiles = true;\n    }\n\n    Runnable buildingRunnable = new Runnable() {\n      public void run() {\n        for (final PsiFile file : files) {\n          if (file != null) {\n            buildFileNode(file);\n          }\n        }\n      }\n    };\n\n    if (showProgress) {\n      ProgressManager.getInstance().runProcessWithProgressSynchronously(buildingRunnable, AnalysisScopeBundle.message(\"package.dependencies.build.process.title\"), false, myProject);\n    }\n    else {\n      buildingRunnable.run();\n    }\n\n    TreeUtil.sort(myRoot, new DependencyNodeComparator());\n    return new TreeModel(myRoot, myTotalFileCount, myMarkedFileCount);\n  }","id":28520,"modified_method":"private TreeModel build(final Set<PsiFile> files, boolean showProgress) {\n    if (files.size() == 1) {\n      myShowFiles = true;\n    }\n\n    Runnable buildingRunnable = new Runnable() {\n      public void run() {\n        for (final PsiFile file : files) {\n          if (file != null) {\n            buildFileNode(file, null);\n          }\n        }\n      }\n    };\n\n    if (showProgress) {\n      ProgressManager.getInstance().runProcessWithProgressSynchronously(buildingRunnable, AnalysisScopeBundle.message(\"package.dependencies.build.process.title\"), false, myProject);\n    }\n    else {\n      buildingRunnable.run();\n    }\n\n    TreeUtil.sort(myRoot, new DependencyNodeComparator());\n    return new TreeModel(myRoot, myTotalFileCount, myMarkedFileCount);\n  }","commit_id":"ee817a280ea4828f2146687833096328eb25ce46","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildFileNode(PsiFile file) {\n    ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    if (indicator != null) {\n      indicator.setIndeterminate(false);\n      indicator.setText(AnalysisScopeBundle.message(\"package.dependencies.build.progress.text\"));\n      final VirtualFile virtualFile = file.getVirtualFile();\n      if (virtualFile != null) {\n        indicator.setText2(virtualFile.getPresentableUrl());\n      }\n      indicator.setFraction(((double)myScannedFileCount++) / myTotalFileCount);\n    }\n\n    if (file == null || !file.isValid()) return;\n    boolean isMarked = myMarker != null && myMarker.isMarked(file);\n    if (isMarked) myMarkedFileCount++;\n    if (isMarked || myAddUnmarkedFiles) {\n      PackageDependenciesNode dirNode = getFileParentNode(file);\n      if (dirNode == null) return;\n\n      if (myShowFiles) {\n        FileNode fileNode = new FileNode(file, isMarked);\n        dirNode.add(fileNode);\n      }\n      else {\n        dirNode.addFile(file, isMarked);\n      }\n    }\n  }","id":28521,"modified_method":"@Nullable\n  private PackageDependenciesNode buildFileNode(PsiFile file, @Nullable PackageDependenciesNode parent) {\n    ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    if (indicator != null) {\n      indicator.setIndeterminate(false);\n      indicator.setText(AnalysisScopeBundle.message(\"package.dependencies.build.progress.text\"));\n      final VirtualFile virtualFile = file.getVirtualFile();\n      if (virtualFile != null) {\n        indicator.setText2(virtualFile.getPresentableUrl());\n      }\n      indicator.setFraction(((double)myScannedFileCount++) / myTotalFileCount);\n    }\n\n    if (file == null || !file.isValid()) return null;\n    boolean isMarked = myMarker != null && myMarker.isMarked(file);\n    if (isMarked) myMarkedFileCount++;\n    if (isMarked || myAddUnmarkedFiles) {\n      PackageDependenciesNode dirNode = parent != null ? parent : getFileParentNode(file);\n      if (dirNode == null) return null;\n\n      if (myShowFiles) {\n        FileNode fileNode = new FileNode(file, isMarked);\n        dirNode.add(fileNode);\n      }\n      else {\n        dirNode.addFile(file, isMarked);\n      }\n      return dirNode;\n    }\n    return null;\n  }","commit_id":"ee817a280ea4828f2146687833096328eb25ce46","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processFilesRecursively(VirtualFile file, PsiManager psiManager) {\n    if (file.isDirectory()) {\n      VirtualFile[] children = file.getChildren();\n      for (VirtualFile aChildren : children) {\n        processFilesRecursively(aChildren, psiManager);\n      }\n    }\n    else {\n      final PsiFile psiFile = psiManager.findFile(file);\n      if (psiFile != null) { // skip inners & anonymous\n        buildFileNode(psiFile);\n      }\n    }\n  }","id":28522,"modified_method":"@Nullable\n  private PackageDependenciesNode processFilesRecursively(VirtualFile file, @Nullable PackageDependenciesNode parent, PsiManager psiManager) {\n    if (file.isDirectory()) {\n      VirtualFile[] children = file.getChildren();\n      PackageDependenciesNode dirNode = null;\n      for (VirtualFile aChildren : children) {\n        dirNode = processFilesRecursively(aChildren, dirNode, psiManager);\n      }\n    }\n    else {\n      final PsiFile psiFile = psiManager.findFile(file);\n      if (psiFile != null) { // skip inners & anonymous\n        return buildFileNode(psiFile, parent);\n      }\n    }\n    return null;\n  }","commit_id":"ee817a280ea4828f2146687833096328eb25ce46","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeModel build(final Project project, final boolean showProgress, final boolean sortByType) {\n    Runnable buildingRunnable = new Runnable() {\n      public void run() {\n        countFiles(project);\n        final PsiManager psiManager = PsiManager.getInstance(project);\n        myFileIndex.iterateContent(new ContentIterator() {\n          public boolean processFile(VirtualFile fileOrDir) {\n            if (!fileOrDir.isDirectory()) {\n              final PsiFile psiFile = psiManager.findFile(fileOrDir);\n              if (psiFile != null) {\n                buildFileNode(psiFile);\n              }\n            }\n            return true;\n          }\n        });\n\n        for (VirtualFile root : LibraryUtil.getLibraryRoots(project)) {\n          processFilesRecursively(root, psiManager);\n        }\n      }\n    };\n\n    if (showProgress) {\n      ProgressManager.getInstance().runProcessWithProgressSynchronously(buildingRunnable, AnalysisScopeBundle.message(\"package.dependencies.build.process.title\"), true, project);\n    }\n    else {\n      buildingRunnable.run();\n    }\n\n    TreeUtil.sort(myRoot, new DependencyNodeComparator(sortByType));\n    return new TreeModel(myRoot, myTotalFileCount, myMarkedFileCount);\n  }","id":28523,"modified_method":"public TreeModel build(final Project project, final boolean showProgress, final boolean sortByType) {\n    Runnable buildingRunnable = new Runnable() {\n      public void run() {\n        countFiles(project);\n        final PsiManager psiManager = PsiManager.getInstance(project);\n        myFileIndex.iterateContent(new ContentIterator() {\n          PackageDependenciesNode lastParent = null;\n          public boolean processFile(VirtualFile fileOrDir) {\n            if (!fileOrDir.isDirectory()) {\n              final PsiFile psiFile = psiManager.findFile(fileOrDir);\n              if (psiFile != null) {\n                lastParent = buildFileNode(psiFile, lastParent);\n              }\n            } else {\n              lastParent = null;\n            }\n            return true;\n          }\n        });\n\n        for (VirtualFile root : LibraryUtil.getLibraryRoots(project)) {\n          processFilesRecursively(root, null, psiManager);\n        }\n      }\n    };\n\n    if (showProgress) {\n      ProgressManager.getInstance().runProcessWithProgressSynchronously(buildingRunnable, AnalysisScopeBundle.message(\"package.dependencies.build.process.title\"), true, project);\n    }\n    else {\n      buildingRunnable.run();\n    }\n\n    TreeUtil.sort(myRoot, new DependencyNodeComparator(sortByType));\n    return new TreeModel(myRoot, myTotalFileCount, myMarkedFileCount);\n  }","commit_id":"ee817a280ea4828f2146687833096328eb25ce46","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void after(final List<? extends VFileEvent> events) {\n\n      Application application = ApplicationManager.getApplication();\n      if (application.isDisposeInProgress() || application.isDisposed()) {\n        return;\n      }\n\n      final ReloadSession reloadSession = new ReloadSession();\n\n      // collecting changed models, modules etc.\n      for (final VFileEvent event : events) {\n        String path = event.getPath();\n        File file = new File(path);\n        FileUtil.processFilesRecursively(file, new Processor<File>() {\n          public boolean process(File file) {\n            String filePath = file.getAbsolutePath();\n            if (MPSFileTypesManager.instance().isModelFile(filePath)) {\n              ModelFileProcessor.getInstance().process(new VFileEventDecorator(event, filePath), reloadSession);\n            } else if (MPSFileTypesManager.instance().isModuleFile(filePath)) {\n              ModuleFileProcessor.getInstance().process(new VFileEventDecorator(event, filePath), reloadSession);\n            }\n            return true;\n          }\n        });\n        if (MPSFileTypesManager.instance().isModelFile(path)) {\n          ModelFileProcessor.getInstance().process(event, reloadSession);\n        } else if (MPSFileTypesManager.instance().isModuleFile(path)) {\n          ModuleFileProcessor.getInstance().process(event, reloadSession);\n        }\n      }\n\n      // reloading\n      application.invokeLater(new Runnable() {\n        public void run() {\n          reloadSession.doReload();\n        }\n      }, ModalityState.NON_MODAL);\n    }","id":28524,"modified_method":"public void after(final List<? extends VFileEvent> events) {\n\n      Application application = ApplicationManager.getApplication();\n      if (application.isDisposeInProgress() || application.isDisposed()) {\n        return;\n      }\n\n      final ReloadSession reloadSession = new ReloadSession();\n\n      // collecting changed models, modules etc.\n      for (final VFileEvent event : events) {\n        String path = event.getPath();\n        File file = new File(path);\n        if (file.isDirectory() && file.exists()) {\n          FileUtil.processFilesRecursively(file, new Processor<File>() {\n            public boolean process(File file) {\n              String filePath = file.getAbsolutePath();\n              if (MPSFileTypesManager.instance().isModelFile(filePath)) {\n                ModelFileProcessor.getInstance().process(new VFileEventDecorator(event, filePath), reloadSession);\n              } else if (MPSFileTypesManager.instance().isModuleFile(filePath)) {\n                ModuleFileProcessor.getInstance().process(new VFileEventDecorator(event, filePath), reloadSession);\n              }\n              return true;\n            }\n          });\n        }\n        if (MPSFileTypesManager.instance().isModelFile(path)) {\n          ModelFileProcessor.getInstance().process(event, reloadSession);\n        } else if (MPSFileTypesManager.instance().isModuleFile(path)) {\n          ModuleFileProcessor.getInstance().process(event, reloadSession);\n        }\n      }\n\n      // reloading\n      application.invokeLater(new Runnable() {\n        public void run() {\n          reloadSession.doReload();\n        }\n      }, ModalityState.NON_MODAL);\n    }","commit_id":"082e57baf6c61c36dc22d7c174400df782c22fff","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void writeRuntimeToJar(final JarOutputStream stream) throws IOException {\n        URL url = KotlinCompiler.class.getClassLoader().getResource(\"jet/JetObject.class\");\n        if (url == null) {\n            System.out.println(\"Couldn't find runtime library\");\n            return;\n        }\n        final String protocol = url.getProtocol();\n        final String path = url.getPath();\n        if (protocol.equals(\"file\")) {   // unpacked runtime\n            final File stdlibDir = new File(path).getParentFile().getParentFile();\n            FileUtil.processFilesRecursively(stdlibDir, new Processor<File>() {\n                @Override\n                public boolean process(File file) {\n                    if (file.isDirectory()) return true;\n                    final String relativePath = FileUtil.getRelativePath(stdlibDir, file);\n                    try {\n                        stream.putNextEntry(new JarEntry(FileUtil.toSystemIndependentName(relativePath)));\n                        FileInputStream fis = new FileInputStream(file);\n                        try {\n                            FileUtil.copy(fis, stream);\n                        } finally {\n                            fis.close();\n                        }\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    return true;\n                }\n            });\n        }\n        else if (protocol.equals(\"jar\")) {\n            File jar = new File(path.substring(path.indexOf(\":\") + 1, path.indexOf(\"!/\")));\n            JarInputStream jis = new JarInputStream(new FileInputStream(jar));\n            try {\n                while (true) {\n                    JarEntry e = jis.getNextJarEntry();\n                    if (e == null) {\n                        break;\n                    }\n                    stream.putNextEntry(e);\n                    FileUtil.copy(jis, stream);\n                }\n            } finally {\n                jis.close();\n            }\n        }\n        else {\n            System.out.println(\"Couldn't copy runtime library from \" + url + \", protocol \" + protocol);\n        }\n    }","id":28525,"modified_method":"private static void writeRuntimeToJar(final JarOutputStream stream) throws IOException {\n        final File unpackedRuntimePath = getUnpackedRuntimePath();\n        if (unpackedRuntimePath != null) {\n            FileUtil.processFilesRecursively(unpackedRuntimePath, new Processor<File>() {\n                @Override\n                public boolean process(File file) {\n                    if (file.isDirectory()) return true;\n                    final String relativePath = FileUtil.getRelativePath(unpackedRuntimePath, file);\n                    try {\n                        stream.putNextEntry(new JarEntry(FileUtil.toSystemIndependentName(relativePath)));\n                        FileInputStream fis = new FileInputStream(file);\n                        try {\n                            FileUtil.copy(fis, stream);\n                        } finally {\n                            fis.close();\n                        }\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    return true;\n                }\n            });\n        }\n        else {\n            File runtimeJarPath = getRuntimeJarPath();\n            if (runtimeJarPath != null) {\n                JarInputStream jis = new JarInputStream(new FileInputStream(runtimeJarPath));\n                try {\n                    while (true) {\n                        JarEntry e = jis.getNextJarEntry();\n                        if (e == null) {\n                            break;\n                        }\n                        if (FileUtil.getExtension(e.getName()).equals(\"class\")) {\n                            stream.putNextEntry(e);\n                            FileUtil.copy(jis, stream);\n                        }\n                    }\n                } finally {\n                    jis.close();\n                }\n            }\n            else {\n                System.out.println(\"Couldn't find runtime library\");\n            }\n        }\n    }","commit_id":"344dea0ad580e305da1e415583bdccca2a168e67","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void main(String[] args) {\n        System.setProperty(\"java.awt.headless\", \"true\");\n        Arguments arguments = new Arguments();\n        try {\n            Args.parse(arguments, args);\n        }\n        catch (Throwable t) {\n            System.out.println(\"Usage: KotlinCompiler [-output <outputDir>|-jar <jarFileName>] -src <filename or dirname>\");\n            t.printStackTrace();\n            return;\n        }\n\n        Disposable root = new Disposable() {\n            @Override\n            public void dispose() {\n            }\n        };\n        JetCoreEnvironment environment = new JetCoreEnvironment(root);\n\n        File rtJar = initJdk();\n        if (rtJar == null) return;\n\n        environment.addToClasspath(rtJar);\n\n        VirtualFile vFile = environment.getLocalFileSystem().findFileByPath(arguments.src);\n        if (vFile == null) {\n            System.out.print(\"File/directory not found: \" + arguments.src);\n            return;\n        }\n\n        Project project = environment.getProject();\n        GenerationState generationState = new GenerationState(project, false);\n        List<JetNamespace> namespaces = Lists.newArrayList();\n        String mainClass = null;\n        if(vFile.isDirectory())  {\n            File dir = new File(vFile.getPath());\n            addFiles(environment, project, namespaces, dir);\n        }\n        else {\n            PsiFile psiFile = PsiManager.getInstance(project).findFile(vFile);\n            if (psiFile instanceof JetFile) {\n                final JetNamespace namespace = ((JetFile) psiFile).getRootNamespace();\n                if (JetMainDetector.hasMain(namespace.getDeclarations())) {\n                    mainClass = namespace.getFQName() + \".namespace\";\n                }\n                namespaces.add(namespace);\n            }\n            else {\n                System.out.print(\"Not a Kotlin file: \" + vFile.getPath());\n                return;\n            }\n        }\n\n        BindingContext bindingContext = AnalyzingUtils.getInstance(JavaDefaultImports.JAVA_DEFAULT_IMPORTS).analyzeNamespaces(project, namespaces, JetControlFlowDataTraceFactory.EMPTY);\n\n        ErrorCollector errorCollector = new ErrorCollector(bindingContext);\n        errorCollector.report();\n\n        if (!errorCollector.hasErrors) {\n            generationState.compileCorrectNamespaces(bindingContext, namespaces);\n\n            final ClassFileFactory factory = generationState.getFactory();\n            if (arguments.jar != null) {\n                writeToJar(factory, arguments.jar, mainClass, true);\n            }\n            else if (arguments.outputDir != null) {\n                writeToOutputDirectory(factory, arguments.outputDir);\n            }\n            else {\n                System.out.println(\"Output directory or jar file is not specified - no files will be saved to the disk\");\n            }\n        }\n\n    }","id":28526,"modified_method":"public static void main(String[] args) {\n        System.setProperty(\"java.awt.headless\", \"true\");\n        Arguments arguments = new Arguments();\n        try {\n            Args.parse(arguments, args);\n        }\n        catch (Throwable t) {\n            System.out.println(\"Usage: KotlinCompiler [-output <outputDir>|-jar <jarFileName>] -src <filename or dirname>\");\n            t.printStackTrace();\n            return;\n        }\n\n        Disposable root = new Disposable() {\n            @Override\n            public void dispose() {\n            }\n        };\n        JetCoreEnvironment environment = new JetCoreEnvironment(root);\n\n        File rtJar = initJdk();\n        if (rtJar == null) return;\n\n        environment.addToClasspath(rtJar);\n        final File unpackedRuntimePath = getUnpackedRuntimePath();\n        if (unpackedRuntimePath != null) {\n            environment.addToClasspath(unpackedRuntimePath);\n        }\n\n        if (arguments.module != null) {\n            compileModule(environment, arguments.module);\n            return;\n        }\n\n        CompileSession session = new CompileSession(environment);\n        session.addSources(arguments.src);\n\n        String mainClass = null;\n        for (JetNamespace namespace : session.getSourceFileNamespaces()) {\n            if (JetMainDetector.hasMain(namespace.getDeclarations())) {\n                mainClass = namespace.getFQName() + \".namespace\";\n                break;\n            }\n        }\n        if (!session.analyze()) {\n            return;\n        }\n\n        ClassFileFactory factory = session.generate();\n        if (arguments.jar != null) {\n            writeToJar(factory, arguments.jar, mainClass, true);\n        }\n        else if (arguments.outputDir != null) {\n            writeToOutputDirectory(factory, arguments.outputDir);\n        }\n        else {\n            System.out.println(\"Output directory or jar file is not specified - no files will be saved to the disk\");\n        }\n    }","commit_id":"344dea0ad580e305da1e415583bdccca2a168e67","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public String toString() {\n        String s = \"DirectoryScanner\";\n        if (dir != null) {\n            s = s + \" scanning dir: \" + dir.getPath();\n        }\n        if (currentList != null) {\n            s = s + \" found \" + currentList.length + \" file(s).\";            \n        }\n        return s;\n    }","id":28527,"modified_method":"public String toString() {\n\t\tString s = \"DirectoryScanner\";\n\t\tif (dir != null) {\n\t\t\ts = s + \" scanning dir: \" + dir.getPath();\n\t\t}\n\t\tif (scanner != null && scanner.files != null) {\n\t\t\ts = s + \" found \" + scanner.files.length + \" file(s).\";\n\t\t}\n\t\treturn s;\n\t}","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"void configure(Properties config) {\n        String d = config.getProperty( RuleAgent.DIRECTORY );\n\n        //now check to see whats in them dir...\n        dir = new File( d );\n        if ( !(dir.isDirectory() && dir.exists()) ) {\n            throw new IllegalArgumentException( \"The directory \" + d + \"is not valid.\" );\n        }\n\n        this.currentList = dir.listFiles();\n        scanner = new FileScanner();\n        scanner.setFiles( currentList );\n\n    }","id":28528,"modified_method":"void configure(Properties config) {\n\t\tString d = config.getProperty(RuleAgent.DIRECTORY);\n\n\t\t// now check to see whats in them dir...\n\t\tdir = new File(d);\n\t\tif (!(dir.isDirectory() && dir.exists())) {\n\t\t\tthrow new IllegalArgumentException(\"The directory \" + d\n\t\t\t\t\t+ \"is not valid.\");\n\t\t}\n\t\t\n\t\tscanner = new FileScanner();\n\t\tscanner.setFiles( dir.listFiles() );\n\n\t}","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"Package[] loadPackageChanges()  {\n        if ( currentList.length != dir.listFiles().length ) {\n            listener.info( \"Extra files detected in the directory \" + dir.getPath() );\n            currentList = dir.listFiles();\n            scanner = new FileScanner();\n            scanner.setFiles( currentList );\n        }\n        return scanner.loadPackageChanges();\n    }","id":28529,"modified_method":"PackageChangeInfo loadPackageChanges() {\n\t\t\n\t\tMap<String, String> pathToPackage = scanner.pathToPackage;\n\t\tCollection<String> removedPackageNames = new ArrayList<String>();\n\t\t\n\t\tif( pathToPackage != null ) {\n\t\t\tMap<String,String> tempPathToPackage = new HashMap<String, String>();\n\t\t\t\n\t\t\tFile[] files = dir.listFiles();\n\t\t\tfor (int i = 0; i < files.length; i++) {\n\t\t\t\tFile f = files[i];\n\t\t\t\tString path = f.getPath();\n\t\t\t\t\n\t\t\t\tif (pathToPackage.containsKey(path)) {\n\n\t\t\t\t\ttempPathToPackage.put(path, pathToPackage.get(path));\n\t\t\t\t\tpathToPackage.remove(path);\n\t\t\t\t} \n\t\t\t}\n\t\t\t\n\t\t\tif( pathToPackage.size() > 0 || files.length != tempPathToPackage.size() ) {\n\t\t\t\tremovedPackageNames.addAll( pathToPackage.values() );\n\t\t\t\t\n\t\t\t\tlistener.info(\"File changes detected in the directory \"\n\t\t\t\t\t\t+ dir.getPath());\n\t\t\t\t\n//\t\t\t\tscanner = new FileScanner();\n\t\t\t\tscanner.setFiles( files );\t\t\t\n\t\t\t}\n\t\t\n\t\t\tscanner.pathToPackage = tempPathToPackage;\n\t\t}\n\t\t\t\t\n\t\tPackageChangeInfo info = scanner.loadPackageChanges();\n\t\t\n\t\tinfo.addRemovedPackages(removedPackageNames);\n\t\t\n\t\treturn info;\n\t}","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testScan() throws Exception {\n        File dir = RuleBaseAssemblerTest.getTempDirectory();       \n        \n        Package p1 = new Package(\"p1\");\n        Package p2 = new Package(\"p2\");\n        File p1f = new File(dir, \"p1.pkg\");\n        File p2f = new File(dir, \"p2.pkg\");        \n        \n        RuleBaseAssemblerTest.writePackage( p1, p1f );\n        RuleBaseAssemblerTest.writePackage( p2, p2f);\n        \n        DirectoryScanner scan = new DirectoryScanner();\n        scan.listener = new MockListener();\n        Properties props = new Properties();\n        props.setProperty( RuleAgent.DIRECTORY, dir.getPath() );\n                \n        scan.configure( props );\n        \n        RuleBase rb = RuleBaseFactory.newRuleBase();\n        PackageProvider.applyChanges( rb, true, scan.loadPackageChanges(), new MockListener() );\n        \n        assertEquals(2, rb.getPackages().length);\n                \n        Package p3 = new Package(\"p3\");\n        File p3f = new File(dir, \"p3.pkg\");\n        \n        RuleBaseAssemblerTest.writePackage( p3, p3f );\n        \n        PackageProvider.applyChanges( rb, true, scan.loadPackageChanges(), new MockListener() );\n\n        assertEquals(3, rb.getPackages().length);        \n    }","id":28530,"modified_method":"public void testScan() throws Exception {\n\t\tFile dir = RuleBaseAssemblerTest.getTempDirectory();\n\n\t\tPackage p1 = new Package(\"p1\");\n\t\tPackage p2 = new Package(\"p2\");\n\t\tFile p1f = new File(dir, \"p1.pkg\");\n\t\tFile p2f = new File(dir, \"p2.pkg\");\n\n\t\tRuleBaseAssemblerTest.writePackage(p1, p1f);\n\t\tRuleBaseAssemblerTest.writePackage(p2, p2f);\n\n\t\tDirectoryScanner scan = new DirectoryScanner();\n\t\tscan.listener = new MockListener();\n\t\tProperties props = new Properties();\n\t\tprops.setProperty(RuleAgent.DIRECTORY, dir.getPath());\n\n\t\tscan.configure(props);\n\n\t\tRuleBase rb = RuleBaseFactory.newRuleBase();\n\t\tPackageProvider.applyChanges(rb, true, scan.loadPackageChanges().getChangedPackages(),\n\t\t\t\tnew MockListener());\n\n\t\tassertEquals(2, rb.getPackages().length);\n\n\t\tPackage p3 = new Package(\"p3\");\n\t\tFile p3f = new File(dir, \"p3.pkg\");\n\n\t\tRuleBaseAssemblerTest.writePackage(p3, p3f);\n\n\t\tPackageProvider.applyChanges(rb, true, scan.loadPackageChanges().getChangedPackages(),\n\t\t\t\tnew MockListener());\n\n\t\tassertEquals(3, rb.getPackages().length);\n\t}","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Calculate a change set, based on last updated times.\n     * (keep a map of files).\n     */\n    private Package[] getChangeSet() {\n        if ( this.files == null ) return new Package[0];\n        List list = new ArrayList();\n        for ( int i = 0; i < files.length; i++ ) {\n            File f = files[i];\n            if ( hasChanged( f.getPath(),\n                             this.lastUpdated,\n                             f.lastModified() ) ) {\n                Package p = readPackage( f );\n                if ( p != null ) list.add( p );\n            }\n        }\n        return (Package[]) list.toArray( new Package[list.size()] );\n    }","id":28531,"modified_method":"/**\n     * Calculate a change set, based on last updated times.\n     * (keep a map of files).\n     */\n    private PackageChangeInfo getChangeSet() {\n    \tPackageChangeInfo info = new PackageChangeInfo();\n        if ( this.files == null ) return info;\n        \n        if( pathToPackage == null ) pathToPackage = new HashMap<String,String>();\n        \n        for ( int i = 0; i < files.length; i++ ) {\n            File f = files[i];\n            \n            if( !f.exists() ){\n            \tString name = pathToPackage.get(f.getPath());\n            \tif( name != null ){\n            \t\tinfo.addRemovedPackage( name );\n            \t}\n            } else if ( hasChanged( f.getPath(),\n                             this.lastUpdated,\n                             f.lastModified() ) ) {\n                Package p = readPackage( f );\n                if ( p != null ) {\n                \tinfo.addPackage( p );\n                \tpathToPackage.put(f.getPath(), p.getName());\n                }\n            }\n        }\n        return info;\n    }","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Perform the scan.\n     * If there was an error reading the packages, this will not fail, it will\n     * just do nothing (as there may be a temporary IO issue).\n     */\n    Package[] loadPackageChanges() {\n        Package[] changes = getChangeSet();\n        return changes;\n    }","id":28532,"modified_method":"/**\n     * Perform the scan.\n     * If there was an error reading the packages, this will not fail, it will\n     * just do nothing (as there may be a temporary IO issue).\n     */\n    PackageChangeInfo loadPackageChanges() {\n    \tPackageChangeInfo changes = getChangeSet();\n        return changes;\n    }","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testEmptyList() throws Exception {\n        FileScanner scan = new FileScanner();\n        RuleBase rb = RuleBaseFactory.newRuleBase();\n        \n        PackageProvider.applyChanges( rb, true, scan.loadPackageChanges(), new MockListener() );\n\n        assertEquals(0, rb.getPackages().length);\n    }","id":28533,"modified_method":"public void testEmptyList() throws Exception {\n        FileScanner scan = new FileScanner();\n        RuleBase rb = RuleBaseFactory.newRuleBase();\n        \n        PackageProvider.applyChanges( rb, true, scan.loadPackageChanges().getChangedPackages(), new MockListener() );\n\n        assertEquals(0, rb.getPackages().length);\n    }","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testScanAndLoad() throws Exception {\n        Package p1 = new Package(\"p1\");\n        Package p2 = new Package(\"p2\");\n        \n        File dir = RuleBaseAssemblerTest.getTempDirectory();\n        File p1f = new File(dir, \"p1.pkg\");\n        File p2f = new File(dir, \"p2.pkg\");\n        \n        RuleBaseAssemblerTest.writePackage( p1, p1f );\n        RuleBaseAssemblerTest.writePackage( p2, p2f);\n        \n        FileScanner scan = new FileScanner();\n        Properties props = new Properties();\n        props.setProperty( RuleAgent.FILES, p1f.getPath() + \" \" + p2f.getPath() );\n        scan.configure( props );\n        \n        RuleBase rb = RuleBaseFactory.newRuleBase();\n        PackageProvider.applyChanges( rb, true, scan.loadPackageChanges(), new MockListener() );\n        \n        \n        \n        assertEquals(2, rb.getPackages().length);\n        assertTrue(\"p1\".equals(rb.getPackages()[0].getName()) || \"p1\".equals(rb.getPackages()[1].getName()));\n        assertTrue(\"p2\".equals(rb.getPackages()[0].getName()) || \"p2\".equals(rb.getPackages()[1].getName()));\n\n        PackageProvider.applyChanges( rb, true, scan.loadPackageChanges(), new MockListener() );\n        assertEquals(2, rb.getPackages().length);\n        assertTrue(\"p1\".equals(rb.getPackages()[0].getName()) || \"p1\".equals(rb.getPackages()[1].getName()));\n        assertTrue(\"p2\".equals(rb.getPackages()[0].getName()) || \"p2\".equals(rb.getPackages()[1].getName()));\n\n        RuleBaseAssemblerTest.writePackage( p2, p2f );\n        PackageProvider.applyChanges( rb, true, scan.loadPackageChanges(), new MockListener() );\n\n\n        assertEquals(2, rb.getPackages().length);\n        assertTrue(\"p1\".equals(rb.getPackages()[0].getName()) || \"p1\".equals(rb.getPackages()[1].getName()));\n        assertTrue(\"p2\".equals(rb.getPackages()[0].getName()) || \"p2\".equals(rb.getPackages()[1].getName()));\n        \n    }","id":28534,"modified_method":"public void testScanAndLoad() throws Exception {\n        Package p1 = new Package(\"p1\");\n        Package p2 = new Package(\"p2\");\n        \n        File dir = RuleBaseAssemblerTest.getTempDirectory();\n        File p1f = new File(dir, \"p1.pkg\");\n        File p2f = new File(dir, \"p2.pkg\");\n        \n        RuleBaseAssemblerTest.writePackage( p1, p1f );\n        RuleBaseAssemblerTest.writePackage( p2, p2f);\n        \n        FileScanner scan = new FileScanner();\n        Properties props = new Properties();\n        props.setProperty( RuleAgent.FILES, p1f.getPath() + \" \" + p2f.getPath() );\n        scan.configure( props );\n        \n        RuleBase rb = RuleBaseFactory.newRuleBase();\n        PackageProvider.applyChanges( rb, true, scan.loadPackageChanges().getChangedPackages(), new MockListener() );\n        \n        \n        \n        assertEquals(2, rb.getPackages().length);\n        assertTrue(\"p1\".equals(rb.getPackages()[0].getName()) || \"p1\".equals(rb.getPackages()[1].getName()));\n        assertTrue(\"p2\".equals(rb.getPackages()[0].getName()) || \"p2\".equals(rb.getPackages()[1].getName()));\n\n        PackageProvider.applyChanges( rb, true, scan.loadPackageChanges().getChangedPackages(), new MockListener() );\n        assertEquals(2, rb.getPackages().length);\n        assertTrue(\"p1\".equals(rb.getPackages()[0].getName()) || \"p1\".equals(rb.getPackages()[1].getName()));\n        assertTrue(\"p2\".equals(rb.getPackages()[0].getName()) || \"p2\".equals(rb.getPackages()[1].getName()));\n\n        RuleBaseAssemblerTest.writePackage( p2, p2f );\n        PackageProvider.applyChanges( rb, true, scan.loadPackageChanges().getChangedPackages(), new MockListener() );\n\n\n        assertEquals(2, rb.getPackages().length);\n        assertTrue(\"p1\".equals(rb.getPackages()[0].getName()) || \"p1\".equals(rb.getPackages()[1].getName()));\n        assertTrue(\"p2\".equals(rb.getPackages()[0].getName()) || \"p2\".equals(rb.getPackages()[1].getName()));\n        \n    }","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"static void applyChanges(RuleBase rb, boolean removeExistingPackages, Collection changes, AgentEventListener listener) {\n        rb.lock();\n        if ( changes == null ) return;\n        for ( Iterator iter = changes.iterator(); iter.hasNext(); ) {\n            Package p = (Package) iter.next();\n            \n            if ( removeExistingPackages ) {\n                removePackage( p.getName(),\n                               rb );\n            }\n            try {\n                listener.info( \"Adding package called \" + p.getName() );\n                rb.addPackage( p );\n            } catch ( Exception e ) {\n                throw new RuntimeDroolsException( e );\n            }\n        }\n        rb.unlock();\n    }","id":28535,"modified_method":"static void applyChanges(RuleBase rb, boolean removeExistingPackages, Collection changes, \n    \t\tAgentEventListener listener) {\n    \tapplyChanges(rb, removeExistingPackages, changes, null, listener);\n    }","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"static void applyChanges(RuleBase rb, boolean removeExistingPackages, Package[] ps, AgentEventListener listener) {\n        applyChanges( rb, removeExistingPackages, Arrays.asList( ps ), listener );\n    }","id":28536,"modified_method":"static void applyChanges(RuleBase rb, boolean removeExistingPackages, Collection changes, \n    \t\t\t\t\t\t\tCollection<String> removed, AgentEventListener listener) {\n    \tif ( changes == null && removed == null ) return;\n    \t\n    \trb.lock();\n        \n    \tif(removed != null ) {\n    \t\tremovePackages(removed, rb, listener);\n    \t}\n    \t\n    \tif( changes != null ) {\n\t        for ( Iterator iter = changes.iterator(); iter.hasNext(); ) {\n\t            Package p = (Package) iter.next();\n\t            \n\t            if ( removeExistingPackages ) {\n\t                removePackage( p.getName(),\n\t                               rb );\n\t            }\n\t            try {\n\t                listener.info( \"Adding package called \" + p.getName() );\n\t                rb.addPackage( p );\n\t            } catch ( Exception e ) {\n\t                throw new RuntimeDroolsException( e );\n\t            }\n\t        }\n    \t}\n        \n        rb.unlock();\n    }","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private synchronized Package[] checkForChanges(PackageProvider prov) {\n        listener.debug( \"SCANNING FOR CHANGE \" + prov.toString() );\n        if (this.ruleBase == null) ruleBase = RuleBaseFactory.newRuleBase( this.ruleBaseConf );\n        Package[] changes = prov.loadPackageChanges();\n        return changes;\n    }","id":28537,"modified_method":"private synchronized PackageChangeInfo checkForChanges(PackageProvider prov) {\n        listener.debug( \"SCANNING FOR CHANGE \" + prov.toString() );\n        if (this.ruleBase == null) ruleBase = RuleBaseFactory.newRuleBase( this.ruleBaseConf );\n        PackageChangeInfo info = prov.loadPackageChanges();\n        return info ;\n    }","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void refreshRuleBase() {\n\n        List changedPackages = new ArrayList();\n\n        for ( Iterator iter = providers.iterator(); iter.hasNext(); ) {\n            PackageProvider prov = (PackageProvider) iter.next();\n            Package[] changes = checkForChanges( prov );\n            if (changes != null && changes.length > 0) {\n                changedPackages.addAll( Arrays.asList( changes ) );\n            }\n        }\n\n        if (changedPackages.size() > 0) {\n            listener.info( \"Applying changes to the rulebase.\" );\n            //we have a change\n            if (this.newInstance) {\n                listener.info( \"Creating a new rulebase as per settings.\" );\n                //blow away old\n                this.ruleBase = RuleBaseFactory.newRuleBase( this.ruleBaseConf );\n\n                //need to store ALL packages\n                for ( Iterator iter = changedPackages.iterator(); iter.hasNext(); ) {\n                    Package element = (Package) iter.next();\n                    this.packages.put( element.getName(), element ); //replace\n                }\n                //get packages from full name\n                PackageProvider.applyChanges( this.ruleBase, false, this.packages.values(), this.listener );\n            } else {\n                PackageProvider.applyChanges( this.ruleBase, true, changedPackages, this.listener );\n            }\n        }\n\n\n    }","id":28538,"modified_method":"public void refreshRuleBase() {\n    \t\n        List<Package> changedPackages = new ArrayList<Package>();\n        List<String> removedPackages = new ArrayList<String>();\n\n        for ( Iterator iter = providers.iterator(); iter.hasNext(); ) {\n            PackageProvider prov = (PackageProvider) iter.next();\n            PackageChangeInfo info = checkForChanges( prov );\n            Collection<Package> changes = info.getChangedPackages(); \n            Collection<String> removed = info.getRemovedPackages(); \n            if (changes != null && changes.size() > 0) {\n                changedPackages.addAll( changes );\n            } \n            if (removed != null && removed.size() > 0) {\n                removedPackages.addAll( removed );\n            }\n        }\n\n        // Update changes.\n        if (changedPackages.size() > 0 || removedPackages.size() > 0) {\n            listener.info( \"Applying changes to the rulebase.\" );\n            //we have a change\n            if (this.newInstance) {\n                listener.info( \"Creating a new rulebase as per settings.\" );\n                //blow away old\n                this.ruleBase = RuleBaseFactory.newRuleBase( this.ruleBaseConf );\n\n                // Remove removed packages.\n                for (String name : removedPackages) {\n            \t\tthis.packages.remove( name );\n\t\t\t\t}\n                //need to store ALL packages\n                for ( Package element : changedPackages ) {\n                    this.packages.put( element.getName(), element ); //replace\n                }\n                //get packages from full name\n                PackageProvider.applyChanges( this.ruleBase, false, this.packages.values(), this.listener );\n            } else {\n                PackageProvider.applyChanges( this.ruleBase, true, changedPackages, removedPackages, this.listener );\n            }\n        }\n\n\n    }","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"Package[] loadPackageChanges() { //void updateRuleBase(RuleBase rb, boolean removeExistingPackages) {\n        Package[] changes = null;\n        try {\n            changes = getChangeSet();\n            return changes;\n        } catch ( IOException e ) {\n        \tlistener.exception( e );\n            if (this.localCacheFileScanner != null) {\n                listener.warning( \"Falling back to local cache.\" );\n                return localCacheFileScanner.loadPackageChanges();\n            }\n        } catch ( ClassNotFoundException e ) {\n            this.listener.exception( e );\n            this.listener.warning( \"Was unable to load a class when loading a package. Perhaps it is missing from this application.\" );\n        }\n        return null;\n    }","id":28539,"modified_method":"PackageChangeInfo loadPackageChanges() { //void updateRuleBase(RuleBase rb, boolean removeExistingPackages) {\n    \tPackageChangeInfo changes = null;\n        try {\n            changes = getChangeSet();\n            return changes;\n        } catch ( IOException e ) {\n        \tlistener.exception( e );\n            if (this.localCacheFileScanner != null) {\n                listener.warning( \"Falling back to local cache.\" );\n                return localCacheFileScanner.loadPackageChanges();\n            }\n        } catch ( ClassNotFoundException e ) {\n            this.listener.exception( e );\n            this.listener.warning( \"Was unable to load a class when loading a package. Perhaps it is missing from this application.\" );\n        }\n        return null;\n    }","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private Package[] getChangeSet() throws IOException, ClassNotFoundException {\n        if ( this.urls == null ) return new Package[0];\n        List list = new ArrayList();\n        for ( int i = 0; i < urls.length; i++ ) {\n            URL u = urls[i];\n            if ( hasChanged( u, this.lastUpdated) ) {\n                Package p = readPackage( u );\n                if ( p == null ) return null;\n                list.add( p );\n                if (localCacheDir != null) {\n                    writeLocalCacheCopy(p, u, localCacheDir);\n                }\n            }\n        }\n        return (Package[]) list.toArray( new Package[list.size()] );\n    }","id":28540,"modified_method":"private PackageChangeInfo getChangeSet() throws IOException, ClassNotFoundException {\n    \t\n    \tPackageChangeInfo info = new PackageChangeInfo();\n    \t\n        if ( this.urls == null ) return info;\n        \n        for ( int i = 0; i < urls.length; i++ ) {\n            URL u = urls[i];\n            if ( hasChanged( u, this.lastUpdated) ) {\n                Package p = readPackage( u );\n                if ( p == null ) return null;\n                info.addPackage( p );\n                if (localCacheDir != null) {\n                    writeLocalCacheCopy(p, u, localCacheDir);\n                }\n            }\n        }\n        return info;\n    }","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testUpdateWithLocalCache() {\n        URLScanner scan = new URLScanner();\n        scan.listener = new MockListener();\n        File dir = RuleBaseAssemblerTest.getTempDirectory();\n\n        Properties config = new Properties();\n        config.setProperty( RuleAgent.LOCAL_URL_CACHE, dir.getPath() );\n        config.setProperty( RuleAgent.URLS, \"http://goo.ber http://wee.waa\" );\n\n        scan.configure( config );\n\n        scan.httpClient = new IHttpClient() {\n\n            public LastUpdatedPing checkLastUpdated(URL url) throws IOException {\n                LastUpdatedPing ping = new LastUpdatedPing();\n                ping.lastUpdated = 123;\n                ping.responseMessage = \"200 OK\";\n                return ping;\n            }\n\n            public Package fetchPackage(URL url) throws IOException {\n                if ( url.toExternalForm().equals( \"http://goo.ber\" ) ) {\n                    return new Package( \"goo.ber\" );\n                } else {\n                    return new Package( \"wee.waa\" );\n                }\n            }\n\n        };\n\n        assertNotNull( scan.localCacheFileScanner );\n        assertNotNull( scan.localCacheDir );\n\n        RuleBase rb = RuleBaseFactory.newRuleBase();\n        PackageProvider.applyChanges( rb, false, scan.loadPackageChanges(), getNilListener() );\n\n\n        assertEquals( 2, rb.getPackages().length );\n        assertTrue(\"goo.ber\".equals(rb.getPackages()[0].getName()) || \"goo.ber\".equals(rb.getPackages()[1].getName()));\n        assertTrue(\"wee.waa\".equals(rb.getPackages()[0].getName()) || \"wee.waa\".equals(rb.getPackages()[1].getName()));\n\n        //assertEquals( 2, dir.list().length );\n\n        //now check with failures:\n        scan.httpClient = new IHttpClient() {\n\n            public LastUpdatedPing checkLastUpdated(URL url) throws IOException {\n                LastUpdatedPing ping = new LastUpdatedPing();\n\n                if (url.toExternalForm().equals( \"http://wee.waa\" )) {\n                    ping.lastUpdated = -1;\n                    ping.responseMessage = \"XXX\";\n\n                } else {\n                    ping.lastUpdated = 123;\n                    ping.responseMessage = \"200 OK\";\n                }\n                return ping;\n            }\n\n            public Package fetchPackage(URL url) throws IOException {\n                throw new IOException(\"poo\");\n            }\n\n        };\n\n        rb = RuleBaseFactory.newRuleBase();\n        assertEquals(0, rb.getPackages().length);\n        PackageProvider.applyChanges( rb, true, scan.loadPackageChanges(), getNilListener() );\n\n        assertEquals(2, rb.getPackages().length);\n\n        final boolean[] fetchCalled = new boolean[1];\n\n        fetchCalled[0] = false;\n\n        //now check with IOExceptions\n        scan.httpClient = new IHttpClient() {\n\n            public LastUpdatedPing checkLastUpdated(URL url) throws IOException {\n                LastUpdatedPing ping = new LastUpdatedPing();\n                ping.lastUpdated = 1234;\n                ping.responseMessage = \"200 OK\";\n                return ping;\n            }\n\n            public Package fetchPackage(URL url) throws IOException {\n                fetchCalled[0] = true;\n                throw new IOException(\"poo\");\n            }\n\n        };\n\n        Package[] changes = scan.loadPackageChanges();\n        assertEquals(0, changes.length);\n        assertEquals(true, fetchCalled[0]);\n        assertEquals(2, ((MockListener)scan.listener).exceptions.size());\n\n    }","id":28541,"modified_method":"public void testUpdateWithLocalCache() {\n        URLScanner scan = new URLScanner();\n        scan.listener = new MockListener();\n        File dir = RuleBaseAssemblerTest.getTempDirectory();\n\n        Properties config = new Properties();\n        config.setProperty( RuleAgent.LOCAL_URL_CACHE, dir.getPath() );\n        config.setProperty( RuleAgent.URLS, \"http://goo.ber http://wee.waa\" );\n\n        scan.configure( config );\n\n        scan.httpClient = new IHttpClient() {\n\n            public LastUpdatedPing checkLastUpdated(URL url) throws IOException {\n                LastUpdatedPing ping = new LastUpdatedPing();\n                ping.lastUpdated = 123;\n                ping.responseMessage = \"200 OK\";\n                return ping;\n            }\n\n            public Package fetchPackage(URL url) throws IOException {\n                if ( url.toExternalForm().equals( \"http://goo.ber\" ) ) {\n                    return new Package( \"goo.ber\" );\n                } else {\n                    return new Package( \"wee.waa\" );\n                }\n            }\n\n        };\n\n        assertNotNull( scan.localCacheFileScanner );\n        assertNotNull( scan.localCacheDir );\n\n        RuleBase rb = RuleBaseFactory.newRuleBase();\n        PackageProvider.applyChanges( rb, false, scan.loadPackageChanges().getChangedPackages(), getNilListener() );\n\n\n        assertEquals( 2, rb.getPackages().length );\n        assertTrue(\"goo.ber\".equals(rb.getPackages()[0].getName()) || \"goo.ber\".equals(rb.getPackages()[1].getName()));\n        assertTrue(\"wee.waa\".equals(rb.getPackages()[0].getName()) || \"wee.waa\".equals(rb.getPackages()[1].getName()));\n\n        //assertEquals( 2, dir.list().length );\n\n        //now check with failures:\n        scan.httpClient = new IHttpClient() {\n\n            public LastUpdatedPing checkLastUpdated(URL url) throws IOException {\n                LastUpdatedPing ping = new LastUpdatedPing();\n\n                if (url.toExternalForm().equals( \"http://wee.waa\" )) {\n                    ping.lastUpdated = -1;\n                    ping.responseMessage = \"XXX\";\n\n                } else {\n                    ping.lastUpdated = 123;\n                    ping.responseMessage = \"200 OK\";\n                }\n                return ping;\n            }\n\n            public Package fetchPackage(URL url) throws IOException {\n                throw new IOException(\"poo\");\n            }\n\n        };\n\n        rb = RuleBaseFactory.newRuleBase();\n        assertEquals(0, rb.getPackages().length);\n        PackageProvider.applyChanges( rb, true, scan.loadPackageChanges().getChangedPackages(), getNilListener() );\n\n        assertEquals(2, rb.getPackages().length);\n\n        final boolean[] fetchCalled = new boolean[1];\n\n        fetchCalled[0] = false;\n\n        //now check with IOExceptions\n        scan.httpClient = new IHttpClient() {\n\n            public LastUpdatedPing checkLastUpdated(URL url) throws IOException {\n                LastUpdatedPing ping = new LastUpdatedPing();\n                ping.lastUpdated = 1234;\n                ping.responseMessage = \"200 OK\";\n                return ping;\n            }\n\n            public Package fetchPackage(URL url) throws IOException {\n                fetchCalled[0] = true;\n                throw new IOException(\"poo\");\n            }\n\n        };\n\n        PackageChangeInfo changes = scan.loadPackageChanges();\n        assertEquals(0, changes.getChangedPackages().size());\n        assertEquals(true, fetchCalled[0]);\n        assertEquals(2, ((MockListener)scan.listener).exceptions.size());\n\n    }","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testUpdateNoLocalCache() throws Exception {\n        URLScanner scan = new URLScanner();\n        File dir = RuleBaseAssemblerTest.getTempDirectory();\n\n        int numfiles = dir.list().length;\n\n\n        Properties config = new Properties();\n        //config.setProperty( RuleAgent.LOCAL_URL_CACHE, dir.getPath() );\n        config.setProperty( RuleAgent.URLS, \"http://goo2.ber http://wee2.waa\" );\n\n        scan.configure( config );\n\n        scan.httpClient = new IHttpClient() {\n\n            public LastUpdatedPing checkLastUpdated(URL url) throws IOException {\n                LastUpdatedPing ping = new LastUpdatedPing();\n                ping.lastUpdated = 123;\n                ping.responseMessage = \"200 OK\";\n                return ping;\n            }\n\n            public Package fetchPackage(URL url) throws IOException {\n                if ( url.toExternalForm().equals( \"http://goo2.ber\" ) ) {\n                    return new Package( \"goo2.ber\" );\n                } else {\n                    return new Package( \"wee2.waa\" );\n                }\n            }\n\n        };\n\n        assertNull( scan.localCacheFileScanner );\n        assertNull( scan.localCacheDir );\n\n        RuleBase rb = RuleBaseFactory.newRuleBase();\n        AgentEventListener list = getNilListener();\n        PackageProvider.applyChanges( rb, false, scan.loadPackageChanges(), list );\n\n\n        assertEquals( 2, rb.getPackages().length );\n\n        assertExists(new String[] {\"goo2.ber\", \"wee2.waa\"}, rb.getPackages());\n\n\n\n        assertEquals( numfiles, dir.list().length );\n    }","id":28542,"modified_method":"public void testUpdateNoLocalCache() throws Exception {\n        URLScanner scan = new URLScanner();\n        File dir = RuleBaseAssemblerTest.getTempDirectory();\n\n        int numfiles = dir.list().length;\n\n\n        Properties config = new Properties();\n        //config.setProperty( RuleAgent.LOCAL_URL_CACHE, dir.getPath() );\n        config.setProperty( RuleAgent.URLS, \"http://goo2.ber http://wee2.waa\" );\n\n        scan.configure( config );\n\n        scan.httpClient = new IHttpClient() {\n\n            public LastUpdatedPing checkLastUpdated(URL url) throws IOException {\n                LastUpdatedPing ping = new LastUpdatedPing();\n                ping.lastUpdated = 123;\n                ping.responseMessage = \"200 OK\";\n                return ping;\n            }\n\n            public Package fetchPackage(URL url) throws IOException {\n                if ( url.toExternalForm().equals( \"http://goo2.ber\" ) ) {\n                    return new Package( \"goo2.ber\" );\n                } else {\n                    return new Package( \"wee2.waa\" );\n                }\n            }\n\n        };\n\n        assertNull( scan.localCacheFileScanner );\n        assertNull( scan.localCacheDir );\n\n        RuleBase rb = RuleBaseFactory.newRuleBase();\n        AgentEventListener list = getNilListener();\n        PackageProvider.applyChanges( rb, false, scan.loadPackageChanges().getChangedPackages(), list );\n\n\n        assertEquals( 2, rb.getPackages().length );\n\n        assertExists(new String[] {\"goo2.ber\", \"wee2.waa\"}, rb.getPackages());\n\n\n\n        assertEquals( numfiles, dir.list().length );\n    }","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testColdStartWithError() throws Exception {\n        //this will show starting up and reading packages from the dir when the remote one doesn't respond\n        URLScanner scan = new URLScanner();\n        scan.listener = new MockListener();\n        File dir = RuleBaseAssemblerTest.getTempDirectory();\n\n        Package p1 = new Package(\"goo.ber\");\n        Package p2 = new Package(\"wee.waa\");\n\n        File f1 = URLScanner.getLocalCacheFileForURL( dir, new URL(\"http://goo.ber\") );\n        File f2 = URLScanner.getLocalCacheFileForURL( dir, new URL(\"http://wee.waa\") );\n\n        RuleBaseAssemblerTest.writePackage( p1, f1 );\n        RuleBaseAssemblerTest.writePackage( p2, f2 );\n\n        Properties config = new Properties();\n        config.setProperty( RuleAgent.LOCAL_URL_CACHE, dir.getPath() );\n        config.setProperty( RuleAgent.URLS, \"http://goo.ber http://wee.waa\" );\n\n        scan.configure( config );\n\n        scan.httpClient = new IHttpClient() {\n\n            public LastUpdatedPing checkLastUpdated(URL url) throws IOException {\n                throw new IOException();\n            }\n\n            public Package fetchPackage(URL url) throws IOException {\n                throw new IOException();\n            }\n\n        };\n\n        assertNotNull( scan.localCacheFileScanner );\n        assertNotNull( scan.localCacheDir );\n\n        RuleBase rb = RuleBaseFactory.newRuleBase();\n        PackageProvider.applyChanges( rb, true, scan.loadPackageChanges(), getNilListener() );\n        assertEquals(2, rb.getPackages().length);\n\n\n    }","id":28543,"modified_method":"public void testColdStartWithError() throws Exception {\n        //this will show starting up and reading packages from the dir when the remote one doesn't respond\n        URLScanner scan = new URLScanner();\n        scan.listener = new MockListener();\n        File dir = RuleBaseAssemblerTest.getTempDirectory();\n\n        Package p1 = new Package(\"goo.ber\");\n        Package p2 = new Package(\"wee.waa\");\n\n        File f1 = URLScanner.getLocalCacheFileForURL( dir, new URL(\"http://goo.ber\") );\n        File f2 = URLScanner.getLocalCacheFileForURL( dir, new URL(\"http://wee.waa\") );\n\n        RuleBaseAssemblerTest.writePackage( p1, f1 );\n        RuleBaseAssemblerTest.writePackage( p2, f2 );\n\n        Properties config = new Properties();\n        config.setProperty( RuleAgent.LOCAL_URL_CACHE, dir.getPath() );\n        config.setProperty( RuleAgent.URLS, \"http://goo.ber http://wee.waa\" );\n\n        scan.configure( config );\n\n        scan.httpClient = new IHttpClient() {\n\n            public LastUpdatedPing checkLastUpdated(URL url) throws IOException {\n                throw new IOException();\n            }\n\n            public Package fetchPackage(URL url) throws IOException {\n                throw new IOException();\n            }\n\n        };\n\n        assertNotNull( scan.localCacheFileScanner );\n        assertNotNull( scan.localCacheDir );\n\n        RuleBase rb = RuleBaseFactory.newRuleBase();\n        PackageProvider.applyChanges( rb, true, scan.loadPackageChanges().getChangedPackages(), getNilListener() );\n        assertEquals(2, rb.getPackages().length);\n\n\n    }","commit_id":"d9155df2d5e744c750c592d965b2f99c026e138c","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Object parseBody(HttpMessage httpMessage) throws IOException {\n        // lets assume the body is a reader\n        HttpServletRequest request = httpMessage.getRequest();\n        // there is only a body if we have a content length, or its -1 to indicate unknown length\n        if (request.getContentLength() == 0) {\n            return null;\n        }\n        if (isUseReaderForPayload()) {\n            // use reader to read the response body\n            return request.getReader();\n        } else {\n            // reade the response body from servlet request\n            return HttpHelper.readResponseBodyFromServletRequest(request, httpMessage.getExchange());\n        }\n    }","id":28544,"modified_method":"public Object parseBody(HttpMessage httpMessage) throws IOException {\n        // lets assume the body is a reader\n        HttpServletRequest request = httpMessage.getRequest();\n        // there is only a body if we have a content length, or its -1 to indicate unknown length\n        int len = request.getContentLength();\n        LOG.trace(\"HttpServletRequest content-length: {}\", len);\n        if (len == 0) {\n            return null;\n        }\n        if (isUseReaderForPayload()) {\n            // use reader to read the response body\n            return request.getReader();\n        } else {\n            // if we do not know if there is any data at all, then make sure to check the stream first\n            if (len < 0) {\n                InputStream is = request.getInputStream();\n                if (is.available() == 0) {\n                    // no data so return null\n                    return null;\n                }\n            }\n            // reade the response body from servlet request\n            return HttpHelper.readResponseBodyFromServletRequest(request, httpMessage.getExchange());\n        }\n    }","commit_id":"1ba5aa2f4b9c646d9b96fb1db43d6a5396e25e48","url":"https://github.com/apache/camel"},{"original_method":"public Object parseBody(HttpMessage httpMessage) throws IOException {\n        // lets assume the body is a reader\n        HttpServletRequest request = httpMessage.getRequest();\n        // there is only a body if we have a content length, or its -1 to indicate unknown length\n        if (request.getContentLength() == 0) {\n            return null;\n        }\n        if (isUseReaderForPayload()) {\n            // use reader to read the response body\n            return request.getReader();\n        } else {\n            // reade the response body from servlet request\n            return HttpHelper.readResponseBodyFromServletRequest(request, httpMessage.getExchange());\n        }\n    }","id":28545,"modified_method":"public Object parseBody(HttpMessage httpMessage) throws IOException {\n        // lets assume the body is a reader\n        HttpServletRequest request = httpMessage.getRequest();\n        // there is only a body if we have a content length, or its -1 to indicate unknown length\n        int len = request.getContentLength();\n        LOG.trace(\"HttpServletRequest content-length: {}\", len);\n        if (len == 0) {\n            return null;\n        }\n        if (isUseReaderForPayload()) {\n            // use reader to read the response body\n            return request.getReader();\n        } else {\n            // if we do not know if there is any data at all, then make sure to check the stream first\n            if (len < 0) {\n                InputStream is = request.getInputStream();\n                if (is.available() == 0) {\n                    // no data so return null\n                    return null;\n                }\n            }\n            // reade the response body from servlet request\n            return HttpHelper.readResponseBodyFromServletRequest(request, httpMessage.getExchange());\n        }\n    }","commit_id":"1ba5aa2f4b9c646d9b96fb1db43d6a5396e25e48","url":"https://github.com/apache/camel"},{"original_method":"@Converter\n    public static InputStream toInputStream(HttpServletRequest request, Exchange exchange) throws IOException {\n        if (request == null) {\n            return null;\n        }\n        if (exchange == null || !exchange.getProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.FALSE, Boolean.class)) {\n            String contentEncoding = request.getHeader(Exchange.CONTENT_ENCODING);\n            return GZIPHelper.uncompressGzip(contentEncoding, request.getInputStream());\n        } else {\n            return request.getInputStream();\n        }\n    }","id":28546,"modified_method":"@Converter\n    public static InputStream toInputStream(HttpServletRequest request, Exchange exchange) throws IOException {\n        if (request == null) {\n            return null;\n        }\n        InputStream is = request.getInputStream();\n        if (is != null && is.available() <= 0) {\n            // there is no data, so we cannot uncompress etc.\n            return is;\n        }\n        if (exchange == null || !exchange.getProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.FALSE, Boolean.class)) {\n            String contentEncoding = request.getHeader(Exchange.CONTENT_ENCODING);\n            return GZIPHelper.uncompressGzip(contentEncoding, is);\n        } else {\n            return is;\n        }\n    }","commit_id":"1ba5aa2f4b9c646d9b96fb1db43d6a5396e25e48","url":"https://github.com/apache/camel"},{"original_method":"@Converter\n    public static InputStream toInputStream(HttpServletRequest request, Exchange exchange) throws IOException {\n        if (request == null) {\n            return null;\n        }\n        if (exchange == null\n            || !exchange.getProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.FALSE, Boolean.class)) {\n            String contentEncoding = request.getHeader(Exchange.CONTENT_ENCODING);\n            return GZIPHelper.uncompressGzip(contentEncoding, request.getInputStream());\n        } else {\n            return request.getInputStream();\n        }\n    }","id":28547,"modified_method":"@Converter\n    public static InputStream toInputStream(HttpServletRequest request, Exchange exchange) throws IOException {\n        if (request == null) {\n            return null;\n        }\n        InputStream is = request.getInputStream();\n        if (is != null && is.available() <= 0) {\n            // there is no data, so we cannot uncompress etc.\n            return is;\n        }\n        if (exchange == null || !exchange.getProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.FALSE, Boolean.class)) {\n            String contentEncoding = request.getHeader(Exchange.CONTENT_ENCODING);\n            return GZIPHelper.uncompressGzip(contentEncoding, is);\n        } else {\n            return is;\n        }\n    }","commit_id":"1ba5aa2f4b9c646d9b96fb1db43d6a5396e25e48","url":"https://github.com/apache/camel"},{"original_method":"public static void serveResource(MimeTypeConfig mimeTypeConfig, String urlString, boolean isVersioned) throws IOException {\n\n        final ExternalContext externalContext = NetUtils.getExternalContext();\n        final ExternalContext.Response response = externalContext.getResponse();\n\n        // Remove version from the path if it is versioned\n        urlString = URLRewriterUtils.decodeResourceURI(urlString, isVersioned);\n\n        // Use the default protocol to read the file as a resource\n        if (!urlString.startsWith(\"oxf:\"))\n            urlString = \"oxf:\" + urlString;\n\n        InputStream urlConnectionInputStream = null;\n        try {\n            // Open resource and set headers\n            try {\n                final URL newURL = URLFactory.createURL(urlString);\n\n                URLConnection urlConnection = null;\n                int length = -1;\n                long lastModified = -1;\n                {\n                    final String urlPath = newURL.getPath();\n                    if (newURL.getProtocol().equals(\"oxf\")) {\n\n                        // IE 6 hack for PNG images\n                        if (UserAgent.isIE6OrEarlier(externalContext.getRequest())) {\n                            if (urlPath.endsWith(\".png\")) {\n                                // Case of a PNG image served to IE 6 or earlier: check if there is a .gif instead\n                                urlString = \"oxf:\" + urlPath.substring(0, urlPath.length() - 3) + \"gif\";\n                                final URL gifURL = URLFactory.createURL(urlString);\n                                try {\n                                    // Try to get InputStream\n                                    final URLConnection gifURLConnection = gifURL.openConnection();\n                                    urlConnectionInputStream = gifURLConnection.getInputStream();\n                                    // If we get to here, we were successful\n                                    urlConnection = gifURLConnection;\n                                } catch (ResourceNotFoundException e) {\n                                    // GIF doesn't exist\n                                    // NOTE: Exception throwing / catching is expensive so we hope this doesn't happen too often\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Open the connection, if not node already\n                if (urlConnection == null) {\n                    urlConnection = newURL.openConnection();\n                    urlConnectionInputStream = urlConnection.getInputStream();\n                }\n                // Get length and last modified, if not done already\n                if (length == -1) length = urlConnection.getContentLength();\n                if (lastModified == -1) lastModified = NetUtils.getLastModified(urlConnection);\n\n                // Set Last-Modified, required for caching and conditional get\n                if (isVersioned) {\n                    // Use expiration far in the future\n                    response.setResourceCaching(lastModified, lastModified + ONE_YEAR_IN_MILLISECONDS);\n                } else {\n                    // Use standard expiration policy\n                    response.setResourceCaching(lastModified, 0);\n                }\n\n                // Check If-Modified-Since and don't return content if condition is met\n                if (!response.checkIfModifiedSince(lastModified, false)) {\n                    response.setStatus(ExternalContext.SC_NOT_MODIFIED);\n                    return;\n                }\n\n                // Lookup and set the content type\n                final String contentType = mimeTypeConfig.getMimeType(urlString);\n                if (contentType != null)\n                    response.setContentType(contentType);\n\n                if (length > 0)\n                    response.setContentLength(length);\n\n            } catch (IOException e) {\n                response.setStatus(ExternalContext.SC_NOT_FOUND);\n                return;\n            } catch (ResourceNotFoundException e) {\n                // Note: we should really not get this exception here, but an IOException\n                // However we do actually get it, and so do the same we do for IOException.\n                response.setStatus(ExternalContext.SC_NOT_FOUND);\n                return;\n            }\n            // Copy stream to output\n            NetUtils.copyStream(urlConnectionInputStream, response.getOutputStream());\n        } finally {\n            // Make sure the stream is closed in all cases so as to not lock the file on disk\n            if (urlConnectionInputStream != null) {\n                urlConnectionInputStream.close();\n            }\n        }\n    }","id":28548,"modified_method":"public static void serveResource(MimeTypeConfig mimeTypeConfig, String urlString, boolean isVersioned) throws IOException {\n\n        final ExternalContext externalContext = NetUtils.getExternalContext();\n        final ExternalContext.Response response = externalContext.getResponse();\n\n        // Remove version from the path if it is versioned\n        urlString = URLRewriterUtils.decodeResourceURI(urlString, isVersioned);\n\n        // Use the default protocol to read the file as a resource\n        if (!urlString.startsWith(\"oxf:\"))\n            urlString = \"oxf:\" + urlString;\n\n        InputStream urlConnectionInputStream = null;\n        try {\n            // Open resource and set headers\n            try {\n                final URL newURL = URLFactory.createURL(urlString);\n\n                // Open the connection\n                final URLConnection urlConnection = newURL.openConnection();\n                urlConnectionInputStream = urlConnection.getInputStream();\n\n                // Get length and last modified\n                final int length = urlConnection.getContentLength();\n                final long lastModified = NetUtils.getLastModified(urlConnection);\n\n                // Set Last-Modified, required for caching and conditional get\n                if (isVersioned) {\n                    // Use expiration far in the future\n                    response.setResourceCaching(lastModified, lastModified + ONE_YEAR_IN_MILLISECONDS);\n                } else {\n                    // Use standard expiration policy\n                    response.setResourceCaching(lastModified, 0);\n                }\n\n                // Check If-Modified-Since and don't return content if condition is met\n                if (!response.checkIfModifiedSince(lastModified, false)) {\n                    response.setStatus(ExternalContext.SC_NOT_MODIFIED);\n                    return;\n                }\n\n                // Lookup and set the content type\n                final String contentType = mimeTypeConfig.getMimeType(urlString);\n                if (contentType != null)\n                    response.setContentType(contentType);\n\n                if (length > 0)\n                    response.setContentLength(length);\n\n            } catch (IOException e) {\n                response.setStatus(ExternalContext.SC_NOT_FOUND);\n                return;\n            } catch (ResourceNotFoundException e) {\n                // Note: we should really not get this exception here, but an IOException\n                // However we do actually get it, and so do the same we do for IOException.\n                response.setStatus(ExternalContext.SC_NOT_FOUND);\n                return;\n            }\n            // Copy stream to output\n            NetUtils.copyStream(urlConnectionInputStream, response.getOutputStream());\n        } finally {\n            // Make sure the stream is closed in all cases so as to not lock the file on disk\n            if (urlConnectionInputStream != null) {\n                urlConnectionInputStream.close();\n            }\n        }\n    }","commit_id":"8cea34d6d944efef72d6868ec03e3975bda3d8e7","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public SolrInputDocument storeDocument(\n            final DigestURI url,\n            final DigestURI referrerURL,\n            final CrawlProfile profile,\n            final ResponseHeader responseHeader,\n            final Document document,\n            final Condenser condenser,\n            final SearchEvent searchEvent,\n            final String sourceName,\n            final boolean storeToRWI\n            ) {\n        final long startTime = System.currentTimeMillis();\n\n        // CREATE INDEX\n\n        // load some document metadata\n        final Date loadDate = new Date();\n        final String id = ASCII.String(url.hash());\n        final String dc_title = document.dc_title();\n        final String urlNormalform = url.toNormalform(true);\n        final String language = votedLanguage(url, urlNormalform, document, condenser); // identification of the language\n\n        // STORE URL TO LOADED-URL-DB\n        Date modDate = responseHeader.lastModified();\n        if (modDate.getTime() > loadDate.getTime()) modDate = loadDate;\n        char docType = Response.docType(document.dc_format());\n        \n        // STORE TO SOLR\n        final SolrInputDocument solrInputDoc = this.fulltext.getSolrScheme().yacy2solr(id, profile, responseHeader, document, condenser, referrerURL, language);\n        try {\n            this.fulltext.putDocument(solrInputDoc);\n        } catch ( final IOException e ) {\n            String error = \"failed to send \" + urlNormalform + \" to solr\";\n            Log.logWarning(\"SOLR\", error + \", pausing Crawler! - \" + e.getMessage());\n            // pause the crawler!!!\n            Switchboard.getSwitchboard().pauseCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, error);\n            Switchboard.getSwitchboard().pauseCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, error);\n        }\n\n        final long storageEndTime = System.currentTimeMillis();\n\n        // STORE PAGE INDEX INTO WORD INDEX DB\n        int outlinksSame = document.inboundLinks().size();\n        int outlinksOther = document.outboundLinks().size();\n        final RankingProcess rankingProcess = (searchEvent == null) ? null : searchEvent.rankingProcess;\n        final int urlLength = urlNormalform.length();\n        final int urlComps = MultiProtocolURI.urlComps(url.toString()).length;\n\n        // create a word prototype which is re-used for all entries\n        if ((this.termIndex != null && storeToRWI) || searchEvent != null) {\n            final int len = (document == null) ? urlLength : document.dc_title().length();\n            final WordReferenceRow ientry = new WordReferenceRow(\n                            url.hash(),\n                            urlLength, urlComps, len,\n                            condenser.RESULT_NUMB_WORDS,\n                            condenser.RESULT_NUMB_SENTENCES,\n                            modDate.getTime(),\n                            System.currentTimeMillis(),\n                            UTF8.getBytes(language),\n                            docType,\n                            outlinksSame, outlinksOther);\n    \n            // iterate over all words of content text\n            Word wprop = null;\n            byte[] wordhash;\n            String word;\n            for (Map.Entry<String, Word> wentry: condenser.words().entrySet()) {\n                word = wentry.getKey();\n                wprop = wentry.getValue();\n                assert (wprop.flags != null);\n                ientry.setWord(wprop);\n                wordhash = Word.word2hash(word);\n                if (this.termIndex != null && storeToRWI) try {\n                    this.termIndex.add(wordhash, ientry);\n                } catch (final Exception e) {\n                    Log.logException(e);\n                }\n    \n                // during a search event it is possible that a heuristic is used which aquires index\n                // data during search-time. To transfer indexed data directly to the search process\n                // the following lines push the index data additionally to the search process\n                // this is done only for searched words\n                if (searchEvent != null && !searchEvent.query.query_exclude_hashes.has(wordhash) && searchEvent.query.query_include_hashes.has(wordhash)) {\n                    // if the page was added in the context of a heuristic this shall ensure that findings will fire directly into the search result\n                    ReferenceContainer<WordReference> container;\n                    try {\n                        container = ReferenceContainer.emptyContainer(Segment.wordReferenceFactory, wordhash, 1);\n                        container.add(ientry);\n                        rankingProcess.add(container, true, sourceName, -1, 5000);\n                    } catch (final SpaceExceededException e) {\n                        continue;\n                    }\n                }\n            }\n            if (searchEvent != null) searchEvent.rankingProcess.addFinalize();\n    \n            // assign the catchall word\n            ientry.setWord(wprop == null ? catchallWord : wprop); // we use one of the word properties as template to get the document characteristics\n            if (this.termIndex != null) try {\n                this.termIndex.add(catchallHash, ientry);\n            } catch (final Exception e) {\n                Log.logException(e);\n            }\n        }\n\n        // STORE PAGE REFERENCES INTO CITATION INDEX\n        final int refs = addCitationIndex(url, modDate, document.getAnchors());\n\n        // finish index time\n        final long indexingEndTime = System.currentTimeMillis();\n\n        if (this.log.isInfo()) {\n            this.log.logInfo(\"*Indexed \" + condenser.words().size() + \" words in URL \" + url +\n                    \" [\" + id + \"]\" +\n                    \"\\n\\tDescription:  \" + dc_title +\n                    \"\\n\\tMimeType: \"  + document.dc_format() + \" | Charset: \" + document.getCharset() + \" | \" +\n                    \"Size: \" + document.getTextLength() + \" bytes | \" +\n                    \"Anchors: \" + refs +\n                    \"\\n\\tLinkStorageTime: \" + (storageEndTime - startTime) + \" ms | \" +\n                    \"indexStorageTime: \" + (indexingEndTime - storageEndTime) + \" ms\");\n        }\n\n        // finished\n        return solrInputDoc;\n    }","id":28549,"modified_method":"public SolrInputDocument storeDocument(\n            final DigestURI url,\n            final DigestURI referrerURL,\n            final CrawlProfile profile,\n            final ResponseHeader responseHeader,\n            final Document document,\n            final Condenser condenser,\n            final SearchEvent searchEvent,\n            final String sourceName,\n            final boolean storeToRWI\n            ) {\n        final long startTime = System.currentTimeMillis();\n\n        // CREATE INDEX\n\n        // load some document metadata\n        final Date loadDate = new Date();\n        final String id = ASCII.String(url.hash());\n        final String dc_title = document.dc_title();\n        final String urlNormalform = url.toNormalform(true);\n        final String language = votedLanguage(url, urlNormalform, document, condenser); // identification of the language\n\n        // STORE URL TO LOADED-URL-DB\n        Date modDate = responseHeader == null ? new Date() : responseHeader.lastModified();\n        if (modDate.getTime() > loadDate.getTime()) modDate = loadDate;\n        char docType = Response.docType(document.dc_format());\n        \n        // STORE TO SOLR\n        final SolrInputDocument solrInputDoc = this.fulltext.getSolrScheme().yacy2solr(id, profile, responseHeader, document, condenser, referrerURL, language);\n        try {\n            this.fulltext.putDocument(solrInputDoc);\n        } catch ( final IOException e ) {\n            String error = \"failed to send \" + urlNormalform + \" to solr\";\n            Log.logWarning(\"SOLR\", error + \", pausing Crawler! - \" + e.getMessage());\n            // pause the crawler!!!\n            Switchboard.getSwitchboard().pauseCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, error);\n            Switchboard.getSwitchboard().pauseCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, error);\n        }\n\n        final long storageEndTime = System.currentTimeMillis();\n\n        // STORE PAGE INDEX INTO WORD INDEX DB\n        int outlinksSame = document.inboundLinks().size();\n        int outlinksOther = document.outboundLinks().size();\n        final RankingProcess rankingProcess = (searchEvent == null) ? null : searchEvent.rankingProcess;\n        final int urlLength = urlNormalform.length();\n        final int urlComps = MultiProtocolURI.urlComps(url.toString()).length;\n\n        // create a word prototype which is re-used for all entries\n        if ((this.termIndex != null && storeToRWI) || searchEvent != null) {\n            final int len = (document == null) ? urlLength : document.dc_title().length();\n            final WordReferenceRow ientry = new WordReferenceRow(\n                            url.hash(),\n                            urlLength, urlComps, len,\n                            condenser.RESULT_NUMB_WORDS,\n                            condenser.RESULT_NUMB_SENTENCES,\n                            modDate.getTime(),\n                            System.currentTimeMillis(),\n                            UTF8.getBytes(language),\n                            docType,\n                            outlinksSame, outlinksOther);\n    \n            // iterate over all words of content text\n            Word wprop = null;\n            byte[] wordhash;\n            String word;\n            for (Map.Entry<String, Word> wentry: condenser.words().entrySet()) {\n                word = wentry.getKey();\n                wprop = wentry.getValue();\n                assert (wprop.flags != null);\n                ientry.setWord(wprop);\n                wordhash = Word.word2hash(word);\n                if (this.termIndex != null && storeToRWI) try {\n                    this.termIndex.add(wordhash, ientry);\n                } catch (final Exception e) {\n                    Log.logException(e);\n                }\n    \n                // during a search event it is possible that a heuristic is used which aquires index\n                // data during search-time. To transfer indexed data directly to the search process\n                // the following lines push the index data additionally to the search process\n                // this is done only for searched words\n                if (searchEvent != null && !searchEvent.query.query_exclude_hashes.has(wordhash) && searchEvent.query.query_include_hashes.has(wordhash)) {\n                    // if the page was added in the context of a heuristic this shall ensure that findings will fire directly into the search result\n                    ReferenceContainer<WordReference> container;\n                    try {\n                        container = ReferenceContainer.emptyContainer(Segment.wordReferenceFactory, wordhash, 1);\n                        container.add(ientry);\n                        rankingProcess.add(container, true, sourceName, -1, 5000);\n                    } catch (final SpaceExceededException e) {\n                        continue;\n                    }\n                }\n            }\n            if (searchEvent != null) searchEvent.rankingProcess.addFinalize();\n    \n            // assign the catchall word\n            ientry.setWord(wprop == null ? catchallWord : wprop); // we use one of the word properties as template to get the document characteristics\n            if (this.termIndex != null) try {\n                this.termIndex.add(catchallHash, ientry);\n            } catch (final Exception e) {\n                Log.logException(e);\n            }\n        }\n\n        // STORE PAGE REFERENCES INTO CITATION INDEX\n        final int refs = addCitationIndex(url, modDate, document.getAnchors());\n\n        // finish index time\n        final long indexingEndTime = System.currentTimeMillis();\n\n        if (this.log.isInfo()) {\n            this.log.logInfo(\"*Indexed \" + condenser.words().size() + \" words in URL \" + url +\n                    \" [\" + id + \"]\" +\n                    \"\\n\\tDescription:  \" + dc_title +\n                    \"\\n\\tMimeType: \"  + document.dc_format() + \" | Charset: \" + document.getCharset() + \" | \" +\n                    \"Size: \" + document.getTextLength() + \" bytes | \" +\n                    \"Anchors: \" + refs +\n                    \"\\n\\tLinkStorageTime: \" + (storageEndTime - startTime) + \" ms | \" +\n                    \"indexStorageTime: \" + (indexingEndTime - storageEndTime) + \" ms\");\n        }\n\n        // finished\n        return solrInputDoc;\n    }","commit_id":"12c0db20e5a2704c0c6e1385e9e1eed93faae7fc","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"protected SolrInputDocument yacy2solr(final String id, final CrawlProfile profile, final ResponseHeader responseHeader, final Document document, Condenser condenser, DigestURI referrerURL, String language) {\n        // we use the SolrCell design as index scheme\n        final SolrInputDocument doc = new SolrInputDocument();\n        final DigestURI digestURI = DigestURI.toDigestURI(document.dc_source());\n        boolean allAttr = this.isEmpty();\n        add(doc, YaCySchema.id, id);\n        if (allAttr || contains(YaCySchema.failreason_t)) add(doc, YaCySchema.failreason_t, \"\"); // overwrite a possible fail reason (in case that there was a fail reason before)\n        String us = digestURI.toNormalform(true);\n        add(doc, YaCySchema.sku, us);\n        if (allAttr || contains(YaCySchema.ip_s)) {\n            final InetAddress address = digestURI.getInetAddress();\n            if (address != null) add(doc, YaCySchema.ip_s, address.getHostAddress());\n        }\n        if (allAttr || contains(YaCySchema.collection_sxt) && profile != null) add(doc, YaCySchema.collection_sxt, profile.collections());\n        if (allAttr || contains(YaCySchema.url_protocol_s)) add(doc, YaCySchema.url_protocol_s, digestURI.getProtocol());\n        Map<String, String> searchpart = digestURI.getSearchpartMap();\n        if (searchpart == null) {\n            if (allAttr || contains(YaCySchema.url_parameter_i)) add(doc, YaCySchema.url_parameter_i, 0);\n        } else {\n            if (allAttr || contains(YaCySchema.url_parameter_i)) add(doc, YaCySchema.url_parameter_i, searchpart.size());\n            if (allAttr || contains(YaCySchema.url_parameter_key_sxt)) add(doc, YaCySchema.url_parameter_key_sxt, searchpart.keySet().toArray(new String[searchpart.size()]));\n            if (allAttr || contains(YaCySchema.url_parameter_value_sxt)) add(doc, YaCySchema.url_parameter_value_sxt,  searchpart.values().toArray(new String[searchpart.size()]));\n        }\n        if (allAttr || contains(YaCySchema.url_chars_i)) add(doc, YaCySchema.url_chars_i, us.length());\n        String host = null;\n        if ((host = digestURI.getHost()) != null) {\n            String dnc = Domains.getDNC(host);\n            String subdomOrga = host.substring(0, host.length() - dnc.length() - 1);\n            int p = subdomOrga.lastIndexOf('.');\n            String subdom = (p < 0) ? \"\" : subdomOrga.substring(0, p);\n            String orga = (p < 0) ? subdomOrga : subdomOrga.substring(p + 1);\n            if (allAttr || contains(YaCySchema.host_s)) add(doc, YaCySchema.host_s, host);\n            if (allAttr || contains(YaCySchema.host_dnc_s)) add(doc, YaCySchema.host_dnc_s, dnc);\n            if (allAttr || contains(YaCySchema.host_organization_s)) add(doc, YaCySchema.host_organization_s, orga);\n            if (allAttr || contains(YaCySchema.host_organizationdnc_s)) add(doc, YaCySchema.host_organizationdnc_s, orga + '.' + dnc);\n            if (allAttr || contains(YaCySchema.host_subdomain_s)) add(doc, YaCySchema.host_subdomain_s, subdom);\n        }\n\n        List<String> titles = document.titles();\n        if (allAttr || contains(YaCySchema.title)) add(doc, YaCySchema.title, titles);\n        if (allAttr || contains(YaCySchema.title_count_i)) add(doc, YaCySchema.title_count_i, titles.size());\n        if (allAttr || contains(YaCySchema.title_chars_val)) {\n            ArrayList<Integer> cv = new ArrayList<Integer>(titles.size());\n            for (String s: titles) cv.add(new Integer(s.length()));\n            add(doc, YaCySchema.title_chars_val, cv);\n        }\n        if (allAttr || contains(YaCySchema.title_words_val)) {\n            ArrayList<Integer> cv = new ArrayList<Integer>(titles.size());\n            for (String s: titles) cv.add(new Integer(s.split(\" \").length));\n            add(doc, YaCySchema.title_words_val, cv);\n        }\n\n        String description = document.dc_description();\n        List<String> descriptions = new ArrayList<String>();\n        for (String s: description.split(\"\\n\")) descriptions.add(s);\n        if (allAttr || contains(YaCySchema.description)) add(doc, YaCySchema.description, description);\n        if (allAttr || contains(YaCySchema.description_count_i)) add(doc, YaCySchema.description_count_i, descriptions.size());\n        if (allAttr || contains(YaCySchema.description_chars_val)) {\n            ArrayList<Integer> cv = new ArrayList<Integer>(descriptions.size());\n            for (String s: descriptions) cv.add(new Integer(s.length()));\n            add(doc, YaCySchema.description_chars_val, cv);\n        }\n        if (allAttr || contains(YaCySchema.description_words_val)) {\n            ArrayList<Integer> cv = new ArrayList<Integer>(descriptions.size());\n            for (String s: descriptions) cv.add(new Integer(s.split(\" \").length));\n            add(doc, YaCySchema.description_words_val, cv);\n        }\n\n        if (allAttr || contains(YaCySchema.author)) add(doc, YaCySchema.author, document.dc_creator());\n        if (allAttr || contains(YaCySchema.content_type)) add(doc, YaCySchema.content_type, new String[]{document.dc_format()});\n        if (allAttr || contains(YaCySchema.last_modified)) add(doc, YaCySchema.last_modified, responseHeader == null ? new Date() : responseHeader.lastModified());\n        if (allAttr || contains(YaCySchema.keywords)) add(doc, YaCySchema.keywords, document.dc_subject(' '));\n        final String content = document.getTextString();\n        if (allAttr || contains(YaCySchema.text_t)) add(doc, YaCySchema.text_t, content);\n        if (allAttr || contains(YaCySchema.wordcount_i)) {\n            final int contentwc = content.split(\" \").length;\n            add(doc, YaCySchema.wordcount_i, contentwc);\n        }\n        if (allAttr || contains(YaCySchema.synonyms_sxt)) {\n            List<String> synonyms = condenser.synonyms();\n            add(doc, YaCySchema.synonyms_sxt, synonyms);\n        }\n\n        // path elements of link\n        if (allAttr || contains(YaCySchema.url_paths_sxt)) add(doc, YaCySchema.url_paths_sxt, digestURI.getPaths());\n        if (allAttr || contains(YaCySchema.url_file_ext_s)) add(doc, YaCySchema.url_file_ext_s, digestURI.getFileExtension());\n\n        // get list of all links; they will be shrinked by urls that appear in other fields of the solr scheme\n        Set<MultiProtocolURI> inboundLinks = document.inboundLinks();\n        Set<MultiProtocolURI> outboundLinks = document.outboundLinks();\n\n        int c = 0;\n        final Object parser = document.getParserObject();\n        Map<MultiProtocolURI, ImageEntry> images = new HashMap<MultiProtocolURI, ImageEntry>();\n        if (parser instanceof ContentScraper) {\n            final ContentScraper html = (ContentScraper) parser;\n            images = html.getImages();\n\n            // header tags\n            int h = 0;\n            int f = 1;\n            String[] hs;\n\n            hs = html.getHeadlines(1); h = h | (hs.length > 0 ? f : 0); f = f * 2; add(doc, YaCySchema.h1_txt, hs); add(doc, YaCySchema.h1_i, hs.length);\n            hs = html.getHeadlines(2); h = h | (hs.length > 0 ? f : 0); f = f * 2; add(doc, YaCySchema.h2_txt, hs); add(doc, YaCySchema.h2_i, hs.length);\n            hs = html.getHeadlines(3); h = h | (hs.length > 0 ? f : 0); f = f * 2; add(doc, YaCySchema.h3_txt, hs); add(doc, YaCySchema.h3_i, hs.length);\n            hs = html.getHeadlines(4); h = h | (hs.length > 0 ? f : 0); f = f * 2; add(doc, YaCySchema.h4_txt, hs); add(doc, YaCySchema.h4_i, hs.length);\n            hs = html.getHeadlines(5); h = h | (hs.length > 0 ? f : 0); f = f * 2; add(doc, YaCySchema.h5_txt, hs); add(doc, YaCySchema.h5_i, hs.length);\n            hs = html.getHeadlines(6); h = h | (hs.length > 0 ? f : 0); f = f * 2; add(doc, YaCySchema.h6_txt, hs); add(doc, YaCySchema.h6_i, hs.length);\n       \n            add(doc, YaCySchema.htags_i, h);\n            add(doc, YaCySchema.schema_org_breadcrumb_i, html.breadcrumbCount());\n\n            // meta tags: Open Graph properties\n            String og;\n            og = html.getMetas().get(\"og:title\"); if (og != null) add(doc, YaCySchema.opengraph_title_t, og);\n            og = html.getMetas().get(\"og:type\"); if (og != null) add(doc, YaCySchema.opengraph_type_s, og);\n            og = html.getMetas().get(\"og:url\"); if (og != null) add(doc, YaCySchema.opengraph_url_s, og);\n            og = html.getMetas().get(\"og:image\"); if (og != null) add(doc, YaCySchema.opengraph_image_s, og);\n\n            // noindex and nofollow attributes\n            // from HTML (meta-tag in HTML header: robots)\n            // and HTTP header (x-robots property)\n            // coded as binary value:\n            // bit  0: \"all\" contained in html header meta\n            // bit  1: \"index\" contained in html header meta\n            // bit  2: \"noindex\" contained in html header meta\n            // bit  3: \"nofollow\" contained in html header meta\n            // bit  8: \"noarchive\" contained in http header properties\n            // bit  9: \"nosnippet\" contained in http header properties\n            // bit 10: \"noindex\" contained in http header properties\n            // bit 11: \"nofollow\" contained in http header properties\n            // bit 12: \"unavailable_after\" contained in http header properties\n            int b = 0;\n            final String robots_meta = html.getMetas().get(\"robots\");\n            // this tag may have values: all, index, noindex, nofollow\n            if (robots_meta != null) {\n                if (robots_meta.indexOf(\"all\",0) >= 0) b += 1;      // set bit 0\n                if (robots_meta.indexOf(\"index\",0) == 0 || robots_meta.indexOf(\" index\",0) >= 0 || robots_meta.indexOf(\",index\",0) >= 0 ) b += 2; // set bit 1\n                if (robots_meta.indexOf(\"noindex\",0) >= 0) b += 4;  // set bit 2\n                if (robots_meta.indexOf(\"nofollow\",0) >= 0) b += 8; // set bit 3\n            }\n            String x_robots_tag = \"\";\n            if (responseHeader != null) {\n                x_robots_tag = responseHeader.get(HeaderFramework.X_ROBOTS_TAG, \"\");\n                if (x_robots_tag.isEmpty()) {\n                    x_robots_tag = responseHeader.get(HeaderFramework.X_ROBOTS, \"\");\n                }\n            }\n            if (!x_robots_tag.isEmpty()) {\n                // this tag may have values: noarchive, nosnippet, noindex, unavailable_after\n                if (x_robots_tag.indexOf(\"noarchive\",0) >= 0) b += 256;         // set bit 8\n                if (x_robots_tag.indexOf(\"nosnippet\",0) >= 0) b += 512;         // set bit 9\n                if (x_robots_tag.indexOf(\"noindex\",0) >= 0) b += 1024;          // set bit 10\n                if (x_robots_tag.indexOf(\"nofollow\",0) >= 0) b += 2048;         // set bit 11\n                if (x_robots_tag.indexOf(\"unavailable_after\",0) >=0) b += 4096; // set bit 12\n            }\n            add(doc, YaCySchema.robots_i, b);\n\n            // meta tags: generator\n            final String generator = html.getMetas().get(\"generator\");\n            if (generator != null) add(doc, YaCySchema.metagenerator_t, generator);\n\n            // bold, italic\n            final String[] bold = html.getBold();\n            add(doc, YaCySchema.boldcount_i, bold.length);\n            if (bold.length > 0) {\n                add(doc, YaCySchema.bold_txt, bold);\n                if (allAttr || contains(YaCySchema.bold_val)) {\n                    add(doc, YaCySchema.bold_val, html.getBoldCount(bold));\n                }\n            }\n            final String[] italic = html.getItalic();\n            add(doc, YaCySchema.italiccount_i, italic.length);\n            if (italic.length > 0) {\n                add(doc, YaCySchema.italic_txt, italic);\n                if (allAttr || contains(YaCySchema.italic_val)) {\n                    add(doc, YaCySchema.italic_val, html.getItalicCount(italic));\n                }\n            }\n            final String[] underline = html.getUnderline();\n            add(doc, YaCySchema.underlinecount_i, underline.length);\n            if (underline.length > 0) {\n                add(doc, YaCySchema.underline_txt, underline);\n                if (allAttr || contains(YaCySchema.underline_val)) {\n                    add(doc, YaCySchema.underline_val, html.getUnderlineCount(underline));\n                }\n            }\n            final String[] li = html.getLi();\n            add(doc, YaCySchema.licount_i, li.length);\n            if (li.length > 0) add(doc, YaCySchema.li_txt, li);\n\n            // images\n            final Collection<ImageEntry> imagesc = images.values();\n            final List<String> imgtags  = new ArrayList<String>(imagesc.size());\n            final List<String> imgprots = new ArrayList<String>(imagesc.size());\n            final List<String> imgstubs = new ArrayList<String>(imagesc.size());\n            final List<String> imgalts  = new ArrayList<String>(imagesc.size());\n            int withalt = 0;\n            for (final ImageEntry ie: imagesc) {\n                final MultiProtocolURI uri = ie.url();\n                inboundLinks.remove(uri);\n                outboundLinks.remove(uri);\n                imgtags.add(ie.toString());\n                String protocol = uri.getProtocol();\n                imgprots.add(protocol);\n                imgstubs.add(uri.toString().substring(protocol.length() + 3));\n                imgalts.add(ie.alt());\n                if (ie.alt() != null && ie.alt().length() > 0) withalt++;\n            }\n            if (allAttr || contains(YaCySchema.imagescount_i)) add(doc, YaCySchema.imagescount_i, imgtags.size());\n            if (allAttr || contains(YaCySchema.images_tag_txt)) add(doc, YaCySchema.images_tag_txt, imgtags);\n            if (allAttr || contains(YaCySchema.images_protocol_sxt)) add(doc, YaCySchema.images_protocol_sxt, protocolList2indexedList(imgprots));\n            if (allAttr || contains(YaCySchema.images_urlstub_txt)) add(doc, YaCySchema.images_urlstub_txt, imgstubs);\n            if (allAttr || contains(YaCySchema.images_alt_txt)) add(doc, YaCySchema.images_alt_txt, imgalts);\n            if (allAttr || contains(YaCySchema.images_withalt_i)) add(doc, YaCySchema.images_withalt_i, withalt);\n\n            // style sheets\n            if (allAttr || contains(YaCySchema.css_tag_txt)) {\n                final Map<MultiProtocolURI, String> csss = html.getCSS();\n                final String[] css_tag = new String[csss.size()];\n                final String[] css_url = new String[csss.size()];\n                c = 0;\n                for (final Map.Entry<MultiProtocolURI, String> entry: csss.entrySet()) {\n                    final String url = entry.getKey().toNormalform(false);\n                    inboundLinks.remove(url);\n                    outboundLinks.remove(url);\n                    css_tag[c] =\n                        \"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" media=\\\"\" + entry.getValue() + \"\\\"\" +\n                        \" href=\\\"\"+ url + \"\\\" />\";\n                    css_url[c] = url;\n                    c++;\n                }\n                add(doc, YaCySchema.csscount_i, css_tag.length);\n                if (css_tag.length > 0) add(doc, YaCySchema.css_tag_txt, css_tag);\n                if (css_url.length > 0) add(doc, YaCySchema.css_url_txt, css_url);\n            }\n\n            // Scripts\n            if (allAttr || contains(YaCySchema.scripts_txt)) {\n                final Set<MultiProtocolURI> scriptss = html.getScript();\n                final String[] scripts = new String[scriptss.size()];\n                c = 0;\n                for (final MultiProtocolURI url: scriptss) {\n                    inboundLinks.remove(url);\n                    outboundLinks.remove(url);\n                    scripts[c++] = url.toNormalform(false);\n                }\n                add(doc, YaCySchema.scriptscount_i, scripts.length);\n                if (scripts.length > 0) add(doc, YaCySchema.scripts_txt, scripts);\n            }\n\n            // Frames\n            if (allAttr || contains(YaCySchema.frames_txt)) {\n                final Set<MultiProtocolURI> framess = html.getFrames();\n                final String[] frames = new String[framess.size()];\n                c = 0;\n                for (final MultiProtocolURI url: framess) {\n                    inboundLinks.remove(url);\n                    outboundLinks.remove(url);\n                    frames[c++] = url.toNormalform(false);\n                }\n                add(doc, YaCySchema.framesscount_i, frames.length);\n                if (frames.length > 0) add(doc, YaCySchema.frames_txt, frames);\n            }\n\n            // IFrames\n            if (allAttr || contains(YaCySchema.iframes_txt)) {\n                final Set<MultiProtocolURI> iframess = html.getIFrames();\n                final String[] iframes = new String[iframess.size()];\n                c = 0;\n                for (final MultiProtocolURI url: iframess) {\n                    inboundLinks.remove(url);\n                    outboundLinks.remove(url);\n                    iframes[c++] = url.toNormalform(false);\n                }\n                add(doc, YaCySchema.iframesscount_i, iframes.length);\n                if (iframes.length > 0) add(doc, YaCySchema.iframes_txt, iframes);\n            }\n\n            // canonical tag\n            if (allAttr || contains(YaCySchema.canonical_t)) {\n                final MultiProtocolURI canonical = html.getCanonical();\n                if (canonical != null) {\n                    inboundLinks.remove(canonical);\n                    outboundLinks.remove(canonical);\n                    add(doc, YaCySchema.canonical_t, canonical.toNormalform(false));\n                }\n            }\n\n            // meta refresh tag\n            if (allAttr || contains(YaCySchema.refresh_s)) {\n                String refresh = html.getRefreshPath();\n                if (refresh != null && refresh.length() > 0) {\n                    MultiProtocolURI refreshURL;\n                    try {\n                        refreshURL = refresh.startsWith(\"http\") ? new MultiProtocolURI(html.getRefreshPath()) : new MultiProtocolURI(digestURI, html.getRefreshPath());\n                        if (refreshURL != null) {\n                            inboundLinks.remove(refreshURL);\n                            outboundLinks.remove(refreshURL);\n                            add(doc, YaCySchema.refresh_s, refreshURL.toNormalform(false));\n                        }\n                    } catch (MalformedURLException e) {\n                        add(doc, YaCySchema.refresh_s, refresh);\n                    }\n                }\n            }\n\n            // flash embedded\n            if (allAttr || contains(YaCySchema.flash_b)) {\n                MultiProtocolURI[] flashURLs = html.getFlash();\n                for (MultiProtocolURI u: flashURLs) {\n                    // remove all flash links from ibound/outbound links\n                    inboundLinks.remove(u);\n                    outboundLinks.remove(u);\n                }\n                add(doc, YaCySchema.flash_b, flashURLs.length > 0);\n            }\n\n            // generic evaluation pattern\n            for (final String model: html.getEvaluationModelNames()) {\n                if (allAttr || contains(\"ext_\" + model + \"_txt\")) {\n                    final String[] scorenames = html.getEvaluationModelScoreNames(model);\n                    if (scorenames.length > 0) {\n                        add(doc, YaCySchema.valueOf(\"ext_\" + model + \"_txt\"), scorenames);\n                        add(doc, YaCySchema.valueOf(\"ext_\" + model + \"_val\"), html.getEvaluationModelScoreCounts(model, scorenames));\n                    }\n                }\n            }\n\n            // response time\n            add(doc, YaCySchema.responsetime_i, responseHeader == null ? 0 : Integer.parseInt(responseHeader.get(HeaderFramework.RESPONSE_TIME_MILLIS, \"0\")));\n        }\n\n        // list all links\n        final Map<MultiProtocolURI, Properties> alllinks = document.getAnchors();\n        c = 0;\n        if (allAttr || contains(YaCySchema.inboundlinkscount_i)) add(doc, YaCySchema.inboundlinkscount_i, inboundLinks.size());\n        if (allAttr || contains(YaCySchema.inboundlinksnofollowcount_i)) add(doc, YaCySchema.inboundlinksnofollowcount_i, document.inboundLinkNofollowCount());\n        final List<String> inboundlinksTag = new ArrayList<String>(inboundLinks.size());\n        final List<String> inboundlinksURLProtocol = new ArrayList<String>(inboundLinks.size());\n        final List<String> inboundlinksURLStub = new ArrayList<String>(inboundLinks.size());\n        final List<String> inboundlinksName = new ArrayList<String>(inboundLinks.size());\n        final List<String> inboundlinksRel = new ArrayList<String>(inboundLinks.size());\n        final List<String> inboundlinksText = new ArrayList<String>(inboundLinks.size());\n        final List<Integer> inboundlinksTextChars = new ArrayList<Integer>(inboundLinks.size());\n        final List<Integer> inboundlinksTextWords = new ArrayList<Integer>(inboundLinks.size());\n        final List<String> inboundlinksAltTag = new ArrayList<String>(inboundLinks.size());\n        for (final MultiProtocolURI url: inboundLinks) {\n            final Properties p = alllinks.get(url);\n            if (p == null) continue;\n            final String name = p.getProperty(\"name\", \"\"); // the name attribute\n            final String rel = p.getProperty(\"rel\", \"\");   // the rel-attribute\n            final String text = p.getProperty(\"text\", \"\"); // the text between the <a><\/a> tag\n            final String urls = url.toNormalform(false);\n            final int pr = urls.indexOf(\"://\",0);\n            inboundlinksURLProtocol.add(urls.substring(0, pr));\n            inboundlinksURLStub.add(urls.substring(pr + 3));\n            inboundlinksName.add(name.length() > 0 ? name : \"\");\n            inboundlinksRel.add(rel.length() > 0 ? rel : \"\");\n            inboundlinksText.add(text.length() > 0 ? text : \"\");\n            inboundlinksTextChars.add(text.length() > 0 ? text.length() : 0);\n            inboundlinksTextWords.add(text.length() > 0 ? text.split(\" \").length : 0);\n            inboundlinksTag.add(\n                \"<a href=\\\"\" + url.toNormalform(false) + \"\\\"\" +\n                (rel.length() > 0 ? \" rel=\\\"\" + rel + \"\\\"\" : \"\") +\n                (name.length() > 0 ? \" name=\\\"\" + name + \"\\\"\" : \"\") +\n                \">\" +\n                ((text.length() > 0) ? text : \"\") + \"<\/a>\");\n            ImageEntry ientry = images.get(url);\n            inboundlinksAltTag.add(ientry == null ? \"\" : ientry.alt());\n            c++;\n        }\n        if (allAttr || contains(YaCySchema.inboundlinks_tag_txt)) add(doc, YaCySchema.inboundlinks_tag_txt, inboundlinksTag);\n        if (allAttr || contains(YaCySchema.inboundlinks_protocol_sxt)) add(doc, YaCySchema.inboundlinks_protocol_sxt, protocolList2indexedList(inboundlinksURLProtocol));\n        if (allAttr || contains(YaCySchema.inboundlinks_urlstub_txt)) add(doc, YaCySchema.inboundlinks_urlstub_txt, inboundlinksURLStub);\n        if (allAttr || contains(YaCySchema.inboundlinks_name_txt)) add(doc, YaCySchema.inboundlinks_name_txt, inboundlinksName);\n        if (allAttr || contains(YaCySchema.inboundlinks_rel_sxt)) add(doc, YaCySchema.inboundlinks_rel_sxt, inboundlinksRel);\n        if (allAttr || contains(YaCySchema.inboundlinks_relflags_val)) add(doc, YaCySchema.inboundlinks_relflags_val, relEval(inboundlinksRel));\n        if (allAttr || contains(YaCySchema.inboundlinks_text_txt)) add(doc, YaCySchema.inboundlinks_text_txt, inboundlinksText);\n        if (allAttr || contains(YaCySchema.inboundlinks_text_chars_val)) add(doc, YaCySchema.inboundlinks_text_chars_val, inboundlinksTextChars);\n        if (allAttr || contains(YaCySchema.inboundlinks_text_words_val)) add(doc, YaCySchema.inboundlinks_text_words_val, inboundlinksTextWords);\n        if (allAttr || contains(YaCySchema.inboundlinks_alttag_txt)) add(doc, YaCySchema.inboundlinks_alttag_txt, inboundlinksAltTag);\n\n        c = 0;\n        if (allAttr || contains(YaCySchema.outboundlinkscount_i)) add(doc, YaCySchema.outboundlinkscount_i, outboundLinks.size());\n        if (allAttr || contains(YaCySchema.outboundlinksnofollowcount_i)) add(doc, YaCySchema.outboundlinksnofollowcount_i, document.outboundLinkNofollowCount());\n        final List<String> outboundlinksTag = new ArrayList<String>(outboundLinks.size());\n        final List<String> outboundlinksURLProtocol = new ArrayList<String>(outboundLinks.size());\n        final List<String> outboundlinksURLStub = new ArrayList<String>(outboundLinks.size());\n        final List<String> outboundlinksName = new ArrayList<String>(outboundLinks.size());\n        final List<String> outboundlinksRel = new ArrayList<String>(outboundLinks.size());\n        final List<Integer> outboundlinksTextChars = new ArrayList<Integer>(outboundLinks.size());\n        final List<Integer> outboundlinksTextWords = new ArrayList<Integer>(outboundLinks.size());\n        final List<String> outboundlinksText = new ArrayList<String>(outboundLinks.size());\n        final List<String> outboundlinksAltTag = new ArrayList<String>(outboundLinks.size());\n        for (final MultiProtocolURI url: outboundLinks) {\n            final Properties p = alllinks.get(url);\n            if (p == null) continue;\n            final String name = p.getProperty(\"name\", \"\"); // the name attribute\n            final String rel = p.getProperty(\"rel\", \"\");   // the rel-attribute\n            final String text = p.getProperty(\"text\", \"\"); // the text between the <a><\/a> tag\n            final String urls = url.toNormalform(false);\n            final int pr = urls.indexOf(\"://\",0);\n            outboundlinksURLProtocol.add(urls.substring(0, pr));\n            outboundlinksURLStub.add(urls.substring(pr + 3));\n            outboundlinksName.add(name.length() > 0 ? name : \"\");\n            outboundlinksRel.add(rel.length() > 0 ? rel : \"\");\n            outboundlinksText.add(text.length() > 0 ? text : \"\");\n            outboundlinksTextChars.add(text.length() > 0 ? text.length() : 0);\n            outboundlinksTextWords.add(text.length() > 0 ? text.split(\" \").length : 0);\n            outboundlinksTag.add(\n                \"<a href=\\\"\" + url.toNormalform(false) + \"\\\"\" +\n                (rel.length() > 0 ? \" rel=\\\"\" + rel + \"\\\"\" : \"\") +\n                (name.length() > 0 ? \" name=\\\"\" + name + \"\\\"\" : \"\") +\n                \">\" +\n                ((text.length() > 0) ? text : \"\") + \"<\/a>\");\n            ImageEntry ientry = images.get(url);\n            inboundlinksAltTag.add(ientry == null ? \"\" : ientry.alt());\n            c++;\n        }\n        if (allAttr || contains(YaCySchema.outboundlinks_tag_txt)) add(doc, YaCySchema.outboundlinks_tag_txt, outboundlinksTag);\n        if (allAttr || contains(YaCySchema.outboundlinks_protocol_sxt)) add(doc, YaCySchema.outboundlinks_protocol_sxt, protocolList2indexedList(outboundlinksURLProtocol));\n        if (allAttr || contains(YaCySchema.outboundlinks_urlstub_txt)) add(doc, YaCySchema.outboundlinks_urlstub_txt, outboundlinksURLStub);\n        if (allAttr || contains(YaCySchema.outboundlinks_name_txt)) add(doc, YaCySchema.outboundlinks_name_txt, outboundlinksName);\n        if (allAttr || contains(YaCySchema.outboundlinks_rel_sxt)) add(doc, YaCySchema.outboundlinks_rel_sxt, outboundlinksRel);\n        if (allAttr || contains(YaCySchema.outboundlinks_relflags_val)) add(doc, YaCySchema.outboundlinks_relflags_val, relEval(outboundlinksRel));\n        if (allAttr || contains(YaCySchema.outboundlinks_text_txt)) add(doc, YaCySchema.outboundlinks_text_txt, outboundlinksText);\n        if (allAttr || contains(YaCySchema.outboundlinks_text_chars_val)) add(doc, YaCySchema.outboundlinks_text_chars_val, outboundlinksTextChars);\n        if (allAttr || contains(YaCySchema.outboundlinks_text_words_val)) add(doc, YaCySchema.outboundlinks_text_words_val, outboundlinksTextWords);\n        if (allAttr || contains(YaCySchema.outboundlinks_alttag_txt)) add(doc, YaCySchema.outboundlinks_alttag_txt, outboundlinksAltTag);\n\n        // charset\n        if (allAttr || contains(YaCySchema.charset_s)) add(doc, YaCySchema.charset_s, document.getCharset());\n\n        // coordinates\n        if (document.lat() != 0.0f && document.lon() != 0.0f) {\n            if (allAttr || contains(YaCySchema.coordinate_p)) add(doc, YaCySchema.coordinate_p, Double.toString(document.lat()) + \",\" + Double.toString(document.lon()));\n        }\n        if (allAttr || contains(YaCySchema.httpstatus_i)) add(doc, YaCySchema.httpstatus_i, responseHeader == null ? 200 : responseHeader.getStatusCode());\n\n        // fields that were additionally in URIMetadataRow\n        Date loadDate = new Date();\n        Date modDate = responseHeader.lastModified();\n        if (modDate.getTime() > loadDate.getTime()) modDate = loadDate;\n        int size = (int) Math.max(document.dc_source().length(), responseHeader.getContentLength());\n        if (allAttr || contains(YaCySchema.load_date_dt)) add(doc, YaCySchema.load_date_dt, loadDate);\n        if (allAttr || contains(YaCySchema.fresh_date_dt)) add(doc, YaCySchema.fresh_date_dt, new Date(loadDate.getTime() + Math.max(0, loadDate.getTime() - modDate.getTime()) / 2)); // freshdate, computed with Proxy-TTL formula\n        if (allAttr || contains(YaCySchema.host_id_s)) add(doc, YaCySchema.host_id_s, document.dc_source().hosthash());\n        if ((allAttr || contains(YaCySchema.referrer_id_txt)) && referrerURL != null) add(doc, YaCySchema.referrer_id_txt, new String[]{ASCII.String(referrerURL.hash())});\n        //if (allAttr || contains(SolrField.md5_s)) add(solrdoc, SolrField.md5_s, new byte[0]);\n        if (allAttr || contains(YaCySchema.publisher_t)) add(doc, YaCySchema.publisher_t, document.dc_publisher());\n        if ((allAttr || contains(YaCySchema.language_s)) && language != null) add(doc, YaCySchema.language_s, language);\n        if (allAttr || contains(YaCySchema.size_i)) add(doc, YaCySchema.size_i, size);\n        if (allAttr || contains(YaCySchema.audiolinkscount_i)) add(doc, YaCySchema.audiolinkscount_i, document.getAudiolinks().size());\n        if (allAttr || contains(YaCySchema.videolinkscount_i)) add(doc, YaCySchema.videolinkscount_i, document.getVideolinks().size());\n        if (allAttr || contains(YaCySchema.applinkscount_i)) add(doc, YaCySchema.applinkscount_i, document.getApplinks().size());\n\n        return doc;\n    }","id":28550,"modified_method":"protected SolrInputDocument yacy2solr(final String id, final CrawlProfile profile, final ResponseHeader responseHeader, final Document document, Condenser condenser, DigestURI referrerURL, String language) {\n        // we use the SolrCell design as index scheme\n        final SolrInputDocument doc = new SolrInputDocument();\n        final DigestURI digestURI = DigestURI.toDigestURI(document.dc_source());\n        boolean allAttr = this.isEmpty();\n        add(doc, YaCySchema.id, id);\n        if (allAttr || contains(YaCySchema.failreason_t)) add(doc, YaCySchema.failreason_t, \"\"); // overwrite a possible fail reason (in case that there was a fail reason before)\n        String us = digestURI.toNormalform(true);\n        add(doc, YaCySchema.sku, us);\n        if (allAttr || contains(YaCySchema.ip_s)) {\n            final InetAddress address = digestURI.getInetAddress();\n            if (address != null) add(doc, YaCySchema.ip_s, address.getHostAddress());\n        }\n        if (allAttr || contains(YaCySchema.collection_sxt) && profile != null) add(doc, YaCySchema.collection_sxt, profile.collections());\n        if (allAttr || contains(YaCySchema.url_protocol_s)) add(doc, YaCySchema.url_protocol_s, digestURI.getProtocol());\n        Map<String, String> searchpart = digestURI.getSearchpartMap();\n        if (searchpart == null) {\n            if (allAttr || contains(YaCySchema.url_parameter_i)) add(doc, YaCySchema.url_parameter_i, 0);\n        } else {\n            if (allAttr || contains(YaCySchema.url_parameter_i)) add(doc, YaCySchema.url_parameter_i, searchpart.size());\n            if (allAttr || contains(YaCySchema.url_parameter_key_sxt)) add(doc, YaCySchema.url_parameter_key_sxt, searchpart.keySet().toArray(new String[searchpart.size()]));\n            if (allAttr || contains(YaCySchema.url_parameter_value_sxt)) add(doc, YaCySchema.url_parameter_value_sxt,  searchpart.values().toArray(new String[searchpart.size()]));\n        }\n        if (allAttr || contains(YaCySchema.url_chars_i)) add(doc, YaCySchema.url_chars_i, us.length());\n        String host = null;\n        if ((host = digestURI.getHost()) != null) {\n            String dnc = Domains.getDNC(host);\n            String subdomOrga = host.substring(0, host.length() - dnc.length() - 1);\n            int p = subdomOrga.lastIndexOf('.');\n            String subdom = (p < 0) ? \"\" : subdomOrga.substring(0, p);\n            String orga = (p < 0) ? subdomOrga : subdomOrga.substring(p + 1);\n            if (allAttr || contains(YaCySchema.host_s)) add(doc, YaCySchema.host_s, host);\n            if (allAttr || contains(YaCySchema.host_dnc_s)) add(doc, YaCySchema.host_dnc_s, dnc);\n            if (allAttr || contains(YaCySchema.host_organization_s)) add(doc, YaCySchema.host_organization_s, orga);\n            if (allAttr || contains(YaCySchema.host_organizationdnc_s)) add(doc, YaCySchema.host_organizationdnc_s, orga + '.' + dnc);\n            if (allAttr || contains(YaCySchema.host_subdomain_s)) add(doc, YaCySchema.host_subdomain_s, subdom);\n        }\n\n        List<String> titles = document.titles();\n        if (allAttr || contains(YaCySchema.title)) add(doc, YaCySchema.title, titles);\n        if (allAttr || contains(YaCySchema.title_count_i)) add(doc, YaCySchema.title_count_i, titles.size());\n        if (allAttr || contains(YaCySchema.title_chars_val)) {\n            ArrayList<Integer> cv = new ArrayList<Integer>(titles.size());\n            for (String s: titles) cv.add(new Integer(s.length()));\n            add(doc, YaCySchema.title_chars_val, cv);\n        }\n        if (allAttr || contains(YaCySchema.title_words_val)) {\n            ArrayList<Integer> cv = new ArrayList<Integer>(titles.size());\n            for (String s: titles) cv.add(new Integer(s.split(\" \").length));\n            add(doc, YaCySchema.title_words_val, cv);\n        }\n\n        String description = document.dc_description();\n        List<String> descriptions = new ArrayList<String>();\n        for (String s: description.split(\"\\n\")) descriptions.add(s);\n        if (allAttr || contains(YaCySchema.description)) add(doc, YaCySchema.description, description);\n        if (allAttr || contains(YaCySchema.description_count_i)) add(doc, YaCySchema.description_count_i, descriptions.size());\n        if (allAttr || contains(YaCySchema.description_chars_val)) {\n            ArrayList<Integer> cv = new ArrayList<Integer>(descriptions.size());\n            for (String s: descriptions) cv.add(new Integer(s.length()));\n            add(doc, YaCySchema.description_chars_val, cv);\n        }\n        if (allAttr || contains(YaCySchema.description_words_val)) {\n            ArrayList<Integer> cv = new ArrayList<Integer>(descriptions.size());\n            for (String s: descriptions) cv.add(new Integer(s.split(\" \").length));\n            add(doc, YaCySchema.description_words_val, cv);\n        }\n\n        if (allAttr || contains(YaCySchema.author)) add(doc, YaCySchema.author, document.dc_creator());\n        if (allAttr || contains(YaCySchema.content_type)) add(doc, YaCySchema.content_type, new String[]{document.dc_format()});\n        if (allAttr || contains(YaCySchema.last_modified)) add(doc, YaCySchema.last_modified, responseHeader == null ? new Date() : responseHeader.lastModified());\n        if (allAttr || contains(YaCySchema.keywords)) add(doc, YaCySchema.keywords, document.dc_subject(' '));\n        final String content = document.getTextString();\n        if (allAttr || contains(YaCySchema.text_t)) add(doc, YaCySchema.text_t, content);\n        if (allAttr || contains(YaCySchema.wordcount_i)) {\n            final int contentwc = content.split(\" \").length;\n            add(doc, YaCySchema.wordcount_i, contentwc);\n        }\n        if (allAttr || contains(YaCySchema.synonyms_sxt)) {\n            List<String> synonyms = condenser.synonyms();\n            add(doc, YaCySchema.synonyms_sxt, synonyms);\n        }\n\n        // path elements of link\n        if (allAttr || contains(YaCySchema.url_paths_sxt)) add(doc, YaCySchema.url_paths_sxt, digestURI.getPaths());\n        if (allAttr || contains(YaCySchema.url_file_ext_s)) add(doc, YaCySchema.url_file_ext_s, digestURI.getFileExtension());\n\n        // get list of all links; they will be shrinked by urls that appear in other fields of the solr scheme\n        Set<MultiProtocolURI> inboundLinks = document.inboundLinks();\n        Set<MultiProtocolURI> outboundLinks = document.outboundLinks();\n\n        int c = 0;\n        final Object parser = document.getParserObject();\n        Map<MultiProtocolURI, ImageEntry> images = new HashMap<MultiProtocolURI, ImageEntry>();\n        if (parser instanceof ContentScraper) {\n            final ContentScraper html = (ContentScraper) parser;\n            images = html.getImages();\n\n            // header tags\n            int h = 0;\n            int f = 1;\n            String[] hs;\n\n            hs = html.getHeadlines(1); h = h | (hs.length > 0 ? f : 0); f = f * 2; add(doc, YaCySchema.h1_txt, hs); add(doc, YaCySchema.h1_i, hs.length);\n            hs = html.getHeadlines(2); h = h | (hs.length > 0 ? f : 0); f = f * 2; add(doc, YaCySchema.h2_txt, hs); add(doc, YaCySchema.h2_i, hs.length);\n            hs = html.getHeadlines(3); h = h | (hs.length > 0 ? f : 0); f = f * 2; add(doc, YaCySchema.h3_txt, hs); add(doc, YaCySchema.h3_i, hs.length);\n            hs = html.getHeadlines(4); h = h | (hs.length > 0 ? f : 0); f = f * 2; add(doc, YaCySchema.h4_txt, hs); add(doc, YaCySchema.h4_i, hs.length);\n            hs = html.getHeadlines(5); h = h | (hs.length > 0 ? f : 0); f = f * 2; add(doc, YaCySchema.h5_txt, hs); add(doc, YaCySchema.h5_i, hs.length);\n            hs = html.getHeadlines(6); h = h | (hs.length > 0 ? f : 0); f = f * 2; add(doc, YaCySchema.h6_txt, hs); add(doc, YaCySchema.h6_i, hs.length);\n       \n            add(doc, YaCySchema.htags_i, h);\n            add(doc, YaCySchema.schema_org_breadcrumb_i, html.breadcrumbCount());\n\n            // meta tags: Open Graph properties\n            String og;\n            og = html.getMetas().get(\"og:title\"); if (og != null) add(doc, YaCySchema.opengraph_title_t, og);\n            og = html.getMetas().get(\"og:type\"); if (og != null) add(doc, YaCySchema.opengraph_type_s, og);\n            og = html.getMetas().get(\"og:url\"); if (og != null) add(doc, YaCySchema.opengraph_url_s, og);\n            og = html.getMetas().get(\"og:image\"); if (og != null) add(doc, YaCySchema.opengraph_image_s, og);\n\n            // noindex and nofollow attributes\n            // from HTML (meta-tag in HTML header: robots)\n            // and HTTP header (x-robots property)\n            // coded as binary value:\n            // bit  0: \"all\" contained in html header meta\n            // bit  1: \"index\" contained in html header meta\n            // bit  2: \"noindex\" contained in html header meta\n            // bit  3: \"nofollow\" contained in html header meta\n            // bit  8: \"noarchive\" contained in http header properties\n            // bit  9: \"nosnippet\" contained in http header properties\n            // bit 10: \"noindex\" contained in http header properties\n            // bit 11: \"nofollow\" contained in http header properties\n            // bit 12: \"unavailable_after\" contained in http header properties\n            int b = 0;\n            final String robots_meta = html.getMetas().get(\"robots\");\n            // this tag may have values: all, index, noindex, nofollow\n            if (robots_meta != null) {\n                if (robots_meta.indexOf(\"all\",0) >= 0) b += 1;      // set bit 0\n                if (robots_meta.indexOf(\"index\",0) == 0 || robots_meta.indexOf(\" index\",0) >= 0 || robots_meta.indexOf(\",index\",0) >= 0 ) b += 2; // set bit 1\n                if (robots_meta.indexOf(\"noindex\",0) >= 0) b += 4;  // set bit 2\n                if (robots_meta.indexOf(\"nofollow\",0) >= 0) b += 8; // set bit 3\n            }\n            String x_robots_tag = \"\";\n            if (responseHeader != null) {\n                x_robots_tag = responseHeader.get(HeaderFramework.X_ROBOTS_TAG, \"\");\n                if (x_robots_tag.isEmpty()) {\n                    x_robots_tag = responseHeader.get(HeaderFramework.X_ROBOTS, \"\");\n                }\n            }\n            if (!x_robots_tag.isEmpty()) {\n                // this tag may have values: noarchive, nosnippet, noindex, unavailable_after\n                if (x_robots_tag.indexOf(\"noarchive\",0) >= 0) b += 256;         // set bit 8\n                if (x_robots_tag.indexOf(\"nosnippet\",0) >= 0) b += 512;         // set bit 9\n                if (x_robots_tag.indexOf(\"noindex\",0) >= 0) b += 1024;          // set bit 10\n                if (x_robots_tag.indexOf(\"nofollow\",0) >= 0) b += 2048;         // set bit 11\n                if (x_robots_tag.indexOf(\"unavailable_after\",0) >=0) b += 4096; // set bit 12\n            }\n            add(doc, YaCySchema.robots_i, b);\n\n            // meta tags: generator\n            final String generator = html.getMetas().get(\"generator\");\n            if (generator != null) add(doc, YaCySchema.metagenerator_t, generator);\n\n            // bold, italic\n            final String[] bold = html.getBold();\n            add(doc, YaCySchema.boldcount_i, bold.length);\n            if (bold.length > 0) {\n                add(doc, YaCySchema.bold_txt, bold);\n                if (allAttr || contains(YaCySchema.bold_val)) {\n                    add(doc, YaCySchema.bold_val, html.getBoldCount(bold));\n                }\n            }\n            final String[] italic = html.getItalic();\n            add(doc, YaCySchema.italiccount_i, italic.length);\n            if (italic.length > 0) {\n                add(doc, YaCySchema.italic_txt, italic);\n                if (allAttr || contains(YaCySchema.italic_val)) {\n                    add(doc, YaCySchema.italic_val, html.getItalicCount(italic));\n                }\n            }\n            final String[] underline = html.getUnderline();\n            add(doc, YaCySchema.underlinecount_i, underline.length);\n            if (underline.length > 0) {\n                add(doc, YaCySchema.underline_txt, underline);\n                if (allAttr || contains(YaCySchema.underline_val)) {\n                    add(doc, YaCySchema.underline_val, html.getUnderlineCount(underline));\n                }\n            }\n            final String[] li = html.getLi();\n            add(doc, YaCySchema.licount_i, li.length);\n            if (li.length > 0) add(doc, YaCySchema.li_txt, li);\n\n            // images\n            final Collection<ImageEntry> imagesc = images.values();\n            final List<String> imgtags  = new ArrayList<String>(imagesc.size());\n            final List<String> imgprots = new ArrayList<String>(imagesc.size());\n            final List<String> imgstubs = new ArrayList<String>(imagesc.size());\n            final List<String> imgalts  = new ArrayList<String>(imagesc.size());\n            int withalt = 0;\n            for (final ImageEntry ie: imagesc) {\n                final MultiProtocolURI uri = ie.url();\n                inboundLinks.remove(uri);\n                outboundLinks.remove(uri);\n                imgtags.add(ie.toString());\n                String protocol = uri.getProtocol();\n                imgprots.add(protocol);\n                imgstubs.add(uri.toString().substring(protocol.length() + 3));\n                imgalts.add(ie.alt());\n                if (ie.alt() != null && ie.alt().length() > 0) withalt++;\n            }\n            if (allAttr || contains(YaCySchema.imagescount_i)) add(doc, YaCySchema.imagescount_i, imgtags.size());\n            if (allAttr || contains(YaCySchema.images_tag_txt)) add(doc, YaCySchema.images_tag_txt, imgtags);\n            if (allAttr || contains(YaCySchema.images_protocol_sxt)) add(doc, YaCySchema.images_protocol_sxt, protocolList2indexedList(imgprots));\n            if (allAttr || contains(YaCySchema.images_urlstub_txt)) add(doc, YaCySchema.images_urlstub_txt, imgstubs);\n            if (allAttr || contains(YaCySchema.images_alt_txt)) add(doc, YaCySchema.images_alt_txt, imgalts);\n            if (allAttr || contains(YaCySchema.images_withalt_i)) add(doc, YaCySchema.images_withalt_i, withalt);\n\n            // style sheets\n            if (allAttr || contains(YaCySchema.css_tag_txt)) {\n                final Map<MultiProtocolURI, String> csss = html.getCSS();\n                final String[] css_tag = new String[csss.size()];\n                final String[] css_url = new String[csss.size()];\n                c = 0;\n                for (final Map.Entry<MultiProtocolURI, String> entry: csss.entrySet()) {\n                    final String url = entry.getKey().toNormalform(false);\n                    inboundLinks.remove(url);\n                    outboundLinks.remove(url);\n                    css_tag[c] =\n                        \"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" media=\\\"\" + entry.getValue() + \"\\\"\" +\n                        \" href=\\\"\"+ url + \"\\\" />\";\n                    css_url[c] = url;\n                    c++;\n                }\n                add(doc, YaCySchema.csscount_i, css_tag.length);\n                if (css_tag.length > 0) add(doc, YaCySchema.css_tag_txt, css_tag);\n                if (css_url.length > 0) add(doc, YaCySchema.css_url_txt, css_url);\n            }\n\n            // Scripts\n            if (allAttr || contains(YaCySchema.scripts_txt)) {\n                final Set<MultiProtocolURI> scriptss = html.getScript();\n                final String[] scripts = new String[scriptss.size()];\n                c = 0;\n                for (final MultiProtocolURI url: scriptss) {\n                    inboundLinks.remove(url);\n                    outboundLinks.remove(url);\n                    scripts[c++] = url.toNormalform(false);\n                }\n                add(doc, YaCySchema.scriptscount_i, scripts.length);\n                if (scripts.length > 0) add(doc, YaCySchema.scripts_txt, scripts);\n            }\n\n            // Frames\n            if (allAttr || contains(YaCySchema.frames_txt)) {\n                final Set<MultiProtocolURI> framess = html.getFrames();\n                final String[] frames = new String[framess.size()];\n                c = 0;\n                for (final MultiProtocolURI url: framess) {\n                    inboundLinks.remove(url);\n                    outboundLinks.remove(url);\n                    frames[c++] = url.toNormalform(false);\n                }\n                add(doc, YaCySchema.framesscount_i, frames.length);\n                if (frames.length > 0) add(doc, YaCySchema.frames_txt, frames);\n            }\n\n            // IFrames\n            if (allAttr || contains(YaCySchema.iframes_txt)) {\n                final Set<MultiProtocolURI> iframess = html.getIFrames();\n                final String[] iframes = new String[iframess.size()];\n                c = 0;\n                for (final MultiProtocolURI url: iframess) {\n                    inboundLinks.remove(url);\n                    outboundLinks.remove(url);\n                    iframes[c++] = url.toNormalform(false);\n                }\n                add(doc, YaCySchema.iframesscount_i, iframes.length);\n                if (iframes.length > 0) add(doc, YaCySchema.iframes_txt, iframes);\n            }\n\n            // canonical tag\n            if (allAttr || contains(YaCySchema.canonical_t)) {\n                final MultiProtocolURI canonical = html.getCanonical();\n                if (canonical != null) {\n                    inboundLinks.remove(canonical);\n                    outboundLinks.remove(canonical);\n                    add(doc, YaCySchema.canonical_t, canonical.toNormalform(false));\n                }\n            }\n\n            // meta refresh tag\n            if (allAttr || contains(YaCySchema.refresh_s)) {\n                String refresh = html.getRefreshPath();\n                if (refresh != null && refresh.length() > 0) {\n                    MultiProtocolURI refreshURL;\n                    try {\n                        refreshURL = refresh.startsWith(\"http\") ? new MultiProtocolURI(html.getRefreshPath()) : new MultiProtocolURI(digestURI, html.getRefreshPath());\n                        if (refreshURL != null) {\n                            inboundLinks.remove(refreshURL);\n                            outboundLinks.remove(refreshURL);\n                            add(doc, YaCySchema.refresh_s, refreshURL.toNormalform(false));\n                        }\n                    } catch (MalformedURLException e) {\n                        add(doc, YaCySchema.refresh_s, refresh);\n                    }\n                }\n            }\n\n            // flash embedded\n            if (allAttr || contains(YaCySchema.flash_b)) {\n                MultiProtocolURI[] flashURLs = html.getFlash();\n                for (MultiProtocolURI u: flashURLs) {\n                    // remove all flash links from ibound/outbound links\n                    inboundLinks.remove(u);\n                    outboundLinks.remove(u);\n                }\n                add(doc, YaCySchema.flash_b, flashURLs.length > 0);\n            }\n\n            // generic evaluation pattern\n            for (final String model: html.getEvaluationModelNames()) {\n                if (allAttr || contains(\"ext_\" + model + \"_txt\")) {\n                    final String[] scorenames = html.getEvaluationModelScoreNames(model);\n                    if (scorenames.length > 0) {\n                        add(doc, YaCySchema.valueOf(\"ext_\" + model + \"_txt\"), scorenames);\n                        add(doc, YaCySchema.valueOf(\"ext_\" + model + \"_val\"), html.getEvaluationModelScoreCounts(model, scorenames));\n                    }\n                }\n            }\n\n            // response time\n            add(doc, YaCySchema.responsetime_i, responseHeader == null ? 0 : Integer.parseInt(responseHeader.get(HeaderFramework.RESPONSE_TIME_MILLIS, \"0\")));\n        }\n\n        // list all links\n        final Map<MultiProtocolURI, Properties> alllinks = document.getAnchors();\n        c = 0;\n        if (allAttr || contains(YaCySchema.inboundlinkscount_i)) add(doc, YaCySchema.inboundlinkscount_i, inboundLinks.size());\n        if (allAttr || contains(YaCySchema.inboundlinksnofollowcount_i)) add(doc, YaCySchema.inboundlinksnofollowcount_i, document.inboundLinkNofollowCount());\n        final List<String> inboundlinksTag = new ArrayList<String>(inboundLinks.size());\n        final List<String> inboundlinksURLProtocol = new ArrayList<String>(inboundLinks.size());\n        final List<String> inboundlinksURLStub = new ArrayList<String>(inboundLinks.size());\n        final List<String> inboundlinksName = new ArrayList<String>(inboundLinks.size());\n        final List<String> inboundlinksRel = new ArrayList<String>(inboundLinks.size());\n        final List<String> inboundlinksText = new ArrayList<String>(inboundLinks.size());\n        final List<Integer> inboundlinksTextChars = new ArrayList<Integer>(inboundLinks.size());\n        final List<Integer> inboundlinksTextWords = new ArrayList<Integer>(inboundLinks.size());\n        final List<String> inboundlinksAltTag = new ArrayList<String>(inboundLinks.size());\n        for (final MultiProtocolURI url: inboundLinks) {\n            final Properties p = alllinks.get(url);\n            if (p == null) continue;\n            final String name = p.getProperty(\"name\", \"\"); // the name attribute\n            final String rel = p.getProperty(\"rel\", \"\");   // the rel-attribute\n            final String text = p.getProperty(\"text\", \"\"); // the text between the <a><\/a> tag\n            final String urls = url.toNormalform(false);\n            final int pr = urls.indexOf(\"://\",0);\n            inboundlinksURLProtocol.add(urls.substring(0, pr));\n            inboundlinksURLStub.add(urls.substring(pr + 3));\n            inboundlinksName.add(name.length() > 0 ? name : \"\");\n            inboundlinksRel.add(rel.length() > 0 ? rel : \"\");\n            inboundlinksText.add(text.length() > 0 ? text : \"\");\n            inboundlinksTextChars.add(text.length() > 0 ? text.length() : 0);\n            inboundlinksTextWords.add(text.length() > 0 ? text.split(\" \").length : 0);\n            inboundlinksTag.add(\n                \"<a href=\\\"\" + url.toNormalform(false) + \"\\\"\" +\n                (rel.length() > 0 ? \" rel=\\\"\" + rel + \"\\\"\" : \"\") +\n                (name.length() > 0 ? \" name=\\\"\" + name + \"\\\"\" : \"\") +\n                \">\" +\n                ((text.length() > 0) ? text : \"\") + \"<\/a>\");\n            ImageEntry ientry = images.get(url);\n            inboundlinksAltTag.add(ientry == null ? \"\" : ientry.alt());\n            c++;\n        }\n        if (allAttr || contains(YaCySchema.inboundlinks_tag_txt)) add(doc, YaCySchema.inboundlinks_tag_txt, inboundlinksTag);\n        if (allAttr || contains(YaCySchema.inboundlinks_protocol_sxt)) add(doc, YaCySchema.inboundlinks_protocol_sxt, protocolList2indexedList(inboundlinksURLProtocol));\n        if (allAttr || contains(YaCySchema.inboundlinks_urlstub_txt)) add(doc, YaCySchema.inboundlinks_urlstub_txt, inboundlinksURLStub);\n        if (allAttr || contains(YaCySchema.inboundlinks_name_txt)) add(doc, YaCySchema.inboundlinks_name_txt, inboundlinksName);\n        if (allAttr || contains(YaCySchema.inboundlinks_rel_sxt)) add(doc, YaCySchema.inboundlinks_rel_sxt, inboundlinksRel);\n        if (allAttr || contains(YaCySchema.inboundlinks_relflags_val)) add(doc, YaCySchema.inboundlinks_relflags_val, relEval(inboundlinksRel));\n        if (allAttr || contains(YaCySchema.inboundlinks_text_txt)) add(doc, YaCySchema.inboundlinks_text_txt, inboundlinksText);\n        if (allAttr || contains(YaCySchema.inboundlinks_text_chars_val)) add(doc, YaCySchema.inboundlinks_text_chars_val, inboundlinksTextChars);\n        if (allAttr || contains(YaCySchema.inboundlinks_text_words_val)) add(doc, YaCySchema.inboundlinks_text_words_val, inboundlinksTextWords);\n        if (allAttr || contains(YaCySchema.inboundlinks_alttag_txt)) add(doc, YaCySchema.inboundlinks_alttag_txt, inboundlinksAltTag);\n\n        c = 0;\n        if (allAttr || contains(YaCySchema.outboundlinkscount_i)) add(doc, YaCySchema.outboundlinkscount_i, outboundLinks.size());\n        if (allAttr || contains(YaCySchema.outboundlinksnofollowcount_i)) add(doc, YaCySchema.outboundlinksnofollowcount_i, document.outboundLinkNofollowCount());\n        final List<String> outboundlinksTag = new ArrayList<String>(outboundLinks.size());\n        final List<String> outboundlinksURLProtocol = new ArrayList<String>(outboundLinks.size());\n        final List<String> outboundlinksURLStub = new ArrayList<String>(outboundLinks.size());\n        final List<String> outboundlinksName = new ArrayList<String>(outboundLinks.size());\n        final List<String> outboundlinksRel = new ArrayList<String>(outboundLinks.size());\n        final List<Integer> outboundlinksTextChars = new ArrayList<Integer>(outboundLinks.size());\n        final List<Integer> outboundlinksTextWords = new ArrayList<Integer>(outboundLinks.size());\n        final List<String> outboundlinksText = new ArrayList<String>(outboundLinks.size());\n        final List<String> outboundlinksAltTag = new ArrayList<String>(outboundLinks.size());\n        for (final MultiProtocolURI url: outboundLinks) {\n            final Properties p = alllinks.get(url);\n            if (p == null) continue;\n            final String name = p.getProperty(\"name\", \"\"); // the name attribute\n            final String rel = p.getProperty(\"rel\", \"\");   // the rel-attribute\n            final String text = p.getProperty(\"text\", \"\"); // the text between the <a><\/a> tag\n            final String urls = url.toNormalform(false);\n            final int pr = urls.indexOf(\"://\",0);\n            outboundlinksURLProtocol.add(urls.substring(0, pr));\n            outboundlinksURLStub.add(urls.substring(pr + 3));\n            outboundlinksName.add(name.length() > 0 ? name : \"\");\n            outboundlinksRel.add(rel.length() > 0 ? rel : \"\");\n            outboundlinksText.add(text.length() > 0 ? text : \"\");\n            outboundlinksTextChars.add(text.length() > 0 ? text.length() : 0);\n            outboundlinksTextWords.add(text.length() > 0 ? text.split(\" \").length : 0);\n            outboundlinksTag.add(\n                \"<a href=\\\"\" + url.toNormalform(false) + \"\\\"\" +\n                (rel.length() > 0 ? \" rel=\\\"\" + rel + \"\\\"\" : \"\") +\n                (name.length() > 0 ? \" name=\\\"\" + name + \"\\\"\" : \"\") +\n                \">\" +\n                ((text.length() > 0) ? text : \"\") + \"<\/a>\");\n            ImageEntry ientry = images.get(url);\n            inboundlinksAltTag.add(ientry == null ? \"\" : ientry.alt());\n            c++;\n        }\n        if (allAttr || contains(YaCySchema.outboundlinks_tag_txt)) add(doc, YaCySchema.outboundlinks_tag_txt, outboundlinksTag);\n        if (allAttr || contains(YaCySchema.outboundlinks_protocol_sxt)) add(doc, YaCySchema.outboundlinks_protocol_sxt, protocolList2indexedList(outboundlinksURLProtocol));\n        if (allAttr || contains(YaCySchema.outboundlinks_urlstub_txt)) add(doc, YaCySchema.outboundlinks_urlstub_txt, outboundlinksURLStub);\n        if (allAttr || contains(YaCySchema.outboundlinks_name_txt)) add(doc, YaCySchema.outboundlinks_name_txt, outboundlinksName);\n        if (allAttr || contains(YaCySchema.outboundlinks_rel_sxt)) add(doc, YaCySchema.outboundlinks_rel_sxt, outboundlinksRel);\n        if (allAttr || contains(YaCySchema.outboundlinks_relflags_val)) add(doc, YaCySchema.outboundlinks_relflags_val, relEval(outboundlinksRel));\n        if (allAttr || contains(YaCySchema.outboundlinks_text_txt)) add(doc, YaCySchema.outboundlinks_text_txt, outboundlinksText);\n        if (allAttr || contains(YaCySchema.outboundlinks_text_chars_val)) add(doc, YaCySchema.outboundlinks_text_chars_val, outboundlinksTextChars);\n        if (allAttr || contains(YaCySchema.outboundlinks_text_words_val)) add(doc, YaCySchema.outboundlinks_text_words_val, outboundlinksTextWords);\n        if (allAttr || contains(YaCySchema.outboundlinks_alttag_txt)) add(doc, YaCySchema.outboundlinks_alttag_txt, outboundlinksAltTag);\n\n        // charset\n        if (allAttr || contains(YaCySchema.charset_s)) add(doc, YaCySchema.charset_s, document.getCharset());\n\n        // coordinates\n        if (document.lat() != 0.0f && document.lon() != 0.0f) {\n            if (allAttr || contains(YaCySchema.coordinate_p)) add(doc, YaCySchema.coordinate_p, Double.toString(document.lat()) + \",\" + Double.toString(document.lon()));\n        }\n        if (allAttr || contains(YaCySchema.httpstatus_i)) add(doc, YaCySchema.httpstatus_i, responseHeader == null ? 200 : responseHeader.getStatusCode());\n\n        // fields that were additionally in URIMetadataRow\n        Date loadDate = new Date();\n        Date modDate = responseHeader == null ? new Date() : responseHeader.lastModified();\n        if (modDate.getTime() > loadDate.getTime()) modDate = loadDate;\n        int size = (int) Math.max(document.dc_source().length(), responseHeader == null ? 0 : responseHeader.getContentLength());\n        if (allAttr || contains(YaCySchema.load_date_dt)) add(doc, YaCySchema.load_date_dt, loadDate);\n        if (allAttr || contains(YaCySchema.fresh_date_dt)) add(doc, YaCySchema.fresh_date_dt, new Date(loadDate.getTime() + Math.max(0, loadDate.getTime() - modDate.getTime()) / 2)); // freshdate, computed with Proxy-TTL formula\n        if (allAttr || contains(YaCySchema.host_id_s)) add(doc, YaCySchema.host_id_s, document.dc_source().hosthash());\n        if ((allAttr || contains(YaCySchema.referrer_id_txt)) && referrerURL != null) add(doc, YaCySchema.referrer_id_txt, new String[]{ASCII.String(referrerURL.hash())});\n        //if (allAttr || contains(SolrField.md5_s)) add(solrdoc, SolrField.md5_s, new byte[0]);\n        if (allAttr || contains(YaCySchema.publisher_t)) add(doc, YaCySchema.publisher_t, document.dc_publisher());\n        if ((allAttr || contains(YaCySchema.language_s)) && language != null) add(doc, YaCySchema.language_s, language);\n        if (allAttr || contains(YaCySchema.size_i)) add(doc, YaCySchema.size_i, size);\n        if (allAttr || contains(YaCySchema.audiolinkscount_i)) add(doc, YaCySchema.audiolinkscount_i, document.getAudiolinks().size());\n        if (allAttr || contains(YaCySchema.videolinkscount_i)) add(doc, YaCySchema.videolinkscount_i, document.getVideolinks().size());\n        if (allAttr || contains(YaCySchema.applinkscount_i)) add(doc, YaCySchema.applinkscount_i, document.getApplinks().size());\n\n        return doc;\n    }","commit_id":"12c0db20e5a2704c0c6e1385e9e1eed93faae7fc","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void downloadResource(Resource res, File destination) throws IOException {\n        if (!(res instanceof HttpResource)) {\n            throw new IllegalArgumentException(\"Can only download HttpResource\");\n        }\n        HttpResource resource = (HttpResource) res;\n        fireTransferInitiated(resource, TransferEvent.REQUEST_GET);\n        try {\n            progress.setTotalLength(resource.getContentLength());\n            resource.writeTo(destination, progress);\n        } catch (IOException e) {\n            fireTransferError(e);\n            throw e;\n        } catch (Exception e) {\n            fireTransferError(e);\n            throw UncheckedException.asUncheckedException(e);\n        } finally {\n            progress.setTotalLength(null);\n            openResources.remove(resource);\n        }\n    }","id":28551,"modified_method":"public void downloadResource(Resource res, File destination) throws IOException {\n        if (!(res instanceof HttpResource)) {\n            throw new IllegalArgumentException(\"Can only download HttpResource\");\n        }\n        HttpResource resource = (HttpResource) res;\n        fireTransferInitiated(resource, TransferEvent.REQUEST_GET);\n        try {\n            progress.setTotalLength(resource.getContentLength() > 0 ? resource.getContentLength() : null);\n            resource.writeTo(destination, progress);\n        } catch (IOException e) {\n            fireTransferError(e);\n            throw e;\n        } catch (Exception e) {\n            fireTransferError(e);\n            throw UncheckedException.asUncheckedException(e);\n        } finally {\n            progress.setTotalLength(null);\n            openResources.remove(resource);\n        }\n    }","commit_id":"049f51db894edcafca00b6d4f566769a75f3419b","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMStructure structure)\n\t\tthrows Exception {\n\n\t\tprepareLanguagesForImport(structure);\n\n\t\tlong userId = portletDataContext.getUserId(structure.getUserUuid());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tstructure, DDMPortletDataHandler.NAMESPACE);\n\n\t\tDDMStructure importedStructure = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tElement element =\n\t\t\t\tportletDataContext.getImportDataStagedModelElement(structure);\n\n\t\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\t\telement.attributeValue(\"preloaded\"));\n\n\t\t\tDDMStructure existingStructure = null;\n\n\t\t\tif (!preloaded) {\n\t\t\t\texistingStructure = DDMStructureUtil.fetchByUUID_G(\n\t\t\t\t\tstructure.getUuid(), portletDataContext.getScopeGroupId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingStructure = DDMStructureUtil.fetchByG_C_S(\n\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\tstructure.getClassNameId(), structure.getStructureKey());\n\t\t\t}\n\n\t\t\tif (existingStructure == null) {\n\t\t\t\tserviceContext.setUuid(structure.getUuid());\n\n\t\t\t\timportedStructure = DDMStructureLocalServiceUtil.addStructure(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tstructure.getParentStructureId(),\n\t\t\t\t\tstructure.getClassNameId(), structure.getStructureKey(),\n\t\t\t\t\tstructure.getNameMap(), structure.getDescriptionMap(),\n\t\t\t\t\tstructure.getXsd(), structure.getStorageType(),\n\t\t\t\t\tstructure.getType(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedStructure =\n\t\t\t\t\tDDMStructureLocalServiceUtil.updateStructure(\n\t\t\t\t\t\texistingStructure.getStructureId(),\n\t\t\t\t\t\tstructure.getParentStructureId(),\n\t\t\t\t\t\tstructure.getNameMap(), structure.getDescriptionMap(),\n\t\t\t\t\t\tstructure.getXsd(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedStructure = DDMStructureLocalServiceUtil.addStructure(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\tstructure.getParentStructureId(), structure.getClassNameId(),\n\t\t\t\tstructure.getStructureKey(), structure.getNameMap(),\n\t\t\t\tstructure.getDescriptionMap(), structure.getXsd(),\n\t\t\t\tstructure.getStorageType(), structure.getType(),\n\t\t\t\tserviceContext);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tstructure, importedStructure, DDMPortletDataHandler.NAMESPACE);\n\n\t\tMap<String, String> ddmStructureKeys =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class + \".ddmStructureKey\");\n\n\t\tddmStructureKeys.put(\n\t\t\tstructure.getStructureKey(), importedStructure.getStructureKey());\n\t}","id":28552,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMStructure structure)\n\t\tthrows Exception {\n\n\t\tprepareLanguagesForImport(structure);\n\n\t\tlong userId = portletDataContext.getUserId(structure.getUserUuid());\n\n\t\tMap<Long, Long> structureIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class);\n\n\t\tlong parentStructureId = MapUtil.getLong(\n\t\t\tstructureIds, structure.getParentStructureId(),\n\t\t\tstructure.getParentStructureId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tstructure, DDMPortletDataHandler.NAMESPACE);\n\n\t\tDDMStructure importedStructure = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tElement element =\n\t\t\t\tportletDataContext.getImportDataStagedModelElement(structure);\n\n\t\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\t\telement.attributeValue(\"preloaded\"));\n\n\t\t\tDDMStructure existingStructure = null;\n\n\t\t\tif (!preloaded) {\n\t\t\t\texistingStructure = DDMStructureUtil.fetchByUUID_G(\n\t\t\t\t\tstructure.getUuid(), portletDataContext.getScopeGroupId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingStructure = DDMStructureUtil.fetchByG_C_S(\n\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\tstructure.getClassNameId(), structure.getStructureKey());\n\t\t\t}\n\n\t\t\tif (existingStructure == null) {\n\t\t\t\tserviceContext.setUuid(structure.getUuid());\n\n\t\t\t\timportedStructure = DDMStructureLocalServiceUtil.addStructure(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tparentStructureId, structure.getClassNameId(),\n\t\t\t\t\tstructure.getStructureKey(), structure.getNameMap(),\n\t\t\t\t\tstructure.getDescriptionMap(), structure.getXsd(),\n\t\t\t\t\tstructure.getStorageType(), structure.getType(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedStructure =\n\t\t\t\t\tDDMStructureLocalServiceUtil.updateStructure(\n\t\t\t\t\t\texistingStructure.getStructureId(), parentStructureId,\n\t\t\t\t\t\tstructure.getNameMap(), structure.getDescriptionMap(),\n\t\t\t\t\t\tstructure.getXsd(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedStructure = DDMStructureLocalServiceUtil.addStructure(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), parentStructureId,\n\t\t\t\tstructure.getClassNameId(), structure.getStructureKey(),\n\t\t\t\tstructure.getNameMap(), structure.getDescriptionMap(),\n\t\t\t\tstructure.getXsd(), structure.getStorageType(),\n\t\t\t\tstructure.getType(), serviceContext);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tstructure, importedStructure, DDMPortletDataHandler.NAMESPACE);\n\n\t\tstructureIds.put(\n\t\t\tstructure.getStructureId(), importedStructure.getStructureId());\n\t}","commit_id":"6f3aac5a83e85f474e8883629c37ec28f197fb33","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void importStructure(\n\t\t\tPortletDataContext portletDataContext,\tElement structureElement)\n\t\tthrows Exception {\n\n\t\tString path = structureElement.attributeValue(\"path\");\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tJournalStructure structure =\n\t\t\t(JournalStructure)portletDataContext.getZipEntryAsObject(path);\n\n\t\tlong userId = portletDataContext.getUserId(structure.getUserUuid());\n\n\t\tString structureId = structure.getStructureId();\n\t\tboolean autoStructureId = false;\n\n\t\tif ((Validator.isNumber(structureId)) ||\n\t\t\t(JournalStructureUtil.fetchByG_S(\n\t\t\t\tportletDataContext.getScopeGroupId(), structureId) != null)) {\n\n\t\t\tautoStructureId = true;\n\t\t}\n\n\t\tJournalCreationStrategy creationStrategy =\n\t\t\tJournalCreationStrategyFactory.getInstance();\n\n\t\tlong authorId = creationStrategy.getAuthorUserId(\n\t\t\tportletDataContext, structure);\n\n\t\tif (authorId != JournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) {\n\t\t\tuserId = authorId;\n\t\t}\n\n\t\tboolean addCommunityPermissions =\n\t\t\tcreationStrategy.addCommunityPermissions(\n\t\t\t\tportletDataContext, structure);\n\t\tboolean addGuestPermissions = creationStrategy.addGuestPermissions(\n\t\t\tportletDataContext, structure);\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(addCommunityPermissions);\n\t\tserviceContext.setAddGuestPermissions(addGuestPermissions);\n\t\tserviceContext.setCreateDate(structure.getCreateDate());\n\t\tserviceContext.setModifiedDate(structure.getModifiedDate());\n\n\t\tJournalStructure existingStructure = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\texistingStructure = JournalStructureUtil.fetchByUUID_G(\n\t\t\t\tstructure.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingStructure == null) {\n\t\t\t\tserviceContext.setUuid(structure.getUuid());\n\n\t\t\t\texistingStructure =\n\t\t\t\t\tJournalStructureLocalServiceUtil.addStructure(\n\t\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\t\tstructureId, autoStructureId,\n\t\t\t\t\t\tstructure.getParentStructureId(), structure.getName(),\n\t\t\t\t\t\tstructure.getDescription(), structure.getXsd(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingStructure =\n\t\t\t\t\tJournalStructureLocalServiceUtil.updateStructure(\n\t\t\t\t\t\texistingStructure.getGroupId(),\n\t\t\t\t\t\texistingStructure.getStructureId(),\n\t\t\t\t\t\tstructure.getParentStructureId(), structure.getName(),\n\t\t\t\t\t\tstructure.getDescription(), structure.getXsd(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\texistingStructure = JournalStructureLocalServiceUtil.addStructure(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), structureId,\n\t\t\t\tautoStructureId, structure.getParentStructureId(),\n\t\t\t\tstructure.getName(), structure.getDescription(),\n\t\t\t\tstructure.getXsd(), serviceContext);\n\t\t}\n\n\t\tMap<String, String> structureIds =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tJournalStructure.class);\n\n\t\tstructureIds.put(structureId, existingStructure.getStructureId());\n\n\t\tportletDataContext.importPermissions(\n\t\t\tJournalStructure.class, structure.getId(),\n\t\t\texistingStructure.getId());\n\n\t\tif (!structureId.equals(existingStructure.getStructureId())) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"A structure with the ID \" + structureId + \" already \" +\n\t\t\t\t\t\t\"exists. The new generated ID is \" +\n\t\t\t\t\t\t\texistingStructure.getStructureId());\n\t\t\t}\n\t\t}\n\t}","id":28553,"modified_method":"protected static void importStructure(\n\t\t\tPortletDataContext portletDataContext,\tElement structureElement)\n\t\tthrows Exception {\n\n\t\tString path = structureElement.attributeValue(\"path\");\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tJournalStructure structure =\n\t\t\t(JournalStructure)portletDataContext.getZipEntryAsObject(path);\n\n\t\tlong userId = portletDataContext.getUserId(structure.getUserUuid());\n\n\t\tString structureId = structure.getStructureId();\n\t\tboolean autoStructureId = false;\n\n\t\tif ((Validator.isNumber(structureId)) ||\n\t\t\t(JournalStructureUtil.fetchByG_S(\n\t\t\t\tportletDataContext.getScopeGroupId(), structureId) != null)) {\n\n\t\t\tautoStructureId = true;\n\t\t}\n\n\t\tJournalCreationStrategy creationStrategy =\n\t\t\tJournalCreationStrategyFactory.getInstance();\n\n\t\tlong authorId = creationStrategy.getAuthorUserId(\n\t\t\tportletDataContext, structure);\n\n\t\tif (authorId != JournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) {\n\t\t\tuserId = authorId;\n\t\t}\n\n\t\tboolean addCommunityPermissions =\n\t\t\tcreationStrategy.addCommunityPermissions(\n\t\t\t\tportletDataContext, structure);\n\t\tboolean addGuestPermissions = creationStrategy.addGuestPermissions(\n\t\t\tportletDataContext, structure);\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(addCommunityPermissions);\n\t\tserviceContext.setAddGuestPermissions(addGuestPermissions);\n\t\tserviceContext.setCreateDate(structure.getCreateDate());\n\t\tserviceContext.setModifiedDate(structure.getModifiedDate());\n\n\t\tJournalStructure existingStructure = null;\n\n\t\tMap<String, String> structureIds =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tJournalStructure.class);\n\n\t\tString parentStructureId = structure.getParentStructureId();\n\n\t\tString newParentStructureId = structureIds.get(parentStructureId);\n\n\t\tif (Validator.isNotNull(newParentStructureId)) {\n\t\t\tparentStructureId = newParentStructureId;\n\t\t}\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\texistingStructure = JournalStructureUtil.fetchByUUID_G(\n\t\t\t\tstructure.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingStructure == null) {\n\t\t\t\tserviceContext.setUuid(structure.getUuid());\n\n\t\t\t\texistingStructure =\n\t\t\t\t\tJournalStructureLocalServiceUtil.addStructure(\n\t\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\t\tstructureId, autoStructureId,\n\t\t\t\t\t\tparentStructureId, structure.getName(),\n\t\t\t\t\t\tstructure.getDescription(), structure.getXsd(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingStructure =\n\t\t\t\t\tJournalStructureLocalServiceUtil.updateStructure(\n\t\t\t\t\t\texistingStructure.getGroupId(),\n\t\t\t\t\t\texistingStructure.getStructureId(),\n\t\t\t\t\t\tparentStructureId, structure.getName(),\n\t\t\t\t\t\tstructure.getDescription(), structure.getXsd(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\texistingStructure = JournalStructureLocalServiceUtil.addStructure(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), structureId,\n\t\t\t\tautoStructureId, parentStructureId,\n\t\t\t\tstructure.getName(), structure.getDescription(),\n\t\t\t\tstructure.getXsd(), serviceContext);\n\t\t}\n\n\t\tstructureIds.put(structureId, existingStructure.getStructureId());\n\n\t\tportletDataContext.importPermissions(\n\t\t\tJournalStructure.class, structure.getId(),\n\t\t\texistingStructure.getId());\n\n\t\tif (!structureId.equals(existingStructure.getStructureId())) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"A structure with the ID \" + structureId + \" already \" +\n\t\t\t\t\t\t\"exists. The new generated ID is \" +\n\t\t\t\t\t\t\texistingStructure.getStructureId());\n\t\t\t}\n\t\t}\n\t}","commit_id":"773082dbb24d14eef38f48ac21a4851919eb41f7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void dumpMapping(TextBuffer buffer) {\n\n    String lineSeparator = DecompilerContext.getNewLineSeparator();\n    String indentstr1 = InterpreterUtil.getIndentString(1);\n    String indentstr2 = InterpreterUtil.getIndentString(2);\n\n\n    for(Entry<String, HashMap<String, HashMap<Integer, Integer>>> class_entry : mapping.entrySet()) {\n      HashMap<String, HashMap<Integer, Integer>> class_mapping = class_entry.getValue();\n      buffer.append(\"class \" + class_entry.getKey() + \"{\" + lineSeparator);\n\n      boolean is_first_method = true;\n\n      for(Entry<String, HashMap<Integer, Integer>> method_entry : class_mapping.entrySet()) {\n        HashMap<Integer, Integer> method_mapping = method_entry.getValue();\n\n        if(!is_first_method) {\n          buffer.append(lineSeparator);\n        }\n        buffer.append(indentstr1 + \"method \" + method_entry.getKey() + \"{\" + lineSeparator);\n\n        for(Entry<Integer, Integer> line : method_mapping.entrySet()) {\n          buffer.append(indentstr2 + line.getKey() + indentstr2 + (line.getValue() +offset_total) + lineSeparator);\n        }\n        buffer.append(indentstr1 + \"}\" + lineSeparator);\n        is_first_method = false;\n      }\n      buffer.append(\"}\" + lineSeparator);\n    }\n  }","id":28554,"modified_method":"public void dumpMapping(TextBuffer buffer) {\n\n    String lineSeparator = DecompilerContext.getNewLineSeparator();\n\n    for(Entry<String, HashMap<String, HashMap<Integer, Integer>>> class_entry : mapping.entrySet()) {\n      HashMap<String, HashMap<Integer, Integer>> class_mapping = class_entry.getValue();\n      buffer.append(\"class \" + class_entry.getKey() + \"{\" + lineSeparator);\n\n      boolean is_first_method = true;\n\n      for(Entry<String, HashMap<Integer, Integer>> method_entry : class_mapping.entrySet()) {\n        HashMap<Integer, Integer> method_mapping = method_entry.getValue();\n\n        if(!is_first_method) {\n          buffer.appendLineSeparator();\n        }\n        buffer.appendIndent(1).append(\"method \" + method_entry.getKey() + \"{\" + lineSeparator);\n\n        for(Entry<Integer, Integer> line : method_mapping.entrySet()) {\n          buffer.appendIndent(2).append(line.getKey().toString()).appendIndent(2).append((line.getValue() + offset_total) + lineSeparator);\n        }\n        buffer.appendIndent(1).append(\"}\").appendLineSeparator();\n        is_first_method = false;\n      }\n      buffer.append(\"}\").appendLineSeparator();\n    }\n  }","commit_id":"03c31c5b11249a3dc29bf60ed42130ce83c7f5ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void appendComment(TextBuffer buffer, String comment, String indentString, String lineSeparator) {\n    buffer.append(indentString).append(\"// $FF: \").append(comment).append(lineSeparator);\n  }","id":28555,"modified_method":"private static void appendComment(TextBuffer buffer, String comment, int indent, String lineSeparator) {\n    buffer.appendIndent(indent).append(\"// $FF: \").append(comment).append(lineSeparator);\n  }","commit_id":"03c31c5b11249a3dc29bf60ed42130ce83c7f5ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void fieldToJava(ClassWrapper wrapper, StructClass cl, StructField fd, TextBuffer buffer, int indent, BytecodeMappingTracer tracer) {\n    String indentString = InterpreterUtil.getIndentString(indent);\n    String lineSeparator = DecompilerContext.getNewLineSeparator();\n\n    boolean isInterface = cl.hasModifier(CodeConstants.ACC_INTERFACE);\n    boolean isDeprecated = fd.getAttributes().containsKey(\"Deprecated\");\n    boolean isEnum = fd.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);\n\n    if (isDeprecated) {\n      appendDeprecation(buffer, indentString, lineSeparator);\n    }\n\n    if (interceptor != null) {\n      String oldName = interceptor.getOldName(cl.qualifiedName + \" \" + fd.getName() + \" \" + fd.getDescriptor());\n      appendRenameComment(buffer, oldName, MType.FIELD, indent, lineSeparator);\n    }\n\n    if (fd.isSynthetic()) {\n      appendComment(buffer, \"synthetic field\", indentString, lineSeparator);\n    }\n\n    appendAnnotations(buffer, fd, indent, lineSeparator);\n\n    buffer.append(indentString);\n\n    if (!isEnum) {\n      appendModifiers(buffer, fd.getAccessFlags(), FIELD_ALLOWED, isInterface, FIELD_EXCLUDED);\n    }\n\n    VarType fieldType = new VarType(fd.getDescriptor(), false);\n\n    GenericFieldDescriptor descriptor = null;\n    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {\n      StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)fd.getAttributes().getWithKey(\"Signature\");\n      if (attr != null) {\n        descriptor = GenericMain.parseFieldSignature(attr.getSignature());\n      }\n    }\n\n    if (!isEnum) {\n      if (descriptor != null) {\n        buffer.append(GenericMain.getGenericCastTypeName(descriptor.type));\n      }\n      else {\n        buffer.append(ExprProcessor.getCastTypeName(fieldType));\n      }\n      buffer.append(' ');\n    }\n\n    buffer.append(fd.getName());\n\n    Exprent initializer;\n    if (fd.hasModifier(CodeConstants.ACC_STATIC)) {\n      initializer = wrapper.getStaticFieldInitializers().getWithKey(InterpreterUtil.makeUniqueKey(fd.getName(), fd.getDescriptor()));\n    }\n    else {\n      initializer = wrapper.getDynamicFieldInitializers().getWithKey(InterpreterUtil.makeUniqueKey(fd.getName(), fd.getDescriptor()));\n    }\n    if (initializer != null) {\n      if (isEnum && initializer.type == Exprent.EXPRENT_NEW) {\n        NewExprent nexpr = (NewExprent)initializer;\n        nexpr.setEnumconst(true);\n        buffer.append(nexpr.toJava(indent, tracer));\n      }\n      else {\n        buffer.append(\" = \");\n        // FIXME: special case field initializer. Can map to more than one method (constructor) and bytecode intruction.\n        buffer.append(initializer.toJava(indent, tracer));\n      }\n    }\n    else if (fd.hasModifier(CodeConstants.ACC_FINAL) && fd.hasModifier(CodeConstants.ACC_STATIC)) {\n      StructConstantValueAttribute attr =\n        (StructConstantValueAttribute)fd.getAttributes().getWithKey(StructGeneralAttribute.ATTRIBUTE_CONSTANT_VALUE);\n      if (attr != null) {\n        PrimitiveConstant constant = cl.getPool().getPrimitiveConstant(attr.getIndex());\n        buffer.append(\" = \");\n        buffer.append(new ConstExprent(fieldType, constant.value).toJava(indent, tracer));\n      }\n    }\n\n    if (!isEnum) {\n      buffer.append(\";\");\n      buffer.append(lineSeparator);\n    }\n  }","id":28556,"modified_method":"private void fieldToJava(ClassWrapper wrapper, StructClass cl, StructField fd, TextBuffer buffer, int indent, BytecodeMappingTracer tracer) {\n    String lineSeparator = DecompilerContext.getNewLineSeparator();\n\n    boolean isInterface = cl.hasModifier(CodeConstants.ACC_INTERFACE);\n    boolean isDeprecated = fd.getAttributes().containsKey(\"Deprecated\");\n    boolean isEnum = fd.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);\n\n    if (isDeprecated) {\n      appendDeprecation(buffer, indent, lineSeparator);\n    }\n\n    if (interceptor != null) {\n      String oldName = interceptor.getOldName(cl.qualifiedName + \" \" + fd.getName() + \" \" + fd.getDescriptor());\n      appendRenameComment(buffer, oldName, MType.FIELD, indent, lineSeparator);\n    }\n\n    if (fd.isSynthetic()) {\n      appendComment(buffer, \"synthetic field\", indent, lineSeparator);\n    }\n\n    appendAnnotations(buffer, fd, indent, lineSeparator);\n\n    buffer.appendIndent(indent);\n\n    if (!isEnum) {\n      appendModifiers(buffer, fd.getAccessFlags(), FIELD_ALLOWED, isInterface, FIELD_EXCLUDED);\n    }\n\n    VarType fieldType = new VarType(fd.getDescriptor(), false);\n\n    GenericFieldDescriptor descriptor = null;\n    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {\n      StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)fd.getAttributes().getWithKey(\"Signature\");\n      if (attr != null) {\n        descriptor = GenericMain.parseFieldSignature(attr.getSignature());\n      }\n    }\n\n    if (!isEnum) {\n      if (descriptor != null) {\n        buffer.append(GenericMain.getGenericCastTypeName(descriptor.type));\n      }\n      else {\n        buffer.append(ExprProcessor.getCastTypeName(fieldType));\n      }\n      buffer.append(' ');\n    }\n\n    buffer.append(fd.getName());\n\n    Exprent initializer;\n    if (fd.hasModifier(CodeConstants.ACC_STATIC)) {\n      initializer = wrapper.getStaticFieldInitializers().getWithKey(InterpreterUtil.makeUniqueKey(fd.getName(), fd.getDescriptor()));\n    }\n    else {\n      initializer = wrapper.getDynamicFieldInitializers().getWithKey(InterpreterUtil.makeUniqueKey(fd.getName(), fd.getDescriptor()));\n    }\n    if (initializer != null) {\n      if (isEnum && initializer.type == Exprent.EXPRENT_NEW) {\n        NewExprent nexpr = (NewExprent)initializer;\n        nexpr.setEnumconst(true);\n        buffer.append(nexpr.toJava(indent, tracer));\n      }\n      else {\n        buffer.append(\" = \");\n        // FIXME: special case field initializer. Can map to more than one method (constructor) and bytecode intruction.\n        buffer.append(initializer.toJava(indent, tracer));\n      }\n    }\n    else if (fd.hasModifier(CodeConstants.ACC_FINAL) && fd.hasModifier(CodeConstants.ACC_STATIC)) {\n      StructConstantValueAttribute attr =\n        (StructConstantValueAttribute)fd.getAttributes().getWithKey(StructGeneralAttribute.ATTRIBUTE_CONSTANT_VALUE);\n      if (attr != null) {\n        PrimitiveConstant constant = cl.getPool().getPrimitiveConstant(attr.getIndex());\n        buffer.append(\" = \");\n        buffer.append(new ConstExprent(fieldType, constant.value).toJava(indent, tracer));\n      }\n    }\n\n    if (!isEnum) {\n      buffer.append(\";\");\n      buffer.append(lineSeparator);\n    }\n  }","commit_id":"03c31c5b11249a3dc29bf60ed42130ce83c7f5ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void classToJava(ClassNode node, TextBuffer buffer, int indent) {\n    ClassNode outerNode = (ClassNode)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASS_NODE);\n    DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASS_NODE, node);\n\n    int total_offset_lines = 0;\n    BytecodeMappingTracer dummy_tracer = new BytecodeMappingTracer();\n\n    try {\n      // last minute processing\n      invokeProcessors(node);\n\n      ClassWrapper wrapper = node.wrapper;\n      StructClass cl = wrapper.getClassStruct();\n\n      DecompilerContext.getLogger().startWriteClass(cl.qualifiedName);\n\n      String lineSeparator = DecompilerContext.getNewLineSeparator();\n\n      // write class definition\n      int start_class_def = buffer.length();\n      writeClassDefinition(node, buffer, indent);\n\n//      // count lines in class definition the easiest way\n//      total_offset_lines = buffer.substring(start_class_def).toString().split(lineSeparator, -1).length - 1;\n\n      boolean hasContent = false;\n\n      // fields\n      boolean enumFields = false;\n\n      for (StructField fd : cl.getFields()) {\n        boolean hide = fd.isSynthetic() && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_SYNTHETIC) ||\n                       wrapper.getHiddenMembers().contains(InterpreterUtil.makeUniqueKey(fd.getName(), fd.getDescriptor()));\n        if (hide) continue;\n\n        boolean isEnum = fd.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);\n        if (isEnum) {\n          if (enumFields) {\n            buffer.append(',');\n            buffer.append(lineSeparator);\n          }\n          enumFields = true;\n        }\n        else if (enumFields) {\n          buffer.append(';');\n          buffer.append(lineSeparator);\n          buffer.append(lineSeparator);\n          enumFields = false;\n        }\n\n        fieldToJava(wrapper, cl, fd, buffer, indent + 1, dummy_tracer); // FIXME: insert real tracer\n\n        hasContent = true;\n      }\n\n      if (enumFields) {\n        buffer.append(';');\n        buffer.append(lineSeparator);\n      }\n\n      // FIXME: fields don't matter at the moment\n      total_offset_lines = buffer.substring(start_class_def).toString().split(lineSeparator, -1).length - 1;\n\n      // methods\n      for (StructMethod mt : cl.getMethods()) {\n        boolean hide = mt.isSynthetic() && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_SYNTHETIC) ||\n                       mt.hasModifier(CodeConstants.ACC_BRIDGE) && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_BRIDGE) ||\n                       wrapper.getHiddenMembers().contains(InterpreterUtil.makeUniqueKey(mt.getName(), mt.getDescriptor()));\n        if (hide) continue;\n\n        int position = buffer.length();\n        if (hasContent) {\n          buffer.append(lineSeparator);\n        }\n        BytecodeMappingTracer method_tracer = new BytecodeMappingTracer(total_offset_lines);\n        boolean methodSkipped = !methodToJava(node, mt, buffer, indent + 1, method_tracer);\n        if (!methodSkipped) {\n          hasContent = true;\n          DecompilerContext.getBytecodeSourceMapper().addTracer(cl.qualifiedName,\n                                  InterpreterUtil.makeUniqueKey(mt.getName(), mt.getDescriptor()), method_tracer);\n          total_offset_lines = (method_tracer.getCurrentSourceLine() + 1); // zero-based line index\n        }\n        else {\n          buffer.setLength(position);\n        }\n      }\n\n      // member classes\n      for (ClassNode inner : node.nested) {\n        if (inner.type == ClassNode.CLASS_MEMBER) {\n          StructClass innerCl = inner.classStruct;\n          boolean isSynthetic = (inner.access & CodeConstants.ACC_SYNTHETIC) != 0 || innerCl.isSynthetic();\n          boolean hide = isSynthetic && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_SYNTHETIC) ||\n                         wrapper.getHiddenMembers().contains(innerCl.qualifiedName);\n          if (hide) continue;\n\n          if (hasContent) {\n            buffer.append(lineSeparator);\n          }\n          classToJava(inner, buffer, indent + 1);\n\n          hasContent = true;\n        }\n      }\n\n      InterpreterUtil.appendIndent(buffer, indent);\n      buffer.append('}');\n\n      if (node.type != ClassNode.CLASS_ANONYMOUS) {\n        buffer.append(lineSeparator);\n      }\n    }\n    finally {\n      DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASS_NODE, outerNode);\n    }\n\n    DecompilerContext.getLogger().endWriteClass();\n  }","id":28557,"modified_method":"public void classToJava(ClassNode node, TextBuffer buffer, int indent) {\n    ClassNode outerNode = (ClassNode)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASS_NODE);\n    DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASS_NODE, node);\n\n    int total_offset_lines = 0;\n    BytecodeMappingTracer dummy_tracer = new BytecodeMappingTracer();\n\n    try {\n      // last minute processing\n      invokeProcessors(node);\n\n      ClassWrapper wrapper = node.wrapper;\n      StructClass cl = wrapper.getClassStruct();\n\n      DecompilerContext.getLogger().startWriteClass(cl.qualifiedName);\n\n      String lineSeparator = DecompilerContext.getNewLineSeparator();\n\n      // write class definition\n      int start_class_def = buffer.length();\n      writeClassDefinition(node, buffer, indent);\n\n//      // count lines in class definition the easiest way\n//      total_offset_lines = buffer.substring(start_class_def).toString().split(lineSeparator, -1).length - 1;\n\n      boolean hasContent = false;\n\n      // fields\n      boolean enumFields = false;\n\n      for (StructField fd : cl.getFields()) {\n        boolean hide = fd.isSynthetic() && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_SYNTHETIC) ||\n                       wrapper.getHiddenMembers().contains(InterpreterUtil.makeUniqueKey(fd.getName(), fd.getDescriptor()));\n        if (hide) continue;\n\n        boolean isEnum = fd.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);\n        if (isEnum) {\n          if (enumFields) {\n            buffer.append(',');\n            buffer.append(lineSeparator);\n          }\n          enumFields = true;\n        }\n        else if (enumFields) {\n          buffer.append(';');\n          buffer.append(lineSeparator);\n          buffer.append(lineSeparator);\n          enumFields = false;\n        }\n\n        fieldToJava(wrapper, cl, fd, buffer, indent + 1, dummy_tracer); // FIXME: insert real tracer\n\n        hasContent = true;\n      }\n\n      if (enumFields) {\n        buffer.append(';');\n        buffer.append(lineSeparator);\n      }\n\n      // FIXME: fields don't matter at the moment\n      total_offset_lines = buffer.substring(start_class_def).toString().split(lineSeparator, -1).length - 1;\n\n      // methods\n      for (StructMethod mt : cl.getMethods()) {\n        boolean hide = mt.isSynthetic() && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_SYNTHETIC) ||\n                       mt.hasModifier(CodeConstants.ACC_BRIDGE) && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_BRIDGE) ||\n                       wrapper.getHiddenMembers().contains(InterpreterUtil.makeUniqueKey(mt.getName(), mt.getDescriptor()));\n        if (hide) continue;\n\n        int position = buffer.length();\n        if (hasContent) {\n          buffer.append(lineSeparator);\n        }\n        BytecodeMappingTracer method_tracer = new BytecodeMappingTracer(total_offset_lines);\n        boolean methodSkipped = !methodToJava(node, mt, buffer, indent + 1, method_tracer);\n        if (!methodSkipped) {\n          hasContent = true;\n          DecompilerContext.getBytecodeSourceMapper().addTracer(cl.qualifiedName,\n                                  InterpreterUtil.makeUniqueKey(mt.getName(), mt.getDescriptor()), method_tracer);\n          total_offset_lines = (method_tracer.getCurrentSourceLine() + 1); // zero-based line index\n        }\n        else {\n          buffer.setLength(position);\n        }\n      }\n\n      // member classes\n      for (ClassNode inner : node.nested) {\n        if (inner.type == ClassNode.CLASS_MEMBER) {\n          StructClass innerCl = inner.classStruct;\n          boolean isSynthetic = (inner.access & CodeConstants.ACC_SYNTHETIC) != 0 || innerCl.isSynthetic();\n          boolean hide = isSynthetic && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_SYNTHETIC) ||\n                         wrapper.getHiddenMembers().contains(innerCl.qualifiedName);\n          if (hide) continue;\n\n          if (hasContent) {\n            buffer.append(lineSeparator);\n          }\n          classToJava(inner, buffer, indent + 1);\n\n          hasContent = true;\n        }\n      }\n\n      buffer.appendIndent(indent).append('}');\n\n      if (node.type != ClassNode.CLASS_ANONYMOUS) {\n        buffer.append(lineSeparator);\n      }\n    }\n    finally {\n      DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASS_NODE, outerNode);\n    }\n\n    DecompilerContext.getLogger().endWriteClass();\n  }","commit_id":"03c31c5b11249a3dc29bf60ed42130ce83c7f5ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void classLambdaToJava(ClassNode node, TextBuffer buffer, Exprent method_object, int indent) {\n    // get the class node with the content method\n    ClassNode classNode = node;\n    while (classNode != null && classNode.type == ClassNode.CLASS_LAMBDA) {\n      classNode = classNode.parent;\n    }\n    if (classNode == null) {\n      return;\n    }\n\n    boolean lambdaToAnonymous = DecompilerContext.getOption(IFernflowerPreferences.LAMBDA_TO_ANONYMOUS_CLASS);\n\n    ClassNode outerNode = (ClassNode)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASS_NODE);\n    DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASS_NODE, node);\n\n    BytecodeMappingTracer tracer = new BytecodeMappingTracer();\n\n    try {\n      ClassWrapper wrapper = classNode.wrapper;\n      StructClass cl = wrapper.getClassStruct();\n\n      DecompilerContext.getLogger().startWriteClass(node.simpleName);\n\n      if (node.lambda_information.is_method_reference) {\n        if (!node.lambda_information.is_content_method_static && method_object != null) {\n          // reference to a virtual method\n          buffer.append(method_object.toJava(indent, tracer));\n        }\n        else {\n          // reference to a static method\n          buffer.append(ExprProcessor.getCastTypeName(new VarType(node.lambda_information.content_class_name, false)));\n        }\n\n        buffer.append(\"::\");\n        buffer.append(node.lambda_information.content_method_name);\n      }\n      else {\n        // lambda method\n        StructMethod mt = cl.getMethod(node.lambda_information.content_method_key);\n        MethodWrapper methodWrapper = wrapper.getMethodWrapper(mt.getName(), mt.getDescriptor());\n        MethodDescriptor md_content = MethodDescriptor.parseDescriptor(node.lambda_information.content_method_descriptor);\n        MethodDescriptor md_lambda = MethodDescriptor.parseDescriptor(node.lambda_information.method_descriptor);\n\n        if (!lambdaToAnonymous) {\n          buffer.append('(');\n\n          boolean firstParameter = true;\n          int index = node.lambda_information.is_content_method_static ? 0 : 1;\n          int start_index = md_content.params.length - md_lambda.params.length;\n\n          for (int i = 0; i < md_content.params.length; i++) {\n            if (i >= start_index) {\n              if (!firstParameter) {\n                buffer.append(\", \");\n              }\n\n              String parameterName = methodWrapper.varproc.getVarName(new VarVersionPaar(index, 0));\n              buffer.append(parameterName == null ? \"param\" + index : parameterName); // null iff decompiled with errors\n\n              firstParameter = false;\n            }\n\n            index += md_content.params[i].stack_size;\n          }\n\n          buffer.append(\") ->\");\n        }\n\n        buffer.append(\" {\");\n        buffer.append(DecompilerContext.getNewLineSeparator());\n\n        methodLambdaToJava(node, classNode, mt, buffer, indent + 1, !lambdaToAnonymous, tracer);\n\n        InterpreterUtil.appendIndent(buffer, indent);\n        buffer.append(\"}\");\n      }\n    }\n    finally {\n      DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASS_NODE, outerNode);\n    }\n\n    DecompilerContext.getLogger().endWriteClass();\n  }","id":28558,"modified_method":"public void classLambdaToJava(ClassNode node, TextBuffer buffer, Exprent method_object, int indent) {\n    // get the class node with the content method\n    ClassNode classNode = node;\n    while (classNode != null && classNode.type == ClassNode.CLASS_LAMBDA) {\n      classNode = classNode.parent;\n    }\n    if (classNode == null) {\n      return;\n    }\n\n    boolean lambdaToAnonymous = DecompilerContext.getOption(IFernflowerPreferences.LAMBDA_TO_ANONYMOUS_CLASS);\n\n    ClassNode outerNode = (ClassNode)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASS_NODE);\n    DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASS_NODE, node);\n\n    BytecodeMappingTracer tracer = new BytecodeMappingTracer();\n\n    try {\n      ClassWrapper wrapper = classNode.wrapper;\n      StructClass cl = wrapper.getClassStruct();\n\n      DecompilerContext.getLogger().startWriteClass(node.simpleName);\n\n      if (node.lambda_information.is_method_reference) {\n        if (!node.lambda_information.is_content_method_static && method_object != null) {\n          // reference to a virtual method\n          buffer.append(method_object.toJava(indent, tracer));\n        }\n        else {\n          // reference to a static method\n          buffer.append(ExprProcessor.getCastTypeName(new VarType(node.lambda_information.content_class_name, false)));\n        }\n\n        buffer.append(\"::\");\n        buffer.append(node.lambda_information.content_method_name);\n      }\n      else {\n        // lambda method\n        StructMethod mt = cl.getMethod(node.lambda_information.content_method_key);\n        MethodWrapper methodWrapper = wrapper.getMethodWrapper(mt.getName(), mt.getDescriptor());\n        MethodDescriptor md_content = MethodDescriptor.parseDescriptor(node.lambda_information.content_method_descriptor);\n        MethodDescriptor md_lambda = MethodDescriptor.parseDescriptor(node.lambda_information.method_descriptor);\n\n        if (!lambdaToAnonymous) {\n          buffer.append('(');\n\n          boolean firstParameter = true;\n          int index = node.lambda_information.is_content_method_static ? 0 : 1;\n          int start_index = md_content.params.length - md_lambda.params.length;\n\n          for (int i = 0; i < md_content.params.length; i++) {\n            if (i >= start_index) {\n              if (!firstParameter) {\n                buffer.append(\", \");\n              }\n\n              String parameterName = methodWrapper.varproc.getVarName(new VarVersionPaar(index, 0));\n              buffer.append(parameterName == null ? \"param\" + index : parameterName); // null iff decompiled with errors\n\n              firstParameter = false;\n            }\n\n            index += md_content.params[i].stack_size;\n          }\n\n          buffer.append(\") ->\");\n        }\n\n        buffer.append(\" {\");\n        buffer.append(DecompilerContext.getNewLineSeparator());\n\n        methodLambdaToJava(node, classNode, mt, buffer, indent + 1, !lambdaToAnonymous, tracer);\n\n        buffer.appendIndent(indent).append(\"}\");\n      }\n    }\n    finally {\n      DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASS_NODE, outerNode);\n    }\n\n    DecompilerContext.getLogger().endWriteClass();\n  }","commit_id":"03c31c5b11249a3dc29bf60ed42130ce83c7f5ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void methodLambdaToJava(ClassNode lambdaNode,\n                                         ClassNode classNode,\n                                         StructMethod mt,\n                                         TextBuffer buffer,\n                                         int indent,\n                                         boolean codeOnly, BytecodeMappingTracer tracer) {\n    ClassWrapper classWrapper = classNode.wrapper;\n    MethodWrapper methodWrapper = classWrapper.getMethodWrapper(mt.getName(), mt.getDescriptor());\n\n    MethodWrapper outerWrapper = (MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);\n    DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, methodWrapper);\n\n    try {\n      String method_name = lambdaNode.lambda_information.method_name;\n      MethodDescriptor md_content = MethodDescriptor.parseDescriptor(lambdaNode.lambda_information.content_method_descriptor);\n      MethodDescriptor md_lambda = MethodDescriptor.parseDescriptor(lambdaNode.lambda_information.method_descriptor);\n\n      if (!codeOnly) {\n        InterpreterUtil.appendIndent(buffer, indent);\n        buffer.append(\"public \");\n        buffer.append(method_name);\n        buffer.append(\"(\");\n\n        boolean firstParameter = true;\n        int index = lambdaNode.lambda_information.is_content_method_static ? 0 : 1;\n        int start_index = md_content.params.length - md_lambda.params.length;\n\n        for (int i = 0; i < md_content.params.length; i++) {\n          if (i >= start_index) {\n            if (!firstParameter) {\n              buffer.append(\", \");\n            }\n\n            String typeName = ExprProcessor.getCastTypeName(md_content.params[i].copy());\n            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&\n                DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {\n              typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);\n            }\n\n            buffer.append(typeName);\n            buffer.append(\" \");\n\n            String parameterName = methodWrapper.varproc.getVarName(new VarVersionPaar(index, 0));\n            buffer.append(parameterName == null ? \"param\" + index : parameterName); // null iff decompiled with errors\n\n            firstParameter = false;\n          }\n\n          index += md_content.params[i].stack_size;\n        }\n\n        buffer.append(\") {\");\n        buffer.append(DecompilerContext.getNewLineSeparator());\n\n        indent += 1;\n      }\n\n      if (!methodWrapper.decompiledWithErrors) {\n        RootStatement root = classWrapper.getMethodWrapper(mt.getName(), mt.getDescriptor()).root;\n        if (root != null) { // check for existence\n          try {\n            buffer.append(root.toJava(indent, tracer));\n          }\n          catch (Throwable ex) {\n            DecompilerContext.getLogger().writeMessage(\"Method \" + mt.getName() + \" \" + mt.getDescriptor() + \" couldn't be written.\", ex);\n            methodWrapper.decompiledWithErrors = true;\n          }\n        }\n      }\n\n      if (methodWrapper.decompiledWithErrors) {\n        InterpreterUtil.appendIndent(buffer, indent);\n        buffer.append(\"// $FF: Couldn't be decompiled\");\n        buffer.append(DecompilerContext.getNewLineSeparator());\n      }\n\n      if (!codeOnly) {\n        indent -= 1;\n\n        InterpreterUtil.appendIndent(buffer, indent);\n        buffer.append('}');\n        buffer.append(DecompilerContext.getNewLineSeparator());\n      }\n    }\n    finally {\n      DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, outerWrapper);\n    }\n  }","id":28559,"modified_method":"private static void methodLambdaToJava(ClassNode lambdaNode,\n                                         ClassNode classNode,\n                                         StructMethod mt,\n                                         TextBuffer buffer,\n                                         int indent,\n                                         boolean codeOnly, BytecodeMappingTracer tracer) {\n    ClassWrapper classWrapper = classNode.wrapper;\n    MethodWrapper methodWrapper = classWrapper.getMethodWrapper(mt.getName(), mt.getDescriptor());\n\n    MethodWrapper outerWrapper = (MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);\n    DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, methodWrapper);\n\n    try {\n      String method_name = lambdaNode.lambda_information.method_name;\n      MethodDescriptor md_content = MethodDescriptor.parseDescriptor(lambdaNode.lambda_information.content_method_descriptor);\n      MethodDescriptor md_lambda = MethodDescriptor.parseDescriptor(lambdaNode.lambda_information.method_descriptor);\n\n      if (!codeOnly) {\n        buffer.appendIndent(indent);\n        buffer.append(\"public \");\n        buffer.append(method_name);\n        buffer.append(\"(\");\n\n        boolean firstParameter = true;\n        int index = lambdaNode.lambda_information.is_content_method_static ? 0 : 1;\n        int start_index = md_content.params.length - md_lambda.params.length;\n\n        for (int i = 0; i < md_content.params.length; i++) {\n          if (i >= start_index) {\n            if (!firstParameter) {\n              buffer.append(\", \");\n            }\n\n            String typeName = ExprProcessor.getCastTypeName(md_content.params[i].copy());\n            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&\n                DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {\n              typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);\n            }\n\n            buffer.append(typeName);\n            buffer.append(\" \");\n\n            String parameterName = methodWrapper.varproc.getVarName(new VarVersionPaar(index, 0));\n            buffer.append(parameterName == null ? \"param\" + index : parameterName); // null iff decompiled with errors\n\n            firstParameter = false;\n          }\n\n          index += md_content.params[i].stack_size;\n        }\n\n        buffer.append(\") {\");\n        buffer.append(DecompilerContext.getNewLineSeparator());\n\n        indent += 1;\n      }\n\n      if (!methodWrapper.decompiledWithErrors) {\n        RootStatement root = classWrapper.getMethodWrapper(mt.getName(), mt.getDescriptor()).root;\n        if (root != null) { // check for existence\n          try {\n            buffer.append(root.toJava(indent, tracer));\n          }\n          catch (Throwable ex) {\n            DecompilerContext.getLogger().writeMessage(\"Method \" + mt.getName() + \" \" + mt.getDescriptor() + \" couldn't be written.\", ex);\n            methodWrapper.decompiledWithErrors = true;\n          }\n        }\n      }\n\n      if (methodWrapper.decompiledWithErrors) {\n        buffer.appendIndent(indent);\n        buffer.append(\"// $FF: Couldn't be decompiled\");\n        buffer.append(DecompilerContext.getNewLineSeparator());\n      }\n\n      if (!codeOnly) {\n        indent -= 1;\n\n        buffer.appendIndent(indent);\n        buffer.append('}');\n        buffer.append(DecompilerContext.getNewLineSeparator());\n      }\n    }\n    finally {\n      DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, outerWrapper);\n    }\n  }","commit_id":"03c31c5b11249a3dc29bf60ed42130ce83c7f5ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void appendRenameComment(TextBuffer buffer, String oldName, MType type, int indent, String lineSeparator) {\n    if (oldName == null) return;\n\n    InterpreterUtil.appendIndent(buffer, indent);\n    buffer.append(\"// $FF: renamed from: \");\n\n    switch (type) {\n      case CLASS:\n        buffer.append(ExprProcessor.buildJavaClassName(oldName));\n        break;\n\n      case FIELD:\n        String[] fParts = oldName.split(\" \");\n        FieldDescriptor fd = FieldDescriptor.parseDescriptor(fParts[2]);\n        buffer.append(fParts[1]);\n        buffer.append(' ');\n        buffer.append(getTypePrintOut(fd.type));\n        break;\n\n      default:\n        String[] mParts = oldName.split(\" \");\n        MethodDescriptor md = MethodDescriptor.parseDescriptor(mParts[2]);\n        buffer.append(mParts[1]);\n        buffer.append(\" (\");\n        boolean first = true;\n        for (VarType paramType : md.params) {\n          if (!first) {\n            buffer.append(\", \");\n          }\n          first = false;\n          buffer.append(getTypePrintOut(paramType));\n        }\n        buffer.append(\") \");\n        buffer.append(getTypePrintOut(md.ret));\n    }\n\n    buffer.append(lineSeparator);\n  }","id":28560,"modified_method":"private static void appendRenameComment(TextBuffer buffer, String oldName, MType type, int indent, String lineSeparator) {\n    if (oldName == null) return;\n\n    buffer.appendIndent(indent);\n    buffer.append(\"// $FF: renamed from: \");\n\n    switch (type) {\n      case CLASS:\n        buffer.append(ExprProcessor.buildJavaClassName(oldName));\n        break;\n\n      case FIELD:\n        String[] fParts = oldName.split(\" \");\n        FieldDescriptor fd = FieldDescriptor.parseDescriptor(fParts[2]);\n        buffer.append(fParts[1]);\n        buffer.append(' ');\n        buffer.append(getTypePrintOut(fd.type));\n        break;\n\n      default:\n        String[] mParts = oldName.split(\" \");\n        MethodDescriptor md = MethodDescriptor.parseDescriptor(mParts[2]);\n        buffer.append(mParts[1]);\n        buffer.append(\" (\");\n        boolean first = true;\n        for (VarType paramType : md.params) {\n          if (!first) {\n            buffer.append(\", \");\n          }\n          first = false;\n          buffer.append(getTypePrintOut(paramType));\n        }\n        buffer.append(\") \");\n        buffer.append(getTypePrintOut(md.ret));\n    }\n\n    buffer.append(lineSeparator);\n  }","commit_id":"03c31c5b11249a3dc29bf60ed42130ce83c7f5ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void appendDeprecation(TextBuffer buffer, String indentString, String lineSeparator) {\n    buffer.append(indentString).append(\"/** @deprecated */\").append(lineSeparator);\n  }","id":28561,"modified_method":"private static void appendDeprecation(TextBuffer buffer, int indent, String lineSeparator) {\n    buffer.appendIndent(indent).append(\"/** @deprecated */\").append(lineSeparator);\n  }","commit_id":"03c31c5b11249a3dc29bf60ed42130ce83c7f5ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void writeClassDefinition(ClassNode node, TextBuffer buffer, int indent) {\n    String lineSeparator = DecompilerContext.getNewLineSeparator();\n    String indentString = InterpreterUtil.getIndentString(indent);\n\n    if (node.type == ClassNode.CLASS_ANONYMOUS) {\n      buffer.append(\" {\");\n      buffer.append(lineSeparator);\n      return;\n    }\n\n    ClassWrapper wrapper = node.wrapper;\n    StructClass cl = wrapper.getClassStruct();\n\n    int flags = node.type == ClassNode.CLASS_ROOT ? cl.getAccessFlags() : node.access;\n    boolean isDeprecated = cl.getAttributes().containsKey(\"Deprecated\");\n    boolean isSynthetic = (flags & CodeConstants.ACC_SYNTHETIC) != 0 || cl.getAttributes().containsKey(\"Synthetic\");\n    boolean isEnum = DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM) && (flags & CodeConstants.ACC_ENUM) != 0;\n    boolean isInterface = (flags & CodeConstants.ACC_INTERFACE) != 0;\n    boolean isAnnotation = (flags & CodeConstants.ACC_ANNOTATION) != 0;\n\n    if (isDeprecated) {\n      appendDeprecation(buffer, indentString, lineSeparator);\n    }\n\n    if (interceptor != null) {\n      String oldName = interceptor.getOldName(cl.qualifiedName);\n      appendRenameComment(buffer, oldName, MType.CLASS, indent, lineSeparator);\n    }\n\n    if (isSynthetic) {\n      appendComment(buffer, \"synthetic class\", indentString, lineSeparator);\n    }\n\n    appendAnnotations(buffer, cl, indent, lineSeparator);\n\n    buffer.append(indentString);\n\n    if (isEnum) {\n      // remove abstract and final flags (JLS 8.9 Enums)\n      flags &= ~CodeConstants.ACC_ABSTRACT;\n      flags &= ~CodeConstants.ACC_FINAL;\n    }\n\n    appendModifiers(buffer, flags, CLASS_ALLOWED, isInterface, CLASS_EXCLUDED);\n\n    if (isEnum) {\n      buffer.append(\"enum \");\n    }\n    else if (isInterface) {\n      if (isAnnotation) {\n        buffer.append('@');\n      }\n      buffer.append(\"interface \");\n    }\n    else {\n      buffer.append(\"class \");\n    }\n\n    GenericClassDescriptor descriptor = null;\n    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {\n      StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)cl.getAttributes().getWithKey(\"Signature\");\n      if (attr != null) {\n        descriptor = GenericMain.parseClassSignature(attr.getSignature());\n      }\n    }\n\n    buffer.append(node.simpleName);\n\n    if (descriptor != null && !descriptor.fparameters.isEmpty()) {\n      appendTypeParameters(buffer, descriptor.fparameters, descriptor.fbounds);\n    }\n\n    buffer.append(' ');\n\n    if (!isEnum && !isInterface && cl.superClass != null) {\n      VarType supertype = new VarType(cl.superClass.getString(), true);\n      if (!VarType.VARTYPE_OBJECT.equals(supertype)) {\n        buffer.append(\"extends \");\n        if (descriptor != null) {\n          buffer.append(GenericMain.getGenericCastTypeName(descriptor.superclass));\n        }\n        else {\n          buffer.append(ExprProcessor.getCastTypeName(supertype));\n        }\n        buffer.append(' ');\n      }\n    }\n\n    if (!isAnnotation) {\n      int[] interfaces = cl.getInterfaces();\n      if (interfaces.length > 0) {\n        buffer.append(isInterface ? \"extends \" : \"implements \");\n        for (int i = 0; i < interfaces.length; i++) {\n          if (i > 0) {\n            buffer.append(\", \");\n          }\n          if (descriptor != null) {\n            buffer.append(GenericMain.getGenericCastTypeName(descriptor.superinterfaces.get(i)));\n          }\n          else {\n            buffer.append(ExprProcessor.getCastTypeName(new VarType(cl.getInterface(i), true)));\n          }\n        }\n        buffer.append(' ');\n      }\n    }\n\n    buffer.append('{');\n    buffer.append(lineSeparator);\n  }","id":28562,"modified_method":"private void writeClassDefinition(ClassNode node, TextBuffer buffer, int indent) {\n    String lineSeparator = DecompilerContext.getNewLineSeparator();\n\n    if (node.type == ClassNode.CLASS_ANONYMOUS) {\n      buffer.append(\" {\");\n      buffer.append(lineSeparator);\n      return;\n    }\n\n    ClassWrapper wrapper = node.wrapper;\n    StructClass cl = wrapper.getClassStruct();\n\n    int flags = node.type == ClassNode.CLASS_ROOT ? cl.getAccessFlags() : node.access;\n    boolean isDeprecated = cl.getAttributes().containsKey(\"Deprecated\");\n    boolean isSynthetic = (flags & CodeConstants.ACC_SYNTHETIC) != 0 || cl.getAttributes().containsKey(\"Synthetic\");\n    boolean isEnum = DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM) && (flags & CodeConstants.ACC_ENUM) != 0;\n    boolean isInterface = (flags & CodeConstants.ACC_INTERFACE) != 0;\n    boolean isAnnotation = (flags & CodeConstants.ACC_ANNOTATION) != 0;\n\n    if (isDeprecated) {\n      appendDeprecation(buffer, indent, lineSeparator);\n    }\n\n    if (interceptor != null) {\n      String oldName = interceptor.getOldName(cl.qualifiedName);\n      appendRenameComment(buffer, oldName, MType.CLASS, indent, lineSeparator);\n    }\n\n    if (isSynthetic) {\n      appendComment(buffer, \"synthetic class\", indent, lineSeparator);\n    }\n\n    appendAnnotations(buffer, cl, indent, lineSeparator);\n\n    buffer.appendIndent(indent);\n\n    if (isEnum) {\n      // remove abstract and final flags (JLS 8.9 Enums)\n      flags &= ~CodeConstants.ACC_ABSTRACT;\n      flags &= ~CodeConstants.ACC_FINAL;\n    }\n\n    appendModifiers(buffer, flags, CLASS_ALLOWED, isInterface, CLASS_EXCLUDED);\n\n    if (isEnum) {\n      buffer.append(\"enum \");\n    }\n    else if (isInterface) {\n      if (isAnnotation) {\n        buffer.append('@');\n      }\n      buffer.append(\"interface \");\n    }\n    else {\n      buffer.append(\"class \");\n    }\n\n    GenericClassDescriptor descriptor = null;\n    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {\n      StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)cl.getAttributes().getWithKey(\"Signature\");\n      if (attr != null) {\n        descriptor = GenericMain.parseClassSignature(attr.getSignature());\n      }\n    }\n\n    buffer.append(node.simpleName);\n\n    if (descriptor != null && !descriptor.fparameters.isEmpty()) {\n      appendTypeParameters(buffer, descriptor.fparameters, descriptor.fbounds);\n    }\n\n    buffer.append(' ');\n\n    if (!isEnum && !isInterface && cl.superClass != null) {\n      VarType supertype = new VarType(cl.superClass.getString(), true);\n      if (!VarType.VARTYPE_OBJECT.equals(supertype)) {\n        buffer.append(\"extends \");\n        if (descriptor != null) {\n          buffer.append(GenericMain.getGenericCastTypeName(descriptor.superclass));\n        }\n        else {\n          buffer.append(ExprProcessor.getCastTypeName(supertype));\n        }\n        buffer.append(' ');\n      }\n    }\n\n    if (!isAnnotation) {\n      int[] interfaces = cl.getInterfaces();\n      if (interfaces.length > 0) {\n        buffer.append(isInterface ? \"extends \" : \"implements \");\n        for (int i = 0; i < interfaces.length; i++) {\n          if (i > 0) {\n            buffer.append(\", \");\n          }\n          if (descriptor != null) {\n            buffer.append(GenericMain.getGenericCastTypeName(descriptor.superinterfaces.get(i)));\n          }\n          else {\n            buffer.append(ExprProcessor.getCastTypeName(new VarType(cl.getInterface(i), true)));\n          }\n        }\n        buffer.append(' ');\n      }\n    }\n\n    buffer.append('{');\n    buffer.append(lineSeparator);\n  }","commit_id":"03c31c5b11249a3dc29bf60ed42130ce83c7f5ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean methodToJava(ClassNode node, StructMethod mt, TextBuffer buffer, int indent, BytecodeMappingTracer tracer) {\n    ClassWrapper wrapper = node.wrapper;\n    StructClass cl = wrapper.getClassStruct();\n    MethodWrapper methodWrapper = wrapper.getMethodWrapper(mt.getName(), mt.getDescriptor());\n\n    boolean hideMethod = false;\n    int start_index_method = buffer.length();\n\n    String indentString = InterpreterUtil.getIndentString(indent);\n    String lineSeparator = DecompilerContext.getNewLineSeparator();\n\n    MethodWrapper outerWrapper = (MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);\n    DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, methodWrapper);\n\n    try {\n      boolean isInterface = cl.hasModifier(CodeConstants.ACC_INTERFACE);\n      boolean isAnnotation = cl.hasModifier(CodeConstants.ACC_ANNOTATION);\n      boolean isEnum = cl.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);\n      boolean isDeprecated = mt.getAttributes().containsKey(\"Deprecated\");\n      boolean clinit = false, init = false, dinit = false;\n\n      int startLine = -1;\n      if (DecompilerContext.getOption(IFernflowerPreferences.USE_DEBUG_LINE_NUMBERS)) {\n        StructLineNumberTableAttribute lineNumberTable =\n          (StructLineNumberTableAttribute)mt.getAttributes().getWithKey(StructGeneralAttribute.ATTRIBUTE_LINE_NUMBER_TABLE);\n        if (lineNumberTable != null) {\n          startLine = lineNumberTable.getFirstLine();\n        }\n      }\n\n      MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());\n\n      int flags = mt.getAccessFlags();\n      if ((flags & CodeConstants.ACC_NATIVE) != 0) {\n        flags &= ~CodeConstants.ACC_STRICT; // compiler bug: a strictfp class sets all methods to strictfp\n      }\n      if (\"<clinit>\".equals(mt.getName())) {\n        flags &= CodeConstants.ACC_STATIC; // ignore all modifiers except 'static' in a static initializer\n      }\n\n      if (isDeprecated) {\n        appendDeprecation(buffer, indentString, lineSeparator);\n      }\n\n      if (interceptor != null) {\n        String oldName = interceptor.getOldName(cl.qualifiedName + \" \" + mt.getName() + \" \" + mt.getDescriptor());\n        appendRenameComment(buffer, oldName, MType.METHOD, indent, lineSeparator);\n      }\n\n      boolean isSynthetic = (flags & CodeConstants.ACC_SYNTHETIC) != 0 || mt.getAttributes().containsKey(\"Synthetic\");\n      boolean isBridge = (flags & CodeConstants.ACC_BRIDGE) != 0;\n      if (isSynthetic) {\n        appendComment(buffer, \"synthetic method\", indentString, lineSeparator);\n      }\n      if (isBridge) {\n        appendComment(buffer, \"bridge method\", indentString, lineSeparator);\n      }\n\n      appendAnnotations(buffer, mt, indent, lineSeparator);\n\n      buffer.append(indentString);\n\n      appendModifiers(buffer, flags, METHOD_ALLOWED, isInterface, METHOD_EXCLUDED);\n\n      if (isInterface && mt.containsCode()) {\n        // 'default' modifier (Java 8)\n        buffer.append(\"default \");\n      }\n\n      String name = mt.getName();\n      if (\"<init>\".equals(name)) {\n        if (node.type == ClassNode.CLASS_ANONYMOUS) {\n          name = \"\";\n          dinit = true;\n        }\n        else {\n          name = node.simpleName;\n          init = true;\n        }\n      }\n      else if (\"<clinit>\".equals(name)) {\n        name = \"\";\n        clinit = true;\n      }\n\n      GenericMethodDescriptor descriptor = null;\n      if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {\n        StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)mt.getAttributes().getWithKey(\"Signature\");\n        if (attr != null) {\n          descriptor = GenericMain.parseMethodSignature(attr.getSignature());\n          if (descriptor != null) {\n            int actualParams = md.params.length;\n            if (isEnum && init) actualParams -= 2;\n            if (actualParams != descriptor.params.size()) {\n              String message = \"Inconsistent generic signature in method \" + mt.getName() + \" \" + mt.getDescriptor();\n              DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);\n              descriptor = null;\n            }\n          }\n        }\n      }\n\n      boolean throwsExceptions = false;\n      int paramCount = 0;\n\n      if (!clinit && !dinit) {\n        boolean thisVar = !mt.hasModifier(CodeConstants.ACC_STATIC);\n\n        if (descriptor != null && !descriptor.fparameters.isEmpty()) {\n          appendTypeParameters(buffer, descriptor.fparameters, descriptor.fbounds);\n          buffer.append(' ');\n        }\n\n        if (!init) {\n          if (descriptor != null) {\n            buffer.append(GenericMain.getGenericCastTypeName(descriptor.ret));\n          }\n          else {\n            buffer.append(ExprProcessor.getCastTypeName(md.ret));\n          }\n          buffer.append(' ');\n        }\n\n        buffer.append(name);\n        buffer.append('(');\n\n        // parameters\n        List<VarVersionPaar> signFields = methodWrapper.signatureFields;\n\n        int lastVisibleParameterIndex = -1;\n        for (int i = 0; i < md.params.length; i++) {\n          if (signFields == null || signFields.get(i) == null) {\n            lastVisibleParameterIndex = i;\n          }\n        }\n\n        boolean firstParameter = true;\n        int index = isEnum && init ? 3 : thisVar ? 1 : 0;\n        int start = isEnum && init && descriptor == null ? 2 : 0;\n        int params = descriptor == null ? md.params.length : descriptor.params.size();\n        for (int i = start; i < params; i++) {\n          if (signFields == null || signFields.get(i) == null) {\n            if (!firstParameter) {\n              buffer.append(\", \");\n            }\n\n            appendParameterAnnotations(buffer, mt, paramCount);\n\n            if (methodWrapper.varproc.getVarFinal(new VarVersionPaar(index, 0)) == VarTypeProcessor.VAR_FINALEXPLICIT) {\n              buffer.append(\"final \");\n            }\n\n            if (descriptor != null) {\n              GenericType parameterType = descriptor.params.get(i);\n\n              boolean isVarArg = (i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arraydim > 0);\n              if (isVarArg) {\n                parameterType.arraydim--;\n              }\n\n              String typeName = GenericMain.getGenericCastTypeName(parameterType);\n              if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&\n                  DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {\n                typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);\n              }\n\n              buffer.append(typeName);\n\n              if (isVarArg) {\n                buffer.append(\"...\");\n              }\n            }\n            else {\n              VarType parameterType = md.params[i].copy();\n\n              boolean isVarArg = (i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arraydim > 0);\n              if (isVarArg) {\n                parameterType.decArrayDim();\n              }\n\n              String typeName = ExprProcessor.getCastTypeName(parameterType);\n              if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&\n                  DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {\n                typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);\n              }\n\n              buffer.append(typeName);\n\n              if (isVarArg) {\n                buffer.append(\"...\");\n              }\n            }\n\n            buffer.append(' ');\n            String parameterName = methodWrapper.varproc.getVarName(new VarVersionPaar(index, 0));\n            buffer.append(parameterName == null ? \"param\" + index : parameterName); // null iff decompiled with errors\n\n            firstParameter = false;\n            paramCount++;\n          }\n\n          index += md.params[i].stack_size;\n        }\n\n        buffer.append(')');\n\n        StructExceptionsAttribute attr = (StructExceptionsAttribute)mt.getAttributes().getWithKey(\"Exceptions\");\n        if ((descriptor != null && !descriptor.exceptions.isEmpty()) || attr != null) {\n          throwsExceptions = true;\n          buffer.append(\" throws \");\n\n          for (int i = 0; i < attr.getThrowsExceptions().size(); i++) {\n            if (i > 0) {\n              buffer.append(\", \");\n            }\n            if (descriptor != null && !descriptor.exceptions.isEmpty()) {\n              GenericType type = descriptor.exceptions.get(i);\n              buffer.append(GenericMain.getGenericCastTypeName(type));\n            }\n            else {\n              VarType type = new VarType(attr.getExcClassname(i, cl.getPool()), true);\n              buffer.append(ExprProcessor.getCastTypeName(type));\n            }\n          }\n        }\n      }\n\n      if ((flags & (CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_NATIVE)) != 0) { // native or abstract method (explicit or interface)\n        if (isAnnotation) {\n          StructAnnDefaultAttribute attr = (StructAnnDefaultAttribute)mt.getAttributes().getWithKey(\"AnnotationDefault\");\n          if (attr != null) {\n            buffer.append(\" default \");\n            buffer.append(attr.getDefaultValue().toJava(indent + 1, new BytecodeMappingTracer())); // dummy tracer\n          }\n        }\n\n        buffer.append(';');\n        buffer.append(lineSeparator);\n      }\n      else {\n        if (!clinit && !dinit) {\n          buffer.append(' ');\n        }\n\n        //TODO: for now only start line set\n        buffer.setCurrentLine(startLine);\n        buffer.append('{');\n        buffer.append(lineSeparator);\n\n        RootStatement root = wrapper.getMethodWrapper(mt.getName(), mt.getDescriptor()).root;\n\n        if (root != null && !methodWrapper.decompiledWithErrors) { // check for existence\n          try {\n\n            tracer.incrementCurrentSourceLine(buffer.substring(start_index_method).split(lineSeparator, -1).length - 1);\n\n            String code = root.toJava(indent + 1, tracer);\n\n            hideMethod = (clinit || dinit || hideConstructor(wrapper, init, throwsExceptions, paramCount)) && code.length() == 0;\n\n            buffer.append(code);\n          }\n          catch (Throwable ex) {\n            DecompilerContext.getLogger().writeMessage(\"Method \" + mt.getName() + \" \" + mt.getDescriptor() + \" couldn't be written.\", ex);\n            methodWrapper.decompiledWithErrors = true;\n          }\n        }\n\n        if (methodWrapper.decompiledWithErrors) {\n          buffer.append(InterpreterUtil.getIndentString(indent + 1));\n          buffer.append(\"// $FF: Couldn't be decompiled\");\n          buffer.append(lineSeparator);\n        }\n\n        buffer.append(indentString);\n        buffer.append('}');\n        buffer.append(lineSeparator);\n      }\n    }\n    finally {\n      DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, outerWrapper);\n    }\n\n    // save total lines\n    // TODO: optimize\n    tracer.setCurrentSourceLine(buffer.substring(start_index_method).split(lineSeparator, -1).length - 1);\n\n    return !hideMethod;\n  }","id":28563,"modified_method":"private boolean methodToJava(ClassNode node, StructMethod mt, TextBuffer buffer, int indent, BytecodeMappingTracer tracer) {\n    ClassWrapper wrapper = node.wrapper;\n    StructClass cl = wrapper.getClassStruct();\n    MethodWrapper methodWrapper = wrapper.getMethodWrapper(mt.getName(), mt.getDescriptor());\n\n    boolean hideMethod = false;\n    int start_index_method = buffer.length();\n\n    String lineSeparator = DecompilerContext.getNewLineSeparator();\n\n    MethodWrapper outerWrapper = (MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);\n    DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, methodWrapper);\n\n    try {\n      boolean isInterface = cl.hasModifier(CodeConstants.ACC_INTERFACE);\n      boolean isAnnotation = cl.hasModifier(CodeConstants.ACC_ANNOTATION);\n      boolean isEnum = cl.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);\n      boolean isDeprecated = mt.getAttributes().containsKey(\"Deprecated\");\n      boolean clinit = false, init = false, dinit = false;\n\n      int startLine = -1;\n      if (DecompilerContext.getOption(IFernflowerPreferences.USE_DEBUG_LINE_NUMBERS)) {\n        StructLineNumberTableAttribute lineNumberTable =\n          (StructLineNumberTableAttribute)mt.getAttributes().getWithKey(StructGeneralAttribute.ATTRIBUTE_LINE_NUMBER_TABLE);\n        if (lineNumberTable != null) {\n          startLine = lineNumberTable.getFirstLine();\n        }\n      }\n\n      MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());\n\n      int flags = mt.getAccessFlags();\n      if ((flags & CodeConstants.ACC_NATIVE) != 0) {\n        flags &= ~CodeConstants.ACC_STRICT; // compiler bug: a strictfp class sets all methods to strictfp\n      }\n      if (\"<clinit>\".equals(mt.getName())) {\n        flags &= CodeConstants.ACC_STATIC; // ignore all modifiers except 'static' in a static initializer\n      }\n\n      if (isDeprecated) {\n        appendDeprecation(buffer, indent, lineSeparator);\n      }\n\n      if (interceptor != null) {\n        String oldName = interceptor.getOldName(cl.qualifiedName + \" \" + mt.getName() + \" \" + mt.getDescriptor());\n        appendRenameComment(buffer, oldName, MType.METHOD, indent, lineSeparator);\n      }\n\n      boolean isSynthetic = (flags & CodeConstants.ACC_SYNTHETIC) != 0 || mt.getAttributes().containsKey(\"Synthetic\");\n      boolean isBridge = (flags & CodeConstants.ACC_BRIDGE) != 0;\n      if (isSynthetic) {\n        appendComment(buffer, \"synthetic method\", indent, lineSeparator);\n      }\n      if (isBridge) {\n        appendComment(buffer, \"bridge method\", indent, lineSeparator);\n      }\n\n      appendAnnotations(buffer, mt, indent, lineSeparator);\n\n      buffer.appendIndent(indent);\n\n      appendModifiers(buffer, flags, METHOD_ALLOWED, isInterface, METHOD_EXCLUDED);\n\n      if (isInterface && mt.containsCode()) {\n        // 'default' modifier (Java 8)\n        buffer.append(\"default \");\n      }\n\n      String name = mt.getName();\n      if (\"<init>\".equals(name)) {\n        if (node.type == ClassNode.CLASS_ANONYMOUS) {\n          name = \"\";\n          dinit = true;\n        }\n        else {\n          name = node.simpleName;\n          init = true;\n        }\n      }\n      else if (\"<clinit>\".equals(name)) {\n        name = \"\";\n        clinit = true;\n      }\n\n      GenericMethodDescriptor descriptor = null;\n      if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {\n        StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)mt.getAttributes().getWithKey(\"Signature\");\n        if (attr != null) {\n          descriptor = GenericMain.parseMethodSignature(attr.getSignature());\n          if (descriptor != null) {\n            int actualParams = md.params.length;\n            if (isEnum && init) actualParams -= 2;\n            if (actualParams != descriptor.params.size()) {\n              String message = \"Inconsistent generic signature in method \" + mt.getName() + \" \" + mt.getDescriptor();\n              DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);\n              descriptor = null;\n            }\n          }\n        }\n      }\n\n      boolean throwsExceptions = false;\n      int paramCount = 0;\n\n      if (!clinit && !dinit) {\n        boolean thisVar = !mt.hasModifier(CodeConstants.ACC_STATIC);\n\n        if (descriptor != null && !descriptor.fparameters.isEmpty()) {\n          appendTypeParameters(buffer, descriptor.fparameters, descriptor.fbounds);\n          buffer.append(' ');\n        }\n\n        if (!init) {\n          if (descriptor != null) {\n            buffer.append(GenericMain.getGenericCastTypeName(descriptor.ret));\n          }\n          else {\n            buffer.append(ExprProcessor.getCastTypeName(md.ret));\n          }\n          buffer.append(' ');\n        }\n\n        buffer.append(name);\n        buffer.append('(');\n\n        // parameters\n        List<VarVersionPaar> signFields = methodWrapper.signatureFields;\n\n        int lastVisibleParameterIndex = -1;\n        for (int i = 0; i < md.params.length; i++) {\n          if (signFields == null || signFields.get(i) == null) {\n            lastVisibleParameterIndex = i;\n          }\n        }\n\n        boolean firstParameter = true;\n        int index = isEnum && init ? 3 : thisVar ? 1 : 0;\n        int start = isEnum && init && descriptor == null ? 2 : 0;\n        int params = descriptor == null ? md.params.length : descriptor.params.size();\n        for (int i = start; i < params; i++) {\n          if (signFields == null || signFields.get(i) == null) {\n            if (!firstParameter) {\n              buffer.append(\", \");\n            }\n\n            appendParameterAnnotations(buffer, mt, paramCount);\n\n            if (methodWrapper.varproc.getVarFinal(new VarVersionPaar(index, 0)) == VarTypeProcessor.VAR_FINALEXPLICIT) {\n              buffer.append(\"final \");\n            }\n\n            if (descriptor != null) {\n              GenericType parameterType = descriptor.params.get(i);\n\n              boolean isVarArg = (i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arraydim > 0);\n              if (isVarArg) {\n                parameterType.arraydim--;\n              }\n\n              String typeName = GenericMain.getGenericCastTypeName(parameterType);\n              if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&\n                  DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {\n                typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);\n              }\n\n              buffer.append(typeName);\n\n              if (isVarArg) {\n                buffer.append(\"...\");\n              }\n            }\n            else {\n              VarType parameterType = md.params[i].copy();\n\n              boolean isVarArg = (i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arraydim > 0);\n              if (isVarArg) {\n                parameterType.decArrayDim();\n              }\n\n              String typeName = ExprProcessor.getCastTypeName(parameterType);\n              if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&\n                  DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {\n                typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);\n              }\n\n              buffer.append(typeName);\n\n              if (isVarArg) {\n                buffer.append(\"...\");\n              }\n            }\n\n            buffer.append(' ');\n            String parameterName = methodWrapper.varproc.getVarName(new VarVersionPaar(index, 0));\n            buffer.append(parameterName == null ? \"param\" + index : parameterName); // null iff decompiled with errors\n\n            firstParameter = false;\n            paramCount++;\n          }\n\n          index += md.params[i].stack_size;\n        }\n\n        buffer.append(')');\n\n        StructExceptionsAttribute attr = (StructExceptionsAttribute)mt.getAttributes().getWithKey(\"Exceptions\");\n        if ((descriptor != null && !descriptor.exceptions.isEmpty()) || attr != null) {\n          throwsExceptions = true;\n          buffer.append(\" throws \");\n\n          for (int i = 0; i < attr.getThrowsExceptions().size(); i++) {\n            if (i > 0) {\n              buffer.append(\", \");\n            }\n            if (descriptor != null && !descriptor.exceptions.isEmpty()) {\n              GenericType type = descriptor.exceptions.get(i);\n              buffer.append(GenericMain.getGenericCastTypeName(type));\n            }\n            else {\n              VarType type = new VarType(attr.getExcClassname(i, cl.getPool()), true);\n              buffer.append(ExprProcessor.getCastTypeName(type));\n            }\n          }\n        }\n      }\n\n      if ((flags & (CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_NATIVE)) != 0) { // native or abstract method (explicit or interface)\n        if (isAnnotation) {\n          StructAnnDefaultAttribute attr = (StructAnnDefaultAttribute)mt.getAttributes().getWithKey(\"AnnotationDefault\");\n          if (attr != null) {\n            buffer.append(\" default \");\n            buffer.append(attr.getDefaultValue().toJava(indent + 1, new BytecodeMappingTracer())); // dummy tracer\n          }\n        }\n\n        buffer.append(';');\n        buffer.append(lineSeparator);\n      }\n      else {\n        if (!clinit && !dinit) {\n          buffer.append(' ');\n        }\n\n        //TODO: for now only start line set\n        buffer.setCurrentLine(startLine);\n        buffer.append('{').appendLineSeparator();\n\n        RootStatement root = wrapper.getMethodWrapper(mt.getName(), mt.getDescriptor()).root;\n\n        if (root != null && !methodWrapper.decompiledWithErrors) { // check for existence\n          try {\n\n            tracer.incrementCurrentSourceLine(buffer.substring(start_index_method).split(lineSeparator, -1).length - 1);\n\n            String code = root.toJava(indent + 1, tracer);\n\n            hideMethod = (clinit || dinit || hideConstructor(wrapper, init, throwsExceptions, paramCount)) && code.length() == 0;\n\n            buffer.append(code);\n          }\n          catch (Throwable ex) {\n            DecompilerContext.getLogger().writeMessage(\"Method \" + mt.getName() + \" \" + mt.getDescriptor() + \" couldn't be written.\", ex);\n            methodWrapper.decompiledWithErrors = true;\n          }\n        }\n\n        if (methodWrapper.decompiledWithErrors) {\n          buffer.appendIndent(indent + 1);\n          buffer.append(\"// $FF: Couldn't be decompiled\");\n          buffer.append(lineSeparator);\n        }\n\n        buffer.appendIndent(indent).append('}').appendLineSeparator();\n      }\n    }\n    finally {\n      DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, outerWrapper);\n    }\n\n    // save total lines\n    // TODO: optimize\n    tracer.setCurrentSourceLine(buffer.substring(start_index_method).split(lineSeparator, -1).length - 1);\n\n    return !hideMethod;\n  }","commit_id":"03c31c5b11249a3dc29bf60ed42130ce83c7f5ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public CharSequence getText(@NotNull VirtualFile file) throws CannotDecompileException {\n    if (\"package-info.class\".equals(file.getName())) {\n      return ClsFileImpl.decompile(file);\n    }\n\n    try {\n      Map<String, VirtualFile> files = ContainerUtil.newLinkedHashMap();\n      files.put(file.getPath(), file);\n      String mask = file.getNameWithoutExtension() + \"$\";\n      for (VirtualFile child : file.getParent().getChildren()) {\n        if (child.getNameWithoutExtension().startsWith(mask) && file.getFileType() == StdFileTypes.CLASS) {\n          files.put(child.getPath(), child);\n        }\n      }\n      MyBytecodeProvider provider = new MyBytecodeProvider(files);\n      MyResultSaver saver = new MyResultSaver();\n\n      myOptions.put(IFernflowerPreferences.USE_DEBUG_LINE_NUMBERS, Registry.is(\"decompiler.use.line.table\") ? \"1\" : \"0\");\n      BaseDecompiler decompiler = new BaseDecompiler(provider, saver, myOptions, myLogger);\n      for (String path : files.keySet()) {\n        decompiler.addSpace(new File(path), true);\n      }\n      decompiler.decompileContext();\n\n      saver.myResult.addBanner(BANNER);\n      return saver.myResult.toString();\n    }\n    catch (Exception e) {\n      if (ApplicationManager.getApplication().isUnitTestMode()) {\n        AssertionError error = new AssertionError(file.getUrl());\n        error.initCause(e);\n        throw error;\n      }\n      else {\n        throw new CannotDecompileException(e);\n      }\n    }\n  }","id":28564,"modified_method":"@NotNull\n  @Override\n  public CharSequence getText(@NotNull VirtualFile file) throws CannotDecompileException {\n    if (\"package-info.class\".equals(file.getName())) {\n      return ClsFileImpl.decompile(file);\n    }\n\n    try {\n      Map<String, VirtualFile> files = ContainerUtil.newLinkedHashMap();\n      files.put(file.getPath(), file);\n      String mask = file.getNameWithoutExtension() + \"$\";\n      for (VirtualFile child : file.getParent().getChildren()) {\n        if (child.getNameWithoutExtension().startsWith(mask) && file.getFileType() == StdFileTypes.CLASS) {\n          files.put(child.getPath(), child);\n        }\n      }\n      MyBytecodeProvider provider = new MyBytecodeProvider(files);\n      MyResultSaver saver = new MyResultSaver();\n\n      myOptions.put(IFernflowerPreferences.USE_DEBUG_LINE_NUMBERS, Registry.is(\"decompiler.use.line.table\") ? \"1\" : \"0\");\n      BaseDecompiler decompiler = new BaseDecompiler(provider, saver, myOptions, myLogger);\n      for (String path : files.keySet()) {\n        decompiler.addSpace(new File(path), true);\n      }\n      decompiler.decompileContext();\n\n      return saver.myResult.addBanner(BANNER).toString();\n    }\n    catch (Exception e) {\n      if (ApplicationManager.getApplication().isUnitTestMode()) {\n        AssertionError error = new AssertionError(file.getUrl());\n        error.initCause(e);\n        throw error;\n      }\n      else {\n        throw new CannotDecompileException(e);\n      }\n    }\n  }","commit_id":"03c31c5b11249a3dc29bf60ed42130ce83c7f5ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String getIndentString(int length) {\n    if (length == 0) return \"\";\n    TextBuffer buf = new TextBuffer();\n    appendIndent(buf, length);\n    return buf.toString();\n  }","id":28565,"modified_method":"public static String getIndentString(int length) {\n    if (length == 0) return \"\";\n    StringBuilder buf = new StringBuilder();\n    String indent = (String)DecompilerContext.getProperty(IFernflowerPreferences.INDENT_STRING);\n    while (length-- > 0) {\n      buf.append(indent);\n    }\n    return buf.toString();\n  }","commit_id":"03c31c5b11249a3dc29bf60ed42130ce83c7f5ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void append(TextBuffer buffer) {\n    if (buffer.myLineToOffsetMapping != null && !buffer.myLineToOffsetMapping.isEmpty()) {\n      checkMapCreated();\n      for (Map.Entry<Integer, Integer> entry : buffer.myLineToOffsetMapping.entrySet()) {\n        myLineToOffsetMapping.put(entry.getKey(), entry.getValue() + myStringBuilder.length());\n      }\n    }\n    myStringBuilder.append(buffer.myStringBuilder);\n  }","id":28566,"modified_method":"public TextBuffer append(TextBuffer buffer) {\n    if (buffer.myLineToOffsetMapping != null && !buffer.myLineToOffsetMapping.isEmpty()) {\n      checkMapCreated();\n      for (Map.Entry<Integer, Integer> entry : buffer.myLineToOffsetMapping.entrySet()) {\n        myLineToOffsetMapping.put(entry.getKey(), entry.getValue() + myStringBuilder.length());\n      }\n    }\n    myStringBuilder.append(buffer.myStringBuilder);\n    return this;\n  }","commit_id":"03c31c5b11249a3dc29bf60ed42130ce83c7f5ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addBanner(String banner) {\n    myStringBuilder.insert(0, banner);\n    if (myLineToOffsetMapping != null) {\n      for (Integer line : myLineToOffsetMapping.keySet()) {\n        myLineToOffsetMapping.put(line, myLineToOffsetMapping.get(line) + banner.length());\n      }\n    }\n  }","id":28567,"modified_method":"public TextBuffer addBanner(String banner) {\n    myStringBuilder.insert(0, banner);\n    if (myLineToOffsetMapping != null) {\n      for (Integer line : myLineToOffsetMapping.keySet()) {\n        myLineToOffsetMapping.put(line, myLineToOffsetMapping.get(line) + banner.length());\n      }\n    }\n    return this;\n  }","commit_id":"03c31c5b11249a3dc29bf60ed42130ce83c7f5ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Map<Integer, Integer> getOriginalLinesMapping() {\n    if (lineNumberTable == null) {\n      return Collections.emptyMap();\n    }\n\n    Map<Integer, Integer> res = new HashMap<Integer, Integer>();\n    int[] data = lineNumberTable.getRawData();\n    for (int i = 0; i < data.length; i += 2) {\n      int originalOffset = data[i];\n      int originalLine = data[i + 1];\n      Integer newLine = mapping.get(originalOffset);\n      if (newLine != null) {\n        res.put(originalLine, newLine);\n      }\n    }\n    for (Entry<Integer, Integer> entry : mapping.entrySet()) {\n      int originalLine = lineNumberTable.findLineNumber(entry.getKey());\n      if (originalLine > -1) {\n        res.put(originalLine, entry.getValue());\n      }\n    }\n    return res;\n  }","id":28568,"modified_method":"public Map<Integer, Integer> getOriginalLinesMapping() {\n    if (lineNumberTable == null) {\n      return Collections.emptyMap();\n    }\n\n    Map<Integer, Integer> res = new HashMap<Integer, Integer>();\n    int[] data = lineNumberTable.getRawData();\n    for (int i = 0; i < data.length; i += 2) {\n      int originalOffset = data[i];\n      int originalLine = data[i + 1];\n      Integer newLine = mapping.get(originalOffset);\n      if (newLine != null) {\n        res.put(originalLine, newLine);\n      }\n      else {\n        unmappedLines.add(originalLine);\n      }\n    }\n    for (Entry<Integer, Integer> entry : mapping.entrySet()) {\n      int originalLine = lineNumberTable.findLineNumber(entry.getKey());\n      if (originalLine > -1) {\n        res.put(originalLine, entry.getValue());\n        unmappedLines.remove(originalLine);\n      }\n    }\n    return res;\n  }","commit_id":"99916a4b4cdebff66c53b12d0d1ae0f33eca357b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Original to decompiled line mapping.\n   */\n  public int[] getOriginalLinesMapping() {\n    int[] res = new int[linesMapping.size() * 2];\n    int i = 0;\n    for (Entry<Integer, Integer> entry : linesMapping.entrySet()) {\n      res[i] = entry.getKey();\n      res[i + 1] = entry.getValue() + offset_total + 1; // make it 1 based\n      i += 2;\n    }\n    return res;\n  }","id":28569,"modified_method":"/**\n   * Original to decompiled line mapping.\n   */\n  public int[] getOriginalLinesMapping() {\n    int[] res = new int[linesMapping.size() * 2];\n    int i = 0;\n    for (Entry<Integer, Integer> entry : linesMapping.entrySet()) {\n      res[i] = entry.getKey();\n      unmappedLines.remove(entry.getKey());\n      res[i + 1] = entry.getValue() + offset_total + 1; // make it 1 based\n      i += 2;\n    }\n    return res;\n  }","commit_id":"99916a4b4cdebff66c53b12d0d1ae0f33eca357b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addTracer(String className, String methodName, BytecodeMappingTracer tracer) {\n    for (Entry<Integer, Integer> entry : tracer.getMapping().entrySet()) {\n      addMapping(className, methodName, entry.getKey(), entry.getValue());\n    }\n    linesMapping.putAll(tracer.getOriginalLinesMapping());\n  }","id":28570,"modified_method":"public void addTracer(String className, String methodName, BytecodeMappingTracer tracer) {\n    for (Entry<Integer, Integer> entry : tracer.getMapping().entrySet()) {\n      addMapping(className, methodName, entry.getKey(), entry.getValue());\n    }\n    linesMapping.putAll(tracer.getOriginalLinesMapping());\n    unmappedLines.addAll(tracer.getUnmappedLines());\n  }","commit_id":"99916a4b4cdebff66c53b12d0d1ae0f33eca357b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dumpMapping(TextBuffer buffer, boolean offsetsToHex) {\n    if (mapping.isEmpty() && linesMapping.isEmpty()) {\n      return;\n    }\n\n    String lineSeparator = DecompilerContext.getNewLineSeparator();\n\n    for (Entry<String, Map<String, Map<Integer, Integer>>> class_entry : mapping.entrySet()) {\n      Map<String, Map<Integer, Integer>> class_mapping = class_entry.getValue();\n      buffer.append(\"class '\" + class_entry.getKey() + \"' {\" + lineSeparator);\n\n      boolean is_first_method = true;\n      for (Entry<String, Map<Integer, Integer>> method_entry : class_mapping.entrySet()) {\n        Map<Integer, Integer> method_mapping = method_entry.getValue();\n\n        if (!is_first_method) {\n          buffer.appendLineSeparator();\n        }\n\n        buffer.appendIndent(1).append(\"method '\" + method_entry.getKey() + \"' {\" + lineSeparator);\n\n        List<Integer> lstBytecodeOffsets = new ArrayList<Integer>(method_mapping.keySet());\n        Collections.sort(lstBytecodeOffsets);\n\n        for (Integer offset : lstBytecodeOffsets) {\n          Integer line = method_mapping.get(offset);\n\n          String strOffset = offsetsToHex ? Integer.toHexString(offset) : line.toString();\n          buffer.appendIndent(2).append(strOffset).appendIndent(2).append((line + offset_total) + lineSeparator);\n        }\n        buffer.appendIndent(1).append(\"}\").appendLineSeparator();\n\n        is_first_method = false;\n      }\n\n      buffer.append(\"}\").appendLineSeparator().appendLineSeparator();\n    }\n\n    // lines mapping\n    buffer.append(\"Lines mapping:\").appendLineSeparator();\n    Map<Integer, Integer> sorted = new TreeMap<Integer, Integer>(linesMapping);\n    for (Entry<Integer, Integer> entry : sorted.entrySet()) {\n      buffer.append(entry.getKey()).append(\" <-> \").append(entry.getValue()+ offset_total + 1).appendLineSeparator();\n    }\n  }","id":28571,"modified_method":"public void dumpMapping(TextBuffer buffer, boolean offsetsToHex) {\n    if (mapping.isEmpty() && linesMapping.isEmpty()) {\n      return;\n    }\n\n    String lineSeparator = DecompilerContext.getNewLineSeparator();\n\n    for (Entry<String, Map<String, Map<Integer, Integer>>> class_entry : mapping.entrySet()) {\n      Map<String, Map<Integer, Integer>> class_mapping = class_entry.getValue();\n      buffer.append(\"class '\" + class_entry.getKey() + \"' {\" + lineSeparator);\n\n      boolean is_first_method = true;\n      for (Entry<String, Map<Integer, Integer>> method_entry : class_mapping.entrySet()) {\n        Map<Integer, Integer> method_mapping = method_entry.getValue();\n\n        if (!is_first_method) {\n          buffer.appendLineSeparator();\n        }\n\n        buffer.appendIndent(1).append(\"method '\" + method_entry.getKey() + \"' {\" + lineSeparator);\n\n        List<Integer> lstBytecodeOffsets = new ArrayList<Integer>(method_mapping.keySet());\n        Collections.sort(lstBytecodeOffsets);\n\n        for (Integer offset : lstBytecodeOffsets) {\n          Integer line = method_mapping.get(offset);\n\n          String strOffset = offsetsToHex ? Integer.toHexString(offset) : line.toString();\n          buffer.appendIndent(2).append(strOffset).appendIndent(2).append((line + offset_total) + lineSeparator);\n        }\n        buffer.appendIndent(1).append(\"}\").appendLineSeparator();\n\n        is_first_method = false;\n      }\n\n      buffer.append(\"}\").appendLineSeparator().appendLineSeparator();\n    }\n\n    // lines mapping\n    buffer.append(\"Lines mapping:\").appendLineSeparator();\n    Map<Integer, Integer> sorted = new TreeMap<Integer, Integer>(linesMapping);\n    for (Entry<Integer, Integer> entry : sorted.entrySet()) {\n      buffer.append(entry.getKey()).append(\" <-> \").append(entry.getValue() + offset_total + 1).appendLineSeparator();\n    }\n\n    if (!unmappedLines.isEmpty()) {\n      buffer.append(\"Not mapped:\").appendLineSeparator();\n      for (Integer line : unmappedLines) {\n        if (!linesMapping.containsKey(line)) {\n          buffer.append(line).appendLineSeparator();\n        }\n      }\n    }\n  }","commit_id":"99916a4b4cdebff66c53b12d0d1ae0f33eca357b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean methodToJava(ClassNode node, StructMethod mt, TextBuffer buffer, int indent, BytecodeMappingTracer tracer) {\n    ClassWrapper wrapper = node.getWrapper();\n    StructClass cl = wrapper.getClassStruct();\n    MethodWrapper methodWrapper = wrapper.getMethodWrapper(mt.getName(), mt.getDescriptor());\n\n    boolean hideMethod = false;\n    int start_index_method = buffer.length();\n\n    MethodWrapper outerWrapper = (MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);\n    DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, methodWrapper);\n\n    try {\n      boolean isInterface = cl.hasModifier(CodeConstants.ACC_INTERFACE);\n      boolean isAnnotation = cl.hasModifier(CodeConstants.ACC_ANNOTATION);\n      boolean isEnum = cl.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);\n      boolean isDeprecated = mt.getAttributes().containsKey(\"Deprecated\");\n      boolean clinit = false, init = false, dinit = false;\n\n      MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());\n\n      int flags = mt.getAccessFlags();\n      if ((flags & CodeConstants.ACC_NATIVE) != 0) {\n        flags &= ~CodeConstants.ACC_STRICT; // compiler bug: a strictfp class sets all methods to strictfp\n      }\n      if (CodeConstants.CLINIT_NAME.equals(mt.getName())) {\n        flags &= CodeConstants.ACC_STATIC; // ignore all modifiers except 'static' in a static initializer\n      }\n\n      if (isDeprecated) {\n        appendDeprecation(buffer, indent);\n      }\n\n      if (interceptor != null) {\n        String oldName = interceptor.getOldName(cl.qualifiedName + \" \" + mt.getName() + \" \" + mt.getDescriptor());\n        appendRenameComment(buffer, oldName, MType.METHOD, indent);\n      }\n\n      boolean isSynthetic = (flags & CodeConstants.ACC_SYNTHETIC) != 0 || mt.getAttributes().containsKey(\"Synthetic\");\n      boolean isBridge = (flags & CodeConstants.ACC_BRIDGE) != 0;\n      if (isSynthetic) {\n        appendComment(buffer, \"synthetic method\", indent);\n      }\n      if (isBridge) {\n        appendComment(buffer, \"bridge method\", indent);\n      }\n\n      appendAnnotations(buffer, mt, indent);\n\n      buffer.appendIndent(indent);\n\n      appendModifiers(buffer, flags, METHOD_ALLOWED, isInterface, METHOD_EXCLUDED);\n\n      if (isInterface && mt.containsCode()) {\n        // 'default' modifier (Java 8)\n        buffer.append(\"default \");\n      }\n\n      String name = mt.getName();\n      if (CodeConstants.INIT_NAME.equals(name)) {\n        if (node.type == ClassNode.CLASS_ANONYMOUS) {\n          name = \"\";\n          dinit = true;\n        }\n        else {\n          name = node.simpleName;\n          init = true;\n        }\n      }\n      else if (CodeConstants.CLINIT_NAME.equals(name)) {\n        name = \"\";\n        clinit = true;\n      }\n\n      GenericMethodDescriptor descriptor = null;\n      if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {\n        StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)mt.getAttributes().getWithKey(\"Signature\");\n        if (attr != null) {\n          descriptor = GenericMain.parseMethodSignature(attr.getSignature());\n          if (descriptor != null) {\n            int actualParams = md.params.length;\n            List<VarVersionPair> sigFields = methodWrapper.signatureFields;\n            if (sigFields != null) {\n               actualParams = 0;\n              for (VarVersionPair field : methodWrapper.signatureFields) {\n                if (field == null) {\n                  actualParams++;\n                }\n              }\n            }\n            else if (isEnum && init) actualParams -= 2;\n            if (actualParams != descriptor.params.size()) {\n              String message = \"Inconsistent generic signature in method \" + mt.getName() + \" \" + mt.getDescriptor() + \" in \" + cl.qualifiedName;\n              DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);\n              descriptor = null;\n            }\n          }\n        }\n      }\n\n      boolean throwsExceptions = false;\n      int paramCount = 0;\n\n      if (!clinit && !dinit) {\n        boolean thisVar = !mt.hasModifier(CodeConstants.ACC_STATIC);\n\n        if (descriptor != null && !descriptor.fparameters.isEmpty()) {\n          appendTypeParameters(buffer, descriptor.fparameters, descriptor.fbounds);\n          buffer.append(' ');\n        }\n\n        if (!init) {\n          if (descriptor != null) {\n            buffer.append(GenericMain.getGenericCastTypeName(descriptor.ret));\n          }\n          else {\n            buffer.append(ExprProcessor.getCastTypeName(md.ret));\n          }\n          buffer.append(' ');\n        }\n\n        buffer.append(toValidJavaIdentifier(name));\n        buffer.append('(');\n\n        // parameters\n        List<VarVersionPair> signFields = methodWrapper.signatureFields;\n\n        int lastVisibleParameterIndex = -1;\n        for (int i = 0; i < md.params.length; i++) {\n          if (signFields == null || signFields.get(i) == null) {\n            lastVisibleParameterIndex = i;\n          }\n        }\n\n        boolean firstParameter = true;\n        int index = isEnum && init ? 3 : thisVar ? 1 : 0;\n        boolean hasDescriptor = descriptor != null;\n        int start = isEnum && init && !hasDescriptor ? 2 : 0;\n        int params = hasDescriptor ? descriptor.params.size() : md.params.length;\n        for (int i = start; i < params; i++) {\n          if (hasDescriptor || (signFields == null || signFields.get(i) == null)) {\n            if (!firstParameter) {\n              buffer.append(\", \");\n            }\n\n            appendParameterAnnotations(buffer, mt, paramCount);\n\n            if (methodWrapper.varproc.getVarFinal(new VarVersionPair(index, 0)) == VarTypeProcessor.VAR_EXPLICIT_FINAL) {\n              buffer.append(\"final \");\n            }\n\n            if (descriptor != null) {\n              GenericType parameterType = descriptor.params.get(i);\n\n              boolean isVarArg = (i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);\n              if (isVarArg) {\n                parameterType = parameterType.decreaseArrayDim();\n              }\n\n              String typeName = GenericMain.getGenericCastTypeName(parameterType);\n              if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&\n                  DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {\n                typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);\n              }\n\n              buffer.append(typeName);\n\n              if (isVarArg) {\n                buffer.append(\"...\");\n              }\n            }\n            else {\n              VarType parameterType = md.params[i];\n\n              boolean isVarArg = (i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);\n              if (isVarArg) {\n                parameterType = parameterType.decreaseArrayDim();\n              }\n\n              String typeName = ExprProcessor.getCastTypeName(parameterType);\n              if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&\n                  DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {\n                typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);\n              }\n\n              buffer.append(typeName);\n\n              if (isVarArg) {\n                buffer.append(\"...\");\n              }\n            }\n\n            buffer.append(' ');\n            String parameterName = methodWrapper.varproc.getVarName(new VarVersionPair(index, 0));\n            buffer.append(parameterName == null ? \"param\" + index : parameterName); // null iff decompiled with errors\n\n            firstParameter = false;\n            paramCount++;\n          }\n\n          index += md.params[i].stackSize;\n        }\n\n        buffer.append(')');\n\n        StructExceptionsAttribute attr = (StructExceptionsAttribute)mt.getAttributes().getWithKey(\"Exceptions\");\n        if ((descriptor != null && !descriptor.exceptions.isEmpty()) || attr != null) {\n          throwsExceptions = true;\n          buffer.append(\" throws \");\n\n          for (int i = 0; i < attr.getThrowsExceptions().size(); i++) {\n            if (i > 0) {\n              buffer.append(\", \");\n            }\n            if (descriptor != null && !descriptor.exceptions.isEmpty()) {\n              GenericType type = descriptor.exceptions.get(i);\n              buffer.append(GenericMain.getGenericCastTypeName(type));\n            }\n            else {\n              VarType type = new VarType(attr.getExcClassname(i, cl.getPool()), true);\n              buffer.append(ExprProcessor.getCastTypeName(type));\n            }\n          }\n        }\n      }\n\n      tracer.incrementCurrentSourceLine(buffer.countLines(start_index_method));\n\n      if ((flags & (CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_NATIVE)) != 0) { // native or abstract method (explicit or interface)\n        if (isAnnotation) {\n          StructAnnDefaultAttribute attr = (StructAnnDefaultAttribute)mt.getAttributes().getWithKey(\"AnnotationDefault\");\n          if (attr != null) {\n            buffer.append(\" default \");\n            buffer.append(attr.getDefaultValue().toJava(indent + 1, new BytecodeMappingTracer())); // dummy tracer\n          }\n        }\n\n        buffer.append(';');\n        buffer.appendLineSeparator();\n        tracer.incrementCurrentSourceLine();\n      }\n      else {\n        if (!clinit && !dinit) {\n          buffer.append(' ');\n        }\n\n        // We do not have line information for method start, lets have it here for now\n        StructLineNumberTableAttribute lineNumberTable =\n          (StructLineNumberTableAttribute)mt.getAttributes().getWithKey(StructGeneralAttribute.ATTRIBUTE_LINE_NUMBER_TABLE);\n        if (lineNumberTable != null && DecompilerContext.getOption(IFernflowerPreferences.USE_DEBUG_LINE_NUMBERS)) {\n          buffer.setCurrentLine(lineNumberTable.getFirstLine() - 1);\n        }\n        buffer.append('{').appendLineSeparator();\n        tracer.incrementCurrentSourceLine();\n\n        RootStatement root = wrapper.getMethodWrapper(mt.getName(), mt.getDescriptor()).root;\n\n        if (root != null && !methodWrapper.decompiledWithErrors) { // check for existence\n          try {\n            int startLine = tracer.getCurrentSourceLine();\n\n            TextBuffer code = root.toJava(indent + 1, tracer);\n\n            hideMethod = (clinit || dinit || hideConstructor(wrapper, init, throwsExceptions, paramCount)) && code.length() == 0;\n\n            if (!hideMethod && lineNumberTable != null && DecompilerContext.getOption(IFernflowerPreferences.USE_DEBUG_LINE_NUMBERS)) {\n              mapLines(code, lineNumberTable, tracer, startLine);\n            }\n\n            buffer.append(code);\n          }\n          catch (Throwable ex) {\n            DecompilerContext.getLogger().writeMessage(\"Method \" + mt.getName() + \" \" + mt.getDescriptor() + \" couldn't be written.\", ex);\n            methodWrapper.decompiledWithErrors = true;\n          }\n        }\n\n        if (methodWrapper.decompiledWithErrors) {\n          buffer.appendIndent(indent + 1);\n          buffer.append(\"// $FF: Couldn't be decompiled\");\n          buffer.appendLineSeparator();\n          tracer.incrementCurrentSourceLine();\n        }\n\n        buffer.appendIndent(indent).append('}').appendLineSeparator();\n        tracer.incrementCurrentSourceLine();\n      }\n    }\n    finally {\n      DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, outerWrapper);\n    }\n\n    // save total lines\n    // TODO: optimize\n    //tracer.setCurrentSourceLine(buffer.countLines(start_index_method));\n\n    return !hideMethod;\n  }","id":28572,"modified_method":"private boolean methodToJava(ClassNode node, StructMethod mt, TextBuffer buffer, int indent, BytecodeMappingTracer tracer) {\n    ClassWrapper wrapper = node.getWrapper();\n    StructClass cl = wrapper.getClassStruct();\n    MethodWrapper methodWrapper = wrapper.getMethodWrapper(mt.getName(), mt.getDescriptor());\n\n    boolean hideMethod = false;\n    int start_index_method = buffer.length();\n\n    MethodWrapper outerWrapper = (MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);\n    DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, methodWrapper);\n\n    try {\n      boolean isInterface = cl.hasModifier(CodeConstants.ACC_INTERFACE);\n      boolean isAnnotation = cl.hasModifier(CodeConstants.ACC_ANNOTATION);\n      boolean isEnum = cl.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);\n      boolean isDeprecated = mt.getAttributes().containsKey(\"Deprecated\");\n      boolean clinit = false, init = false, dinit = false;\n\n      MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());\n\n      int flags = mt.getAccessFlags();\n      if ((flags & CodeConstants.ACC_NATIVE) != 0) {\n        flags &= ~CodeConstants.ACC_STRICT; // compiler bug: a strictfp class sets all methods to strictfp\n      }\n      if (CodeConstants.CLINIT_NAME.equals(mt.getName())) {\n        flags &= CodeConstants.ACC_STATIC; // ignore all modifiers except 'static' in a static initializer\n      }\n\n      if (isDeprecated) {\n        appendDeprecation(buffer, indent);\n      }\n\n      if (interceptor != null) {\n        String oldName = interceptor.getOldName(cl.qualifiedName + \" \" + mt.getName() + \" \" + mt.getDescriptor());\n        appendRenameComment(buffer, oldName, MType.METHOD, indent);\n      }\n\n      boolean isSynthetic = (flags & CodeConstants.ACC_SYNTHETIC) != 0 || mt.getAttributes().containsKey(\"Synthetic\");\n      boolean isBridge = (flags & CodeConstants.ACC_BRIDGE) != 0;\n      if (isSynthetic) {\n        appendComment(buffer, \"synthetic method\", indent);\n      }\n      if (isBridge) {\n        appendComment(buffer, \"bridge method\", indent);\n      }\n\n      appendAnnotations(buffer, mt, indent);\n\n      buffer.appendIndent(indent);\n\n      appendModifiers(buffer, flags, METHOD_ALLOWED, isInterface, METHOD_EXCLUDED);\n\n      if (isInterface && mt.containsCode()) {\n        // 'default' modifier (Java 8)\n        buffer.append(\"default \");\n      }\n\n      String name = mt.getName();\n      if (CodeConstants.INIT_NAME.equals(name)) {\n        if (node.type == ClassNode.CLASS_ANONYMOUS) {\n          name = \"\";\n          dinit = true;\n        }\n        else {\n          name = node.simpleName;\n          init = true;\n        }\n      }\n      else if (CodeConstants.CLINIT_NAME.equals(name)) {\n        name = \"\";\n        clinit = true;\n      }\n\n      GenericMethodDescriptor descriptor = null;\n      if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {\n        StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)mt.getAttributes().getWithKey(\"Signature\");\n        if (attr != null) {\n          descriptor = GenericMain.parseMethodSignature(attr.getSignature());\n          if (descriptor != null) {\n            int actualParams = md.params.length;\n            List<VarVersionPair> sigFields = methodWrapper.signatureFields;\n            if (sigFields != null) {\n               actualParams = 0;\n              for (VarVersionPair field : methodWrapper.signatureFields) {\n                if (field == null) {\n                  actualParams++;\n                }\n              }\n            }\n            else if (isEnum && init) actualParams -= 2;\n            if (actualParams != descriptor.params.size()) {\n              String message = \"Inconsistent generic signature in method \" + mt.getName() + \" \" + mt.getDescriptor() + \" in \" + cl.qualifiedName;\n              DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);\n              descriptor = null;\n            }\n          }\n        }\n      }\n\n      boolean throwsExceptions = false;\n      int paramCount = 0;\n\n      if (!clinit && !dinit) {\n        boolean thisVar = !mt.hasModifier(CodeConstants.ACC_STATIC);\n\n        if (descriptor != null && !descriptor.fparameters.isEmpty()) {\n          appendTypeParameters(buffer, descriptor.fparameters, descriptor.fbounds);\n          buffer.append(' ');\n        }\n\n        if (!init) {\n          if (descriptor != null) {\n            buffer.append(GenericMain.getGenericCastTypeName(descriptor.ret));\n          }\n          else {\n            buffer.append(ExprProcessor.getCastTypeName(md.ret));\n          }\n          buffer.append(' ');\n        }\n\n        buffer.append(toValidJavaIdentifier(name));\n        buffer.append('(');\n\n        // parameters\n        List<VarVersionPair> signFields = methodWrapper.signatureFields;\n\n        int lastVisibleParameterIndex = -1;\n        for (int i = 0; i < md.params.length; i++) {\n          if (signFields == null || signFields.get(i) == null) {\n            lastVisibleParameterIndex = i;\n          }\n        }\n\n        boolean firstParameter = true;\n        int index = isEnum && init ? 3 : thisVar ? 1 : 0;\n        boolean hasDescriptor = descriptor != null;\n        int start = isEnum && init && !hasDescriptor ? 2 : 0;\n        int params = hasDescriptor ? descriptor.params.size() : md.params.length;\n        for (int i = start; i < params; i++) {\n          if (hasDescriptor || (signFields == null || signFields.get(i) == null)) {\n            if (!firstParameter) {\n              buffer.append(\", \");\n            }\n\n            appendParameterAnnotations(buffer, mt, paramCount);\n\n            if (methodWrapper.varproc.getVarFinal(new VarVersionPair(index, 0)) == VarTypeProcessor.VAR_EXPLICIT_FINAL) {\n              buffer.append(\"final \");\n            }\n\n            if (descriptor != null) {\n              GenericType parameterType = descriptor.params.get(i);\n\n              boolean isVarArg = (i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);\n              if (isVarArg) {\n                parameterType = parameterType.decreaseArrayDim();\n              }\n\n              String typeName = GenericMain.getGenericCastTypeName(parameterType);\n              if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&\n                  DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {\n                typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);\n              }\n\n              buffer.append(typeName);\n\n              if (isVarArg) {\n                buffer.append(\"...\");\n              }\n            }\n            else {\n              VarType parameterType = md.params[i];\n\n              boolean isVarArg = (i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);\n              if (isVarArg) {\n                parameterType = parameterType.decreaseArrayDim();\n              }\n\n              String typeName = ExprProcessor.getCastTypeName(parameterType);\n              if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&\n                  DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {\n                typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);\n              }\n\n              buffer.append(typeName);\n\n              if (isVarArg) {\n                buffer.append(\"...\");\n              }\n            }\n\n            buffer.append(' ');\n            String parameterName = methodWrapper.varproc.getVarName(new VarVersionPair(index, 0));\n            buffer.append(parameterName == null ? \"param\" + index : parameterName); // null iff decompiled with errors\n\n            firstParameter = false;\n            paramCount++;\n          }\n\n          index += md.params[i].stackSize;\n        }\n\n        buffer.append(')');\n\n        StructExceptionsAttribute attr = (StructExceptionsAttribute)mt.getAttributes().getWithKey(\"Exceptions\");\n        if ((descriptor != null && !descriptor.exceptions.isEmpty()) || attr != null) {\n          throwsExceptions = true;\n          buffer.append(\" throws \");\n\n          for (int i = 0; i < attr.getThrowsExceptions().size(); i++) {\n            if (i > 0) {\n              buffer.append(\", \");\n            }\n            if (descriptor != null && !descriptor.exceptions.isEmpty()) {\n              GenericType type = descriptor.exceptions.get(i);\n              buffer.append(GenericMain.getGenericCastTypeName(type));\n            }\n            else {\n              VarType type = new VarType(attr.getExcClassname(i, cl.getPool()), true);\n              buffer.append(ExprProcessor.getCastTypeName(type));\n            }\n          }\n        }\n      }\n\n      tracer.incrementCurrentSourceLine(buffer.countLines(start_index_method));\n\n      if ((flags & (CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_NATIVE)) != 0) { // native or abstract method (explicit or interface)\n        if (isAnnotation) {\n          StructAnnDefaultAttribute attr = (StructAnnDefaultAttribute)mt.getAttributes().getWithKey(\"AnnotationDefault\");\n          if (attr != null) {\n            buffer.append(\" default \");\n            buffer.append(attr.getDefaultValue().toJava(indent + 1, new BytecodeMappingTracer())); // dummy tracer\n          }\n        }\n\n        buffer.append(';');\n        buffer.appendLineSeparator();\n        tracer.incrementCurrentSourceLine();\n      }\n      else {\n        if (!clinit && !dinit) {\n          buffer.append(' ');\n        }\n\n        // We do not have line information for method start, lets have it here for now\n        StructLineNumberTableAttribute lineNumberTable =\n          (StructLineNumberTableAttribute)mt.getAttributes().getWithKey(StructGeneralAttribute.ATTRIBUTE_LINE_NUMBER_TABLE);\n        if (lineNumberTable != null && DecompilerContext.getOption(IFernflowerPreferences.USE_DEBUG_LINE_NUMBERS)) {\n          buffer.setCurrentLine(lineNumberTable.getFirstLine() - 1);\n        }\n        buffer.append('{').appendLineSeparator();\n        tracer.incrementCurrentSourceLine();\n\n        RootStatement root = wrapper.getMethodWrapper(mt.getName(), mt.getDescriptor()).root;\n\n        if (root != null && !methodWrapper.decompiledWithErrors) { // check for existence\n          try {\n            int startLine = tracer.getCurrentSourceLine();\n\n            TextBuffer code = root.toJava(indent + 1, tracer);\n\n            hideMethod = (clinit || dinit || hideConstructor(wrapper, init, throwsExceptions, paramCount)) && code.length() == 0;\n\n            if (!hideMethod && lineNumberTable != null && DecompilerContext.getOption(IFernflowerPreferences.USE_DEBUG_LINE_NUMBERS)) {\n              mapLines(code, lineNumberTable, tracer, startLine);\n            }\n\n            buffer.append(code);\n          }\n          catch (Throwable ex) {\n            DecompilerContext.getLogger().writeMessage(\"Method \" + mt.getName() + \" \" + mt.getDescriptor() + \" couldn't be written.\", ex);\n            methodWrapper.decompiledWithErrors = true;\n          }\n        }\n\n        if (methodWrapper.decompiledWithErrors) {\n          buffer.appendIndent(indent + 1);\n          buffer.append(\"// $FF: Couldn't be decompiled\");\n          buffer.appendLineSeparator();\n          tracer.incrementCurrentSourceLine();\n        }\n\n        if (root != null) {\n          tracer.addMapping(root.getDummyExit().bytecode);\n        }\n        buffer.appendIndent(indent).append('}').appendLineSeparator();\n        tracer.incrementCurrentSourceLine();\n      }\n    }\n    finally {\n      DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, outerWrapper);\n    }\n\n    // save total lines\n    // TODO: optimize\n    //tracer.setCurrentSourceLine(buffer.countLines(start_index_method));\n\n    return !hideMethod;\n  }","commit_id":"99916a4b4cdebff66c53b12d0d1ae0f33eca357b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void methodLambdaToJava(ClassNode lambdaNode,\n                                         ClassWrapper classWrapper,\n                                         StructMethod mt,\n                                         TextBuffer buffer,\n                                         int indent,\n                                         boolean codeOnly, BytecodeMappingTracer tracer) {\n    MethodWrapper methodWrapper = classWrapper.getMethodWrapper(mt.getName(), mt.getDescriptor());\n\n    MethodWrapper outerWrapper = (MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);\n    DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, methodWrapper);\n\n    try {\n      String method_name = lambdaNode.lambdaInformation.method_name;\n      MethodDescriptor md_content = MethodDescriptor.parseDescriptor(lambdaNode.lambdaInformation.content_method_descriptor);\n      MethodDescriptor md_lambda = MethodDescriptor.parseDescriptor(lambdaNode.lambdaInformation.method_descriptor);\n\n      if (!codeOnly) {\n        buffer.appendIndent(indent);\n        buffer.append(\"public \");\n        buffer.append(method_name);\n        buffer.append(\"(\");\n\n        boolean firstParameter = true;\n        int index = lambdaNode.lambdaInformation.is_content_method_static ? 0 : 1;\n        int start_index = md_content.params.length - md_lambda.params.length;\n\n        for (int i = 0; i < md_content.params.length; i++) {\n          if (i >= start_index) {\n            if (!firstParameter) {\n              buffer.append(\", \");\n            }\n\n            String typeName = ExprProcessor.getCastTypeName(md_content.params[i].copy());\n            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&\n                DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {\n              typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);\n            }\n\n            buffer.append(typeName);\n            buffer.append(\" \");\n\n            String parameterName = methodWrapper.varproc.getVarName(new VarVersionPair(index, 0));\n            buffer.append(parameterName == null ? \"param\" + index : parameterName); // null iff decompiled with errors\n\n            firstParameter = false;\n          }\n\n          index += md_content.params[i].stackSize;\n        }\n\n        buffer.append(\") {\").appendLineSeparator();\n\n        indent += 1;\n      }\n\n      if (!methodWrapper.decompiledWithErrors) {\n        RootStatement root = classWrapper.getMethodWrapper(mt.getName(), mt.getDescriptor()).root;\n        if (root != null) { // check for existence\n          try {\n            buffer.append(root.toJava(indent, tracer));\n          }\n          catch (Throwable ex) {\n            DecompilerContext.getLogger().writeMessage(\"Method \" + mt.getName() + \" \" + mt.getDescriptor() + \" couldn't be written.\", ex);\n            methodWrapper.decompiledWithErrors = true;\n          }\n        }\n      }\n\n      if (methodWrapper.decompiledWithErrors) {\n        buffer.appendIndent(indent);\n        buffer.append(\"// $FF: Couldn't be decompiled\");\n        buffer.appendLineSeparator();\n      }\n\n      if (!codeOnly) {\n        indent -= 1;\n\n        buffer.appendIndent(indent);\n        buffer.append('}');\n        buffer.appendLineSeparator();\n      }\n    }\n    finally {\n      DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, outerWrapper);\n    }\n  }","id":28573,"modified_method":"private static void methodLambdaToJava(ClassNode lambdaNode,\n                                         ClassWrapper classWrapper,\n                                         StructMethod mt,\n                                         TextBuffer buffer,\n                                         int indent,\n                                         boolean codeOnly, BytecodeMappingTracer tracer) {\n    MethodWrapper methodWrapper = classWrapper.getMethodWrapper(mt.getName(), mt.getDescriptor());\n\n    MethodWrapper outerWrapper = (MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);\n    DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, methodWrapper);\n\n    try {\n      String method_name = lambdaNode.lambdaInformation.method_name;\n      MethodDescriptor md_content = MethodDescriptor.parseDescriptor(lambdaNode.lambdaInformation.content_method_descriptor);\n      MethodDescriptor md_lambda = MethodDescriptor.parseDescriptor(lambdaNode.lambdaInformation.method_descriptor);\n\n      if (!codeOnly) {\n        buffer.appendIndent(indent);\n        buffer.append(\"public \");\n        buffer.append(method_name);\n        buffer.append(\"(\");\n\n        boolean firstParameter = true;\n        int index = lambdaNode.lambdaInformation.is_content_method_static ? 0 : 1;\n        int start_index = md_content.params.length - md_lambda.params.length;\n\n        for (int i = 0; i < md_content.params.length; i++) {\n          if (i >= start_index) {\n            if (!firstParameter) {\n              buffer.append(\", \");\n            }\n\n            String typeName = ExprProcessor.getCastTypeName(md_content.params[i].copy());\n            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&\n                DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {\n              typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);\n            }\n\n            buffer.append(typeName);\n            buffer.append(\" \");\n\n            String parameterName = methodWrapper.varproc.getVarName(new VarVersionPair(index, 0));\n            buffer.append(parameterName == null ? \"param\" + index : parameterName); // null iff decompiled with errors\n\n            firstParameter = false;\n          }\n\n          index += md_content.params[i].stackSize;\n        }\n\n        buffer.append(\") {\").appendLineSeparator();\n\n        indent += 1;\n      }\n\n      RootStatement root = classWrapper.getMethodWrapper(mt.getName(), mt.getDescriptor()).root;\n      if (!methodWrapper.decompiledWithErrors) {\n        if (root != null) { // check for existence\n          try {\n            buffer.append(root.toJava(indent, tracer));\n          }\n          catch (Throwable ex) {\n            DecompilerContext.getLogger().writeMessage(\"Method \" + mt.getName() + \" \" + mt.getDescriptor() + \" couldn't be written.\", ex);\n            methodWrapper.decompiledWithErrors = true;\n          }\n        }\n      }\n\n      if (methodWrapper.decompiledWithErrors) {\n        buffer.appendIndent(indent);\n        buffer.append(\"// $FF: Couldn't be decompiled\");\n        buffer.appendLineSeparator();\n      }\n\n      if (root != null) {\n        tracer.addMapping(root.getDummyExit().bytecode);\n      }\n\n      if (!codeOnly) {\n        indent -= 1;\n        buffer.appendIndent(indent).append('}').appendLineSeparator();\n      }\n    }\n    finally {\n      DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER, outerWrapper);\n    }\n  }","commit_id":"99916a4b4cdebff66c53b12d0d1ae0f33eca357b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static RootStatement graphToStatement(ControlFlowGraph graph) {\n\n    VBStyleCollection<Statement, Integer> stats = new VBStyleCollection<Statement, Integer>();\n    VBStyleCollection<BasicBlock, Integer> blocks = graph.getBlocks();\n\n    for (BasicBlock block : blocks) {\n      stats.addWithKey(new BasicBlockStatement(block), block.id);\n    }\n\n    BasicBlock firstblock = graph.getFirst();\n    // head statement\n    Statement firstst = stats.getWithKey(firstblock.id);\n    // dummy exit statement\n    Statement dummyexit = new Statement();\n    dummyexit.type = Statement.TYPE_DUMMYEXIT;\n\n    Statement general;\n    if (stats.size() > 1 || firstblock.isSuccessor(firstblock)) { // multiple basic blocks or an infinite loop of one block\n      general = new GeneralStatement(firstst, stats, null);\n    }\n    else { // one straightforward basic block\n      RootStatement root = new RootStatement(firstst, dummyexit);\n      firstst.addSuccessor(new StatEdge(StatEdge.TYPE_BREAK, firstst, dummyexit, root));\n\n      return root;\n    }\n\n    for (BasicBlock block : blocks) {\n      Statement stat = stats.getWithKey(block.id);\n\n      for (BasicBlock succ : block.getSuccs()) {\n        Statement stsucc = stats.getWithKey(succ.id);\n\n        int type;\n        if (stsucc == firstst) {\n          type = StatEdge.TYPE_CONTINUE;\n        }\n        else if (graph.getFinallyExits().contains(block)) {\n          type = StatEdge.TYPE_FINALLYEXIT;\n          stsucc = dummyexit;\n        }\n        else if (succ.id == graph.getLast().id) {\n          type = StatEdge.TYPE_BREAK;\n          stsucc = dummyexit;\n        }\n        else {\n          type = StatEdge.TYPE_REGULAR;\n        }\n\n        stat.addSuccessor(new StatEdge(type, stat, (type == StatEdge.TYPE_CONTINUE) ? general : stsucc,\n                                       (type == StatEdge.TYPE_REGULAR) ? null : general));\n      }\n\n      // exceptions edges\n      for (BasicBlock succex : block.getSuccExceptions()) {\n        Statement stsuccex = stats.getWithKey(succex.id);\n\n        ExceptionRangeCFG range = graph.getExceptionRange(succex, block);\n        if (!range.isCircular()) {\n          stat.addSuccessor(new StatEdge(stat, stsuccex, range.getExceptionTypes()));\n        }\n      }\n    }\n\n    general.buildContinueSet();\n    general.buildMonitorFlags();\n    return new RootStatement(general, dummyexit);\n  }","id":28574,"modified_method":"private static RootStatement graphToStatement(ControlFlowGraph graph) {\n\n    VBStyleCollection<Statement, Integer> stats = new VBStyleCollection<Statement, Integer>();\n    VBStyleCollection<BasicBlock, Integer> blocks = graph.getBlocks();\n\n    for (BasicBlock block : blocks) {\n      stats.addWithKey(new BasicBlockStatement(block), block.id);\n    }\n\n    BasicBlock firstblock = graph.getFirst();\n    // head statement\n    Statement firstst = stats.getWithKey(firstblock.id);\n    // dummy exit statement\n    DummyExitStatement dummyexit = new DummyExitStatement();\n\n    Statement general;\n    if (stats.size() > 1 || firstblock.isSuccessor(firstblock)) { // multiple basic blocks or an infinite loop of one block\n      general = new GeneralStatement(firstst, stats, null);\n    }\n    else { // one straightforward basic block\n      RootStatement root = new RootStatement(firstst, dummyexit);\n      firstst.addSuccessor(new StatEdge(StatEdge.TYPE_BREAK, firstst, dummyexit, root));\n\n      return root;\n    }\n\n    for (BasicBlock block : blocks) {\n      Statement stat = stats.getWithKey(block.id);\n\n      for (BasicBlock succ : block.getSuccs()) {\n        Statement stsucc = stats.getWithKey(succ.id);\n\n        int type;\n        if (stsucc == firstst) {\n          type = StatEdge.TYPE_CONTINUE;\n        }\n        else if (graph.getFinallyExits().contains(block)) {\n          type = StatEdge.TYPE_FINALLYEXIT;\n          stsucc = dummyexit;\n        }\n        else if (succ.id == graph.getLast().id) {\n          type = StatEdge.TYPE_BREAK;\n          stsucc = dummyexit;\n        }\n        else {\n          type = StatEdge.TYPE_REGULAR;\n        }\n\n        stat.addSuccessor(new StatEdge(type, stat, (type == StatEdge.TYPE_CONTINUE) ? general : stsucc,\n                                       (type == StatEdge.TYPE_REGULAR) ? null : general));\n      }\n\n      // exceptions edges\n      for (BasicBlock succex : block.getSuccExceptions()) {\n        Statement stsuccex = stats.getWithKey(succex.id);\n\n        ExceptionRangeCFG range = graph.getExceptionRange(succex, block);\n        if (!range.isCircular()) {\n          stat.addSuccessor(new StatEdge(stat, stsuccex, range.getExceptionTypes()));\n        }\n      }\n    }\n\n    general.buildContinueSet();\n    general.buildMonitorFlags();\n    return new RootStatement(general, dummyexit);\n  }","commit_id":"99916a4b4cdebff66c53b12d0d1ae0f33eca357b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean removeRedundantReturns(RootStatement root) {\n\n    boolean res = false;\n\n    for (StatEdge edge : root.getDummyExit().getAllPredecessorEdges()) {\n      if (!edge.explicit) {\n        Statement source = edge.getSource();\n        List<Exprent> lstExpr = source.getExprents();\n        if (lstExpr != null && !lstExpr.isEmpty()) {\n          Exprent expr = lstExpr.get(lstExpr.size() - 1);\n          if (expr.type == Exprent.EXPRENT_EXIT) {\n            ExitExprent ex = (ExitExprent)expr;\n            if (ex.getExitType() == ExitExprent.EXIT_RETURN && ex.getValue() == null) {\n              // remove redundant return\n              lstExpr.remove(lstExpr.size() - 1);\n              res = true;\n            }\n          }\n        }\n      }\n    }\n\n    return res;\n  }","id":28575,"modified_method":"public static boolean removeRedundantReturns(RootStatement root) {\n\n    boolean res = false;\n\n    DummyExitStatement dummyExit = root.getDummyExit();\n\n    for (StatEdge edge : dummyExit.getAllPredecessorEdges()) {\n      if (!edge.explicit) {\n        Statement source = edge.getSource();\n        List<Exprent> lstExpr = source.getExprents();\n        if (lstExpr != null && !lstExpr.isEmpty()) {\n          Exprent expr = lstExpr.get(lstExpr.size() - 1);\n          if (expr.type == Exprent.EXPRENT_EXIT) {\n            ExitExprent ex = (ExitExprent)expr;\n            if (ex.getExitType() == ExitExprent.EXIT_RETURN && ex.getValue() == null) {\n              // remove redundant return\n              dummyExit.addBytecodeOffsets(ex.bytecode);\n              lstExpr.remove(lstExpr.size() - 1);\n              res = true;\n            }\n          }\n        }\n      }\n    }\n\n    return res;\n  }","commit_id":"99916a4b4cdebff66c53b12d0d1ae0f33eca357b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setDummyExit(Statement dummyExit) {\n    this.dummyExit = dummyExit;\n  }","id":28576,"modified_method":"public void setDummyExit(DummyExitStatement dummyExit) {\n    this.dummyExit = dummyExit;\n  }","commit_id":"99916a4b4cdebff66c53b12d0d1ae0f33eca357b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RootStatement(Statement head, Statement dummyExit) {\n\n    type = Statement.TYPE_ROOT;\n\n    first = head;\n    this.dummyExit = dummyExit;\n\n    stats.addWithKey(first, first.id);\n    first.setParent(this);\n  }","id":28577,"modified_method":"public RootStatement(Statement head, DummyExitStatement dummyExit) {\n\n    type = Statement.TYPE_ROOT;\n\n    first = head;\n    this.dummyExit = dummyExit;\n\n    stats.addWithKey(first, first.id);\n    first.setParent(this);\n  }","commit_id":"99916a4b4cdebff66c53b12d0d1ae0f33eca357b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Statement getDummyExit() {\n    return dummyExit;\n  }","id":28578,"modified_method":"public DummyExitStatement getDummyExit() {\n    return dummyExit;\n  }","commit_id":"99916a4b4cdebff66c53b12d0d1ae0f33eca357b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Opens the validation options sidebar\n     *\n     * @return new EditorPage\n     */\n    public EditorPage openValidationOptions() {\n        getDriver().findElement(By.className(\"i--checkmark\")).click();\n        waitForTenSec().until(new Function<WebDriver, Boolean>() {\n            @Override\n            public Boolean apply(WebDriver driver) {\n                return getDriver().findElement(By.id(\"validationOptionsView\"))\n                        .isDisplayed();\n            }\n        });\n        return new EditorPage(getDriver());\n    }","id":28579,"modified_method":"/**\n     * Opens the validation options sidebar\n     *\n     * @return new EditorPage\n     */\n    public EditorPage openValidationOptions() {\n        waitForTenSec().until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return getDriver()\n                        .findElement(By.id(\"container\"))\n                        .findElement(By.className(\"new-zanata\"))\n                        .findElement(By.xpath(\"//a[@title='Validation options']\"))\n                        .isEnabled();\n            }\n        });\n        new Actions(getDriver()).click(\n                getDriver().findElement(By.id(\"container\"))\n                        .findElement(By.className(\"new-zanata\"))\n                        .findElement(By.xpath(\"//a[@title='Validation options']\")))\n                .perform();\n        waitForTenSec().until(new Function<WebDriver, Boolean>() {\n            @Override\n            public Boolean apply(WebDriver driver) {\n                return getDriver().findElement(By.id(\"validationOptionsView\"))\n                        .isDisplayed();\n            }\n        });\n        return new EditorPage(getDriver());\n    }","commit_id":"db6b7d0ccd35ffafeadbd62a02d29501fbb152bb","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n      protected boolean buildHeaderOrFooterImpl()\n      {\n         TableRowBuilder row = startRow();\n         row.startTD().className(style_.objectGridHeader()).text(\"Name\").endTD();\n         row.startTD().className(style_.objectGridHeader()).text(\"Type\").endTD();\n         row.startTD().className(style_.objectGridHeader()).text(\"Length\").endTD();\n         row.startTD().className(style_.objectGridHeader()).text(\"Size\").endTD();\n         row.startTD().className(style_.objectGridHeader()).text(\"Value\").endTD();\n         row.end();\n         return true;\n      }","id":28580,"modified_method":"@Override\n      protected boolean buildHeaderOrFooterImpl()\n      {\n         TableRowBuilder row = startRow();\n         for (ObjectGridColumn col: columns_)\n         {\n            TableCellBuilder cell = row.startTD();\n            cell.className(style_.objectGridHeader());\n            cell.style().width(col.getWidth(), Unit.PCT);\n            cell.text(col.getName());\n            cell.endTD();\n         }\n         row.end();\n         return true;\n      }","commit_id":"36102b83149d513c34b8691034896cb7fbd190ee","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void createColumns()\n   {\n      columns_.add(new Column<RObjectEntry, String>(\n              new ClickableTextCell())\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return object.rObject.getName();\n                  }\n              });\n      columns_.add(new Column<RObjectEntry, String>(\n              new ClickableTextCell())\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return object.rObject.getType();\n                  }\n              });\n      columns_.add(new Column<RObjectEntry, String>(\n              new ClickableTextCell())\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return (new Integer(object.rObject.getLength())).toString();\n                  }\n              });\n      columns_.add(new Column<RObjectEntry, String>(\n              new ClickableTextCell())\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return StringUtil.formatFileSize(object.rObject.getSize());\n                  }\n              });\n      columns_.add(new Column<RObjectEntry, String>(\n              new ClickableTextCell())\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return object.rObject.getValue();\n                  }\n              });\n      for (Column<RObjectEntry, String> column: columns_)\n      {\n         addColumn(column);\n      }\n   }","id":28581,"modified_method":"private void createColumns()\n   {\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(), \"Name\", 20, \n              ObjectGridColumn.COLUMN_NAME)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return object.rObject.getName();\n                  }\n              });\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(), \"Type\", 15, ObjectGridColumn.COLUMN_TYPE)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return object.rObject.getType();\n                  }\n              });\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(), \"Length\", 10, ObjectGridColumn.COLUMN_LENGTH)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return (new Integer(object.rObject.getLength())).toString();\n                  }\n              });\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(), \"Size\", 15, ObjectGridColumn.COLUMN_SIZE)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return StringUtil.formatFileSize(object.rObject.getSize());\n                  }\n              });\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(), \"Value\", 40, ObjectGridColumn.COLUMN_VALUE)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return object.rObject.getValue();\n                  }\n              });\n      for (Column<RObjectEntry, String> column: columns_)\n      {\n         addColumn(column);\n      }\n   }","commit_id":"36102b83149d513c34b8691034896cb7fbd190ee","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n      protected void buildRowImpl(RObjectEntry rowValue, int absRowIndex)\n      {\n         TableRowBuilder row = startRow();\n\n         if (!rowValue.visible)\n            return;\n\n         for (int i = 0; i < columns_.size(); i++)\n         {\n            TableCellBuilder nameCol = row.startTD();\n            nameCol.className(style_.objectGridColumn());\n            renderCell(nameCol, createContext(i), columns_.get(i), rowValue);\n            nameCol.endTD();\n         }\n         \n         row.end();\n      }","id":28582,"modified_method":"@Override\n      protected void buildRowImpl(RObjectEntry rowValue, int absRowIndex)\n      {\n         TableRowBuilder row = startRow();\n\n         if (!rowValue.visible)\n            return;\n\n         for (int i = 0; i < columns_.size(); i++)\n         {\n            ObjectGridColumn col = columns_.get(i);\n            TableCellBuilder nameCol = row.startTD();\n            nameCol.className(style_.objectGridColumn());\n            nameCol.style().width(col.getWidth(), Unit.PCT);\n            renderCell(nameCol, createContext(i), col, rowValue);\n            nameCol.endTD();\n         }\n         \n         row.end();\n      }","commit_id":"36102b83149d513c34b8691034896cb7fbd190ee","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void setObjectDisplay(int type)\n   {\n      // if we already have an active display of this type, do nothing\n      if (type == objectDisplayType_ && \n          objectDisplay_ != null)\n      {\n         return;\n      }\n      \n      // clean up previous object display, if we had one\n      if (objectDisplay_ != null)\n      {\n         objectDataProvider_.removeDataDisplay(objectDisplay_);\n         splitPanel.remove(objectDisplay_);\n      }\n      // create the new object display and wire it to the data source\n      if (type == OBJECT_LIST_VIEW)\n         objectDisplay_ = new EnvironmentObjectList(this, observer_);\n      else if (type == OBJECT_GRID_VIEW)\n         objectDisplay_ = new EnvironmentObjectGrid(this, observer_);\n\n      objectDataProvider_.addDataDisplay(objectDisplay_);\n\n      // disable persistent and transient row selection (currently necessary\n      // because we emit more than one row per object and the DataGrid selection\n      // behaviors aren't designed to work that way)\n      objectDisplay_.setSelectionModel(new NoSelectionModel<RObjectEntry>(\n              RObjectEntry.KEY_PROVIDER));\n      objectDisplay_.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.DISABLED);\n      objectDisplay_.getScrollPanel().addScrollHandler(new ScrollHandler()\n      {\n         @Override\n         public void onScroll(ScrollEvent event)\n         {\n            if (useStatePersistence())\n            {\n               deferredScrollPosition_ = getScrollPosition();\n               observer_.setPersistedScrollPosition(deferredScrollPosition_);\n            }\n         }\n      });\n\n      objectDisplay_.setEmptyTableWidget(buildEmptyGridMessage());\n      objectDisplay_.setStyleName(style.objectGrid() + \" \" + style.environmentPanel());\n      splitPanel.add(objectDisplay_);\n      objectDisplayType_ = type;\n   }","id":28583,"modified_method":"public void setObjectDisplay(int type)\n   {\n      // if we already have an active display of this type, do nothing\n      if (type == objectDisplayType_ && \n          objectDisplay_ != null)\n      {\n         return;\n      }\n      \n      // clean up previous object display, if we had one\n      if (objectDisplay_ != null)\n      {\n         objectDataProvider_.removeDataDisplay(objectDisplay_);\n         splitPanel.remove(objectDisplay_);\n      }\n      // create the new object display and wire it to the data source\n      if (type == OBJECT_LIST_VIEW)\n      {\n         objectDisplay_ = new EnvironmentObjectList(this, observer_);\n         objectSort_.setSortType(RObjectEntrySort.SORT_AUTO);\n      }\n      else if (type == OBJECT_GRID_VIEW)\n      {\n         objectDisplay_ = new EnvironmentObjectGrid(this, observer_);\n         objectSort_.setSortType(RObjectEntrySort.SORT_COLUMN);\n      }\n\n      Collections.sort(objectDataProvider_.getList(), objectSort_);\n      objectDataProvider_.addDataDisplay(objectDisplay_);\n\n      // disable persistent and transient row selection (currently necessary\n      // because we emit more than one row per object and the DataGrid selection\n      // behaviors aren't designed to work that way)\n      objectDisplay_.setSelectionModel(new NoSelectionModel<RObjectEntry>(\n              RObjectEntry.KEY_PROVIDER));\n      objectDisplay_.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.DISABLED);\n      objectDisplay_.getScrollPanel().addScrollHandler(new ScrollHandler()\n      {\n         @Override\n         public void onScroll(ScrollEvent event)\n         {\n            if (useStatePersistence())\n            {\n               deferredScrollPosition_ = getScrollPosition();\n               observer_.setPersistedScrollPosition(deferredScrollPosition_);\n            }\n         }\n      });\n\n      objectDisplay_.setEmptyTableWidget(buildEmptyGridMessage());\n      objectDisplay_.setStyleName(style.objectGrid() + \" \" + style.environmentPanel());\n      splitPanel.add(objectDisplay_);\n      objectDisplayType_ = type;\n   }","commit_id":"36102b83149d513c34b8691034896cb7fbd190ee","url":"https://github.com/rstudio/rstudio"},{"original_method":"public EnvironmentObjects(EnvironmentObjectsObserver observer)\n   {\n      observer_ = observer;\n      contextDepth_ = 0;\n      environmentName_ = EnvironmentPane.GLOBAL_ENVIRONMENT_NAME;\n\n      objectDisplayType_ = OBJECT_LIST_VIEW;\n      objectDataProvider_ = new ListDataProvider<RObjectEntry>();\n\n      // set up the call frame panel\n      callFramePanel_ = new CallFramePanel(observer_, this);\n\n      initWidget(GWT.<Binder>create(Binder.class).createAndBindUi(this));\n\n      splitPanel.addSouth(callFramePanel_, 150);\n      splitPanel.setWidgetMinSize(callFramePanel_, style.headerRowHeight());\n      \n      setObjectDisplay(objectDisplayType_);\n      \n      FontSizer.applyNormalFontSize(this);\n   }","id":28584,"modified_method":"public EnvironmentObjects(EnvironmentObjectsObserver observer)\n   {\n      observer_ = observer;\n      contextDepth_ = 0;\n      environmentName_ = EnvironmentPane.GLOBAL_ENVIRONMENT_NAME;\n\n      objectDisplayType_ = OBJECT_LIST_VIEW;\n      objectDataProvider_ = new ListDataProvider<RObjectEntry>();\n      objectSort_ = new RObjectEntrySort();\n\n      // set up the call frame panel\n      callFramePanel_ = new CallFramePanel(observer_, this);\n\n      initWidget(GWT.<Binder>create(Binder.class).createAndBindUi(this));\n\n      splitPanel.addSouth(callFramePanel_, 150);\n      splitPanel.setWidgetMinSize(callFramePanel_, style.headerRowHeight());\n      \n      setObjectDisplay(objectDisplayType_);\n      \n      FontSizer.applyNormalFontSize(this);\n   }","commit_id":"36102b83149d513c34b8691034896cb7fbd190ee","url":"https://github.com/rstudio/rstudio"},{"original_method":"private int indexOfNewObject(RObjectEntry obj)\n   {\n      List<RObjectEntry> objects = objectDataProvider_.getList();\n      RObjectEntrySort sort = new RObjectEntrySort();\n      int numObjects = objects.size();\n      int idx;\n      // consider: can we use binary search here?\n      for (idx = 0; idx < numObjects; idx++)\n      {\n         if (sort.compare(obj, objects.get(idx)) < 0)\n         {\n            break;\n         }\n      }\n      return idx;\n   }","id":28585,"modified_method":"private int indexOfNewObject(RObjectEntry obj)\n   {\n      List<RObjectEntry> objects = objectDataProvider_.getList();\n      int numObjects = objects.size();\n      int idx;\n      // consider: can we use binary search here?\n      for (idx = 0; idx < numObjects; idx++)\n      {\n         if (objectSort_.compare(obj, objects.get(idx)) < 0)\n         {\n            break;\n         }\n      }\n      return idx;\n   }","commit_id":"36102b83149d513c34b8691034896cb7fbd190ee","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void addObjects(JsArray<RObject> objects)\n   {\n      // create an entry for each object and sort the array\n      int numObjects = objects.length();\n      ArrayList<RObjectEntry> objectEntryList = new ArrayList<RObjectEntry>();\n      for (int i = 0; i < numObjects; i++)\n      {\n         RObjectEntry entry = entryFromRObject(objects.get(i));\n         objectEntryList.add(entry);\n      }\n      Collections.sort(objectEntryList, new RObjectEntrySort());\n\n      // push the list into the UI and update category leaders\n      objectDataProvider_.getList().addAll(objectEntryList);\n      updateCategoryLeaders(false);\n\n      if (useStatePersistence())\n      {\n         setDeferredState();\n      }\n   }","id":28586,"modified_method":"public void addObjects(JsArray<RObject> objects)\n   {\n      // create an entry for each object and sort the array\n      int numObjects = objects.length();\n      ArrayList<RObjectEntry> objectEntryList = new ArrayList<RObjectEntry>();\n      for (int i = 0; i < numObjects; i++)\n      {\n         RObjectEntry entry = entryFromRObject(objects.get(i));\n         objectEntryList.add(entry);\n      }\n      Collections.sort(objectEntryList, objectSort_);\n\n      // push the list into the UI and update category leaders\n      objectDataProvider_.getList().addAll(objectEntryList);\n      updateCategoryLeaders(false);\n\n      if (useStatePersistence())\n      {\n         setDeferredState();\n      }\n   }","commit_id":"36102b83149d513c34b8691034896cb7fbd190ee","url":"https://github.com/rstudio/rstudio"},{"original_method":"public int compare(RObjectEntry first, RObjectEntry second)\n   {\n      int result = first.getCategory() - second.getCategory();\n      if (result == 0)\n      {\n         result = localeCompare(first.rObject.getName(), second.rObject.getName());\n      }\n      return result;\n   }","id":28587,"modified_method":"public int compare(RObjectEntry first, RObjectEntry second)\n   {\n      int result = 0;\n      if (sortType_ == SORT_AUTO)\n      {\n         result = first.getCategory() - second.getCategory();\n         if (result == 0)\n         {\n            result = localeCompare(first.rObject.getName(), \n                                   second.rObject.getName());\n         }\n      }\n      else if (sortType_ == SORT_COLUMN)\n      {\n         switch (sortColumn_)\n         {\n         case ObjectGridColumn.COLUMN_NAME:\n            result = localeCompare(first.rObject.getName(),\n                                   second.rObject.getName());\n            break;\n         case ObjectGridColumn.COLUMN_TYPE:\n            result = localeCompare(first.rObject.getType(),\n                                   second.rObject.getType());\n            break;\n         case ObjectGridColumn.COLUMN_LENGTH:\n            result = first.rObject.getLength() - second.rObject.getLength();\n            break;\n         case ObjectGridColumn.COLUMN_SIZE:\n            result = first.rObject.getSize() - second.rObject.getSize();\n            break;\n         case ObjectGridColumn.COLUMN_VALUE:\n            result = localeCompare(first.rObject.getValue(), \n                                   second.rObject.getValue());\n            break;\n         }\n      }\n      return result;\n   }","commit_id":"36102b83149d513c34b8691034896cb7fbd190ee","url":"https://github.com/rstudio/rstudio"},{"original_method":"private String getMembersInfo()\n   {\n      WebElement memberInfo = memberPanelBody.findElement(By.xpath(\".//p\"));\n      return memberInfo.getText();\n   }","id":28588,"modified_method":"private String getMembersInfo()\n   {\n      WebElement memberInfo = memberPanel.findElement(By.xpath(\".//p\"));\n      return memberInfo.getText();\n   }","commit_id":"fd78414d2a822bd712f228cdbc63c52db19c6355","url":"https://github.com/zanata/zanata-server"},{"original_method":"public List<TableRow> searchPerson(final String personName)\n   {\n      WebElement searchInput = waitForTenSec().until(new Function<WebDriver, WebElement>()\n      {\n         public WebElement apply(WebDriver driver)\n         {\n            return driver.findElement(By.id(\"personSearch:form:searchField\"));\n         }\n      });\n      searchInput.sendKeys(personName);\n      WebElement searchButton = getDriver().findElement(By.id(\"personSearch:form:searchBtn\"));\n      searchButton.click();\n\n      WebElement searchResultTable = waitForTenSec().until(new Function<WebDriver, WebElement>()\n      {\n         @Override\n         public WebElement apply(WebDriver driver)\n         {\n            WebElement table = driver.findElement(By.id(\"personSearch:searchResult:personTable\"));\n            List<TableRow> tableRows = WebElementUtil.getTableRows(table);\n            //we want to wait until search result comes back\n            if (tableRows.isEmpty() || !tableRows.get(0).getCellContents().get(0).contains(personName))\n            {\n               log.debug(\"waiting for search result refresh...\");\n               return null;\n            }\n            return table;\n         }\n      });\n\n      return WebElementUtil.getTableRows(searchResultTable);\n   }","id":28589,"modified_method":"public List<TableRow> searchPerson(final String personName)\n   {\n      final WebElement addUserPanel = getDriver().findElement(By.id(\"userAddPanel_container\"));\n\n      WebElement searchInput = waitForTenSec().until(new Function<WebDriver, WebElement>()\n      {\n         public WebElement apply(WebDriver driver)\n         {\n            return addUserPanel.findElement(By.id(\"searchForm:searchField\"));\n         }\n      });\n      searchInput.sendKeys(personName);\n      WebElement searchButton = getDriver().findElement(By.id(\"searchForm:searchBtn\"));\n      searchButton.click();\n\n      WebElement searchResultTable = waitForTenSec().until(new Function<WebDriver, WebElement>()\n      {\n         @Override\n         public WebElement apply(WebDriver driver)\n         {\n            WebElement table = driver.findElement(By.id(\"resultForm:personTable\"));\n            List<TableRow> tableRows = WebElementUtil.getTableRows(table);\n            //we want to wait until search result comes back\n            if (tableRows.isEmpty() || !tableRows.get(0).getCellContents().get(0).contains(personName))\n            {\n               log.debug(\"waiting for search result refresh...\");\n               return null;\n            }\n            return table;\n         }\n      });\n\n      return WebElementUtil.getTableRows(searchResultTable);\n   }","commit_id":"fd78414d2a822bd712f228cdbc63c52db19c6355","url":"https://github.com/zanata/zanata-server"},{"original_method":"public ManageLanguageTeamMemberPage addToTeam(TableRow personRow)\n   {\n      List<WebElement> cells = personRow.getCells();\n      WebElement lastColumn = cells.get(cells.size() - 1);\n      if (!lastColumn.getText().contains(\"Already in Team\"))\n      {\n         WebElement addButton = lastColumn.findElement(By.xpath(\".//input[@value='Add']\"));\n         addButton.click();\n         WebElement closeButton = getDriver().findElement(By.id(\"personSearch:form:closeBtn\"));\n         closeButton.click();\n         return new ManageLanguageTeamMemberPage(getDriver());\n      }\n      return this;\n   }","id":28590,"modified_method":"public ManageLanguageTeamMemberPage addToTeam(TableRow personRow)\n   {\n      List<WebElement> cells = personRow.getCells();\n      final String personUsername = personRow.getCellContents().get(0);\n      log.info(\"username to be added: {}\", personUsername);\n      WebElement lastColumn = cells.get(cells.size() - 1);\n      if (!lastColumn.getText().contains(\"Already in Team\"))\n      {\n         WebElement addButton = lastColumn.findElement(By.xpath(\".//input[@value='Add']\"));\n         addButton.click();\n         WebElement closeButton = getDriver().findElement(By.id(\"searchForm:closeBtn\"));\n         closeButton.click();\n         // we need to wait for the page to refresh\n         waitForSeconds(getDriver(), 5).until(new Predicate<WebDriver>()\n         {\n            @Override\n            public boolean apply(WebDriver driver)\n            {\n               WebElement languageTable = driver.findElement(By.id(\"memberPanel:threads\"));\n               List<TableRow> languageMembersTable = WebElementUtil.getTableRows(languageTable);\n               List<String> usernameColumn = WebElementUtil.getColumnContents(languageMembersTable, USERNAME_COLUMN);\n               log.info(\"username column: {}\", usernameColumn);\n               return usernameColumn.contains(personUsername);\n            }\n         });\n         return new ManageLanguageTeamMemberPage(getDriver());\n      }\n      return this;\n   }","commit_id":"fd78414d2a822bd712f228cdbc63c52db19c6355","url":"https://github.com/zanata/zanata-server"},{"original_method":"public List<String> getMemberUsernames()\n   {\n      if (getMembersInfo().contains(\"0 members\"))\n      {\n         log.info(\"no members yet for this language\");\n         return Collections.emptyList();\n      }\n      List<TableRow> languageMembersTable = WebElementUtil.getTableRows(memberPanelBody.findElement(By.xpath(\".//table\")));\n      return WebElementUtil.getColumnContents(languageMembersTable, USERNAME_COLUMN);\n   }","id":28591,"modified_method":"public List<String> getMemberUsernames()\n   {\n      if (getMembersInfo().contains(\"0 members\"))\n      {\n         log.info(\"no members yet for this language\");\n         return Collections.emptyList();\n      }\n      WebElement languageTable = getDriver().findElement(By.id(\"memberPanel:threads\"));\n      List<TableRow> languageMembersTable = WebElementUtil.getTableRows(languageTable);\n      List<String> usernameColumn = WebElementUtil.getColumnContents(languageMembersTable, USERNAME_COLUMN);\n      log.info(\"username column: {}\", usernameColumn);\n      return usernameColumn;\n   }","commit_id":"fd78414d2a822bd712f228cdbc63c52db19c6355","url":"https://github.com/zanata/zanata-server"},{"original_method":"public ProjectVersionPage goToVersion(final String versionId)\n   {\n      List<WebElement> versionLinks = getDriver().findElements(By.className(\"version_link\"));\n      log.info(\"found {} active versions\", versionLinks.size());\n\n      Preconditions.checkState(!versionLinks.isEmpty(), \"no version links available\");\n      Optional<WebElement> found = Iterables.tryFind(versionLinks, new Predicate<WebElement>()\n      {\n         @Override\n         public boolean apply(WebElement input)\n         {\n            return input.getText().contains(versionId);\n         }\n      });\n      Preconditions.checkState(found.isPresent(), versionId + \" not found\");\n      found.get().click();\n      return new ProjectVersionPage(getDriver());\n   }","id":28592,"modified_method":"public ProjectVersionPage goToVersion(final String versionId)\n   {\n      WebElement versionTable = getDriver().findElement(By.id(\"main_content:iterationsForm:iterations\"));\n      List<WebElement> versionLinks = versionTable.findElements(By.className(\"version_link\"));\n      log.info(\"found {} active versions\", versionLinks.size());\n\n      Preconditions.checkState(!versionLinks.isEmpty(), \"no version links available\");\n      Optional<WebElement> found = Iterables.tryFind(versionLinks, new Predicate<WebElement>()\n      {\n         @Override\n         public boolean apply(WebElement input)\n         {\n            return input.getText().contains(versionId);\n         }\n      });\n      Preconditions.checkState(found.isPresent(), versionId + \" not found\");\n      String href = found.get().getAttribute(\"href\");\n      getDriver().get(href);\n      return new ProjectVersionPage(getDriver());\n   }","commit_id":"fd78414d2a822bd712f228cdbc63c52db19c6355","url":"https://github.com/zanata/zanata-server"},{"original_method":"@SuppressWarnings(\"unused\")\n   public List<String> getTranslatableLocales()\n   {\n      List<String> rows = Lists.transform(localeTableRows, new Function<WebElement, String>()\n      {\n         @Override\n         public String apply(WebElement tr)\n         {\n            log.debug(\"table row: {}\", tr.getText());\n            List<WebElement> links = tr.findElements(By.tagName(\"a\"));\n            return getLocaleLinkText(links.get(0));\n         }\n      });\n\n      return ImmutableList.copyOf(rows);\n   }","id":28593,"modified_method":"@SuppressWarnings(\"unused\")\n   public List<String> getTranslatableLocales()\n   {\n      List<WebElement> tableRows = getLocaleTableRows();\n      List<String> rows = Lists.transform(tableRows, new Function<WebElement, String>()\n      {\n         @Override\n         public String apply(WebElement tr)\n         {\n            log.debug(\"table row: {}\", tr.getText());\n            List<WebElement> links = tr.findElements(By.tagName(\"a\"));\n            return getLocaleLinkText(links.get(0));\n         }\n      });\n\n      return ImmutableList.copyOf(rows);\n   }","commit_id":"fd78414d2a822bd712f228cdbc63c52db19c6355","url":"https://github.com/zanata/zanata-server"},{"original_method":"@SuppressWarnings(\"unused\")\n   public List<String> getTranslatableLanguages()\n   {\n      List<String> rows = Lists.transform(localeTableRows, new Function<WebElement, String>()\n      {\n         @Override\n         public String apply(WebElement tr)\n         {\n            log.debug(\"table row: {}\", tr.getText());\n            WebElement nativeName = tr.findElement(By.className(\"nativeName\"));\n            return nativeName.getText();\n         }\n      });\n\n      return ImmutableList.copyOf(rows);\n   }","id":28594,"modified_method":"@SuppressWarnings(\"unused\")\n   public List<String> getTranslatableLanguages()\n   {\n      List<WebElement> tableRows = getLocaleTableRows();\n      List<String> rows = Lists.transform(tableRows, new Function<WebElement, String>()\n      {\n         @Override\n         public String apply(WebElement tr)\n         {\n            log.debug(\"table row: {}\", tr.getText());\n            WebElement nativeName = tr.findElement(By.className(\"nativeName\"));\n            return nativeName.getText();\n         }\n      });\n\n      return ImmutableList.copyOf(rows);\n   }","commit_id":"fd78414d2a822bd712f228cdbc63c52db19c6355","url":"https://github.com/zanata/zanata-server"},{"original_method":"public DocumentsViewPage translate(String locale)\n   {\n\n      for (WebElement tableRow : localeTableRows)\n      {\n         List<WebElement> links = tableRow.findElements(By.tagName(\"a\"));\n         Preconditions.checkState(links.size() == 2, \"each translatable locale row should have 2 links\");\n         WebElement localeCell = links.get(0);\n         if (getLocaleLinkText(localeCell).equals(locale))\n         {\n            localeCell.click();\n            return new DocumentsViewPage(getDriver());\n         }\n      }\n      throw new IllegalArgumentException(\"can not translate locale: \" + locale);\n   }","id":28595,"modified_method":"public DocumentsViewPage translate(String locale)\n   {\n      List<WebElement> localeTableRows = getLocaleTableRows();\n      for (WebElement tableRow : localeTableRows)\n      {\n         List<WebElement> links = tableRow.findElements(By.tagName(\"a\"));\n         WebElement localeCell = links.get(0);\n         if (getLocaleLinkText(localeCell).equals(locale))\n         {\n            localeCell.click();\n            return new DocumentsViewPage(getDriver());\n         }\n      }\n      throw new IllegalArgumentException(\"can not translate locale: \" + locale);\n   }","commit_id":"fd78414d2a822bd712f228cdbc63c52db19c6355","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void classDescriptionNeededForEntityName(NSNotification n) {\n            cat.debug(\"classDescriptionNeededForEntityName: \" + (String)n.object());\n            String name = (String)n.object();\n            EOEntity e = EOModelGroup.defaultGroup().entityNamed(name); //FIXME: This isn't the best way to get\n            cat.debug(\"Entity: \" + e);\n            ERXEntityClassDescription.registerDescriptionForEntity(e);\n        }","id":28596,"modified_method":"public void classDescriptionNeededForEntityName(NSNotification n) {\n            cat.debug(\"classDescriptionNeededForEntityName: \" + (String)n.object());\n            String name = (String)n.object();\n            EOEntity e = EOModelGroup.defaultGroup().entityNamed(name); //FIXME: This isn't the best way to get\n            ERXEntityClassDescription.registerDescriptionForEntity(e);\n        }","commit_id":"c4facbb71fc71f9f826ffe0debc0e6aa88093f88","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static void registerDescriptionForEntitiesInModel(EOModel model) {\n        if (!_registeredModelNames.containsObject(model.name())) {\n            for (Enumeration e = model.entities().objectEnumerator(); e.hasMoreElements();) {\n                EOEntity eoentity = (EOEntity)e.nextElement();\n                if(cat.isDebugEnabled())\n                    cat.debug(\"Adding entity \" +eoentity.name()+ \" with class \" + eoentity.className());\n                NSMutableArray array = (NSMutableArray)_entitiesForClass.objectForKey(eoentity.className());\n                if(array == null) {\n                    array = new NSMutableArray();\n                }\n                array.addObject(eoentity);\n                _entitiesForClass.setObjectForKey(array, eoentity.className());\n            }\n            _registeredModelNames.addObject(model.name());\n        }\n        // Don't want this guy getting in our way later on ;)\n        NSNotificationCenter.defaultCenter().removeObserver(model);\n    }","id":28597,"modified_method":"public static void registerDescriptionForEntitiesInModel(EOModel model) {\n        if (!_registeredModelNames.containsObject(model.name())) {\n            for (Enumeration e = model.entities().objectEnumerator(); e.hasMoreElements();) {\n                EOEntity eoentity = (EOEntity)e.nextElement();\n                String className = eoentity.className();\n                if(className.equals(\"EOGenericRecord\")) {\n                    className = ERXGenericRecord.class.getName();\n                    eoentity.setClassName(className);\n                    cat.debug(eoentity.name() + \": setting class from EOGenericRecord to \" + className);\n                }\n                if(cat.isDebugEnabled())\n                    cat.debug(\"Adding entity \" +eoentity.name()+ \" with class \" + eoentity.className());\n                \n                NSMutableArray array = (NSMutableArray)_entitiesForClass.objectForKey(className);\n                if(array == null) {\n                    array = new NSMutableArray();\n                }\n                array.addObject(eoentity);\n                _entitiesForClass.setObjectForKey(array, eoentity.className());\n                //HACK ALERT: (ak) We work around classDescriptionForNewInstances() of EOEntity being broken here...\n                registerDescriptionForEntity(eoentity);\n            }\n            _registeredModelNames.addObject(model.name());\n        }\n        // Don't want this guy getting in our way later on ;)\n        NSNotificationCenter.defaultCenter().removeObserver(model);\n    }","commit_id":"c4facbb71fc71f9f826ffe0debc0e6aa88093f88","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static void registerDescriptionForClass(Class class1) {\n        NSArray entities = (NSArray)_entitiesForClass.objectForKey(class1.getName());\n        if (entities != null) {\n            if (cat.isDebugEnabled())\n                cat.debug(\"Registering descriptions for class: \" + class1.getName() + \" found entities: \" + entities.valueForKey(\"name\"));\n            for (Enumeration e = entities.objectEnumerator(); e.hasMoreElements();) {\n                EOClassDescription.registerClassDescription(new ERXEntityClassDescription((EOEntity)e.nextElement()), class1);\n            }\n        } else {\n            cat.error(\"Unable to register descriptions for class: \" + class1.getName());\n        }\n    }","id":28598,"modified_method":"public static void registerDescriptionForClass(Class class1) {\n        NSArray entities = (NSArray)_entitiesForClass.objectForKey(class1.getName());\n        if (entities != null) {\n            if (cat.isDebugEnabled())\n                cat.debug(\"Registering descriptions for class: \" + class1.getName() + \" found entities: \" + entities.valueForKey(\"name\"));\n            for (Enumeration e = entities.objectEnumerator(); e.hasMoreElements();) {\n                EOEntity entity = (EOEntity)e.nextElement();\n                ERXEntityClassDescription cd = new ERXEntityClassDescription(entity);\n                EOClassDescription.registerClassDescription(cd, class1);\n                _setClassDescriptionOnEntity(entity, cd);\n            }\n        } else {\n            cat.error(\"Unable to register descriptions for class: \" + class1.getName());\n        }\n    }","commit_id":"c4facbb71fc71f9f826ffe0debc0e6aa88093f88","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static void registerDescriptionForEntity(EOEntity entity) {\n        try {\n            Class entityClass = entity.className().equals(\"EOGenericRecord\") ? EOGenericRecord.class : Class.forName(entity.className());\n            if (cat.isDebugEnabled())\n                cat.debug(\"Registering description for entity: \" + entity.name() + \" with class: \" + entity.className());\n            EOClassDescription.registerClassDescription(new ERXEntityClassDescription(entity), entityClass);\n        } catch (java.lang.ClassNotFoundException ex) {\n            cat.error(\"Invalid class name for entity: \" + entity + \" exception: \" + ex);\n        }\n    }","id":28599,"modified_method":"public static void registerDescriptionForEntity(EOEntity entity) {\n        try {\n            Class entityClass = entity.className().equals(\"EOGenericRecord\") ? EOGenericRecord.class : Class.forName(entity.className());\n            if (cat.isDebugEnabled())\n                cat.debug(\"Registering description for entity: \" + entity.name() + \" with class: \" + entity.className());\n            ERXEntityClassDescription cd = new ERXEntityClassDescription(entity);\n            EOClassDescription.registerClassDescription(cd, entityClass);\n            _setClassDescriptionOnEntity(entity, cd);\n        } catch (java.lang.ClassNotFoundException ex) {\n            cat.error(\"Invalid class name for entity: \" + entity.name() + \" exception: \" + ex);\n        }\n    }","commit_id":"c4facbb71fc71f9f826ffe0debc0e6aa88093f88","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static void validationFailedWithException(Throwable e,\n                                                     Object value,\n                                                     String keyPath,\n                                                     NSMutableDictionary errorMessages,\n                                                     String displayPropertyKeyPath,\n                                                     EOEntity entity,\n                                                     boolean pushChanges) {\n        if (cat.isDebugEnabled())\n            cat.debug(\"ValidationFailedWithException: \" + e.getClass().getName() + \" message: \" + e.getMessage());\n        boolean addKeyToErrorMessage=false;\n        String key = null;\n        String newErrorMessage=e.getMessage();\n        // Need to reset the context for each validation exception.\n        propertyNameContext.setEntity(null);\n        if (e instanceof NSValidation.ValidationException && ((NSValidation.ValidationException)e).key() != null\n            && ((NSValidation.ValidationException)e).object() != null) {\n            NSValidation.ValidationException nve = (NSValidation.ValidationException)e;\n            key = nve.key();\n            Object eo=nve.object();\n            // this because exceptions raised by formatters have the failing VALUE in this key..\n            // strip the exception name\n            newErrorMessage=newErrorMessage.substring(newErrorMessage.indexOf(\":\")+1);\n            newErrorMessage=newErrorMessage.substring(newErrorMessage.indexOf(\":\")+1);\n            if (eo instanceof EOEnterpriseObject) {\n                // the exception is coming from EREnterpriseObject\n                // WE PUSH THE WRONG VALUE INTO THE EO ANYWAY!\n                if (pushChanges)  {\n                    ((EOEnterpriseObject)eo).takeValueForKeyPath(value, key);\n                }\n                // Setting the entity on the context\n                propertyNameContext.setEntity(EOUtilities.entityForObject(((EOEnterpriseObject)eo).editingContext(),\n                                                                          (EOEnterpriseObject)eo));\n            } else {\n                //the exception is coming from a formatter\n                key=(String)NSArray.componentsSeparatedByString(displayPropertyKeyPath,\".\").lastObject();\n                newErrorMessage=\"<b>\"+key+\"<\/b>:\"+newErrorMessage;\n                if (entity!=null)\n                    propertyNameContext.setEntity(entity);\n            }\n        } else {\n            key = keyPath;\n            if (entity!=null)\n                propertyNameContext.setEntity(entity);\n        }\n        // Leveraging the power of D2WContext to generate great looking error messages.\n        cat.debug(propertyNameContext.entity() );\n        if (propertyNameContext.entity() != null && key != null) {\n            propertyNameContext.setPropertyKey(key);\n            errorMessages.setObjectForKey(newErrorMessage, propertyNameContext.displayNameForProperty());\n        } else {\n            errorMessages.setObjectForKey(newErrorMessage, key);\n        }\n    }","id":28600,"modified_method":"public static void validationFailedWithException(Throwable e,\n                                                     Object value,\n                                                     String keyPath,\n                                                     NSMutableDictionary errorMessages,\n                                                     String displayPropertyKeyPath,\n                                                     EOEntity entity,\n                                                     boolean pushChanges) {\n        if (cat.isDebugEnabled())\n            cat.debug(\"ValidationFailedWithException: \" + e.getClass().getName() + \" message: \" + e.getMessage());\n        boolean addKeyToErrorMessage=false;\n        String key = null;\n        String newErrorMessage=e.getMessage();\n        // Need to reset the context for each validation exception.\n        propertyNameContext.setEntity(null);\n        if (e instanceof NSValidation.ValidationException && ((NSValidation.ValidationException)e).key() != null\n            && ((NSValidation.ValidationException)e).object() != null) {\n            NSValidation.ValidationException nve = (NSValidation.ValidationException)e;\n            key = nve.key();\n            Object eo=nve.object();\n            // this because exceptions raised by formatters have the failing VALUE in this key..\n            // strip the exception name\n            newErrorMessage=newErrorMessage.substring(newErrorMessage.indexOf(\":\")+1);\n            newErrorMessage=newErrorMessage.substring(newErrorMessage.indexOf(\":\")+1);\n            if (eo instanceof EOEnterpriseObject) {\n                // the exception is coming from EREnterpriseObject\n                // WE PUSH THE WRONG VALUE INTO THE EO ANYWAY!\n                if (pushChanges)  {\n                    ((EOEnterpriseObject)eo).takeValueForKeyPath(value, key);\n                }\n                // Setting the entity on the context\n                propertyNameContext.setEntity(EOUtilities.entityForObject(((EOEnterpriseObject)eo).editingContext(),\n                                                                          (EOEnterpriseObject)eo));\n            } else {\n                //the exception is coming from a formatter\n                key=(String)NSArray.componentsSeparatedByString(displayPropertyKeyPath,\".\").lastObject();\n                newErrorMessage=\"<b>\"+key+\"<\/b>:\"+newErrorMessage;\n                if (entity!=null)\n                    propertyNameContext.setEntity(entity);\n            }\n        } else {\n            key = keyPath;\n            if (entity!=null)\n                propertyNameContext.setEntity(entity);\n        }\n        // Leveraging the power of D2WContext to generate great looking error messages.\n        if (propertyNameContext.entity() != null && key != null) {\n            propertyNameContext.setPropertyKey(key);\n            errorMessages.setObjectForKey(newErrorMessage, propertyNameContext.displayNameForProperty());\n        } else {\n            errorMessages.setObjectForKey(newErrorMessage, key);\n        }\n    }","commit_id":"c4facbb71fc71f9f826ffe0debc0e6aa88093f88","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Object objectForKey( String aKey ) { return _userInfo().objectForKey( aKey ); }","id":28601,"modified_method":"public Object objectForKey( String aKey ) {\n        Object obj = _userInfo().objectForKey( aKey );\n        if(obj == null && _context != null && _context != this)\n            obj = _context.valueForKey(aKey);\n        return obj;\n    }","commit_id":"c4facbb71fc71f9f826ffe0debc0e6aa88093f88","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String getMessage() {\n        if (_message == null) {\n            _message = ERXValidationFactory.defaultFactory().messageForException(this);\n        }\n        return _message;\n    }","id":28602,"modified_method":"public String getMessage() {\n        return ERXValidationFactory.defaultFactory().messageForException(this);\n    }","commit_id":"c4facbb71fc71f9f826ffe0debc0e6aa88093f88","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String templateForException(ERXValidationException erv) {\n        String template = null;\n        if (erv.delegate() != null && erv.delegate() instanceof ExceptionDelegateInterface) {\n            template = ((ExceptionDelegateInterface)erv.delegate()).templateForException(erv);\n        }\n        if (template == null) {\n            String entityName = erv.eoObject().entityName();\n            String property = erv.isCustomMethodException() ? erv.method() : erv.propertyKey();\n            String type = erv.type();\n            String targetLanguage = erv.targetLanguage() != null ? erv.targetLanguage() : defaultTargetLanguage();\n            ERXMultiKey k = new ERXMultiKey(new NSArray(new Object[] {entityName, property, type, targetLanguage}));\n            template = (String)_cache.get(k);\n            // Not in the cache.  Simple resolving.\n            if (template == null) {\n                template = templateForEntityPropertyType(entityName, property, type, targetLanguage);\n                _cache.put(k, template);\n            }\n        }\n        return template;\n    }","id":28603,"modified_method":"public String templateForException(ERXValidationException erv) {\n        String template = null;\n        if (erv.delegate() != null && erv.delegate() instanceof ExceptionDelegateInterface) {\n            template = ((ExceptionDelegateInterface)erv.delegate()).templateForException(erv);\n        }\n        if (template == null) {\n            String entityName = erv.eoObject().entityName();\n            String property = erv.isCustomMethodException() ? erv.method() : erv.propertyKey();\n            String type = erv.type();\n            String targetLanguage = erv.targetLanguage() != null ? erv.targetLanguage() : defaultTargetLanguage();\n            cat.debug(\"templateForException with entityName: \" + entityName + \"; property: \" + property + \"; type: \" + type + \"; targetLanguage: \" + targetLanguage);\n            ERXMultiKey k = new ERXMultiKey(new NSArray(new Object[] {entityName, property, type, targetLanguage}));\n            template = (String)_cache.get(k);\n            // Not in the cache.  Simple resolving.\n            if (template == null) {\n                template = templateForEntityPropertyType(entityName, property, type, targetLanguage);\n                _cache.put(k, template);\n            }\n        }\n        return template;\n    }","commit_id":"c4facbb71fc71f9f826ffe0debc0e6aa88093f88","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXValidationException convertException(NSValidation.ValidationException eov, Object value) {\n        ERXValidationException erve = null;\n        if (cat.isDebugEnabled())\n            cat.debug(\"Converting exception: \" + eov + \" value: \" + (value != null ? value : \"<NULL>\"));\n        if (!(eov instanceof ERXValidationException)) {\n            String message = eov.getMessage();\n            NSDictionary userInfo = eov.userInfo() != null ? (NSDictionary)eov.userInfo() : ERXConstant.EmptyDictionary;\n            for (Enumeration e = _mappings.allKeys().objectEnumerator(); e.hasMoreElements();) {\n                EOEnterpriseObject eo = (EOEnterpriseObject)userInfo.objectForKey(NSValidation.ValidationException.ValidatedObjectUserInfoKey);\n                String key = (String)e.nextElement();\n                if (message.lastIndexOf(key) >= 0) {\n                    String property = (String)userInfo.objectForKey(NSValidation.ValidationException.ValidatedObjectUserInfoKey);\n                    erve = createException(eo, property, value, (String)_mappings.objectForKey(key));\n                    break;\n                }\n            }\n            NSArray additionalExceptions = (NSArray)userInfo.objectForKey(NSValidation.ValidationException.AdditionalExceptionsKey);\n            if (erve == null) {\n                cat.error(\"Unable to convert validation exception: \" + eov);\n            } else if (additionalExceptions != null && additionalExceptions.count() > 0) {\n                NSMutableArray erveAddtionalExceptions = new NSMutableArray();\n                for (Enumeration e = additionalExceptions.objectEnumerator(); e.hasMoreElements();) {\n                    ERXValidationException erven = convertException((NSValidation.ValidationException)e.nextElement());\n                    if (erven != null)\n                        erveAddtionalExceptions.addObject(erven);\n                }\n                if (erveAddtionalExceptions.count() > 0)\n                    erve.setObjectForKey(erveAddtionalExceptions, NSValidation.ValidationException.AdditionalExceptionsKey);\n            }\n        } else {\n            cat.warn(\"Attempting to convert validation exception: \" + eov + \" that is already of type ERXValidationException\");\n            erve = (ERXValidationException)eov;\n        }\n        return erve;\n    }","id":28604,"modified_method":"public ERXValidationException convertException(NSValidation.ValidationException eov, Object value) {\n        ERXValidationException erve = null;\n        if (cat.isDebugEnabled())\n            cat.debug(\"Converting exception: \" + eov + \" value: \" + (value != null ? value : \"<NULL>\"));\n        if (!(eov instanceof ERXValidationException)) {\n            String message = eov.getMessage();\n            NSDictionary userInfo = eov.userInfo() != null ? (NSDictionary)eov.userInfo() : ERXConstant.EmptyDictionary;\n            for (Enumeration e = _mappings.allKeys().objectEnumerator(); e.hasMoreElements();) {\n                EOEnterpriseObject eo = (EOEnterpriseObject)userInfo.objectForKey(NSValidation.ValidationException.ValidatedObjectUserInfoKey);\n                String key = (String)e.nextElement();\n                String type = (String)_mappings.objectForKey(key);\n                if (message.lastIndexOf(key) >= 0) {\n                    // String property = (String)userInfo.objectForKey(NSValidation.ValidationException.ValidatedKeyUserInfoKey);\n                    cat.debug(\"UserInfo:\" + userInfo);\n                    String property = eov.key();\n                    if(property == null && message.indexOf(\"Removal\") == 0) {\n                        //FIXME: (ak) pattern matching?\n                        property = (String)(NSArray.componentsSeparatedByString(message, \"'\").objectAtIndex(3));\n                    }\n                    erve = createException(eo, property, value, type);\n                    break;\n                }\n            }\n            NSArray additionalExceptions = (NSArray)userInfo.objectForKey(NSValidation.ValidationException.AdditionalExceptionsKey);\n            if (erve == null) {\n                cat.error(\"Unable to convert validation exception: \" + eov);\n            } else if (additionalExceptions != null && additionalExceptions.count() > 0) {\n                NSMutableArray erveAddtionalExceptions = new NSMutableArray();\n                for (Enumeration e = additionalExceptions.objectEnumerator(); e.hasMoreElements();) {\n                    ERXValidationException erven = convertException((NSValidation.ValidationException)e.nextElement());\n                    if (erven != null)\n                        erveAddtionalExceptions.addObject(erven);\n                }\n                if (erveAddtionalExceptions.count() > 0)\n                    erve.setObjectForKey(erveAddtionalExceptions, NSValidation.ValidationException.AdditionalExceptionsKey);\n            }\n        } else {\n            cat.warn(\"Attempting to convert validation exception: \" + eov + \" that is already of type ERXValidationException\");\n            erve = (ERXValidationException)eov;\n        }\n        return erve;\n    }","commit_id":"c4facbb71fc71f9f826ffe0debc0e6aa88093f88","url":"https://github.com/wocommunity/wonder"},{"original_method":"private void createColumns()\n   {\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(filterRenderer_), \"Name\", 20, \n              ObjectGridColumn.COLUMN_NAME, host_)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return object.rObject.getName();\n                  }\n              });\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(), \"Type\", 15, \n              ObjectGridColumn.COLUMN_TYPE, host_)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return object.rObject.getType();\n                  }\n              });\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(), \"Length\", 10, \n              ObjectGridColumn.COLUMN_LENGTH, host_)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return (new Integer(object.rObject.getLength())).toString();\n                  }\n              });\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(), \"Size\", 15, \n              ObjectGridColumn.COLUMN_SIZE, host_)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return StringUtil.formatFileSize(object.rObject.getSize());\n                  }\n              });\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(filterRenderer_), \"Value\", 35, \n              ObjectGridColumn.COLUMN_VALUE, host_)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return object.rObject.getValue();\n                  }\n              });\n      checkColumn_ = new Column<RObjectEntry, Boolean>(\n            new CheckboxCell(false, false))\n            {\n               @Override\n               public Boolean getValue(RObjectEntry value)\n               {\n                  return selection_.isSelected(value); \n               }\n            };\n      addColumn(checkColumn_);\n      for (Column<RObjectEntry, String> column: columns_)\n      {\n         addColumn(column);\n      }\n   }","id":28605,"modified_method":"private void createColumns()\n   {\n      checkColumn_ = new Column<RObjectEntry, Boolean>(\n            new CheckboxCell(false, false))\n            {\n               @Override\n               public Boolean getValue(RObjectEntry value)\n               {\n                  return selection_.isSelected(value); \n               }\n            };\n      addColumn(checkColumn_);\n      checkHeader_ = new Header<Boolean>(new CheckboxCell())\n      {\n         @Override\n         public Boolean getValue()\n         {\n            return selectAll_;\n         }\n      };\n      checkHeader_.setUpdater(new ValueUpdater<Boolean>()\n      {\n         @Override\n         public void update(Boolean value)\n         {\n            if (selectAll_ != value)\n            {\n               setSelectAll(value);\n               selectAll_ = value;\n            }\n         }\n      });\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(filterRenderer_), \"Name\", 20, \n              ObjectGridColumn.COLUMN_NAME, host_)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return object.rObject.getName();\n                  }\n              });\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(), \"Type\", 15, \n              ObjectGridColumn.COLUMN_TYPE, host_)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return object.rObject.getType();\n                  }\n              });\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(), \"Length\", 10, \n              ObjectGridColumn.COLUMN_LENGTH, host_)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return (new Integer(object.rObject.getLength())).toString();\n                  }\n              });\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(), \"Size\", 15, \n              ObjectGridColumn.COLUMN_SIZE, host_)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return StringUtil.formatFileSize(object.rObject.getSize());\n                  }\n              });\n      columns_.add(new ObjectGridColumn(\n              new ClickableTextCell(filterRenderer_), \"Value\", 35, \n              ObjectGridColumn.COLUMN_VALUE, host_)\n              {\n                  @Override\n                  public String getValue(RObjectEntry object)\n                  {\n                     return object.rObject.getValue();\n                  }\n              });\n      for (Column<RObjectEntry, String> column: columns_)\n      {\n         addColumn(column);\n      }\n   }","commit_id":"749bed41eade2082697c4305fee60c00ae033742","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public List<String> getSelectedObjects()\n   {\n      // In list view, everything visible is selected\n      ArrayList<String> objectNames = new ArrayList<String>();\n      List<RObjectEntry> objects = getVisibleItems();\n      for (RObjectEntry object: objects)\n      {\n         if (object.visible && selection_.isSelected(object))\n         {\n            objectNames.add(object.rObject.getName());\n         }\n      }\n      return objectNames;\n   }","id":28606,"modified_method":"@Override\n   public List<String> getSelectedObjects()\n   {\n      boolean hasFilter = !host_.getFilterText().isEmpty();\n      ArrayList<String> selectedObjectNames = new ArrayList<String>();\n      ArrayList<String> filteredObjectNames = new ArrayList<String>();\n      List<RObjectEntry> objects = getVisibleItems();\n      for (RObjectEntry object: objects)\n      {\n         if (object.visible)\n         {\n            if (hasFilter)\n            {\n               filteredObjectNames.add(object.rObject.getName());\n            }\n            if (selection_.isSelected(object))\n            {\n               selectedObjectNames.add(object.rObject.getName());\n            }\n         }\n      }\n      return selectedObjectNames.size() == 0 ? filteredObjectNames :\n                                               selectedObjectNames;\n   }","commit_id":"749bed41eade2082697c4305fee60c00ae033742","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n      protected boolean buildHeaderOrFooterImpl()\n      {\n         TableRowBuilder row = startRow();\n         // Render an empty header cell for the check column\n         row.startTH().className(style_.objectGridHeader()).end();\n\n         for (int i = 0; i < columns_.size(); i++)\n         {\n            ObjectGridColumn col = columns_.get(i);\n            TableCellBuilder cell = row.startTH();\n            cell.className(style_.objectGridHeader());\n            cell.style().width(col.getWidth(), Unit.PCT);\n            Cell.Context context = new Cell.Context(0, i, null);\n            renderSortableHeader(cell, context, col.getHeader(), \n                  i == host_.getSortColumn(), \n                  host_.isAscendingSort());\n            cell.endTH();\n         }\n         row.end();\n         return true;\n      }","id":28607,"modified_method":"@Override\n      protected boolean buildHeaderOrFooterImpl()\n      {\n         TableRowBuilder row = startRow();\n         // Render an empty header cell for the check column\n         TableCellBuilder selectAll = row.startTH();\n         selectAll.className(style_.objectGridHeader() + \" \" +\n                             style_.checkColumn());\n         renderHeader(selectAll, new Cell.Context(0, 0, null), checkHeader_);\n         selectAll.end();\n\n         for (int i = 0; i < columns_.size(); i++)\n         {\n            ObjectGridColumn col = columns_.get(i);\n            TableCellBuilder cell = row.startTH();\n            cell.className(style_.objectGridHeader());\n            cell.style().width(col.getWidth(), Unit.PCT);\n            Cell.Context context = new Cell.Context(0, i, null);\n            renderSortableHeader(cell, context, col.getHeader(), \n                  i == host_.getSortColumn(), \n                  host_.isAscendingSort());\n            cell.endTH();\n         }\n         row.end();\n         return true;\n      }","commit_id":"749bed41eade2082697c4305fee60c00ae033742","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public List<String> getSelectedObjects()\n   {\n      // If the view is unfiltered, remove everything.\n      if (host_.getFilterText() == \"\")\n      {\n         return new ArrayList<String>();\n      }\n\n      // If the view is filtered, remove items that are visible.\n      ArrayList<String> objectNames = new ArrayList<String>();\n      List<RObjectEntry> objects = getVisibleItems();\n      for (RObjectEntry object: objects)\n      {\n         if (object.visible)\n         {\n            objectNames.add(object.rObject.getName());\n         }\n      }\n      return objectNames;\n   }","id":28608,"modified_method":"@Override\n   public List<String> getSelectedObjects()\n   {\n      // If the view is unfiltered, remove everything.\n      if (host_.getFilterText().isEmpty())\n      {\n         return new ArrayList<String>();\n      }\n\n      // If the view is filtered, remove items that are visible.\n      ArrayList<String> objectNames = new ArrayList<String>();\n      List<RObjectEntry> objects = getVisibleItems();\n      for (RObjectEntry object: objects)\n      {\n         if (object.visible)\n         {\n            objectNames.add(object.rObject.getName());\n         }\n      }\n      return objectNames;\n   }","commit_id":"749bed41eade2082697c4305fee60c00ae033742","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void moveResource(DocumentImpl doc, Collection destination, String newName)\n\tthrows PermissionDeniedException, LockException {\n\t    if (readOnly)\n\t\t\tthrow new PermissionDeniedException(DATABASE_IS_READ_ONLY);\n\t    Collection collection = doc.getCollection();\n\t    if(!collection.getPermissions().validate(user, Permission.WRITE))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to move resource \" +\n\t                doc.getFileName());\n\t    if(!doc.getPermissions().validate(user, Permission.WRITE))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to move resource \" +\n\t                doc.getFileName());\n\t    if(newName == null) {\n            int p = doc.getFileName().lastIndexOf('/');\n            newName = doc.getFileName().substring(p + 1);\n        }\n\t    Lock lock = null;\n\t    try {\n\t        lock = collectionsDb.getLock();\n\t        lock.acquire(Lock.WRITE_LOCK);\n\t        // check if the move would overwrite a collection\n\t        if(getCollection(destination.getName() + '/' + newName) != null)\n\t            throw new PermissionDeniedException(\"A resource can not replace an existing collection\");\n\t        DocumentImpl oldDoc = destination.getDocument(this, newName);\n\t        if(oldDoc != null) {\n\t        \tif(doc.getDocId() == oldDoc.getDocId())\n\t            \tthrow new PermissionDeniedException(\"Cannot move resource to itself\");\n\t            if(!destination.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            if(!oldDoc.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            if (oldDoc.getResourceType() == DocumentImpl.BINARY_FILE)\n\t            \tcollection.removeBinaryResource(this, oldDoc);\n\t            else\n\t            \tcollection.removeDocument(this, oldDoc.getFileName());\n\t        } else\n\t            if(!destination.getPermissions().validate(user, Permission.WRITE))\n\t    \t        throw new PermissionDeniedException(\"Insufficient privileges on target collection \" +\n\t    \t                destination.getName());\n\t        \n\t        boolean renameOnly = collection.getId() == destination.getId();\n\t        collection.unlinkDocument(doc);\n\t        doc.setFileName(newName);\n        \tdoc.setCollection(destination);\n\t        if (doc.getResourceType() == DocumentImpl.XML_FILE) {\n\t\t        if(!renameOnly) {\n\t\t\t        elementIndex.dropIndex(doc);\n\t\t\t\t\ttextEngine.dropIndex(doc);\n\t\t\t\t\tvalueIndex.dropIndex(doc);\n\t\t\t\t\tif ( qnameValueIndexation )\n\t\t\t\t\t\tqnameValueIndex.dropIndex(doc);\n\t\t\t\t\tsaveCollection(collection);\n\t\t        }\n\t\t        destination.addDocument(this, doc);\n\t\t        if(!renameOnly) {\n\t\t\t        // reindexing\n\t\t\t\t\treindex(doc);\n\t\t        }\n\t        } else {\n\t        \t// binary resource\n\t        \tdestination.addDocument(this, doc);\n\t        }\n\t\t\tsaveCollection(destination);\n        } catch (TriggerException e) {\n            throw new PermissionDeniedException(e.getMessage());\n        } catch (ReadOnlyException e) {\n            throw new PermissionDeniedException(e.getMessage());\n        } finally {\n\t        lock.release();\n\t    }\n\t}","id":28609,"modified_method":"public void moveResource(DocumentImpl doc, Collection destination, String newName)\n\tthrows PermissionDeniedException, LockException {\n\t    if (readOnly)\n\t\t\tthrow new PermissionDeniedException(DATABASE_IS_READ_ONLY);\n\t    Collection collection = doc.getCollection();\n\t    if(!collection.getPermissions().validate(user, Permission.WRITE))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to move resource \" +\n\t                doc.getFileName());\n\t    if(!doc.getPermissions().validate(user, Permission.WRITE))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to move resource \" +\n\t                doc.getFileName());\n\t    if(newName == null) {\n            int p = doc.getFileName().lastIndexOf('/');\n            newName = doc.getFileName().substring(p + 1);\n        }\n\t    Lock lock = null;\n\t    try {\n\t        lock = collectionsDb.getLock();\n\t        lock.acquire(Lock.WRITE_LOCK);\n\t        // check if the move would overwrite a collection\n\t        if(getCollection(destination.getName() + '/' + newName) != null)\n\t            throw new PermissionDeniedException(\"A resource can not replace an existing collection\");\n\t        DocumentImpl oldDoc = destination.getDocument(this, newName);\n\t        if(oldDoc != null) {\n\t        \tif(doc.getDocId() == oldDoc.getDocId())\n\t            \tthrow new PermissionDeniedException(\"Cannot move resource to itself\");\n\t            if(!destination.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            if(!oldDoc.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            if (oldDoc.getResourceType() == DocumentImpl.BINARY_FILE)\n\t            \tdestination.removeBinaryResource(this, oldDoc);\n\t            else\n\t            \tdestination.removeDocument(this, oldDoc.getFileName());\n\t        } else\n\t            if(!destination.getPermissions().validate(user, Permission.WRITE))\n\t    \t        throw new PermissionDeniedException(\"Insufficient privileges on target collection \" +\n\t    \t                destination.getName());\n\t        \n\t        boolean renameOnly = collection.getId() == destination.getId();\n\t        collection.unlinkDocument(doc);\n\t        doc.setFileName(newName);\n        \tdoc.setCollection(destination);\n\t        if (doc.getResourceType() == DocumentImpl.XML_FILE) {\n\t\t        if(!renameOnly) {\n\t\t\t        elementIndex.dropIndex(doc);\n\t\t\t\t\ttextEngine.dropIndex(doc);\n\t\t\t\t\tvalueIndex.dropIndex(doc);\n\t\t\t\t\tif ( qnameValueIndexation )\n\t\t\t\t\t\tqnameValueIndex.dropIndex(doc);\n\t\t\t\t\tsaveCollection(collection);\n\t\t        }\n\t\t        destination.addDocument(this, doc);\n\t\t        if(!renameOnly) {\n\t\t\t        // reindexing\n\t\t\t\t\treindex(doc);\n\t\t        }\n\t        } else {\n\t        \t// binary resource\n\t        \tdestination.addDocument(this, doc);\n\t        }\n\t\t\tsaveCollection(destination);\n        } catch (TriggerException e) {\n            throw new PermissionDeniedException(e.getMessage());\n        } catch (ReadOnlyException e) {\n            throw new PermissionDeniedException(e.getMessage());\n        } finally {\n\t        lock.release();\n\t    }\n\t}","commit_id":"4a6ade21c4483e3b5de3d70571e16cd0629a18d3","url":"https://github.com/eXist-db/exist"},{"original_method":"public void copyResource(DocumentImpl doc, Collection destination, String newName)\n\tthrows PermissionDeniedException, LockException {\n\t\tif (readOnly)\n\t\t\tthrow new PermissionDeniedException(DATABASE_IS_READ_ONLY);\n\t    Collection collection = doc.getCollection();\n\t    if(!collection.getPermissions().validate(user, Permission.READ))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to copy resource \" +\n\t                doc.getFileName());\n\t    if(!doc.getPermissions().validate(user, Permission.READ))\n\t    \tthrow new PermissionDeniedException(\"Insufficient privileges to copy resource \" +\n\t                doc.getFileName());\n\t    if(newName == null) {\n            int p = doc.getFileName().lastIndexOf('/');\n            newName = doc.getFileName().substring(p + 1);\n        }\n\n\t    Lock lock = null;\n\t    try {\n\t        lock = collectionsDb.getLock();\n\t        lock.acquire(Lock.WRITE_LOCK);\n\t        // check if the move would overwrite a collection\n\t        if(getCollection(destination.getName() + '/' + newName) != null)\n\t            throw new PermissionDeniedException(\"A resource can not replace an existing collection\");\n\t        DocumentImpl oldDoc = destination.getDocument(this, newName);\n\t        if(oldDoc != null) {\n\t        \tif(doc.getDocId() == oldDoc.getDocId())\n\t            \tthrow new PermissionDeniedException(\"Cannot copy resource to itself\");\n\t            if(!destination.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            if(!oldDoc.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            collection.removeDocument(this, oldDoc.getFileName());\n\t        } else {\n\t        \tif(!destination.getPermissions().validate(user, Permission.WRITE))\n\t    \t        throw new PermissionDeniedException(\"Insufficient privileges on target collection \" +\n\t    \t                destination.getName());\n\t        }\n\t        \n\t        DocumentImpl newDoc;\n\t        if (doc.getResourceType() == DocumentImpl.BINARY_FILE)  {\n\t        \tbyte[] data = getBinaryResourceData((BinaryDocument) doc);\n\t        \tBinaryDocument newBinary = \n        \t\t\tdestination.addBinaryResource(this, newName, data, doc.getMimeType());\n\t        } else {\n\t        \tnewDoc = new DocumentImpl(this, newName, destination);\n\t\t        newDoc.copyOf(doc);\n\t\t        newDoc.setDocId(getNextDocId(destination));\n\t\t        copyResource(doc, newDoc);\n\t\t        destination.addDocument(this, newDoc);\n\t\t        updateDocument(newDoc);\n\t        }\n//\t        saveCollection(destination);\n\t\t} catch (TriggerException e) {\n\t\t\tthrow new PermissionDeniedException(e.getMessage());\n\t\t} catch (EXistException e) {\n\t\t\tLOG.warn(\"An error occurred while copying resource\", e);\n\t\t} finally {\n\t    \tlock.release();\n\t    }\n\t}","id":28610,"modified_method":"public void copyResource(DocumentImpl doc, Collection destination, String newName)\n\tthrows PermissionDeniedException, LockException {\n\t\tif (readOnly)\n\t\t\tthrow new PermissionDeniedException(DATABASE_IS_READ_ONLY);\n\t    Collection collection = doc.getCollection();\n\t    if(!collection.getPermissions().validate(user, Permission.READ))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to copy resource \" +\n\t                doc.getFileName());\n\t    if(!doc.getPermissions().validate(user, Permission.READ))\n\t    \tthrow new PermissionDeniedException(\"Insufficient privileges to copy resource \" +\n\t                doc.getFileName());\n\t    if(newName == null) {\n            int p = doc.getFileName().lastIndexOf('/');\n            newName = doc.getFileName().substring(p + 1);\n        }\n\n\t    Lock lock = null;\n\t    try {\n\t        lock = collectionsDb.getLock();\n\t        lock.acquire(Lock.WRITE_LOCK);\n\t        // check if the move would overwrite a collection\n\t        if(getCollection(destination.getName() + '/' + newName) != null)\n\t            throw new PermissionDeniedException(\"A resource can not replace an existing collection\");\n\t        DocumentImpl oldDoc = destination.getDocument(this, newName);\n\t        if(oldDoc != null) {\n\t        \tif(doc.getDocId() == oldDoc.getDocId())\n\t            \tthrow new PermissionDeniedException(\"Cannot copy resource to itself\");\n\t            if(!destination.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            if(!oldDoc.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n                if (oldDoc.getResourceType() == DocumentImpl.BINARY_FILE)\n                    destination.removeBinaryResource(this, oldDoc);\n                else\n                    destination.removeDocument(this, oldDoc.getFileName());\n\t        } else {\n\t        \tif(!destination.getPermissions().validate(user, Permission.WRITE))\n\t    \t        throw new PermissionDeniedException(\"Insufficient privileges on target collection \" +\n\t    \t                destination.getName());\n\t        }\n\t        \n\t        DocumentImpl newDoc;\n\t        if (doc.getResourceType() == DocumentImpl.BINARY_FILE)  {\n\t        \tbyte[] data = getBinaryResourceData((BinaryDocument) doc);\n\t        \tBinaryDocument newBinary = \n        \t\t\tdestination.addBinaryResource(this, newName, data, doc.getMimeType());\n\t        } else {\n\t        \tnewDoc = new DocumentImpl(this, newName, destination);\n\t\t        newDoc.copyOf(doc);\n\t\t        newDoc.setDocId(getNextDocId(destination));\n\t\t        copyResource(doc, newDoc);\n\t\t        destination.addDocument(this, newDoc);\n\t\t        updateDocument(newDoc);\n\t        }\n//\t        saveCollection(destination);\n\t\t} catch (TriggerException e) {\n\t\t\tthrow new PermissionDeniedException(e.getMessage());\n\t\t} catch (EXistException e) {\n\t\t\tLOG.warn(\"An error occurred while copying resource\", e);\n\t\t} finally {\n\t    \tlock.release();\n\t    }\n\t}","commit_id":"4a6ade21c4483e3b5de3d70571e16cd0629a18d3","url":"https://github.com/eXist-db/exist"},{"original_method":"public void addCollection(Collection child) {\n        try {\n            collection.addCollection(child);\n    \t\tfinal int p = child.getName().lastIndexOf('/') + 1;\n    \t\tfinal String childName = child.getName().substring(p);\n            ClusterComunication.getInstance().addCollection(this.getName(),childName);\n        } catch (ClusterException e) {\n            e.printStackTrace();\n        }\n\n    }","id":28611,"modified_method":"public void addCollection(Collection child) {\n        try {\n            collection.addCollection(child);\n    \t\tfinal int p = child.getName().lastIndexOf('/') + 1;\n    \t\tfinal String childName = child.getName().substring(p);\n            System.out.println(\"________ ADDDING COLLECTION \" + child.getName() +\" TO \" + this.getName() );\n            ClusterComunication cluster = ClusterComunication.getInstance();\n            if(cluster!=null)\n                cluster.addCollection(this.getName(),childName);\n        } catch (ClusterException e) {\n            e.printStackTrace();\n        }\n\n    }","commit_id":"38b3490341b673d55986e635879448e9dc974cf0","url":"https://github.com/eXist-db/exist"},{"original_method":"public void removeDocument(Txn transaction, DBBroker broker, String docname) throws PermissionDeniedException, TriggerException, LockException {\n        collection.removeDocument(transaction, broker, docname);\n        try {\n            ClusterComunication.getInstance().removeDocument(this.getName(), docname);\n        } catch (ClusterException e) {\n            e.printStackTrace();\n        }\n    }","id":28612,"modified_method":"public void removeDocument(Txn transaction, DBBroker broker, String docname) throws PermissionDeniedException, TriggerException, LockException {\n        collection.removeDocument(transaction, broker, docname);\n        try {\n            ClusterComunication cluster = ClusterComunication.getInstance();\n            if(cluster!=null)\n                cluster.removeDocument(this.getName(), docname);\n        } catch (ClusterException e) {\n            e.printStackTrace();\n        }\n    }","commit_id":"38b3490341b673d55986e635879448e9dc974cf0","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * This method is used by the XML RPC client.\n     *\n     * @param broker\n     * @param info\n     * @param source\n     * @param privileged\n     * @throws EXistException\n     * @throws PermissionDeniedException\n     * @throws TriggerException\n     * @throws SAXException\n     * @throws LockException\n     */\n    public void store(Txn transaction, DBBroker broker, IndexInfo info, InputSource source, boolean privileged)\n            throws EXistException, PermissionDeniedException, TriggerException,\n            SAXException, LockException {\n        \n        Indexer indexer = info.getIndexer();\n        DocumentImpl document = indexer.getDocument();\n\n        collection.store(transaction, broker, info, source, privileged);\n\n\n        InputStream is = source.getByteStream();\n        Reader cs = source.getCharacterStream();\n        String uri = null;\n\n        String content = \"\";\n        try {\n            byte b[] = new byte[1];\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            if (is != null) {\n\n                is.reset();\n                while (is.read(b) != -1) {\n                    bos.write(b);\n                }\n            } else if(cs!=null) {\n\n                if (cs != null) {\n                    cs.reset();\n                    int c;\n                    while ((c = cs.read()) != -1) {\n                        bos.write(c);\n                    }\n                }\n            }else {\n                uri = source.getSystemId();\n                URL url = new URL(uri);\n                BufferedReader br = new BufferedReader(new InputStreamReader(url.openConnection().getInputStream()));\n                StringBuffer buffer = new StringBuffer();\n                String line = null;\n                while((line=br.readLine())!=null){\n                    buffer.append(line).append(System.getProperty(\"line.separator\"));\n                }\n                content = buffer.toString();\n            }\n\n\n            bos.flush();\n            bos.close();\n            if(uri==null){\n                content = bos.toString();\n            }\n        } catch (IOException e) {\n             e.printStackTrace();\n        }\n\n        try {\n            ClusterComunication.getInstance().storeDocument(this.getName(), document.getName().substring(this.getName().length() + 1), content);\n        } catch (ClusterException e) {\n            e.printStackTrace();\n        }\n\n\n    }","id":28613,"modified_method":"/**\n     * This method is used by the XML RPC client.\n     *\n     * @param broker\n     * @param info\n     * @param source\n     * @param privileged\n     * @throws EXistException\n     * @throws PermissionDeniedException\n     * @throws TriggerException\n     * @throws SAXException\n     * @throws LockException\n     */\n    public void store(Txn transaction, DBBroker broker, IndexInfo info, InputSource source, boolean privileged)\n            throws EXistException, PermissionDeniedException, TriggerException,\n            SAXException, LockException {\n        \n        Indexer indexer = info.getIndexer();\n        DocumentImpl document = indexer.getDocument();\n\n        collection.store(transaction, broker, info, source, privileged);\n\n\n        InputStream is = source.getByteStream();\n        Reader cs = source.getCharacterStream();\n        String uri = null;\n\n        String content = \"\";\n        try {\n            byte b[] = new byte[1];\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            if (is != null) {\n\n                is.reset();\n                while (is.read(b) != -1) {\n                    bos.write(b);\n                }\n            } else if(cs!=null) {\n\n                if (cs != null) {\n                    cs.reset();\n                    int c;\n                    while ((c = cs.read()) != -1) {\n                        bos.write(c);\n                    }\n                }\n            }else {\n                uri = source.getSystemId();\n                URL url = new URL(uri);\n                BufferedReader br = new BufferedReader(new InputStreamReader(url.openConnection().getInputStream()));\n                StringBuffer buffer = new StringBuffer();\n                String line = null;\n                while((line=br.readLine())!=null){\n                    buffer.append(line).append(System.getProperty(\"line.separator\"));\n                }\n                content = buffer.toString();\n            }\n\n\n            bos.flush();\n            bos.close();\n            if(uri==null){\n                content = bos.toString();\n            }\n        } catch (IOException e) {\n             e.printStackTrace();\n        }\n\n        try {\n            ClusterComunication cluster = ClusterComunication.getInstance();\n            if(cluster!=null)\n                cluster.storeDocument(this.getName(), document.getName().substring(this.getName().length() + 1), content);\n        } catch (ClusterException e) {\n            e.printStackTrace();\n        }\n\n\n    }","commit_id":"38b3490341b673d55986e635879448e9dc974cf0","url":"https://github.com/eXist-db/exist"},{"original_method":"public void moveResource(DocumentImpl doc, Collection destination, String newName)\n\tthrows PermissionDeniedException, LockException {\n\t    if (readOnly)\n\t\t\tthrow new PermissionDeniedException(DATABASE_IS_READ_ONLY);\n\t    Collection collection = doc.getCollection();\n\t    if(!collection.getPermissions().validate(user, Permission.WRITE))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to move resource \" +\n\t                doc.getFileName());\n\t    if(!doc.getPermissions().validate(user, Permission.WRITE))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to move resource \" +\n\t                doc.getFileName());\n\t    if(newName == null) {\n            int p = doc.getFileName().lastIndexOf('/');\n            newName = doc.getFileName().substring(p + 1);\n        }\n\t    Lock lock = null;\n\t    try {\n\t        lock = collectionsDb.getLock();\n\t        lock.acquire(Lock.WRITE_LOCK);\n\t        // check if the move would overwrite a collection\n\t        if(getCollection(destination.getName() + '/' + newName) != null)\n\t            throw new PermissionDeniedException(\"A resource can not replace an existing collection\");\n\t        DocumentImpl oldDoc = destination.getDocument(this, newName);\n\t        if(oldDoc != null) {\n\t        \tif(doc.getDocId() == oldDoc.getDocId())\n\t            \tthrow new PermissionDeniedException(\"Cannot move resource to itself\");\n\t            if(!destination.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            if(!oldDoc.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            collection.removeDocument(this, oldDoc.getFileName());\n\t        } else\n\t            if(!destination.getPermissions().validate(user, Permission.WRITE))\n\t    \t        throw new PermissionDeniedException(\"Insufficient privileges on target collection \" +\n\t    \t                destination.getName());\n\t            \n\t        boolean renameOnly = collection.getId() == destination.getId();\n\t        collection.unlinkDocument(doc);\n\t        if(!renameOnly) {\n\t\t        elementIndex.dropIndex(doc);\n\t\t\t\ttextEngine.dropIndex(doc);\n\t\t\t\tvalueIndex.dropIndex(doc);\n\t\t\t\tif ( qnameValueIndexation )\n\t\t\t\t\tqnameValueIndex.dropIndex(doc);\n\t\t\t\tsaveCollection(collection);\n\t        }\n\t\t\tdoc.setFileName(newName);\n\t\t\tdestination.addDocument(this, doc);\n\t        doc.setCollection(destination);\n\n\t        if(!renameOnly) {\n\t\t        // reindexing\n\t\t\t\treindex(doc);\n\t        }\n\t\t\tsaveCollection(destination);\n        } catch (TriggerException e) {\n            throw new PermissionDeniedException(e.getMessage());\n        } catch (ReadOnlyException e) {\n            throw new PermissionDeniedException(e.getMessage());\n        } finally {\n\t        lock.release();\n\t    }\n\t}","id":28614,"modified_method":"public void moveResource(DocumentImpl doc, Collection destination, String newName)\n\tthrows PermissionDeniedException, LockException {\n\t    if (readOnly)\n\t\t\tthrow new PermissionDeniedException(DATABASE_IS_READ_ONLY);\n\t    Collection collection = doc.getCollection();\n\t    if(!collection.getPermissions().validate(user, Permission.WRITE))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to move resource \" +\n\t                doc.getFileName());\n\t    if(!doc.getPermissions().validate(user, Permission.WRITE))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to move resource \" +\n\t                doc.getFileName());\n\t    if(newName == null) {\n            int p = doc.getFileName().lastIndexOf('/');\n            newName = doc.getFileName().substring(p + 1);\n        }\n\t    Lock lock = null;\n\t    try {\n\t        lock = collectionsDb.getLock();\n\t        lock.acquire(Lock.WRITE_LOCK);\n\t        // check if the move would overwrite a collection\n\t        if(getCollection(destination.getName() + '/' + newName) != null)\n\t            throw new PermissionDeniedException(\"A resource can not replace an existing collection\");\n\t        DocumentImpl oldDoc = destination.getDocument(this, newName);\n\t        if(oldDoc != null) {\n\t        \tif(doc.getDocId() == oldDoc.getDocId())\n\t            \tthrow new PermissionDeniedException(\"Cannot move resource to itself\");\n\t            if(!destination.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            if(!oldDoc.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            if (oldDoc.getResourceType() == DocumentImpl.BINARY_FILE)\n\t            \tcollection.removeBinaryResource(this, oldDoc);\n\t            else\n\t            \tcollection.removeDocument(this, oldDoc.getFileName());\n\t        } else\n\t            if(!destination.getPermissions().validate(user, Permission.WRITE))\n\t    \t        throw new PermissionDeniedException(\"Insufficient privileges on target collection \" +\n\t    \t                destination.getName());\n\t        \n\t        boolean renameOnly = collection.getId() == destination.getId();\n\t        collection.unlinkDocument(doc);\n\t        doc.setFileName(newName);\n        \tdoc.setCollection(destination);\n\t        if (doc.getResourceType() == DocumentImpl.XML_FILE) {\n\t\t        if(!renameOnly) {\n\t\t\t        elementIndex.dropIndex(doc);\n\t\t\t\t\ttextEngine.dropIndex(doc);\n\t\t\t\t\tvalueIndex.dropIndex(doc);\n\t\t\t\t\tif ( qnameValueIndexation )\n\t\t\t\t\t\tqnameValueIndex.dropIndex(doc);\n\t\t\t\t\tsaveCollection(collection);\n\t\t        }\n\t\t        destination.addDocument(this, doc);\n\t\t        if(!renameOnly) {\n\t\t\t        // reindexing\n\t\t\t\t\treindex(doc);\n\t\t        }\n\t        } else {\n\t        \t// binary resource\n\t        \tdestination.addDocument(this, doc);\n\t        }\n\t\t\tsaveCollection(destination);\n        } catch (TriggerException e) {\n            throw new PermissionDeniedException(e.getMessage());\n        } catch (ReadOnlyException e) {\n            throw new PermissionDeniedException(e.getMessage());\n        } finally {\n\t        lock.release();\n\t    }\n\t}","commit_id":"f82f8a61c9e796974dfb1d5feb268637df6db863","url":"https://github.com/eXist-db/exist"},{"original_method":"public void copyResource(DocumentImpl doc, Collection destination, String newName) \n\tthrows PermissionDeniedException, LockException {\n\t\tif (readOnly)\n\t\t\tthrow new PermissionDeniedException(DATABASE_IS_READ_ONLY);\n\t    Collection collection = doc.getCollection();\n\t    if(!collection.getPermissions().validate(user, Permission.READ))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to copy resource \" +\n\t                doc.getFileName());\n\t    if(!doc.getPermissions().validate(user, Permission.READ))\n\t    \tthrow new PermissionDeniedException(\"Insufficient privileges to copy resource \" +\n\t                doc.getFileName());\n\t    if(newName == null) {\n            int p = doc.getFileName().lastIndexOf('/');\n            newName = doc.getFileName().substring(p + 1);\n        }\n\n\t    Lock lock = null;\n\t    try {\n\t        lock = collectionsDb.getLock();\n\t        lock.acquire(Lock.WRITE_LOCK);\n\t        // check if the move would overwrite a collection\n\t        if(getCollection(destination.getName() + '/' + newName) != null)\n\t            throw new PermissionDeniedException(\"A resource can not replace an existing collection\");\n\t        DocumentImpl oldDoc = destination.getDocument(this, newName);\n\t        if(oldDoc != null) {\n\t        \tif(doc.getDocId() == oldDoc.getDocId())\n\t            \tthrow new PermissionDeniedException(\"Cannot copy resource to itself\");\n\t            if(!destination.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            if(!oldDoc.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            collection.removeDocument(this, oldDoc.getFileName());\n\t        } else {\n\t        \tif(!destination.getPermissions().validate(user, Permission.WRITE))\n\t    \t        throw new PermissionDeniedException(\"Insufficient privileges on target collection \" +\n\t    \t                destination.getName());\n\t        }\n\t        DocumentImpl newDoc = new DocumentImpl(this, newName, destination);\n\t        newDoc.copyOf(doc);\n\t        newDoc.setDocId(getNextDocId(destination));\n\t        copyResource(doc, newDoc);\n\t        destination.addDocument(this, newDoc);\n\t        updateDocument(newDoc);\n//\t        saveCollection(destination);\n\t\t} catch (TriggerException e) {\n\t\t\tthrow new PermissionDeniedException(e.getMessage());\n\t\t} finally {\n\t    \tlock.release();\n\t    }\n\t}","id":28615,"modified_method":"public void copyResource(DocumentImpl doc, Collection destination, String newName)\n\tthrows PermissionDeniedException, LockException {\n\t\tif (readOnly)\n\t\t\tthrow new PermissionDeniedException(DATABASE_IS_READ_ONLY);\n\t    Collection collection = doc.getCollection();\n\t    if(!collection.getPermissions().validate(user, Permission.READ))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to copy resource \" +\n\t                doc.getFileName());\n\t    if(!doc.getPermissions().validate(user, Permission.READ))\n\t    \tthrow new PermissionDeniedException(\"Insufficient privileges to copy resource \" +\n\t                doc.getFileName());\n\t    if(newName == null) {\n            int p = doc.getFileName().lastIndexOf('/');\n            newName = doc.getFileName().substring(p + 1);\n        }\n\n\t    Lock lock = null;\n\t    try {\n\t        lock = collectionsDb.getLock();\n\t        lock.acquire(Lock.WRITE_LOCK);\n\t        // check if the move would overwrite a collection\n\t        if(getCollection(destination.getName() + '/' + newName) != null)\n\t            throw new PermissionDeniedException(\"A resource can not replace an existing collection\");\n\t        DocumentImpl oldDoc = destination.getDocument(this, newName);\n\t        if(oldDoc != null) {\n\t        \tif(doc.getDocId() == oldDoc.getDocId())\n\t            \tthrow new PermissionDeniedException(\"Cannot copy resource to itself\");\n\t            if(!destination.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            if(!oldDoc.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            collection.removeDocument(this, oldDoc.getFileName());\n\t        } else {\n\t        \tif(!destination.getPermissions().validate(user, Permission.WRITE))\n\t    \t        throw new PermissionDeniedException(\"Insufficient privileges on target collection \" +\n\t    \t                destination.getName());\n\t        }\n\t        \n\t        DocumentImpl newDoc;\n\t        if (doc.getResourceType() == DocumentImpl.BINARY_FILE)  {\n\t        \tbyte[] data = getBinaryResourceData((BinaryDocument) doc);\n\t        \tBinaryDocument newBinary = \n        \t\t\tdestination.addBinaryResource(this, newName, data, doc.getMimeType());\n\t        } else {\n\t        \tnewDoc = new DocumentImpl(this, newName, destination);\n\t\t        newDoc.copyOf(doc);\n\t\t        newDoc.setDocId(getNextDocId(destination));\n\t\t        copyResource(doc, newDoc);\n\t\t        destination.addDocument(this, newDoc);\n\t\t        updateDocument(newDoc);\n\t        }\n//\t        saveCollection(destination);\n\t\t} catch (TriggerException e) {\n\t\t\tthrow new PermissionDeniedException(e.getMessage());\n\t\t} catch (EXistException e) {\n\t\t\tLOG.warn(\"An error occurred while copying resource\", e);\n\t\t} finally {\n\t    \tlock.release();\n\t    }\n\t}","commit_id":"f82f8a61c9e796974dfb1d5feb268637df6db863","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Reorders the live table columns by moving one column before another.\n     * \n     * @param columnToMove the label of the live table column to be moved\n     * @param beforeColumn the label of the reference column\n     */\n    public void moveLiveTableColumnBefore(String columnToMove, String beforeColumn)\n    {\n        new Actions(getDriver().getWrappedDriver()).clickAndHold(getLiveTableColumn(columnToMove))\n            .moveToElement(getLiveTableColumn(beforeColumn), 0, 0).perform();\n    }","id":28616,"modified_method":"/**\n     * Reorders the live table columns by moving one column before another.\n     * \n     * @param columnToMove the label of the live table column to be moved\n     * @param beforeColumn the label of the reference column\n     */\n    public void moveLiveTableColumnBefore(String columnToMove, String beforeColumn)\n    {\n        new Actions(getDriver().getWrappedDriver()).clickAndHold(getLiveTableColumn(columnToMove))\n            .moveToElement(getLiveTableColumn(beforeColumn), -3, 0).release().perform();\n    }","commit_id":"986254daa21c951178d5a050422d40ada91c810a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Drag this field over the specified element. Use this method to reorder class fields.\n     * \n     * @param element the element to drag this field to\n     * @param xOffset offset from the top-left corner of the given element; a negative value means coordinates right\n     *            from the given element\n     * @param yOffset offset from the top-left corner of the given element; a negative value means coordinates above the\n     *            given element\n     */\n    public void dragTo(WebElement element, int xOffset, int yOffset)\n    {\n        // This doesn't trigger the :hover CSS pseudo class so we're forced to manually set the display of the tool box.\n        new Actions(getDriver().getWrappedDriver()).moveToElement(container).perform();\n\n        // FIXME: The following line is a hack to overcome the fact that the previous line doesn't trigger the :hover\n        // CSS pseudo class on the field container (even if the mouse if moved over it).\n        showToolBox();\n\n        WebElement dragHandler = toolBox.findElement(By.xpath(\"img[@alt = 'Move']\"));\n        new Actions(getDriver().getWrappedDriver()).clickAndHold(dragHandler).moveToElement(element, xOffset, yOffset)\n            .perform();\n\n        // Reset the tool box display. Remove this line when the :hover CSS class will be triggered by mouse over.\n        hideToolBox();\n    }","id":28617,"modified_method":"/**\n     * Drag this field over the specified element. Use this method to reorder class fields.\n     * \n     * @param element the element to drag this field to\n     * @param xOffset offset from the top-left corner of the given element; a negative value means coordinates right\n     *            from the given element\n     * @param yOffset offset from the top-left corner of the given element; a negative value means coordinates above the\n     *            given element\n     */\n    public void dragTo(WebElement element, int xOffset, int yOffset)\n    {\n        // This doesn't trigger the :hover CSS pseudo class so we're forced to manually set the display of the tool box.\n        new Actions(getDriver().getWrappedDriver()).moveToElement(container).perform();\n\n        // FIXME: The following line is a hack to overcome the fact that the previous line doesn't trigger the :hover\n        // CSS pseudo class on the field container (even if the mouse if moved over it).\n        showToolBox();\n\n        WebElement dragHandler = toolBox.findElement(By.xpath(\"img[@alt = 'Move']\"));\n        new Actions(getDriver().getWrappedDriver()).clickAndHold(dragHandler).moveToElement(element, xOffset, yOffset)\n            .release().perform();\n\n        // Reset the tool box display. Remove this line when the :hover CSS class will be triggered by mouse over.\n        hideToolBox();\n    }","commit_id":"986254daa21c951178d5a050422d40ada91c810a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Reorders list items.\n     * \n     * @param valueToMove the value of the item to be moved\n     * @param beforeValue the value of the reference item\n     */\n    public void moveBefore(String valueToMove, String beforeValue)\n    {\n        new Actions(getDriver().getWrappedDriver()).clickAndHold(getItem(valueToMove))\n            .moveToElement(getItem(beforeValue), -3, 0).perform();\n    }","id":28618,"modified_method":"/**\n     * Reorders list items.\n     * \n     * @param valueToMove the value of the item to be moved\n     * @param beforeValue the value of the reference item\n     */\n    public void moveBefore(String valueToMove, String beforeValue)\n    {\n        new Actions(getDriver().getWrappedDriver()).clickAndHold(getItem(valueToMove))\n            .moveToElement(getItem(beforeValue), -3, 0).release().perform();\n    }","commit_id":"986254daa21c951178d5a050422d40ada91c810a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void visitMethod(@NotNull PsiMethod method) {\n      //note: no call to super;\n      @NonNls final String methodName = method.getName();\n      if (!methodName.startsWith(\"test\") &&\n          !TestUtils.isJUnit4TestMethod(method)) {\n        return;\n      }\n      final PsiType returnType = method.getReturnType();\n      if (returnType == null) {\n        return;\n      }\n      final PsiParameterList parameterList = method.getParameterList();\n      final boolean takesArguments;\n      final boolean isStatic;\n      if (parameterList.getParametersCount() == 0) {\n        takesArguments = false;\n        isStatic = method.hasModifierProperty(PsiModifier.STATIC);\n        if (!isStatic && returnType.equals(PsiType.VOID) &&\n            method.hasModifierProperty(PsiModifier.PUBLIC)) {\n          return;\n        }\n      }\n      else {\n        isStatic = false;\n        takesArguments = true;\n      }\n      final PsiClass targetClass = method.getContainingClass();\n      if (!AnnotationUtil.isAnnotated(method, \"org.junit.Test\", true)) {\n        if (targetClass == null ||\n            !InheritanceUtil.isInheritor(targetClass,\n                                         \"junit.framework.TestCase\")) {\n          return;\n        }\n      }\n      registerMethodError(method, Boolean.valueOf(takesArguments),\n                          Boolean.valueOf(isStatic));\n    }","id":28619,"modified_method":"@Override\n    public void visitMethod(@NotNull PsiMethod method) {\n      //note: no call to super;\n      if (method.isConstructor()) {\n        return;\n      }\n      if (!TestUtils.isJUnit3TestMethod(method) && !TestUtils.isJUnit4TestMethod(method)) {\n        return;\n      }\n      final PsiType returnType = method.getReturnType();\n      final PsiParameterList parameterList = method.getParameterList();\n      final boolean takesArguments;\n      final boolean isStatic;\n      if (parameterList.getParametersCount() == 0) {\n        takesArguments = false;\n        isStatic = method.hasModifierProperty(PsiModifier.STATIC);\n        if (!isStatic && PsiType.VOID.equals(returnType) && method.hasModifierProperty(PsiModifier.PUBLIC)) {\n          return;\n        }\n      }\n      else {\n        isStatic = false;\n        takesArguments = true;\n      }\n      registerMethodError(method, Boolean.valueOf(takesArguments),\n                          Boolean.valueOf(isStatic));\n    }","commit_id":"95e967e93f959c5fadee95172ab2198f53073bcc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isJUnitTestMethod(@Nullable PsiMethod method) {\n    if (method == null) {\n      return false;\n    }\n    if (isJUnit4TestMethod(method)) {\n      return true;\n    }\n    final String methodName = method.getName();\n    @NonNls final String test = \"test\";\n    if (!methodName.startsWith(test)) {\n      return false;\n    }\n    if (method.hasModifierProperty(PsiModifier.ABSTRACT) ||\n        !method.hasModifierProperty(PsiModifier.PUBLIC)) {\n      return false;\n    }\n    final PsiType returnType = method.getReturnType();\n    if (returnType == null) {\n      return false;\n    }\n    if (!returnType.equals(PsiType.VOID)) {\n      return false;\n    }\n    final PsiParameterList parameterList = method.getParameterList();\n    if (parameterList.getParametersCount() != 0) {\n      return false;\n    }\n    final PsiClass targetClass = method.getContainingClass();\n    return isJUnitTestClass(targetClass);\n  }","id":28620,"modified_method":"public static boolean isJUnitTestMethod(@Nullable PsiMethod method) {\n    return isRunnable(method) && (isJUnit3TestMethod(method) || isJUnit4TestMethod(method));\n  }","commit_id":"95e967e93f959c5fadee95172ab2198f53073bcc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitMethod(PsiMethod method) {\n      super.visitMethod(method);\n      final PsiClass containingClass = method.getContainingClass();\n      if (containingClass == null) {\n        return;\n      }\n      if (!TestUtils.isJUnitTestClass(containingClass)) {\n        return;\n      }\n      if (AnnotationUtil.isAnnotated(method, IGNORE, false) && method.getName().startsWith(\"test\")) {\n        registerMethodError(method, method);\n        return;\n      }\n      if (!TestUtils.isJUnit4TestMethod(method)) {\n        return;\n      }\n      final String className = containingClass.getName();\n      registerMethodError(method, className);\n    }","id":28621,"modified_method":"@Override\n    public void visitMethod(PsiMethod method) {\n      super.visitMethod(method);\n      final PsiClass containingClass = method.getContainingClass();\n      if (containingClass == null) {\n        return;\n      }\n      if (!TestUtils.isJUnitTestClass(containingClass)) {\n        return;\n      }\n      if (AnnotationUtil.isAnnotated(method, IGNORE, false) && method.getName().startsWith(\"test\")) {\n        registerMethodError(method, containingClass, method);\n      } else if (TestUtils.isJUnit4TestMethod(method)) {\n        registerMethodError(method, containingClass, method);\n      }\n    }","commit_id":"94cb3c1f8f1ff96f207e326ab7b8604ca0acc67b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public String getName() {\n      return \"Remove @Test annotation\";\n    }","id":28622,"modified_method":"@Override\n    @NotNull\n    public String getName() {\n      return InspectionGadgetsBundle.message(\"remove.junit4.test.annotation.quickfix\");\n    }","commit_id":"94cb3c1f8f1ff96f207e326ab7b8604ca0acc67b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  protected String buildErrorString(Object... infos) {\n\n    if (infos[0] instanceof PsiMethod &&\n        AnnotationUtil.isAnnotated((PsiModifierListOwner)infos[0], IGNORE, false)) {\n      return InspectionGadgetsBundle.message(\"ignore.test.method.in.class.extending.junit3.testcase.problem.descriptor\");\n    }\n    return InspectionGadgetsBundle.message(\n      \"junit4.test.method.in.class.extending.junit3.testcase.problem.descriptor\");\n  }","id":28623,"modified_method":"@Override\n  @NotNull\n  protected String buildErrorString(Object... infos) {\n    if (AnnotationUtil.isAnnotated((PsiMethod)infos[1], IGNORE, false)) {\n      return InspectionGadgetsBundle.message(\"ignore.test.method.in.class.extending.junit3.testcase.problem.descriptor\");\n    }\n    return InspectionGadgetsBundle.message(\"junit4.test.method.in.class.extending.junit3.testcase.problem.descriptor\");\n  }","commit_id":"94cb3c1f8f1ff96f207e326ab7b8604ca0acc67b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    @Override\n    public String getName() {\n      return InspectionGadgetsBundle.message(\"ignore.test.method.in.class.extending.junit3.testcase.problem.fix\", getTargetName());\n    }","id":28624,"modified_method":"@NotNull\n    @Override\n    public String getName() {\n      return InspectionGadgetsBundle.message(\"ignore.test.method.in.class.extending.junit3.testcase.quickfix\", getTargetName());\n    }","commit_id":"94cb3c1f8f1ff96f207e326ab7b8604ca0acc67b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected InspectionGadgetsFix[] buildFixes(Object... infos) {\n    String className = null;\n    if (infos[0] instanceof PsiMethod) {\n      final PsiMethod method = (PsiMethod)infos[0];\n      PsiClass containingClass = method.getContainingClass();\n      if (containingClass == null) return InspectionGadgetsFix.EMPTY_ARRAY;\n      className = containingClass.getName();\n      if (AnnotationUtil.isAnnotated(method, IGNORE, false)) {\n        if (!TestUtils.isJUnit4TestMethod(method)) {\n          return new InspectionGadgetsFix[]{new RemoveIgnoreAndRename(method),\n            new RemoveExtendsTestCaseFix(className)};\n        }\n        else {\n          return new InspectionGadgetsFix[]{new RemoveIgnoreAndRename(method),\n            new RemoveTestAnnotationFix(),\n            new RemoveExtendsTestCaseFix(className)};\n        }\n      }\n    }\n\n    if (className == null) {\n      className = (String)infos[0];\n    }\n    if (className != null) {\n      return new InspectionGadgetsFix[]{\n        new RemoveTestAnnotationFix(),\n        new RemoveExtendsTestCaseFix(className)\n      };\n    }\n    else {\n      return new InspectionGadgetsFix[]{\n        new RemoveTestAnnotationFix()\n      };\n    }\n  }","id":28625,"modified_method":"@NotNull\n  @Override\n  protected InspectionGadgetsFix[] buildFixes(Object... infos) {\n    final List<InspectionGadgetsFix> fixes = new ArrayList(3);\n    final PsiMethod method = (PsiMethod)infos[1];\n    if (AnnotationUtil.isAnnotated(method, IGNORE, false)) {\n      fixes.add(new RemoveIgnoreAndRename(method));\n    }\n    if (TestUtils.isJUnit4TestMethod(method)) {\n      fixes.add(new RemoveTestAnnotationFix());\n    }\n    final PsiClass aClass = (PsiClass)infos[0];\n    final String className = aClass.getName();\n    fixes.add(new ConvertToJUnit4Fix(className));\n    return fixes.toArray(new InspectionGadgetsFix[fixes.size()]);\n  }","commit_id":"94cb3c1f8f1ff96f207e326ab7b8604ca0acc67b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void generate(final GeneratorConfiguration configuration, final Set<SModelDescriptor> modelDescriptors, final boolean generateText) {\n    new Thread() {\n      {\n        setPriority(Thread.MIN_PRIORITY);\n      }\n\n      public void run() {\n        myProject.getComponent(ProjectPane.class).disableRebuild();\n\n        ProgressMonitor progress = new ProgressWindowProgressMonitor(false);\n\n        boolean isIdeaPresent = MPSPlugin.getInstance().isIDEAPresent();\n        try {\n          int modelCount = 0;\n          for (GeneratorConfigurationCommand cmd : CollectionUtil.iteratorAsIterable(configuration.commands())) {\n            modelCount += findModelsWithLanguage(modelDescriptors, cmd.getSourceLanguage().getName()).size();\n          }\n\n          int ideaCompilations = 0;\n          if (isIdeaPresent && myCompileOnGeneration) {\n            if (generateText) {\n              ideaCompilations = 1;\n            } else {\n              ideaCompilations = 2;\n            }\n          }\n\n          progress.start(\"Generating\", (modelCount + ideaCompilations) * AMOUNT_PER_MODEL);\n          if (myCompileOnGeneration && ideaCompilations == 0) {\n            progress.addText(\"IntelliJ IDEA with installed MPS is not present\");\n          }\n\n          if (!myCompileOnGeneration) {\n            progress.addText(\"Compilation in IDEA on generation is turned off\");\n          }\n\n          clearMessages();\n          addMessage(new Message(MessageKind.INFORMATION, null, \"Generating configuration \" + configuration.getName()));\n\n          if (isIdeaPresent && myCompileOnGeneration) {\n            progress.addText(\"Compiling in IntelliJ IDEA...\");\n            LOG.debug(\"Compiling in IDE before generation \");\n            compileAndReload();\n            progress.advance(AMOUNT_PER_MODEL);\n          }\n\n\n          for (GeneratorConfigurationCommand cmd : CollectionUtil.iteratorAsIterable(configuration.commands())) {\n            LOG.debug(\"Executing command : \" + cmd.getSourceLanguage().getName() + \" -> \" + cmd.getTargetLanguage().getName());\n\n            Set<SModelDescriptor> modelsWithLanguage = findModelsWithLanguage(modelDescriptors, cmd.getSourceLanguage().getName());\n            Generator generator = findGenerator(cmd.getSourceLanguage().getName(), cmd.getTargetLanguage().getName());\n            for (Root r : CollectionUtil.iteratorAsIterable(generator.languages())) {\n              myProject.getComponent(RootManager.class).readLanguageDescriptors(new File(r.getPath()));\n            }\n            String generatorClass = findGeneratorClass(generator);\n            if (generatorClass == null) generatorClass = DefaultTemplateGenerator.class.getName();\n            SModelDescriptor templatesModel = loadTemplatesModel(generator);\n            for (final SModelDescriptor model : modelsWithLanguage) {\n              try {\n                generate_internal_new(model, generatorClass, templatesModel, configuration.getOutputPath(), progress, generateText);\n              } catch (final GenerationCanceledException e) {\n                addMessage(new Message(MessageKind.WARNING, \"generation canceled\"));\n                progress.addText(\"Generation canceled\");\n                showMessageView();\n                return;\n              } catch (final GenerationFailedException gfe) {\n                LOG.error(model.getFQName() + \" generation failed\", gfe);\n                addMessage(new Message(MessageKind.ERROR, model.getFQName() + \" model generation failed\"));\n                showMessageView();\n                return;\n              } catch (Exception e) {\n                LOG.error(\"Exception \", e);\n              }\n              addMessage(new Message(MessageKind.INFORMATION, model.getFQName() + \" model is generated\"));\n            }\n          }\n          if (!generateText && isIdeaPresent && myCompileOnGeneration) {\n            LOG.debug(\"Compiling in IDE after generation\");\n            progress.addText(\"Compiling in IntelliJ IDEA...\");\n            compileAndReload();\n            progress.advance(AMOUNT_PER_MODEL);\n          }\n          addMessage(new Message(MessageKind.INFORMATION, \"Generation finished\"));\n          if (!generateText) {\n            showMessageView();\n          }\n\n          progress.addText(\"Finished.\");\n        } finally {\n          progress.finish();\n          myProject.getComponent(ProjectPane.class).enableRebuild();\n        }\n      }\n    }.start();\n  }","id":28626,"modified_method":"public void generate(final GeneratorConfiguration configuration, final Set<SModelDescriptor> modelDescriptors, final boolean generateText) {\n    new Thread() {\n      {\n        setPriority(Thread.MIN_PRIORITY);\n      }\n\n      public void run() {\n        myProject.getComponent(ProjectPane.class).disableRebuild();\n\n        ProgressMonitor progress = new ProgressWindowProgressMonitor(false);\n\n        boolean isIdeaPresent = MPSPlugin.getInstance().isIDEAPresent();\n        try {\n          int modelCount = 0;\n          for (GeneratorConfigurationCommand cmd : CollectionUtil.iteratorAsIterable(configuration.commands())) {\n            modelCount += findModelsWithLanguage(modelDescriptors, cmd.getSourceLanguage().getName()).size();\n          }\n\n          int ideaCompilations = 0;\n          if (isIdeaPresent && myCompileOnGeneration) {\n            if (generateText) {\n              ideaCompilations = 1;\n            } else {\n              ideaCompilations = 2;\n            }\n          }\n\n          progress.start(\"Generating\", (modelCount + ideaCompilations) * AMOUNT_PER_MODEL);\n          if (myCompileOnGeneration && ideaCompilations == 0) {\n            progress.addText(\"IntelliJ IDEA with installed MPS is not present\");\n          }\n\n          if (!myCompileOnGeneration) {\n            progress.addText(\"Compilation in IDEA on generation is turned off\");\n          }\n\n          clearMessages();\n          addMessage(new Message(MessageKind.INFORMATION, null, \"Generating configuration \" + configuration.getName()));\n\n          if (isIdeaPresent && myCompileOnGeneration) {\n            progress.addText(\"Compiling in IntelliJ IDEA...\");\n            LOG.debug(\"Compiling in IDE before generation \");\n            compileAndReload();\n            progress.advance(AMOUNT_PER_MODEL);\n          }\n\n\n          for (GeneratorConfigurationCommand cmd : CollectionUtil.iteratorAsIterable(configuration.commands())) {\n            LOG.debug(\"Executing command : \" + cmd.getSourceLanguage().getName() + \" -> \" + cmd.getTargetLanguage().getName());\n\n            Set<SModelDescriptor> modelsWithLanguage = findModelsWithLanguage(modelDescriptors, cmd.getSourceLanguage().getName());\n            Generator generator = findGenerator(cmd.getSourceLanguage().getName(), cmd.getTargetLanguage().getName());\n            for (String languageRoot : generator.getRequiredLanguageRoots()) {\n              myProject.getComponent(RootManager.class).readLanguageDescriptors(new File(languageRoot));\n            }\n            String generatorClass = findGeneratorClass(generator);\n            if (generatorClass == null) generatorClass = DefaultTemplateGenerator.class.getName();\n            SModelDescriptor templatesModel = loadTemplatesModel(generator);\n            for (final SModelDescriptor model : modelsWithLanguage) {\n              try {\n                generate_internal_new(model, generatorClass, templatesModel, configuration.getOutputPath(), progress, generateText);\n              } catch (final GenerationCanceledException e) {\n                addMessage(new Message(MessageKind.WARNING, \"generation canceled\"));\n                progress.addText(\"Generation canceled\");\n                showMessageView();\n                return;\n              } catch (final GenerationFailedException gfe) {\n                LOG.error(model.getFQName() + \" generation failed\", gfe);\n                addMessage(new Message(MessageKind.ERROR, model.getFQName() + \" model generation failed\"));\n                showMessageView();\n                return;\n              } catch (Exception e) {\n                LOG.error(\"Exception \", e);\n              }\n              addMessage(new Message(MessageKind.INFORMATION, model.getFQName() + \" model is generated\"));\n            }\n          }\n          if (!generateText && isIdeaPresent && myCompileOnGeneration) {\n            LOG.debug(\"Compiling in IDE after generation\");\n            progress.addText(\"Compiling in IntelliJ IDEA...\");\n            compileAndReload();\n            progress.advance(AMOUNT_PER_MODEL);\n          }\n          addMessage(new Message(MessageKind.INFORMATION, \"Generation finished\"));\n          if (!generateText) {\n            showMessageView();\n          }\n\n          progress.addText(\"Finished.\");\n        } finally {\n          progress.finish();\n          myProject.getComponent(ProjectPane.class).enableRebuild();\n        }\n      }\n    }.start();\n  }","commit_id":"86d9101d54df20a1cfd83ff4c453ec28477b297a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private SModelDescriptor loadTemplatesModel(Generator generator) {\n    if (generator.getTemplatesModel() == null) {\n      return null;\n    }\n\n    if (generator.getModelRootsCount() == 0) {\n      LOG.error(\"Couldn't find templates model \" + generator.getTemplatesModel().getName() + \" model roots aren't specified\");\n      getMessageView().add(new Message(MessageKind.WARNING, \"Couldn't find templates model \" + generator.getTemplatesModel().getName() + \" model roots aren't specified\"));\n      return null;\n    }\n\n    Set<ModelRoot> roots = new HashSet<ModelRoot>();\n    Iterator<ModelRoot> iterator = generator.modelRoots();\n    while (iterator.hasNext()) {\n      ModelRoot modelRoot = iterator.next();\n      roots.add(modelRoot);\n    }\n\n    Set<SModelDescriptor> models = new HashSet<SModelDescriptor>();\n    SModelRepository.getInstance().readModelDescriptors(roots, models, myProject);\n\n    for (SModelDescriptor model : models) {\n      if (model.getFQName().equals(generator.getTemplatesModel().getName())) return model;\n    }\n    getMessageView().add(new Message(MessageKind.WARNING, \"Couldn't find templates model \" + generator.getTemplatesModel().getName()));\n    return null;\n  }","id":28627,"modified_method":"private SModelDescriptor loadTemplatesModel(Generator generator) {\n    if (generator.getTemplatesModel() == null) {\n      return null;\n    }\n\n    if (generator.getModelRoots().size() == 0) {\n      LOG.error(\"Couldn't find templates model \" + generator.getTemplatesModel() + \" model roots aren't specified\");\n      getMessageView().add(new Message(MessageKind.WARNING, \"Couldn't find templates model \" + generator.getTemplatesModel() + \" model roots aren't specified\"));\n      return null;\n    }\n\n    Set<ModelRoot> roots = new HashSet<ModelRoot>();\n    Iterator<ModelRoot> iterator = generator.getModelRoots().iterator();\n    while (iterator.hasNext()) {\n      ModelRoot modelRoot = iterator.next();\n      roots.add(modelRoot);\n    }\n\n    Set<SModelDescriptor> models = new HashSet<SModelDescriptor>();\n    SModelRepository.getInstance().readModelDescriptors(roots, models, myProject);\n\n    for (SModelDescriptor model : models) {\n      if (model.getFQName().equals(generator.getTemplatesModel())) return model;\n    }\n    getMessageView().add(new Message(MessageKind.WARNING, \"Couldn't find templates model \" + generator.getTemplatesModel()));\n    return null;\n  }","commit_id":"86d9101d54df20a1cfd83ff4c453ec28477b297a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private String findGeneratorClass(Generator generator) {\n    if (generator.getGeneratorClass() != null) return generator.getGeneratorClass();\n    Language targetLanguage = myProject.getLanguage(generator.getTargetLanguage().getName());\n    if (targetLanguage.getLanguageDescriptor().getTargetOfGenerator() != null) {\n      return targetLanguage.getLanguageDescriptor().getTargetOfGenerator().getGeneratorClass();\n    }\n    return null;\n  }","id":28628,"modified_method":"private String findGeneratorClass(Generator generator) {\n    if (generator.getGeneratorClass() != null) return generator.getGeneratorClass();\n    Language targetLanguage = myProject.getLanguage(generator.getTargetLanguage());\n    if (targetLanguage.getLanguageDescriptor().getTargetOfGenerator() != null) {\n      return targetLanguage.getLanguageDescriptor().getTargetOfGenerator().getGeneratorClass();\n    }\n    return null;\n  }","commit_id":"86d9101d54df20a1cfd83ff4c453ec28477b297a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Generator findGenerator(String sourceLanguage, String targetLanguage) {\n    Language source = LanguageRepository.getInstance().getLanguage(sourceLanguage);\n    Generator result = null;\n\n    LOG.assertLog(source != null, \"Source language must be not null. Can't find language \" + sourceLanguage);\n\n    for (Generator gen : CollectionUtil.iteratorAsIterable(source.getLanguageDescriptor().generators())) {\n      if (gen.getTargetLanguage().getName().equals(targetLanguage)) {\n        result = gen;\n        break;\n      }\n    }\n    return result;\n  }","id":28629,"modified_method":"private Generator findGenerator(String sourceLanguage, String targetLanguage) {\n    Language source = LanguageRepository.getInstance().getLanguage(sourceLanguage);\n    Generator result = null;\n\n    LOG.assertLog(source != null, \"Source language must be not null. Can't find language \" + sourceLanguage);\n\n    for (Generator gen : source.getGenerators()) {\n      if (gen.getTargetLanguage().equals(targetLanguage)) {\n        result = gen;\n        break;\n      }\n    }\n    return result;\n  }","commit_id":"86d9101d54df20a1cfd83ff4c453ec28477b297a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Language getTargetLanguage() {\n    return getLanguage(myGeneratorDescriptor.getTargetLanguage().getName());\n  }","id":28630,"modified_method":"public Language getTargetLanguage() {\n    jetbrains.mps.projectLanguage.Language targetLanguage = myGeneratorDescriptor.getTargetLanguage();\n    if (targetLanguage != null) {\n      return getLanguage(targetLanguage.getName());\n    }\n    return null;\n  }","commit_id":"2a6fd3a870d31674bdf0f9c6bb87401a9480b5e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<ModelRoot> getModelRoots() {\n    return CollectionUtil.iteratorAsList(myGeneratorDescriptor.modelRoots());\n  }","id":28631,"modified_method":"public List<jetbrains.mps.projectLanguage.ModelRoot> getModelRoots() {\n    return CollectionUtil.iteratorAsList(myGeneratorDescriptor.modelRoots());\n  }","commit_id":"2a6fd3a870d31674bdf0f9c6bb87401a9480b5e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getTargetLanguageName() {\n    return myGeneratorDescriptor.getTargetLanguage().getName();\n  }","id":28632,"modified_method":"public String getTargetLanguageName() {\n    jetbrains.mps.projectLanguage.Language targetLanguage = myGeneratorDescriptor.getTargetLanguage();\n    if (targetLanguage != null) {\n      return targetLanguage.getName();\n    }\n    return null;\n  }","commit_id":"2a6fd3a870d31674bdf0f9c6bb87401a9480b5e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public JPopupMenu getPopupMenu() {\n    JPopupMenu result = new JPopupMenu();\n    ActionContext context = new ActionContext(myOperationContext);\n    context.put(Generator.class, myGenerator);\n    ActionManager.instance().getGroup(ProjectPane.PROJECT_PANE_GENERATOR_ACTIONS).add(result, context);\n    return result;\n  }","id":28633,"modified_method":"public JPopupMenu getPopupMenu() {\n    JPopupMenu result = new JPopupMenu();\n    ActionContext context = new ActionContext(getOperationContext());\n    context.put(MPSProject.class, getOperationContext().getProject());\n    context.put(Generator.class, getGenerator());\n    ActionManager.instance().getGroup(ProjectPane.PROJECT_PANE_GENERATOR_ACTIONS).add(result, context);\n    return result;\n  }","commit_id":"2a6fd3a870d31674bdf0f9c6bb87401a9480b5e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public GeneratorTreeNode(String text, Generator generator, MPSProject project, IOperationContext operationContext) {\n    super(text);\n    myGenerator = generator;\n    myProject = project;\n    myOperationContext = new ModuleContext(generator, operationContext.getProject());\n    populate();\n  }","id":28634,"modified_method":"public GeneratorTreeNode(Generator generator, MPSProject project) {\n    super(new ModuleContext(generator, project));\n    populate();\n  }","commit_id":"2a6fd3a870d31674bdf0f9c6bb87401a9480b5e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void populate() {\n    List<GeneratorModelsTreeNode> modelTreeNodes = GeneratorModelsTreeNode.createModelsTreeNodes(myOperationContext);\n    for (GeneratorModelsTreeNode modelsTreeNode : modelTreeNodes) {\n      this.add(modelsTreeNode);\n    }\n    \n    LanguagesTreeNode languagesNode = new LanguagesTreeNode(myProject, myOperationContext);\n    this.add(languagesNode);\n  }","id":28635,"modified_method":"private void populate() {\n    List<GeneratorModelsTreeNode> modelTreeNodes = GeneratorModelsTreeNode.createModelsTreeNodes(getOperationContext());\n    for (GeneratorModelsTreeNode modelsTreeNode : modelTreeNodes) {\n      this.add(modelsTreeNode);\n    }\n\n    LanguagesTreeNode languagesNode = new LanguagesTreeNode(getOperationContext().getProject(), getOperationContext());\n    this.add(languagesNode);\n  }","commit_id":"2a6fd3a870d31674bdf0f9c6bb87401a9480b5e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void populate() {\n    IOperationContext operationContext = getOperationContext();\n\n    // language aspects\n\n    SModelDescriptor structureModelDescriptor = myLanguage.getStructureModelDescriptor();\n    if(structureModelDescriptor != null) {\n      this.add(new SModelTreeNode(structureModelDescriptor, \"structure\", operationContext));\n    }\n\n    SModelDescriptor editorModelDescriptor = myLanguage.getEditorModelDescriptor();\n    if(editorModelDescriptor != null) {\n      this.add(new SModelTreeNode(editorModelDescriptor, \"editor\", operationContext));\n    }\n\n    // todo: tmp here\n    SModelDescriptor templatesEditorModelDescriptor = myLanguage.getEditorModelDescriptor(\"templates\");\n    if(templatesEditorModelDescriptor != null) {\n      this.add(new SModelTreeNode(templatesEditorModelDescriptor, \"templates editor\", operationContext));\n    }\n\n    SModelDescriptor typesystemModelDescriptor = myLanguage.getTypesystemModelDescriptor();\n    if (typesystemModelDescriptor != null) {\n      this.add(new SModelTreeNode(typesystemModelDescriptor, \"typesystem\", operationContext));\n    }\n\n    SModelDescriptor actionsModelDescriptor = myLanguage.getActionsModelDescriptor();\n    if (actionsModelDescriptor != null) {\n      this.add(new SModelTreeNode(actionsModelDescriptor, \"actions\", operationContext));\n    }\n\n    // language accessory models\n\n    TextTreeNode libraries = new TextTreeNode(\"<html><b>accessory<\/b>\") {\n      public Icon getIcon(boolean expanded) {\n        return Icons.LIB_ICON;\n      }\n    };\n\n    List<SModelDescriptor> sortedModels = SortUtil.sortModels(myLanguage.getAccessoryModels());\n    for (SModelDescriptor model : sortedModels) {\n      libraries.add(new SModelTreeNode(model, null, operationContext));\n    }\n    this.add(libraries);\n\n\n    // language generators\n\n    for (Generator generator : myLanguage.getGenerators()) {\n      TextTreeNode generatorNode = new GeneratorTreeNode(\"<html><b>generator \\\"\" + generator.getName() + \"\\\"<\/b>\", generator, myProject, operationContext);\n      this.add(generatorNode);\n    }\n  }","id":28636,"modified_method":"private void populate() {\n    IOperationContext operationContext = getOperationContext();\n\n    // language aspects\n\n    SModelDescriptor structureModelDescriptor = myLanguage.getStructureModelDescriptor();\n    if (structureModelDescriptor != null) {\n      this.add(new SModelTreeNode(structureModelDescriptor, \"structure\", operationContext));\n    }\n\n    SModelDescriptor editorModelDescriptor = myLanguage.getEditorModelDescriptor();\n    if (editorModelDescriptor != null) {\n      this.add(new SModelTreeNode(editorModelDescriptor, \"editor\", operationContext));\n    }\n\n    // todo: tmp here\n    SModelDescriptor templatesEditorModelDescriptor = myLanguage.getEditorModelDescriptor(\"templates\");\n    if (templatesEditorModelDescriptor != null) {\n      this.add(new SModelTreeNode(templatesEditorModelDescriptor, \"templates editor\", operationContext));\n    }\n\n    SModelDescriptor typesystemModelDescriptor = myLanguage.getTypesystemModelDescriptor();\n    if (typesystemModelDescriptor != null) {\n      this.add(new SModelTreeNode(typesystemModelDescriptor, \"typesystem\", operationContext));\n    }\n\n    SModelDescriptor actionsModelDescriptor = myLanguage.getActionsModelDescriptor();\n    if (actionsModelDescriptor != null) {\n      this.add(new SModelTreeNode(actionsModelDescriptor, \"actions\", operationContext));\n    }\n\n    // language accessory models\n\n    TextTreeNode accessories = new TextTreeNode(\"accessories\") {\n      public Icon getIcon(boolean expanded) {\n        return Icons.LIB_ICON;\n      }\n    };\n\n    List<SModelDescriptor> sortedModels = SortUtil.sortModels(myLanguage.getAccessoryModels());\n    for (SModelDescriptor model : sortedModels) {\n      accessories.add(new SModelTreeNode(model, null, operationContext));\n    }\n    this.add(accessories);\n\n    // language generators\n    TextTreeNode generators = new TextTreeNode(\"generators\", operationContext) {\n      public Icon getIcon(boolean expanded) {\n        return Icons.GENERATORS_ICON;\n      }\n\n      public JPopupMenu getPopupMenu() {\n        JPopupMenu result = new JPopupMenu();\n        ActionContext context = new ActionContext(getOperationContext());\n        ActionManager.instance().getGroup(ProjectPane.PROJECT_PANE_GENERATORS_ACTIONS).add(result, context);\n        return result;\n      }\n    };\n    this.add(generators);\n\n\n    for (Generator generator : myLanguage.getGenerators()) {\n      MPSTreeNode generatorNode = new GeneratorTreeNode(generator, myProject);\n      generators.add(generatorNode);\n    }\n  }","commit_id":"2a6fd3a870d31674bdf0f9c6bb87401a9480b5e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void modelChangedInCommand(final List<SModelEvent> events, EditorContext editorContext) {\n      ProjectPane projectPane = getOperationContext().getComponent(ProjectPane.class);\n      projectPane.rebuildTree(new Runnable() {\n        public void run() {\n          SModelEventVisitor visitor = new SModelEventVisitor() {\n            public void visitRootEvent(SModelRootEvent event) {\n              SModelTreeNode.this.update();\n              updateTreeWithRoot(event.getRoot());\n            }\n\n            public void visitChildEvent(SModelChildEvent event) {\n              updateTreeWithRoot(event.getParent());\n            }\n\n            public void visitPropertyEvent(SModelPropertyEvent event) {\n              DefaultTreeModel treeModel = (DefaultTreeModel)getOperationContext().getComponent(IdeMain.class).getProjectPane().getTree().getModel();\n\n              //i tried to use nodeChange but it didn't work\n              treeModel.nodeStructureChanged((TreeNode) findAncestorWith(event.getNode()));\n            }\n\n            public void visitReferenceEvent(SModelReferenceEvent event) {\n            }\n          };\n          for (SModelEvent event : events) {\n            event.accept(visitor);\n          }\n\n        }\n      }, EventUtil.isDramaticalChange(events));\n    }","id":28637,"modified_method":"public void modelChangedInCommand(final List<SModelEvent> events, EditorContext editorContext) {\n      ProjectPane projectPane = getOperationContext().getComponent(ProjectPane.class);\n      projectPane.rebuildTree(new Runnable() {\n        public void run() {\n          SModelEventVisitor visitor = new SModelEventVisitor() {\n            public void visitRootEvent(SModelRootEvent event) {\n              SModelTreeNode.this.update();\n              updateTreeWithRoot(event.getRoot());\n            }\n\n            public void visitChildEvent(SModelChildEvent event) {\n              updateTreeWithRoot(event.getParent());\n            }\n\n            public void visitPropertyEvent(SModelPropertyEvent event) {\n              DefaultTreeModel treeModel = (DefaultTreeModel) getOperationContext().getComponent(IdeMain.class).getProjectPane().getTree().getModel();\n\n              //i tried to use nodeChange but it didn't work\n              treeModel.nodeStructureChanged(findAncestorWith(event.getNode()));\n            }\n\n            public void visitReferenceEvent(SModelReferenceEvent event) {\n            }\n          };\n          for (SModelEvent event : events) {\n            event.accept(visitor);\n          }\n\n        }\n      }, EventUtil.isDramaticalChange(events));\n    }","commit_id":"2a6fd3a870d31674bdf0f9c6bb87401a9480b5e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TextTreeNode(String text) {\n    super(null);\n    myText = text;\n  }","id":28638,"modified_method":"public TextTreeNode(String text) {\n    this(text, null);\n  }","commit_id":"2a6fd3a870d31674bdf0f9c6bb87401a9480b5e9","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void submitAndVerifyStreamBatchJob(Class<? extends AbstractApplication> appClass,\n                                             String streamWriter, String mapReduceName, int timeout) throws Exception {\n    ApplicationManager applicationManager = deployApplication(appClass);\n    StreamManager streamManager = getStreamManager(streamWriter);\n    for (int i = 0; i < 50; i++) {\n      streamManager.send(String.valueOf(i));\n    }\n\n    MapReduceManager mapReduceManager = applicationManager.startMapReduce(mapReduceName);\n    mapReduceManager.waitForFinish(timeout, TimeUnit.SECONDS);\n\n    // The MR job simply turns every stream event body into key/value pairs, with key==value.\n    DataSetManager<KeyValueTable> datasetManager = applicationManager.getDataSet(\"results\");\n    KeyValueTable results = datasetManager.get();\n    for (int i = 0; i < 50; i++) {\n      byte[] key = String.valueOf(i).getBytes(Charsets.UTF_8);\n      Assert.assertArrayEquals(key, results.read(key));\n    }\n  }","id":28639,"modified_method":"private void submitAndVerifyStreamBatchJob(Class<? extends AbstractApplication> appClass,\n                                             String streamWriter, String mapReduceName, int timeout) throws Exception {\n    ApplicationManager applicationManager = deployApplication(appClass);\n    StreamManager streamManager = getStreamManager(streamWriter);\n    for (int i = 0; i < 50; i++) {\n      streamManager.send(String.valueOf(i));\n    }\n\n    MapReduceManager mapReduceManager = applicationManager.getMapReduceManager(mapReduceName);\n    mapReduceManager.start();\n    mapReduceManager.waitForFinish(timeout, TimeUnit.SECONDS);\n\n    // The MR job simply turns every stream event body into key/value pairs, with key==value.\n    DataSetManager<KeyValueTable> datasetManager = applicationManager.getDataSet(\"results\");\n    KeyValueTable results = datasetManager.get();\n    for (int i = 0; i < 50; i++) {\n      byte[] key = String.valueOf(i).getBytes(Charsets.UTF_8);\n      Assert.assertArrayEquals(key, results.read(key));\n    }\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testWordCountOnFileSet() throws Exception {\n\n    // deploy the application\n    ApplicationManager applicationManager = deployApplication(FileSetExample.class);\n\n    final String line1 = \"a b a\";\n    final String line2 = \"b a b\";\n\n    // discover the file set service\n    ServiceManager serviceManager = applicationManager.startService(\"FileSetService\");\n    serviceManager.waitForStatus(true);\n    URL serviceURL = serviceManager.getServiceURL();\n\n    // write a file to the file set using the service\n    HttpURLConnection connection = (HttpURLConnection) new URL(serviceURL, \"lines?path=nn.1\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(line1.getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // run word count over that file only\n    Map<String, String> runtimeArguments = Maps.newHashMap();\n    Map<String, String> inputArgs = Maps.newHashMap();\n    FileSetArguments.setInputPaths(inputArgs, \"nn.1\");\n    Map<String, String> outputArgs = Maps.newHashMap();\n    FileSetArguments.setOutputPath(outputArgs, \"out.1\");\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"lines\", inputArgs));\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"counts\", outputArgs));\n\n    MapReduceManager mapReduceManager = applicationManager.startMapReduce(\"WordCount\", runtimeArguments);\n    mapReduceManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    // retrieve the counts through the service and verify\n    Map<String, Integer> counts = Maps.newHashMap();\n    connection = (HttpURLConnection) new URL(serviceURL, \"counts?path=out.1/part-r-00000\").openConnection();\n    try {\n      connection.setRequestMethod(\"GET\");\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n      readCounts(connection.getInputStream(), counts);\n    } finally {\n      connection.disconnect();\n    }\n    // \"a b a\" should yield \"a\":2, \"b\":1\n    Assert.assertEquals(2, counts.size());\n    Assert.assertEquals(new Integer(2), counts.get(\"a\"));\n    Assert.assertEquals(new Integer(1), counts.get(\"b\"));\n\n    // write a file to the file set using the dataset directly\n    DataSetManager<FileSet> linesManager = getDataset(\"lines\");\n    OutputStream output = linesManager.get().getLocation(\"nn.2\").getOutputStream();\n    try {\n      output.write(line2.getBytes(Charsets.UTF_8));\n    } finally {\n      output.close();\n    }\n\n    // run word count over both files\n    FileSetArguments.setInputPath(inputArgs, \"nn.1\");\n    FileSetArguments.addInputPath(inputArgs, \"nn.2\");\n    FileSetArguments.setOutputPath(outputArgs, \"out.2\");\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"lines\", inputArgs));\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"counts\", outputArgs));\n\n    mapReduceManager = applicationManager.startMapReduce(\"WordCount\", runtimeArguments);\n    mapReduceManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    // retrieve the counts through the dataset API and verify\n    // write a file to the file set using the dataset directly\n    DataSetManager<FileSet> countsManager = getDataset(\"counts\");\n\n    counts.clear();\n    Location resultLocation = countsManager.get().getLocation(\"out.2\");\n    Assert.assertTrue(resultLocation.isDirectory());\n    for (Location child : resultLocation.list()) {\n      if (child.getName().startsWith(\"part-\")) { // only read part files, no check sums or done files\n        readCounts(child.getInputStream(), counts);\n      }\n    }\n    // \"a b a\" and \"b a b\" should yield \"a\":3, \"b\":3\n    Assert.assertEquals(2, counts.size());\n    Assert.assertEquals(new Integer(3), counts.get(\"a\"));\n    Assert.assertEquals(new Integer(3), counts.get(\"b\"));\n\n    serviceManager.stop();\n  }","id":28640,"modified_method":"@Test\n  public void testWordCountOnFileSet() throws Exception {\n\n    // deploy the application\n    ApplicationManager applicationManager = deployApplication(FileSetExample.class);\n\n    final String line1 = \"a b a\";\n    final String line2 = \"b a b\";\n\n    // discover the file set service\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"FileSetService\");\n    serviceManager.start();\n    serviceManager.waitForStatus(true);\n    URL serviceURL = serviceManager.getServiceURL();\n\n    // write a file to the file set using the service\n    HttpURLConnection connection = (HttpURLConnection) new URL(serviceURL, \"lines?path=nn.1\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(line1.getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // run word count over that file only\n    Map<String, String> runtimeArguments = Maps.newHashMap();\n    Map<String, String> inputArgs = Maps.newHashMap();\n    FileSetArguments.setInputPaths(inputArgs, \"nn.1\");\n    Map<String, String> outputArgs = Maps.newHashMap();\n    FileSetArguments.setOutputPath(outputArgs, \"out.1\");\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"lines\", inputArgs));\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"counts\", outputArgs));\n\n    MapReduceManager mapReduceManager = applicationManager.getMapReduceManager(\"WordCount\");\n    mapReduceManager.start(runtimeArguments);\n    mapReduceManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    // retrieve the counts through the service and verify\n    Map<String, Integer> counts = Maps.newHashMap();\n    connection = (HttpURLConnection) new URL(serviceURL, \"counts?path=out.1/part-r-00000\").openConnection();\n    try {\n      connection.setRequestMethod(\"GET\");\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n      readCounts(connection.getInputStream(), counts);\n    } finally {\n      connection.disconnect();\n    }\n    // \"a b a\" should yield \"a\":2, \"b\":1\n    Assert.assertEquals(2, counts.size());\n    Assert.assertEquals(new Integer(2), counts.get(\"a\"));\n    Assert.assertEquals(new Integer(1), counts.get(\"b\"));\n\n    // write a file to the file set using the dataset directly\n    DataSetManager<FileSet> linesManager = getDataset(\"lines\");\n    OutputStream output = linesManager.get().getLocation(\"nn.2\").getOutputStream();\n    try {\n      output.write(line2.getBytes(Charsets.UTF_8));\n    } finally {\n      output.close();\n    }\n\n    // run word count over both files\n    FileSetArguments.setInputPath(inputArgs, \"nn.1\");\n    FileSetArguments.addInputPath(inputArgs, \"nn.2\");\n    FileSetArguments.setOutputPath(outputArgs, \"out.2\");\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"lines\", inputArgs));\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"counts\", outputArgs));\n\n    mapReduceManager = applicationManager.getMapReduceManager(\"WordCount\");\n    mapReduceManager.start(runtimeArguments);\n    mapReduceManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    // retrieve the counts through the dataset API and verify\n    // write a file to the file set using the dataset directly\n    DataSetManager<FileSet> countsManager = getDataset(\"counts\");\n\n    counts.clear();\n    Location resultLocation = countsManager.get().getLocation(\"out.2\");\n    Assert.assertTrue(resultLocation.isDirectory());\n    for (Location child : resultLocation.list()) {\n      if (child.getName().startsWith(\"part-\")) { // only read part files, no check sums or done files\n        readCounts(child.getInputStream(), counts);\n      }\n    }\n    // \"a b a\" and \"b a b\" should yield \"a\":3, \"b\":3\n    Assert.assertEquals(2, counts.size());\n    Assert.assertEquals(new Integer(3), counts.get(\"a\"));\n    Assert.assertEquals(new Integer(3), counts.get(\"b\"));\n\n    serviceManager.stop();\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testStreamBatch() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestFlowStreamIntegrationApp.class);\n    StreamManager s1 = getStreamManager(\"s1\");\n    for (int i = 0; i < 50; i++) {\n      s1.send(String.valueOf(i));\n    }\n\n    applicationManager.startFlow(\"StreamTestFlow\");\n    RuntimeMetrics flowletMetrics1 = RuntimeStats.getFlowletMetrics(\"TestFlowStreamIntegrationApp\",\n                                                                    \"StreamTestFlow\", \"StreamReader\");\n    flowletMetrics1.waitForProcessed(1, 10, TimeUnit.SECONDS);\n    if (flowletMetrics1.getException() > 0) {\n      Assert.fail(\"StreamReader test failed\");\n    }\n  }","id":28641,"modified_method":"@Test\n  public void testStreamBatch() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestFlowStreamIntegrationApp.class);\n    StreamManager s1 = getStreamManager(\"s1\");\n    for (int i = 0; i < 50; i++) {\n      s1.send(String.valueOf(i));\n    }\n\n    applicationManager.getFlowManager(\"StreamTestFlow\").start();\n    RuntimeMetrics flowletMetrics1 = RuntimeStats.getFlowletMetrics(\"TestFlowStreamIntegrationApp\",\n                                                                    \"StreamTestFlow\", \"StreamReader\");\n    flowletMetrics1.waitForProcessed(1, 10, TimeUnit.SECONDS);\n    if (flowletMetrics1.getException() > 0) {\n      Assert.fail(\"StreamReader test failed\");\n    }\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws Exception {\n    // Deploy the HelloWorld application\n    ApplicationManager appManager = deployApplication(HelloWorld.class);\n\n    // Start WhoFlow\n    FlowManager flowManager = appManager.startFlow(\"WhoFlow\");\n    Assert.assertTrue(flowManager.isRunning());\n\n    // Send stream events to the \"who\" Stream\n    StreamManager streamManager = getStreamManager(\"who\");\n    streamManager.send(\"1\");\n    streamManager.send(\"2\");\n    streamManager.send(\"3\");\n    streamManager.send(\"4\");\n    streamManager.send(\"5\");\n\n    try {\n      // Wait for the last Flowlet processing 5 events, or at most 5 seconds\n      RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"HelloWorld\", \"WhoFlow\", \"saver\");\n      metrics.waitForProcessed(5, 5, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n      Assert.assertFalse(flowManager.isRunning());\n    }\n\n    // Start Greeting service and use it\n    ServiceManager serviceManager = appManager.startService(HelloWorld.Greeting.SERVICE_NAME);\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    URL url = new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"greet\");\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    String response;\n    try {\n      response = new String(ByteStreams.toByteArray(connection.getInputStream()), Charsets.UTF_8);\n    } finally {\n      connection.disconnect();\n    }\n    Assert.assertEquals(\"Hello 5!\", response);\n  }","id":28642,"modified_method":"@Test\n  public void test() throws Exception {\n    // Deploy the HelloWorld application\n    ApplicationManager appManager = deployApplication(HelloWorld.class);\n\n    // Start WhoFlow\n    FlowManager flowManager = appManager.getFlowManager(\"WhoFlow\");\n    flowManager.start();\n    Assert.assertTrue(flowManager.isRunning());\n\n    // Send stream events to the \"who\" Stream\n    StreamManager streamManager = getStreamManager(\"who\");\n    streamManager.send(\"1\");\n    streamManager.send(\"2\");\n    streamManager.send(\"3\");\n    streamManager.send(\"4\");\n    streamManager.send(\"5\");\n\n    try {\n      // Wait for the last Flowlet processing 5 events, or at most 5 seconds\n      RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"HelloWorld\", \"WhoFlow\", \"saver\");\n      metrics.waitForProcessed(5, 5, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n      Assert.assertFalse(flowManager.isRunning());\n    }\n\n    // Start Greeting service and use it\n    ServiceManager serviceManager = appManager.getServiceManager(HelloWorld.Greeting.SERVICE_NAME);\n    serviceManager.start();\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    URL url = new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"greet\");\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    String response;\n    try {\n      response = new String(ByteStreams.toByteArray(connection.getInputStream()), Charsets.UTF_8);\n    } finally {\n      connection.disconnect();\n    }\n    Assert.assertEquals(\"Hello 5!\", response);\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testFlowManager() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestApplication.class);\n    FlowManager flowManager = applicationManager.startFlow(TestFlow.NAME);\n    flowManager.stop();\n  }","id":28643,"modified_method":"@Test\n  public void testFlowManager() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestApplication.class);\n    FlowManager flowManager = applicationManager.getFlowManager(TestFlow.NAME);\n    flowManager.start();\n    flowManager.stop();\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestMapReduceServiceIntegrationApp.class);\n    ServiceManager serviceManager = applicationManager.startService(TestMapReduceServiceIntegrationApp.SERVICE_NAME);\n    serviceManager.waitForStatus(true);\n\n    DataSetManager<MyKeyValueTableDefinition.KeyValueTable> inDataSet =\n      applicationManager.getDataSet(TestMapReduceServiceIntegrationApp.INPUT_DATASET);\n    inDataSet.get().write(\"key1\", \"Two words\");\n    inDataSet.get().write(\"key2\", \"Plus three words\");\n    inDataSet.flush();\n\n    MapReduceManager mrManager = applicationManager.startMapReduce(TestMapReduceServiceIntegrationApp.MR_NAME);\n    mrManager.waitForFinish(180, TimeUnit.SECONDS);\n\n    DataSetManager<MyKeyValueTableDefinition.KeyValueTable> outDataSet =\n      applicationManager.getDataSet(TestMapReduceServiceIntegrationApp.OUTPUT_DATASET);\n    MyKeyValueTableDefinition.KeyValueTable results = outDataSet.get();\n\n    String total = results.get(TestMapReduceServiceIntegrationApp.SQUARED_TOTAL_WORDS_COUNT);\n    Assert.assertEquals(25, Integer.parseInt(total));\n  }","id":28644,"modified_method":"@Test\n  public void test() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestMapReduceServiceIntegrationApp.class);\n    ServiceManager serviceManager =\n      applicationManager.getServiceManager(TestMapReduceServiceIntegrationApp.SERVICE_NAME);\n    serviceManager.start();\n    serviceManager.waitForStatus(true);\n\n    DataSetManager<MyKeyValueTableDefinition.KeyValueTable> inDataSet =\n      applicationManager.getDataSet(TestMapReduceServiceIntegrationApp.INPUT_DATASET);\n    inDataSet.get().write(\"key1\", \"Two words\");\n    inDataSet.get().write(\"key2\", \"Plus three words\");\n    inDataSet.flush();\n\n    MapReduceManager mrManager = applicationManager.getMapReduceManager(TestMapReduceServiceIntegrationApp.MR_NAME);\n    mrManager.start();\n    mrManager.waitForFinish(180, TimeUnit.SECONDS);\n\n    DataSetManager<MyKeyValueTableDefinition.KeyValueTable> outDataSet =\n      applicationManager.getDataSet(TestMapReduceServiceIntegrationApp.OUTPUT_DATASET);\n    MyKeyValueTableDefinition.KeyValueTable results = outDataSet.get();\n\n    String total = results.get(TestMapReduceServiceIntegrationApp.SQUARED_TOTAL_WORDS_COUNT);\n    Assert.assertEquals(25, Integer.parseInt(total));\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws Exception {\n\n    ApplicationManager applicationManager = deployApplication(AppWithMapReduceUsingStream.class);\n    Schema schema = new Schema.Parser().parse(AppWithMapReduceUsingStream.SCHEMA.toString());\n    StreamManager streamManager = getStreamManager(\"mrStream\");\n    streamManager.send(createEvent(schema, \"YHOO\", 100, 10.0f));\n    streamManager.send(createEvent(schema, \"YHOO\", 10, 10.1f));\n    streamManager.send(createEvent(schema, \"YHOO\", 13, 9.9f));\n    float yhooTotal = 100 * 10.0f + 10 * 10.1f + 13 * 9.9f;\n    streamManager.send(createEvent(schema, \"AAPL\", 5, 300.0f));\n    streamManager.send(createEvent(schema, \"AAPL\", 3, 298.34f));\n    streamManager.send(createEvent(schema, \"AAPL\", 50, 305.23f));\n    streamManager.send(createEvent(schema, \"AAPL\", 1000, 284.13f));\n    float aaplTotal = 5 * 300.0f + 3 * 298.34f + 50 * 305.23f + 1000 * 284.13f;\n\n    MapReduceManager mrManager = applicationManager.startMapReduce(\"BodyTracker\");\n    mrManager.waitForFinish(180, TimeUnit.SECONDS);\n\n    KeyValueTable pricesDS = (KeyValueTable) getDataset(\"prices\").get();\n    float yhooVal = Bytes.toFloat(pricesDS.read(Bytes.toBytes(\"YHOO\")));\n    float aaplVal = Bytes.toFloat(pricesDS.read(Bytes.toBytes(\"AAPL\")));\n    Assert.assertTrue(Math.abs(yhooTotal - yhooVal) < 0.0000001);\n    Assert.assertTrue(Math.abs(aaplTotal - aaplVal) < 0.0000001);\n  }","id":28645,"modified_method":"@Test\n  public void test() throws Exception {\n\n    ApplicationManager applicationManager = deployApplication(AppWithMapReduceUsingStream.class);\n    Schema schema = new Schema.Parser().parse(AppWithMapReduceUsingStream.SCHEMA.toString());\n    StreamManager streamManager = getStreamManager(\"mrStream\");\n    streamManager.send(createEvent(schema, \"YHOO\", 100, 10.0f));\n    streamManager.send(createEvent(schema, \"YHOO\", 10, 10.1f));\n    streamManager.send(createEvent(schema, \"YHOO\", 13, 9.9f));\n    float yhooTotal = 100 * 10.0f + 10 * 10.1f + 13 * 9.9f;\n    streamManager.send(createEvent(schema, \"AAPL\", 5, 300.0f));\n    streamManager.send(createEvent(schema, \"AAPL\", 3, 298.34f));\n    streamManager.send(createEvent(schema, \"AAPL\", 50, 305.23f));\n    streamManager.send(createEvent(schema, \"AAPL\", 1000, 284.13f));\n    float aaplTotal = 5 * 300.0f + 3 * 298.34f + 50 * 305.23f + 1000 * 284.13f;\n\n    MapReduceManager mrManager = applicationManager.getMapReduceManager(\"BodyTracker\");\n    mrManager.start();\n    mrManager.waitForFinish(180, TimeUnit.SECONDS);\n\n    KeyValueTable pricesDS = (KeyValueTable) getDataset(\"prices\").get();\n    float yhooVal = Bytes.toFloat(pricesDS.read(Bytes.toBytes(\"YHOO\")));\n    float aaplVal = Bytes.toFloat(pricesDS.read(Bytes.toBytes(\"AAPL\")));\n    Assert.assertTrue(Math.abs(yhooTotal - yhooVal) < 0.0000001);\n    Assert.assertTrue(Math.abs(aaplTotal - aaplVal) < 0.0000001);\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"private ServiceManager getUserProfileServiceManager(ApplicationManager appManager) throws InterruptedException {\n    // Start UserProfileService\n    ServiceManager userProfileServiceManager = appManager.startService(UserProfileServiceHandler.SERVICE_NAME);\n\n    // Wait for service startup\n    userProfileServiceManager.waitForStatus(true);\n    return userProfileServiceManager;\n  }","id":28646,"modified_method":"private ServiceManager getUserProfileServiceManager(ApplicationManager appManager) throws InterruptedException {\n    // Start UserProfileService\n    ServiceManager userProfileServiceManager = appManager.getServiceManager(UserProfileServiceHandler.SERVICE_NAME);\n    userProfileServiceManager.start();\n\n    // Wait for service startup\n    userProfileServiceManager.waitForStatus(true);\n    return userProfileServiceManager;\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws Exception {\n    // Deploy the PurchaseApp application\n    ApplicationManager appManager = deployApplication(PurchaseApp.class);\n\n    // Start PurchaseFlow\n    FlowManager flowManager = appManager.startFlow(\"PurchaseFlow\");\n\n    // Send stream events to the \"purchaseStream\" Stream\n    StreamManager streamManager = getStreamManager(\"purchaseStream\");\n    streamManager.send(\"bob bought 3 apples for $30\");\n    streamManager.send(\"joe bought 1 apple for $100\");\n    streamManager.send(\"joe bought 10 pineapples for $20\");\n    streamManager.send(\"cat bought 3 bottles for $12\");\n    streamManager.send(\"cat bought 2 pops for $14\");\n\n    try {\n      // Wait for the last Flowlet processing 5 events, or at most 5 seconds\n      RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"PurchaseHistory\", \"PurchaseFlow\", \"collector\");\n      metrics.waitForProcessed(5, 15, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n    }\n\n    ServiceManager userProfileServiceManager = getUserProfileServiceManager(appManager);\n\n    // Add customer's profile information\n    URL userProfileUrl = new URL(userProfileServiceManager.getServiceURL(15, TimeUnit.SECONDS),\n                                    UserProfileServiceHandler.USER_ENDPOINT);\n    HttpURLConnection userProfileConnection = (HttpURLConnection) userProfileUrl.openConnection();\n    String userProfileJson = \"{'id' : 'joe', 'firstName': 'joe', 'lastName':'bernard', 'categories': ['fruits']}\";\n\n    try {\n      userProfileConnection.setDoOutput(true);\n      userProfileConnection.setRequestMethod(\"POST\");\n      userProfileConnection.getOutputStream().write(userProfileJson.getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, userProfileConnection.getResponseCode());\n    } finally {\n      userProfileConnection.disconnect();\n    }\n\n    // Test service to retrieve customer's profile information\n    userProfileUrl = new URL(userProfileServiceManager.getServiceURL(15, TimeUnit.SECONDS),\n                                    UserProfileServiceHandler.USER_ENDPOINT + \"/joe\");\n    userProfileConnection = (HttpURLConnection) userProfileUrl.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, userProfileConnection.getResponseCode());\n    String customerJson;\n    try {\n      customerJson = new String(ByteStreams.toByteArray(userProfileConnection.getInputStream()), Charsets.UTF_8);\n    } finally {\n      userProfileConnection.disconnect();\n    }\n\n    UserProfile profileFromService = GSON.fromJson(customerJson, UserProfile.class);\n    Assert.assertEquals(profileFromService.getFirstName(), \"joe\");\n    Assert.assertEquals(profileFromService.getLastName(), \"bernard\");\n\n    // Run PurchaseHistoryWorkflow which will process the data\n    MapReduceManager mapReduceManager = appManager.startMapReduce(\"PurchaseHistoryBuilder\",\n                                                                  ImmutableMap.<String, String>of());\n    mapReduceManager.waitForFinish(3, TimeUnit.MINUTES);\n\n    // Start PurchaseHistoryService\n    ServiceManager purchaseHistoryServiceManager = appManager.startService(PurchaseHistoryService.SERVICE_NAME);\n\n    // Wait for service startup\n    purchaseHistoryServiceManager.waitForStatus(true);\n\n    // Test service to retrieve a customer's purchase history\n    URL url = new URL(purchaseHistoryServiceManager.getServiceURL(15, TimeUnit.SECONDS), \"history/joe\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, conn.getResponseCode());\n    String historyJson;\n    try {\n      historyJson = new String(ByteStreams.toByteArray(conn.getInputStream()), Charsets.UTF_8);\n    } finally {\n      conn.disconnect();\n    }\n    PurchaseHistory history = GSON.fromJson(historyJson, PurchaseHistory.class);\n    Assert.assertEquals(\"joe\", history.getCustomer());\n    Assert.assertEquals(2, history.getPurchases().size());\n\n    UserProfile profileFromPurchaseHistory = history.getUserProfile();\n    Assert.assertEquals(profileFromPurchaseHistory.getFirstName(), \"joe\");\n    Assert.assertEquals(profileFromPurchaseHistory.getLastName(), \"bernard\");\n  }","id":28647,"modified_method":"@Test\n  public void test() throws Exception {\n    // Deploy the PurchaseApp application\n    ApplicationManager appManager = deployApplication(PurchaseApp.class);\n\n    // Start PurchaseFlow\n    FlowManager flowManager = appManager.getFlowManager(\"PurchaseFlow\");\n    flowManager.start();\n\n    // Send stream events to the \"purchaseStream\" Stream\n    StreamManager streamManager = getStreamManager(\"purchaseStream\");\n    streamManager.send(\"bob bought 3 apples for $30\");\n    streamManager.send(\"joe bought 1 apple for $100\");\n    streamManager.send(\"joe bought 10 pineapples for $20\");\n    streamManager.send(\"cat bought 3 bottles for $12\");\n    streamManager.send(\"cat bought 2 pops for $14\");\n\n    try {\n      // Wait for the last Flowlet processing 5 events, or at most 5 seconds\n      RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"PurchaseHistory\", \"PurchaseFlow\", \"collector\");\n      metrics.waitForProcessed(5, 15, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n    }\n\n    ServiceManager userProfileServiceManager = getUserProfileServiceManager(appManager);\n\n    // Add customer's profile information\n    URL userProfileUrl = new URL(userProfileServiceManager.getServiceURL(15, TimeUnit.SECONDS),\n                                    UserProfileServiceHandler.USER_ENDPOINT);\n    HttpURLConnection userProfileConnection = (HttpURLConnection) userProfileUrl.openConnection();\n    String userProfileJson = \"{'id' : 'joe', 'firstName': 'joe', 'lastName':'bernard', 'categories': ['fruits']}\";\n\n    try {\n      userProfileConnection.setDoOutput(true);\n      userProfileConnection.setRequestMethod(\"POST\");\n      userProfileConnection.getOutputStream().write(userProfileJson.getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, userProfileConnection.getResponseCode());\n    } finally {\n      userProfileConnection.disconnect();\n    }\n\n    // Test service to retrieve customer's profile information\n    userProfileUrl = new URL(userProfileServiceManager.getServiceURL(15, TimeUnit.SECONDS),\n                                    UserProfileServiceHandler.USER_ENDPOINT + \"/joe\");\n    userProfileConnection = (HttpURLConnection) userProfileUrl.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, userProfileConnection.getResponseCode());\n    String customerJson;\n    try {\n      customerJson = new String(ByteStreams.toByteArray(userProfileConnection.getInputStream()), Charsets.UTF_8);\n    } finally {\n      userProfileConnection.disconnect();\n    }\n\n    UserProfile profileFromService = GSON.fromJson(customerJson, UserProfile.class);\n    Assert.assertEquals(profileFromService.getFirstName(), \"joe\");\n    Assert.assertEquals(profileFromService.getLastName(), \"bernard\");\n\n    // Run PurchaseHistoryWorkflow which will process the data\n    MapReduceManager mapReduceManager = appManager.getMapReduceManager(\"PurchaseHistoryBuilder\");\n    mapReduceManager.start();\n    mapReduceManager.waitForFinish(3, TimeUnit.MINUTES);\n\n    // Start PurchaseHistoryService\n    ServiceManager purchaseHistoryServiceManager = appManager.getServiceManager(PurchaseHistoryService.SERVICE_NAME);\n    purchaseHistoryServiceManager.start();\n\n    // Wait for service startup\n    purchaseHistoryServiceManager.waitForStatus(true);\n\n    // Test service to retrieve a customer's purchase history\n    URL url = new URL(purchaseHistoryServiceManager.getServiceURL(15, TimeUnit.SECONDS), \"history/joe\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, conn.getResponseCode());\n    String historyJson;\n    try {\n      historyJson = new String(ByteStreams.toByteArray(conn.getInputStream()), Charsets.UTF_8);\n    } finally {\n      conn.disconnect();\n    }\n    PurchaseHistory history = GSON.fromJson(historyJson, PurchaseHistory.class);\n    Assert.assertEquals(\"joe\", history.getCustomer());\n    Assert.assertEquals(2, history.getPurchases().size());\n\n    UserProfile profileFromPurchaseHistory = history.getUserProfile();\n    Assert.assertEquals(profileFromPurchaseHistory.getFirstName(), \"joe\");\n    Assert.assertEquals(profileFromPurchaseHistory.getLastName(), \"bernard\");\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws Exception {\n    // Deploy the Application\n    ApplicationManager appManager = deployApplication(SparkKMeansApp.class);\n    // Start the Flow\n    FlowManager flowManager = appManager.startFlow(\"PointsFlow\");\n    // Send a few points to the stream\n    StreamManager streamManager = getStreamManager(\"pointsStream\");\n    streamManager.send(\"10.6 519.2 110.3\");\n    streamManager.send(\"10.6 518.1 110.1\");\n    streamManager.send(\"10.6 519.6 109.9\");\n    streamManager.send(\"10.6 517.9 108.9\");\n    streamManager.send(\"10.7 518 109.2\");\n\n    //  Wait for the events to be processed, or at most 5 seconds\n    RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"SparkKMeans\", \"PointsFlow\", \"reader\");\n    metrics.waitForProcessed(3, 5, TimeUnit.SECONDS);\n\n    // Start a Spark Program\n    SparkManager sparkManager = appManager.startSpark(\"SparkKMeansProgram\");\n    sparkManager.waitForFinish(60, TimeUnit.SECONDS);\n\n    flowManager.stop();\n\n    // Start CentersService\n    ServiceManager serviceManager = appManager.startService(SparkKMeansApp.CentersService.SERVICE_NAME);\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    // Request data and verify it\n    String response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"centers/1\"));\n    String[] coordinates = response.split(\",\");\n    Assert.assertTrue(coordinates.length == 3);\n    for (String coordinate : coordinates) {\n      double value = Double.parseDouble(coordinate);\n      Assert.assertTrue(value > 0);\n    }\n\n    // Request data by incorrect index and verify response\n    URL url = new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"centers/10\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    try {\n      Assert.assertEquals(HttpURLConnection.HTTP_NO_CONTENT, conn.getResponseCode());\n    } finally {\n      conn.disconnect();\n    }\n  }","id":28648,"modified_method":"@Test\n  public void test() throws Exception {\n    // Deploy the Application\n    ApplicationManager appManager = deployApplication(SparkKMeansApp.class);\n    // Start the Flow\n    FlowManager flowManager = appManager.getFlowManager(\"PointsFlow\");\n    flowManager.start();\n    // Send a few points to the stream\n    StreamManager streamManager = getStreamManager(\"pointsStream\");\n    streamManager.send(\"10.6 519.2 110.3\");\n    streamManager.send(\"10.6 518.1 110.1\");\n    streamManager.send(\"10.6 519.6 109.9\");\n    streamManager.send(\"10.6 517.9 108.9\");\n    streamManager.send(\"10.7 518 109.2\");\n\n    //  Wait for the events to be processed, or at most 5 seconds\n    RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"SparkKMeans\", \"PointsFlow\", \"reader\");\n    metrics.waitForProcessed(3, 5, TimeUnit.SECONDS);\n\n    // Start a Spark Program\n    SparkManager sparkManager = appManager.getSparkManager(\"SparkKMeansProgram\");\n    sparkManager.start();\n    sparkManager.waitForFinish(60, TimeUnit.SECONDS);\n\n    flowManager.stop();\n\n    // Start CentersService\n    ServiceManager serviceManager = appManager.getServiceManager(SparkKMeansApp.CentersService.SERVICE_NAME);\n    serviceManager.start();\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    // Request data and verify it\n    String response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"centers/1\"));\n    String[] coordinates = response.split(\",\");\n    Assert.assertTrue(coordinates.length == 3);\n    for (String coordinate : coordinates) {\n      double value = Double.parseDouble(coordinate);\n      Assert.assertTrue(value > 0);\n    }\n\n    // Request data by incorrect index and verify response\n    URL url = new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"centers/10\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    try {\n      Assert.assertEquals(HttpURLConnection.HTTP_NO_CONTENT, conn.getResponseCode());\n    } finally {\n      conn.disconnect();\n    }\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSparkMetrics() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestSparkMetricsIntegrationApp.class);\n    SparkManager sparkManager = applicationManager.startSpark(TestSparkMetricsIntegrationApp.APP_SPARK_NAME);\n    sparkManager.waitForFinish(120, TimeUnit.SECONDS);\n\n    Assert.assertTrue(getSparkMetric(TestSparkMetricsIntegrationApp.APP_NAME,\n                                     TestSparkMetricsIntegrationApp.APP_SPARK_NAME, METRICS_KEY) > 0);\n    //TODO: Add test to check user metrics once the support is added: CDAP-765\n  }","id":28649,"modified_method":"@Test\n  public void testSparkMetrics() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestSparkMetricsIntegrationApp.class);\n    SparkManager sparkManager = applicationManager.getSparkManager(TestSparkMetricsIntegrationApp.APP_SPARK_NAME);\n    sparkManager.start();\n    sparkManager.waitForFinish(120, TimeUnit.SECONDS);\n\n    Assert.assertTrue(getSparkMetric(TestSparkMetricsIntegrationApp.APP_NAME,\n                                     TestSparkMetricsIntegrationApp.APP_SPARK_NAME, METRICS_KEY) > 0);\n    //TODO: Add test to check user metrics once the support is added: CDAP-765\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws Exception {\n    // Deploy the SparkPageRankApp\n    ApplicationManager appManager = deployApplication(SparkPageRankApp.class);\n\n    // Send a stream events to the Stream\n    StreamManager streamManager = getStreamManager(\"backlinkURLStream\");\n    streamManager.send(URL_PAIR12);\n    streamManager.send(URL_PAIR13);\n    streamManager.send(URL_PAIR21);\n    streamManager.send(URL_PAIR31);\n\n    // Start GoogleTypePR\n    ServiceManager transformServiceManager = appManager.startService(SparkPageRankApp.GOOGLE_TYPE_PR_SERVICE_NAME);\n    // Start CentersService\n    ServiceManager serviceManager = appManager.startService(SparkPageRankApp.RANKS_SERVICE_NAME);\n\n    // Wait for GoogleTypePR service to start since the Spark program needs it\n    transformServiceManager.waitForStatus(true);\n\n    // Start the SparkPageRankProgram\n    SparkManager sparkManager = appManager.startSpark(\"SparkPageRankProgram\");\n    sparkManager.waitForFinish(60, TimeUnit.SECONDS);\n\n    // Wait for ranks service to start\n    serviceManager.waitForStatus(true);\n\n    String response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS),\n                                             \"rank?url=http://example.com/page1\"));\n    Assert.assertEquals(RANK, response);\n  }","id":28650,"modified_method":"@Test\n  public void test() throws Exception {\n    // Deploy the SparkPageRankApp\n    ApplicationManager appManager = deployApplication(SparkPageRankApp.class);\n\n    // Send a stream events to the Stream\n    StreamManager streamManager = getStreamManager(\"backlinkURLStream\");\n    streamManager.send(URL_PAIR12);\n    streamManager.send(URL_PAIR13);\n    streamManager.send(URL_PAIR21);\n    streamManager.send(URL_PAIR31);\n\n    // Start GoogleTypePR\n    ServiceManager transformServiceManager = appManager.getServiceManager(SparkPageRankApp.GOOGLE_TYPE_PR_SERVICE_NAME);\n    transformServiceManager.start();\n    // Start CentersService\n    ServiceManager serviceManager = appManager.getServiceManager(SparkPageRankApp.RANKS_SERVICE_NAME);\n    serviceManager.start();\n\n    // Wait for GoogleTypePR service to start since the Spark program needs it\n    transformServiceManager.waitForStatus(true);\n\n    // Start the SparkPageRankProgram\n    SparkManager sparkManager = appManager.getSparkManager(\"SparkPageRankProgram\");\n    sparkManager.start();\n    sparkManager.waitForFinish(60, TimeUnit.SECONDS);\n\n    // Wait for ranks service to start\n    serviceManager.waitForStatus(true);\n\n    String response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS),\n                                             \"rank?url=http://example.com/page1\"));\n    Assert.assertEquals(RANK, response);\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Starts a Service\n   */\n  private void startService(ApplicationManager applicationManager) {\n    ServiceManager serviceManager = applicationManager.startService(TestSparkServiceIntegrationApp.SERVICE_NAME);\n    try {\n      serviceManager.waitForStatus(true);\n    } catch (InterruptedException e) {\n      LOG.error(\"Failed to start {} service\", TestSparkServiceIntegrationApp.SERVICE_NAME, e);\n      throw Throwables.propagate(e);\n    }\n  }","id":28651,"modified_method":"/**\n   * Starts a Service\n   */\n  private void startService(ApplicationManager applicationManager) {\n    ServiceManager serviceManager = applicationManager.getServiceManager(TestSparkServiceIntegrationApp.SERVICE_NAME);\n    try {\n      serviceManager.start();\n      serviceManager.waitForStatus(true);\n    } catch (InterruptedException e) {\n      LOG.error(\"Failed to start {} service\", TestSparkServiceIntegrationApp.SERVICE_NAME, e);\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSparkWithService() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestSparkServiceIntegrationApp.class);\n    startService(applicationManager);\n\n    SparkManager sparkManager = applicationManager.startSpark(\n      TestSparkServiceIntegrationApp.SparkServiceProgram.class.getSimpleName());\n    sparkManager.waitForFinish(120, TimeUnit.SECONDS);\n\n    DataSetManager<KeyValueTable> datasetManager = applicationManager.getDataSet(\"result\");\n    KeyValueTable results = datasetManager.get();\n    for (int i = 1; i <= 5; i++) {\n      byte[] key = String.valueOf(i).getBytes(Charsets.UTF_8);\n      Assert.assertEquals((i * i), Integer.parseInt(Bytes.toString(results.read(key))));\n    }\n  }","id":28652,"modified_method":"@Test\n  public void testSparkWithService() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestSparkServiceIntegrationApp.class);\n    startService(applicationManager);\n\n    SparkManager sparkManager = applicationManager.getSparkManager(\n      TestSparkServiceIntegrationApp.SparkServiceProgram.class.getSimpleName());\n    sparkManager.start();\n    sparkManager.waitForFinish(120, TimeUnit.SECONDS);\n\n    DataSetManager<KeyValueTable> datasetManager = applicationManager.getDataSet(\"result\");\n    KeyValueTable results = datasetManager.get();\n    for (int i = 1; i <= 5; i++) {\n      byte[] key = String.valueOf(i).getBytes(Charsets.UTF_8);\n      Assert.assertEquals((i * i), Integer.parseInt(Bytes.toString(results.read(key))));\n    }\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSparkWithStream() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestSparkStreamIntegrationApp.class);\n    StreamManager streamManager = getStreamManager(\"testStream\");\n    for (int i = 0; i < 50; i++) {\n      streamManager.send(String.valueOf(i));\n    }\n\n    SparkManager sparkManager = applicationManager.startSpark(\"SparkStreamProgram\");\n    sparkManager.waitForFinish(120, TimeUnit.SECONDS);\n\n    // The Spark job simply turns every stream event body into key/value pairs, with key==value.\n    DataSetManager<KeyValueTable> datasetManager = applicationManager.getDataSet(\"result\");\n    KeyValueTable results = datasetManager.get();\n    for (int i = 0; i < 50; i++) {\n      byte[] key = String.valueOf(i).getBytes(Charsets.UTF_8);\n      Assert.assertArrayEquals(key, results.read(key));\n    }\n  }","id":28653,"modified_method":"@Test\n  public void testSparkWithStream() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestSparkStreamIntegrationApp.class);\n    StreamManager streamManager = getStreamManager(\"testStream\");\n    for (int i = 0; i < 50; i++) {\n      streamManager.send(String.valueOf(i));\n    }\n\n    SparkManager sparkManager = applicationManager.getSparkManager(\"SparkStreamProgram\");\n    sparkManager.start();\n    sparkManager.waitForFinish(120, TimeUnit.SECONDS);\n\n    // The Spark job simply turns every stream event body into key/value pairs, with key==value.\n    DataSetManager<KeyValueTable> datasetManager = applicationManager.getDataSet(\"result\");\n    KeyValueTable results = datasetManager.get();\n    for (int i = 0; i < 50; i++) {\n      byte[] key = String.valueOf(i).getBytes(Charsets.UTF_8);\n      Assert.assertArrayEquals(key, results.read(key));\n    }\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testPartitionedCounting() throws Exception {\n\n    // deploy the application and start the upload service\n    ApplicationManager appManager = deployApplication(SportResults.class);\n    ServiceManager serviceManager = appManager.startService(\"UploadService\");\n    serviceManager.waitForStatus(true);\n\n    // upload a few dummy results\n    URL url = serviceManager.getServiceURL();\n    uploadResults(url, \"fantasy\", 2014, FANTASY_2014);\n    uploadResults(url, \"fantasy\", 2015, FANTASY_2015);\n    uploadResults(url, \"critters\", 2014, CRITTERS_2014);\n\n    // start a map/reduce that counts all seasons for the fantasy league\n    MapReduceManager mrManager = appManager.startMapReduce(\"ScoreCounter\", ImmutableMap.of(\"league\", \"fantasy\"));\n    mrManager.waitForFinish(5, TimeUnit.MINUTES); // should be much faster, though\n\n    // validate the output by reading directly from the file set\n    DataSetManager<PartitionedFileSet> dataSetManager = getDataset(\"totals\");\n    PartitionedFileSet totals = dataSetManager.get();\n    Partition partition = totals.getPartition(PartitionKey.builder().addStringField(\"league\", \"fantasy\").build());\n    Assert.assertNotNull(partition);\n    Location location = partition.getLocation();\n\n    // find the part file that has the actual results\n    Assert.assertTrue(location.isDirectory());\n    for (Location file : location.list()) {\n      if (file.getName().startsWith(\"part\")) {\n        location = file;\n      }\n    }\n    BufferedReader reader = new BufferedReader(new InputStreamReader(location.getInputStream()));\n\n    // validate each line\n    Map<String, String[]> expected = ImmutableMap.of(\n      \"My Team\", new String[] { \"My Team\", \"2\", \"0\", \"1\", \"53\", \"65\" },\n      \"Your Team\", new String[] { \"Your Team\", \"1\", \"0\", \"2\", \"63\", \"60\" },\n      \"Other Team\", new String[] { \"Other Team\", \"1\", \"0\", \"1\", \"40\", \"31\" });\n    while (true) {\n      String line = reader.readLine();\n      if (line == null) {\n        break;\n      }\n      String[] fields = line.split(\",\");\n      Assert.assertArrayEquals(expected.get(fields[0]), fields);\n    }\n\n    // verify using SQL\n    // query with SQL\n    Connection connection = getQueryClient();\n    ResultSet results = connection\n      .prepareStatement(\"SELECT wins, ties, losses, scored, conceded \" +\n                          \"FROM dataset_totals WHERE team = 'My Team' AND league = 'fantasy'\")\n      .executeQuery();\n\n    // should return only one row, with correct time fields\n    Assert.assertTrue(results.next());\n    Assert.assertEquals(2, results.getInt(1));\n    Assert.assertEquals(0, results.getInt(2));\n    Assert.assertEquals(1, results.getInt(3));\n    Assert.assertEquals(53, results.getInt(4));\n    Assert.assertEquals(65, results.getInt(5));\n    Assert.assertFalse(results.next());\n  }","id":28654,"modified_method":"@Test\n  public void testPartitionedCounting() throws Exception {\n\n    // deploy the application and start the upload service\n    ApplicationManager appManager = deployApplication(SportResults.class);\n    ServiceManager serviceManager = appManager.getServiceManager(\"UploadService\");\n    serviceManager.start();\n    serviceManager.waitForStatus(true);\n\n    // upload a few dummy results\n    URL url = serviceManager.getServiceURL();\n    uploadResults(url, \"fantasy\", 2014, FANTASY_2014);\n    uploadResults(url, \"fantasy\", 2015, FANTASY_2015);\n    uploadResults(url, \"critters\", 2014, CRITTERS_2014);\n\n    // start a map/reduce that counts all seasons for the fantasy league\n    MapReduceManager mrManager = appManager.getMapReduceManager(\"ScoreCounter\");\n    mrManager.start(ImmutableMap.of(\"league\", \"fantasy\"));\n    mrManager.waitForFinish(5, TimeUnit.MINUTES); // should be much faster, though\n\n    // validate the output by reading directly from the file set\n    DataSetManager<PartitionedFileSet> dataSetManager = getDataset(\"totals\");\n    PartitionedFileSet totals = dataSetManager.get();\n    Partition partition = totals.getPartition(PartitionKey.builder().addStringField(\"league\", \"fantasy\").build());\n    Assert.assertNotNull(partition);\n    Location location = partition.getLocation();\n\n    // find the part file that has the actual results\n    Assert.assertTrue(location.isDirectory());\n    for (Location file : location.list()) {\n      if (file.getName().startsWith(\"part\")) {\n        location = file;\n      }\n    }\n    BufferedReader reader = new BufferedReader(new InputStreamReader(location.getInputStream()));\n\n    // validate each line\n    Map<String, String[]> expected = ImmutableMap.of(\n      \"My Team\", new String[] { \"My Team\", \"2\", \"0\", \"1\", \"53\", \"65\" },\n      \"Your Team\", new String[] { \"Your Team\", \"1\", \"0\", \"2\", \"63\", \"60\" },\n      \"Other Team\", new String[] { \"Other Team\", \"1\", \"0\", \"1\", \"40\", \"31\" });\n    while (true) {\n      String line = reader.readLine();\n      if (line == null) {\n        break;\n      }\n      String[] fields = line.split(\",\");\n      Assert.assertArrayEquals(expected.get(fields[0]), fields);\n    }\n\n    // verify using SQL\n    // query with SQL\n    Connection connection = getQueryClient();\n    ResultSet results = connection\n      .prepareStatement(\"SELECT wins, ties, losses, scored, conceded \" +\n                          \"FROM dataset_totals WHERE team = 'My Team' AND league = 'fantasy'\")\n      .executeQuery();\n\n    // should return only one row, with correct time fields\n    Assert.assertTrue(results.next());\n    Assert.assertEquals(2, results.getInt(1));\n    Assert.assertEquals(0, results.getInt(2));\n    Assert.assertEquals(1, results.getInt(3));\n    Assert.assertEquals(53, results.getInt(4));\n    Assert.assertEquals(65, results.getInt(5));\n    Assert.assertFalse(results.next());\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testStreamConversion() throws Exception {\n\n    // Deploy the PurchaseApp application\n    ApplicationManager appManager = deployApplication(StreamConversionApp.class);\n\n    // send some data to the events stream\n    StreamManager streamManager = getStreamManager(\"events\");\n    streamManager.send(\"15\");\n    streamManager.send(\"16\");\n    streamManager.send(\"17\");\n\n    // record the current time\n    final long startTime = System.currentTimeMillis();\n\n    // run the mapreduce\n    MapReduceManager mapReduceManager =\n      appManager.startMapReduce(\"StreamConversionMapReduce\", RuntimeArguments.NO_ARGUMENTS);\n    mapReduceManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    // verify the single partition in the file set\n    long partitionTime = assertWithRetry(new Callable<Long>() {\n      @Override\n      public Long call() throws Exception {\n        DataSetManager<TimePartitionedFileSet> fileSetManager = getDataset(\"converted\");\n        TimePartitionedFileSet converted = fileSetManager.get();\n        Set<TimePartition> partitions = converted.getPartitionsByTime(startTime, System.currentTimeMillis());\n        Assert.assertEquals(1, partitions.size());\n        return partitions.iterator().next().getTime();\n      }\n    }, 15L, TimeUnit.SECONDS, 100L, TimeUnit.MILLISECONDS);\n\n    // we must round down the start time to the full minute before we compare the partition time\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTimeInMillis(startTime);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MILLISECOND, 0);\n    long startMinute = calendar.getTimeInMillis();\n\n    // partition time should be the logical start time of the MapReduce. That is between start and now.\n    Assert.assertTrue(partitionTime >= startMinute);\n    Assert.assertTrue(partitionTime <= System.currentTimeMillis());\n\n    // extract fields from partition time\n    calendar.setTimeInMillis(partitionTime);\n    int year = calendar.get(Calendar.YEAR);\n    int month = calendar.get(Calendar.MONTH) + 1;\n    int day = calendar.get(Calendar.DAY_OF_MONTH);\n    int hour = calendar.get(Calendar.HOUR_OF_DAY);\n    int minute = calendar.get(Calendar.MINUTE);\n\n    // query with SQL\n    Connection connection = getQueryClient();\n    ResultSet results = connection.prepareStatement(\"SELECT year, month, day, hour, minute \" +\n                                                      \"FROM dataset_converted \" +\n                                                      \"WHERE body = '17'\").executeQuery();\n\n    // should return only one row, with correct time fields\n    Assert.assertTrue(results.next());\n    Assert.assertEquals(year, results.getInt(1));\n    Assert.assertEquals(month, results.getInt(2));\n    Assert.assertEquals(day, results.getInt(3));\n    Assert.assertEquals(hour, results.getInt(4));\n    Assert.assertEquals(minute, results.getInt(5));\n    Assert.assertFalse(results.next());\n  }","id":28655,"modified_method":"@Test\n  public void testStreamConversion() throws Exception {\n\n    // Deploy the PurchaseApp application\n    ApplicationManager appManager = deployApplication(StreamConversionApp.class);\n\n    // send some data to the events stream\n    StreamManager streamManager = getStreamManager(\"events\");\n    streamManager.send(\"15\");\n    streamManager.send(\"16\");\n    streamManager.send(\"17\");\n\n    // record the current time\n    final long startTime = System.currentTimeMillis();\n\n    // run the mapreduce\n    MapReduceManager mapReduceManager = appManager.getMapReduceManager(\"StreamConversionMapReduce\");\n    mapReduceManager.start(RuntimeArguments.NO_ARGUMENTS);\n    mapReduceManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    // verify the single partition in the file set\n    long partitionTime = assertWithRetry(new Callable<Long>() {\n      @Override\n      public Long call() throws Exception {\n        DataSetManager<TimePartitionedFileSet> fileSetManager = getDataset(\"converted\");\n        TimePartitionedFileSet converted = fileSetManager.get();\n        Set<TimePartition> partitions = converted.getPartitionsByTime(startTime, System.currentTimeMillis());\n        Assert.assertEquals(1, partitions.size());\n        return partitions.iterator().next().getTime();\n      }\n    }, 15L, TimeUnit.SECONDS, 100L, TimeUnit.MILLISECONDS);\n\n    // we must round down the start time to the full minute before we compare the partition time\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTimeInMillis(startTime);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MILLISECOND, 0);\n    long startMinute = calendar.getTimeInMillis();\n\n    // partition time should be the logical start time of the MapReduce. That is between start and now.\n    Assert.assertTrue(partitionTime >= startMinute);\n    Assert.assertTrue(partitionTime <= System.currentTimeMillis());\n\n    // extract fields from partition time\n    calendar.setTimeInMillis(partitionTime);\n    int year = calendar.get(Calendar.YEAR);\n    int month = calendar.get(Calendar.MONTH) + 1;\n    int day = calendar.get(Calendar.DAY_OF_MONTH);\n    int hour = calendar.get(Calendar.HOUR_OF_DAY);\n    int minute = calendar.get(Calendar.MINUTE);\n\n    // query with SQL\n    Connection connection = getQueryClient();\n    ResultSet results = connection.prepareStatement(\"SELECT year, month, day, hour, minute \" +\n                                                      \"FROM dataset_converted \" +\n                                                      \"WHERE body = '17'\").executeQuery();\n\n    // should return only one row, with correct time fields\n    Assert.assertTrue(results.next());\n    Assert.assertEquals(year, results.getInt(1));\n    Assert.assertEquals(month, results.getInt(2));\n    Assert.assertEquals(day, results.getInt(3));\n    Assert.assertEquals(hour, results.getInt(4));\n    Assert.assertEquals(minute, results.getInt(5));\n    Assert.assertFalse(results.next());\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testApp() throws Exception {\n    // Deploy the application\n    ApplicationManager appManager = deployApplication(AppWithCube.class);\n\n    ServiceManager serviceManager = appManager.startService(AppWithCube.SERVICE_NAME);\n    try {\n      serviceManager.waitForStatus(true);\n      URL url = serviceManager.getServiceURL();\n\n      long tsInSec = System.currentTimeMillis() / 1000;\n\n      // round to a minute for testing minute resolution\n      tsInSec = (tsInSec / 60) * 60;\n\n      // add couple facts\n      add(url, ImmutableList.of(new CubeFact(tsInSec)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"click\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1)));\n\n      add(url, ImmutableList.of(new CubeFact(tsInSec)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"click\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1),\n                                new CubeFact(tsInSec + 1)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"back\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1),\n                                new CubeFact(tsInSec + 2)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"click\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1)));\n\n      // search for tags\n      Collection<DimensionValue> tags =\n        searchDimensionValue(url, new CubeExploreQuery(tsInSec - 60, tsInSec + 60, 1, 100,\n                                                       new ArrayList<DimensionValue>()));\n      Assert.assertEquals(1, tags.size());\n      DimensionValue tv = tags.iterator().next();\n      Assert.assertEquals(\"user\", tv.getName());\n      Assert.assertEquals(\"alex\", tv.getValue());\n\n      tags = searchDimensionValue(url,\n                                  CubeExploreQuery.builder()\n                                    .from()\n                                      .resolution(1, TimeUnit.SECONDS)\n                                    .where()\n                                      .dimension(\"user\", \"alex\")\n                                      .timeRange(tsInSec - 60, tsInSec + 60)\n                                    .limit(100)\n                                    .build());\n      Assert.assertEquals(2, tags.size());\n      Iterator<DimensionValue> iterator = tags.iterator();\n      tv = iterator.next();\n      Assert.assertEquals(\"action\", tv.getName());\n      Assert.assertEquals(\"back\", tv.getValue());\n      tv = iterator.next();\n      Assert.assertEquals(\"action\", tv.getName());\n      Assert.assertEquals(\"click\", tv.getValue());\n\n      // search for measures\n      Collection<String> measures =\n        searchMeasure(url, new CubeExploreQuery(tsInSec - 60, tsInSec + 60, 1, 100,\n                                                ImmutableList.of(new DimensionValue(\"user\", \"alex\"))));\n      Assert.assertEquals(1, measures.size());\n      String measure = measures.iterator().next();\n      Assert.assertEquals(\"count\", measure);\n\n      // query for data\n\n      // 1-sec resolution\n      Collection<TimeSeries> data =\n        query(url,\n              CubeQuery.builder()\n                .select()\n                  .measurement(\"count\", AggregationFunction.SUM)\n                .from(null)\n                  .resolution(1, TimeUnit.SECONDS)\n                .where()\n                  .dimension(\"action\", \"click\")\n                  .timeRange(tsInSec - 60, tsInSec + 60)\n                .limit(100)\n                .build());\n      Assert.assertEquals(1, data.size());\n      TimeSeries series = data.iterator().next();\n      List<TimeValue> timeValues = series.getTimeValues();\n      Assert.assertEquals(2, timeValues.size());\n      TimeValue timeValue = timeValues.get(0);\n      Assert.assertEquals(tsInSec, timeValue.getTimestamp());\n      Assert.assertEquals(2, timeValue.getValue());\n      timeValue = timeValues.get(1);\n      Assert.assertEquals(tsInSec + 2, timeValue.getTimestamp());\n      Assert.assertEquals(1, timeValue.getValue());\n\n      // 60-sec resolution\n      data = query(url, new CubeQuery(null, tsInSec - 60, tsInSec + 60, 60, 100,\n                                      ImmutableMap.of(\"count\", AggregationFunction.SUM),\n                                      ImmutableMap.of(\"action\", \"click\"), new ArrayList<String>(), null));\n      Assert.assertEquals(1, data.size());\n      series = data.iterator().next();\n      timeValues = series.getTimeValues();\n      Assert.assertEquals(1, timeValues.size());\n      timeValue = timeValues.get(0);\n      Assert.assertEquals(tsInSec, timeValue.getTimestamp());\n      Assert.assertEquals(3, timeValue.getValue());\n\n    } finally {\n      serviceManager.stop();\n      serviceManager.waitForStatus(false);\n    }\n  }","id":28656,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testApp() throws Exception {\n    // Deploy the application\n    ApplicationManager appManager = deployApplication(AppWithCube.class);\n\n    ServiceManager serviceManager = appManager.getServiceManager(AppWithCube.SERVICE_NAME);\n    try {\n      serviceManager.start();\n      serviceManager.waitForStatus(true);\n      URL url = serviceManager.getServiceURL();\n\n      long tsInSec = System.currentTimeMillis() / 1000;\n\n      // round to a minute for testing minute resolution\n      tsInSec = (tsInSec / 60) * 60;\n\n      // add couple facts\n      add(url, ImmutableList.of(new CubeFact(tsInSec)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"click\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1)));\n\n      add(url, ImmutableList.of(new CubeFact(tsInSec)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"click\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1),\n                                new CubeFact(tsInSec + 1)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"back\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1),\n                                new CubeFact(tsInSec + 2)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"click\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1)));\n\n      // search for tags\n      Collection<DimensionValue> tags =\n        searchDimensionValue(url, new CubeExploreQuery(tsInSec - 60, tsInSec + 60, 1, 100,\n                                                       new ArrayList<DimensionValue>()));\n      Assert.assertEquals(1, tags.size());\n      DimensionValue tv = tags.iterator().next();\n      Assert.assertEquals(\"user\", tv.getName());\n      Assert.assertEquals(\"alex\", tv.getValue());\n\n      tags = searchDimensionValue(url,\n                                  CubeExploreQuery.builder()\n                                    .from()\n                                      .resolution(1, TimeUnit.SECONDS)\n                                    .where()\n                                      .dimension(\"user\", \"alex\")\n                                      .timeRange(tsInSec - 60, tsInSec + 60)\n                                    .limit(100)\n                                    .build());\n      Assert.assertEquals(2, tags.size());\n      Iterator<DimensionValue> iterator = tags.iterator();\n      tv = iterator.next();\n      Assert.assertEquals(\"action\", tv.getName());\n      Assert.assertEquals(\"back\", tv.getValue());\n      tv = iterator.next();\n      Assert.assertEquals(\"action\", tv.getName());\n      Assert.assertEquals(\"click\", tv.getValue());\n\n      // search for measures\n      Collection<String> measures =\n        searchMeasure(url, new CubeExploreQuery(tsInSec - 60, tsInSec + 60, 1, 100,\n                                                ImmutableList.of(new DimensionValue(\"user\", \"alex\"))));\n      Assert.assertEquals(1, measures.size());\n      String measure = measures.iterator().next();\n      Assert.assertEquals(\"count\", measure);\n\n      // query for data\n\n      // 1-sec resolution\n      Collection<TimeSeries> data =\n        query(url,\n              CubeQuery.builder()\n                .select()\n                  .measurement(\"count\", AggregationFunction.SUM)\n                .from(null)\n                  .resolution(1, TimeUnit.SECONDS)\n                .where()\n                  .dimension(\"action\", \"click\")\n                  .timeRange(tsInSec - 60, tsInSec + 60)\n                .limit(100)\n                .build());\n      Assert.assertEquals(1, data.size());\n      TimeSeries series = data.iterator().next();\n      List<TimeValue> timeValues = series.getTimeValues();\n      Assert.assertEquals(2, timeValues.size());\n      TimeValue timeValue = timeValues.get(0);\n      Assert.assertEquals(tsInSec, timeValue.getTimestamp());\n      Assert.assertEquals(2, timeValue.getValue());\n      timeValue = timeValues.get(1);\n      Assert.assertEquals(tsInSec + 2, timeValue.getTimestamp());\n      Assert.assertEquals(1, timeValue.getValue());\n\n      // 60-sec resolution\n      data = query(url, new CubeQuery(null, tsInSec - 60, tsInSec + 60, 60, 100,\n                                      ImmutableMap.of(\"count\", AggregationFunction.SUM),\n                                      ImmutableMap.of(\"action\", \"click\"), new ArrayList<String>(), null));\n      Assert.assertEquals(1, data.size());\n      series = data.iterator().next();\n      timeValues = series.getTimeValues();\n      Assert.assertEquals(1, timeValues.size());\n      timeValue = timeValues.get(0);\n      Assert.assertEquals(tsInSec, timeValue.getTimestamp());\n      Assert.assertEquals(3, timeValue.getValue());\n\n    } finally {\n      serviceManager.stop();\n      serviceManager.waitForStatus(false);\n    }\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testBundleJar() throws Exception {\n    File helloWorldJar = new File(TestBundleJarApp.class.getClassLoader().getResource(\"helloworld.jar\").toURI());\n    ApplicationManager applicationManager = deployApplication(BundleJarApp.class, helloWorldJar);\n    FlowManager flowManager = applicationManager.startFlow(\"SimpleFlow\");\n    StreamManager streamManager = getStreamManager(\"simpleInputStream\");\n    for (int i = 0; i < 5; i++) {\n      streamManager.send(\"test\" + i + \":\" + i);\n    }\n\n    // Check the flowlet metrics\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"BundleJarApp\", \"SimpleFlow\", \"simpleFlowlet\");\n    flowletMetrics.waitForProcessed(5, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, flowletMetrics.getException());\n    flowManager.stop();\n\n    // Query the result\n    ServiceManager serviceManager = applicationManager.startService(\"SimpleGetInput\");\n\n    // Verify the query result\n    String queryResult = callServiceGet(serviceManager.getServiceURL(), \"/get/test1\");\n    String expectedQueryResult = new Gson().toJson(\n      ImmutableMap.of(\"test1\", \"1\" + BundleJarApp.EXPECTED_LOAD_TEST_CLASSES_OUTPUT));\n    Assert.assertEquals(expectedQueryResult, queryResult);\n    serviceManager.stop();\n\n    serviceManager = applicationManager.startService(\"PrintService\");\n\n    String helloWorldClassName = \"hello.HelloWorld\";\n    String result = callServiceGet(serviceManager.getServiceURL(), \"/load/\" + helloWorldClassName);\n    String expected = new Gson().toJson(\n      ImmutableMap.of(\"Class.forName\", helloWorldClassName));\n    Assert.assertEquals(expected, result);\n  }","id":28657,"modified_method":"@Test\n  public void testBundleJar() throws Exception {\n    File helloWorldJar = new File(TestBundleJarApp.class.getClassLoader().getResource(\"helloworld.jar\").toURI());\n    ApplicationManager applicationManager = deployApplication(BundleJarApp.class, helloWorldJar);\n    FlowManager flowManager = applicationManager.getFlowManager(\"SimpleFlow\");\n    flowManager.start();\n    StreamManager streamManager = getStreamManager(\"simpleInputStream\");\n    for (int i = 0; i < 5; i++) {\n      streamManager.send(\"test\" + i + \":\" + i);\n    }\n\n    // Check the flowlet metrics\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"BundleJarApp\", \"SimpleFlow\", \"simpleFlowlet\");\n    flowletMetrics.waitForProcessed(5, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, flowletMetrics.getException());\n    flowManager.stop();\n\n    // Query the result\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"SimpleGetInput\");\n    serviceManager.start();\n\n    // Verify the query result\n    String queryResult = callServiceGet(serviceManager.getServiceURL(), \"/get/test1\");\n    String expectedQueryResult = new Gson().toJson(\n      ImmutableMap.of(\"test1\", \"1\" + BundleJarApp.EXPECTED_LOAD_TEST_CLASSES_OUTPUT));\n    Assert.assertEquals(expectedQueryResult, queryResult);\n    serviceManager.stop();\n\n    serviceManager = applicationManager.getServiceManager(\"PrintService\");\n    serviceManager.start();\n\n    String helloWorldClassName = \"hello.HelloWorld\";\n    String result = callServiceGet(serviceManager.getServiceURL(), \"/load/\" + helloWorldClassName);\n    String expected = new Gson().toJson(\n      ImmutableMap.of(\"Class.forName\", helloWorldClassName));\n    Assert.assertEquals(expected, result);\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testMapperDatasetAccess() throws Exception {\n    addDatasetInstance(\"keyValueTable\", \"table1\").create();\n    addDatasetInstance(\"keyValueTable\", \"table2\").create();\n    DataSetManager<KeyValueTable> tableManager = getDataset(\"table1\");\n    KeyValueTable inputTable = tableManager.get();\n    inputTable.write(\"hello\", \"world\");\n    tableManager.flush();\n\n    ApplicationManager appManager = deployApplication(DatasetWithMRApp.class);\n    Map<String, String> argsForMR = ImmutableMap.of(DatasetWithMRApp.INPUT_KEY, \"table1\",\n                                                    DatasetWithMRApp.OUTPUT_KEY, \"table2\");\n    MapReduceManager mrManager = appManager.startMapReduce(DatasetWithMRApp.MAPREDUCE_PROGRAM, argsForMR);\n    mrManager.waitForFinish(5, TimeUnit.MINUTES);\n    appManager.stopAll();\n\n    DataSetManager<KeyValueTable> outTableManager = getDataset(\"table2\");\n    KeyValueTable outputTable = outTableManager.get();\n    Assert.assertEquals(\"world\", Bytes.toString(outputTable.read(\"hello\")));\n  }","id":28658,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testMapperDatasetAccess() throws Exception {\n    addDatasetInstance(\"keyValueTable\", \"table1\").create();\n    addDatasetInstance(\"keyValueTable\", \"table2\").create();\n    DataSetManager<KeyValueTable> tableManager = getDataset(\"table1\");\n    KeyValueTable inputTable = tableManager.get();\n    inputTable.write(\"hello\", \"world\");\n    tableManager.flush();\n\n    ApplicationManager appManager = deployApplication(DatasetWithMRApp.class);\n    Map<String, String> argsForMR = ImmutableMap.of(DatasetWithMRApp.INPUT_KEY, \"table1\",\n                                                    DatasetWithMRApp.OUTPUT_KEY, \"table2\");\n    MapReduceManager mrManager = appManager.getMapReduceManager(DatasetWithMRApp.MAPREDUCE_PROGRAM);\n    mrManager.start(argsForMR);\n    mrManager.waitForFinish(5, TimeUnit.MINUTES);\n    appManager.stopAll();\n\n    DataSetManager<KeyValueTable> outTableManager = getDataset(\"table2\");\n    KeyValueTable outputTable = outTableManager.get();\n    Assert.assertEquals(\"world\", Bytes.toString(outputTable.read(\"hello\")));\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testAppWithWorker() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppWithWorker.class);\n    LOG.info(\"Deployed.\");\n    WorkerManager manager = applicationManager.startWorker(AppWithWorker.WORKER);\n    TimeUnit.MILLISECONDS.sleep(200);\n    manager.stop();\n    applicationManager.stopAll();\n    DataSetManager<KeyValueTable> dataSetManager = getDataset(testSpace, AppWithWorker.DATASET);\n    KeyValueTable table = dataSetManager.get();\n    Assert.assertEquals(AppWithWorker.INITIALIZE, Bytes.toString(table.read(AppWithWorker.INITIALIZE)));\n    Assert.assertEquals(AppWithWorker.RUN, Bytes.toString(table.read(AppWithWorker.RUN)));\n    Assert.assertEquals(AppWithWorker.STOP, Bytes.toString(table.read(AppWithWorker.STOP)));\n  }","id":28659,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testAppWithWorker() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppWithWorker.class);\n    LOG.info(\"Deployed.\");\n    WorkerManager manager = applicationManager.getWorkerManager(AppWithWorker.WORKER);\n    manager.start();\n    TimeUnit.MILLISECONDS.sleep(200);\n    manager.stop();\n    applicationManager.stopAll();\n    DataSetManager<KeyValueTable> dataSetManager = getDataset(testSpace, AppWithWorker.DATASET);\n    KeyValueTable table = dataSetManager.get();\n    Assert.assertEquals(AppWithWorker.INITIALIZE, Bytes.toString(table.read(AppWithWorker.INITIALIZE)));\n    Assert.assertEquals(AppWithWorker.RUN, Bytes.toString(table.read(AppWithWorker.RUN)));\n    Assert.assertEquals(AppWithWorker.STOP, Bytes.toString(table.read(AppWithWorker.STOP)));\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 60000L)\n  public void testFlowletMetricsReset() throws Exception {\n    ApplicationManager appManager = deployApplication(DataSetInitApp.class);\n    FlowManager flowManager = appManager.startFlow(\"DataSetFlow\");\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"DataSetInitApp\", \"DataSetFlow\", \"Consumer\");\n    flowletMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n    flowManager.stop();\n    Assert.assertEquals(1, flowletMetrics.getProcessed());\n    RuntimeStats.resetAll();\n    // check the metrics were deleted after reset\n    Assert.assertEquals(0, flowletMetrics.getProcessed());\n  }","id":28660,"modified_method":"@Test(timeout = 60000L)\n  public void testFlowletMetricsReset() throws Exception {\n    ApplicationManager appManager = deployApplication(DataSetInitApp.class);\n    FlowManager flowManager = appManager.getFlowManager(\"DataSetFlow\");\n    flowManager.start();\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"DataSetInitApp\", \"DataSetFlow\", \"Consumer\");\n    flowletMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n    flowManager.stop();\n    Assert.assertEquals(1, flowletMetrics.getProcessed());\n    RuntimeStats.resetAll();\n    // check the metrics were deleted after reset\n    Assert.assertEquals(0, flowletMetrics.getProcessed());\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testTransactionHandlerService() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppWithServices.class);\n    LOG.info(\"Deployed.\");\n    ServiceManager serviceManager = applicationManager.startService(AppWithServices.TRANSACTIONS_SERVICE_NAME);\n    serviceManager.waitForStatus(true);\n\n    LOG.info(\"Service Started\");\n\n\n    final URL baseUrl = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(baseUrl);\n\n    // Make a request to write in a separate thread and wait for it to return.\n    ExecutorService executorService = Executors.newSingleThreadExecutor();\n    Future<Integer> requestFuture = executorService.submit(new Callable<Integer>() {\n      @Override\n      public Integer call() throws Exception {\n        try {\n          URL url = new URL(String.format(\"%s/write/%s/%s/%d\",\n                                          baseUrl,\n                                          AppWithServices.DATASET_TEST_KEY,\n                                          AppWithServices.DATASET_TEST_VALUE,\n                                          10000));\n          HttpRequest request = HttpRequest.get(url).build();\n          HttpResponse response = HttpRequests.execute(request);\n          return response.getResponseCode();\n        } catch (Exception e) {\n          LOG.error(\"Request thread got exception.\", e);\n          throw Throwables.propagate(e);\n        }\n      }\n    });\n\n    // The dataset should not be written by the time this request is made, since the transaction to write\n    // has not been committed yet.\n    URL url = new URL(String.format(\"%s/read/%s\", baseUrl, AppWithServices.DATASET_TEST_KEY));\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(204, response.getResponseCode());\n\n    // Wait for the transaction to commit.\n    Integer writeStatusCode = requestFuture.get();\n    Assert.assertEquals(200, writeStatusCode.intValue());\n\n    // Make the same request again. By now the transaction should've completed.\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE,\n                        new Gson().fromJson(response.getResponseBodyAsString(), String.class));\n\n    executorService.shutdown();\n    serviceManager.stop();\n    serviceManager.waitForStatus(false);\n\n    DataSetManager<KeyValueTable> dsManager = getDataset(testSpace, AppWithServices.TRANSACTIONS_DATASET_NAME);\n    String value = Bytes.toString(dsManager.get().read(AppWithServices.DESTROY_KEY));\n    Assert.assertEquals(AppWithServices.VALUE, value);\n  }","id":28661,"modified_method":"@Test\n  public void testTransactionHandlerService() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppWithServices.class);\n    LOG.info(\"Deployed.\");\n    ServiceManager serviceManager = applicationManager.getServiceManager(AppWithServices.TRANSACTIONS_SERVICE_NAME);\n    serviceManager.start();\n    serviceManager.waitForStatus(true);\n\n    LOG.info(\"Service Started\");\n\n\n    final URL baseUrl = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(baseUrl);\n\n    // Make a request to write in a separate thread and wait for it to return.\n    ExecutorService executorService = Executors.newSingleThreadExecutor();\n    Future<Integer> requestFuture = executorService.submit(new Callable<Integer>() {\n      @Override\n      public Integer call() throws Exception {\n        try {\n          URL url = new URL(String.format(\"%s/write/%s/%s/%d\",\n                                          baseUrl,\n                                          AppWithServices.DATASET_TEST_KEY,\n                                          AppWithServices.DATASET_TEST_VALUE,\n                                          10000));\n          HttpRequest request = HttpRequest.get(url).build();\n          HttpResponse response = HttpRequests.execute(request);\n          return response.getResponseCode();\n        } catch (Exception e) {\n          LOG.error(\"Request thread got exception.\", e);\n          throw Throwables.propagate(e);\n        }\n      }\n    });\n\n    // The dataset should not be written by the time this request is made, since the transaction to write\n    // has not been committed yet.\n    URL url = new URL(String.format(\"%s/read/%s\", baseUrl, AppWithServices.DATASET_TEST_KEY));\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(204, response.getResponseCode());\n\n    // Wait for the transaction to commit.\n    Integer writeStatusCode = requestFuture.get();\n    Assert.assertEquals(200, writeStatusCode.intValue());\n\n    // Make the same request again. By now the transaction should've completed.\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE,\n                        new Gson().fromJson(response.getResponseBodyAsString(), String.class));\n\n    executorService.shutdown();\n    serviceManager.stop();\n    serviceManager.waitForStatus(false);\n\n    DataSetManager<KeyValueTable> dsManager = getDataset(testSpace, AppWithServices.TRANSACTIONS_DATASET_NAME);\n    String value = Bytes.toString(dsManager.get().read(AppWithServices.DESTROY_KEY));\n    Assert.assertEquals(AppWithServices.VALUE, value);\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 60000L)\n  public void testFlowletInitAndSetInstances() throws Exception {\n    ApplicationManager appManager = deployApplication(testSpace, DataSetInitApp.class);\n    FlowManager flowManager = appManager.startFlow(\"DataSetFlow\");\n\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(), \"DataSetInitApp\",\n                                                                   \"DataSetFlow\", \"Consumer\");\n\n    flowletMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n\n    String generator = \"Generator\";\n    Assert.assertEquals(1, flowManager.getFlowletInstances(generator));\n    // Now change generator to 3 instances\n    flowManager.setFlowletInstances(generator, 3);\n    Assert.assertEquals(3, flowManager.getFlowletInstances(generator));\n\n    // Now should have 3 processed from the consumer flowlet\n    flowletMetrics.waitForProcessed(3, 10, TimeUnit.SECONDS);\n\n    // Now reset to 1 instances\n    flowManager.setFlowletInstances(generator, 1);\n    Assert.assertEquals(1, flowManager.getFlowletInstances(generator));\n\n    // Shouldn't have new item\n    TimeUnit.SECONDS.sleep(3);\n    Assert.assertEquals(3, flowletMetrics.getProcessed());\n\n    // Now set to 2 instances again. Since there is a new instance, expect one new item emitted\n    flowManager.setFlowletInstances(generator, 2);\n    Assert.assertEquals(2, flowManager.getFlowletInstances(generator));\n    flowletMetrics.waitForProcessed(4, 10, TimeUnit.SECONDS);\n\n    flowManager.stop();\n\n    DataSetManager<Table> dataSetManager = getDataset(testSpace, \"conf\");\n    Table confTable = dataSetManager.get();\n\n    Assert.assertEquals(\"generator\", confTable.get(new Get(\"key\", \"column\")).getString(\"column\"));\n\n    dataSetManager.flush();\n  }","id":28662,"modified_method":"@Test(timeout = 60000L)\n  public void testFlowletInitAndSetInstances() throws Exception {\n    ApplicationManager appManager = deployApplication(testSpace, DataSetInitApp.class);\n    FlowManager flowManager = appManager.getFlowManager(\"DataSetFlow\");\n    flowManager.start();\n\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(), \"DataSetInitApp\",\n                                                                   \"DataSetFlow\", \"Consumer\");\n\n    flowletMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n\n    String generator = \"Generator\";\n    Assert.assertEquals(1, flowManager.getFlowletInstances(generator));\n    // Now change generator to 3 instances\n    flowManager.setFlowletInstances(generator, 3);\n    Assert.assertEquals(3, flowManager.getFlowletInstances(generator));\n\n    // Now should have 3 processed from the consumer flowlet\n    flowletMetrics.waitForProcessed(3, 10, TimeUnit.SECONDS);\n\n    // Now reset to 1 instances\n    flowManager.setFlowletInstances(generator, 1);\n    Assert.assertEquals(1, flowManager.getFlowletInstances(generator));\n\n    // Shouldn't have new item\n    TimeUnit.SECONDS.sleep(3);\n    Assert.assertEquals(3, flowletMetrics.getProcessed());\n\n    // Now set to 2 instances again. Since there is a new instance, expect one new item emitted\n    flowManager.setFlowletInstances(generator, 2);\n    Assert.assertEquals(2, flowManager.getFlowletInstances(generator));\n    flowletMetrics.waitForProcessed(4, 10, TimeUnit.SECONDS);\n\n    flowManager.stop();\n\n    DataSetManager<Table> dataSetManager = getDataset(testSpace, \"conf\");\n    Table confTable = dataSetManager.get();\n\n    Assert.assertEquals(\"generator\", confTable.get(new Get(\"key\", \"column\")).getString(\"column\"));\n\n    dataSetManager.flush();\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testWorkerInstances() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppUsingGetServiceURL.class);\n    WorkerManager workerManager = applicationManager.startWorker(AppUsingGetServiceURL.PINGING_WORKER);\n    workerManager.waitForStatus(true);\n\n    int retries = 5;\n\n    // Should be 5 instances when first started.\n    workerInstancesCheck(workerManager, 5, retries);\n\n    // Test increasing instances.\n    workerManager.setInstances(10);\n    workerInstancesCheck(workerManager, 10, retries);\n\n    // Test decreasing instances.\n    workerManager.setInstances(2);\n    workerInstancesCheck(workerManager, 2, retries);\n\n    // Test requesting same number of instances.\n    workerManager.setInstances(2);\n    workerInstancesCheck(workerManager, 2, retries);\n\n    WorkerManager lifecycleWorkerManager = applicationManager.startWorker(AppUsingGetServiceURL.LIFECYCLE_WORKER);\n    lifecycleWorkerManager.waitForStatus(true);\n\n    // Set 5 instances for the LifecycleWorker\n    lifecycleWorkerManager.setInstances(5);\n    workerInstancesCheck(lifecycleWorkerManager, 5, retries);\n\n    lifecycleWorkerManager.stop();\n    lifecycleWorkerManager.waitForStatus(false);\n\n    workerManager.stop();\n    workerManager.waitForStatus(false);\n\n    // Should be same instances after being stopped.\n    workerInstancesCheck(lifecycleWorkerManager, 5, retries);\n    workerInstancesCheck(workerManager, 2, retries);\n\n    // Assert the LifecycleWorker dataset writes\n    // 3 workers should have started with 3 total instances. 2 more should later start with 5 total instances.\n    assertWorkerDatasetWrites(applicationManager, Bytes.toBytes(\"init\"),\n                              Bytes.stopKeyForPrefix(Bytes.toBytes(\"init.2\")), 3, 3);\n    assertWorkerDatasetWrites(applicationManager, Bytes.toBytes(\"init.3\"),\n                              Bytes.stopKeyForPrefix(Bytes.toBytes(\"init\")), 2, 5);\n\n    // Test that the worker had 5 instances when stopped, and each knew that there were 5 instances\n    byte[] startRow = Bytes.toBytes(\"stop\");\n    assertWorkerDatasetWrites(applicationManager, startRow, Bytes.stopKeyForPrefix(startRow), 5, 5);\n  }","id":28663,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testWorkerInstances() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppUsingGetServiceURL.class);\n    WorkerManager workerManager = applicationManager.getWorkerManager(AppUsingGetServiceURL.PINGING_WORKER);\n    workerManager.start();\n    workerManager.waitForStatus(true);\n\n    int retries = 5;\n\n    // Should be 5 instances when first started.\n    workerInstancesCheck(workerManager, 5, retries);\n\n    // Test increasing instances.\n    workerManager.setInstances(10);\n    workerInstancesCheck(workerManager, 10, retries);\n\n    // Test decreasing instances.\n    workerManager.setInstances(2);\n    workerInstancesCheck(workerManager, 2, retries);\n\n    // Test requesting same number of instances.\n    workerManager.setInstances(2);\n    workerInstancesCheck(workerManager, 2, retries);\n\n    WorkerManager lifecycleWorkerManager = applicationManager.getWorkerManager(AppUsingGetServiceURL.LIFECYCLE_WORKER);\n    lifecycleWorkerManager.start();\n    lifecycleWorkerManager.waitForStatus(true);\n\n    // Set 5 instances for the LifecycleWorker\n    lifecycleWorkerManager.setInstances(5);\n    workerInstancesCheck(lifecycleWorkerManager, 5, retries);\n\n    lifecycleWorkerManager.stop();\n    lifecycleWorkerManager.waitForStatus(false);\n\n    workerManager.stop();\n    workerManager.waitForStatus(false);\n\n    // Should be same instances after being stopped.\n    workerInstancesCheck(lifecycleWorkerManager, 5, retries);\n    workerInstancesCheck(workerManager, 2, retries);\n\n    // Assert the LifecycleWorker dataset writes\n    // 3 workers should have started with 3 total instances. 2 more should later start with 5 total instances.\n    assertWorkerDatasetWrites(applicationManager, Bytes.toBytes(\"init\"),\n                              Bytes.stopKeyForPrefix(Bytes.toBytes(\"init.2\")), 3, 3);\n    assertWorkerDatasetWrites(applicationManager, Bytes.toBytes(\"init.3\"),\n                              Bytes.stopKeyForPrefix(Bytes.toBytes(\"init\")), 2, 5);\n\n    // Test that the worker had 5 instances when stopped, and each knew that there were 5 instances\n    byte[] startRow = Bytes.toBytes(\"stop\");\n    assertWorkerDatasetWrites(applicationManager, startRow, Bytes.stopKeyForPrefix(startRow), 5, 5);\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"private void testApp(Class<? extends Application> app, String streamName) throws Exception {\n\n    ApplicationManager applicationManager = deployApplication(app);\n    applicationManager.startFlow(\"WordCountFlow\");\n\n    // Send some inputs to streams\n    StreamManager streamManager = getStreamManager(streamName);\n    for (int i = 0; i < 100; i++) {\n      streamManager.send(ImmutableMap.of(\"title\", \"title \" + i), \"testing message \" + i);\n    }\n\n    // Check the flowlet metrics\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"WordCountApp\",\n                                                                   \"WordCountFlow\",\n                                                                   \"CountByField\");\n    flowletMetrics.waitForProcessed(500, 10, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, flowletMetrics.getException());\n\n    // Query the result\n    ServiceManager serviceManager = applicationManager.startService(\"WordFrequency\");\n    serviceManager.waitForStatus(true, 2, 1);\n\n    // Verify the query result\n    Type resultType = new TypeToken<Map<String, Long>>() { }.getType();\n    Map<String, Long> result = new Gson().fromJson(\n      callServiceGet(serviceManager.getServiceURL(), \"wordfreq/\" + streamName + \":testing\"), resultType);\n    Assert.assertEquals(100L, result.get(streamName + \":testing\").longValue());\n\n    // check the metrics\n    RuntimeMetrics serviceMetrics = RuntimeStats.getServiceMetrics(\"WordCountApp\", \"WordFrequency\");\n    serviceMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, serviceMetrics.getException());\n\n    // Run mapreduce job\n    MapReduceManager mrManager = applicationManager.startMapReduce(\"countTotal\");\n    mrManager.waitForFinish(1800L, TimeUnit.SECONDS);\n\n    long totalCount = Long.valueOf(callServiceGet(serviceManager.getServiceURL(), \"total\"));\n    // every event has 5 tokens\n    Assert.assertEquals(5 * 100L, totalCount);\n\n    // Run mapreduce from stream\n    mrManager = applicationManager.startMapReduce(\"countFromStream\");\n    mrManager.waitForFinish(120L, TimeUnit.SECONDS);\n\n    totalCount = Long.valueOf(callServiceGet(serviceManager.getServiceURL(), \"stream_total\"));\n    // The stream MR only consume the body, not the header.\n    Assert.assertEquals(3 * 100L, totalCount);\n\n    DataSetManager<MyKeyValueTableDefinition.KeyValueTable> mydatasetManager = getDataset(\"mydataset\");\n    Assert.assertEquals(100L, Long.valueOf(mydatasetManager.get().get(\"title:title\")).longValue());\n  }","id":28664,"modified_method":"private void testApp(Class<? extends Application> app, String streamName) throws Exception {\n\n    ApplicationManager applicationManager = deployApplication(app);\n    applicationManager.getFlowManager(\"WordCountFlow\").start();\n\n    // Send some inputs to streams\n    StreamManager streamManager = getStreamManager(streamName);\n    for (int i = 0; i < 100; i++) {\n      streamManager.send(ImmutableMap.of(\"title\", \"title \" + i), \"testing message \" + i);\n    }\n\n    // Check the flowlet metrics\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"WordCountApp\",\n                                                                   \"WordCountFlow\",\n                                                                   \"CountByField\");\n    flowletMetrics.waitForProcessed(500, 10, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, flowletMetrics.getException());\n\n    // Query the result\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"WordFrequency\");\n    serviceManager.start();\n    serviceManager.waitForStatus(true, 2, 1);\n\n    // Verify the query result\n    Type resultType = new TypeToken<Map<String, Long>>() { }.getType();\n    Map<String, Long> result = new Gson().fromJson(\n      callServiceGet(serviceManager.getServiceURL(), \"wordfreq/\" + streamName + \":testing\"), resultType);\n    Assert.assertEquals(100L, result.get(streamName + \":testing\").longValue());\n\n    // check the metrics\n    RuntimeMetrics serviceMetrics = RuntimeStats.getServiceMetrics(\"WordCountApp\", \"WordFrequency\");\n    serviceMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, serviceMetrics.getException());\n\n    // Run mapreduce job\n    MapReduceManager mrManager = applicationManager.getMapReduceManager(\"countTotal\");\n    mrManager.start();\n    mrManager.waitForFinish(1800L, TimeUnit.SECONDS);\n\n    long totalCount = Long.valueOf(callServiceGet(serviceManager.getServiceURL(), \"total\"));\n    // every event has 5 tokens\n    Assert.assertEquals(5 * 100L, totalCount);\n\n    // Run mapreduce from stream\n    mrManager = applicationManager.getMapReduceManager(\"countFromStream\");\n    mrManager.start();\n    mrManager.waitForFinish(120L, TimeUnit.SECONDS);\n\n    totalCount = Long.valueOf(callServiceGet(serviceManager.getServiceURL(), \"stream_total\"));\n    // The stream MR only consume the body, not the header.\n    Assert.assertEquals(3 * 100L, totalCount);\n\n    DataSetManager<MyKeyValueTableDefinition.KeyValueTable> mydatasetManager = getDataset(\"mydataset\");\n    Assert.assertEquals(100L, Long.valueOf(mydatasetManager.get().get(\"title:title\")).longValue());\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"private void testAppWithDataset(Class<? extends Application> app, String serviceName) throws Exception {\n    ApplicationManager applicationManager = deployApplication(app);\n    // Query the result\n    ServiceManager serviceManager = applicationManager.startService(serviceName);\n    serviceManager.waitForStatus(true, 2, 1);\n    callServicePut(serviceManager.getServiceURL(), \"key1\", \"value1\");\n    String response = callServiceGet(serviceManager.getServiceURL(), \"key1\");\n    Assert.assertEquals(\"value1\", new Gson().fromJson(response, String.class));\n  }","id":28665,"modified_method":"private void testAppWithDataset(Class<? extends Application> app, String serviceName) throws Exception {\n    ApplicationManager applicationManager = deployApplication(app);\n    // Query the result\n    ServiceManager serviceManager = applicationManager.getServiceManager(serviceName);\n    serviceManager.start();\n    serviceManager.waitForStatus(true, 2, 1);\n    callServicePut(serviceManager.getServiceURL(), \"key1\", \"value1\");\n    String response = callServiceGet(serviceManager.getServiceURL(), \"key1\");\n    Assert.assertEquals(\"value1\", new Gson().fromJson(response, String.class));\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testFlowRuntimeArguments() throws Exception {\n    ApplicationManager applicationManager = deployApplication(FilterApp.class);\n    Map<String, String> args = Maps.newHashMap();\n    args.put(\"threshold\", \"10\");\n    applicationManager.startFlow(\"FilterFlow\", args);\n\n    StreamManager input = getStreamManager(\"input\");\n    input.send(\"1\");\n    input.send(\"11\");\n\n    ServiceManager serviceManager = applicationManager.startService(\"CountService\");\n    serviceManager.waitForStatus(true, 2, 1);\n\n    Assert.assertEquals(\"1\", new Gson().fromJson(\n      callServiceGet(serviceManager.getServiceURL(), \"result\"), String.class));\n  }","id":28666,"modified_method":"@Test\n  public void testFlowRuntimeArguments() throws Exception {\n    ApplicationManager applicationManager = deployApplication(FilterApp.class);\n    Map<String, String> args = Maps.newHashMap();\n    args.put(\"threshold\", \"10\");\n    applicationManager.getFlowManager(\"FilterFlow\").start(args);\n\n    StreamManager input = getStreamManager(\"input\");\n    input.send(\"1\");\n    input.send(\"11\");\n\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"CountService\");\n    serviceManager.start();\n    serviceManager.waitForStatus(true, 2, 1);\n\n    Assert.assertEquals(\"1\", new Gson().fromJson(\n      callServiceGet(serviceManager.getServiceURL(), \"result\"), String.class));\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testGenerator() throws InterruptedException, IOException, TimeoutException {\n    ApplicationManager applicationManager = deployApplication(testSpace, GenSinkApp2.class);\n    applicationManager.startFlow(\"GenSinkFlow\");\n\n    // Check the flowlet metrics\n    RuntimeMetrics genMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(),\n                                                               \"GenSinkApp\",\n                                                               \"GenSinkFlow\",\n                                                               \"GenFlowlet\");\n\n    RuntimeMetrics sinkMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(),\n                                                                \"GenSinkApp\",\n                                                                \"GenSinkFlow\",\n                                                                \"SinkFlowlet\");\n\n    RuntimeMetrics batchSinkMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(),\n                                                                     \"GenSinkApp\",\n                                                                     \"GenSinkFlow\",\n                                                                     \"BatchSinkFlowlet\");\n\n    // Generator generators 99 events + 99 batched events\n    sinkMetrics.waitFor(\"system.process.events.in\", 198, 5, TimeUnit.SECONDS);\n    sinkMetrics.waitForProcessed(198, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, sinkMetrics.getException());\n\n    // Batch sink only get the 99 batch events\n    batchSinkMetrics.waitFor(\"system.process.events.in\", 99, 5, TimeUnit.SECONDS);\n    batchSinkMetrics.waitForProcessed(99, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, batchSinkMetrics.getException());\n\n    Assert.assertEquals(1L, genMetrics.getException());\n  }","id":28667,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testGenerator() throws InterruptedException, IOException, TimeoutException {\n    ApplicationManager applicationManager = deployApplication(testSpace, GenSinkApp2.class);\n    applicationManager.getFlowManager(\"GenSinkFlow\").start();\n\n    // Check the flowlet metrics\n    RuntimeMetrics genMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(),\n                                                               \"GenSinkApp\",\n                                                               \"GenSinkFlow\",\n                                                               \"GenFlowlet\");\n\n    RuntimeMetrics sinkMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(),\n                                                                \"GenSinkApp\",\n                                                                \"GenSinkFlow\",\n                                                                \"SinkFlowlet\");\n\n    RuntimeMetrics batchSinkMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(),\n                                                                     \"GenSinkApp\",\n                                                                     \"GenSinkFlow\",\n                                                                     \"BatchSinkFlowlet\");\n\n    // Generator generators 99 events + 99 batched events\n    sinkMetrics.waitFor(\"system.process.events.in\", 198, 5, TimeUnit.SECONDS);\n    sinkMetrics.waitForProcessed(198, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, sinkMetrics.getException());\n\n    // Batch sink only get the 99 batch events\n    batchSinkMetrics.waitFor(\"system.process.events.in\", 99, 5, TimeUnit.SECONDS);\n    batchSinkMetrics.waitForProcessed(99, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, batchSinkMetrics.getException());\n\n    Assert.assertEquals(1L, genMetrics.getException());\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testAppWithServices() throws Exception {\n    ApplicationManager applicationManager = deployApplication(AppWithServices.class);\n    LOG.info(\"Deployed.\");\n    ServiceManager serviceManager = applicationManager.startService(AppWithServices.SERVICE_NAME);\n    serviceManager.waitForStatus(true);\n\n    LOG.info(\"Service Started\");\n\n    URL serviceURL = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(serviceURL);\n\n    // Call the ping endpoint\n    URL url = new URL(serviceURL, \"ping2\");\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    // Call the failure endpoint\n    url = new URL(serviceURL, \"failure\");\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(500, response.getResponseCode());\n    Assert.assertTrue(response.getResponseBodyAsString().contains(\"Transaction failure\"));\n\n    // Call the verify ClassLoader endpoint\n    url = new URL(serviceURL, \"verifyClassLoader\");\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    RuntimeMetrics serviceMetrics = RuntimeStats.getServiceMetrics(AppWithServices.APP_NAME,\n                                                                   AppWithServices.SERVICE_NAME);\n    serviceMetrics.waitForinput(3, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(3, serviceMetrics.getInput());\n    Assert.assertEquals(2, serviceMetrics.getProcessed());\n    Assert.assertEquals(1, serviceMetrics.getException());\n\n    // in the AppWithServices the handlerName is same as the serviceName - \"ServerService\" handler\n    RuntimeMetrics handlerMetrics = RuntimeStats.getServiceHandlerMetrics(AppWithServices.APP_NAME,\n                                                                          AppWithServices.SERVICE_NAME,\n                                                                          AppWithServices.SERVICE_NAME);\n    handlerMetrics.waitForinput(3, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(3, handlerMetrics.getInput());\n    Assert.assertEquals(2, handlerMetrics.getProcessed());\n    Assert.assertEquals(1, handlerMetrics.getException());\n\n    // we can verify metrics, by adding getServiceMetrics in RuntimeStats and then disabling the system scope test in\n    // TestMetricsCollectionService\n\n    LOG.info(\"DatasetUpdateService Started\");\n    Map<String, String> args\n      = ImmutableMap.of(AppWithServices.WRITE_VALUE_RUN_KEY, AppWithServices.DATASET_TEST_VALUE,\n                        AppWithServices.WRITE_VALUE_STOP_KEY, AppWithServices.DATASET_TEST_VALUE_STOP);\n    ServiceManager datasetWorkerServiceManager = applicationManager\n      .startService(AppWithServices.DATASET_WORKER_SERVICE_NAME, args);\n    WorkerManager datasetWorker = applicationManager.startWorker(AppWithServices.DATASET_UPDATE_WORKER, args);\n    datasetWorkerServiceManager.waitForStatus(true);\n\n    ServiceManager noopManager = applicationManager.startService(\"NoOpService\");\n    serviceManager.waitForStatus(true, 2, 1);\n\n    String result = callServiceGet(noopManager.getServiceURL(), \"ping/\" + AppWithServices.DATASET_TEST_KEY);\n    String decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE, decodedResult);\n\n    handlerMetrics = RuntimeStats.getServiceHandlerMetrics(AppWithServices.APP_NAME,\n                                                                          \"NoOpService\",\n                                                                          \"NoOpHandler\");\n    handlerMetrics.waitForinput(1, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(1, handlerMetrics.getInput());\n    Assert.assertEquals(1, handlerMetrics.getProcessed());\n    Assert.assertEquals(0, handlerMetrics.getException());\n\n    // Test that a service can discover another service\n    String path = String.format(\"discover/%s/%s\",\n                                AppWithServices.APP_NAME, AppWithServices.DATASET_WORKER_SERVICE_NAME);\n    url = new URL(serviceURL, path);\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    datasetWorker.stop();\n    datasetWorkerServiceManager.stop();\n    datasetWorkerServiceManager.waitForStatus(false);\n    LOG.info(\"DatasetUpdateService Stopped\");\n    serviceManager.stop();\n    serviceManager.waitForStatus(false);\n    LOG.info(\"ServerService Stopped\");\n\n    result = callServiceGet(noopManager.getServiceURL(), \"ping/\" + AppWithServices.DATASET_TEST_KEY_STOP);\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP, decodedResult);\n\n    result = callServiceGet(noopManager.getServiceURL(), \"ping/\" + AppWithServices.DATASET_TEST_KEY_STOP_2);\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP_2, decodedResult);\n  }","id":28668,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testAppWithServices() throws Exception {\n    ApplicationManager applicationManager = deployApplication(AppWithServices.class);\n    LOG.info(\"Deployed.\");\n    ServiceManager serviceManager = applicationManager.getServiceManager(AppWithServices.SERVICE_NAME);\n    serviceManager.start();\n    serviceManager.waitForStatus(true);\n\n    LOG.info(\"Service Started\");\n\n    URL serviceURL = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(serviceURL);\n\n    // Call the ping endpoint\n    URL url = new URL(serviceURL, \"ping2\");\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    // Call the failure endpoint\n    url = new URL(serviceURL, \"failure\");\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(500, response.getResponseCode());\n    Assert.assertTrue(response.getResponseBodyAsString().contains(\"Transaction failure\"));\n\n    // Call the verify ClassLoader endpoint\n    url = new URL(serviceURL, \"verifyClassLoader\");\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    RuntimeMetrics serviceMetrics = RuntimeStats.getServiceMetrics(AppWithServices.APP_NAME,\n                                                                   AppWithServices.SERVICE_NAME);\n    serviceMetrics.waitForinput(3, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(3, serviceMetrics.getInput());\n    Assert.assertEquals(2, serviceMetrics.getProcessed());\n    Assert.assertEquals(1, serviceMetrics.getException());\n\n    // in the AppWithServices the handlerName is same as the serviceName - \"ServerService\" handler\n    RuntimeMetrics handlerMetrics = RuntimeStats.getServiceHandlerMetrics(AppWithServices.APP_NAME,\n                                                                          AppWithServices.SERVICE_NAME,\n                                                                          AppWithServices.SERVICE_NAME);\n    handlerMetrics.waitForinput(3, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(3, handlerMetrics.getInput());\n    Assert.assertEquals(2, handlerMetrics.getProcessed());\n    Assert.assertEquals(1, handlerMetrics.getException());\n\n    // we can verify metrics, by adding getServiceMetrics in RuntimeStats and then disabling the system scope test in\n    // TestMetricsCollectionService\n\n    LOG.info(\"DatasetUpdateService Started\");\n    Map<String, String> args\n      = ImmutableMap.of(AppWithServices.WRITE_VALUE_RUN_KEY, AppWithServices.DATASET_TEST_VALUE,\n                        AppWithServices.WRITE_VALUE_STOP_KEY, AppWithServices.DATASET_TEST_VALUE_STOP);\n    ServiceManager datasetWorkerServiceManager = applicationManager\n      .getServiceManager(AppWithServices.DATASET_WORKER_SERVICE_NAME);\n    datasetWorkerServiceManager.start(args);\n    WorkerManager datasetWorker = applicationManager.getWorkerManager(AppWithServices.DATASET_UPDATE_WORKER);\n    datasetWorker.start(args);\n    datasetWorkerServiceManager.waitForStatus(true);\n\n    ServiceManager noopManager = applicationManager.getServiceManager(\"NoOpService\");\n    noopManager.start();\n    serviceManager.waitForStatus(true, 2, 1);\n\n    String result = callServiceGet(noopManager.getServiceURL(), \"ping/\" + AppWithServices.DATASET_TEST_KEY);\n    String decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE, decodedResult);\n\n    handlerMetrics = RuntimeStats.getServiceHandlerMetrics(AppWithServices.APP_NAME,\n                                                                          \"NoOpService\",\n                                                                          \"NoOpHandler\");\n    handlerMetrics.waitForinput(1, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(1, handlerMetrics.getInput());\n    Assert.assertEquals(1, handlerMetrics.getProcessed());\n    Assert.assertEquals(0, handlerMetrics.getException());\n\n    // Test that a service can discover another service\n    String path = String.format(\"discover/%s/%s\",\n                                AppWithServices.APP_NAME, AppWithServices.DATASET_WORKER_SERVICE_NAME);\n    url = new URL(serviceURL, path);\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    datasetWorker.stop();\n    datasetWorkerServiceManager.stop();\n    datasetWorkerServiceManager.waitForStatus(false);\n    LOG.info(\"DatasetUpdateService Stopped\");\n    serviceManager.stop();\n    serviceManager.waitForStatus(false);\n    LOG.info(\"ServerService Stopped\");\n\n    result = callServiceGet(noopManager.getServiceURL(), \"ping/\" + AppWithServices.DATASET_TEST_KEY_STOP);\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP, decodedResult);\n\n    result = callServiceGet(noopManager.getServiceURL(), \"ping/\" + AppWithServices.DATASET_TEST_KEY_STOP_2);\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP_2, decodedResult);\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testGetServiceURL() throws Exception {\n    ApplicationManager applicationManager = deployApplication(AppUsingGetServiceURL.class);\n    ServiceManager centralServiceManager = applicationManager.startService(AppUsingGetServiceURL.CENTRAL_SERVICE);\n    centralServiceManager.waitForStatus(true);\n\n    WorkerManager pingingWorker = applicationManager.startWorker(AppUsingGetServiceURL.PINGING_WORKER);\n    pingingWorker.waitForStatus(true);\n\n    // Test service's getServiceURL\n    ServiceManager serviceManager = applicationManager.startService(AppUsingGetServiceURL.FORWARDING);\n    String result = callServiceGet(serviceManager.getServiceURL(), \"ping\");\n    String decodedResult = new Gson().fromJson(result, String.class);\n    // Verify that the service was able to hit the CentralService and retrieve the answer.\n    Assert.assertEquals(AppUsingGetServiceURL.ANSWER, decodedResult);\n\n    result = callServiceGet(serviceManager.getServiceURL(), \"read/\" + AppUsingGetServiceURL.DATASET_KEY);\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppUsingGetServiceURL.ANSWER, decodedResult);\n\n    serviceManager.stop();\n\n    pingingWorker.stop();\n    pingingWorker.waitForStatus(false);\n\n    centralServiceManager.stop();\n    centralServiceManager.waitForStatus(false);\n  }","id":28669,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testGetServiceURL() throws Exception {\n    ApplicationManager applicationManager = deployApplication(AppUsingGetServiceURL.class);\n    ServiceManager centralServiceManager = applicationManager.getServiceManager(AppUsingGetServiceURL.CENTRAL_SERVICE);\n    centralServiceManager.start();\n    centralServiceManager.waitForStatus(true);\n\n    WorkerManager pingingWorker = applicationManager.getWorkerManager(AppUsingGetServiceURL.PINGING_WORKER);\n    pingingWorker.start();\n    pingingWorker.waitForStatus(true);\n\n    // Test service's getServiceURL\n    ServiceManager serviceManager = applicationManager.getServiceManager(AppUsingGetServiceURL.FORWARDING);\n    serviceManager.start();\n    String result = callServiceGet(serviceManager.getServiceURL(), \"ping\");\n    String decodedResult = new Gson().fromJson(result, String.class);\n    // Verify that the service was able to hit the CentralService and retrieve the answer.\n    Assert.assertEquals(AppUsingGetServiceURL.ANSWER, decodedResult);\n\n    result = callServiceGet(serviceManager.getServiceURL(), \"read/\" + AppUsingGetServiceURL.DATASET_KEY);\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppUsingGetServiceURL.ANSWER, decodedResult);\n\n    serviceManager.stop();\n\n    pingingWorker.stop();\n    pingingWorker.waitForStatus(false);\n\n    centralServiceManager.stop();\n    centralServiceManager.waitForStatus(false);\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(XSlowTests.class)\n  @Test\n  public void testByteCodeClassLoader() throws Exception {\n    // This test verify bytecode generated classes ClassLoading\n\n    ApplicationManager appManager = deployApplication(testSpace, ClassLoaderTestApp.class);\n    FlowManager flowManager = appManager.startFlow(\"BasicFlow\");\n\n    // Wait for at least 10 records being generated\n    RuntimeMetrics flowMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(), \"ClassLoaderTestApp\",\n                                                                \"BasicFlow\", \"Sink\");\n    flowMetrics.waitForProcessed(10, 5000, TimeUnit.MILLISECONDS);\n    flowManager.stop();\n\n    ServiceManager serviceManager = appManager.startService(\"RecordQuery\");\n    URL serviceURL = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(serviceURL);\n\n    // Query record\n    URL url = new URL(serviceURL, \"query?type=public\");\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    long count = Long.parseLong(response.getResponseBodyAsString());\n    serviceManager.stop();\n\n    // Verify the record count with dataset\n    DataSetManager<KeyValueTable> recordsManager = getDataset(testSpace, \"records\");\n    KeyValueTable records = recordsManager.get();\n    Assert.assertTrue(count == Bytes.toLong(records.read(\"PUBLIC\")));\n  }","id":28670,"modified_method":"@Category(XSlowTests.class)\n  @Test\n  public void testByteCodeClassLoader() throws Exception {\n    // This test verify bytecode generated classes ClassLoading\n\n    ApplicationManager appManager = deployApplication(testSpace, ClassLoaderTestApp.class);\n    FlowManager flowManager = appManager.getFlowManager(\"BasicFlow\");\n    flowManager.start();\n\n    // Wait for at least 10 records being generated\n    RuntimeMetrics flowMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(), \"ClassLoaderTestApp\",\n                                                                \"BasicFlow\", \"Sink\");\n    flowMetrics.waitForProcessed(10, 5000, TimeUnit.MILLISECONDS);\n    flowManager.stop();\n\n    ServiceManager serviceManager = appManager.getServiceManager(\"RecordQuery\");\n    serviceManager.start();\n    URL serviceURL = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(serviceURL);\n\n    // Query record\n    URL url = new URL(serviceURL, \"query?type=public\");\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    long count = Long.parseLong(response.getResponseBodyAsString());\n    serviceManager.stop();\n\n    // Verify the record count with dataset\n    DataSetManager<KeyValueTable> recordsManager = getDataset(testSpace, \"records\");\n    KeyValueTable records = recordsManager.get();\n    Assert.assertTrue(count == Bytes.toLong(records.read(\"PUBLIC\")));\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(XSlowTests.class)\n  @Test(timeout = 240000)\n  @Ignore\n  // TODO: Investigate why this fails in Bamboo, but not locally\n  public void testMultiInput() throws Exception {\n    ApplicationManager applicationManager = deployApplication(JoinMultiStreamApp.class);\n    applicationManager.startFlow(\"JoinMultiFlow\");\n\n    StreamManager s1 = getStreamManager(\"s1\");\n    StreamManager s2 = getStreamManager(\"s2\");\n    StreamManager s3 = getStreamManager(\"s3\");\n\n    s1.send(\"testing 1\");\n    s2.send(\"testing 2\");\n    s3.send(\"testing 3\");\n\n    RuntimeMetrics terminalMetrics = RuntimeStats.getFlowletMetrics(\"JoinMulti\",\n                                                                    \"JoinMultiFlow\", \"Terminal\");\n    terminalMetrics.waitForProcessed(3, 60, TimeUnit.SECONDS);\n    TimeUnit.SECONDS.sleep(1);\n\n    ServiceManager queryManager = applicationManager.startService(\"QueryService\");\n    queryManager.waitForStatus(true, 2, 1);\n    URL serviceURL = queryManager.getServiceURL();\n    Gson gson = new Gson();\n\n    Assert.assertEquals(\"testing 1\", gson.fromJson(callServiceGet(serviceURL, \"input1\"), String.class));\n    Assert.assertEquals(\"testing 2\", gson.fromJson(callServiceGet(serviceURL, \"input2\"), String.class));\n    Assert.assertEquals(\"testing 3\", gson.fromJson(callServiceGet(serviceURL, \"input3\"), String.class));\n  }","id":28671,"modified_method":"@Category(XSlowTests.class)\n  @Test(timeout = 240000)\n  @Ignore\n  // TODO: Investigate why this fails in Bamboo, but not locally\n  public void testMultiInput() throws Exception {\n    ApplicationManager applicationManager = deployApplication(JoinMultiStreamApp.class);\n    applicationManager.getFlowManager(\"JoinMultiFlow\").start();\n\n    StreamManager s1 = getStreamManager(\"s1\");\n    StreamManager s2 = getStreamManager(\"s2\");\n    StreamManager s3 = getStreamManager(\"s3\");\n\n    s1.send(\"testing 1\");\n    s2.send(\"testing 2\");\n    s3.send(\"testing 3\");\n\n    RuntimeMetrics terminalMetrics = RuntimeStats.getFlowletMetrics(\"JoinMulti\",\n                                                                    \"JoinMultiFlow\", \"Terminal\");\n    terminalMetrics.waitForProcessed(3, 60, TimeUnit.SECONDS);\n    TimeUnit.SECONDS.sleep(1);\n\n    ServiceManager queryManager = applicationManager.getServiceManager(\"QueryService\");\n    queryManager.start();\n    queryManager.waitForStatus(true, 2, 1);\n    URL serviceURL = queryManager.getServiceURL();\n    Gson gson = new Gson();\n\n    Assert.assertEquals(\"testing 1\", gson.fromJson(callServiceGet(serviceURL, \"input1\"), String.class));\n    Assert.assertEquals(\"testing 2\", gson.fromJson(callServiceGet(serviceURL, \"input2\"), String.class));\n    Assert.assertEquals(\"testing 3\", gson.fromJson(callServiceGet(serviceURL, \"input3\"), String.class));\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testUserProfiles() throws Exception {\n\n    // deploy the app\n    ApplicationManager applicationManager = deployApplication(UserProfiles.class);\n\n    // run the service and the flow\n    FlowManager flowManager = applicationManager.startFlow(\"ActivityFlow\");\n\n    ServiceManager serviceManager = applicationManager.startService(\"UserProfileService\");\n    serviceManager.waitForStatus(true);\n    URL serviceURL = serviceManager.getServiceURL();\n\n    // create a user through the service\n    String userJson = new Gson().toJson(ImmutableMap.of(\"id\", \"1234\", \"name\", \"joe\", \"email\", \"joe@bla.ck\"));\n    HttpURLConnection connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(userJson.getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_CREATED, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // read the user through the dataset\n    DataSetManager<Table> tableManager = getDataset(\"profiles\");\n    Row row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@bla.ck\", row.getString(\"email\"));\n    Assert.assertNull(row.getLong(\"login\"));\n    Assert.assertNull(row.getLong(\"active\"));\n\n    // update email address through service\n    connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234/email\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(\"joe@black.com\".getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // verify the updated email address\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@black.com\", row.getString(\"email\"));\n    Assert.assertNull(row.getLong(\"login\"));\n    Assert.assertNull(row.getLong(\"active\"));\n\n    // send a login event\n    long loginTime = System.currentTimeMillis();\n    connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234/lastLogin\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(Long.toString(loginTime).getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // verify the login time through the dataset\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@black.com\", row.getString(\"email\"));\n    Assert.assertEquals(new Long(loginTime), row.getLong(\"login\"));\n    Assert.assertNull(row.getLong(\"active\"));\n\n    // send an event to the stream\n    long activeTime = System.currentTimeMillis();\n    StreamManager streamManager = getStreamManager(\"events\");\n    streamManager.send(new Gson().toJson(new Event(activeTime, \"1234\", \"/some/path\")));\n\n    try {\n      // Wait for the last Flowlet processing 1 events, or at most 5 seconds\n      RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"UserProfiles\", \"ActivityFlow\", \"updater\");\n      metrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n      Assert.assertFalse(flowManager.isRunning());\n    }\n\n    // verify the last active time for the user\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@black.com\", row.getString(\"email\"));\n    Assert.assertEquals(new Long(loginTime), row.getLong(\"login\"));\n    Assert.assertEquals(new Long(activeTime), row.getLong(\"active\"));\n\n    // delete the user\n    connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234\").openConnection();\n    try {\n      connection.setRequestMethod(\"DELETE\");\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // verify the user is gone\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertTrue(row.isEmpty());\n\n    // stop the service and the flow\n    serviceManager.stop();\n  }","id":28672,"modified_method":"@Test\n  public void testUserProfiles() throws Exception {\n\n    // deploy the app\n    ApplicationManager applicationManager = deployApplication(UserProfiles.class);\n\n    // run the service and the flow\n    FlowManager flowManager = applicationManager.getFlowManager(\"ActivityFlow\");\n    flowManager.start();\n\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"UserProfileService\");\n    serviceManager.start();\n    serviceManager.waitForStatus(true);\n    URL serviceURL = serviceManager.getServiceURL();\n\n    // create a user through the service\n    String userJson = new Gson().toJson(ImmutableMap.of(\"id\", \"1234\", \"name\", \"joe\", \"email\", \"joe@bla.ck\"));\n    HttpURLConnection connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(userJson.getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_CREATED, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // read the user through the dataset\n    DataSetManager<Table> tableManager = getDataset(\"profiles\");\n    Row row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@bla.ck\", row.getString(\"email\"));\n    Assert.assertNull(row.getLong(\"login\"));\n    Assert.assertNull(row.getLong(\"active\"));\n\n    // update email address through service\n    connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234/email\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(\"joe@black.com\".getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // verify the updated email address\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@black.com\", row.getString(\"email\"));\n    Assert.assertNull(row.getLong(\"login\"));\n    Assert.assertNull(row.getLong(\"active\"));\n\n    // send a login event\n    long loginTime = System.currentTimeMillis();\n    connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234/lastLogin\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(Long.toString(loginTime).getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // verify the login time through the dataset\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@black.com\", row.getString(\"email\"));\n    Assert.assertEquals(new Long(loginTime), row.getLong(\"login\"));\n    Assert.assertNull(row.getLong(\"active\"));\n\n    // send an event to the stream\n    long activeTime = System.currentTimeMillis();\n    StreamManager streamManager = getStreamManager(\"events\");\n    streamManager.send(new Gson().toJson(new Event(activeTime, \"1234\", \"/some/path\")));\n\n    try {\n      // Wait for the last Flowlet processing 1 events, or at most 5 seconds\n      RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"UserProfiles\", \"ActivityFlow\", \"updater\");\n      metrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n      Assert.assertFalse(flowManager.isRunning());\n    }\n\n    // verify the last active time for the user\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@black.com\", row.getString(\"email\"));\n    Assert.assertEquals(new Long(loginTime), row.getLong(\"login\"));\n    Assert.assertEquals(new Long(activeTime), row.getLong(\"active\"));\n\n    // delete the user\n    connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234\").openConnection();\n    try {\n      connection.setRequestMethod(\"DELETE\");\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // verify the user is gone\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertTrue(row.isEmpty());\n\n    // stop the service and the flow\n    serviceManager.stop();\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testWebAnalytics() throws Exception {\n    // Deploy the Application\n    ApplicationManager appManager = deployApplication(WebAnalytics.class);\n    // Start the Flow\n    appManager.startFlow(\"WebAnalyticsFlow\");\n\n    // Send events to the Stream\n    StreamManager streamManager = getStreamManager(\"log\");\n    BufferedReader reader = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(\"/access.log\"),\n                                                                     \"UTF-8\"));\n    int lines = 0;\n    try {\n      String line = reader.readLine();\n      while (line != null) {\n        streamManager.send(line);\n        lines++;\n        line = reader.readLine();\n      }\n    } finally {\n      reader.close();\n    }\n\n    // Wait for the flow to process all data\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"WebAnalytics\",\n                                                                   \"WebAnalyticsFlow\", \"UniqueVisitor\");\n    flowletMetrics.waitForProcessed(lines, 10, TimeUnit.SECONDS);\n\n    // Verify the unique count\n    UniqueVisitCount uniqueVisitCount = appManager.<UniqueVisitCount>getDataSet(\"UniqueVisitCount\").get();\n    Assert.assertEquals(3L, uniqueVisitCount.getCount(\"192.168.12.72\"));\n  }","id":28673,"modified_method":"@Test\n  public void testWebAnalytics() throws Exception {\n    // Deploy the Application\n    ApplicationManager appManager = deployApplication(WebAnalytics.class);\n    // Start the Flow\n    appManager.getFlowManager(\"WebAnalyticsFlow\").start();\n\n    // Send events to the Stream\n    StreamManager streamManager = getStreamManager(\"log\");\n    BufferedReader reader = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(\"/access.log\"),\n                                                                     \"UTF-8\"));\n    int lines = 0;\n    try {\n      String line = reader.readLine();\n      while (line != null) {\n        streamManager.send(line);\n        lines++;\n        line = reader.readLine();\n      }\n    } finally {\n      reader.close();\n    }\n\n    // Wait for the flow to process all data\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"WebAnalytics\",\n                                                                   \"WebAnalyticsFlow\", \"UniqueVisitor\");\n    flowletMetrics.waitForProcessed(lines, 10, TimeUnit.SECONDS);\n\n    // Verify the unique count\n    UniqueVisitCount uniqueVisitCount = appManager.<UniqueVisitCount>getDataSet(\"UniqueVisitCount\").get();\n    Assert.assertEquals(3L, uniqueVisitCount.getCount(\"192.168.12.72\"));\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testWordCount() throws Exception {\n    // Deploy the Application\n    ApplicationManager appManager = deployApplication(WordCount.class);\n\n    // Start the Flow\n    appManager.startFlow(\"WordCounter\");\n\n    // Send a few events to the stream\n    StreamManager streamManager = getStreamManager(\"wordStream\");\n    streamManager.send(\"hello world\");\n    streamManager.send(\"a wonderful world\");\n    streamManager.send(\"the world says hello\");\n\n    // Wait for the events to be processed, or at most 5 seconds\n    RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"WordCount\", \"WordCounter\", \"associator\");\n    metrics.waitForProcessed(3, 5, TimeUnit.SECONDS);\n\n    // Start RetrieveCounts service\n    ServiceManager serviceManager = appManager.startService(RetrieveCounts.SERVICE_NAME);\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    // First verify global statistics\n    String response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"stats\"));\n    Map<String, String> map = new Gson().fromJson(response, stringMapType);\n    Assert.assertEquals(\"9\", map.get(\"totalWords\"));\n    Assert.assertEquals(\"6\", map.get(\"uniqueWords\"));\n    Assert.assertEquals(((double) 42) / 9, Double.valueOf(map.get(\"averageLength\")), 0.001);\n\n    // Now verify statistics for a specific word\n    response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"count/world\"));\n    Map<String, Object> omap = new Gson().fromJson(response, objectMapType);\n    Assert.assertEquals(\"world\", omap.get(\"word\"));\n    Assert.assertEquals(3.0, omap.get(\"count\"));\n\n    // The associations are a map within the map\n    @SuppressWarnings(\"unchecked\")\n    Map<String, Double> assocs = (Map<String, Double>) omap.get(\"assocs\");\n    Assert.assertEquals(2.0, assocs.get(\"hello\"), 0.000001);\n    Assert.assertTrue(assocs.containsKey(\"hello\"));\n  }","id":28674,"modified_method":"@Test\n  public void testWordCount() throws Exception {\n    // Deploy the Application\n    ApplicationManager appManager = deployApplication(WordCount.class);\n\n    // Start the Flow\n    appManager.getFlowManager(\"WordCounter\").start();\n\n    // Send a few events to the stream\n    StreamManager streamManager = getStreamManager(\"wordStream\");\n    streamManager.send(\"hello world\");\n    streamManager.send(\"a wonderful world\");\n    streamManager.send(\"the world says hello\");\n\n    // Wait for the events to be processed, or at most 5 seconds\n    RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"WordCount\", \"WordCounter\", \"associator\");\n    metrics.waitForProcessed(3, 5, TimeUnit.SECONDS);\n\n    // Start RetrieveCounts service\n    ServiceManager serviceManager = appManager.getServiceManager(RetrieveCounts.SERVICE_NAME);\n    serviceManager.start();\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    // First verify global statistics\n    String response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"stats\"));\n    Map<String, String> map = new Gson().fromJson(response, stringMapType);\n    Assert.assertEquals(\"9\", map.get(\"totalWords\"));\n    Assert.assertEquals(\"6\", map.get(\"uniqueWords\"));\n    Assert.assertEquals(((double) 42) / 9, Double.valueOf(map.get(\"averageLength\")), 0.001);\n\n    // Now verify statistics for a specific word\n    response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"count/world\"));\n    Map<String, Object> omap = new Gson().fromJson(response, objectMapType);\n    Assert.assertEquals(\"world\", omap.get(\"word\"));\n    Assert.assertEquals(3.0, omap.get(\"count\"));\n\n    // The associations are a map within the map\n    @SuppressWarnings(\"unchecked\")\n    Map<String, Double> assocs = (Map<String, Double>) omap.get(\"assocs\");\n    Assert.assertEquals(2.0, assocs.get(\"hello\"), 0.000001);\n    Assert.assertTrue(assocs.containsKey(\"hello\"));\n  }","commit_id":"6d199856371b803e7e02bcde75fb5b84b7792228","url":"https://github.com/caskdata/cdap"},{"original_method":"public Importable translate(Node resourceNode, Document descriptor,\n\t\t\tString contextPath, String archiveBasePath) {\n\t\tHtmlDocument rv = new HtmlDocument();\n\t\tString href = XPathHelper.getNodeValue(\"./@href\", resourceNode);\n\t\tString filename = href.substring(href.lastIndexOf(\"/\"),href.length() - 1);\n\t\ttry {\n\t        FileInputStream file = new FileInputStream (archiveBasePath + \"/\" + href);\n\t        byte[] b = new byte[file.available()];\n\t        file.read(b);\n\t        file.close ();\n\t        rv.setContent(new String (b));\n\t        rv.setContextPath(contextPath);\n\t        rv.setTitle(filename);\n\t\t} catch (IOException e) {\n\t\t\treturn null;\n\t\t}\n\t\treturn rv;\n\t}","id":28675,"modified_method":"public Importable translate(Node resourceNode, Document descriptor,\n\t\t\tString contextPath, String archiveBasePath) {\n\t\t\n\t\tWebLink rv = new WebLink();\n\t\tString href = XPathHelper.getNodeValue(\"./@href\", resourceNode);\n\t\tDocument factoryDocument = resourceNode.getOwnerDocument();\n\t\tElement fileElement = factoryDocument.createElement(\"file\");\n\t\tfileElement.setAttribute(\"href\", href);\n\t\tresourceNode.appendChild(fileElement);\n\t\t// String filename = href.substring(href.lastIndexOf(\"/\"),href.length() - 1);\n\t\tString title = ((Element)resourceNode).getAttribute(\"title\");\n\t\trv.setAbsolute(false);\n\t\trv.setUrl(href);\n\t\trv.setContextPath(contextPath + title);\n\t\trv.setTitle(title);\n\t\treturn rv;\n\t}","commit_id":"b59f2144dacca2ddb5b80ca9b111fe47467ab7c3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String getTitle(Node resourceNode) {\n\t\t\tDocument descriptor = getDescriptor(resourceNode);\n\t\t\treturn XPathHelper.getNodeValue(\"/CONTENT/TITLE\",descriptor);\n\t\t}","id":28676,"modified_method":"public String getTitle(Node resourceNode) {\n\t\t\tDocument descriptor = getDescriptor(resourceNode);\n\t\t\tString title = XPathHelper.getNodeValue(\"/CONTENT/TITLE\",descriptor);\n\t\t\tif (title == null || \"\".equals(title)) {\n\t\t\t\tNode itemNode = XPathHelper.selectNode(\"//item[@identifierref='\" + this.getId(resourceNode) + \"']\", resourceNode.getOwnerDocument());\n\t\t\t\tif (itemNode != null) {\n\t\t\t\t\ttitle = XPathHelper.getNodeValue(\"./title\", itemNode);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn title;\n\t\t}","commit_id":"b59f2144dacca2ddb5b80ca9b111fe47467ab7c3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public CommonCartridgeFileParser() {\n\t\t// add resource translators here\n\t\taddResourceTranslator(new CCAssessmentTranslator());\n\t\taddResourceTranslator(new CCWebLinkTranslator());\n\t\t// addResourceTranslator(new  CCWebContentTranslator());\n\t\tresourceHelper = new CCResourceHelper();\n\t\titemHelper = new CCItemHelper();\n\t\tfileHelper = new CCFileHelper();\n\t\tmanifestHelper = new CCManifestHelper();\n\t}","id":28677,"modified_method":"public CommonCartridgeFileParser() {\n\t\t// add resource translators here\n\t\taddResourceTranslator(new CCAssessmentTranslator());\n\t\taddResourceTranslator(new CCWebLinkTranslator());\n\t\taddResourceTranslator(new CCWebContentTranslator());\n\t\taddResourceTranslator(new CCDiscussionTopicTranslator());\n\t\tresourceHelper = new CCResourceHelper();\n\t\titemHelper = new CCItemHelper();\n\t\tfileHelper = new CCFileHelper();\n\t\tmanifestHelper = new CCManifestHelper();\n\t}","commit_id":"b59f2144dacca2ddb5b80ca9b111fe47467ab7c3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"protected Collection translateFromNodeToImportables(Node node, String contextPath, Importable parent) {\n\t\tCollection branchOfImportables = new ArrayList();\n\t\tString tag = node.getNodeName();\n\t\tString itemResourceId = null;\n\t\tif (\"item\".equals(tag)) {\n\t\t\titemResourceId = itemHelper.getResourceId(node);\n\t\t} else if (\"resource\".equals(tag)) {\n\t\t\titemResourceId = resourceHelper.getId(node);\n\t\t} else if (\"file\".equals(tag)) {\n\t\t\titemResourceId = resourceHelper.getId(node.getParentNode());\n\t\t}\n\t\tDocument resourceDescriptor = resourceHelper.getDescriptor(manifestHelper.getResourceForId(itemResourceId, this.archiveManifest));\n\t\tif (resourceHelper.isFolder(resourceDescriptor) || \n\t  \t\t    (\"item\".equals(tag) && (XPathHelper.selectNodes(\"./item\", node).size() > 0)) ||\n\t  \t\t    ( \"item\".equals(tag) && \n\t  \t          isCompoundDocument(manifestHelper.getResourceForId(itemResourceId, archiveManifest),resourceDescriptor)\n\t  \t\t    )) {\n\t\t\tString folderTitle = getTitleForNode(node);\n\t\t\tFolder folder = new Folder();\n\t\t\tfolder.setPath(contextPath);\n\t\t\tfolder.setTitle(folderTitle);\n\t\t\tfolder.setDescription(getDescriptionForNode(node));\n\t\t\tif (parent != null) {\n  \t\t\t\tfolder.setParent(parent);\n  \t\t\t\tfolder.setLegacyGroup(parent.getLegacyGroup());\n  \t\t\t} else folder.setLegacyGroup(folderTitle);\n\t\t\t// now we take care of the folder's child Nodes\n\t\t\t// construct a new path and make sure we replace any forward slashes from the resource title\n\t\t\tString folderPath = contextPath + folderTitle.replaceAll(\"/\", \"_\") + \"/\";\n\t\t\tif (isCompoundDocument(manifestHelper.getResourceForId(itemResourceId, archiveManifest),resourceDescriptor)) {\n\t\t\t\tbranchOfImportables.addAll(translateFromNodeToImportables(manifestHelper.getResourceForId(itemResourceId, archiveManifest), folderPath,folder));\n\t\t\t} else {\n\t  \t\t\tList children = XPathHelper.selectNodes(\"./item\", node);\n\t  \t\t\tfor (Iterator i = children.iterator(); i.hasNext();) {\n\t  \t\t\t\tbranchOfImportables.addAll(\n\t  \t\t\t\t\t\ttranslateFromNodeToImportables((Node)i.next(),folderPath, folder));\n\t  \t\t\t}\n\t\t\t}\n  \t\t\tresourceMap.remove(itemResourceId);\n  \t\t\tbranchOfImportables.add(folder);\n\t\t} // node is folder\n\t\t\n\t\telse if(\"item\".equals(tag)) {\n\t\t\t// this item is a leaf, so we handle the resource associated with it\n\t\t\tNode resourceNode = manifestHelper.getResourceForId(itemResourceId, this.archiveManifest);\n  \t\t\tif (resourceNode != null) {\n  \t\t\t\tif (parent == null) {\n  \t\t\t\t\tparent = new Folder();\n  \t\t\t\t\tparent.setLegacyGroup(itemHelper.getTitle(node));\n  \t\t\t\t}\n  \t\t\t\tbranchOfImportables.addAll(\n  \t\t\t\t\t\ttranslateFromNodeToImportables(resourceNode,contextPath, parent));\n  \t\t\t}\n\t\t} else if(\"file\".equals(tag)) {\n\t\t\tFileResource file = new FileResource();\n\t\t\ttry {\n\t\t\t\tString fileName = fileHelper.getFilenameForNode(node);\n \t\t\t\tfile.setFileName(fileName);\n\t\t\t\t// If \n\t\t\t\tif (node.getParentNode().getChildNodes().getLength() > 1) {\n\t\t\t\t\tfile.setDescription(\"\");\n\t\t\t\t} else file.setDescription(resourceHelper.getDescription(node.getParentNode()));\n\t\t\t\tfile.setFileBytes(fileHelper.getFileBytesForNode(node, contextPath));\n\t\t\t\tfile.setDestinationResourcePath(fileHelper.getFilePathForNode(node, contextPath));\n\t\t\t\tfile.setContentType(this.mimeTypes.getContentType(fileName));\n\t\t\t\tfile.setTitle(fileHelper.getTitle(node));\n\t\t\t\tif(parent != null) {\n\t\t\t\t\tfile.setParent(parent);\n\t\t\t\t\tfile.setLegacyGroup(parent.getLegacyGroup());\n\t\t\t\t} else file.setLegacyGroup(\"\");\n\t\t\t} catch (IOException e) {\n\t\t\t\tresourceMap.remove(resourceHelper.getId(node.getParentNode()));\n\t\t\t\treturn branchOfImportables;\n\t\t\t}\n\t\t\tbranchOfImportables.add(file);\n\t\t\tresourceMap.remove(resourceHelper.getId(node.getParentNode()));\n\t\t\treturn branchOfImportables;\n\t\t} else if(\"resource\".equals(tag)) {\n\t\t\t// TODO handle a resource node\n\t\t\tImportable resource = null;\n\t\t\tboolean processResourceChildren = true;\n\t\t\tIMSResourceTranslator translator = (IMSResourceTranslator)translatorMap.get(resourceHelper.getType(node));\n\t\t\tif (translator != null) {\n\t\t\t\tresource = translator.translate(node, resourceHelper.getDescriptor(node), contextPath, this.pathToData);\n\t\t\t\tprocessResourceChildren = translator.processResourceChildren();\n\t\t\t}\n\t\t\tif (resource != null) {\n\t\t\t\tif (parent != null) {\n\t\t\t\t\tresource.setParent(parent);\n\t\t\t\t\tresource.setLegacyGroup(parent.getLegacyGroup());\n\t\t\t\t} else resource.setLegacyGroup(resourceHelper.getTitle(node));\n\t\t\t\tbranchOfImportables.add(resource);\n\t\t\t\tparent = resource;\n\t\t\t}\n\t\t\t// processing the child nodes implies that their files can wind up in the Resources tool.\n\t\t\t// this is not always desireable, such as the QTI files from assessments.\n\t\t\tif (processResourceChildren) {\n\t\t\t\tNodeList children = node.getChildNodes();\n\t\t  \t\tfor (int i = 0;i < children.getLength();i++) {\n\t\t  \t\t\tbranchOfImportables.addAll(translateFromNodeToImportables(children.item(i), contextPath, parent));\n\t\t  \t\t\t}\n\t\t\t}\n\t\t\tresourceMap.remove(itemResourceId);\n\t\t}\n\t\treturn branchOfImportables;\n\t}","id":28678,"modified_method":"protected Collection translateFromNodeToImportables(Node node, String contextPath, Importable parent) {\n\t\tCollection branchOfImportables = new ArrayList();\n\t\tString tag = node.getNodeName();\n\t\tString itemResourceId = null;\n\t\tif (\"item\".equals(tag)) {\n\t\t\titemResourceId = itemHelper.getResourceId(node);\n\t\t} else if (\"resource\".equals(tag)) {\n\t\t\titemResourceId = resourceHelper.getId(node);\n\t\t} else if (\"file\".equals(tag)) {\n\t\t\titemResourceId = resourceHelper.getId(node.getParentNode());\n\t\t}\n\t\tDocument resourceDescriptor = resourceHelper.getDescriptor(manifestHelper.getResourceForId(itemResourceId, this.archiveManifest));\n\t\tif (resourceHelper.isFolder(resourceDescriptor) || \n\t  \t\t    (\"item\".equals(tag) && (XPathHelper.selectNodes(\"./item\", node).size() > 0)) ||\n\t  \t\t    ( \"item\".equals(tag) && \n\t  \t          isCompoundDocument(manifestHelper.getResourceForId(itemResourceId, archiveManifest),resourceDescriptor)\n\t  \t\t    )) {\n\t\t\tString folderTitle = getTitleForNode(node);\n\t\t\tFolder folder = new Folder();\n\t\t\tfolder.setPath(contextPath);\n\t\t\tfolder.setTitle(folderTitle);\n\t\t\tfolder.setDescription(getDescriptionForNode(node));\n\t\t\tif (parent != null) {\n  \t\t\t\tfolder.setParent(parent);\n  \t\t\t\tfolder.setLegacyGroup(parent.getLegacyGroup());\n  \t\t\t} else folder.setLegacyGroup(folderTitle);\n\t\t\t// now we take care of the folder's child Nodes\n\t\t\t// construct a new path and make sure we replace any forward slashes from the resource title\n\t\t\tString folderPath = contextPath + folderTitle.replaceAll(\"/\", \"_\") + \"/\";\n\t\t\tif (isCompoundDocument(manifestHelper.getResourceForId(itemResourceId, archiveManifest),resourceDescriptor)) {\n\t\t\t\tbranchOfImportables.addAll(translateFromNodeToImportables(manifestHelper.getResourceForId(itemResourceId, archiveManifest), folderPath,folder));\n\t\t\t} else {\n\t  \t\t\tList children = XPathHelper.selectNodes(\"./item\", node);\n\t  \t\t\tfor (Iterator i = children.iterator(); i.hasNext();) {\n\t  \t\t\t\tbranchOfImportables.addAll(\n\t  \t\t\t\t\t\ttranslateFromNodeToImportables((Node)i.next(),folderPath, folder));\n\t  \t\t\t}\n\t\t\t}\n  \t\t\tresourceMap.remove(itemResourceId);\n  \t\t\tbranchOfImportables.add(folder);\n\t\t} // node is folder\n\t\t\n\t\telse if(\"item\".equals(tag)) {\n\t\t\t// this item is a leaf, so we handle the resource associated with it\n\t\t\tNode resourceNode = manifestHelper.getResourceForId(itemResourceId, this.archiveManifest);\n  \t\t\tif (resourceNode != null) {\n  \t\t\t\tif (parent == null) {\n  \t\t\t\t\tparent = new Folder();\n  \t\t\t\t\tparent.setLegacyGroup(itemHelper.getTitle(node));\n  \t\t\t\t}\n  \t\t\t\tbranchOfImportables.addAll(\n  \t\t\t\t\t\ttranslateFromNodeToImportables(resourceNode,contextPath, parent));\n  \t\t\t}\n\t\t} else if(\"file\".equals(tag)) {\n\t\t\tFileResource file = new FileResource();\n\t\t\ttry {\n\t\t\t\tString fileName = fileHelper.getFilenameForNode(node);\n \t\t\t\tfile.setFileName(fileName);\n\t\t\t\t// If \n\t\t\t\tif (node.getParentNode().getChildNodes().getLength() > 1) {\n\t\t\t\t\tfile.setDescription(\"\");\n\t\t\t\t} else file.setDescription(resourceHelper.getDescription(node.getParentNode()));\n\t\t\t\tfile.setFileBytes(fileHelper.getFileBytesForNode(node, contextPath));\n\t\t\t\tfile.setDestinationResourcePath(fileHelper.getFilePathForNode(node, contextPath));\n\t\t\t\tfile.setContentType(this.mimeTypes.getContentType(fileName));\n\t\t\t\tfile.setTitle(fileHelper.getTitle(node));\n\t\t\t\tif(parent != null) {\n\t\t\t\t\tfile.setParent(parent);\n\t\t\t\t\tfile.setLegacyGroup(parent.getLegacyGroup());\n\t\t\t\t} else file.setLegacyGroup(\"\");\n\t\t\t} catch (IOException e) {\n\t\t\t\tresourceMap.remove(resourceHelper.getId(node.getParentNode()));\n\t\t\t\treturn branchOfImportables;\n\t\t\t}\n\t\t\tbranchOfImportables.add(file);\n\t\t\tresourceMap.remove(resourceHelper.getId(node.getParentNode()));\n\t\t\treturn branchOfImportables;\n\t\t} else if(\"resource\".equals(tag)) {\n\t\t\t// TODO handle a resource node\n\t\t\tImportable resource = null;\n\t\t\tboolean processResourceChildren = true;\n\t\t\tIMSResourceTranslator translator = (IMSResourceTranslator)translatorMap.get(resourceHelper.getType(node));\n\t\t\tif (translator != null) {\n\t\t\t\tString title = resourceHelper.getTitle(node);\n\t\t\t\t((Element)node).setAttribute(\"title\", title);\n\t\t\t\tresource = translator.translate(node, resourceHelper.getDescriptor(node), contextPath, this.pathToData);\n\t\t\t\tprocessResourceChildren = translator.processResourceChildren();\n\t\t\t}\n\t\t\tif (resource != null) {\n\t\t\t\tif (parent != null) {\n\t\t\t\t\tresource.setParent(parent);\n\t\t\t\t\tresource.setLegacyGroup(parent.getLegacyGroup());\n\t\t\t\t} else resource.setLegacyGroup(resourceHelper.getTitle(node));\n\t\t\t\tbranchOfImportables.add(resource);\n\t\t\t\tparent = resource;\n\t\t\t}\n\t\t\t// processing the child nodes implies that their files can wind up in the Resources tool.\n\t\t\t// this is not always desirable, such as the QTI files from assessments.\n\t\t\tif (processResourceChildren) {\n\t\t\t\tNodeList children = node.getChildNodes();\n\t\t  \t\tfor (int i = 0;i < children.getLength();i++) {\n\t\t  \t\t\tbranchOfImportables.addAll(translateFromNodeToImportables(children.item(i), contextPath, parent));\n\t\t  \t\t\t}\n\t\t\t}\n\t\t\tresourceMap.remove(itemResourceId);\n\t\t}\n\t\treturn branchOfImportables;\n\t}","commit_id":"b59f2144dacca2ddb5b80ca9b111fe47467ab7c3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"protected void addContentResource(String id, String contentType, byte[] contents, Map properties, int notifyOption) {\n\t\ttry {\n\t\t\tid = makeIdClean(id);\n\t\t\tResourcePropertiesEdit resourceProps = ContentHostingService.newResourceProperties();\n\t\t\tSet keys = properties.keySet();\n\t\t\tfor (Iterator i = keys.iterator();i.hasNext();) {\n\t\t\t\tString key = (String)i.next();\n\t\t\t\tString value = (String)properties.get(key);\n\t\t\t\tresourceProps.addProperty(key, value);\n\t\t\t}\n//\t\t\tString enclosingDirectory = id.substring(0, id.lastIndexOf('/', id.length() - 2) + 1);\n//\t\t\tif(!existsDirectory(enclosingDirectory)) {\n//\t\t\t\tMap props = new HashMap();\n//\t\t\t\tprops.put(ResourceProperties.PROP_DISPLAY_NAME, enclosingDirectory.substring(enclosingDirectory.lastIndexOf('/') + 1, enclosingDirectory.length()));\n//\t\t\t\taddContentCollection(enclosingDirectory, props);\n//\t\t\t}\n\t\t\tContentHostingService.addResource(id, contentType, contents, resourceProps, notifyOption);\n\t\t} catch (PermissionException e) {\n\t\t\tm_log.error(\"ResourcesHandler.addContentResource: \" + e.toString());\n\t\t} catch (IdUsedException e) {\n//\t\t\tTODO Auto-generated catch block\n            e.printStackTrace();\n\t\t} catch (IdInvalidException e) {\n//\t\t\tTODO Auto-generated catch block\n            e.printStackTrace();\n\t\t} catch (InconsistentException e) {\n//\t\t\tTODO Auto-generated catch block\n            e.printStackTrace();\n\t\t} catch (OverQuotaException e) {\n//\t\t\tTODO Auto-generated catch block\n            e.printStackTrace();\n\t\t} catch (ServerOverloadException e) {\n//\t\t\tTODO Auto-generated catch block\n            e.printStackTrace();\n\t\t}\n\t\t\n\t}","id":28679,"modified_method":"protected void addContentResource(String id, String contentType, byte[] contents, Map properties, int notifyOption) {\n\t\ttry {\n\t\t\tid = makeIdClean(id);\n\t\t\tResourcePropertiesEdit resourceProps = ContentHostingService.newResourceProperties();\n\t\t\tSet keys = properties.keySet();\n\t\t\tfor (Iterator i = keys.iterator();i.hasNext();) {\n\t\t\t\tString key = (String)i.next();\n\t\t\t\tString value = (String)properties.get(key);\n\t\t\t\tresourceProps.addProperty(key, value);\n\t\t\t}\n//\t\t\tString enclosingDirectory = id.substring(0, id.lastIndexOf('/', id.length() - 2) + 1);\n//\t\t\tif(!existsDirectory(enclosingDirectory)) {\n//\t\t\t\tMap props = new HashMap();\n//\t\t\t\tprops.put(ResourceProperties.PROP_DISPLAY_NAME, enclosingDirectory.substring(enclosingDirectory.lastIndexOf('/') + 1, enclosingDirectory.length()));\n//\t\t\t\taddContentCollection(enclosingDirectory, props);\n//\t\t\t}\n\t\t\tContentHostingService.addResource(id, contentType, contents, resourceProps, notifyOption);\n\t\t} catch (PermissionException e) {\n\t\t\tm_log.error(\"ResourcesHandler.addContentResource: \" + e.toString());\n\t\t} catch (IdUsedException e) {\n\t\t\tm_log.warn(\"ResourcesHandler.addContentResource IdUsedException: \" + e.toString());\n\t\t} catch (IdInvalidException e) {\n//\t\t\tTODO Auto-generated catch block\n            e.printStackTrace();\n\t\t} catch (InconsistentException e) {\n//\t\t\tTODO Auto-generated catch block\n            e.printStackTrace();\n\t\t} catch (OverQuotaException e) {\n//\t\t\tTODO Auto-generated catch block\n            e.printStackTrace();\n\t\t} catch (ServerOverloadException e) {\n//\t\t\tTODO Auto-generated catch block\n            e.printStackTrace();\n\t\t}\n\t\t\n\t}","commit_id":"b59f2144dacca2ddb5b80ca9b111fe47467ab7c3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Find the value entry in a node\n\t * @param n The node\n\t * @return The value entry as a string\n\t */\n\tpublic static final String getNodeValue(Node n)\n\t{\n\t\tint i;\n\t\tNodeList children;\n\t\tNode childnode;\n\t\tString retval;\n\t\t\n\t\tif (n==null) return null;\n\t\t\n\t\t// Find the child-nodes of this Node n:\n\t\tchildren=n.getChildNodes();\n\t\tfor (i=0;i<children.getLength();i++)  // Try all children\n\t\t{\n\t\t\tchildnode=children.item(i);\n\t\t\tretval=childnode.getNodeValue();\n\t\t\tif (retval!=null)  // We found the right value\n\t\t\t{\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":28680,"modified_method":"/**\n\t * Find the value entry in a node\n\t * @param n The node\n\t * @return The value entry as a string\n\t */\n\tpublic static final String getNodeValue(Node n)\n\t{\n\t\tif (n==null) return null;\n\t\t\n\t\t// Find the child-nodes of this Node n:\n        NodeList children=n.getChildNodes();\n\t\tfor (int i=0;i<children.getLength();i++)  // Try all children\n\t\t{\n            Node childnode=children.item(i);\n\t\t\tString retval=childnode.getNodeValue();\n\t\t\tif (retval!=null)  // We found the right value\n\t\t\t{\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"bcb1ddf8831008ddb57e272eef4273c46de9335a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Displays the macro identified by the given start comment node which contains meta data about the macro call.\n     * \n     * @param start the start comment node identifying the macro to be displayed\n     */\n    private void display(Node start)\n    {\n        // Look for the stop macro comment.\n        Node stop = start.getNextSibling();\n        int siblingCount = 0;\n        while (stop != null\n            && (stop.getNodeType() != DOMUtils.COMMENT_NODE || !\"stopmacro\".equals(stop.getNodeValue()))) {\n            stop = stop.getNextSibling();\n            siblingCount++;\n        }\n        if (stop == null) {\n            return;\n        }\n\n        Element container;\n        if (siblingCount == 1 && isMacroContainer(start.getNextSibling())) {\n            // Macro container is already there.\n            container = (Element) start.getNextSibling();\n        } else {\n            // Put macro output inside a read only text box.\n            container = createMacroContainer(start, stop, siblingCount);\n            // Expand the macro by default.\n            setCollapsed(container, false);\n        }\n\n        // Hide macro meta data.\n        container.setMetaData(extractMetaData(start, stop));\n\n        // We have to display the macro as unselected to ensure the selected state is changed only from the\n        // MacroSelector.\n        setSelected(container, false);\n    }","id":28681,"modified_method":"/**\n     * Displays the macro identified by the given start comment node which contains meta data about the macro call.\n     * \n     * @param start the start comment node identifying the macro to be displayed\n     */\n    private void display(Node start)\n    {\n        // Look for the stop macro comment.\n        Node stop = start.getNextSibling();\n        int siblingCount = 0;\n        int openedMacrosCount = 0;\n        while (stop != null) {\n            if (stop.getNodeType() == DOMUtils.COMMENT_NODE) {\n                if (stop.getNodeValue().startsWith(START_MACRO_COMMENT_PREFIX)) {\n                    // Nested macro. Ignore the next stop macro comment.\n                    openedMacrosCount++;\n                } else if (STOP_MACRO_COMMENT_VALUE.equals(stop.getNodeValue())) {\n                    // Check if there are nested macros opened.\n                    if (openedMacrosCount == 0) {\n                        break;\n                    }\n                    openedMacrosCount--;\n                }\n            }\n\n            stop = stop.getNextSibling();\n            siblingCount++;\n        }\n        if (stop == null) {\n            return;\n        }\n\n        Element container;\n        if (siblingCount == 1 && isMacroContainer(start.getNextSibling())) {\n            // Macro container is already there.\n            container = (Element) start.getNextSibling();\n        } else {\n            // Put macro output inside a read only text box.\n            container = createMacroContainer(start, stop, siblingCount);\n            // Expand the macro by default.\n            setCollapsed(container, false);\n        }\n\n        // Hide macro meta data.\n        container.setMetaData(extractMetaData(start, stop));\n\n        // We have to display the macro as unselected to ensure the selected state is changed only from the\n        // MacroSelector.\n        setSelected(container, false);\n    }","commit_id":"3b1d377c3a7a6885181e780174e2f5910820f373","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param root the root of a DOM subtree\n     * @return the list of start macro comment nodes under the given subtree\n     */\n    private List<Node> getStartMacroComments(Node root)\n    {\n        Document document = (Document) root.getOwnerDocument();\n        Iterator<Node> iterator = document.getIterator(root);\n        List<Node> startMacroComments = new ArrayList<Node>();\n        while (iterator.hasNext()) {\n            Node node = iterator.next();\n            if (node.getNodeType() == DOMUtils.COMMENT_NODE && node.getNodeValue().startsWith(\"startmacro:\")) {\n                startMacroComments.add(node);\n            }\n        }\n        return startMacroComments;\n    }","id":28682,"modified_method":"/**\n     * @param root the root of a DOM subtree\n     * @return the list of start macro comment nodes for the top level macros under the given subtree (nested macros are\n     *         ignored)\n     */\n    private List<Node> getStartMacroComments(Node root)\n    {\n        Document document = (Document) root.getOwnerDocument();\n        Iterator<Node> iterator = document.getIterator(root);\n        List<Node> startMacroComments = new ArrayList<Node>();\n        int openedMacrosCount = 0;\n        while (iterator.hasNext()) {\n            Node node = iterator.next();\n            if (node.getNodeType() == DOMUtils.COMMENT_NODE) {\n                if (node.getNodeValue().startsWith(START_MACRO_COMMENT_PREFIX)) {\n                    // Include only the top level macros.\n                    if (openedMacrosCount == 0) {\n                        startMacroComments.add(node);\n                    }\n                    openedMacrosCount++;\n                } else if (STOP_MACRO_COMMENT_VALUE.equals(node.getNodeValue())) {\n                    openedMacrosCount--;\n                }\n            }\n        }\n        return startMacroComments;\n    }","commit_id":"3b1d377c3a7a6885181e780174e2f5910820f373","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getString(String name, String defaultValue) {\n    Node attr = node.getAttributes().getNamedItem(name);\n    return (attr == null) ? defaultValue : attr.getNodeValue();\n  }","id":28683,"modified_method":"public String getString(String name, String defaultValue) {\n    NamedNodeMap attrs = node.getAttributes();\n    if (attrs != null) {\n      Node attr = attrs.getNamedItem(name);\n      if (attr != null) {\n        return attr.getNodeValue();\n      }\n    }\n    return defaultValue;\n  }","commit_id":"959c8c9d09000ae6cc40ebffbb4b1f16b015479a","url":"https://github.com/processing/processing"},{"original_method":"/**\n * checks if the resource sticks to the rules for templates and bodys if it is in\n * the correlative path. If this method is called from the CmsImport the resource\n * does not exist in opencms therefor the content is part of the parameter.\n *\n * @param name The absolute path of the resource in OpenCms.\n * @param content The content of the resource.\n * @param type The resource type.\n * @return true if the resource is ok.\n */\npublic boolean isTemplateCompatible(String name, byte[] content, String type){\n    if ( name == null){\n        return false;\n    }\n    if (name.startsWith(\"/content/bodys/\")){\n        // this is a body file\n        if (!C_TYPE_PLAIN_NAME.equals(type)){\n            // only plain files allowed in content/bodys\n            return false;\n        }\n        // to check the rest we have to parse the content\n        try{\n            org.w3c.dom.Document xmlDoc = A_CmsXmlContent.getXmlParser().parse(\n                                            new java.io.StringReader(new String(content)));\n             for(Node n = xmlDoc.getFirstChild(); n != null; n = treeWalker(xmlDoc, n)) {\n                System.err.println(\"mgm--node:\"+ n.getNodeName()+\" type:\"+n.getNodeType()+\" value:\"+n.getNodeValue());\n                if((n.getNodeType() > n.CDATA_SECTION_NODE) || (n.getNodeType() == n.ATTRIBUTE_NODE)){\n                    return false;\n                }\n                if(n.getNodeType() == n.ELEMENT_NODE){\n                    String tagName = n.getNodeName();\n                    if(!(\"template\".equalsIgnoreCase(tagName) || \"xmltemplate\".equalsIgnoreCase(tagName))){\n                        return false;\n                    }\n                }\n            }\n        }catch(Exception e){\n            return false;\n        }\n\n    } else if (name.startsWith(\"/content/templates/\")\n                || (name.startsWith(\"/system/modules/\") && name.indexOf(\"/templates/\") > -1)){\n        // this is a template file\n        if (!C_TYPE_PLAIN_NAME.equals(type)){\n            // only plain templates are allowed\n            return false;\n        }\n        // to check the rest we have to parse the content\n        try{\n            org.w3c.dom.Document xmlDoc = A_CmsXmlContent.getXmlParser().parse(\n                                            new java.io.StringReader(new String(content)));\n            NodeList list = xmlDoc.getChildNodes();\n            for(int i=0; i<list.getLength(); i++){\n                Node n = list.item(i);\n//mgm at work                System.err.println(\"mgm--t node:\"+ n.getNodeName()+\" type:\"+n.getNodeType()+\" value:\"+n.getNodeValue());\n            }\n\n        }catch(Exception e){\n            return false;\n        }\n    }\n    return true;\n}","id":28684,"modified_method":"/**\n     * checks if the resource sticks to the rules for templates and bodys if it is in\n     * the correlative path. If this method is called from the CmsImport the resource\n     * does not exist in opencms therefor the content is part of the parameter.\n     *\n     * @param name The absolute path of the resource in OpenCms.\n     * @param content The content of the resource.\n     * @param type The resource type.\n     * @return true if the resource is ok.\n     */\n    public boolean isTemplateCompatible(String name, byte[] content, String type){\n        if ( name == null){\n            return false;\n        }\n        if (name.startsWith(\"/content/bodys/\")){\n            // this is a body file\n            if (!C_TYPE_PLAIN_NAME.equals(type)){\n                // only plain files allowed in content/bodys\n                return false;\n            }\n            // to check the rest we have to parse the content\n            try{\n                org.w3c.dom.Document xmlDoc = A_CmsXmlContent.getXmlParser().parse(\n                                                new java.io.StringReader(new String(content)));\n                 for(Node n = xmlDoc.getFirstChild(); n != null; n = treeWalker(xmlDoc, n)) {\n                    short ntype = n.getNodeType();\n                    if(((ntype > n.CDATA_SECTION_NODE) && ntype < n.DOCUMENT_TYPE_NODE)\n                                        || (ntype == n.ATTRIBUTE_NODE)){\n                        return false;\n                    }\n                    if(n.getNodeType() == n.ELEMENT_NODE){\n                        String tagName = n.getNodeName();\n                        if(!(\"template\".equalsIgnoreCase(tagName) || \"xmltemplate\".equalsIgnoreCase(tagName))){\n                            return false;\n                        }\n                    }\n                }\n            }catch(Exception e){\n                return false;\n            }\n\n        } else if (name.startsWith(\"/content/templates/\")\n                    || (name.startsWith(\"/system/modules/\") && name.indexOf(\"/templates/\") > -1)){\n            // this is a template file\n            if (!C_TYPE_PLAIN_NAME.equals(type)){\n                // only plain templates are allowed\n                return false;\n            }\n            // to check the rest we have to parse the content\n            try{\n                org.w3c.dom.Document xmlDoc = A_CmsXmlContent.getXmlParser().parse(\n                                                new java.io.StringReader(new String(content)));\n                // we check the sub nodes from <xmltemplate>\n                // there should be the two elementdefs, one template and some empty text nodes\n                NodeList list = xmlDoc.getChildNodes();\n                list = (list.item(0)).getChildNodes();\n                int counterEldefs = 0;\n                int counterTeplate = 0;\n                for(int i=0; i<list.getLength(); i++){\n                    Node n = list.item(i);\n                    short nodeType = n.getNodeType();\n                    if(nodeType == n.ELEMENT_NODE){\n                        // allowed is the Elementdef or the template tag\n                        String nodeName = n.getNodeName();\n                        if (\"elementdef\".equalsIgnoreCase(nodeName)){\n                            // check the rules for the elementdefinitions\n                            if(!isElementDefOk((Element)n)){\n                                return false;\n                            }\n                            counterEldefs++;\n                        }else if(\"template\".equalsIgnoreCase(nodeName)){\n                            // check if the template node is ok.\n                            if(!isTemplateTagOk((Element)n)){\n                                return false;\n                            }\n                            counterTeplate++;\n                        }else{\n                            //this name is not allowed\n                            return false;\n                        }\n\n                    }else if(nodeType == n.TEXT_NODE){\n                        // text node is only allowed if the value is empty\n                        String nodeValue = n.getNodeValue();\n                        if((nodeValue != null) && (nodeValue.trim().length() > 0)){\n                            return false;\n                        }\n                    }else{\n                        // this nodeType is not allowed\n                        return false;\n                    }\n                }\n                if(counterEldefs != 2 || counterTeplate != 1){\n                    // there have to be exactly two elementdefs and one template tag\n                    return false;\n                }\n\n            }catch(Exception e){\n                return false;\n            }\n        }\n        return true;\n    }","commit_id":"cb7d255ccb32224268bd1d685980a2e0085fc789","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * checks if the file sticks to the rules for files in the conten path.\n     * If not, it sets the type of the file to compatible_plain.\n     * This is for exports of older versions of OpenCms. The imported files\n     * will work as befor, but they cant be edited.\n     *\n     * @param path the path the resource will be imported to.\n     * @param name The name of the resource.\n     * @param content the content of the resource.\n     * @param type the type of the resourse, is set to compatible_plain if nessesary.\n     * @param properties the properties, not yet used here.\n     * @return the new type of the resouce\n     */\n    private String fitFileType(String path, String name, byte[] content, String type, Hashtable properties){\n\n        // only check the file if the version of the export is 0\n        if(m_importVersion == 0){\n            // ok, an old system exported this, check if the file is ok\n            if(!(new CmsCompatibleCheck()).isTemplateCompatible(path+name, content, type)){\n                type = C_TYPE_COMPATIBLEPLAIN_NAME;\n            }\n        }\n        return type;\n    }","id":28685,"modified_method":"/**\n     * checks if the file sticks to the rules for files in the conten path.\n     * If not, it sets the type of the file to compatible_plain.\n     * This is for exports of older versions of OpenCms. The imported files\n     * will work as befor, but they cant be edited.\n     *\n     * @param path the path the resource will be imported to.\n     * @param name The name of the resource.\n     * @param content the content of the resource.\n     * @param type the type of the resourse, is set to compatible_plain if nessesary.\n     * @param properties the properties, not yet used here.\n     * @return the new type of the resouce\n     */\n    private String fitFileType(String path, String name, byte[] content, String type, Hashtable properties){\n\n        // first if the type is javascript set it to plain\n        if(\"script\".equals(type)){\n            type = C_TYPE_PLAIN_NAME;\n        }\n\n        // only check the file if the version of the export is 0\n        if(m_importVersion == 0){\n            // ok, an old system exported this, check if the file is ok\n            if(!(new CmsCompatibleCheck()).isTemplateCompatible(path+name, content, type)){\n                type = C_TYPE_COMPATIBLEPLAIN_NAME;\n            }\n        }\n        return type;\n    }","commit_id":"cb7d255ccb32224268bd1d685980a2e0085fc789","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * This constructs a new CmsImport-object which imports the resources.\n     *\n     * @param importFile the file or folder to import from.\n     * @param importPath the path to the cms to import into.\n     * @exception CmsException the CmsException is thrown if something goes wrong.\n     */\n    public CmsImport(String importFile, String importPath, CmsObject cms)\n        throws CmsException {\n\n        m_importFile = importFile;\n        m_importPath = importPath;\n        m_cms = cms;\n\n        // create the digest\n        createDigest();\n\n        // open the import resource\n        getImportResource();\n\n        // read the xml-config file\n        getXmlConfigFile();\n\n        // try to read the export version nummber\n        try{\n            m_importVersion = Integer.parseInt(\n                getTextNodeValue((Element)m_docXml.getElementsByTagName(\n                    C_EXPORT_TAG_INFO).item(0) , C_EXPORT_TAG_VERSION));\n        }catch(Exception e){\n            //ignore the exception, the export file has no version nummber (version 0).\n        }\n        System.err.println(\"mgm--importVersion: \"+m_importVersion);\n    }","id":28686,"modified_method":"/**\n     * This constructs a new CmsImport-object which imports the resources.\n     *\n     * @param importFile the file or folder to import from.\n     * @param importPath the path to the cms to import into.\n     * @exception CmsException the CmsException is thrown if something goes wrong.\n     */\n    public CmsImport(String importFile, String importPath, CmsObject cms)\n        throws CmsException {\n\n        m_importFile = importFile;\n        m_importPath = importPath;\n        m_cms = cms;\n\n        // create the digest\n        createDigest();\n\n        // open the import resource\n        getImportResource();\n\n        // read the xml-config file\n        getXmlConfigFile();\n\n        // try to read the export version nummber\n        try{\n            m_importVersion = Integer.parseInt(\n                getTextNodeValue((Element)m_docXml.getElementsByTagName(\n                    C_EXPORT_TAG_INFO).item(0) , C_EXPORT_TAG_VERSION));\n        }catch(Exception e){\n            //ignore the exception, the export file has no version nummber (version 0).\n        }\n    }","commit_id":"cb7d255ccb32224268bd1d685980a2e0085fc789","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t* Copies a Resource.\n\t*\n\t* @param source the complete path of the sourcefile.\n\t* @param destination the complete path of the destinationfolder.\n\t* @param keepFlags <code>true<\/code> if the copy should keep the source file's flags,\n\t*        <code>false<\/code> if the copy should get the user's default flags.\n\t*\n\t* @exception CmsException if the file couldn't be copied, or the user\n\t* has not the appropriate rights to copy the file.\n\t*/\n\tpublic void copyResource(CmsObject cms, String source, String destination, boolean keepFlags) throws CmsException{\n// mgm - at work\n\t\tcms.doCopyFile(source, destination);\n        if(!keepFlags) {\n            setDefaultFlags(cms, destination);\n        }\n\t}","id":28687,"modified_method":"/**\n\t* Copies a Resource.\n\t*\n\t* @param source the complete path of the sourcefile.\n\t* @param destination the complete path of the destinationfolder.\n\t* @param keepFlags <code>true<\/code> if the copy should keep the source file's flags,\n\t*        <code>false<\/code> if the copy should get the user's default flags.\n\t*\n\t* @exception CmsException if the file couldn't be copied, or the user\n\t* has not the appropriate rights to copy the file.\n\t*/\n\tpublic void copyResource(CmsObject cms, String source, String destination, boolean keepFlags) throws CmsException{\n\t\tcms.doCopyFile(source, destination);\n        if(!keepFlags) {\n            setDefaultFlags(cms, destination);\n        }\n        cms.doChtype(destination, I_CmsConstants.C_TYPE_PLAIN_NAME);\n\t}","commit_id":"cb7d255ccb32224268bd1d685980a2e0085fc789","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void updateOptionsPanel() {\n    final FrameworkSupportNodeBase node = getSelectedNode();\n    if (node instanceof FrameworkSupportNode) {\n      FrameworkSupportNode frameworkSupportNode = (FrameworkSupportNode)node;\n      initializeOptionsPanel(frameworkSupportNode);\n      showCard(frameworkSupportNode.getProvider().getFrameworkType().getId());\n      UIUtil.setEnabled(myOptionsPanel, frameworkSupportNode.isChecked(), true);\n      frameworkSupportNode.getConfigurable().onFrameworkSelectionChanged(node.isChecked());\n    }\n    else if (node instanceof FrameworkGroupNode) {\n      FrameworkGroup<?> group = ((FrameworkGroupNode)node).getGroup();\n      initializeGroupPanel(group);\n      showCard(group.getId());\n    }\n    else {\n      showCard(EMPTY_CARD);\n    }\n  }","id":28688,"modified_method":"private void updateOptionsPanel() {\n    final FrameworkSupportNodeBase node = getSelectedNode();\n    if (node instanceof FrameworkSupportNode) {\n      FrameworkSupportNode frameworkSupportNode = (FrameworkSupportNode)node;\n      initializeOptionsPanel(frameworkSupportNode);\n      showCard(frameworkSupportNode.getProvider().getFrameworkType().getId());\n      UIUtil.setEnabled(myOptionsPanel, frameworkSupportNode.isChecked(), true);\n      frameworkSupportNode.getConfigurable().onFrameworkSelectionChanged(node.isChecked());\n    }\n    else if (node instanceof FrameworkGroupNode) {\n      FrameworkGroup<?> group = ((FrameworkGroupNode)node).getGroup();\n      initializeGroupPanel(group);\n      showCard(group.getId());\n      UIUtil.setEnabled(myOptionsPanel, true, true);\n    }\n    else {\n      showCard(EMPTY_CARD);\n    }\n  }","commit_id":"17891c949766b3852b18db7d6424e7228f91cfd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setSelectedVersion(@NotNull String frameworkOrGroupId, @NotNull FrameworkVersion version) {\n    FrameworkVersion oldVersion = mySelectedVersions.put(frameworkOrGroupId, version);\n    if (!Comparing.equal(oldVersion, version)) {\n      for (Map.Entry<String, FrameworkSupportNode> entry : mySettingsMap.entrySet()) {\n        if (hasParentWithId(entry.getValue(), frameworkOrGroupId)) {\n          updateFrameworkLibraryComponent(entry.getKey());\n        }\n      }\n    }\n    myVersionEventDispatcher.getMulticaster().versionChanged(version);\n  }","id":28689,"modified_method":"public void setSelectedVersion(@NotNull String frameworkOrGroupId, @NotNull FrameworkVersion version) {\n    FrameworkVersion oldVersion = mySelectedVersions.put(frameworkOrGroupId, version);\n    if (!Comparing.equal(oldVersion, version)) {\n      for (Map.Entry<String, FrameworkSupportNode> entry : mySettingsMap.entrySet()) {\n        if (hasParentWithId(entry.getValue(), frameworkOrGroupId)) {\n          if (!entry.getValue().getId().equals(frameworkOrGroupId)) {\n            FrameworkSupportOptionsComponent component = myOptionsComponentsMap.get(entry.getKey());\n            if (component != null) {\n              component.updateVersionsComponent();\n            }\n          }\n          updateFrameworkLibraryComponent(entry.getKey());\n        }\n      }\n    }\n    myVersionEventDispatcher.getMulticaster().versionChanged(version);\n  }","commit_id":"17891c949766b3852b18db7d6424e7228f91cfd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FrameworkSupportOptionsComponent(FrameworkSupportModelBase model,\n                                          LibrariesContainer container,\n                                          Disposable parentDisposable,\n                                          FrameworkSupportInModuleProvider provider,\n                                          final FrameworkSupportInModuleConfigurable configurable) {\n    myModel = model;\n    myConfigurable = configurable;\n    VerticalFlowLayout layout = new VerticalFlowLayout();\n    layout.setVerticalFill(true);\n    myMainPanel = new JPanel(layout);\n    myModel.registerOptionsComponent(provider, this);\n    List<FrameworkVersion> versions = provider.getFrameworkType().getVersions();\n    if (!versions.isEmpty()) {\n      myMainPanel.add(new FrameworkVersionComponent(model, provider.getFrameworkType().getId(), versions).getMainPanel());\n    }\n\n    final JComponent component = myConfigurable.createComponent();\n    if (component != null) {\n      myMainPanel.add(component);\n    }\n\n    final boolean addSeparator = component != null || !versions.isEmpty();\n    myLibraryOptionsPanelWrapper = new JPanel(new BorderLayout());\n    myMainPanel.add(myLibraryOptionsPanelWrapper);\n    if (myConfigurable instanceof OldFrameworkSupportProviderWrapper.FrameworkSupportConfigurableWrapper) {\n      ((OldFrameworkSupportProviderWrapper.FrameworkSupportConfigurableWrapper)myConfigurable).getConfigurable().addListener(\n        new FrameworkSupportConfigurableListener() {\n          public void frameworkVersionChanged() {\n            updateLibrariesPanel();\n          }\n        });\n    }\n    model.addFrameworkListener(new FrameworkSupportModelAdapter() {\n      @Override\n      public void wizardStepUpdated() {\n        updateLibrariesPanel();\n      }\n    }, parentDisposable);\n\n    final CustomLibraryDescription description = myConfigurable.createLibraryDescription();\n    if (description != null) {\n      myLibraryOptionsPanel = new LibraryOptionsPanel(description, myModel.getBaseDirectoryForLibrariesPath(), createLibraryVersionFilter(),\n                                                      container, !myConfigurable.isOnlyLibraryAdded());\n      Disposer.register(myConfigurable, myLibraryOptionsPanel);\n      if (addSeparator) {\n        JComponent separator1 = SeparatorFactory.createSeparator(\"Libraries\", null);\n        separator1.setBorder(IdeBorderFactory.createEmptyBorder(5, 0, 5, 5));\n        myLibraryOptionsPanelWrapper.add(BorderLayout.NORTH, separator1);\n      }\n      myLibraryOptionsPanelWrapper.add(BorderLayout.CENTER, myLibraryOptionsPanel.getMainPanel());\n      myLibraryOptionsPanelWrapper.setVisible(myConfigurable.isVisible());\n    }\n  }","id":28690,"modified_method":"public FrameworkSupportOptionsComponent(FrameworkSupportModelBase model,\n                                          LibrariesContainer container,\n                                          Disposable parentDisposable,\n                                          FrameworkSupportInModuleProvider provider,\n                                          final FrameworkSupportInModuleConfigurable configurable) {\n    myModel = model;\n    myConfigurable = configurable;\n    VerticalFlowLayout layout = new VerticalFlowLayout();\n    layout.setVerticalFill(true);\n    myMainPanel = new JPanel(layout);\n    myModel.registerOptionsComponent(provider, this);\n    List<FrameworkVersion> versions = provider.getFrameworkType().getVersions();\n    if (!versions.isEmpty()) {\n      myFrameworkVersionComponent = new FrameworkVersionComponent(model, provider.getFrameworkType().getId(), versions);\n      myMainPanel.add(myFrameworkVersionComponent.getMainPanel());\n    }\n\n    final JComponent component = myConfigurable.createComponent();\n    if (component != null) {\n      myMainPanel.add(component);\n    }\n\n    final boolean addSeparator = component != null || myFrameworkVersionComponent != null;\n    myLibraryOptionsPanelWrapper = new JPanel(new BorderLayout());\n    myMainPanel.add(myLibraryOptionsPanelWrapper);\n    if (myConfigurable instanceof OldFrameworkSupportProviderWrapper.FrameworkSupportConfigurableWrapper) {\n      ((OldFrameworkSupportProviderWrapper.FrameworkSupportConfigurableWrapper)myConfigurable).getConfigurable().addListener(\n        new FrameworkSupportConfigurableListener() {\n          public void frameworkVersionChanged() {\n            updateLibrariesPanel();\n          }\n        });\n    }\n    model.addFrameworkListener(new FrameworkSupportModelAdapter() {\n      @Override\n      public void wizardStepUpdated() {\n        updateLibrariesPanel();\n      }\n    }, parentDisposable);\n\n    final CustomLibraryDescription description = myConfigurable.createLibraryDescription();\n    if (description != null) {\n      myLibraryOptionsPanel = new LibraryOptionsPanel(description, myModel.getBaseDirectoryForLibrariesPath(), createLibraryVersionFilter(),\n                                                      container, !myConfigurable.isOnlyLibraryAdded());\n      Disposer.register(myConfigurable, myLibraryOptionsPanel);\n      if (addSeparator) {\n        JComponent separator1 = SeparatorFactory.createSeparator(\"Libraries\", null);\n        separator1.setBorder(IdeBorderFactory.createEmptyBorder(5, 0, 5, 5));\n        myLibraryOptionsPanelWrapper.add(BorderLayout.NORTH, separator1);\n      }\n      myLibraryOptionsPanelWrapper.add(BorderLayout.CENTER, myLibraryOptionsPanel.getMainPanel());\n      myLibraryOptionsPanelWrapper.setVisible(myConfigurable.isVisible());\n    }\n  }","commit_id":"17891c949766b3852b18db7d6424e7228f91cfd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FrameworkVersionComponent(final FrameworkSupportModelBase model, final String frameworkOrGroupId,\n                                   final List<? extends FrameworkVersion> versions) {\n    JPanel panel = new JPanel(new VerticalFlowLayout());\n    if (!versions.isEmpty()) {\n      final ComboBox versionsBox = new ComboBox();\n      versionsBox.setRenderer(new ListCellRendererWrapper<FrameworkVersion>() {\n        @Override\n        public void customize(JList list, FrameworkVersion value, int index, boolean selected, boolean hasFocus) {\n          setText(value != null ? value.getPresentableName() : \"\");\n        }\n      });\n      versionsBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          model.setSelectedVersion(frameworkOrGroupId, (FrameworkVersion)versionsBox.getSelectedItem());\n        }\n      });\n      for (FrameworkVersion version : versions) {\n        versionsBox.addItem(version);\n      }\n      FrameworkVersion latestVersion = versions.get(versions.size() - 1);\n      versionsBox.setSelectedItem(latestVersion);\n      model.setSelectedVersion(frameworkOrGroupId, latestVersion);\n      panel.add(FormBuilder.createFormBuilder().addLabeledComponent(\"Version:\", versionsBox).getPanel());\n    }\n    myMainPanel = panel;\n  }","id":28691,"modified_method":"public FrameworkVersionComponent(final FrameworkSupportModelBase model, final String frameworkOrGroupId,\n                                   final List<? extends FrameworkVersion> versions_) {\n    myModel = model;\n    myAllVersions = versions_;\n    myMainPanel = new JPanel(new VerticalFlowLayout());\n    myFrameworkOrGroupId = frameworkOrGroupId;\n    myVersionsBox = new ComboBox();\n    myVersionsBox.setRenderer(new ListCellRendererWrapper<FrameworkVersion>() {\n      @Override\n      public void customize(JList list, FrameworkVersion value, int index, boolean selected, boolean hasFocus) {\n        setText(value != null ? value.getPresentableName() : \"\");\n      }\n    });\n    myVersionsBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        FrameworkVersion selectedVersion = getSelectedVersion();\n        if (selectedVersion != null) {\n          model.setSelectedVersion(frameworkOrGroupId, selectedVersion);\n        }\n      }\n    });\n\n    myVersionsPanel = FormBuilder.createFormBuilder().addLabeledComponent(\"Version:\", myVersionsBox).getPanel();\n    myMainPanel.add(myVersionsPanel);\n    updateVersionsList();\n  }","commit_id":"17891c949766b3852b18db7d6424e7228f91cfd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void initializeControls(PsiExpression initializerExpression, BaseExpressionToFieldHandler.InitializationPlace ourLastInitializerPlace) {\n    super.initializeControls(initializerExpression, ourLastInitializerPlace);\n    initializeInitializerPlace(initializerExpression, ourLastInitializerPlace);\n    String ourLastVisibility = JavaRefactoringSettings.getInstance().INTRODUCE_FIELD_VISIBILITY;\n    setVisibility(ourLastVisibility);\n  }","id":28692,"modified_method":"protected void initializeControls(PsiExpression initializerExpression, BaseExpressionToFieldHandler.InitializationPlace ourLastInitializerPlace) {\n    super.initializeControls(initializerExpression, ourLastInitializerPlace);\n\n    String ourLastVisibility = JavaRefactoringSettings.getInstance().INTRODUCE_FIELD_VISIBILITY;\n    setVisibility(ourLastVisibility);\n  }","commit_id":"3be8c309f135a41cbcb9eaf9b6a7cb9cb1190dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean setEnabledInitializationPlaces(PsiElement initializerPart, PsiElement initializer) {\n    if (initializerPart instanceof PsiReferenceExpression) {\n      PsiReferenceExpression refExpr = (PsiReferenceExpression) initializerPart;\n      if (refExpr.getQualifierExpression() == null) {\n        PsiElement refElement = refExpr.resolve();\n        if (refElement == null ||\n            (refElement instanceof PsiLocalVariable || refElement instanceof PsiParameter) &&\n            !PsiTreeUtil.isAncestor(initializer, refElement, true)) {\n          myInitialisersPlaceModel.removeElement(BaseExpressionToFieldHandler.InitializationPlace.IN_FIELD_DECLARATION);\n          myInitialisersPlaceModel.removeElement(BaseExpressionToFieldHandler.InitializationPlace.IN_CONSTRUCTOR);\n          myInitialisersPlaceModel.removeElement(BaseExpressionToFieldHandler.InitializationPlace.IN_SETUP_METHOD);\n          enableFinal(false);\n          return false;\n        }\n      }\n    }\n    PsiElement[] children = initializerPart.getChildren();\n    for (PsiElement child : children) {\n      if (!setEnabledInitializationPlaces(child, initializer)) return false;\n    }\n    return true;\n  }","id":28693,"modified_method":"protected boolean setEnabledInitializationPlaces(PsiElement initializerPart, PsiElement initializer) {\n    if (initializerPart instanceof PsiReferenceExpression) {\n      PsiReferenceExpression refExpr = (PsiReferenceExpression) initializerPart;\n      if (refExpr.getQualifierExpression() == null) {\n        PsiElement refElement = refExpr.resolve();\n        if (refElement == null ||\n            (refElement instanceof PsiLocalVariable || refElement instanceof PsiParameter) &&\n            !PsiTreeUtil.isAncestor(initializer, refElement, true)) {\n          myInitialisersPlaceModel.removeElement(BaseExpressionToFieldHandler.InitializationPlace.IN_FIELD_DECLARATION);\n          myInitialisersPlaceModel.removeElement(BaseExpressionToFieldHandler.InitializationPlace.IN_CONSTRUCTOR);\n          myInitialisersPlaceModel.removeElement(BaseExpressionToFieldHandler.InitializationPlace.IN_SETUP_METHOD);\n          return false;\n        }\n      }\n    }\n    PsiElement[] children = initializerPart.getChildren();\n    for (PsiElement child : children) {\n      if (!setEnabledInitializationPlaces(child, initializer)) return false;\n    }\n    return true;\n  }","commit_id":"3be8c309f135a41cbcb9eaf9b6a7cb9cb1190dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean allowFinal() {\n    final Object selectedItem = myInitializerCombo.getSelectedItem();\n    boolean allowFinal = selectedItem == BaseExpressionToFieldHandler.InitializationPlace.IN_FIELD_DECLARATION ||\n                         (selectedItem == BaseExpressionToFieldHandler.InitializationPlace.IN_CONSTRUCTOR && !myWillBeDeclaredStatic);\n    if (selectedItem == BaseExpressionToFieldHandler.InitializationPlace.IN_CURRENT_METHOD && myIsCurrentMethodConstructor) {\n      final PsiMethod[] constructors = myParentClass.getConstructors();\n      allowFinal = constructors.length <= 1;\n    }\n    return allowFinal;\n  }","id":28694,"modified_method":"@Override\n  protected boolean allowFinal() {\n    final Object selectedItem = getInitializerPlace();\n    boolean allowFinal = selectedItem == BaseExpressionToFieldHandler.InitializationPlace.IN_FIELD_DECLARATION ||\n                         (selectedItem == BaseExpressionToFieldHandler.InitializationPlace.IN_CONSTRUCTOR && !myWillBeDeclaredStatic);\n    if (selectedItem == BaseExpressionToFieldHandler.InitializationPlace.IN_CURRENT_METHOD && myIsCurrentMethodConstructor) {\n      final PsiMethod[] constructors = myParentClass.getConstructors();\n      allowFinal = constructors.length <= 1;\n    }\n    return allowFinal;\n  }","commit_id":"3be8c309f135a41cbcb9eaf9b6a7cb9cb1190dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BaseExpressionToFieldHandler.InitializationPlace getInitializerPlace() {\n    return (BaseExpressionToFieldHandler.InitializationPlace)myInitializerCombo.getSelectedItem();\n  }","id":28695,"modified_method":"public BaseExpressionToFieldHandler.InitializationPlace getInitializerPlace() {\n    if (myInitializerCombo != null) {\n      return (BaseExpressionToFieldHandler.InitializationPlace)myInitializerCombo.getSelectedItem();\n    }\n    return (BaseExpressionToFieldHandler.InitializationPlace)myInitialisersPlaceModel.getElementAt(0);\n  }","commit_id":"3be8c309f135a41cbcb9eaf9b6a7cb9cb1190dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setInitializeInFieldDeclaration() {\n    myInitializerCombo.setSelectedItem(BaseExpressionToFieldHandler.InitializationPlace.IN_FIELD_DECLARATION);\n  }","id":28696,"modified_method":"public void setInitializeInFieldDeclaration() {\n    LOG.assertTrue(myInitializerCombo != null);\n    myInitializerCombo.setSelectedItem(BaseExpressionToFieldHandler.InitializationPlace.IN_FIELD_DECLARATION);\n  }","commit_id":"3be8c309f135a41cbcb9eaf9b6a7cb9cb1190dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createInitializerPlacePanel(final ItemListener itemListener, final ItemListener finalUpdater) {\n    JPanel mainPanel = new JPanel();\n    mainPanel.setLayout(new BorderLayout());\n\n   JPanel groupPanel = new JPanel(new GridBagLayout());\n    final GridBagConstraints gridBagConstraints =\n      new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,\n                             new Insets(0, 5, 0, 0), 0, 0);\n    gridBagConstraints.insets.top = 5;\n    final JLabel initLabel = new JLabel(RefactoringBundle.message(\"initialize.in.border.title\") + \":\");\n    initLabel.setDisplayedMnemonic('i');\n    groupPanel.add(initLabel, gridBagConstraints);\n\n    myInitialisersPlaceModel = new DefaultComboBoxModel();\n    myInitialisersPlaceModel.addElement(BaseExpressionToFieldHandler.InitializationPlace.IN_CURRENT_METHOD);\n    myInitialisersPlaceModel.addElement(BaseExpressionToFieldHandler.InitializationPlace.IN_FIELD_DECLARATION);\n    myInitialisersPlaceModel.addElement(BaseExpressionToFieldHandler.InitializationPlace.IN_CONSTRUCTOR);\n    if (TestUtil.isTestClass(myParentClass)) {\n      myInitialisersPlaceModel.addElement(BaseExpressionToFieldHandler.InitializationPlace.IN_SETUP_METHOD);\n    }\n    myInitializerCombo = new JComboBox(myInitialisersPlaceModel);\n    InplaceIntroduceConstantPopup.appendActions(myInitializerCombo, myParentClass.getProject());\n    initLabel.setLabelFor(myInitializerCombo);\n    myInitializerCombo.setRenderer(new ListCellRendererWrapper<BaseExpressionToFieldHandler.InitializationPlace>(myInitializerCombo) {\n      @Override\n      public void customize(JList list,\n                            BaseExpressionToFieldHandler.InitializationPlace value,\n                            int index,\n                            boolean selected,\n                            boolean hasFocus) {\n        if (value == BaseExpressionToFieldHandler.InitializationPlace.IN_CURRENT_METHOD) {\n          setText(\"current method\");\n        } else if (value == BaseExpressionToFieldHandler.InitializationPlace.IN_CONSTRUCTOR) {\n          setText(\"constructor\");\n        } else if (value == BaseExpressionToFieldHandler.InitializationPlace.IN_FIELD_DECLARATION) {\n          setText(\"field declaration\");\n        } else {\n          setText(\"setUp\");\n        }\n      }\n    });\n    myInitializerCombo.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        itemListener.itemStateChanged(null);\n        finalUpdater.itemStateChanged(null);\n      }\n    });\n    gridBagConstraints.gridx = 1;\n    gridBagConstraints.insets.top = 0;\n    gridBagConstraints.insets.left = 0;\n    gridBagConstraints.fill = GridBagConstraints.HORIZONTAL;\n    groupPanel.add(myInitializerCombo, gridBagConstraints);\n\n\n\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 1;\n    gridBagConstraints.insets.top = 8;\n    gridBagConstraints.insets.left = 5;\n    myVisibilityCombo = InplaceIntroduceConstantPopup.createVisibilityCombo(groupPanel, gridBagConstraints, myParentClass.getProject());\n\n    mainPanel.add(groupPanel, BorderLayout.CENTER);\n\n    return mainPanel;\n  }","id":28697,"modified_method":"protected JComponent createInitializerPlacePanel(final ItemListener itemListener, final ItemListener finalUpdater) {\n    JPanel mainPanel = new JPanel();\n    mainPanel.setLayout(new BorderLayout());\n\n   JPanel groupPanel = new JPanel(new GridBagLayout());\n    final GridBagConstraints gridBagConstraints =\n      new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,\n                             new Insets(0, 5, 0, 0), 0, 0);\n    gridBagConstraints.insets.top = 5;\n\n\n    myInitialisersPlaceModel = new DefaultComboBoxModel();\n    myInitialisersPlaceModel.addElement(BaseExpressionToFieldHandler.InitializationPlace.IN_CURRENT_METHOD);\n    myInitialisersPlaceModel.addElement(BaseExpressionToFieldHandler.InitializationPlace.IN_FIELD_DECLARATION);\n    myInitialisersPlaceModel.addElement(BaseExpressionToFieldHandler.InitializationPlace.IN_CONSTRUCTOR);\n    if (TestUtil.isTestClass(myParentClass)) {\n      myInitialisersPlaceModel.addElement(BaseExpressionToFieldHandler.InitializationPlace.IN_SETUP_METHOD);\n    }\n    initializeInitializerPlace(myInitializerExpression, InplaceIntroduceFieldPopup.ourLastInitializerPlace);\n    if (myInitialisersPlaceModel.getSize() > 1) {\n      final JLabel initLabel = new JLabel(RefactoringBundle.message(\"initialize.in.border.title\") + \":\");\n      initLabel.setDisplayedMnemonic('i');\n      groupPanel.add(initLabel, gridBagConstraints);\n      JComboBox initializersCombo = new JComboBox(myInitialisersPlaceModel);\n      InplaceIntroduceConstantPopup.appendActions(initializersCombo, myParentClass.getProject());\n      initLabel.setLabelFor(initializersCombo);\n      initializersCombo.setRenderer(new ListCellRendererWrapper<BaseExpressionToFieldHandler.InitializationPlace>(initializersCombo) {\n        @Override\n        public void customize(JList list,\n                              BaseExpressionToFieldHandler.InitializationPlace value,\n                              int index,\n                              boolean selected,\n                              boolean hasFocus) {\n          setText(getPresentableText(value));\n        }\n      });\n      initializersCombo.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          itemListener.itemStateChanged(null);\n          finalUpdater.itemStateChanged(null);\n        }\n      });\n      gridBagConstraints.gridx = 1;\n      gridBagConstraints.insets.top = 0;\n      gridBagConstraints.insets.left = 0;\n      gridBagConstraints.fill = GridBagConstraints.HORIZONTAL;\n      groupPanel.add(initializersCombo, gridBagConstraints);\n      myInitializerCombo = initializersCombo;\n    } else {\n      gridBagConstraints.gridwidth = 2;\n      groupPanel.add(new JLabel(\"Initialize field in \" +\n                                getPresentableText((BaseExpressionToFieldHandler.InitializationPlace)myInitialisersPlaceModel.getElementAt(0))),\n                     gridBagConstraints);\n      gridBagConstraints.gridwidth = 1;\n    }\n\n\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 1;\n    gridBagConstraints.insets.top = 8;\n    gridBagConstraints.insets.left = 5;\n    myVisibilityCombo = InplaceIntroduceConstantPopup.createVisibilityCombo(groupPanel, gridBagConstraints, myParentClass.getProject());\n\n    mainPanel.add(groupPanel, BorderLayout.CENTER);\n\n    return mainPanel;\n  }","commit_id":"3be8c309f135a41cbcb9eaf9b6a7cb9cb1190dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean configureTask(RunConfiguration runConfiguration, MavenBeforeRunTask task) {\n    MavenExecuteGoalDialog dialog = new MavenExecuteGoalDialog(myProject);\n\n    dialog.setTitle(TasksBundle.message(\"maven.tasks.select.goal.title\"));\n\n    if (task.getGoal() == null) {\n      // just created empty task.\n      MavenProjectsManager projectsManager = MavenProjectsManager.getInstance(myProject);\n      List<MavenProject> rootProjects = projectsManager.getRootProjects();\n      if (rootProjects.size() > 0) {\n        dialog.setSelectedMavenProject(rootProjects.get(0));\n      }\n      else {\n        dialog.setSelectedMavenProject(null);\n      }\n    }\n    else {\n      dialog.setGoals(task.getGoal());\n      MavenProject mavenProject = getMavenProject(task);\n      if (mavenProject != null) {\n        dialog.setSelectedMavenProject(mavenProject);\n      }\n      else {\n        dialog.setSelectedMavenProject(null);\n      }\n    }\n\n    dialog.show();\n    if (!dialog.isOK()) return false;\n\n    task.setProjectPath(dialog.getWorkDirectory() + \"/pom.xml\");\n    task.setGoal(dialog.getGoals());\n    return true;\n  }","id":28698,"modified_method":"public boolean configureTask(RunConfiguration runConfiguration, MavenBeforeRunTask task) {\n    MavenExecuteGoalDialog dialog = new MavenExecuteGoalDialog(myProject, Arrays.asList(\"aaa\", \"adasdas\"));\n\n    dialog.setTitle(TasksBundle.message(\"maven.tasks.select.goal.title\"));\n\n    if (task.getGoal() == null) {\n      // just created empty task.\n      MavenProjectsManager projectsManager = MavenProjectsManager.getInstance(myProject);\n      List<MavenProject> rootProjects = projectsManager.getRootProjects();\n      if (rootProjects.size() > 0) {\n        dialog.setSelectedMavenProject(rootProjects.get(0));\n      }\n      else {\n        dialog.setSelectedMavenProject(null);\n      }\n    }\n    else {\n      dialog.setGoals(task.getGoal());\n      MavenProject mavenProject = getMavenProject(task);\n      if (mavenProject != null) {\n        dialog.setSelectedMavenProject(mavenProject);\n      }\n      else {\n        dialog.setSelectedMavenProject(null);\n      }\n    }\n\n    dialog.show();\n    if (!dialog.isOK()) return false;\n\n    task.setProjectPath(dialog.getWorkDirectory() + \"/pom.xml\");\n    task.setGoal(dialog.getGoals());\n    return true;\n  }","commit_id":"ad45a9d10bca9b06075211d8e1a0b050f46f1ff0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MavenExecuteGoalDialog(@NotNull Project project) {\n    super(project, true);\n    myProject = project;\n\n    setTitle(\"Run Maven Goal\");\n    setUpDialog();\n    setModal(true);\n    init();\n  }","id":28699,"modified_method":"public MavenExecuteGoalDialog(@NotNull Project project) {\n    this(project, null);\n  }","commit_id":"ad45a9d10bca9b06075211d8e1a0b050f46f1ff0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setUpDialog() {\n    // Configure project combobox\n    myGoalsComboBox.setLightWeightPopupEnabled(false);\n\n    EditorComboBoxEditor editor = new StringComboboxEditor(myProject, PlainTextFileType.INSTANCE, myGoalsComboBox);\n    myGoalsComboBox.setRenderer(new EditorComboBoxRenderer(editor));\n\n    myGoalsComboBox.setEditable(true);\n    myGoalsComboBox.setEditor(editor);\n    myGoalsComboBox.setFocusable(true);\n\n    EditorTextField editorTextField = editor.getEditorComponent();\n\n    new MavenArgumentsCompletionProvider(myProject).apply(editorTextField);\n\n    // Configure Module ComboBox\n    MavenProjectsManager projectsManager = MavenProjectsManager.getInstance(myProject);\n\n    showProjectTreeButton.setIcon(AllIcons.Actions.Module);\n    MavenSelectProjectPopup.attachToWorkingDirectoryField(projectsManager, workDirectoryField.getTextField(), showProjectTreeButton,\n                                                          myGoalsComboBox);\n\n    workDirectoryField.addBrowseFolderListener(\n      RunnerBundle.message(\"maven.select.maven.project.file\"), \"\", myProject,\n      new FileChooserDescriptor(false, true, false, false, false, false) {\n        @Override\n        public boolean isFileSelectable(VirtualFile file) {\n          if (!super.isFileSelectable(file)) return false;\n          return file.findChild(MavenConstants.POM_XML) != null;\n        }\n      });\n  }","id":28700,"modified_method":"private void setUpDialog() {\n    JComponent goalComponent;\n    if (myHistory == null) {\n      goalsEditor = new EditorTextField(\"\", myProject, PlainTextFileType.INSTANCE);\n      goalComponent = goalsEditor;\n\n      goalsLabel.setLabelFor(goalsEditor);\n    }\n    else {\n      //noinspection SSBasedInspection\n      goalsComboBox = new ComboBox(myHistory.toArray(new String[myHistory.size()]), -1);\n      goalComponent = goalsComboBox;\n\n      goalsLabel.setLabelFor(goalsComboBox);\n\n      goalsComboBox.setLightWeightPopupEnabled(false);\n\n      EditorComboBoxEditor editor = new StringComboboxEditor(myProject, PlainTextFileType.INSTANCE, goalsComboBox);\n      goalsComboBox.setRenderer(new EditorComboBoxRenderer(editor));\n\n      goalsComboBox.setEditable(true);\n      goalsComboBox.setEditor(editor);\n      goalsComboBox.setFocusable(true);\n\n      goalsEditor = editor.getEditorComponent();\n    }\n\n    goalsPanel.add(goalComponent);\n\n    new MavenArgumentsCompletionProvider(myProject).apply(goalsEditor);\n\n    // Configure Module ComboBox\n    MavenProjectsManager projectsManager = MavenProjectsManager.getInstance(myProject);\n\n    showProjectTreeButton.setIcon(AllIcons.Actions.Module);\n    MavenSelectProjectPopup.attachToWorkingDirectoryField(projectsManager, workDirectoryField.getTextField(), showProjectTreeButton,\n                                                          goalsComboBox != null ? goalsComboBox : goalsEditor);\n\n    workDirectoryField.addBrowseFolderListener(\n      RunnerBundle.message(\"maven.select.maven.project.file\"), \"\", myProject,\n      new FileChooserDescriptor(false, true, false, false, false, false) {\n        @Override\n        public boolean isFileSelectable(VirtualFile file) {\n          if (!super.isFileSelectable(file)) return false;\n          return file.findChild(MavenConstants.POM_XML) != null;\n        }\n      });\n  }","commit_id":"ad45a9d10bca9b06075211d8e1a0b050f46f1ff0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JComponent getPreferredFocusedComponent() {\n    return myGoalsComboBox;\n  }","id":28701,"modified_method":"public JComponent getPreferredFocusedComponent() {\n    return goalsComboBox;\n  }","commit_id":"ad45a9d10bca9b06075211d8e1a0b050f46f1ff0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getGoals() {\n    return (String)myGoalsComboBox.getEditor().getItem();\n  }","id":28702,"modified_method":"@NotNull\n  public String getGoals() {\n    if (goalsComboBox != null) {\n      return (String)goalsComboBox.getEditor().getItem();\n    }\n    else {\n      return goalsEditor.getText();\n    }\n  }","commit_id":"ad45a9d10bca9b06075211d8e1a0b050f46f1ff0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setGoals(@NotNull String goals) {\n    myGoalsComboBox.setSelectedItem(goals);\n  }","id":28703,"modified_method":"public void setGoals(@NotNull String goals) {\n    if (goalsComboBox != null) {\n      goalsComboBox.setSelectedItem(goals);\n    }\n    else {\n      goalsEditor.setText(goals);\n    }\n  }","commit_id":"ad45a9d10bca9b06075211d8e1a0b050f46f1ff0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Pager(final WebTransMessages messages, final Resources resources)\n   {\n      this.resources = resources;\n      initWidget(uiBinder.createAndBindUi(this));\n\n      // set tooltips of page nav icons, i18n-ized w/ WebTransMessages.java\n      firstPage.setTitle(messages.tooltipsWithShortcut(messages.firstPage(), messages.firstPageShortcut()));\n      prevPage.setTitle(messages.tooltipsWithShortcut(messages.prevPage(), messages.prevPageShortcut()));\n      nextPage.setTitle(messages.tooltipsWithShortcut(messages.nextPage(), messages.nextPageShortcut()));\n      lastPage.setTitle(messages.tooltipsWithShortcut(messages.lastPage(), messages.lastPageShortcut()));\n   }","id":28704,"modified_method":"public Pager(final WebTransMessages messages, final Resources resources)\n   {\n      this.resources = resources;\n      initWidget(uiBinder.createAndBindUi(this));\n\n      // set tooltips of page nav icons, i18n-ized w/ WebTransMessages.java\n      firstPage.setTitle(messages.firstPage());\n      prevPage.setTitle(messages.prevPage());\n      nextPage.setTitle(messages.nextPage());\n      lastPage.setTitle(messages.lastPage());\n   }","commit_id":"0a3839b58472cd6fe5f7ed71229609fd9fcdfc90","url":"https://github.com/zanata/zanata-server"},{"original_method":"public Pager(final WebTransMessages messages, final Resources resources)\n   {\n      this.resources = resources;\n      initWidget(uiBinder.createAndBindUi(this));\n\n      // set tooltips of page nav icons, i18n-ized w/ WebTransMessages.java\n      firstPage.setTitle(messages.tooltipsWithShortcut(messages.firstPage(), messages.firstPageShortcut()));\n      prevPage.setTitle(messages.tooltipsWithShortcut(messages.prevPage(), messages.prevPageShortcut()));\n      nextPage.setTitle(messages.tooltipsWithShortcut(messages.nextPage(), messages.nextPageShortcut()));\n      lastPage.setTitle(messages.tooltipsWithShortcut(messages.lastPage(), messages.lastPageShortcut()));\n   }","id":28705,"modified_method":"public Pager(final WebTransMessages messages, final Resources resources)\n   {\n      this.resources = resources;\n      initWidget(uiBinder.createAndBindUi(this));\n\n      // set tooltips of page nav icons, i18n-ized w/ WebTransMessages.java\n      firstPage.setTitle(messages.firstPage());\n      prevPage.setTitle(messages.prevPage());\n      nextPage.setTitle(messages.nextPage());\n      lastPage.setTitle(messages.lastPage());\n   }","commit_id":"79af82f1baa53271aea6c5384f48ae3c98d98d9e","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n        public void actionPerformed(ActionEvent e) {\n            MarkupSource source = panel.getSelectedSource();\n            if (source.hasPreviousItem()) {\n                int indexVal = source.previousItem();\n\n                //scroll\n                panel.scrollToAnchor(source.getAnchorPrefix() + Integer.toString(indexVal));\n\n                //update display\n                panel.updateCurrentMatchDisplay(source.currentItem());\n                panel.updateTotaMatcheslDisplay(source.getNumberHits());\n\n                //update controls if needed\n                if (!source.hasPreviousItem()) {\n                    panel.enablePrevMatchControl(false);\n                }\n                if (source.hasNextItem()) {\n                    panel.enableNextMatchControl(true);\n                }\n            }\n        }","id":28706,"modified_method":"@Override\n        public void actionPerformed(ActionEvent e) {\n            MarkupSource source = panel.getSelectedSource();\n            final boolean hasPreviousItem = source.hasPreviousItem();\n            final boolean hasPreviousPage = source.hasPreviousPage();\n            int indexVal = 0;\n            if (hasPreviousItem || hasPreviousPage) {\n                if (!hasPreviousItem) {\n                    //flip the page\n                    previousPage();\n                    indexVal = source.currentItem();\n                } else {\n                    indexVal = source.previousItem();\n                }\n\n                //scroll\n                panel.scrollToAnchor(source.getAnchorPrefix() + Integer.toString(indexVal));\n\n                //update display\n                panel.updateCurrentMatchDisplay(source.currentItem());\n                panel.updateTotaMatcheslDisplay(source.getNumberHits());\n\n                //update controls if needed\n                if (!source.hasPreviousItem() && !source.hasPreviousPage()) {\n                    panel.enablePrevMatchControl(false);\n                }\n                if (source.hasNextItem() || source.hasNextPage()) {\n                    panel.enableNextMatchControl(true);\n                }\n            }\n        }","commit_id":"0d20d22808e2b3db5fe3cbb081e82ec02ce4246f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void updateSearchControls() {\n        //setup search controls\n        if (currentSource != null && currentSource.isSearchable()) {\n            //TODO might need to scroll\n\n            panel.updateCurrentMatchDisplay(currentSource.currentItem());\n            panel.updateTotaMatcheslDisplay(currentSource.getNumberHits());\n\n            if (currentSource.hasNextItem()) {\n                panel.enableNextMatchControl(true);\n            } else {\n                panel.enableNextMatchControl(false);\n            }\n\n            if (currentSource.hasPreviousItem()) {\n                panel.enablePrevMatchControl(true);\n            } else {\n                panel.enablePrevMatchControl(false);\n            }\n\n        } else {\n            panel.enableNextMatchControl(false);\n            panel.enablePrevMatchControl(false);\n        }\n    }","id":28707,"modified_method":"private void updateSearchControls() {\n        //setup search controls\n        if (currentSource != null && currentSource.isSearchable()) {\n\n            panel.updateCurrentMatchDisplay(currentSource.currentItem());\n            panel.updateTotaMatcheslDisplay(currentSource.getNumberHits());\n\n            if (currentSource.hasNextItem() || currentSource.hasNextPage()) {\n                panel.enableNextMatchControl(true);\n            } else {\n                panel.enableNextMatchControl(false);\n            }\n\n            if (currentSource.hasPreviousItem() || currentSource.hasPreviousPage()) {\n                panel.enablePrevMatchControl(true);\n            } else {\n                panel.enablePrevMatchControl(false);\n            }\n\n        } else {\n            panel.enableNextMatchControl(false);\n            panel.enablePrevMatchControl(false);\n        }\n    }","commit_id":"0d20d22808e2b3db5fe3cbb081e82ec02ce4246f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public void actionPerformed(ActionEvent e) {\n            MarkupSource source = panel.getSelectedSource();\n            if (source.hasNextItem()) {\n                int indexVal = source.nextItem();\n\n                //scroll\n                panel.scrollToAnchor(source.getAnchorPrefix() + Integer.toString(indexVal));\n\n                //update display\n                panel.updateCurrentMatchDisplay(source.currentItem());\n                panel.updateTotaMatcheslDisplay(source.getNumberHits());\n\n                //update controls if needed\n                if (!source.hasNextItem()) {\n                    panel.enableNextMatchControl(false);\n                }\n                if (source.hasPreviousItem()) {\n                    panel.enablePrevMatchControl(true);\n                }\n            }\n        }","id":28708,"modified_method":"@Override\n        public void actionPerformed(ActionEvent e) {\n            MarkupSource source = panel.getSelectedSource();\n            final boolean hasNextItem = source.hasNextItem();\n            final boolean hasNextPage = source.hasNextPage();\n            int indexVal = 0;\n            if (hasNextItem || hasNextPage) {\n                if (!hasNextItem) {\n                    //flip the page\n                    nextPage();\n                    indexVal = source.currentItem();\n                } else {\n                    indexVal = source.nextItem();\n                }\n\n                //scroll\n                panel.scrollToAnchor(source.getAnchorPrefix() + Integer.toString(indexVal));\n\n                //update display\n                panel.updateCurrentMatchDisplay(source.currentItem());\n                panel.updateTotaMatcheslDisplay(source.getNumberHits());\n\n                //update controls if needed\n                if (!source.hasNextItem() && !source.hasNextPage()) {\n                    panel.enableNextMatchControl(false);\n                }\n                if (source.hasPreviousItem() || source.hasPreviousPage()) {\n                    panel.enablePrevMatchControl(true);\n                }\n            }\n        }","commit_id":"0d20d22808e2b3db5fe3cbb081e82ec02ce4246f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public void actionPerformed(ActionEvent e) {\n\n            if (currentSource.hasNextPage()) {\n                currentSource.nextPage();\n\n                //set new text\n                panel.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n                panel.refreshCurrentMarkup();\n                panel.setCursor(null);\n\n                //update display\n                panel.updateCurrentPageDisplay(currentSource.getCurrentPage());\n\n                //scroll to current selection\n                ExtractedContentViewer.this.scrollToCurrentHit();\n\n                //update controls if needed\n                if (!currentSource.hasNextPage()) {\n                    panel.enableNextPageControl(false);\n                }\n                if (currentSource.hasPreviousPage()) {\n                    panel.enablePrevPageControl(true);\n                }\n\n                updateSearchControls();\n            }\n        }","id":28709,"modified_method":"@Override\n        public void actionPerformed(ActionEvent e) {\n            nextPage();\n        }","commit_id":"0d20d22808e2b3db5fe3cbb081e82ec02ce4246f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public void actionPerformed(ActionEvent e) {\n            if (currentSource.hasPreviousPage()) {\n                currentSource.previousPage();\n\n                //set new text\n                panel.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n                panel.refreshCurrentMarkup();\n                panel.setCursor(null);\n\n                //update display\n                panel.updateCurrentPageDisplay(currentSource.getCurrentPage());\n\n                //scroll to current selection\n                ExtractedContentViewer.this.scrollToCurrentHit();\n                \n                //update controls if needed\n                if (!currentSource.hasPreviousPage()) {\n                    panel.enablePrevPageControl(false);\n                }\n                if (currentSource.hasNextPage()) {\n                    panel.enableNextPageControl(true);\n                }\n\n                updateSearchControls();\n            }\n        }","id":28710,"modified_method":"@Override\n        public void actionPerformed(ActionEvent e) {\n            previousPage();\n        }","commit_id":"0d20d22808e2b3db5fe3cbb081e82ec02ce4246f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private Document<Feed> getDocument() throws IOException, ParseException {\n        if (document == null) {\n            document = AtomUtils.parseDocument(endpoint.getFeedUri());\n            list = document.getRoot().getEntries();\n            entryIndex = list.size() - 1;\n        }\n        return document;\n    }","id":28711,"modified_method":"private Document<Feed> getDocument() throws IOException, ParseException {\n        if (document == null) {\n            document = AtomUtils.parseDocument(endpoint.getFeedUri());\n            Feed root = document.getRoot();\n            if (endpoint.isSortEntries()) {\n                sortEntries(root);\n            }             \n            list = root.getEntries();            \n            entryIndex = list.size() - 1;\n        }\n        return document;\n    }","commit_id":"bcef3c52c5c402caf5665c9f77b65c6c2f86bb03","url":"https://github.com/apache/camel"},{"original_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"atom:file:src/test/data/feed.atom?splitEntries=true&consumer.delay=500\").to(\"mock:result1\");\n\n                from(\"atom:file:src/test/data/feed.atom?splitEntries=true&filter=false&consumer.delay=500\").to(\"mock:result2\");\n\n                from(\"atom:file:src/test/data/feed.atom?splitEntries=true&filter=true&lastUpdate=2007-11-13T14:35:00&consumer.delay=500\").to(\"mock:result3\");\n            }\n        };\n    }","id":28712,"modified_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"atom:file:src/test/data/feed.atom?splitEntries=true&consumer.delay=500\").to(\"mock:result1\");\n\n                from(\"atom:file:src/test/data/feed.atom?splitEntries=true&filter=false&consumer.delay=500\").to(\"mock:result2\");                \n\n                from(\"atom:file:src/test/data/feed.atom?splitEntries=true&filter=true&lastUpdate=#myDate&consumer.delay=500\").to(\"mock:result3\");\n            }\n        };\n    }","commit_id":"bcef3c52c5c402caf5665c9f77b65c6c2f86bb03","url":"https://github.com/apache/camel"},{"original_method":"public boolean isValidEntry(FeedEndpoint endpoint, Object feed, Object entry) {        \n        Date updated = ((Entry)entry).getUpdated();\n        if (updated == null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No updated time for entry so assuming its valid: entry=[\" + entry + \"]\");\n            }\n            return true;\n        }\n        if (lastUpdate != null) {\n            if (lastUpdate.after(updated)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Entry is older than lastupdate=[\" + lastUpdate\n                        + \"], no valid entry=[\" + entry + \"]\");\n                }\n                return false;\n            }\n        }\n        lastUpdate = updated;\n        return true;\n    }","id":28713,"modified_method":"public boolean isValidEntry(FeedEndpoint endpoint, Object feed, Object entry) {        \n        Date updated = ((Entry)entry).getUpdated();\n        if (updated == null) { // never been updated so get published date\n            updated = ((Entry)entry).getPublished();\n        }        \n        if (updated == null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No updated time for entry so assuming its valid: entry=[\" + entry + \"]\");\n            }\n            return true;\n        }        \n        if (lastUpdate != null) {\n            if (lastUpdate.after(updated) || lastUpdate.equals(updated)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Entry is older than lastupdate=[\" + lastUpdate\n                        + \"], no valid entry=[\" + entry + \"]\");\n                }\n                return false;\n            }\n        }\n        lastUpdate = updated;\n        return true;\n    }","commit_id":"bcef3c52c5c402caf5665c9f77b65c6c2f86bb03","url":"https://github.com/apache/camel"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\tpublic CalEvent updateEvent(\n\t\t\tlong userId, long eventId, String title, String description,\n\t\t\tString location, int startDateMonth, int startDateDay,\n\t\t\tint startDateYear, int startDateHour, int startDateMinute,\n\t\t\tint endDateMonth, int endDateDay, int endDateYear, int durationHour,\n\t\t\tint durationMinute, boolean allDay, boolean timeZoneSensitive,\n\t\t\tString type, boolean repeating, TZSRecurrence recurrence,\n\t\t\tint remindBy, int firstReminder, int secondReminder,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Event\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tLocale locale = null;\n\t\tTimeZone timeZone = null;\n\n\t\tif (timeZoneSensitive) {\n\t\t\tlocale = user.getLocale();\n\t\t\ttimeZone = user.getTimeZone();\n\t\t}\n\t\telse {\n\t\t\tlocale = LocaleUtil.getDefault();\n\t\t\ttimeZone = TimeZoneUtil.getDefault();\n\t\t}\n\n\t\tCalendar startDate = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tstartDate.set(Calendar.MONTH, startDateMonth);\n\t\tstartDate.set(Calendar.DATE, startDateDay);\n\t\tstartDate.set(Calendar.YEAR, startDateYear);\n\t\tstartDate.set(Calendar.HOUR_OF_DAY, startDateHour);\n\t\tstartDate.set(Calendar.MINUTE, startDateMinute);\n\t\tstartDate.set(Calendar.SECOND, 0);\n\t\tstartDate.set(Calendar.MILLISECOND, 0);\n\n\t\tCalendar endDate = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tendDate.set(Calendar.MONTH, endDateMonth);\n\t\tendDate.set(Calendar.DATE, endDateDay);\n\t\tendDate.set(Calendar.YEAR, endDateYear);\n\t\tendDate.set(Calendar.HOUR_OF_DAY, 23);\n\t\tendDate.set(Calendar.MINUTE, 59);\n\t\tendDate.set(Calendar.SECOND, 59);\n\t\tendDate.set(Calendar.MILLISECOND, 990);\n\n\t\tif (allDay) {\n\t\t\tstartDate.set(Calendar.HOUR_OF_DAY, 0);\n\t\t\tstartDate.set(Calendar.MINUTE, 0);\n\n\t\t\tdurationHour = 24;\n\t\t\tdurationMinute = 0;\n\t\t}\n\n\t\tvalidate(\n\t\t\ttitle, startDateMonth, startDateDay, startDateYear, endDateMonth,\n\t\t\tendDateDay, endDateYear, durationHour, durationMinute, allDay,\n\t\t\trepeating, recurrence);\n\n\t\tCalEvent event = calEventPersistence.findByPrimaryKey(eventId);\n\n\t\tevent.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tevent.setTitle(title);\n\t\tevent.setDescription(description);\n\t\tevent.setLocation(location);\n\t\tevent.setStartDate(startDate.getTime());\n\t\tevent.setEndDate(endDate.getTime());\n\t\tevent.setDurationHour(durationHour);\n\t\tevent.setDurationMinute(durationMinute);\n\t\tevent.setAllDay(allDay);\n\t\tevent.setTimeZoneSensitive(timeZoneSensitive);\n\t\tevent.setType(type);\n\t\tevent.setRepeating(repeating);\n\t\tevent.setRecurrenceObj(recurrence);\n\t\tevent.setRemindBy(remindBy);\n\t\tevent.setFirstReminder(firstReminder);\n\t\tevent.setSecondReminder(secondReminder);\n\t\tevent.setExpandoBridgeAttributes(serviceContext);\n\n\t\tcalEventPersistence.update(event, false);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, event, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Social\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", event.getTitle());\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, event.getGroupId(), CalEvent.class.getName(), eventId,\n\t\t\tCalendarActivityKeys.UPDATE_EVENT, extraDataJSONObject.toString(),\n\t\t\t0);\n\n\t\t// Pool\n\n\t\tCalEventLocalUtil.clearEventsPool(event.getGroupId());\n\n\t\treturn event;\n\t}","id":28714,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\tpublic CalEvent updateEvent(\n\t\t\tlong userId, long eventId, String title, String description,\n\t\t\tString location, int startDateMonth, int startDateDay,\n\t\t\tint startDateYear, int startDateHour, int startDateMinute,\n\t\t\tint durationHour, int durationMinute, boolean allDay,\n\t\t\tboolean timeZoneSensitive, String type, boolean repeating,\n\t\t\tTZSRecurrence recurrence, int remindBy, int firstReminder,\n\t\t\tint secondReminder, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Event\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tLocale locale = null;\n\t\tTimeZone timeZone = null;\n\n\t\tif (timeZoneSensitive) {\n\t\t\tlocale = user.getLocale();\n\t\t\ttimeZone = user.getTimeZone();\n\t\t}\n\t\telse {\n\t\t\tlocale = LocaleUtil.getDefault();\n\t\t\ttimeZone = TimeZoneUtil.getDefault();\n\t\t}\n\n\t\tCalendar startDate = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tstartDate.set(Calendar.MONTH, startDateMonth);\n\t\tstartDate.set(Calendar.DATE, startDateDay);\n\t\tstartDate.set(Calendar.YEAR, startDateYear);\n\t\tstartDate.set(Calendar.HOUR_OF_DAY, startDateHour);\n\t\tstartDate.set(Calendar.MINUTE, startDateMinute);\n\t\tstartDate.set(Calendar.SECOND, 0);\n\t\tstartDate.set(Calendar.MILLISECOND, 0);\n\n\t\tDate endDate = null;\n\n\t\tif (hasRecurrenceEndDate(recurrence)) {\n\t\t\tendDate = recurrence.getUntil().getTime();\n\t\t}\n\n\t\tif (allDay) {\n\t\t\tstartDate.set(Calendar.HOUR_OF_DAY, 0);\n\t\t\tstartDate.set(Calendar.MINUTE, 0);\n\n\t\t\tdurationHour = 24;\n\t\t\tdurationMinute = 0;\n\t\t}\n\n\t\tvalidate(\n\t\t\ttitle, startDateMonth, startDateDay, startDateYear, durationHour,\n\t\t\tdurationMinute, allDay, repeating, recurrence);\n\n\t\tCalEvent event = calEventPersistence.findByPrimaryKey(eventId);\n\n\t\tevent.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tevent.setTitle(title);\n\t\tevent.setDescription(description);\n\t\tevent.setLocation(location);\n\t\tevent.setStartDate(startDate.getTime());\n\t\tevent.setEndDate(endDate);\n\t\tevent.setDurationHour(durationHour);\n\t\tevent.setDurationMinute(durationMinute);\n\t\tevent.setAllDay(allDay);\n\t\tevent.setTimeZoneSensitive(timeZoneSensitive);\n\t\tevent.setType(type);\n\t\tevent.setRepeating(repeating);\n\t\tevent.setRecurrenceObj(recurrence);\n\t\tevent.setRemindBy(remindBy);\n\t\tevent.setFirstReminder(firstReminder);\n\t\tevent.setSecondReminder(secondReminder);\n\t\tevent.setExpandoBridgeAttributes(serviceContext);\n\n\t\tcalEventPersistence.update(event, false);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, event, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Social\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", event.getTitle());\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, event.getGroupId(), CalEvent.class.getName(), eventId,\n\t\t\tCalendarActivityKeys.UPDATE_EVENT, extraDataJSONObject.toString(),\n\t\t\t0);\n\n\t\t// Pool\n\n\t\tCalEventLocalUtil.clearEventsPool(event.getGroupId());\n\n\t\treturn event;\n\t}","commit_id":"85c3ecde347dd24804efb4bd33e6cb0934704c6a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\tpublic CalEvent addEvent(\n\t\t\tlong userId, String title, String description, String location,\n\t\t\tint startDateMonth, int startDateDay, int startDateYear,\n\t\t\tint startDateHour, int startDateMinute, int endDateMonth,\n\t\t\tint endDateDay, int endDateYear, int durationHour,\n\t\t\tint durationMinute, boolean allDay, boolean timeZoneSensitive,\n\t\t\tString type, boolean repeating, TZSRecurrence recurrence,\n\t\t\tint remindBy, int firstReminder, int secondReminder,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Event\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\t\tDate now = new Date();\n\n\t\tLocale locale = null;\n\t\tTimeZone timeZone = null;\n\n\t\tif (timeZoneSensitive) {\n\t\t\tlocale = user.getLocale();\n\t\t\ttimeZone = user.getTimeZone();\n\t\t}\n\t\telse {\n\t\t\tlocale = LocaleUtil.getDefault();\n\t\t\ttimeZone = TimeZoneUtil.getDefault();\n\t\t}\n\n\t\tCalendar startDate = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tstartDate.set(Calendar.MONTH, startDateMonth);\n\t\tstartDate.set(Calendar.DATE, startDateDay);\n\t\tstartDate.set(Calendar.YEAR, startDateYear);\n\t\tstartDate.set(Calendar.HOUR_OF_DAY, startDateHour);\n\t\tstartDate.set(Calendar.MINUTE, startDateMinute);\n\t\tstartDate.set(Calendar.SECOND, 0);\n\t\tstartDate.set(Calendar.MILLISECOND, 0);\n\n\t\tCalendar endDate = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tendDate.set(Calendar.MONTH, endDateMonth);\n\t\tendDate.set(Calendar.DATE, endDateDay);\n\t\tendDate.set(Calendar.YEAR, endDateYear);\n\t\tendDate.set(Calendar.HOUR_OF_DAY, 23);\n\t\tendDate.set(Calendar.MINUTE, 59);\n\t\tendDate.set(Calendar.SECOND, 59);\n\t\tendDate.set(Calendar.MILLISECOND, 990);\n\n\t\tif (allDay) {\n\t\t\tstartDate.set(Calendar.HOUR_OF_DAY, 0);\n\t\t\tstartDate.set(Calendar.MINUTE, 0);\n\n\t\t\tdurationHour = 24;\n\t\t\tdurationMinute = 0;\n\t\t}\n\n\t\tvalidate(\n\t\t\ttitle, startDateMonth, startDateDay, startDateYear, endDateMonth,\n\t\t\tendDateDay, endDateYear, durationHour, durationMinute, allDay,\n\t\t\trepeating, recurrence);\n\n\t\tlong eventId = counterLocalService.increment();\n\n\t\tCalEvent event = calEventPersistence.create(eventId);\n\n\t\tevent.setUuid(serviceContext.getUuid());\n\t\tevent.setGroupId(groupId);\n\t\tevent.setCompanyId(user.getCompanyId());\n\t\tevent.setUserId(user.getUserId());\n\t\tevent.setUserName(user.getFullName());\n\t\tevent.setCreateDate(serviceContext.getCreateDate(now));\n\t\tevent.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tevent.setTitle(title);\n\t\tevent.setDescription(description);\n\t\tevent.setLocation(location);\n\t\tevent.setStartDate(startDate.getTime());\n\t\tevent.setEndDate(endDate.getTime());\n\t\tevent.setDurationHour(durationHour);\n\t\tevent.setDurationMinute(durationMinute);\n\t\tevent.setAllDay(allDay);\n\t\tevent.setTimeZoneSensitive(timeZoneSensitive);\n\t\tevent.setType(type);\n\t\tevent.setRepeating(repeating);\n\t\tevent.setRecurrenceObj(recurrence);\n\t\tevent.setRemindBy(remindBy);\n\t\tevent.setFirstReminder(firstReminder);\n\t\tevent.setSecondReminder(secondReminder);\n\t\tevent.setExpandoBridgeAttributes(serviceContext);\n\n\t\tcalEventPersistence.update(event, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.isAddGroupPermissions() ||\n\t\t\tserviceContext.isAddGuestPermissions()) {\n\n\t\t\taddEventResources(\n\t\t\t\tevent, serviceContext.isAddGroupPermissions(),\n\t\t\t\tserviceContext.isAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEventResources(\n\t\t\t\tevent, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, event, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Message boards\n\n\t\tif (PropsValues.CALENDAR_EVENT_COMMENTS_ENABLED) {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, event.getUserName(), groupId, CalEvent.class.getName(),\n\t\t\t\tevent.getEventId(), WorkflowConstants.ACTION_PUBLISH);\n\t\t}\n\n\t\t// Social\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", event.getTitle());\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, groupId, CalEvent.class.getName(), eventId,\n\t\t\tCalendarActivityKeys.ADD_EVENT, extraDataJSONObject.toString(), 0);\n\n\t\t// Pool\n\n\t\tCalEventLocalUtil.clearEventsPool(event.getGroupId());\n\n\t\treturn event;\n\t}","id":28715,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\tpublic CalEvent addEvent(\n\t\t\tlong userId, String title, String description, String location,\n\t\t\tint startDateMonth, int startDateDay, int startDateYear,\n\t\t\tint startDateHour, int startDateMinute, int durationHour,\n\t\t\tint durationMinute, boolean allDay, boolean timeZoneSensitive,\n\t\t\tString type, boolean repeating, TZSRecurrence recurrence,\n\t\t\tint remindBy, int firstReminder, int secondReminder,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Event\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\t\tDate now = new Date();\n\n\t\tLocale locale = null;\n\t\tTimeZone timeZone = null;\n\n\t\tif (timeZoneSensitive) {\n\t\t\tlocale = user.getLocale();\n\t\t\ttimeZone = user.getTimeZone();\n\t\t}\n\t\telse {\n\t\t\tlocale = LocaleUtil.getDefault();\n\t\t\ttimeZone = TimeZoneUtil.getDefault();\n\t\t}\n\n\t\tCalendar startDate = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tstartDate.set(Calendar.MONTH, startDateMonth);\n\t\tstartDate.set(Calendar.DATE, startDateDay);\n\t\tstartDate.set(Calendar.YEAR, startDateYear);\n\t\tstartDate.set(Calendar.HOUR_OF_DAY, startDateHour);\n\t\tstartDate.set(Calendar.MINUTE, startDateMinute);\n\t\tstartDate.set(Calendar.SECOND, 0);\n\t\tstartDate.set(Calendar.MILLISECOND, 0);\n\n\t\tDate endDate = null;\n\n\t\tif (hasRecurrenceEndDate(recurrence)) {\n\t\t\tendDate = recurrence.getUntil().getTime();\n\t\t}\n\n\t\tif (allDay) {\n\t\t\tstartDate.set(Calendar.HOUR_OF_DAY, 0);\n\t\t\tstartDate.set(Calendar.MINUTE, 0);\n\n\t\t\tdurationHour = 24;\n\t\t\tdurationMinute = 0;\n\t\t}\n\n\t\tvalidate(\n\t\t\ttitle, startDateMonth, startDateDay, startDateYear, durationHour,\n\t\t\tdurationMinute, allDay, repeating, recurrence);\n\n\t\tlong eventId = counterLocalService.increment();\n\n\t\tCalEvent event = calEventPersistence.create(eventId);\n\n\t\tevent.setUuid(serviceContext.getUuid());\n\t\tevent.setGroupId(groupId);\n\t\tevent.setCompanyId(user.getCompanyId());\n\t\tevent.setUserId(user.getUserId());\n\t\tevent.setUserName(user.getFullName());\n\t\tevent.setCreateDate(serviceContext.getCreateDate(now));\n\t\tevent.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tevent.setTitle(title);\n\t\tevent.setDescription(description);\n\t\tevent.setLocation(location);\n\t\tevent.setStartDate(startDate.getTime());\n\t\tevent.setEndDate(endDate);\n\t\tevent.setDurationHour(durationHour);\n\t\tevent.setDurationMinute(durationMinute);\n\t\tevent.setAllDay(allDay);\n\t\tevent.setTimeZoneSensitive(timeZoneSensitive);\n\t\tevent.setType(type);\n\t\tevent.setRepeating(repeating);\n\t\tevent.setRecurrenceObj(recurrence);\n\t\tevent.setRemindBy(remindBy);\n\t\tevent.setFirstReminder(firstReminder);\n\t\tevent.setSecondReminder(secondReminder);\n\t\tevent.setExpandoBridgeAttributes(serviceContext);\n\n\t\tcalEventPersistence.update(event, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.isAddGroupPermissions() ||\n\t\t\tserviceContext.isAddGuestPermissions()) {\n\n\t\t\taddEventResources(\n\t\t\t\tevent, serviceContext.isAddGroupPermissions(),\n\t\t\t\tserviceContext.isAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEventResources(\n\t\t\t\tevent, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, event, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Message boards\n\n\t\tif (PropsValues.CALENDAR_EVENT_COMMENTS_ENABLED) {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, event.getUserName(), groupId, CalEvent.class.getName(),\n\t\t\t\tevent.getEventId(), WorkflowConstants.ACTION_PUBLISH);\n\t\t}\n\n\t\t// Social\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", event.getTitle());\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, groupId, CalEvent.class.getName(), eventId,\n\t\t\tCalendarActivityKeys.ADD_EVENT, extraDataJSONObject.toString(), 0);\n\n\t\t// Pool\n\n\t\tCalEventLocalUtil.clearEventsPool(event.getGroupId());\n\n\t\treturn event;\n\t}","commit_id":"85c3ecde347dd24804efb4bd33e6cb0934704c6a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importICal4j(long userId, long groupId, VEvent event)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\t// X iCal property\n\n\t\tProperty timeZoneXProperty = event.getProperty(\n\t\t\tTimeZoneSensitive.PROPERTY_NAME);\n\n\t\tboolean timeZoneXPropertyValue = true;\n\n\t\tif ((timeZoneXProperty != null) &&\n\t\t\ttimeZoneXProperty.getValue().equals(\"FALSE\")) {\n\n\t\t\ttimeZoneXPropertyValue = false;\n\t\t}\n\n\t\t// Title\n\n\t\tString title = StringPool.BLANK;\n\n\t\tif (event.getSummary() != null) {\n\t\t\ttitle = ModelHintsUtil.trimString(\n\t\t\t\tCalEvent.class.getName(), \"title\",\n\t\t\t\tevent.getSummary().getValue());\n\t\t}\n\n\t\t// Description\n\n\t\tString description = StringPool.BLANK;\n\n\t\tif (event.getDescription() != null) {\n\t\t\tdescription = event.getDescription().getValue();\n\t\t}\n\n\t\t// Location\n\n\t\tString location = StringPool.BLANK;\n\n\t\tif (event.getLocation() != null) {\n\t\t\tlocation = event.getLocation().getValue();\n\t\t}\n\n\t\t// Start date\n\n\t\tDtStart dtStart = event.getStartDate();\n\n\t\tCalendar startDate = toCalendar(\n\t\t\tdtStart, timeZone, timeZoneXPropertyValue);\n\n\t\tstartDate.setTime(dtStart.getDate());\n\n\t\t// End date\n\n\t\tCalendar endDate = null;\n\n\t\tDtEnd dtEnd = event.getEndDate(true);\n\n\t\tRRule rrule = (RRule)event.getProperty(Property.RRULE);\n\n\t\tif (dtEnd != null) {\n\t\t\tendDate = toCalendar(dtEnd, timeZone, timeZoneXPropertyValue);\n\n\t\t\tendDate.setTime(dtEnd.getDate());\n\t\t}\n\t\telse {\n\t\t\tendDate = (Calendar)startDate.clone();\n\t\t\tendDate.add(Calendar.DATE, 1);\n\t\t}\n\n\t\t// Duration\n\n\t\tlong diffMillis = 0;\n\t\tlong durationHours = 24;\n\t\tlong durationMins = 0;\n\t\tboolean multiDayEvent = false;\n\n\t\tif (dtEnd != null) {\n\t\t\tdiffMillis =\n\t\t\t\tdtEnd.getDate().getTime() - startDate.getTimeInMillis();\n\t\t\tdurationHours = diffMillis / Time.HOUR;\n\t\t\tdurationMins = (diffMillis / Time.MINUTE) - (durationHours * 60);\n\n\t\t\tif ((durationHours > 24) ||\n\t\t\t\t((durationHours == 24) && (durationMins > 0))) {\n\n\t\t\t\tdurationHours = 24;\n\t\t\t\tdurationMins = 0;\n\t\t\t\tmultiDayEvent = true;\n\t\t\t}\n\t\t}\n\n\t\t// All day\n\n\t\tboolean allDay = false;\n\n\t\tif (isICal4jDateOnly(event.getStartDate()) || multiDayEvent) {\n\t\t\tallDay = true;\n\t\t}\n\n\t\t// Time zone sensitive\n\n\t\tboolean timeZoneSensitive = true;\n\n\t\tif (allDay || !timeZoneXPropertyValue) {\n\t\t\ttimeZoneSensitive = false;\n\t\t}\n\n\t\t// Type\n\n\t\tString type = StringPool.BLANK;\n\n\t\tProperty comment = event.getProperty(Property.COMMENT);\n\n\t\tif ((comment != null) &&\n\t\t\tArrayUtil.contains(CalEventConstants.TYPES, comment.getValue())) {\n\n\t\t\ttype = comment.getValue();\n\t\t}\n\n\t\t// Recurrence\n\n\t\tboolean repeating = false;\n\t\tTZSRecurrence recurrence = null;\n\n\t\tif (multiDayEvent) {\n\t\t\trepeating = true;\n\n\t\t\tCalendar recStartCal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tTimeZoneUtil.getTimeZone(StringPool.UTC));\n\n\t\t\trecStartCal.setTime(startDate.getTime());\n\n\t\t\tcom.liferay.portal.kernel.cal.Duration duration =\n\t\t\t\tnew com.liferay.portal.kernel.cal.Duration(1, 0, 0, 0);\n\n\t\t\trecurrence = new TZSRecurrence(\n\t\t\t\trecStartCal, duration, Recurrence.DAILY);\n\n\t\t\tCalendar until = CalendarFactoryUtil.getCalendar(\n\t\t\t\tTimeZoneUtil.getTimeZone(StringPool.UTC));\n\n\t\t\tuntil.setTimeInMillis(until.getTimeInMillis() + diffMillis);\n\n\t\t\trecurrence.setUntil(until);\n\n\t\t\tendDate.setTime(recurrence.getUntil().getTime());\n\t\t}\n\t\telse if (rrule != null) {\n\t\t\trepeating = true;\n\t\t\trecurrence = toRecurrence(rrule, startDate);\n\n\t\t\tif (recurrence.getUntil() != null) {\n\t\t\t\tendDate.setTime(recurrence.getUntil().getTime());\n\t\t\t}\n\t\t}\n\n\t\t// Reminder\n\n\t\tint remindBy = CalEventConstants.REMIND_BY_NONE;\n\t\tint firstReminder = 300000;\n\t\tint secondReminder = 300000;\n\n\t\t// Permissions\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setScopeGroupId(groupId);\n\n\t\t// Merge event\n\n\t\tString uuid = null;\n\n\t\tCalEvent existingEvent = null;\n\n\t\tif (event.getUid() != null) {\n\t\t\tUid uid = event.getUid();\n\n\t\t\tif (existingEvent == null) {\n\n\t\t\t\t// VEvent exported by Liferay portal\n\n\t\t\t\tuuid = uid.getValue();\n\n\t\t\t\texistingEvent = calEventPersistence.fetchByUUID_G(\n\t\t\t\t\tuuid, groupId);\n\t\t\t}\n\n\t\t\tif (existingEvent == null) {\n\n\t\t\t\t// VEvent exported by external application\n\n\t\t\t\tuuid = PortalUUIDUtil.generate(uid.getValue().getBytes());\n\n\t\t\t\texistingEvent = calEventPersistence.fetchByUUID_G(\n\t\t\t\t\tuuid, groupId);\n\t\t\t}\n\t\t}\n\n\t\tint startDateMonth = startDate.get(Calendar.MONTH);\n\t\tint startDateDay = startDate.get(Calendar.DAY_OF_MONTH);\n\t\tint startDateYear = startDate.get(Calendar.YEAR);\n\t\tint startDateHour = startDate.get(Calendar.HOUR_OF_DAY);\n\t\tint startDateMinute = startDate.get(Calendar.MINUTE);\n\t\tint endDateMonth = endDate.get(Calendar.MONTH);\n\t\tint endDateDay = endDate.get(Calendar.DAY_OF_MONTH);\n\t\tint endDateYear = endDate.get(Calendar.YEAR);\n\t\tint durationHour = (int)durationHours;\n\t\tint durationMinute = (int)durationMins;\n\n\t\tif (existingEvent == null) {\n\t\t\tserviceContext.setUuid(uuid);\n\n\t\t\tcalEventLocalService.addEvent(\n\t\t\t\tuserId, title, description, location, startDateMonth,\n\t\t\t\tstartDateDay, startDateYear, startDateHour, startDateMinute,\n\t\t\t\tendDateMonth, endDateDay, endDateYear, durationHour,\n\t\t\t\tdurationMinute, allDay, timeZoneSensitive, type, repeating,\n\t\t\t\trecurrence, remindBy, firstReminder, secondReminder,\n\t\t\t\tserviceContext);\n\t\t}\n\t\telse {\n\t\t\tcalEventLocalService.updateEvent(\n\t\t\t\tuserId, existingEvent.getEventId(), title, description,\n\t\t\t\tlocation, startDateMonth, startDateDay, startDateYear,\n\t\t\t\tstartDateHour, startDateMinute, endDateMonth, endDateDay,\n\t\t\t\tendDateYear, durationHour, durationMinute, allDay,\n\t\t\t\ttimeZoneSensitive, type, repeating, recurrence, remindBy,\n\t\t\t\tfirstReminder, secondReminder, serviceContext);\n\t\t}\n\t}","id":28716,"modified_method":"protected void importICal4j(long userId, long groupId, VEvent event)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\t// X iCal property\n\n\t\tProperty timeZoneXProperty = event.getProperty(\n\t\t\tTimeZoneSensitive.PROPERTY_NAME);\n\n\t\tboolean timeZoneXPropertyValue = true;\n\n\t\tif ((timeZoneXProperty != null) &&\n\t\t\ttimeZoneXProperty.getValue().equals(\"FALSE\")) {\n\n\t\t\ttimeZoneXPropertyValue = false;\n\t\t}\n\n\t\t// Title\n\n\t\tString title = StringPool.BLANK;\n\n\t\tif (event.getSummary() != null) {\n\t\t\ttitle = ModelHintsUtil.trimString(\n\t\t\t\tCalEvent.class.getName(), \"title\",\n\t\t\t\tevent.getSummary().getValue());\n\t\t}\n\n\t\t// Description\n\n\t\tString description = StringPool.BLANK;\n\n\t\tif (event.getDescription() != null) {\n\t\t\tdescription = event.getDescription().getValue();\n\t\t}\n\n\t\t// Location\n\n\t\tString location = StringPool.BLANK;\n\n\t\tif (event.getLocation() != null) {\n\t\t\tlocation = event.getLocation().getValue();\n\t\t}\n\n\t\t// Start date\n\n\t\tDtStart dtStart = event.getStartDate();\n\n\t\tCalendar startDate = toCalendar(\n\t\t\tdtStart, timeZone, timeZoneXPropertyValue);\n\n\t\tstartDate.setTime(dtStart.getDate());\n\n\t\t// End date\n\n\t\tDtEnd dtEnd = event.getEndDate(true);\n\n\t\tRRule rrule = (RRule)event.getProperty(Property.RRULE);\n\n\t\t// Duration\n\n\t\tlong diffMillis = 0;\n\t\tlong durationHours = 24;\n\t\tlong durationMins = 0;\n\t\tboolean multiDayEvent = false;\n\n\t\tif (dtEnd != null) {\n\t\t\tdiffMillis =\n\t\t\t\tdtEnd.getDate().getTime() - startDate.getTimeInMillis();\n\t\t\tdurationHours = diffMillis / Time.HOUR;\n\t\t\tdurationMins = (diffMillis / Time.MINUTE) - (durationHours * 60);\n\n\t\t\tif ((durationHours > 24) ||\n\t\t\t\t((durationHours == 24) && (durationMins > 0))) {\n\n\t\t\t\tdurationHours = 24;\n\t\t\t\tdurationMins = 0;\n\t\t\t\tmultiDayEvent = true;\n\t\t\t}\n\t\t}\n\n\t\t// All day\n\n\t\tboolean allDay = false;\n\n\t\tif (isICal4jDateOnly(event.getStartDate()) || multiDayEvent) {\n\t\t\tallDay = true;\n\t\t}\n\n\t\t// Time zone sensitive\n\n\t\tboolean timeZoneSensitive = true;\n\n\t\tif (allDay || !timeZoneXPropertyValue) {\n\t\t\ttimeZoneSensitive = false;\n\t\t}\n\n\t\t// Type\n\n\t\tString type = StringPool.BLANK;\n\n\t\tProperty comment = event.getProperty(Property.COMMENT);\n\n\t\tif ((comment != null) &&\n\t\t\tArrayUtil.contains(CalEventConstants.TYPES, comment.getValue())) {\n\n\t\t\ttype = comment.getValue();\n\t\t}\n\n\t\t// Recurrence\n\n\t\tboolean repeating = false;\n\t\tTZSRecurrence recurrence = null;\n\n\t\tif (multiDayEvent) {\n\t\t\trepeating = true;\n\n\t\t\tCalendar recStartCal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tTimeZoneUtil.getTimeZone(StringPool.UTC));\n\n\t\t\trecStartCal.setTime(startDate.getTime());\n\n\t\t\tcom.liferay.portal.kernel.cal.Duration duration =\n\t\t\t\tnew com.liferay.portal.kernel.cal.Duration(1, 0, 0, 0);\n\n\t\t\trecurrence = new TZSRecurrence(\n\t\t\t\trecStartCal, duration, Recurrence.DAILY);\n\n\t\t\tCalendar until = CalendarFactoryUtil.getCalendar(\n\t\t\t\tTimeZoneUtil.getTimeZone(StringPool.UTC));\n\n\t\t\tuntil.setTimeInMillis(until.getTimeInMillis() + diffMillis);\n\n\t\t\trecurrence.setUntil(until);\n\t\t}\n\t\telse if (rrule != null) {\n\t\t\trepeating = true;\n\t\t\trecurrence = toRecurrence(rrule, startDate);\n\t\t}\n\n\t\t// Reminder\n\n\t\tint remindBy = CalEventConstants.REMIND_BY_NONE;\n\t\tint firstReminder = 300000;\n\t\tint secondReminder = 300000;\n\n\t\t// Permissions\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setScopeGroupId(groupId);\n\n\t\t// Merge event\n\n\t\tString uuid = null;\n\n\t\tCalEvent existingEvent = null;\n\n\t\tif (event.getUid() != null) {\n\t\t\tUid uid = event.getUid();\n\n\t\t\tif (existingEvent == null) {\n\n\t\t\t\t// VEvent exported by Liferay portal\n\n\t\t\t\tuuid = uid.getValue();\n\n\t\t\t\texistingEvent = calEventPersistence.fetchByUUID_G(\n\t\t\t\t\tuuid, groupId);\n\t\t\t}\n\n\t\t\tif (existingEvent == null) {\n\n\t\t\t\t// VEvent exported by external application\n\n\t\t\t\tuuid = PortalUUIDUtil.generate(uid.getValue().getBytes());\n\n\t\t\t\texistingEvent = calEventPersistence.fetchByUUID_G(\n\t\t\t\t\tuuid, groupId);\n\t\t\t}\n\t\t}\n\n\t\tint startDateMonth = startDate.get(Calendar.MONTH);\n\t\tint startDateDay = startDate.get(Calendar.DAY_OF_MONTH);\n\t\tint startDateYear = startDate.get(Calendar.YEAR);\n\t\tint startDateHour = startDate.get(Calendar.HOUR_OF_DAY);\n\t\tint startDateMinute = startDate.get(Calendar.MINUTE);\n\t\tint durationHour = (int)durationHours;\n\t\tint durationMinute = (int)durationMins;\n\n\t\tif (existingEvent == null) {\n\t\t\tserviceContext.setUuid(uuid);\n\n\t\t\tcalEventLocalService.addEvent(\n\t\t\t\tuserId, title, description, location, startDateMonth,\n\t\t\t\tstartDateDay, startDateYear, startDateHour, startDateMinute,\n\t\t\t\tdurationHour, durationMinute, allDay, timeZoneSensitive, type,\n\t\t\t\trepeating, recurrence, remindBy, firstReminder, secondReminder,\n\t\t\t\tserviceContext);\n\t\t}\n\t\telse {\n\t\t\tcalEventLocalService.updateEvent(\n\t\t\t\tuserId, existingEvent.getEventId(), title, description,\n\t\t\t\tlocation, startDateMonth, startDateDay, startDateYear,\n\t\t\t\tstartDateHour, startDateMinute, durationHour, durationMinute,\n\t\t\t\tallDay, timeZoneSensitive, type, repeating, recurrence,\n\t\t\t\tremindBy, firstReminder, secondReminder, serviceContext);\n\t\t}\n\t}","commit_id":"85c3ecde347dd24804efb4bd33e6cb0934704c6a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void validate(\n\t\t\tString title, int startDateMonth, int startDateDay,\n\t\t\tint startDateYear, int endDateMonth, int endDateDay,\n\t\t\tint endDateYear, int durationHour, int durationMinute,\n\t\t\tboolean allDay, boolean repeating, TZSRecurrence recurrence)\n\t\tthrows PortalException {\n\n\t\tif (Validator.isNull(title)) {\n\t\t\tthrow new EventTitleException();\n\t\t}\n\t\telse if (!Validator.isDate(\n\t\t\t\tstartDateMonth, startDateDay, startDateYear)) {\n\n\t\t\tthrow new EventStartDateException();\n\t\t}\n\t\telse if (!Validator.isDate(endDateMonth, endDateDay, endDateYear)) {\n\t\t\tthrow new EventEndDateException();\n\t\t}\n\n\t\tif (!allDay && (durationHour <= 0) && (durationMinute <= 0)) {\n\t\t\tthrow new EventDurationException();\n\t\t}\n\n\t\tCalendar startDate = CalendarFactoryUtil.getCalendar(\n\t\t\tstartDateYear, startDateMonth, startDateDay);\n\n\t\tif (repeating) {\n\t\t\tCalendar until = recurrence.getUntil();\n\n\t\t\tif (startDate.after(until)) {\n\t\t\t\tthrow new EventEndDateException();\n\t\t\t}\n\t\t}\n\t}","id":28717,"modified_method":"protected void validate(\n\t\t\tString title, int startDateMonth, int startDateDay,\n\t\t\tint startDateYear, int durationHour, int durationMinute,\n\t\t\tboolean allDay, boolean repeating, TZSRecurrence recurrence)\n\t\tthrows PortalException {\n\n\t\tif (Validator.isNull(title)) {\n\t\t\tthrow new EventTitleException();\n\t\t}\n\n\t\tif (!Validator.isDate(startDateMonth, startDateDay, startDateYear)) {\n\t\t\tthrow new EventStartDateException();\n\t\t}\n\n\t\tif (!allDay && (durationHour <= 0) && (durationMinute <= 0)) {\n\t\t\tthrow new EventDurationException();\n\t\t}\n\n\t\tCalendar startDate = CalendarFactoryUtil.getCalendar(\n\t\t\tstartDateYear, startDateMonth, startDateDay);\n\n\t\tif (repeating) {\n\t\t\tCalendar until = recurrence.getUntil();\n\n\t\t\tif ((until != null) && startDate.after(until)) {\n\t\t\t\tthrow new EventEndDateException();\n\t\t\t}\n\t\t}\n\t}","commit_id":"85c3ecde347dd24804efb4bd33e6cb0934704c6a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public CalEvent updateEvent(\n\t\t\tlong eventId, String title, String description, String location,\n\t\t\tint startDateMonth, int startDateDay, int startDateYear,\n\t\t\tint startDateHour, int startDateMinute, int endDateMonth,\n\t\t\tint endDateDay, int endDateYear, int durationHour,\n\t\t\tint durationMinute, boolean allDay, boolean timeZoneSensitive,\n\t\t\tString type, boolean repeating, TZSRecurrence recurrence,\n\t\t\tint remindBy, int firstReminder, int secondReminder,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalEventPermission.check(\n\t\t\tgetPermissionChecker(), eventId, ActionKeys.UPDATE);\n\n\t\treturn calEventLocalService.updateEvent(\n\t\t\tgetUserId(), eventId, title, description, location, startDateMonth,\n\t\t\tstartDateDay, startDateYear, startDateHour, startDateMinute,\n\t\t\tendDateMonth, endDateDay, endDateYear, durationHour, durationMinute,\n\t\t\tallDay, timeZoneSensitive, type, repeating, recurrence, remindBy,\n\t\t\tfirstReminder, secondReminder, serviceContext);\n\t}","id":28718,"modified_method":"public CalEvent updateEvent(\n\t\t\tlong eventId, String title, String description, String location,\n\t\t\tint startDateMonth, int startDateDay, int startDateYear,\n\t\t\tint startDateHour, int startDateMinute, int durationHour,\n\t\t\tint durationMinute, boolean allDay, boolean timeZoneSensitive,\n\t\t\tString type, boolean repeating, TZSRecurrence recurrence,\n\t\t\tint remindBy, int firstReminder, int secondReminder,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalEventPermission.check(\n\t\t\tgetPermissionChecker(), eventId, ActionKeys.UPDATE);\n\n\t\treturn calEventLocalService.updateEvent(\n\t\t\tgetUserId(), eventId, title, description, location, startDateMonth,\n\t\t\tstartDateDay, startDateYear, startDateHour, startDateMinute,\n\t\t\tdurationHour, durationMinute, allDay, timeZoneSensitive, type,\n\t\t\trepeating, recurrence, remindBy, firstReminder, secondReminder,\n\t\t\tserviceContext);\n\t}","commit_id":"85c3ecde347dd24804efb4bd33e6cb0934704c6a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public CalEvent addEvent(\n\t\t\tString title, String description, String location,\n\t\t\tint startDateMonth, int startDateDay, int startDateYear,\n\t\t\tint startDateHour, int startDateMinute, int endDateMonth,\n\t\t\tint endDateDay, int endDateYear, int durationHour,\n\t\t\tint durationMinute, boolean allDay, boolean timeZoneSensitive,\n\t\t\tString type, boolean repeating, TZSRecurrence recurrence,\n\t\t\tint remindBy, int firstReminder, int secondReminder,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalendarPermission.check(\n\t\t\tgetPermissionChecker(), serviceContext.getScopeGroupId(),\n\t\t\tActionKeys.ADD_EVENT);\n\n\t\treturn calEventLocalService.addEvent(\n\t\t\tgetUserId(), title, description, location, startDateMonth,\n\t\t\tstartDateDay, startDateYear, startDateHour, startDateMinute,\n\t\t\tendDateMonth, endDateDay, endDateYear, durationHour, durationMinute,\n\t\t\tallDay, timeZoneSensitive, type, repeating, recurrence, remindBy,\n\t\t\tfirstReminder, secondReminder, serviceContext);\n\t}","id":28719,"modified_method":"public CalEvent addEvent(\n\t\t\tString title, String description, String location,\n\t\t\tint startDateMonth, int startDateDay, int startDateYear,\n\t\t\tint startDateHour, int startDateMinute, int durationHour,\n\t\t\tint durationMinute, boolean allDay, boolean timeZoneSensitive,\n\t\t\tString type, boolean repeating, TZSRecurrence recurrence,\n\t\t\tint remindBy, int firstReminder, int secondReminder,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalendarPermission.check(\n\t\t\tgetPermissionChecker(), serviceContext.getScopeGroupId(),\n\t\t\tActionKeys.ADD_EVENT);\n\n\t\treturn calEventLocalService.addEvent(\n\t\t\tgetUserId(), title, description, location, startDateMonth,\n\t\t\tstartDateDay, startDateYear, startDateHour, startDateMinute,\n\t\t\tdurationHour, durationMinute, allDay, timeZoneSensitive, type,\n\t\t\trepeating, recurrence, remindBy, firstReminder, secondReminder,\n\t\t\tserviceContext);\n\t}","commit_id":"85c3ecde347dd24804efb4bd33e6cb0934704c6a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static String getMethodSignature(String template) {\n    String s = after(template, \"*/\").trim();\n\n    StringBuffer signature = new StringBuffer();\n\n    String[] lines = s.split(\"\\n\");\n    for (String line : lines) {\n      line = line.trim();\n      if (line.startsWith(\"@\")) {\n        continue;\n      }\n      signature.append(line);\n      if (line.indexOf('{') > -1) {\n        break;\n      }\n    }\n\n    // remove last {\n    String result = signature.toString();\n    return result.substring(0, result.lastIndexOf(\"{\"));\n  }","id":28720,"modified_method":"private static String getMethodSignature(String template) {\n    final String trimmed = template.trim();\n    String s = trimmed.startsWith(\"/*\") ? after(trimmed, \"*/\") : trimmed;\n\n    StringBuffer signature = new StringBuffer();\n\n    String[] lines = s.split(\"\\n\");\n    for (String line : lines) {\n      line = line.trim();\n      if (line.startsWith(\"@\")) {\n        continue;\n      }\n      signature.append(line);\n      if (line.indexOf('{') > -1) {\n        break;\n      }\n    }\n\n    // remove last {\n    String result = signature.toString();\n    return result.substring(0, result.lastIndexOf(\"{\"));\n  }","commit_id":"c201af56b6d6269ded0b64d6b6e659eebb5657ee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Get's the javadoc, if any.\n   *\n   * @return the javadoc, null if no javadoc.\n   */\n  @Nullable\n  public String getJavaDoc() {\n    int i = template.indexOf(\"*/\");\n    if (i == -1) {\n      return null;\n    }\n\n    return template.substring(0, i + 2);\n  }","id":28721,"modified_method":"/**\n   * Get's the javadoc, if any.\n   *\n   * @return the javadoc, null if no javadoc.\n   */\n  @Nullable\n  public String getJavaDoc() {\n    int i = template.trim().startsWith(\"/*\") ? template.indexOf(\"*/\") : -1;\n    if (i == -1) {\n      return null;\n    }\n\n    return template.substring(0, i + 2);\n  }","commit_id":"c201af56b6d6269ded0b64d6b6e659eebb5657ee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isExpired(\n\t\tServiceContext serviceContext, Date defaultCreateDate) {\n\n\t\tDate createDate = serviceContext.getCreateDate(defaultCreateDate);\n\n\t\tif (createDate.after(getExpirationDate())) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","id":28722,"modified_method":"public boolean isExpired(\n\t\tServiceContext serviceContext, Date defaultCreateDate) {\n\n\t\tDate createDate = serviceContext.getCreateDate(defaultCreateDate);\n\t\tDate expirationDate = getExpirationDate();\n\n\t\tif ((expirationDate != null) && createDate.after(expirationDate)) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"1e55388aaf07e1e7560b21ee0095d64bafb095d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void trackUsage(final URI trackerUrl, final Collection<Plugin> plugins) {\r\n        if (trackerUrl == null) {\r\n            logError(Level.INFO, \"Not submitting usage tracking for plugins with blank URL: \" + getPluginNames(plugins));\r\n            return;\r\n        }\r\n        final String entryPoint = getEntryPoint();\r\n        Thread thread = new Thread(new Runnable() {\r\n            public void run() {\r\n                try {\r\n                    actuallyTrackUsage(trackerUrl, plugins, entryPoint);\r\n                } catch (Exception e) {\r\n                    logError(e, \"Error submitting usage tracking data to \" + trackerUrl);\r\n                }\r\n            }\r\n        });\r\n        thread.setDaemon(true);\r\n        thread.start();\r\n    }","id":28723,"modified_method":"private void trackUsage(final URI trackerUrl, final Collection<Plugin> plugins) {\r\n        if (trackerUrl == null) {\r\n            logError(Level.INFO, \"Not submitting usage tracking for plugins with blank URL: \" + getPluginNames(plugins));\r\n            return;\r\n        }\r\n        final String entryPoint = getEntryPoint();\r\n        if (entryPoint.contains(\"edu.umd.cs.findbugs.FindBugsTestCase\")\r\n                && (trackerUrl.getScheme().equals(\"http\") || trackerUrl.getScheme().equals(\"https\"))) {\r\n            LOGGER.fine(\"Skipping usage tracking because we're running in FindBugsTestCase and using \"\r\n                    + trackerUrl.getScheme());\r\n            return;\r\n        }\r\n        Thread thread = new Thread(new Runnable() {\r\n            public void run() {\r\n                try {\r\n                    actuallyTrackUsage(trackerUrl, plugins, entryPoint);\r\n                } catch (Exception e) {\r\n                    logError(e, \"Error submitting usage tracking data to \" + trackerUrl);\r\n                }\r\n            }\r\n        });\r\n        thread.setDaemon(true);\r\n        thread.start();\r\n    }","commit_id":"ba7ecf2354048cf381277f9371b5777099360ec6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void printPluginUpdateMsg(Plugin plugin, Element maxEl) throws ParseException {\r\n        String version = maxEl.attributeValue(\"version\");\r\n        if (version.equals(plugin.getVersion()))\r\n            return;\r\n\r\n        String url = maxEl.attributeValue(\"url\");\r\n\r\n        String message = maxEl.element(\"message\").getTextTrim();\r\n        //TODO check jar file for release date\r\n        Date date = parseReleaseDate(maxEl);\r\n        Date releaseDate = plugin.getReleaseDate();\r\n        if (date.after(releaseDate)) {\r\n            printMessage(\"PLUGIN UPDATE: \" + plugin.getShortDescription() + \" \" + version\r\n                    + \" has been released (you have \" + plugin.getVersion() + \")\");\r\n            if (message != null && message.length() > 0)\r\n                printMessage(\"   \" + message.replaceAll(\"\\\\n\", \"\\n   \"));\r\n            printMessage(\"Visit \" + url + \" for downloads and release notes.\");\r\n        }\r\n    }","id":28724,"modified_method":"private void printPluginUpdateMsg(Plugin plugin, Element maxEl) throws ParseException {\r\n        String version = maxEl.attributeValue(\"version\");\r\n        if (version.equals(plugin.getVersion()))\r\n            return;\r\n\r\n        String url = maxEl.attributeValue(\"url\");\r\n\r\n        String message = maxEl.element(\"message\").getTextTrim();\r\n        Date date = parseReleaseDate(maxEl);\r\n        Date releaseDate = plugin.getReleaseDate();\r\n        if (releaseDate == null || date.after(releaseDate)) {\r\n            printMessage(\"PLUGIN UPDATE: \" + plugin.getShortDescription() + \" \" + version\r\n                    + \" has been released (you have \" + plugin.getVersion() + \")\");\r\n            if (message != null && message.length() > 0)\r\n                printMessage(\"   \" + message.replaceAll(\"\\\\n\", \"\\n   \"));\r\n            printMessage(\"Visit \" + url + \" for downloads and release notes.\");\r\n        }\r\n    }","commit_id":"ba7ecf2354048cf381277f9371b5777099360ec6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void actuallyTrackUsage(URI trackerUrl, Collection<Plugin> plugins, String entryPoint) throws IOException {\r\n//        System.out.println(\"Submitting anonymous usage tracking info to \" + trackerUrl + \" for \" + getPluginNames(plugins));\r\n        HttpURLConnection conn = (HttpURLConnection) trackerUrl.toURL().openConnection();\r\n        conn.setDoInput(true);\r\n        conn.setDoOutput(true);\r\n        conn.setRequestMethod(\"POST\");\r\n        conn.connect();\r\n        OutputStream out = conn.getOutputStream();\r\n        XMLOutput xmlOutput = new OutputStreamXMLOutput(out);\r\n        xmlOutput.beginDocument();\r\n        xmlOutput.startTag(\"findbugs-invocation\");\r\n        xmlOutput.addAttribute(\"version\", Version.RELEASE);\r\n        String applicationName = Version.getApplicationName();\r\n        if (applicationName == null || applicationName.equals(\"\")) {\r\n            int lastDot = entryPoint.lastIndexOf('.');\r\n            if (lastDot == -1)\r\n                applicationName = entryPoint;\r\n            else\r\n                applicationName = entryPoint.substring(lastDot + 1);\r\n        }\r\n        xmlOutput.addAttribute(\"app-name\", applicationName);\r\n        String applicationVersion = Version.getApplicationVersion();\r\n        if (applicationVersion == null)\r\n            applicationVersion = \"\";\r\n        xmlOutput.addAttribute(\"app-version\", applicationVersion);\r\n        xmlOutput.addAttribute(\"entry-point\", entryPoint);\r\n        xmlOutput.addAttribute(\"os\", SystemProperties.getProperty(\"os.name\", \"\"));\r\n        xmlOutput.addAttribute(\"java-version\", getMajorJavaVersion());\r\n        Locale locale = Locale.getDefault();\r\n        xmlOutput.addAttribute(\"language\", locale.getLanguage());\r\n        xmlOutput.addAttribute(\"country\", locale.getCountry());\r\n        xmlOutput.addAttribute(\"uuid\", getUuid());\r\n        xmlOutput.stopTag(false);\r\n        for (Plugin plugin : plugins) {\r\n            xmlOutput.startTag(\"plugin\");\r\n            xmlOutput.addAttribute(\"id\", plugin.getPluginId());\r\n            xmlOutput.addAttribute(\"name\", plugin.getShortDescription());\r\n            xmlOutput.addAttribute(\"version\", plugin.getVersion());\r\n            xmlOutput.stopTag(true);\r\n        }\r\n\r\n        xmlOutput.closeTag(\"findbugs-invocation\");\r\n        xmlOutput.finish();\r\n        int responseCode = conn.getResponseCode();\r\n        if (responseCode != 200) {\r\n            logError(Level.WARNING, \"Error submitting anonymous usage data to \" + trackerUrl + \": \"\r\n                    + responseCode + \" - \" + conn.getResponseMessage());\r\n        }\r\n        parseUpdateXml(trackerUrl, plugins, conn.getInputStream());\r\n        out.close();\r\n        conn.disconnect();\r\n        \r\n    }","id":28725,"modified_method":"private void actuallyTrackUsage(URI trackerUrl, Collection<Plugin> plugins, String entryPoint) throws IOException {\r\n        LOGGER.fine(\"Submitting anonymous usage tracking info to \" + trackerUrl\r\n                + \" for \" + getPluginNames(plugins));\r\n        HttpURLConnection conn = (HttpURLConnection) trackerUrl.toURL().openConnection();\r\n        conn.setDoInput(true);\r\n        conn.setDoOutput(true);\r\n        conn.setRequestMethod(\"POST\");\r\n        conn.connect();\r\n        OutputStream out = conn.getOutputStream();\r\n        XMLOutput xmlOutput = new OutputStreamXMLOutput(out);\r\n        xmlOutput.beginDocument();\r\n        xmlOutput.startTag(\"findbugs-invocation\");\r\n        xmlOutput.addAttribute(\"version\", Version.RELEASE);\r\n        String applicationName = Version.getApplicationName();\r\n        if (applicationName == null || applicationName.equals(\"\")) {\r\n            int lastDot = entryPoint.lastIndexOf('.');\r\n            if (lastDot == -1)\r\n                applicationName = entryPoint;\r\n            else\r\n                applicationName = entryPoint.substring(lastDot + 1);\r\n        }\r\n        xmlOutput.addAttribute(\"app-name\", applicationName);\r\n        String applicationVersion = Version.getApplicationVersion();\r\n        if (applicationVersion == null)\r\n            applicationVersion = \"\";\r\n        xmlOutput.addAttribute(\"app-version\", applicationVersion);\r\n        xmlOutput.addAttribute(\"entry-point\", entryPoint);\r\n        xmlOutput.addAttribute(\"os\", SystemProperties.getProperty(\"os.name\", \"\"));\r\n        xmlOutput.addAttribute(\"java-version\", getMajorJavaVersion());\r\n        Locale locale = Locale.getDefault();\r\n        xmlOutput.addAttribute(\"language\", locale.getLanguage());\r\n        xmlOutput.addAttribute(\"country\", locale.getCountry());\r\n        xmlOutput.addAttribute(\"uuid\", getUuid());\r\n        xmlOutput.stopTag(false);\r\n        for (Plugin plugin : plugins) {\r\n            xmlOutput.startTag(\"plugin\");\r\n            xmlOutput.addAttribute(\"id\", plugin.getPluginId());\r\n            xmlOutput.addAttribute(\"name\", plugin.getShortDescription());\r\n            xmlOutput.addAttribute(\"version\", plugin.getVersion());\r\n            xmlOutput.stopTag(true);\r\n        }\r\n\r\n        xmlOutput.closeTag(\"findbugs-invocation\");\r\n        xmlOutput.finish();\r\n        int responseCode = conn.getResponseCode();\r\n        if (responseCode != 200) {\r\n            logError(Level.WARNING, \"Error submitting anonymous usage data to \" + trackerUrl + \": \"\r\n                    + responseCode + \" - \" + conn.getResponseMessage());\r\n        }\r\n        parseUpdateXml(trackerUrl, plugins, conn.getInputStream());\r\n        out.close();\r\n        conn.disconnect();\r\n        \r\n    }","commit_id":"ba7ecf2354048cf381277f9371b5777099360ec6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public boolean isValidEntry(FeedEndpoint endpoint, Object feed, Object entry) {        \n        Date updated = ((Entry)entry).getUpdated();\n        if (updated == null) {\n            // never been updated so get published date\n            updated = ((Entry)entry).getPublished();\n        }        \n        if (updated == null) {\n            LOG.debug(\"No updated time for entry so assuming its valid: entry=[{}]\", entry);\n            return true;\n        }        \n        if (lastUpdate != null) {\n            if (lastUpdate.after(updated)) {\n                LOG.debug(\"Entry is older than lastupdate=[{}], no valid entry=[{}]\", lastUpdate, entry);\n                return false;\n            }\n        }\n        lastUpdate = updated;\n        return true;\n    }","id":28726,"modified_method":"public boolean isValidEntry(FeedEndpoint endpoint, Object feed, Object entry) {        \n        Date updated = ((Entry)entry).getUpdated();\n        if (updated == null) {\n            // never been updated so get published date\n            updated = ((Entry)entry).getPublished();\n        }        \n        if (updated == null) {\n            LOG.debug(\"No updated time for entry so assuming its valid: entry=[{}]\", entry);\n            return true;\n        }        \n        if (lastUpdate != null) {\n            // we need to skip the latest updated entry\n            if (lastUpdate.after(updated) || lastUpdate.equals(updated)) {\n                LOG.debug(\"Entry is older than lastupdate=[{}], no valid entry=[{}]\", lastUpdate, entry);\n                return false;\n            }\n        }\n        lastUpdate = updated;\n        return true;\n    }","commit_id":"25740b0e4a50aa6446b962871d64ef475326ac84","url":"https://github.com/apache/camel"},{"original_method":"public static SNode call_getLoopOrSwitch_1213877377041(SNode thisNode) {\n    for (SNode item : SNodeOperations.getAncestorsWhereConceptInList(thisNode, new String[]{\"jetbrains.mps.baseLanguage.structure.AbstractLoopStatement\",\"jetbrains.mps.baseLanguage.structure.SwitchStatement\"}, false)) {\n      if (SNodeOperations.isInstanceOf(item, \"jetbrains.mps.baseLanguage.structure.SwitchStatement\") && SPropertyOperations.getString(thisNode, \"label\") == null) {\n        return item;\n      }\n      if (SNodeOperations.isInstanceOf(item, \"jetbrains.mps.baseLanguage.structure.AbstractLoopStatement\")) {\n        SNode loop = SNodeOperations.cast(item, \"jetbrains.mps.baseLanguage.structure.AbstractLoopStatement\");\n        if (SPropertyOperations.getString(thisNode, \"label\") == null) {\n          if (SPropertyOperations.getString(loop, \"label\") == null) {\n            return loop;\n          }\n        } else {\n          if (SPropertyOperations.getString(thisNode, \"label\").equals(SPropertyOperations.getString(loop, \"label\"))) {\n            return loop;\n          }\n        }\n      }\n    }\n    return null;\n  }","id":28727,"modified_method":"public static SNode call_getLoopOrSwitch_1213877377041(SNode thisNode) {\n    for (SNode item : SNodeOperations.getAncestorsWhereConceptInList(thisNode, new String[]{\"jetbrains.mps.baseLanguage.structure.AbstractLoopStatement\",\"jetbrains.mps.baseLanguage.structure.SwitchStatement\"}, false)) {\n      if (SNodeOperations.isInstanceOf(item, \"jetbrains.mps.baseLanguage.structure.SwitchStatement\") && SPropertyOperations.getString(thisNode, \"label\") == null) {\n        // todo: labels of switch\n        return item;\n      }\n      if (SNodeOperations.isInstanceOf(item, \"jetbrains.mps.baseLanguage.structure.AbstractLoopStatement\")) {\n        SNode loop = SNodeOperations.cast(item, \"jetbrains.mps.baseLanguage.structure.AbstractLoopStatement\");\n        if ((SLinkOperations.getTarget(thisNode, \"loopLabelReference\", true) != null)) {\n          SNode loopLabel = SLinkOperations.getTarget(SLinkOperations.getTarget(thisNode, \"loopLabelReference\", true), \"loopLabel\", false);\n          if ((loopLabel != null)) {\n            if (loopLabel == SLinkOperations.getTarget(loop, \"loopLabel\", true)) {\n              return loop;\n            }\n          }\n        } else {\n          if (SPropertyOperations.getString(thisNode, \"label\") == null) {\n            return loop;\n          } else {\n            if (SPropertyOperations.getString(thisNode, \"label\").equals(SPropertyOperations.getString(loop, \"label\"))) {\n              return loop;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }","commit_id":"747bc6f3192f09190e99a604f8d4ef9fd91aafae","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void build(final IOperationContext operationContext, final DataFlowBuilderContext _context) {\n    if ((BreakStatement_Behavior.call_getLoop_1213877377001(_context.getNode()) != null)) {\n      _context.getBuilder().emitJump(_context.getBuilder().after(BreakStatement_Behavior.call_getLoop_1213877377001(_context.getNode())));\n    } else\n    if ((BreakStatement_Behavior.call_getSwitch_1213877377021(_context.getNode()) != null)) {\n      _context.getBuilder().emitJump(_context.getBuilder().after(BreakStatement_Behavior.call_getSwitch_1213877377021(_context.getNode())));\n    } else {\n      _context.getBuilder().emitNop();\n    }\n  }","id":28728,"modified_method":"public void build(final IOperationContext operationContext, final DataFlowBuilderContext _context) {\n    SNode loopStatement = BreakStatement_Behavior.call_getLoop_1213877377001(_context.getNode());\n    SNode switchStatement = BreakStatement_Behavior.call_getSwitch_1213877377021(_context.getNode());\n    if ((loopStatement != null)) {\n      _context.getBuilder().emitJump(_context.getBuilder().after(loopStatement));\n    } else\n    if ((switchStatement != null)) {\n      _context.getBuilder().emitJump(_context.getBuilder().after(switchStatement));\n    } else {\n      _context.getBuilder().emitNop();\n    }\n  }","commit_id":"747bc6f3192f09190e99a604f8d4ef9fd91aafae","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode call_getLoop_1213877346346(SNode thisNode) {\n    for (SNode loop : SNodeOperations.getAncestors(thisNode, \"jetbrains.mps.baseLanguage.structure.AbstractLoopStatement\", false)) {\n      if (SPropertyOperations.getString(thisNode, \"label\") == null) {\n        return loop;\n      }\n      if (SPropertyOperations.getString(thisNode, \"label\").equals(SPropertyOperations.getString(loop, \"label\"))) {\n        return loop;\n      }\n    }\n    return null;\n  }","id":28729,"modified_method":"public static SNode call_getLoop_1213877346346(SNode thisNode) {\n    for (SNode loop : SNodeOperations.getAncestors(thisNode, \"jetbrains.mps.baseLanguage.structure.AbstractLoopStatement\", false)) {\n      if ((SLinkOperations.getTarget(thisNode, \"loopLabelReference\", true) != null)) {\n        SNode loopLabel = SLinkOperations.getTarget(SLinkOperations.getTarget(thisNode, \"loopLabelReference\", true), \"loopLabel\", false);\n        if ((loopLabel != null)) {\n          if (loopLabel == SLinkOperations.getTarget(loop, \"loopLabel\", true)) {\n            return loop;\n          }\n        }\n      } else {\n        if (SPropertyOperations.getString(thisNode, \"label\") == null) {\n          return loop;\n        }\n        if (SPropertyOperations.getString(thisNode, \"label\").equals(SPropertyOperations.getString(loop, \"label\"))) {\n          return loop;\n        }\n      }\n    }\n    return null;\n  }","commit_id":"747bc6f3192f09190e99a604f8d4ef9fd91aafae","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void create_and_acquire_semaphore() throws Exception {\n    LOG.info(\"create_and_acquire_semaphore\");\n    SemaphoreDao dao = new SemaphoreDao(getMyBatis());\n    Lock lock = dao.acquire(\"foo\", 60);\n    assertThat(lock.isAcquired()).isTrue();\n    assertThat(lock.getDurationSinceLocked()).isNull();\n\n    SemaphoreDto semaphore = selectSemaphore(\"foo\");\n    LOG.info(\"semaphore : \" + semaphore);\n    assertThat(semaphore).isNotNull();\n    assertThat(semaphore.getName()).isEqualTo(\"foo\");\n    assertThat(isRecent(semaphore.getCreatedAt())).isTrue();\n    assertThat(isRecent(semaphore.getUpdatedAt())).isTrue();\n    assertThat(isRecent(semaphore.getLockedAt())).isTrue();\n\n    dao.release(\"foo\");\n    assertThat(selectSemaphore(\"foo\")).isNull();\n  }","id":28730,"modified_method":"@Test\n  public void create_and_acquire_semaphore() throws Exception {\n    SemaphoreDao dao = new SemaphoreDao(getMyBatis());\n    Lock lock = dao.acquire(\"foo\", 60);\n    assertThat(lock.isAcquired()).isTrue();\n    assertThat(lock.getDurationSinceLocked()).isNull();\n\n    SemaphoreDto semaphore = selectSemaphore(\"foo\");\n    assertThat(semaphore).isNotNull();\n    assertThat(semaphore.getName()).isEqualTo(\"foo\");\n    assertThat(isRecent(semaphore.getCreatedAt())).isTrue();\n    assertThat(isRecent(semaphore.getUpdatedAt())).isTrue();\n    assertThat(isRecent(semaphore.getLockedAt())).isTrue();\n\n    dao.release(\"foo\");\n    assertThat(selectSemaphore(\"foo\")).isNull();\n  }","commit_id":"827c047c411d86101d08b8845a9395b5c1bfcdff","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private boolean isRecent(Date date) {\n    LOG.info(\"**** Date : \" + date);\n    Date now = now();\n    LOG.info(\"**** Now : \" + now);\n    Date dateInTheFuture = DateUtils.addDays(date, 1);\n    LOG.info(\"**** DateInTheFuture : \" + dateInTheFuture);\n    LOG.info(\"date.before(now) -> \" + date.before(now) + \" && dateInTheFuture.after(date) -> \" + dateInTheFuture.after(date));\n    return date.before(now) && dateInTheFuture.after(now);\n  }","id":28731,"modified_method":"private boolean isRecent(Date date) {\n    Date futur = DateUtils.addDays(now(), 1);\n    Date past = DateUtils.addDays(now(), -1);\n    return date.after(past) && date.before(futur);\n  }","commit_id":"827c047c411d86101d08b8845a9395b5c1bfcdff","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n     * @see org.apache.maven.plugin.eclipse.writers.EclipseWriter#write()\n     */\n    public void write()\n        throws MojoExecutionException\n    {\n\n        Writer w;\n\n        try\n        {\n            w =\n                new OutputStreamWriter( new FileOutputStream( new File( config.getEclipseProjectDirectory(),\n                                                                        FILE_DOT_CLASSPATH ) ), \"UTF-8\" );\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( ELT_CLASSPATH );\n\n        String defaultOutput =\n            IdeUtils.toRelativeAndFixSeparator( config.getProjectBaseDir(), config.getBuildOutputDirectory(), false );\n\n        // ----------------------------------------------------------------------\n        // Source roots and resources\n        // ----------------------------------------------------------------------\n\n        // List<EclipseSourceDir>\n        List specialSources = new ArrayList();\n\n        // Map<String,List<EclipseSourceDir>>\n        Map byOutputDir = new HashMap();\n\n        for ( int j = 0; j < config.getSourceDirs().length; j++ )\n        {\n            EclipseSourceDir dir = config.getSourceDirs()[j];\n\n            // List<EclipseSourceDir>\n            List byOutputDirs = (List) byOutputDir.get( dir.getOutput() );\n            if ( byOutputDirs == null )\n            {\n                // ArrayList<EclipseSourceDir>\n                byOutputDir.put( dir.getOutput() == null ? defaultOutput : dir.getOutput(), byOutputDirs =\n                    new ArrayList() );\n            }\n            byOutputDirs.add( dir );\n        }\n\n        for ( int j = 0; j < config.getSourceDirs().length; j++ )\n        {\n            EclipseSourceDir dir = config.getSourceDirs()[j];\n\n            log.debug( \"Processing \" + ( dir.isResource() ? \"re\" : \"\" ) + \"source \" + dir.getPath() + \": output=\" +\n                dir.getOutput() + \"; default output=\" + defaultOutput );\n\n            boolean isSpecial = false;\n\n            // handle resource with nested output folders\n            if ( dir.isResource() )\n            {\n                // Check if the output is a subdirectory of the default output,\n                // and if the default output has any sources that copy there.\n\n                if ( dir.getOutput() != null // resource output dir is set\n                    &&\n                    !dir.getOutput().equals( defaultOutput ) // output dir is not default target/classes\n                    && dir.getOutput().startsWith( defaultOutput ) // ... but is nested\n                    && byOutputDir.get( defaultOutput ) != null // ???\n                    && !( (List) byOutputDir.get( defaultOutput ) ).isEmpty() // ???\n                )\n                {\n                    // do not specify as source since the output will be nested. Instead, mark\n                    // it as a todo, and handle it with a custom build.xml file later.\n\n                    log.debug( \"Marking as special to prevent output folder nesting: \" + dir.getPath() + \" (output=\" +\n                        dir.getOutput() + \")\" );\n\n                    isSpecial = true;\n                    specialSources.add( dir );\n                }\n            }\n\n            writer.startElement( ELT_CLASSPATHENTRY );\n\n            writer.addAttribute( ATTR_KIND, \"src\" ); //$NON-NLS-1$\n            writer.addAttribute( ATTR_PATH, dir.getPath() );\n\n            if ( !isSpecial && dir.getOutput() != null && !defaultOutput.equals( dir.getOutput() ) )\n            {\n                writer.addAttribute( ATTR_OUTPUT, dir.getOutput() );\n            }\n\n            if ( StringUtils.isNotEmpty( dir.getInclude() ) )\n            {\n                writer.addAttribute( ATTR_INCLUDING, dir.getInclude() );\n            }\n\n            String excludes = dir.getExclude();\n\n            if ( dir.isResource() )\n            {\n                // automatically exclude java files: eclipse doesn't have the concept of resource directory so it will\n                // try to compile any java file found in maven resource dirs\n                excludes = StringUtils.isEmpty( excludes ) ? \"**/*.java\" : excludes + \"|**/*.java\";\n            }\n\n            if ( StringUtils.isNotEmpty( excludes ) )\n            {\n                writer.addAttribute( ATTR_EXCLUDING, excludes );\n            }\n\n            writer.endElement();\n\n        }\n\n        // handle the special sources.\n        if ( !specialSources.isEmpty() )\n        {\n            log.info( \"Creating maven-eclipse.xml Ant file to handle resources\" );\n\n            try\n            {\n                Writer buildXmlWriter =\n                    new OutputStreamWriter( new FileOutputStream( new File( config.getEclipseProjectDirectory(),\n                                                                            \"maven-eclipse.xml\" ) ), \"UTF-8\" );\n                PrettyPrintXMLWriter buildXmlPrinter = new PrettyPrintXMLWriter( buildXmlWriter );\n\n                buildXmlPrinter.startElement( \"project\" );\n                buildXmlPrinter.addAttribute( \"default\", \"copy-resources\" );\n\n                buildXmlPrinter.startElement( \"target\" );\n                buildXmlPrinter.addAttribute( \"name\", \"init\" );\n                // initialize filtering tokens here\n                buildXmlPrinter.endElement();\n\n                buildXmlPrinter.startElement( \"target\" );\n                buildXmlPrinter.addAttribute( \"name\", \"copy-resources\" );\n                buildXmlPrinter.addAttribute( \"depends\", \"init\" );\n\n                for ( Iterator it = specialSources.iterator(); it.hasNext(); )\n                {\n                    // TODO: merge source dirs on output path+filtering to reduce\n                    // <copy> tags for speed.\n                    EclipseSourceDir dir = (EclipseSourceDir) it.next();\n                    buildXmlPrinter.startElement( \"copy\" );\n                    buildXmlPrinter.addAttribute( \"todir\", dir.getOutput() );\n                    buildXmlPrinter.addAttribute( \"filtering\", \"\" + dir.isFiltering() );\n\n                    buildXmlPrinter.startElement( \"fileset\" );\n                    buildXmlPrinter.addAttribute( \"dir\", dir.getPath() );\n                    if ( dir.getInclude() != null )\n                    {\n                        buildXmlPrinter.addAttribute( \"includes\", dir.getInclude() );\n                    }\n                    if ( dir.getExclude() != null )\n                    {\n                        buildXmlPrinter.addAttribute( \"excludes\", dir.getExclude() );\n                    }\n                    buildXmlPrinter.endElement();\n\n                    buildXmlPrinter.endElement();\n                }\n\n                buildXmlPrinter.endElement();\n\n                buildXmlPrinter.endElement();\n\n                IOUtil.close( buildXmlWriter );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot create \" + config.getEclipseProjectDirectory() +\n                    \"/maven-eclipse.xml\", e );\n            }\n\n            log.info( \"Creating external launcher file\" );\n            // now create the launcher\n            new EclipseAntExternalLaunchConfigurationWriter().init( log, config, \"Maven_Ant_Builder.launch\",\n                                                                    \"maven-eclipse.xml\" ).write();\n\n            // finally add it to the project writer.\n\n            config.getBuildCommands().add(\n                                           new BuildCommand(\n                                                             \"org.eclipse.ui.externaltools.ExternalToolBuilder\",\n                                                             \"LaunchConfigHandle\",\n                                                             \"<project>/\" +\n                                                                 EclipseLaunchConfigurationWriter.FILE_DOT_EXTERNAL_TOOL_BUILDERS +\n                                                                 \"Maven_Ant_Builder.launch\" ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // The default output\n        // ----------------------------------------------------------------------\n\n        writer.startElement( ELT_CLASSPATHENTRY );\n        writer.addAttribute( ATTR_KIND, ATTR_OUTPUT );\n        writer.addAttribute( ATTR_PATH, defaultOutput );\n        writer.endElement();\n\n        Set addedDependencies = new HashSet();\n        // TODO if (..magic property equals orderDependencies..)\n\n\t\t// ----------------------------------------------------------------------\n        // Java API dependencies that may complete the classpath container so must \n\t\t// be declared BEFORE so that container access rules don't fail\n        // ----------------------------------------------------------------------\n        IdeDependency[] depsToWrite = config.getDepsOrdered();\n\t\tfor ( int j = 0; j < depsToWrite.length; j++ )\n        {\n            IdeDependency dep = depsToWrite[j];\n\t\t\tif ( dep.isJavaApi() )\n\t\t\t{\n\t\t\t\tString depId =\n                    dep.getGroupId() + \":\" + dep.getArtifactId() + \":\" + dep.getClassifier() + \":\" + dep.getVersion();\n\t\t\t\taddDependency( writer, dep );\n\t\t\t\taddedDependencies.add( depId );\n\t\t\t}\n\t\t}\n\t\t\n        // ----------------------------------------------------------------------\n        // Container classpath entries\n        // ----------------------------------------------------------------------\n\n        for ( Iterator it = config.getClasspathContainers().iterator(); it.hasNext(); )\n        {\n            writer.startElement( ELT_CLASSPATHENTRY );\n            writer.addAttribute( ATTR_KIND, \"con\" ); //$NON-NLS-1$\n            writer.addAttribute( ATTR_PATH, (String) it.next() );\n            writer.endElement(); // name\n        }\n\n        // ----------------------------------------------------------------------\n        // The dependencies\n        // ----------------------------------------------------------------------\n        for ( int j = 0; j < depsToWrite.length; j++ )\n        {\n            IdeDependency dep = depsToWrite[j];\n\n            if ( dep.isAddedToClasspath() )\n            {\n                String depId =\n                    dep.getGroupId() + \":\" + dep.getArtifactId() + \":\" + dep.getClassifier() + \":\" + dep.getVersion();\n                /* avoid duplicates in the classpath for artifacts with different types (like ejbs) */\n                if ( !addedDependencies.contains( depId ) )\n                {\n                    addDependency( writer, dep );\n                    addedDependencies.add( depId );\n                }\n            }\n        }\n\n        writer.endElement();\n\n        IOUtil.close( w );\n\n    }","id":28732,"modified_method":"/**\n     * @see org.apache.maven.plugin.eclipse.writers.EclipseWriter#write()\n     */\n    public void write()\n        throws MojoExecutionException\n    {\n\n        Writer w;\n\n        try\n        {\n            w =\n                new OutputStreamWriter( new FileOutputStream( new File( config.getEclipseProjectDirectory(),\n                                                                        FILE_DOT_CLASSPATH ) ), \"UTF-8\" );\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( ELT_CLASSPATH );\n\n        String defaultOutput =\n            IdeUtils.toRelativeAndFixSeparator( config.getProjectBaseDir(), config.getBuildOutputDirectory(), false );\n\n        // ----------------------------------------------------------------------\n        // Source roots and resources\n        // ----------------------------------------------------------------------\n\n        // List<EclipseSourceDir>\n        List specialSources = new ArrayList();\n\n        // Map<String,List<EclipseSourceDir>>\n        Map byOutputDir = new HashMap();\n\n        for ( int j = 0; j < config.getSourceDirs().length; j++ )\n        {\n            EclipseSourceDir dir = config.getSourceDirs()[j];\n\n            // List<EclipseSourceDir>\n            List byOutputDirs = (List) byOutputDir.get( dir.getOutput() );\n            if ( byOutputDirs == null )\n            {\n                // ArrayList<EclipseSourceDir>\n                byOutputDir.put( dir.getOutput() == null ? defaultOutput : dir.getOutput(), byOutputDirs =\n                    new ArrayList() );\n            }\n            byOutputDirs.add( dir );\n        }\n\n        for ( int j = 0; j < config.getSourceDirs().length; j++ )\n        {\n            EclipseSourceDir dir = config.getSourceDirs()[j];\n\n            log.debug( \"Processing \" + ( dir.isResource() ? \"re\" : \"\" ) + \"source \" + dir.getPath() + \": output=\" +\n                dir.getOutput() + \"; default output=\" + defaultOutput );\n\n            boolean isSpecial = false;\n\n            // handle resource with nested output folders\n            if ( dir.isResource() )\n            {\n                // Check if the output is a subdirectory of the default output,\n                // and if the default output has any sources that copy there.\n\n                if ( dir.getOutput() != null // resource output dir is set\n                    &&\n                    !dir.getOutput().equals( defaultOutput ) // output dir is not default target/classes\n                    && dir.getOutput().startsWith( defaultOutput ) // ... but is nested\n                    && byOutputDir.get( defaultOutput ) != null // ???\n                    && !( (List) byOutputDir.get( defaultOutput ) ).isEmpty() // ???\n                )\n                {\n                    // do not specify as source since the output will be nested. Instead, mark\n                    // it as a todo, and handle it with a custom build.xml file later.\n\n                    log.debug( \"Marking as special to prevent output folder nesting: \" + dir.getPath() + \" (output=\" +\n                        dir.getOutput() + \")\" );\n\n                    isSpecial = true;\n                    specialSources.add( dir );\n                }\n            }\n\n            writer.startElement( ELT_CLASSPATHENTRY );\n\n            writer.addAttribute( ATTR_KIND, \"src\" ); //$NON-NLS-1$\n            writer.addAttribute( ATTR_PATH, dir.getPath() );\n\n            if ( !isSpecial && dir.getOutput() != null && !defaultOutput.equals( dir.getOutput() ) )\n            {\n                writer.addAttribute( ATTR_OUTPUT, dir.getOutput() );\n            }\n\n            if ( StringUtils.isNotEmpty( dir.getInclude() ) )\n            {\n                writer.addAttribute( ATTR_INCLUDING, dir.getInclude() );\n            }\n\n            String excludes = dir.getExclude();\n\n            if ( dir.isResource() )\n            {\n                // automatically exclude java files: eclipse doesn't have the concept of resource directory so it will\n                // try to compile any java file found in maven resource dirs\n                excludes = StringUtils.isEmpty( excludes ) ? \"**/*.java\" : excludes + \"|**/*.java\";\n            }\n\n            if ( StringUtils.isNotEmpty( excludes ) )\n            {\n                writer.addAttribute( ATTR_EXCLUDING, excludes );\n            }\n\n            writer.endElement();\n\n        }\n\n        // handle the special sources.\n        if ( !specialSources.isEmpty() )\n        {\n            log.info( \"Creating maven-eclipse.xml Ant file to handle resources\" );\n\n            try\n            {\n                Writer buildXmlWriter =\n                    new OutputStreamWriter( new FileOutputStream( new File( config.getEclipseProjectDirectory(),\n                                                                            \"maven-eclipse.xml\" ) ), \"UTF-8\" );\n                PrettyPrintXMLWriter buildXmlPrinter = new PrettyPrintXMLWriter( buildXmlWriter );\n\n                buildXmlPrinter.startElement( \"project\" );\n                buildXmlPrinter.addAttribute( \"default\", \"copy-resources\" );\n\n                buildXmlPrinter.startElement( \"target\" );\n                buildXmlPrinter.addAttribute( \"name\", \"init\" );\n                // initialize filtering tokens here\n                buildXmlPrinter.endElement();\n\n                buildXmlPrinter.startElement( \"target\" );\n                buildXmlPrinter.addAttribute( \"name\", \"copy-resources\" );\n                buildXmlPrinter.addAttribute( \"depends\", \"init\" );\n\n                for ( Iterator it = specialSources.iterator(); it.hasNext(); )\n                {\n                    // TODO: merge source dirs on output path+filtering to reduce\n                    // <copy> tags for speed.\n                    EclipseSourceDir dir = (EclipseSourceDir) it.next();\n                    buildXmlPrinter.startElement( \"copy\" );\n                    buildXmlPrinter.addAttribute( \"todir\", dir.getOutput() );\n                    buildXmlPrinter.addAttribute( \"filtering\", \"\" + dir.isFiltering() );\n\n                    buildXmlPrinter.startElement( \"fileset\" );\n                    buildXmlPrinter.addAttribute( \"dir\", dir.getPath() );\n                    if ( dir.getInclude() != null )\n                    {\n                        buildXmlPrinter.addAttribute( \"includes\", dir.getInclude() );\n                    }\n                    if ( dir.getExclude() != null )\n                    {\n                        buildXmlPrinter.addAttribute( \"excludes\", dir.getExclude() );\n                    }\n                    buildXmlPrinter.endElement();\n\n                    buildXmlPrinter.endElement();\n                }\n\n                buildXmlPrinter.endElement();\n\n                buildXmlPrinter.endElement();\n\n                IOUtil.close( buildXmlWriter );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot create \" + config.getEclipseProjectDirectory() +\n                    \"/maven-eclipse.xml\", e );\n            }\n\n            log.info( \"Creating external launcher file\" );\n            // now create the launcher\n            new EclipseAntExternalLaunchConfigurationWriter().init( log, config, \"Maven_Ant_Builder.launch\",\n                                                                    \"maven-eclipse.xml\" ).write();\n\n            // finally add it to the project writer.\n\n            config.getBuildCommands().add(\n                                           new BuildCommand(\n                                                             \"org.eclipse.ui.externaltools.ExternalToolBuilder\",\n                                                             \"LaunchConfigHandle\",\n                                                             \"<project>/\" +\n                                                                 EclipseLaunchConfigurationWriter.FILE_DOT_EXTERNAL_TOOL_BUILDERS +\n                                                                 \"Maven_Ant_Builder.launch\" ) );\n        }\n\n        // ----------------------------------------------------------------------\n        // The default output\n        // ----------------------------------------------------------------------\n\n        writer.startElement( ELT_CLASSPATHENTRY );\n        writer.addAttribute( ATTR_KIND, ATTR_OUTPUT );\n        writer.addAttribute( ATTR_PATH, defaultOutput );\n        writer.endElement();\n\n        Set addedDependencies = new HashSet();\n        // TODO if (..magic property equals orderDependencies..)\n\n\t\t// ----------------------------------------------------------------------\n        // Java API dependencies that may complete the classpath container so must\n\t\t// be declared BEFORE so that container access rules don't fail\n        // ----------------------------------------------------------------------\n        IdeDependency[] depsToWrite = config.getDepsOrdered();\n\t\tfor ( int j = 0; j < depsToWrite.length; j++ )\n        {\n            IdeDependency dep = depsToWrite[j];\n\t\t\tif ( dep.isJavaApi() )\n\t\t\t{\n\t\t\t\tString depId = getDependencyId( dep );\n\t\t\t\tif ( !addedDependencies.contains( depId ) )\n                {\n\t\t\t\t    addDependency( writer, dep );\n\t                addedDependencies.add( depId );\n                }\n\t\t\t}\n\t\t}\n\n        // ----------------------------------------------------------------------\n        // Container classpath entries\n        // ----------------------------------------------------------------------\n\n        for ( Iterator it = config.getClasspathContainers().iterator(); it.hasNext(); )\n        {\n            writer.startElement( ELT_CLASSPATHENTRY );\n            writer.addAttribute( ATTR_KIND, \"con\" ); //$NON-NLS-1$\n            writer.addAttribute( ATTR_PATH, (String) it.next() );\n            writer.endElement(); // name\n        }\n\n        // ----------------------------------------------------------------------\n        // The dependencies\n        // ----------------------------------------------------------------------\n        for ( int j = 0; j < depsToWrite.length; j++ )\n        {\n            IdeDependency dep = depsToWrite[j];\n\n            if ( dep.isAddedToClasspath() )\n            {\n                String depId = getDependencyId( dep );\n                /* avoid duplicates in the classpath for artifacts with different types (like ejbs or test-jars) */\n                if ( !addedDependencies.contains( depId ) )\n                {\n\t                addDependency( writer, dep );\n                    addedDependencies.add( depId );\n                }\n            }\n        }\n\n        writer.endElement();\n\n        IOUtil.close( w );\n\n    }","commit_id":"f649ab097c2ef30d08c9e5aa45a75583f9e512bc","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.plugin.eclipse.writers.EclipseWriter#write()\n     */\n    public void write()\n        throws MojoExecutionException\n    {\n\n        Set projectnatures = new LinkedHashSet();\n        Set buildCommands = new LinkedHashSet();\n\n        File dotProject = new File( config.getEclipseProjectDirectory(), FILE_DOT_PROJECT );\n\n        if ( dotProject.exists() )\n        {\n\n            log.info( Messages.getString( \"EclipsePlugin.keepexisting\", dotProject.getAbsolutePath() ) ); //$NON-NLS-1$\n\n            // parse existing file in order to keep manually-added entries\n            Reader reader = null;\n            try\n            {\n                reader = new InputStreamReader( new FileInputStream( dotProject ), \"UTF-8\" );\n                Xpp3Dom dom = Xpp3DomBuilder.build( reader );\n\n                Xpp3Dom naturesElement = dom.getChild( ELT_NATURES );\n                if ( naturesElement != null )\n                {\n                    Xpp3Dom[] existingNatures = naturesElement.getChildren( ELT_NATURE );\n                    for ( int j = 0; j < existingNatures.length; j++ )\n                    {\n                        // adds all the existing natures\n                        projectnatures.add( existingNatures[j].getValue() );\n                    }\n                }\n\n                Xpp3Dom buildSpec = dom.getChild( ELT_BUILD_SPEC );\n                if ( buildSpec != null )\n                {\n                    Xpp3Dom[] existingBuildCommands = buildSpec.getChildren( ELT_BUILD_COMMAND );\n                    for ( int j = 0; j < existingBuildCommands.length; j++ )\n                    {\n                        Xpp3Dom buildCommandName = existingBuildCommands[j].getChild( ELT_NAME );\n                        if ( buildCommandName != null )\n                        {\n                            buildCommands.add( new BuildCommand( existingBuildCommands[j] ) );\n                        }\n                    }\n                }\n            }\n            catch ( XmlPullParserException e )\n            {\n                log.warn( Messages.getString( \"EclipsePlugin.cantparseexisting\", dotProject.getAbsolutePath() ) ); //$NON-NLS-1$\n            }\n            catch ( IOException e )\n            {\n                log.warn( Messages.getString( \"EclipsePlugin.cantparseexisting\", dotProject.getAbsolutePath() ) ); //$NON-NLS-1$\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n        }\n\n        // adds new entries after the existing ones\n        for ( Iterator iter = config.getProjectnatures().iterator(); iter.hasNext(); )\n        {\n            projectnatures.add( iter.next() );\n        }\n\n        for ( Iterator iter = config.getBuildCommands().iterator(); iter.hasNext(); )\n        {\n            buildCommands.add( (BuildCommand) iter.next() );\n        }\n\n        Writer w;\n\n        try\n        {\n            w = new OutputStreamWriter( new FileOutputStream( dotProject ), \"UTF-8\" );\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( \"projectDescription\" ); //$NON-NLS-1$\n\n        writer.startElement( ELT_NAME );\n        writer.writeText( config.getEclipseProjectName() );\n        writer.endElement();\n\n        // TODO: this entire element might be dropped if the comment is null.\n        // but as the maven1 eclipse plugin does it, it's better to be safe than sorry\n        // A eclipse developer might want to look at this.\n        writer.startElement( \"comment\" ); //$NON-NLS-1$\n\n        if ( config.getProject().getDescription() != null )\n        {\n            writer.writeText( config.getProject().getDescription() );\n        }\n\n        writer.endElement();\n\n        writer.startElement( \"projects\" ); //$NON-NLS-1$\n\n        // referenced projects should not be added for plugins\n        if ( !config.isPde() )\n        {\n            for ( int j = 0; j < config.getDepsOrdered().length; j++ )\n            {\n                IdeDependency dep = config.getDepsOrdered()[j];\n                if ( dep.isReferencedProject() )\n                {\n                    writer.startElement( \"project\" ); //$NON-NLS-1$\n                    writer.writeText( dep.getEclipseProjectName() );\n                    writer.endElement();\n                }\n            }\n        }\n\n        writer.endElement(); // projects\n\n        writer.startElement( ELT_BUILD_SPEC );\n\n        for ( Iterator it = buildCommands.iterator(); it.hasNext(); )\n        {\n            ( (BuildCommand) it.next() ).print( writer );\n        }\n\n        writer.endElement(); // buildSpec\n\n        writer.startElement( ELT_NATURES );\n\n        for ( Iterator it = projectnatures.iterator(); it.hasNext(); )\n        {\n            writer.startElement( ELT_NATURE );\n            writer.writeText( (String) it.next() );\n            writer.endElement(); // name\n        }\n\n        writer.endElement(); // natures\n\n        boolean addLinks = !config.getProjectBaseDir().equals( config.getEclipseProjectDirectory() );\n\n        if ( addLinks || ( config.isPde() && config.getDepsOrdered().length > 0 ) )\n        {\n            writer.startElement( \"linkedResources\" ); //$NON-NLS-1$\n\n            if ( addLinks )\n            {\n\n                addFileLink( writer, config.getProjectBaseDir(), config.getEclipseProjectDirectory(),\n                             config.getProject().getFile() );\n\n                addSourceLinks( writer, config.getProjectBaseDir(), config.getEclipseProjectDirectory(),\n                                config.getProject().getCompileSourceRoots() );\n                addResourceLinks( writer, config.getProjectBaseDir(), config.getEclipseProjectDirectory(),\n                                  config.getProject().getBuild().getResources() );\n\n                addSourceLinks( writer, config.getProjectBaseDir(), config.getEclipseProjectDirectory(),\n                                config.getProject().getTestCompileSourceRoots() );\n                addResourceLinks( writer, config.getProjectBaseDir(), config.getEclipseProjectDirectory(),\n                                  config.getProject().getBuild().getTestResources() );\n\n            }\n\n            if ( config.isPde() )\n            {\n                for ( int j = 0; j < config.getDepsOrdered().length; j++ )\n                {\n                    IdeDependency dep = config.getDepsOrdered()[j];\n\n                    if ( dep.isAddedToClasspath() && !dep.isProvided() && !dep.isReferencedProject() &&\n                        !dep.isTestDependency() && !dep.isOsgiBundle() )\n                    {\n                        String name = dep.getFile().getName();\n                        addLink( writer, name, StringUtils.replace( IdeUtils.getCanonicalPath( dep.getFile() ), \"\\\\\",\n                                                                    \"/\" ), LINK_TYPE_FILE );\n                    }\n                }\n            }\n\n            writer.endElement(); // linkedResources\n        }\n\n        writer.endElement(); // projectDescription\n\n        IOUtil.close( w );\n    }","id":28733,"modified_method":"/**\n     * @see org.apache.maven.plugin.eclipse.writers.EclipseWriter#write()\n     */\n    public void write()\n        throws MojoExecutionException\n    {\n\n        Set projectnatures = new LinkedHashSet();\n        Set buildCommands = new LinkedHashSet();\n\n        File dotProject = new File( config.getEclipseProjectDirectory(), FILE_DOT_PROJECT );\n\n        if ( dotProject.exists() )\n        {\n\n            log.info( Messages.getString( \"EclipsePlugin.keepexisting\", dotProject.getAbsolutePath() ) ); //$NON-NLS-1$\n\n            // parse existing file in order to keep manually-added entries\n            Reader reader = null;\n            try\n            {\n                reader = new InputStreamReader( new FileInputStream( dotProject ), \"UTF-8\" );\n                Xpp3Dom dom = Xpp3DomBuilder.build( reader );\n\n                Xpp3Dom naturesElement = dom.getChild( ELT_NATURES );\n                if ( naturesElement != null )\n                {\n                    Xpp3Dom[] existingNatures = naturesElement.getChildren( ELT_NATURE );\n                    for ( int j = 0; j < existingNatures.length; j++ )\n                    {\n                        // adds all the existing natures\n                        projectnatures.add( existingNatures[j].getValue() );\n                    }\n                }\n\n                Xpp3Dom buildSpec = dom.getChild( ELT_BUILD_SPEC );\n                if ( buildSpec != null )\n                {\n                    Xpp3Dom[] existingBuildCommands = buildSpec.getChildren( ELT_BUILD_COMMAND );\n                    for ( int j = 0; j < existingBuildCommands.length; j++ )\n                    {\n                        Xpp3Dom buildCommandName = existingBuildCommands[j].getChild( ELT_NAME );\n                        if ( buildCommandName != null )\n                        {\n                            buildCommands.add( new BuildCommand( existingBuildCommands[j] ) );\n                        }\n                    }\n                }\n            }\n            catch ( XmlPullParserException e )\n            {\n                log.warn( Messages.getString( \"EclipsePlugin.cantparseexisting\", dotProject.getAbsolutePath() ) ); //$NON-NLS-1$\n            }\n            catch ( IOException e )\n            {\n                log.warn( Messages.getString( \"EclipsePlugin.cantparseexisting\", dotProject.getAbsolutePath() ) ); //$NON-NLS-1$\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n        }\n\n        // adds new entries after the existing ones\n        for ( Iterator iter = config.getProjectnatures().iterator(); iter.hasNext(); )\n        {\n            projectnatures.add( iter.next() );\n        }\n\n        for ( Iterator iter = config.getBuildCommands().iterator(); iter.hasNext(); )\n        {\n            buildCommands.add( (BuildCommand) iter.next() );\n        }\n\n        Writer w;\n\n        try\n        {\n            w = new OutputStreamWriter( new FileOutputStream( dotProject ), \"UTF-8\" );\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( \"projectDescription\" ); //$NON-NLS-1$\n\n        writer.startElement( ELT_NAME );\n        writer.writeText( config.getEclipseProjectName() );\n        writer.endElement();\n\n        // TODO: this entire element might be dropped if the comment is null.\n        // but as the maven1 eclipse plugin does it, it's better to be safe than sorry\n        // A eclipse developer might want to look at this.\n        writer.startElement( \"comment\" ); //$NON-NLS-1$\n\n        if ( config.getProject().getDescription() != null )\n        {\n            writer.writeText( config.getProject().getDescription() );\n        }\n\n        writer.endElement();\n\n        writer.startElement( \"projects\" ); //$NON-NLS-1$\n\n        // referenced projects should not be added for plugins\n        if ( !config.isPde() )\n        {\n            List duplicates = new ArrayList();\n            for ( int j = 0; j < config.getDepsOrdered().length; j++ )\n            {\n                IdeDependency dep = config.getDepsOrdered()[j];\n                // Avoid duplicates entries when same project is refered using multiple types\n                // (ejb, test-jar ...)\n                if ( dep.isReferencedProject() && ! duplicates.contains( dep.getEclipseProjectName() ))\n                {\n                    writer.startElement( \"project\" ); //$NON-NLS-1$\n                    writer.writeText( dep.getEclipseProjectName() );\n                    writer.endElement();\n                    duplicates.add( dep.getEclipseProjectName() );\n                }\n            }\n        }\n\n        writer.endElement(); // projects\n\n        writer.startElement( ELT_BUILD_SPEC );\n\n        for ( Iterator it = buildCommands.iterator(); it.hasNext(); )\n        {\n            ( (BuildCommand) it.next() ).print( writer );\n        }\n\n        writer.endElement(); // buildSpec\n\n        writer.startElement( ELT_NATURES );\n\n        for ( Iterator it = projectnatures.iterator(); it.hasNext(); )\n        {\n            writer.startElement( ELT_NATURE );\n            writer.writeText( (String) it.next() );\n            writer.endElement(); // name\n        }\n\n        writer.endElement(); // natures\n\n        boolean addLinks = !config.getProjectBaseDir().equals( config.getEclipseProjectDirectory() );\n\n        if ( addLinks || ( config.isPde() && config.getDepsOrdered().length > 0 ) )\n        {\n            writer.startElement( \"linkedResources\" ); //$NON-NLS-1$\n\n            if ( addLinks )\n            {\n\n                addFileLink( writer, config.getProjectBaseDir(), config.getEclipseProjectDirectory(),\n                             config.getProject().getFile() );\n\n                addSourceLinks( writer, config.getProjectBaseDir(), config.getEclipseProjectDirectory(),\n                                config.getProject().getCompileSourceRoots() );\n                addResourceLinks( writer, config.getProjectBaseDir(), config.getEclipseProjectDirectory(),\n                                  config.getProject().getBuild().getResources() );\n\n                addSourceLinks( writer, config.getProjectBaseDir(), config.getEclipseProjectDirectory(),\n                                config.getProject().getTestCompileSourceRoots() );\n                addResourceLinks( writer, config.getProjectBaseDir(), config.getEclipseProjectDirectory(),\n                                  config.getProject().getBuild().getTestResources() );\n\n            }\n\n            if ( config.isPde() )\n            {\n                for ( int j = 0; j < config.getDepsOrdered().length; j++ )\n                {\n                    IdeDependency dep = config.getDepsOrdered()[j];\n\n                    if ( dep.isAddedToClasspath() && !dep.isProvided() && !dep.isReferencedProject() &&\n                        !dep.isTestDependency() && !dep.isOsgiBundle() )\n                    {\n                        String name = dep.getFile().getName();\n                        addLink( writer, name, StringUtils.replace( IdeUtils.getCanonicalPath( dep.getFile() ), \"\\\\\",\n                                                                    \"/\" ), LINK_TYPE_FILE );\n                    }\n                }\n            }\n\n            writer.endElement(); // linkedResources\n        }\n\n        writer.endElement(); // projectDescription\n\n        IOUtil.close( w );\n    }","commit_id":"f649ab097c2ef30d08c9e5aa45a75583f9e512bc","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Resolve source artifacts and download them if <code>downloadSources<\/code> is <code>true<\/code>. Source and\n     * javadocs artifacts will be attached to the <code>IdeDependency<\/code>\n     * @param deps resolved dependencies\n     */\n    private void resolveSourceArtifacts( IdeDependency[] deps )\n    {\n\n        ArtifactRepository localRepository = getLocalRepository();\n        ArtifactResolver artifactResolver = getArtifactResolver();\n        ArtifactFactory artifactFactory = getArtifactFactory();\n\n        // if downloadSources is off, just check local repository for reporting missing jars\n        List remoteRepos = getDownloadSources() ? getRemoteArtifactRepositories() : Collections.EMPTY_LIST;\n\n        for ( int j = 0; j < deps.length; j++ )\n        {\n            IdeDependency dependency = deps[j];\n\n            if ( dependency.isReferencedProject() )\n            {\n                // source artifact not needed\n                continue;\n            }\n\n            // source artifact: use the \"sources\" classifier added by the source plugin\n            Artifact sourceArtifact = IdeUtils.resolveArtifactWithClassifier( dependency.getGroupId(), dependency\n                .getArtifactId(), dependency.getVersion(), \"sources\", localRepository, artifactResolver, //$NON-NLS-1$\n                                                                              artifactFactory, remoteRepos, getLog() );\n\n            if ( sourceArtifact.isResolved() )\n            {\n                dependency.setSourceAttachment( sourceArtifact.getFile() );\n            }\n            else\n            {\n                // try using a plain javadoc jar if the source jar is not available\n                Artifact javadocArtifact = IdeUtils.resolveArtifactWithClassifier( dependency.getGroupId(), dependency\n                    .getArtifactId(), dependency.getVersion(), \"javadoc\", localRepository, artifactResolver, //$NON-NLS-1$\n                                                                                   artifactFactory, remoteRepos,\n                                                                                   getLog() );\n\n                if ( javadocArtifact.isResolved() )\n                {\n                    dependency.setJavadocAttachment( javadocArtifact.getFile() );\n                }\n\n                // @todo also report deps without a source attachment but with a javadoc one?\n                missingSourceDependencies.add( dependency );\n            }\n        }\n    }","id":28734,"modified_method":"/**\n     * Resolve source artifacts and download them if <code>downloadSources<\/code> is <code>true<\/code>. Source and\n     * javadocs artifacts will be attached to the <code>IdeDependency<\/code>\n     * @param deps resolved dependencies\n     */\n    private void resolveSourceArtifacts( IdeDependency[] deps )\n    {\n\n        ArtifactRepository localRepository = getLocalRepository();\n        ArtifactResolver artifactResolver = getArtifactResolver();\n        ArtifactFactory artifactFactory = getArtifactFactory();\n\n        // if downloadSources is off, just check local repository for reporting missing jars\n        List remoteRepos = getDownloadSources() ? getRemoteArtifactRepositories() : Collections.EMPTY_LIST;\n\n        for ( int j = 0; j < deps.length; j++ )\n        {\n            IdeDependency dependency = deps[j];\n\n            if ( dependency.isReferencedProject() || dependency.isSystemScoped() )\n            {\n                // source artifact not needed\n                continue;\n            }\n\n            // source artifact: use the \"sources\" classifier added by the source plugin\n            Artifact sourceArtifact = IdeUtils.resolveArtifactWithClassifier( dependency.getGroupId(), dependency\n                .getArtifactId(), dependency.getVersion(), \"sources\", localRepository, artifactResolver, //$NON-NLS-1$\n                                                                              artifactFactory, remoteRepos, getLog() );\n\n            if ( sourceArtifact.isResolved() )\n            {\n                dependency.setSourceAttachment( sourceArtifact.getFile() );\n            }\n            else\n            {\n                // try using a plain javadoc jar if the source jar is not available\n                Artifact javadocArtifact = IdeUtils.resolveArtifactWithClassifier( dependency.getGroupId(), dependency\n                    .getArtifactId(), dependency.getVersion(), \"javadoc\", localRepository, artifactResolver, //$NON-NLS-1$\n                                                                                   artifactFactory, remoteRepos,\n                                                                                   getLog() );\n\n                if ( javadocArtifact.isResolved() )\n                {\n                    dependency.setJavadocAttachment( javadocArtifact.getFile() );\n                }\n\n                // @todo also report deps without a source attachment but with a javadoc one?\n                missingSourceDependencies.add( dependency );\n            }\n        }\n    }","commit_id":"f4370c5e6d20469c4a834d81f9eb0ddae22608a1","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void write( File projectBaseDir, EclipseSourceDir[] sourceDirs, List classpathContainers,\n                       ArtifactRepository localRepository, File buildOutputDirectory )\n        throws MojoExecutionException\n    {\n\n        FileWriter w;\n\n        try\n        {\n            w = new FileWriter( new File( getEclipseProjectDirectory(), FILE_DOT_CLASSPATH ) );\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( ELT_CLASSPATH );\n\n        String defaultOutput = IdeUtils.toRelativeAndFixSeparator( projectBaseDir, buildOutputDirectory, false );\n\n        // ----------------------------------------------------------------------\n        // Source roots and resources\n        // ----------------------------------------------------------------------\n\n        for ( int j = 0; j < sourceDirs.length; j++ )\n        {\n            EclipseSourceDir dir = sourceDirs[j];\n\n            writer.startElement( ELT_CLASSPATHENTRY );\n\n            writer.addAttribute( ATTR_KIND, \"src\" ); //$NON-NLS-1$ \n            writer.addAttribute( ATTR_PATH, dir.getPath() );\n            if ( dir.getOutput() != null && !defaultOutput.equals( dir.getOutput() ) )\n            {\n                writer.addAttribute( ATTR_OUTPUT, dir.getOutput() );\n            }\n\n            writer.endElement();\n\n        }\n\n        // ----------------------------------------------------------------------\n        // The default output\n        // ----------------------------------------------------------------------\n\n        writer.startElement( ELT_CLASSPATHENTRY );\n        writer.addAttribute( ATTR_KIND, ATTR_OUTPUT );\n        writer.addAttribute( ATTR_PATH, defaultOutput );\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // Container classpath entries\n        // ----------------------------------------------------------------------\n\n        for ( Iterator it = classpathContainers.iterator(); it.hasNext(); )\n        {\n            writer.startElement( ELT_CLASSPATHENTRY );\n            writer.addAttribute( ATTR_KIND, \"con\" ); //$NON-NLS-1$ \n            writer.addAttribute( ATTR_PATH, (String) it.next() );\n            writer.endElement(); // name\n        }\n\n        // ----------------------------------------------------------------------\n        // The dependencies\n        // ----------------------------------------------------------------------\n\n        for ( int j = 0; j < deps.length; j++ )\n        {\n            IdeDependency dep = deps[j];\n\n            if ( dep.isAddedToClasspath() )\n            {\n                addDependency( writer, dep, localRepository );\n            }\n        }\n\n        writer.endElement();\n\n        IOUtil.close( w );\n\n    }","id":28735,"modified_method":"public void write( File projectBaseDir, EclipseSourceDir[] sourceDirs, List classpathContainers,\n                       ArtifactRepository localRepository, File buildOutputDirectory, boolean inPdeMode,\n                       String pdeLibDir )\n        throws MojoExecutionException\n    {\n\n        FileWriter w;\n\n        try\n        {\n            w = new FileWriter( new File( getEclipseProjectDirectory(), FILE_DOT_CLASSPATH ) );\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( ELT_CLASSPATH );\n\n        String defaultOutput = IdeUtils.toRelativeAndFixSeparator( projectBaseDir, buildOutputDirectory, false );\n\n        // ----------------------------------------------------------------------\n        // Source roots and resources\n        // ----------------------------------------------------------------------\n\n        for ( int j = 0; j < sourceDirs.length; j++ )\n        {\n            EclipseSourceDir dir = sourceDirs[j];\n\n            writer.startElement( ELT_CLASSPATHENTRY );\n\n            writer.addAttribute( ATTR_KIND, \"src\" ); //$NON-NLS-1$ \n            writer.addAttribute( ATTR_PATH, dir.getPath() );\n            if ( dir.getOutput() != null && !defaultOutput.equals( dir.getOutput() ) )\n            {\n                writer.addAttribute( ATTR_OUTPUT, dir.getOutput() );\n            }\n\n            writer.endElement();\n\n        }\n\n        // ----------------------------------------------------------------------\n        // The default output\n        // ----------------------------------------------------------------------\n\n        writer.startElement( ELT_CLASSPATHENTRY );\n        writer.addAttribute( ATTR_KIND, ATTR_OUTPUT );\n        writer.addAttribute( ATTR_PATH, defaultOutput );\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // Container classpath entries\n        // ----------------------------------------------------------------------\n\n        for ( Iterator it = classpathContainers.iterator(); it.hasNext(); )\n        {\n            writer.startElement( ELT_CLASSPATHENTRY );\n            writer.addAttribute( ATTR_KIND, \"con\" ); //$NON-NLS-1$ \n            writer.addAttribute( ATTR_PATH, (String) it.next() );\n            writer.endElement(); // name\n        }\n\n        // ----------------------------------------------------------------------\n        // The dependencies\n        // ----------------------------------------------------------------------\n\n        for ( int j = 0; j < deps.length; j++ )\n        {\n            IdeDependency dep = deps[j];\n\n            if ( dep.isAddedToClasspath() )\n            {\n                addDependency( writer, dep, localRepository, projectBaseDir, inPdeMode, pdeLibDir );\n            }\n        }\n\n        writer.endElement();\n\n        IOUtil.close( w );\n\n    }","commit_id":"bf34a2ad0c0288ebf6aca749b5634b9c8d32c3da","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void addDependency( XMLWriter writer, IdeDependency dep, ArtifactRepository localRepository )\n        throws MojoExecutionException\n    {\n\n        String path;\n        String kind;\n        String sourcepath = null;\n        String javadocpath = null;\n\n        if ( dep.isReferencedProject() )\n        {\n            path = \"/\" + dep.getArtifactId(); //$NON-NLS-1$\n            kind = \"src\"; //$NON-NLS-1$\n        }\n        else\n        {\n            File artifactPath = dep.getFile();\n\n            if ( artifactPath == null )\n            {\n                getLog().error( Messages.getString( \"EclipsePlugin.artifactpathisnull\", dep.getId() ) ); //$NON-NLS-1$\n                return;\n            }\n\n            if ( dep.isSystemScoped() )\n            {\n                path = IdeUtils.toRelativeAndFixSeparator( getEclipseProjectDirectory(), artifactPath, false );\n\n                if ( getLog().isDebugEnabled() )\n                {\n                    getLog().debug( Messages.getString( \"EclipsePlugin.artifactissystemscoped\", //$NON-NLS-1$\n                                                        new Object[] { dep.getArtifactId(), path } ) );\n                }\n\n                kind = \"lib\"; //$NON-NLS-1$\n            }\n            else\n            {\n                File localRepositoryFile = new File( localRepository.getBasedir() );\n\n                String fullPath = artifactPath.getPath();\n\n                path = \"M2_REPO/\" //$NON-NLS-1$\n                    + IdeUtils.toRelativeAndFixSeparator( localRepositoryFile, new File( fullPath ), false );\n\n                if ( dep.getSourceAttachment() != null )\n                {\n                    sourcepath = \"M2_REPO/\" //$NON-NLS-1$\n                        + IdeUtils.toRelativeAndFixSeparator( localRepositoryFile, dep.getSourceAttachment(), false );\n                }\n\n                if ( dep.getJavadocAttachment() != null )\n                {\n                    //                  NB eclipse (3.1) doesn't support variables in javadoc paths, so we need to add the\n                    // full path for the maven repo\n                    javadocpath = StringUtils.replace( IdeUtils.getCanonicalPath( dep.getJavadocAttachment() ),\n                                                       \"\\\\\", \"/\" ); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n\n                kind = \"var\"; //$NON-NLS-1$\n            }\n\n        }\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", kind ); //$NON-NLS-1$\n        writer.addAttribute( \"path\", path ); //$NON-NLS-1$\n\n        if ( sourcepath != null )\n        {\n            writer.addAttribute( \"sourcepath\", sourcepath ); //$NON-NLS-1$\n        }\n        else if ( javadocpath != null )\n        {\n            writer.startElement( \"attributes\" ); //$NON-NLS-1$\n\n            writer.startElement( \"attribute\" ); //$NON-NLS-1$\n            writer.addAttribute( \"value\", \"jar:file:/\" + javadocpath + \"!/\" ); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n            writer.addAttribute( \"name\", \"javadoc_location\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.endElement();\n\n            writer.endElement();\n        }\n\n        writer.endElement();\n\n    }","id":28736,"modified_method":"private void addDependency( XMLWriter writer, IdeDependency dep, ArtifactRepository localRepository,\n                                File projectBaseDir, boolean inPdeMode, String pdeLibDir )\n        throws MojoExecutionException\n    {\n\n        String path;\n        String kind;\n        String sourcepath = null;\n        String javadocpath = null;\n\n        if ( dep.isReferencedProject() && !inPdeMode )\n        {\n            path = \"/\" + dep.getArtifactId(); //$NON-NLS-1$\n            kind = ATTR_SRC;\n        }\n        else\n        {\n            File artifactPath = dep.getFile();\n\n            if ( artifactPath == null )\n            {\n                getLog().error( Messages.getString( \"EclipsePlugin.artifactpathisnull\", dep.getId() ) ); //$NON-NLS-1$\n                return;\n            }\n\n            if ( dep.isSystemScoped() )\n            {\n                path = IdeUtils.toRelativeAndFixSeparator( getEclipseProjectDirectory(), artifactPath, false );\n\n                if ( getLog().isDebugEnabled() )\n                {\n                    getLog().debug( Messages.getString( \"EclipsePlugin.artifactissystemscoped\", //$NON-NLS-1$\n                                                        new Object[] { dep.getArtifactId(), path } ) );\n                }\n\n                kind = ATTR_LIB;\n            }\n            else\n            {\n                File localRepositoryFile = new File( localRepository.getBasedir() );\n\n                // if the dependency is not provided and the plugin runs in \"pde mode\", the dependency is\n                // added to the Bundle-Classpath:\n                if ( inPdeMode && !dep.isProvided() )\n                {\n                    try\n                    {\n                        // TODO problem with reactor build\n                        File libsDir = new File( projectBaseDir, pdeLibDir );\n                        if ( !libsDir.exists() )\n                        {\n                            libsDir.mkdirs();\n                        }\n                        FileUtils.copyFileToDirectory( dep.getFile(), libsDir );\n\n                    }\n                    catch ( IOException e )\n                    {\n                        throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.cantcopyartifact\", dep\n                            .getArtifactId() ) );\n                    }\n                    path = pdeLibDir + \"/\" + dep.getFile().getName();\n                    kind = ATTR_LIB;\n                }\n                // running in PDE mode and the dependency is provided means, that it is provided by\n                // the target platform. This case is covered by adding the plugin container\n                else if ( inPdeMode && dep.isProvided() )\n                {\n                    return;\n                }\n                else\n                {\n                    String fullPath = artifactPath.getPath();\n\n                    path = M2_REPO + \"/\" //$NON-NLS-1$\n                        + IdeUtils.toRelativeAndFixSeparator( localRepositoryFile, new File( fullPath ), false );\n\n                    kind = ATTR_VAR; //$NON-NLS-1$\n                }\n                if ( dep.getSourceAttachment() != null )\n                {\n                    sourcepath = M2_REPO + \"/\" //$NON-NLS-1$\n                        + IdeUtils.toRelativeAndFixSeparator( localRepositoryFile, dep.getSourceAttachment(), false );\n                }\n\n                if ( dep.getJavadocAttachment() != null )\n                {\n                    //                  NB eclipse (3.1) doesn't support variables in javadoc paths, so we need to add the\n                    // full path for the maven repo\n                    javadocpath = StringUtils.replace( IdeUtils.getCanonicalPath( dep.getJavadocAttachment() ),\n                                                       \"\\\\\", \"/\" ); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n\n            }\n\n        }\n\n        writer.startElement( ELT_CLASSPATHENTRY );\n        writer.addAttribute( ATTR_KIND, kind );\n        writer.addAttribute( ATTR_PATH, path );\n\n        if ( sourcepath != null )\n        {\n            writer.addAttribute( ATTR_SOURCEPATH, sourcepath );\n        }\n        else if ( javadocpath != null )\n        {\n            writer.startElement( \"attributes\" ); //$NON-NLS-1$\n\n            writer.startElement( \"attribute\" ); //$NON-NLS-1$\n            writer.addAttribute( \"value\", \"jar:file:/\" + javadocpath + \"!/\" ); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n            writer.addAttribute( \"name\", \"javadoc_location\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.endElement();\n\n            writer.endElement();\n        }\n\n        writer.endElement();\n\n    }","commit_id":"bf34a2ad0c0288ebf6aca749b5634b9c8d32c3da","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void fillDefaultNatures( String packaging )\n    {\n        projectnatures = new ArrayList();\n\n        if ( wtp10 )\n        {\n            projectnatures.add( NATURE_WST_FACET_CORE_NATURE ); // WTP 1.0 nature\n        }\n\n        if ( isJavaProject )\n        {\n            projectnatures.add( NATURE_JDT_CORE_JAVA );\n        }\n\n        if ( wtpR7 || wtp10 )\n        {\n            projectnatures.add( NATURE_WST_MODULE_CORE_NATURE ); // WTP 0.7/1.0 nature\n\n            if ( isJavaProject )\n            {\n                projectnatures.add( NATURE_JEM_WORKBENCH_JAVA_EMF ); // WTP 0.7/1.0 nature\n            }\n        }\n\n    }","id":28737,"modified_method":"private void fillDefaultNatures( String packaging )\n    {\n        projectnatures = new ArrayList();\n\n        if ( wtp10 )\n        {\n            projectnatures.add( NATURE_WST_FACET_CORE_NATURE ); // WTP 1.0 nature\n        }\n\n        if ( isJavaProject )\n        {\n            projectnatures.add( NATURE_JDT_CORE_JAVA );\n        }\n\n        if ( wtpR7 || wtp10 )\n        {\n            projectnatures.add( NATURE_WST_MODULE_CORE_NATURE ); // WTP 0.7/1.0 nature\n\n            if ( isJavaProject )\n            {\n                projectnatures.add( NATURE_JEM_WORKBENCH_JAVA_EMF ); // WTP 0.7/1.0 nature\n            }\n        }\n\n        if ( pde )\n        {\n            projectnatures.add( NATURE_PDE_PLUGIN );\n        }\n\n    }","commit_id":"bf34a2ad0c0288ebf6aca749b5634b9c8d32c3da","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void writeConfiguration( IdeDependency[] deps )\n        throws MojoExecutionException\n    {\n        File projectBaseDir = executedProject.getFile().getParentFile();\n\n        // build a list of UNIQUE source dirs (both src and resources) to be\n        // used in classpath and wtpmodules\n        EclipseSourceDir[] sourceDirs = buildDirectoryList( executedProject, eclipseProjectDir, buildOutputDirectory );\n\n        if ( wtpR7 )\n        {\n            new EclipseWtpmodulesWriter( getLog(), eclipseProjectDir, project, deps ).write( sourceDirs,\n                                                                                             localRepository,\n                                                                                             buildOutputDirectory );\n        }\n\n        if ( wtp10 || wtp15 )\n        {\n            new EclipseWtpFacetsWriter( getLog(), eclipseProjectDir, project, deps ).write( sourceDirs,\n                                                                                            localRepository,\n                                                                                            buildOutputDirectory );\n        }\n        if ( wtp10 )\n        {\n\n            new EclipseWtpComponentWriter( getLog(), eclipseProjectDir, project, deps ).write( sourceDirs,\n                                                                                               localRepository,\n                                                                                               buildOutputDirectory );\n        }\n        if ( wtp15 )\n        {\n            new EclipseWtpComponent15Writer( getLog(), eclipseProjectDir, project, deps ).write( sourceDirs,\n                                                                                                 localRepository,\n                                                                                                 buildOutputDirectory );\n        }\n\n        new EclipseProjectWriter( getLog(), eclipseProjectDir, project, deps ).write( projectBaseDir, executedProject,\n                                                                                      projectnatures, buildcommands );\n\n        new EclipseSettingsWriter( getLog(), eclipseProjectDir, project, deps ).write();\n\n        if ( isJavaProject )\n        {\n            new EclipseClasspathWriter( getLog(), eclipseProjectDir, project, deps ).write( projectBaseDir, sourceDirs,\n                                                                                            classpathContainers,\n                                                                                            localRepository,\n                                                                                            buildOutputDirectory );\n        }\n\n        getLog().info( Messages.getString( \"EclipsePlugin.wrote\", new Object[] { //$NON-NLS-1$\n                                           project.getArtifactId(), eclipseProjectDir.getAbsolutePath() } ) );\n    }","id":28738,"modified_method":"public void writeConfiguration( IdeDependency[] deps )\n        throws MojoExecutionException\n    {\n        File projectBaseDir = executedProject.getFile().getParentFile();\n\n        // build a list of UNIQUE source dirs (both src and resources) to be\n        // used in classpath and wtpmodules\n        EclipseSourceDir[] sourceDirs = buildDirectoryList( executedProject, eclipseProjectDir, buildOutputDirectory );\n\n        if ( wtpR7 )\n        {\n            new EclipseWtpmodulesWriter( getLog(), eclipseProjectDir, project, deps ).write( sourceDirs,\n                                                                                             localRepository,\n                                                                                             buildOutputDirectory );\n        }\n\n        if ( wtp10 || wtp15 )\n        {\n            new EclipseWtpFacetsWriter( getLog(), eclipseProjectDir, project, deps ).write( sourceDirs,\n                                                                                            localRepository,\n                                                                                            buildOutputDirectory );\n        }\n        if ( wtp10 )\n        {\n\n            new EclipseWtpComponentWriter( getLog(), eclipseProjectDir, project, deps ).write( sourceDirs,\n                                                                                               localRepository,\n                                                                                               buildOutputDirectory );\n        }\n        if ( wtp15 )\n        {\n            new EclipseWtpComponent15Writer( getLog(), eclipseProjectDir, project, deps ).write( sourceDirs,\n                                                                                                 localRepository,\n                                                                                                 buildOutputDirectory );\n        }\n\n        new EclipseProjectWriter( getLog(), eclipseProjectDir, project, deps ).write( projectBaseDir, executedProject,\n                                                                                      projectnatures, buildcommands );\n\n        new EclipseSettingsWriter( getLog(), eclipseProjectDir, project, deps ).write();\n\n        if ( isJavaProject )\n        {\n            new EclipseClasspathWriter( getLog(), eclipseProjectDir, project, deps ).write( projectBaseDir, sourceDirs,\n                                                                                            classpathContainers,\n                                                                                            localRepository,\n                                                                                            buildOutputDirectory, pde,\n                                                                                            pdeLibDir );\n        }\n\n        if ( pde )\n        {\n            this.getLog().info( \"The Maven Eclipse plugin runs in 'pde'-mode.\" );\n            new EclipseOSGiManifestWriter( getLog(), eclipseProjectDir, project, deps )\n                .write( this.manifest, pdeLibDir );\n        }\n\n        getLog().info( Messages.getString( \"EclipsePlugin.wrote\", new Object[] { //$NON-NLS-1$\n                                           project.getArtifactId(), eclipseProjectDir.getAbsolutePath() } ) );\n    }","commit_id":"bf34a2ad0c0288ebf6aca749b5634b9c8d32c3da","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void fillDefaultBuilders( String packaging )\n    {\n        buildcommands = new ArrayList();\n\n        if ( wtpR7 )\n        {\n            buildcommands.add( BUILDER_WST_COMPONENT_STRUCTURAL ); // WTP 0.7 builder\n        }\n\n        if ( isJavaProject )\n        {\n            buildcommands.add( BUILDER_JDT_CORE_JAVA );\n        }\n\n        if ( wtpR7 || wtp10 )\n        {\n            buildcommands.add( BUILDER_WST_VALIDATION ); // WTP 0.7/1.0 builder\n        }\n\n        if ( wtpR7 )\n        {\n            buildcommands.add( BUILDER_WST_COMPONENT_STRUCTURAL_DEPENDENCY_RESOLVER ); // WTP 0.7 builder\n        }\n    }","id":28739,"modified_method":"private void fillDefaultBuilders( String packaging )\n    {\n        buildcommands = new ArrayList();\n\n        if ( wtpR7 )\n        {\n            buildcommands.add( BUILDER_WST_COMPONENT_STRUCTURAL ); // WTP 0.7 builder\n        }\n\n        if ( isJavaProject )\n        {\n            buildcommands.add( BUILDER_JDT_CORE_JAVA );\n        }\n\n        if ( wtpR7 || wtp10 )\n        {\n            buildcommands.add( BUILDER_WST_VALIDATION ); // WTP 0.7/1.0 builder\n        }\n\n        if ( wtpR7 )\n        {\n            buildcommands.add( BUILDER_WST_COMPONENT_STRUCTURAL_DEPENDENCY_RESOLVER ); // WTP 0.7 builder\n        }\n\n        if ( pde )\n        {\n            buildcommands.add( BUILDER_PDE_MANIFEST );\n            buildcommands.add( BUILDER_PDE_SCHEMA );\n        }\n    }","commit_id":"bf34a2ad0c0288ebf6aca749b5634b9c8d32c3da","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void fillDefaultClasspathContainers( String packaging )\n    {\n        classpathContainers = new ArrayList();\n        classpathContainers.add( COMMON_PATH_JDT_LAUNCHING_JRE_CONTAINER );\n    }","id":28740,"modified_method":"private void fillDefaultClasspathContainers( String packaging )\n    {\n        classpathContainers = new ArrayList();\n        classpathContainers.add( COMMON_PATH_JDT_LAUNCHING_JRE_CONTAINER );\n\n        if ( pde )\n        {\n            classpathContainers.add( REQUIRED_PLUGINS_CONTAINER );\n        }\n    }","commit_id":"bf34a2ad0c0288ebf6aca749b5634b9c8d32c3da","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Sends status <code>401<\/code> (Unauthorized) with a\n     * <code>WWW-Authenticate<\/code> requesting standard HTTP header\n     * authentication with the <code>Basic<\/code> scheme and the configured\n     * realm name.\n     * <p>\n     * Returns <code>true<\/code> if the response could successfully be sent to\n     * the client. Otherwise <code>false<\/code> is returned.\n     *\n     * @param request The request object\n     * @param response The response object to which to send the request\n     * @param addInfo Additional information string from the configuration. This\n     *            may for example be used as the realm name for HTTP header\n     *            authentication. TODO configuration\n     * @return true if the information could be requested or false, if the\n     *         request should fail with the appropriate error status\n     */\n    public boolean requestAuthentication(HttpServletRequest request,\n            HttpServletResponse response) {\n\n        // if the response is already committed, we have a problem !!\n        if (response.isCommitted()) {\n            log.warn(\"requestAuthentication: response already committed\");\n            return false;\n        }\n\n        response.setHeader(HEADER_WWW_AUTHENTICATE,\n            AUTHENTICATION_SCHEME_BASIC + \" realm=\\\"\" + this.realm + \"\\\"\");\n\n        try {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return true;\n        } catch (IOException ioe) {\n            log.info(\"requestAuthentication: Cannot send the error: {0}\",\n                ioe.toString());\n        }\n\n        // got a problem with sending the error\n        return false;\n    }","id":28741,"modified_method":"/**\n     * Sends status <code>401<\/code> (Unauthorized) with a\n     * <code>WWW-Authenticate<\/code> requesting standard HTTP header\n     * authentication with the <code>Basic<\/code> scheme and the configured\n     * realm name. If the response is already committed, an error message is\n     * logged but the 401 status is not sent.\n     *\n     * @param request The request object\n     * @param response The response object to which to send the request\n     * @return <code>true<\/code> is always returned by this handler\n     * @throws IOException if an error occurrs sending back the response.\n     */\n    public boolean requestAuthentication(HttpServletRequest request,\n            HttpServletResponse response) throws IOException {\n\n        // if the response is already committed, we have a problem !!\n        if (!response.isCommitted()) {\n\n            response.setHeader(HEADER_WWW_AUTHENTICATE,\n                AUTHENTICATION_SCHEME_BASIC + \" realm=\\\"\" + this.realm + \"\\\"\");\n\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n\n        } else {\n\n            log.error(\"requestAuthentication: Response is committed, cannot request authentication\");\n\n\n        }\n\n        return true;\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Extract the Base64 authentication string from the request\n     */\n    protected Credentials extractAuthentication(HttpServletRequest request) {\n\n        // Return immediately if the header is missing\n        String authHeader = request.getHeader(HEADER_AUTHORIZATION);\n        if (authHeader == null || authHeader.length() == 0) {\n\n            // try to fall back to cookies\n            Cookie[] cookies = request.getCookies();\n            if (cookies != null) {\n                for (int i = 0; i < cookies.length; i++) {\n                    if (HEADER_AUTHORIZATION.equalsIgnoreCase(cookies[i].getName())) {\n                        authHeader = cookies[i].getValue();\n                        break;\n                    }\n                }\n            }\n\n            // If still no authentication, return null\n            if (authHeader == null || authHeader.length() == 0) {\n                return null;\n            }\n        }\n\n        // Get the authType (Basic, Digest) and authInfo (user/password) from\n        // the header\n        authHeader = authHeader.trim();\n        int blank = authHeader.indexOf(' ');\n        if (blank <= 0) {\n            return null;\n        }\n        String authType = authHeader.substring(0, blank);\n        String authInfo = authHeader.substring(blank).trim();\n\n        // Check whether authorization type matches\n        if (!authType.equalsIgnoreCase(AUTHENTICATION_SCHEME_BASIC)) {\n            return null;\n        }\n\n        // Base64 decode and split on colon\n\n        // we cannot use default base64, since we need iso encoding\n        // (nb: ISO-8859-1 is required as per API spec to be available)\n        String decoded;\n        try {\n            byte[] encoded = authInfo.getBytes(\"ISO-8859-1\");\n            byte[] bytes = Base64.decodeBase64(encoded);\n            decoded = new String(bytes, \"ISO-8859-1\");\n        } catch (UnsupportedEncodingException uee) {\n            // unexpected\n            log.error(\n                \"extractAuthentication: Cannot en/decode authentication info\",\n                uee);\n            return null;\n        }\n\n        int colIdx = decoded.indexOf(':');\n        if (colIdx < 0) {\n            return new SimpleCredentials(decoded, new char[0]);\n        }\n\n        return new SimpleCredentials(decoded.substring(0, colIdx),\n            decoded.substring(colIdx + 1).toCharArray());\n    }","id":28742,"modified_method":"/**\n     * Extract the Base64 authentication string from the request\n     */\n    protected AuthenticationInfo extractAuthentication(\n            HttpServletRequest request) {\n\n        // Return immediately if the header is missing\n        String authHeader = request.getHeader(HEADER_AUTHORIZATION);\n        if (authHeader == null || authHeader.length() == 0) {\n\n            // try to fall back to cookies\n            Cookie[] cookies = request.getCookies();\n            if (cookies != null) {\n                for (int i = 0; i < cookies.length; i++) {\n                    if (HEADER_AUTHORIZATION.equalsIgnoreCase(cookies[i].getName())) {\n                        authHeader = cookies[i].getValue();\n                        break;\n                    }\n                }\n            }\n\n            // If still no authentication, return null\n            if (authHeader == null || authHeader.length() == 0) {\n                return null;\n            }\n        }\n\n        // Get the authType (Basic, Digest) and authInfo (user/password) from\n        // the header\n        authHeader = authHeader.trim();\n        int blank = authHeader.indexOf(' ');\n        if (blank <= 0) {\n            return null;\n        }\n        String authType = authHeader.substring(0, blank);\n        String authInfo = authHeader.substring(blank).trim();\n\n        // Check whether authorization type matches\n        if (!authType.equalsIgnoreCase(AUTHENTICATION_SCHEME_BASIC)) {\n            return null;\n        }\n\n        // Base64 decode and split on colon\n\n        // we cannot use default base64, since we need iso encoding\n        // (nb: ISO-8859-1 is required as per API spec to be available)\n        String decoded;\n        try {\n            byte[] encoded = authInfo.getBytes(\"ISO-8859-1\");\n            byte[] bytes = Base64.decodeBase64(encoded);\n            decoded = new String(bytes, \"ISO-8859-1\");\n        } catch (UnsupportedEncodingException uee) {\n            // unexpected\n            log.error(\n                \"extractAuthentication: Cannot en/decode authentication info\",\n                uee);\n            return null;\n        }\n\n        Credentials creds;\n        int colIdx = decoded.indexOf(':');\n        if (colIdx < 0) {\n            creds = new SimpleCredentials(decoded, new char[0]);\n        } else {\n            creds = new SimpleCredentials(decoded.substring(0, colIdx),\n                decoded.substring(colIdx + 1).toCharArray());\n        }\n\n        return new AuthenticationInfo(HttpServletRequest.BASIC_AUTH, creds);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Extracts credential data from the request if at all contained. This check\n     * is only based on the original request object, no URI translation has\n     * taken place yet.\n     * <p>\n     * The method returns any of the following values : <table>\n     * <tr>\n     * <th>value\n     * <th>description<\/tr>\n     * <tr>\n     * <td><code>null<\/code>\n     * <td>no user details were contained in the request <\/tr>\n     * <tr>\n     * <td>{@link #DOING_AUTH}\n     * <td>the handler is in an ongoing authentication exchange with the\n     * client. The request handling is terminated.\n     * <tr>\n     * <tr>\n     * <td>valid credentials\n     * <td>The user sent credentials.<\/tr>\n     * <\/table>\n     * <p>\n     * The method must not request credential information from the client, if\n     * they are not found in the request.\n     * <p>\n     * Note : The implementation should pay special attention to the fact, that\n     * the request may be for an included servlet, in which case the values for\n     * some URI specific values are contained in javax.servlet.include.* request\n     * attributes.\n     *\n     * @param request The request object containing the information for the\n     *            authentication.\n     * @param response The response object which may be used to send the\n     *            information on the request failure to the user.\n     * @return A valid Credentials instance identifying the request user,\n     *         DOING_AUTH if the handler is in an authentication trasaction with\n     *         the client or null if the request does not contain authentication\n     *         information. In case of DOING_AUTH, the method must have sent a\n     *         response indicating that fact to the client.\n     */\n    public Credentials authenticate(HttpServletRequest request,\n            HttpServletResponse response) {\n        return this.extractAuthentication(request);\n    }","id":28743,"modified_method":"/**\n     * Extracts credential data from the request if at all contained. This check\n     * is only based on the original request object, no URI translation has\n     * taken place yet.\n     * <p>\n     * The method returns any of the following values : <table>\n     * <tr>\n     * <th>value\n     * <th>description<\/tr>\n     * <tr>\n     * <td><code>null<\/code>\n     * <td>no user details were contained in the request <\/tr>\n     * <tr>\n     * <td>{@link #DOING_AUTH}\n     * <td>the handler is in an ongoing authentication exchange with the\n     * client. The request handling is terminated.\n     * <tr>\n     * <tr>\n     * <td>valid credentials\n     * <td>The user sent credentials.<\/tr>\n     * <\/table>\n     * <p>\n     * The method must not request credential information from the client, if\n     * they are not found in the request.\n     * <p>\n     * Note : The implementation should pay special attention to the fact, that\n     * the request may be for an included servlet, in which case the values for\n     * some URI specific values are contained in javax.servlet.include.* request\n     * attributes.\n     *\n     * @param request The request object containing the information for the\n     *            authentication.\n     * @param response The response object which may be used to send the\n     *            information on the request failure to the user.\n     * @return A valid Credentials instance identifying the request user,\n     *         DOING_AUTH if the handler is in an authentication trasaction with\n     *         the client or null if the request does not contain authentication\n     *         information. In case of DOING_AUTH, the method must have sent a\n     *         response indicating that fact to the client.\n     */\n    public AuthenticationInfo authenticate(HttpServletRequest request,\n            HttpServletResponse response) {\n        return this.extractAuthentication(request);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Requests authentication information from the client. Returns\n     * <code>true<\/code> if the information has been requested and request\n     * processing can be terminated. Otherwise the request information could not\n     * be requested and the request should be terminated with a 40x (Forbidden)\n     * response.\n     * <p>\n     * Any response sent by the handler is also handled by the error handler\n     * infrastructure.\n     *\n     * @param req The request object\n     * @param res The response object to which to send the request\n     * @return true if the information could be requested or false, if the\n     *         request should fail with the appropriate error status\n     */\n    public boolean requestAuthentication(HttpServletRequest req,\n            HttpServletResponse res) {\n\n        AuthenticationHandler handler = this.getAuthHandler(req);\n        if (handler != null) {\n            log.debug(\"requestAuthentication: requesting authentication using \"\n                + \"handler: {0}\", handler);\n\n            return handler.requestAuthentication(req, res);\n        }\n\n        log.info(\"requestAuthentication: no handler found for request\");\n        return false;\n    }","id":28744,"modified_method":"/**\n     * Requests authentication information from the client. Returns\n     * <code>true<\/code> if the information has been requested and request\n     * processing can be terminated. Otherwise the request information could not\n     * be requested and the request should be terminated with a 40x (Forbidden)\n     * response.\n     * <p>\n     * Any response sent by the handler is also handled by the error handler\n     * infrastructure.\n     *\n     * @param req The request object\n     * @param res The response object to which to send the request\n     */\n    public void requestAuthentication(HttpServletRequest request,\n            HttpServletResponse response) {\n\n        AuthenticationHandler[] handlers = getAuthenticationHandlers();\n        boolean done = false;\n        for (int i = 0; !done && i < handlers.length; i++) {\n            log.debug(\n                \"requestAuthentication: requesting authentication using handler: {0}\",\n                handlers[i]);\n\n            try {\n                done = handlers[i].requestAuthentication(request, response);\n            } catch (IOException ioe) {\n                log.error(\n                    \"requestAuthentication: Failed sending authentication request through handler \"\n                        + handlers[i] + \", access forbidden\", ioe);\n                done = true;\n            }\n        }\n\n        // no handler could send an authentication request, fail with FORBIDDEN\n        log.info(\"requestAuthentication: No handler for request, sending FORBIDDEN\");\n        sendFailure(response);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"private Session getAnonymousSession(HttpServletRequest req,\n            HttpServletResponse res) {\n        // login anonymously, log the exact cause in case of failure\n        if (this.anonymousAllowed) {\n            try {\n                return getRepository().login();\n            } catch (TooManySessionsException se) {\n                log.error(\n                    \"getAnonymousSession: Too many anonymous users active\", se);\n            } catch (LoginException le) {\n                log.error(\n                    \"getAnonymousSession: Login failure, requesting authentication\",\n                    le);\n            } catch (RepositoryException re) {\n                log.error(\"getAnonymousSession: Cannot get anonymous session\",\n                    re);\n            }\n        } else {\n            log.debug(\"getAnonymousSession: Anonymous access not allowed by configuration\");\n        }\n\n        // request authentication now, and fail if not possible\n        if (!this.requestAuthentication(req, res)) {\n            this.sendFailure(res);\n        }\n\n        // fallback to no session\n        return null;\n    }","id":28745,"modified_method":"private boolean getAnonymousSession(HttpServletRequest req,\n            HttpServletResponse res) {\n        // login anonymously, log the exact cause in case of failure\n        if (this.anonymousAllowed) {\n            try {\n                Session session = getRepository().login();\n                setAttributes(session, null, req);\n                return true;\n            } catch (TooManySessionsException se) {\n                log.error(\n                    \"getAnonymousSession: Too many anonymous users active\", se);\n            } catch (LoginException le) {\n                log.error(\n                    \"getAnonymousSession: Login failure, requesting authentication\",\n                    le);\n            } catch (RepositoryException re) {\n                log.error(\"getAnonymousSession: Cannot get anonymous session\",\n                    re);\n            }\n        } else {\n            log.debug(\"getAnonymousSession: Anonymous access not allowed by configuration\");\n        }\n\n        // request authentication now, and fail if not possible\n        requestAuthentication(req, res);\n\n        // fallback to no session\n        return false;\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"private AuthenticationHandler getAuthHandler(HttpServletRequest req) {\n        AuthenticationHandler[] local = getAuthenticationHandlers();\n        for (int i = 0; i < local.length; i++) {\n            if (local[i].handles(req)) {\n                return local[i];\n            }\n        }\n\n        // no handler found for the request ....\n        return null;\n    }","id":28746,"modified_method":"private AuthenticationInfo getAuthenticationInfo(\n            HttpServletRequest request, HttpServletResponse response) {\n        AuthenticationHandler[] local = getAuthenticationHandlers();\n        for (int i = 0; i < local.length; i++) {\n            AuthenticationInfo authInfo = local[i].authenticate(request,\n                response);\n            if (authInfo != null) {\n                return authInfo;\n            }\n        }\n\n        // no handler found for the request ....\n        log.debug(\"getCredentials: no handler could extract credentials\");\n        return null;\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Checks the authentication contained in the request. This check is only\n     * based on the original request object, no URI translation has taken place\n     * yet.\n     * <p>\n     * The method will either return the anonymous ticket, if no authentication\n     * handler could extract credentials from the request, or null, if\n     * credentials extracted from the request are not valid to create a ticket\n     * or a ticket identifying the user's credentials extracted from the ticket.\n     * This method must not call back to client for valid credentials, if they\n     * are missing.\n     * <p>\n     * If sessions are enabled the returned ticket may be impersonated, that is\n     * for another user than the one who has authenticated.\n     *\n     * @param req The request object containing the information for the\n     *            authentication.\n     * @param res The response object which may be used to send the information\n     *            on the request failure to the user.\n     * @return A valid ContentBus Ticket identifying the request user or the\n     *         anonymous ticket, if the request does not contain credential data\n     *         or null if the credential data cannot be used to create a ticket.\n     *         If <code>null<\/code> the request should be terminated as it can\n     *         be assumed, that during this method enough response information\n     *         has been sent to the client.\n     */\n    public Session authenticate(HttpServletRequest req, HttpServletResponse res) {\n\n        // 0. Get package for request and be anonymous if none configured\n        AuthenticationHandler handler = this.getAuthHandler(req);\n        if (handler == null) {\n            log.debug(\"authenticate: no authentication needed, anonymous access\");\n            return this.getAnonymousSession(req, res);\n        }\n\n        // 1. Check request login session - only if we have sessions\n        // not any more :-)\n\n        // 2. Ask the packages handler for the credentials\n        Credentials creds = handler.authenticate(req, res);\n\n        // 3. Check Credentials\n        if (creds == AuthenticationHandler.DOING_AUTH) {\n\n            log.debug(\"authenticate: ongoing authentication in the handler\");\n            // is this the correct return value ??\n            return null;\n\n        } else if (creds == null) {\n\n            log.debug(\"authenticate: no credentials in the request, anonymous\");\n            return this.getAnonymousSession(req, res);\n\n        } else {\n            // try to connect\n            try {\n                log.debug(\"authenticate: credentials, trying to get a ticket\");\n                Session session = getRepository().login(creds, null);\n\n                // handle impersonation\n                session = this.handleImpersonation(req, res, session);\n\n                return session;\n\n            } catch (TooManySessionsException se) {\n                log.info(\"Too many sessions for user: {}\", se.getMessage());\n            } catch (LoginException e) {\n                log.info(\"Unable to authenticate: {}\", e.getMessage());\n            } catch (RepositoryException re) {\n                log.error(\"Unable to authenticate\", re);\n            }\n\n            // request authentication information and send 403 (Forbidden)\n            // if the handler cannot request authentication information.\n            if (!handler.requestAuthentication(req, res)) {\n                this.sendFailure(res);\n            }\n\n            // end request\n            return null;\n        }\n    }","id":28747,"modified_method":"/**\n     * Checks the authentication contained in the request. This check is only\n     * based on the original request object, no URI translation has taken place\n     * yet.\n     * <p>\n     * The method will either return the anonymous ticket, if no authentication\n     * handler could extract credentials from the request, or null, if\n     * credentials extracted from the request are not valid to create a ticket\n     * or a ticket identifying the user's credentials extracted from the ticket.\n     * This method must not call back to client for valid credentials, if they\n     * are missing.\n     * <p>\n     * If sessions are enabled the returned ticket may be impersonated, that is\n     * for another user than the one who has authenticated.\n     *\n     * @param req The request object containing the information for the\n     *            authentication.\n     * @param res The response object which may be used to send the information\n     *            on the request failure to the user.\n     * @return A valid ContentBus Ticket identifying the request user or the\n     *         anonymous ticket, if the request does not contain credential data\n     *         or null if the credential data cannot be used to create a ticket.\n     *         If <code>null<\/code> the request should be terminated as it can\n     *         be assumed, that during this method enough response information\n     *         has been sent to the client.\n     */\n    public boolean authenticate(HttpServletRequest req, HttpServletResponse res) {\n\n        // 0. Nothing to do, if the session is also in the request\n        // this might be the case if the request is handled as a result\n        // of a servlet container include inside another Sling request\n        Object sessionAttr = req.getAttribute(SlingHttpContext.SESSION);\n        if (sessionAttr instanceof Session) {\n            log.debug(\"authenticate: Request already authenticated, nothing to do\");\n            return true;\n        } else if (sessionAttr != null) {\n            // warn and remove existing non-session\n            log.warn(\n                \"authenticate: Overwriting existing Session attribute ({})\",\n                sessionAttr);\n            req.removeAttribute(SlingHttpContext.SESSION);\n        }\n\n        // 1. Ask all authentication handlers to try to extract credentials\n        AuthenticationInfo authInfo = getAuthenticationInfo(req, res);\n\n        // 3. Check Credentials\n        if (authInfo == AuthenticationInfo.DOING_AUTH) {\n\n            log.debug(\"authenticate: ongoing authentication in the handler\");\n            return false;\n\n        } else if (authInfo == null) {\n\n            log.debug(\"authenticate: no credentials in the request, anonymous\");\n            return getAnonymousSession(req, res);\n\n        } else {\n            // try to connect\n            try {\n                log.debug(\"authenticate: credentials, trying to get a ticket\");\n                Session session = getRepository().login(\n                    authInfo.getCredentials(), null);\n\n                // handle impersonation\n                session = handleImpersonation(req, res, session);\n                setAttributes(session, authInfo.getAuthType(), req);\n\n                return true;\n\n            } catch (TooManySessionsException se) {\n                log.info(\"Too many sessions for user: {}\", se.getMessage());\n            } catch (LoginException e) {\n                log.info(\"Unable to authenticate: {}\", e.getMessage());\n            } catch (RepositoryException re) {\n                log.error(\"Unable to authenticate\", re);\n            }\n\n            // request authentication information and send 403 (Forbidden)\n            // if no handler can request authentication information.\n            requestAuthentication(req, res);\n\n            // end request\n            return false;\n        }\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public String getMimeType(String name) {\n        return this.mimeTypeService.getMimeType(name);\n    }","id":28748,"modified_method":"/** Asks the MimeTypeService for the MIME type mapping */\n    public String getMimeType(String name) {\n        return this.mimeTypeService.getMimeType(name);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public boolean handleSecurity(HttpServletRequest request,\n            HttpServletResponse response) {\n\n        /*\n         * Currently we do not handle security in the context but in the\n         * SlingServlet as an SlingAuthenticator. It might be worth it\n         * considering to move the authentication from the SlingAuthenticator\n         * to this context.\n         */\n\n        return true;\n    }","id":28749,"modified_method":"/** Asks the SlingAuthenticator to authenticate the request */\n    public boolean handleSecurity(HttpServletRequest request,\n            HttpServletResponse response) {\n        return slingAuthenticator.authenticate(request, response);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public URL getResource(String name) {\n        // This context cannot provide any resources, so we just return nothing\n        return null;\n    }","id":28750,"modified_method":"/** Always returns <code>null<\/code>, we have no resources here */\n    public URL getResource(String name) {\n        return null;\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"SlingHttpContext(MimeTypeService mimeTypeService) {\n        this.mimeTypeService = mimeTypeService;\n    }","id":28751,"modified_method":"/**\n     * Creates an instance of this OSGi HttpContext implementation using the\n     * give MIME type and authentication helpers.\n     */\n    SlingHttpContext(MimeTypeService mimeTypeService,\n            SlingAuthenticator slingAuthenticator) {\n        this.mimeTypeService = mimeTypeService;\n        this.slingAuthenticator = slingAuthenticator;\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"protected void activate(ComponentContext componentContext) {\n\n        // setup server info\n        BundleContext bundleContext = componentContext.getBundleContext();\n        Dictionary<?, ?> props = bundleContext.getBundle().getHeaders();\n        Version bundleVersion = Version.parseVersion((String) props.get(Constants.BUNDLE_VERSION));\n        String productVersion = bundleVersion.getMajor() + \".\"\n            + bundleVersion.getMinor();\n        this.serverInfo = PRODUCT_NAME + \"/\" + productVersion + \" (\"\n            + System.getProperty(\"java.vm.name\") + \" \"\n            + System.getProperty(\"java.version\") + \"; \"\n            + System.getProperty(\"os.name\") + \" \"\n            + System.getProperty(\"os.version\") + \" \"\n            + System.getProperty(\"os.arch\") + \")\";\n\n        // prepare the servlet configuration from the component config\n        Hashtable<String, Object> configuration = new Hashtable<String, Object>();\n        Dictionary<?, ?> componentConfig = componentContext.getProperties();\n        for (Enumeration<?> cce = componentConfig.keys(); cce.hasMoreElements();) {\n            Object key = cce.nextElement();\n            configuration.put(String.valueOf(key), componentConfig.get(key));\n        }\n\n        // get the web manager root path\n        Object wmr = configuration.get(\"sling.root\");\n        this.slingRoot = (wmr instanceof String) ? (String) wmr : null;\n        if (this.slingRoot == null) {\n            this.slingRoot = \"/\";\n        } else if (!this.slingRoot.startsWith(\"/\")) {\n            this.slingRoot = \"/\" + this.slingRoot;\n        }\n\n        // ensure the servlet name\n        if (!(configuration.get(\"servlet-name\") instanceof String)) {\n            configuration.put(\"servlet-name\", PRODUCT_NAME + \" \"\n                + productVersion);\n        }\n\n        // setup servlet request processing helpers\n        this.slingServiceLocator = new ServiceLocatorImpl(bundleContext);\n        this.slingAuthenticator = new SlingAuthenticator(bundleContext);\n        this.servletResolver = new SlingServletResolver(bundleContext, slingServletContext);\n        this.errorHandler = new ErrorHandler(bundleContext, slingServletContext);\n\n        // register the servlet and resources\n        try {\n            this.slingHttpContext = new SlingHttpContext(this.mimeTypeService);\n            this.httpService.registerServlet(this.slingRoot, this,\n                configuration, this.slingHttpContext);\n\n            log.info(\"{} ready to serve requests\", this.getServerInfo());\n\n        } catch (Exception e) {\n            log.error(\"Cannot register \" + this.getServerInfo(), e);\n        }\n\n        // prepare the Sling Component Context now after having finished the\n        // handler setup but before initializing the filters\n        this.slingServletContext = new SlingServletContext(this);\n\n        // register render filters already registered after registration with\n        // the HttpService as filter initialization may cause the servlet\n        // context to be required (see SLING-42)\n\n        List<ServiceReference> filterList;\n        synchronized (this) {\n            filterList = delayedComponentFilters;\n\n            // assign the OSGi Component Context now, after leaving this\n            // synched block, bindFilter will be \"active\" and set the\n            // delayedComponentFilters field to null for GC\n            osgiComponentContext = componentContext;\n            delayedComponentFilters = null;\n        }\n\n        // if there are filters at all, initialize them now\n        if (filterList != null) {\n            for (ServiceReference serviceReference : filterList) {\n                initFilter(componentContext, serviceReference);\n            }\n        }\n    }","id":28752,"modified_method":"protected void activate(ComponentContext componentContext) {\n\n        // setup server info\n        BundleContext bundleContext = componentContext.getBundleContext();\n        Dictionary<?, ?> props = bundleContext.getBundle().getHeaders();\n        Version bundleVersion = Version.parseVersion((String) props.get(Constants.BUNDLE_VERSION));\n        String productVersion = bundleVersion.getMajor() + \".\"\n            + bundleVersion.getMinor();\n        this.serverInfo = PRODUCT_NAME + \"/\" + productVersion + \" (\"\n            + System.getProperty(\"java.vm.name\") + \" \"\n            + System.getProperty(\"java.version\") + \"; \"\n            + System.getProperty(\"os.name\") + \" \"\n            + System.getProperty(\"os.version\") + \" \"\n            + System.getProperty(\"os.arch\") + \")\";\n\n        // prepare the servlet configuration from the component config\n        Hashtable<String, Object> configuration = new Hashtable<String, Object>();\n        Dictionary<?, ?> componentConfig = componentContext.getProperties();\n        for (Enumeration<?> cce = componentConfig.keys(); cce.hasMoreElements();) {\n            Object key = cce.nextElement();\n            configuration.put(String.valueOf(key), componentConfig.get(key));\n        }\n\n        // get the web manager root path\n        Object wmr = configuration.get(\"sling.root\");\n        this.slingRoot = (wmr instanceof String) ? (String) wmr : null;\n        if (this.slingRoot == null) {\n            this.slingRoot = \"/\";\n        } else if (!this.slingRoot.startsWith(\"/\")) {\n            this.slingRoot = \"/\" + this.slingRoot;\n        }\n\n        // ensure the servlet name\n        if (!(configuration.get(\"servlet-name\") instanceof String)) {\n            configuration.put(\"servlet-name\", PRODUCT_NAME + \" \"\n                + productVersion);\n        }\n\n        // setup servlet request processing helpers\n        this.slingServiceLocator = new ServiceLocatorImpl(bundleContext);\n        this.slingAuthenticator = new SlingAuthenticator(bundleContext);\n        this.servletResolver = new SlingServletResolver(bundleContext,\n            slingServletContext);\n        this.errorHandler = new ErrorHandler(bundleContext, slingServletContext);\n\n        // register the servlet and resources\n        try {\n            HttpContext httpContext = new HttpContext() {\n                public String getMimeType(String name) {\n                    return mimeTypeService.getMimeType(name);\n                }\n\n                public URL getResource(String name) {\n                    return null;\n                }\n\n                public boolean handleSecurity(HttpServletRequest request,\n                        HttpServletResponse response) {\n                    return slingAuthenticator.authenticate(request, response);\n                }\n            };\n            this.httpService.registerServlet(this.slingRoot, this,\n                configuration, httpContext);\n\n            log.info(\"{} ready to serve requests\", this.getServerInfo());\n\n        } catch (Exception e) {\n            log.error(\"Cannot register \" + this.getServerInfo(), e);\n        }\n\n        // prepare the Sling Component Context now after having finished the\n        // handler setup but before initializing the filters\n        this.slingServletContext = new SlingServletContext(this);\n\n        // register render filters already registered after registration with\n        // the HttpService as filter initialization may cause the servlet\n        // context to be required (see SLING-42)\n\n        List<ServiceReference> filterList;\n        synchronized (this) {\n            filterList = delayedComponentFilters;\n\n            // assign the OSGi Component Context now, after leaving this\n            // synched block, bindFilter will be \"active\" and set the\n            // delayedComponentFilters field to null for GC\n            osgiComponentContext = componentContext;\n            delayedComponentFilters = null;\n        }\n\n        // if there are filters at all, initialize them now\n        if (filterList != null) {\n            for (ServiceReference serviceReference : filterList) {\n                initFilter(componentContext, serviceReference);\n            }\n        }\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"private void initFilter(ComponentContext osgiContext, ServiceReference ref) {\n        Filter filter = (Filter) osgiContext.locateService(\n            COMPONENT_FILTER_NAME, ref);\n\n        // require a name for the filter\n        String filterName = AbstractServiceReferenceConfig.getName(ref);\n        if (filterName == null) {\n            log.error(\"initFilter: Missing name for filter {}\", ref);\n            return;\n        }\n\n        // initialize the filter first\n        try {\n            FilterConfig config = new SlingFilterConfig(slingServletContext,\n                ref, filterName);\n            filter.init(config);\n\n            // service id\n            Long serviceId = (Long) ref.getProperty(Constants.SERVICE_ID);\n\n            // get the order, Integer.MAX_VALUE by default\n            Object orderObj = ref.getProperty(\"filter.order\");\n            int order = (orderObj instanceof Integer)\n                    ? ((Integer) orderObj).intValue()\n                    : Integer.MAX_VALUE;\n\n            // register by scope\n            getChain(ref).addFilter(filter, serviceId, order);\n\n        } catch (ComponentException ce) {\n            log.error(\"ComponentFilter \" + \"\" + \" failed to initialize\", ce);\n        } catch (Throwable t) {\n            log.error(\"Unexpected Problem initializing ComponentFilter \" + \"\",\n                t);\n        }\n    }","id":28753,"modified_method":"private void initFilter(ComponentContext osgiContext, ServiceReference ref) {\n        Filter filter = (Filter) osgiContext.locateService(FILTER_NAME, ref);\n\n        // require a name for the filter\n        String filterName = AbstractServiceReferenceConfig.getName(ref);\n        if (filterName == null) {\n            log.error(\"initFilter: Missing name for filter {}\", ref);\n            return;\n        }\n\n        // initialize the filter first\n        try {\n            FilterConfig config = new SlingFilterConfig(slingServletContext,\n                ref, filterName);\n            filter.init(config);\n\n            // service id\n            Long serviceId = (Long) ref.getProperty(Constants.SERVICE_ID);\n\n            // get the order, Integer.MAX_VALUE by default\n            Object orderObj = ref.getProperty(\"filter.order\");\n            int order = (orderObj instanceof Integer)\n                    ? ((Integer) orderObj).intValue()\n                    : Integer.MAX_VALUE;\n\n            // register by scope\n            getChain(ref).addFilter(filter, serviceId, order);\n\n        } catch (ComponentException ce) {\n            log.error(\"ComponentFilter \" + \"\" + \" failed to initialize\", ce);\n        } catch (Throwable t) {\n            log.error(\"Unexpected Problem initializing ComponentFilter \" + \"\",\n                t);\n        }\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public void service(HttpServletRequest clientRequest,\n            HttpServletResponse clientResponse) throws IOException {\n\n        Session session = getSlingAuthenticator().authenticate(clientRequest,\n            clientResponse);\n        if (session != null) {\n            RequestData requestData = null;\n            try {\n\n                // prepare internal request stuff\n                requestData = new RequestData(this, session, clientRequest,\n                    clientResponse);\n                SlingHttpServletRequest request = requestData.getSlingRequest();\n                SlingHttpServletResponse response = requestData.getSlingResponse();\n\n                Filter[] filters = requestFilterChain.getFilters();\n                if (filters != null) {\n                    FilterChain processor = new RequestSlingFilterChain(this,\n                        filters);\n\n                    processor.doFilter(request, response);\n\n                } else {\n                    log.error(\"service: No Request Handling filters, cannot process request\");\n                    response.sendError(\n                        HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n                        \"Cannot process Request\");\n                }\n\n            } catch (AccessControlException ace) {\n\n                // try to request authentication fail, if not possible\n                if (!getSlingAuthenticator().requestAuthentication(\n                    clientRequest, clientResponse)) {\n                    getErrorHandler().handleError(\n                        HttpServletResponse.SC_FORBIDDEN, \"Access Denied\",\n                        clientRequest, clientResponse);\n                }\n\n            } catch (HttpStatusCodeException hsce) {\n                // convert the status code exception to sendError\n                getErrorHandler().handleError(hsce.getStatusCode(),\n                    hsce.getMessage(), clientRequest, clientResponse);\n\n            } catch (Throwable t) {\n                getErrorHandler().handleError(t, clientRequest, clientResponse);\n\n            } finally {\n                if (requestData != null) {\n                    requestData.dispose();\n                }\n\n                session.logout();\n            }\n        }\n\n    }","id":28754,"modified_method":"public void service(HttpServletRequest clientRequest,\n            HttpServletResponse clientResponse) throws IOException {\n\n        Session session = (Session) clientRequest.getAttribute(SlingHttpContext.SESSION);\n        if (session != null) {\n            RequestData requestData = null;\n            try {\n\n                // prepare internal request stuff\n                requestData = new RequestData(this, session, clientRequest,\n                    clientResponse);\n                SlingHttpServletRequest request = requestData.getSlingRequest();\n                SlingHttpServletResponse response = requestData.getSlingResponse();\n\n                Filter[] filters = requestFilterChain.getFilters();\n                if (filters != null) {\n                    FilterChain processor = new RequestSlingFilterChain(this,\n                        filters);\n\n                    processor.doFilter(request, response);\n\n                } else {\n                    log.error(\"service: No Request Handling filters, cannot process request\");\n                    response.sendError(\n                        HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n                        \"Cannot process Request\");\n                }\n\n            } catch (AccessControlException ace) {\n\n                // try to request authentication fail, if not possible\n                getSlingAuthenticator().requestAuthentication(clientRequest,\n                    clientResponse);\n\n            } catch (HttpStatusCodeException hsce) {\n                // convert the status code exception to sendError\n                getErrorHandler().handleError(hsce.getStatusCode(),\n                    hsce.getMessage(), clientRequest, clientResponse);\n\n            } catch (Throwable t) {\n                getErrorHandler().handleError(t, clientRequest, clientResponse);\n\n            } finally {\n                if (requestData != null) {\n                    requestData.dispose();\n                }\n\n                session.logout();\n            }\n        }\n\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"protected void deactivate(ComponentContext componentContext) {\n\n        destroyFilters(innerFilterChain);\n        destroyFilters(requestFilterChain);\n\n        if (errorHandler != null) {\n            errorHandler.dispose();\n            errorHandler = null;\n        }\n        if (servletResolver != null) {\n            servletResolver.dispose();\n            servletResolver = null;\n        }\n        if (slingAuthenticator != null) {\n            slingAuthenticator.dispose();\n            slingAuthenticator = null;\n        }\n        if (slingServiceLocator != null) {\n            slingServiceLocator.dispose();\n            slingServiceLocator = null;\n        }\n\n        this.httpService.unregister(this.slingRoot);\n\n        if (this.slingHttpContext != null) {\n            this.slingHttpContext.dispose();\n        }\n\n        this.slingServletContext = null;\n        this.osgiComponentContext = null;\n\n        log.info(this.getServerInfo() + \" shut down\");\n    }","id":28755,"modified_method":"protected void deactivate(ComponentContext componentContext) {\n\n        // first of all, we have to unregister\n        httpService.unregister(this.slingRoot);\n\n        destroyFilters(innerFilterChain);\n        destroyFilters(requestFilterChain);\n\n        if (errorHandler != null) {\n            errorHandler.dispose();\n            errorHandler = null;\n        }\n        if (servletResolver != null) {\n            servletResolver.dispose();\n            servletResolver = null;\n        }\n        if (slingAuthenticator != null) {\n            slingAuthenticator.dispose();\n            slingAuthenticator = null;\n        }\n        if (slingServiceLocator != null) {\n            slingServiceLocator.dispose();\n            slingServiceLocator = null;\n        }\n\n        this.slingServletContext = null;\n        this.osgiComponentContext = null;\n\n        log.info(this.getServerInfo() + \" shut down\");\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"protected void bindComponentFilter(ServiceReference ref) {\n        synchronized (this) {\n            if (osgiComponentContext == null) {\n                if (delayedComponentFilters == null) {\n                    delayedComponentFilters = new ArrayList<ServiceReference>();\n                }\n                delayedComponentFilters.add(ref);\n            } else {\n                initFilter(osgiComponentContext, ref);\n            }\n        }\n    }","id":28756,"modified_method":"protected void bindFilter(ServiceReference ref) {\n        synchronized (this) {\n            if (osgiComponentContext == null) {\n                if (delayedComponentFilters == null) {\n                    delayedComponentFilters = new ArrayList<ServiceReference>();\n                }\n                delayedComponentFilters.add(ref);\n            } else {\n                initFilter(osgiComponentContext, ref);\n            }\n        }\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"protected void unbindComponentFilter(ServiceReference ref) {\n        // service id\n        Object serviceId = ref.getProperty(Constants.SERVICE_ID);\n\n        // unregister by scope and destroy it\n        Filter filter = getChain(ref).removeFilterById(serviceId);\n        if (filter != null) {\n            try {\n                filter.destroy();\n            } catch (Throwable t) {\n                log.error(\"Unexpected problem destroying ComponentFilter {}\",\n                    filter, t);\n            }\n        }\n    }","id":28757,"modified_method":"protected void unbindFilter(ServiceReference ref) {\n        // service id\n        Object serviceId = ref.getProperty(Constants.SERVICE_ID);\n\n        // unregister by scope and destroy it\n        Filter filter = getChain(ref).removeFilterById(serviceId);\n        if (filter != null) {\n            try {\n                filter.destroy();\n            } catch (Throwable t) {\n                log.error(\"Unexpected problem destroying ComponentFilter {}\",\n                    filter, t);\n            }\n        }\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public void log(String msg) {\n        log.info(msg);\n    }","id":28758,"modified_method":"/** Logs the message at info level to the logger */\n    public void log(String message) {\n        log.info(message);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public void log(Exception exception, String msg) {\n        log(msg, exception);\n    }","id":28759,"modified_method":"/** Logs the message and optional exception at error level to the logger */\n    @Deprecated\n    public void log(Exception exception, String message) {\n        log(message, exception);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletContext#setAttribute(java.lang.String,\n     *      java.lang.Object)\n     */\n    public void setAttribute(String name, Object object) {\n        getServletContext().removeAttribute(name);\n    }","id":28760,"modified_method":"/**\n     * Sets the name servlet context attribute to the requested value. This\n     * method calls on the <code>ServletContext<\/code> in which the\n     * {@link SlingMainServlet} is running.\n     */\n    public void setAttribute(String name, Object object) {\n        getServletContext().removeAttribute(name);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public InputStream getResourceAsStream(String path) {\n        // TODO Auto-generated method stub\n        return null;\n    }","id":28761,"modified_method":"/**\n     * Returns an input stream to the given path. This method calls on the\n     * <code>ServletContext<\/code> in which the {@link SlingMainServlet} is\n     * running.\n     */\n    public InputStream getResourceAsStream(String path) {\n        return getServletContext().getResourceAsStream(path);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public URL getResource(String path) throws MalformedURLException {\n        // TODO Auto-generated method stub\n        return null;\n    }","id":28762,"modified_method":"/**\n     * Returns the URI for the given path. This method calls on the\n     * <code>ServletContext<\/code> in which the {@link SlingMainServlet} is\n     * running.\n     */\n    public URL getResource(String path) throws MalformedURLException {\n        return getServletContext().getResource(path);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"@Deprecated\n    public Servlet getServlet(String name) {\n        return null;\n    }","id":28763,"modified_method":"/** Returns <code>null<\/code> as defined in Servlet API 2.4 */\n    @Deprecated\n    public Servlet getServlet(String name) {\n        return null;\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletContext#getAttribute(java.lang.String)\n     */\n    public Object getAttribute(String name) {\n        return getServletContext().getAttribute(name);\n    }","id":28764,"modified_method":"/**\n     * Returns the named servlet context attribute. This method calls on the\n     * <code>ServletContext<\/code> in which the {@link SlingMainServlet} is\n     * running.\n     */\n    public Object getAttribute(String name) {\n        return getServletContext().getAttribute(name);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletContext#removeAttribute(java.lang.String)\n     */\n    public void removeAttribute(String name) {\n        getServletContext().removeAttribute(name);\n    }","id":28765,"modified_method":"/**\n     * Removes the named servlet context attribute. This method calls on the\n     * <code>ServletContext<\/code> in which the {@link SlingMainServlet} is\n     * running.\n     */\n    public void removeAttribute(String name) {\n        getServletContext().removeAttribute(name);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public SlingServletContext(SlingMainServlet requestHandler) {\n        this.requestHandler = requestHandler;\n    }","id":28766,"modified_method":"/**\n     * Creates an instance of this class delegating some methods to the given\n     * {@link SlingMainServlet}. In addition the new instance is registered as\n     * a <code>ManagedService<\/code> and <code>ServletContext<\/code> to\n     * receive configuration information.\n     */\n    public SlingServletContext(SlingMainServlet requestHandler) {\n        this.requestHandler = requestHandler;\n\n        Dictionary<String, Object> props = new Hashtable<String, Object>();\n        props.put(Constants.SERVICE_PID, getClass().getName());\n        props.put(Constants.SERVICE_DESCRIPTION, \"Sling ServletContext\");\n        props.put(Constants.SERVICE_VENDOR, \"The Apache Software Foundation\");\n        registration = requestHandler.getBundleContext().registerService(\n            ServletContext.class.getName(), this, props);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"@Deprecated\n    public Enumeration<?> getServletNames() {\n        return null;\n    }","id":28767,"modified_method":"/** Returns <code>null<\/code> as defined in Servlet API 2.4 */\n    @Deprecated\n    public Enumeration<?> getServletNames() {\n        return Collections.enumeration(Collections.emptyList());\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletContext#getMimeType(java.lang.String)\n     */\n    public String getMimeType(String file) {\n        return getServletContext().getMimeType(file);\n    }","id":28768,"modified_method":"/**\n     * Returns a MIME type for the extension of the given file name. This method\n     * calls on the <code>ServletContext<\/code> in which the\n     * {@link SlingMainServlet} is running.\n     */\n    public String getMimeType(String file) {\n        return getServletContext().getMimeType(file);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"private ServletContext getServletContext() {\n        return requestHandler.getServletContext();\n    }","id":28769,"modified_method":"/**\n     * Returns the real servlet context of the servlet container in which the\n     * Sling Servlet is running.\n     */\n    private ServletContext getServletContext() {\n        return requestHandler.getServletContext();\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public void log(String message, Throwable throwable) {\n        log.error(message, throwable);\n    }","id":28770,"modified_method":"/** Logs the message and optional throwable at error level to the logger */\n    public void log(String message, Throwable throwable) {\n        log.error(message, throwable);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public String getRealPath(String path) {\n        return getServletContext().getRealPath(path);\n    }","id":28771,"modified_method":"/**\n     * Returns the real file inside the web application to which the given path\n     * maps or <code>null<\/code> if no such file exists. This method calls on\n     * the <code>ServletContext<\/code> in which the {@link SlingMainServlet}\n     * is running.\n     */\n    public String getRealPath(String path) {\n        return getServletContext().getRealPath(path);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public RequestDispatcher getRequestDispatcher(String path) {\n        // return no dispatcher if content is null\n        if (path == null) {\n            log.error(\"getRequestDispatcher: No path, cannot create request dispatcher\");\n            return null;\n        }\n\n        return new SlingRequestDispatcher(path);\n    }","id":28772,"modified_method":"/**\n     * Returns a {@link SlingRequestDispatcher} for the given path if not\n     * <code>null<\/code>. Otherwise <code>null<\/code> is returned.\n     */\n    public RequestDispatcher getRequestDispatcher(String path) {\n        // return no dispatcher if content is null\n        if (path == null) {\n            log.error(\"getRequestDispatcher: No path, cannot create request dispatcher\");\n            return null;\n        }\n\n        return new SlingRequestDispatcher(path);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletContext#getInitParameterNames()\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Enumeration<String> getInitParameterNames() {\n        return getServletContext().getInitParameterNames();\n    }","id":28773,"modified_method":"/**\n     * Returns the names of the init-params of the servlet context in which\n     * Sling is configured. This method calls on the <code>ServletContext<\/code>\n     * in which the {@link SlingMainServlet} is running.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Enumeration<String> getInitParameterNames() {\n        return getServletContext().getInitParameterNames();\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletContext#getAttributeNames()\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Enumeration<String> getAttributeNames() {\n        return getServletContext().getAttributeNames();\n    }","id":28774,"modified_method":"/**\n     * Returns the names of all servlet context attributes. This method calls on\n     * the <code>ServletContext<\/code> in which the {@link SlingMainServlet}\n     * is running.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Enumeration<String> getAttributeNames() {\n        return getServletContext().getAttributeNames();\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public RequestDispatcher getNamedDispatcher(String name) {\n        return getServletContext().getNamedDispatcher(name);\n    }","id":28775,"modified_method":"/**\n     * Returns a servlet container request dispatcher for the named servlet.\n     * This method calls on the <code>ServletContext<\/code> in which the\n     * {@link SlingMainServlet} is running.\n     */\n    public RequestDispatcher getNamedDispatcher(String name) {\n        return getServletContext().getNamedDispatcher(name);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletContext#getInitParameter(java.lang.String)\n     */\n    public String getInitParameter(String name) {\n        return getServletContext().getInitParameter(name);\n    }","id":28776,"modified_method":"/**\n     * Returns the init-param of the servlet context in which Sling is\n     * configured. This method calls on the <code>ServletContext<\/code> in\n     * which the {@link SlingMainServlet} is running.\n     */\n    public String getInitParameter(String name) {\n        return getServletContext().getInitParameter(name);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"@Deprecated\n    public Enumeration<?> getServlets() {\n        return null;\n    }","id":28777,"modified_method":"/** Returns <code>null<\/code> as defined in Servlet API 2.4 */\n    @Deprecated\n    public Enumeration<?> getServlets() {\n        return Collections.enumeration(Collections.emptyList());\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public String getServerInfo() {\n        return requestHandler.getServerInfo();\n    }","id":28778,"modified_method":"/**\n     * Returns the Sling server info string. This is not the same server info\n     * string as returned by the servlet context in which Sling is configured.\n     */\n    public String getServerInfo() {\n        return requestHandler.getServerInfo();\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletContext#getMinorVersion()\n     */\n    public int getMinorVersion() {\n        return getServletContext().getMinorVersion();\n    }","id":28779,"modified_method":"/**\n     * Returns the minor version number of the Servlet API supported by the\n     * servlet container in which Sling is running. This method calls on the\n     * <code>ServletContext<\/code> in which the {@link SlingMainServlet} is\n     * running.\n     */\n    public int getMinorVersion() {\n        return getServletContext().getMinorVersion();\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletContext#getMajorVersion()\n     */\n    public int getMajorVersion() {\n        return getServletContext().getMajorVersion();\n    }","id":28780,"modified_method":"/**\n     * Returns the major version number of the Servlet API supported by the\n     * servlet container in which Sling is running. This method calls on the\n     * <code>ServletContext<\/code> in which the {@link SlingMainServlet} is\n     * running.\n     */\n    public int getMajorVersion() {\n        return getServletContext().getMajorVersion();\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public String getServletContextName() {\n        return getServletContext().getServletContextName();\n    }","id":28781,"modified_method":"/**\n     * Returns the name of the servlet context in which Sling is configured.\n     * This method calls on the <code>ServletContext<\/code> in which the\n     * {@link SlingMainServlet} is running.\n     */\n    public String getServletContextName() {\n        return getServletContext().getServletContextName();\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public Set getResourcePaths(String arg0) {\n        // TODO Auto-generated method stub\n        return null;\n    }","id":28782,"modified_method":"/**\n     * Returns a set of names for path entries considered children of the given\n     * path. This method calls on the <code>ServletContext<\/code> in which the\n     * {@link SlingMainServlet} is running.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Set<String> getResourcePaths(String parentPath) {\n        return getServletContext().getResourcePaths(parentPath);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"public ServletContext getContext(String uripath) {\n        // check whether to return ComponentContext ??\n        return getServletContext().getContext(uripath);\n    }","id":28783,"modified_method":"/**\n     * Returns the servlet context from the servlet container in which sling is\n     * running. This method calls on the <code>ServletContext<\/code> in which\n     * the {@link SlingMainServlet} is running.\n     */\n    public ServletContext getContext(String uripath) {\n        return getServletContext().getContext(uripath);\n    }","commit_id":"6622172c3e9d30567ff812727c4bf21d84a71775","url":"https://github.com/apache/sling"},{"original_method":"/**\n   * Generate the trace.\n   * Enable events, start thread to display events,\n   * start threads to forward remote error and output streams,\n   * resume the remote VM, wait for the final event, and shutdown.\n   */\n  @Override\n  protected void generateTrace(final PrintWriter writer) {\n\n    final Thread logcatter = new Thread(new Runnable() {\n      public void run() {\n        try {\n          new SketchLogCatter().start();\n          System.err.println(\"logcatter exited normally\");\n        } catch (final InterruptedException e) {\n          System.err.println(\"logcat interrupted\");\n        } catch (final Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }, \"logcatter\");\n    logcatter.start();\n\n    // At this point, disable the run button.\n    // This happens when the sketch is exited by hitting ESC,\n    // or the user manually closes the sketch window.\n    // TODO this should be handled better, should it not?\n    if (editor != null) {\n      editor.internalRunnerClosed();\n    }\n\n    if (writer != null) {\n      writer.close();\n    }\n  }","id":28784,"modified_method":"/**\n   * Generate the trace.\n   * Enable events, start thread to display events,\n   * start threads to forward remote error and output streams,\n   * resume the remote VM, wait for the final event, and shutdown.\n   */\n  @Override\n  protected void generateTrace(final PrintWriter writer) {\n\n    final Thread logcatter = new Thread(new Runnable() {\n      public void run() {\n        try {\n          new SketchLogCatter().start();\n        } catch (final InterruptedException e) {\n          System.err.println(\"logcat interrupted\");\n        } catch (final Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }, \"logcatter\");\n    logcatter.start();\n\n    // At this point, disable the run button.\n    // This happens when the sketch is exited by hitting ESC,\n    // or the user manually closes the sketch window.\n    // TODO this should be handled better, should it not?\n    if (editor != null) {\n      editor.internalRunnerClosed();\n    }\n\n    if (writer != null) {\n      writer.close();\n    }\n  }","commit_id":"80e411581e1abe50e005bd8718267b134e0fec02","url":"https://github.com/processing/processing"},{"original_method":"static protected File getCoreZipFile() {\n    // for debugging only, check to see if this is an svn checkout\n    File debugFile = new File(\"../../../android/core.zip\");\n    if (!debugFile.exists() && Base.isMacOS()) {\n      // current path might be inside Processing.app, so need to go much higher\n      debugFile = new File(\"../../../../../../../android/core.zip\");\n    }\n    if (debugFile.exists()) {\n      System.out.println(\"Using version of core.zip from local SVN checkout.\");\n      return debugFile;\n      // } else {\n      // //System.out.println(\"no core.zip at \" + debugFile.getAbsolutePath());\n      // try {\n      // System.out.println(\"no core.zip at \" + debugFile.getCanonicalPath());\n      // } catch (IOException e) {\n      // e.printStackTrace();\n      // }\n    }\n\n    // otherwise do the usual\n    return new File(Base.getSketchbookFolder(), ANDROID_CORE_FILENAME);\n  }","id":28785,"modified_method":"static protected File getCoreZipFile() {\n    // for debugging only, check to see if this is an svn checkout\n    File debugFile = new File(\"../../../android/core.zip\");\n    if (!debugFile.exists() && Base.isMacOS()) {\n      // current path might be inside Processing.app, so need to go much higher\n      debugFile = new File(\"../../../../../../../android/core.zip\");\n    }\n    if (debugFile.exists()) {\n      System.err.println(\"Using version of core.zip from local SVN checkout.\");\n      return debugFile;\n      // } else {\n      // //System.out.println(\"no core.zip at \" + debugFile.getAbsolutePath());\n      // try {\n      // System.out.println(\"no core.zip at \" + debugFile.getCanonicalPath());\n      // } catch (IOException e) {\n      // e.printStackTrace();\n      // }\n    }\n\n    // otherwise do the usual\n    return new File(Base.getSketchbookFolder(), ANDROID_CORE_FILENAME);\n  }","commit_id":"80e411581e1abe50e005bd8718267b134e0fec02","url":"https://github.com/processing/processing"},{"original_method":"String startSketch(final String device) {\n    try {\n      //      final String lastPort = getJdwpPort(device);\n\n      // \"am start -a android.intent.action.MAIN -n com.android.browser/.BrowserActivity\"\n      final ProcessResult result = new ProcessHelper(\n                                                     \"adb\",\n                                                     \"-s\",\n                                                     device,\n                                                     // \"-d\", // this is for a single USB device\n                                                     \"shell\",\n                                                     \"am\",\n                                                     \"start\", // kick things off\n                                                     // -D causes a hang with\n                                                     // \"waiting for the debugger to attach\"\n                                                     // \"-D\", // debug\n                                                     \"-e\",\n                                                     \"debug\",\n                                                     \"true\",\n                                                     \"-a\",\n                                                     \"android.intent.action.MAIN\",\n                                                     \"-c\",\n                                                     \"android.intent.category.LAUNCHER\",\n                                                     \"-n\", build\n                                                         .getPackageName()\n                                                         + \"/.\"\n                                                         + build.getClassName())\n          .execute();\n      if (result.succeeded()) {\n        final boolean emu = device.startsWith(\"emulator\");\n        editor.statusNotice(\"Sketch started on the \"\n            + (emu ? \"emulator\" : \"phone\") + \".\");\n        return \"\";//lastPort;\n      }\n      editor.statusError(\"Could not start the sketch.\");\n      System.err.println(result);\n    } catch (final IOException e) {\n      editor.statusError(e);\n    } catch (final InterruptedException e) {\n      e.printStackTrace();\n    }\n    return null;\n  }","id":28786,"modified_method":"private void startSketch(final String device) {\n    final String id = build.getPackageName() + \"/.\" + build.getClassName();\n    final ProcessHelper startSketch = new ProcessHelper(\n                                                        \"adb\",\n                                                        \"-s\",\n                                                        device,\n                                                        \"shell\",\n                                                        \"am\",\n                                                        \"start\", // kick things off\n                                                        \"-e\",\n                                                        \"debug\",\n                                                        \"true\",\n                                                        \"-a\",\n                                                        \"android.intent.action.MAIN\",\n                                                        \"-c\",\n                                                        \"android.intent.category.LAUNCHER\",\n                                                        \"-n\", id);\n    try {\n      // \"am start -a android.intent.action.MAIN -n com.android.browser/.BrowserActivity\"\n      final ProcessResult result = startSketch.execute();\n      if (result.succeeded()) {\n        final boolean emu = device.startsWith(\"emulator\");\n        editor.statusNotice(\"Sketch started on the \"\n            + (emu ? \"emulator\" : \"phone\") + \".\");\n        new AndroidRunner(editor, editor.getSketch()).launch(ADB_SOCKET_PORT);\n      } else {\n        editor.statusError(\"Could not start the sketch.\");\n        System.err.println(result);\n      }\n    } catch (final IOException e) {\n      editor.statusError(e);\n    } catch (final InterruptedException e) {\n    }\n  }","commit_id":"80e411581e1abe50e005bd8718267b134e0fec02","url":"https://github.com/processing/processing"},{"original_method":"public void run() {\n      checkServer();\n      final String device = findDevice();\n      if (device == null) {\n        editor.statusError(\"No device found.\");\n      } else {\n        // installAndRun(\"debug\", device);\n        boolean success;\n\n        final Build build = getBuilder();\n        success = build.createProject();\n        if (!success) {\n          return;\n        }\n\n        // now run the ant debug or release version\n        success = build.antBuild(\"debug\");\n        // System.out.println(\"ant build complete \" + success);\n        if (!success) {\n          return;\n        }\n\n        success = waitUntilReady(device);\n        if (!success) {\n          return;\n        }\n\n        success = installSketch(device);\n        if (!success) {\n          return;\n        }\n\n        // Returns the last JDWP port that in use before launching\n        final String prevPort = startSketch(device);\n        if (prevPort == null) {\n          return;\n        }\n\n        //success = debugSketch(device, prevPort);\n      }\n    }","id":28787,"modified_method":"public void run() {\n      checkServer();\n      final String device = findDevice();\n      if (device == null) {\n        editor.statusError(\"No device found.\");\n      } else {\n        // installAndRun(\"debug\", device);\n        boolean success;\n\n        final Build build = getBuilder();\n        success = build.createProject();\n        if (!success) {\n          return;\n        }\n\n        // now run the ant debug or release version\n        success = build.antBuild(\"debug\");\n        // System.out.println(\"ant build complete \" + success);\n        if (!success) {\n          return;\n        }\n\n        success = waitUntilReady(device);\n        if (!success) {\n          return;\n        }\n\n        success = installSketch(device);\n        if (!success) {\n          return;\n        }\n\n        startSketch(device);\n      }\n    }","commit_id":"80e411581e1abe50e005bd8718267b134e0fec02","url":"https://github.com/processing/processing"},{"original_method":"public void installAndRun(final String target, final String device) {\n    boolean success;\n\n    // //adb get-state\n    // try {\n    // System.out.print(\"(installAndRun) adb get state: \");\n    // ProcessHelper p = new ProcessHelper(new String[] { \"adb\", \"get-state\" });\n    // p.waitFor();\n    // p.printLines();\n    // } catch (Exception e) {\n    // e.printStackTrace();\n    // }\n\n    // Simply reset the debug bridge, since it seems so prone to getting\n    // into bad states and not producing error messages.\n    // resetServer();\n\n    final Build build = getBuilder();\n    success = build.createProject();\n    if (!success) {\n      return;\n    }\n\n    /*\n     * <!-- Compile this project's .java files into .class files. --> <target\n     * name=\"compile\" depends=\"resource-src, aidl\"> <javac encoding=\"ascii\"\n     * target=\"1.5\" debug=\"true\" extdirs=\"\" destdir=\"${out-classes}\"\n     * bootclasspathref=\"android.target.classpath\"> <src path=\"${source-folder}\"\n     * /> <src path=\"${gen-folder}\" /> <classpath> <fileset\n     * dir=\"${external-libs-folder}\" includes=\"*.jar\"/> <pathelement\n     * path=\"${main-out-classes}\"/> <\/classpath> <\/javac> <\/target>\n     */\n    // first build the code (.java -> .class) separately\n    // success = build.antBuild(\"compile\");\n    // PApplet.println(\"umm compile\");\n    // success = build.execAntCompile();\n    // PApplet.println(\"umm yeah compile\");\n    // now run the ant debug or release version\n    success = build.antBuild(\"debug\");\n    // System.out.println(\"ant build complete \" + success);\n    if (!success) {\n      return;\n    }\n\n    success = waitUntilReady(device);\n    if (!success) {\n      return;\n    }\n\n    success = installSketch(device);\n    if (!success) {\n      return;\n    }\n\n    // Returns the last JDWP port that in use before launching\n    final String prevPort = startSketch(device);\n    if (prevPort == null) {\n      return;\n    }\n    new AndroidRunner(editor, editor.getSketch()).launch(ADB_SOCKET_PORT);\n    //success = debugSketch(device, prevPort);\n  }","id":28788,"modified_method":"public void installAndRun(final String target, final String device) {\n\n    // //adb get-state\n    // try {\n    // System.out.print(\"(installAndRun) adb get state: \");\n    // ProcessHelper p = new ProcessHelper(new String[] { \"adb\", \"get-state\" });\n    // p.waitFor();\n    // p.printLines();\n    // } catch (Exception e) {\n    // e.printStackTrace();\n    // }\n\n    // Simply reset the debug bridge, since it seems so prone to getting\n    // into bad states and not producing error messages.\n    // resetServer();\n\n    final Build build = getBuilder();\n    if (!build.createProject()) {\n      return;\n    }\n\n    /*\n     * <!-- Compile this project's .java files into .class files. --> <target\n     * name=\"compile\" depends=\"resource-src, aidl\"> <javac encoding=\"ascii\"\n     * target=\"1.5\" debug=\"true\" extdirs=\"\" destdir=\"${out-classes}\"\n     * bootclasspathref=\"android.target.classpath\"> <src path=\"${source-folder}\"\n     * /> <src path=\"${gen-folder}\" /> <classpath> <fileset\n     * dir=\"${external-libs-folder}\" includes=\"*.jar\"/> <pathelement\n     * path=\"${main-out-classes}\"/> <\/classpath> <\/javac> <\/target>\n     */\n    // first build the code (.java -> .class) separately\n    // success = build.antBuild(\"compile\");\n    // PApplet.println(\"umm compile\");\n    // success = build.execAntCompile();\n    // PApplet.println(\"umm yeah compile\");\n    // now run the ant debug or release version\n    // System.out.println(\"ant build complete \" + success);\n    if (!build.antBuild(\"debug\")) {\n      return;\n    }\n\n    if (!waitUntilReady(device)) {\n      return;\n    }\n\n    if (!installSketch(device)) {\n      return;\n    }\n\n    startSketch(device);\n  }","commit_id":"80e411581e1abe50e005bd8718267b134e0fec02","url":"https://github.com/processing/processing"},{"original_method":"public void run() {\n      // installAndRun(\"debug\", findEmulator());\n      checkServer();\n      final String device = findEmulator();\n      boolean success;\n\n      final Build build = getBuilder();\n      success = build.createProject();\n      if (!success) {\n        return;\n      }\n\n      // now run the ant debug or release version\n      success = build.antBuild(\"debug\");\n      // System.out.println(\"ant build complete \" + success);\n      if (!success) {\n        return;\n      }\n\n      success = waitUntilReady(device);\n      if (!success) {\n        return;\n      }\n\n      success = installSketch(device);\n      if (!success) {\n        return;\n      }\n\n      // Returns the last JDWP port that in use before launching\n      final String prevPort = startSketch(device);\n      if (prevPort == null) {\n        return;\n      }\n      new AndroidRunner(editor, editor.getSketch()).launch(ADB_SOCKET_PORT);\n      //success = debugSketch(device, prevPort);\n    }","id":28789,"modified_method":"public void run() {\n      // installAndRun(\"debug\", findEmulator());\n      checkServer();\n      final String device = findEmulator();\n\n      final Build build = getBuilder();\n      if (!build.createProject()) {\n        return;\n      }\n\n      if (!build.antBuild(\"debug\")) {\n        return;\n      }\n\n      if (!waitUntilReady(device)) {\n        return;\n      }\n\n      if (!installSketch(device)) {\n        return;\n      }\n\n      startSketch(device);\n    }","commit_id":"80e411581e1abe50e005bd8718267b134e0fec02","url":"https://github.com/processing/processing"},{"original_method":"public String getDefaultDevice() {\n    // return Device.avdDonut.name;\n    return Device.avdEclair.name;\n  }","id":28790,"modified_method":"public String getDefaultDevice() {\n    // return Device.avdDonut.name;\n    return Device.ECLAIR.name;\n  }","commit_id":"80e411581e1abe50e005bd8718267b134e0fec02","url":"https://github.com/processing/processing"},{"original_method":"static boolean checkDefaults() {\n    try {\n      if (!avdEclair.exists()) {\n        if (!avdEclair.create()) {\n          Base.showWarning(\"Android Error\", AVD_CREATE_ERROR, null);\n        }\n      }\n      return true;\n\n    } catch (final Exception e) {\n      Base.showWarning(\"Android Error\", AVD_CREATE_ERROR, e);\n    }\n    return false;\n  }","id":28791,"modified_method":"static boolean checkDefaults() {\n    try {\n      if (!ECLAIR.exists()) {\n        if (!ECLAIR.create()) {\n          Base.showWarning(\"Android Error\", AVD_CREATE_ERROR, null);\n        }\n      }\n      return true;\n\n    } catch (final Exception e) {\n      Base.showWarning(\"Android Error\", AVD_CREATE_ERROR, e);\n    }\n    return false;\n  }","commit_id":"80e411581e1abe50e005bd8718267b134e0fec02","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Blocking execution.\n   * @param teeOut Send process's stdout to stdout in addition to capturing it\n   * @param teeErr Send process's stderr to stderr in addition to capturing it\n   * @return exit value of process\n   * @throws InterruptedException\n   * @throws IOException\n   */\n  public ProcessResult execute(final boolean teeOut, final boolean teeErr)\n      throws InterruptedException, IOException {\n    final StringWriter stdout = new StringWriter();\n    final StringWriter stderr = new StringWriter();\n    final long startTime = System.currentTimeMillis();\n\n    //    System.err.println(\"Executing \" + PApplet.join(cmd, ' '));\n    final Process process = Runtime.getRuntime().exec(cmd);\n    // The latch is decremented by the StringRedirectingThread when it exhausts its stream\n    final CountDownLatch latch = new CountDownLatch(2);\n    if (teeOut) {\n      new StringRedirectThread(process.getInputStream(), latch, stdout,\n                               new OutputStreamWriter(System.out)).start();\n    } else {\n      new StringRedirectThread(process.getInputStream(), latch, stdout).start();\n    }\n    if (teeErr) {\n      new StringRedirectThread(process.getErrorStream(), latch, stderr,\n                               new OutputStreamWriter(System.err)).start();\n    } else {\n      new StringRedirectThread(process.getErrorStream(), latch, stderr).start();\n    }\n    latch.await();\n    //    System.err.println((System.currentTimeMillis() - startTime) + \"ms: \"\n    //        + PApplet.join(cmd, \" \"));\n    return new ProcessResult(PApplet.join(cmd, ' '), process.waitFor(), stdout\n        .toString(), stderr.toString(), System.currentTimeMillis() - startTime);\n  }","id":28792,"modified_method":"/**\n   * Blocking execution.\n   * @param teeOut Send process's stdout to stdout in addition to capturing it\n   * @param teeErr Send process's stderr to stderr in addition to capturing it\n   * @return exit value of process\n   * @throws InterruptedException\n   * @throws IOException\n   */\n  public ProcessResult execute(final boolean teeOut, final boolean teeErr)\n      throws InterruptedException, IOException {\n    final StringWriter outWriter = new StringWriter();\n    final StringWriter errWriter = new StringWriter();\n    final long startTime = System.currentTimeMillis();\n\n    final Process process = Runtime.getRuntime().exec(cmd);\n\n    final StreamPump outpump = new StreamPump(process.getInputStream())\n        .addTarget(outWriter);\n    if (teeOut) {\n      outpump.addTarget(System.out);\n    }\n    outpump.start();\n\n    final StreamPump errpump = new StreamPump(process.getErrorStream())\n        .addTarget(errWriter);\n    if (teeErr) {\n      errpump.addTarget(System.err);\n    }\n    errpump.start();\n\n    return new ProcessResult(getCommand(), process.waitFor(), outWriter\n        .toString(), errWriter.toString(), System.currentTimeMillis()\n        - startTime);\n  }","commit_id":"80e411581e1abe50e005bd8718267b134e0fec02","url":"https://github.com/processing/processing"},{"original_method":"public void start() throws InterruptedException, IOException {\n    final Process process = Runtime.getRuntime().exec(\n      new String[] { \"adb\", \"logcat\" });\n    final CountDownLatch latch = new CountDownLatch(2);\n    new LogcatThread(process, latch).start();\n    new ProcessHelper.StringRedirectThread(process.getErrorStream(), latch,\n                                           new OutputStreamWriter(System.err))\n        .start();\n    latch.await();\n    process.waitFor();\n  }","id":28793,"modified_method":"public void start() throws InterruptedException, IOException {\n    final Process process = Runtime.getRuntime().exec(\n      new String[] { \"adb\", \"logcat\" });\n    new StreamPump(process.getInputStream()).addTarget(this).start();\n    new StreamPump(process.getErrorStream()).addTarget(System.err).start();\n    process.waitFor();\n  }","commit_id":"80e411581e1abe50e005bd8718267b134e0fec02","url":"https://github.com/processing/processing"},{"original_method":"protected void logErrors(String cmd, Process cliProc) {\n        System.out.println(\"Failed to execute '\" + cmd + \"'\");\n        System.out.println(\"Command's output: '\" + cliOutput + \"'\");\n        try {\n            int bytesTotal = cliProc.getErrorStream().available();\n            if (bytesTotal > 0) {\n                final byte[] bytes = new byte[bytesTotal];\n                cliProc.getErrorStream().read(bytes);\n                System.out.println(\"Command's error log: '\" + new String(bytes) + \"'\");\n            } else {\n                System.out.println(\"No output data for the command.\");\n            }\n        } catch (IOException e) {\n            fail(\"Failed to read command's error output: \" + e.getLocalizedMessage());\n        }\n    }","id":28794,"modified_method":"protected void logErrors(String cmd, Process cliProc) {\n        System.out.println(\"Failed to execute '\" + cmd + \"'\");\n        System.out.println(\"Command's output: '\" + cliOutput + \"'\");\n\n        java.io.InputStreamReader isr = new java.io.InputStreamReader(cliProc.getErrorStream());\n        java.io.BufferedReader br = new java.io.BufferedReader(isr);\n        String line=null;\n        try {\n            line = br.readLine();\n            if(line == null) {\n                System.out.println(\"No output data for the command.\");\n            } else {\n                StringBuilder buf = new StringBuilder(line);\n                while((line = br.readLine()) != null) {\n                    buf.append(Util.LINE_SEPARATOR);\n                    buf.append(line);\n                }\n                System.out.println(\"Command's error log: '\" + buf + \"'\");\n\n            }\n        } catch (IOException e) {\n            fail(\"Failed to read command's error output: \" + e.getLocalizedMessage());\n        }\n    }","commit_id":"3ac6b8d07191f1625c79b0c201e42d3f35df8629","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void readStream(final StringBuilder cliOutBuf, InputStream cliStream) {\n        try {\n            int bytesTotal = cliStream.available();\n            if (bytesTotal > 0) {\n                final byte[] bytes = new byte[bytesTotal];\n                cliStream.read(bytes);\n                cliOutBuf.append(new String(bytes));\n            }\n        } catch (IOException e) {\n            fail(\"Failed to read command's output: \" + e.getLocalizedMessage());\n        }\n    }","id":28795,"modified_method":"protected void readStream(final StringBuilder cliOutBuf, InputStream cliStream) {\n        java.io.InputStreamReader isr = new java.io.InputStreamReader(cliStream);\n        java.io.BufferedReader br = new java.io.BufferedReader(isr);\n        String line=null;\n        try {\n            while ((line = br.readLine()) != null) {\n                cliOutBuf.append(line).append(Util.LINE_SEPARATOR);\n            }\n        } catch (IOException e) {\n            fail(\"Failed to read command's output: \" + e.getLocalizedMessage());\n        }\n    }","commit_id":"3ac6b8d07191f1625c79b0c201e42d3f35df8629","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * @param action absolute URL or absolute path (which must include the context path)\n     */\n    public static XFormsModelSubmission.ConnectionResult doRegular(PipelineContext pipelineContext, ExternalContext externalContext,\n                                                                   String method, final String action, String mediatype, boolean doReplace,\n                                                                   byte[] serializedInstance, String serializedInstanceString) {\n\n        // Compute submission URL\n        final URL submissionURL;\n        try {\n            final String actionString;\n            {\n                final StringBuffer updatedActionStringBuffer = new StringBuffer(action);\n                if (serializedInstanceString != null) {\n                    if (action.indexOf('?') == -1)\n                        updatedActionStringBuffer.append('?');\n                    else\n                        updatedActionStringBuffer.append('&');\n                    updatedActionStringBuffer.append(serializedInstanceString);\n                }\n                actionString = updatedActionStringBuffer.toString();\n            }\n\n            if (actionString.startsWith(\"/\")) {\n                // Case of path absolute\n                final String requestURL = externalContext.getRequest().getRequestURL();\n                submissionURL = URLFactory.createURL(requestURL, actionString);\n            } else if (NetUtils.urlHasProtocol(actionString)) {\n                // Case of absolute URL\n                submissionURL = URLFactory.createURL(actionString);\n            } else {\n                throw new OXFException(\"xforms:submission: invalid action: \" + actionString);\n            }\n        } catch (MalformedURLException e) {\n            throw new OXFException(\"xforms:submission: invalid action: \" + action, e);\n        }\n\n        // Perform submission\n        final String scheme = submissionURL.getProtocol();\n        if (scheme.equals(\"http\") || scheme.equals(\"https\")) {\n            // http MUST be supported\n            // https SHOULD be supported\n            try {\n                final HttpURLConnection urlConnection = (HttpURLConnection) submissionURL.openConnection();\n                if (isPost(method) || isPut(method) || isGet(method)) {\n                    urlConnection.setDoInput(true);\n                    urlConnection.setDoOutput(!isGet(method)); // Only if POST / PUT\n\n                    urlConnection.setRequestMethod(method.toUpperCase());\n                    if (!isGet(method))\n                        urlConnection.setRequestProperty(\"content-type\", (mediatype != null) ? mediatype : \"application/xml\");\n\n                    // Forward cookies for session handling\n                    // TODO: The Servlet spec mandates JSESSIONID as cookie name; we should only forward this cookie\n                    final String[] cookies = (String[]) externalContext.getRequest().getHeaderValuesMap().get(\"cookie\");\n                    if (cookies != null) {\n                        for (int i = 0; i < cookies.length; i++) {\n                            final String cookie = cookies[i];\n                            urlConnection.setRequestProperty(\"cookie\", cookie);\n                        }\n                    }\n\n                    urlConnection.connect();\n\n                    // Write request body if needed\n                    if (!isGet(method)) {\n                        final OutputStream os = urlConnection.getOutputStream();\n                        try {\n                            os.write(serializedInstance);\n                        } finally {\n                            if (os != null) {\n                                try {\n                                    os.close();\n                                } catch (IOException e) {\n                                    throw new OXFException(\"Exception while closing output stream for action: \" + action);\n                                }\n                            }\n                        }\n                    }\n\n                    // Create result\n                    final XFormsModelSubmission.ConnectionResult connectionResult = new XFormsModelSubmission.ConnectionResult(submissionURL.toExternalForm()) {\n                        public void close() {\n                            if (resultInputStream != null) {\n                                try {\n                                    resultInputStream.close();\n                                } catch (IOException e) {\n                                    throw new OXFException(\"Exception while closing input stream for action: \" + action);\n                                }\n                            }\n\n                            if (urlConnection != null)\n                                urlConnection.disconnect();\n                        }\n                    };\n\n                    // Get response information that needs to be forwarded\n                    connectionResult.resultCode = urlConnection.getResponseCode();\n                    final String contentType = urlConnection.getContentType();\n                    connectionResult.resultMediaType = NetUtils.getContentTypeMediaType(contentType);\n                    connectionResult.resultHeaders = urlConnection.getHeaderFields();\n                    connectionResult.resultInputStream = urlConnection.getInputStream();\n\n                    return connectionResult;\n\n                } else if (method.equals(\"multipart-post\")) {\n                    // TODO\n                    throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                } else if (method.equals(\"form-data-post\")) {\n                    // TODO\n                    throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                } else if (method.equals(\"urlencoded-post\")) {\n                    throw new OXFException(\"xforms:submission: deprecated submission method requested: \" + method);\n                } else {\n                    throw new OXFException(\"xforms:submission: invalid submission method requested: \" + method);\n                }\n            } catch (IOException e) {\n                throw new OXFException(e);\n            }\n        } else if (scheme.equals(\"file\")) {\n            // TODO\n            // SHOULD be supported\n            // Question: should support oxf: as well?\n            throw new OXFException(\"xforms:submission: submission URL scheme not yet implemented: \" + scheme);\n        } else if (scheme.equals(\"mailto\")) {\n            // TODO\n            // MAY be supported\n            throw new OXFException(\"xforms:submission: submission URL scheme not yet implemented: \" + scheme);\n        } else {\n            throw new OXFException(\"xforms:submission: submission URL scheme not supported: \" + scheme);\n        }\n    }","id":28796,"modified_method":"/**\n     * @param action absolute URL or absolute path (which must include the context path)\n     */\n    public static XFormsModelSubmission.ConnectionResult doRegular(PipelineContext pipelineContext, ExternalContext externalContext,\n                                                                   String method, final String action, String mediatype, boolean doReplace,\n                                                                   byte[] serializedInstance, String serializedInstanceString) {\n\n        // Compute submission URL\n        final URL submissionURL;\n        try {\n            final String actionString;\n            {\n                final StringBuffer updatedActionStringBuffer = new StringBuffer(action);\n                if (serializedInstanceString != null) {\n                    if (action.indexOf('?') == -1)\n                        updatedActionStringBuffer.append('?');\n                    else\n                        updatedActionStringBuffer.append('&');\n                    updatedActionStringBuffer.append(serializedInstanceString);\n                }\n                actionString = updatedActionStringBuffer.toString();\n            }\n\n            if (actionString.startsWith(\"/\")) {\n                // Case of path absolute\n                final String requestURL = externalContext.getRequest().getRequestURL();\n                submissionURL = URLFactory.createURL(requestURL, actionString);\n            } else if (NetUtils.urlHasProtocol(actionString)) {\n                // Case of absolute URL\n                submissionURL = URLFactory.createURL(actionString);\n            } else {\n                throw new OXFException(\"xforms:submission: invalid action: \" + actionString);\n            }\n        } catch (MalformedURLException e) {\n            throw new OXFException(\"xforms:submission: invalid action: \" + action, e);\n        }\n\n        // Perform submission\n        final String scheme = submissionURL.getProtocol();\n        if (scheme.equals(\"http\") || scheme.equals(\"https\") || (isGet(method) && (scheme.equals(\"file\") || scheme.equals(\"oxf\")))) {\n            // http MUST be supported\n            // https SHOULD be supported\n            // file SHOULD be supported\n            try {\n                final URLConnection urlConnection = submissionURL.openConnection();\n                final HttpURLConnection httpURLConnection = (urlConnection instanceof HttpURLConnection) ? (HttpURLConnection) urlConnection : null;\n                if (isPost(method) || isPut(method) || isGet(method)) {\n                    urlConnection.setDoInput(true);\n                    urlConnection.setDoOutput(!isGet(method)); // Only if POST / PUT\n\n                    if (httpURLConnection != null) {\n                        httpURLConnection.setRequestMethod(method.toUpperCase());\n                    }\n                    if (!isGet(method))\n                        urlConnection.setRequestProperty(\"content-type\", (mediatype != null) ? mediatype : \"application/xml\");\n\n                    // Forward cookies for session handling\n                    // TODO: The Servlet spec mandates JSESSIONID as cookie name; we should only forward this cookie\n                    final String[] cookies = (String[]) externalContext.getRequest().getHeaderValuesMap().get(\"cookie\");\n                    if (cookies != null) {\n                        for (int i = 0; i < cookies.length; i++) {\n                            final String cookie = cookies[i];\n                            urlConnection.setRequestProperty(\"cookie\", cookie);\n                        }\n                    }\n\n                    urlConnection.connect();\n\n                    // Write request body if needed\n                    if (!isGet(method)) {\n                        final OutputStream os = urlConnection.getOutputStream();\n                        try {\n                            os.write(serializedInstance);\n                        } finally {\n                            if (os != null) {\n                                try {\n                                    os.close();\n                                } catch (IOException e) {\n                                    throw new OXFException(\"Exception while closing output stream for action: \" + action);\n                                }\n                            }\n                        }\n                    }\n\n                    // Create result\n                    final XFormsModelSubmission.ConnectionResult connectionResult = new XFormsModelSubmission.ConnectionResult(submissionURL.toExternalForm()) {\n                        public void close() {\n                            if (resultInputStream != null) {\n                                try {\n                                    resultInputStream.close();\n                                } catch (IOException e) {\n                                    throw new OXFException(\"Exception while closing input stream for action: \" + action);\n                                }\n                            }\n\n                            if (httpURLConnection != null)\n                                httpURLConnection.disconnect();\n                        }\n                    };\n\n                    // Get response information that needs to be forwarded\n                    connectionResult.resultCode = (httpURLConnection != null) ? httpURLConnection.getResponseCode() : 200;\n                    final String contentType = urlConnection.getContentType();\n                    connectionResult.resultMediaType = NetUtils.getContentTypeMediaType(contentType);\n                    connectionResult.resultHeaders = urlConnection.getHeaderFields();\n                    connectionResult.resultInputStream = urlConnection.getInputStream();\n\n                    return connectionResult;\n\n                } else if (method.equals(\"multipart-post\")) {\n                    // TODO\n                    throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                } else if (method.equals(\"form-data-post\")) {\n                    // TODO\n                    throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                } else if (method.equals(\"urlencoded-post\")) {\n                    throw new OXFException(\"xforms:submission: deprecated submission method requested: \" + method);\n                } else {\n                    throw new OXFException(\"xforms:submission: invalid submission method requested: \" + method);\n                }\n            } catch (IOException e) {\n                throw new OXFException(e);\n            }\n        } else if (!isGet(method) && (scheme.equals(\"file\") || scheme.equals(\"oxf\"))) {\n            // TODO\n            // SHOULD be supported (should probably support oxf: as well)\n            throw new OXFException(\"xforms:submission: submission URL scheme not yet implemented: \" + scheme);\n        } else if (scheme.equals(\"mailto\")) {\n            // TODO\n            // MAY be supported\n            throw new OXFException(\"xforms:submission: submission URL scheme not yet implemented: \" + scheme);\n        } else {\n            throw new OXFException(\"xforms:submission: submission URL scheme not supported: \" + scheme);\n        }\n    }","commit_id":"26a7f87d7dabf8477deb87ad04732455807a59ba","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Override\n        public void run() {\n            for (int i = 0; i < m_iterations; i++)\n                try {\n                    long start = System.nanoTime();\n                    String jsonResponse = TestJSONInterface.callProcOverJSON(\"Select\", pset, null, null);\n                    long stop = System.nanoTime();\n                    totalExecTime += stop - start;\n                    //System.out.println(jsonResponse);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(-1);\n                }\n        }","id":28797,"modified_method":"@Override\n        public void run() {\n            for (int i = 0; i < m_iterations; i++) {\n                try {\n                    long start = System.nanoTime();\n                    String jsonResponse = TestJSONInterface.callProcOverJSON(\"Select\", pset, null, null);\n                    long stop = System.nanoTime();\n                    totalExecTime += stop - start;\n                    //System.out.println(jsonResponse);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(-1);\n                }\n                if (i % 100 == 0) {\n                    System.out.printf(\"Client %03d has done %7d/%7d and is %2d%% complete.\\n\", m_id, i, m_iterations, (int) (m_iterations / (i * 100.0)));\n                    System.gc();\n                }\n            }\n        }","commit_id":"858f75d7143989c923e1eed926b33d7f00228758","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public JSONClient(int iterations) {\n            m_iterations = iterations;\n        }","id":28798,"modified_method":"public JSONClient(int clientId, int iterations) {\n            m_id = clientId;\n            m_iterations = iterations;\n        }","commit_id":"858f75d7143989c923e1eed926b33d7f00228758","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testJSON(int clientCount, int iterations) throws Exception {\n        ServerThread server = startup();\n\n        JSONClient[] clients = new JSONClient[clientCount];\n        for (int i = 0; i < clientCount; i++)\n            clients[i] = new JSONClient(iterations);\n\n        long execTime = 0;\n\n        long start = System.nanoTime();\n        for (JSONClient client : clients) {\n            client.start();\n        }\n        for (JSONClient client : clients) {\n            client.join();\n            execTime += client.totalExecTime;\n        }\n\n        long finish = System.nanoTime();\n\n        double seconds = (finish - start) / (1000d * 1000d * 1000d);\n        double rate = (iterations * clientCount) / seconds;\n        double latency = execTime / (double) (iterations * clientCount);\n        latency /= 1000d * 1000d;\n\n        System.out.printf(\"Simple bench did %.2f iterations / sec at %.2f ms latency per txn.\\n\", rate, latency);\n\n        server.shutdown();\n        server.join();\n    }","id":28799,"modified_method":"public void testJSON() {\n        try {\n            //b.testSimple();\n            //b.testThreadCreation();\n            JSONBench(2, 20000);\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }","commit_id":"858f75d7143989c923e1eed926b33d7f00228758","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void main(String args[]) {\n        HTTPDBenchmark b = new HTTPDBenchmark();\n\n        try {\n            b.testSimple();\n            b.testThreadCreation();\n            b.testJSON(20, 1000);\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }","id":28800,"modified_method":"public static void main(String args[]) {\n        HTTPDBenchmark b = new HTTPDBenchmark();\n\n        try {\n            //b.testSimple();\n            //b.testThreadCreation();\n            b.JSONBench(2, 20000);\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }","commit_id":"858f75d7143989c923e1eed926b33d7f00228758","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static String callProcOverJSONRaw(String varString) throws Exception {\n        URL jsonAPIURL = new URL(\"http://localhost:8095/api/1.0/\");\n\n        HttpURLConnection conn = (HttpURLConnection) jsonAPIURL.openConnection();\n        conn.setDoOutput(true);\n\n        conn.setRequestMethod(\"POST\");\n        OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n        out.write(varString);\n        out.close();\n\n        BufferedReader in = null;\n        try {\n            if(conn.getInputStream()!=null){\n                in = new BufferedReader(\n                        new InputStreamReader(\n                        conn.getInputStream(), \"UTF-8\"));\n            }\n        } catch(IOException e){\n            if(conn.getErrorStream()!=null){\n                in = new BufferedReader(\n                        new InputStreamReader(\n                        conn.getErrorStream(), \"UTF-8\"));\n            }\n        }\n        if(in==null) {\n            throw new Exception(\"Unable to read response from server\");\n        }\n\n        StringBuffer decodedString = new StringBuffer();\n        String line;\n        while ((line = in.readLine()) != null) {\n            decodedString.append(line);\n        }\n        in.close();\n        // get result code\n        int responseCode = conn.getResponseCode();\n\n        String response = decodedString.toString();\n\n        assertEquals(200, responseCode);\n        return response;\n    }","id":28801,"modified_method":"public static String callProcOverJSONRaw(String varString) throws Exception {\n        URL jsonAPIURL = new URL(\"http://localhost:8095/api/1.0/\");\n\n        HttpURLConnection conn = (HttpURLConnection) jsonAPIURL.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.connect();\n\n        OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n        out.write(varString);\n        out.flush();\n        out.close();\n        out = null;\n        conn.getOutputStream().close();\n\n        BufferedReader in = null;\n        try {\n            if(conn.getInputStream()!=null){\n                in = new BufferedReader(\n                        new InputStreamReader(\n                        conn.getInputStream(), \"UTF-8\"));\n            }\n        } catch(IOException e){\n            if(conn.getErrorStream()!=null){\n                in = new BufferedReader(\n                        new InputStreamReader(\n                        conn.getErrorStream(), \"UTF-8\"));\n            }\n        }\n        if(in==null) {\n            throw new Exception(\"Unable to read response from server\");\n        }\n\n        StringBuffer decodedString = new StringBuffer();\n        String line;\n        while ((line = in.readLine()) != null) {\n            decodedString.append(line);\n        }\n        in.close();\n        in = null;\n        // get result code\n        int responseCode = conn.getResponseCode();\n\n        String response = decodedString.toString();\n\n        assertEquals(200, responseCode);\n\n        conn.getInputStream().close();\n        conn.disconnect();\n        conn = null;\n\n        //System.err.println(response);\n\n        return response;\n    }","commit_id":"858f75d7143989c923e1eed926b33d7f00228758","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@DB\n    protected ApplicationLoadBalancerRule persistLbRule(final ApplicationLoadBalancerRuleVO newRuleFinal) throws NetworkRuleConflictException {\n        boolean success = true;\n        ApplicationLoadBalancerRuleVO newRule = null;\n        try {\n            newRule = Transaction.execute(new TransactionCallbackWithException<ApplicationLoadBalancerRuleVO, NetworkRuleConflictException>() {\n                @Override\n                public ApplicationLoadBalancerRuleVO doInTransaction(TransactionStatus status) throws NetworkRuleConflictException {\n                    //1) Persist the rule\n                    ApplicationLoadBalancerRuleVO newRule = _lbDao.persist(newRuleFinal);\n\n                    //2) Detect conflicts\n                    detectLbRulesConflicts(newRule);\n                    if (!_firewallDao.setStateToAdd(newRule)) {\n                        throw new CloudRuntimeException(\"Unable to update the state to add for \" + newRule);\n                    }\n                    s_logger.debug(\"Load balancer \" + newRule.getId() + \" for Ip address \" + newRule.getSourceIp().addr() + \", source port \" +\n                        newRule.getSourcePortStart() + \", instance port \" + newRule.getDefaultPortStart() + \" is added successfully.\");\n                    CallContext.current().setEventDetails(\"Load balancer Id: \" + newRule.getId());\n                    Network ntwk = _networkModel.getNetwork(newRule.getNetworkId());\n                    UsageEventUtils.publishUsageEvent(EventTypes.EVENT_LOAD_BALANCER_CREATE, newRule.getAccountId(), ntwk.getDataCenterId(), newRule.getId(), null,\n                        LoadBalancingRule.class.getName(), newRule.getUuid());\n\n                    return newRule;\n                }\n            });\n\n            return newRule;\n        } catch (Exception e) {\n            success = false;\n            if (e instanceof NetworkRuleConflictException) {\n                throw (NetworkRuleConflictException)e;\n            }\n            throw new CloudRuntimeException(\"Unable to add lb rule for ip address \" + newRuleFinal.getSourceIpAddressId(), e);\n        } finally {\n            if (!success && newRule != null) {\n                _lbMgr.removeLBRule(newRule);\n            }\n        }\n    }","id":28802,"modified_method":"@DB\n    protected ApplicationLoadBalancerRule persistLbRule(final ApplicationLoadBalancerRuleVO newRuleFinal) throws NetworkRuleConflictException {\n        boolean success = true;\n        ApplicationLoadBalancerRuleVO newRule = null;\n        try {\n            newRule = Transaction.execute(new TransactionCallbackWithException<ApplicationLoadBalancerRuleVO, NetworkRuleConflictException>() {\n                @Override\n                public ApplicationLoadBalancerRuleVO doInTransaction(TransactionStatus status) throws NetworkRuleConflictException {\n                    //1) Persist the rule\n                    ApplicationLoadBalancerRuleVO newRule = _lbDao.persist(newRuleFinal);\n\n                    //2) Detect conflicts\n                    detectLbRulesConflicts(newRule);\n                    if (!_firewallDao.setStateToAdd(newRule)) {\n                        throw new CloudRuntimeException(\"Unable to update the state to add for \" + newRule);\n                    }\n                    s_logger.debug(\"Load balancer \" + newRule.getId() + \" for Ip address \" + newRule.getSourceIp().addr() + \", source port \" +\n                        newRule.getSourcePortStart().intValue() + \", instance port \" + newRule.getDefaultPortStart() + \" is added successfully.\");\n                    CallContext.current().setEventDetails(\"Load balancer Id: \" + newRule.getId());\n                    Network ntwk = _networkModel.getNetwork(newRule.getNetworkId());\n                    UsageEventUtils.publishUsageEvent(EventTypes.EVENT_LOAD_BALANCER_CREATE, newRule.getAccountId(), ntwk.getDataCenterId(), newRule.getId(), null,\n                        LoadBalancingRule.class.getName(), newRule.getUuid());\n\n                    return newRule;\n                }\n            });\n\n            return newRule;\n        } catch (Exception e) {\n            success = false;\n            if (e instanceof NetworkRuleConflictException) {\n                throw (NetworkRuleConflictException)e;\n            }\n            throw new CloudRuntimeException(\"Unable to add lb rule for ip address \" + newRuleFinal.getSourceIpAddressId(), e);\n        } finally {\n            if (!success && newRule != null) {\n                _lbMgr.removeLBRule(newRule);\n            }\n        }\n    }","commit_id":"dda2820552f943f65c835cc3495c849ff2c060e4","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * Detects Internal Lb Rules conflicts\n     * @param newLbRule\n     * @throws NetworkRuleConflictException\n     */\n    protected void detectInternalLbRulesConflict(ApplicationLoadBalancerRule newLbRule) throws NetworkRuleConflictException {\n        List<ApplicationLoadBalancerRuleVO> lbRules = _lbDao.listBySourceIpAndNotRevoked(newLbRule.getSourceIp(), newLbRule.getSourceIpNetworkId());\n\n        for (ApplicationLoadBalancerRuleVO lbRule : lbRules) {\n            if (lbRule.getId() == newLbRule.getId()) {\n                continue; // Skips my own rule.\n            }\n\n            if (lbRule.getNetworkId() != newLbRule.getNetworkId() && lbRule.getState() != State.Revoke) {\n                throw new NetworkRuleConflictException(\"New rule is for a different network than what's specified in rule \" + lbRule.getXid());\n            }\n\n            if ((lbRule.getSourcePortStart().intValue() <= newLbRule.getSourcePortStart().intValue() && lbRule.getSourcePortEnd().intValue() >= newLbRule.getSourcePortStart()\n                .intValue()) ||\n                (lbRule.getSourcePortStart().intValue() <= newLbRule.getSourcePortEnd().intValue() && lbRule.getSourcePortEnd().intValue() >= newLbRule.getSourcePortEnd()\n                    .intValue()) ||\n                (newLbRule.getSourcePortStart().intValue() <= lbRule.getSourcePortStart().intValue() && newLbRule.getSourcePortEnd().intValue() >= lbRule.getSourcePortStart()\n                    .intValue()) ||\n                (newLbRule.getSourcePortStart().intValue() <= lbRule.getSourcePortEnd().intValue() && newLbRule.getSourcePortEnd().intValue() >= lbRule.getSourcePortEnd()\n                    .intValue())) {\n\n                throw new NetworkRuleConflictException(\"The range specified, \" + newLbRule.getSourcePortStart() + \"-\" + newLbRule.getSourcePortEnd() +\n                    \", conflicts with rule \" + lbRule.getId() + \" which has \" + lbRule.getSourcePortStart() + \"-\" + lbRule.getSourcePortEnd());\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"No network rule conflicts detected for \" + newLbRule + \" against \" + (lbRules.size() - 1) + \" existing rules\");\n        }\n    }","id":28803,"modified_method":"/**\n     * Detects Internal Lb Rules conflicts\n     * @param newLbRule\n     * @throws NetworkRuleConflictException\n     */\n    protected void detectInternalLbRulesConflict(ApplicationLoadBalancerRule newLbRule) throws NetworkRuleConflictException {\n        List<ApplicationLoadBalancerRuleVO> lbRules = _lbDao.listBySourceIpAndNotRevoked(newLbRule.getSourceIp(), newLbRule.getSourceIpNetworkId());\n\n        for (ApplicationLoadBalancerRuleVO lbRule : lbRules) {\n            if (lbRule.getId() == newLbRule.getId()) {\n                continue; // Skips my own rule.\n            }\n\n            if (lbRule.getNetworkId() != newLbRule.getNetworkId() && lbRule.getState() != State.Revoke) {\n                throw new NetworkRuleConflictException(\"New rule is for a different network than what's specified in rule \" + lbRule.getXid());\n            }\n\n            if ((lbRule.getSourcePortStart().intValue() <= newLbRule.getSourcePortStart().intValue() && lbRule.getSourcePortEnd().intValue() >= newLbRule.getSourcePortStart()\n                .intValue()) ||\n                (lbRule.getSourcePortStart().intValue() <= newLbRule.getSourcePortEnd().intValue() && lbRule.getSourcePortEnd().intValue() >= newLbRule.getSourcePortEnd()\n                    .intValue()) ||\n                (newLbRule.getSourcePortStart().intValue() <= lbRule.getSourcePortStart().intValue() && newLbRule.getSourcePortEnd().intValue() >= lbRule.getSourcePortStart()\n                    .intValue()) ||\n                (newLbRule.getSourcePortStart().intValue() <= lbRule.getSourcePortEnd().intValue() && newLbRule.getSourcePortEnd().intValue() >= lbRule.getSourcePortEnd()\n                    .intValue())) {\n\n                throw new NetworkRuleConflictException(\"The range specified, \" + newLbRule.getSourcePortStart().intValue() + \"-\" + newLbRule.getSourcePortEnd().intValue() +\n                    \", conflicts with rule \" + lbRule.getId() + \" which has \" + lbRule.getSourcePortStart().intValue() + \"-\" + lbRule.getSourcePortEnd().intValue());\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"No network rule conflicts detected for \" + newLbRule + \" against \" + (lbRules.size() - 1) + \" existing rules\");\n        }\n    }","commit_id":"dda2820552f943f65c835cc3495c849ff2c060e4","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Integer getSourcePortStart() {\n        if (publicStartPort != null) {\n            return publicStartPort.intValue();\n        }\n        return null;\n    }","id":28804,"modified_method":"@Override\n    public Integer getSourcePortStart() {\n        if (publicStartPort != null) {\n            return publicStartPort;\n        }\n        return null;\n    }","commit_id":"dda2820552f943f65c835cc3495c849ff2c060e4","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Integer getSourcePortEnd() {\n        if (publicEndPort == null) {\n            if (publicStartPort != null) {\n                return publicStartPort.intValue();\n            }\n        } else {\n            return publicEndPort.intValue();\n        }\n\n        return null;\n    }","id":28805,"modified_method":"@Override\n    public Integer getSourcePortEnd() {\n        if (publicEndPort == null) {\n            if (publicStartPort != null) {\n                return publicStartPort;\n            }\n        } else {\n            return publicEndPort;\n        }\n\n        return null;\n    }","commit_id":"dda2820552f943f65c835cc3495c849ff2c060e4","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void create() {\n        if (getSourceCidrList() != null) {\n            for (String cidr : getSourceCidrList()) {\n                if (!NetUtils.isValidCIDR(cidr)) {\n                    throw new ServerApiException(ApiErrorCode.PARAM_ERROR, \"Source cidrs formatting error \" + cidr);\n                }\n            }\n        }\n\n        try {\n            FirewallRule result = _firewallService.createIngressFirewallRule(this);\n            setEntityId(result.getId());\n            setEntityUuid(result.getUuid());\n        } catch (NetworkRuleConflictException ex) {\n            s_logger.info(\"Network rule conflict: \" + ex.getMessage());\n            s_logger.trace(\"Network Rule Conflict: \", ex);\n            throw new ServerApiException(ApiErrorCode.NETWORK_RULE_CONFLICT_ERROR, ex.getMessage());\n        }\n    }","id":28806,"modified_method":"@Override\n    public void create() {\n        if (getSourceCidrList() != null) {\n            for (String cidr : getSourceCidrList()) {\n                if (!NetUtils.isValidCIDR(cidr)) {\n                    throw new ServerApiException(ApiErrorCode.PARAM_ERROR, \"Source cidrs formatting error \" + cidr);\n                }\n            }\n        }\n        try {\n            FirewallRule result = _firewallService.createIngressFirewallRule(this);\n            if (result != null) {\n                setEntityId(result.getId());\n                setEntityUuid(result.getUuid());\n            }\n        } catch (NetworkRuleConflictException ex) {\n            s_logger.info(\"Network rule conflict: \" + ex.getMessage());\n            s_logger.trace(\"Network Rule Conflict: \", ex);\n            throw new ServerApiException(ApiErrorCode.NETWORK_RULE_CONFLICT_ERROR, ex.getMessage());\n        }\n    }","commit_id":"dda2820552f943f65c835cc3495c849ff2c060e4","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    @DB\n    @ActionEvent(eventType = EventTypes.EVENT_REMOTE_ACCESS_VPN_DESTROY, eventDescription = \"removing remote access vpn\", async = true)\n    public boolean destroyRemoteAccessVpnForIp(long ipId, Account caller) throws ResourceUnavailableException {\n        final RemoteAccessVpnVO vpn = _remoteAccessVpnDao.findByPublicIpAddress(ipId);\n        if (vpn == null) {\n            s_logger.debug(\"there are no Remote access vpns for public ip address id=\" + ipId);\n            return true;\n        }\n\n        _accountMgr.checkAccess(caller, AccessType.OperateEntry, true, vpn);\n\n        RemoteAccessVpn.State prevState = vpn.getState();\n        vpn.setState(RemoteAccessVpn.State.Removed);\n        _remoteAccessVpnDao.update(vpn.getId(), vpn);\n\n        boolean success = false;\n        try {\n            for (RemoteAccessVPNServiceProvider element : _vpnServiceProviders) {\n                if (element.stopVpn(vpn)) {\n                    success = true;\n                    break;\n                }\n            }\n        }catch (ResourceUnavailableException ex) {\n            vpn.setState(prevState);\n            _remoteAccessVpnDao.update(vpn.getId(), vpn);\n            s_logger.debug(\"Failed to stop the vpn \" + vpn.getId() + \" , so reverted state to \"+\n                    RemoteAccessVpn.State.Running);\n            success = false;\n        } finally {\n            if (success) {\n                //Cleanup corresponding ports\n                final List<? extends FirewallRule> vpnFwRules = _rulesDao.listByIpAndPurpose(ipId, Purpose.Vpn);\n\n                boolean applyFirewall = false;\n                final List<FirewallRuleVO> fwRules = new ArrayList<FirewallRuleVO>();\n                //if related firewall rule is created for the first vpn port, it would be created for the 2 other ports as well, so need to cleanup the backend\n                if (vpnFwRules.size() != 0 && _rulesDao.findByRelatedId(vpnFwRules.get(0).getId()) != null) {\n                    applyFirewall = true;\n                }\n\n                if (applyFirewall) {\n                    Transaction.execute(new TransactionCallbackNoReturn() {\n                        @Override\n                        public void doInTransactionWithoutResult(TransactionStatus status) {\n                            for (FirewallRule vpnFwRule : vpnFwRules) {\n                                //don't apply on the backend yet; send all 3 rules in a banch\n                                _firewallMgr.revokeRelatedFirewallRule(vpnFwRule.getId(), false);\n                                fwRules.add(_rulesDao.findByRelatedId(vpnFwRule.getId()));\n                            }\n\n                            s_logger.debug(\"Marked \" + fwRules.size() + \" firewall rules as Revoked as a part of disable remote access vpn\");\n                        }\n                    });\n\n                    //now apply vpn rules on the backend\n                    s_logger.debug(\"Reapplying firewall rules for ip id=\" + ipId + \" as a part of disable remote access vpn\");\n                    success = _firewallMgr.applyIngressFirewallRules(ipId, caller);\n                }\n\n                if (success) {\n                    try {\n                        Transaction.execute(new TransactionCallbackNoReturn() {\n                            @Override\n                            public void doInTransactionWithoutResult(TransactionStatus status) {\n                                _remoteAccessVpnDao.remove(vpn.getId());\n                                // Stop billing of VPN users when VPN is removed. VPN_User_ADD events will be generated when VPN is created again\n                                List<VpnUserVO> vpnUsers = _vpnUsersDao.listByAccount(vpn.getAccountId());\n                                for (VpnUserVO user : vpnUsers) {\n                                    // VPN_USER_REMOVE event is already generated for users in Revoke state\n                                    if (user.getState() != VpnUser.State.Revoke) {\n                                        UsageEventUtils.publishUsageEvent(EventTypes.EVENT_VPN_USER_REMOVE, user.getAccountId(), 0, user.getId(), user.getUsername(),\n                                            user.getClass().getName(), user.getUuid());\n                                    }\n                                }\n                                if (vpnFwRules != null) {\n                                    for (FirewallRule vpnFwRule : vpnFwRules) {\n                                        _rulesDao.remove(vpnFwRule.getId());\n                                        s_logger.debug(\"Successfully removed firewall rule with ip id=\" + vpnFwRule.getSourceIpAddressId() + \" and port \" +\n                                            vpnFwRule.getSourcePortStart() + \" as a part of vpn cleanup\");\n                                    }\n                                }\n                            }\n                        });\n                    } catch (Exception ex) {\n                        s_logger.warn(\"Unable to release the three vpn ports from the firewall rules\", ex);\n                    }\n                }\n            }\n        }\n        return success;\n    }","id":28807,"modified_method":"@Override\n    @DB\n    @ActionEvent(eventType = EventTypes.EVENT_REMOTE_ACCESS_VPN_DESTROY, eventDescription = \"removing remote access vpn\", async = true)\n    public boolean destroyRemoteAccessVpnForIp(long ipId, Account caller) throws ResourceUnavailableException {\n        final RemoteAccessVpnVO vpn = _remoteAccessVpnDao.findByPublicIpAddress(ipId);\n        if (vpn == null) {\n            s_logger.debug(\"there are no Remote access vpns for public ip address id=\" + ipId);\n            return true;\n        }\n\n        _accountMgr.checkAccess(caller, AccessType.OperateEntry, true, vpn);\n\n        RemoteAccessVpn.State prevState = vpn.getState();\n        vpn.setState(RemoteAccessVpn.State.Removed);\n        _remoteAccessVpnDao.update(vpn.getId(), vpn);\n\n        boolean success = false;\n        try {\n            for (RemoteAccessVPNServiceProvider element : _vpnServiceProviders) {\n                if (element.stopVpn(vpn)) {\n                    success = true;\n                    break;\n                }\n            }\n        }catch (ResourceUnavailableException ex) {\n            vpn.setState(prevState);\n            _remoteAccessVpnDao.update(vpn.getId(), vpn);\n            s_logger.debug(\"Failed to stop the vpn \" + vpn.getId() + \" , so reverted state to \"+\n                    RemoteAccessVpn.State.Running);\n            success = false;\n        } finally {\n            if (success) {\n                //Cleanup corresponding ports\n                final List<? extends FirewallRule> vpnFwRules = _rulesDao.listByIpAndPurpose(ipId, Purpose.Vpn);\n\n                boolean applyFirewall = false;\n                final List<FirewallRuleVO> fwRules = new ArrayList<FirewallRuleVO>();\n                //if related firewall rule is created for the first vpn port, it would be created for the 2 other ports as well, so need to cleanup the backend\n                if (vpnFwRules.size() != 0 && _rulesDao.findByRelatedId(vpnFwRules.get(0).getId()) != null) {\n                    applyFirewall = true;\n                }\n\n                if (applyFirewall) {\n                    Transaction.execute(new TransactionCallbackNoReturn() {\n                        @Override\n                        public void doInTransactionWithoutResult(TransactionStatus status) {\n                            for (FirewallRule vpnFwRule : vpnFwRules) {\n                                //don't apply on the backend yet; send all 3 rules in a banch\n                                _firewallMgr.revokeRelatedFirewallRule(vpnFwRule.getId(), false);\n                                fwRules.add(_rulesDao.findByRelatedId(vpnFwRule.getId()));\n                            }\n\n                            s_logger.debug(\"Marked \" + fwRules.size() + \" firewall rules as Revoked as a part of disable remote access vpn\");\n                        }\n                    });\n\n                    //now apply vpn rules on the backend\n                    s_logger.debug(\"Reapplying firewall rules for ip id=\" + ipId + \" as a part of disable remote access vpn\");\n                    success = _firewallMgr.applyIngressFirewallRules(ipId, caller);\n                }\n\n                if (success) {\n                    try {\n                        Transaction.execute(new TransactionCallbackNoReturn() {\n                            @Override\n                            public void doInTransactionWithoutResult(TransactionStatus status) {\n                                _remoteAccessVpnDao.remove(vpn.getId());\n                                // Stop billing of VPN users when VPN is removed. VPN_User_ADD events will be generated when VPN is created again\n                                List<VpnUserVO> vpnUsers = _vpnUsersDao.listByAccount(vpn.getAccountId());\n                                for (VpnUserVO user : vpnUsers) {\n                                    // VPN_USER_REMOVE event is already generated for users in Revoke state\n                                    if (user.getState() != VpnUser.State.Revoke) {\n                                        UsageEventUtils.publishUsageEvent(EventTypes.EVENT_VPN_USER_REMOVE, user.getAccountId(), 0, user.getId(), user.getUsername(),\n                                            user.getClass().getName(), user.getUuid());\n                                    }\n                                }\n                                if (vpnFwRules != null) {\n                                    for (FirewallRule vpnFwRule : vpnFwRules) {\n                                        _rulesDao.remove(vpnFwRule.getId());\n                                        s_logger.debug(\"Successfully removed firewall rule with ip id=\" + vpnFwRule.getSourceIpAddressId() + \" and port \" +\n                                            vpnFwRule.getSourcePortStart().intValue() + \" as a part of vpn cleanup\");\n                                    }\n                                }\n                            }\n                        });\n                    } catch (Exception ex) {\n                        s_logger.warn(\"Unable to release the three vpn ports from the firewall rules\", ex);\n                    }\n                }\n            }\n        }\n        return success;\n    }","commit_id":"dda2820552f943f65c835cc3495c849ff2c060e4","url":"https://github.com/apache/cloudstack"},{"original_method":"public StaticNatRuleImpl(FirewallRuleVO rule, String dstIp) {\n        id = rule.getId();\n        xid = rule.getXid();\n        uuid = rule.getUuid();\n        protocol = rule.getProtocol();\n        portStart = rule.getSourcePortStart();\n        portEnd = rule.getSourcePortEnd();\n        state = rule.getState();\n        accountId = rule.getAccountId();\n        domainId = rule.getDomainId();\n        networkId = rule.getNetworkId();\n        sourceIpAddressId = rule.getSourceIpAddressId();\n        destIpAddress = dstIp;\n        forDisplay = rule.isDisplay();\n    }","id":28808,"modified_method":"public StaticNatRuleImpl(FirewallRuleVO rule, String dstIp) {\n        id = rule.getId();\n        xid = rule.getXid();\n        uuid = rule.getUuid();\n        protocol = rule.getProtocol();\n        portStart = rule.getSourcePortStart().intValue();\n        portEnd = rule.getSourcePortEnd().intValue();\n        state = rule.getState();\n        accountId = rule.getAccountId();\n        domainId = rule.getDomainId();\n        networkId = rule.getNetworkId();\n        sourceIpAddressId = rule.getSourceIpAddressId();\n        destIpAddress = dstIp;\n        forDisplay = rule.isDisplay();\n    }","commit_id":"dda2820552f943f65c835cc3495c849ff2c060e4","url":"https://github.com/apache/cloudstack"},{"original_method":"@Inject\n   public Console(final Display view, EventBus events, Commands commands)\n   {    \n      view_ = view;\n\n      events.addHandler(SendToConsoleEvent.TYPE, new SendToConsoleHandler()\n      {\n         public void onSendToConsole(SendToConsoleEvent event)\n         {\n            view.bringToFront();\n         }\n      });\n\n      ((Binder) GWT.create(Binder.class)).bind(commands, this);\n   }","id":28809,"modified_method":"@Inject\n   public Console(final Display view, EventBus events, Commands commands)\n   {    \n      view_ = view;\n\n      events.addHandler(SendToConsoleEvent.TYPE, new SendToConsoleHandler()\n      {\n         public void onSendToConsole(SendToConsoleEvent event)\n         {\n            view.bringToFront();\n         }\n      });\n\n      ((Binder) GWT.create(Binder.class)).bind(commands, this);\n\n      fadeInHelper_ = new DelayFadeInHelper(\n            view_.getConsoleInterruptButton().asWidget());\n      events.addHandler(BusyEvent.TYPE, new BusyHandler()\n      {\n         @Override\n         public void onBusy(BusyEvent event)\n         {\n            if (event.isBusy())\n               fadeInHelper_.beginShow();\n            else\n               fadeInHelper_.hide();\n         }\n      });\n\n      events.addHandler(ConsolePromptEvent.TYPE, new ConsolePromptHandler()\n      {\n         @Override\n         public void onConsolePrompt(ConsolePromptEvent event)\n         {\n            fadeInHelper_.hide();\n         }\n      });\n   }","commit_id":"cbf75e27641610349631950630b5e6b2ab72c485","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public ConsoleInterruptButton(EventBus events,\n                                 Commands commands)\n   {\n      // The SimplePanel wrapper is necessary for the toolbar button's \"pushed\"\n      // effect to work.\n      SimplePanel panel = new SimplePanel();\n      panel.getElement().getStyle().setPosition(Position.RELATIVE);\n\n      commands_ = commands;\n      ImageResource icon = commands_.interruptR().getImageResource();\n      ToolbarButton button = new ToolbarButton(icon,\n                                               commands.interruptR());\n      width_ = icon.getWidth() + 6;\n      height_ = icon.getHeight();\n      panel.setWidget(button);\n\n      initWidget(panel);\n      setVisible(false);\n\n      events.addHandler(BusyEvent.TYPE, new BusyHandler()\n      {\n         public void onBusy(BusyEvent event)\n         {\n            if (event.isBusy())\n               beginShow();\n            else\n               hide();\n         }\n      });\n\n      /*\n      JJ says:\n      It is possible that the client could miss the busy = false event (if the\n      client goes out of network coverage and then the server suspends before\n      it can come back into coverage). For this reason I think that the icon's\n      controller logic should subscribe to the ConsolePromptEvent and clear it\n      whenenver a prompt occurs.\n      */\n      events.addHandler(ConsolePromptEvent.TYPE, new ConsolePromptHandler()\n      {\n         public void onConsolePrompt(ConsolePromptEvent event)\n         {\n            hide();\n         }\n      });\n   }","id":28810,"modified_method":"@Inject\n   public ConsoleInterruptButton(EventBus events,\n                                 Commands commands)\n   {\n      fadeInHelper_ = new DelayFadeInHelper(this);\n\n      // The SimplePanel wrapper is necessary for the toolbar button's \"pushed\"\n      // effect to work.\n      SimplePanel panel = new SimplePanel();\n      panel.getElement().getStyle().setPosition(Position.RELATIVE);\n\n      commands_ = commands;\n      ImageResource icon = commands_.interruptR().getImageResource();\n      ToolbarButton button = new ToolbarButton(icon,\n                                               commands.interruptR());\n      width_ = icon.getWidth() + 6;\n      height_ = icon.getHeight();\n      panel.setWidget(button);\n\n      initWidget(panel);\n      setVisible(false);\n\n      events.addHandler(BusyEvent.TYPE, new BusyHandler()\n      {\n         public void onBusy(BusyEvent event)\n         {\n            if (event.isBusy())\n            {\n               fadeInHelper_.beginShow();\n               commands_.interruptR().setEnabled(true);\n            }\n            else\n            {\n               fadeInHelper_.hide();\n               commands_.interruptR().setEnabled(false);\n            }\n         }\n      });\n\n      /*\n      JJ says:\n      It is possible that the client could miss the busy = false event (if the\n      client goes out of network coverage and then the server suspends before\n      it can come back into coverage). For this reason I think that the icon's\n      controller logic should subscribe to the ConsolePromptEvent and clear it\n      whenenver a prompt occurs.\n      */\n      events.addHandler(ConsolePromptEvent.TYPE, new ConsolePromptHandler()\n      {\n         public void onConsolePrompt(ConsolePromptEvent event)\n         {\n            fadeInHelper_.hide();\n            commands_.interruptR().setEnabled(false);\n         }\n      });\n   }","commit_id":"cbf75e27641610349631950630b5e6b2ab72c485","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      Toolbar toolbar = new Toolbar();\n      workingDir_ = new Label();\n      workingDir_.setStyleName(ThemeStyles.INSTANCE.subtitle());\n      toolbar.addLeftWidget(workingDir_);\n      toolbar.addLeftWidget(commands_.goToWorkingDir().createToolbarButton());\n      toolbar.addRightWidget(commands_.interruptR().createToolbarButton());\n      return toolbar;\n   }","id":28811,"modified_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      Toolbar toolbar = new Toolbar();\n      workingDir_ = new Label();\n      workingDir_.setStyleName(ThemeStyles.INSTANCE.subtitle());\n      toolbar.addLeftWidget(workingDir_);\n      toolbar.addLeftWidget(commands_.goToWorkingDir().createToolbarButton());\n      consoleInterruptButton_ = commands_.interruptR().createToolbarButton();\n      toolbar.addRightWidget(consoleInterruptButton_);\n      return toolbar;\n   }","commit_id":"cbf75e27641610349631950630b5e6b2ab72c485","url":"https://github.com/rstudio/rstudio"},{"original_method":"private Toolbar createToolbar(Commands commands)\n   {\n      Toolbar toolbar = new Toolbar();\n      toolbar.addLeftWidget(commands_.viewerPopout().createToolbarButton());\n      toolbar.addRightWidget(commands_.reloadShinyApp().createToolbarButton());\n      return toolbar;\n   }","id":28812,"modified_method":"private Toolbar createToolbar(Commands commands)\n   {\n      Toolbar toolbar = new Toolbar();\n      toolbar.addLeftWidget(commands_.reloadShinyApp().createToolbarButton());\n      urlBox_ = new Label(\"\");\n      Style style = urlBox_.getElement().getStyle();\n      style.setColor(\"#606060\");\n      toolbar.addLeftWidget(urlBox_);\n      ToolbarButton popout = commands_.viewerPopout().createToolbarButton();\n      popout.setText(\"Open in Browser\");\n      toolbar.addRightWidget(popout);\n      return toolbar;\n   }","commit_id":"0818e05be82e4f0a7b3287e4e413a5d7b634a90e","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void showApp(ShinyApplicationParams params)\n   {\n      appParams_ = params;\n\n      if (appFrame_ != null)\n      {\n         rootPanel_.remove(appFrame_);\n         appFrame_ = null;\n      }\n\n      appFrame_ = new RStudioFrame(appParams_.getUrl());\n      appFrame_.setSize(\"100%\", \"100%\");\n      rootPanel_.add(appFrame_);\n      rootPanel_.setWidgetLeftRight(appFrame_,  0, Unit.PX, 0, Unit.PX);\n      rootPanel_.setWidgetTopBottom(appFrame_, toolbar_.getHeight()+1, Unit.PX, 0, Unit.PX);\n   }","id":28813,"modified_method":"@Override\n   public void showApp(ShinyApplicationParams params)\n   {\n      appParams_ = params;\n\n      if (appFrame_ != null)\n      {\n         rootPanel_.remove(appFrame_);\n         appFrame_ = null;\n      }\n      \n      urlBox_.setText(params.getUrl());\n      appFrame_ = new RStudioFrame(appParams_.getUrl());\n      appFrame_.setSize(\"100%\", \"100%\");\n      rootPanel_.add(appFrame_);\n      rootPanel_.setWidgetLeftRight(appFrame_,  0, Unit.PX, 0, Unit.PX);\n      rootPanel_.setWidgetTopBottom(appFrame_, toolbar_.getHeight()+1, Unit.PX, 0, Unit.PX);\n   }","commit_id":"0818e05be82e4f0a7b3287e4e413a5d7b634a90e","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      return new Toolbar(\n            new Widget[] {\n                  createImportMenu(),\n                  commands_.clearWorkspace().createToolbarButton()\n            },\n            new Widget[] {\n                  commands_.refreshWorkspace().createToolbarButton()\n            }\n      );\n   }","id":28814,"modified_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      Toolbar toolbar = new Toolbar();\n      toolbar.addLeftWidget(commands_.loadWorkspace().createToolbarButton());\n      toolbar.addLeftWidget(commands_.saveWorkspace().createToolbarButton());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(createImportMenu());\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.clearWorkspace().createToolbarButton());\n      \n      toolbar.addRightWidget(commands_.refreshWorkspace().createToolbarButton());\n      \n      return toolbar;\n   }","commit_id":"971eae2c32999bb8027b93aaaf58f980f612eace","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n\tpublic ImageBag read(byte[] bytes) throws IOException {\n\t\tString formatName = null;\n\n\t\tImageInputStream imageInputStream = null;\n\n\t\tRenderedImage renderedImage = null;\n\n\t\ttry {\n\t\t\timageInputStream = ImageIO.createImageInputStream(\n\t\t\t\tnew ByteArrayInputStream(bytes));\n\n\t\t\tIterator<ImageReader> iterator = ImageIO.getImageReaders(\n\t\t\t\timageInputStream);\n\n\t\t\tif (iterator.hasNext()) {\n\t\t\t\tImageReader imageReader = iterator.next();\n\n\t\t\t\timageReader.setInput(imageInputStream);\n\n\t\t\t\trenderedImage = imageReader.read(0);\n\t\t\t\tformatName = imageReader.getFormatName();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (imageInputStream != null) {\n\t\t\t\timageInputStream.close();\n\t\t\t}\n\t\t}\n\n\t\tformatName = StringUtil.toLowerCase(formatName);\n\n\t\tString type = TYPE_JPEG;\n\n\t\tif (formatName.contains(TYPE_BMP)) {\n\t\t\ttype = TYPE_BMP;\n\t\t}\n\t\telse if (formatName.contains(TYPE_GIF)) {\n\t\t\ttype = TYPE_GIF;\n\t\t}\n\t\telse if (formatName.contains(\"jpeg\") || type.equals(\"jpeg\")) {\n\t\t\ttype = TYPE_JPEG;\n\t\t}\n\t\telse if (formatName.contains(TYPE_PNG)) {\n\t\t\ttype = TYPE_PNG;\n\t\t}\n\t\telse if (formatName.contains(TYPE_TIFF)) {\n\t\t\ttype = TYPE_TIFF;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(type + \" is not supported\");\n\t\t}\n\n\t\treturn new ImageBag(renderedImage, type);\n\t}","id":28815,"modified_method":"@Override\n\tpublic ImageBag read(byte[] bytes) throws IOException {\n\t\tString formatName = null;\n\n\t\tImageInputStream imageInputStream = null;\n\n\t\tQueue<ImageReader> imageReaders = new LinkedList<ImageReader>();\n\n\t\tRenderedImage renderedImage = null;\n\n\t\ttry {\n\t\t\timageInputStream = ImageIO.createImageInputStream(\n\t\t\t\tnew ByteArrayInputStream(bytes));\n\n\t\t\tIterator<ImageReader> iterator = ImageIO.getImageReaders(\n\t\t\t\timageInputStream);\n\n\t\t\tboolean firstImageReader = true;\n\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tImageReader imageReader = iterator.next();\n\n\t\t\t\timageReaders.offer(imageReader);\n\n\t\t\t\tif (firstImageReader) {\n\t\t\t\t\timageReader.setInput(imageInputStream);\n\n\t\t\t\t\trenderedImage = imageReader.read(0);\n\n\t\t\t\t\tformatName = imageReader.getFormatName();\n\n\t\t\t\t\tfirstImageReader = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\twhile (!imageReaders.isEmpty()) {\n\t\t\t\tImageReader imageReader = imageReaders.poll();\n\n\t\t\t\timageReader.dispose();\n\t\t\t}\n\n\t\t\tif (imageInputStream != null) {\n\t\t\t\timageInputStream.close();\n\t\t\t}\n\t\t}\n\n\t\tformatName = StringUtil.toLowerCase(formatName);\n\n\t\tString type = TYPE_JPEG;\n\n\t\tif (formatName.contains(TYPE_BMP)) {\n\t\t\ttype = TYPE_BMP;\n\t\t}\n\t\telse if (formatName.contains(TYPE_GIF)) {\n\t\t\ttype = TYPE_GIF;\n\t\t}\n\t\telse if (formatName.contains(\"jpeg\") || type.equals(\"jpeg\")) {\n\t\t\ttype = TYPE_JPEG;\n\t\t}\n\t\telse if (formatName.contains(TYPE_PNG)) {\n\t\t\ttype = TYPE_PNG;\n\t\t}\n\t\telse if (formatName.contains(TYPE_TIFF)) {\n\t\t\ttype = TYPE_TIFF;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(type + \" is not supported\");\n\t\t}\n\n\t\treturn new ImageBag(renderedImage, type);\n\t}","commit_id":"7f221950c27bc6b0771003522e78bffb096c56bc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * We compress the payload if it is larger than <code>min_size<\/code>. In this case we add a header containing\n     * the original size before compression. Otherwise we add no header.<br/>\n     * Note that we compress either the entire buffer (if offset/length are not used), or a subset (if offset/length\n     * are used)\n     * @param evt\n     */\n    public void down(Event evt) {\n        if(evt.getType() == Event.MSG) {\n            Message msg=(Message)evt.getArg();\n            int length=msg.getLength(); // takes offset/length (if set) into account\n            if(length >= min_size) {\n                byte[] payload=msg.getRawBuffer(); // here we get the ref so we can avoid copying\n                byte[] compressed_payload=new byte[length];\n                int compressed_size;\n                int tmp_index=getDeflaterIndex();\n                Deflater deflater=deflater_pool[tmp_index]; // must be guaranteed to be non-null !\n                synchronized(deflater) {\n                    deflater.reset();\n                    deflater.setInput(payload, msg.getOffset(), length);\n                    deflater.finish();\n                    deflater.deflate(compressed_payload);\n                    compressed_size=deflater.getTotalOut();\n                }\n                byte[] new_payload=new byte[compressed_size];\n                System.arraycopy(compressed_payload, 0, new_payload, 0, compressed_size);\n                msg.setBuffer(new_payload);\n                msg.putHeader(name, new CompressHeader(length));\n                if(trace)\n                    log.trace(\"compressed payload from \" + length + \" bytes to \" + compressed_size + \" bytes (inflater #\" +\n                    tmp_index + \")\");\n            }\n        }\n        passDown(evt);\n    }","id":28816,"modified_method":"/**\n     * We compress the payload if it is larger than <code>min_size<\/code>. In this case we add a header containing\n     * the original size before compression. Otherwise we add no header.<br/>\n     * Note that we compress either the entire buffer (if offset/length are not used), or a subset (if offset/length\n     * are used)\n     * @param evt\n     */\n    public void down(Event evt) {\n        if(evt.getType() == Event.MSG) {\n            Message msg=(Message)evt.getArg();\n            int length=msg.getLength(); // takes offset/length (if set) into account\n            if(length >= min_size) {\n                byte[] payload=msg.getRawBuffer(); // here we get the ref so we can avoid copying\n                byte[] compressed_payload=new byte[length];\n                int compressed_size;\n                Deflater deflater=null;\n                try {\n                    deflater=deflater_pool.take();\n                    deflater.reset();\n                    deflater.setInput(payload, msg.getOffset(), length);\n                    deflater.finish();\n                    deflater.deflate(compressed_payload);\n                    compressed_size=deflater.getTotalOut();\n                    byte[] new_payload=new byte[compressed_size];\n                    System.arraycopy(compressed_payload, 0, new_payload, 0, compressed_size);\n                    msg.setBuffer(new_payload);\n                    msg.putHeader(name, new CompressHeader(length));\n                    if(trace)\n                        log.trace(\"compressed payload from \" + length + \" bytes to \" + compressed_size + \" bytes\");\n                }\n                catch(InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n                finally {\n                    if(deflater != null)\n                        deflater_pool.offer(deflater);\n                }\n            }\n        }\n        passDown(evt);\n    }","commit_id":"6b57079ae8b902f33eb6724a8610e2a40175b065","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean setProperties(Properties props) {\n        String str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"compression_level\");\n        if(str != null) {\n            compression_level=Integer.parseInt(str);\n            props.remove(\"compression_level\");\n        }\n\n        str=props.getProperty(\"min_size\");\n        if(str != null) {\n            min_size=Long.parseLong(str);\n            props.remove(\"min_size\");\n        }\n\n        str=props.getProperty(\"pool_size\");\n        if(str != null) {\n            pool_size=Integer.parseInt(str);\n            if(pool_size <= 0) {\n                log.warn(\"pool_size must be > 0, setting it to 1\");\n                pool_size=1;\n            }\n            props.remove(\"pool_size\");\n        }\n\n        if(props.size() > 0) {\n            log.error(\"the following properties are not recognized: \" + props);\n            return false;\n        }\n        return true;\n    }","id":28817,"modified_method":"public boolean setProperties(Properties props) {\n        String str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"compression_level\");\n        if(str != null) {\n            compression_level=Integer.parseInt(str);\n            props.remove(\"compression_level\");\n        }\n\n        str=props.getProperty(\"min_size\");\n        if(str != null) {\n            min_size=Long.parseLong(str);\n            props.remove(\"min_size\");\n        }\n\n        str=props.getProperty(\"pool_size\");\n        if(str != null) {\n            pool_size=Integer.parseInt(str);\n            if(pool_size <= 0) {\n                log.warn(\"pool_size must be > 0, setting it to 1\");\n                pool_size=1;\n            }\n            props.remove(\"pool_size\");\n        }\n\n        if(!props.isEmpty()) {\n            log.error(\"the following properties are not recognized: \" + props);\n            return false;\n        }\n        return true;\n    }","commit_id":"6b57079ae8b902f33eb6724a8610e2a40175b065","url":"https://github.com/belaban/JGroups"},{"original_method":"public void destroy() {\n        for(int i=0; i < deflater_pool.length; i++) {\n            Deflater deflater=deflater_pool[i];\n            deflater.end();\n        }\n        for(int i=0; i < inflater_pool.length; i++) {\n            Inflater inflater=inflater_pool[i];\n            inflater.end();\n        }\n    }","id":28818,"modified_method":"public void destroy() {\n        for(Deflater deflater: deflater_pool)\n            deflater.end();\n        for(Inflater inflater: inflater_pool)\n            inflater.end();\n    }","commit_id":"6b57079ae8b902f33eb6724a8610e2a40175b065","url":"https://github.com/belaban/JGroups"},{"original_method":"public void init() throws Exception {\n        deflater_pool=new Deflater[pool_size];\n        for(int i=0; i < deflater_pool.length; i++) {\n            deflater_pool[i]=new Deflater(compression_level);\n        }\n        inflater_pool=new Inflater[pool_size];\n        for(int i=0; i < inflater_pool.length; i++) {\n            inflater_pool[i]=new Inflater();\n        }\n    }","id":28819,"modified_method":"public void init() throws Exception {\n        deflater_pool=new ArrayBlockingQueue<Deflater>(pool_size);\n        for(int i=0; i < pool_size; i++) {\n            deflater_pool.add(new Deflater(compression_level));\n        }\n        inflater_pool=new ArrayBlockingQueue<Inflater>(pool_size);\n        for(int i=0; i < pool_size; i++) {\n            inflater_pool.add(new Inflater());\n        }\n    }","commit_id":"6b57079ae8b902f33eb6724a8610e2a40175b065","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * If there is no header, we pass the message up. Otherwise we uncompress the payload to its original size.\n     * @param evt\n     */\n    public void up(Event evt) {\n        if(evt.getType() == Event.MSG) {\n            Message msg=(Message)evt.getArg();\n            CompressHeader hdr=(CompressHeader)msg.removeHeader(name);\n            if(hdr != null) {\n                byte[] compressed_payload=msg.getRawBuffer();\n                if(compressed_payload != null && compressed_payload.length > 0) {\n                    int original_size=hdr.original_size;\n                    byte[] uncompressed_payload=new byte[original_size];\n                    int tmp_index=getInflaterIndex();\n                    Inflater inflater=inflater_pool[tmp_index];\n                    synchronized(inflater) {\n                        inflater.reset();\n                        inflater.setInput(compressed_payload, msg.getOffset(), msg.getLength());\n                        try {\n                            inflater.inflate(uncompressed_payload);\n                            if(trace)\n                                log.trace(\"uncompressed \" + compressed_payload.length + \" bytes to \" + original_size +\n                                        \" bytes (deflater #\" + tmp_index + \")\");\n                            msg.setBuffer(uncompressed_payload);\n                        }\n                        catch(DataFormatException e) {\n                            if(log.isErrorEnabled()) log.error(\"exception on uncompression\", e);\n                        }\n                    }\n                }\n            }\n        }\n        passUp(evt);\n    }","id":28820,"modified_method":"/**\n     * If there is no header, we pass the message up. Otherwise we uncompress the payload to its original size.\n     * @param evt\n     */\n    public void up(Event evt) {\n        if(evt.getType() == Event.MSG) {\n            Message msg=(Message)evt.getArg();\n            CompressHeader hdr=(CompressHeader)msg.getHeader(name);\n            if(hdr != null) {\n                byte[] compressed_payload=msg.getRawBuffer();\n                if(compressed_payload != null && compressed_payload.length > 0) {\n                    int original_size=hdr.original_size;\n                    byte[] uncompressed_payload=new byte[original_size];\n                    Inflater inflater=null;\n                    try {\n                        inflater=inflater_pool.take();\n                        inflater.reset();\n                        inflater.setInput(compressed_payload, msg.getOffset(), msg.getLength());\n                        try {\n                            inflater.inflate(uncompressed_payload);\n                            if(trace)\n                                log.trace(\"uncompressed \" + compressed_payload.length + \" bytes to \" + original_size +\n                                        \" bytes\");\n                            msg.setBuffer(uncompressed_payload);\n                        }\n                        catch(DataFormatException e) {\n                            if(log.isErrorEnabled()) log.error(\"exception on uncompression\", e);\n                        }\n                    }\n                    catch(InterruptedException e) {\n                        Thread.currentThread().interrupt(); // set the interrupt bit again, so caller can handle it\n                    }\n                    finally {\n                        if(inflater != null)\n                            inflater_pool.offer(inflater);\n                    }\n\n                }\n            }\n        }\n        passUp(evt);\n    }","commit_id":"6b57079ae8b902f33eb6724a8610e2a40175b065","url":"https://github.com/belaban/JGroups"},{"original_method":"private void configureViewer() {\n\t\tTreeViewer viewer = getTreeViewer();\n\t\tviewer.setAutoExpandLevel(1);\n\t\tviewer.setUseHashlookup(false);\n\t}","id":28821,"modified_method":"private void configureViewer() {\n\t\tTreeViewer viewer = getTreeViewer();\n\t\tviewer.setAutoExpandLevel(2);\n\t\tviewer.setUseHashlookup(false);\n\t}","commit_id":"cfb7018325da620beddca12ab084ba08e93eec7b","url":"https://github.com/eclipse/xtext"},{"original_method":"private void configureDocument() {\n\t\tif (sourceViewer != null) {\n\t\t\tIDocument document = sourceViewer.getDocument();\n\t\t\tIXtextDocument xtextDocument = XtextDocumentUtil.get(document);\n\n\t\t\t// TODO: it would be better to have NodeContentAdapter update the\n\t\t\t// parts of the outline model that need updates instead of\n\t\t\t// installing a model listener.\n\t\t\tinstallModelListener();\n\n\t\t\tinternalSetInput(xtextDocument);\n\t\t}\n\t}","id":28822,"modified_method":"private void configureDocument() {\n\t\tif (sourceViewer != null) {\n\t\t\tIDocument document = sourceViewer.getDocument();\n\t\t\tIXtextDocument xtextDocument = XtextDocumentUtil.get(document);\n\n\t\t\t// TODO: it would be better to have NodeContentAdapter update the\n\t\t\t// parts of the outline model that need updates instead of\n\t\t\t// installing a model listener.\n\t\t\tinstallModelListener();\n\n\t\t\tinternalSetInput(xtextDocument, true);\n\t\t}\n\t}","commit_id":"cfb7018325da620beddca12ab084ba08e93eec7b","url":"https://github.com/eclipse/xtext"},{"original_method":"private void internalSetInput(IXtextDocument xtextDocument) {\n\t\tTreeViewer tree = getTreeViewer();\n\t\tif (tree != null) {\n\t\t\ttree.setInput(xtextDocument);\n\t\t}\n\t}","id":28823,"modified_method":"private void internalSetInput(IXtextDocument xtextDocument, boolean initial) {\n\t\tTreeViewer tree = getTreeViewer();\n\t\tif (tree != null) {\n\t\t\tObject[] expandedElements = null;\n\t\t\texpandedElements = tree.getExpandedElements();\n\n\t\t\ttree.setInput(xtextDocument);\n\t\t\t\n\t\t\tif (expandedElements != null && expandedElements.length > 0)\n\t\t\t\ttree.setExpandedElements(expandedElements);\n\t\t}\n\t}","commit_id":"cfb7018325da620beddca12ab084ba08e93eec7b","url":"https://github.com/eclipse/xtext"},{"original_method":"private void refresh() {\n\t\trunInSWTThread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tTreeViewer tv = getTreeViewer();\n\t\t\t\tif (tv != null) {\n\t\t\t\t\tIDocument document = sourceViewer.getDocument();\n\t\t\t\t\tinternalSetInput(XtextDocumentUtil.get(document));\n\t\t\t\t\ttv.refresh();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","id":28824,"modified_method":"private void refresh() {\n\t\trunInSWTThread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tTreeViewer tv = getTreeViewer();\n\t\t\t\tif (tv != null) {\n\t\t\t\t\tIDocument document = sourceViewer.getDocument();\n\t\t\t\t\tinternalSetInput(XtextDocumentUtil.get(document), false);\n\t\t\t\t\ttv.refresh();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","commit_id":"cfb7018325da620beddca12ab084ba08e93eec7b","url":"https://github.com/eclipse/xtext"},{"original_method":"private void configureViewer() {\n\t\tTreeViewer viewer = getTreeViewer();\n\t\tviewer.setAutoExpandLevel(1);\n\t\tviewer.setUseHashlookup(false);\n\t}","id":28825,"modified_method":"private void configureViewer() {\n\t\tTreeViewer viewer = getTreeViewer();\n\t\tviewer.setAutoExpandLevel(2);\n\t\tviewer.setUseHashlookup(false);\n\t}","commit_id":"f14ebd6f2be5e452b27c74a006a722a652de4786","url":"https://github.com/eclipse/xtext"},{"original_method":"private void refresh() {\n\t\trunInSWTThread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tTreeViewer tv = getTreeViewer();\n\t\t\t\tif (tv != null) {\n\t\t\t\t\tIDocument document = sourceViewer.getDocument();\n\t\t\t\t\tinternalSetInput(XtextDocumentUtil.get(document));\n\t\t\t\t\ttv.refresh();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","id":28826,"modified_method":"private void refresh() {\n\t\trunInSWTThread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tTreeViewer tv = getTreeViewer();\n\t\t\t\tif (tv != null) {\n\t\t\t\t\tIDocument document = sourceViewer.getDocument();\n\t\t\t\t\tinternalSetInput(XtextDocumentUtil.get(document), false);\n\t\t\t\t\ttv.refresh();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","commit_id":"f14ebd6f2be5e452b27c74a006a722a652de4786","url":"https://github.com/eclipse/xtext"},{"original_method":"private void configureDocument() {\n\t\tif (sourceViewer != null) {\n\t\t\tIDocument document = sourceViewer.getDocument();\n\t\t\tIXtextDocument xtextDocument = XtextDocumentUtil.get(document);\n\n\t\t\t// TODO: it would be better to have NodeContentAdapter update the\n\t\t\t// parts of the outline model that need updates instead of\n\t\t\t// installing a model listener.\n\t\t\tinstallModelListener();\n\n\t\t\tinternalSetInput(xtextDocument);\n\t\t}\n\t}","id":28827,"modified_method":"private void configureDocument() {\n\t\tif (sourceViewer != null) {\n\t\t\tIDocument document = sourceViewer.getDocument();\n\t\t\tIXtextDocument xtextDocument = XtextDocumentUtil.get(document);\n\n\t\t\t// TODO: it would be better to have NodeContentAdapter update the\n\t\t\t// parts of the outline model that need updates instead of\n\t\t\t// installing a model listener.\n\t\t\tinstallModelListener();\n\n\t\t\tinternalSetInput(xtextDocument, true);\n\t\t}\n\t}","commit_id":"f14ebd6f2be5e452b27c74a006a722a652de4786","url":"https://github.com/eclipse/xtext"},{"original_method":"private void internalSetInput(IXtextDocument xtextDocument) {\n\t\tTreeViewer tree = getTreeViewer();\n\t\tif (tree != null) {\n\t\t\ttree.setInput(xtextDocument);\n\t\t}\n\t}","id":28828,"modified_method":"private void internalSetInput(IXtextDocument xtextDocument, boolean initial) {\n\t\tTreeViewer tree = getTreeViewer();\n\t\tif (tree != null) {\n\t\t\tObject[] expandedElements = null;\n\t\t\texpandedElements = tree.getExpandedElements();\n\n\t\t\ttree.setInput(xtextDocument);\n\t\t\t\n\t\t\tif (expandedElements != null && expandedElements.length > 0)\n\t\t\t\ttree.setExpandedElements(expandedElements);\n\t\t}\n\t}","commit_id":"f14ebd6f2be5e452b27c74a006a722a652de4786","url":"https://github.com/eclipse/xtext"},{"original_method":"public void destroy() {\n        for(int i=0; i < deflater_pool.length; i++) {\n            Deflater deflater=deflater_pool[i];\n            deflater.end();\n        }\n        for(int i=0; i < inflater_pool.length; i++) {\n            Inflater inflater=inflater_pool[i];\n            inflater.end();\n        }\n    }","id":28829,"modified_method":"public void destroy() {\n        for(Deflater deflater: deflater_pool)\n            deflater.end();\n        for(Inflater inflater: inflater_pool)\n            inflater.end();\n    }","commit_id":"28b870e0ad41d261250a647e301ed0d6852d01f4","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * We compress the payload if it is larger than <code>min_size<\/code>. In this case we add a header containing\n     * the original size before compression. Otherwise we add no header.<br/>\n     * Note that we compress either the entire buffer (if offset/length are not used), or a subset (if offset/length\n     * are used)\n     * @param evt\n     */\n    public void down(Event evt) {\n        if(evt.getType() == Event.MSG) {\n            Message msg=(Message)evt.getArg();\n            int length=msg.getLength(); // takes offset/length (if set) into account\n            if(length >= min_size) {\n                byte[] payload=msg.getRawBuffer(); // here we get the ref so we can avoid copying\n                byte[] compressed_payload=new byte[length];\n                int compressed_size;\n                int tmp_index=getDeflaterIndex();\n                Deflater deflater=deflater_pool[tmp_index]; // must be guaranteed to be non-null !\n                synchronized(deflater) {\n                    deflater.reset();\n                    deflater.setInput(payload, msg.getOffset(), length);\n                    deflater.finish();\n                    deflater.deflate(compressed_payload);\n                    compressed_size=deflater.getTotalOut();\n                }\n                byte[] new_payload=new byte[compressed_size];\n                System.arraycopy(compressed_payload, 0, new_payload, 0, compressed_size);\n                msg.setBuffer(new_payload);\n                msg.putHeader(name, new CompressHeader(length));\n                if(trace)\n                    log.trace(\"compressed payload from \" + length + \" bytes to \" + compressed_size + \" bytes (inflater #\" +\n                    tmp_index + \")\");\n            }\n        }\n        passDown(evt);\n    }","id":28830,"modified_method":"/**\n     * We compress the payload if it is larger than <code>min_size<\/code>. In this case we add a header containing\n     * the original size before compression. Otherwise we add no header.<br/>\n     * Note that we compress either the entire buffer (if offset/length are not used), or a subset (if offset/length\n     * are used)\n     * @param evt\n     */\n    public void down(Event evt) {\n        if(evt.getType() == Event.MSG) {\n            Message msg=(Message)evt.getArg();\n            int length=msg.getLength(); // takes offset/length (if set) into account\n            if(length >= min_size) {\n                byte[] payload=msg.getRawBuffer(); // here we get the ref so we can avoid copying\n                byte[] compressed_payload=new byte[length];\n                int compressed_size;\n                Deflater deflater=null;\n                try {\n                    deflater=deflater_pool.take();\n                    deflater.reset();\n                    deflater.setInput(payload, msg.getOffset(), length);\n                    deflater.finish();\n                    deflater.deflate(compressed_payload);\n                    compressed_size=deflater.getTotalOut();\n                    byte[] new_payload=new byte[compressed_size];\n                    System.arraycopy(compressed_payload, 0, new_payload, 0, compressed_size);\n                    msg.setBuffer(new_payload);\n                    msg.putHeader(name, new CompressHeader(length));\n                    if(trace)\n                        log.trace(\"compressed payload from \" + length + \" bytes to \" + compressed_size + \" bytes\");\n                }\n                catch(InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n                finally {\n                    if(deflater != null)\n                        deflater_pool.offer(deflater);\n                }\n            }\n        }\n        passDown(evt);\n    }","commit_id":"28b870e0ad41d261250a647e301ed0d6852d01f4","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean setProperties(Properties props) {\n        String str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"compression_level\");\n        if(str != null) {\n            compression_level=Integer.parseInt(str);\n            props.remove(\"compression_level\");\n        }\n\n        str=props.getProperty(\"min_size\");\n        if(str != null) {\n            min_size=Long.parseLong(str);\n            props.remove(\"min_size\");\n        }\n\n        str=props.getProperty(\"pool_size\");\n        if(str != null) {\n            pool_size=Integer.parseInt(str);\n            if(pool_size <= 0) {\n                log.warn(\"pool_size must be > 0, setting it to 1\");\n                pool_size=1;\n            }\n            props.remove(\"pool_size\");\n        }\n\n        if(props.size() > 0) {\n            log.error(\"the following properties are not recognized: \" + props);\n            return false;\n        }\n        return true;\n    }","id":28831,"modified_method":"public boolean setProperties(Properties props) {\n        String str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"compression_level\");\n        if(str != null) {\n            compression_level=Integer.parseInt(str);\n            props.remove(\"compression_level\");\n        }\n\n        str=props.getProperty(\"min_size\");\n        if(str != null) {\n            min_size=Long.parseLong(str);\n            props.remove(\"min_size\");\n        }\n\n        str=props.getProperty(\"pool_size\");\n        if(str != null) {\n            pool_size=Integer.parseInt(str);\n            if(pool_size <= 0) {\n                log.warn(\"pool_size must be > 0, setting it to 1\");\n                pool_size=1;\n            }\n            props.remove(\"pool_size\");\n        }\n\n        if(!props.isEmpty()) {\n            log.error(\"the following properties are not recognized: \" + props);\n            return false;\n        }\n        return true;\n    }","commit_id":"28b870e0ad41d261250a647e301ed0d6852d01f4","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * If there is no header, we pass the message up. Otherwise we uncompress the payload to its original size.\n     * @param evt\n     */\n    public void up(Event evt) {\n        if(evt.getType() == Event.MSG) {\n            Message msg=(Message)evt.getArg();\n            CompressHeader hdr=(CompressHeader)msg.removeHeader(name);\n            if(hdr != null) {\n                byte[] compressed_payload=msg.getRawBuffer();\n                if(compressed_payload != null && compressed_payload.length > 0) {\n                    int original_size=hdr.original_size;\n                    byte[] uncompressed_payload=new byte[original_size];\n                    int tmp_index=getInflaterIndex();\n                    Inflater inflater=inflater_pool[tmp_index];\n                    synchronized(inflater) {\n                        inflater.reset();\n                        inflater.setInput(compressed_payload, msg.getOffset(), msg.getLength());\n                        try {\n                            inflater.inflate(uncompressed_payload);\n                            if(trace)\n                                log.trace(\"uncompressed \" + compressed_payload.length + \" bytes to \" + original_size +\n                                        \" bytes (deflater #\" + tmp_index + \")\");\n                            msg.setBuffer(uncompressed_payload);\n                        }\n                        catch(DataFormatException e) {\n                            if(log.isErrorEnabled()) log.error(\"exception on uncompression\", e);\n                        }\n                    }\n                }\n            }\n        }\n        passUp(evt);\n    }","id":28832,"modified_method":"/**\n     * If there is no header, we pass the message up. Otherwise we uncompress the payload to its original size.\n     * @param evt\n     */\n    public void up(Event evt) {\n        if(evt.getType() == Event.MSG) {\n            Message msg=(Message)evt.getArg();\n            CompressHeader hdr=(CompressHeader)msg.getHeader(name);\n            if(hdr != null) {\n                byte[] compressed_payload=msg.getRawBuffer();\n                if(compressed_payload != null && compressed_payload.length > 0) {\n                    int original_size=hdr.original_size;\n                    byte[] uncompressed_payload=new byte[original_size];\n                    Inflater inflater=null;\n                    try {\n                        inflater=inflater_pool.take();\n                        inflater.reset();\n                        inflater.setInput(compressed_payload, msg.getOffset(), msg.getLength());\n                        try {\n                            inflater.inflate(uncompressed_payload);\n                            if(trace)\n                                log.trace(\"uncompressed \" + compressed_payload.length + \" bytes to \" + original_size +\n                                        \" bytes\");\n                            msg.setBuffer(uncompressed_payload);\n                        }\n                        catch(DataFormatException e) {\n                            if(log.isErrorEnabled()) log.error(\"exception on uncompression\", e);\n                        }\n                    }\n                    catch(InterruptedException e) {\n                        Thread.currentThread().interrupt(); // set the interrupt bit again, so caller can handle it\n                    }\n                    finally {\n                        if(inflater != null)\n                            inflater_pool.offer(inflater);\n                    }\n\n                }\n            }\n        }\n        passUp(evt);\n    }","commit_id":"28b870e0ad41d261250a647e301ed0d6852d01f4","url":"https://github.com/belaban/JGroups"},{"original_method":"public void init() throws Exception {\n        deflater_pool=new Deflater[pool_size];\n        for(int i=0; i < deflater_pool.length; i++) {\n            deflater_pool[i]=new Deflater(compression_level);\n        }\n        inflater_pool=new Inflater[pool_size];\n        for(int i=0; i < inflater_pool.length; i++) {\n            inflater_pool[i]=new Inflater();\n        }\n    }","id":28833,"modified_method":"public void init() throws Exception {\n        deflater_pool=new ArrayBlockingQueue<Deflater>(pool_size);\n        for(int i=0; i < pool_size; i++) {\n            deflater_pool.add(new Deflater(compression_level));\n        }\n        inflater_pool=new ArrayBlockingQueue<Inflater>(pool_size);\n        for(int i=0; i < pool_size; i++) {\n            inflater_pool.add(new Inflater());\n        }\n    }","commit_id":"28b870e0ad41d261250a647e301ed0d6852d01f4","url":"https://github.com/belaban/JGroups"},{"original_method":"protected Element getDynamicContentElement(\n\t\t\tElement dynamicElementElement, Locale locale, int index) {\n\n\t\t\tString languageId = LocaleUtil.toLanguageId(locale);\n\n\t\t\tXPath dynamicContentXPath = SAXReaderUtil.createXPath(\n\t\t\t\t\"dynamic-content[(@language-id='\" + languageId + \"')]\");\n\n\t\t\tList<Node> nodes = (List<Node>)dynamicContentXPath.selectNodes(\n\t\t\t\tdynamicElementElement);\n\n\t\t\treturn (Element)nodes.get(index);\n\t\t}","id":28834,"modified_method":"protected Element getDynamicContentElement(\n\t\t\tElement dynamicElementElement, Locale locale, int index) {\n\n\t\t\tString languageId = LocaleUtil.toLanguageId(locale);\n\n\t\t\tXPath dynamicContentXPath = SAXReaderUtil.createXPath(\n\t\t\t\t\"dynamic-content[(@language-id='\" + languageId + \"')]\");\n\n\t\t\tList<Node> nodes = dynamicContentXPath.selectNodes(\n\t\t\t\tdynamicElementElement);\n\n\t\t\treturn (Element)nodes.get(index);\n\t\t}","commit_id":"56e6643a6ce08203e87af0f0042a92a6234430a3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Scan a Document to find out the ranges of attributes.\n\t * All Documents must be scanned before generating the ARFF\n\t * header and instances.\n\t *\n\t * @param document the Document\n\t * @param appName  the application name\n\t */\n\tpublic void scan(Document document, final String appName) throws MissingNodeException, IOException {\n\t\tList<Element> bugInstanceList = getBugInstanceList(document);\n\n\t\tfor (final Element element : bugInstanceList) {\n\t\t\tscanAttributeList(new AttributeCallback() {\n\t\t\t\tpublic void apply(Attribute attribute) throws MissingNodeException {\n\t\t\t\t\tattribute.scan(element, appName);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}","id":28835,"modified_method":"/**\n\t * Scan a Document to find out the ranges of attributes.\n\t * All Documents must be scanned before generating the ARFF\n\t * header and instances.\n\t *\n\t * @param document the Document\n\t * @param appName  the application name\n\t */\n\tpublic void scan(Document document, final String appName) throws MissingNodeException, IOException {\n\t\tList<Element> bugInstanceList = getBugInstanceList(document);\n\n\t\tfor (Iterator<Element> i = bugInstanceList.iterator(); i.hasNext(); ) {\n\t\t\tfinal Element element = (Element) i.next();\n\t\t\tscanAttributeList(new AttributeCallback() {\n\t\t\t\tpublic void apply(Attribute attribute) throws MissingNodeException {\n\t\t\t\t\tattribute.scan(element, appName);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}","commit_id":"0e10164ad5e1318fb52c35cd2ea6dab7737ab41e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void init() throws PluginException {\n\t\t// Plugin descriptor (a.k.a, \"findbugs.xml\").  Defines\n\t\t// the bug detectors and bug patterns that the plugin provides.\n\t\tDocument pluginDescriptor;\n\t\t\n\t\t// Unique plugin id\n\t\tString pluginId;\n\n\t\t// List of message translation files in decreasing order of precedence\n\t\tArrayList<Document> messageCollectionList = new ArrayList<Document>();\n\n\t\t// Read the plugin descriptor\n\t\ttry {\n\t\t\tURL descriptorURL = findResource(\"findbugs.xml\");\n\t\t\tif (descriptorURL == null)\n\t\t\t\tthrow new PluginException(\"Couldn't find \\\"findbugs.xml\\\" in plugin\");\n\n\t\t\tSAXReader reader = new SAXReader();\n\t\t\tpluginDescriptor = reader.read(descriptorURL);\n\t\t} catch (DocumentException e) {\n\t\t\tthrow new PluginException(\"Couldn't parse \\\"findbugs.xml\\\"\", e);\n\t\t}\n\t\t\n\t\t// Get the unique plugin id (or generate one, if none is present)\n\t\tpluginId = pluginDescriptor.valueOf(\"/FindbugsPlugin/@pluginid\");\n\t\tif (pluginId.equals(\"\")) {\n\t\t\tsynchronized (PluginLoader.class) {\n\t\t\t\tpluginId = \"plugin\" + nextUnknownId++;\n\t\t\t}\n\t\t}\n\n\t\t// See if the plugin is enabled or disabled by default.\n\t\t// Note that if there is no \"defaultenabled\" attribute,\n\t\t// then we assume that the plugin IS enabled by default.\n\t\tString defaultEnabled = pluginDescriptor.valueOf(\"/FindbugsPlugin/@defaultenabled\");\n\t\tboolean pluginEnabled = defaultEnabled.equals(\"\") || Boolean.valueOf(defaultEnabled).booleanValue();\n\n\t\t// Load the message collections\n\t\ttry {\n\t\t\tLocale locale = Locale.getDefault();\n\t\t\tString language = locale.getLanguage();\n\t\t\tString country = locale.getCountry();\n\n\t\t\tif (country != null)\n\t\t\t\taddCollection(messageCollectionList, \"messages_\" + language + \"_\" + country + \".xml\");\n\t\t\taddCollection(messageCollectionList, \"messages_\" + language + \".xml\");\n\t\t\taddCollection(messageCollectionList, \"messages.xml\");\n\t\t} catch (DocumentException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new PluginException(\"Couldn't parse \\\"messages.xml\\\"\", e);\n\t\t}\n\t\t\n\t\t// Create the Plugin object (but don't assign to the plugin field yet,\n\t\t// since we're still not sure if everything will load correctly)\n\t\tPlugin plugin = new Plugin(pluginId);\n\t\tplugin.setEnabled(pluginEnabled);\n\n\t\t// Set provider and website, if specified\n\t\tString provider = pluginDescriptor.valueOf(\"/FindbugsPlugin/@provider\");\n\t\tif (!provider.equals(\"\"))\n\t\t\tplugin.setProvider(provider);\n\t\tString website = pluginDescriptor.valueOf(\"/FindbugsPlugin/@website\");\n\t\tif (!website.equals(\"\"))\n\t\t\tplugin.setWebsite(website);\n\n\t\t// Set short description, if specified\n\t\tNode pluginShortDesc = null;\n\t\ttry {\n\t\t\tpluginShortDesc = findMessageNode(\n\t\t\t\t\tmessageCollectionList,\n\t\t\t\t\t\"/MessageCollection/Plugin/ShortDescription\",\n\t\t\t\t\t\"no plugin description\");\n\t\t} catch (PluginException e) {\n\t\t\t// Missing description is not fatal, so ignore\n\t\t}\n\t\tif (pluginShortDesc != null) {\n\t\t\tplugin.setShortDescription(pluginShortDesc.getText());\n\t\t}\n\n\t\t// Create a DetectorFactory for all Detector nodes\n\t\ttry {\n\t\t\tList<Node> detectorNodeList = pluginDescriptor.selectNodes(\"/FindbugsPlugin/Detector\");\n\t\t\tint detectorCount = 0;\n\t\t\tfor (Node detectorNode : detectorNodeList) {\n\t\t\t\tString className = detectorNode.valueOf(\"@class\");\n\t\t\t\tString speed = detectorNode.valueOf(\"@speed\");\n\t\t\t\tString disabled = detectorNode.valueOf(\"@disabled\");\n\t\t\t\tString reports = detectorNode.valueOf(\"@reports\");\n\t\t\t\tString requireJRE = detectorNode.valueOf(\"@requirejre\");\n\t\t\t\tString hidden = detectorNode.valueOf(\"@hidden\");\n\n\t\t\t\t//System.out.println(\"Found detector: class=\"+className+\", disabled=\"+disabled);\n\n\t\t\t\t// Create DetectorFactory for the detector\n\t\t\t\t//Class <? extends Detector>detectorClass = loadClass(className).asSubclass(Detector.class);\n\t\t\t\tClass detectorClass = loadClass(className);\n\t\t\t\tif (!Detector.class.isAssignableFrom(detectorClass))\n\t\t\t\t\tthrow new PluginException(\"Class \" + className + \" does not implement Detector\");\n\t\t\t\tDetectorFactory factory = new DetectorFactory(\n\t\t\t\t\t\tplugin,\n\t\t\t\t\t\t(Class<? extends Detector>) detectorClass, !disabled.equals(\"true\"),\n\t\t\t\t\t\tspeed, reports, requireJRE);\n\t\t\t\tif (Boolean.valueOf(hidden).booleanValue())\n\t\t\t\t\tfactory.setHidden(true);\n\t\t\t\tfactory.setPositionSpecifiedInPluginDescriptor(detectorCount++);\n\t\t\t\tplugin.addDetectorFactory(factory);\n\n\t\t\t\t// Find Detector node in one of the messages files,\n\t\t\t\t// to get the detail HTML.\n\t\t\t\tNode node = findMessageNode(messageCollectionList,\n\t\t\t\t\t\t\"/MessageCollection/Detector[@class='\" + className + \"']/Details\",\n\t\t\t\t\t\t\"Missing Detector description for detector \" + className);\n\n\t\t\t\tElement details = (Element) node;\n\t\t\t\tString detailHTML = details.getText();\n\t\t\t\tStringBuffer buf = new StringBuffer();\n\t\t\t\tbuf.append(\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\">\\n\");\n\t\t\t\tbuf.append(\"<HTML><HEAD><TITLE>Detector Description<\/TITLE><\/HEAD><BODY>\\n\");\n\t\t\t\tbuf.append(detailHTML);\n\t\t\t\tbuf.append(\"<\/BODY><\/HTML>\\n\");\n\t\t\t\tfactory.setDetailHTML(buf.toString());\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tthrow new PluginException(\"Could not instantiate detector class: \" + e, e);\n\t\t}\n\n\t\t// Create ordering constraints\n\t\tNode orderingConstraintsNode =\n\t\t\tpluginDescriptor.selectSingleNode(\"/FindbugsPlugin/OrderingConstraints\");\n\t\tif (orderingConstraintsNode != null) {\n\t\t\t// Get inter-pass and intra-pass constraints\n\t\t\tfor (Element constraintElement : (Iterable<Element>) orderingConstraintsNode.selectNodes(\"./SplitPass|./WithinPass\")) {\n\t\t\t\t// Create the selectors which determine which detectors are\n\t\t\t\t// involved in the constraint\n\t\t\t\tDetectorFactorySelector earlierSelector = getConstraintSelector(\n\t\t\t\t\t\tconstraintElement, plugin, \"Earlier\", \"EarlierCategory\");\n\t\t\t\tDetectorFactorySelector laterSelector = getConstraintSelector(\n\t\t\t\t\t\tconstraintElement, plugin, \"Later\", \"LaterCategory\");\n\n\t\t\t\t// Create the constraint\n\t\t\t\tDetectorOrderingConstraint constraint = new DetectorOrderingConstraint(\n\t\t\t\t\t\tearlierSelector, laterSelector);\n\n\t\t\t\t// Add the constraint to the plugin\n\t\t\t\tif (constraintElement.getName().equals(\"SplitPass\"))\n\t\t\t\t\tplugin.addInterPassOrderingConstraint(constraint);\n\t\t\t\telse\n\t\t\t\t\tplugin.addIntraPassOrderingConstraint(constraint);\n\t\t\t}\n\t\t}\n\n\t\t// Create BugPatterns\n\t\tList<Node> bugPatternNodeList = pluginDescriptor.selectNodes(\"/FindbugsPlugin/BugPattern\");\n\t\tfor (Node bugPatternNode : bugPatternNodeList) {\n\t\t\tString type = bugPatternNode.valueOf(\"@type\");\n\t\t\tString abbrev = bugPatternNode.valueOf(\"@abbrev\");\n\t\t\tString category = bugPatternNode.valueOf(\"@category\");\n\t\t\tString experimental = bugPatternNode.valueOf(\"@experimental\");\n\n\t\t\t// Find the matching element in messages.xml (or translations)\n\t\t\tString query = \"/MessageCollection/BugPattern[@type='\" + type + \"']\";\n\t\t\tNode messageNode = findMessageNode(messageCollectionList, query,\n\t\t\t\t\t\"messages.xml missing BugPattern element for type \" + type);\n\n\t\t\tString shortDesc = getChildText(messageNode, \"ShortDescription\");\n\t\t\tString longDesc = getChildText(messageNode, \"LongDescription\");\n\t\t\tString detailText = getChildText(messageNode, \"Details\");\n\n\t\t\tBugPattern bugPattern = new BugPattern(type, abbrev, category,\n\t\t\t\t\tBoolean.valueOf(experimental).booleanValue(),\n\t\t\t\t\tshortDesc, longDesc, detailText);\n\t\t\tplugin.addBugPattern(bugPattern);\n\t\t}\n\n\t\t// Create BugCodes\n\t\tSet<String> definedBugCodes = new HashSet<String>();\n\t\tfor (Document messageCollection : messageCollectionList) {\n\t\t\tList<Node> bugCodeNodeList = messageCollection.selectNodes(\"/MessageCollection/BugCode\");\n\t\t\tfor (Node bugCodeNode : bugCodeNodeList) {\n\t\t\t\tString abbrev = bugCodeNode.valueOf(\"@abbrev\");\n\t\t\t\tif (abbrev.equals(\"\"))\n\t\t\t\t\tthrow new PluginException(\"BugCode element with missing abbrev attribute\");\n\t\t\t\tif (definedBugCodes.contains(abbrev))\n\t\t\t\t\tcontinue;\n\t\t\t\tString description = bugCodeNode.getText();\n\t\t\t\tBugCode bugCode = new BugCode(abbrev, description);\n\t\t\t\tplugin.addBugCode(bugCode);\n\t\t\t\tdefinedBugCodes.add(abbrev);\n\t\t\t}\n\n\t\t}\n\t\t\n\t\t// Success!\n\t\t// Assign to the plugin field, so getPlugin() can return the\n\t\t// new Plugin object.\n\t\tthis.plugin = plugin;\n\n\t}","id":28836,"modified_method":"private void init() throws PluginException {\n\t\t// Plugin descriptor (a.k.a, \"findbugs.xml\").  Defines\n\t\t// the bug detectors and bug patterns that the plugin provides.\n\t\tDocument pluginDescriptor;\n\t\t\n\t\t// Unique plugin id\n\t\tString pluginId;\n\n\t\t// List of message translation files in decreasing order of precedence\n\t\tArrayList<Document> messageCollectionList = new ArrayList<Document>();\n\n\t\t// Read the plugin descriptor\n\t\ttry {\n\t\t\tURL descriptorURL = findResource(\"findbugs.xml\");\n\t\t\tif (descriptorURL == null)\n\t\t\t\tthrow new PluginException(\"Couldn't find \\\"findbugs.xml\\\" in plugin\");\n\n\t\t\tSAXReader reader = new SAXReader();\n\t\t\tpluginDescriptor = reader.read(descriptorURL);\n\t\t} catch (DocumentException e) {\n\t\t\tthrow new PluginException(\"Couldn't parse \\\"findbugs.xml\\\"\", e);\n\t\t}\n\t\t\n\t\t// Get the unique plugin id (or generate one, if none is present)\n\t\tpluginId = pluginDescriptor.valueOf(\"/FindbugsPlugin/@pluginid\");\n\t\tif (pluginId.equals(\"\")) {\n\t\t\tsynchronized (PluginLoader.class) {\n\t\t\t\tpluginId = \"plugin\" + nextUnknownId++;\n\t\t\t}\n\t\t}\n\n\t\t// See if the plugin is enabled or disabled by default.\n\t\t// Note that if there is no \"defaultenabled\" attribute,\n\t\t// then we assume that the plugin IS enabled by default.\n\t\tString defaultEnabled = pluginDescriptor.valueOf(\"/FindbugsPlugin/@defaultenabled\");\n\t\tboolean pluginEnabled = defaultEnabled.equals(\"\") || Boolean.valueOf(defaultEnabled).booleanValue();\n\n\t\t// Load the message collections\n\t\ttry {\n\t\t\tLocale locale = Locale.getDefault();\n\t\t\tString language = locale.getLanguage();\n\t\t\tString country = locale.getCountry();\n\n\t\t\tif (country != null)\n\t\t\t\taddCollection(messageCollectionList, \"messages_\" + language + \"_\" + country + \".xml\");\n\t\t\taddCollection(messageCollectionList, \"messages_\" + language + \".xml\");\n\t\t\taddCollection(messageCollectionList, \"messages.xml\");\n\t\t} catch (DocumentException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new PluginException(\"Couldn't parse \\\"messages.xml\\\"\", e);\n\t\t}\n\t\t\n\t\t// Create the Plugin object (but don't assign to the plugin field yet,\n\t\t// since we're still not sure if everything will load correctly)\n\t\tPlugin plugin = new Plugin(pluginId);\n\t\tplugin.setEnabled(pluginEnabled);\n\n\t\t// Set provider and website, if specified\n\t\tString provider = pluginDescriptor.valueOf(\"/FindbugsPlugin/@provider\");\n\t\tif (!provider.equals(\"\"))\n\t\t\tplugin.setProvider(provider);\n\t\tString website = pluginDescriptor.valueOf(\"/FindbugsPlugin/@website\");\n\t\tif (!website.equals(\"\"))\n\t\t\tplugin.setWebsite(website);\n\n\t\t// Set short description, if specified\n\t\tNode pluginShortDesc = null;\n\t\ttry {\n\t\t\tpluginShortDesc = findMessageNode(\n\t\t\t\t\tmessageCollectionList,\n\t\t\t\t\t\"/MessageCollection/Plugin/ShortDescription\",\n\t\t\t\t\t\"no plugin description\");\n\t\t} catch (PluginException e) {\n\t\t\t// Missing description is not fatal, so ignore\n\t\t}\n\t\tif (pluginShortDesc != null) {\n\t\t\tplugin.setShortDescription(pluginShortDesc.getText());\n\t\t}\n\n\t\t// Create a DetectorFactory for all Detector nodes\n\t\ttry {\n\t\t\tList<Node> detectorNodeList = pluginDescriptor.selectNodes(\"/FindbugsPlugin/Detector\");\n\t\t\tint detectorCount = 0;\n\t\t\tfor (Node detectorNode : detectorNodeList) {\n\t\t\t\tString className = detectorNode.valueOf(\"@class\");\n\t\t\t\tString speed = detectorNode.valueOf(\"@speed\");\n\t\t\t\tString disabled = detectorNode.valueOf(\"@disabled\");\n\t\t\t\tString reports = detectorNode.valueOf(\"@reports\");\n\t\t\t\tString requireJRE = detectorNode.valueOf(\"@requirejre\");\n\t\t\t\tString hidden = detectorNode.valueOf(\"@hidden\");\n\n\t\t\t\t//System.out.println(\"Found detector: class=\"+className+\", disabled=\"+disabled);\n\n\t\t\t\t// Create DetectorFactory for the detector\n\t\t\t\t//Class <? extends Detector>detectorClass = loadClass(className).asSubclass(Detector.class);\n\t\t\t\tClass detectorClass = loadClass(className);\n\t\t\t\tif (!Detector.class.isAssignableFrom(detectorClass))\n\t\t\t\t\tthrow new PluginException(\"Class \" + className + \" does not implement Detector\");\n\t\t\t\tDetectorFactory factory = new DetectorFactory(\n\t\t\t\t\t\tplugin,\n\t\t\t\t\t\t(Class<? extends Detector>) detectorClass, !disabled.equals(\"true\"),\n\t\t\t\t\t\tspeed, reports, requireJRE);\n\t\t\t\tif (Boolean.valueOf(hidden).booleanValue())\n\t\t\t\t\tfactory.setHidden(true);\n\t\t\t\tfactory.setPositionSpecifiedInPluginDescriptor(detectorCount++);\n\t\t\t\tplugin.addDetectorFactory(factory);\n\n\t\t\t\t// Find Detector node in one of the messages files,\n\t\t\t\t// to get the detail HTML.\n\t\t\t\tNode node = findMessageNode(messageCollectionList,\n\t\t\t\t\t\t\"/MessageCollection/Detector[@class='\" + className + \"']/Details\",\n\t\t\t\t\t\t\"Missing Detector description for detector \" + className);\n\n\t\t\t\tElement details = (Element) node;\n\t\t\t\tString detailHTML = details.getText();\n\t\t\t\tStringBuffer buf = new StringBuffer();\n\t\t\t\tbuf.append(\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\">\\n\");\n\t\t\t\tbuf.append(\"<HTML><HEAD><TITLE>Detector Description<\/TITLE><\/HEAD><BODY>\\n\");\n\t\t\t\tbuf.append(detailHTML);\n\t\t\t\tbuf.append(\"<\/BODY><\/HTML>\\n\");\n\t\t\t\tfactory.setDetailHTML(buf.toString());\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tthrow new PluginException(\"Could not instantiate detector class: \" + e, e);\n\t\t}\n\n\t\t// Create ordering constraints\n\t\tNode orderingConstraintsNode =\n\t\t\tpluginDescriptor.selectSingleNode(\"/FindbugsPlugin/OrderingConstraints\");\n\t\tif (orderingConstraintsNode != null) {\n\t\t\t// Get inter-pass and intra-pass constraints\n\t\t\tfor (Iterator<Element> i = orderingConstraintsNode.selectNodes(\"./SplitPass|./WithinPass\").iterator();\n\t\t\t\ti.hasNext();) {\n\t\t\t\tElement constraintElement =  i.next();\n\n\t\t\t\t// Create the selectors which determine which detectors are\n\t\t\t\t// involved in the constraint\n\t\t\t\tDetectorFactorySelector earlierSelector = getConstraintSelector(\n\t\t\t\t\t\tconstraintElement, plugin, \"Earlier\", \"EarlierCategory\");\n\t\t\t\tDetectorFactorySelector laterSelector = getConstraintSelector(\n\t\t\t\t\t\tconstraintElement, plugin, \"Later\", \"LaterCategory\");\n\n\t\t\t\t// Create the constraint\n\t\t\t\tDetectorOrderingConstraint constraint = new DetectorOrderingConstraint(\n\t\t\t\t\t\tearlierSelector, laterSelector);\n\n\t\t\t\t// Add the constraint to the plugin\n\t\t\t\tif (constraintElement.getName().equals(\"SplitPass\"))\n\t\t\t\t\tplugin.addInterPassOrderingConstraint(constraint);\n\t\t\t\telse\n\t\t\t\t\tplugin.addIntraPassOrderingConstraint(constraint);\n\t\t\t}\n\t\t}\n\n\t\t// Create BugPatterns\n\t\tList<Node> bugPatternNodeList = pluginDescriptor.selectNodes(\"/FindbugsPlugin/BugPattern\");\n\t\tfor (Node bugPatternNode : bugPatternNodeList) {\n\t\t\tString type = bugPatternNode.valueOf(\"@type\");\n\t\t\tString abbrev = bugPatternNode.valueOf(\"@abbrev\");\n\t\t\tString category = bugPatternNode.valueOf(\"@category\");\n\t\t\tString experimental = bugPatternNode.valueOf(\"@experimental\");\n\n\t\t\t// Find the matching element in messages.xml (or translations)\n\t\t\tString query = \"/MessageCollection/BugPattern[@type='\" + type + \"']\";\n\t\t\tNode messageNode = findMessageNode(messageCollectionList, query,\n\t\t\t\t\t\"messages.xml missing BugPattern element for type \" + type);\n\n\t\t\tString shortDesc = getChildText(messageNode, \"ShortDescription\");\n\t\t\tString longDesc = getChildText(messageNode, \"LongDescription\");\n\t\t\tString detailText = getChildText(messageNode, \"Details\");\n\n\t\t\tBugPattern bugPattern = new BugPattern(type, abbrev, category,\n\t\t\t\t\tBoolean.valueOf(experimental).booleanValue(),\n\t\t\t\t\tshortDesc, longDesc, detailText);\n\t\t\tplugin.addBugPattern(bugPattern);\n\t\t}\n\n\t\t// Create BugCodes\n\t\tSet<String> definedBugCodes = new HashSet<String>();\n\t\tfor (Document messageCollection : messageCollectionList) {\n\t\t\tList<Node> bugCodeNodeList = messageCollection.selectNodes(\"/MessageCollection/BugCode\");\n\t\t\tfor (Node bugCodeNode : bugCodeNodeList) {\n\t\t\t\tString abbrev = bugCodeNode.valueOf(\"@abbrev\");\n\t\t\t\tif (abbrev.equals(\"\"))\n\t\t\t\t\tthrow new PluginException(\"BugCode element with missing abbrev attribute\");\n\t\t\t\tif (definedBugCodes.contains(abbrev))\n\t\t\t\t\tcontinue;\n\t\t\t\tString description = bugCodeNode.getText();\n\t\t\t\tBugCode bugCode = new BugCode(abbrev, description);\n\t\t\t\tplugin.addBugCode(bugCode);\n\t\t\t\tdefinedBugCodes.add(abbrev);\n\t\t\t}\n\n\t\t}\n\t\t\n\t\t// Success!\n\t\t// Assign to the plugin field, so getPlugin() can return the\n\t\t// new Plugin object.\n\t\tthis.plugin = plugin;\n\n\t}","commit_id":"0e10164ad5e1318fb52c35cd2ea6dab7737ab41e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void find(String xpath) {\n\t\tfor (Node node : (Iterable<Node>) document.selectNodes(xpath)) {\n\t\t\tmatch(node);\n\t\t}\n\t}","id":28837,"modified_method":"public void find(String xpath) {\n\t\tfor (Iterator<Node> i = document.selectNodes(xpath).iterator(); i.hasNext(); ) {\n\t\t\tmatch(i.next());\n\t\t}\n\t}","commit_id":"0e10164ad5e1318fb52c35cd2ea6dab7737ab41e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void check(Item p) throws IOException, SAXException {\n        HtmlPage page = new WebClient().getPage(p, \"configure\");\n        List<HtmlSelect> selects = (List<HtmlSelect>)page.selectNodes(\"//select\");\n        assertTrue(selects.size()>0);\n        for (HtmlSelect select : selects) {\n            Set<String> title = new HashSet<String>();\n            for(HtmlOption o : select.getOptions()) {\n                assertTrue(\"Duplicate entry: \"+o.getText(),title.add(o.getText()));\n            }\n        }\n    }","id":28838,"modified_method":"private void check(Item p) throws IOException, SAXException {\n        HtmlPage page = new WebClient().getPage(p, \"configure\");\n        List<HtmlSelect> selects = page.selectNodes(\"//select\");\n        assertTrue(selects.size()>0);\n        for (HtmlSelect select : selects) {\n            Set<String> title = new HashSet<String>();\n            for(HtmlOption o : select.getOptions()) {\n                assertTrue(\"Duplicate entry: \"+o.getText(),title.add(o.getText()));\n            }\n        }\n    }","commit_id":"e9cf60f6a1854f0385a7d488ea30735fed7c6cad","url":"https://github.com/kohsuke/hudson"},{"original_method":"public static Class<? extends Keyed> getKeyedClass(Class<? extends KeyV3> clz) {\n    // (Only) if we're a subclass of KeyV1 the Keyed class is type parameter 2.\n    if (clz == KeyV3.class)\n      return Keyed.class;\n    return (Class<? extends Keyed>) ReflectionUtils.findActualClassParameter(clz, 2);\n  }","id":28839,"modified_method":"public static Class<? extends Keyed> getKeyedClass(Class<? extends KeyV3> clz) {\n    // (Only) if we're a subclass of KeyV1 the Keyed class is type parameter 2.\n    if (clz == KeyV3.class)\n      return Keyed.class;\n    return ReflectionUtils.findActualClassParameter(clz, 2);\n  }","commit_id":"cbc4ad8692ec769557e5a644e59c100b0d0bd405","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Factory method to create the model-specific parameters schema. */\n  final public P createParametersSchema() {\n    // special case, because ModelBuilderSchema is the top of the tree and is parameterized differently\n    if (ModelBuilderSchema.class == this.getClass()) {\n      return (P)new ModelParametersSchema();\n    }\n\n    try {\n      Class<? extends ModelParametersSchema> parameters_class = (Class<? extends ModelParametersSchema>) ReflectionUtils.findActualClassParameter(this.getClass(), 2);\n      return (P)parameters_class.newInstance();\n    }\n    catch (Exception e) {\n      throw H2O.fail(\"Caught exception trying to instantiate a builder instance for ModelBuilderSchema: \" + this + \": \" + e, e);\n    }\n  }","id":28840,"modified_method":"/** Factory method to create the model-specific parameters schema. */\n  final public P createParametersSchema() {\n    // special case, because ModelBuilderSchema is the top of the tree and is parameterized differently\n    if (ModelBuilderSchema.class == this.getClass()) {\n      return (P)new ModelParametersSchema();\n    }\n\n    try {\n      Class<? extends ModelParametersSchema> parameters_class = ReflectionUtils.findActualClassParameter(this.getClass(), 2);\n      return (P)parameters_class.newInstance();\n    }\n    catch (Exception e) {\n      throw H2O.fail(\"Caught exception trying to instantiate a builder instance for ModelBuilderSchema: \" + this + \": \" + e, e);\n    }\n  }","commit_id":"cbc4ad8692ec769557e5a644e59c100b0d0bd405","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Reflection helper which returns the actual class for a type parameter, even if itself is parameterized.\n   */\n  public static Class findActualClassParameter(Class clz, int parm) {\n    Class parm_class = null;\n\n    if (clz.getGenericSuperclass() instanceof ParameterizedType) {\n      Type[] handler_type_parms = ((ParameterizedType) (clz.getGenericSuperclass())).getActualTypeArguments();\n      if (handler_type_parms[parm] instanceof Class) {\n        // The handler's Iced class is not parameterized (the normal case):\n        parm_class = (Class) handler_type_parms[parm];  // E.g., for a Schema [0] is the impl (Iced) type; [1] is the Schema type\n      } else if (handler_type_parms[parm] instanceof TypeVariable) {\n        // The handler's Iced class is parameterized, e.g. to handle multiple layers of Schema classes as in ModelsHandler:\n        TypeVariable v = (TypeVariable) (handler_type_parms[parm]);\n        Type t = v.getBounds()[0];  // [0] or [parm] ?\n        if (t instanceof Class)\n          parm_class = (Class) t;\n        else if (t instanceof ParameterizedType)\n          parm_class = (Class) ((ParameterizedType) t).getRawType();\n      } else if (handler_type_parms[parm] instanceof ParameterizedType) {\n        // The handler's Iced class is parameterized, e.g. to handle multiple layers of Schema classes as in ModelsHandler:\n        parm_class = (Class) ((ParameterizedType) (handler_type_parms[parm])).getRawType(); // For a Key<Frame> this returns Key.class; see also getActualTypeArguments()\n      } else {\n        String msg = \"Iced parameter for handler: \" + clz + \" uses a type parameterization scheme that we don't yet handle: \" + handler_type_parms[parm];\n        Log.warn(msg);\n        throw H2O.fail(msg);\n      }\n    } else {\n      // Superclass is not a ParameterizedType, so we just have Iced.\n      parm_class = Iced.class; // If the handler isn't parameterized on the Iced class then this has to be Iced.\n    }\n    return parm_class;\n  }","id":28841,"modified_method":"/**\n   * Reflection helper which returns the actual class for a type parameter, even if itself is parameterized.\n   */\n  public static <T> Class<T> findActualClassParameter(Class clz, int parm) {\n    Class parm_class = null;\n\n    if (clz.getGenericSuperclass() instanceof ParameterizedType) {\n      Type[] handler_type_parms = ((ParameterizedType) (clz.getGenericSuperclass())).getActualTypeArguments();\n      if (handler_type_parms[parm] instanceof Class) {\n        // The handler's Iced class is not parameterized (the normal case):\n        parm_class = (Class) handler_type_parms[parm];  // E.g., for a Schema [0] is the impl (Iced) type; [1] is the Schema type\n      } else if (handler_type_parms[parm] instanceof TypeVariable) {\n        // The handler's Iced class is parameterized, e.g. to handle multiple layers of Schema classes as in ModelsHandler:\n        TypeVariable v = (TypeVariable) (handler_type_parms[parm]);\n        Type t = v.getBounds()[0];  // [0] or [parm] ?\n        if (t instanceof Class)\n          parm_class = (Class) t;\n        else if (t instanceof ParameterizedType)\n          parm_class = (Class) ((ParameterizedType) t).getRawType();\n      } else if (handler_type_parms[parm] instanceof ParameterizedType) {\n        // The handler's Iced class is parameterized, e.g. to handle multiple layers of Schema classes as in ModelsHandler:\n        parm_class = (Class) ((ParameterizedType) (handler_type_parms[parm])).getRawType(); // For a Key<Frame> this returns Key.class; see also getActualTypeArguments()\n      } else {\n        String msg = \"Iced parameter for handler: \" + clz + \" uses a type parameterization scheme that we don't yet handle: \" + handler_type_parms[parm];\n        Log.warn(msg);\n        throw H2O.fail(msg);\n      }\n    } else {\n      // Superclass is not a ParameterizedType, so we just have Iced.\n      parm_class = Iced.class; // If the handler isn't parameterized on the Iced class then this has to be Iced.\n    }\n    return (Class<T>) parm_class;\n  }","commit_id":"cbc4ad8692ec769557e5a644e59c100b0d0bd405","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * For a given version and type (Iced class simpleName) return the appropriate Schema\n   * class, if any.\n   * <p>\n   * If a higher version is asked for than is available (e.g., if the highest version of\n   * Frame is FrameV2 and the client asks for the schema for (Frame, 17) then FrameV2 will\n   * be returned.  This compatibility lookup is cached.\n   */\n  public static Class<? extends Schema> schemaClass(int version, String type) {\n    if (version < 1) return null;\n\n    Class<? extends Schema> clz = iced_to_schema.get(new Pair(type, version));\n\n    if (null != clz) return clz; // found!\n\n    clz = schemaClass(version - 1, type);\n\n    if (null != clz) iced_to_schema.put(new Pair(type, version), clz); // found a lower-numbered schema: cache\n    return clz;\n  }","id":28842,"modified_method":"/**\n   * For a given version and type (Iced class simpleName) return the appropriate Schema\n   * class, if any.\n   * <p>\n   * If a higher version is asked for than is available (e.g., if the highest version of\n   * Frame is FrameV2 and the client asks for the schema for (Frame, 17) then FrameV2 will\n   * be returned.  This compatibility lookup is cached.\n   */\n  public static Class<? extends Schema> schemaClass(int version, String type) {\n    if (version < 1) return null;\n\n    Class<? extends Schema> clz = iced_to_schema.get(new Pair<>(type, version));\n\n    if (clz != null) return clz; // found!\n\n    clz = schemaClass(version==EXPERIMENTAL_VERSION? HIGHEST_SUPPORTED_VERSION : version-1, type);\n\n    if (clz != null) iced_to_schema.put(new Pair<>(type, version), clz); // found a lower-numbered schema: cache\n    return clz;\n  }","commit_id":"cbc4ad8692ec769557e5a644e59c100b0d0bd405","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private static String[] splitArgs(String argStr) {\n    StringBuffer sb = new StringBuffer (argStr);\n    StringBuffer arg = new StringBuffer ();\n    List<String> splitArgList = new ArrayList<String> ();\n    boolean inDoubleQuotes = false;\n    boolean inSquareBrackets = false; // for arrays of arrays\n\n    for (int i=0; i < sb.length(); i++) {\n      if (sb.charAt(i) == '\"' && !inDoubleQuotes && !inSquareBrackets) {\n        inDoubleQuotes = true;\n        arg.append(sb.charAt(i));\n      } else if (sb.charAt(i) == '\"' && inDoubleQuotes && !inSquareBrackets) {\n        inDoubleQuotes = false;\n        arg.append(sb.charAt(i));\n      } else if (sb.charAt(i) == ',' && !inDoubleQuotes && !inSquareBrackets) {\n        splitArgList.add(arg.toString());\n        // clear the field for next word\n        arg.setLength(0);\n      } else if (sb.charAt(i) == '[') {\n        inSquareBrackets = true;\n        arg.append(sb.charAt(i));\n      } else if (sb.charAt(i) == ']') {\n        inSquareBrackets = false;\n        arg.append(sb.charAt(i));\n      } else {\n        arg.append(sb.charAt(i));\n      }\n    }\n    if (arg.length() > 0)\n      splitArgList.add(arg.toString());\n\n    return splitArgList.toArray(new String[splitArgList.size()]);\n  }","id":28843,"modified_method":"private static String[] splitArgs(String argStr) {\n    StringBuilder sb = new StringBuilder(argStr);\n    StringBuilder arg = new StringBuilder();\n    List<String> splitArgList = new ArrayList<String> ();\n    boolean inDoubleQuotes = false;\n    boolean inSquareBrackets = false; // for arrays of arrays\n\n    for (int i=0; i < sb.length(); i++) {\n      if (sb.charAt(i) == '\"' && !inDoubleQuotes && !inSquareBrackets) {\n        inDoubleQuotes = true;\n        arg.append(sb.charAt(i));\n      } else if (sb.charAt(i) == '\"' && inDoubleQuotes && !inSquareBrackets) {\n        inDoubleQuotes = false;\n        arg.append(sb.charAt(i));\n      } else if (sb.charAt(i) == ',' && !inDoubleQuotes && !inSquareBrackets) {\n        splitArgList.add(arg.toString());\n        // clear the field for next word\n        arg.setLength(0);\n      } else if (sb.charAt(i) == '[') {\n        inSquareBrackets = true;\n        arg.append(sb.charAt(i));\n      } else if (sb.charAt(i) == ']') {\n        inSquareBrackets = false;\n        arg.append(sb.charAt(i));\n      } else {\n        arg.append(sb.charAt(i));\n      }\n    }\n    if (arg.length() > 0)\n      splitArgList.add(arg.toString());\n\n    return splitArgList.toArray(new String[splitArgList.size()]);\n  }","commit_id":"cbc4ad8692ec769557e5a644e59c100b0d0bd405","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Return the class of the implementation type parameter I for the\n   *  given Schema class. Used by the metadata facilities and the\n   *  reflection-base field-copying magic in PojoUtils. */\n  public static Class<? extends Iced> getImplClass(Class<? extends Schema> clz) {\n    Class<? extends Iced> impl_class = (Class<? extends Iced>)ReflectionUtils.findActualClassParameter(clz, 0);\n    if (null == impl_class)\n      Log.warn(\"Failed to find an impl class for Schema: \" + clz);\n    return impl_class;\n  }","id":28844,"modified_method":"/** Return the class of the implementation type parameter I for the\n   *  given Schema class. Used by the metadata facilities and the\n   *  reflection-base field-copying magic in PojoUtils. */\n  public static Class<? extends Iced> getImplClass(Class<? extends Schema> clz) {\n    Class<? extends Iced> impl_class = ReflectionUtils.findActualClassParameter(clz, 0);\n    if (null == impl_class)\n      Log.warn(\"Failed to find an impl class for Schema: \" + clz);\n    return impl_class;\n  }","commit_id":"cbc4ad8692ec769557e5a644e59c100b0d0bd405","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Return the class of the implementation type parameter I for this Schema.\n   *  Used by generic code which deals with arbitrary schemas and their backing\n   *  impl classes.  Never returns null. */\n  public Class<I> getImplClass() {\n    return _impl_class != null ? _impl_class : (_impl_class = (Class<I>) ReflectionUtils.findActualClassParameter(this.getClass(), 0));\n  }","id":28845,"modified_method":"/** Return the class of the implementation type parameter I for this Schema.\n   *  Used by generic code which deals with arbitrary schemas and their backing\n   *  impl classes.  Never returns null. */\n  public Class<I> getImplClass() {\n    return _impl_class != null ? _impl_class : (_impl_class = ReflectionUtils.findActualClassParameter(this.getClass(), 0));\n  }","commit_id":"cbc4ad8692ec769557e5a644e59c100b0d0bd405","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Default constructor; triggers lazy schema registration.\n   *  @throws water.exceptions.H2OFailException if there is a name collision or\n   *          there is more than one schema which maps to the same Iced class */\n  public Schema() {\n    String name = this.getClass().getSimpleName();\n    int version = extractVersionFromSchemaName(name);\n    String type = getImplClass().getSimpleName();\n    init_meta();\n\n    if (null == schema_to_iced.get(name)) {\n      Log.debug(\"Registering schema: \" + name + \" schema_version: \" + version + \" with Iced class: \" + _impl_class.toString());\n      if (null != schemas.get(name))\n        throw H2O.fail(\"Found a duplicate schema name in two different packages: \" + schemas.get(name) + \" and: \" + this.getClass().toString());\n\n      schemas.put(name, this.getClass());\n      schema_to_iced.put(name, _impl_class);\n\n      if (_impl_class != Iced.class) {\n        Pair versioned = new Pair(type, version);\n        // Check for conflicts\n        if (null != iced_to_schema.get(versioned)) {\n          throw H2O.fail(\"Found two schemas mapping to the same Iced class with the same version: \" + iced_to_schema.get(versioned) + \" and: \" + this.getClass().toString() + \" both map to version: \" + version + \" of Iced class: \" + _impl_class);\n        }\n        iced_to_schema.put(versioned, this.getClass());\n      }\n    }\n  }","id":28846,"modified_method":"/** Default constructor; triggers lazy schema registration.\n   *  @throws water.exceptions.H2OFailException if there is a name collision or\n   *          there is more than one schema which maps to the same Iced class */\n  public Schema() {\n    init_meta();\n    String name = __meta.getSchemaName();\n    int version = __meta.getSchemaVersion();\n    String type = __meta.getSchemaType();\n\n    if (schema_to_iced.get(name) == null) {\n      Log.debug(\"Registering schema: \" + name + \" version: \" + version + \" with Iced class: \" + _impl_class.toString());\n      if (schemas.get(name) != null)\n        throw H2O.fail(\"Found a duplicate schema name in: \" + schemas.get(name) + \" and: \" + this.getClass());\n\n      schemas.put(name, this.getClass());\n      schema_to_iced.put(name, _impl_class);\n\n      if (_impl_class != Iced.class) {\n        Pair<String, Integer> versioned = new Pair<>(type, version);\n        // Check for conflicts\n        if (iced_to_schema.get(versioned) != null)\n          throw H2O.fail(\"Found two schemas mapping to the same Iced class with the same version: \" +\n                         iced_to_schema.get(versioned) + \" and: \" + this.getClass().toString() + \" both map to \" +\n                         \"version: \" + version + \" of Iced class: \" + _impl_class);\n        iced_to_schema.put(versioned, this.getClass());\n      }\n    }\n  }","commit_id":"cbc4ad8692ec769557e5a644e59c100b0d0bd405","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public static Class<? extends Keyed> getKeyedClass(Class<? extends KeyV3> clz) {\n    // (Only) if we're a subclass of KeyV1 the Keyed class is type parameter 2.\n    if (clz == KeyV3.class)\n      return Keyed.class;\n    return (Class<? extends Keyed>) ReflectionUtils.findActualClassParameter(clz, 2);\n  }","id":28847,"modified_method":"public static Class<? extends Keyed> getKeyedClass(Class<? extends KeyV3> clz) {\n    // (Only) if we're a subclass of KeyV1 the Keyed class is type parameter 2.\n    if (clz == KeyV3.class)\n      return Keyed.class;\n    return ReflectionUtils.findActualClassParameter(clz, 2);\n  }","commit_id":"faba5f78628fa4c7d4b02257061ca2b88a399057","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Factory method to create the model-specific parameters schema. */\n  final public P createParametersSchema() {\n    // special case, because ModelBuilderSchema is the top of the tree and is parameterized differently\n    if (ModelBuilderSchema.class == this.getClass()) {\n      return (P)new ModelParametersSchema();\n    }\n\n    try {\n      Class<? extends ModelParametersSchema> parameters_class = (Class<? extends ModelParametersSchema>) ReflectionUtils.findActualClassParameter(this.getClass(), 2);\n      return (P)parameters_class.newInstance();\n    }\n    catch (Exception e) {\n      throw H2O.fail(\"Caught exception trying to instantiate a builder instance for ModelBuilderSchema: \" + this + \": \" + e, e);\n    }\n  }","id":28848,"modified_method":"/** Factory method to create the model-specific parameters schema. */\n  final public P createParametersSchema() {\n    // special case, because ModelBuilderSchema is the top of the tree and is parameterized differently\n    if (ModelBuilderSchema.class == this.getClass()) {\n      return (P)new ModelParametersSchema();\n    }\n\n    try {\n      Class<? extends ModelParametersSchema> parameters_class = ReflectionUtils.findActualClassParameter(this.getClass(), 2);\n      return (P)parameters_class.newInstance();\n    }\n    catch (Exception e) {\n      throw H2O.fail(\"Caught exception trying to instantiate a builder instance for ModelBuilderSchema: \" + this + \": \" + e, e);\n    }\n  }","commit_id":"faba5f78628fa4c7d4b02257061ca2b88a399057","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Reflection helper which returns the actual class for a type parameter, even if itself is parameterized.\n   */\n  public static Class findActualClassParameter(Class clz, int parm) {\n    Class parm_class = null;\n\n    if (clz.getGenericSuperclass() instanceof ParameterizedType) {\n      Type[] handler_type_parms = ((ParameterizedType) (clz.getGenericSuperclass())).getActualTypeArguments();\n      if (handler_type_parms[parm] instanceof Class) {\n        // The handler's Iced class is not parameterized (the normal case):\n        parm_class = (Class) handler_type_parms[parm];  // E.g., for a Schema [0] is the impl (Iced) type; [1] is the Schema type\n      } else if (handler_type_parms[parm] instanceof TypeVariable) {\n        // The handler's Iced class is parameterized, e.g. to handle multiple layers of Schema classes as in ModelsHandler:\n        TypeVariable v = (TypeVariable) (handler_type_parms[parm]);\n        Type t = v.getBounds()[0];  // [0] or [parm] ?\n        if (t instanceof Class)\n          parm_class = (Class) t;\n        else if (t instanceof ParameterizedType)\n          parm_class = (Class) ((ParameterizedType) t).getRawType();\n      } else if (handler_type_parms[parm] instanceof ParameterizedType) {\n        // The handler's Iced class is parameterized, e.g. to handle multiple layers of Schema classes as in ModelsHandler:\n        parm_class = (Class) ((ParameterizedType) (handler_type_parms[parm])).getRawType(); // For a Key<Frame> this returns Key.class; see also getActualTypeArguments()\n      } else {\n        String msg = \"Iced parameter for handler: \" + clz + \" uses a type parameterization scheme that we don't yet handle: \" + handler_type_parms[parm];\n        Log.warn(msg);\n        throw H2O.fail(msg);\n      }\n    } else {\n      // Superclass is not a ParameterizedType, so we just have Iced.\n      parm_class = Iced.class; // If the handler isn't parameterized on the Iced class then this has to be Iced.\n    }\n    return parm_class;\n  }","id":28849,"modified_method":"/**\n   * Reflection helper which returns the actual class for a type parameter, even if itself is parameterized.\n   */\n  public static <T> Class<T> findActualClassParameter(Class clz, int parm) {\n    Class parm_class = null;\n\n    if (clz.getGenericSuperclass() instanceof ParameterizedType) {\n      Type[] handler_type_parms = ((ParameterizedType) (clz.getGenericSuperclass())).getActualTypeArguments();\n      if (handler_type_parms[parm] instanceof Class) {\n        // The handler's Iced class is not parameterized (the normal case):\n        parm_class = (Class) handler_type_parms[parm];  // E.g., for a Schema [0] is the impl (Iced) type; [1] is the Schema type\n      } else if (handler_type_parms[parm] instanceof TypeVariable) {\n        // The handler's Iced class is parameterized, e.g. to handle multiple layers of Schema classes as in ModelsHandler:\n        TypeVariable v = (TypeVariable) (handler_type_parms[parm]);\n        Type t = v.getBounds()[0];  // [0] or [parm] ?\n        if (t instanceof Class)\n          parm_class = (Class) t;\n        else if (t instanceof ParameterizedType)\n          parm_class = (Class) ((ParameterizedType) t).getRawType();\n      } else if (handler_type_parms[parm] instanceof ParameterizedType) {\n        // The handler's Iced class is parameterized, e.g. to handle multiple layers of Schema classes as in ModelsHandler:\n        parm_class = (Class) ((ParameterizedType) (handler_type_parms[parm])).getRawType(); // For a Key<Frame> this returns Key.class; see also getActualTypeArguments()\n      } else {\n        String msg = \"Iced parameter for handler: \" + clz + \" uses a type parameterization scheme that we don't yet handle: \" + handler_type_parms[parm];\n        Log.warn(msg);\n        throw H2O.fail(msg);\n      }\n    } else {\n      // Superclass is not a ParameterizedType, so we just have Iced.\n      parm_class = Iced.class; // If the handler isn't parameterized on the Iced class then this has to be Iced.\n    }\n    return (Class<T>) parm_class;\n  }","commit_id":"faba5f78628fa4c7d4b02257061ca2b88a399057","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * For a given version and type (Iced class simpleName) return the appropriate Schema\n   * class, if any.\n   * <p>\n   * If a higher version is asked for than is available (e.g., if the highest version of\n   * Frame is FrameV2 and the client asks for the schema for (Frame, 17) then FrameV2 will\n   * be returned.  This compatibility lookup is cached.\n   */\n  public static Class<? extends Schema> schemaClass(int version, String type) {\n    if (version < 1) return null;\n\n    Class<? extends Schema> clz = iced_to_schema.get(new Pair(type, version));\n\n    if (null != clz) return clz; // found!\n\n    clz = schemaClass(version - 1, type);\n\n    if (null != clz) iced_to_schema.put(new Pair(type, version), clz); // found a lower-numbered schema: cache\n    return clz;\n  }","id":28850,"modified_method":"/**\n   * For a given version and type (Iced class simpleName) return the appropriate Schema\n   * class, if any.\n   * <p>\n   * If a higher version is asked for than is available (e.g., if the highest version of\n   * Frame is FrameV2 and the client asks for the schema for (Frame, 17) then FrameV2 will\n   * be returned.  This compatibility lookup is cached.\n   */\n  public static Class<? extends Schema> schemaClass(int version, String type) {\n    if (version < 1) return null;\n\n    Class<? extends Schema> clz = iced_to_schema.get(new Pair<>(type, version));\n\n    if (clz != null) return clz; // found!\n\n    clz = schemaClass(version==EXPERIMENTAL_VERSION? HIGHEST_SUPPORTED_VERSION : version-1, type);\n\n    if (clz != null) iced_to_schema.put(new Pair<>(type, version), clz); // found a lower-numbered schema: cache\n    return clz;\n  }","commit_id":"faba5f78628fa4c7d4b02257061ca2b88a399057","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Return the class of the implementation type parameter I for the\n   *  given Schema class. Used by the metadata facilities and the\n   *  reflection-base field-copying magic in PojoUtils. */\n  public static Class<? extends Iced> getImplClass(Class<? extends Schema> clz) {\n    Class<? extends Iced> impl_class = (Class<? extends Iced>)ReflectionUtils.findActualClassParameter(clz, 0);\n    if (null == impl_class)\n      Log.warn(\"Failed to find an impl class for Schema: \" + clz);\n    return impl_class;\n  }","id":28851,"modified_method":"/** Return the class of the implementation type parameter I for the\n   *  given Schema class. Used by the metadata facilities and the\n   *  reflection-base field-copying magic in PojoUtils. */\n  public static Class<? extends Iced> getImplClass(Class<? extends Schema> clz) {\n    Class<? extends Iced> impl_class = ReflectionUtils.findActualClassParameter(clz, 0);\n    if (null == impl_class)\n      Log.warn(\"Failed to find an impl class for Schema: \" + clz);\n    return impl_class;\n  }","commit_id":"faba5f78628fa4c7d4b02257061ca2b88a399057","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Default constructor; triggers lazy schema registration.\n   *  @throws water.exceptions.H2OFailException if there is a name collision or\n   *          there is more than one schema which maps to the same Iced class */\n  public Schema() {\n    String name = this.getClass().getSimpleName();\n    int version = extractVersionFromSchemaName(name);\n    String type = getImplClass().getSimpleName();\n    init_meta();\n\n    if (null == schema_to_iced.get(name)) {\n      Log.debug(\"Registering schema: \" + name + \" schema_version: \" + version + \" with Iced class: \" + _impl_class.toString());\n      if (null != schemas.get(name))\n        throw H2O.fail(\"Found a duplicate schema name in two different packages: \" + schemas.get(name) + \" and: \" + this.getClass().toString());\n\n      schemas.put(name, this.getClass());\n      schema_to_iced.put(name, _impl_class);\n\n      if (_impl_class != Iced.class) {\n        Pair versioned = new Pair(type, version);\n        // Check for conflicts\n        if (null != iced_to_schema.get(versioned)) {\n          throw H2O.fail(\"Found two schemas mapping to the same Iced class with the same version: \" + iced_to_schema.get(versioned) + \" and: \" + this.getClass().toString() + \" both map to version: \" + version + \" of Iced class: \" + _impl_class);\n        }\n        iced_to_schema.put(versioned, this.getClass());\n      }\n    }\n  }","id":28852,"modified_method":"/** Default constructor; triggers lazy schema registration.\n   *  @throws water.exceptions.H2OFailException if there is a name collision or\n   *          there is more than one schema which maps to the same Iced class */\n  public Schema() {\n    init_meta();\n    String name = __meta.getSchemaName();\n    int version = __meta.getSchemaVersion();\n    String type = __meta.getSchemaType();\n\n    if (schema_to_iced.get(name) == null) {\n      Log.debug(\"Registering schema: \" + name + \" version: \" + version + \" with Iced class: \" + _impl_class.toString());\n      if (schemas.get(name) != null)\n        throw H2O.fail(\"Found a duplicate schema name in: \" + schemas.get(name) + \" and: \" + this.getClass());\n\n      schemas.put(name, this.getClass());\n      schema_to_iced.put(name, _impl_class);\n\n      if (_impl_class != Iced.class) {\n        Pair<String, Integer> versioned = new Pair<>(type, version);\n        // Check for conflicts\n        if (iced_to_schema.get(versioned) != null)\n          throw H2O.fail(\"Found two schemas mapping to the same Iced class with the same version: \" +\n                         iced_to_schema.get(versioned) + \" and: \" + this.getClass().toString() + \" both map to \" +\n                         \"version: \" + version + \" of Iced class: \" + _impl_class);\n        iced_to_schema.put(versioned, this.getClass());\n      }\n    }\n  }","commit_id":"faba5f78628fa4c7d4b02257061ca2b88a399057","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private static String[] splitArgs(String argStr) {\n    StringBuffer sb = new StringBuffer (argStr);\n    StringBuffer arg = new StringBuffer ();\n    List<String> splitArgList = new ArrayList<String> ();\n    boolean inDoubleQuotes = false;\n    boolean inSquareBrackets = false; // for arrays of arrays\n\n    for (int i=0; i < sb.length(); i++) {\n      if (sb.charAt(i) == '\"' && !inDoubleQuotes && !inSquareBrackets) {\n        inDoubleQuotes = true;\n        arg.append(sb.charAt(i));\n      } else if (sb.charAt(i) == '\"' && inDoubleQuotes && !inSquareBrackets) {\n        inDoubleQuotes = false;\n        arg.append(sb.charAt(i));\n      } else if (sb.charAt(i) == ',' && !inDoubleQuotes && !inSquareBrackets) {\n        splitArgList.add(arg.toString());\n        // clear the field for next word\n        arg.setLength(0);\n      } else if (sb.charAt(i) == '[') {\n        inSquareBrackets = true;\n        arg.append(sb.charAt(i));\n      } else if (sb.charAt(i) == ']') {\n        inSquareBrackets = false;\n        arg.append(sb.charAt(i));\n      } else {\n        arg.append(sb.charAt(i));\n      }\n    }\n    if (arg.length() > 0)\n      splitArgList.add(arg.toString());\n\n    return splitArgList.toArray(new String[splitArgList.size()]);\n  }","id":28853,"modified_method":"private static String[] splitArgs(String argStr) {\n    StringBuilder sb = new StringBuilder(argStr);\n    StringBuilder arg = new StringBuilder();\n    List<String> splitArgList = new ArrayList<String> ();\n    boolean inDoubleQuotes = false;\n    boolean inSquareBrackets = false; // for arrays of arrays\n\n    for (int i=0; i < sb.length(); i++) {\n      if (sb.charAt(i) == '\"' && !inDoubleQuotes && !inSquareBrackets) {\n        inDoubleQuotes = true;\n        arg.append(sb.charAt(i));\n      } else if (sb.charAt(i) == '\"' && inDoubleQuotes && !inSquareBrackets) {\n        inDoubleQuotes = false;\n        arg.append(sb.charAt(i));\n      } else if (sb.charAt(i) == ',' && !inDoubleQuotes && !inSquareBrackets) {\n        splitArgList.add(arg.toString());\n        // clear the field for next word\n        arg.setLength(0);\n      } else if (sb.charAt(i) == '[') {\n        inSquareBrackets = true;\n        arg.append(sb.charAt(i));\n      } else if (sb.charAt(i) == ']') {\n        inSquareBrackets = false;\n        arg.append(sb.charAt(i));\n      } else {\n        arg.append(sb.charAt(i));\n      }\n    }\n    if (arg.length() > 0)\n      splitArgList.add(arg.toString());\n\n    return splitArgList.toArray(new String[splitArgList.size()]);\n  }","commit_id":"faba5f78628fa4c7d4b02257061ca2b88a399057","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/** Return the class of the implementation type parameter I for this Schema.\n   *  Used by generic code which deals with arbitrary schemas and their backing\n   *  impl classes.  Never returns null. */\n  public Class<I> getImplClass() {\n    return _impl_class != null ? _impl_class : (_impl_class = (Class<I>) ReflectionUtils.findActualClassParameter(this.getClass(), 0));\n  }","id":28854,"modified_method":"/** Return the class of the implementation type parameter I for this Schema.\n   *  Used by generic code which deals with arbitrary schemas and their backing\n   *  impl classes.  Never returns null. */\n  public Class<I> getImplClass() {\n    return _impl_class != null ? _impl_class : (_impl_class = ReflectionUtils.findActualClassParameter(this.getClass(), 0));\n  }","commit_id":"faba5f78628fa4c7d4b02257061ca2b88a399057","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public String nameToCanonicalName(String name, PsiNamedElement psiVariable) {\n    final CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(psiVariable.getManager());\n    final String propertyName = codeStyleManager.variableNameToPropertyName(name, codeStyleManager.getVariableKind((PsiVariable)psiVariable));\n    if (myToUnpluralize.contains(psiVariable)) return StringUtil.unpluralize(propertyName);\n    return propertyName;\n  }","id":28855,"modified_method":"public String nameToCanonicalName(String name, PsiNamedElement psiVariable) {\n    final CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(psiVariable.getManager());\n    final String propertyName = codeStyleManager.variableNameToPropertyName(name, codeStyleManager.getVariableKind((PsiVariable)psiVariable));\n    if (myToUnpluralize.contains(psiVariable)) {\n      final String singular = StringUtil.unpluralize(propertyName);\n      if (singular != null) return singular;\n    }\n    return propertyName;\n  }","commit_id":"82003bc6c31a5d89b0c29f38bc92c98b60b63ae2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AutomaticVariableRenamer(PsiClass aClass, String newClassName, List<UsageInfo> usages) {\n    for (Iterator<UsageInfo> iterator = usages.iterator(); iterator.hasNext();) {\n      final UsageInfo info = iterator.next();\n      final PsiElement element = info.getElement();\n      if (!(element instanceof PsiJavaCodeReferenceElement)) continue;\n      final PsiVariable variable = PsiTreeUtil.getParentOfType(element, PsiVariable.class);\n      if (variable == null) continue;\n      final PsiJavaCodeReferenceElement ref = variable.getTypeElement().getInnermostComponentReferenceElement();\n      if (ref == null) continue;\n      if (ref.equals(element)) {\n        myElements.add((variable));\n        if (variable.getType() instanceof PsiArrayType) {\n          myToUnpluralize.add(variable);\n        }\n      } else {\n        PsiType collectionType = variable.getManager().getElementFactory().createTypeByFQClassName(\"java.util.Collection\", variable.getResolveScope());\n        if (!collectionType.isAssignableFrom(variable.getType())) continue;\n        final PsiTypeElement[] typeParameterElements = ref.getParameterList().getTypeParameterElements();\n        for (PsiTypeElement typeParameterElement : typeParameterElements) {\n          final PsiJavaCodeReferenceElement parameterRef = typeParameterElement.getInnermostComponentReferenceElement();\n          if (parameterRef != null && parameterRef.equals(element)) {\n            myElements.add((variable));\n            myToUnpluralize.add(variable);\n            break;\n          }\n        }\n      }\n    }\n    suggestAllNames(aClass.getName(), newClassName);\n  }","id":28856,"modified_method":"public AutomaticVariableRenamer(PsiClass aClass, String newClassName, List<UsageInfo> usages) {\n    for (final UsageInfo info : usages) {\n      final PsiElement element = info.getElement();\n      if (!(element instanceof PsiJavaCodeReferenceElement)) continue;\n      final PsiVariable variable = PsiTreeUtil.getParentOfType(element, PsiVariable.class);\n      if (variable == null) continue;\n      final PsiJavaCodeReferenceElement ref = variable.getTypeElement().getInnermostComponentReferenceElement();\n      if (ref == null) continue;\n      if (ref.equals(element)) {\n        myElements.add((variable));\n        if (variable.getType() instanceof PsiArrayType) {\n          myToUnpluralize.add(variable);\n        }\n      }\n      else {\n        PsiType collectionType =\n          variable.getManager().getElementFactory().createTypeByFQClassName(\"java.util.Collection\", variable.getResolveScope());\n        if (!collectionType.isAssignableFrom(variable.getType())) continue;\n        final PsiTypeElement[] typeParameterElements = ref.getParameterList().getTypeParameterElements();\n        for (PsiTypeElement typeParameterElement : typeParameterElements) {\n          final PsiJavaCodeReferenceElement parameterRef = typeParameterElement.getInnermostComponentReferenceElement();\n          if (parameterRef != null && parameterRef.equals(element)) {\n            myElements.add((variable));\n            myToUnpluralize.add(variable);\n            break;\n          }\n        }\n      }\n    }\n    suggestAllNames(aClass.getName(), newClassName);\n  }","commit_id":"82003bc6c31a5d89b0c29f38bc92c98b60b63ae2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  @NotNull\n  public static String unpluralize(final @NotNull String name) {\n    if (name.endsWith(\"sses\") || name.endsWith(\"xes\")) { //?\n      return name.substring(0, name.length() - 2);\n    }\n\n    if (name.endsWith(\"ses\")) {\n      return name.substring(0, name.length() - 1);\n    }\n\n    if (name.endsWith(\"ies\")) {\n      return name.substring(0, name.length() - 3) + \"y\";\n    }\n\n    if (endsWithChar(name, 's')) {\n      return name.substring(0, name.length() - 1);\n    }\n\n    if (name.endsWith(\"children\")) {\n      return name.substring(0, name.length() - \"children\".length()) + \"child\";\n    }\n\n    if (name.endsWith(\"Children\") && name.length() > \"Children\".length()) {\n      return name.substring(0, name.length() - \"Children\".length()) + \"Child\";\n    }\n\n    return name;\n  }","id":28857,"modified_method":"/**\n   * Returns unpluralized variant using English based heuristics like proprties -> property, names -> name, children -> child.\n   * Returns <code>null<\/code> if failed to match appropriate heuristic.\n   * @param name english word in plural form\n   * @return name in singular form or <code>null<\/code> if failed to find one.\n   */\n  @SuppressWarnings({\"HardCodedStringLiteral\"})\n  @Nullable\n  public static String unpluralize(final @NotNull String name) {\n    if (name.endsWith(\"sses\") || name.endsWith(\"xes\")) { //?\n      return name.substring(0, name.length() - 2);\n    }\n\n    if (name.endsWith(\"ses\")) {\n      return name.substring(0, name.length() - 1);\n    }\n\n    if (name.endsWith(\"ies\")) {\n      return name.substring(0, name.length() - 3) + \"y\";\n    }\n\n    if (endsWithChar(name, 's')) {\n      return name.substring(0, name.length() - 1);\n    }\n\n    if (name.endsWith(\"children\")) {\n      return name.substring(0, name.length() - \"children\".length()) + \"child\";\n    }\n\n    if (name.endsWith(\"Children\") && name.length() > \"Children\".length()) {\n      return name.substring(0, name.length() - \"Children\".length()) + \"Child\";\n    }\n\n    return null;\n  }","commit_id":"82003bc6c31a5d89b0c29f38bc92c98b60b63ae2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String smartUnpluralize(String param) {\n    if (param.endsWith(\"_list\")) {\n      return param.substring(0, param.length()-5);\n    }\n    final String result = StringUtil.unpluralize(param);\n    return result == null ? param : result;\n  }","id":28858,"modified_method":"private static String smartUnpluralize(String param) {\n    if (param.endsWith(\"_list\")) {\n      return param.substring(0, param.length()-5);\n    }\n    return StringUtil.unpluralize(param);\n  }","commit_id":"4569a1cbf24a18f783c4e2dd3655b9b573ff3159","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private String getSubTagNameForCollection(final JavaMethodSignature method) {\n    final SubTagList subTagList = method.findAnnotation(SubTagList.class, myClass);\n    if (subTagList == null || StringUtil.isEmpty(subTagList.value())) {\n      final String propertyName = getPropertyName(method);\n      return propertyName != null ? getNameStrategy(false).convertName(StringUtil.unpluralize(propertyName)) : null;\n    }\n    return subTagList.value();\n  }","id":28859,"modified_method":"@Nullable\n  private String getSubTagNameForCollection(final JavaMethodSignature method) {\n    final SubTagList subTagList = method.findAnnotation(SubTagList.class, myClass);\n    if (subTagList == null || StringUtil.isEmpty(subTagList.value())) {\n      final String propertyName = getPropertyName(method);\n      if (propertyName != null) {\n        final String singular = StringUtil.unpluralize(propertyName);\n        assert singular != null : \"Can't unpluralize: \" + propertyName;\n        return getNameStrategy(false).convertName(singular);\n      }\n      else {\n        return null;\n      }\n    }\n    return subTagList.value();\n  }","commit_id":"e4707729b9922f84287990eebe9382ec888c5b90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean isExpectedType(LightweightTypeReference expectation, Class<?> clazz) {\n\t\tif (expectation != null) {\n\t\t\tif (expectation.isResolved() && expectation.isSubtypeOf(clazz)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (expectation instanceof UnboundTypeReference) {\n\t\t\t\tif (expectation.getOwner().newParameterizedTypeReference(((UnboundTypeReference) expectation).getTypeParameter()).isSubtypeOf(clazz)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tList<LightweightBoundTypeArgument> hints = ((UnboundTypeReference) expectation).getAllHints();\n\t\t\t\tfor(LightweightBoundTypeArgument hint: hints) {\n\t\t\t\t\tLightweightTypeReference hintReference = hint.getTypeReference();\n\t\t\t\t\tif (hintReference.isSubtypeOf(clazz)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (expectation instanceof ParameterizedTypeReference) {\n\t\t\t\treturn expectation.isSubtypeOf(clazz);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":28860,"modified_method":"protected boolean isExpectedType(LightweightTypeReference expectation, Class<?> clazz) {\n\t\tif (expectation != null) {\n\t\t\tif (expectation.isResolved() && expectation.isSubtypeOf(clazz)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (expectation instanceof UnboundTypeReference) {\n\t\t\t\tif (expectation.getOwner().newParameterizedTypeReference(((UnboundTypeReference) expectation).getTypeParameter()).isSubtypeOf(clazz)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tList<LightweightBoundTypeArgument> hints = ((UnboundTypeReference) expectation).getAllHints();\n\t\t\t\tfor(LightweightBoundTypeArgument hint: hints) {\n\t\t\t\t\tLightweightTypeReference hintReference = hint.getTypeReference();\n\t\t\t\t\tif (hintReference != null && hintReference.isSubtypeOf(clazz)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (expectation instanceof ParameterizedTypeReference) {\n\t\t\t\treturn expectation.isSubtypeOf(clazz);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"68f85ef56a24b2170ac07fb40a155f06d27b9242","url":"https://github.com/eclipse/xtext"},{"original_method":"protected boolean isExpectedType(LightweightTypeReference expectation, Class<?> clazz) {\n\t\tif (expectation != null) {\n\t\t\tif (expectation.isResolved() && expectation.isSubtypeOf(clazz)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (expectation instanceof UnboundTypeReference) {\n\t\t\t\tif (expectation.getOwner().newParameterizedTypeReference(((UnboundTypeReference) expectation).getTypeParameter()).isSubtypeOf(clazz)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tList<LightweightBoundTypeArgument> hints = ((UnboundTypeReference) expectation).getAllHints();\n\t\t\t\tfor(LightweightBoundTypeArgument hint: hints) {\n\t\t\t\t\tLightweightTypeReference hintReference = hint.getTypeReference();\n\t\t\t\t\tif (hintReference.isSubtypeOf(clazz)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (expectation instanceof ParameterizedTypeReference) {\n\t\t\t\treturn expectation.isSubtypeOf(clazz);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":28861,"modified_method":"protected boolean isExpectedType(LightweightTypeReference expectation, Class<?> clazz) {\n\t\tif (expectation != null) {\n\t\t\tif (expectation.isResolved() && expectation.isSubtypeOf(clazz)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (expectation instanceof UnboundTypeReference) {\n\t\t\t\tif (expectation.getOwner().newParameterizedTypeReference(((UnboundTypeReference) expectation).getTypeParameter()).isSubtypeOf(clazz)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tList<LightweightBoundTypeArgument> hints = ((UnboundTypeReference) expectation).getAllHints();\n\t\t\t\tfor(LightweightBoundTypeArgument hint: hints) {\n\t\t\t\t\tLightweightTypeReference hintReference = hint.getTypeReference();\n\t\t\t\t\tif (hintReference != null && hintReference.isSubtypeOf(clazz)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (expectation instanceof ParameterizedTypeReference) {\n\t\t\t\treturn expectation.isSubtypeOf(clazz);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"573be49eb4406e442b6327cafa94934d6423f05a","url":"https://github.com/eclipse/xtext"},{"original_method":"public static boolean isFindBugsMarker(IMarker marker) {\n\t\ttry {\n\t\t\treturn marker.isSubtypeOf(FindBugsMarker.NAME);\n\t\t} catch (CoreException e) {\n\t\t\tFindbugsPlugin.getDefault().logException(e,\n\t\t\t\"Exception while checking FindBugs type on marker.\");\n\t\t}\n\t\treturn false;\n\t}","id":28862,"modified_method":"public static boolean isFindBugsMarker(IMarker marker) {\n\t\ttry {\n\t\t\treturn marker != null && marker.exists() && marker.isSubtypeOf(FindBugsMarker.NAME);\n\t\t} catch (CoreException e) {\n\t\t\tFindbugsPlugin.getDefault().logException(e,\n\t\t\t\"Exception while checking FindBugs type on marker.\");\n\t\t}\n\t\treturn false;\n\t}","commit_id":"d22df8c816b8d791636e52596c7df3ffc61a25c0","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Fish an IMarker out of given selection.\n\t *\n\t * @param selection the selection\n\t * @return the selected IMarker, or null if we can't find an IMarker\n\t *         in the selection\n\t */\n\tpublic static Set<IMarker> getMarkerFromSelection(ISelection selection) {\n\t\tSet<IMarker> markers = new HashSet<IMarker>();\n\t\tif(!(selection instanceof IStructuredSelection)){\n\t\t\treturn markers;\n\t\t}\n\t\tIStructuredSelection sSelection = (IStructuredSelection) selection;\n\t\tfor (Iterator<?> iter = sSelection.iterator(); iter.hasNext();) {\n\t\t\tObject next = iter.next();\n\t\t\tif(next instanceof IMarker){\n\t\t\t\tIMarker marker = (IMarker) next;\n\t\t\t\tif (!marker.exists() || !isFindBugsMarker(marker)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmarkers.add(marker);\n\t\t\t} else if (next instanceof BugGroup){\n\t\t\t\tBugGroup group = (BugGroup) next;\n\t\t\t\tmarkers.addAll(group.getAllMarkers());\n\t\t\t} else if (next instanceof IResource){\n\t\t\t\tIResource res = (IResource) next;\n\t\t\t\tIMarker[] markers2 = MarkerUtil.getAllMarkers(res);\n\t\t\t\tfor (IMarker marker : markers2) {\n\t\t\t\t\tmarkers.add(marker);\n\t\t\t\t}\n\t\t\t} else if (next instanceof IAdaptable){\n\t\t\t\tIAdaptable adapter = (IAdaptable) next;\n\t\t\t\tIMarker marker = (IMarker) adapter.getAdapter(IMarker.class);\n\t\t\t\tif (marker == null || !isFindBugsMarker(marker)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmarkers.add(marker);\n\t\t\t}\n\t\t}\n\t\treturn markers;\n\t}","id":28863,"modified_method":"/**\n\t * Fish an IMarker out of given selection.\n\t *\n\t * @param selection the selection\n\t * @return the selected IMarker, or null if we can't find an IMarker\n\t *         in the selection\n\t */\n\tpublic static Set<IMarker> getMarkerFromSelection(ISelection selection) {\n\t\tSet<IMarker> markers = new HashSet<IMarker>();\n\t\tif(!(selection instanceof IStructuredSelection)){\n\t\t\treturn markers;\n\t\t}\n\t\tIStructuredSelection sSelection = (IStructuredSelection) selection;\n\t\tfor (Iterator<?> iter = sSelection.iterator(); iter.hasNext();) {\n\t\t\tObject next = iter.next();\n\t\t\tif(next instanceof IMarker){\n\t\t\t\tIMarker marker = (IMarker) next;\n\t\t\t\tif (!isFindBugsMarker(marker)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmarkers.add(marker);\n\t\t\t} else if (next instanceof BugGroup){\n\t\t\t\tBugGroup group = (BugGroup) next;\n\t\t\t\tmarkers.addAll(group.getAllMarkers());\n\t\t\t} else if (next instanceof IResource){\n\t\t\t\tIResource res = (IResource) next;\n\t\t\t\tIMarker[] markers2 = MarkerUtil.getAllMarkers(res);\n\t\t\t\tfor (IMarker marker : markers2) {\n\t\t\t\t\tmarkers.add(marker);\n\t\t\t\t}\n\t\t\t} else if (next instanceof IAdaptable){\n\t\t\t\tIAdaptable adapter = (IAdaptable) next;\n\t\t\t\tIMarker marker = (IMarker) adapter.getAdapter(IMarker.class);\n\t\t\t\tif (marker == null || !isFindBugsMarker(marker)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmarkers.add(marker);\n\t\t\t}\n\t\t}\n\t\treturn markers;\n\t}","commit_id":"d22df8c816b8d791636e52596c7df3ffc61a25c0","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static IMarker getMarkerFromSingleSelection(ISelection selection) {\n\t\tif(!(selection instanceof IStructuredSelection)){\n\t\t\treturn null;\n\t\t}\n\t\tIStructuredSelection sSelection = (IStructuredSelection) selection;\n\t\tif(sSelection.size() != 1){\n\t\t\treturn null;\n\t\t}\n\n\t\tObject next = sSelection.getFirstElement();\n\t\tif(next instanceof IMarker){\n\t\t\tIMarker marker = (IMarker) next;\n\t\t\tif (!marker.exists() || !isFindBugsMarker(marker)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn marker;\n\t\t} else if (next instanceof BugGroup){\n\t\t\treturn null;\n\t\t} else if (next instanceof IResource){\n\t\t\treturn null;\n\t\t} else if (next instanceof IAdaptable){\n\t\t\tIAdaptable adapter = (IAdaptable) next;\n\t\t\tIMarker marker = (IMarker) adapter.getAdapter(IMarker.class);\n\t\t\tif (marker == null || !isFindBugsMarker(marker)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn marker;\n\t\t}\n\t\treturn null;\n\t}","id":28864,"modified_method":"public static IMarker getMarkerFromSingleSelection(ISelection selection) {\n\t\tif(!(selection instanceof IStructuredSelection)){\n\t\t\treturn null;\n\t\t}\n\t\tIStructuredSelection sSelection = (IStructuredSelection) selection;\n\t\tif(sSelection.size() != 1){\n\t\t\treturn null;\n\t\t}\n\n\t\tObject next = sSelection.getFirstElement();\n\t\tif(next instanceof IMarker){\n\t\t\tIMarker marker = (IMarker) next;\n\t\t\tif (!isFindBugsMarker(marker)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn marker;\n\t\t} else if (next instanceof BugGroup){\n\t\t\treturn null;\n\t\t} else if (next instanceof IResource){\n\t\t\treturn null;\n\t\t} else if (next instanceof IAdaptable){\n\t\t\tIAdaptable adapter = (IAdaptable) next;\n\t\t\tIMarker marker = (IMarker) adapter.getAdapter(IMarker.class);\n\t\t\tif (marker == null || !isFindBugsMarker(marker)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn marker;\n\t\t}\n\t\treturn null;\n\t}","commit_id":"d22df8c816b8d791636e52596c7df3ffc61a25c0","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n\tpublic Object getAdapter(Object adaptableObject, Class adapterType) {\r\n\t\tif (adapterType == IPropertySheetPage.class && (adaptableObject instanceof JavaEditor)) {\r\n\t\t\tIWorkbenchPart part = (IWorkbenchPart) adaptableObject;\r\n\t\t\tIViewReference[] references = part.getSite().getPage().getViewReferences();\r\n\t\t\tfor (IViewReference viewReference : references) {\r\n\t\t\t\tif (\"de.tobject.findbugs.view.bugtreeview\".equals(viewReference.getId())) {\r\n\t\t\t\t\tIWorkbenchPart workbenchPart = viewReference.getPart(false);\r\n\t\t\t\t\tif(workbenchPart != null){\r\n\t\t\t\t\t\treturn new JavaEditorTabbedPropertySheetPage(workbenchPart);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// return nothing to get rid of errors generated through\r\n\t\t\t// TabbedPropertySheetAdapterFactory which is adapting to CommonNavigator\r\n\t\t\t// class\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (adapterType == IPropertySource.class) {\r\n\t\t\tif (adaptableObject instanceof BugPattern\r\n\t\t\t\t\t|| adaptableObject instanceof BugInstance\r\n\t\t\t\t\t|| adaptableObject instanceof BugGroup) {\r\n\t\t\t\treturn new PropertySource(adaptableObject);\r\n\t\t\t}\r\n\t\t\tIMarker marker = null;\r\n\t\t\tif (adaptableObject instanceof IMarker) {\r\n\t\t\t\tmarker = (IMarker) adaptableObject;\r\n\t\t\t} else if (adaptableObject instanceof IAdaptable) {\r\n\t\t\t\tmarker = (IMarker) ((IAdaptable) adaptableObject)\r\n\t\t\t\t\t\t.getAdapter(IMarker.class);\r\n\t\t\t}\r\n\t\t\tif (marker == null || !marker.exists() || !MarkerUtil.isFindBugsMarker(marker)) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\treturn new MarkerPropertySource(marker);\r\n\t\t}\r\n\t\tif (adapterType == BugInstance.class) {\r\n\t\t\tif (adaptableObject instanceof BugInstance) {\r\n\t\t\t\tBugInstance bug = (BugInstance) adaptableObject;\r\n\t\t\t\treturn new PropertySource(bug);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (adapterType == BugPattern.class) {\r\n\t\t\tif (adaptableObject instanceof BugPattern) {\r\n\t\t\t\tBugPattern bug = (BugPattern) adaptableObject;\r\n\t\t\t\treturn new PropertySource(bug);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}","id":28865,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n\tpublic Object getAdapter(Object adaptableObject, Class adapterType) {\r\n\t\tif (adapterType == IPropertySheetPage.class && (adaptableObject instanceof JavaEditor)) {\r\n\t\t\tIWorkbenchPart part = (IWorkbenchPart) adaptableObject;\r\n\t\t\tIViewReference[] references = part.getSite().getPage().getViewReferences();\r\n\t\t\tfor (IViewReference viewReference : references) {\r\n\t\t\t\tif (\"de.tobject.findbugs.view.bugtreeview\".equals(viewReference.getId())) {\r\n\t\t\t\t\tIWorkbenchPart workbenchPart = viewReference.getPart(false);\r\n\t\t\t\t\tif(workbenchPart != null){\r\n\t\t\t\t\t\treturn new JavaEditorTabbedPropertySheetPage(workbenchPart);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// return nothing to get rid of errors generated through\r\n\t\t\t// TabbedPropertySheetAdapterFactory which is adapting to CommonNavigator\r\n\t\t\t// class\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (adapterType == IPropertySource.class) {\r\n\t\t\tif (adaptableObject instanceof BugPattern\r\n\t\t\t\t\t|| adaptableObject instanceof BugInstance\r\n\t\t\t\t\t|| adaptableObject instanceof BugGroup) {\r\n\t\t\t\treturn new PropertySource(adaptableObject);\r\n\t\t\t}\r\n\t\t\tIMarker marker = null;\r\n\t\t\tif (adaptableObject instanceof IMarker) {\r\n\t\t\t\tmarker = (IMarker) adaptableObject;\r\n\t\t\t} else if (adaptableObject instanceof IAdaptable) {\r\n\t\t\t\tmarker = (IMarker) ((IAdaptable) adaptableObject)\r\n\t\t\t\t\t\t.getAdapter(IMarker.class);\r\n\t\t\t}\r\n\t\t\tif (!MarkerUtil.isFindBugsMarker(marker)) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\treturn new MarkerPropertySource(marker);\r\n\t\t}\r\n\t\tif (adapterType == BugInstance.class) {\r\n\t\t\tif (adaptableObject instanceof BugInstance) {\r\n\t\t\t\tBugInstance bug = (BugInstance) adaptableObject;\r\n\t\t\t\treturn new PropertySource(bug);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (adapterType == BugPattern.class) {\r\n\t\t\tif (adaptableObject instanceof BugPattern) {\r\n\t\t\t\tBugPattern bug = (BugPattern) adaptableObject;\r\n\t\t\t\treturn new PropertySource(bug);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}","commit_id":"d22df8c816b8d791636e52596c7df3ffc61a25c0","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public long createRecord(final ORecordId iRid, final byte[] iContent, final byte iRecordType, final int iMode,\r\n\t\t\tORecordCallback<Long> iCallback) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal OCluster cluster = getClusterById(iRid.clusterId);\r\n\r\n\t\tif (txManager.isCommitting())\r\n\t\t\tiRid.clusterPosition = txManager\r\n\t\t\t\t\t.createRecord(txManager.getCurrentTransaction().getId(), cluster, iRid, iContent, iRecordType);\r\n\t\telse {\r\n\t\t\tiRid.clusterPosition = createRecord(cluster, iContent, iRecordType);\r\n\r\n\t\t\tif(OGlobalConfiguration.NON_TX_RECORD_UPDATE_SYNCH.getValueAsBoolean())\r\n\t\t\t\tsynch();\r\n\t\t}\r\n\r\n\t\treturn iRid.clusterPosition;\r\n\t}","id":28866,"modified_method":"public long createRecord(final ORecordId iRid, final byte[] iContent, final byte iRecordType, final int iMode,\r\n\t\t\tORecordCallback<Long> iCallback) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal OCluster cluster = getClusterById(iRid.clusterId);\r\n\r\n\t\tif (txManager.isCommitting())\r\n\t\t\tiRid.clusterPosition = txManager\r\n\t\t\t\t\t.createRecord(txManager.getCurrentTransaction().getId(), cluster, iRid, iContent, iRecordType);\r\n\t\telse {\r\n\t\t\tfinal OPhysicalPosition ppos = createRecord(cluster, iContent, iRecordType, iRid);\r\n\r\n\t\t\tif(OGlobalConfiguration.NON_TX_RECORD_UPDATE_SYNCH.getValueAsBoolean())\r\n\t\t\t\tsynchRecordUpdate(cluster, ppos);\r\n\t\t}\r\n\r\n\t\treturn iRid.clusterPosition;\r\n\t}","commit_id":"211af91b00f1b58bd0c28219831c319ea4cfb9c6","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int updateRecord(final ORecordId iRid, final byte[] iContent, final int iVersion, final byte iRecordType, final int iMode,\r\n\t\t\tORecordCallback<Integer> iCallback) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal OCluster cluster = getClusterById(iRid.clusterId);\r\n\r\n\t\tif (txManager.isCommitting())\r\n\t\t\treturn txManager.updateRecord(txManager.getCurrentTransaction().getId(), cluster, iRid, iContent, iVersion, iRecordType);\r\n\t\telse {\r\n\t\t\tfinal int version = updateRecord(cluster, iRid, iContent, iVersion, iRecordType);\r\n\r\n\t\t\tif(version > -1 && OGlobalConfiguration.NON_TX_RECORD_UPDATE_SYNCH.getValueAsBoolean())\r\n\t\t\t\tsynch();\r\n\r\n\t\t\treturn version;\r\n\t\t}\r\n\t}","id":28867,"modified_method":"public int updateRecord(final ORecordId iRid, final byte[] iContent, final int iVersion, final byte iRecordType, final int iMode,\r\n\t\t\tORecordCallback<Integer> iCallback) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal OCluster cluster = getClusterById(iRid.clusterId);\r\n\r\n\t\tif (txManager.isCommitting())\r\n\t\t\treturn txManager.updateRecord(txManager.getCurrentTransaction().getId(), cluster, iRid, iContent, iVersion, iRecordType);\r\n\t\telse {\r\n\t\t\tfinal OPhysicalPosition ppos = updateRecord(cluster, iRid, iContent, iVersion, iRecordType);\r\n\r\n\t\t\tif(ppos != null && OGlobalConfiguration.NON_TX_RECORD_UPDATE_SYNCH.getValueAsBoolean())\r\n\t\t\t\tsynchRecordUpdate(cluster, ppos);\r\n\r\n\t\t\tif(ppos != null)\r\n\t\t\t\treturn ppos.version;\r\n\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t}","commit_id":"211af91b00f1b58bd0c28219831c319ea4cfb9c6","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected int updateRecord(final OCluster iClusterSegment, final ORecordId iRid, final byte[] iContent, final int iVersion,\r\n\t\t\tfinal byte iRecordType) {\r\n\t\tif (iClusterSegment == null)\r\n\t\t\tthrow new OStorageException(\"Cluster not defined for record: \" + iRid);\r\n\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tlock.acquireSharedLock();\r\n\r\n\t\ttry {\r\n\t\t\tlockManager.acquireLock(Thread.currentThread(), iRid, LOCK.EXCLUSIVE);\r\n\t\t\ttry {\r\n\t\t\t\tfinal OPhysicalPosition ppos = iClusterSegment.getPhysicalPosition(iRid.clusterPosition, new OPhysicalPosition());\r\n\t\t\t\tif (!checkForRecordValidity(ppos))\r\n\t\t\t\t\t// DELETED\r\n\t\t\t\t\treturn -1;\r\n\r\n\t\t\t\t// VERSION CONTROL CHECK\r\n\t\t\t\tswitch (iVersion) {\r\n\t\t\t\t// DOCUMENT UPDATE, NO VERSION CONTROL\r\n\t\t\t\tcase -1:\r\n\t\t\t\t\t++ppos.version;\r\n\t\t\t\t\tiClusterSegment.updateVersion(iRid.clusterPosition, ppos.version);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// DOCUMENT UPDATE, NO VERSION CONTROL, NO VERSION UPDATE\r\n\t\t\t\tcase -2:\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// MVCC CONTROL AND RECORD UPDATE OR WRONG VERSION VALUE\r\n\t\t\t\t\tif (iVersion > -1) {\r\n\t\t\t\t\t\t// MVCC TRANSACTION: CHECK IF VERSION IS THE SAME\r\n\t\t\t\t\t\tif (iVersion != ppos.version)\r\n\t\t\t\t\t\t\tthrow new OConcurrentModificationException(\r\n\t\t\t\t\t\t\t\t\t\"Cannot update record \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ iRid\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" in storage '\"\r\n\t\t\t\t\t\t\t\t\t\t\t+ name\r\n\t\t\t\t\t\t\t\t\t\t\t+ \"' because the version is not the latest. Probably you are updating an old record or it has been modified by another user (db=v\"\r\n\t\t\t\t\t\t\t\t\t\t\t+ ppos.version + \" your=v\" + iVersion + \")\", iRid, ppos.version, iVersion);\r\n\t\t\t\t\t\t++ppos.version;\r\n\t\t\t\t\t\tiClusterSegment.updateVersion(iRid.clusterPosition, ppos.version);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// DOCUMENT ROLLBACKED\r\n\t\t\t\t\t\tppos.version = iVersion - Integer.MIN_VALUE;\r\n\t\t\t\t\t\tiClusterSegment.updateVersion(iRid.clusterPosition, ppos.version);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (ppos.type != iRecordType)\r\n\t\t\t\t\tiClusterSegment.updateRecordType(iRid.clusterPosition, iRecordType);\r\n\r\n\t\t\t\tfinal long newDataSegmentOffset;\r\n\t\t\t\tif (ppos.dataChunkPosition == -1)\r\n\t\t\t\t\t// WAS EMPTY FIRST TIME, CREATE IT NOW\r\n\t\t\t\t\tnewDataSegmentOffset = getDataSegment(ppos.dataSegmentId).addRecord(iRid, iContent);\r\n\t\t\t\telse\r\n\t\t\t\t\t// UPDATE IT\r\n\t\t\t\t\tnewDataSegmentOffset = getDataSegment(ppos.dataSegmentId).setRecord(ppos.dataChunkPosition, iRid, iContent);\r\n\r\n\t\t\t\tif (newDataSegmentOffset != ppos.dataChunkPosition)\r\n\t\t\t\t\t// UPDATE DATA SEGMENT OFFSET WITH THE NEW PHYSICAL POSITION\r\n\t\t\t\t\tiClusterSegment.setPhysicalPosition(iRid.clusterPosition, ppos.dataSegmentId, newDataSegmentOffset, iRecordType,\r\n\t\t\t\t\t\t\tppos.version);\r\n\r\n\t\t\t\tincrementVersion();\r\n\r\n\t\t\t\treturn ppos.version;\r\n\r\n\t\t\t} finally {\r\n\t\t\t\tlockManager.releaseLock(Thread.currentThread(), iRid, LOCK.EXCLUSIVE);\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on updating record \" + iRid + \" (cluster: \" + iClusterSegment + \")\", e);\r\n\r\n\t\t} finally {\r\n\t\t\tlock.releaseSharedLock();\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(PROFILER_UPDATE_RECORD, timer);\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}","id":28868,"modified_method":"protected OPhysicalPosition updateRecord(final OCluster iClusterSegment, final ORecordId iRid, final byte[] iContent, final int iVersion,\r\n\t\t\tfinal byte iRecordType) {\r\n\t\tif (iClusterSegment == null)\r\n\t\t\tthrow new OStorageException(\"Cluster not defined for record: \" + iRid);\r\n\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tlock.acquireSharedLock();\r\n\r\n\t\ttry {\r\n\t\t\tlockManager.acquireLock(Thread.currentThread(), iRid, LOCK.EXCLUSIVE);\r\n\t\t\ttry {\r\n\t\t\t\tfinal OPhysicalPosition ppos = iClusterSegment.getPhysicalPosition(iRid.clusterPosition, new OPhysicalPosition());\r\n\t\t\t\tif (!checkForRecordValidity(ppos))\r\n\t\t\t\t\t// DELETED\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t// VERSION CONTROL CHECK\r\n\t\t\t\tswitch (iVersion) {\r\n\t\t\t\t// DOCUMENT UPDATE, NO VERSION CONTROL\r\n\t\t\t\tcase -1:\r\n\t\t\t\t\t++ppos.version;\r\n\t\t\t\t\tiClusterSegment.updateVersion(iRid.clusterPosition, ppos.version);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// DOCUMENT UPDATE, NO VERSION CONTROL, NO VERSION UPDATE\r\n\t\t\t\tcase -2:\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// MVCC CONTROL AND RECORD UPDATE OR WRONG VERSION VALUE\r\n\t\t\t\t\tif (iVersion > -1) {\r\n\t\t\t\t\t\t// MVCC TRANSACTION: CHECK IF VERSION IS THE SAME\r\n\t\t\t\t\t\tif (iVersion != ppos.version)\r\n\t\t\t\t\t\t\tthrow new OConcurrentModificationException(\r\n\t\t\t\t\t\t\t\t\t\"Cannot update record \"\r\n\t\t\t\t\t\t\t\t\t\t\t+ iRid\r\n\t\t\t\t\t\t\t\t\t\t\t+ \" in storage '\"\r\n\t\t\t\t\t\t\t\t\t\t\t+ name\r\n\t\t\t\t\t\t\t\t\t\t\t+ \"' because the version is not the latest. Probably you are updating an old record or it has been modified by another user (db=v\"\r\n\t\t\t\t\t\t\t\t\t\t\t+ ppos.version + \" your=v\" + iVersion + \")\", iRid, ppos.version, iVersion);\r\n\t\t\t\t\t\t++ppos.version;\r\n\t\t\t\t\t\tiClusterSegment.updateVersion(iRid.clusterPosition, ppos.version);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// DOCUMENT ROLLBACKED\r\n\t\t\t\t\t\tppos.version = iVersion - Integer.MIN_VALUE;\r\n\t\t\t\t\t\tiClusterSegment.updateVersion(iRid.clusterPosition, ppos.version);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (ppos.type != iRecordType)\r\n\t\t\t\t\tiClusterSegment.updateRecordType(iRid.clusterPosition, iRecordType);\r\n\r\n\t\t\t\tfinal long newDataSegmentOffset;\r\n\t\t\t\tif (ppos.dataChunkPosition == -1)\r\n\t\t\t\t\t// WAS EMPTY FIRST TIME, CREATE IT NOW\r\n\t\t\t\t\tnewDataSegmentOffset = getDataSegment(ppos.dataSegmentId).addRecord(iRid, iContent);\r\n\t\t\t\telse\r\n\t\t\t\t\t// UPDATE IT\r\n\t\t\t\t\tnewDataSegmentOffset = getDataSegment(ppos.dataSegmentId).setRecord(ppos.dataChunkPosition, iRid, iContent);\r\n\r\n\t\t\t\tif (newDataSegmentOffset != ppos.dataChunkPosition)\r\n\t\t\t\t\t// UPDATE DATA SEGMENT OFFSET WITH THE NEW PHYSICAL POSITION\r\n\t\t\t\t\tiClusterSegment.setPhysicalPosition(iRid.clusterPosition, ppos.dataSegmentId, newDataSegmentOffset, iRecordType,\r\n\t\t\t\t\t\t\tppos.version);\r\n\r\n\t\t\t\tincrementVersion();\r\n\r\n\t\t\t\tppos.dataChunkPosition = newDataSegmentOffset;\r\n\t\t\t\treturn ppos;\r\n\r\n\t\t\t} finally {\r\n\t\t\t\tlockManager.releaseLock(Thread.currentThread(), iRid, LOCK.EXCLUSIVE);\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on updating record \" + iRid + \" (cluster: \" + iClusterSegment + \")\", e);\r\n\r\n\t\t} finally {\r\n\t\t\tlock.releaseSharedLock();\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(PROFILER_UPDATE_RECORD, timer);\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}","commit_id":"211af91b00f1b58bd0c28219831c319ea4cfb9c6","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean deleteRecord(final ORecordId iRid, final int iVersion, final int iMode, ORecordCallback<Boolean> iCallback) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal OCluster cluster = getClusterById(iRid.clusterId);\r\n\r\n\t\tif (txManager.isCommitting())\r\n\t\t\treturn txManager.deleteRecord(txManager.getCurrentTransaction().getId(), cluster, iRid.clusterPosition, iVersion);\r\n\t\telse {\r\n\t\t\tfinal boolean deleted = deleteRecord(cluster, iRid, iVersion);\r\n\r\n\t\t\tif(deleted && OGlobalConfiguration.NON_TX_RECORD_UPDATE_SYNCH.getValueAsBoolean())\r\n\t\t\t\tsynch();\r\n\r\n\t\t\treturn deleted;\r\n\t\t}\r\n\t}","id":28869,"modified_method":"public boolean deleteRecord(final ORecordId iRid, final int iVersion, final int iMode, ORecordCallback<Boolean> iCallback) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal OCluster cluster = getClusterById(iRid.clusterId);\r\n\r\n\t\tif (txManager.isCommitting())\r\n\t\t\treturn txManager.deleteRecord(txManager.getCurrentTransaction().getId(), cluster, iRid.clusterPosition, iVersion);\r\n\t\telse {\r\n\t\t\tfinal OPhysicalPosition ppos = deleteRecord(cluster, iRid, iVersion);\r\n\t\t\tif(ppos != null && OGlobalConfiguration.NON_TX_RECORD_UPDATE_SYNCH.getValueAsBoolean())\r\n\t\t\t\tsynchRecordUpdate(cluster, ppos);\r\n\r\n\t\t\treturn ppos != null;\r\n\t\t}\r\n\t}","commit_id":"211af91b00f1b58bd0c28219831c319ea4cfb9c6","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected boolean deleteRecord(final OCluster iClusterSegment, final ORecordId iRid, final int iVersion) {\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tlock.acquireExclusiveLock();\r\n\t\ttry {\r\n\r\n\t\t\tlockManager.acquireLock(Thread.currentThread(), iRid, LOCK.EXCLUSIVE);\r\n\t\t\ttry {\r\n\r\n\t\t\t\tfinal OPhysicalPosition ppos = iClusterSegment.getPhysicalPosition(iRid.clusterPosition, new OPhysicalPosition());\r\n\r\n\t\t\t\tif (!checkForRecordValidity(ppos))\r\n\t\t\t\t\t// ALREADY DELETED\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t// MVCC TRANSACTION: CHECK IF VERSION IS THE SAME\r\n\t\t\t\tif (iVersion > -1 && ppos.version != iVersion)\r\n\t\t\t\t\tthrow new OConcurrentModificationException(\r\n\t\t\t\t\t\t\t\"Cannot delete the record \"\r\n\t\t\t\t\t\t\t\t\t+ iRid\r\n\t\t\t\t\t\t\t\t\t+ \" in storage '\"\r\n\t\t\t\t\t\t\t\t\t+ name\r\n\t\t\t\t\t\t\t\t\t+ \"' because the version is not the latest. Probably you are deleting an old record or it has been modified by another user (db=v\"\r\n\t\t\t\t\t\t\t\t\t+ ppos.version + \" your=v\" + iVersion + \")\", iRid, ppos.version, iVersion);\r\n\r\n\t\t\t\tif (ppos.dataChunkPosition > -1)\r\n\t\t\t\t\tgetDataSegment(ppos.dataSegmentId).deleteRecord(ppos.dataChunkPosition);\r\n\r\n\t\t\t\tiClusterSegment.removePhysicalPosition(iRid.clusterPosition, ppos);\r\n\r\n\t\t\t\tincrementVersion();\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t} finally {\r\n\t\t\t\tlockManager.releaseLock(Thread.currentThread(), iRid, LOCK.EXCLUSIVE);\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on deleting record \" + iRid + \"( cluster: \" + iClusterSegment + \")\", e);\r\n\r\n\t\t} finally {\r\n\t\t\tlock.releaseExclusiveLock();\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(PROFILER_DELETE_RECORD, timer);\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}","id":28870,"modified_method":"protected OPhysicalPosition deleteRecord(final OCluster iClusterSegment, final ORecordId iRid, final int iVersion) {\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tlock.acquireExclusiveLock();\r\n\t\ttry {\r\n\r\n\t\t\tlockManager.acquireLock(Thread.currentThread(), iRid, LOCK.EXCLUSIVE);\r\n\t\t\ttry {\r\n\r\n\t\t\t\tfinal OPhysicalPosition ppos = iClusterSegment.getPhysicalPosition(iRid.clusterPosition, new OPhysicalPosition());\r\n\r\n\t\t\t\tif (!checkForRecordValidity(ppos))\r\n\t\t\t\t\t// ALREADY DELETED\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t// MVCC TRANSACTION: CHECK IF VERSION IS THE SAME\r\n\t\t\t\tif (iVersion > -1 && ppos.version != iVersion)\r\n\t\t\t\t\tthrow new OConcurrentModificationException(\r\n\t\t\t\t\t\t\t\"Cannot delete the record \"\r\n\t\t\t\t\t\t\t\t\t+ iRid\r\n\t\t\t\t\t\t\t\t\t+ \" in storage '\"\r\n\t\t\t\t\t\t\t\t\t+ name\r\n\t\t\t\t\t\t\t\t\t+ \"' because the version is not the latest. Probably you are deleting an old record or it has been modified by another user (db=v\"\r\n\t\t\t\t\t\t\t\t\t+ ppos.version + \" your=v\" + iVersion + \")\", iRid, ppos.version, iVersion);\r\n\r\n\t\t\t\tif (ppos.dataChunkPosition > -1)\r\n\t\t\t\t\tgetDataSegment(ppos.dataSegmentId).deleteRecord(ppos.dataChunkPosition);\r\n\r\n\t\t\t\tiClusterSegment.removePhysicalPosition(iRid.clusterPosition, ppos);\r\n\r\n\t\t\t\tincrementVersion();\r\n\r\n\t\t\t\treturn ppos;\r\n\r\n\t\t\t} finally {\r\n\t\t\t\tlockManager.releaseLock(Thread.currentThread(), iRid, LOCK.EXCLUSIVE);\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on deleting record \" + iRid + \"( cluster: \" + iClusterSegment + \")\", e);\r\n\r\n\t\t} finally {\r\n\t\t\tlock.releaseExclusiveLock();\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(PROFILER_DELETE_RECORD, timer);\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}","commit_id":"211af91b00f1b58bd0c28219831c319ea4cfb9c6","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected long createRecord(final OCluster iClusterSegment, final byte[] iContent, final byte iRecordType) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tif (iContent == null)\r\n\t\t\tthrow new IllegalArgumentException(\"Record is null\");\r\n\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tlock.acquireSharedLock();\r\n\t\ttry {\r\n\r\n\t\t\tfinal int dataSegment = getDataSegmentForRecord(iClusterSegment, iContent);\r\n\t\t\tfinal ODataLocal data = getDataSegment(dataSegment);\r\n\r\n\t\t\tfinal ORecordId rid = new ORecordId(iClusterSegment.getId());\r\n\t\t\trid.clusterPosition = iClusterSegment.addPhysicalPosition(-1, -1, iRecordType);\r\n\r\n\t\t\tfinal long dataOffset = data.addRecord(rid, iContent);\r\n\r\n\t\t\t// UPDATE THE POSITION IN CLUSTER WITH THE POSITION OF RECORD IN\r\n\t\t\t// DATA\r\n\t\t\tiClusterSegment.setPhysicalPosition(rid.clusterPosition, dataSegment, dataOffset, iRecordType, 0);\r\n\r\n\t\t\tincrementVersion();\r\n\r\n\t\t\treturn rid.clusterPosition;\r\n\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on creating record in cluster: \" + iClusterSegment, e);\r\n\t\t\treturn -1;\r\n\t\t} finally {\r\n\t\t\tlock.releaseSharedLock();\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(PROFILER_CREATE_RECORD, timer);\r\n\t\t}\r\n\t}","id":28871,"modified_method":"protected OPhysicalPosition createRecord(final OCluster iClusterSegment, final byte[] iContent,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t final byte iRecordType, final ORecordId iRid) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tif (iContent == null)\r\n\t\t\tthrow new IllegalArgumentException(\"Record is null\");\r\n\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tlock.acquireSharedLock();\r\n\t\ttry {\r\n\r\n\t\t\tfinal int dataSegment = getDataSegmentForRecord(iClusterSegment, iContent);\r\n\t\t\tfinal ODataLocal data = getDataSegment(dataSegment);\r\n\r\n\t\t\tfinal ORecordId rid = new ORecordId(iClusterSegment.getId());\r\n\t\t\trid.clusterPosition = iClusterSegment.addPhysicalPosition(-1, -1, iRecordType);\r\n\r\n\t\t\tfinal long dataOffset = data.addRecord(rid, iContent);\r\n\r\n\t\t\t// UPDATE THE POSITION IN CLUSTER WITH THE POSITION OF RECORD IN\r\n\t\t\t// DATA\r\n\t\t\tiClusterSegment.setPhysicalPosition(rid.clusterPosition, dataSegment, dataOffset, iRecordType, 0);\r\n\r\n\t\t\tincrementVersion();\r\n\r\n\t\t\tfinal OPhysicalPosition ppos = new OPhysicalPosition();\r\n\t\t\tppos.dataChunkPosition = dataOffset;\r\n\t\t\tppos.dataSegmentId = dataSegment;\r\n\t\t\tppos.type = iRecordType;\r\n\t\t\tppos.version = 0;\r\n\r\n\t\t\tiRid.clusterPosition = rid.clusterPosition;\r\n\r\n\t\t\treturn ppos;\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on creating record in cluster: \" + iClusterSegment, e);\r\n\t\t\treturn null;\r\n\t\t} finally {\r\n\t\t\tlock.releaseSharedLock();\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(PROFILER_CREATE_RECORD, timer);\r\n\t\t}\r\n\t}","commit_id":"211af91b00f1b58bd0c28219831c319ea4cfb9c6","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Stores the new content in a new position, then saves in the log the coords of the new position. At free time the\r\n\t * \r\n\t * @param iTxId\r\n\t * @param iClusterSegment\r\n\t * @param iRid\r\n\t * @param iContent\r\n\t * @param iVersion\r\n\t * @param iRecordType\r\n\t * @return\r\n\t */\r\n\r\n\tprotected int updateRecord(final int iTxId, final OCluster iClusterSegment, final ORecordId iRid, final byte[] iContent,\r\n\t\t\tfinal int iVersion, final byte iRecordType) {\r\n\t\ttry {\r\n\t\t\t// READ CURRENT RECORD CONTENT\r\n\t\t\tfinal ORawBuffer buffer = storage.readRecord(iClusterSegment, iRid, false);\r\n\r\n\t\t\t// SAVE INTO THE LOG THE POSITION OF THE OLD RECORD JUST DELETED. IF TX FAILS AT THIS POINT AS ABOVE\r\n\t\t\ttxSegment.addLog(OTxSegment.OPERATION_UPDATE, iTxId, iRid.clusterId, iRid.clusterPosition, iRecordType, buffer.version,\r\n\t\t\t\t\tbuffer.buffer);\r\n\r\n\t\t\treturn storage.updateRecord(iClusterSegment, iRid, iContent, iVersion, iRecordType);\r\n\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on updating entry #\" + iRid + \" in log segment: \" + iClusterSegment, e,\r\n\t\t\t\t\tOTransactionException.class);\r\n\t\t}\r\n\t\treturn -1;\r\n\t}","id":28872,"modified_method":"/**\r\n\t * Stores the new content in a new position, then saves in the log the coords of the new position. At free time the\r\n\t * \r\n\t * @param iTxId\r\n\t * @param iClusterSegment\r\n\t * @param iRid\r\n\t * @param iContent\r\n\t * @param iVersion\r\n\t * @param iRecordType\r\n\t * @return\r\n\t */\r\n\r\n\tprotected int updateRecord(final int iTxId, final OCluster iClusterSegment, final ORecordId iRid, final byte[] iContent,\r\n\t\t\tfinal int iVersion, final byte iRecordType) {\r\n\t\ttry {\r\n\t\t\t// READ CURRENT RECORD CONTENT\r\n\t\t\tfinal ORawBuffer buffer = storage.readRecord(iClusterSegment, iRid, false);\r\n\r\n\t\t\t// SAVE INTO THE LOG THE POSITION OF THE OLD RECORD JUST DELETED. IF TX FAILS AT THIS POINT AS ABOVE\r\n\t\t\ttxSegment.addLog(OTxSegment.OPERATION_UPDATE, iTxId, iRid.clusterId, iRid.clusterPosition, iRecordType, buffer.version,\r\n\t\t\t\t\tbuffer.buffer);\r\n\r\n\t\t\tfinal OPhysicalPosition ppos = storage.updateRecord(iClusterSegment, iRid, iContent, iVersion, iRecordType);\r\n\t\t\tif(ppos != null)\r\n\t\t\t\treturn ppos.version;\r\n\r\n\t\t\treturn -1;\r\n\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on updating entry #\" + iRid + \" in log segment: \" + iClusterSegment, e,\r\n\t\t\t\t\tOTransactionException.class);\r\n\t\t}\r\n\t\treturn -1;\r\n\t}","commit_id":"211af91b00f1b58bd0c28219831c319ea4cfb9c6","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected long createRecord(final int iTxId, final OCluster iClusterSegment, final ORecordId iRid, final byte[] iContent,\r\n\t\t\tfinal byte iRecordType) {\r\n\t\tiRid.clusterPosition = -1;\r\n\r\n\t\ttry {\r\n\t\t\tiRid.clusterPosition = storage.createRecord(iClusterSegment, iContent, iRecordType);\r\n\r\n\t\t\t// SAVE INTO THE LOG THE POSITION OF THE RECORD JUST CREATED. IF TX FAILS AT THIS POINT A GHOST RECORD IS CREATED UNTIL DEFRAG\r\n\t\t\ttxSegment.addLog(OTxSegment.OPERATION_CREATE, iTxId, iRid.clusterId, iRid.clusterPosition, iRecordType, 0, null);\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on creating entry in log segment: \" + iClusterSegment, e,\r\n\t\t\t\t\tOTransactionException.class);\r\n\t\t}\r\n\r\n\t\treturn iRid.clusterPosition;\r\n\t}","id":28873,"modified_method":"protected long createRecord(final int iTxId, final OCluster iClusterSegment, final ORecordId iRid, final byte[] iContent,\r\n\t\t\tfinal byte iRecordType) {\r\n\t\tiRid.clusterPosition = -1;\r\n\r\n\t\ttry {\r\n\t\t\tstorage.createRecord(iClusterSegment, iContent, iRecordType, iRid);\r\n\r\n\t\t\t// SAVE INTO THE LOG THE POSITION OF THE RECORD JUST CREATED. IF TX FAILS AT THIS POINT A GHOST RECORD IS CREATED UNTIL DEFRAG\r\n\t\t\ttxSegment.addLog(OTxSegment.OPERATION_CREATE, iTxId, iRid.clusterId, iRid.clusterPosition, iRecordType, 0, null);\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on creating entry in log segment: \" + iClusterSegment, e,\r\n\t\t\t\t\tOTransactionException.class);\r\n\t\t}\r\n\r\n\t\treturn iRid.clusterPosition;\r\n\t}","commit_id":"211af91b00f1b58bd0c28219831c319ea4cfb9c6","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected boolean deleteRecord(final int iTxId, final OCluster iClusterSegment, final long iPosition, final int iVersion) {\r\n\t\ttry {\r\n\t\t\tfinal ORecordId rid = new ORecordId(iClusterSegment.getId(), iPosition);\r\n\r\n\t\t\t// READ CURRENT RECORD CONTENT\r\n\t\t\tfinal ORawBuffer buffer = storage.readRecord(iClusterSegment, rid, false);\r\n\r\n\t\t\t// SAVE INTO THE LOG THE OLD RECORD\r\n\t\t\ttxSegment.addLog(OTxSegment.OPERATION_DELETE, iTxId, iClusterSegment.getId(), iPosition, buffer.recordType, buffer.version,\r\n\t\t\t\t\tbuffer.buffer);\r\n\r\n\t\t\treturn storage.deleteRecord(iClusterSegment, rid, iVersion);\r\n\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on deleting entry #\" + iPosition + \" in log segment: \" + iClusterSegment, e,\r\n\t\t\t\t\tOTransactionException.class);\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":28874,"modified_method":"protected boolean deleteRecord(final int iTxId, final OCluster iClusterSegment, final long iPosition, final int iVersion) {\r\n\t\ttry {\r\n\t\t\tfinal ORecordId rid = new ORecordId(iClusterSegment.getId(), iPosition);\r\n\r\n\t\t\t// READ CURRENT RECORD CONTENT\r\n\t\t\tfinal ORawBuffer buffer = storage.readRecord(iClusterSegment, rid, false);\r\n\r\n\t\t\t// SAVE INTO THE LOG THE OLD RECORD\r\n\t\t\ttxSegment.addLog(OTxSegment.OPERATION_DELETE, iTxId, iClusterSegment.getId(), iPosition, buffer.recordType, buffer.version,\r\n\t\t\t\t\tbuffer.buffer);\r\n\r\n\t\t\treturn storage.deleteRecord(iClusterSegment, rid, iVersion) != null;\r\n\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on deleting entry #\" + iPosition + \" in log segment: \" + iClusterSegment, e,\r\n\t\t\t\t\tOTransactionException.class);\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"211af91b00f1b58bd0c28219831c319ea4cfb9c6","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int updateRecord(final ORecordId iRid, final byte[] iContent, final int iVersion, final byte iRecordType, final int iMode,\r\n\t\t\tORecordCallback<Integer> iCallback) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal OCluster cluster = getClusterById(iRid.clusterId);\r\n\r\n\t\tif (txManager.isCommitting())\r\n\t\t\treturn txManager.updateRecord(txManager.getCurrentTransaction().getId(), cluster, iRid, iContent, iVersion, iRecordType);\r\n\t\telse\r\n\t\t\treturn updateRecord(cluster, iRid, iContent, iVersion, iRecordType);\r\n\t}","id":28875,"modified_method":"public int updateRecord(final ORecordId iRid, final byte[] iContent, final int iVersion, final byte iRecordType, final int iMode,\r\n\t\t\tORecordCallback<Integer> iCallback) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal OCluster cluster = getClusterById(iRid.clusterId);\r\n\r\n\t\tif (txManager.isCommitting())\r\n\t\t\treturn txManager.updateRecord(txManager.getCurrentTransaction().getId(), cluster, iRid, iContent, iVersion, iRecordType);\r\n\t\telse {\r\n\t\t\tfinal int version = updateRecord(cluster, iRid, iContent, iVersion, iRecordType);\r\n\r\n\t\t\tif(version > -1 && OGlobalConfiguration.NON_TX_RECORD_UPDATE_SYNCH.getValueAsBoolean())\r\n\t\t\t\tsynch();\r\n\r\n\t\t\treturn version;\r\n\t\t}\r\n\t}","commit_id":"1a3a1a35c3e6975dea093f167bc85b2b705dc2a2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public long createRecord(final ORecordId iRid, final byte[] iContent, final byte iRecordType, final int iMode,\r\n\t\t\tORecordCallback<Long> iCallback) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal OCluster cluster = getClusterById(iRid.clusterId);\r\n\r\n\t\tif (txManager.isCommitting())\r\n\t\t\tiRid.clusterPosition = txManager\r\n\t\t\t\t\t.createRecord(txManager.getCurrentTransaction().getId(), cluster, iRid, iContent, iRecordType);\r\n\t\telse\r\n\t\t\tiRid.clusterPosition = createRecord(cluster, iContent, iRecordType);\r\n\t\treturn iRid.clusterPosition;\r\n\t}","id":28876,"modified_method":"public long createRecord(final ORecordId iRid, final byte[] iContent, final byte iRecordType, final int iMode,\r\n\t\t\tORecordCallback<Long> iCallback) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal OCluster cluster = getClusterById(iRid.clusterId);\r\n\r\n\t\tif (txManager.isCommitting())\r\n\t\t\tiRid.clusterPosition = txManager\r\n\t\t\t\t\t.createRecord(txManager.getCurrentTransaction().getId(), cluster, iRid, iContent, iRecordType);\r\n\t\telse {\r\n\t\t\tiRid.clusterPosition = createRecord(cluster, iContent, iRecordType);\r\n\r\n\t\t\tif(OGlobalConfiguration.NON_TX_RECORD_UPDATE_SYNCH.getValueAsBoolean())\r\n\t\t\t\tsynch();\r\n\t\t}\r\n\r\n\t\treturn iRid.clusterPosition;\r\n\t}","commit_id":"1a3a1a35c3e6975dea093f167bc85b2b705dc2a2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean deleteRecord(final ORecordId iRid, final int iVersion, final int iMode, ORecordCallback<Boolean> iCallback) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal OCluster cluster = getClusterById(iRid.clusterId);\r\n\r\n\t\tif (txManager.isCommitting())\r\n\t\t\treturn txManager.deleteRecord(txManager.getCurrentTransaction().getId(), cluster, iRid.clusterPosition, iVersion);\r\n\t\telse\r\n\t\t\treturn deleteRecord(cluster, iRid, iVersion);\r\n\t}","id":28877,"modified_method":"public boolean deleteRecord(final ORecordId iRid, final int iVersion, final int iMode, ORecordCallback<Boolean> iCallback) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal OCluster cluster = getClusterById(iRid.clusterId);\r\n\r\n\t\tif (txManager.isCommitting())\r\n\t\t\treturn txManager.deleteRecord(txManager.getCurrentTransaction().getId(), cluster, iRid.clusterPosition, iVersion);\r\n\t\telse {\r\n\t\t\tfinal boolean deleted = deleteRecord(cluster, iRid, iVersion);\r\n\r\n\t\t\tif(deleted && OGlobalConfiguration.NON_TX_RECORD_UPDATE_SYNCH.getValueAsBoolean())\r\n\t\t\t\tsynch();\r\n\r\n\t\t\treturn deleted;\r\n\t\t}\r\n\t}","commit_id":"1a3a1a35c3e6975dea093f167bc85b2b705dc2a2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public synchronized void open(final int iRequesterId, final String iUserName, final String iUserPassword) {\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\taddUser();\r\n\t\tcache.addUser();\r\n\r\n\t\tfinal boolean locked = acquireExclusiveLock();\r\n\r\n\t\ttry {\r\n\t\t\tif (open)\r\n\t\t\t\t// ALREADY OPENED: THIS IS THE CASE WHEN A STORAGE INSTANCE IS\r\n\t\t\t\t// REUSED\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif (!exists())\r\n\t\t\t\tthrow new OStorageException(\"Can't open the storage '\" + name + \"' because it not exists in path: \" + url);\r\n\r\n\t\t\topen = true;\r\n\r\n\t\t\t// OPEN BASIC SEGMENTS\r\n\t\t\tint pos;\r\n\t\t\tpos = registerDataSegment(new OStorageDataConfiguration(configuration, OStorage.DATA_DEFAULT_NAME));\r\n\t\t\tdataSegments[pos].open();\r\n\r\n\t\t\tpos = createClusterFromConfig(new OStoragePhysicalClusterConfiguration(configuration, OStorage.CLUSTER_INTERNAL_NAME,\r\n\t\t\t\t\tclusters.length));\r\n\t\t\tclusters[pos].open();\r\n\r\n\t\t\tpos = createClusterFromConfig(new OStoragePhysicalClusterConfiguration(configuration, OStorage.CLUSTER_INDEX_NAME,\r\n\t\t\t\t\tclusters.length));\r\n\t\t\tclusters[pos].open();\r\n\r\n\t\t\tdefaultClusterId = createClusterFromConfig(new OStoragePhysicalClusterConfiguration(configuration,\r\n\t\t\t\t\tOStorage.CLUSTER_DEFAULT_NAME, clusters.length));\r\n\t\t\tclusters[defaultClusterId].open();\r\n\r\n\t\t\tconfiguration.load();\r\n\r\n\t\t\tif (configuration.isEmpty())\r\n\t\t\t\tthrow new OStorageException(\"Can't open storage because it not exists. Storage path: \" + url);\r\n\r\n\t\t\t// REGISTER DATA SEGMENT\r\n\t\t\tOStorageDataConfiguration dataConfig;\r\n\t\t\tfor (int i = 0; i < configuration.dataSegments.size(); ++i) {\r\n\t\t\t\tdataConfig = configuration.dataSegments.get(i);\r\n\r\n\t\t\t\tpos = registerDataSegment(dataConfig);\r\n\t\t\t\tif (pos == -1) {\r\n\t\t\t\t\t// CLOSE AND REOPEN TO BE SURE ALL THE FILE SEGMENTS ARE\r\n\t\t\t\t\t// OPENED\r\n\t\t\t\t\tdataSegments[i].close();\r\n\t\t\t\t\tdataSegments[i] = new ODataLocal(this, dataConfig, pos);\r\n\t\t\t\t\tdataSegments[i].open();\r\n\t\t\t\t} else\r\n\t\t\t\t\tdataSegments[pos].open();\r\n\t\t\t}\r\n\r\n\t\t\t// REGISTER CLUSTER\r\n\t\t\tOStorageClusterConfiguration clusterConfig;\r\n\t\t\tfor (int i = 0; i < configuration.clusters.size(); ++i) {\r\n\t\t\t\tclusterConfig = configuration.clusters.get(i);\r\n\r\n\t\t\t\tpos = createClusterFromConfig(clusterConfig);\r\n\r\n\t\t\t\tif (pos == -1) {\r\n\t\t\t\t\t// CLOSE AND REOPEN TO BE SURE ALL THE FILE SEGMENTS ARE\r\n\t\t\t\t\t// OPENED\r\n\t\t\t\t\tclusters[i].close();\r\n\t\t\t\t\tclusters[i] = new OClusterLocal(this, (OStoragePhysicalClusterConfiguration) clusterConfig);\r\n\t\t\t\t\tclusterMap.put(clusters[i].getName(), clusters[i]);\r\n\t\t\t\t\tclusters[i].open();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (clusterConfig.getName().equals(OStorage.CLUSTER_DEFAULT_NAME))\r\n\t\t\t\t\t\tdefaultClusterId = pos;\r\n\r\n\t\t\t\t\tclusters[pos].open();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttxManager.open();\r\n\r\n\t\t} catch (IOException e) {\r\n\t\t\topen = false;\r\n\t\t\tdataSegments = new ODataLocal[0];\r\n\t\t\tclusters = new OCluster[0];\r\n\t\t\tclusterMap.clear();\r\n\t\t\tthrow new OStorageException(\"Can't open local storage: \" + url + \", with mode=\" + mode, e);\r\n\t\t} finally {\r\n\t\t\treleaseExclusiveLock(locked);\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(\"OStorageLocal.open\", timer);\r\n\t\t}\r\n\t}","id":28878,"modified_method":"public synchronized void open(final int iRequesterId, final String iUserName, final String iUserPassword) {\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\taddUser();\r\n\t\tcache.addUser();\r\n\r\n\t\tfinal boolean locked = acquireExclusiveLock();\r\n\r\n\t\ttry {\r\n\t\t\tif (open)\r\n\t\t\t\t// ALREADY OPENED: THIS IS THE CASE WHEN A STORAGE INSTANCE IS\r\n\t\t\t\t// REUSED\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif (!exists())\r\n\t\t\t\tthrow new OStorageException(\"Can't open the storage '\" + name + \"' because it not exists in path: \" + url);\r\n\r\n\t\t\topen = true;\r\n\r\n\t\t\t// OPEN BASIC SEGMENTS\r\n\t\t\tint pos;\r\n\t\t\tpos = registerDataSegment(new OStorageDataConfiguration(configuration, OStorage.DATA_DEFAULT_NAME));\r\n\t\t\tdataSegments[pos].open();\r\n\r\n\t\t\tpos = createClusterFromConfig(new OStoragePhysicalClusterConfiguration(configuration, OStorage.CLUSTER_INTERNAL_NAME,\r\n\t\t\t\t\tclusters.length));\r\n\t\t\tclusters[pos].open();\r\n\r\n\t\t\tpos = createClusterFromConfig(new OStoragePhysicalClusterConfiguration(configuration, OStorage.CLUSTER_INDEX_NAME,\r\n\t\t\t\t\tclusters.length));\r\n\t\t\tclusters[pos].open();\r\n\r\n\t\t\tdefaultClusterId = createClusterFromConfig(new OStoragePhysicalClusterConfiguration(configuration,\r\n\t\t\t\t\tOStorage.CLUSTER_DEFAULT_NAME, clusters.length));\r\n\t\t\tclusters[defaultClusterId].open();\r\n\r\n\t\t\tconfiguration.load();\r\n\r\n\t\t\tif (configuration.isEmpty())\r\n\t\t\t\tthrow new OStorageException(\"Can't open storage because it not exists. Storage path: \" + url);\r\n\r\n\t\t\t// REGISTER DATA SEGMENT\r\n\t\t\tOStorageDataConfiguration dataConfig;\r\n\t\t\tfor (int i = 0; i < configuration.dataSegments.size(); ++i) {\r\n\t\t\t\tdataConfig = configuration.dataSegments.get(i);\r\n\r\n\t\t\t\tpos = registerDataSegment(dataConfig);\r\n\t\t\t\tif (pos == -1) {\r\n\t\t\t\t\t// CLOSE AND REOPEN TO BE SURE ALL THE FILE SEGMENTS ARE\r\n\t\t\t\t\t// OPENED\r\n\t\t\t\t\tdataSegments[i].close();\r\n\t\t\t\t\tdataSegments[i] = new ODataLocal(this, dataConfig, pos);\r\n\t\t\t\t\tdataSegments[i].open();\r\n\t\t\t\t} else\r\n\t\t\t\t\tdataSegments[pos].open();\r\n\t\t\t}\r\n\r\n\t\t\t// REGISTER CLUSTER\r\n\t\t\tOStorageClusterConfiguration clusterConfig;\r\n\t\t\tfor (int i = 0; i < configuration.clusters.size(); ++i) {\r\n\t\t\t\tclusterConfig = configuration.clusters.get(i);\r\n\r\n\t\t\t\tpos = createClusterFromConfig(clusterConfig);\r\n\r\n\t\t\t\tif (pos == -1) {\r\n\t\t\t\t\t// CLOSE AND REOPEN TO BE SURE ALL THE FILE SEGMENTS ARE\r\n\t\t\t\t\t// OPENED\r\n\t\t\t\t\tclusters[i].close();\r\n\t\t\t\t\tclusters[i] = new OClusterLocal(this, (OStoragePhysicalClusterConfiguration) clusterConfig);\r\n\t\t\t\t\tclusterMap.put(clusters[i].getName(), clusters[i]);\r\n\t\t\t\t\tclusters[i].open();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (clusterConfig.getName().equals(OStorage.CLUSTER_DEFAULT_NAME))\r\n\t\t\t\t\t\tdefaultClusterId = pos;\r\n\r\n\t\t\t\t\tclusters[pos].open();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tloadVersion();\r\n\r\n\t\t\ttxManager.open();\r\n\r\n\t\t} catch (IOException e) {\r\n\t\t\topen = false;\r\n\t\t\tdataSegments = new ODataLocal[0];\r\n\t\t\tclusters = new OCluster[0];\r\n\t\t\tclusterMap.clear();\r\n\t\t\tthrow new OStorageException(\"Can't open local storage: \" + url + \", with mode=\" + mode, e);\r\n\t\t} finally {\r\n\t\t\treleaseExclusiveLock(locked);\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(\"OStorageLocal.open\", timer);\r\n\t\t}\r\n\t}","commit_id":"326f9d4bff532395ac74c5bb291d1ccfe6cdec1e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean deleteRecord(final int iRequesterId, final int iClusterId, final long iPosition, final int iVersion) {\r\n\t\tcheckOpeness();\r\n\t\treturn deleteRecord(iRequesterId, getClusterById(iClusterId), iPosition, iVersion);\r\n\t}","id":28879,"modified_method":"public boolean deleteRecord(final int iRequesterId, final int iClusterId, final long iPosition, final int iVersion) {\r\n\t\tcheckOpeness();\r\n\t\tfinal boolean succeed = deleteRecord(iRequesterId, getClusterById(iClusterId), iPosition, iVersion);\r\n\t\tincrementVersion();\r\n\t\treturn succeed;\r\n\t}","commit_id":"326f9d4bff532395ac74c5bb291d1ccfe6cdec1e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void commit(final int iRequesterId, final OTransaction<?> iTx) {\r\n\t\tfinal boolean locked = acquireSharedLock();\r\n\r\n\t\ttry {\r\n\t\t\ttxManager.commitAllPendingRecords(iRequesterId, iTx);\r\n\r\n\t\t} catch (IOException e) {\r\n\t\t\trollback(iRequesterId, iTx);\r\n\r\n\t\t} finally {\r\n\t\t\treleaseSharedLock(locked);\r\n\t\t}\r\n\t}","id":28880,"modified_method":"public void commit(final int iRequesterId, final OTransaction<?> iTx) {\r\n\t\tfinal boolean locked = acquireSharedLock();\r\n\r\n\t\ttry {\r\n\t\t\ttxManager.commitAllPendingRecords(iRequesterId, iTx);\r\n\r\n\t\t\tincrementVersion();\r\n\r\n\t\t} catch (IOException e) {\r\n\t\t\trollback(iRequesterId, iTx);\r\n\r\n\t\t} finally {\r\n\t\t\treleaseSharedLock(locked);\r\n\t\t}\r\n\t}","commit_id":"326f9d4bff532395ac74c5bb291d1ccfe6cdec1e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void synch() {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tfinal boolean locked = acquireExclusiveLock();\r\n\r\n\t\ttry {\r\n\t\t\tfor (OCluster cluster : clusters)\r\n\t\t\t\tcluster.synch();\r\n\r\n\t\t\tfor (ODataLocal data : dataSegments)\r\n\t\t\t\tdata.synch();\r\n\r\n\t\t} finally {\r\n\t\t\treleaseExclusiveLock(locked);\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(\"OStorageLocal.synch\", timer);\r\n\t\t}\r\n\t}","id":28881,"modified_method":"public void synch() {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tfinal boolean locked = acquireExclusiveLock();\r\n\r\n\t\ttry {\r\n\t\t\tsaveVersion();\r\n\r\n\t\t\tfor (OCluster cluster : clusters)\r\n\t\t\t\tcluster.synch();\r\n\r\n\t\t\tfor (ODataLocal data : dataSegments)\r\n\t\t\t\tdata.synch();\r\n\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new OStorageException(\"Error on synch\", e);\r\n\t\t} finally {\r\n\t\t\treleaseExclusiveLock(locked);\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(\"OStorageLocal.synch\", timer);\r\n\t\t}\r\n\t}","commit_id":"326f9d4bff532395ac74c5bb291d1ccfe6cdec1e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected int updateRecord(final int iRequesterId, final OCluster iClusterSegment, final long iPosition, final byte[] iContent,\r\n\t\t\tfinal int iVersion, final byte iRecordType) {\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tfinal String recId = ORecordId.generateString(iClusterSegment.getId(), iPosition);\r\n\r\n\t\tfinal boolean locked = acquireSharedLock();\r\n\r\n\t\ttry {\r\n\t\t\t// lockManager.acquireLock(iRequesterId, recId, LOCK.EXCLUSIVE,\r\n\t\t\t// timeout);\r\n\r\n\t\t\tfinal OPhysicalPosition ppos = iClusterSegment.getPhysicalPosition(iPosition, new OPhysicalPosition());\r\n\t\t\tif (!checkForRecordValidity(ppos))\r\n\t\t\t\t// DELETED\r\n\t\t\t\treturn -1;\r\n\r\n\t\t\t// MVCC TRANSACTION: CHECK IF VERSION IS THE SAME\r\n\t\t\tif (iVersion > -1 && ppos.version != iVersion)\r\n\t\t\t\tthrow new OConcurrentModificationException(\r\n\t\t\t\t\t\t\"Can't update record #\"\r\n\t\t\t\t\t\t\t\t+ recId\r\n\t\t\t\t\t\t\t\t+ \" because it has been modified by another user (v\"\r\n\t\t\t\t\t\t\t\t+ ppos.version\r\n\t\t\t\t\t\t\t\t+ \" != v\"\r\n\t\t\t\t\t\t\t\t+ iVersion\r\n\t\t\t\t\t\t\t\t+ \") in the meanwhile of current transaction. Use pessimistic locking instead of optimistic or simply re-execute the transaction\");\r\n\r\n\t\t\tif (ppos.type != iRecordType)\r\n\t\t\t\tiClusterSegment.updateRecordType(iPosition, iRecordType);\r\n\r\n\t\t\tiClusterSegment.updateVersion(iPosition, ++ppos.version);\r\n\r\n\t\t\tfinal long newDataSegmentOffset = getDataSegment(ppos.dataSegment).setRecord(ppos.dataPosition, iClusterSegment.getId(),\r\n\t\t\t\t\tiPosition, iContent);\r\n\r\n\t\t\tif (newDataSegmentOffset != ppos.dataPosition)\r\n\t\t\t\t// UPDATE DATA SEGMENT OFFSET WITH THE NEW PHYSICAL POSITION\r\n\t\t\t\tiClusterSegment.setPhysicalPosition(iPosition, ppos.dataSegment, newDataSegmentOffset, iRecordType);\r\n\r\n\t\t\treturn ppos.version;\r\n\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on updating record #\" + iPosition + \" in cluster: \" + iClusterSegment, e);\r\n\r\n\t\t} finally {\r\n\t\t\treleaseSharedLock(locked);\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(\"OStorageLocal.updateRecord\", timer);\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}","id":28882,"modified_method":"protected int updateRecord(final int iRequesterId, final OCluster iClusterSegment, final long iPosition, final byte[] iContent,\r\n\t\t\tfinal int iVersion, final byte iRecordType) {\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tfinal String recId = ORecordId.generateString(iClusterSegment.getId(), iPosition);\r\n\r\n\t\tfinal boolean locked = acquireSharedLock();\r\n\r\n\t\ttry {\r\n\t\t\t// lockManager.acquireLock(iRequesterId, recId, LOCK.EXCLUSIVE,\r\n\t\t\t// timeout);\r\n\r\n\t\t\tfinal OPhysicalPosition ppos = iClusterSegment.getPhysicalPosition(iPosition, new OPhysicalPosition());\r\n\t\t\tif (!checkForRecordValidity(ppos))\r\n\t\t\t\t// DELETED\r\n\t\t\t\treturn -1;\r\n\r\n\t\t\t// MVCC TRANSACTION: CHECK IF VERSION IS THE SAME\r\n\t\t\tif (iVersion > -1 && ppos.version != iVersion)\r\n\t\t\t\tthrow new OConcurrentModificationException(\r\n\t\t\t\t\t\t\"Can't update record #\"\r\n\t\t\t\t\t\t\t\t+ recId\r\n\t\t\t\t\t\t\t\t+ \" because it has been modified by another user (v\"\r\n\t\t\t\t\t\t\t\t+ ppos.version\r\n\t\t\t\t\t\t\t\t+ \" != v\"\r\n\t\t\t\t\t\t\t\t+ iVersion\r\n\t\t\t\t\t\t\t\t+ \") in the meanwhile of current transaction. Use pessimistic locking instead of optimistic or simply re-execute the transaction\");\r\n\r\n\t\t\tif (ppos.type != iRecordType)\r\n\t\t\t\tiClusterSegment.updateRecordType(iPosition, iRecordType);\r\n\r\n\t\t\tiClusterSegment.updateVersion(iPosition, ++ppos.version);\r\n\r\n\t\t\tfinal long newDataSegmentOffset = getDataSegment(ppos.dataSegment).setRecord(ppos.dataPosition, iClusterSegment.getId(),\r\n\t\t\t\t\tiPosition, iContent);\r\n\r\n\t\t\tif (newDataSegmentOffset != ppos.dataPosition)\r\n\t\t\t\t// UPDATE DATA SEGMENT OFFSET WITH THE NEW PHYSICAL POSITION\r\n\t\t\t\tiClusterSegment.setPhysicalPosition(iPosition, ppos.dataSegment, newDataSegmentOffset, iRecordType);\r\n\r\n\t\t\tincrementVersion();\r\n\r\n\t\t\treturn ppos.version;\r\n\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on updating record #\" + iPosition + \" in cluster: \" + iClusterSegment, e);\r\n\r\n\t\t} finally {\r\n\t\t\treleaseSharedLock(locked);\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(\"OStorageLocal.updateRecord\", timer);\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}","commit_id":"326f9d4bff532395ac74c5bb291d1ccfe6cdec1e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public long createRecord(final int iClusterId, final byte[] iContent, final byte iRecordType) {\r\n\t\tcheckOpeness();\r\n\t\treturn createRecord(getClusterById(iClusterId), iContent, iRecordType);\r\n\t}","id":28883,"modified_method":"public long createRecord(final int iClusterId, final byte[] iContent, final byte iRecordType) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal long clusterPosition = createRecord(getClusterById(iClusterId), iContent, iRecordType);\r\n\t\tincrementVersion();\r\n\t\treturn clusterPosition;\r\n\t}","commit_id":"326f9d4bff532395ac74c5bb291d1ccfe6cdec1e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void close() {\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tfinal boolean locked = acquireExclusiveLock();\r\n\r\n\t\tif (!open)\r\n\t\t\treturn;\r\n\r\n\t\ttry {\r\n\t\t\tfor (OCluster cluster : clusters)\r\n\t\t\t\tif (cluster != null)\r\n\t\t\t\t\tcluster.close();\r\n\t\t\tclusters = new OCluster[0];\r\n\t\t\tclusterMap.clear();\r\n\r\n\t\t\tfor (ODataLocal data : dataSegments)\r\n\t\t\t\tdata.close();\r\n\t\t\tdataSegments = new ODataLocal[0];\r\n\r\n\t\t\ttxManager.close();\r\n\r\n\t\t\tcache.removeUser();\r\n\t\t\tcache.clear();\r\n\t\t\tconfiguration = new OStorageConfiguration(this);\r\n\r\n\t\t\tOMMapManager.flush();\r\n\r\n\t\t\topen = false;\r\n\t\t} catch (IOException e) {\r\n\t\t\tOLogManager.instance().error(this, \"Error on closing of the storage '\" + name, e, OStorageException.class);\r\n\r\n\t\t} finally {\r\n\t\t\treleaseExclusiveLock(locked);\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(\"OStorageLocal.close\", timer);\r\n\t\t}\r\n\t}","id":28884,"modified_method":"public void close() {\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tfinal boolean locked = acquireExclusiveLock();\r\n\r\n\t\tif (!open)\r\n\t\t\treturn;\r\n\r\n\t\ttry {\r\n\t\t\tsaveVersion();\r\n\r\n\t\t\tfor (OCluster cluster : clusters)\r\n\t\t\t\tif (cluster != null)\r\n\t\t\t\t\tcluster.close();\r\n\t\t\tclusters = new OCluster[0];\r\n\t\t\tclusterMap.clear();\r\n\r\n\t\t\tfor (ODataLocal data : dataSegments)\r\n\t\t\t\tdata.close();\r\n\t\t\tdataSegments = new ODataLocal[0];\r\n\r\n\t\t\ttxManager.close();\r\n\r\n\t\t\tcache.removeUser();\r\n\t\t\tcache.clear();\r\n\t\t\tconfiguration = new OStorageConfiguration(this);\r\n\r\n\t\t\tOMMapManager.flush();\r\n\r\n\t\t\topen = false;\r\n\t\t} catch (IOException e) {\r\n\t\t\tOLogManager.instance().error(this, \"Error on closing of the storage '\" + name, e, OStorageException.class);\r\n\r\n\t\t} finally {\r\n\t\t\treleaseExclusiveLock(locked);\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(\"OStorageLocal.close\", timer);\r\n\t\t}\r\n\t}","commit_id":"326f9d4bff532395ac74c5bb291d1ccfe6cdec1e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected boolean deleteRecord(final int iRequesterId, final OCluster iClusterSegment, final long iPosition, final int iVersion) {\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tfinal String recId = ORecordId.generateString(iClusterSegment.getId(), iPosition);\r\n\r\n\t\tfinal boolean locked = acquireSharedLock();\r\n\r\n\t\ttry {\r\n\t\t\tfinal OPhysicalPosition ppos = iClusterSegment.getPhysicalPosition(iPosition, new OPhysicalPosition());\r\n\r\n\t\t\tif (!checkForRecordValidity(ppos))\r\n\t\t\t\t// ALREADY DELETED\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t// MVCC TRANSACTION: CHECK IF VERSION IS THE SAME\r\n\t\t\tif (iVersion > -1 && ppos.version != iVersion)\r\n\t\t\t\tthrow new OConcurrentModificationException(\r\n\t\t\t\t\t\t\"Can't delete the record #\"\r\n\t\t\t\t\t\t\t\t+ recId\r\n\t\t\t\t\t\t\t\t+ \" because it was modified by another user in the meanwhile of current transaction. Use pessimistic locking instead of optimistic or simply re-execute the transaction\");\r\n\r\n\t\t\tiClusterSegment.removePhysicalPosition(iPosition, ppos);\r\n\r\n\t\t\tgetDataSegment(ppos.dataSegment).deleteRecord(ppos.dataPosition);\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on deleting record #\" + iPosition + \" in cluster: \" + iClusterSegment, e);\r\n\r\n\t\t} finally {\r\n\t\t\treleaseSharedLock(locked);\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(\"OStorageLocal.deleteRecord\", timer);\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}","id":28885,"modified_method":"protected boolean deleteRecord(final int iRequesterId, final OCluster iClusterSegment, final long iPosition, final int iVersion) {\r\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\r\n\r\n\t\tfinal String recId = ORecordId.generateString(iClusterSegment.getId(), iPosition);\r\n\r\n\t\tfinal boolean locked = acquireSharedLock();\r\n\r\n\t\ttry {\r\n\t\t\tfinal OPhysicalPosition ppos = iClusterSegment.getPhysicalPosition(iPosition, new OPhysicalPosition());\r\n\r\n\t\t\tif (!checkForRecordValidity(ppos))\r\n\t\t\t\t// ALREADY DELETED\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t// MVCC TRANSACTION: CHECK IF VERSION IS THE SAME\r\n\t\t\tif (iVersion > -1 && ppos.version != iVersion)\r\n\t\t\t\tthrow new OConcurrentModificationException(\r\n\t\t\t\t\t\t\"Can't delete the record #\"\r\n\t\t\t\t\t\t\t\t+ recId\r\n\t\t\t\t\t\t\t\t+ \" because it was modified by another user in the meanwhile of current transaction. Use pessimistic locking instead of optimistic or simply re-execute the transaction\");\r\n\r\n\t\t\tiClusterSegment.removePhysicalPosition(iPosition, ppos);\r\n\r\n\t\t\tgetDataSegment(ppos.dataSegment).deleteRecord(ppos.dataPosition);\r\n\r\n\t\t\tincrementVersion();\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t} catch (IOException e) {\r\n\r\n\t\t\tOLogManager.instance().error(this, \"Error on deleting record #\" + iPosition + \" in cluster: \" + iClusterSegment, e);\r\n\r\n\t\t} finally {\r\n\t\t\treleaseSharedLock(locked);\r\n\r\n\t\t\tOProfiler.getInstance().stopChrono(\"OStorageLocal.deleteRecord\", timer);\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}","commit_id":"326f9d4bff532395ac74c5bb291d1ccfe6cdec1e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int updateRecord(final int iRequesterId, final int iClusterId, final long iPosition, final byte[] iContent,\r\n\t\t\tfinal int iVersion, final byte iRecordType) {\r\n\t\tcheckOpeness();\r\n\t\treturn updateRecord(iRequesterId, getClusterById(iClusterId), iPosition, iContent, iVersion, iRecordType);\r\n\t}","id":28886,"modified_method":"public int updateRecord(final int iRequesterId, final int iClusterId, final long iPosition, final byte[] iContent,\r\n\t\t\tfinal int iVersion, final byte iRecordType) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal int recordVersion = updateRecord(iRequesterId, getClusterById(iClusterId), iPosition, iContent, iVersion, iRecordType);\r\n\t\tincrementVersion();\r\n\t\treturn recordVersion;\r\n\t}","commit_id":"326f9d4bff532395ac74c5bb291d1ccfe6cdec1e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * Test Element representation of channel to see that its node name is \n     * 'channel' and that it has the proper owning document and that the channel\n     * element has the correct identifer such that it can be gotten by ID.\n     * @throws ParserConfigurationException\n     */\n    public void testGetDocument() throws ParserConfigurationException {\n        ChannelDefinition cd = new ChannelDefinition(73);\n        \n        cd.setDescription(\"A test channel description.\");\n        cd.setEditable(false);\n        cd.setFName(\"test_fname\");\n        cd.setHasAbout(true);\n        cd.setHasHelp(false);\n        cd.setIsSecure(false);\n        cd.setJavaClass(\"org.jasig.portal.channels.CGenericXSLT\");\n        cd.setName(\"testName\");\n        cd.setTimeout(500);\n        cd.setTitle(\"testTitle\");\n        cd.setTypeId(12);\n        \n        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n        \n        Element channelElement = cd.getDocument(doc, \"testId\");\n        \n        assertEquals(\"channel\", channelElement.getNodeName());\n        assertSame(doc, channelElement.getOwnerDocument());\n        \n        doc.appendChild(channelElement);\n        \n        assertSame(channelElement, doc.getElementById(\"testId\"));\n        \n        assertEquals(\"A test channel description.\", channelElement.getAttribute(\"description\"));\n        assertEquals(\"false\", channelElement.getAttribute(\"editable\"));\n        assertEquals(\"test_fname\", channelElement.getAttribute(\"fname\"));\n        assertEquals(\"true\", channelElement.getAttribute(\"hasAbout\"));\n        assertEquals(\"false\", channelElement.getAttribute(\"hasHelp\"));\n        assertEquals(\"false\", channelElement.getAttribute(\"secure\"));\n        assertEquals(\"org.jasig.portal.channels.CGenericXSLT\", channelElement.getAttribute(\"class\"));\n        assertEquals(\"testName\", channelElement.getAttribute(\"name\"));\n        assertEquals(\"500\", channelElement.getAttribute(\"timeout\"));\n        assertEquals(\"testTitle\", channelElement.getAttribute(\"title\"));\n        assertEquals(\"12\", channelElement.getAttribute(\"typeID\"));\n\n        \n    }","id":28887,"modified_method":"/**\n     * Test Element representation of channel to see that its node name is \n     * 'channel' and that it has the proper owning document and that the channel\n     * element has the correct identifer such that it can be gotten by ID.\n     * @throws ParserConfigurationException\n     */\n    public void testGetDocument() throws ParserConfigurationException {\n        IChannelDefinition cd = new ChannelDefinitionImpl(73);\n        \n        cd.setDescription(\"A test channel description.\");\n        cd.setEditable(false);\n        cd.setFName(\"test_fname\");\n        cd.setHasAbout(true);\n        cd.setHasHelp(false);\n        cd.setIsSecure(false);\n        cd.setJavaClass(\"org.jasig.portal.channels.CGenericXSLT\");\n        cd.setName(\"testName\");\n        cd.setTimeout(500);\n        cd.setTitle(\"testTitle\");\n        cd.setTypeId(12);\n        \n        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n        \n        Element channelElement = cd.getDocument(doc, \"testId\");\n        \n        assertEquals(\"channel\", channelElement.getNodeName());\n        assertSame(doc, channelElement.getOwnerDocument());\n        \n        doc.appendChild(channelElement);\n        \n        assertSame(channelElement, doc.getElementById(\"testId\"));\n        \n        assertEquals(\"A test channel description.\", channelElement.getAttribute(\"description\"));\n        assertEquals(\"false\", channelElement.getAttribute(\"editable\"));\n        assertEquals(\"test_fname\", channelElement.getAttribute(\"fname\"));\n        assertEquals(\"true\", channelElement.getAttribute(\"hasAbout\"));\n        assertEquals(\"false\", channelElement.getAttribute(\"hasHelp\"));\n        assertEquals(\"false\", channelElement.getAttribute(\"secure\"));\n        assertEquals(\"org.jasig.portal.channels.CGenericXSLT\", channelElement.getAttribute(\"class\"));\n        assertEquals(\"testName\", channelElement.getAttribute(\"name\"));\n        assertEquals(\"500\", channelElement.getAttribute(\"timeout\"));\n        assertEquals(\"testTitle\", channelElement.getAttribute(\"title\"));\n        assertEquals(\"12\", channelElement.getAttribute(\"typeID\"));\n\n        \n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Test that ChannelDefinition identifies CPortletAdaptor as a portlet but\n     * does not identify CGenericXSLT as a portlet.\n     */\n    public void testIsPortlet() {\n        ChannelDefinition cd = new ChannelDefinition(72);\n        \n        cd.setJavaClass(\"org.jasig.portal.channels.CGenericXSLT\");\n        assertFalse(cd.isPortlet());\n        \n        cd.setJavaClass(\"org.jasig.portal.channels.portlet.CSpringPortletAdaptor\");\n        assertTrue(cd.isPortlet());\n        \n    }","id":28888,"modified_method":"/**\n     * Test that ChannelDefinition identifies CPortletAdaptor as a portlet but\n     * does not identify CGenericXSLT as a portlet.\n     */\n    public void testIsPortlet() {\n        IChannelDefinition cd = new ChannelDefinitionImpl(72);\n        \n        cd.setJavaClass(\"org.jasig.portal.channels.CGenericXSLT\");\n        assertFalse(cd.isPortlet());\n        \n        cd.setJavaClass(\"org.jasig.portal.channels.portlet.CSpringPortletAdaptor\");\n        assertTrue(cd.isPortlet());\n        \n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void testStoreAllEvents() throws Exception {\n        PersonImpl person = new PersonImpl();\n        person.setID(1);\n        person.setAttribute(IPerson.USERNAME, \"admin\");\n        final Set<String> groups = Collections.emptySet();\n        this.jpaPortalEventStore.addPersonGroups(person, groups);\n        \n        \n        PortalEvent portalEvent;\n        \n        portalEvent = new UserLoggedInPortalEvent(this, person);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new UserLoggedOutPortalEvent(this, person);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(2, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(2, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new UserSessionCreatedPortalEvent(this, person);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(3, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(3, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new UserSessionDestroyedPortalEvent(this, person);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(4, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(4, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        \n        final ChannelDefinition channelDefinition = new ChannelDefinition(1);\n        \n        \n        portalEvent = new PublishedChannelDefinitionPortalEvent(this, person, channelDefinition);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(5, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(5, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new ModifiedChannelDefinitionPortalEvent(this, person, channelDefinition);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(6, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(6, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(2, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new RemovedChannelDefinitionPortalEvent(this, person, channelDefinition);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(7, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(7, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(3, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        \n        final UserProfile userProfile = new UserProfile();\n        userProfile.setProfileId(1);\n        \n        final IUserLayoutChannelDescription channelDescription = EasyMock.createMock(IUserLayoutChannelDescription.class);\n        EasyMock.expect(channelDescription.getName()).andReturn(\"chanPub1\").anyTimes();\n        EasyMock.expect(channelDescription.getChannelPublishId()).andReturn(\"chanPub1\").anyTimes();\n        EasyMock.expect(channelDescription.getChannelSubscribeId()).andReturn(\"chanSub1\").anyTimes();\n        \n        final IUserLayoutNodeDescription parentNodeDescription = EasyMock.createMock(IUserLayoutNodeDescription.class);\n        EasyMock.expect(parentNodeDescription.getName()).andReturn(\"parentNode1\").anyTimes();\n        EasyMock.expect(parentNodeDescription.getId()).andReturn(\"parentNode1\").anyTimes();\n        \n        EasyMock.replay(channelDescription, parentNodeDescription);\n        \n        \n        portalEvent = new ChannelAddedToLayoutPortalEvent(this, person, userProfile, channelDescription, parentNodeDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(8, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(8, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(4, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new ChannelUpdatedInLayoutPortalEvent(this, person, userProfile, channelDescription, parentNodeDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(9, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(9, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(5, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(2, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n\n        final IUserLayoutNodeDescription oldParentNodeDescription = EasyMock.createMock(IUserLayoutNodeDescription.class);\n        EasyMock.expect(oldParentNodeDescription.getId()).andReturn(\"oldParentNode1\").anyTimes();\n        EasyMock.expect(oldParentNodeDescription.getName()).andReturn(\"oldParentNode1\").anyTimes();\n        \n        EasyMock.replay(oldParentNodeDescription);\n        \n        \n        portalEvent = new ChannelMovedInLayoutPortalEvent(this, person, userProfile, channelDescription, oldParentNodeDescription, parentNodeDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(6, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(3, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new ChannelRemovedFromLayoutPortalEvent(this, person, userProfile, channelDescription, oldParentNodeDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(11, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(11, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(7, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(4, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new ChannelRenderedInLayoutPortalEvent(this, person, userProfile, channelDescription, parentNodeDescription, 1234, false);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(12, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(12, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(8, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(5, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new ChannelTargetedInLayoutPortalEvent(this, person, userProfile, channelDescription, parentNodeDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(13, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(13, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(9, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(6, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new ChannelInstanciatedInLayoutPortalEvent(this, person, userProfile, channelDescription, parentNodeDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(14, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(14, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(7, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n\n        final IUserLayoutFolderDescription layoutFolderDescription = EasyMock.createMock(IUserLayoutFolderDescription.class);\n        EasyMock.expect(layoutFolderDescription.getId()).andReturn(\"layoutFolder1\").anyTimes();\n        EasyMock.expect(layoutFolderDescription.getName()).andReturn(\"layoutFolder1\").anyTimes();\n        \n        EasyMock.replay(layoutFolderDescription);\n        \n        \n        portalEvent = new UserAddedFolderToLayoutPortalEvent(this, person, userProfile, layoutFolderDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(15, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(15, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(8, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new UserMovedFolderInLayoutPortalEvent(this, person, userProfile, layoutFolderDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(16, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(16, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(9, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new UserRemovedFolderFromLayoutPortalEvent(this, person, userProfile, layoutFolderDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(17, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(17, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new UserUpdatedFolderInLayoutPortalEvent(this, person, userProfile, layoutFolderDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(18, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(18, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(11, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new PageRenderTimePortalEvent(this, person, userProfile, layoutFolderDescription, 12345);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(19, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(19, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(12, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(2, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new PortletActionInLayoutPortalEvent(this, person, userProfile, channelDescription, parentNodeDescription, 1236);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(20, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(20, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(11, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(13, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(3, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n    }","id":28889,"modified_method":"public void testStoreAllEvents() throws Exception {\n        PersonImpl person = new PersonImpl();\n        person.setID(1);\n        person.setAttribute(IPerson.USERNAME, \"admin\");\n        final Set<String> groups = Collections.emptySet();\n        this.jpaPortalEventStore.addPersonGroups(person, groups);\n        \n        \n        PortalEvent portalEvent;\n        \n        portalEvent = new UserLoggedInPortalEvent(this, person);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new UserLoggedOutPortalEvent(this, person);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(2, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(2, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new UserSessionCreatedPortalEvent(this, person);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(3, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(3, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new UserSessionDestroyedPortalEvent(this, person);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(4, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(4, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        \n        final IChannelDefinition channelDefinition = new ChannelDefinitionImpl(1);\n        \n        \n        portalEvent = new PublishedChannelDefinitionPortalEvent(this, person, channelDefinition);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(5, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(5, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new ModifiedChannelDefinitionPortalEvent(this, person, channelDefinition);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(6, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(6, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(2, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new RemovedChannelDefinitionPortalEvent(this, person, channelDefinition);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(7, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(7, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(3, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        \n        final UserProfile userProfile = new UserProfile();\n        userProfile.setProfileId(1);\n        \n        final IUserLayoutChannelDescription channelDescription = EasyMock.createMock(IUserLayoutChannelDescription.class);\n        EasyMock.expect(channelDescription.getName()).andReturn(\"chanPub1\").anyTimes();\n        EasyMock.expect(channelDescription.getChannelPublishId()).andReturn(\"chanPub1\").anyTimes();\n        EasyMock.expect(channelDescription.getChannelSubscribeId()).andReturn(\"chanSub1\").anyTimes();\n        \n        final IUserLayoutNodeDescription parentNodeDescription = EasyMock.createMock(IUserLayoutNodeDescription.class);\n        EasyMock.expect(parentNodeDescription.getName()).andReturn(\"parentNode1\").anyTimes();\n        EasyMock.expect(parentNodeDescription.getId()).andReturn(\"parentNode1\").anyTimes();\n        \n        EasyMock.replay(channelDescription, parentNodeDescription);\n        \n        \n        portalEvent = new ChannelAddedToLayoutPortalEvent(this, person, userProfile, channelDescription, parentNodeDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(8, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(8, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(4, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new ChannelUpdatedInLayoutPortalEvent(this, person, userProfile, channelDescription, parentNodeDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(9, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(9, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(5, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(2, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n\n        final IUserLayoutNodeDescription oldParentNodeDescription = EasyMock.createMock(IUserLayoutNodeDescription.class);\n        EasyMock.expect(oldParentNodeDescription.getId()).andReturn(\"oldParentNode1\").anyTimes();\n        EasyMock.expect(oldParentNodeDescription.getName()).andReturn(\"oldParentNode1\").anyTimes();\n        \n        EasyMock.replay(oldParentNodeDescription);\n        \n        \n        portalEvent = new ChannelMovedInLayoutPortalEvent(this, person, userProfile, channelDescription, oldParentNodeDescription, parentNodeDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(6, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(3, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new ChannelRemovedFromLayoutPortalEvent(this, person, userProfile, channelDescription, oldParentNodeDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(11, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(11, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(7, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(4, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new ChannelRenderedInLayoutPortalEvent(this, person, userProfile, channelDescription, parentNodeDescription, 1234, false);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(12, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(12, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(8, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(5, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new ChannelTargetedInLayoutPortalEvent(this, person, userProfile, channelDescription, parentNodeDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(13, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(13, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(9, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(6, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new ChannelInstanciatedInLayoutPortalEvent(this, person, userProfile, channelDescription, parentNodeDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(14, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(14, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(7, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n\n        final IUserLayoutFolderDescription layoutFolderDescription = EasyMock.createMock(IUserLayoutFolderDescription.class);\n        EasyMock.expect(layoutFolderDescription.getId()).andReturn(\"layoutFolder1\").anyTimes();\n        EasyMock.expect(layoutFolderDescription.getName()).andReturn(\"layoutFolder1\").anyTimes();\n        \n        EasyMock.replay(layoutFolderDescription);\n        \n        \n        portalEvent = new UserAddedFolderToLayoutPortalEvent(this, person, userProfile, layoutFolderDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(15, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(15, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(8, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new UserMovedFolderInLayoutPortalEvent(this, person, userProfile, layoutFolderDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(16, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(16, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(9, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new UserRemovedFolderFromLayoutPortalEvent(this, person, userProfile, layoutFolderDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(17, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(17, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new UserUpdatedFolderInLayoutPortalEvent(this, person, userProfile, layoutFolderDescription);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(18, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(18, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(11, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(1, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new PageRenderTimePortalEvent(this, person, userProfile, layoutFolderDescription, 12345);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(19, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(19, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(10, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(12, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(2, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n        \n        \n        portalEvent = new PortletActionInLayoutPortalEvent(this, person, userProfile, channelDescription, parentNodeDescription, 1236);\n        this.jpaPortalEventStore.storePortalEvents(portalEvent);\n        this.checkPoint();\n        \n        assertEquals(1, this.countRowsInTable(\"STATS_SESSION\"));\n        assertEquals(0, this.countRowsInTable(\"STATS_SESSION_GROUPS\"));\n        assertEquals(20, this.countRowsInTable(\"STATS_EVENT\"));\n        assertEquals(20, this.countRowsInTable(\"STATS_EVENT_TYPE\"));\n        assertEquals(11, this.countRowsInTable(\"STATS_CHANNEL\"));\n        assertEquals(13, this.countRowsInTable(\"STATS_FOLDER\"));\n        assertEquals(3, this.countRowsInTable(\"STATS_RENDER_TIME\"));\n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public ChannelDefinition[] getAllChildChannels(ChannelCategory parent) throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n    }","id":28890,"modified_method":"public IChannelDefinition[] getAllChildChannels(ChannelCategory parent) {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void saveChannelDefinition(ChannelDefinition channelDef) throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","id":28891,"modified_method":"public void saveChannelDefinition(IChannelDefinition channelDef) {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void removeChannelFromCategory(ChannelDefinition channelDef, ChannelCategory category) throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","id":28892,"modified_method":"public void removeChannelFromCategory(IChannelDefinition channelDef, ChannelCategory category) {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public ChannelDefinition getChannelDefinition(String channelFunctionalName) throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n    }","id":28893,"modified_method":"public IChannelDefinition getChannelDefinition(String channelFunctionalName) {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public ChannelDefinition newChannelDefinition() throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n        \n    }","id":28894,"modified_method":"public IChannelDefinition newChannelDefinition() {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n        \n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public ChannelType newChannelType() throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n        \n    }","id":28895,"modified_method":"public IChannelType newChannelType() {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n        \n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void setChannelDefinitions(ChannelDefinition[] channelDefinitions) {\n        this.channelDefinitionsById = new HashMap<Integer, ChannelDefinition>(channelDefinitions.length);\n        \n        for (ChannelDefinition channelDefinition : channelDefinitions) {\n            this.channelDefinitionsById.put(channelDefinition.getId(), channelDefinition);\n        }\n    }","id":28896,"modified_method":"public void setChannelDefinitions(IChannelDefinition[] channelDefinitions) {\n        this.channelDefinitionsById = new HashMap<Integer, IChannelDefinition>(channelDefinitions.length);\n        \n        for (IChannelDefinition channelDefinition : channelDefinitions) {\n            this.channelDefinitionsById.put(channelDefinition.getId(), channelDefinition);\n        }\n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void approveChannelDefinition(ChannelDefinition channelDef, IPerson approver, Date approveDate)\n            throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","id":28897,"modified_method":"public void approveChannelDefinition(IChannelDefinition channelDef, IPerson approver, Date approveDate)\n            {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public ChannelCategory[] getParentCategories(ChannelDefinition child) throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n        \n    }","id":28898,"modified_method":"public ChannelCategory[] getParentCategories(IChannelDefinition child) {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n        \n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public ChannelDefinition[] getChildChannels(ChannelCategory parent) throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n        \n    }","id":28899,"modified_method":"public IChannelDefinition[] getChildChannels(ChannelCategory parent) {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n        \n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void disapproveChannelDefinition(ChannelDefinition channelDef) throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","id":28900,"modified_method":"public void disapproveChannelDefinition(IChannelDefinition channelDef) {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public ChannelDefinition[] getChannelDefinitions() throws Exception {\n        return this.channelDefinitionsById.values().toArray(new ChannelDefinition[0]);\n    }","id":28901,"modified_method":"public List<IChannelDefinition> getChannelDefinitions() {\n    \tList<IChannelDefinition> defs = new ArrayList<IChannelDefinition>();\n    \tdefs.addAll(this.channelDefinitionsById.values());\n        return defs;\n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public ChannelDefinition newChannelDefinition(int id) throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n        \n    }","id":28902,"modified_method":"public IChannelDefinition newChannelDefinition(int id) {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n        \n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public ChannelType getChannelType(int channelTypeId) throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n        \n    }","id":28903,"modified_method":"public IChannelType getChannelType(int channelTypeId) {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n        \n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void saveChannelType(ChannelType chanType) throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","id":28904,"modified_method":"public IChannelType saveChannelType(IChannelType chanType) {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void deleteChannelType(ChannelType chanType) throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","id":28905,"modified_method":"public void deleteChannelType(IChannelType chanType) {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public ChannelDefinition getChannelDefinition(int channelPublishId) throws Exception {\n        return this.channelDefinitionsById.get(channelPublishId);\n    }","id":28906,"modified_method":"public IChannelDefinition getChannelDefinition(int channelPublishId) {\n        return this.channelDefinitionsById.get(channelPublishId);\n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void addChannelToCategory(ChannelDefinition channelDef, ChannelCategory category) throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","id":28907,"modified_method":"public void addChannelToCategory(IChannelDefinition channelDef, ChannelCategory category) {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void deleteChannelDefinition(ChannelDefinition channelDef) throws Exception {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","id":28908,"modified_method":"public void deleteChannelDefinition(IChannelDefinition channelDef) {\n        throw new UnsupportedOperationException(\"Not Implemented\");\n\n    }","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void recordChannelDefinitionModified(IPerson person, ChannelDefinition channelDef) {\n\t\tthis.channelDefinitionModifies++;\n\t}","id":28909,"modified_method":"public void recordChannelDefinitionModified(IPerson person, IChannelDefinition channelDef) {\n\t\tthis.channelDefinitionModifies++;\n\t}","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void recordChannelDefinitionRemoved(IPerson person, ChannelDefinition channelDef) {\n\t\tthis.channelDefinitionRemoves++;\n\t}","id":28910,"modified_method":"public void recordChannelDefinitionRemoved(IPerson person, IChannelDefinition channelDef) {\n\t\tthis.channelDefinitionRemoves++;\n\t}","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void recordChannelDefinitionPublished(IPerson person, ChannelDefinition channelDef) {\n\t\tthis.channelDefinitionPublishes++;\n\t}","id":28911,"modified_method":"public void recordChannelDefinitionPublished(IPerson person, IChannelDefinition channelDef) {\n\t\tthis.channelDefinitionPublishes++;\n\t}","commit_id":"b4c3429cbd38a98ce0c47257ed49e5f42678ba1a","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void loadClassFields(final Class clazz,\n                                 final String shortTypeName) throws IOException {\n        if ( clazz == null ) {\n            return;\n        }\n        final ClassFieldInspector inspector = new ClassFieldInspector( clazz );\n        String[] fields = (String[]) inspector.getFieldNames().keySet().toArray( new String[inspector.getFieldNames().size()] );\n        Arrays.sort(fields);\n\n        fields = removeIrrelevantFields( fields );\n\n        this.builder.addFieldsForType( shortTypeName,\n                                       fields );\n\n        Method[] methods = clazz.getMethods();\n        List modifierStrings = new ArrayList();\n        for (int i = 0; i < methods.length; i++) {\n            Method method = methods[i];\n            modifierStrings.add((String) method.getName());\n        }\n        String[] modifiers = new String[modifierStrings.size()];\n        modifierStrings.toArray(modifiers);\n\n        this.builder.addModifiersForType( shortTypeName,\n                                       modifiers);\n\n        for ( int i = 0; i < fields.length; i++ ) {\n            final Class type = (Class) inspector.getFieldTypes().get( fields[i] );\n            final String fieldType = getFieldType( type );\n            this.builder.addFieldType( shortTypeName + \".\" + fields[i],\n                                       fieldType );\n        }\n    }","id":28912,"modified_method":"private void loadClassFields(final Class clazz,\n                                 final String shortTypeName) throws IOException {\n        if (clazz == null) {\n            return;\n        }\n\n        final ClassFieldInspector inspector = new ClassFieldInspector(clazz);\n        Set<String> fieldSet = new HashSet<String>();\n        fieldSet.addAll(inspector.getFieldNames().keySet());\n        // add the \"this\" field. This won't come out from the inspector\n        fieldSet.add(\"this\");\n\n        String [] fields = fieldSet.toArray(new String []{});\n        Arrays.sort(fields);\n\n        fields = removeIrrelevantFields(fields);\n\n        this.builder.addFieldsForType(shortTypeName, fields);\n\n        Method[] methods = clazz.getMethods();\n        List<String> modifierStrings = new ArrayList<String>();\n        for (Method method : methods) {\n            modifierStrings.add(method.getName());\n        }\n        String[] modifiers = new String[modifierStrings.size()];\n        modifierStrings.toArray(modifiers);\n\n        this.builder.addModifiersForType(shortTypeName, modifiers);\n\n        // remove this back out because there is no type for it. We add it explicity\n        fieldSet.remove(\"this\");\n        this.builder.addFieldType(shortTypeName + \".this\", SuggestionCompletionEngine.TYPE_OBJECT);\n\n        for (String field : fieldSet) {\n            final Class type = inspector.getFieldTypes().get(field);\n            final String fieldType = getFieldType(type);\n            this.builder.addFieldType(shortTypeName + \".\" + field, fieldType);\n        }\n\n    }","commit_id":"0f59e3c56d7ef76a07cbb4ee974eda289d55eab8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * This will add the given jars to the classloader.\n     */\n    private void addJars(final List jars) throws IOException {\n        for ( final Iterator it = jars.iterator(); it.hasNext(); ) {\n            final JarInputStream jis = (JarInputStream) it.next();\n            JarEntry entry = null;\n            final byte[] buf = new byte[1024];\n            int len = 0;\n            while ( (entry = jis.getNextJarEntry()) != null ) {\n                if ( !entry.isDirectory() ) {\n                    final ByteArrayOutputStream out = new ByteArrayOutputStream();\n                    while ( (len = jis.read( buf )) >= 0 ) {\n                        out.write( buf,\n                                   0,\n                                   len );\n                    }\n                    this.loader.addResource( entry.getName(),\n                                             out.toByteArray() );\n                }\n            }\n\n        }\n    }","id":28913,"modified_method":"/**\n     * This will add the given jars to the classloader.\n     */\n    private void addJars(final List jars) throws IOException {\n        for (final Iterator it = jars.iterator(); it.hasNext();) {\n            final JarInputStream jis = (JarInputStream) it.next();\n            JarEntry entry  ;\n            final byte[] buf = new byte[1024];\n            int len  ;\n            while ((entry = jis.getNextJarEntry()) != null) {\n                if (!entry.isDirectory()) {\n                    final ByteArrayOutputStream out = new ByteArrayOutputStream();\n                    while ((len = jis.read(buf)) >= 0) {\n                        out.write(buf,\n                                0,\n                                len);\n                    }\n                    this.loader.addResource(entry.getName(),\n                            out.toByteArray());\n                }\n            }\n\n        }\n    }","commit_id":"0f59e3c56d7ef76a07cbb4ee974eda289d55eab8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Override\n  public boolean addElement(Element element) {\n    elements.add(element);\n    return true;\n  }","id":28914,"modified_method":"@Override\n  public <T extends Collection<? super Element>> T finish(T collection) {\n    collection.addAll(elements);\n    elements.clear();\n    return collection;\n  }","commit_id":"377ce17c8fa7901d5a866e729e5bd4d3b70409b4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testAllCollector() {\n    Assert.assertArrayEquals(collect(new AllCollector<Integer>(Integer.class), 0), new Integer[] { });\n    Assert.assertArrayEquals(collect(new AllCollector<Integer>(Integer.class), 4), new Integer[] { 0, 1, 2, 3 });\n  }","id":28915,"modified_method":"@Test\n  public void testAllCollector() {\n    Collector<Integer> collector = new AllCollector<Integer>();\n    Assert.assertEquals(collect(collector, 0), ImmutableList.<Integer>of());\n    Assert.assertEquals(collect(collector, 4), ImmutableList.of(0, 1, 2, 3));\n    Assert.assertEquals(collect(collector, 4), ImmutableList.of(0, 1, 2, 3));\n  }","commit_id":"377ce17c8fa7901d5a866e729e5bd4d3b70409b4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testFirstNCollector() {\n    // add 0 elements\n    Assert.assertArrayEquals(collect(new FirstNCollector<Integer>(1, Integer.class), 0), new Integer[] { });\n    Assert.assertArrayEquals(collect(new FirstNCollector<Integer>(10, Integer.class), 0), new Integer[] { });\n    // add more than capacity\n    Assert.assertArrayEquals(collect(new FirstNCollector<Integer>(1, Integer.class), 10), new Integer[] { 0 });\n    Assert.assertArrayEquals(collect(new FirstNCollector<Integer>(4, Integer.class), 10), new Integer[] { 0, 1, 2, 3 });\n    // add same as capacity\n    Assert.assertArrayEquals(collect(new FirstNCollector<Integer>(1, Integer.class), 1), new Integer[] { 0 });\n    Assert.assertArrayEquals(collect(new FirstNCollector<Integer>(4, Integer.class), 4), new Integer[] { 0, 1, 2, 3 });\n    // add less than capacity\n    Assert.assertArrayEquals(collect(new FirstNCollector<Integer>(4, Integer.class), 1), new Integer[] { 0 });\n    Assert.assertArrayEquals(collect(new FirstNCollector<Integer>(10, Integer.class), 4), new Integer[] { 0, 1, 2, 3 });\n  }","id":28916,"modified_method":"@Test\n  public void testFirstNCollector() {\n    Collector<Integer> collector1 = new FirstNCollector<Integer>(1);\n    Collector<Integer> collector4 = new FirstNCollector<Integer>(4);\n    Collector<Integer> collector10 = new FirstNCollector<Integer>(10);\n\n    // add 0 elements\n    Assert.assertEquals(collect(collector1, 0), ImmutableList.<Integer>of());\n    Assert.assertEquals(collect(collector10, 0), ImmutableList.<Integer>of());\n    // add more than capacity\n    Assert.assertEquals(collect(collector1, 10), ImmutableList.of(0));\n    Assert.assertEquals(collect(collector4, 10), ImmutableList.of(0, 1, 2, 3));\n    // add same as capacity\n    Assert.assertEquals(collect(collector1, 1), ImmutableList.of(0));\n    Assert.assertEquals(collect(collector4, 4), ImmutableList.of(0, 1, 2, 3));\n    // add less than capacity\n    Assert.assertEquals(collect(collector4, 1), ImmutableList.of(0));\n    Assert.assertEquals(collect(collector10, 4), ImmutableList.of(0, 1, 2, 3));\n  }","commit_id":"377ce17c8fa7901d5a866e729e5bd4d3b70409b4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testLastNCollector() {\n    // add 0 elements\n    Assert.assertArrayEquals(collect(new LastNCollector<Integer>(1, Integer.class), 0), new Integer[] { });\n    Assert.assertArrayEquals(collect(new LastNCollector<Integer>(10, Integer.class), 0), new Integer[] { });\n    // add more than capacity\n    Assert.assertArrayEquals(collect(new LastNCollector<Integer>(1, Integer.class), 10), new Integer[] { 9 });\n    Assert.assertArrayEquals(collect(new LastNCollector<Integer>(4, Integer.class), 10), new Integer[] { 6, 7, 8, 9 });\n    // add same as capacity\n    Assert.assertArrayEquals(collect(new LastNCollector<Integer>(1, Integer.class), 1), new Integer[] { 0 });\n    Assert.assertArrayEquals(collect(new LastNCollector<Integer>(4, Integer.class), 4), new Integer[] { 0, 1, 2, 3 });\n    // add less than capacity\n    Assert.assertArrayEquals(collect(new LastNCollector<Integer>(4, Integer.class), 1), new Integer[] { 0 });\n    Assert.assertArrayEquals(collect(new LastNCollector<Integer>(10, Integer.class), 4), new Integer[] { 0, 1, 2, 3 });\n  }","id":28917,"modified_method":"@Test\n  public void testLastNCollector() {\n    Collector<Integer> collector1 = new LastNCollector<Integer>(1);\n    Collector<Integer> collector4 = new LastNCollector<Integer>(4);\n    Collector<Integer> collector10 = new LastNCollector<Integer>(10);\n\n    // add 0 elements\n    Assert.assertEquals(collect(collector1, 0), ImmutableList.<Integer>of());\n    Assert.assertEquals(collect(collector10, 0), ImmutableList.<Integer>of());\n    // add more than capacity\n    Assert.assertEquals(collect(collector1, 10), ImmutableList.of(9));\n    Assert.assertEquals(collect(collector4, 10), ImmutableList.of(6, 7, 8, 9));\n    // add same as capacity\n    Assert.assertEquals(collect(collector1, 1), ImmutableList.of(0));\n    Assert.assertEquals(collect(collector4, 4), ImmutableList.of(0, 1, 2, 3));\n    // add less than capacity\n    Assert.assertEquals(collect(collector4, 1), ImmutableList.of(0));\n    Assert.assertEquals(collect(collector10, 4), ImmutableList.of(0, 1, 2, 3));\n  }","commit_id":"377ce17c8fa7901d5a866e729e5bd4d3b70409b4","url":"https://github.com/caskdata/cdap"},{"original_method":"private Integer[] collect(Collector<Integer> collector, int n) {\n    for (int i = 0; i < n; i++) {\n      if (!collector.addElement(i)) {\n        break;\n      }\n    }\n    return collector.finish();\n  }","id":28918,"modified_method":"private Collection<Integer> collect(Collector<Integer> collector, int n) {\n    for (int i = 0; i < n; i++) {\n      if (!collector.addElement(i)) {\n        break;\n      }\n    }\n    return collector.finish(new ArrayList<Integer>());\n  }","commit_id":"377ce17c8fa7901d5a866e729e5bd4d3b70409b4","url":"https://github.com/caskdata/cdap"},{"original_method":"public FirstNCollector(int n, Class<Element> clazz) {\n    Preconditions.checkArgument(n > 0, \"n must be greater than 0\");\n    elements = ObjectArrays.newArray(clazz, n);\n  }","id":28919,"modified_method":"public FirstNCollector(int n) {\n    Preconditions.checkArgument(n > 0, \"n must be greater than 0\");\n    this.maxCount = n;\n    this.elements = Lists.newArrayListWithCapacity(n);\n  }","commit_id":"377ce17c8fa7901d5a866e729e5bd4d3b70409b4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean addElement(Element element) {\n    if (count >= elements.length) {\n      return false;\n    }\n    elements[count++] = element;\n    return (count < elements.length);\n  }","id":28920,"modified_method":"@Override\n  public boolean addElement(Element element) {\n    if (elements.size() >= maxCount) {\n      return false;\n    }\n    elements.add(element);\n    return (elements.size() < maxCount);\n  }","commit_id":"377ce17c8fa7901d5a866e729e5bd4d3b70409b4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Element[] finish() {\n    if (count >= elements.length) {\n      return elements;\n    }\n    return Arrays.copyOf(elements, count);\n  }","id":28921,"modified_method":"@Override\n  public <T extends Collection<? super Element>> T finish(T collection) {\n    collection.addAll(elements);\n    elements.clear();\n    return collection;\n  }","commit_id":"377ce17c8fa7901d5a866e729e5bd4d3b70409b4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean addElement(Element element) {\n    elements[count % elements.length] = element;\n    count++;\n    return true;\n  }","id":28922,"modified_method":"@Override\n  public boolean addElement(Element element) {\n    if (elements.size() < maxCount) {\n      elements.addLast(element);\n    } else {\n      elements.removeFirst();\n      elements.addLast(element);\n    }\n    return true;\n  }","commit_id":"377ce17c8fa7901d5a866e729e5bd4d3b70409b4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Element[] finish() {\n    if (count < elements.length) {\n      return Arrays.copyOf(elements, count);\n    } else {\n      int mod = count % elements.length;\n      Element[] array = ObjectArrays.newArray(clazz, elements.length);\n      System.arraycopy(elements, mod, array, 0, elements.length - mod);\n      System.arraycopy(elements, 0, array, elements.length - mod, mod);\n      return array;\n    }\n  }","id":28923,"modified_method":"@Override\n  public <T extends Collection<? super Element>> T finish(T collection) {\n    collection.addAll(elements);\n    elements.clear();\n    return collection;\n  }","commit_id":"377ce17c8fa7901d5a866e729e5bd4d3b70409b4","url":"https://github.com/caskdata/cdap"},{"original_method":"public LastNCollector(int n, Class<Element> clazz) {\n    Preconditions.checkArgument(n > 0, \"n must be greater than 0\");\n    this.clazz = clazz;\n    elements = ObjectArrays.newArray(clazz, n);\n  }","id":28924,"modified_method":"public LastNCollector(int n) {\n    Preconditions.checkArgument(n > 0, \"n must be greater than 0\");\n    this.maxCount = n;\n    this.elements = Lists.newLinkedList();\n  }","commit_id":"377ce17c8fa7901d5a866e729e5bd4d3b70409b4","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * This is actually the main method, but in order to make it testable,\n   * instead of exiting in case of error it returns null, whereas in case of\n   * success it returns the retrieved value as shown on the console.\n   *\n   * @param config The configuration of the gateway\n   * @return null in case of error, an string representing the retrieved value\n   *         in case of success\n   */\n  protected String execute(CConfiguration config) {\n    if (help) {\n      return \"\";\n    }\n    // read the access token from file if it exists\n    if (accessToken == null && tokenFile != null) {\n      accessToken = readTokenFile();\n    }\n\n    // determine the base url for the HTTP requests\n    String baseUrl = GatewayUrlGenerator.getBaseUrl(config, hostname, port, !forceNoSSL && apikey != null);\n    if (baseUrl == null) {\n      System.err.println(\"Can't figure out the URL to send to. Please use --host to specify\");\n      return null;\n    } else {\n      if (verbose) {\n        System.out.println(\"Using base URL: \" + baseUrl);\n      }\n    }\n\n    // build the full URI for the request and validate it\n    String requestUrl = baseUrl + \"streams/\" + destination;\n\n    if (\"send\".equals(command)) {\n      // get the body as a byte array\n      byte[] binaryBody = readBody();\n      if (binaryBody == null) {\n        System.err.println(\"Cannot send an event without body. \" +\n                           \"Please use --body or --body-file to specify the body.\");\n        return null;\n      }\n\n      // create an HttpPost\n      HttpPost post = new HttpPost(requestUrl);\n      for (String header : headers.keySet()) {\n        post.setHeader(destination + \".\" + header, headers.get(header));\n      }\n      post.setEntity(new ByteArrayEntity(binaryBody));\n      HttpClient client = new DefaultHttpClient();\n      try {\n        return (sendHttpRequest(client, post, null) != null) ? \"OK.\" : null;\n      } finally {\n        client.getConnectionManager().shutdown();\n      }\n    } else if (\"group\".equals(command)) {\n      String id = getConsumerId(requestUrl);\n      if (id != null) {\n        System.out.println(id);\n        return id;\n      } else {\n        return null;\n      }\n    } else if (\"info\".equals(command)) {\n      String info = getQueueInfo(requestUrl);\n      if (info != null) {\n        System.out.println(info);\n        return \"OK.\";\n      } else {\n        return null;\n      }\n    } else if (\"fetch\".equals(command)) {\n      StreamEvent event;\n      try {\n        event = fetchOne(requestUrl, consumer);\n      } catch (Exception e) {\n        System.err.println(e.getMessage());\n        return null;\n      }\n      if (event == null) {\n        System.out.println(\"no event\");\n        return \"\";\n      }\n      // print all the headers\n      for (String name : event.getHeaders().keySet()) {\n        // unless --verbose was given, we suppress continuuity headers\n        if (!verbose && name.startsWith(Constants.Gateway.CONTINUUITY_PREFIX)) {\n          continue;\n        }\n        System.out.println(name + \": \" + event.getHeaders().get(name));\n      }\n      // and finally write out the body\n      return writeBody(Bytes.toBytes(event.getBody()));\n    } else if (\"view\".equals(command)) {\n      if (consumer == null) {\n        HttpClient client = new DefaultHttpClient();\n        HttpPost post = new HttpPost(requestUrl + \"/consumer-id\");\n        try {\n          HttpResponse response = sendHttpRequest(client, post, null);\n          if (response == null) {\n            return null;\n          }\n          // read the binary value from the HTTP response\n          byte[] binaryValue = Util.readHttpResponse(response);\n          if (binaryValue == null) {\n            System.err.println(\"Unexpected response without body.\");\n            return null;\n          }\n          consumer = Bytes.toString(binaryValue);\n        } finally {\n          client.getConnectionManager().shutdown();\n        }\n      }\n      Collector<StreamEvent> collector =\n        all ? new AllCollector<StreamEvent>(StreamEvent.class) :\n          first != null ? new FirstNCollector<StreamEvent>(first, StreamEvent.class) :\n            last != null ? new LastNCollector<StreamEvent>(last, StreamEvent.class) :\n              new FirstNCollector<StreamEvent>(10, StreamEvent.class);\n      try {\n        StreamEvent[] events =\n          fetchAll(requestUrl, consumer, collector);\n        return printEvents(events);\n      } catch (Exception e) {\n        System.err.println(e.getMessage());\n        return null;\n      }\n\n    } else if (\"create\".equals(command)) {\n      HttpClient client = new DefaultHttpClient();\n      HttpPut put = new HttpPut(requestUrl);\n      try {\n        return (sendHttpRequest(client, put, null) != null) ? \"OK.\" : null;\n      } finally {\n        client.getConnectionManager().shutdown();\n      }\n    } else if (\"truncate\".equals(command)) {\n      HttpClient client = new DefaultHttpClient();\n      HttpPost post = new HttpPost(requestUrl + \"/truncate\");\n      try {\n        return (sendHttpRequest(client, post, null) != null) ? \"OK.\" : null;\n      } finally {\n        client.getConnectionManager().shutdown();\n      }\n    } else if (\"config\".equals(command)) {\n      HttpClient client = new DefaultHttpClient();\n      HttpPut put = new HttpPut(requestUrl + \"/config\");\n      JsonObject streamConfig = new JsonObject();\n      streamConfig.addProperty(\"ttl\", ttl);\n      put.setEntity(new ByteArrayEntity(GSON.toJson(streamConfig).getBytes(Charsets.UTF_8)));\n      try {\n        return (sendHttpRequest(client, put, null) != null) ? \"OK.\" : null;\n      } finally {\n        client.getConnectionManager().shutdown();\n      }\n    }\n    return null;\n  }","id":28925,"modified_method":"/**\n   * This is actually the main method, but in order to make it testable,\n   * instead of exiting in case of error it returns null, whereas in case of\n   * success it returns the retrieved value as shown on the console.\n   *\n   * @param config The configuration of the gateway\n   * @return null in case of error, an string representing the retrieved value\n   *         in case of success\n   */\n  protected String execute(CConfiguration config) {\n    if (help) {\n      return \"\";\n    }\n    // read the access token from file if it exists\n    if (accessToken == null && tokenFile != null) {\n      accessToken = readTokenFile();\n    }\n\n    // determine the base url for the HTTP requests\n    String baseUrl = GatewayUrlGenerator.getBaseUrl(config, hostname, port, !forceNoSSL && apikey != null);\n    if (baseUrl == null) {\n      System.err.println(\"Can't figure out the URL to send to. Please use --host to specify\");\n      return null;\n    } else {\n      if (verbose) {\n        System.out.println(\"Using base URL: \" + baseUrl);\n      }\n    }\n\n    // build the full URI for the request and validate it\n    String requestUrl = baseUrl + \"streams/\" + destination;\n\n    if (\"send\".equals(command)) {\n      // get the body as a byte array\n      byte[] binaryBody = readBody();\n      if (binaryBody == null) {\n        System.err.println(\"Cannot send an event without body. \" +\n                           \"Please use --body or --body-file to specify the body.\");\n        return null;\n      }\n\n      // create an HttpPost\n      HttpPost post = new HttpPost(requestUrl);\n      for (String header : headers.keySet()) {\n        post.setHeader(destination + \".\" + header, headers.get(header));\n      }\n      post.setEntity(new ByteArrayEntity(binaryBody));\n      HttpClient client = new DefaultHttpClient();\n      try {\n        return (sendHttpRequest(client, post, null) != null) ? \"OK.\" : null;\n      } finally {\n        client.getConnectionManager().shutdown();\n      }\n    } else if (\"group\".equals(command)) {\n      String id = getConsumerId(requestUrl);\n      if (id != null) {\n        System.out.println(id);\n        return id;\n      } else {\n        return null;\n      }\n    } else if (\"info\".equals(command)) {\n      String info = getQueueInfo(requestUrl);\n      if (info != null) {\n        System.out.println(info);\n        return \"OK.\";\n      } else {\n        return null;\n      }\n    } else if (\"fetch\".equals(command)) {\n      StreamEvent event;\n      try {\n        event = fetchOne(requestUrl, consumer);\n      } catch (Exception e) {\n        System.err.println(e.getMessage());\n        return null;\n      }\n      if (event == null) {\n        System.out.println(\"no event\");\n        return \"\";\n      }\n      // print all the headers\n      for (String name : event.getHeaders().keySet()) {\n        // unless --verbose was given, we suppress continuuity headers\n        if (!verbose && name.startsWith(Constants.Gateway.CONTINUUITY_PREFIX)) {\n          continue;\n        }\n        System.out.println(name + \": \" + event.getHeaders().get(name));\n      }\n      // and finally write out the body\n      return writeBody(Bytes.toBytes(event.getBody()));\n    } else if (\"view\".equals(command)) {\n      if (consumer == null) {\n        HttpClient client = new DefaultHttpClient();\n        HttpPost post = new HttpPost(requestUrl + \"/consumer-id\");\n        try {\n          HttpResponse response = sendHttpRequest(client, post, null);\n          if (response == null) {\n            return null;\n          }\n          // read the binary value from the HTTP response\n          byte[] binaryValue = Util.readHttpResponse(response);\n          if (binaryValue == null) {\n            System.err.println(\"Unexpected response without body.\");\n            return null;\n          }\n          consumer = Bytes.toString(binaryValue);\n        } finally {\n          client.getConnectionManager().shutdown();\n        }\n      }\n      Collector<StreamEvent> collector =\n        all ? new AllCollector<StreamEvent>() :\n          first != null ? new FirstNCollector<StreamEvent>(first) :\n            last != null ? new LastNCollector<StreamEvent>(last) :\n              new FirstNCollector<StreamEvent>(10);\n      try {\n        return printEvents(fetchAll(requestUrl, consumer, collector));\n      } catch (Exception e) {\n        System.err.println(e.getMessage());\n        return null;\n      }\n\n    } else if (\"create\".equals(command)) {\n      HttpClient client = new DefaultHttpClient();\n      HttpPut put = new HttpPut(requestUrl);\n      try {\n        return (sendHttpRequest(client, put, null) != null) ? \"OK.\" : null;\n      } finally {\n        client.getConnectionManager().shutdown();\n      }\n    } else if (\"truncate\".equals(command)) {\n      HttpClient client = new DefaultHttpClient();\n      HttpPost post = new HttpPost(requestUrl + \"/truncate\");\n      try {\n        return (sendHttpRequest(client, post, null) != null) ? \"OK.\" : null;\n      } finally {\n        client.getConnectionManager().shutdown();\n      }\n    } else if (\"config\".equals(command)) {\n      HttpClient client = new DefaultHttpClient();\n      HttpPut put = new HttpPut(requestUrl + \"/config\");\n      JsonObject streamConfig = new JsonObject();\n      streamConfig.addProperty(\"ttl\", ttl);\n      put.setEntity(new ByteArrayEntity(GSON.toJson(streamConfig).getBytes(Charsets.UTF_8)));\n      try {\n        return (sendHttpRequest(client, put, null) != null) ? \"OK.\" : null;\n      } finally {\n        client.getConnectionManager().shutdown();\n      }\n    }\n    return null;\n  }","commit_id":"377ce17c8fa7901d5a866e729e5bd4d3b70409b4","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Helper method for --view, given a request URL already constructed, a\n   * consumer ID, and an event collector, it iterates over events from the\n   * stream until the stream is empty or the collector indicates to stop.\n   *\n   * @param uri       The request URI including the stream name without the query\n   * @param consumer  the consumer group id, as previously returned by\n   *                  getConsumerId()\n   * @param collector a collector for the events in the stream\n   * @return all events collected\n   * @throws Exception if something goes wrong\n   */\n  StreamEvent[] fetchAll(String uri, String consumer, Collector<StreamEvent> collector)\n    throws Exception {\n    while (true) {\n      StreamEvent event = fetchOne(uri, consumer);\n      if (event == null) {\n        return collector.finish();\n      }\n      boolean collectMore = collector.addElement(event);\n      if (!collectMore) {\n        return collector.finish();\n      }\n    }\n  }","id":28926,"modified_method":"/**\n   * Helper method for --view, given a request URL already constructed, a\n   * consumer ID, and an event collector, it iterates over events from the\n   * stream until the stream is empty or the collector indicates to stop.\n   *\n   * @param uri       The request URI including the stream name without the query\n   * @param consumer  the consumer group id, as previously returned by\n   *                  getConsumerId()\n   * @param collector a collector for the events in the stream\n   * @return all events collected\n   * @throws Exception if something goes wrong\n   */\n  Collection<StreamEvent> fetchAll(String uri, String consumer, Collector<StreamEvent> collector)\n    throws Exception {\n    while (true) {\n      StreamEvent event = fetchOne(uri, consumer);\n      if (event == null) {\n        return collector.finish(new ArrayList<StreamEvent>());\n      }\n      boolean collectMore = collector.addElement(event);\n      if (!collectMore) {\n        return collector.finish(new ArrayList<StreamEvent>());\n      }\n    }\n  }","commit_id":"377ce17c8fa7901d5a866e729e5bd4d3b70409b4","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Helper for --view. Prints all the collected events to stdout. This can be\n   * improved to use better formatting, shortening, etc.\n   *\n   * @param events An array of events\n   * @return a String indicating how many events were printed\n   */\n  String printEvents(StreamEvent[] events) {\n    System.out.println(events.length + \" events: \");\n    for (StreamEvent event : events) {\n      String sep = \"\";\n      for (String name : event.getHeaders().keySet()) {\n        // unless --verbose was given, we suppress continuuity headers\n        if (!verbose && name.startsWith(Constants.Gateway.CONTINUUITY_PREFIX)) {\n          continue;\n        }\n        System.out.print(sep + name + \"=\" + event.getHeaders().get(name));\n        sep = \", \";\n      }\n      System.out.print(\": \");\n      if (hex) {\n        System.out.print(Util.toHex(Bytes.toBytes(event.getBody())));\n      } else if (urlenc) {\n        System.out.print(Util.urlEncode(Bytes.toBytes(event.getBody())));\n      } else {\n        System.out.print(new String(Bytes.toBytes(event.getBody())));\n      }\n      System.out.println();\n    }\n    return events.length + \" events.\";\n  }","id":28927,"modified_method":"/**\n   * Helper for --view. Prints all the collected events to stdout. This can be\n   * improved to use better formatting, shortening, etc.\n   *\n   * @param events An array of events\n   * @return a String indicating how many events were printed\n   */\n  String printEvents(Collection<StreamEvent> events) {\n    System.out.println(events.size() + \" events: \");\n    for (StreamEvent event : events) {\n      String sep = \"\";\n      for (String name : event.getHeaders().keySet()) {\n        // unless --verbose was given, we suppress continuuity headers\n        if (!verbose && name.startsWith(Constants.Gateway.CONTINUUITY_PREFIX)) {\n          continue;\n        }\n        System.out.print(sep + name + \"=\" + event.getHeaders().get(name));\n        sep = \", \";\n      }\n      System.out.print(\": \");\n      if (hex) {\n        System.out.print(Util.toHex(Bytes.toBytes(event.getBody())));\n      } else if (urlenc) {\n        System.out.print(Util.urlEncode(Bytes.toBytes(event.getBody())));\n      } else {\n        System.out.print(new String(Bytes.toBytes(event.getBody())));\n      }\n      System.out.println();\n    }\n    return events.size() + \" events.\";\n  }","commit_id":"377ce17c8fa7901d5a866e729e5bd4d3b70409b4","url":"https://github.com/caskdata/cdap"},{"original_method":"public int getBaseLine () {\n\t\treturn bitmapFont.getCapHeight();\n\t}","id":28928,"modified_method":"public int getBaseLine () {\n\t\treturn (int)bitmapFont.getCapHeight();\n\t}","commit_id":"e12490cdfabc92ac1fd82725605c4ef6c4421222","url":"https://github.com/libgdx/libgdx"},{"original_method":"public int getLineHeight () {\n\t\treturn bitmapFont.getLineHeight();\n\t}","id":28929,"modified_method":"public int getLineHeight () {\n\t\treturn (int)bitmapFont.getLineHeight();\n\t}","commit_id":"e12490cdfabc92ac1fd82725605c4ef6c4421222","url":"https://github.com/libgdx/libgdx"},{"original_method":"public int getEM () {\n\t\treturn bitmapFont.getLineHeight();\n\t}","id":28930,"modified_method":"public int getEM () {\n\t\treturn (int)bitmapFont.getLineHeight();\n\t}","commit_id":"e12490cdfabc92ac1fd82725605c4ef6c4421222","url":"https://github.com/libgdx/libgdx"},{"original_method":"public int getEX () {\n\t\treturn bitmapFont.getXHeight();\n\t}","id":28931,"modified_method":"public int getEX () {\n\t\treturn (int)bitmapFont.getXHeight();\n\t}","commit_id":"e12490cdfabc92ac1fd82725605c4ef6c4421222","url":"https://github.com/libgdx/libgdx"},{"original_method":"public int getSpaceWidth () {\n\t\treturn bitmapFont.getSpaceWidth();\n\t}","id":28932,"modified_method":"public int getSpaceWidth () {\n\t\treturn (int)bitmapFont.getSpaceWidth();\n\t}","commit_id":"e12490cdfabc92ac1fd82725605c4ef6c4421222","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void updateText() {\n      FontMetrics fontMetrics = ((EditorImpl)myEditor).getFontMetrics(Font.PLAIN);\n      DocumentEx document = myEditor.getDocument();\n      Insets insets = getInsets();\n      int maxLineWidth = getWidth() - (insets != null ? insets.left + insets.right : 0);\n\n      myDocumentTextBuilder.setLength(0);\n      if (getHeight() / myEditor.getLineHeight() < 1.1f) {\n        String line = document.getText().replace('\\n', RETURN_SYMBOL);\n        appendAbbreviatedLine(myDocumentTextBuilder, line, fontMetrics, maxLineWidth);\n      }\n      else {\n        for (LineIterator line = document.createLineIterator(); !line.atEnd(); line.advance()) {\n          String lineText = document.getText(new TextRange(line.getStart(), line.getEnd()));\n          appendAbbreviatedLine(myDocumentTextBuilder, lineText, fontMetrics, maxLineWidth);\n        }\n      }\n\n      setText(myDocumentTextBuilder.toString(), true);\n    }","id":28933,"modified_method":"private void updateText() {\n      FontMetrics fontMetrics = ((EditorImpl)myEditor).getFontMetrics(myTextAttributes != null ? myTextAttributes.getFontType() : Font.PLAIN);\n      Insets insets = getInsets();\n      int maxLineWidth = getWidth() - (insets != null ? insets.left + insets.right : 0);\n\n      myDocumentTextBuilder.setLength(0);\n      float visibleLinesCountFractional = getHeight() / (float)myEditor.getLineHeight();\n      if (visibleLinesCountFractional < 1.1f) {\n        appendAbbreviated(myDocumentTextBuilder, myRawText, 0, myRawText.length(), fontMetrics, maxLineWidth, true);\n      }\n      else {\n        Matcher m = LINE_PATTERN.matcher(myRawText);\n        int visibleLinesCount = (int)Math.floor(visibleLinesCountFractional + 0.5);\n        for (int i = 0; i < visibleLinesCount && m.find(); i++) {\n          appendAbbreviated(myDocumentTextBuilder, myRawText, m.start(1), m.end(1), fontMetrics, maxLineWidth, false);\n          if (m.start(2) != -1) {\n            myDocumentTextBuilder.append('\\n');\n          }\n        }\n      }\n\n      setTextToEditor(myDocumentTextBuilder.toString());\n    }","commit_id":"153239b9e45ab3ea5b08d9761a87920569d16a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setText(String text) {\n      setText(text, false);\n    }","id":28934,"modified_method":"private void setTextToEditor(String text) {\n      myEditor.getMarkupModel().removeAllHighlighters();\n      myEditor.getDocument().setText(text);\n      myEditor.getHighlighter().setText(text);\n      if (myTextAttributes != null) {\n        myEditor.getMarkupModel().addRangeHighlighter(0, myEditor.getDocument().getTextLength(),\n          HighlighterLayer.ADDITIONAL_SYNTAX, myTextAttributes, HighlighterTargetArea.EXACT_RANGE);\n      }\n\n      ((EditorImpl)myEditor).resetSizes();\n\n      SelectionModel selectionModel = myEditor.getSelectionModel();\n      selectionModel.setSelection(0, selectionModel.hasSelection() ? myEditor.getDocument().getTextLength() : 0);\n    }","commit_id":"153239b9e45ab3ea5b08d9761a87920569d16a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n    MyPanel panel = getEditorPanel(table);\n    EditorEx editor = panel.myEditor;\n    Font font = table.getFont();\n    Font editorFont = editor.getColorsScheme().getFont(EditorFontType.PLAIN);\n    if (!Comparing.equal(font, editorFont)) {\n      editor.getColorsScheme().setEditorFontSize(font.getSize());\n    }\n    panel.setText(getText(((EditorImpl)editor).getFontMetrics(Font.PLAIN), table, value, row, column));\n\n    ((EditorImpl)editor).setPaintSelection(isSelected);\n    editor.getSelectionModel().setSelection(0, isSelected ? editor.getDocument().getTextLength() : 0);\n    editor.getColorsScheme().setColor(EditorColors.SELECTION_BACKGROUND_COLOR, table.getSelectionBackground());\n    editor.getColorsScheme().setColor(EditorColors.SELECTION_FOREGROUND_COLOR, table.getSelectionForeground());\n    editor.setBackgroundColor(getCellBackgroundColor(getColorScheme(), table, isSelected, row));\n\n    panel.setBorder(null); // prevents double border painting when ExtendedItemRendererComponentWrapper is used\n\n    customizeEditor(editor, value, isSelected, row, column);\n    return panel;\n  }","id":28935,"modified_method":"@Override\n  public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n    MyPanel panel = getEditorPanel(table);\n    EditorEx editor = panel.myEditor;\n    Font font = table.getFont();\n    Font editorFont = editor.getColorsScheme().getFont(EditorFontType.PLAIN);\n    if (!Comparing.equal(font, editorFont)) {\n      editor.getColorsScheme().setEditorFontSize(font.getSize());\n    }\n    String text = getText(((EditorImpl)editor).getFontMetrics(Font.PLAIN), table, value, row, column);\n    TextAttributes textAttributes = getTextAttributes(value, isSelected, row, column);\n    panel.setText(text, textAttributes);\n\n    ((EditorImpl)editor).setPaintSelection(isSelected);\n    editor.getSelectionModel().setSelection(0, isSelected ? editor.getDocument().getTextLength() : 0);\n    editor.getColorsScheme().setColor(EditorColors.SELECTION_BACKGROUND_COLOR, table.getSelectionBackground());\n    editor.getColorsScheme().setColor(EditorColors.SELECTION_FOREGROUND_COLOR, table.getSelectionForeground());\n    editor.setBackgroundColor(getCellBackgroundColor(getColorScheme(), table, isSelected, row));\n\n    panel.setBorder(null); // prevents double border painting when ExtendedItemRendererComponentWrapper is used\n\n    return panel;\n  }","commit_id":"153239b9e45ab3ea5b08d9761a87920569d16a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void appendAbbreviatedLine(StringBuilder to, String line, FontMetrics metrics, int maxWidth) {\n      if (metrics.charWidth('m') * line.length() <= maxWidth) {\n        to.append(line);\n        return;\n      }\n\n      int abbrWidth = metrics.stringWidth(ABBREVIATION_SUFFIX);\n      int abbrIdx = 0;\n\n      for (; abbrIdx < line.length(); abbrIdx++) {\n        int nextCharWidth = metrics.charWidth(line.charAt(abbrIdx));\n        if (abbrWidth + nextCharWidth >= maxWidth) break;\n        abbrWidth += nextCharWidth;\n      }\n\n      to.append(line, 0, abbrIdx);\n      to.append(ABBREVIATION_SUFFIX);\n      if (abbrIdx != line.length() && line.endsWith(\"\\n\")) {\n        to.append('\\n');\n      }\n    }","id":28936,"modified_method":"private static void appendAbbreviated(StringBuilder to, String text, int start, int end,\n                                          FontMetrics metrics, int maxWidth, boolean replaceLineTerminators) {\n      if (metrics.charWidth('m') * (end - start) <= maxWidth) {\n        appendAndReplaceLineTerminatorsIfNeeded(to, text, start, end, replaceLineTerminators);\n        return;\n      }\n\n      int abbrWidth = metrics.charWidth(ABBREVIATION_SUFFIX);\n      int abbrIdx = start;\n\n      Matcher m = LINE_TERMINATOR_OR_A_CHARACTER_PATTERN.matcher(text);\n      m.region(start, end);\n\n      while (m.find()) {\n        int appendWidth = 0;\n        if (replaceLineTerminators && m.start(1) != -1) {\n          appendWidth = metrics.charWidth(RETURN_SYMBOL);\n        }\n        else {\n          for (int i = m.start(); i < m.end(); i++) {\n            appendWidth += metrics.charWidth(text.charAt(i));\n          }\n        }\n        if (abbrWidth + appendWidth >= maxWidth) break;\n        abbrWidth += appendWidth;\n        abbrIdx = m.end();\n      }\n\n      appendAndReplaceLineTerminatorsIfNeeded(to, text, start, abbrIdx, replaceLineTerminators);\n      to.append(ABBREVIATION_SUFFIX);\n    }","commit_id":"153239b9e45ab3ea5b08d9761a87920569d16a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setText(String text, boolean abbreviationOfCurrentText) {\n      if (!abbreviationOfCurrentText) {\n        myEditor.getMarkupModel().removeAllHighlighters();\n      }\n\n      myEditor.getDocument().setText(text);\n      myEditor.getHighlighter().setText(text);\n      ((EditorImpl)myEditor).resetSizes();\n\n      SelectionModel selectionModel = myEditor.getSelectionModel();\n      selectionModel.setSelection(0, selectionModel.hasSelection() ? myEditor.getDocument().getTextLength() : 0);\n\n      if (!abbreviationOfCurrentText) {\n        myPreferredSize = super.getPreferredSize();\n      }\n    }","id":28937,"modified_method":"public void setText(String text, @Nullable TextAttributes textAttributes) {\n      myRawText = text;\n      myTextAttributes = textAttributes;\n      recalculatePreferredSize();\n    }","commit_id":"153239b9e45ab3ea5b08d9761a87920569d16a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public Dimension getPreferredSize() {\n      return myPreferredSize == null ? super.getPreferredSize() : myPreferredSize;\n    }","id":28938,"modified_method":"@Override\n    public Dimension getPreferredSize() {\n      return myPreferredSize;\n    }","commit_id":"153239b9e45ab3ea5b08d9761a87920569d16a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private MyPanel getEditorPanel(JTable table) {\n    MyPanel panel = UIUtil.getClientProperty(table, MY_PANEL_PROPERTY);\n    if (panel != null) {\n      EditorColorsScheme scheme = panel.myEditor.getColorsScheme();\n      if (scheme instanceof DelegateColorScheme) {\n        ((DelegateColorScheme)scheme).setDelegate(getColorScheme());\n      }\n      return panel;\n    }\n\n    // reuse EditorTextField initialization logic\n    EditorTextField field = new EditorTextField(new MyDocument(), null, FileTypes.PLAIN_TEXT);\n    field.setSupplementary(true);\n    field.addNotify(); // creates editor\n\n    EditorEx editor = (EditorEx)ObjectUtils.assertNotNull(field.getEditor());\n    editor.setRendererMode(true);\n\n    editor.setColorsScheme(editor.createBoundColorSchemeDelegate(null));\n    editor.getColorsScheme().setColor(EditorColors.CARET_ROW_COLOR, null);\n\n    editor.getScrollPane().setBorder(null);\n\n    panel = new MyPanel(editor);\n    Disposer.register(this, panel);\n\n    table.putClientProperty(MY_PANEL_PROPERTY, panel);\n    return panel;\n  }","id":28939,"modified_method":"@NotNull\n  private MyPanel getEditorPanel(JTable table) {\n    MyPanel panel = UIUtil.getClientProperty(table, MY_PANEL_PROPERTY);\n    if (panel != null) {\n      EditorColorsScheme scheme = panel.myEditor.getColorsScheme();\n      if (scheme instanceof DelegateColorScheme) {\n        ((DelegateColorScheme)scheme).setDelegate(getColorScheme());\n      }\n      return panel;\n    }\n\n    // reuse EditorTextField initialization logic\n    EditorTextField field = new EditorTextField(new MyDocument(), null, FileTypes.PLAIN_TEXT, false, false);\n    field.setSupplementary(true);\n    field.addNotify(); // creates editor\n\n    EditorEx editor = (EditorEx)ObjectUtils.assertNotNull(field.getEditor());\n    editor.setRendererMode(true);\n\n    editor.setColorsScheme(editor.createBoundColorSchemeDelegate(null));\n    editor.getColorsScheme().setColor(EditorColors.CARET_ROW_COLOR, null);\n\n    editor.getScrollPane().setBorder(null);\n\n    panel = new MyPanel(editor);\n    Disposer.register(this, panel);\n\n    table.putClientProperty(MY_PANEL_PROPERTY, panel);\n    return panel;\n  }","commit_id":"153239b9e45ab3ea5b08d9761a87920569d16a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GetBucketAccessControlPolicyResponseType getBucketAccessControlPolicy(\n\t\t\tGetBucketAccessControlPolicyType request)\n\t\t\t\t\tthrows EucalyptusCloudException {\n\t\tGetBucketAccessControlPolicyResponseType reply = (GetBucketAccessControlPolicyResponseType) request\n\t\t\t\t.getReply();\n\n\t\tString bucketName = request.getBucket();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString ownerId = null;\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tAccessControlListType accessControlList = new AccessControlListType();\n\t\tBucketLogData logData;\n\n\t\tif (bucketList.size() > 0) {\n\t\t\t// construct access control policy from grant infos\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tlogData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tList<GrantInfo> grantInfos = bucket.getGrants();\n\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\tbucket.canReadACP(account.getAccountNumber()) &&\n\t\t\t\t\t(bucket.isGlobalReadACP() || Lookups.checkPrivilege(PolicySpec.S3_GETBUCKETACL,\n\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_BUCKET,\n\t\t\t\t\t\t\tbucketName,\n\t\t\t\t\t\t\tnull)))) {\n\t\t\t\tif (logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\n\t\t\t\townerId = bucket.getOwnerId();\n\t\t\t\tArrayList<Grant> grants = new ArrayList<Grant>();\n\t\t\t\tbucket.readPermissions(grants);\n\t\t\t\tfor (GrantInfo grantInfo : grantInfos) {\n\t\t\t\t\tString uId = grantInfo.getUserId();\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//TODO: zhill - Modify this to handle invalid accounts and just skip them. This is just response creation, not authorization\n\t\t\t\t\t\tif (uId != null) {\n\t\t\t\t\t\t\taddPermission(grants, Accounts.lookupAccountById(uId), grantInfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddPermission(grants, grantInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName,\n\t\t\t\t\t\t\t\tlogData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taccessControlList.setGrants(grants);\n\t\t\t} else {\n\t\t\t\tLOG.error( \"Not authorized to get bucket ACL by \" + ctx.getUserFullName( ) );\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tAccessControlPolicyType accessControlPolicy = new AccessControlPolicyType();\n\t\ttry {\n\t\t\tAccount ownerInfo = Accounts.lookupAccountById(ownerId);\n\t\t\taccessControlPolicy.setOwner(new CanonicalUserType(ownerInfo.getAccountNumber(), ownerInfo.getName()));\n\t\t\taccessControlPolicy.setAccessControlList(accessControlList);\n\t\t} catch (AuthException e) {\n\t\t\tdb.rollback();\n\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t}\n\t\treply.setAccessControlPolicy(accessControlPolicy);\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":28940,"modified_method":"public GetBucketAccessControlPolicyResponseType getBucketAccessControlPolicy(\n\t\t\tGetBucketAccessControlPolicyType request)\n\t\t\t\t\tthrows EucalyptusCloudException {\n\t\tGetBucketAccessControlPolicyResponseType reply = (GetBucketAccessControlPolicyResponseType) request\n\t\t\t\t.getReply();\n\n\t\tString bucketName = request.getBucket();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString ownerId = null;\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tAccessControlListType accessControlList = new AccessControlListType();\n\t\tBucketLogData logData;\n\n\t\tif (bucketList.size() > 0) {\n\t\t\t// construct access control policy from grant infos\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tlogData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tList<GrantInfo> grantInfos = bucket.getGrants();\n\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\tbucket.canReadACP(account.getAccountNumber()) &&\n\t\t\t\t\t(bucket.isGlobalReadACP() || Lookups.checkPrivilege(PolicySpec.S3_GETBUCKETACL,\n\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_BUCKET,\n\t\t\t\t\t\t\tbucketName,\n\t\t\t\t\t\t\tnull)))) {\n\t\t\t\tif (logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\n\t\t\t\townerId = bucket.getOwnerId();\n\t\t\t\tArrayList<Grant> grants = new ArrayList<Grant>();\n\t\t\t\tbucket.readPermissions(grants);\n\t\t\t\tCanonicalUserType grantUser = null;\n\t\t\t\tAccount tmpAccnt = null;\n\t\t\t\tfor (GrantInfo grantInfo : grantInfos) {\n\t\t\t\t\tString uId = grantInfo.getUserId();\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (uId != null) {\n\t\t\t\t\t\t\t//Lots of work just to try to get the display Name of the userId.\n\t\t\t\t\t\t\t//TODO: zhill - Operations like this shouldn't have to hit the DB for every user, that can be in the grant record\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\ttmpAccnt = Accounts.lookupAccountById(uId);\n\t\t\t\t\t\t\t\tgrantUser = new CanonicalUserType(tmpAccnt.getAccountNumber(), tmpAccnt.getName());\n\t\t\t\t\t\t\t\ttmpAccnt = null;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} catch(AuthException e) {\n\t\t\t\t\t\t\t\tLOG.debug(e,e);\n\t\t\t\t\t\t\t\t//Couldn't get one, use empty string\n\t\t\t\t\t\t\t\tgrantUser = new CanonicalUserType(uId, \"\");\n\t\t\t\t\t\t\t\ttmpAccnt = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddPermission(grants, grantUser, grantInfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddPermission(grants, grantInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t//Just skip this entry, this is not an auth issue\n\t\t\t\t\t\tLOG.debug(e,e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taccessControlList.setGrants(grants);\n\t\t\t} else {\n\t\t\t\tLOG.error( \"Not authorized to get bucket ACL by \" + ctx.getUserFullName( ) );\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tAccessControlPolicyType accessControlPolicy = new AccessControlPolicyType();\n\t\ttry {\n\t\t\tAccount ownerInfo = Accounts.lookupAccountById(ownerId);\n\t\t\taccessControlPolicy.setOwner(new CanonicalUserType(ownerInfo.getAccountNumber(), ownerInfo.getName()));\n\t\t\taccessControlPolicy.setAccessControlList(accessControlList);\n\t\t} catch (AuthException e) {\n\t\t\tdb.rollback();\n\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t}\n\t\treply.setAccessControlPolicy(accessControlPolicy);\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"49f46d08af4f554a8862c0f79beb50c2ed997c1a","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ListVersionsResponseType listVersions(ListVersionsType request)\n\t\t\tthrows EucalyptusCloudException {\n\t\tListVersionsResponseType reply = (ListVersionsResponseType) request\n\t\t\t\t.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString prefix = request.getPrefix();\n\t\tif (prefix == null)\n\t\t\tprefix = \"\";\n\n\t\tString keyMarker = request.getKeyMarker();\n\t\tString versionIdMarker = request.getVersionIdMarker();\n\n\t\tint maxKeys = -1;\n\t\tString maxKeysString = request.getMaxKeys();\n\t\tif (maxKeysString != null)\n\t\t\tmaxKeys = Integer.parseInt(maxKeysString);\n\t\telse\n\t\t\tmaxKeys = WalrusProperties.MAX_KEYS;\n\n\t\tString delimiter = request.getDelimiter();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tbucketInfo.setHidden(false);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tArrayList<PrefixEntry> prefixes = new ArrayList<PrefixEntry>();\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\tbucket.canRead(account.getAccountNumber()) &&\n\t\t\t\t\t(bucket.isGlobalRead() || Lookups.checkPrivilege(PolicySpec.S3_LISTBUCKETVERSIONS,\n\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_BUCKET,\n\t\t\t\t\t\t\tbucketName,\n\t\t\t\t\t\t\tnull)))) {\n\t\t\t\tif (bucket.isVersioningDisabled()) {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new EucalyptusCloudException(\n\t\t\t\t\t\t\t\"Versioning has not been enabled for bucket: \"\n\t\t\t\t\t\t\t\t\t+ bucketName);\n\t\t\t\t}\n\t\t\t\tif (logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\n\t\t\t\tif (Contexts.lookup().hasAdministrativePrivileges()) {\n\t\t\t\t\tEntityWrapper<WalrusSnapshotInfo> dbSnap = db\n\t\t\t\t\t\t\t.recast(WalrusSnapshotInfo.class);\n\t\t\t\t\tWalrusSnapshotInfo walrusSnapInfo = new WalrusSnapshotInfo();\n\t\t\t\t\twalrusSnapInfo.setSnapshotBucket(bucketName);\n\t\t\t\t\tList<WalrusSnapshotInfo> walrusSnaps = dbSnap\n\t\t\t\t\t\t\t.query(walrusSnapInfo);\n\t\t\t\t\tif (walrusSnaps.size() > 0) {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treply.setName(bucketName);\n\t\t\t\treply.setIsTruncated(false);\n\t\t\t\tif (maxKeys >= 0)\n\t\t\t\t\treply.setMaxKeys(maxKeys);\n\t\t\t\treply.setPrefix(prefix);\n\t\t\t\treply.setKeyMarker(keyMarker);\n\t\t\t\treply.setVersionIdMarker(versionIdMarker);\n\t\t\t\tif (delimiter != null)\n\t\t\t\t\treply.setDelimiter(delimiter);\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db\n\t\t\t\t\t\t.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo();\n\t\t\t\tsearchObjectInfo.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\tint howManyProcessed = 0;\n\t\t\t\t\tif (keyMarker != null || objectInfos.size() < maxKeys)\n\t\t\t\t\t\tCollections.sort(objectInfos);\n\t\t\t\t\tArrayList<VersionEntry> versions = new ArrayList<VersionEntry>();\n\t\t\t\t\tArrayList<DeleteMarkerEntry> deleteMarkers = new ArrayList<DeleteMarkerEntry>();\n\t\t\t\t\t\n\t\t\t\t\tfor (ObjectInfo objectInfo : objectInfos) {\n\t\t\t\t\t\tString objectKey = objectInfo.getObjectKey();\n\n\t\t\t\t\t\tif(keyMarker != null) { if(objectKey.compareTo(keyMarker)\n\t\t\t\t\t\t\t\t<= 0) continue; } else if (versionIdMarker != null) {\n\t\t\t\t\t\t\t\t\tif(!objectInfo.getVersionId().equals(versionIdMarker))\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (prefix != null) {\n\t\t\t\t\t\t\tif (!objectKey.startsWith(prefix)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (delimiter != null) {\n\t\t\t\t\t\t\t\t\tString[] parts = objectKey.substring(\n\t\t\t\t\t\t\t\t\t\t\tprefix.length()).split(delimiter);\n\t\t\t\t\t\t\t\t\tif (parts.length > 1) {\n\t\t\t\t\t\t\t\t\t\tString prefixString = parts[0]\n\t\t\t\t\t\t\t\t\t\t\t\t+ delimiter;\n\t\t\t\t\t\t\t\t\t\tboolean foundPrefix = false;\n\t\t\t\t\t\t\t\t\t\tfor (PrefixEntry prefixEntry : prefixes) {\n\t\t\t\t\t\t\t\t\t\t\tif (prefixEntry.getPrefix().equals(\n\t\t\t\t\t\t\t\t\t\t\t\t\tprefixString)) {\n\t\t\t\t\t\t\t\t\t\t\t\tfoundPrefix = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!foundPrefix) {\n\t\t\t\t\t\t\t\t\t\t\tprefixes.add(new PrefixEntry(\n\t\t\t\t\t\t\t\t\t\t\t\t\tprefixString));\n\t\t\t\t\t\t\t\t\t\t\tif (maxKeys >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (howManyProcessed++ >= maxKeys) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (maxKeys >= 0) {\n\t\t\t\t\t\t\tif (howManyProcessed++ >= maxKeys) {\n\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!objectInfo.getDeleted()) {\n\t\t\t\t\t\t\tVersionEntry versionEntry = new VersionEntry();\n\t\t\t\t\t\t\tversionEntry.setKey(objectKey);\n\t\t\t\t\t\t\tversionEntry\n\t\t\t\t\t\t\t.setVersionId(objectInfo.getVersionId());\n\t\t\t\t\t\t\tversionEntry.setEtag(objectInfo.getEtag());\n\t\t\t\t\t\t\tversionEntry.setLastModified(DateUtils.format(\n\t\t\t\t\t\t\t\t\tobjectInfo.getLastModified().getTime(),\n\t\t\t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t\t\t\t\t\t+ \".000Z\");\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tString displayName = Accounts.lookupAccountById(objectInfo.getOwnerId()).getName();\n\t\t\t\t\t\t\t\tversionEntry.setOwner(new CanonicalUserType(objectInfo.getOwnerId(), displayName));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\",\n\t\t\t\t\t\t\t\t\t\tbucketName, logData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tversionEntry.setSize(objectInfo.getSize());\n\t\t\t\t\t\t\tversionEntry.setStorageClass(objectInfo\n\t\t\t\t\t\t\t\t\t.getStorageClass());\n\t\t\t\t\t\t\tversionEntry.setIsLatest(objectInfo.getLast());\n\t\t\t\t\t\t\tversions.add(versionEntry);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDeleteMarkerEntry deleteMarkerEntry = new DeleteMarkerEntry();\n\t\t\t\t\t\t\tdeleteMarkerEntry.setKey(objectKey);\n\t\t\t\t\t\t\tdeleteMarkerEntry.setVersionId(objectInfo.getVersionId());\n\t\t\t\t\t\t\tdeleteMarkerEntry.setLastModified(DateUtils.format(\n\t\t\t\t\t\t\t\t\tobjectInfo.getLastModified().getTime(),\n\t\t\t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t\t\t\t\t\t+ \".000Z\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tString ownerId = objectInfo.getOwnerId();\n\t\t\t\t\t\t\t\tString displayName = Accounts.lookupAccountById(ownerId).getName();\n\t\t\t\t\t\t\t\tdeleteMarkerEntry.setOwner(new CanonicalUserType(ownerId, displayName));\n\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\",\n\t\t\t\t\t\t\t\t\t\tbucketName, logData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdeleteMarkerEntry.setIsLatest(objectInfo.getLast());\n\t\t\t\t\t\t\tdeleteMarkers.add(deleteMarkerEntry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treply.setVersions(versions);\n\t\t\t\t\treply.setDeleteMarkers(deleteMarkers);\n\t\t\t\t\tif (prefix != null) {\n\t\t\t\t\t\treply.setCommonPrefixes(prefixes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":28941,"modified_method":"public ListVersionsResponseType listVersions(ListVersionsType request)\n\t\t\tthrows EucalyptusCloudException {\n\t\tListVersionsResponseType reply = (ListVersionsResponseType) request\n\t\t\t\t.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString prefix = request.getPrefix();\n\t\tif (prefix == null)\n\t\t\tprefix = \"\";\n\n\t\tString keyMarker = request.getKeyMarker();\n\t\tString versionIdMarker = request.getVersionIdMarker();\n\n\t\tint maxKeys = -1;\n\t\tString maxKeysString = request.getMaxKeys();\n\t\tif (maxKeysString != null)\n\t\t\tmaxKeys = Integer.parseInt(maxKeysString);\n\t\telse\n\t\t\tmaxKeys = WalrusProperties.MAX_KEYS;\n\n\t\tString delimiter = request.getDelimiter();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tbucketInfo.setHidden(false);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tArrayList<PrefixEntry> prefixes = new ArrayList<PrefixEntry>();\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\tbucket.canRead(account.getAccountNumber()) &&\n\t\t\t\t\t(bucket.isGlobalRead() || Lookups.checkPrivilege(PolicySpec.S3_LISTBUCKETVERSIONS,\n\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_BUCKET,\n\t\t\t\t\t\t\tbucketName,\n\t\t\t\t\t\t\tnull)))) {\n\t\t\t\tif (bucket.isVersioningDisabled()) {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new EucalyptusCloudException(\n\t\t\t\t\t\t\t\"Versioning has not been enabled for bucket: \"\n\t\t\t\t\t\t\t\t\t+ bucketName);\n\t\t\t\t}\n\t\t\t\tif (logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\n\t\t\t\tif (Contexts.lookup().hasAdministrativePrivileges()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif(bucketHasSnapshots(bucketName)) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\tLOG.debug(e,e);\n\t\t\t\t\t\tthrow new EucalyptusCloudException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treply.setName(bucketName);\n\t\t\t\treply.setIsTruncated(false);\n\t\t\t\tif (maxKeys >= 0)\n\t\t\t\t\treply.setMaxKeys(maxKeys);\n\t\t\t\treply.setPrefix(prefix);\n\t\t\t\treply.setKeyMarker(keyMarker);\n\t\t\t\treply.setVersionIdMarker(versionIdMarker);\n\t\t\t\tif (delimiter != null)\n\t\t\t\t\treply.setDelimiter(delimiter);\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db\n\t\t\t\t\t\t.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo();\n\t\t\t\tsearchObjectInfo.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\tint howManyProcessed = 0;\n\t\t\t\t\tif (keyMarker != null || objectInfos.size() < maxKeys)\n\t\t\t\t\t\tCollections.sort(objectInfos);\n\t\t\t\t\tArrayList<VersionEntry> versions = new ArrayList<VersionEntry>();\n\t\t\t\t\tArrayList<DeleteMarkerEntry> deleteMarkers = new ArrayList<DeleteMarkerEntry>();\n\t\t\t\t\t\n\t\t\t\t\tfor (ObjectInfo objectInfo : objectInfos) {\n\t\t\t\t\t\tString objectKey = objectInfo.getObjectKey();\n\n\t\t\t\t\t\tif(keyMarker != null) { if(objectKey.compareTo(keyMarker)\n\t\t\t\t\t\t\t\t<= 0) continue; } else if (versionIdMarker != null) {\n\t\t\t\t\t\t\t\t\tif(!objectInfo.getVersionId().equals(versionIdMarker))\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (prefix != null) {\n\t\t\t\t\t\t\tif (!objectKey.startsWith(prefix)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (delimiter != null) {\n\t\t\t\t\t\t\t\t\tString[] parts = objectKey.substring(\n\t\t\t\t\t\t\t\t\t\t\tprefix.length()).split(delimiter);\n\t\t\t\t\t\t\t\t\tif (parts.length > 1) {\n\t\t\t\t\t\t\t\t\t\tString prefixString = parts[0]\n\t\t\t\t\t\t\t\t\t\t\t\t+ delimiter;\n\t\t\t\t\t\t\t\t\t\tboolean foundPrefix = false;\n\t\t\t\t\t\t\t\t\t\tfor (PrefixEntry prefixEntry : prefixes) {\n\t\t\t\t\t\t\t\t\t\t\tif (prefixEntry.getPrefix().equals(\n\t\t\t\t\t\t\t\t\t\t\t\t\tprefixString)) {\n\t\t\t\t\t\t\t\t\t\t\t\tfoundPrefix = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!foundPrefix) {\n\t\t\t\t\t\t\t\t\t\t\tprefixes.add(new PrefixEntry(\n\t\t\t\t\t\t\t\t\t\t\t\t\tprefixString));\n\t\t\t\t\t\t\t\t\t\t\tif (maxKeys >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (howManyProcessed++ >= maxKeys) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (maxKeys >= 0) {\n\t\t\t\t\t\t\tif (howManyProcessed++ >= maxKeys) {\n\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!objectInfo.getDeleted()) {\n\t\t\t\t\t\t\tVersionEntry versionEntry = new VersionEntry();\n\t\t\t\t\t\t\tversionEntry.setKey(objectKey);\n\t\t\t\t\t\t\tversionEntry\n\t\t\t\t\t\t\t.setVersionId(objectInfo.getVersionId());\n\t\t\t\t\t\t\tversionEntry.setEtag(objectInfo.getEtag());\n\t\t\t\t\t\t\tversionEntry.setLastModified(DateUtils.format(\n\t\t\t\t\t\t\t\t\tobjectInfo.getLastModified().getTime(),\n\t\t\t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t\t\t\t\t\t+ \".000Z\");\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tString displayName = Accounts.lookupAccountById(objectInfo.getOwnerId()).getName();\n\t\t\t\t\t\t\t\tversionEntry.setOwner(new CanonicalUserType(objectInfo.getOwnerId(), displayName));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\",\n\t\t\t\t\t\t\t\t\t\tbucketName, logData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tversionEntry.setSize(objectInfo.getSize());\n\t\t\t\t\t\t\tversionEntry.setStorageClass(objectInfo\n\t\t\t\t\t\t\t\t\t.getStorageClass());\n\t\t\t\t\t\t\tversionEntry.setIsLatest(objectInfo.getLast());\n\t\t\t\t\t\t\tversions.add(versionEntry);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDeleteMarkerEntry deleteMarkerEntry = new DeleteMarkerEntry();\n\t\t\t\t\t\t\tdeleteMarkerEntry.setKey(objectKey);\n\t\t\t\t\t\t\tdeleteMarkerEntry.setVersionId(objectInfo.getVersionId());\n\t\t\t\t\t\t\tdeleteMarkerEntry.setLastModified(DateUtils.format(\n\t\t\t\t\t\t\t\t\tobjectInfo.getLastModified().getTime(),\n\t\t\t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t\t\t\t\t\t+ \".000Z\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tString ownerId = objectInfo.getOwnerId();\n\t\t\t\t\t\t\t\tString displayName = Accounts.lookupAccountById(ownerId).getName();\n\t\t\t\t\t\t\t\tdeleteMarkerEntry.setOwner(new CanonicalUserType(ownerId, displayName));\n\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\",\n\t\t\t\t\t\t\t\t\t\tbucketName, logData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdeleteMarkerEntry.setIsLatest(objectInfo.getLast());\n\t\t\t\t\t\t\tdeleteMarkers.add(deleteMarkerEntry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treply.setVersions(versions);\n\t\t\t\t\treply.setDeleteMarkers(deleteMarkers);\n\t\t\t\t\tif (prefix != null) {\n\t\t\t\t\t\treply.setCommonPrefixes(prefixes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"49f46d08af4f554a8862c0f79beb50c2ed997c1a","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ListAllMyBucketsResponseType listAllMyBuckets(\n\t\t\tListAllMyBucketsType request) throws EucalyptusCloudException {\n\t\tListAllMyBucketsResponseType reply = (ListAllMyBucketsResponseType) request\n\t\t\t\t.getReply();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\n\t\tif (account == null) {\n\t\t\tthrow new AccessDeniedException(\"no such account\");\n\t\t}\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\ttry {\n\t\t\tBucketInfo searchBucket = new BucketInfo();\n\t\t\tsearchBucket.setOwnerId(account.getAccountNumber());\n\t\t\tsearchBucket.setHidden(false);\n\t\t\tList<BucketInfo> bucketInfoList = db.query(searchBucket);\n\n\t\t\tArrayList<BucketListEntry> buckets = new ArrayList<BucketListEntry>();\n\n\t\t\tfor (BucketInfo bucketInfo : bucketInfoList) {\n\t\t\t\tif (ctx.hasAdministrativePrivileges()) {\t\t\t\t\t\t\n\t\t\t\t\tEntityWrapper<WalrusSnapshotInfo> dbSnap = EntityWrapper.get(WalrusSnapshotInfo.class);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tWalrusSnapshotInfo walrusSnapInfo = new WalrusSnapshotInfo();\n\t\t\t\t\t\twalrusSnapInfo.setSnapshotBucket(bucketInfo.getBucketName());\n\t\t\t\t\t\tList<WalrusSnapshotInfo> walrusSnaps = dbSnap\n\t\t\t\t\t\t\t\t.query(walrusSnapInfo);\n\t\t\t\t\t\tdbSnap.commit();\n\t\t\t\t\t\tif (walrusSnaps.size() > 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} catch (Exception eee) {\n\t\t\t\t\t\tLOG.debug(eee, eee);\n\t\t\t\t\t\tdbSnap.rollback();\n\t\t\t\t\t}\n\t\t\t\t}\n        if (ctx.hasAdministrativePrivileges() ||\n            Lookups.checkPrivilege(PolicySpec.S3_LISTALLMYBUCKETS,\n                PolicySpec.VENDOR_S3,\n                PolicySpec.S3_RESOURCE_BUCKET,\n                bucketInfo.getBucketName(),\n                bucketInfo.getOwnerId())) {           \n          buckets.add(new BucketListEntry(bucketInfo.getBucketName(),\n              DateUtils.format(bucketInfo.getCreationDate().getTime(),\n                  DateUtils.ISO8601_DATETIME_PATTERN)\n                  + \".000Z\"));\n        }\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tCanonicalUserType owner = new CanonicalUserType(account.getAccountNumber(), account.getName());\n\t\t\t\tListAllMyBucketsList bucketList = new ListAllMyBucketsList();\n\t\t\t\treply.setOwner(owner);\n\t\t\t\tbucketList.setBuckets(buckets);\n\t\t\t\treply.setBucketList(bucketList);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tdb.rollback();\n\t\t\t\tLOG.error(ex);\n\t\t\t\tthrow new AccessDeniedException(\"Account: \" + account.getName() + \" not found\", ex);\n\t\t\t}\n\t\t\tdb.commit();\n\t\t} catch (EucalyptusCloudException e) {\n\t\t\tdb.rollback();\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tLOG.debug(e, e);\n\t\t\tdb.rollback();\n\t\t}\n\t\treturn reply;\n\t}","id":28942,"modified_method":"public ListAllMyBucketsResponseType listAllMyBuckets(\n\t\t\tListAllMyBucketsType request) throws EucalyptusCloudException {\n\t\tListAllMyBucketsResponseType reply = (ListAllMyBucketsResponseType) request\n\t\t\t\t.getReply();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\n\t\tif (account == null) {\n\t\t\tthrow new AccessDeniedException(\"no such account\");\n\t\t}\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\ttry {\n\t\t\tBucketInfo searchBucket = new BucketInfo();\n\t\t\tsearchBucket.setOwnerId(account.getAccountNumber());\n\t\t\tsearchBucket.setHidden(false);\n\t\t\t\n\t\t\tList<BucketInfo> bucketInfoList = db.query(searchBucket);\n\n\t\t\tArrayList<BucketListEntry> buckets = new ArrayList<BucketListEntry>();\n\n\t\t\tfor (BucketInfo bucketInfo : bucketInfoList) {\n\t\t\t\tif (ctx.hasAdministrativePrivileges()) {\t\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//TODO: zhill -- we should modify the bucket schema to indicate if the bucket is a snapshot bucket, or use a seperate type for snap containers\n\t\t\t\t\t\tif(bucketHasSnapshots(bucketInfo.getBucketName())) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\tLOG.debug(e, e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\t\n\t\t\t\t}\t\n        \t\tif (ctx.hasAdministrativePrivileges() || \n        \t\t\tLookups.checkPrivilege(PolicySpec.S3_LISTALLMYBUCKETS, \n                \tPolicySpec.VENDOR_S3,\n                \tPolicySpec.S3_RESOURCE_BUCKET,\n                \tbucketInfo.getBucketName(),\n                \tbucketInfo.getOwnerId())) {\n        \t\t\n        \t\t\tbuckets.add(new BucketListEntry(bucketInfo.getBucketName(),\n        \t\t\t\t\tDateUtils.format(bucketInfo.getCreationDate().getTime(), \n        \t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN) \n        \t\t\t\t\t\t\t+ \".000Z\"));\n        \t\t}\n\t\t\t}\n\t\t\tdb.commit();\n\t\t\t\n\t\t\ttry {\n\t\t\t\tCanonicalUserType owner = new CanonicalUserType(account.getAccountNumber(), account.getName());\n\t\t\t\tListAllMyBucketsList bucketList = new ListAllMyBucketsList();\n\t\t\t\treply.setOwner(owner);\n\t\t\t\tbucketList.setBuckets(buckets);\n\t\t\t\treply.setBucketList(bucketList);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tLOG.error(ex);\n\t\t\t\tthrow new AccessDeniedException(\"Account: \" + account.getName() + \" not found\", ex);\n\t\t\t}\t\t\t\n\t\t} catch (EucalyptusCloudException e) {\n\t\t\tdb.rollback();\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tLOG.debug(e, e);\n\t\t\tdb.rollback();\n\t\t}\n\t\treturn reply;\n\t}","commit_id":"49f46d08af4f554a8862c0f79beb50c2ed997c1a","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public GetObjectAccessControlPolicyResponseType getObjectAccessControlPolicy(\n\t\t\tGetObjectAccessControlPolicyType request)\n\t\t\t\t\tthrows EucalyptusCloudException {\n\t\tGetObjectAccessControlPolicyResponseType reply = (GetObjectAccessControlPolicyResponseType) request\n\t\t\t\t.getReply();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString ownerId = null;\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\t\tBucketLogData logData;\n\n\t\tAccessControlListType accessControlList = new AccessControlListType();\n\t\tif (bucketList.size() > 0) {\n\t\t\t// construct access control policy from grant infos\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tlogData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tsearchObjectInfo.setVersionId(request.getVersionId());\n\t\t\t\t\tif(request.getVersionId() == null) {\n\t\t\t\t\t\tsearchObjectInfo.setLast(true);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tsearchObjectInfo.setDeleted(false);\n\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges( ) || (\n\t\t\t\t\t\t\t\tobjectInfo.canReadACP(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t\t(objectInfo.isGlobalReadACP() || Lookups.checkPrivilege(PolicySpec.S3_GETOBJECTACL,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(bucketName, objectKey),\n\t\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\townerId = objectInfo.getOwnerId();\n\t\t\t\t\t\t\tArrayList<Grant> grants = new ArrayList<Grant>();\n\t\t\t\t\t\t\tList<GrantInfo> grantInfos = objectInfo.getGrants();\n\t\t\t\t\t\t\tfor (GrantInfo grantInfo : grantInfos) {\n\t\t\t\t\t\t\t\tString uId = grantInfo.getUserId();\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tobjectInfo.readPermissions(grants);\n\t\t\t\t\t\t\t\t\taddPermission(grants, Accounts.lookupAccountById(uId), grantInfo);\n\t\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey,\n\t\t\t\t\t\t\t\t\t\t\tlogData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taccessControlList.setGrants(grants);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tAccessControlPolicyType accessControlPolicy = new AccessControlPolicyType();\n\t\ttry {\n\t\t\tAccount ownerInfo = Accounts.lookupAccountById(ownerId);\n\t\t\taccessControlPolicy.setOwner(new CanonicalUserType(ownerInfo.getAccountNumber(), ownerInfo.getName()));\t\t\t\n\t\t\taccessControlPolicy.setAccessControlList(accessControlList);\n\t\t} catch (AuthException e) {\n\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t}\n\t\treply.setAccessControlPolicy(accessControlPolicy);\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":28943,"modified_method":"public GetObjectAccessControlPolicyResponseType getObjectAccessControlPolicy(\n\t\t\tGetObjectAccessControlPolicyType request)\n\t\t\t\t\tthrows EucalyptusCloudException {\n\t\tGetObjectAccessControlPolicyResponseType reply = (GetObjectAccessControlPolicyResponseType) request\n\t\t\t\t.getReply();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString ownerId = null;\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\t\tBucketLogData logData;\n\n\t\tAccessControlListType accessControlList = new AccessControlListType();\n\t\tif (bucketList.size() > 0) {\n\t\t\t// construct access control policy from grant infos\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tlogData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tsearchObjectInfo.setVersionId(request.getVersionId());\n\t\t\t\t\tif(request.getVersionId() == null) {\n\t\t\t\t\t\tsearchObjectInfo.setLast(true);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tsearchObjectInfo.setDeleted(false);\n\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges( ) || (\n\t\t\t\t\t\t\t\tobjectInfo.canReadACP(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t\t(objectInfo.isGlobalReadACP() || Lookups.checkPrivilege(PolicySpec.S3_GETOBJECTACL,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(bucketName, objectKey),\n\t\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\townerId = objectInfo.getOwnerId();\n\t\t\t\t\t\t\tArrayList<Grant> grants = new ArrayList<Grant>();\n\t\t\t\t\t\t\tList<GrantInfo> grantInfos = objectInfo.getGrants();\n\t\t\t\t\t\t\tobjectInfo.readPermissions(grants);\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddGrants(grants, grantInfos);\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taccessControlList.setGrants(grants);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tAccessControlPolicyType accessControlPolicy = new AccessControlPolicyType();\n\t\ttry {\n\t\t\tAccount ownerInfo = Accounts.lookupAccountById(ownerId);\n\t\t\taccessControlPolicy.setOwner(new CanonicalUserType(ownerInfo.getAccountNumber(), ownerInfo.getName()));\t\t\t\n\t\t\taccessControlPolicy.setAccessControlList(accessControlList);\n\t\t} catch (AuthException e) {\n\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t}\n\t\treply.setAccessControlPolicy(accessControlPolicy);\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"49f46d08af4f554a8862c0f79beb50c2ed997c1a","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ListBucketResponseType listBucket(ListBucketType request)\n\t\t\tthrows EucalyptusCloudException {\n\t\tListBucketResponseType reply = (ListBucketResponseType) request\n\t\t\t\t.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString prefix = request.getPrefix();\n\t\tif (prefix == null) {\n\t\t\tprefix = \"\";\n\t\t}\n\n\t\tString marker = request.getMarker();\n\t\tint maxKeys = -1;\n\t\tString maxKeysString = request.getMaxKeys();\n\t\tif (maxKeysString != null) {\n\t\t\tmaxKeys = Integer.parseInt(maxKeysString);\t\t\t\n\t\t} else {\n\t\t\tmaxKeys = WalrusProperties.MAX_KEYS;\n\t\t}\n\n\t\tString delimiter = request.getDelimiter();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tbucketInfo.setHidden(false);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tHashtable<String,PrefixEntry> prefixes = new Hashtable<String,PrefixEntry>();\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\t\t\tbucket.canRead(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t(bucket.isGlobalRead() || Lookups.checkPrivilege(PolicySpec.S3_LISTBUCKET,\n\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_BUCKET,\n\t\t\t\t\t\t\t\t\tbucketName,\n\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (Contexts.lookup().hasAdministrativePrivileges()) {\n\t\t\t\t\t\t\tEntityWrapper<WalrusSnapshotInfo> dbSnap = db\n\t\t\t\t\t\t\t\t\t.recast(WalrusSnapshotInfo.class);\n\t\t\t\t\t\t\tWalrusSnapshotInfo walrusSnapInfo = new WalrusSnapshotInfo();\n\t\t\t\t\t\t\twalrusSnapInfo.setSnapshotBucket(bucketName);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tCriteria snapCount = dbSnap.createCriteria(WalrusSnapshotInfo.class).add(Example.create(walrusSnapInfo)).setProjection(Projections.rowCount());\n\t\t\t\t\t\t\tLong rowCount = (Long)snapCount.uniqueResult();\n\t\t\t\t\t\t\tif (rowCount != null && rowCount.longValue() > 0) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treply.setName(bucketName);\n\t\t\t\t\t\treply.setIsTruncated(false);\n\t\t\t\t\t\treply.setPrefix(prefix);\t\t\t\t\t\t\n\t\t\t\t\t\tif (maxKeys >= 0) {\n\t\t\t\t\t\t\treply.setMaxKeys(maxKeys);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (delimiter != null){\n\t\t\t\t\t\t\treply.setDelimiter(delimiter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(maxKeys == 0) {\n\t\t\t\t\t\t\t//No keys requested, so just return\n\t\t\t\t\t\t\treply.setContents(new ArrayList<ListEntry>());\n\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\treturn reply;\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int queryStrideSize = maxKeys + 1;\t\t\t\t\t\t\n\t\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db\n\t\t\t\t\t\t\t\t.recast(ObjectInfo.class);\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tObjectInfo searchObj = new ObjectInfo();\n\t\t\t\t\t\tsearchObj.setBucketName(bucketName);\n\t\t\t\t\t\tsearchObj.setLast(true);\n\t\t\t\t\t\tsearchObj.setDeleted(false);\n\t\t\t\t\t\t\n\t\t\t\t\t\tCriteria objCriteria = dbObject.createCriteria(ObjectInfo.class);\n\t\t\t\t\t\t//objCriteria.setReadOnly(true); //don't use yet, make sure semantics don't change (i.e. caching)\n\t\t\t\t\t\tobjCriteria.add(Example.create(searchObj));\t\t\t\t\t\t\n\t\t\t\t\t\tobjCriteria.addOrder(Order.asc(\"objectKey\"));\t\t\t\t\t\t\n\t\t\t\t\t\tobjCriteria.setMaxResults(queryStrideSize); //add one to, hopefully, indicate truncation in one call\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(marker != null) {\n\t\t\t\t\t\t\tobjCriteria.add(Restrictions.ge(\"objectKey\", marker));\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(prefix != null && !prefix.equals(\"\")) {\n\t\t\t\t\t\t\tobjCriteria.add(Restrictions.like(\"objectKey\", prefix, MatchMode.START));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tList<ObjectInfo> objectInfos = null;//(List<ObjectInfo>)objCriteria.list();\n\t\t\t\t\t\tint resultKeyCount = 0;\n\t\t\t\t\t\tString objectKey = null;\n\t\t\t\t\t\tString[] parts = null;\n\t\t\t\t\t\tString prefixString = null;\n\t\t\t\t\t\tArrayList<ListEntry> contents = new ArrayList<ListEntry>(); //contents for reply\n\t\t\t\t\t\tArrayList<MetaDataEntry> metaData = new ArrayList<MetaDataEntry>(); //metadata for reply\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t//Iterate over result sets of size maxkeys + 1\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tobjectKey = null;\n\t\t\t\t\t\t\tparts = null;\n\t\t\t\t\t\t\tprefixString = null;\n\t\t\t\t\t\t\tif(resultKeyCount > 0) { //Start from end of last round-trip if necessary\n\t\t\t\t\t\t\t\tobjCriteria.setFirstResult(queryStrideSize);\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tobjectInfos = (List<ObjectInfo>)objCriteria.list();\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\t\t\tfor (ObjectInfo objectInfo : objectInfos) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tobjectKey = objectInfo.getObjectKey();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t//Check if it will get aggregated as a commonprefix\n\t\t\t\t\t\t\t\t\tif (delimiter != null) {\n\t\t\t\t\t\t\t\t\t\tparts = objectKey.substring(prefix.length()).split(delimiter);\n\t\t\t\t\t\t\t\t\t\tif (parts.length > 1) {\n\t\t\t\t\t\t\t\t\t\t\tprefixString = parts[0] + delimiter;\n\t\t\t\t\t\t\t\t\t\t\tif(!prefixes.containsKey(prefixString)) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(resultKeyCount == maxKeys) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t//This is a new record, so we know we're truncating if this is true\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setNextMarker(objectKey);\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\tresultKeyCount++;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tprefixes.put(prefixString, new PrefixEntry(prefixString));\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tresultKeyCount++; //count the unique commonprefix as a single return entry\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(resultKeyCount == maxKeys) {\n\t\t\t\t\t\t\t\t\t\t//This is a new (non-commonprefix) record, so we know we're truncating\n\t\t\t\t\t\t\t\t\t\treply.setNextMarker(objectKey);\n\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\tresultKeyCount++;\n\t\t\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t//Process the entry as a full key listing\n\t\t\t\t\t\t\t\t\tListEntry listEntry = new ListEntry();\n\t\t\t\t\t\t\t\t\tlistEntry.setKey(objectKey);\n\t\t\t\t\t\t\t\t\tlistEntry.setEtag(objectInfo.getEtag());\n\t\t\t\t\t\t\t\t\tlistEntry.setLastModified(DateUtils.format(objectInfo\n\t\t\t\t\t\t\t\t\t\t\t.getLastModified().getTime(),\n\t\t\t\t\t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t\t\t\t\t\t\t\t+ \".000Z\");\n\t\t\t\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\n\t\t\t\t\t\t\t\t\ttry {\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tlistEntry.setOwner(new CanonicalUserType(objectInfo.getOwnerId(), Accounts.lookupAccountById(objectInfo.getOwnerId()).getName()));\n\t\t\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tobjectInfo.returnMetaData(metaData);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tlistEntry.setSize(objectInfo.getSize());\n\t\t\t\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\t\t\t\t\t\t\t\t\tcontents.add(listEntry);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tresultKeyCount++;\n\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\n\n\t\t\t\t\t\t\tif(resultKeyCount <= maxKeys && objectInfos.size() <= maxKeys) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while(resultKeyCount <= maxKeys);\n\t\t\t\t\t\t\n\t\t\t\t\t\treply.setMetaData(metaData);\n\t\t\t\t\t\treply.setContents(contents);\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t//Sort the prefixes from the hashtable and add to the reply\n\t\t\t\t\t\tif (prefixes != null && prefixes.size() > 0) {\n\t\t\t\t\t\t\tArrayList<PrefixEntry> prefixList = new ArrayList<PrefixEntry>();\n\t\t\t\t\t\t\tprefixList.addAll(prefixes.values());\n\n\t\t\t\t\t\t\tCollections.sort(prefixList, new Comparator<PrefixEntry>() {\n\t\t\t\t\t\t\t\tpublic int compare(PrefixEntry e1, PrefixEntry e2) {\n\t\t\t\t\t\t\t\t\treturn e1.getPrefix().compareTo(e2.getPrefix());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\treply.setCommonPrefixes(prefixList);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":28944,"modified_method":"public ListBucketResponseType listBucket(ListBucketType request)\n\t\t\tthrows EucalyptusCloudException {\n\t\tListBucketResponseType reply = (ListBucketResponseType) request\n\t\t\t\t.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString prefix = request.getPrefix();\n\t\tif (prefix == null) {\n\t\t\tprefix = \"\";\n\t\t}\n\n\t\tString marker = request.getMarker();\n\t\tint maxKeys = -1;\n\t\tString maxKeysString = request.getMaxKeys();\n\t\tif (maxKeysString != null) {\n\t\t\tmaxKeys = Integer.parseInt(maxKeysString);\t\t\t\n\t\t} else {\n\t\t\tmaxKeys = WalrusProperties.MAX_KEYS;\n\t\t}\n\n\t\tString delimiter = request.getDelimiter();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tbucketInfo.setHidden(false);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tHashtable<String,PrefixEntry> prefixes = new Hashtable<String,PrefixEntry>();\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\t\t\tbucket.canRead(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t(bucket.isGlobalRead() || Lookups.checkPrivilege(PolicySpec.S3_LISTBUCKET,\n\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_BUCKET,\n\t\t\t\t\t\t\t\t\tbucketName,\n\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (Contexts.lookup().hasAdministrativePrivileges()) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif(bucketHasSnapshots(bucketName)) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treply.setName(bucketName);\n\t\t\t\t\t\treply.setIsTruncated(false);\n\t\t\t\t\t\treply.setPrefix(prefix);\t\t\t\t\t\t\n\t\t\t\t\t\tif (maxKeys >= 0) {\n\t\t\t\t\t\t\treply.setMaxKeys(maxKeys);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (delimiter != null){\n\t\t\t\t\t\t\treply.setDelimiter(delimiter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(maxKeys == 0) {\n\t\t\t\t\t\t\t//No keys requested, so just return\n\t\t\t\t\t\t\treply.setContents(new ArrayList<ListEntry>());\n\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\treturn reply;\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int queryStrideSize = maxKeys + 1;\t\t\t\t\t\t\n\t\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tObjectInfo searchObj = new ObjectInfo();\n\t\t\t\t\t\tsearchObj.setBucketName(bucketName);\n\t\t\t\t\t\tsearchObj.setLast(true);\n\t\t\t\t\t\tsearchObj.setDeleted(false);\n\t\t\t\t\t\t\n\t\t\t\t\t\tCriteria objCriteria = dbObject.createCriteria(ObjectInfo.class);\n\t\t\t\t\t\t//objCriteria.setReadOnly(true); //don't use yet, make sure semantics don't change (i.e. caching)\n\t\t\t\t\t\tobjCriteria.add(Example.create(searchObj));\t\t\t\t\t\t\n\t\t\t\t\t\tobjCriteria.addOrder(Order.asc(\"objectKey\"));\t\t\t\t\t\t\n\t\t\t\t\t\tobjCriteria.setMaxResults(queryStrideSize); //add one to, hopefully, indicate truncation in one call\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(marker != null) {\n\t\t\t\t\t\t\tobjCriteria.add(Restrictions.ge(\"objectKey\", marker));\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(prefix != null && !prefix.equals(\"\")) {\n\t\t\t\t\t\t\tobjCriteria.add(Restrictions.like(\"objectKey\", prefix, MatchMode.START));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tList<ObjectInfo> objectInfos = null;//(List<ObjectInfo>)objCriteria.list();\n\t\t\t\t\t\tint resultKeyCount = 0;\n\t\t\t\t\t\tString objectKey = null;\n\t\t\t\t\t\tString[] parts = null;\n\t\t\t\t\t\tString prefixString = null;\n\t\t\t\t\t\tArrayList<ListEntry> contents = new ArrayList<ListEntry>(); //contents for reply\n\t\t\t\t\t\tArrayList<MetaDataEntry> metaData = new ArrayList<MetaDataEntry>(); //metadata for reply\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t//Iterate over result sets of size maxkeys + 1\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tobjectKey = null;\n\t\t\t\t\t\t\tparts = null;\n\t\t\t\t\t\t\tprefixString = null;\n\t\t\t\t\t\t\tif(resultKeyCount > 0) { //Start from end of last round-trip if necessary\n\t\t\t\t\t\t\t\tobjCriteria.setFirstResult(queryStrideSize);\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tobjectInfos = (List<ObjectInfo>)objCriteria.list();\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\t\t\tfor (ObjectInfo objectInfo : objectInfos) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tobjectKey = objectInfo.getObjectKey();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t//Check if it will get aggregated as a commonprefix\n\t\t\t\t\t\t\t\t\tif (delimiter != null) {\n\t\t\t\t\t\t\t\t\t\tparts = objectKey.substring(prefix.length()).split(delimiter);\n\t\t\t\t\t\t\t\t\t\tif (parts.length > 1) {\n\t\t\t\t\t\t\t\t\t\t\tprefixString = parts[0] + delimiter;\n\t\t\t\t\t\t\t\t\t\t\tif(!prefixes.containsKey(prefixString)) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(resultKeyCount == maxKeys) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t//This is a new record, so we know we're truncating if this is true\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setNextMarker(objectKey);\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\tresultKeyCount++;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tprefixes.put(prefixString, new PrefixEntry(prefixString));\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tresultKeyCount++; //count the unique commonprefix as a single return entry\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(resultKeyCount == maxKeys) {\n\t\t\t\t\t\t\t\t\t\t//This is a new (non-commonprefix) record, so we know we're truncating\n\t\t\t\t\t\t\t\t\t\treply.setNextMarker(objectKey);\n\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\tresultKeyCount++;\n\t\t\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t//Process the entry as a full key listing\n\t\t\t\t\t\t\t\t\tListEntry listEntry = new ListEntry();\n\t\t\t\t\t\t\t\t\tlistEntry.setKey(objectKey);\n\t\t\t\t\t\t\t\t\tlistEntry.setEtag(objectInfo.getEtag());\n\t\t\t\t\t\t\t\t\tlistEntry.setLastModified(DateUtils.format(objectInfo\n\t\t\t\t\t\t\t\t\t\t\t.getLastModified().getTime(),\n\t\t\t\t\t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t\t\t\t\t\t\t\t+ \".000Z\");\n\t\t\t\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\n\t\t\t\t\t\t\t\t\ttry {\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tlistEntry.setOwner(new CanonicalUserType(objectInfo.getOwnerId(), Accounts.lookupAccountById(objectInfo.getOwnerId()).getName()));\n\t\t\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tobjectInfo.returnMetaData(metaData);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tlistEntry.setSize(objectInfo.getSize());\n\t\t\t\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\t\t\t\t\t\t\t\t\tcontents.add(listEntry);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tresultKeyCount++;\n\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\n\n\t\t\t\t\t\t\tif(resultKeyCount <= maxKeys && objectInfos.size() <= maxKeys) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while(resultKeyCount <= maxKeys);\n\t\t\t\t\t\t\n\t\t\t\t\t\treply.setMetaData(metaData);\n\t\t\t\t\t\treply.setContents(contents);\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t//Sort the prefixes from the hashtable and add to the reply\n\t\t\t\t\t\tif (prefixes != null && prefixes.size() > 0) {\n\t\t\t\t\t\t\tArrayList<PrefixEntry> prefixList = new ArrayList<PrefixEntry>();\n\t\t\t\t\t\t\tprefixList.addAll(prefixes.values());\n\n\t\t\t\t\t\t\tCollections.sort(prefixList, new Comparator<PrefixEntry>() {\n\t\t\t\t\t\t\t\tpublic int compare(PrefixEntry e1, PrefixEntry e2) {\n\t\t\t\t\t\t\t\t\treturn e1.getPrefix().compareTo(e2.getPrefix());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\treply.setCommonPrefixes(prefixList);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"49f46d08af4f554a8862c0f79beb50c2ed997c1a","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"static String displayName( Field field ) {\n    HttpParameterMapping httpParameterMapping = Ats.from( field ).get( HttpParameterMapping.class );\n    return httpParameterMapping != null ?\n        httpParameterMapping.parameter() :\n        CaseFormat.LOWER_CAMEL.to( CaseFormat.UPPER_CAMEL, field.getName() );\n  }","id":28945,"modified_method":"static String displayName( Field field ) {\n    HttpParameterMapping httpParameterMapping = Ats.from( field ).get( HttpParameterMapping.class );\n    return httpParameterMapping != null ?\n        httpParameterMapping.parameter()[0] :\n        CaseFormat.LOWER_CAMEL.to( CaseFormat.UPPER_CAMEL, field.getName() );\n  }","commit_id":"90ec9af17a4557371df3931b21e92d18113c37a1","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private Map<String, String> buildFieldMap( Class<?> targetType ) {\n    final Map<String, String> fieldMap = new HashMap<String, String>( );\n    while ( !BaseMessage.class.equals( targetType ) && !EucalyptusMessage.class.equals( targetType ) && !EucalyptusData.class.equals( targetType )\n            && !BaseData.class.equals( targetType ) ) {\n      final Field[] fields = targetType.getDeclaredFields( );\n      for ( final Field f : fields ) {\n        if ( Modifier.isStatic( f.getModifiers( ) ) )\n          continue;\n        else if ( f.isAnnotationPresent( HttpParameterMapping.class ) || f.isAnnotationPresent( HttpParameterMappings.class ) ) {\n          fieldMap.put( getHttpParameterMappingAnnotation( f ).parameter(), f.getName( ) );\n        } else {\n          fieldMap.put( f.getName( ).substring( 0, 1 ).toUpperCase( ).concat( f.getName( ).substring( 1 ) ), f.getName( ) );\n        }\n      }\n      targetType = targetType.getSuperclass( );\n    }\n    return fieldMap;\n  }","id":28946,"modified_method":"private Map<String, String> buildFieldMap( Class<?> targetType ) {\n    final Map<String, String> fieldMap = new HashMap<String, String>( );\n    while ( !BaseMessage.class.equals( targetType ) && !EucalyptusMessage.class.equals( targetType ) && !EucalyptusData.class.equals( targetType )\n            && !BaseData.class.equals( targetType ) ) {\n      final Field[] fields = targetType.getDeclaredFields( );\n      for ( final Field f : fields ) {\n        if ( Modifier.isStatic( f.getModifiers( ) ) )\n          continue;\n        else if ( f.isAnnotationPresent( HttpParameterMapping.class ) || f.isAnnotationPresent( HttpParameterMappings.class ) ) {\n          for ( String parameter : getHttpParameterMappingAnnotation( f ).parameter() ) {\n            fieldMap.put( parameter, f.getName( ) );\n          }\n        } else {\n          fieldMap.put( f.getName( ).substring( 0, 1 ).toUpperCase( ).concat( f.getName( ).substring( 1 ) ), f.getName( ) );\n        }\n      }\n      targetType = targetType.getSuperclass( );\n    }\n    return fieldMap;\n  }","commit_id":"90ec9af17a4557371df3931b21e92d18113c37a1","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void verifyUserIds(final List<String> userIds) throws EucalyptusCloudException {\n\t\tfor (int i = 0; i < userIds.size(); i++) {\n\t\t\tString userId = userIds.get(i);\n\t\t\ttry {\n\t\t\t\tfinal Account account = Accounts.lookupAccountById(userId);\n\t\t\t} catch (final Exception e) {\n\t\t\t\ttry {\n\t\t\t\t\tfinal User user = Accounts.lookupUserById(userId);\n\t\t\t\t} catch (AuthException ex) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfinal User user = Accounts.lookupUserByAccessKeyId(userId);\n\t\t\t\t\t} catch (AuthException ex1) {\n\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Not a valid userId : \" + userId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":28947,"modified_method":"private static List<String> verifyUserIds(final List<String> userIds) throws EucalyptusCloudException {\n    final Set<String> validUserIds = Sets.newHashSet( );\n    for ( String userId : userIds ) {\n      try {\n        validUserIds.add( Accounts.lookupAccountById( userId ).getAccountNumber() );\n      } catch ( final Exception e ) {\n        try {\n          validUserIds.add( Accounts.lookupUserById( userId ).getAccount().getAccountNumber() );\n        } catch ( AuthException ex ) {\n          try {\n            validUserIds.add( Accounts.lookupUserByAccessKeyId( userId ).getAccount().getAccountNumber() );\n          } catch ( AuthException ex1 ) {\n            throw new EucalyptusCloudException( \"Not a valid userId : \" + userId );\n          }\n        }\n      }\n    }\n    return Lists.newArrayList( validUserIds );\n  }","commit_id":"90ec9af17a4557371df3931b21e92d18113c37a1","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DescribeImageAttributeResponseType describeImageAttribute( DescribeImageAttributeType request ) throws EucalyptusCloudException {\n    DescribeImageAttributeResponseType reply = ( DescribeImageAttributeResponseType ) request.getReply( );\n    reply.setImageId( request.getImageId( ) );\n    final Context ctx = Contexts.lookup( );\n    final String requestAccountId = ctx.getUserFullName( ).getAccountNumber( );\n    final User requestUser = Contexts.lookup( ).getUser( );\n    final String action = PolicySpec.requestToAction( request );\n    \n    if ( request.getAttribute( ) != null ) request.applyAttribute( );\n    \n    EntityWrapper<ImageInfo> db = EntityWrapper.get( ImageInfo.class );\n    try {\n      ImageInfo imgInfo = db.getUnique( Images.exampleWithImageId( request.getImageId( ) ) );\n      if ( !ctx.hasAdministrativePrivileges( ) &&\n           ( !imgInfo.getOwnerAccountNumber( ).equals( requestAccountId ) || !RestrictedTypes.filterPrivileged( ).apply( imgInfo ) ) ) {\n        throw new EucalyptusCloudException( \"Not authorized to describe image attribute\" );\n      }\n      if ( request.getKernel( ) != null ) {\n        reply.setRealResponse( reply.getKernel( ) );\n        if ( imgInfo instanceof MachineImageInfo ) {\n          if ( ( ( MachineImageInfo ) imgInfo ).getKernelId( ) != null ) {\n            reply.getKernel( ).add( ( ( MachineImageInfo ) imgInfo ).getKernelId( ) );\n          }\n        }\n      } else if ( request.getRamdisk( ) != null ) {\n        reply.setRealResponse( reply.getRamdisk( ) );\n        if ( imgInfo instanceof MachineImageInfo ) {\n          if ( ( ( MachineImageInfo ) imgInfo ).getRamdiskId( ) != null ) {\n            reply.getRamdisk( ).add( ( ( MachineImageInfo ) imgInfo ).getRamdiskId( ) );\n          }\n        }\n      } else if ( request.getLaunchPermission( ) != null ) {\n        reply.setRealResponse( reply.getLaunchPermission( ) );\n        if ( imgInfo.getImagePublic( ) ) {\n          reply.getLaunchPermission( ).add( LaunchPermissionItemType.getGroup( ) );\n        }\n        Iterator <String> permItr = imgInfo.getPermissions( ).iterator();        \n        while( permItr.hasNext() )\n          reply.getLaunchPermission( ).add( LaunchPermissionItemType.getUser( permItr.next() ) );\n      } else if ( request.getProductCodes( ) != null ) {\n        reply.setRealResponse( reply.getProductCodes( ) );\n        reply.getProductCodes( ).addAll( imgInfo.getProductCodes( ) );\n      } else if ( request.getBlockDeviceMapping( ) != null ) {\n        reply.setRealResponse( reply.getBlockDeviceMapping( ) );\n        reply.getBlockDeviceMapping( ).add( ImageUtil.EMI );\n        reply.getBlockDeviceMapping( ).add( ImageUtil.EPHEMERAL );\n        reply.getBlockDeviceMapping( ).add( ImageUtil.SWAP );\n        reply.getBlockDeviceMapping( ).add( ImageUtil.ROOT );\n      } else {\n        throw new EucalyptusCloudException( \"invalid image attribute request.\" );\n      }\n    } finally {\n      db.commit( );\n    }\n    return reply;\n  }","id":28948,"modified_method":"public DescribeImageAttributeResponseType describeImageAttribute( final DescribeImageAttributeType request ) throws EucalyptusCloudException {\n    DescribeImageAttributeResponseType reply = ( DescribeImageAttributeResponseType ) request.getReply( );\n    reply.setImageId( request.getImageId( ) );\n    final Context ctx = Contexts.lookup();\n    final String requestAccountId = ctx.getUserFullName( ).getAccountNumber();\n\n    if ( request.getAttribute( ) != null ) request.applyAttribute( );\n    \n    final EntityWrapper<ImageInfo> db = EntityWrapper.get( ImageInfo.class );\n    try {\n      final ImageInfo imgInfo = db.getUnique( Images.exampleWithImageId( request.getImageId( ) ) );\n      if ( !ctx.hasAdministrativePrivileges( ) &&\n           ( !imgInfo.getOwnerAccountNumber( ).equals( requestAccountId ) || !RestrictedTypes.filterPrivileged( ).apply( imgInfo ) ) ) {\n        throw new EucalyptusCloudException( \"Not authorized to describe image attribute\" );\n      }\n      if ( request.getKernel( ) != null ) {\n        reply.setRealResponse( reply.getKernel( ) );\n        if ( imgInfo instanceof MachineImageInfo ) {\n          if ( ( ( MachineImageInfo ) imgInfo ).getKernelId( ) != null ) {\n            reply.getKernel( ).add( ( ( MachineImageInfo ) imgInfo ).getKernelId( ) );\n          }\n        }\n      } else if ( request.getRamdisk( ) != null ) {\n        reply.setRealResponse( reply.getRamdisk( ) );\n        if ( imgInfo instanceof MachineImageInfo ) {\n          if ( ( ( MachineImageInfo ) imgInfo ).getRamdiskId( ) != null ) {\n            reply.getRamdisk( ).add( ( ( MachineImageInfo ) imgInfo ).getRamdiskId( ) );\n          }\n        }\n      } else if ( request.getLaunchPermission( ) != null ) {\n        reply.setRealResponse( reply.getLaunchPermission( ) );\n        if ( imgInfo.getImagePublic( ) ) {\n          reply.getLaunchPermission( ).add( LaunchPermissionItemType.newGroupLaunchPermission() );\n        }\n        for ( final String permission : imgInfo.getPermissions() )\n          reply.getLaunchPermission().add( LaunchPermissionItemType.newUserLaunchPermission( permission ) );\n      } else if ( request.getProductCodes( ) != null ) {\n        reply.setRealResponse( reply.getProductCodes( ) );\n        reply.getProductCodes( ).addAll( imgInfo.getProductCodes( ) );\n      } else if ( request.getBlockDeviceMapping( ) != null ) {\n        reply.setRealResponse( reply.getBlockDeviceMapping( ) );\n        reply.getBlockDeviceMapping( ).add( ImageUtil.EMI );\n        reply.getBlockDeviceMapping( ).add( ImageUtil.EPHEMERAL );\n        reply.getBlockDeviceMapping( ).add( ImageUtil.SWAP );\n        reply.getBlockDeviceMapping( ).add( ImageUtil.ROOT );\n      } else if ( request.getDescription( ) != null ) {\n        reply.setRealResponse( reply.getDescription( ) );\n        if ( imgInfo.getDescription() != null ) {\n          reply.getDescription().add( imgInfo.getDescription() );\n        }\n      } else {\n        throw new EucalyptusCloudException( \"invalid image attribute request.\" );\n      }\n    } finally {\n      db.commit( );\n    }\n    return reply;\n  }","commit_id":"90ec9af17a4557371df3931b21e92d18113c37a1","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ModifyImageAttributeResponseType modifyImageAttribute( ModifyImageAttributeType request ) throws EucalyptusCloudException {\n    ModifyImageAttributeResponseType reply = ( ModifyImageAttributeResponseType ) request.getReply( );\n    final Context ctx = Contexts.lookup( );\n    final String requestAccountId = ctx.getUserFullName( ).getAccountNumber( );\n    final User requestUser = ctx.getUser( );\n    final String action = PolicySpec.requestToAction( request );\n    \n    EntityWrapper<ImageInfo> db = EntityWrapper.get( ImageInfo.class );\n    ImageInfo imgInfo = null;\n    try {\n      imgInfo = db.getUnique( Images.exampleWithImageId( request.getImageId( ) ) );\n      if ( !ctx.hasAdministrativePrivileges( ) &&\n           ( !imgInfo.getOwnerAccountNumber( ).equals( requestAccountId ) ||\n               !RestrictedTypes.filterPrivileged( ).apply( imgInfo ) ) ) {\n        throw new EucalyptusCloudException( \"Not authorized to modify image attribute\" );\n      }\n      // Product codes\n      for ( String productCode : request.getProductCodes( ) ) {\n        imgInfo.addProductCode( productCode );\n      }\n      // Launch permissions\n      if ( \"launchPermission\".equals( request.getAttribute( ) ) ) {\n        if (request.getQueryUserGroup( ).isEmpty( ) && request.getQueryUserId( ).isEmpty( ) )\n          throw new EucalyptusCloudException( \"No userId provided\" );\n        if ( ADD.equals( request.getOperationType( ) ) ) {\n        \tthis.verifyUserIds( request.getQueryUserId( ) );\n          imgInfo.addPermissions( request.getQueryUserId( ) );\n          // Only \"all\" is valid\n          if ( !request.getQueryUserGroup( ).isEmpty( ) ) {\n            imgInfo.setImagePublic( true );\n          }\n        } else {\n          for ( int i = 0; i < request.getQueryUserId( ).size( ); i++ ) {\n        \t\tString accountId = request.getQueryUserId( ).get( i );\n        \t\tif(!imgInfo.checkPermission( accountId ) )\n        \t\tthrow new EucalyptusCloudException( \"No existing launch permission for userId \" + accountId );\n          }\n          imgInfo.removePermissions( request.getQueryUserId( ) );\n          // Only \"all\" is valid\n          if ( !request.getQueryUserGroup( ).isEmpty( ) ) {\n            imgInfo.setImagePublic( false );\n          }\n        }\n      }\n      db.commit( );\n      reply.set_return( true );\n    } catch ( EucalyptusCloudException e ) {\n      db.rollback( );\n      reply.set_return( false );\n      throw e;\n    }\n    \n    return reply;\n  }","id":28949,"modified_method":"public ModifyImageAttributeResponseType modifyImageAttribute( final ModifyImageAttributeType request ) throws EucalyptusCloudException {\n    final ModifyImageAttributeResponseType reply = ( ModifyImageAttributeResponseType ) request.getReply( );\n    final Context ctx = Contexts.lookup();\n    final String requestAccountId = ctx.getUserFullName( ).getAccountNumber();\n\n    final EntityWrapper<ImageInfo> db = EntityWrapper.get( ImageInfo.class );\n    try {\n      final ImageInfo imgInfo = db.getUnique( Images.exampleWithImageId( request.getImageId( ) ) );\n      if ( !ctx.hasAdministrativePrivileges( ) &&\n           ( !imgInfo.getOwnerAccountNumber( ).equals( requestAccountId ) ||\n               !RestrictedTypes.filterPrivileged( ).apply( imgInfo ) ) ) {\n        throw new EucalyptusCloudException( \"Not authorized to modify image attribute\" );\n      }\n\n      switch ( request.getImageAttribute() ) {\n        case LaunchPermission:\n          if ( request.isAdd() ) {\n            imgInfo.addPermissions( verifyUserIds( request.getUserIds() ) );\n            if ( request.isGroupAll() ) {\n              imgInfo.setImagePublic( true );\n            }\n          } else {\n            imgInfo.removePermissions( request.getUserIds() );\n            if ( request.isGroupAll() ) {\n              imgInfo.setImagePublic( false );\n            }\n          }\n          break;\n        case ProductCode:\n          for ( String productCode : request.getProductCodes( ) ) {\n            imgInfo.addProductCode( productCode );\n          }\n          break;\n        case Description:\n          imgInfo.setDescription( request.getDescription() );\n          break;\n      }\n\n      db.commit( );\n      reply.set_return( true );\n    } catch ( EucalyptusCloudException e ) {\n      db.rollback( );\n      reply.set_return( false );\n      throw e;\n    }\n    \n    return reply;\n  }","commit_id":"90ec9af17a4557371df3931b21e92d18113c37a1","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private Map<String, String> buildFieldMap( final Class targetType ) {\n\t\tMap<String, String> fieldMap = new HashMap<String, String>( );\n\t\tField[] fields = targetType.getDeclaredFields( );\n\t\tfor ( Field f : fields )\n\t\t\tif ( Modifier.isStatic( f.getModifiers( ) ) ) continue;\n\t\t\telse if ( f.isAnnotationPresent( HttpParameterMapping.class ) ) {\n\t\t\t\tfieldMap.put( f.getAnnotation( HttpParameterMapping.class ).parameter( ), f.getName( ) );\n\t\t\t\tfieldMap.put( f.getName( ).substring( 0, 1 ).toUpperCase( ).concat( f.getName( ).substring( 1 ) ), f.getName( ) );\n\t\t\t} else fieldMap.put( f.getName( ).substring( 0, 1 ).toUpperCase( ).concat( f.getName( ).substring( 1 ) ), f.getName( ) );\n\t\treturn fieldMap;\n\t}","id":28950,"modified_method":"private Map<String, String> buildFieldMap( final Class targetType ) {\n\t\tMap<String, String> fieldMap = new HashMap<String, String>( );\n\t\tField[] fields = targetType.getDeclaredFields( );\n\t\tfor ( Field f : fields )\n\t\t\tif ( Modifier.isStatic( f.getModifiers( ) ) ) continue;\n\t\t\telse if ( f.isAnnotationPresent( HttpParameterMapping.class ) ) {\n\t\t\t\tfor( final String parameter : f.getAnnotation( HttpParameterMapping.class ).parameter( ) )\n\t\t\t\t\tfieldMap.put( parameter, f.getName( ) );\n\t\t\t\tfieldMap.put( f.getName( ).substring( 0, 1 ).toUpperCase( ).concat( f.getName( ).substring( 1 ) ), f.getName( ) );\n\t\t\t} else fieldMap.put( f.getName( ).substring( 0, 1 ).toUpperCase( ).concat( f.getName( ).substring( 1 ) ), f.getName( ) );\n\t\treturn fieldMap;\n\t}","commit_id":"90ec9af17a4557371df3931b21e92d18113c37a1","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public GetObjectAccessControlPolicyResponseType getObjectAccessControlPolicy(\n\t\t\tGetObjectAccessControlPolicyType request)\n\t\t\t\t\tthrows EucalyptusCloudException {\n\t\tGetObjectAccessControlPolicyResponseType reply = (GetObjectAccessControlPolicyResponseType) request\n\t\t\t\t.getReply();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString ownerId = null;\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\t\tBucketLogData logData;\n\n\t\tAccessControlListType accessControlList = new AccessControlListType();\n\t\tif (bucketList.size() > 0) {\n\t\t\t// construct access control policy from grant infos\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tlogData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tsearchObjectInfo.setVersionId(request.getVersionId());\n\t\t\t\t\tif(request.getVersionId() == null) {\n\t\t\t\t\t\tsearchObjectInfo.setLast(true);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tsearchObjectInfo.setDeleted(false);\n\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges( ) || (\n\t\t\t\t\t\t\t\tobjectInfo.canReadACP(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t\t(objectInfo.isGlobalReadACP() || Lookups.checkPrivilege(PolicySpec.S3_GETOBJECTACL,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(bucketName, objectKey),\n\t\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\townerId = objectInfo.getOwnerId();\n\t\t\t\t\t\t\tArrayList<Grant> grants = new ArrayList<Grant>();\n\t\t\t\t\t\t\tList<GrantInfo> grantInfos = objectInfo.getGrants();\n\t\t\t\t\t\t\tfor (GrantInfo grantInfo : grantInfos) {\n\t\t\t\t\t\t\t\tString uId = grantInfo.getUserId();\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tobjectInfo.readPermissions(grants);\n\t\t\t\t\t\t\t\t\taddPermission(grants, Accounts.lookupAccountById(uId), grantInfo);\n\t\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey,\n\t\t\t\t\t\t\t\t\t\t\tlogData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taccessControlList.setGrants(grants);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tAccessControlPolicyType accessControlPolicy = new AccessControlPolicyType();\n\t\ttry {\n\t\t\tAccount ownerInfo = Accounts.lookupAccountById(ownerId);\n\t\t\taccessControlPolicy.setOwner(new CanonicalUserType(ownerInfo.getAccountNumber(), ownerInfo.getName()));\t\t\t\n\t\t\taccessControlPolicy.setAccessControlList(accessControlList);\n\t\t} catch (AuthException e) {\n\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t}\n\t\treply.setAccessControlPolicy(accessControlPolicy);\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":28951,"modified_method":"public GetObjectAccessControlPolicyResponseType getObjectAccessControlPolicy(\n\t\t\tGetObjectAccessControlPolicyType request)\n\t\t\t\t\tthrows EucalyptusCloudException {\n\t\tGetObjectAccessControlPolicyResponseType reply = (GetObjectAccessControlPolicyResponseType) request\n\t\t\t\t.getReply();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString ownerId = null;\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\t\tBucketLogData logData;\n\n\t\tAccessControlListType accessControlList = new AccessControlListType();\n\t\tif (bucketList.size() > 0) {\n\t\t\t// construct access control policy from grant infos\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tlogData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\tsearchObjectInfo.setVersionId(request.getVersionId());\n\t\t\t\t\tif(request.getVersionId() == null) {\n\t\t\t\t\t\tsearchObjectInfo.setLast(true);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tsearchObjectInfo.setDeleted(false);\n\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\tObjectInfo objectInfo = objectInfos.get(0);\n\t\t\t\t\t\tif (ctx.hasAdministrativePrivileges( ) || (\n\t\t\t\t\t\t\t\tobjectInfo.canReadACP(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t\t(objectInfo.isGlobalReadACP() || Lookups.checkPrivilege(PolicySpec.S3_GETOBJECTACL,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_OBJECT,\n\t\t\t\t\t\t\t\t\t\tPolicySpec.objectFullName(bucketName, objectKey),\n\t\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\tlogData.setObjectSize(objectInfo.getSize());\n\t\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\townerId = objectInfo.getOwnerId();\n\t\t\t\t\t\t\tArrayList<Grant> grants = new ArrayList<Grant>();\n\t\t\t\t\t\t\tList<GrantInfo> grantInfos = objectInfo.getGrants();\n\t\t\t\t\t\t\tobjectInfo.readPermissions(grants);\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddGrants(grants, grantInfos);\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taccessControlList.setGrants(grants);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchEntityException(objectKey, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tAccessControlPolicyType accessControlPolicy = new AccessControlPolicyType();\n\t\ttry {\n\t\t\tAccount ownerInfo = Accounts.lookupAccountById(ownerId);\n\t\t\taccessControlPolicy.setOwner(new CanonicalUserType(ownerInfo.getAccountNumber(), ownerInfo.getName()));\t\t\t\n\t\t\taccessControlPolicy.setAccessControlList(accessControlList);\n\t\t} catch (AuthException e) {\n\t\t\tthrow new AccessDeniedException(\"Key\", objectKey, logData);\n\t\t}\n\t\treply.setAccessControlPolicy(accessControlPolicy);\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"45aae5fedf670f0fbe49b4a867c3bcf67f03bcab","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ListVersionsResponseType listVersions(ListVersionsType request)\n\t\t\tthrows EucalyptusCloudException {\n\t\tListVersionsResponseType reply = (ListVersionsResponseType) request\n\t\t\t\t.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString prefix = request.getPrefix();\n\t\tif (prefix == null)\n\t\t\tprefix = \"\";\n\n\t\tString keyMarker = request.getKeyMarker();\n\t\tString versionIdMarker = request.getVersionIdMarker();\n\n\t\tint maxKeys = -1;\n\t\tString maxKeysString = request.getMaxKeys();\n\t\tif (maxKeysString != null)\n\t\t\tmaxKeys = Integer.parseInt(maxKeysString);\n\t\telse\n\t\t\tmaxKeys = WalrusProperties.MAX_KEYS;\n\n\t\tString delimiter = request.getDelimiter();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tbucketInfo.setHidden(false);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tArrayList<PrefixEntry> prefixes = new ArrayList<PrefixEntry>();\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\tbucket.canRead(account.getAccountNumber()) &&\n\t\t\t\t\t(bucket.isGlobalRead() || Lookups.checkPrivilege(PolicySpec.S3_LISTBUCKETVERSIONS,\n\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_BUCKET,\n\t\t\t\t\t\t\tbucketName,\n\t\t\t\t\t\t\tnull)))) {\n\t\t\t\tif (bucket.isVersioningDisabled()) {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new EucalyptusCloudException(\n\t\t\t\t\t\t\t\"Versioning has not been enabled for bucket: \"\n\t\t\t\t\t\t\t\t\t+ bucketName);\n\t\t\t\t}\n\t\t\t\tif (logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\n\t\t\t\tif (Contexts.lookup().hasAdministrativePrivileges()) {\n\t\t\t\t\tEntityWrapper<WalrusSnapshotInfo> dbSnap = db\n\t\t\t\t\t\t\t.recast(WalrusSnapshotInfo.class);\n\t\t\t\t\tWalrusSnapshotInfo walrusSnapInfo = new WalrusSnapshotInfo();\n\t\t\t\t\twalrusSnapInfo.setSnapshotBucket(bucketName);\n\t\t\t\t\tList<WalrusSnapshotInfo> walrusSnaps = dbSnap\n\t\t\t\t\t\t\t.query(walrusSnapInfo);\n\t\t\t\t\tif (walrusSnaps.size() > 0) {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treply.setName(bucketName);\n\t\t\t\treply.setIsTruncated(false);\n\t\t\t\tif (maxKeys >= 0)\n\t\t\t\t\treply.setMaxKeys(maxKeys);\n\t\t\t\treply.setPrefix(prefix);\n\t\t\t\treply.setKeyMarker(keyMarker);\n\t\t\t\treply.setVersionIdMarker(versionIdMarker);\n\t\t\t\tif (delimiter != null)\n\t\t\t\t\treply.setDelimiter(delimiter);\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db\n\t\t\t\t\t\t.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo();\n\t\t\t\tsearchObjectInfo.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\tint howManyProcessed = 0;\n\t\t\t\t\tif (keyMarker != null || objectInfos.size() < maxKeys)\n\t\t\t\t\t\tCollections.sort(objectInfos);\n\t\t\t\t\tArrayList<VersionEntry> versions = new ArrayList<VersionEntry>();\n\t\t\t\t\tArrayList<DeleteMarkerEntry> deleteMarkers = new ArrayList<DeleteMarkerEntry>();\n\t\t\t\t\t\n\t\t\t\t\tfor (ObjectInfo objectInfo : objectInfos) {\n\t\t\t\t\t\tString objectKey = objectInfo.getObjectKey();\n\n\t\t\t\t\t\tif(keyMarker != null) { if(objectKey.compareTo(keyMarker)\n\t\t\t\t\t\t\t\t<= 0) continue; } else if (versionIdMarker != null) {\n\t\t\t\t\t\t\t\t\tif(!objectInfo.getVersionId().equals(versionIdMarker))\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (prefix != null) {\n\t\t\t\t\t\t\tif (!objectKey.startsWith(prefix)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (delimiter != null) {\n\t\t\t\t\t\t\t\t\tString[] parts = objectKey.substring(\n\t\t\t\t\t\t\t\t\t\t\tprefix.length()).split(delimiter);\n\t\t\t\t\t\t\t\t\tif (parts.length > 1) {\n\t\t\t\t\t\t\t\t\t\tString prefixString = parts[0]\n\t\t\t\t\t\t\t\t\t\t\t\t+ delimiter;\n\t\t\t\t\t\t\t\t\t\tboolean foundPrefix = false;\n\t\t\t\t\t\t\t\t\t\tfor (PrefixEntry prefixEntry : prefixes) {\n\t\t\t\t\t\t\t\t\t\t\tif (prefixEntry.getPrefix().equals(\n\t\t\t\t\t\t\t\t\t\t\t\t\tprefixString)) {\n\t\t\t\t\t\t\t\t\t\t\t\tfoundPrefix = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!foundPrefix) {\n\t\t\t\t\t\t\t\t\t\t\tprefixes.add(new PrefixEntry(\n\t\t\t\t\t\t\t\t\t\t\t\t\tprefixString));\n\t\t\t\t\t\t\t\t\t\t\tif (maxKeys >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (howManyProcessed++ >= maxKeys) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (maxKeys >= 0) {\n\t\t\t\t\t\t\tif (howManyProcessed++ >= maxKeys) {\n\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!objectInfo.getDeleted()) {\n\t\t\t\t\t\t\tVersionEntry versionEntry = new VersionEntry();\n\t\t\t\t\t\t\tversionEntry.setKey(objectKey);\n\t\t\t\t\t\t\tversionEntry\n\t\t\t\t\t\t\t.setVersionId(objectInfo.getVersionId());\n\t\t\t\t\t\t\tversionEntry.setEtag(objectInfo.getEtag());\n\t\t\t\t\t\t\tversionEntry.setLastModified(DateUtils.format(\n\t\t\t\t\t\t\t\t\tobjectInfo.getLastModified().getTime(),\n\t\t\t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t\t\t\t\t\t+ \".000Z\");\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tString displayName = Accounts.lookupAccountById(objectInfo.getOwnerId()).getName();\n\t\t\t\t\t\t\t\tversionEntry.setOwner(new CanonicalUserType(objectInfo.getOwnerId(), displayName));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\",\n\t\t\t\t\t\t\t\t\t\tbucketName, logData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tversionEntry.setSize(objectInfo.getSize());\n\t\t\t\t\t\t\tversionEntry.setStorageClass(objectInfo\n\t\t\t\t\t\t\t\t\t.getStorageClass());\n\t\t\t\t\t\t\tversionEntry.setIsLatest(objectInfo.getLast());\n\t\t\t\t\t\t\tversions.add(versionEntry);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDeleteMarkerEntry deleteMarkerEntry = new DeleteMarkerEntry();\n\t\t\t\t\t\t\tdeleteMarkerEntry.setKey(objectKey);\n\t\t\t\t\t\t\tdeleteMarkerEntry.setVersionId(objectInfo.getVersionId());\n\t\t\t\t\t\t\tdeleteMarkerEntry.setLastModified(DateUtils.format(\n\t\t\t\t\t\t\t\t\tobjectInfo.getLastModified().getTime(),\n\t\t\t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t\t\t\t\t\t+ \".000Z\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tString ownerId = objectInfo.getOwnerId();\n\t\t\t\t\t\t\t\tString displayName = Accounts.lookupAccountById(ownerId).getName();\n\t\t\t\t\t\t\t\tdeleteMarkerEntry.setOwner(new CanonicalUserType(ownerId, displayName));\n\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\",\n\t\t\t\t\t\t\t\t\t\tbucketName, logData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdeleteMarkerEntry.setIsLatest(objectInfo.getLast());\n\t\t\t\t\t\t\tdeleteMarkers.add(deleteMarkerEntry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treply.setVersions(versions);\n\t\t\t\t\treply.setDeleteMarkers(deleteMarkers);\n\t\t\t\t\tif (prefix != null) {\n\t\t\t\t\t\treply.setCommonPrefixes(prefixes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":28952,"modified_method":"public ListVersionsResponseType listVersions(ListVersionsType request)\n\t\t\tthrows EucalyptusCloudException {\n\t\tListVersionsResponseType reply = (ListVersionsResponseType) request\n\t\t\t\t.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString prefix = request.getPrefix();\n\t\tif (prefix == null)\n\t\t\tprefix = \"\";\n\n\t\tString keyMarker = request.getKeyMarker();\n\t\tString versionIdMarker = request.getVersionIdMarker();\n\n\t\tint maxKeys = -1;\n\t\tString maxKeysString = request.getMaxKeys();\n\t\tif (maxKeysString != null)\n\t\t\tmaxKeys = Integer.parseInt(maxKeysString);\n\t\telse\n\t\t\tmaxKeys = WalrusProperties.MAX_KEYS;\n\n\t\tString delimiter = request.getDelimiter();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tbucketInfo.setHidden(false);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tArrayList<PrefixEntry> prefixes = new ArrayList<PrefixEntry>();\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\tbucket.canRead(account.getAccountNumber()) &&\n\t\t\t\t\t(bucket.isGlobalRead() || Lookups.checkPrivilege(PolicySpec.S3_LISTBUCKETVERSIONS,\n\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_BUCKET,\n\t\t\t\t\t\t\tbucketName,\n\t\t\t\t\t\t\tnull)))) {\n\t\t\t\tif (bucket.isVersioningDisabled()) {\n\t\t\t\t\tdb.rollback();\n\t\t\t\t\tthrow new EucalyptusCloudException(\n\t\t\t\t\t\t\t\"Versioning has not been enabled for bucket: \"\n\t\t\t\t\t\t\t\t\t+ bucketName);\n\t\t\t\t}\n\t\t\t\tif (logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\n\t\t\t\tif (Contexts.lookup().hasAdministrativePrivileges()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif(bucketHasSnapshots(bucketName)) {\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\tLOG.debug(e,e);\n\t\t\t\t\t\tthrow new EucalyptusCloudException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treply.setName(bucketName);\n\t\t\t\treply.setIsTruncated(false);\n\t\t\t\tif (maxKeys >= 0)\n\t\t\t\t\treply.setMaxKeys(maxKeys);\n\t\t\t\treply.setPrefix(prefix);\n\t\t\t\treply.setKeyMarker(keyMarker);\n\t\t\t\treply.setVersionIdMarker(versionIdMarker);\n\t\t\t\tif (delimiter != null)\n\t\t\t\t\treply.setDelimiter(delimiter);\n\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db\n\t\t\t\t\t\t.recast(ObjectInfo.class);\n\t\t\t\tObjectInfo searchObjectInfo = new ObjectInfo();\n\t\t\t\tsearchObjectInfo.setBucketName(bucketName);\n\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(searchObjectInfo);\n\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\tint howManyProcessed = 0;\n\t\t\t\t\tif (keyMarker != null || objectInfos.size() < maxKeys)\n\t\t\t\t\t\tCollections.sort(objectInfos);\n\t\t\t\t\tArrayList<VersionEntry> versions = new ArrayList<VersionEntry>();\n\t\t\t\t\tArrayList<DeleteMarkerEntry> deleteMarkers = new ArrayList<DeleteMarkerEntry>();\n\t\t\t\t\t\n\t\t\t\t\tfor (ObjectInfo objectInfo : objectInfos) {\n\t\t\t\t\t\tString objectKey = objectInfo.getObjectKey();\n\n\t\t\t\t\t\tif(keyMarker != null) { if(objectKey.compareTo(keyMarker)\n\t\t\t\t\t\t\t\t<= 0) continue; } else if (versionIdMarker != null) {\n\t\t\t\t\t\t\t\t\tif(!objectInfo.getVersionId().equals(versionIdMarker))\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (prefix != null) {\n\t\t\t\t\t\t\tif (!objectKey.startsWith(prefix)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (delimiter != null) {\n\t\t\t\t\t\t\t\t\tString[] parts = objectKey.substring(\n\t\t\t\t\t\t\t\t\t\t\tprefix.length()).split(delimiter);\n\t\t\t\t\t\t\t\t\tif (parts.length > 1) {\n\t\t\t\t\t\t\t\t\t\tString prefixString = parts[0]\n\t\t\t\t\t\t\t\t\t\t\t\t+ delimiter;\n\t\t\t\t\t\t\t\t\t\tboolean foundPrefix = false;\n\t\t\t\t\t\t\t\t\t\tfor (PrefixEntry prefixEntry : prefixes) {\n\t\t\t\t\t\t\t\t\t\t\tif (prefixEntry.getPrefix().equals(\n\t\t\t\t\t\t\t\t\t\t\t\t\tprefixString)) {\n\t\t\t\t\t\t\t\t\t\t\t\tfoundPrefix = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!foundPrefix) {\n\t\t\t\t\t\t\t\t\t\t\tprefixes.add(new PrefixEntry(\n\t\t\t\t\t\t\t\t\t\t\t\t\tprefixString));\n\t\t\t\t\t\t\t\t\t\t\tif (maxKeys >= 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (howManyProcessed++ >= maxKeys) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (maxKeys >= 0) {\n\t\t\t\t\t\t\tif (howManyProcessed++ >= maxKeys) {\n\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!objectInfo.getDeleted()) {\n\t\t\t\t\t\t\tVersionEntry versionEntry = new VersionEntry();\n\t\t\t\t\t\t\tversionEntry.setKey(objectKey);\n\t\t\t\t\t\t\tversionEntry\n\t\t\t\t\t\t\t.setVersionId(objectInfo.getVersionId());\n\t\t\t\t\t\t\tversionEntry.setEtag(objectInfo.getEtag());\n\t\t\t\t\t\t\tversionEntry.setLastModified(DateUtils.format(\n\t\t\t\t\t\t\t\t\tobjectInfo.getLastModified().getTime(),\n\t\t\t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t\t\t\t\t\t+ \".000Z\");\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tString displayName = Accounts.lookupAccountById(objectInfo.getOwnerId()).getName();\n\t\t\t\t\t\t\t\tversionEntry.setOwner(new CanonicalUserType(objectInfo.getOwnerId(), displayName));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\",\n\t\t\t\t\t\t\t\t\t\tbucketName, logData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tversionEntry.setSize(objectInfo.getSize());\n\t\t\t\t\t\t\tversionEntry.setStorageClass(objectInfo\n\t\t\t\t\t\t\t\t\t.getStorageClass());\n\t\t\t\t\t\t\tversionEntry.setIsLatest(objectInfo.getLast());\n\t\t\t\t\t\t\tversions.add(versionEntry);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDeleteMarkerEntry deleteMarkerEntry = new DeleteMarkerEntry();\n\t\t\t\t\t\t\tdeleteMarkerEntry.setKey(objectKey);\n\t\t\t\t\t\t\tdeleteMarkerEntry.setVersionId(objectInfo.getVersionId());\n\t\t\t\t\t\t\tdeleteMarkerEntry.setLastModified(DateUtils.format(\n\t\t\t\t\t\t\t\t\tobjectInfo.getLastModified().getTime(),\n\t\t\t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t\t\t\t\t\t+ \".000Z\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tString ownerId = objectInfo.getOwnerId();\n\t\t\t\t\t\t\t\tString displayName = Accounts.lookupAccountById(ownerId).getName();\n\t\t\t\t\t\t\t\tdeleteMarkerEntry.setOwner(new CanonicalUserType(ownerId, displayName));\n\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\",\n\t\t\t\t\t\t\t\t\t\tbucketName, logData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdeleteMarkerEntry.setIsLatest(objectInfo.getLast());\n\t\t\t\t\t\t\tdeleteMarkers.add(deleteMarkerEntry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treply.setVersions(versions);\n\t\t\t\t\treply.setDeleteMarkers(deleteMarkers);\n\t\t\t\t\tif (prefix != null) {\n\t\t\t\t\t\treply.setCommonPrefixes(prefixes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"45aae5fedf670f0fbe49b4a867c3bcf67f03bcab","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public GetBucketAccessControlPolicyResponseType getBucketAccessControlPolicy(\n\t\t\tGetBucketAccessControlPolicyType request)\n\t\t\t\t\tthrows EucalyptusCloudException {\n\t\tGetBucketAccessControlPolicyResponseType reply = (GetBucketAccessControlPolicyResponseType) request\n\t\t\t\t.getReply();\n\n\t\tString bucketName = request.getBucket();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString ownerId = null;\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tAccessControlListType accessControlList = new AccessControlListType();\n\t\tBucketLogData logData;\n\n\t\tif (bucketList.size() > 0) {\n\t\t\t// construct access control policy from grant infos\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tlogData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tList<GrantInfo> grantInfos = bucket.getGrants();\n\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\tbucket.canReadACP(account.getAccountNumber()) &&\n\t\t\t\t\t(bucket.isGlobalReadACP() || Lookups.checkPrivilege(PolicySpec.S3_GETBUCKETACL,\n\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_BUCKET,\n\t\t\t\t\t\t\tbucketName,\n\t\t\t\t\t\t\tnull)))) {\n\t\t\t\tif (logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\n\t\t\t\townerId = bucket.getOwnerId();\n\t\t\t\tArrayList<Grant> grants = new ArrayList<Grant>();\n\t\t\t\tbucket.readPermissions(grants);\n\t\t\t\tfor (GrantInfo grantInfo : grantInfos) {\n\t\t\t\t\tString uId = grantInfo.getUserId();\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//TODO: zhill - Modify this to handle invalid accounts and just skip them. This is just response creation, not authorization\n\t\t\t\t\t\tif (uId != null) {\n\t\t\t\t\t\t\taddPermission(grants, Accounts.lookupAccountById(uId), grantInfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddPermission(grants, grantInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName,\n\t\t\t\t\t\t\t\tlogData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taccessControlList.setGrants(grants);\n\t\t\t} else {\n\t\t\t\tLOG.error( \"Not authorized to get bucket ACL by \" + ctx.getUserFullName( ) );\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tAccessControlPolicyType accessControlPolicy = new AccessControlPolicyType();\n\t\ttry {\n\t\t\tAccount ownerInfo = Accounts.lookupAccountById(ownerId);\n\t\t\taccessControlPolicy.setOwner(new CanonicalUserType(ownerInfo.getAccountNumber(), ownerInfo.getName()));\n\t\t\taccessControlPolicy.setAccessControlList(accessControlList);\n\t\t} catch (AuthException e) {\n\t\t\tdb.rollback();\n\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t}\n\t\treply.setAccessControlPolicy(accessControlPolicy);\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":28953,"modified_method":"public GetBucketAccessControlPolicyResponseType getBucketAccessControlPolicy(\n\t\t\tGetBucketAccessControlPolicyType request)\n\t\t\t\t\tthrows EucalyptusCloudException {\n\t\tGetBucketAccessControlPolicyResponseType reply = (GetBucketAccessControlPolicyResponseType) request\n\t\t\t\t.getReply();\n\n\t\tString bucketName = request.getBucket();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString ownerId = null;\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tAccessControlListType accessControlList = new AccessControlListType();\n\t\tBucketLogData logData;\n\n\t\tif (bucketList.size() > 0) {\n\t\t\t// construct access control policy from grant infos\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tlogData = bucket.getLoggingEnabled() ? request.getLogData() : null;\n\t\t\tList<GrantInfo> grantInfos = bucket.getGrants();\n\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\tbucket.canReadACP(account.getAccountNumber()) &&\n\t\t\t\t\t(bucket.isGlobalReadACP() || Lookups.checkPrivilege(PolicySpec.S3_GETBUCKETACL,\n\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_BUCKET,\n\t\t\t\t\t\t\tbucketName,\n\t\t\t\t\t\t\tnull)))) {\n\t\t\t\tif (logData != null) {\n\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t}\n\t\t\t\townerId = bucket.getOwnerId();\n\t\t\t\tArrayList<Grant> grants = new ArrayList<Grant>();\n\t\t\t\tbucket.readPermissions(grants);\n\t\t\t\tCanonicalUserType grantUser = null;\n\t\t\t\tAccount tmpAccnt = null;\n\t\t\t\tfor (GrantInfo grantInfo : grantInfos) {\n\t\t\t\t\tString uId = grantInfo.getUserId();\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (uId != null) {\n\t\t\t\t\t\t\t//Lots of work just to try to get the display Name of the userId.\n\t\t\t\t\t\t\t//TODO: zhill - Operations like this shouldn't have to hit the DB for every user, that can be in the grant record\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\ttmpAccnt = Accounts.lookupAccountById(uId);\n\t\t\t\t\t\t\t\tgrantUser = new CanonicalUserType(tmpAccnt.getAccountNumber(), tmpAccnt.getName());\n\t\t\t\t\t\t\t\ttmpAccnt = null;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} catch(AuthException e) {\n\t\t\t\t\t\t\t\tLOG.debug(e,e);\n\t\t\t\t\t\t\t\t//Couldn't get one, use empty string\n\t\t\t\t\t\t\t\tgrantUser = new CanonicalUserType(uId, \"\");\n\t\t\t\t\t\t\t\ttmpAccnt = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddPermission(grants, grantUser, grantInfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddPermission(grants, grantInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t//Just skip this entry, this is not an auth issue\n\t\t\t\t\t\tLOG.debug(e,e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taccessControlList.setGrants(grants);\n\t\t\t} else {\n\t\t\t\tLOG.error( \"Not authorized to get bucket ACL by \" + ctx.getUserFullName( ) );\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\n\t\tAccessControlPolicyType accessControlPolicy = new AccessControlPolicyType();\n\t\ttry {\n\t\t\tAccount ownerInfo = Accounts.lookupAccountById(ownerId);\n\t\t\taccessControlPolicy.setOwner(new CanonicalUserType(ownerInfo.getAccountNumber(), ownerInfo.getName()));\n\t\t\taccessControlPolicy.setAccessControlList(accessControlList);\n\t\t} catch (AuthException e) {\n\t\t\tdb.rollback();\n\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t}\n\t\treply.setAccessControlPolicy(accessControlPolicy);\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"45aae5fedf670f0fbe49b4a867c3bcf67f03bcab","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ListAllMyBucketsResponseType listAllMyBuckets(\n\t\t\tListAllMyBucketsType request) throws EucalyptusCloudException {\n\t\tListAllMyBucketsResponseType reply = (ListAllMyBucketsResponseType) request\n\t\t\t\t.getReply();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\n\t\tif (account == null) {\n\t\t\tthrow new AccessDeniedException(\"no such account\");\n\t\t}\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\ttry {\n\t\t\tBucketInfo searchBucket = new BucketInfo();\n\t\t\tsearchBucket.setOwnerId(account.getAccountNumber());\n\t\t\tsearchBucket.setHidden(false);\n\t\t\tList<BucketInfo> bucketInfoList = db.query(searchBucket);\n\n\t\t\tArrayList<BucketListEntry> buckets = new ArrayList<BucketListEntry>();\n\n\t\t\tfor (BucketInfo bucketInfo : bucketInfoList) {\n\t\t\t\tif (ctx.hasAdministrativePrivileges()) {\t\t\t\t\t\t\n\t\t\t\t\tEntityWrapper<WalrusSnapshotInfo> dbSnap = EntityWrapper.get(WalrusSnapshotInfo.class);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tWalrusSnapshotInfo walrusSnapInfo = new WalrusSnapshotInfo();\n\t\t\t\t\t\twalrusSnapInfo.setSnapshotBucket(bucketInfo.getBucketName());\n\t\t\t\t\t\tList<WalrusSnapshotInfo> walrusSnaps = dbSnap\n\t\t\t\t\t\t\t\t.query(walrusSnapInfo);\n\t\t\t\t\t\tdbSnap.commit();\n\t\t\t\t\t\tif (walrusSnaps.size() > 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} catch (Exception eee) {\n\t\t\t\t\t\tLOG.debug(eee, eee);\n\t\t\t\t\t\tdbSnap.rollback();\n\t\t\t\t\t}\n\t\t\t\t}\n        if (ctx.hasAdministrativePrivileges() ||\n            Lookups.checkPrivilege(PolicySpec.S3_LISTALLMYBUCKETS,\n                PolicySpec.VENDOR_S3,\n                PolicySpec.S3_RESOURCE_BUCKET,\n                bucketInfo.getBucketName(),\n                bucketInfo.getOwnerId())) {           \n          buckets.add(new BucketListEntry(bucketInfo.getBucketName(),\n              DateUtils.format(bucketInfo.getCreationDate().getTime(),\n                  DateUtils.ISO8601_DATETIME_PATTERN)\n                  + \".000Z\"));\n        }\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tCanonicalUserType owner = new CanonicalUserType(account.getAccountNumber(), account.getName());\n\t\t\t\tListAllMyBucketsList bucketList = new ListAllMyBucketsList();\n\t\t\t\treply.setOwner(owner);\n\t\t\t\tbucketList.setBuckets(buckets);\n\t\t\t\treply.setBucketList(bucketList);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tdb.rollback();\n\t\t\t\tLOG.error(ex);\n\t\t\t\tthrow new AccessDeniedException(\"Account: \" + account.getName() + \" not found\", ex);\n\t\t\t}\n\t\t\tdb.commit();\n\t\t} catch (EucalyptusCloudException e) {\n\t\t\tdb.rollback();\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tLOG.debug(e, e);\n\t\t\tdb.rollback();\n\t\t}\n\t\treturn reply;\n\t}","id":28954,"modified_method":"public ListAllMyBucketsResponseType listAllMyBuckets(\n\t\t\tListAllMyBucketsType request) throws EucalyptusCloudException {\n\t\tListAllMyBucketsResponseType reply = (ListAllMyBucketsResponseType) request\n\t\t\t\t.getReply();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\n\t\tif (account == null) {\n\t\t\tthrow new AccessDeniedException(\"no such account\");\n\t\t}\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\ttry {\n\t\t\tBucketInfo searchBucket = new BucketInfo();\n\t\t\tsearchBucket.setOwnerId(account.getAccountNumber());\n\t\t\tsearchBucket.setHidden(false);\n\t\t\t\n\t\t\tList<BucketInfo> bucketInfoList = db.query(searchBucket);\n\n\t\t\tArrayList<BucketListEntry> buckets = new ArrayList<BucketListEntry>();\n\n\t\t\tfor (BucketInfo bucketInfo : bucketInfoList) {\n\t\t\t\tif (ctx.hasAdministrativePrivileges()) {\t\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//TODO: zhill -- we should modify the bucket schema to indicate if the bucket is a snapshot bucket, or use a seperate type for snap containers\n\t\t\t\t\t\tif(bucketHasSnapshots(bucketInfo.getBucketName())) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\tLOG.debug(e, e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\t\n\t\t\t\t}\t\n        \t\tif (ctx.hasAdministrativePrivileges() || \n        \t\t\tLookups.checkPrivilege(PolicySpec.S3_LISTALLMYBUCKETS, \n                \tPolicySpec.VENDOR_S3,\n                \tPolicySpec.S3_RESOURCE_BUCKET,\n                \tbucketInfo.getBucketName(),\n                \tbucketInfo.getOwnerId())) {\n        \t\t\n        \t\t\tbuckets.add(new BucketListEntry(bucketInfo.getBucketName(),\n        \t\t\t\t\tDateUtils.format(bucketInfo.getCreationDate().getTime(), \n        \t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN) \n        \t\t\t\t\t\t\t+ \".000Z\"));\n        \t\t}\n\t\t\t}\n\t\t\tdb.commit();\n\t\t\t\n\t\t\ttry {\n\t\t\t\tCanonicalUserType owner = new CanonicalUserType(account.getAccountNumber(), account.getName());\n\t\t\t\tListAllMyBucketsList bucketList = new ListAllMyBucketsList();\n\t\t\t\treply.setOwner(owner);\n\t\t\t\tbucketList.setBuckets(buckets);\n\t\t\t\treply.setBucketList(bucketList);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tLOG.error(ex);\n\t\t\t\tthrow new AccessDeniedException(\"Account: \" + account.getName() + \" not found\", ex);\n\t\t\t}\t\t\t\n\t\t} catch (EucalyptusCloudException e) {\n\t\t\tdb.rollback();\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tLOG.debug(e, e);\n\t\t\tdb.rollback();\n\t\t}\n\t\treturn reply;\n\t}","commit_id":"45aae5fedf670f0fbe49b4a867c3bcf67f03bcab","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ListBucketResponseType listBucket(ListBucketType request)\n\t\t\tthrows EucalyptusCloudException {\n\t\tListBucketResponseType reply = (ListBucketResponseType) request\n\t\t\t\t.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString prefix = request.getPrefix();\n\t\tif (prefix == null) {\n\t\t\tprefix = \"\";\n\t\t}\n\n\t\tString marker = request.getMarker();\n\t\tint maxKeys = -1;\n\t\tString maxKeysString = request.getMaxKeys();\n\t\tif (maxKeysString != null) {\n\t\t\tmaxKeys = Integer.parseInt(maxKeysString);\t\t\t\n\t\t} else {\n\t\t\tmaxKeys = WalrusProperties.MAX_KEYS;\n\t\t}\n\n\t\tString delimiter = request.getDelimiter();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tbucketInfo.setHidden(false);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tHashtable<String,PrefixEntry> prefixes = new Hashtable<String,PrefixEntry>();\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\t\t\tbucket.canRead(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t(bucket.isGlobalRead() || Lookups.checkPrivilege(PolicySpec.S3_LISTBUCKET,\n\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_BUCKET,\n\t\t\t\t\t\t\t\t\tbucketName,\n\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (Contexts.lookup().hasAdministrativePrivileges()) {\n\t\t\t\t\t\t\tEntityWrapper<WalrusSnapshotInfo> dbSnap = db\n\t\t\t\t\t\t\t\t\t.recast(WalrusSnapshotInfo.class);\n\t\t\t\t\t\t\tWalrusSnapshotInfo walrusSnapInfo = new WalrusSnapshotInfo();\n\t\t\t\t\t\t\twalrusSnapInfo.setSnapshotBucket(bucketName);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tCriteria snapCount = dbSnap.createCriteria(WalrusSnapshotInfo.class).add(Example.create(walrusSnapInfo)).setProjection(Projections.rowCount());\n\t\t\t\t\t\t\tLong rowCount = (Long)snapCount.uniqueResult();\n\t\t\t\t\t\t\tif (rowCount != null && rowCount.longValue() > 0) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treply.setName(bucketName);\n\t\t\t\t\t\treply.setIsTruncated(false);\n\t\t\t\t\t\treply.setPrefix(prefix);\t\t\t\t\t\t\n\t\t\t\t\t\tif (maxKeys >= 0) {\n\t\t\t\t\t\t\treply.setMaxKeys(maxKeys);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (delimiter != null){\n\t\t\t\t\t\t\treply.setDelimiter(delimiter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(maxKeys == 0) {\n\t\t\t\t\t\t\t//No keys requested, so just return\n\t\t\t\t\t\t\treply.setContents(new ArrayList<ListEntry>());\n\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\treturn reply;\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int queryStrideSize = maxKeys + 1;\t\t\t\t\t\t\n\t\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db\n\t\t\t\t\t\t\t\t.recast(ObjectInfo.class);\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tObjectInfo searchObj = new ObjectInfo();\n\t\t\t\t\t\tsearchObj.setBucketName(bucketName);\n\t\t\t\t\t\tsearchObj.setLast(true);\n\t\t\t\t\t\tsearchObj.setDeleted(false);\n\t\t\t\t\t\t\n\t\t\t\t\t\tCriteria objCriteria = dbObject.createCriteria(ObjectInfo.class);\n\t\t\t\t\t\t//objCriteria.setReadOnly(true); //don't use yet, make sure semantics don't change (i.e. caching)\n\t\t\t\t\t\tobjCriteria.add(Example.create(searchObj));\t\t\t\t\t\t\n\t\t\t\t\t\tobjCriteria.addOrder(Order.asc(\"objectKey\"));\t\t\t\t\t\t\n\t\t\t\t\t\tobjCriteria.setMaxResults(queryStrideSize); //add one to, hopefully, indicate truncation in one call\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(marker != null) {\n\t\t\t\t\t\t\tobjCriteria.add(Restrictions.ge(\"objectKey\", marker));\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(prefix != null && !prefix.equals(\"\")) {\n\t\t\t\t\t\t\tobjCriteria.add(Restrictions.like(\"objectKey\", prefix, MatchMode.START));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tList<ObjectInfo> objectInfos = null;//(List<ObjectInfo>)objCriteria.list();\n\t\t\t\t\t\tint resultKeyCount = 0;\n\t\t\t\t\t\tString objectKey = null;\n\t\t\t\t\t\tString[] parts = null;\n\t\t\t\t\t\tString prefixString = null;\n\t\t\t\t\t\tArrayList<ListEntry> contents = new ArrayList<ListEntry>(); //contents for reply\n\t\t\t\t\t\tArrayList<MetaDataEntry> metaData = new ArrayList<MetaDataEntry>(); //metadata for reply\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t//Iterate over result sets of size maxkeys + 1\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tobjectKey = null;\n\t\t\t\t\t\t\tparts = null;\n\t\t\t\t\t\t\tprefixString = null;\n\t\t\t\t\t\t\tif(resultKeyCount > 0) { //Start from end of last round-trip if necessary\n\t\t\t\t\t\t\t\tobjCriteria.setFirstResult(queryStrideSize);\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tobjectInfos = (List<ObjectInfo>)objCriteria.list();\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\t\t\tfor (ObjectInfo objectInfo : objectInfos) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tobjectKey = objectInfo.getObjectKey();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t//Check if it will get aggregated as a commonprefix\n\t\t\t\t\t\t\t\t\tif (delimiter != null) {\n\t\t\t\t\t\t\t\t\t\tparts = objectKey.substring(prefix.length()).split(delimiter);\n\t\t\t\t\t\t\t\t\t\tif (parts.length > 1) {\n\t\t\t\t\t\t\t\t\t\t\tprefixString = parts[0] + delimiter;\n\t\t\t\t\t\t\t\t\t\t\tif(!prefixes.containsKey(prefixString)) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(resultKeyCount == maxKeys) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t//This is a new record, so we know we're truncating if this is true\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setNextMarker(objectKey);\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\tresultKeyCount++;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tprefixes.put(prefixString, new PrefixEntry(prefixString));\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tresultKeyCount++; //count the unique commonprefix as a single return entry\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(resultKeyCount == maxKeys) {\n\t\t\t\t\t\t\t\t\t\t//This is a new (non-commonprefix) record, so we know we're truncating\n\t\t\t\t\t\t\t\t\t\treply.setNextMarker(objectKey);\n\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\tresultKeyCount++;\n\t\t\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t//Process the entry as a full key listing\n\t\t\t\t\t\t\t\t\tListEntry listEntry = new ListEntry();\n\t\t\t\t\t\t\t\t\tlistEntry.setKey(objectKey);\n\t\t\t\t\t\t\t\t\tlistEntry.setEtag(objectInfo.getEtag());\n\t\t\t\t\t\t\t\t\tlistEntry.setLastModified(DateUtils.format(objectInfo\n\t\t\t\t\t\t\t\t\t\t\t.getLastModified().getTime(),\n\t\t\t\t\t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t\t\t\t\t\t\t\t+ \".000Z\");\n\t\t\t\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\n\t\t\t\t\t\t\t\t\ttry {\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tlistEntry.setOwner(new CanonicalUserType(objectInfo.getOwnerId(), Accounts.lookupAccountById(objectInfo.getOwnerId()).getName()));\n\t\t\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tobjectInfo.returnMetaData(metaData);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tlistEntry.setSize(objectInfo.getSize());\n\t\t\t\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\t\t\t\t\t\t\t\t\tcontents.add(listEntry);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tresultKeyCount++;\n\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\n\n\t\t\t\t\t\t\tif(resultKeyCount <= maxKeys && objectInfos.size() <= maxKeys) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while(resultKeyCount <= maxKeys);\n\t\t\t\t\t\t\n\t\t\t\t\t\treply.setMetaData(metaData);\n\t\t\t\t\t\treply.setContents(contents);\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t//Sort the prefixes from the hashtable and add to the reply\n\t\t\t\t\t\tif (prefixes != null && prefixes.size() > 0) {\n\t\t\t\t\t\t\tArrayList<PrefixEntry> prefixList = new ArrayList<PrefixEntry>();\n\t\t\t\t\t\t\tprefixList.addAll(prefixes.values());\n\n\t\t\t\t\t\t\tCollections.sort(prefixList, new Comparator<PrefixEntry>() {\n\t\t\t\t\t\t\t\tpublic int compare(PrefixEntry e1, PrefixEntry e2) {\n\t\t\t\t\t\t\t\t\treturn e1.getPrefix().compareTo(e2.getPrefix());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\treply.setCommonPrefixes(prefixList);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":28955,"modified_method":"public ListBucketResponseType listBucket(ListBucketType request)\n\t\t\tthrows EucalyptusCloudException {\n\t\tListBucketResponseType reply = (ListBucketResponseType) request\n\t\t\t\t.getReply();\n\t\tString bucketName = request.getBucket();\n\t\tContext ctx = Contexts.lookup();\n\t\tAccount account = ctx.getAccount();\n\t\tString prefix = request.getPrefix();\n\t\tif (prefix == null) {\n\t\t\tprefix = \"\";\n\t\t}\n\n\t\tString marker = request.getMarker();\n\t\tint maxKeys = -1;\n\t\tString maxKeysString = request.getMaxKeys();\n\t\tif (maxKeysString != null) {\n\t\t\tmaxKeys = Integer.parseInt(maxKeysString);\t\t\t\n\t\t} else {\n\t\t\tmaxKeys = WalrusProperties.MAX_KEYS;\n\t\t}\n\n\t\tString delimiter = request.getDelimiter();\n\n\t\tEntityWrapper<BucketInfo> db = EntityWrapper.get(BucketInfo.class);\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tbucketInfo.setHidden(false);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tHashtable<String,PrefixEntry> prefixes = new Hashtable<String,PrefixEntry>();\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tif (ctx.hasAdministrativePrivileges() || (\n\t\t\t\t\t\t\tbucket.canRead(account.getAccountNumber()) &&\n\t\t\t\t\t\t\t(bucket.isGlobalRead() || Lookups.checkPrivilege(PolicySpec.S3_LISTBUCKET,\n\t\t\t\t\t\t\t\t\tPolicySpec.VENDOR_S3,\n\t\t\t\t\t\t\t\t\tPolicySpec.S3_RESOURCE_BUCKET,\n\t\t\t\t\t\t\t\t\tbucketName,\n\t\t\t\t\t\t\t\t\tnull)))) {\n\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (Contexts.lookup().hasAdministrativePrivileges()) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif(bucketHasSnapshots(bucketName)) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treply.setName(bucketName);\n\t\t\t\t\t\treply.setIsTruncated(false);\n\t\t\t\t\t\treply.setPrefix(prefix);\t\t\t\t\t\t\n\t\t\t\t\t\tif (maxKeys >= 0) {\n\t\t\t\t\t\t\treply.setMaxKeys(maxKeys);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (delimiter != null){\n\t\t\t\t\t\t\treply.setDelimiter(delimiter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(maxKeys == 0) {\n\t\t\t\t\t\t\t//No keys requested, so just return\n\t\t\t\t\t\t\treply.setContents(new ArrayList<ListEntry>());\n\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\treturn reply;\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int queryStrideSize = maxKeys + 1;\t\t\t\t\t\t\n\t\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tObjectInfo searchObj = new ObjectInfo();\n\t\t\t\t\t\tsearchObj.setBucketName(bucketName);\n\t\t\t\t\t\tsearchObj.setLast(true);\n\t\t\t\t\t\tsearchObj.setDeleted(false);\n\t\t\t\t\t\t\n\t\t\t\t\t\tCriteria objCriteria = dbObject.createCriteria(ObjectInfo.class);\n\t\t\t\t\t\t//objCriteria.setReadOnly(true); //don't use yet, make sure semantics don't change (i.e. caching)\n\t\t\t\t\t\tobjCriteria.add(Example.create(searchObj));\t\t\t\t\t\t\n\t\t\t\t\t\tobjCriteria.addOrder(Order.asc(\"objectKey\"));\t\t\t\t\t\t\n\t\t\t\t\t\tobjCriteria.setMaxResults(queryStrideSize); //add one to, hopefully, indicate truncation in one call\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(marker != null) {\n\t\t\t\t\t\t\tobjCriteria.add(Restrictions.ge(\"objectKey\", marker));\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(prefix != null && !prefix.equals(\"\")) {\n\t\t\t\t\t\t\tobjCriteria.add(Restrictions.like(\"objectKey\", prefix, MatchMode.START));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tList<ObjectInfo> objectInfos = null;//(List<ObjectInfo>)objCriteria.list();\n\t\t\t\t\t\tint resultKeyCount = 0;\n\t\t\t\t\t\tString objectKey = null;\n\t\t\t\t\t\tString[] parts = null;\n\t\t\t\t\t\tString prefixString = null;\n\t\t\t\t\t\tArrayList<ListEntry> contents = new ArrayList<ListEntry>(); //contents for reply\n\t\t\t\t\t\tArrayList<MetaDataEntry> metaData = new ArrayList<MetaDataEntry>(); //metadata for reply\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t//Iterate over result sets of size maxkeys + 1\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tobjectKey = null;\n\t\t\t\t\t\t\tparts = null;\n\t\t\t\t\t\t\tprefixString = null;\n\t\t\t\t\t\t\tif(resultKeyCount > 0) { //Start from end of last round-trip if necessary\n\t\t\t\t\t\t\t\tobjCriteria.setFirstResult(queryStrideSize);\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tobjectInfos = (List<ObjectInfo>)objCriteria.list();\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (objectInfos.size() > 0) {\n\t\t\t\t\t\t\t\tfor (ObjectInfo objectInfo : objectInfos) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tobjectKey = objectInfo.getObjectKey();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t//Check if it will get aggregated as a commonprefix\n\t\t\t\t\t\t\t\t\tif (delimiter != null) {\n\t\t\t\t\t\t\t\t\t\tparts = objectKey.substring(prefix.length()).split(delimiter);\n\t\t\t\t\t\t\t\t\t\tif (parts.length > 1) {\n\t\t\t\t\t\t\t\t\t\t\tprefixString = parts[0] + delimiter;\n\t\t\t\t\t\t\t\t\t\t\tif(!prefixes.containsKey(prefixString)) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(resultKeyCount == maxKeys) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t//This is a new record, so we know we're truncating if this is true\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setNextMarker(objectKey);\n\t\t\t\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\tresultKeyCount++;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tprefixes.put(prefixString, new PrefixEntry(prefixString));\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tresultKeyCount++; //count the unique commonprefix as a single return entry\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(resultKeyCount == maxKeys) {\n\t\t\t\t\t\t\t\t\t\t//This is a new (non-commonprefix) record, so we know we're truncating\n\t\t\t\t\t\t\t\t\t\treply.setNextMarker(objectKey);\n\t\t\t\t\t\t\t\t\t\treply.setIsTruncated(true);\n\t\t\t\t\t\t\t\t\t\tresultKeyCount++;\n\t\t\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t//Process the entry as a full key listing\n\t\t\t\t\t\t\t\t\tListEntry listEntry = new ListEntry();\n\t\t\t\t\t\t\t\t\tlistEntry.setKey(objectKey);\n\t\t\t\t\t\t\t\t\tlistEntry.setEtag(objectInfo.getEtag());\n\t\t\t\t\t\t\t\t\tlistEntry.setLastModified(DateUtils.format(objectInfo\n\t\t\t\t\t\t\t\t\t\t\t.getLastModified().getTime(),\n\t\t\t\t\t\t\t\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t\t\t\t\t\t\t\t+ \".000Z\");\n\t\t\t\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\n\t\t\t\t\t\t\t\t\ttry {\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tlistEntry.setOwner(new CanonicalUserType(objectInfo.getOwnerId(), Accounts.lookupAccountById(objectInfo.getOwnerId()).getName()));\n\t\t\t\t\t\t\t\t\t} catch (AuthException e) {\n\t\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tobjectInfo.returnMetaData(metaData);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tlistEntry.setSize(objectInfo.getSize());\n\t\t\t\t\t\t\t\t\tlistEntry.setStorageClass(objectInfo.getStorageClass());\n\t\t\t\t\t\t\t\t\tcontents.add(listEntry);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tresultKeyCount++;\n\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\n\n\t\t\t\t\t\t\tif(resultKeyCount <= maxKeys && objectInfos.size() <= maxKeys) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while(resultKeyCount <= maxKeys);\n\t\t\t\t\t\t\n\t\t\t\t\t\treply.setMetaData(metaData);\n\t\t\t\t\t\treply.setContents(contents);\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t//Sort the prefixes from the hashtable and add to the reply\n\t\t\t\t\t\tif (prefixes != null && prefixes.size() > 0) {\n\t\t\t\t\t\t\tArrayList<PrefixEntry> prefixList = new ArrayList<PrefixEntry>();\n\t\t\t\t\t\t\tprefixList.addAll(prefixes.values());\n\n\t\t\t\t\t\t\tCollections.sort(prefixList, new Comparator<PrefixEntry>() {\n\t\t\t\t\t\t\t\tpublic int compare(PrefixEntry e1, PrefixEntry e2) {\n\t\t\t\t\t\t\t\t\treturn e1.getPrefix().compareTo(e2.getPrefix());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\treply.setCommonPrefixes(prefixList);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"45aae5fedf670f0fbe49b4a867c3bcf67f03bcab","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private String printChanges(final Collection<Change> changes) {\n    final StringBuilder sb = new StringBuilder(\"Changes: \");\n    for (Change change : changes) {\n      sb.append(\"'\").append(change.getAfterRevision().getFile().getIOFile().getAbsolutePath()).append(\"' | \");\n    }\n    return sb.toString();\n  }","id":28956,"modified_method":"private String printChanges(final Collection<Change> changes) {\n    final StringBuilder sb = new StringBuilder(\"Changes: \");\n    for (Change change : changes) {\n      final ContentRevision cr = change.getAfterRevision() == null ? change.getBeforeRevision() : change.getAfterRevision();\n      sb.append(\"'\").append(cr.getFile().getIOFile().getAbsolutePath()).append(\"' | \");\n    }\n    return sb.toString();\n  }","commit_id":"40b92b3fb1c2642dc534c0032d1e59f8680609ec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean canExecute(Collection<Change> changes, String commitMessage) {\n      if (!myFileNameInitialized) {\n        if (PATCH_PATH == \"\") {\n          PATCH_PATH = myProject.getBaseDir().getPresentableUrl();\n        }\n        myPanel.setFileName(ShelveChangesManager.suggestPatchName(commitMessage, new File(PATCH_PATH)));\n        myFileNameInitialized = true;\n      }\n      return true;\n    }","id":28957,"modified_method":"public boolean canExecute(Collection<Change> changes, String commitMessage) {\n      if (!myFileNameInitialized) {\n        if (PATCH_PATH == \"\") {\n          PATCH_PATH = myProject.getBaseDir().getPresentableUrl();\n        }\n        myPanel.setFileName(ShelveChangesManager.suggestPatchName(commitMessage, new File(PATCH_PATH)));\n        myPanel.setReversePatch(REVERSE_PATCH);\n        myFileNameInitialized = true;\n      }\n      return true;\n    }","commit_id":"57b87201461dc2725fd704df8d27650fd2cb6bbe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void execute(Collection<Change> changes, String commitMessage) {\n      int binaryCount = 0;\n      for(Change change: changes) {\n        if (change.getBeforeRevision() instanceof BinaryContentRevision ||\n            change.getAfterRevision() instanceof BinaryContentRevision) {\n          binaryCount++;\n        }\n      }\n      if (binaryCount == changes.size()) {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            Messages.showInfoMessage(myProject, VcsBundle.message(\"create.patch.all.binary\"),\n                                     VcsBundle.message(\"create.patch.commit.action.title\"));\n          }\n        });\n        return;\n      }\n      try {\n        final String fileName = myPanel.getFileName();\n        final File file = new File(fileName).getAbsoluteFile();\n        PATCH_PATH = file.getParent();\n        Writer writer = new OutputStreamWriter(new FileOutputStream(fileName));\n        try {\n          List<FilePatch> patches = PatchBuilder.buildPatch(changes, myProject.getBaseDir().getPresentableUrl(), false);\n          UnifiedDiffWriter.write(patches, writer);\n        }\n        finally {\n          writer.close();\n        }\n        if (binaryCount == 0) {\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            public void run() {\n              Messages.showInfoMessage(myProject, VcsBundle.message(\"create.patch.success.confirmation\", file.getPath()),\n                                       VcsBundle.message(\"create.patch.commit.action.title\"));\n            }\n          });\n        }\n        else {\n          final int binaryCount1 = binaryCount;\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            public void run() {\n              Messages.showInfoMessage(myProject, VcsBundle.message(\"create.patch.partial.success.confirmation\", file.getPath(),\n                                                                    binaryCount1),\n                                       VcsBundle.message(\"create.patch.commit.action.title\"));\n            }\n          });\n        }\n      }\n      catch (final Exception ex) {\n        LOG.info(ex);\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", ex.getMessage()), CommonBundle.getErrorTitle());\n          }\n        });\n      }\n    }","id":28958,"modified_method":"public void execute(Collection<Change> changes, String commitMessage) {\n      int binaryCount = 0;\n      for(Change change: changes) {\n        if (change.getBeforeRevision() instanceof BinaryContentRevision ||\n            change.getAfterRevision() instanceof BinaryContentRevision) {\n          binaryCount++;\n        }\n      }\n      if (binaryCount == changes.size()) {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            Messages.showInfoMessage(myProject, VcsBundle.message(\"create.patch.all.binary\"),\n                                     VcsBundle.message(\"create.patch.commit.action.title\"));\n          }\n        });\n        return;\n      }\n      try {\n        final String fileName = myPanel.getFileName();\n        final File file = new File(fileName).getAbsoluteFile();\n        PATCH_PATH = file.getParent();\n        REVERSE_PATCH = myPanel.isReversePatch();\n        Writer writer = new OutputStreamWriter(new FileOutputStream(fileName));\n        try {\n          List<FilePatch> patches = PatchBuilder.buildPatch(changes, myProject.getBaseDir().getPresentableUrl(), false, REVERSE_PATCH);\n          UnifiedDiffWriter.write(patches, writer);\n        }\n        finally {\n          writer.close();\n        }\n        if (binaryCount == 0) {\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            public void run() {\n              Messages.showInfoMessage(myProject, VcsBundle.message(\"create.patch.success.confirmation\", file.getPath()),\n                                       VcsBundle.message(\"create.patch.commit.action.title\"));\n            }\n          });\n        }\n        else {\n          final int binaryCount1 = binaryCount;\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            public void run() {\n              Messages.showInfoMessage(myProject, VcsBundle.message(\"create.patch.partial.success.confirmation\", file.getPath(),\n                                                                    binaryCount1),\n                                       VcsBundle.message(\"create.patch.commit.action.title\"));\n            }\n          });\n        }\n      }\n      catch (final Exception ex) {\n        LOG.info(ex);\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", ex.getMessage()), CommonBundle.getErrorTitle());\n          }\n        });\n      }\n    }","commit_id":"57b87201461dc2725fd704df8d27650fd2cb6bbe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String getRevisionName(final ContentRevision revision, final File ioFile) {\n    String revisionName = revision.getRevisionNumber().asString();\n    if (revisionName.length() > 0) {\n      return \"(revision \" + revisionName + \")\";\n    }\n    return new Date(ioFile.lastModified()).toString();\n  }","id":28959,"modified_method":"private static String getRevisionName(final ContentRevision revision, final File ioFile) {\n    String revisionName = revision.getRevisionNumber().asString();\n    if (revisionName.length() > 0) {\n      return MessageFormat.format(REVISION_NAME_TEMPLATE, revisionName);\n    }\n    return new Date(ioFile.lastModified()).toString();\n  }","commit_id":"57b87201461dc2725fd704df8d27650fd2cb6bbe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<FilePatch> buildPatch(final Collection<Change> changes, final String basePath, final boolean allowRename) throws VcsException {\n    List<FilePatch> result = new ArrayList<FilePatch>();\n    for(Change c: changes) {\n      final ContentRevision beforeRevision = c.getBeforeRevision();\n      final ContentRevision afterRevision = c.getAfterRevision();\n      if (beforeRevision instanceof BinaryContentRevision || afterRevision instanceof BinaryContentRevision) {\n        continue;\n      }\n\n      if (beforeRevision != null && beforeRevision.getFile().isDirectory()) {\n        continue;\n      }\n      if (afterRevision != null && afterRevision.getFile().isDirectory()) {\n        continue;\n      }\n\n      if (beforeRevision == null) {\n        result.add(buildAddedFile(basePath, afterRevision));\n        continue;\n      }\n      if (afterRevision == null) {\n        result.add(buildDeletedFile(basePath, beforeRevision));\n        continue;\n      }\n\n      if (!allowRename && !beforeRevision.getFile().equals(afterRevision.getFile())) {\n        result.add(buildDeletedFile(basePath, beforeRevision));\n        result.add(buildAddedFile(basePath, afterRevision));\n        continue;\n      }\n\n      final String beforeContent = beforeRevision.getContent();\n      if (beforeContent == null) {\n        throw new VcsException(\"Failed to fetch old content for changed file \" + beforeRevision.getFile().getPath());\n      }\n      final String afterContent = afterRevision.getContent();\n      if (afterContent == null) {\n        throw new VcsException(\"Failed to fetch new content for changed file \" + afterRevision.getFile().getPath());\n      }\n      String[] beforeLines = DiffUtil.convertToLines(beforeContent);\n      String[] afterLines = DiffUtil.convertToLines(afterContent);\n\n      DiffFragment[] woFormattingBlocks = DiffPolicy.LINES_WO_FORMATTING.buildFragments(beforeContent, afterContent);\n      DiffFragment[] step1lineFragments = new DiffCorrection.TrueLineBlocks(ComparisonPolicy.DEFAULT).correctAndNormalize(woFormattingBlocks);\n      ArrayList<LineFragment> fragments = new DiffFragmentsProcessor().process(step1lineFragments);\n\n      if (fragments.size() > 1) {\n        FilePatch patch = buildPatchHeading(basePath, beforeRevision, afterRevision);\n        result.add(patch);\n\n        int lastLine1 = 0;\n        int lastLine2 = 0;\n\n        while(fragments.size() > 0) {\n          List<LineFragment> adjacentFragments = getAdjacentFragments(fragments);\n          if (adjacentFragments.size() > 0) {\n            LineFragment first = adjacentFragments.get(0);\n            LineFragment last = adjacentFragments.get(adjacentFragments.size()-1);\n\n            final int start1 = first.getStartingLine1();\n            final int start2 = first.getStartingLine2();\n            final int end1 = last.getStartingLine1() + last.getModifiedLines1();\n            final int end2 = last.getStartingLine2() + last.getModifiedLines2();\n            int contextStart1 = Math.max(start1 - CONTEXT_LINES, lastLine1);\n            int contextStart2 = Math.max(start2 - CONTEXT_LINES, lastLine2);\n            int contextEnd1 = Math.min(end1 + CONTEXT_LINES, beforeLines.length);\n            int contextEnd2 = Math.min(end2 + CONTEXT_LINES, afterLines.length);\n\n            PatchHunk hunk = new PatchHunk(contextStart1, contextEnd1, contextStart2, contextEnd2);\n            patch.addHunk(hunk);\n\n            for(LineFragment fragment: adjacentFragments) {\n              for(int i=contextStart1; i<fragment.getStartingLine1(); i++) {\n                hunk.addLine(new PatchLine(PatchLine.Type.CONTEXT, beforeLines [i]));\n              }\n              for(int i=fragment.getStartingLine1(); i<fragment.getStartingLine1()+fragment.getModifiedLines1(); i++) {\n                addLineToHunk(hunk, beforeLines [i], PatchLine.Type.REMOVE);\n              }\n              for(int i=fragment.getStartingLine2(); i<fragment.getStartingLine2()+fragment.getModifiedLines2(); i++) {\n                addLineToHunk(hunk, afterLines[i], PatchLine.Type.ADD);\n              }\n              contextStart1 = fragment.getStartingLine1()+fragment.getModifiedLines1();\n            }\n            for(int i=contextStart1; i<contextEnd1; i++) {\n              hunk.addLine(new PatchLine(PatchLine.Type.CONTEXT, beforeLines [i]));\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }","id":28960,"modified_method":"public static List<FilePatch> buildPatch(final Collection<Change> changes, final String basePath, final boolean allowRename,\n                                           final boolean reversePatch) throws VcsException {\n    List<FilePatch> result = new ArrayList<FilePatch>();\n    for(Change c: changes) {\n      final ContentRevision beforeRevision;\n      final ContentRevision afterRevision;\n      if (reversePatch) {\n        beforeRevision = c.getAfterRevision();\n        afterRevision = c.getBeforeRevision();\n      }\n      else {\n        beforeRevision = c.getBeforeRevision();\n        afterRevision = c.getAfterRevision();\n      }\n      if (beforeRevision instanceof BinaryContentRevision || afterRevision instanceof BinaryContentRevision) {\n        continue;\n      }\n\n      if (beforeRevision != null && beforeRevision.getFile().isDirectory()) {\n        continue;\n      }\n      if (afterRevision != null && afterRevision.getFile().isDirectory()) {\n        continue;\n      }\n\n      if (beforeRevision == null) {\n        result.add(buildAddedFile(basePath, afterRevision));\n        continue;\n      }\n      if (afterRevision == null) {\n        result.add(buildDeletedFile(basePath, beforeRevision));\n        continue;\n      }\n\n      if (!allowRename && !beforeRevision.getFile().equals(afterRevision.getFile())) {\n        result.add(buildDeletedFile(basePath, beforeRevision));\n        result.add(buildAddedFile(basePath, afterRevision));\n        continue;\n      }\n\n      final String beforeContent = beforeRevision.getContent();\n      if (beforeContent == null) {\n        throw new VcsException(\"Failed to fetch old content for changed file \" + beforeRevision.getFile().getPath());\n      }\n      final String afterContent = afterRevision.getContent();\n      if (afterContent == null) {\n        throw new VcsException(\"Failed to fetch new content for changed file \" + afterRevision.getFile().getPath());\n      }\n      String[] beforeLines = DiffUtil.convertToLines(beforeContent);\n      String[] afterLines = DiffUtil.convertToLines(afterContent);\n\n      DiffFragment[] woFormattingBlocks = DiffPolicy.LINES_WO_FORMATTING.buildFragments(beforeContent, afterContent);\n      DiffFragment[] step1lineFragments = new DiffCorrection.TrueLineBlocks(ComparisonPolicy.DEFAULT).correctAndNormalize(woFormattingBlocks);\n      ArrayList<LineFragment> fragments = new DiffFragmentsProcessor().process(step1lineFragments);\n\n      if (fragments.size() > 1) {\n        FilePatch patch = buildPatchHeading(basePath, beforeRevision, afterRevision);\n        result.add(patch);\n\n        int lastLine1 = 0;\n        int lastLine2 = 0;\n\n        while(fragments.size() > 0) {\n          List<LineFragment> adjacentFragments = getAdjacentFragments(fragments);\n          if (adjacentFragments.size() > 0) {\n            LineFragment first = adjacentFragments.get(0);\n            LineFragment last = adjacentFragments.get(adjacentFragments.size()-1);\n\n            final int start1 = first.getStartingLine1();\n            final int start2 = first.getStartingLine2();\n            final int end1 = last.getStartingLine1() + last.getModifiedLines1();\n            final int end2 = last.getStartingLine2() + last.getModifiedLines2();\n            int contextStart1 = Math.max(start1 - CONTEXT_LINES, lastLine1);\n            int contextStart2 = Math.max(start2 - CONTEXT_LINES, lastLine2);\n            int contextEnd1 = Math.min(end1 + CONTEXT_LINES, beforeLines.length);\n            int contextEnd2 = Math.min(end2 + CONTEXT_LINES, afterLines.length);\n\n            PatchHunk hunk = new PatchHunk(contextStart1, contextEnd1, contextStart2, contextEnd2);\n            patch.addHunk(hunk);\n\n            for(LineFragment fragment: adjacentFragments) {\n              for(int i=contextStart1; i<fragment.getStartingLine1(); i++) {\n                hunk.addLine(new PatchLine(PatchLine.Type.CONTEXT, beforeLines [i]));\n              }\n              for(int i=fragment.getStartingLine1(); i<fragment.getStartingLine1()+fragment.getModifiedLines1(); i++) {\n                addLineToHunk(hunk, beforeLines [i], PatchLine.Type.REMOVE);\n              }\n              for(int i=fragment.getStartingLine2(); i<fragment.getStartingLine2()+fragment.getModifiedLines2(); i++) {\n                addLineToHunk(hunk, afterLines[i], PatchLine.Type.ADD);\n              }\n              contextStart1 = fragment.getStartingLine1()+fragment.getModifiedLines1();\n            }\n            for(int i=contextStart1; i<contextEnd1; i++) {\n              hunk.addLine(new PatchLine(PatchLine.Type.CONTEXT, beforeLines [i]));\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }","commit_id":"57b87201461dc2725fd704df8d27650fd2cb6bbe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ShelvedChangeList shelveChanges(final Collection<Change> changes, final String commitMessage) throws IOException, VcsException {\n    final List<Change> textChanges = new ArrayList<Change>();\n    final List<ShelvedBinaryFile> binaryFiles = new ArrayList<ShelvedBinaryFile>();\n    for(Change change: changes) {\n      if (ChangesUtil.getFilePath(change).isDirectory()) {\n        continue;\n      }\n      if (change.getBeforeRevision() instanceof BinaryContentRevision || change.getAfterRevision() instanceof BinaryContentRevision) {\n        binaryFiles.add(shelveBinaryFile(change));\n      }\n      else {\n        textChanges.add(change);\n      }\n    }\n\n    File patchPath = getPatchPath(commitMessage);\n    Writer writer;\n    try {\n      writer = new OutputStreamWriter(new FileOutputStream(patchPath));\n    }\n    catch(IOException ex) {\n      patchPath = getPatchPath(\"shelved_change\");\n      writer = new OutputStreamWriter(new FileOutputStream(patchPath));\n    }\n    try {\n      List<FilePatch> patches = PatchBuilder.buildPatch(textChanges, myProject.getBaseDir().getPresentableUrl(), true);\n      UnifiedDiffWriter.write(patches, writer);\n    }\n    finally {\n      writer.close();\n    }\n\n    RollbackChangesDialog.doRollback(myProject, changes, true, false);\n\n    final ShelvedChangeList changeList = new ShelvedChangeList(patchPath.toString(), commitMessage.replace('\\n', ' '), binaryFiles);\n    myShelvedChangeLists.add(changeList);\n    notifyStateChanged();\n    return changeList;\n  }","id":28961,"modified_method":"public ShelvedChangeList shelveChanges(final Collection<Change> changes, final String commitMessage) throws IOException, VcsException {\n    final List<Change> textChanges = new ArrayList<Change>();\n    final List<ShelvedBinaryFile> binaryFiles = new ArrayList<ShelvedBinaryFile>();\n    for(Change change: changes) {\n      if (ChangesUtil.getFilePath(change).isDirectory()) {\n        continue;\n      }\n      if (change.getBeforeRevision() instanceof BinaryContentRevision || change.getAfterRevision() instanceof BinaryContentRevision) {\n        binaryFiles.add(shelveBinaryFile(change));\n      }\n      else {\n        textChanges.add(change);\n      }\n    }\n\n    File patchPath = getPatchPath(commitMessage);\n    Writer writer;\n    try {\n      writer = new OutputStreamWriter(new FileOutputStream(patchPath));\n    }\n    catch(IOException ex) {\n      patchPath = getPatchPath(\"shelved_change\");\n      writer = new OutputStreamWriter(new FileOutputStream(patchPath));\n    }\n    try {\n      List<FilePatch> patches = PatchBuilder.buildPatch(textChanges, myProject.getBaseDir().getPresentableUrl(), true, false);\n      UnifiedDiffWriter.write(patches, writer);\n    }\n    finally {\n      writer.close();\n    }\n\n    RollbackChangesDialog.doRollback(myProject, changes, true, false);\n\n    final ShelvedChangeList changeList = new ShelvedChangeList(patchPath.toString(), commitMessage.replace('\\n', ' '), binaryFiles);\n    myShelvedChangeLists.add(changeList);\n    notifyStateChanged();\n    return changeList;\n  }","commit_id":"57b87201461dc2725fd704df8d27650fd2cb6bbe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void updateChangesImpl(final List<Change> changes, final ChangeWrapper wrapper) {\n    // approx so ok\n    final ProgressIndicator pi = ProgressManager.getInstance().getProgressIndicator();\n    if (pi != null) {\n      pi.setIndeterminate(false);\n    }\n    final double num = changes.size();\n\n    int cnt = 0;\n    final FilesForRefresh filesForRefresh = new FilesForRefresh();\n    for (Change change : changes) {\n      if ((! wrapper.beforeNull(change)) && (wrapper.movedOrRenamedOrReplaced(change) || (wrapper.afterNull(change)))) {\n        refreshDeletedOrReplaced(wrapper.getBeforeFile(change));\n      } else if (! wrapper.beforeNull(change)) {\n        refresh(wrapper.getBeforeFile(change));\n      }\n      if ((! wrapper.afterNull(change)) && (! Comparing.equal(change.getAfterRevision(), change.getBeforeRevision()))) {\n        refreshDeletedOrReplaced(wrapper.getAfterFile(change));\n      }\n      if (pi != null) {\n        ++ cnt;\n        pi.setFraction(cnt/num);\n        pi.setText2(\"Refreshing: \" + change.toString());\n      }\n    }\n  }","id":28962,"modified_method":"private static void updateChangesImpl(final List<Change> changes, final ChangeWrapper wrapper) {\n    // approx so ok\n    final ProgressIndicator pi = ProgressManager.getInstance().getProgressIndicator();\n    if (pi != null) {\n      pi.setIndeterminate(false);\n    }\n    final double num = changes.size();\n\n    int cnt = 0;\n    final FilesForRefresh filesForRefresh = new FilesForRefresh();\n    for (Change change : changes) {\n      if ((! wrapper.beforeNull(change)) && (wrapper.movedOrRenamedOrReplaced(change) || (wrapper.afterNull(change)))) {\n        refreshDeletedOrReplaced(wrapper.getBeforeFile(change));\n      } else if (! wrapper.beforeNull(change)) {\n        refresh(wrapper.getBeforeFile(change));\n      }\n      if ((! wrapper.afterNull(change)) && \n          (wrapper.beforeNull(change) || (! Comparing.equal(change.getAfterRevision().getFile(), change.getBeforeRevision().getFile())))\n         ) {\n        refresh(wrapper.getAfterFile(change));\n      }\n      if (pi != null) {\n        ++ cnt;\n        pi.setFraction(cnt/num);\n        pi.setText2(\"Refreshing: \" + change.toString());\n      }\n    }\n  }","commit_id":"f4ac85411f3e08d490db15a892cf03c3fc91f51a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrVariableDeclaration createSimpleVariableDeclaration(String name, String typeText) {\n    String classText;\n    if (Character.isLowerCase(typeText.charAt(0))) {\n      classText = \"class A { def \" + typeText + \" \" + name + \"}\";\n    } else {\n      classText = \"class A { \" + typeText + \" \" + name + \"}\";\n    }\n\n    GroovyFileBase file = (GroovyFileBase) createGroovyFile(classText);\n    final GrTypeDefinitionBody body = file.getTypeDefinitions()[0].getBody();\n    return (GrVariableDeclaration) body.getMemberDeclarations()[0];\n  }","id":28963,"modified_method":"public GrVariableDeclaration createSimpleVariableDeclaration(String name, String typeText) {\n    String classText;\n    if (Character.isLowerCase(typeText.charAt(0))) {\n      classText = \"class A { def \" + typeText + \" \" + name + \"}\";\n    } else {\n      classText = \"class A { \" + typeText + \" \" + name + \"}\";\n    }\n\n    GroovyFileBase file = createGroovyFile(classText);\n    final GrTypeDefinitionBody body = file.getTypeDefinitions()[0].getBody();\n    return (GrVariableDeclaration) body.getMemberDeclarations()[0];\n  }","commit_id":"0e4e1031b6aac7345639aecee5aecf78da9d7ba1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public GrVariableDeclaration createFieldDeclarationFromText(String text) {\n    final GroovyFile file = (GroovyFile)createGroovyFile(\"class X{\\n\" + text + \"\\n}\");\n    final PsiClass psiClass = file.getClasses()[0];\n    return (GrVariableDeclaration)psiClass.getFields()[0].getParent();\n  }","id":28964,"modified_method":"@Override\n  public GrVariableDeclaration createFieldDeclarationFromText(String text) {\n    final GroovyFile file = createGroovyFile(\"class X{\\n\" + text + \"\\n}\");\n    final PsiClass psiClass = file.getClasses()[0];\n    return (GrVariableDeclaration)psiClass.getFields()[0].getParent();\n  }","commit_id":"0e4e1031b6aac7345639aecee5aecf78da9d7ba1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrVariableDeclaration createFieldDeclaration(String[] modifiers,\n                                                      String identifier,\n                                                      @Nullable GrExpression initializer,\n                                                      @Nullable PsiType type) {\n    final String varDeclaration = createVariableDeclaration(modifiers, initializer, type, identifier).getText();\n\n    final GroovyFileBase file = (GroovyFileBase) createGroovyFile(\"class A { \" + varDeclaration + \"}\");\n    final GrTypeDefinitionBody body = file.getTypeDefinitions()[0].getBody();\n    LOG.assertTrue(body.getMemberDeclarations().length == 1 && body.getMemberDeclarations()[0] instanceof GrVariableDeclaration,\n                   \"ident = <\" + identifier + \"> initializer = \" + (initializer == null ? \"_null_\" : (\"<\" + initializer.getText()) + \">\"));\n    return (GrVariableDeclaration) body.getMemberDeclarations()[0];\n  }","id":28965,"modified_method":"public GrVariableDeclaration createFieldDeclaration(String[] modifiers,\n                                                      String identifier,\n                                                      @Nullable GrExpression initializer,\n                                                      @Nullable PsiType type) {\n    final String varDeclaration = createVariableDeclaration(modifiers, initializer, type, identifier).getText();\n\n    final GroovyFileBase file = createGroovyFile(\"class A { \" + varDeclaration + \"}\");\n    final GrTypeDefinitionBody body = file.getTypeDefinitions()[0].getBody();\n    LOG.assertTrue(body.getMemberDeclarations().length == 1 && body.getMemberDeclarations()[0] instanceof GrVariableDeclaration,\n                   \"ident = <\" + identifier + \"> initializer = \" + (initializer == null ? \"_null_\" : (\"<\" + initializer.getText()) + \">\"));\n    return (GrVariableDeclaration) body.getMemberDeclarations()[0];\n  }","commit_id":"0e4e1031b6aac7345639aecee5aecf78da9d7ba1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public GrEnumConstant createEnumConstantFromText(String text) {\n    GroovyFile file = (GroovyFile)createGroovyFile(\"enum E{\" + text + \"}\");\n    final GrEnumTypeDefinition enumClass = (GrEnumTypeDefinition)file.getClasses()[0];\n    return enumClass.getEnumConstants()[0];\n  }","id":28966,"modified_method":"@Override\n  public GrEnumConstant createEnumConstantFromText(String text) {\n    GroovyFile file = createGroovyFile(\"enum E{\" + text + \"}\");\n    final GrEnumTypeDefinition enumClass = (GrEnumTypeDefinition)file.getClasses()[0];\n    return enumClass.getEnumConstants()[0];\n  }","commit_id":"0e4e1031b6aac7345639aecee5aecf78da9d7ba1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrVariableDeclaration createVariableDeclaration(@Nullable String[] modifiers,\n                                                         @Nullable GrExpression initializer,\n                                                         @Nullable PsiType type,\n                                                         String... identifiers) {\n    StringBuilder text = writeModifiers(modifiers);\n\n    if (type != null) {\n      final PsiType unboxed = TypesUtil.unboxPrimitiveTypeWrapper(type);\n      final String typeText = getTypeText(unboxed);\n      text.append(typeText).append(\" \");\n    } else if (text.length() == 0) {\n      text.insert(0, \"def \");\n    }\n\n    if (identifiers.length > 1 && initializer != null) {\n      text.append('(');\n    }\n    for (int i = 0; i < identifiers.length; i++) {\n      if (i > 0) text.append(\", \");\n      String identifier = identifiers[i];\n      text.append(identifier);\n    }\n\n    if (identifiers.length > 1 && initializer != null) {\n      text.append(')');\n    }\n\n    if (initializer != null) {\n      if (initializer instanceof GrApplicationStatement &&\n          !GroovyConfigUtils.getInstance().isVersionAtLeast(initializer, GroovyConfigUtils.GROOVY1_8, false)) {\n        initializer = createMethodCallByAppCall((GrApplicationStatement)initializer);\n      }\n      assert initializer != null;\n      text.append(\" = \").append(initializer.getText());\n    }\n\n    GrTopStatement[] topStatements = ((GroovyFileBase)createGroovyFile(text.toString())).getTopStatements();\n    if (topStatements.length == 0 || !(topStatements[0] instanceof GrVariableDeclaration)) {\n      topStatements = ((GroovyFileBase)createGroovyFile(\"def \" + text)).getTopStatements();\n    }\n    if (topStatements.length == 0 || !(topStatements[0] instanceof GrVariableDeclaration)) {\n      throw new RuntimeException(\"Invalid arguments, text = \" + text);\n    }\n\n    final GrVariableDeclaration statement = (GrVariableDeclaration)topStatements[0];\n    //todo switch-case formatting should work without this hack\n    CodeEditUtil.markToReformatBefore(statement.getNode().findLeafElementAt(0), true);\n    return statement;\n  }","id":28967,"modified_method":"public GrVariableDeclaration createVariableDeclaration(@Nullable String[] modifiers,\n                                                         @Nullable GrExpression initializer,\n                                                         @Nullable PsiType type,\n                                                         String... identifiers) {\n    StringBuilder text = writeModifiers(modifiers);\n\n    if (type != null) {\n      final PsiType unboxed = TypesUtil.unboxPrimitiveTypeWrapper(type);\n      final String typeText = getTypeText(unboxed);\n      text.append(typeText).append(\" \");\n    } else if (text.length() == 0) {\n      text.insert(0, \"def \");\n    }\n\n    if (identifiers.length > 1 && initializer != null) {\n      text.append('(');\n    }\n    for (int i = 0; i < identifiers.length; i++) {\n      if (i > 0) text.append(\", \");\n      String identifier = identifiers[i];\n      text.append(identifier);\n    }\n\n    if (identifiers.length > 1 && initializer != null) {\n      text.append(')');\n    }\n\n    if (initializer != null) {\n      if (initializer instanceof GrApplicationStatement &&\n          !GroovyConfigUtils.getInstance().isVersionAtLeast(initializer, GroovyConfigUtils.GROOVY1_8, false)) {\n        initializer = createMethodCallByAppCall((GrApplicationStatement)initializer);\n      }\n      assert initializer != null;\n      text.append(\" = \").append(initializer.getText());\n    }\n\n    GrTopStatement[] topStatements = createGroovyFile(text.toString()).getTopStatements();\n    if (topStatements.length == 0 || !(topStatements[0] instanceof GrVariableDeclaration)) {\n      topStatements = createGroovyFile(\"def \" + text).getTopStatements();\n    }\n    if (topStatements.length == 0 || !(topStatements[0] instanceof GrVariableDeclaration)) {\n      throw new RuntimeException(\"Invalid arguments, text = \" + text);\n    }\n\n    final GrVariableDeclaration statement = (GrVariableDeclaration)topStatements[0];\n    //todo switch-case formatting should work without this hack\n    CodeEditUtil.markToReformatBefore(statement.getNode().findLeafElementAt(0), true);\n    return statement;\n  }","commit_id":"0e4e1031b6aac7345639aecee5aecf78da9d7ba1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void showView(MainView viewToShow)\n   {\n      if (currentView != viewToShow)\n      {\n         if (currentView == MainView.Editor)\n         {\n            translationPresenter.saveEditorPendingChange();\n         }\n\n         switch (viewToShow)\n         {\n         case Editor:\n            if (selectedDocument != null)\n            {\n               display.setDocumentLabel(selectedDocument.getPath(), selectedDocument.getName());\n            }\n            currentDisplayStats = selectedDocumentStats;\n            break;\n         case Search:\n            display.setDocumentLabel(\"\", messages.projectWideSearchAndReplace());\n            currentDisplayStats = projectStats;\n            break;\n         case Documents:\n            layoutSelectorPresenter.show();\n         default:\n            display.setDocumentLabel(\"\", messages.noDocumentSelected());\n            currentDisplayStats = projectStats;\n            break;\n         }\n         display.showInMainView(viewToShow);\n         currentView = viewToShow;\n         refreshStatsDisplay();\n      }\n   }","id":28968,"modified_method":"private void showView(MainView viewToShow)\n   {\n      if (currentView != viewToShow)\n      {\n         if (currentView == MainView.Editor)\n         {\n            translationPresenter.saveEditorPendingChange();\n         }\n\n         switch (viewToShow)\n         {\n         case Editor:\n            if (selectedDocument != null)\n            {\n               display.setDocumentLabel(selectedDocument.getPath(), selectedDocument.getName());\n            }\n            currentDisplayStats = selectedDocumentStats;\n            break;\n         case Search:\n            display.setDocumentLabel(\"\", messages.projectWideSearchAndReplace());\n            currentDisplayStats = projectStats;\n            break;\n         case Documents:\n            break;\n         default:\n            display.setDocumentLabel(\"\", messages.noDocumentSelected());\n            currentDisplayStats = projectStats;\n            break;\n         }\n         display.showInMainView(viewToShow);\n         currentView = viewToShow;\n         refreshStatsDisplay();\n      }\n   }","commit_id":"7253a35181dd239052a573d3dae9678a0bd3c749","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   protected void onBind()\n   {\n      documentListPresenter.bind();\n      translationPresenter.bind();\n      searchResultsPresenter.bind();\n      notificationPresenter.bind();\n      layoutSelectorPresenter.bind();\n\n      notificationPresenter.setErrorLabelListener(this);\n\n      registerHandler(eventBus.addHandler(WorkspaceContextUpdateEvent.getType(), new WorkspaceContextUpdateEventHandler()\n      {\n\n         @Override\n         public void onWorkspaceContextUpdated(WorkspaceContextUpdateEvent event)\n         {\n            display.setReadOnlyVisible(event.isReadOnly());\n         }\n      }));\n\n      setErrorNotificationLabel(notificationPresenter.getMessageCount());\n\n      registerHandler(eventBus.addHandler(NotificationEvent.getType(), new NotificationEventHandler()\n      {\n         @Override\n         public void onNotification(NotificationEvent event)\n         {\n            // See NotificationPresenter for Severity.Error message\n            if (event.getSeverity() != Severity.Error)\n            {\n               display.setNotificationMessage(event.getMessage(), event.getSeverity());\n               display.getDismissVisibility().setVisible(true);\n               Log.info(\"Notification:\" + event.getMessage());\n            }\n            else\n            {\n               setErrorNotificationLabel(notificationPresenter.getMessageCount());\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(DocumentStatsUpdatedEvent.getType(), new DocumentStatsUpdatedEventHandler()\n      {\n\n         @Override\n         public void onDocumentStatsUpdated(DocumentStatsUpdatedEvent event)\n         {\n            if (selectedDocument != null && event.getDocId().equals(selectedDocument.getId()))\n            {\n               selectedDocumentStats.set(event.getNewStats());\n               if (currentView.equals(MainView.Editor))\n               {\n                  refreshStatsDisplay();\n               }\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(ProjectStatsUpdatedEvent.getType(), new ProjectStatsUpdatedEventHandler()\n      {\n\n         @Override\n         public void onProjectStatsRetrieved(ProjectStatsUpdatedEvent event)\n         {\n            projectStats.set(event.getProjectStats());\n            if (currentView.equals(MainView.Documents))\n            {\n               refreshStatsDisplay();\n            }\n         }\n      }));\n\n      registerHandler(display.getDismiss().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            display.setNotificationMessage(\"\", NotificationEvent.Severity.Info);\n            display.getDismissVisibility().setVisible(false);\n         }\n      }));\n\n      display.getDismissVisibility().setVisible(false);\n\n      registerHandler(display.getDocumentsLink().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(history.getToken());\n\n            if (token.getView().equals(MainView.Documents))\n            {\n               if (selectedDocument == null)\n               {\n                  return; // abort if no doc to edit\n               }\n               token.setView(MainView.Editor);\n            }\n            else\n            {\n               token.setView(MainView.Documents);\n            }\n            history.newItem(token.toTokenString());\n         }\n      }));\n\n      registerHandler(history.addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            processHistoryEvent(event);\n         }\n      }));\n      \n      registerHandler(display.getErrorNotificationBtn().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            notificationPresenter.showErrorNotification();\n         }\n      }));\n\n      display.getLeaveWorkspaceMenuItem().setCommand(new Command()\n      {\n         @Override\n         public void execute()\n         {\n            // use when opening workspace in new window\n            // Application.closeWindow();\n\n            // use when opening workspace in same window\n            Application.exitWorkspace();\n            Application.redirectToZanataProjectHome(workspaceContext.getWorkspaceId());\n         }\n      });\n\n      display.getHelpMenuItem().setCommand(new Command()\n      {\n         @Override\n         public void execute()\n         {\n            com.google.gwt.user.client.Window.open(messages.hrefHelpLink(), messages.hrefHelpLink(), null);\n         }\n      });\n\n      display.getSignOutMenuItem().setCommand(new Command()\n      {\n         @Override\n         public void execute()\n         {\n            Application.redirectToLogout();\n         }\n      });\n\n      display.getSearchAndReplaceLink().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(history.getToken());\n            if (!token.getView().equals(MainView.Search))\n            {\n               token.setView(MainView.Search);\n               history.newItem(token.toTokenString());\n            }\n         }\n      });\n\n      display.setUserLabel(identity.getPerson().getName());\n      String workspaceTitle = windowLocation.getParameter(WORKSPACE_TITLE_QUERY_PARAMETER_KEY);\n      display.setWorkspaceNameLabel(workspaceContext.getWorkspaceName(), workspaceTitle);\n      window.setTitle(messages.windowTitle(workspaceContext.getWorkspaceName(), workspaceContext.getLocaleName()));\n\n      display.setReadOnlyVisible(workspaceContext.isReadOnly());\n\n      showView(MainView.Documents);\n\n      history.fireCurrentHistoryState();\n   }","id":28969,"modified_method":"@Override\n   protected void onBind()\n   {\n      documentListPresenter.bind();\n      translationPresenter.bind();\n      searchResultsPresenter.bind();\n      notificationPresenter.bind();\n      layoutSelectorPresenter.bind();\n      \n      layoutSelectorPresenter.setLayoutListener(translationPresenter);\n      notificationPresenter.setErrorLabelListener(this);\n\n      registerHandler(eventBus.addHandler(WorkspaceContextUpdateEvent.getType(), new WorkspaceContextUpdateEventHandler()\n      {\n\n         @Override\n         public void onWorkspaceContextUpdated(WorkspaceContextUpdateEvent event)\n         {\n            display.setReadOnlyVisible(event.isReadOnly());\n         }\n      }));\n\n      setErrorNotificationLabel(notificationPresenter.getMessageCount());\n\n      registerHandler(eventBus.addHandler(NotificationEvent.getType(), new NotificationEventHandler()\n      {\n         @Override\n         public void onNotification(NotificationEvent event)\n         {\n            // See NotificationPresenter for Severity.Error message\n            if (event.getSeverity() != Severity.Error)\n            {\n               display.setNotificationMessage(event.getMessage(), event.getSeverity());\n               display.getDismissVisibility().setVisible(true);\n               Log.info(\"Notification:\" + event.getMessage());\n            }\n            else\n            {\n               setErrorNotificationLabel(notificationPresenter.getMessageCount());\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(DocumentStatsUpdatedEvent.getType(), new DocumentStatsUpdatedEventHandler()\n      {\n\n         @Override\n         public void onDocumentStatsUpdated(DocumentStatsUpdatedEvent event)\n         {\n            if (selectedDocument != null && event.getDocId().equals(selectedDocument.getId()))\n            {\n               selectedDocumentStats.set(event.getNewStats());\n               if (currentView.equals(MainView.Editor))\n               {\n                  refreshStatsDisplay();\n               }\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(ProjectStatsUpdatedEvent.getType(), new ProjectStatsUpdatedEventHandler()\n      {\n\n         @Override\n         public void onProjectStatsRetrieved(ProjectStatsUpdatedEvent event)\n         {\n            projectStats.set(event.getProjectStats());\n            if (currentView.equals(MainView.Documents))\n            {\n               refreshStatsDisplay();\n            }\n         }\n      }));\n\n      registerHandler(display.getDismiss().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            display.setNotificationMessage(\"\", NotificationEvent.Severity.Info);\n            display.getDismissVisibility().setVisible(false);\n         }\n      }));\n\n      display.getDismissVisibility().setVisible(false);\n\n      registerHandler(display.getDocumentsLink().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(history.getToken());\n\n            if (token.getView().equals(MainView.Documents))\n            {\n               if (selectedDocument == null)\n               {\n                  return; // abort if no doc to edit\n               }\n               token.setView(MainView.Editor);\n            }\n            else\n            {\n               token.setView(MainView.Documents);\n            }\n            history.newItem(token.toTokenString());\n         }\n      }));\n\n      registerHandler(history.addValueChangeHandler(new ValueChangeHandler<String>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<String> event)\n         {\n            processHistoryEvent(event);\n         }\n      }));\n      \n      registerHandler(display.getErrorNotificationBtn().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            notificationPresenter.showErrorNotification();\n         }\n      }));\n\n      display.getLeaveWorkspaceMenuItem().setCommand(new Command()\n      {\n         @Override\n         public void execute()\n         {\n            // use when opening workspace in new window\n            // Application.closeWindow();\n\n            // use when opening workspace in same window\n            Application.exitWorkspace();\n            Application.redirectToZanataProjectHome(workspaceContext.getWorkspaceId());\n         }\n      });\n\n      display.getHelpMenuItem().setCommand(new Command()\n      {\n         @Override\n         public void execute()\n         {\n            com.google.gwt.user.client.Window.open(messages.hrefHelpLink(), messages.hrefHelpLink(), null);\n         }\n      });\n\n      display.getSignOutMenuItem().setCommand(new Command()\n      {\n         @Override\n         public void execute()\n         {\n            Application.redirectToLogout();\n         }\n      });\n\n      display.getLayoutMenuItem().setCommand(new Command()\n      {\n         @Override\n         public void execute()\n         {\n            layoutSelectorPresenter.show();            \n         }\n      });\n      \n      display.getSearchAndReplaceLink().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            HistoryToken token = HistoryToken.fromTokenString(history.getToken());\n            if (!token.getView().equals(MainView.Search))\n            {\n               token.setView(MainView.Search);\n               history.newItem(token.toTokenString());\n            }\n         }\n      });\n\n      display.setUserLabel(identity.getPerson().getName());\n      String workspaceTitle = windowLocation.getParameter(WORKSPACE_TITLE_QUERY_PARAMETER_KEY);\n      display.setWorkspaceNameLabel(workspaceContext.getWorkspaceName(), workspaceTitle);\n      window.setTitle(messages.windowTitle(workspaceContext.getWorkspaceName(), workspaceContext.getLocaleName()));\n\n      display.setReadOnlyVisible(workspaceContext.isReadOnly());\n\n      showView(MainView.Documents);\n\n      history.fireCurrentHistoryState();\n   }","commit_id":"7253a35181dd239052a573d3dae9678a0bd3c749","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void setUserLabel(String userLabel)\n   {\n      HorizontalPanel userImageAndLabel = new HorizontalPanel();\n      userImageAndLabel.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);\n      userImageAndLabel.add(userImg);\n      \n      Label userNameLabel = new Label(userLabel);\n      userNameLabel.setStyleName(style.userName());\n      userImageAndLabel.add(userNameLabel);\n      Label downArrowLabel = new Label(messages.downArrow());\n      userImageAndLabel.add(downArrowLabel);\n      \n      userImageAndLabel.setCellHorizontalAlignment(downArrowLabel, HasHorizontalAlignment.ALIGN_RIGHT);\n\n      topMenuBar.addItem(userImageAndLabel.getElement().getString(), true, menuBar);\n   }","id":28970,"modified_method":"@Override\n   public void setUserLabel(String userLabel)\n   {\n      ImageLabel userMenu = new ImageLabel(userAvatarUrl, userLabel + \" \" + messages.downArrow());\n      userMenu.setLabelStyle(style.userName());\n      userMenu.setImageStyle(style.image());\n\n      topMenuBar.addItem(userMenu.getElement().getString(), true, menuBar);\n   }","commit_id":"7253a35181dd239052a573d3dae9678a0bd3c749","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n   public AppView(Resources resources, WebTransMessages messages, DocumentListPresenter.Display documentListView, SearchResultsPresenter.Display searchResultsView, TranslationPresenter.Display translationView, final Identity identity)\n   {\n      this.resources = resources;\n      this.messages = messages;\n\n      StyleInjector.inject(resources.style().getText(), true);\n\n      // this must be initialized before uiBinder.createAndBindUi(), or an\n      // exception will be thrown at runtime\n      translationStatsBar = new TransUnitCountBar(messages, true);\n      translationStatsBar.setVisible(false); // hide until there is a value to\n                                             // display\n\n      initWidget(uiBinder.createAndBindUi(this));\n\n      menuBar = new MenuBar(true);\n      helpMenuItem = new MenuCommandItem(messages.help(), emptyCommand);\n      leaveWorkspaceMenuItem = new MenuCommandItem(messages.leaveWorkspace(), emptyCommand);\n      signOutMenuItem = new MenuCommandItem(messages.signOut(), emptyCommand);\n\n      searchAndReplace.setText(messages.searchAndReplace());\n\n      menuBar.addItem(helpMenuItem);\n      menuBar.addSeparator();\n      menuBar.addItem(leaveWorkspaceMenuItem);\n      menuBar.addItem(signOutMenuItem);\n      userImg = new Image(identity.getPerson().getAvatarUrl());\n      userImg.setStyleName(style.image());\n\n      this.documentListView = documentListView.asWidget();\n      this.container.add(this.documentListView);\n\n      this.translationView = translationView.asWidget();\n      this.container.add(this.translationView);\n\n      this.searchResultsView = searchResultsView.asWidget();\n      this.container.add(this.searchResultsView);\n\n      errorNotificationBtn.setTitle(messages.errorNotification());\n\n      Window.enableScrolling(false);\n   }","id":28971,"modified_method":"@Inject\n   public AppView(Resources resources, WebTransMessages messages, DocumentListPresenter.Display documentListView, SearchResultsPresenter.Display searchResultsView, TranslationPresenter.Display translationView, final Identity identity)\n   {\n      this.resources = resources;\n      this.messages = messages;\n\n      StyleInjector.inject(resources.style().getText(), true);\n\n      // this must be initialized before uiBinder.createAndBindUi(), or an\n      // exception will be thrown at runtime\n      translationStatsBar = new TransUnitCountBar(messages, true);\n      translationStatsBar.setVisible(false); // hide until there is a value to\n                                             // display\n\n      initWidget(uiBinder.createAndBindUi(this));\n\n      menuBar = new MenuBar(true);\n      helpMenuItem = new MenuCommandItem(messages.help(), emptyCommand);\n      leaveWorkspaceMenuItem = new MenuCommandItem(messages.leaveWorkspace(), emptyCommand);\n      signOutMenuItem = new MenuCommandItem(messages.signOut(), emptyCommand);\n      layoutMenuItem = new MenuCommandItem(messages.layout(), emptyCommand);\n\n      searchAndReplace.setText(messages.searchAndReplace());\n      \n      \n      menuBar.addItem(helpMenuItem);\n      menuBar.addSeparator();\n      menuBar.addItem(layoutMenuItem);\n      menuBar.addSeparator();\n      menuBar.addItem(leaveWorkspaceMenuItem);\n      menuBar.addItem(signOutMenuItem);\n      \n      userAvatarUrl = identity.getPerson().getAvatarUrl();\n\n      this.documentListView = documentListView.asWidget();\n      this.container.add(this.documentListView);\n\n      this.translationView = translationView.asWidget();\n      this.container.add(this.translationView);\n\n      this.searchResultsView = searchResultsView.asWidget();\n      this.container.add(this.searchResultsView);\n\n      errorNotificationBtn.setTitle(messages.errorNotification());\n\n      Window.enableScrolling(false);\n   }","commit_id":"7253a35181dd239052a573d3dae9678a0bd3c749","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   protected void onBind()\n   {\n      display.showLayoutList(false);\n\n      registerHandler(display.getConfigButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            display.toggleView();\n         }\n      }));\n   }","id":28972,"modified_method":"@Override\n   protected void onBind()\n   {\n      display.hide();\n      \n      registerHandler(display.getDefaultLayoutContainer().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            layoutOrganiser.setSidePanelVisible(true);\n            layoutOrganiser.setSouthPanelVisible(true);\n            display.hide();\n         }\n      }));\n      \n      registerHandler(display.getMaximiseLayoutContainer().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            layoutOrganiser.setSidePanelVisible(false);\n            layoutOrganiser.setSouthPanelVisible(false);\n            display.hide();\n         }\n      }));\n      \n      registerHandler(display.getNoOptionLayoutContainer().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            layoutOrganiser.setSidePanelVisible(false);\n            layoutOrganiser.setSouthPanelVisible(true);\n            display.hide();\n         }\n      }));\n      \n      registerHandler(display.getNoSouthLayoutContainer().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            layoutOrganiser.setSidePanelVisible(true);\n            layoutOrganiser.setSouthPanelVisible(false);\n            display.hide();\n         }\n      }));\n   }","commit_id":"7253a35181dd239052a573d3dae9678a0bd3c749","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void show()\n   {\n      display.show();\n   }","id":28973,"modified_method":"public void show()\n   {\n      display.center();\n   }","commit_id":"7253a35181dd239052a573d3dae9678a0bd3c749","url":"https://github.com/zanata/zanata-server"},{"original_method":"public LayoutSelectorView()\n   {\n      setAutoHideEnabled(false);\n      setAnimationEnabled(false);\n\n      initDefaultLayout();\n      initMaximiseWorkspaceLayout();\n\n      setWidget(uiBinder.createAndBindUi(this));\n\n      this.setStyleName(style.mainPanel());\n\n      configImage.setResource(resources.viewChoose());\n      configImage.addStyleName(\"pointer\");\n   }","id":28974,"modified_method":"public LayoutSelectorView()\n   {\n      setWidget(uiBinder.createAndBindUi(this));\n      \n      setAutoHideEnabled(true);\n      setGlassEnabled(true);\n      \n      setStyleName(style.mainPanel());\n      \n      defaultLayoutContainer.add(initDefaultLayout());\n      maximizeLayoutContainer.add(initMaximiseWorkspaceLayout());\n      noOptionLayoutContainer.add(initNoOptionsWorkspaceLayout());\n      noSouthLayoutContainer.add(initNoSouthWorkspaceLayout());\n   }","commit_id":"7253a35181dd239052a573d3dae9678a0bd3c749","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void initMaximiseWorkspaceLayout()\n   {\n      Label workspaceLabel = new Label(\"\");\n\n      maximizeWorkspaceLayout = new DockPanel();\n      maximizeWorkspaceLayout.add(workspaceLabel, DockPanel.CENTER);\n   }","id":28975,"modified_method":"private DockPanel initMaximiseWorkspaceLayout()\n   {\n      DockPanel maximizeWorkspaceLayout = new DockPanel();\n      maximizeWorkspaceLayout.setStyleName(style.layoutTable());\n      \n      Label workspaceLabel = new Label(\"Workspace\");\n      \n      maximizeWorkspaceLayout.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);\n      maximizeWorkspaceLayout.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);\n      \n      maximizeWorkspaceLayout.add(workspaceLabel, DockPanel.CENTER);\n      \n      return maximizeWorkspaceLayout;\n   }","commit_id":"7253a35181dd239052a573d3dae9678a0bd3c749","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void initDefaultLayout()\n   {\n      Label optionLabel = new Label(\"Options\");\n      Label southLabel = new Label(\"TM/Glossay/Users\");\n      Label workspaceLabel = new Label(\"Workspace\");\n\n      defaultLayout = new DockPanel();\n      defaultLayout.add(southLabel, DockPanel.SOUTH);\n      defaultLayout.add(optionLabel, DockPanel.EAST);\n      defaultLayout.add(workspaceLabel, DockPanel.CENTER);\n\n      defaultLayout.setCellHeight(workspaceLabel, \"55px\");\n      defaultLayout.setCellHeight(optionLabel, \"55px\");\n\n      defaultLayout.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);\n      defaultLayout.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);\n   }","id":28976,"modified_method":"private DockPanel initDefaultLayout()\n   {\n      DockPanel defaultLayout = new DockPanel();\n      defaultLayout.setStyleName(style.layoutTable());\n      \n      Label optionLabel = new Label(\"Options\");\n      Label southLabel = new Label(\"TM/Glossay/Users\");\n      Label workspaceLabel = new Label(\"Workspace\");\n      \n      defaultLayout.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);\n      defaultLayout.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);\n      \n      defaultLayout.add(southLabel, DockPanel.SOUTH);\n      defaultLayout.add(optionLabel, DockPanel.EAST);\n      defaultLayout.add(workspaceLabel, DockPanel.CENTER);\n\n      defaultLayout.setCellHeight(workspaceLabel, NORTH_WIDTH);\n      defaultLayout.setCellHeight(optionLabel, NORTH_WIDTH);\n      defaultLayout.setCellWidth(optionLabel, EAST_WIDTH);\n      \n      return defaultLayout;\n   }","commit_id":"7253a35181dd239052a573d3dae9678a0bd3c749","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   protected void onBind()\n   {\n      bindSouthPanelPresenters();\n      translationEditorPresenter.bind();\n      optionsPanelPresenter.bind();\n\n\n      registerHandler(eventBus.addHandler(ExitWorkspaceEvent.getType(), new ExitWorkspaceEventHandler()\n      {\n         @Override\n         public void onExitWorkspace(ExitWorkspaceEvent event)\n         {\n            workspaceUsersPresenter.removeTranslator(event.getSessionId(), event.getPerson());\n            targetContentsPresenter.updateTranslators();\n            display.setParticipantsTitle(messages.nUsersOnline(workspaceUsersPresenter.getTranslatorsSize()));\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(EnterWorkspaceEvent.getType(), new EnterWorkspaceEventHandler()\n      {\n         @Override\n         public void onEnterWorkspace(EnterWorkspaceEvent event)\n         {\n            workspaceUsersPresenter.addTranslator(event.getSessionId(), event.getPerson(), null);\n            workspaceUsersPresenter.dispatchChatAction(event.getPerson().getId().toString(), messages.hasJoinedWorkspace());\n            display.setParticipantsTitle(messages.nUsersOnline(workspaceUsersPresenter.getTranslatorsSize()));\n         }\n      }));\n\n      // We won't receive the EnterWorkspaceEvent generated by our own login,\n      // because this presenter is not bound until we get the callback from\n      // EventProcessor.\n      // Thus we load the translator list here.\n      loadTranslatorList();\n\n      registerHandler(eventBus.addHandler(WorkspaceContextUpdateEvent.getType(), new WorkspaceContextUpdateEventHandler()\n      {\n         @Override\n         public void onWorkspaceContextUpdated(WorkspaceContextUpdateEvent event)\n         {\n            setSouthPanelReadOnly(event.isReadOnly());\n         }\n      }));\n\n      if (workspaceContext.isReadOnly())\n      {\n         setSouthPanelReadOnly(true);\n      }\n\n      registerHandler(display.getOptionsToggle().addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            boolean shouldShowOptions = event.getValue();\n            if (shouldShowOptions)\n            {\n               display.setSidePanelVisible(true);\n               display.setOptionsToggleTooltip(messages.hideEditorOptions());\n            }\n            else\n            {\n               display.setSidePanelVisible(false);\n               display.setOptionsToggleTooltip(messages.showEditorOptions());\n            }\n         }\n      }));\n\n      registerHandler(display.getSouthPanelToggle().addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            boolean shouldShowSouthPanel = event.getValue();\n            setSouthPanelExpanded(shouldShowSouthPanel);\n         }\n      }));\n\n      final CheckKey checkKey = new CheckKeyImpl(CheckKeyImpl.Context.Navigation);\n\n      // TODO make testable\n\n      nativeEvent.addNativePreviewHandler(new NativePreviewHandler()\n      {\n         @Override\n         public void onPreviewNativeEvent(NativePreviewEvent event)\n         {\n            /**\n             * keyup is used because TargetCellEditor will intercept the event\n             * again (Firefox) See textArea.addKeyDownHandler@InlineTargetCellEditor\n             **/\n            if (display.asWidget().isVisible() && (event.getNativeEvent().getType().equals(\"keyup\") || event.getNativeEvent().getType().equals(\"keydown\")))\n            {\n               checkKey.init(event.getNativeEvent());\n               \n               if (translationEditorPresenter.getSelectedTransUnit() != null && checkKey.isCopyFromTransMem())\n               {\n                  int index;\n                  switch (checkKey.getKeyCode())\n                  {\n                  case CheckKey.KEY_1:\n                  case CheckKey.KEY_1_NUM:\n                     index = 0;\n                     break;\n                  case CheckKey.KEY_2:\n                  case CheckKey.KEY_2_NUM:\n                     index = 1;\n                     break;\n                  case CheckKey.KEY_3:\n                  case CheckKey.KEY_3_NUM:\n                     index = 2;\n                     break;\n                  case CheckKey.KEY_4:\n                  case CheckKey.KEY_4_NUM:\n                     index = 3;\n                     break;\n                  default:\n                     index = -1;\n                     break;\n                  }\n                  Log.info(\"Copy from translation memory:\" + index);\n                  eventBus.fireEvent(new TransMemoryShortcutCopyEvent(index));\n               }\n\n               /**\n                * @formatter:off\n                * Only when the Table is showed,editor is closed, search field\n                * not focused, the keyboard event will be processed.\n                **/\n               if (!translationEditorPresenter.isEditing() &&\n                  !translationEditorPresenter.isTransFilterFocused() && \n                  !transMemoryPresenter.getDisplay().isFocused() && \n                  !glossaryPresenter.getDisplay().isFocused() &&\n                  !translationEditorPresenter.getDisplay().isPagerFocused())\n               {\n                  if (event.getNativeEvent().getType().equals(\"keyup\"))\n                  {\n                     if (checkKey.isEnterKey() && !checkKey.isCtrlKey())\n                     {\n                        if (translationEditorPresenter.getSelectedTransUnit() != null)\n                        {\n                           if (!translationEditorPresenter.isCancelButtonFocused())\n                           {\n                              event.getNativeEvent().stopPropagation();\n                              event.getNativeEvent().preventDefault();\n                              \n                              translationEditorPresenter.openEditorOnSelectedRow();\n                           }\n                           translationEditorPresenter.setCancelButtonFocused(false);\n                        }\n                     }\n                  }\n                  if (event.getNativeEvent().getType().equals(\"keydown\"))\n                  {\n                     if (checkKey.isPreviousEntryKey())\n                     {\n                        Log.info(\"Go to previous entry\");\n                        event.getNativeEvent().stopPropagation();\n                        event.getNativeEvent().preventDefault();\n                        translationEditorPresenter.gotoPrevRow(false);\n                     }\n                     else if (checkKey.isNextEntryKey())\n                     {\n                        Log.info(\"Go to next entry\");\n                        event.getNativeEvent().stopPropagation();\n                        event.getNativeEvent().preventDefault();\n                        translationEditorPresenter.gotoNextRow(false);\n                     }\n                  }\n               }\n            }\n         }\n      });\n   }","id":28977,"modified_method":"@Override\n   protected void onBind()\n   {\n      bindSouthPanelPresenters();\n      translationEditorPresenter.bind();\n      optionsPanelPresenter.bind();\n\n\n      registerHandler(eventBus.addHandler(ExitWorkspaceEvent.getType(), new ExitWorkspaceEventHandler()\n      {\n         @Override\n         public void onExitWorkspace(ExitWorkspaceEvent event)\n         {\n            workspaceUsersPresenter.removeTranslator(event.getSessionId(), event.getPerson());\n            targetContentsPresenter.updateTranslators();\n            display.setParticipantsTitle(messages.nUsersOnline(workspaceUsersPresenter.getTranslatorsSize()));\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(EnterWorkspaceEvent.getType(), new EnterWorkspaceEventHandler()\n      {\n         @Override\n         public void onEnterWorkspace(EnterWorkspaceEvent event)\n         {\n            workspaceUsersPresenter.addTranslator(event.getSessionId(), event.getPerson(), null);\n            workspaceUsersPresenter.dispatchChatAction(event.getPerson().getId().toString(), messages.hasJoinedWorkspace());\n            display.setParticipantsTitle(messages.nUsersOnline(workspaceUsersPresenter.getTranslatorsSize()));\n         }\n      }));\n\n      // We won't receive the EnterWorkspaceEvent generated by our own login,\n      // because this presenter is not bound until we get the callback from\n      // EventProcessor.\n      // Thus we load the translator list here.\n      loadTranslatorList();\n\n      registerHandler(eventBus.addHandler(WorkspaceContextUpdateEvent.getType(), new WorkspaceContextUpdateEventHandler()\n      {\n         @Override\n         public void onWorkspaceContextUpdated(WorkspaceContextUpdateEvent event)\n         {\n            setSouthPanelReadOnly(event.isReadOnly());\n         }\n      }));\n\n      if (workspaceContext.isReadOnly())\n      {\n         setSouthPanelReadOnly(true);\n      }\n\n      registerHandler(display.getOptionsToggle().addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            boolean shouldShowOptions = event.getValue();\n            setOptionsExpended(shouldShowOptions);\n         }\n      }));\n\n      registerHandler(display.getSouthPanelToggle().addValueChangeHandler(new ValueChangeHandler<Boolean>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            boolean shouldShowSouthPanel = event.getValue();\n            setSouthPanelExpanded(shouldShowSouthPanel);\n         }\n      }));\n\n      final CheckKey checkKey = new CheckKeyImpl(CheckKeyImpl.Context.Navigation);\n\n      // TODO make testable\n\n      nativeEvent.addNativePreviewHandler(new NativePreviewHandler()\n      {\n         @Override\n         public void onPreviewNativeEvent(NativePreviewEvent event)\n         {\n            /**\n             * keyup is used because TargetCellEditor will intercept the event\n             * again (Firefox) See textArea.addKeyDownHandler@InlineTargetCellEditor\n             **/\n            if (display.asWidget().isVisible() && (event.getNativeEvent().getType().equals(\"keyup\") || event.getNativeEvent().getType().equals(\"keydown\")))\n            {\n               checkKey.init(event.getNativeEvent());\n               \n               if (translationEditorPresenter.getSelectedTransUnit() != null && checkKey.isCopyFromTransMem())\n               {\n                  int index;\n                  switch (checkKey.getKeyCode())\n                  {\n                  case CheckKey.KEY_1:\n                  case CheckKey.KEY_1_NUM:\n                     index = 0;\n                     break;\n                  case CheckKey.KEY_2:\n                  case CheckKey.KEY_2_NUM:\n                     index = 1;\n                     break;\n                  case CheckKey.KEY_3:\n                  case CheckKey.KEY_3_NUM:\n                     index = 2;\n                     break;\n                  case CheckKey.KEY_4:\n                  case CheckKey.KEY_4_NUM:\n                     index = 3;\n                     break;\n                  default:\n                     index = -1;\n                     break;\n                  }\n                  Log.info(\"Copy from translation memory:\" + index);\n                  eventBus.fireEvent(new TransMemoryShortcutCopyEvent(index));\n               }\n\n               /**\n                * @formatter:off\n                * Only when the Table is showed,editor is closed, search field\n                * not focused, the keyboard event will be processed.\n                **/\n               if (!translationEditorPresenter.isEditing() &&\n                  !translationEditorPresenter.isTransFilterFocused() && \n                  !transMemoryPresenter.getDisplay().isFocused() && \n                  !glossaryPresenter.getDisplay().isFocused() &&\n                  !translationEditorPresenter.getDisplay().isPagerFocused())\n               {\n                  if (event.getNativeEvent().getType().equals(\"keyup\"))\n                  {\n                     if (checkKey.isEnterKey() && !checkKey.isCtrlKey())\n                     {\n                        if (translationEditorPresenter.getSelectedTransUnit() != null)\n                        {\n                           if (!translationEditorPresenter.isCancelButtonFocused())\n                           {\n                              event.getNativeEvent().stopPropagation();\n                              event.getNativeEvent().preventDefault();\n                              \n                              translationEditorPresenter.openEditorOnSelectedRow();\n                           }\n                           translationEditorPresenter.setCancelButtonFocused(false);\n                        }\n                     }\n                  }\n                  if (event.getNativeEvent().getType().equals(\"keydown\"))\n                  {\n                     if (checkKey.isPreviousEntryKey())\n                     {\n                        Log.info(\"Go to previous entry\");\n                        event.getNativeEvent().stopPropagation();\n                        event.getNativeEvent().preventDefault();\n                        translationEditorPresenter.gotoPrevRow(false);\n                     }\n                     else if (checkKey.isNextEntryKey())\n                     {\n                        Log.info(\"Go to next entry\");\n                        event.getNativeEvent().stopPropagation();\n                        event.getNativeEvent().preventDefault();\n                        translationEditorPresenter.gotoNextRow(false);\n                     }\n                  }\n               }\n            }\n         }\n      });\n   }","commit_id":"7253a35181dd239052a573d3dae9678a0bd3c749","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * This has one advantage over the standard EOUtilites\n     * method of first checking if the editingcontexts are\n     * equal before creating a fault for the object in the\n     * editing context.\n     * @param ec editing context to get a local instance of the object in\n     * @param eo object to get a local copy of\n     * @return enterprise object local to the passed in editing contex\n     */\n    public static EOEnterpriseObject localInstanceOfObject(EOEditingContext ec, EOEnterpriseObject eo) {\n        return eo != null && ec != null && eo.editingContext() != null && !ec.equals(eo.editingContext()) ?\n        EOUtilities.localInstanceOfObject(ec, eo) : eo;\n    }","id":28978,"modified_method":"/**\n     * This has one advantage over the standard EOUtilites\n     * method of first checking if the editingcontexts are\n     * equal before creating a fault for the object in the\n     * editing context.\n     * @param ec editing context to get a local instance of the object in\n     * @param eo object to get a local copy of\n     * @return enterprise object local to the passed in editing contex\n     */\n    @SuppressWarnings(\"unchecked\")\n\tpublic static <T extends EOEnterpriseObject> T localInstanceOfObject(EOEditingContext ec, T eo) {\n        return eo != null && ec != null && eo.editingContext() != null && !ec.equals(eo.editingContext()) ?\n        (T)EOUtilities.localInstanceOfObject(ec, eo) : eo;\n    }","commit_id":"a9b73dcbe68cdaef3247138a217761722f3889a4","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Provides the same functionality as the equivalent method\n     * in {@link com.webobjects.eoaccess.EOUtilities EOUtilities}\n     * except it will use the localInstanceOfObject\n     * method from this utilities class which has a few enhancements.\n     *\n     * @param ec editing context to pull local object copies\n     * @param eos array of enterprise objects\n     * @return an array of copies of local objects\n     */\n    public static NSArray localInstancesOfObjects(EOEditingContext ec, NSArray eos) {\n        if (eos == null)\n            throw new RuntimeException(\"ERXUtilites: localInstancesOfObjects: Array is null\");\n        if (ec == null)\n            throw new RuntimeException(\"ERXUtilites: localInstancesOfObjects: EditingContext is null\");\n        NSMutableArray localEos = new NSMutableArray();\n        for (Enumeration e = eos.objectEnumerator(); e.hasMoreElements();) {\n            localEos.addObject(localInstanceOfObject(ec, (EOEnterpriseObject)e.nextElement()));\n        }\n        return localEos;\n    }","id":28979,"modified_method":"/**\n     * Provides the same functionality as the equivalent method\n     * in {@link com.webobjects.eoaccess.EOUtilities EOUtilities}\n     * except it will use the localInstanceOfObject\n     * method from this utilities class which has a few enhancements.\n     *\n     * @param ec editing context to pull local object copies\n     * @param eos array of enterprise objects\n     * @return an array of copies of local objects\n     */\n    public static <T extends EOEnterpriseObject> NSArray<T> localInstancesOfObjects(EOEditingContext ec, NSArray<T> eos) {\n        if (eos == null)\n            throw new RuntimeException(\"ERXUtilites: localInstancesOfObjects: Array is null\");\n        if (ec == null)\n            throw new RuntimeException(\"ERXUtilites: localInstancesOfObjects: EditingContext is null\");\n        NSMutableArray<T> localEos = new NSMutableArray<T>();\n        for (Enumeration<T> e = eos.objectEnumerator(); e.hasMoreElements();) {\n            localEos.addObject(localInstanceOfObject(ec, e.nextElement()));\n        }\n        return localEos;\n    }","commit_id":"a9b73dcbe68cdaef3247138a217761722f3889a4","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void awakeFromInsertion(EOEditingContext ec) {\n        super.awakeFromInsertion(ec);\n        setPriority(Priority.MEDIUM);\n        setState(State.ANALYZE);\n        addToBothSidesOfTargetRelease(Release.clazz.defaultRelease(ec));\n        setReadAsBoolean(true);\n        setDateSubmitted(new NSTimestamp());\n        setDateModified(new NSTimestamp());\n        setFeatureRequest(Boolean.FALSE);\n    }","id":28980,"modified_method":"public void init(EOEditingContext ec) {\n        super.init(ec);\n        setPriority(Priority.MEDIUM);\n        setState(State.ANALYZE);\n        addToBothSidesOfTargetRelease(Release.clazz.defaultRelease(ec));\n        setReadAsBoolean(true);\n        setDateSubmitted(new NSTimestamp());\n        setDateModified(new NSTimestamp());\n        setFeatureRequest(Boolean.FALSE);\n    }","commit_id":"7f039822165cf597729444a9a210db086e8f603c","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void markReadBy(People reader) {\n        if (owner() != null && owner().equals(localInstanceOf(reader)) && !isReadAsBoolean()) {\n            setReadAsBoolean(true);\n            editingContext().saveChanges();\n        }\n    }","id":28981,"modified_method":"public void markReadBy(People reader) {\n        if (owner() != null && owner().equals(localInstanceOf(reader)) && !isRead()) {\n            setReadAsBoolean(true);\n            editingContext().saveChanges();\n        }\n    }","commit_id":"7f039822165cf597729444a9a210db086e8f603c","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void markAsRead() {\n\t\tEOEditingContext ec = ERXEC.newEditingContext();\n\t\tec.lock();\n\t\ttry {\n\t\t\tPeople people = (People) ERCoreBusinessLogic.actor(ec);\n\t\t\tBug copy = (Bug) ERXEOControlUtilities.localInstanceOfObject(ec, this);\n\t\t\tif(copy != null && !copy.isReadAsBoolean() && copy.owner().equals(people)) {\n\t\t\t\tcopy.setReadAsBoolean(true);\n\t\t\t\tec.saveChanges();\n\t\t\t}\n\t\t} finally {\n\t\t\tec.unlock();\n\t\t}\n\t}","id":28982,"modified_method":"public void markAsRead() {\n\t\tEOEditingContext ec = ERXEC.newEditingContext();\n\t\tec.lock();\n\t\ttry {\n\t\t\tPeople people = (People) ERCoreBusinessLogic.actor(ec);\n\t\t\tBug copy = (Bug) ERXEOControlUtilities.localInstanceOfObject(ec, this);\n\t\t\tif(copy != null && !copy.isRead() && copy.owner().equals(people)) {\n\t\t\t\tcopy.setReadAsBoolean(true);\n\t\t\t\tec.saveChanges();\n\t\t\t}\n\t\t} finally {\n\t\t\tec.unlock();\n\t\t}\n\t}","commit_id":"7f039822165cf597729444a9a210db086e8f603c","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void validateForUpdate() {\n        if (_componentChanged && component()!=null && !_ownerChanged) {\n            addToBothSidesOfOwner(component().owner());\n        }\n        _componentChanged=false;\n        _ownerChanged=false;\n        super.validateForUpdate();\n        if(changesFromCommittedSnapshot().count() > 1 && !changesFromCommittedSnapshot().allKeys().containsObject(\"isRead\")) {\n            touch();\n        }\n\n    }","id":28983,"modified_method":"public void validateForUpdate() {\n        if (_componentChanged && component()!=null && !_ownerChanged) {\n            addToBothSidesOfOwner(component().owner());\n        }\n        _componentChanged=false;\n        _ownerChanged=false;\n        super.validateForUpdate();\n        if(!(changesFromCommittedSnapshot().count() == 1 && changesFromCommittedSnapshot().allKeys().containsObject(\"read\"))) {\n            touch();\n        }\n\n    }","commit_id":"7f039822165cf597729444a9a210db086e8f603c","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isFeatureRequest() { return ERXUtilities.booleanValue(featureRequest()); }","id":28984,"modified_method":"public boolean isFeatureRequest() {\n\t\treturn ERXValueUtilities.booleanValue(featureRequest());\n\t}","commit_id":"7f039822165cf597729444a9a210db086e8f603c","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void flushCaches() {\n        _cachedComponents=null;\n    }","id":28985,"modified_method":"public void flushCaches() {\n\t\tclazz._cachedComponents = null;\n\t}","commit_id":"7f039822165cf597729444a9a210db086e8f603c","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void awakeFromInsertion(EOEditingContext ec) {\n        super.awakeFromInsertion(ec);\n    }","id":28986,"modified_method":"public void init(EOEditingContext ec) {\n        super.init(ec);\n    }","commit_id":"7f039822165cf597729444a9a210db086e8f603c","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void awakeFromInsertion(EOEditingContext ec) {\n        super.awakeFromInsertion(ec);\n        setState(TestItemState.OPEN);\n        setDateCreated(new NSTimestamp());\n    }","id":28987,"modified_method":"public void init(EOEditingContext ec) {\n        super.init(ec);\n        setState(TestItemState.OPEN);\n        setDateCreated(new NSTimestamp());\n    }","commit_id":"7f039822165cf597729444a9a210db086e8f603c","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** \n     * Creates a new, editable instance of the supplied object. Takes into account if the object is\n     * newly inserted, lives in a shared context and can either create a peer or nested context.\n     *\n     * @param eo object for the new instance\n     * @param createNestedContext true, if we should create a nested context (otherwise we create a peer context)\n     *\n     * @return new EO in new editing context\n     */\n     public static EOEnterpriseObject editableInstanceOfObject(EOEnterpriseObject eo, \n     \t\tboolean createNestedContext) {\n     \t\n     \tif(eo == null) throw new IllegalArgumentException(\"EO can't be null\");\n     \tEOEditingContext ec = eo.editingContext();\n     \t\n     \tif(ec == null) throw new IllegalArgumentException(\"EO must live in an EC\");\n     \t\n        boolean isNewObject = ERXEOControlUtilities.isNewObject(eo);\n        \n        // Check for old EOF bug and do nothing as we can't localInstance\n        // anything here\n        if (ERXProperties.webObjectsVersionAsDouble() < 5.21d && isNewObject) {\n            return eo;\n        }\n\n        EOEnterpriseObject localObject = eo;\n        \n        // Either we have an already saved object or a new one and create a nested context.\n        // Otherwise (new object and a peer) we should probably raise, but simple return the EO\n        if((isNewObject && createNestedContext) || !isNewObject) {\n    \t\t// create either peer or nested context\n     \t\tEOEditingContext newEc = ERXEC.newEditingContext(createNestedContext \n     \t\t\t\t? ec : ec.parentObjectStore());\n     \t\tec.lock();\n     \t\ttry {\n     \t\t\tnewEc.lock();\n     \t\t\ttry {\n     \t\t\t\tif(ec instanceof EOSharedEditingContext \n     \t     \t\t\t\t|| ec.sharedEditingContext() == null) {\n     \t     \t\t\tnewEc.setSharedEditingContext(null);\n     \t     \t\t}\n     \t     \t\tlocalObject = EOUtilities.localInstanceOfObject(newEc, eo);\n     \t\t\t\tlocalObject.willRead();\n     \t\t\t} finally {\n     \t\t\t\tnewEc.unlock();\n     \t\t\t}\n     \t\t} finally {\n     \t\t\tec.unlock();\n     \t\t}\n     \t}\n      \treturn localObject;\n     }","id":28988,"modified_method":"/** \n     * Creates a new, editable instance of the supplied object. Takes into account if the object is\n     * newly inserted, lives in a shared context and can either create a peer or nested context.\n     *\n     * @param eo object for the new instance\n     * @param createNestedContext true, if we should create a nested context (otherwise we create a peer context)\n     *\n     * @return new EO in new editing context\n     */\n     public static <T extends EOEnterpriseObject> T editableInstanceOfObject(T eo, \n     \t\tboolean createNestedContext) {\n     \t\n     \tif(eo == null) throw new IllegalArgumentException(\"EO can't be null\");\n     \tEOEditingContext ec = eo.editingContext();\n     \t\n     \tif(ec == null) throw new IllegalArgumentException(\"EO must live in an EC\");\n     \t\n        boolean isNewObject = ERXEOControlUtilities.isNewObject(eo);\n        \n        // Check for old EOF bug and do nothing as we can't localInstance\n        // anything here\n        if (ERXProperties.webObjectsVersionAsDouble() < 5.21d && isNewObject) {\n            return eo;\n        }\n\n        T localObject = eo;\n        \n        // Either we have an already saved object or a new one and create a nested context.\n        // Otherwise (new object and a peer) we should probably raise, but simple return the EO\n        if((isNewObject && createNestedContext) || !isNewObject) {\n    \t\t// create either peer or nested context\n     \t\tEOEditingContext newEc = ERXEC.newEditingContext(createNestedContext \n     \t\t\t\t? ec : ec.parentObjectStore());\n     \t\tec.lock();\n     \t\ttry {\n     \t\t\tnewEc.lock();\n     \t\t\ttry {\n     \t\t\t\tif(ec instanceof EOSharedEditingContext \n     \t     \t\t\t\t|| ec.sharedEditingContext() == null) {\n     \t     \t\t\tnewEc.setSharedEditingContext(null);\n     \t     \t\t}\n     \t     \t\tlocalObject = (T) EOUtilities.localInstanceOfObject(newEc, eo);\n     \t\t\t\tlocalObject.willRead();\n     \t\t\t} finally {\n     \t\t\t\tnewEc.unlock();\n     \t\t\t}\n     \t\t} finally {\n     \t\t\tec.unlock();\n     \t\t}\n     \t}\n      \treturn localObject;\n     }","commit_id":"79f86b1de790b946cb4e1a9cc703c2e6913bb535","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void runBatchReport() {\n        // we run over all people in the DB and send them a summary email if they have unread bugs\n        EOEditingContext ec=new EOEditingContext();\n        NSArray everybody=EOUtilities.objectsForEntityNamed(ec,\"People\");\n        for (Enumeration e=everybody.objectEnumerator(); e.hasMoreElements();) {\n            EOEnterpriseObject person=(EOEnterpriseObject)e.nextElement();\n            NSDictionary bindings = new NSDictionary(new Object[] {person}, new Object[] {\"user\"});\n            NSArray unreadBugs=EOUtilities.objectsWithFetchSpecificationAndBindings (ec,\n                                                                                     \"Bug\",\n                                                                                     \"MyUnreadBugs\",\n                                                                                     bindings);\n            String email=(String)person.valueForKey(\"email\");\n           if (unreadBugs.count()>0 && email!=null && email.length()!=0) {\n                WOComponent emailBody = pageWithName(\"BugReportEmail\",\n                                                     new WOContext(new WORequest(null,null,null,null,null,null)));\n                emailBody.takeValueForKey(unreadBugs,\"unreadBugs\");\n                emailBody.takeValueForKey(person,\"owner\");\n                WOMailDelivery.sharedInstance().composeComponentEmail(\"bugtracker@netstruxr.com\",\n                                                                      new NSArray(person.valueForKey(\"email\")),\n                                                                      null,\n                                                                      \"You have \"+unreadBugs.count()+\" unread bug(s)\",\n                                                                      emailBody,\n                                                                      true);\n                NSLog.debug.appendln(\"Sending report to \"+email+\": \"+unreadBugs.count()+\" unread bugs\");\n            }\n        }\n    }","id":28989,"modified_method":"/** we run over all people in the DB and send them a summary email if they have unread bugs */\n    public void runBatchReport() {\n        EOEditingContext ec=ERXEC.newEditingContext();\n        try {\n            NSArray everybody=People.clazz.allObjects(ec);\n            for (Enumeration e=everybody.objectEnumerator(); e.hasMoreElements();) {\n                People person=(People)e.nextElement();\n                NSDictionary bindings = new NSDictionary(new Object[] {person}, new Object[] {\"user\"});\n                NSArray unreadBugs=person.unreadBugs();\n                String email=person.email();\n                if (unreadBugs.count()>0 && email!=null && email.length()!=0) {\n                    WOComponent emailBody = pageWithName(\"BugReportEmail\", ERXWOContext.newContext());\n                    emailBody.takeValueForKey(unreadBugs,\"unreadBugs\");\n                    emailBody.takeValueForKey(person,\"owner\");\n                    WOMailDelivery.sharedInstance().composeComponentEmail(\"bugtracker@netstruxr.com\", new NSArray(email), null, \"You have \"+unreadBugs.count()+\" unread bug(s)\", emailBody, true);\n                    NSLog.debug.appendln(\"Sending report to \"+email+\": \"+unreadBugs.count()+\" unread bugs\");\n                }\n            }\n        } finally {\n            ec.unlock();\n        }\n    }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Application() {\n        setContextClassName(\"er.extensions.ERXWOContext\");\n        setPageRefreshOnBacktrackEnabled(true);\n        statisticsStore().setPassword(\"4Stats\");\n        // http://myhost:aPort/cgi-bin/WebObjects/MyApp.woa/wa/WOEventSetup\n        EOEventCenter.setPassword(\"4Events\");\n        setDefaultRequestHandler(requestHandlerForKey(directActionRequestHandlerKey()));\n        ERXLocalizer.setFrameworkSearchPath(new NSArray(new Object [] {\n            \"app\", \"BTBusinessLogic\", \"ERDirectToWeb\", \"ERExtensions\"} ));\n        setTimeOut(8*60*60); //set the timeout to 8 hours.\n        Class core = er.corebusinesslogic.ERCoreBusinessLogic.class;\n        Class bug = er.bugtracker.BTBusinessLogic.class;\n    }","id":28990,"modified_method":"public Application() {\n        setContextClassName(\"er.extensions.ERXWOContext\");\n        setPageRefreshOnBacktrackEnabled(true);\n        // http://myhost:aPort/cgi-bin/WebObjects/MyApp.woa/wa/WOEventSetup\n        setDefaultRequestHandler(requestHandlerForKey(directActionRequestHandlerKey()));\n        setTimeOut(8*60*60); //set the timeout to 8 hours.\n        Class core = er.corebusinesslogic.ERCoreBusinessLogic.class;\n        Class bug = er.bugtracker.BTBusinessLogic.class;\n    }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"NSArray array() {\n        return (NSArray)valueForBinding(\"items\");\n    }","id":28991,"modified_method":"protected NSArray array() {\n        return (NSArray)valueForBinding(\"items\");\n    }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"String entityName() {\n        return (String)valueForBinding(\"entityName\");\n    }","id":28992,"modified_method":"protected String entityName() {\n        return (String)valueForBinding(\"entityName\");\n    }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent createTestItem() {\n        ERXLocalizer localizer = ERXLocalizer.localizerForSession(session());\n        EOEditingContext peer = new EOEditingContext(bug.editingContext().parentObjectStore());\n        People user = (People)EOUtilities.localInstanceOfObject(peer,((Session)session()).getUser());\n\n        String description = localizer.localizedTemplateStringForKeyWithObject(\"CreateTestItemFromReq.templateString\", bug);\n        TestItem testItem = user.createTestItemFromRequestWithDescription(bug, (Component)valueForKey(\"component\"), description);\n\n        EditPageInterface epi=(EditPageInterface)D2W.factory().pageForConfigurationNamed(\"CreateNewTestItemFromReq\",session());\n        epi.setObject(testItem);\n        epi.setNextPage(context().page());\n\n        return (WOComponent)epi;\n    }","id":28993,"modified_method":"public WOComponent createTestItem() {\n        ERXLocalizer localizer = ERXLocalizer.localizerForSession(session());\n        EOEditingContext peer = ERXEC.newEditingContext(bug.editingContext().parentObjectStore());\n        EditPageInterface epi = null;\n        peer.lock();\n        try {\n            People user = (People)EOUtilities.localInstanceOfObject(peer,((Session)session()).getUser());\n\n            String description = localizer.localizedTemplateStringForKeyWithObject(\"CreateTestItemFromReq.templateString\", bug);\n            TestItem testItem = user.createTestItemFromRequestWithDescription(bug, (Component)valueForKey(\"component\"), description);\n            epi=(EditPageInterface)D2W.factory().pageForConfigurationNamed(\"CreateNewTestItemFromReq\",session());\n            epi.setObject(testItem);\n            epi.setNextPage(context().page());\n        } finally {\n            peer.unlock();\n        }\n\n        return (WOComponent)epi;\n    }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent transfertDescriptionAction(){\n        EOEditingContext ec = ERXExtensions.newEditingContext();\n        NSArray bugs = EOUtilities.objectsWithFetchSpecificationAndBindings(ec, \"Bug\",\n                                                                            \"BugsToTransfert\", null);\n        for(Enumeration e = bugs.objectEnumerator(); e.hasMoreElements();){\n            Bug bug = (Bug)e.nextElement();\n            System.out.println(\"bug = \"+bug.valueForKey(\"subject\"));\n            String description = (String)bug.valueForKey(\"textDescription\");\n            bug.takeValueForKey(description, \"textDescription\");\n            ec.saveChanges();\n        }\n        return null;\n    }","id":28994,"modified_method":"public WOComponent transfertDescriptionAction(){\n        EOEditingContext ec = ERXEC.newEditingContext();\n        ec.lock();\n        try {\n            NSArray bugs = EOUtilities.objectsWithFetchSpecificationAndBindings(ec, \"Bug\", \"BugsToTransfert\", null);\n            for(Enumeration e = bugs.objectEnumerator(); e.hasMoreElements();){\n                Bug bug = (Bug)e.nextElement();\n                System.out.println(\"bug = \"+bug.valueForKey(\"subject\"));\n                String description = (String)bug.valueForKey(\"textDescription\");\n                bug.takeValueForKey(description, \"textDescription\");\n                ec.saveChanges();\n            }\n        } finally {\n            ec.unlock();\n        }\n        return null;\n    }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent pingAction() {\n        WOComponent result = null;\n        try{\n            EOUtilities.rawRowsForSQL(pingEditingContext(),\n                                      \"bug\",\n                                      \"select count(*) from PRIORITY\");\n            result=pageWithName(\"ERXSuccess\");\n        } catch(Exception e) {}\n        return result;\n    }","id":28995,"modified_method":"public WOComponent pingAction() {\n        WOComponent result = null;\n        EOEditingContext ec = pingEditingContext();\n        ec.lock();\n        try{\n            EOUtilities.rawRowsForSQL(ec,\n                                      \"bug\",\n                                      \"select count(*) from PRIORITY\");\n            result=pageWithName(\"ERXSuccess\");\n        } catch(Exception e) {\n        } finally {\n            ec.unlock();\n        }\n        return result;\n    }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Object invoke(Object ctx) {\n            Session session = (Session)ctx;\n            WOComponent result = null;\n            if ((numberFromRequest == null) || (numberFromRequest.equals(\"\"))) {\n                result = errorPage(\"Invalid Request\", session);\n            } else {\n                try {\n                    Integer bugId = new Integer(numberFromRequest);\n                    EOEditingContext ec = session.defaultEditingContext();\n                    NSArray bugs = EOUtilities.objectsMatchingKeyAndValue(ec, \"Bug\", \"bugid\", bugId);\n                    EOEnterpriseObject bug = bugs.count() > 0 ? (EOEnterpriseObject)bugs.objectAtIndex(0) : null;\n                    if (bug == null) {\n                        result = errorPage(\"Bug not found\", session);\n                    } else {\n                        EditBug eb = (EditBug)Application.application().pageWithName(\"EditBug\",session.context());\n                        eb.setObject(bug);\n                        eb.setNextPage(Application.application().pageWithName(\"HomePage\",session.context()));\n                        result = eb;\n                    }\n                } catch (NumberFormatException nfe) {\n                    result = errorPage(\"Invalid Request\", session);\n                } catch (Exception e) {\n                    result = errorPage(\"Bug Not Found\", session);\n                }\n            }\n            if (result == null) {\n                result = errorPage(\"An Error Occured\", session);\n            }\n            return result;\n        }","id":28996,"modified_method":"public Object invoke(Object ctx) {\n            Session session = (Session)ctx;\n            WOComponent result = null;\n            if ((numberFromRequest == null) || (numberFromRequest.equals(\"\"))) {\n                result = errorPage(\"Invalid Request\", session);\n            } else {\n                EOEditingContext ec = session.defaultEditingContext();\n                ec.lock();\n                try {\n                    Integer bugId = new Integer(numberFromRequest);\n                    NSArray bugs = EOUtilities.objectsMatchingKeyAndValue(ec, \"Bug\", \"bugid\", bugId);\n                    EOEnterpriseObject bug = bugs.count() > 0 ? (EOEnterpriseObject)bugs.objectAtIndex(0) : null;\n                    if (bug == null) {\n                        result = errorPage(\"Bug not found\", session);\n                    } else {\n                        EditBug eb = (EditBug)Application.application().pageWithName(\"EditBug\",session.context());\n                        eb.setObject(bug);\n                        eb.setNextPage(Application.application().pageWithName(\"HomePage\",session.context()));\n                        result = eb;\n                    }\n                } catch (NumberFormatException nfe) {\n                    result = errorPage(\"Invalid Request\", session);\n                } catch (Exception e) {\n                    result = errorPage(\"Bug Not Found\", session);\n                } finally {\n                    ec.unlock();\n                }\n            }\n            if (result == null) {\n                result = errorPage(\"An Error Occured\", session);\n            }\n            return result;\n        }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected static EOEditingContext pingEditingContext() {\n        if (_pingEditingContext == null)\n            _pingEditingContext = ERXExtensions.newEditingContext();\n        return _pingEditingContext;\n    }","id":28997,"modified_method":"protected static EOEditingContext pingEditingContext() {\n        if (_pingEditingContext == null)\n            _pingEditingContext = ERXEC.newEditingContext();\n        return _pingEditingContext;\n    }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static People userFromRequest(WORequest r, EOEditingContext ec) {\n        People user=null;\n        //This gets us the encrypted ID stored for the login cookie\n        String  encryptedPrimaryKey=r.cookieValueForKey(\"BTL\");\n        if (encryptedPrimaryKey !=null &&\n            !encryptedPrimaryKey.equals(\"\") &&\n            !encryptedPrimaryKey.equals(\"-\")) {\n            String clearPrimaryKey = ERXCrypto.blowfishDecode(encryptedPrimaryKey);\n            if (clearPrimaryKey!=null) {\n                clearPrimaryKey = clearPrimaryKey.trim();\n                try{\n                    Integer clearPrimaryKeyInt = new Integer(clearPrimaryKey);\n                    NSDictionary dictionary = new NSDictionary(clearPrimaryKeyInt, new String(\"id\"));\n                    user = (People)EOUtilities.objectWithPrimaryKey(ec,\n                                                                    \"People\",\n                                                                    dictionary);\n                } catch(NumberFormatException NFe){\n                    //WOApplication.application().logString(NFe.toString());\n                }\n            }\n        }\n        return user;\n    }","id":28998,"modified_method":"public static People userFromRequest(WORequest r, EOEditingContext ec) {\n        People user=null;\n        //This gets us the encrypted ID stored for the login cookie\n        String  encryptedPrimaryKey=r.cookieValueForKey(\"BTL\");\n        if (encryptedPrimaryKey !=null &&\n            !encryptedPrimaryKey.equals(\"\") &&\n            !encryptedPrimaryKey.equals(\"-\")) {\n            String clearPrimaryKey = ERXCrypto.blowfishDecode(encryptedPrimaryKey);\n            if (clearPrimaryKey!=null) {\n                clearPrimaryKey = clearPrimaryKey.trim();\n                ec.lock();\n                try{\n                    Integer clearPrimaryKeyInt = new Integer(clearPrimaryKey);\n                    NSDictionary dictionary = new NSDictionary(clearPrimaryKeyInt, new String(\"id\"));\n                    user = (People)EOUtilities.objectWithPrimaryKey(ec,\n                                                                    \"People\",\n                                                                    dictionary);\n                } catch(NumberFormatException NFe){\n                    //WOApplication.application().logString(NFe.toString());\n                } finally {\n                    ec.unlock();\n                }\n            }\n        }\n        return user;\n    }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent fileBug() {\n        EOEntity entity=EOModelGroup.defaultGroup().entityNamed(\"Bug\");\n        EOClassDescription aClassDesc=entity.classDescriptionForInstances();\n        EOEditingContext peerContext=new EOEditingContext(object.editingContext().parentObjectStore());\n        EOEnterpriseObject localObject=EOUtilities.localInstanceOfObject(peerContext,object);\n        localObject.addObjectToBothSidesOfRelationshipWithKey(TestItemState.BUG,\"state\");\n        EOEnterpriseObject aNewEO=(EOEnterpriseObject)aClassDesc.createInstanceWithEditingContext(peerContext, null);\n        peerContext.insertObject(aNewEO);\n        String entityName = object.entityName();\n        localObject.addObjectToBothSidesOfRelationshipWithKey(aNewEO,\"bugs\");\n        EOEnterpriseObject localUser=EOUtilities.localInstanceOfObject(aNewEO.editingContext(),\n                                                                       ((Session)session()).getUser());\n        aNewEO.addObjectToBothSidesOfRelationshipWithKey(localUser,\"originator\");\n        aNewEO.addObjectToBothSidesOfRelationshipWithKey((EOEnterpriseObject)localObject.valueForKey(\"component\"),\"component\");\n        String pKey=object.primaryKey();\n        aNewEO.takeValueForKey(\"[From Test #\"+pKey+\"]\",\"textDescription\");\n        //aNewEO.takeValueForKey(\"[From Test #\"+pKey+\"]\",\"subject\");\n        \n        EditPageInterface epi=(EditPageInterface)D2W.factory().pageForConfigurationNamed(\"EditNewBug\",session());\n        epi.setObject(aNewEO);\n        epi.setNextPage(context().page());\n        /*\n        if(0)     {\n            EOEditingContext peer = new EOEditingContext(object.editingContext().parentObjectStore());\n            TestItem testItem = (TestItem)EOUtilities.localInstanceOfObject(peer,object);\n            People user = (People)EOUtilities.localInstanceOfObject(peer,((Session)session()).getUser());\n            Component component = valueForKey(\"component\");\n\n            Bug bug = new Bug();\n            peer.insertObject(bug);\n            testItem.setState(TestItem.BUG_STATE);\n\n            bug.setTextDescription(\"[From Test #\"testItem.primaryKey()+\"]\");\n            bug.addtoBothSidesOfTestItems(testItem);\n            bug.addtoBothSidesOfOriginator(user);\n            bug.addtoBothSidesOfComponents(component);\n\n            EditPageInterface epi=(EditPageInterface)D2W.factory().pageForConfigurationNamed(\"EditNewBug\",session());\n            epi.setObject(bug);\n            epi.setNextPage(context().page());\n\n            return (WOComponent)epi;\n        }*/\n        \n        return (WOComponent)epi;        \n    }","id":28999,"modified_method":"public WOComponent fileBug() {\n        EOEditingContext peer = ERXEC.newEditingContext(object.editingContext().parentObjectStore());\n        EditPageInterface epi = null;\n        peer.lock();\n        try {\n            TestItem testItem = (TestItem)EOUtilities.localInstanceOfObject(peer,object);\n            People user = (People)EOUtilities.localInstanceOfObject(peer,((Session)session()).getUser());\n            Component component = (Component)valueForKey(\"component\");\n\n            Bug bug = new Bug();\n            peer.insertObject(bug);\n            testItem.setState(TestItemState.BUG);\n\n            bug.setTextDescription(\"[From Test #\" + testItem.primaryKey()+\"]\");\n            bug.addToBothSidesOfTestItems(testItem);\n            bug.addToBothSidesOfOriginator(user);\n            bug.addToBothSidesOfComponent(component);\n\n            epi=(EditPageInterface)D2W.factory().pageForConfigurationNamed(\"EditNewBug\",session());\n            epi.setObject(bug);\n            epi.setNextPage(context().page());\n        } finally {\n            peer.unlock();\n        }\n         return (WOComponent)epi;        \n    }","commit_id":"a8f1495dff9fbd49d7378b2716c8774c4b27141d","url":"https://github.com/wocommunity/wonder"}]