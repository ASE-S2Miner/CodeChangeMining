[{"original_method":"/**\n     * Check if new class name is valid.\n     *\n     * @param pojo Current edited POJO.\n     * @param newVal New value for class name.\n     * @param key {@code true} if key class name is checked.\n     * @return {@code true} if class name is valid.\n     */\n    private boolean checkClassName(PojoDescriptor pojo, String newVal, boolean key) {\n        if (key) {\n            if (newVal.equals(pojo.valueClassName())) {\n                MessageBox.warningDialog(owner, \"Key class name must be different from value class name!\");\n\n                return false;\n            }\n        }\n        else if (newVal.equals(pojo.keyClassName())) {\n            MessageBox.warningDialog(owner, \"Value class name must be different from key class name!\");\n\n            return false;\n        }\n\n        return checkClassNameUnique(pojo, newVal, key);\n    }","id":91000,"modified_method":"/**\n     * Check if new class name is valid.\n     *\n     * @param pojo Current edited POJO.\n     * @param newVal New value for class name.\n     * @param key {@code true} if key class name is checked.\n     * @return {@code true} if class name is valid.\n     */\n    private boolean checkClassName(PojoDescriptor pojo, String newVal, boolean key) {\n        if (newVal.trim().isEmpty()) {\n            MessageBox.warningDialog(owner, (key ? \"Key\" : \"Value\") + \" class name must be non empty!\");\n\n            return false;\n        }\n\n        if (key) {\n            if (newVal.equals(pojo.valueClassName())) {\n                MessageBox.warningDialog(owner, \"Key class name must be different from value class name!\");\n\n                return false;\n            }\n        }\n        else if (newVal.equals(pojo.keyClassName())) {\n            MessageBox.warningDialog(owner, \"Value class name must be different from key class name!\");\n\n            return false;\n        }\n\n        return checkClassNameUnique(pojo, newVal, key);\n    }","commit_id":"1356a20627be5aa0405a8a04823e5ee0af47ba5a","url":"https://github.com/apache/ignite"},{"original_method":"protected Expression constructorCallExpression(AST node) {\n        if (isType(CTOR_CALL, node) || isType(LITERAL_new, node)) {\n            node = node.getFirstChild();\n        }\n        AST constructorCallNode = node;\n\n        String name = resolvedName(node);\n        AST elist = node.getNextSibling();\n\n        if (isType(ARRAY_DECLARATOR, elist)) {\n            Expression size = expression(elist.getFirstChild());\n            ArrayExpression arrayExpression = new ArrayExpression(name, size);\n            configureAST(arrayExpression, node);\n            return arrayExpression;\n        }\n        Expression arguments = arguments(elist);\n        ConstructorCallExpression expression = new ConstructorCallExpression(name, arguments);\n        configureAST(expression, constructorCallNode);\n        return expression;\n    }","id":91001,"modified_method":"protected Expression constructorCallExpression(AST node) {\n        if (isType(CTOR_CALL, node) || isType(LITERAL_new, node)) {\n            node = node.getFirstChild();\n        }\n        AST constructorCallNode = node;\n\n        String name = resolvedName(node);\n        AST elist = node.getNextSibling();\n\n        if (isType(ARRAY_DECLARATOR, elist)) {\n            AST expressionNode = elist.getFirstChild();\n            if (expressionNode == null) {\n                throw new ASTRuntimeException(elist, \"No expression for the arrary constructor call\");\n            }\n            Expression size = expression(expressionNode);\n            ArrayExpression arrayExpression = new ArrayExpression(name, size);\n            configureAST(arrayExpression, node);\n            return arrayExpression;\n        }\n        Expression arguments = arguments(elist);\n        ConstructorCallExpression expression = new ConstructorCallExpression(name, arguments);\n        configureAST(expression, constructorCallNode);\n        return expression;\n    }","commit_id":"f537987f4d953d74b335eb13b33619509501a812","url":"https://github.com/apache/groovy"},{"original_method":"@NotNull\n    private static JetModifierListOwner addModifier(@NotNull PsiElement element, @NotNull JetKeywordToken modifier, @Nullable JetToken[] modifiersThanCanBeReplaced, @NotNull Project project) {\n        JetModifierListOwner newElement = (JetModifierListOwner) (element.copy());\n\n        JetModifierList modifierList = newElement.getModifierList();\n        JetModifierList listWithModifier = JetPsiFactory.createModifier(project, modifier);\n        PsiElement whiteSpace = JetPsiFactory.createWhiteSpace(project);\n        if (modifierList == null) {\n            PsiElement firstChild = newElement.getFirstChild();\n            newElement.addBefore(listWithModifier, firstChild);\n            newElement.addBefore(whiteSpace, firstChild);\n        }\n        else {\n            boolean replaced = false;\n            if (modifiersThanCanBeReplaced != null) {\n                for (JetToken modifierThanCanBeReplaced : modifiersThanCanBeReplaced) {\n                    if (modifierList.hasModifier(modifierThanCanBeReplaced)) {\n                        PsiElement openModifierPsi = modifierList.getModifierNode(modifierThanCanBeReplaced).getPsi();\n                        assert openModifierPsi != null;\n                        openModifierPsi.replace(listWithModifier.getFirstChild());\n                        replaced = true;\n                    }\n                }\n            }\n            if (!replaced) {\n                PsiElement lastChild = modifierList.getLastChild();\n                modifierList.addAfter(listWithModifier.getFirstChild(), lastChild);\n                modifierList.addAfter(whiteSpace, lastChild);\n            }\n        }\n        return newElement;\n    }","id":91002,"modified_method":"@NotNull\n    /*package*/ static JetModifierListOwner addModifier(@NotNull PsiElement element, @NotNull JetKeywordToken modifier, @Nullable JetToken[] modifiersThatCanBeReplaced, @NotNull Project project, boolean toBeginning) {\n        JetModifierListOwner newElement = (JetModifierListOwner) (element.copy());\n\n        JetModifierList modifierList = newElement.getModifierList();\n        JetModifierList listWithModifier = JetPsiFactory.createModifier(project, modifier);\n        PsiElement whiteSpace = JetPsiFactory.createWhiteSpace(project);\n        if (modifierList == null) {\n            PsiElement firstChild = newElement.getFirstChild();\n            newElement.addBefore(listWithModifier, firstChild);\n            newElement.addBefore(whiteSpace, firstChild);\n        }\n        else {\n            boolean replaced = false;\n            if (modifiersThatCanBeReplaced != null) {\n                PsiElement toBeReplaced = null;\n                PsiElement toReplace = null;\n                for (JetToken modifierThatCanBeReplaced : modifiersThatCanBeReplaced) {\n                    if (modifierList.hasModifier(modifierThatCanBeReplaced)) {\n                        PsiElement modifierElement = modifierList.getModifierNode(modifierThatCanBeReplaced).getPsi();\n                        assert modifierElement != null;\n                        if (!replaced) {\n                            toBeReplaced = modifierElement;\n                            toReplace = listWithModifier.getFirstChild();\n                            //modifierElement.replace(listWithModifier.getFirstChild());\n                            replaced = true;\n                        }\n                        else {\n                            modifierList.deleteChildInternal(modifierElement.getNode());\n                        }\n                    }\n                }\n                if (toBeReplaced != null && toReplace != null) {\n                    toBeReplaced.replace(toReplace);\n                }\n            }\n            if (!replaced) {\n                if (toBeginning) {\n                    PsiElement firstChild = modifierList.getFirstChild();\n                    modifierList.addBefore(listWithModifier.getFirstChild(), firstChild);\n                    modifierList.addBefore(whiteSpace, firstChild);\n                }\n                else {\n                    PsiElement lastChild = modifierList.getLastChild();\n                    modifierList.addAfter(listWithModifier.getFirstChild(), lastChild);\n                    modifierList.addAfter(whiteSpace, lastChild);\n                }\n            }\n        }\n        return newElement;\n    }","commit_id":"0f20d4a6e2700901867bfe26ffbf29d636a56d98","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n        element.replace(addModifier(element, modifier, modifiersThanCanBeReplaced, project));\n    }","id":91003,"modified_method":"@Override\n    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n        element.replace(addModifier(element, modifier, modifiersThanCanBeReplaced, project, false));\n    }","commit_id":"0f20d4a6e2700901867bfe26ffbf29d636a56d98","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void followPeer(LeftTuple lt, SegmentMemory smem, List<LeftTupleSink> sinks, int i, boolean insert, InternalWorkingMemory wm) {\n        LeftTupleSink sink = sinks.get(i);\n\n        if ( i == 0 ) {\n            if ( insert ) {\n                if ( NodeTypeEnums.isBetaNode(sink) ) {\n                    BetaNode bn = ( BetaNode ) sink;\n                    if ( bn.isRightInputIsRiaNode() ) {\n                        // must also create and stage the LeftTuple for the subnetwork\n                        SegmentMemory subSmem = smem.getPrevious(); // Subnetwork segment will be before this one\n                        insertPeerLeftTuple(lt, (LeftTupleSink)subSmem.getRootNode(), subSmem);\n                    }\n                }\n                insertPeerLeftTuple(lt, sink, smem);\n            } else {\n                if ( NodeTypeEnums.isBetaNode(sink) ) {\n                    BetaNode bn = ( BetaNode ) sink;\n                    if ( bn.isRightInputIsRiaNode() ) {\n                        // must also create and stage the LeftTuple for the subnetwork\n                        SegmentMemory subSmem = smem.getPrevious(); // Subnetwork segment will be before this one\n                        deletePeerLeftTuple(lt, (LeftTupleSink)subSmem.getRootNode(), subSmem);\n                    }\n                }\n                deletePeerLeftTuple(lt, sink, smem);\n            }\n        } else {\n            LeftTuple peer = lt;\n            while (peer.getSink() != sink) {\n                peer = peer.getPeer();\n            }\n\n            if (NodeTypeEnums.AccumulateNode == peer.getLeftTupleSink().getType()) {\n                AccumulateContext accctx = (AccumulateContext) lt.getObject();\n                followPeer(accctx.getResultLeftTuple(), smem, sinks,  sinks.size()-1, insert, wm);\n            } else if ( peer.getFirstChild() != null ) {\n                followPeer(peer.getFirstChild(), smem, sinks, i-1, insert, wm);\n            }\n\n        }\n\n\n    }","id":91004,"modified_method":"private static void followPeer(LeftTuple lt, SegmentMemory smem, List<LeftTupleSink> sinks, int i, boolean insert, InternalWorkingMemory wm) {\n        LeftTupleSink sink = sinks.get(i);\n\n        if ( i == 0 ) {\n            if ( insert ) {\n                if ( NodeTypeEnums.isBetaNode(sink) ) {\n                    BetaNode bn = ( BetaNode ) sink;\n                    if ( bn.isRightInputIsRiaNode() ) {\n                        // must also create and stage the LeftTuple for the subnetwork\n                        SegmentMemory subSmem = smem.getPrevious(); // Subnetwork segment will be before this one\n                        insertPeerLeftTuple(lt, (LeftTupleSink)subSmem.getRootNode(), subSmem);\n                    }\n                }\n                insertPeerLeftTuple(lt, sink, smem);\n            } else {\n                if ( NodeTypeEnums.isBetaNode(sink) ) {\n                    BetaNode bn = ( BetaNode ) sink;\n                    if ( bn.isRightInputIsRiaNode() ) {\n                        // must also create and stage the LeftTuple for the subnetwork\n                        SegmentMemory subSmem = smem.getPrevious(); // Subnetwork segment will be before this one\n                        deletePeerLeftTuple(lt, (LeftTupleSink)subSmem.getRootNode(), subSmem);\n                    }\n                }\n                deletePeerLeftTuple(lt, sink, smem);\n            }\n        } else {\n            LeftTuple peer = lt;\n            while (peer.getSink() != sink) {\n                peer = peer.getPeer();\n            }\n\n            if (NodeTypeEnums.AccumulateNode == peer.getLeftTupleSink().getType()) {\n                AccumulateContext accctx = (AccumulateContext) peer.getObject();\n                followPeer(accctx.getResultLeftTuple(), smem, sinks,  i-1, insert, wm);\n            } else if ( peer.getFirstChild() != null ) {\n                for (LeftTuple childLt = peer.getFirstChild(); childLt != null; childLt = childLt.getLeftParentNext()) {\n                    followPeer(childLt, smem, sinks, i-1, insert, wm);\n                }\n            }\n\n        }\n\n\n    }","commit_id":"84144290a4655f114a7e229e1c0357792ead8ee9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static void addRule(TerminalNode tn, InternalWorkingMemory[] wms) {\n        LeftTupleSource splitStartLeftTupleSource = getNetworkSplitPoint(tn);\n\n        if (wms.length > 0) {\n            ((ReteooRuleBase)wms[0].getRuleBase()).invalidateSegmentPrototype(splitStartLeftTupleSource);\n        }\n\n        for ( InternalWorkingMemory wm : wms ) {\n\n            if ( splitStartLeftTupleSource.getAssociations().size() > 1 ) {\n                List<PathMemory> pathMems = new ArrayList<PathMemory>();\n\n                collectRtnPathMemories(splitStartLeftTupleSource, wm, pathMems, tn); // get all PathMemories, except current\n\n                PathMemory newPmem = (PathMemory) wm.getNodeMemory( (MemoryFactory) tn);\n\n                int s = getSegmentPos(splitStartLeftTupleSource, null);\n\n                LeftTupleSink[] sinks = splitStartLeftTupleSource.getSinkPropagator().getSinks();\n                if ( sinks.length == 2 || ( sinks.length == 3 && NodeTypeEnums.isBetaNode(sinks[2])) && ((BetaNode)sinks[2]).isRightInputIsRiaNode() ) {\n                    List<SegmentMemory[]> previousSmems = reInitPathMemories(wm, pathMems, null);\n\n                    // can only be two if the adding node caused the split to be created\n                    int p = 0;\n                    SegmentMemory splitSmem = null;\n                    for ( PathMemory pmem : pathMems) {\n                        SegmentMemory[] smems = previousSmems.get(p);\n\n                        for (int i = 0; i < smems.length; i++ ) {\n                            SegmentMemory sm = smems[i];\n                            if ( sm == null ) {\n                                continue; // SegmentMemory is not yet initialized\n                            }\n\n                            if ( i < s ) {\n                                correctSegmentBeforeSplitOnAdd(wm, newPmem, p, pmem, sm);\n                            } else if ( i == s ) {\n                                splitSmem = correctSegmentOnSplitOnAdd(splitStartLeftTupleSource, wm, newPmem, p, splitSmem, pmem, sm);\n                            } else if (i > s) {\n                                correctSegmentAfterSplitOnAdd(wm, pmem, i, sm);\n                            }\n                        }\n                        p++;\n                    }\n                } else {\n                    SegmentMemory sm = pathMems.get(0).getSegmentMemories()[s];\n                    initNewSegment(splitStartLeftTupleSource, wm, sm);\n                    correctSegmentBeforeSplitOnAdd(wm, newPmem, 0, pathMems.get(0), sm);\n                }\n            }\n\n            if (NodeTypeEnums.LeftInputAdapterNode == splitStartLeftTupleSource.getType() && splitStartLeftTupleSource.getAssociations().size() == 1) {\n                // rule added with no sharing\n                insertLiaFacts(splitStartLeftTupleSource, wm);\n            }\n\n            insertFacts( splitStartLeftTupleSource.getSinkPropagator().getLastLeftTupleSink(), wm);\n        }\n    }","id":91005,"modified_method":"public static void addRule(TerminalNode tn, InternalWorkingMemory[] wms) {\n        if ( log.isTraceEnabled() ) {\n            log.trace(\"Adding Rule {}\", tn.getRule().getName() );\n        }\n        LeftTupleSource splitStartLeftTupleSource = getNetworkSplitPoint(tn);\n\n        if (wms.length > 0) {\n            ((ReteooRuleBase) wms[0].getRuleBase()).invalidateSegmentPrototype(splitStartLeftTupleSource);\n        }\n\n        for (InternalWorkingMemory wm : wms) {\n\n            if (splitStartLeftTupleSource.getAssociations().size() > 1) {\n                List<PathMemory> pathMems = new ArrayList<PathMemory>();\n\n                collectRtnPathMemories(splitStartLeftTupleSource, wm, pathMems, tn); // get all PathMemories, except current\n\n                PathMemory newPmem = (PathMemory) wm.getNodeMemory((MemoryFactory) tn);\n\n                int s = getSegmentPos(splitStartLeftTupleSource, null);\n\n                LeftTupleSink[] sinks = splitStartLeftTupleSource.getSinkPropagator().getSinks();\n                if (sinks.length == 2 || (sinks.length == 3 && NodeTypeEnums.isBetaNode(sinks[2])) && ((BetaNode) sinks[2]).isRightInputIsRiaNode()) {\n                    List<SegmentMemory[]> previousSmems = reInitPathMemories(wm, pathMems, null);\n\n                    // can only be two if the adding node caused the split to be created\n                    int p = 0;\n                    SegmentMemory splitSmem = null;\n                    for (PathMemory pmem : pathMems) {\n                        SegmentMemory[] smems = previousSmems.get(p);\n\n                        for (int i = 0; i < smems.length; i++) {\n                            SegmentMemory sm = smems[i];\n                            if (sm == null) {\n                                continue; // SegmentMemory is not yet initialized\n                            }\n\n                            if (i < s) {\n                                correctSegmentBeforeSplitOnAdd(wm, newPmem, p, pmem, sm);\n                            } else if (i == s) {\n                                splitSmem = correctSegmentOnSplitOnAdd(splitStartLeftTupleSource, wm, newPmem, p, splitSmem, pmem, sm);\n                            } else if (i > s) {\n                                correctSegmentAfterSplitOnAdd(wm, pmem, i, sm);\n                            }\n                        }\n                        p++;\n                    }\n                } else {\n                    SegmentMemory sm = pathMems.get(0).getSegmentMemories()[s];\n                    initNewSegment(splitStartLeftTupleSource, wm, sm);\n                    correctSegmentBeforeSplitOnAdd(wm, newPmem, 0, pathMems.get(0), sm);\n                }\n            }\n\n            if (NodeTypeEnums.LeftInputAdapterNode == splitStartLeftTupleSource.getType() && splitStartLeftTupleSource.getAssociations().size() == 1) {\n                // rule added with no sharing\n                insertLiaFacts(splitStartLeftTupleSource, wm);\n            }\n\n            insertFacts( splitStartLeftTupleSource.getSinkPropagator().getLastLeftTupleSink(), wm);\n        }\n    }","commit_id":"84144290a4655f114a7e229e1c0357792ead8ee9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static void removeRule(TerminalNode tn, InternalWorkingMemory[] wms) {\n         LeftTupleSource splitStartNode = getNetworkSplitPoint(tn);\n\n         if (wms.length > 0) {\n             ((ReteooRuleBase)wms[0].getRuleBase()).invalidateSegmentPrototype(splitStartNode);\n         }\n\n         for ( InternalWorkingMemory wm : wms ) {\n\n             PathMemory removedPmem = (PathMemory) wm.getNodeMemory( (MemoryFactory) tn);\n             int s = getSegmentPos(splitStartNode, null);\n\n             // if a segment is going to be merged it is necessary to flush all its staged left tuples before doing any change to the network\n             flushSegmentIfMerge(wm, tn, removedPmem, splitStartNode, s);\n\n             // must be done before segments are mutated\n             flushStagedTuples(splitStartNode, removedPmem, wm, true);\n\n             //\n             if (NodeTypeEnums.LeftInputAdapterNode == splitStartNode.getType() && splitStartNode.getAssociations().size() == 1) {\n                 // rule added with no sharing\n                 deleteLiaFacts(splitStartNode, wm);\n             }\n\n             LeftTupleSink sink;\n             if ( splitStartNode.getAssociations().size() == 1 ) {\n                 // there is no sharing, so get the node after the root of the only SegmentMemory\n                 SegmentMemory sm =  removedPmem.getSegmentMemories()[s];\n                 if ( sm == null ) {\n                     continue; // this rule has not been initialized yet\n                 }\n                 sink = ((LeftInputAdapterNode)sm.getRootNode()).getSinkPropagator().getFirstLeftTupleSink();\n             } else {\n                 // Sharing exists, get the root of the SegmentMemory after the split\n                 SegmentMemory sm =  removedPmem.getSegmentMemories()[s+1];\n                 if ( sm == null ) {\n                     continue; // this rule has not been initialized yet\n                 }\n                 sink = (LeftTupleSink) removedPmem.getSegmentMemories()[s+1].getRootNode();\n             }\n             deleteFacts( sink, wm);\n\n             if ( splitStartNode.getAssociations().size() > 1 ) {\n                 List<PathMemory> pathMems = new ArrayList<PathMemory>();\n\n                 collectRtnPathMemories(splitStartNode, wm, pathMems, tn); // get all PathMemories, except current\n\n                 List<SegmentMemory[]> previousSmems = reInitPathMemories(wm, pathMems, tn.getRule() );\n\n                 if ( splitStartNode.getSinkPropagator().size() == 2 ) {\n                     // can only be two if the removing node causes the split to be removed\n                     int p = 0;\n                     for ( PathMemory pmem : pathMems) {\n                         SegmentMemory[] smems = previousSmems.get(p);\n\n                         for (int i = 0; i < smems.length; i++ ) {\n                             SegmentMemory sm = smems[i];\n                             if ( sm == null ) {\n                                 continue; // SegmentMemory is not yet initialized\n                             }\n\n                             if ( i < s ) {\n                                 correctSegmentBeforeSplitOnRemove(wm, removedPmem, pmem, sm, p);\n                             } else if ( i == s ) {\n                                 correctSegmentOnSplitOnRemove(wm,  sm, smems[i+1], pmem, removedPmem, p);\n                                 i++; // increase to skip merged segment\n                             } else if (i > s) {\n                                 correctSegmentAfterSplitOnRemove(wm, pmem, i, sm);\n                             }\n                         }\n                         p++;\n                     }\n                 }\n             }\n             if ( removedPmem.getRuleAgendaItem() != null && removedPmem.getRuleAgendaItem().isQueued() ) {\n                 removedPmem.getRuleAgendaItem().dequeue();\n             }\n         }\n     }","id":91006,"modified_method":"public static void removeRule(TerminalNode tn, InternalWorkingMemory[] wms) {\n         if ( log.isTraceEnabled() ) {\n             log.trace(\"Removing Rule {}\", tn.getRule().getName() );\n         }\n\n         LeftTupleSource splitStartNode = getNetworkSplitPoint(tn);\n\n         if (wms.length > 0) {\n             ((ReteooRuleBase)wms[0].getRuleBase()).invalidateSegmentPrototype(splitStartNode);\n         }\n\n         for ( InternalWorkingMemory wm : wms ) {\n\n             PathMemory removedPmem = (PathMemory) wm.getNodeMemory( (MemoryFactory) tn);\n             int s = getSegmentPos(splitStartNode, null);\n\n             // if a segment is going to be merged it is necessary to flush all its staged left tuples before doing any change to the network\n             flushSegmentIfMerge(wm, tn, removedPmem, splitStartNode, s);\n\n             // must be done before segments are mutated\n             flushStagedTuples(splitStartNode, removedPmem, wm, true);\n\n             //\n             if (NodeTypeEnums.LeftInputAdapterNode == splitStartNode.getType() && splitStartNode.getAssociations().size() == 1) {\n                 // rule added with no sharing\n                 deleteLiaFacts(splitStartNode, wm);\n             }\n\n             LeftTupleSink sink;\n             if ( splitStartNode.getAssociations().size() == 1 ) {\n                 // there is no sharing, so get the node after the root of the only SegmentMemory\n                 SegmentMemory sm =  removedPmem.getSegmentMemories()[s];\n                 if ( sm == null ) {\n                     continue; // this rule has not been initialized yet\n                 }\n                 sink = ((LeftInputAdapterNode)sm.getRootNode()).getSinkPropagator().getFirstLeftTupleSink();\n             } else {\n                 // Sharing exists, get the root of the SegmentMemory after the split\n                 SegmentMemory sm =  removedPmem.getSegmentMemories()[s+1];\n                 if ( sm == null ) {\n                     continue; // this rule has not been initialized yet\n                 }\n                 sink = (LeftTupleSink) removedPmem.getSegmentMemories()[s+1].getRootNode();\n             }\n             deleteFacts( sink, wm);\n\n             if ( splitStartNode.getAssociations().size() > 1 ) {\n                 List<PathMemory> pathMems = new ArrayList<PathMemory>();\n\n                 collectRtnPathMemories(splitStartNode, wm, pathMems, tn); // get all PathMemories, except current\n\n                 List<SegmentMemory[]> previousSmems = reInitPathMemories(wm, pathMems, tn.getRule() );\n\n                 if ( splitStartNode.getSinkPropagator().size() == 2 ) {\n                     // can only be two if the removing node causes the split to be removed\n                     int p = 0;\n                     for ( PathMemory pmem : pathMems) {\n                         SegmentMemory[] smems = previousSmems.get(p);\n\n                         for (int i = 0; i < smems.length; i++ ) {\n                             SegmentMemory sm = smems[i];\n                             if ( sm == null ) {\n                                 continue; // SegmentMemory is not yet initialized\n                             }\n\n                             if ( i < s ) {\n                                 correctSegmentBeforeSplitOnRemove(wm, removedPmem, pmem, sm, p);\n                             } else if ( i == s ) {\n                                 correctSegmentOnSplitOnRemove(wm,  sm, smems[i+1], pmem, removedPmem, p);\n                                 i++; // increase to skip merged segment\n                             } else if (i > s) {\n                                 correctSegmentAfterSplitOnRemove(wm, pmem, i, sm);\n                             }\n                         }\n                         p++;\n                     }\n                 }\n             }\n             if ( removedPmem.getRuleAgendaItem() != null && removedPmem.getRuleAgendaItem().isQueued() ) {\n                 removedPmem.getRuleAgendaItem().dequeue();\n             }\n         }\n     }","commit_id":"84144290a4655f114a7e229e1c0357792ead8ee9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static void setValue(Element self, String value) {\n        self.getFirstChild().setNodeValue(value);\n    }","id":91007,"modified_method":"public static void setValue(Element self, String value) {\n        Node firstChild = self.getFirstChild();\n        if (firstChild == null) {\n            firstChild = self.getOwnerDocument().createTextNode(value);\n            self.appendChild(firstChild);\n        }\n        firstChild.setNodeValue(value);\n    }","commit_id":"feca30c017351f48686c09ea041a6c64b00a2494","url":"https://github.com/apache/groovy"},{"original_method":"@PUT\n\t@Consumes({ MediaTypes.APPLICATION_FLIES_DOCUMENT_XML, MediaTypes.APPLICATION_FLIES_DOCUMENT_JSON,\n\t\t\t\tMediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })\n\t@Restrict(\"#{identity.loggedIn}\")\n\tpublic Response put(Document document) throws URISyntaxException {\n\t\t\n\t\tString hDocId = URIHelper.convertFromDocumentURIId(documentId);\n\n\t\tif(!document.getId().equals(hDocId)){\n\t\t\treturn Response.status(Status.BAD_REQUEST).entity(\"Invalid document Id\").build();\n\t\t}\n\n\t\tHProjectContainer hProjectContainer = getContainerOrFail();\n\n\t\tHDocument hDoc = documentDAO.getByDocId(hProjectContainer, hDocId);\n\t\t\n\t\tif(hDoc == null) { // it's a create operation\n\t\t\thDoc = documentConverter.create(document, hProjectContainer);\n\t\t\thProjectContainer.getDocuments().put(hDoc.getDocId(), hDoc);\n\t\t\tsession.save(hDoc);\n\t\t\ttry{\n\t\t\t\tsession.flush();\n\t\t\t\treturn Response.created( uri.getBaseUri().resolve(URIHelper.getDocument(projectSlug, iterationSlug, documentId))).build();\n\t\t\t}\n\t\t\tcatch(Exception e){\n\t\t\t\tlog.error(\"Invalid document content\", e);\n\t\t\t\t// TODO validation on the input data\n\t\t\t\t// this could also be a server error\n\t\t\t\treturn Response.status(Status.BAD_REQUEST).entity(\"Invalid document content\").build();\n\t\t\t}\n\t\t}\n\t\telse{ // it's an update operation\n\t\t\tdocumentConverter.merge(document, hDoc);\n\t\t\tsession.save(hDoc);\n\t\t\tsession.flush();\n\t\t\treturn Response.status(205).build();\n\t\t}\n\t\t\n\t}","id":91008,"modified_method":"@PUT\n\t@Consumes({ MediaTypes.APPLICATION_FLIES_DOCUMENT_XML, MediaTypes.APPLICATION_FLIES_DOCUMENT_JSON,\n\t\t\t\tMediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })\n\t@Restrict(\"#{identity.loggedIn}\")\n\tpublic Response put(Document document) throws URISyntaxException {\n\t\t\n\t\tString hDocId = URIHelper.convertFromDocumentURIId(documentId);\n\n\t\tif(!document.getId().equals(hDocId)){\n\t\t\treturn Response.status(Status.BAD_REQUEST).entity(\"Invalid document Id\").build();\n\t\t}\n\n\t\tHProjectContainer hProjectContainer = getContainer();\n\t\tif(hProjectContainer == null)\n\t\t\treturn containerNotFound();\n\n\t\tHDocument hDoc = documentDAO.getByDocId(hProjectContainer, hDocId);\n\t\t\n\t\tif(hDoc == null) { // it's a create operation\n\t\t\thDoc = documentConverter.create(document, hProjectContainer);\n\t\t\thProjectContainer.getDocuments().put(hDoc.getDocId(), hDoc);\n\t\t\tsession.save(hDoc);\n\t\t\ttry{\n\t\t\t\tsession.flush();\n\t\t\t\treturn Response.created( uri.getBaseUri().resolve(URIHelper.getDocument(projectSlug, iterationSlug, documentId))).build();\n\t\t\t}\n\t\t\tcatch(Exception e){\n\t\t\t\tlog.error(\"Invalid document content\", e);\n\t\t\t\t// TODO validation on the input data\n\t\t\t\t// this could also be a server error\n\t\t\t\treturn Response.status(Status.BAD_REQUEST).entity(\"Invalid document content\").build();\n\t\t\t}\n\t\t}\n\t\telse{ // it's an update operation\n\t\t\tdocumentConverter.merge(document, hDoc);\n\t\t\tsession.save(hDoc);\n\t\t\tsession.flush();\n\t\t\treturn Response.status(205).build();\n\t\t}\n\t\t\n\t}","commit_id":"bb8f291cc4407f1ec11219e4e905eec72e7004ed","url":"https://github.com/zanata/zanata-server"},{"original_method":"private HProjectContainer getContainerOrFail(){\n\t\tHProjectContainer hProjectContainer = projectContainerDAO.getBySlug(projectSlug, iterationSlug); \n\t\t\n\t\tif(hProjectContainer == null)\n\t\t\tthrow new WebApplicationException(\n\t\t\t\t\tResponse.status(Status.NOT_FOUND).entity(\"Project Container not found\").build());\n\t\t\n\t\treturn hProjectContainer;\n\t}","id":91009,"modified_method":"private HProjectContainer getContainer() {\n\t\tif (projectContainer != null)\n\t\t\treturn projectContainer;\n\t\tprojectContainer = projectContainerDAO.getBySlug(\n\t\t\t\tgetProjectSlug(), \n\t\t\t\tgetIterationSlug());\n\t\treturn projectContainer;\n\t}","commit_id":"bb8f291cc4407f1ec11219e4e905eec72e7004ed","url":"https://github.com/zanata/zanata-server"},{"original_method":"@POST\n\t@Consumes({ MediaTypes.APPLICATION_FLIES_DOCUMENTS_XML, MediaType.APPLICATION_JSON })\n\t@Restrict(\"#{identity.loggedIn}\")\n\tpublic Response post(Documents documents) {\n\t    impl.post(documents);\n\t    return Response.ok().build();\n\t}","id":91010,"modified_method":"@POST\n\t@Consumes({ MediaTypes.APPLICATION_FLIES_DOCUMENTS_XML, MediaType.APPLICATION_JSON })\n\t@Restrict(\"#{identity.loggedIn}\")\n\tpublic Response post(Documents documents) {\n\t    return impl.post(documents);\n\t}","commit_id":"bb8f291cc4407f1ec11219e4e905eec72e7004ed","url":"https://github.com/zanata/zanata-server"},{"original_method":"@GET\n\t@Produces({ MediaTypes.APPLICATION_FLIES_DOCUMENTS_XML, MediaType.APPLICATION_JSON })\n\tpublic Documents get() {\n\t    return impl.get();\n\t}","id":91011,"modified_method":"@GET\n\t@Produces({ MediaTypes.APPLICATION_FLIES_DOCUMENTS_XML, MediaType.APPLICATION_JSON })\n\tpublic Response get() {\n\t    return impl.get();\n\t}","commit_id":"bb8f291cc4407f1ec11219e4e905eec72e7004ed","url":"https://github.com/zanata/zanata-server"},{"original_method":"public Response put(Documents docs) {\n    \tlog.debug(\"HTTP PUT {0} : \\n{1}\",documentsService.getRequest().getRequestURL(), docs);\n    \tHProjectContainer hContainer = getContainer();\n    \tMap<String, HDocument> docMap = hContainer.getDocuments();\n    \t// any Docs still in this set at the end will be marked obsolete\n    \tSet<HDocument> obsoleteDocs = new HashSet<HDocument>(docMap.values());\n    \tClassValidator<HDocument> docValidator = new ClassValidator<HDocument>(HDocument.class);\n    \tStringBuilder sb = new StringBuilder();\n\n    \tfor (Document doc: docs.getDocuments()) {\n\t\t\t// if doc already exists, load it and update it, but don't create it\n    \t\tHDocument hDoc = documentDAO.getByDocId(hContainer, doc.getId()); \n    \t\tif (hDoc == null) {\n    \t\t\tlog.debug(\"PUT creating new HDocument with id {0}\", doc.getId());\n    \t\t\thDoc = new HDocument(doc);\n    \t\t\thDoc.setRevision(1);\n    \t\t\thDoc.setProject(hContainer);\n    \t\t} else {\n    \t\t\tlog.debug(\"PUT updating HDocument with id {0}\", doc.getId());\n    \t\t\tobsoleteDocs.remove(hDoc);\n    \t\t}\n    \t\tdocMap.put(hDoc.getDocId(), hDoc);\n    \t\ttry {\n\t\t\t\tdocumentConverter.copy(doc, hDoc, true);\n\t\t\t\tInvalidValue[] invalidValues = docValidator.getInvalidValues(hDoc);\n\t\t\t\tif (invalidValues.length != 0) {\n\t\t\t\t\tString message = \"Document with id '\"+doc.getId()+\"' is invalid: \"+Arrays.asList(invalidValues);\n\t\t\t\t\tobsoleteDocs.add(hDoc);\n\t\t\t\t\tlog.error(message);\n\t\t\t\t\tsb.append(message);\n\t\t\t\t\tsb.append('\\n');\n\t\t\t\t} else {\n\t\t\t\t\tsession.save(hDoc);\n\t\t\t\t}\n\t\t\t} catch (InvalidStateException e) {\n\t\t\t\tString message = \"Document with id '\"+doc.getId()+\"' is invalid: \"+Arrays.asList(e.getInvalidValues());\n\t\t\t\tlog.error(message+'\\n'+doc, e);\n\t\t\t\tthrow new WebApplicationException(\n\t\t\t\t\t\tResponse.status(Status.BAD_REQUEST).entity(message).build());\n\t\t\t}\n//\t\t\tsession.save(hDoc);\n    \t}\n    \tfor (HDocument hDoc: obsoleteDocs) {\n    \t\thDoc.setObsolete(true);\n    \t\tdocMap.remove(hDoc.getId());\n    \t}\n    \tsession.flush();\n    \treturn Response.status(Status.OK).entity(sb.toString()).build();\n    }","id":91012,"modified_method":"@Override\n    public Response put(Documents docs) {\n    \tlog.debug(\"HTTP PUT {0} : \\n{1}\",documentsService.getRequest().getRequestURL(), docs);\n    \tHProjectContainer hContainer = getContainer();\n    \tif (hContainer == null)\n    \t\treturn containerNotFound();\n    \tMap<String, HDocument> docMap = hContainer.getDocuments();\n    \t// any Docs still in this set at the end will be marked obsolete\n    \tSet<HDocument> obsoleteDocs = new HashSet<HDocument>(docMap.values());\n    \tClassValidator<HDocument> docValidator = new ClassValidator<HDocument>(HDocument.class);\n    \tStringBuilder sb = new StringBuilder();\n\n    \tfor (Document doc: docs.getDocuments()) {\n\t\t\t// if doc already exists, load it and update it, but don't create it\n    \t\tHDocument hDoc = documentDAO.getByDocId(hContainer, doc.getId()); \n    \t\tif (hDoc == null) {\n    \t\t\tlog.debug(\"PUT creating new HDocument with id {0}\", doc.getId());\n    \t\t\thDoc = new HDocument(doc);\n    \t\t\thDoc.setRevision(1);\n    \t\t\thDoc.setProject(hContainer);\n    \t\t} else {\n    \t\t\tlog.debug(\"PUT updating HDocument with id {0}\", doc.getId());\n    \t\t\tobsoleteDocs.remove(hDoc);\n    \t\t}\n    \t\tdocMap.put(hDoc.getDocId(), hDoc);\n    \t\ttry {\n\t\t\t\tdocumentConverter.copy(doc, hDoc, true);\n\t\t\t\tInvalidValue[] invalidValues = docValidator.getInvalidValues(hDoc);\n\t\t\t\tif (invalidValues.length != 0) {\n\t\t\t\t\tString message = \"Document with id '\"+doc.getId()+\"' is invalid: \"+Arrays.asList(invalidValues);\n\t\t\t\t\tobsoleteDocs.add(hDoc);\n\t\t\t\t\tlog.error(message);\n\t\t\t\t\tsb.append(message);\n\t\t\t\t\tsb.append('\\n');\n\t\t\t\t} else {\n\t\t\t\t\tsession.save(hDoc);\n\t\t\t\t}\n\t\t\t} catch (InvalidStateException e) {\n\t\t\t\tString message = \"Document with id '\"+doc.getId()+\"' is invalid: \"+Arrays.asList(e.getInvalidValues());\n\t\t\t\tlog.error(message+'\\n'+doc, e);\n\t\t\t\treturn Response.status(Status.BAD_REQUEST).entity(message).build();\n\t\t\t}\n//\t\t\tsession.save(hDoc);\n    \t}\n    \tfor (HDocument hDoc: obsoleteDocs) {\n    \t\thDoc.setObsolete(true);\n    \t\tdocMap.remove(hDoc.getId());\n    \t}\n    \tsession.flush();\n    \treturn Response.status(Status.OK).entity(sb.toString()).build();\n    }","commit_id":"bb8f291cc4407f1ec11219e4e905eec72e7004ed","url":"https://github.com/zanata/zanata-server"},{"original_method":"public Documents get() {\n    \tlog.debug(\"HTTP GET {0}\", documentsService.getRequest().getRequestURL());\n//    \tURI baseUri = documentsService.getUri().getBaseUri();\n    \tCollection<HDocument> hdocs = getContainer().getDocuments().values();\n    \tDocuments result = new Documents();\n\t\n    \tfor (HDocument hDocument : hdocs) {\n    \t\tDocument doc = hDocument.toDocument(true);\n\t\t\tresult.getDocuments().add(doc);\n\t\t\t\n//\t\t\tURI docUri = baseUri.resolve(URIHelper.getDocument(\n//\t\t\t\t\tgetProjectSlug(), getIterationSlug(), doc.getId()));\n//\t\t\tURI iterationUri = baseUri.resolve(URIHelper.getIteration(\n//\t\t\t\t\tgetProjectSlug(), getIterationSlug()));\n//\t\t\tdocumentConverter.addLinks(doc, docUri, iterationUri );\n    \t}\n    \tlog.debug(\"HTTP GET result :\\n\"+result);\n    \treturn result;\n    }","id":91013,"modified_method":"@Override\n    public Response get() {\n    \tlog.debug(\"HTTP GET {0}\", documentsService.getRequest().getRequestURL());\n//    \tURI baseUri = documentsService.getUri().getBaseUri();\n    \tif (getContainer() == null)\n    \t\treturn containerNotFound();\n    \tCollection<HDocument> hdocs = getContainer().getDocuments().values();\n    \tDocuments result = new Documents();\n\t\n    \tfor (HDocument hDocument : hdocs) {\n    \t\tDocument doc = hDocument.toDocument(true);\n\t\t\tresult.getDocuments().add(doc);\n\t\t\t\n//\t\t\tURI docUri = baseUri.resolve(URIHelper.getDocument(\n//\t\t\t\t\tgetProjectSlug(), getIterationSlug(), doc.getId()));\n//\t\t\tURI iterationUri = baseUri.resolve(URIHelper.getIteration(\n//\t\t\t\t\tgetProjectSlug(), getIterationSlug()));\n//\t\t\tdocumentConverter.addLinks(doc, docUri, iterationUri );\n    \t}\n    \tlog.debug(\"HTTP GET result :\\n\"+result);\n    \treturn Response.ok(result).build();\n    }","commit_id":"bb8f291cc4407f1ec11219e4e905eec72e7004ed","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void post(Documents docs) {\n    \tlog.debug(\"HTTP POST {0} : \\n{1}\",documentsService.getRequest().getRequestURL(), docs);\n    \tHProjectContainer hContainer = getContainer();\n    \tMap<String, HDocument> docMap = hContainer.getDocuments();\n    \tfor (Document doc: docs.getDocuments()) {\n\t\t\t// if doc already exists, load it and update it, but don't create it\n    \t\tHDocument hDoc = docMap.get(doc.getId());\n    \t\tif (hDoc == null) {\n    \t\t\tlog.info(\"POST creating new HDocument with id {0}\", doc.getId());\n    \t\t\thDoc = new HDocument(doc);\n    \t\t\thDoc.setRevision(1);\n    \t\t\thDoc.setProject(hContainer);\n    \t\t} else {\n    \t\t\tlog.info(\"POST updating HDocument with id {0}\", doc.getId());\n    \t\t}\n    \t\t\n\t\t\tdocMap.put(hDoc.getDocId(), hDoc);\n\t\t\t// TODO handle invalid data.  See put()\n    \t\tsession.save(hDoc);\n    \t\tdocumentConverter.copy(doc, hDoc, true);\n    \t}\n    \tsession.flush();\n    }","id":91014,"modified_method":"@Override\n    public Response post(Documents docs) {\n    \tlog.debug(\"HTTP POST {0} : \\n{1}\",documentsService.getRequest().getRequestURL(), docs);\n    \tHProjectContainer hContainer = getContainer();\n    \tif (hContainer == null)\n    \t\treturn containerNotFound();\n    \tMap<String, HDocument> docMap = hContainer.getDocuments();\n    \tfor (Document doc: docs.getDocuments()) {\n\t\t\t// if doc already exists, load it and update it, but don't create it\n    \t\tHDocument hDoc = docMap.get(doc.getId());\n    \t\tif (hDoc == null) {\n    \t\t\tlog.info(\"POST creating new HDocument with id {0}\", doc.getId());\n    \t\t\thDoc = new HDocument(doc);\n    \t\t\thDoc.setRevision(1);\n    \t\t\thDoc.setProject(hContainer);\n    \t\t} else {\n    \t\t\tlog.info(\"POST updating HDocument with id {0}\", doc.getId());\n    \t\t}\n    \t\t\n\t\t\tdocMap.put(hDoc.getDocId(), hDoc);\n\t\t\t// TODO handle invalid data.  See put()\n    \t\tsession.save(hDoc);\n    \t\tdocumentConverter.copy(doc, hDoc, true);\n    \t}\n    \tsession.flush();\n    \treturn Response.ok().build();\n    }","commit_id":"bb8f291cc4407f1ec11219e4e905eec72e7004ed","url":"https://github.com/zanata/zanata-server"},{"original_method":"private HProjectContainer getContainer() {\n\t\tHProjectContainer result = projectContainerDAO.getBySlug(\n\t\t\t\tgetProjectSlug(), \n\t\t\t\tgetIterationSlug());\n\t\tif (result == null) {\n\t\t\t// TODO use a Response, not an exception\n\t\t\tthrow new WebApplicationException(Response.status(Status.NOT_FOUND).entity(\"Container not found\").build());\n\t\t}\n\t\treturn result;\n\t}","id":91015,"modified_method":"private HProjectContainer getContainer() {\n\t\tif (projectContainer != null)\n\t\t\treturn projectContainer;\n\t\tprojectContainer = projectContainerDAO.getBySlug(\n\t\t\t\tgetProjectSlug(), \n\t\t\t\tgetIterationSlug());\n\t\treturn projectContainer;\n\t}","commit_id":"bb8f291cc4407f1ec11219e4e905eec72e7004ed","url":"https://github.com/zanata/zanata-server"},{"original_method":"@PUT\n\t@Consumes({ MediaTypes.APPLICATION_FLIES_PROJECT_XML, MediaType.APPLICATION_JSON })\n\t@Restrict(\"#{identity.loggedIn}\")\n\tpublic Response put(Project project) throws URISyntaxException{\n\t\t\n\t\tHProject hProject = projectDAO.getBySlug(project.getId());\n\t\tif(hProject == null){\n\t\t\treturn Response.status(Status.BAD_REQUEST).build();\n\t\t}\n\t\t//hProject = new org.fedorahosted.flies.core.model.HIterationProject();\n\t\thProject.setSlug(project.getId());\n\t\thProject.setName(project.getName());\n\t\thProject.setDescription(project.getDescription());\n\t\tHAccount hAccount = accountDAO.getByUsername(Identity.instance().getCredentials().getUsername());\n\t\tif(hAccount != null && hAccount.getPerson() != null) {\n\t\t\thProject.getMaintainers().add(hAccount.getPerson());\n\t\t}\n\t\t\n\t\ttry{\n\t\t\tsession.flush();\n\t\t\treturn Response.created( new URI(\"/projects/p/\"+hProject.getSlug()) ).build();\n\t\t}\n        catch(InvalidStateException e){\n        \treturn Response.status(Status.BAD_REQUEST).build();\n        }\n        catch(HibernateException e){\n\t\t\treturn Response.status(Status.INTERNAL_SERVER_ERROR).build();\n\t\t}\n\t}","id":91016,"modified_method":"@PUT\n\t@Consumes({ MediaTypes.APPLICATION_FLIES_PROJECT_XML, MediaType.APPLICATION_JSON })\n\t@Restrict(\"#{identity.loggedIn}\")\n\tpublic Response put(Project project) throws URISyntaxException{\n\t\t\n\t\tHProject hProject = projectDAO.getBySlug(project.getId());\n\t\tif(hProject == null){\n\t\t\treturn Response.status(Status.BAD_REQUEST).build();\n\t\t}\n\t\t//hProject = new org.fedorahosted.flies.core.model.HIterationProject();\n\t\thProject.setSlug(project.getId());\n\t\thProject.setName(project.getName());\n\t\thProject.setDescription(project.getDescription());\n\t\tHAccount hAccount = accountDAO.getByUsername(Identity.instance().getCredentials().getUsername());\n\t\tif(hAccount != null && hAccount.getPerson() != null) {\n\t\t\thProject.getMaintainers().add(hAccount.getPerson());\n\t\t}\n\t\t\n\t\ttry{\n\t\t\tsession.flush();\n\t\t\treturn Response.ok().build();\n\t\t}\n        catch(InvalidStateException e){\n        \treturn Response.status(Status.BAD_REQUEST).build();\n        }\n        catch(HibernateException e){\n\t\t\treturn Response.status(Status.INTERNAL_SERVER_ERROR).build();\n\t\t}\n\t}","commit_id":"bb8f291cc4407f1ec11219e4e905eec72e7004ed","url":"https://github.com/zanata/zanata-server"},{"original_method":"@GET\n\t@Produces({ MediaTypes.APPLICATION_FLIES_PROJECT_XML, MediaType.APPLICATION_JSON })\n\tpublic Project get() {\n\n\t\tHProject hProject = projectDAO.getBySlug(projectSlug);\n\t\tif(hProject == null)\n\t\t\t// TODO use a Response, not an exception\n\t\t\tthrow new WebApplicationException(Status.NOT_FOUND);\n\t\t\n\t\treturn toMini(hProject);\n\t}","id":91017,"modified_method":"@GET\n\t@Produces({ MediaTypes.APPLICATION_FLIES_PROJECT_XML, MediaType.APPLICATION_JSON })\n\tpublic Response get() {\n\n\t\tHProject hProject = projectDAO.getBySlug(projectSlug);\n\t\tif(hProject == null)\n\t\t\treturn Response.status(Status.NOT_FOUND).build();\n\t\t\n\t\treturn Response.ok(toMini(hProject)).build();\n\t}","commit_id":"bb8f291cc4407f1ec11219e4e905eec72e7004ed","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void updateProject() {\n\t\tProject project = new Project(\"sample-project\", \"My Project Update\", \"Update project\");\n\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(\"sample-project\"));\n\t\t\n\t\tResponse response = projectService.put(project);\n\t\t\t\t\n\t\tassertThat( response.getStatus(), is( Status.CREATED.getStatusCode()));\n\t\t\n\t\tClientResponse<Project> projectResponse = projectService.get();\n\t\t\n\t\tassertThat( projectResponse.getStatus(), is( Status.OK.getStatusCode()));\n\t\t\n\t\tproject = projectResponse.getEntity();\n\t\t\n\t\tassertThat( project.getName(), is(\"My Project Update\"));\n\t\tassertThat( project.getDescription(), is(\"Update project\"));\n\t}","id":91018,"modified_method":"public void updateProject() {\n\t\tProject project = new Project(\"sample-project\", \"My Project Update\", \"Update project\");\n\n\t\tprojectService = clientRequestFactory.createProxy(IProjectResource.class, baseUri.resolve(\"sample-project\"));\n\t\t\n\t\tResponse response = projectService.put(project);\n\t\t\t\t\n\t\tassertThat( response.getStatus(), is( Status.OK.getStatusCode()));\n\t\t\n\t\tClientResponse<Project> projectResponse = projectService.get();\n\t\t\n\t\tassertThat( projectResponse.getStatus(), is( Status.OK.getStatusCode()));\n\t\t\n\t\tproject = projectResponse.getEntity();\n\t\t\n\t\tassertThat( project.getName(), is(\"My Project Update\"));\n\t\tassertThat( project.getDescription(), is(\"Update project\"));\n\t}","commit_id":"bb8f291cc4407f1ec11219e4e905eec72e7004ed","url":"https://github.com/zanata/zanata-server"},{"original_method":"public List<Status> getAllStatus()\n   {\n      List<Status> result = new ArrayList<Status>();\n      HProjectIteration iteration = projectIterationDAO.getBySlug(this.projectSlug, this.iterationSlug);\n      Map<String, TransUnitWords> stats = projectIterationDAO.getAllWordStatsStatistics(iteration.getId());\n      List<HLocale> locale = localeServiceImpl.getSupportedLangugeByProjectIteration(this.projectSlug, this.iterationSlug);\n      Long total = projectIterationDAO.getTotalCountForIteration(iteration.getId());\n      for (HLocale var : locale)\n      {\n         TransUnitWords words = stats.get(var.getLocaleId().getId());\n         if (words == null)\n         {\n            words = new TransUnitWords();\n            words.set(ContentState.New, total.intValue());\n\n         }\n         int per;\n         if (total.intValue() == 0)\n         {\n            per = 0;\n         }\n         else\n         {\n            per = (int) Math.ceil(100 * words.getApproved() / words.getTotal());\n\n         }\n         Status op = new Status(var.getLocaleId().getId(), var.retrieveNativeName(), words, per);\n         result.add(op);\n      }\n      Collections.sort(result);\n      return result;\n   }","id":91019,"modified_method":"public List<Status> getAllStatus()\n   {\n      List<Status> result = new ArrayList<Status>();\n      HProjectIteration iteration = projectIterationDAO.getBySlug(this.projectSlug, this.iterationSlug);\n      Map<String, TransUnitWords> stats = projectIterationDAO.getAllWordStatsStatistics(iteration.getId());\n      List<HLocale> locale = this.getDisplayLocales();\n      Long total = projectIterationDAO.getTotalCountForIteration(iteration.getId());\n      for (HLocale var : locale)\n      {\n         TransUnitWords words = stats.get(var.getLocaleId().getId());\n         if (words == null)\n         {\n            words = new TransUnitWords();\n            words.set(ContentState.New, total.intValue());\n\n         }\n         int per;\n         if (total.intValue() == 0)\n         {\n            per = 0;\n         }\n         else\n         {\n            per = (int) Math.ceil(100 * words.getApproved() / words.getTotal());\n\n         }\n         boolean isMember = authenticatedAccount != null ? authenticatedAccount.getPerson().isMember(var) : false;\n         \n         Status op = new Status(var.getLocaleId().getId(), var.retrieveNativeName(), words, per, isMember);\n         result.add(op);\n      }\n      Collections.sort(result);\n      return result;\n   }","commit_id":"dad0f31c526f9a8393799ec2ea8d9fb088e8e418","url":"https://github.com/zanata/zanata-server"},{"original_method":"public Status(String locale, String nativeName, TransUnitWords words, int per)\n      {\n         this.locale = locale;\n         this.nativeName = nativeName;\n         this.words = words;\n         this.per = per;\n      }","id":91020,"modified_method":"public Status(String locale, String nativeName, TransUnitWords words, int per, boolean userInLanguageTeam)\n      {\n         this.locale = locale;\n         this.nativeName = nativeName;\n         this.words = words;\n         this.per = per;\n         this.userInLanguageTeam = userInLanguageTeam;\n      }","commit_id":"dad0f31c526f9a8393799ec2ea8d9fb088e8e418","url":"https://github.com/zanata/zanata-server"},{"original_method":"public HProjectIteration getProjectIteration()\n   {\n      return projectIterationDAO.getBySlug(projectSlug, iterationSlug);\n   }","id":91021,"modified_method":"public HProjectIteration getProjectIteration()\n   {\n      if( this.projectIteration == null )\n      {\n         this.projectIteration = projectIterationDAO.getBySlug(projectSlug, iterationSlug);\n      }\n      return this.projectIteration;\n   }","commit_id":"dad0f31c526f9a8393799ec2ea8d9fb088e8e418","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void bindClassSources(final DeploymentUnit deploymentUnit, final AnnotationInstance annotation, final EEModuleClassDescription classDescription)\n        throws DeploymentUnitProcessingException {\n\n        // handle PersistenceContext and PersistenceUnit annotations\n        if (isPersistenceContext(annotation) ||\n                isPersistenceUnit(annotation)) {\n            String injectionTypeName = getClassLevelInjectionType(annotation);\n            InjectionSource injectionSource = getBindingSource(deploymentUnit, annotation, injectionTypeName, classDescription);\n            if (injectionSource != null) {\n                final AnnotationValue nameValue = annotation.value(\"name\");\n                if (nameValue == null || nameValue.asString().isEmpty()) {\n                    throw MESSAGES.classLevelAnnotationParameterRequired(annotation.name().toString(), \"name\");\n                }\n                final String name = nameValue.asString();\n\n                final BindingConfiguration bindingConfiguration = new BindingConfiguration(name, injectionSource);\n                classDescription.getBindingConfigurations().add(bindingConfiguration);\n            }\n        } else if (isPersistenceUnits(annotation)) {\n            // handle PersistenceUnits (array of PersistenceUnit)\n            AnnotationValue containedPersistenceUnits = annotation.value(\"value\");\n            AnnotationInstance[] arrayPersistenceUnits;\n            if (containedPersistenceUnits != null &&\n                (arrayPersistenceUnits = containedPersistenceUnits.asNestedArray()) != null) {\n                for (int source = 0; source < arrayPersistenceUnits.length; source++) {\n                    String injectionTypeName = getClassLevelInjectionType(arrayPersistenceUnits[source]);\n                    InjectionSource injectionSource = getBindingSource(deploymentUnit, arrayPersistenceUnits[source], injectionTypeName, classDescription);\n                    if (injectionSource != null) {\n                        final AnnotationValue nameValue = arrayPersistenceUnits[source].value(\"name\");\n                        if (nameValue == null || nameValue.asString().isEmpty()) {\n                            throw MESSAGES.classLevelAnnotationParameterRequired(arrayPersistenceUnits[source].name().toString(), \"name\");\n                        }\n                        final String name = nameValue.asString();\n\n                        final BindingConfiguration bindingConfiguration = new BindingConfiguration(name, injectionSource);\n                        classDescription.getBindingConfigurations().add(bindingConfiguration);\n                    }\n                }\n            }\n        } else if (isPersistenceContexts(annotation)) {\n            // handle PersistenceContexts (array of PersistenceContext)\n            AnnotationValue containedPersistenceContexts = annotation.value(\"value\");\n            AnnotationInstance[] arrayPersistenceContexts;\n            if (containedPersistenceContexts != null &&\n                (arrayPersistenceContexts = containedPersistenceContexts.asNestedArray()) != null) {\n                for (int source = 0; source < arrayPersistenceContexts.length; source++) {\n                    String injectionTypeName = getClassLevelInjectionType(arrayPersistenceContexts[source]);\n                    InjectionSource injectionSource = getBindingSource(deploymentUnit, arrayPersistenceContexts[source], injectionTypeName, classDescription);\n                    if (injectionSource != null) {\n                        final AnnotationValue nameValue = arrayPersistenceContexts[source].value(\"name\");\n                        if (nameValue == null || nameValue.asString().isEmpty()) {\n                            throw MESSAGES.classLevelAnnotationParameterRequired(arrayPersistenceContexts[source].name().toString(), \"name\");\n                        }\n                        final String name = nameValue.asString();\n\n                        final BindingConfiguration bindingConfiguration = new BindingConfiguration(name, injectionSource);\n                        classDescription.getBindingConfigurations().add(bindingConfiguration);\n                    }\n                }\n            }\n        }\n    }","id":91022,"modified_method":"private void bindClassSources(final DeploymentUnit deploymentUnit, final AnnotationInstance annotation, final EEModuleClassDescription classDescription)\n        throws DeploymentUnitProcessingException {\n\n        // handle PersistenceContext and PersistenceUnit annotations\n        if (isPersistenceContext(annotation) ||\n                isPersistenceUnit(annotation)) {\n            String injectionTypeName = getClassLevelInjectionType(annotation);\n            InjectionSource injectionSource = getBindingSource(deploymentUnit, annotation, injectionTypeName, classDescription);\n            if (injectionSource != null) {\n                final AnnotationValue nameValue = annotation.value(\"name\");\n                if (nameValue == null || nameValue.asString().isEmpty()) {\n                    classDescription.setInvalid(MESSAGES.classLevelAnnotationParameterRequired(annotation.name().toString(), classDescription.getClassName(), \"name\"));\n                    return;\n                }\n                final String name = nameValue.asString();\n\n                final BindingConfiguration bindingConfiguration = new BindingConfiguration(name, injectionSource);\n                classDescription.getBindingConfigurations().add(bindingConfiguration);\n            }\n        } else if (isPersistenceUnits(annotation)) {\n            // handle PersistenceUnits (array of PersistenceUnit)\n            AnnotationValue containedPersistenceUnits = annotation.value(\"value\");\n            AnnotationInstance[] arrayPersistenceUnits;\n            if (containedPersistenceUnits != null &&\n                (arrayPersistenceUnits = containedPersistenceUnits.asNestedArray()) != null) {\n                for (int source = 0; source < arrayPersistenceUnits.length; source++) {\n                    String injectionTypeName = getClassLevelInjectionType(arrayPersistenceUnits[source]);\n                    InjectionSource injectionSource = getBindingSource(deploymentUnit, arrayPersistenceUnits[source], injectionTypeName, classDescription);\n                    if (injectionSource != null) {\n                        final AnnotationValue nameValue = arrayPersistenceUnits[source].value(\"name\");\n                        if (nameValue == null || nameValue.asString().isEmpty()) {\n                            classDescription.setInvalid(MESSAGES.classLevelAnnotationParameterRequired(arrayPersistenceUnits[source].name().toString(), classDescription.getClassName(), \"name\"));\n                            return;\n                        }\n                        final String name = nameValue.asString();\n\n                        final BindingConfiguration bindingConfiguration = new BindingConfiguration(name, injectionSource);\n                        classDescription.getBindingConfigurations().add(bindingConfiguration);\n                    }\n                }\n            }\n        } else if (isPersistenceContexts(annotation)) {\n            // handle PersistenceContexts (array of PersistenceContext)\n            AnnotationValue containedPersistenceContexts = annotation.value(\"value\");\n            AnnotationInstance[] arrayPersistenceContexts;\n            if (containedPersistenceContexts != null &&\n                (arrayPersistenceContexts = containedPersistenceContexts.asNestedArray()) != null) {\n                for (int source = 0; source < arrayPersistenceContexts.length; source++) {\n                    String injectionTypeName = getClassLevelInjectionType(arrayPersistenceContexts[source]);\n                    InjectionSource injectionSource = getBindingSource(deploymentUnit, arrayPersistenceContexts[source], injectionTypeName, classDescription);\n                    if (injectionSource != null) {\n                        final AnnotationValue nameValue = arrayPersistenceContexts[source].value(\"name\");\n                        if (nameValue == null || nameValue.asString().isEmpty()) {\n                            classDescription.setInvalid(MESSAGES.classLevelAnnotationParameterRequired(arrayPersistenceContexts[source].name().toString(), classDescription.getClassName(), \"name\"));\n                            return;\n                        }\n                        final String name = nameValue.asString();\n\n                        final BindingConfiguration bindingConfiguration = new BindingConfiguration(name, injectionSource);\n                        classDescription.getBindingConfigurations().add(bindingConfiguration);\n                    }\n                }\n            }\n        }\n    }","commit_id":"543a425a7e0987cc5090b011fa641f704de52e1f","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static boolean filterJspErrors(final PsiErrorElement element) {\n    PsiElement nextSibling = element.getNextSibling();\n\n    if (nextSibling == null) {\n      final PsiFile containingFile = element.getContainingFile();\n      if (PsiUtil.isInJspFile(containingFile)) {\n        final JspxFileViewProvider viewProvider = (JspxFileViewProvider)containingFile.getViewProvider();\n        nextSibling = viewProvider.findElementAt(element.getTextOffset() + 1, viewProvider.getTemplateDataLanguage());\n      }\n    }\n\n    while (nextSibling instanceof PsiWhiteSpace) {\n      nextSibling = nextSibling.getNextSibling();\n    }\n\n    final PsiElement psiElement = PsiTreeUtil.findCommonParent(nextSibling, element);\n    if ((nextSibling instanceof OuterLanguageElement ||\n         nextSibling instanceof JspExpression ||\n         nextSibling instanceof ELExpressionHolder\n        ) && psiElement != null && !(psiElement instanceof PsiFile) // error is not inside jsp text\n       ) {\n      return true;\n    }\n\n    final XmlAttributeValue parentOfType = PsiTreeUtil.getParentOfType(element, XmlAttributeValue.class);\n    if(parentOfType != null && parentOfType.getUserData(DO_NOT_VALIDATE_KEY) != null) {\n      return true;\n    }\n\n    final ASTNode astNode = TreeUtil.prevLeaf(element.getNode());\n    if (astNode != null && astNode.getPsi() instanceof OuterLanguageElement) {\n      return true;\n    }\n\n    return element.getParent().getUserData(DO_NOT_VALIDATE_KEY) != null;\n\n  }","id":91023,"modified_method":"private static boolean filterJspErrors(final PsiErrorElement element) {\n    PsiElement nextSibling = element.getNextSibling();\n\n    if (nextSibling == null) {\n      final PsiFile containingFile = element.getContainingFile();\n      if (PsiUtil.isInJspFile(containingFile)) {\n        final JspxFileViewProvider viewProvider = (JspxFileViewProvider)containingFile.getViewProvider();\n        nextSibling = viewProvider.findElementAt(element.getTextOffset() + 1, viewProvider.getTemplateDataLanguage());\n      }\n    }\n\n    while (nextSibling instanceof PsiWhiteSpace) {\n      nextSibling = nextSibling.getNextSibling();\n    }\n\n    final PsiElement psiElement = nextSibling == null ? null : PsiTreeUtil.findCommonParent(nextSibling, element);\n    if ((nextSibling instanceof OuterLanguageElement ||\n         nextSibling instanceof JspExpression ||\n         nextSibling instanceof ELExpressionHolder\n        ) && psiElement != null && !(psiElement instanceof PsiFile) // error is not inside jsp text\n       ) {\n      return true;\n    }\n\n    final XmlAttributeValue parentOfType = PsiTreeUtil.getParentOfType(element, XmlAttributeValue.class);\n    if(parentOfType != null && parentOfType.getUserData(DO_NOT_VALIDATE_KEY) != null) {\n      return true;\n    }\n\n    final ASTNode astNode = TreeUtil.prevLeaf(element.getNode());\n    if (astNode != null && astNode.getPsi() instanceof OuterLanguageElement) {\n      return true;\n    }\n\n    return element.getParent().getUserData(DO_NOT_VALIDATE_KEY) != null;\n\n  }","commit_id":"80bba244770c2eb2e3b2eb5fee3e322212b7dafd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processText(PsiFile file, final FormatTextRanges ranges, boolean doPostponedFormatting) {\n    final Project project = file.getProject();\n    Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n    final List<FormatTextRanges.FormatTextRange> textRanges = ranges.getRanges();\n    if (document instanceof DocumentWindow) {\n      file = InjectedLanguageUtil.getTopLevelFile(file);\n      final DocumentWindow documentWindow = (DocumentWindow)document;\n      for (FormatTextRanges.FormatTextRange range : textRanges) {\n        range.setTextRange(documentWindow.injectedToHost(range.getTextRange()));\n      }\n      document = documentWindow.getDelegate();\n    }\n\n\n    final FormattingModelBuilder builder = LanguageFormatting.INSTANCE.forContext(file);\n\n    if (builder != null) {\n      if (file.getTextLength() > 0) {\n        try {\n          final PsiElement startElement = file.findElementAt(textRanges.get(0).getTextRange().getStartOffset());\n          final PsiElement endElement = file.findElementAt(textRanges.get(textRanges.size() - 1).getTextRange().getEndOffset() - 1);\n          final PsiElement commonParent = PsiTreeUtil.findCommonParent(startElement, endElement);\n          ASTNode node = null;\n          if (commonParent != null) {\n            node = commonParent.getNode();\n          }\n          if (node == null) {\n            node = file.getNode();\n          }\n          ranges.preprocess(node);\n          if (doPostponedFormatting) {\n            RangeMarker[] markers = new RangeMarker[textRanges.size()];\n            int i = 0;\n            for (FormatTextRanges.FormatTextRange range : textRanges) {\n              TextRange textRange = range.getTextRange();\n              int start = textRange.getStartOffset();\n              int end = textRange.getEndOffset();\n              if (start >= 0 && end > start && end <= document.getTextLength()) {\n                markers[i] = document.createRangeMarker(textRange);\n                markers[i].setGreedyToLeft(true);\n                markers[i].setGreedyToRight(true);\n                i++;\n              }\n            }\n            final PostprocessReformattingAspect component = file.getProject().getComponent(PostprocessReformattingAspect.class);\n            component.doPostponedFormatting(file.getViewProvider());\n            i = 0;\n            for (FormatTextRanges.FormatTextRange range : textRanges) {\n              RangeMarker marker = markers[i];\n              if (marker != null) {\n                range.setTextRange(new TextRange(marker.getStartOffset(), marker.getEndOffset()));\n                marker.dispose();\n              }\n              i++;\n            }\n\n          }\n          final FormattingModel originalModel = builder.createModel(file, mySettings);\n          final FormattingModel model = new DocumentBasedFormattingModel(originalModel.getRootBlock(),\n                                                                         document,\n                                                                         project, mySettings, file.getFileType(), file);\n\n          FormatterEx.getInstanceEx().format(model, mySettings, mySettings.getIndentOptions(file.getFileType()), ranges);\n          for (FormatTextRanges.FormatTextRange range : textRanges) {\n            TextRange textRange = range.getTextRange();\n            wrapLongLinesIfNecessary(file, document, textRange.getStartOffset(), textRange.getEndOffset());\n          }\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    }\n  }","id":91024,"modified_method":"public void processText(PsiFile file, final FormatTextRanges ranges, boolean doPostponedFormatting) {\n    final Project project = file.getProject();\n    Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n    final List<FormatTextRanges.FormatTextRange> textRanges = ranges.getRanges();\n    if (document instanceof DocumentWindow) {\n      file = InjectedLanguageUtil.getTopLevelFile(file);\n      final DocumentWindow documentWindow = (DocumentWindow)document;\n      for (FormatTextRanges.FormatTextRange range : textRanges) {\n        range.setTextRange(documentWindow.injectedToHost(range.getTextRange()));\n      }\n      document = documentWindow.getDelegate();\n    }\n\n\n    final FormattingModelBuilder builder = LanguageFormatting.INSTANCE.forContext(file);\n\n    if (builder != null) {\n      if (file.getTextLength() > 0) {\n        try {\n          final PsiElement startElement = file.findElementAt(textRanges.get(0).getTextRange().getStartOffset());\n          final PsiElement endElement = file.findElementAt(textRanges.get(textRanges.size() - 1).getTextRange().getEndOffset() - 1);\n          final PsiElement commonParent = startElement != null && endElement != null ? PsiTreeUtil.findCommonParent(startElement, endElement) : null;\n          ASTNode node = null;\n          if (commonParent != null) {\n            node = commonParent.getNode();\n          }\n          if (node == null) {\n            node = file.getNode();\n          }\n          ranges.preprocess(node);\n          if (doPostponedFormatting) {\n            RangeMarker[] markers = new RangeMarker[textRanges.size()];\n            int i = 0;\n            for (FormatTextRanges.FormatTextRange range : textRanges) {\n              TextRange textRange = range.getTextRange();\n              int start = textRange.getStartOffset();\n              int end = textRange.getEndOffset();\n              if (start >= 0 && end > start && end <= document.getTextLength()) {\n                markers[i] = document.createRangeMarker(textRange);\n                markers[i].setGreedyToLeft(true);\n                markers[i].setGreedyToRight(true);\n                i++;\n              }\n            }\n            final PostprocessReformattingAspect component = file.getProject().getComponent(PostprocessReformattingAspect.class);\n            component.doPostponedFormatting(file.getViewProvider());\n            i = 0;\n            for (FormatTextRanges.FormatTextRange range : textRanges) {\n              RangeMarker marker = markers[i];\n              if (marker != null) {\n                range.setTextRange(new TextRange(marker.getStartOffset(), marker.getEndOffset()));\n                marker.dispose();\n              }\n              i++;\n            }\n\n          }\n          final FormattingModel originalModel = builder.createModel(file, mySettings);\n          final FormattingModel model = new DocumentBasedFormattingModel(originalModel.getRootBlock(),\n                                                                         document,\n                                                                         project, mySettings, file.getFileType(), file);\n\n          FormatterEx.getInstanceEx().format(model, mySettings, mySettings.getIndentOptions(file.getFileType()), ranges);\n          for (FormatTextRanges.FormatTextRange range : textRanges) {\n            TextRange textRange = range.getTextRange();\n            wrapLongLinesIfNecessary(file, document, textRange.getStartOffset(), textRange.getEndOffset());\n          }\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    }\n  }","commit_id":"9cc0d8813a891504555bdbb0eaba841763e0b645","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean checkReferenceExpressionScope (final PsiReferenceExpression ref, final PsiElement targetClassMember) {\n    final JavaResolveResult resolveResult = ref.advancedResolve(false);\n    final PsiElement def = resolveResult.getElement();\n    if (def != null) {\n      PsiElement parent = def.getParent ();\n      PsiElement commonParent = PsiTreeUtil.findCommonParent(parent, targetClassMember);\n      if (commonParent == null) {\n        parent = resolveResult.getCurrentFileResolveScope();\n      }\n      if (parent instanceof PsiClass) {\n        final PsiClass clss = (PsiClass) parent;\n        if (PsiTreeUtil.isAncestor(targetClassMember, clss, false))\n          return false;\n        }\n    }\n\n    return true;\n  }","id":91025,"modified_method":"private static boolean checkReferenceExpressionScope(final PsiReferenceExpression ref, @NotNull PsiElement targetClassMember) {\n    final JavaResolveResult resolveResult = ref.advancedResolve(false);\n    final PsiElement def = resolveResult.getElement();\n    if (def != null) {\n      PsiElement parent = def.getParent();\n      PsiElement commonParent = parent == null ? null : PsiTreeUtil.findCommonParent(parent, targetClassMember);\n      if (commonParent == null) {\n        parent = resolveResult.getCurrentFileResolveScope();\n      }\n      if (parent instanceof PsiClass) {\n        final PsiClass clss = (PsiClass)parent;\n        if (PsiTreeUtil.isAncestor(targetClassMember, clss, false)) return false;\n      }\n    }\n\n    return true;\n  }","commit_id":"d897efe54540ad5709512e581dd36dd01ac0fb37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void stop() {\n        _executor.shutdownNow();\n    }","id":91026,"modified_method":"public void stop() {\n        if (_executor != null)\n            _executor.shutdownNow();\n    }","commit_id":"a08dd4aefa8cbf5ab4869b096acf2f3fccb59317","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void closeConsumer() {\n        if (m_consumer != null) {\n            m_consumer.stop();\n            m_consumer = null;\n        }\n        m_es.shutdownNow();\n    }","id":91027,"modified_method":"public void closeConsumer() {\n        if (m_consumer != null) {\n            m_consumer.stop();\n            m_consumer = null;\n        }\n        if (m_es != null) {\n            m_es.shutdownNow();\n            m_es = null;\n        }\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Close all connections and cleanup on both the sides.\n     */\n    public void close() {\n        try {\n            if (m_loader != null) {\n                m_loader.flush();\n                m_loader.cancelQueued();\n                m_loader.drain();\n                m_loader.close();\n                m_loader = null;\n            }\n            if (m_client != null) {\n                m_client.close();\n                m_client = null;\n            }\n        } catch (InterruptedException ex) {\n        }\n    }","id":91028,"modified_method":"/**\n     * Close all connections and cleanup on both the sides.\n     */\n    public void close() {\n        try {\n            closeConsumer();\n            if (m_loader != null) {\n                m_loader.flush();\n                m_loader.cancelQueued();\n                m_loader.drain();\n                m_loader.close();\n                m_loader = null;\n            }\n            if (m_client != null) {\n                m_client.close();\n                m_client = null;\n            }\n        } catch (InterruptedException ex) {\n        }\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void processKafkaMessages() throws Exception {\n        // Split server list\n        final String[] serverlist = m_config.servers.split(\",\");\n\n        // Create connection\n        final ClientConfig c_config = new ClientConfig(m_config.user, m_config.password);\n        c_config.setProcedureCallTimeout(0); // Set procedure all to infinite\n\n        m_client = getClient(c_config, serverlist);\n\n        m_loader = m_client.getNewBulkLoader(m_config.table, m_config.batch, new KafkaBulkLoaderCallback());\n        m_loader.setFlushInterval(m_config.flush, m_config.flush, new Flusher());\n        m_consumer = new KafkaConsumerConnector(m_config.zookeeper, m_config.table);\n        try {\n            m_es = getConsumerExecutor(m_consumer, m_loader);\n            m_log.info(\"Kafka Consumer from topic: \" + m_config.topic + \" Started for table: \" + m_config.table);\n            m_es.awaitTermination(365, TimeUnit.DAYS);\n        } catch (Exception ex) {\n            m_log.error(\"Error in Kafka Consumer\", ex);\n            System.exit(-1);\n        }\n        close();\n    }","id":91029,"modified_method":"public void processKafkaMessages() throws Exception {\n        // Split server list\n        final String[] serverlist = m_config.servers.split(\",\");\n\n        // Create connection\n        final ClientConfig c_config = new ClientConfig(m_config.user, m_config.password);\n        c_config.setProcedureCallTimeout(0); // Set procedure all to infinite\n\n        m_client = getClient(c_config, serverlist);\n\n        m_loader = m_client.getNewBulkLoader(m_config.table, m_config.batch, new KafkaBulkLoaderCallback());\n        m_loader.setFlushInterval(m_config.flush, m_config.flush);\n        m_consumer = new KafkaConsumerConnector(m_config.zookeeper, m_config.table);\n        try {\n            m_es = getConsumerExecutor(m_consumer, m_loader);\n            m_log.info(\"Kafka Consumer from topic: \" + m_config.topic + \" Started for table: \" + m_config.table);\n            m_es.awaitTermination(365, TimeUnit.DAYS);\n        } catch (Exception ex) {\n            m_log.error(\"Error in Kafka Consumer\", ex);\n            System.exit(-1);\n        }\n        close();\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"synchronized void flushAllTableQueues() {\n        if (m_partitionQueuedRowCnt.get() % m_minBatchTriggerSize != 0) {\n            // A flush will typically cause the table to be split into 2 batches\n            m_partitionProcessorQueue.add(this);\n        }\n    }","id":91030,"modified_method":"synchronized void flushAllTableQueues(boolean force) {\n        if (m_partitionQueuedRowCnt.get() % m_minBatchTriggerSize != 0 && (m_okToFlush || force)) {\n            // A flush will typically cause the table to be split into 2 batches\n            m_partitionProcessorQueue.add(this);\n        }\n        if (!force) {\n            m_okToFlush = true;\n        }\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"synchronized void insertRowInTable(VoltBulkLoaderRow nextRow) throws InterruptedException {\n        if (!m_partitionRowQueue.offer(nextRow))\n            m_partitionRowQueue.put(nextRow);\n        if (m_partitionQueuedRowCnt.incrementAndGet() % m_minBatchTriggerSize == 0) {\n            // A sync row will typically cause the table to be split into 2 requests\n            m_partitionProcessorQueue.add(this);\n        }\n    }","id":91031,"modified_method":"synchronized void insertRowInTable(VoltBulkLoaderRow nextRow) throws InterruptedException {\n        if (!m_partitionRowQueue.offer(nextRow)) {\n            m_partitionRowQueue.put(nextRow);\n        }\n        if (m_partitionQueuedRowCnt.incrementAndGet() % m_minBatchTriggerSize == 0) {\n            // A sync row will typically cause the table to be split into 2 requests\n            m_okToFlush = false;\n            m_partitionProcessorQueue.add(this);\n        }\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testBlankEmpty() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_tinyint tinyint default 0, \" +\n                        \"clm_smallint smallint default 0, \" +\n                        \"clm_bigint bigint default 0, \" +\n                        \"clm_string varchar(20) default null, \" +\n                        \"clm_decimal decimal default null, \" +\n                        \"clm_float float default null, \"+\n                        \"clm_timestamp timestamp default null, \" +\n                        \"clm_varinary varbinary(20) default null\" +\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = {\n            {0,null,null,null,null,null,null,null,null}\n        };\n        Integer[] failures = {};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface( mySchema, myData, myBatchSize, expectedFailures );\n    }","id":91032,"modified_method":"public void testBlankEmpty() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_tinyint tinyint default 0, \" +\n                        \"clm_smallint smallint default 0, \" +\n                        \"clm_bigint bigint default 0, \" +\n                        \"clm_string varchar(20) default null, \" +\n                        \"clm_decimal decimal default null, \" +\n                        \"clm_float float default null, \"+\n                        \"clm_timestamp timestamp default null, \" +\n                        \"clm_varinary varbinary(20) default null\" +\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = {\n            {0,null,null,null,null,null,null,null,null}\n        };\n        Integer[] failures = {};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface(mySchema, myData, myBatchSize, expectedFailures, 0);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testBatchOptionThatSplitsAndGetsViolations() throws Exception {\n        String mySchema =\n                \"create table BLAH (\"\n                + \"clm_integer integer not null, \"\n                + // column that is partitioned on\n                \"clm_tinyint tinyint default 0, \"\n                + \"clm_smallint smallint default 0, \"\n                + \"clm_bigint bigint default 0, \"\n                + \"clm_string varchar(20) default null, \"\n                + \"clm_decimal decimal default null, \"\n                + \"clm_float float default null, \"\n                + \"clm_timestamp timestamp default null, \"\n                + \"PRIMARY KEY(clm_integer) \"\n                + \"); \";\n        int myBatchSize = 2;\n        TimestampType currentTime = new TimestampType();\n        Object [][] myData = {\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {2,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {3,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {4,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime}, //Whole batch fails\n            {2,1,1,11111111,\"first\",1.10,1.11,currentTime}, //Whole batch fails\n            {5,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {6,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime}, //Whole batch fails\n            {2,1,1,11111111,\"first\",1.10,1.11,currentTime}, //Whole batch fails\n            {7,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {8,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {11,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime}, //Whole batch fails\n            {2,1,1,11111111,\"first\",1.10,1.11,currentTime}, //Whole batch fails\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime}, //Whole batch fails\n            {12,1,1,11111111,\"first\",1.10,1.11,currentTime}\n        };\n        Integer[] failures = {5,6,9,10,14,15,16};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface( mySchema, myData, myBatchSize, expectedFailures );\n    }","id":91033,"modified_method":"public void testBatchOptionThatSplitsAndGetsViolations() throws Exception {\n        String mySchema =\n                \"create table BLAH (\"\n                + \"clm_integer integer not null, \"\n                + // column that is partitioned on\n                \"clm_tinyint tinyint default 0, \"\n                + \"clm_smallint smallint default 0, \"\n                + \"clm_bigint bigint default 0, \"\n                + \"clm_string varchar(20) default null, \"\n                + \"clm_decimal decimal default null, \"\n                + \"clm_float float default null, \"\n                + \"clm_timestamp timestamp default null, \"\n                + \"PRIMARY KEY(clm_integer) \"\n                + \"); \";\n        int myBatchSize = 2;\n        TimestampType currentTime = new TimestampType();\n        Object [][] myData = {\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {2,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {3,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {4,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime}, //Whole batch fails\n            {2,1,1,11111111,\"first\",1.10,1.11,currentTime}, //Whole batch fails\n            {5,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {6,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime}, //Whole batch fails\n            {2,1,1,11111111,\"first\",1.10,1.11,currentTime}, //Whole batch fails\n            {7,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {8,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {11,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime}, //Whole batch fails\n            {2,1,1,11111111,\"first\",1.10,1.11,currentTime}, //Whole batch fails\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime}, //Whole batch fails\n            {12,1,1,11111111,\"first\",1.10,1.11,currentTime}\n        };\n        Integer[] failures = {5,6,9,10,14,15,16};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface(mySchema, myData, myBatchSize, expectedFailures, 0);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testNoWhiteSpace() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                                \"clm_string varchar(20), \" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_tinyint tinyint default 0, \" +\n                        \"clm_smallint smallint default 0, \" +\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = {\n            {\"nospace\",1,1,1},\n            {\"   frontspace\",2,2,2},\n            {\"rearspace   \",3,3,3},\n            {\"\\\" inquotespace \\\"   \",4,4,4}\n        };\n        Integer[] failures = {};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface( mySchema, myData, myBatchSize, expectedFailures );\n    }","id":91034,"modified_method":"public void testNoWhiteSpace() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                                \"clm_string varchar(20), \" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_tinyint tinyint default 0, \" +\n                        \"clm_smallint smallint default 0, \" +\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = {\n            {\"nospace\",1,1,1},\n            {\"   frontspace\",2,2,2},\n            {\"rearspace   \",3,3,3},\n            {\"\\\" inquotespace \\\"   \",4,4,4}\n        };\n        Integer[] failures = {};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface(mySchema, myData, myBatchSize, expectedFailures, 0);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testOpenQuote() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n\n                \"clm_integer1 integer default 0, \" +\n                \"clm_bigint bigint default 0, \" +\n\n                \"clm_string varchar(200) default null, \" +\n                \"clm_timestamp timestamp default null \" +\n                \"); \";\n        int myBatchSize = 200;\n        TimestampType timeParam = new TimestampType(\"7777-12-25 14:35:26\");\n        Object [][]myData = {\n            {1,1,1,\"\\\"Jesus\\\\\\\"\\\"loves\"+ \"\\n\" +\"you\\\"\",timeParam},\n        };\n        Integer[] failures = {};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface( mySchema, myData, myBatchSize, expectedFailures );\n    }","id":91035,"modified_method":"public void testOpenQuote() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n\n                \"clm_integer1 integer default 0, \" +\n                \"clm_bigint bigint default 0, \" +\n\n                \"clm_string varchar(200) default null, \" +\n                \"clm_timestamp timestamp default null \" +\n                \"); \";\n        int myBatchSize = 200;\n        TimestampType timeParam = new TimestampType(\"7777-12-25 14:35:26\");\n        Object [][]myData = {\n            {1,1,1,\"\\\"Jesus\\\\\\\"\\\"loves\"+ \"\\n\" +\"you\\\"\",timeParam},\n        };\n        Integer[] failures = {};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface(mySchema, myData, myBatchSize, expectedFailures, 0);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testCommon() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n\n                \"clm_tinyint tinyint default 0, \" +\n                \"clm_smallint smallint default 0, \" +\n                \"clm_bigint bigint default 0, \" +\n\n                \"clm_string varchar(20) default null, \" +\n                \"clm_decimal decimal default null, \" +\n                \"clm_float float default null, \"+\n                //\"clm_varinary varbinary(20) default null,\" +\n                \"clm_timestamp timestamp default null \" +\n                \"); \";\n        int myBatchSize = 200;\n        TimestampType currentTime = new TimestampType();\n        Object [][]myData = {\n            {1 ,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {2,2,2,222222,\"second\",3.30,\"NULL\",currentTime},\n            {3,3,3,333333,\" third \",null,3.33,currentTime},\n            {4,4,4,444444,\" NULL \",4.40 ,4.44,currentTime},\n            {5,5,5,5555555,\"  \\\"abcde\\\"g\",5.50,5.55,currentTime},\n            {6,6,\"NULL\",666666,\" sixth\", 6.60, 6.66,currentTime},\n            {7,null,7,7777777,\" seventh\", 7.70, 7.77,currentTime},\n            {11,1,1,\"\\\"1,000\\\"\",\"first\",1.10,1.11,currentTime},\n            //empty line\n            {},\n            //invalid lines below\n            {8,8},\n            {9,\"NLL\",9,\"\\\"1,000\\\"\",\"nine\",1.10,1.11,currentTime},\n            {10,10,10,\"10 101 010\",\"second\",2.20,2.22},\n            {12,\"n ull\",12,12121212,\"twelveth\",12.12,12.12}\n        };\n        Integer[] failures = {2,6,8,9,10,11,12,13};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface( mySchema, myData, myBatchSize, expectedFailures );\n    }","id":91036,"modified_method":"public void testCommon() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n\n                \"clm_tinyint tinyint default 0, \" +\n                \"clm_smallint smallint default 0, \" +\n                \"clm_bigint bigint default 0, \" +\n\n                \"clm_string varchar(20) default null, \" +\n                \"clm_decimal decimal default null, \" +\n                \"clm_float float default null, \"+\n                //\"clm_varinary varbinary(20) default null,\" +\n                \"clm_timestamp timestamp default null \" +\n                \"); \";\n        int myBatchSize = 200;\n        TimestampType currentTime = new TimestampType();\n        Object [][]myData = {\n            {1 ,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {2,2,2,222222,\"second\",3.30,\"NULL\",currentTime},\n            {3,3,3,333333,\" third \",null,3.33,currentTime},\n            {4,4,4,444444,\" NULL \",4.40 ,4.44,currentTime},\n            {5,5,5,5555555,\"  \\\"abcde\\\"g\",5.50,5.55,currentTime},\n            {6,6,\"NULL\",666666,\" sixth\", 6.60, 6.66,currentTime},\n            {7,null,7,7777777,\" seventh\", 7.70, 7.77,currentTime},\n            {11,1,1,\"\\\"1,000\\\"\",\"first\",1.10,1.11,currentTime},\n            //empty line\n            {},\n            //invalid lines below\n            {8,8},\n            {9,\"NLL\",9,\"\\\"1,000\\\"\",\"nine\",1.10,1.11,currentTime},\n            {10,10,10,\"10 101 010\",\"second\",2.20,2.22},\n            {12,\"n ull\",12,12121212,\"twelveth\",12.12,12.12}\n        };\n        Integer[] failures = {2,6,8,9,10,11,12,13};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface(mySchema, myData, myBatchSize, expectedFailures, 0);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testColumnLimitSize() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                                \"clm_string varchar(20), \" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_tinyint tinyint default 0, \" +\n                        \"clm_smallint smallint default 0, \" +\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = {\n            {\"\\\"openquote\",1,1,1},\n            {\"second\",2,2,2},\n            {\"third\",3,3,3},\n            {\"123456789012345678901\",4,4,4}\n        };\n        Integer[] failures = {4};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface( mySchema, myData, myBatchSize, expectedFailures );\n    }","id":91037,"modified_method":"public void testColumnLimitSize() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                                \"clm_string varchar(20), \" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_tinyint tinyint default 0, \" +\n                        \"clm_smallint smallint default 0, \" +\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = {\n            {\"\\\"openquote\",1,1,1},\n            {\"second\",2,2,2},\n            {\"third\",3,3,3},\n            {\"123456789012345678901\",4,4,4}\n        };\n        Integer[] failures = {4};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface(mySchema, myData, myBatchSize, expectedFailures, 0);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testEmptyFile() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_tinyint tinyint default 0, \" +\n                        \"clm_smallint smallint default 0, \" +\n                        \"clm_bigint bigint default 0, \" +\n                        \"clm_string varchar(20) default null, \" +\n                        \"clm_decimal decimal default null, \" +\n                        \"clm_float float default null, \"+\n                        \"clm_timestamp timestamp default null, \" +\n                        \"clm_varinary varbinary(20) default null\" +\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = null;\n        Integer[] failures = {};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface( mySchema, myData, myBatchSize, expectedFailures );\n    }","id":91038,"modified_method":"public void testEmptyFile() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_tinyint tinyint default 0, \" +\n                        \"clm_smallint smallint default 0, \" +\n                        \"clm_bigint bigint default 0, \" +\n                        \"clm_string varchar(20) default null, \" +\n                        \"clm_decimal decimal default null, \" +\n                        \"clm_float float default null, \"+\n                        \"clm_timestamp timestamp default null, \" +\n                        \"clm_varinary varbinary(20) default null\" +\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = null;\n        Integer[] failures = {};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface(mySchema, myData, myBatchSize, expectedFailures, 0);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testStrictQuote() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_tinyint tinyint default 0, \" +\n                        \"clm_smallint smallint default 0, \" +\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = {\n            {\"\\\"1\\\"\",\"\\\"1\\\"\",\"\\\"1\\\"\"},\n            {2,2,2},\n            {3,3,3},\n            {\"\\\"4\\\"\",\"\\\"4\\\"\",\"\\\"4\\\"\"},\n        };\n        Integer[] failures = {1, 4};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface( mySchema, myData, myBatchSize, expectedFailures );\n    }","id":91039,"modified_method":"public void testStrictQuote() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_tinyint tinyint default 0, \" +\n                        \"clm_smallint smallint default 0, \" +\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = {\n            {\"\\\"1\\\"\",\"\\\"1\\\"\",\"\\\"1\\\"\"},\n            {2,2,2},\n            {3,3,3},\n            {\"\\\"4\\\"\",\"\\\"4\\\"\",\"\\\"4\\\"\"},\n        };\n        Integer[] failures = {1, 4};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface(mySchema, myData, myBatchSize, expectedFailures, 0);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testBatchOptionThatSplitsAndGetsViolationsAndDataIsSmall() throws Exception {\n        String mySchema =\n                \"create table BLAH (\"\n                + \"clm_integer integer not null, \"\n                + // column that is partitioned on\n                \"clm_tinyint tinyint default 0, \"\n                + \"clm_smallint smallint default 0, \"\n                + \"clm_bigint bigint default 0, \"\n                + \"clm_string varchar(20) default null, \"\n                + \"clm_decimal decimal default null, \"\n                + \"clm_float float default null, \"\n                + \"clm_timestamp timestamp default null, \"\n                + \"PRIMARY KEY(clm_integer) \"\n                + \"); \";\n        int myBatchSize = 2;\n        TimestampType currentTime = new TimestampType();\n        Object [][] myData = {\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {2,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {2,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime}\n        };\n        Integer[] failures = {3,4};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface( mySchema, myData, myBatchSize, expectedFailures );\n    }","id":91040,"modified_method":"public void testBatchOptionThatSplitsAndGetsViolationsAndDataIsSmall() throws Exception {\n        String mySchema =\n                \"create table BLAH (\"\n                + \"clm_integer integer not null, \"\n                + // column that is partitioned on\n                \"clm_tinyint tinyint default 0, \"\n                + \"clm_smallint smallint default 0, \"\n                + \"clm_bigint bigint default 0, \"\n                + \"clm_string varchar(20) default null, \"\n                + \"clm_decimal decimal default null, \"\n                + \"clm_float float default null, \"\n                + \"clm_timestamp timestamp default null, \"\n                + \"PRIMARY KEY(clm_integer) \"\n                + \"); \";\n        int myBatchSize = 2;\n        TimestampType currentTime = new TimestampType();\n        Object [][] myData = {\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {2,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {2,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime}\n        };\n        Integer[] failures = {3,4};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface(mySchema, myData, myBatchSize, expectedFailures, 0);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testColumnLimitSize2() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_string varchar(20), \"+\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = {\n            {1,\"\\\"Edwr\"},\n            {\"Burnam\\\"\",2,\"\\\"Tabatha\"},\n            {\"Gehling\"}\n        };\n\n        Integer[] failures = {2, 3};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface( mySchema, myData, myBatchSize, expectedFailures );\n    }","id":91041,"modified_method":"public void testColumnLimitSize2() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_string varchar(20), \"+\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = {\n            {1,\"\\\"Edwr\"},\n            {\"Burnam\\\"\",2,\"\\\"Tabatha\"},\n            {\"Gehling\"}\n        };\n\n        Integer[] failures = {2, 3};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface(mySchema, myData, myBatchSize, expectedFailures, 0);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testBatchOptionThatSplits() throws Exception {\n        String mySchema =\n                \"create table BLAH (\"\n                + \"clm_integer integer default 0 not null, \"\n                + // column that is partitioned on\n                \"clm_tinyint tinyint default 0, \"\n                + \"clm_smallint smallint default 0, \"\n                + \"clm_bigint bigint default 0, \"\n                + \"clm_string varchar(20) default null, \"\n                + \"clm_decimal decimal default null, \"\n                + \"clm_float float default null, \"\n                + //\"clm_varinary varbinary(20) default null,\" +\n                \"clm_timestamp timestamp default null \"\n                + \"); \";\n        int myBatchSize = 2;\n        TimestampType currentTime = new TimestampType();\n        Object [][] myData = {\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {2,2,2,222222,\"second\",3.30,null,currentTime},\n            {3,3,3,333333,\" third \",null,3.33,currentTime},\n            {4,4,4,444444,\" NULL \",4.40 ,4.44,currentTime},\n            {5,5,5,5555555,\"abcdeg\",5.50,5.55,currentTime},\n            {6,6,null,666666,\"sixth\",6.60,6.66,currentTime},\n            {7,7,7,7777777,\" seventh\",7.70,7.77,currentTime},\n            {11, 1,1,1000,\"first\",1.10,1.11,currentTime},\n            //empty line\n            {},\n            //invalid lines below\n            {8,8},\n            {9,9,9,900,\"nine\",1.10,1.11,currentTime},\n            {10,10,10,10,\"second\",2.20,2.22,currentTime},\n            {12,null,12,12121212,\"twelveth\",12.12,12.12,currentTime}\n        };\n        Integer[] failures = {9,10};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface( mySchema, myData, myBatchSize, expectedFailures );\n    }","id":91042,"modified_method":"public void testBatchOptionThatSplits() throws Exception {\n        String mySchema =\n                \"create table BLAH (\"\n                + \"clm_integer integer default 0 not null, \"\n                + // column that is partitioned on\n                \"clm_tinyint tinyint default 0, \"\n                + \"clm_smallint smallint default 0, \"\n                + \"clm_bigint bigint default 0, \"\n                + \"clm_string varchar(20) default null, \"\n                + \"clm_decimal decimal default null, \"\n                + \"clm_float float default null, \"\n                + //\"clm_varinary varbinary(20) default null,\" +\n                \"clm_timestamp timestamp default null \"\n                + \"); \";\n        int myBatchSize = 2;\n        TimestampType currentTime = new TimestampType();\n        Object [][] myData = {\n            {1,1,1,11111111,\"first\",1.10,1.11,currentTime},\n            {2,2,2,222222,\"second\",3.30,null,currentTime},\n            {3,3,3,333333,\" third \",null,3.33,currentTime},\n            {4,4,4,444444,\" NULL \",4.40 ,4.44,currentTime},\n            {5,5,5,5555555,\"abcdeg\",5.50,5.55,currentTime},\n            {6,6,null,666666,\"sixth\",6.60,6.66,currentTime},\n            {7,7,7,7777777,\" seventh\",7.70,7.77,currentTime},\n            {11, 1,1,1000,\"first\",1.10,1.11,currentTime},\n            //empty line\n            {},\n            //invalid lines below\n            {8,8},\n            {9,9,9,900,\"nine\",1.10,1.11,currentTime},\n            {10,10,10,10,\"second\",2.20,2.22,currentTime},\n            {12,null,12,12121212,\"twelveth\",12.12,12.12,currentTime}\n        };\n        Integer[] failures = {9,10};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface(mySchema, myData, myBatchSize, expectedFailures, 0);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testEscapeChar() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                                \"clm_string varchar(20), \" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_tinyint tinyint default 0, \" +\n                        \"clm_smallint smallint default 0, \" +\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = {\n            {\"~\\\"escapequotes\",1,1,1},\n            {\"~\\\\nescapenewline\",2,2,2},\n            {\"~'escapeprimesymbol\",3,3,3}\n        };\n        Integer[] failures = {};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface( mySchema, myData, myBatchSize, expectedFailures );\n    }","id":91043,"modified_method":"public void testEscapeChar() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                                \"clm_string varchar(20), \" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_tinyint tinyint default 0, \" +\n                        \"clm_smallint smallint default 0, \" +\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = {\n            {\"~\\\"escapequotes\",1,1,1},\n            {\"~\\\\nescapenewline\",2,2,2},\n            {\"~'escapeprimesymbol\",3,3,3}\n        };\n        Integer[] failures = {};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface(mySchema, myData, myBatchSize, expectedFailures, 0);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testNULL() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n\n                \"clm_tinyint tinyint default 0, \" +\n                \"clm_smallint smallint default 0, \" +\n                \"clm_bigint bigint default 0, \" +\n\n                \"clm_string varchar(20) default null, \" +\n                \"clm_decimal decimal default null, \" +\n                \"clm_float float default null \"+\n                //\"clm_timestamp timestamp default null, \" +\n                //\"clm_varinary varbinary(20) default null\" +\n                \"); \";\n        int myBatchSize = 200;\n        //Both \\N and \\\\N as csv input are treated as NULL\n        Object [][]myData = {\n            {1,Constants.CSV_NULL,1,11111111,null,1.10,1.11},\n            {2,Constants.QUOTED_CSV_NULL,1,11111111,null,1.10,1.11},\n            {3,Constants.CSV_NULL,1,11111111,\"  \\\\\" + Constants.CSV_NULL + \"  \",1.10,1.11},\n            {4,Constants.CSV_NULL,1,11111111,\"  \" + Constants.QUOTED_CSV_NULL + \"  \",1.10,1.11},\n            {5,null,1,11111111,\" \\\"  \\\\\" + Constants.CSV_NULL   + \"  \\\"\",1.10,1.11},\n            {6,Constants.CSV_NULL,1,11111111,\" \\\"  \\\\\" + Constants.CSV_NULL  + \" L \\\"\",1.10,1.11},\n            {7,Constants.CSV_NULL,1,11111111,\"  \\\"abc\\\\\" + Constants.CSV_NULL + \"\\\"  \",1.10,1.11}\n        };\n        Integer[] failures = {2};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface( mySchema, myData, myBatchSize, expectedFailures );\n    }","id":91044,"modified_method":"public void testNULL() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n\n                \"clm_tinyint tinyint default 0, \" +\n                \"clm_smallint smallint default 0, \" +\n                \"clm_bigint bigint default 0, \" +\n\n                \"clm_string varchar(20) default null, \" +\n                \"clm_decimal decimal default null, \" +\n                \"clm_float float default null \"+\n                //\"clm_timestamp timestamp default null, \" +\n                //\"clm_varinary varbinary(20) default null\" +\n                \"); \";\n        int myBatchSize = 200;\n        //Both \\N and \\\\N as csv input are treated as NULL\n        Object [][]myData = {\n            {1,Constants.CSV_NULL,1,11111111,null,1.10,1.11},\n            {2,Constants.QUOTED_CSV_NULL,1,11111111,null,1.10,1.11},\n            {3,Constants.CSV_NULL,1,11111111,\"  \\\\\" + Constants.CSV_NULL + \"  \",1.10,1.11},\n            {4,Constants.CSV_NULL,1,11111111,\"  \" + Constants.QUOTED_CSV_NULL + \"  \",1.10,1.11},\n            {5,null,1,11111111,\" \\\"  \\\\\" + Constants.CSV_NULL   + \"  \\\"\",1.10,1.11},\n            {6,Constants.CSV_NULL,1,11111111,\" \\\"  \\\\\" + Constants.CSV_NULL  + \" L \\\"\",1.10,1.11},\n            {7,Constants.CSV_NULL,1,11111111,\"  \\\"abc\\\\\" + Constants.CSV_NULL + \"\\\"  \",1.10,1.11}\n        };\n        Integer[] failures = {2};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface(mySchema, myData, myBatchSize, expectedFailures, 0);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void test_Interface( String my_schema, Object[][] my_data, int my_batchSize,  ArrayList<Integer> expectedFailList) throws Exception {\n        try{\n            pathToCatalog = Configuration.getPathToCatalogForTest(\"vbl.jar\");\n            pathToDeployment = Configuration.getPathToCatalogForTest(\"vbl.xml\");\n            builder = new VoltProjectBuilder();\n\n            builder.addLiteralSchema(my_schema);\n            builder.addPartitionInfo(\"BLAH\", \"clm_integer\");\n            boolean success = builder.compile(pathToCatalog, 2, 1, 0);\n            assertTrue(success);\n            MiscUtils.copyFile(builder.getPathToDeployment(), pathToDeployment);\n            config = new VoltDB.Configuration();\n            config.m_pathToCatalog = pathToCatalog;\n            config.m_pathToDeployment = pathToDeployment;\n            localServer = new ServerThread(config);\n            client1 = null;\n\n            localServer.start();\n            localServer.waitForInitialization();\n\n            client1 = ClientFactory.createClient();\n            client1.createConnection(\"localhost\");\n\n            prepare();\n            TestFailureCallback testCallback = new TestFailureCallback();\n            VoltBulkLoader bulkLoader = client1.getNewBulkLoader(\"BLAH\", my_batchSize, testCallback);\n            // do the test\n\n            VoltTable modCount;\n            modCount = client1.callProcedure(\"@AdHoc\", \"SELECT * FROM BLAH;\").getResults()[0];\n            System.out.println(\"data inserted to table BLAH:\\n\" + modCount);\n\n            // Call validate partitioning to check if we are good.\n            VoltTable valTable;\n            valTable = client1.callProcedure(\"@ValidatePartitioning\", null, null).getResults()[0];\n            System.out.println(\"Validate for BLAH:\\n\" + valTable);\n            while (valTable.advanceRow()) {\n                long miscnt = valTable.getLong(\"MISPARTITIONED_ROWS\");\n                assertEquals(miscnt, 0);\n            }\n\n            int rowCnt=1;\n            try{\n                for (Object[] nextRow : my_data) {\n                    Integer rowId = new Integer(rowCnt);\n                    bulkLoader.insertRow(rowId, nextRow);\n                    rowCnt++;\n                    if (rnd.nextInt() % 30 == 0)\n                        //  Randomly inject a flush\n                        bulkLoader.flush();\n                }\n            }\n            catch( Exception e) {\n                System.err.print( e.getMessage() );\n            }\n            System.out.println(String.format(\"Attempted inserting %d rows\", --rowCnt));\n\n            if (rnd.nextBoolean()) {\n                // One in 10 tests generate a sync and VoltBulkLoader internal state verification\n                bulkLoader.drain();\n                assert(bulkLoader.getOutstandingRowCount() == 0);\n                assert(bulkLoader.getCompletedRowCount() == rowCnt);\n            }\n\n            bulkLoader.close();\n            assert(bulkLoader.getCompletedRowCount() == rowCnt);\n            assert(testCallback.failureRowListMatches(expectedFailList));\n        }\n        finally {\n            if (client1 != null) client1.close();\n            client1 = null;\n\n            if (localServer != null) {\n                localServer.shutdown();\n                localServer.join();\n            }\n            localServer = null;\n\n            // no clue how helpful this is\n            System.gc();\n        }\n    }","id":91045,"modified_method":"public void test_Interface(String my_schema, Object[][] my_data,\n            int my_batchSize, ArrayList<Integer> expectedFailList, int flushInterval) throws Exception {\n        try{\n            pathToCatalog = Configuration.getPathToCatalogForTest(\"vbl.jar\");\n            pathToDeployment = Configuration.getPathToCatalogForTest(\"vbl.xml\");\n            builder = new VoltProjectBuilder();\n\n            builder.addLiteralSchema(my_schema);\n            builder.addPartitionInfo(\"BLAH\", \"clm_integer\");\n            boolean success = builder.compile(pathToCatalog, 2, 1, 0);\n            assertTrue(success);\n            MiscUtils.copyFile(builder.getPathToDeployment(), pathToDeployment);\n            config = new VoltDB.Configuration();\n            config.m_pathToCatalog = pathToCatalog;\n            config.m_pathToDeployment = pathToDeployment;\n            localServer = new ServerThread(config);\n            client1 = null;\n\n            localServer.start();\n            localServer.waitForInitialization();\n\n            client1 = ClientFactory.createClient();\n            client1.createConnection(\"localhost\");\n\n            prepare();\n            TestFailureCallback testCallback = new TestFailureCallback();\n            VoltBulkLoader bulkLoader = client1.getNewBulkLoader(\"BLAH\", my_batchSize, testCallback);\n            if (flushInterval > 0) {\n                bulkLoader.setFlushInterval(0, flushInterval);\n            }\n            // do the test\n\n            VoltTable modCount;\n            modCount = client1.callProcedure(\"@AdHoc\", \"SELECT * FROM BLAH;\").getResults()[0];\n            System.out.println(\"data inserted to table BLAH:\\n\" + modCount);\n\n            // Call validate partitioning to check if we are good.\n            VoltTable valTable;\n            valTable = client1.callProcedure(\"@ValidatePartitioning\", null, null).getResults()[0];\n            System.out.println(\"Validate for BLAH:\\n\" + valTable);\n            while (valTable.advanceRow()) {\n                long miscnt = valTable.getLong(\"MISPARTITIONED_ROWS\");\n                assertEquals(miscnt, 0);\n            }\n\n            int rowCnt=1;\n            try{\n                for (Object[] nextRow : my_data) {\n                    Integer rowId = new Integer(rowCnt);\n                    bulkLoader.insertRow(rowId, nextRow);\n                    rowCnt++;\n                    if (flushInterval <= 0 && (rnd.nextInt() % 30 == 0)) {\n                        //  Randomly inject a flush if no timer flush is involved.\n                        bulkLoader.flush();\n                    }\n                }\n            }\n            catch( Exception e) {\n                System.err.print( e.getMessage() );\n            }\n            System.out.println(String.format(\"Attempted inserting %d rows\", --rowCnt));\n\n            if (flushInterval <= 0 && rnd.nextBoolean()) {\n                // One in 10 tests generate a sync and VoltBulkLoader internal state verification\n                bulkLoader.drain();\n                assert(bulkLoader.getOutstandingRowCount() == 0);\n                assert(bulkLoader.getCompletedRowCount() == rowCnt);\n            }\n            if (flushInterval > 0) {\n                //Lets get timerFlush in\n                Thread.sleep(flushInterval + 500);\n                bulkLoader.drain();\n                //We should have everything processed callbacked.\n                assert (bulkLoader.getOutstandingRowCount() == 0);\n                assert (bulkLoader.getCompletedRowCount() == rowCnt);\n            }\n\n            bulkLoader.close();\n            assert(bulkLoader.getCompletedRowCount() == rowCnt);\n            assert(testCallback.failureRowListMatches(expectedFailList));\n        }\n        finally {\n            if (client1 != null) client1.close();\n            client1 = null;\n\n            if (localServer != null) {\n                localServer.shutdown();\n                localServer.join();\n            }\n            localServer = null;\n\n            // no clue how helpful this is\n            System.gc();\n        }\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testBlankNull() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_tinyint tinyint default 0, \" +\n                        \"clm_smallint smallint default 0, \" +\n                        \"clm_bigint bigint default 0, \" +\n                        \"clm_string varchar(20) default null, \" +\n                        \"clm_decimal decimal default null, \" +\n                        \"clm_float float default null, \"+\n                        \"clm_timestamp timestamp default null, \" +\n                        \"clm_varinary varbinary(20) default null\" +\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = {\n            {1,null,null,null,null,null,null,null,null}\n        };\n        Integer[] failures = {};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface( mySchema, myData, myBatchSize, expectedFailures );\n    }","id":91046,"modified_method":"public void testBlankNull() throws Exception\n    {\n        String mySchema =\n                \"create table BLAH (\" +\n                        \"clm_integer integer default 0 not null, \" + // column that is partitioned on\n                        \"clm_tinyint tinyint default 0, \" +\n                        \"clm_smallint smallint default 0, \" +\n                        \"clm_bigint bigint default 0, \" +\n                        \"clm_string varchar(20) default null, \" +\n                        \"clm_decimal decimal default null, \" +\n                        \"clm_float float default null, \"+\n                        \"clm_timestamp timestamp default null, \" +\n                        \"clm_varinary varbinary(20) default null\" +\n                        \"); \";\n        int myBatchSize = 200;\n\n        Object [][]myData = {\n            {1,null,null,null,null,null,null,null,null}\n        };\n        Integer[] failures = {};\n        ArrayList<Integer> expectedFailures = new ArrayList<Integer>(Arrays.asList(failures));\n        test_Interface(mySchema, myData, myBatchSize, expectedFailures, 0);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Called to asynchronously force the VoltBulkLoader to submit all the partially full batches\n     * in all partitions of the table to the Client for insert. To wait for all rows to be processed,\n     * use drain(). This method will also flush pending rows submitted by other VoltBulkLoader\n     * instances working on the same table and using the same instance of Client.\n     */\n    public void flush() {\n        for (int i=m_firstPartitionTable; i<=m_lastPartitionTable; i++)\n            m_partitionTable[i].flushAllTableQueues();\n    }","id":91047,"modified_method":"/**\n     * Called to asynchronously force the VoltBulkLoader to submit all the partially full batches\n     * in all partitions of the table to the Client for insert. To wait for all rows to be processed,\n     * use drain(). This method will also flush pending rows submitted by other VoltBulkLoader\n     * instances working on the same table and using the same instance of Client.\n     */\n    public void flush() {\n        _flush(true);\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Set periodic flush interval and initial delay in seconds.\n     *\n     * @param delay Initial delay in seconds\n     * @param seconds Interval in seconds, passing <code>seconds <= 0<\/code> value will cancel periodic flush\n     */\n    public synchronized void setFlushInterval(long delay, long seconds, Runnable task) {\n        if (m_flush != null) {\n            m_flush.cancel(false);\n            m_flush = null;\n        }\n        if (seconds > 0) {\n            m_flush = m_ses.scheduleAtFixedRate(task, delay, seconds, TimeUnit.SECONDS);\n        }\n    }","id":91048,"modified_method":"/**\n     * Set periodic flush interval and initial delay in seconds.\n     *\n     * @param delay Initial delay in seconds\n     * @param seconds Interval in seconds, passing <code>seconds <= 0<\/code> value will cancel periodic flush\n     */\n    public synchronized void setFlushInterval(long delay, long seconds) {\n        if (m_flush != null) {\n            m_flush.cancel(false);\n            m_flush = null;\n        }\n        if (seconds > 0) {\n            m_flush = m_ses.scheduleAtFixedRate(new Runnable() {\n                @Override\n                public void run() {\n                    timedFlush();\n                }\n            }, delay, seconds, TimeUnit.SECONDS);\n        }\n    }","commit_id":"bd0ff67e12a91e5f184f70ed9f3606b7c903a674","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n         * @param startCtx Starting context.\n         * @throws IgniteCheckedException If start failed.\n         */\n        @SuppressWarnings({\"unchecked\", \"TooBroadScope\"})\n        private void start0(GridStartContext startCtx) throws IgniteCheckedException {\n            assert grid == null : \"Grid is already started: \" + name;\n\n            IgniteConfiguration cfg = startCtx.config();\n\n            if (cfg == null)\n                cfg = new IgniteConfiguration();\n\n            IgniteConfiguration myCfg = new IgniteConfiguration();\n\n            String ggHome = cfg.getIgniteHome();\n\n            // Set Ignite home.\n            if (ggHome == null)\n                ggHome = U.getIgniteHome();\n            else\n                // If user provided IGNITE_HOME - set it as a system property.\n                U.setIgniteHome(ggHome);\n\n            U.setWorkDirectory(cfg.getWorkDirectory(), ggHome);\n\n            /*\n             * Set up all defaults and perform all checks.\n             */\n\n            // Ensure invariant.\n            // It's a bit dirty - but this is a result of late refactoring\n            // and I don't want to reshuffle a lot of code.\n            assert F.eq(name, cfg.getGridName());\n\n            // Set configuration URL, if any, into system property.\n            if (startCtx.configUrl() != null)\n                System.setProperty(IGNITE_CONFIG_URL, startCtx.configUrl().toString());\n\n            myCfg.setGridName(cfg.getGridName());\n\n            UUID nodeId = cfg.getNodeId();\n\n            if (nodeId == null)\n                nodeId = UUID.randomUUID();\n\n            IgniteLogger cfgLog = initLogger(cfg.getGridLogger(), nodeId);\n\n            assert cfgLog != null;\n\n            cfgLog = new GridLoggerProxy(cfgLog, null, name, U.id8(nodeId));\n\n            // Initialize factory's log.\n            log = cfgLog.getLogger(G.class);\n\n            // Check Ignite home folder (after log is available).\n            if (ggHome != null) {\n                File ggHomeFile = new File(ggHome);\n\n                if (!ggHomeFile.exists() || !ggHomeFile.isDirectory())\n                    throw new IgniteCheckedException(\"Invalid Ignite installation home folder: \" + ggHome);\n            }\n\n            myCfg.setIgniteHome(ggHome);\n\n            // Copy values that don't need extra processing.\n            myCfg.setLicenseUrl(cfg.getLicenseUrl());\n            myCfg.setPeerClassLoadingEnabled(cfg.isPeerClassLoadingEnabled());\n            myCfg.setDeploymentMode(cfg.getDeploymentMode());\n            myCfg.setNetworkTimeout(cfg.getNetworkTimeout());\n            myCfg.setClockSyncSamples(cfg.getClockSyncSamples());\n            myCfg.setClockSyncFrequency(cfg.getClockSyncFrequency());\n            myCfg.setDiscoveryStartupDelay(cfg.getDiscoveryStartupDelay());\n            myCfg.setMetricsHistorySize(cfg.getMetricsHistorySize());\n            myCfg.setMetricsExpireTime(cfg.getMetricsExpireTime());\n            myCfg.setMetricsUpdateFrequency(cfg.getMetricsUpdateFrequency());\n            myCfg.setLifecycleBeans(cfg.getLifecycleBeans());\n            myCfg.setLocalEventListeners(cfg.getLocalEventListeners());\n            myCfg.setPeerClassLoadingMissedResourcesCacheSize(cfg.getPeerClassLoadingMissedResourcesCacheSize());\n            myCfg.setIncludeEventTypes(cfg.getIncludeEventTypes());\n            myCfg.setDaemon(cfg.isDaemon());\n            myCfg.setIncludeProperties(cfg.getIncludeProperties());\n            myCfg.setLifeCycleEmailNotification(cfg.isLifeCycleEmailNotification());\n            myCfg.setMetricsLogFrequency(cfg.getMetricsLogFrequency());\n            myCfg.setNetworkSendRetryDelay(cfg.getNetworkSendRetryDelay());\n            myCfg.setNetworkSendRetryCount(cfg.getNetworkSendRetryCount());\n            myCfg.setSecurityCredentialsProvider(cfg.getSecurityCredentialsProvider());\n            myCfg.setServiceConfiguration(cfg.getServiceConfiguration());\n            myCfg.setWarmupClosure(cfg.getWarmupClosure());\n            myCfg.setPluginConfigurations(cfg.getPluginConfigurations());\n            myCfg.setTransactionConfiguration(new TransactionConfiguration(cfg.getTransactionConfiguration()));\n            myCfg.setQueryConfiguration(cfg.getQueryConfiguration());\n            myCfg.setAtomicConfiguration(cfg.getAtomicConfiguration());\n\n            ClientConnectionConfiguration clientCfg = cfg.getClientConnectionConfiguration();\n\n            if (clientCfg == null) {\n                clientCfg = new ClientConnectionConfiguration();\n\n                clientCfg.setClientMessageInterceptor(cfg.getClientMessageInterceptor());\n                clientCfg.setRestAccessibleFolders(cfg.getRestAccessibleFolders());\n                clientCfg.setRestIdleTimeout(cfg.getRestIdleTimeout());\n                clientCfg.setRestJettyPath(cfg.getRestJettyPath());\n                clientCfg.setRestPortRange(cfg.getRestPortRange());\n                clientCfg.setRestSecretKey(cfg.getRestSecretKey());\n                clientCfg.setRestTcpDirectBuffer(cfg.isRestTcpDirectBuffer());\n                clientCfg.setRestTcpHost(cfg.getRestTcpHost());\n                clientCfg.setRestTcpNoDelay(cfg.isRestTcpNoDelay());\n                clientCfg.setRestTcpPort(cfg.getRestTcpPort());\n                clientCfg.setRestTcpReceiveBufferSize(cfg.getRestTcpReceiveBufferSize());\n                clientCfg.setRestTcpSelectorCount(cfg.getRestTcpSelectorCount());\n                clientCfg.setRestTcpSendBufferSize(cfg.getRestTcpSendBufferSize());\n                clientCfg.setRestTcpSendQueueLimit(cfg.getRestTcpSendQueueLimit());\n                clientCfg.setRestTcpSslClientAuth(cfg.isRestTcpSslClientAuth());\n                clientCfg.setRestTcpSslContextFactory(cfg.getRestTcpSslContextFactory());\n                clientCfg.setRestTcpSslEnabled(cfg.isRestTcpSslEnabled());\n            }\n            else\n                clientCfg = new ClientConnectionConfiguration(clientCfg);\n\n\n            String ntfStr = IgniteSystemProperties.getString(IGNITE_LIFECYCLE_EMAIL_NOTIFY);\n\n            if (ntfStr != null)\n                myCfg.setLifeCycleEmailNotification(Boolean.parseBoolean(ntfStr));\n\n            // Local host.\n            String locHost = IgniteSystemProperties.getString(IGNITE_LOCAL_HOST);\n\n            myCfg.setLocalHost(F.isEmpty(locHost) ? cfg.getLocalHost() : locHost);\n\n            // Override daemon flag if it was set on the factory.\n            if (daemon)\n                myCfg.setDaemon(true);\n\n            // Check for deployment mode override.\n            String depModeName = IgniteSystemProperties.getString(IGNITE_DEP_MODE_OVERRIDE);\n\n            if (!F.isEmpty(depModeName)) {\n                if (!F.isEmpty(cfg.getCacheConfiguration())) {\n                    U.quietAndInfo(log, \"Skipping deployment mode override for caches (custom closure \" +\n                        \"execution may not work for console Visor)\");\n                }\n                else {\n                    try {\n                        DeploymentMode depMode = DeploymentMode.valueOf(depModeName);\n\n                        if (myCfg.getDeploymentMode() != depMode)\n                            myCfg.setDeploymentMode(depMode);\n                    }\n                    catch (IllegalArgumentException e) {\n                        throw new IgniteCheckedException(\"Failed to override deployment mode using system property \" +\n                            \"(are there any misspellings?)\" +\n                            \"[name=\" + IGNITE_DEP_MODE_OVERRIDE + \", value=\" + depModeName + ']', e);\n                    }\n                }\n            }\n\n            Map<String, ?> attrs = cfg.getUserAttributes();\n\n            if (attrs == null)\n                attrs = Collections.emptyMap();\n\n            MBeanServer mbSrv = cfg.getMBeanServer();\n\n            Marshaller marsh = cfg.getMarshaller();\n\n            String[] p2pExclude = cfg.getPeerClassLoadingLocalClassPathExclude();\n\n            CommunicationSpi commSpi = cfg.getCommunicationSpi();\n            DiscoverySpi discoSpi = cfg.getDiscoverySpi();\n            EventStorageSpi evtSpi = cfg.getEventStorageSpi();\n            CollisionSpi colSpi = cfg.getCollisionSpi();\n            AuthenticationSpi authSpi = cfg.getAuthenticationSpi();\n            SecureSessionSpi sesSpi = cfg.getSecureSessionSpi();\n            DeploymentSpi deploySpi = cfg.getDeploymentSpi();\n            CheckpointSpi[] cpSpi = cfg.getCheckpointSpi();\n            FailoverSpi[] failSpi = cfg.getFailoverSpi();\n            LoadBalancingSpi[] loadBalancingSpi = cfg.getLoadBalancingSpi();\n            SwapSpaceSpi swapspaceSpi = cfg.getSwapSpaceSpi();\n            GridIndexingSpi indexingSpi = cfg.getIndexingSpi();\n\n            execSvc = new IgniteThreadPoolExecutor(\n                \"pub-\" + cfg.getGridName(),\n                cfg.getPublicThreadPoolSize(),\n                cfg.getPublicThreadPoolSize(),\n                DFLT_PUBLIC_KEEP_ALIVE_TIME,\n                new LinkedBlockingQueue<Runnable>(DFLT_PUBLIC_THREADPOOL_QUEUE_CAP));\n\n            // Pre-start all threads as they are guaranteed to be needed.\n            ((ThreadPoolExecutor) execSvc).prestartAllCoreThreads();\n\n            // Note that since we use 'LinkedBlockingQueue', number of\n            // maximum threads has no effect.\n            sysExecSvc = new IgniteThreadPoolExecutor(\n                \"sys-\" + cfg.getGridName(),\n                cfg.getSystemThreadPoolSize(),\n                cfg.getSystemThreadPoolSize(),\n                DFLT_SYSTEM_KEEP_ALIVE_TIME,\n                new LinkedBlockingQueue<Runnable>(DFLT_SYSTEM_THREADPOOL_QUEUE_CAP));\n\n            // Pre-start all threads as they are guaranteed to be needed.\n            ((ThreadPoolExecutor) sysExecSvc).prestartAllCoreThreads();\n\n            // Note that since we use 'LinkedBlockingQueue', number of\n            // maximum threads has no effect.\n            // Note, that we do not pre-start threads here as management pool may\n            // not be needed.\n            mgmtExecSvc = new IgniteThreadPoolExecutor(\n                \"mgmt-\" + cfg.getGridName(),\n                cfg.getManagementThreadPoolSize(),\n                cfg.getManagementThreadPoolSize(),\n                0,\n                new LinkedBlockingQueue<Runnable>());\n\n            // Note that since we use 'LinkedBlockingQueue', number of\n            // maximum threads has no effect.\n            // Note, that we do not pre-start threads here as class loading pool may\n            // not be needed.\n            p2pExecSvc = new IgniteThreadPoolExecutor(\n                \"p2p-\" + cfg.getGridName(),\n                cfg.getPeerClassLoadingThreadPoolSize(),\n                cfg.getPeerClassLoadingThreadPoolSize(),\n                0,\n                new LinkedBlockingQueue<Runnable>());\n\n            // Note that we do not pre-start threads here as ggfs pool may not be needed.\n            ggfsExecSvc = new IgniteThreadPoolExecutor(\n                \"ggfs-\" + cfg.getGridName(),\n                cfg.getGgfsThreadPoolSize(),\n                cfg.getGgfsThreadPoolSize(),\n                0,\n                new LinkedBlockingQueue<Runnable>());\n\n            restExecSvc = new IgniteThreadPoolExecutor(\n                \"rest-\" + cfg.getGridName(),\n                clientCfg.getRestThreadPoolSize(),\n                clientCfg.getRestThreadPoolSize(),\n                DFLT_REST_KEEP_ALIVE_TIME,\n                new LinkedBlockingQueue<Runnable>(DFLT_REST_THREADPOOL_QUEUE_CAP)\n            );\n\n            utilityCacheExecSvc = new IgniteThreadPoolExecutor(\n                \"utility-\" + cfg.getGridName(),\n                DFLT_SYSTEM_CORE_THREAD_CNT,\n                DFLT_SYSTEM_MAX_THREAD_CNT,\n                DFLT_SYSTEM_KEEP_ALIVE_TIME,\n                new LinkedBlockingQueue<Runnable>(DFLT_SYSTEM_THREADPOOL_QUEUE_CAP));\n\n            if (marsh == null) {\n                if (!U.isHotSpot()) {\n                    U.warn(log, \"GridOptimizedMarshaller is not supported on this JVM \" +\n                        \"(only Java HotSpot VMs are supported). Switching to standard JDK marshalling - \" +\n                        \"object serialization performance will be significantly slower.\",\n                        \"To enable fast marshalling upgrade to recent 1.6 or 1.7 HotSpot VM release.\");\n\n                    marsh = new JdkMarshaller();\n                }\n                else if (!OptimizedMarshaller.available()) {\n                    U.warn(log, \"GridOptimizedMarshaller is not supported on this JVM \" +\n                        \"(only recent 1.6 and 1.7 versions HotSpot VMs are supported). \" +\n                        \"To enable fast marshalling upgrade to recent 1.6 or 1.7 HotSpot VM release. \" +\n                        \"Switching to standard JDK marshalling - \" +\n                        \"object serialization performance will be significantly slower.\",\n                        \"To enable fast marshalling upgrade to recent 1.6 or 1.7 HotSpot VM release.\");\n\n                    marsh = new JdkMarshaller();\n                }\n                else\n                    marsh = new OptimizedMarshaller();\n            }\n            else if (marsh instanceof OptimizedMarshaller && !U.isHotSpot()) {\n                U.warn(log, \"Using GridOptimizedMarshaller on untested JVM (only Java HotSpot VMs were tested) - \" +\n                    \"object serialization behavior could yield unexpected results.\",\n                    \"Using GridOptimizedMarshaller on untested JVM.\");\n            }\n\n            myCfg.setUserAttributes(attrs);\n            myCfg.setMBeanServer(mbSrv == null ? ManagementFactory.getPlatformMBeanServer() : mbSrv);\n            myCfg.setGridLogger(cfgLog);\n            myCfg.setMarshaller(marsh);\n            myCfg.setMarshalLocalJobs(cfg.isMarshalLocalJobs());\n            myCfg.setNodeId(nodeId);\n\n            IgniteFsConfiguration[] ggfsCfgs = cfg.getGgfsConfiguration();\n\n            if (ggfsCfgs != null) {\n                IgniteFsConfiguration[] clone = ggfsCfgs.clone();\n\n                for (int i = 0; i < ggfsCfgs.length; i++)\n                    clone[i] = new IgniteFsConfiguration(ggfsCfgs[i]);\n\n                myCfg.setGgfsConfiguration(clone);\n            }\n\n            StreamerConfiguration[] streamerCfgs = cfg.getStreamerConfiguration();\n\n            if (streamerCfgs != null) {\n                StreamerConfiguration[] clone = streamerCfgs.clone();\n\n                for (int i = 0; i < streamerCfgs.length; i++)\n                    clone[i] = new StreamerConfiguration(streamerCfgs[i]);\n\n                myCfg.setStreamerConfiguration(clone);\n            }\n\n            if (p2pExclude == null)\n                p2pExclude = EMPTY_STR_ARR;\n\n            myCfg.setPeerClassLoadingLocalClassPathExclude(p2pExclude);\n\n            /*\n             * Initialize default SPI implementations.\n             */\n\n            if (commSpi == null)\n                commSpi = new TcpCommunicationSpi();\n\n            if (discoSpi == null)\n                discoSpi = new TcpDiscoverySpi();\n\n            if (discoSpi instanceof TcpDiscoverySpi) {\n                TcpDiscoverySpi tcpDisco = (TcpDiscoverySpi)discoSpi;\n\n                if (tcpDisco.getIpFinder() == null)\n                    tcpDisco.setIpFinder(new TcpDiscoveryMulticastIpFinder());\n            }\n\n            if (evtSpi == null)\n                evtSpi = new MemoryEventStorageSpi();\n\n            if (colSpi == null)\n                colSpi = new NoopCollisionSpi();\n\n            if (authSpi == null)\n                authSpi = new NoopAuthenticationSpi();\n\n            if (sesSpi == null)\n                sesSpi = new NoopSecureSessionSpi();\n\n            if (deploySpi == null)\n                deploySpi = new LocalDeploymentSpi();\n\n            if (cpSpi == null)\n                cpSpi = new CheckpointSpi[] {new NoopCheckpointSpi()};\n\n            if (failSpi == null)\n                failSpi = new FailoverSpi[] {new AlwaysFailoverSpi()};\n\n            if (loadBalancingSpi == null)\n                loadBalancingSpi = new LoadBalancingSpi[] {new RoundRobinLoadBalancingSpi()};\n\n            if (swapspaceSpi == null) {\n                boolean needSwap = false;\n\n                CacheConfiguration[] caches = cfg.getCacheConfiguration();\n\n                if (caches != null) {\n                    for (CacheConfiguration c : caches) {\n                        if (c.isSwapEnabled()) {\n                            needSwap = true;\n\n                            break;\n                        }\n                    }\n                }\n\n                swapspaceSpi = needSwap ? new FileSwapSpaceSpi() : new NoopSwapSpaceSpi();\n            }\n\n            if (indexingSpi == null)\n                indexingSpi = new GridNoopIndexingSpi();\n\n            myCfg.setCommunicationSpi(commSpi);\n            myCfg.setDiscoverySpi(discoSpi);\n            myCfg.setCheckpointSpi(cpSpi);\n            myCfg.setEventStorageSpi(evtSpi);\n            myCfg.setAuthenticationSpi(authSpi);\n            myCfg.setSecureSessionSpi(sesSpi);\n            myCfg.setDeploymentSpi(deploySpi);\n            myCfg.setFailoverSpi(failSpi);\n            myCfg.setCollisionSpi(colSpi);\n            myCfg.setLoadBalancingSpi(loadBalancingSpi);\n            myCfg.setSwapSpaceSpi(swapspaceSpi);\n            myCfg.setIndexingSpi(indexingSpi);\n\n            myCfg.setAddressResolver(cfg.getAddressResolver());\n\n            // Set SMTP configuration.\n            myCfg.setSmtpFromEmail(cfg.getSmtpFromEmail());\n            myCfg.setSmtpHost(cfg.getSmtpHost());\n            myCfg.setSmtpPort(cfg.getSmtpPort());\n            myCfg.setSmtpSsl(cfg.isSmtpSsl());\n            myCfg.setSmtpUsername(cfg.getSmtpUsername());\n            myCfg.setSmtpPassword(cfg.getSmtpPassword());\n            myCfg.setAdminEmails(cfg.getAdminEmails());\n\n            // REST configuration.\n            myCfg.setClientConnectionConfiguration(clientCfg);\n\n            // Portable configuration.\n            myCfg.setPortableConfiguration(cfg.getPortableConfiguration());\n\n            // Hadoop configuration.\n            myCfg.setHadoopConfiguration(cfg.getHadoopConfiguration());\n\n            // Validate segmentation configuration.\n            GridSegmentationPolicy segPlc = cfg.getSegmentationPolicy();\n\n            // 1. Warn on potential configuration problem: grid is not configured to wait\n            // for correct segment after segmentation happens.\n            if (!F.isEmpty(cfg.getSegmentationResolvers()) && segPlc == RESTART_JVM && !cfg.isWaitForSegmentOnStart()) {\n                U.warn(log, \"Found potential configuration problem (forgot to enable waiting for segment\" +\n                    \"on start?) [segPlc=\" + segPlc + \", wait=false]\");\n            }\n\n            myCfg.setSegmentationResolvers(cfg.getSegmentationResolvers());\n            myCfg.setSegmentationPolicy(segPlc);\n            myCfg.setSegmentCheckFrequency(cfg.getSegmentCheckFrequency());\n            myCfg.setWaitForSegmentOnStart(cfg.isWaitForSegmentOnStart());\n            myCfg.setAllSegmentationResolversPassRequired(cfg.isAllSegmentationResolversPassRequired());\n\n            // Override SMTP configuration from system properties\n            // and environment variables, if specified.\n            String fromEmail = IgniteSystemProperties.getString(IGNITE_SMTP_FROM);\n\n            if (fromEmail != null)\n                myCfg.setSmtpFromEmail(fromEmail);\n\n            String smtpHost = IgniteSystemProperties.getString(IGNITE_SMTP_HOST);\n\n            if (smtpHost != null)\n                myCfg.setSmtpHost(smtpHost);\n\n            String smtpUsername = IgniteSystemProperties.getString(IGNITE_SMTP_USERNAME);\n\n            if (smtpUsername != null)\n                myCfg.setSmtpUsername(smtpUsername);\n\n            String smtpPwd = IgniteSystemProperties.getString(IGNITE_SMTP_PWD);\n\n            if (smtpPwd != null)\n                myCfg.setSmtpPassword(smtpPwd);\n\n            int smtpPort = IgniteSystemProperties.getInteger(IGNITE_SMTP_PORT, -1);\n\n            if(smtpPort != -1)\n                myCfg.setSmtpPort(smtpPort);\n\n            myCfg.setSmtpSsl(IgniteSystemProperties.getBoolean(IGNITE_SMTP_SSL));\n\n            String adminEmails = IgniteSystemProperties.getString(IGNITE_ADMIN_EMAILS);\n\n            if (adminEmails != null)\n                myCfg.setAdminEmails(adminEmails.split(\",\"));\n\n            CacheConfiguration[] cacheCfgs = cfg.getCacheConfiguration();\n\n            final boolean hasHadoop = IgniteComponentType.HADOOP.inClassPath();\n\n            final boolean hasAtomics = cfg.getAtomicConfiguration() != null;\n\n            final boolean clientDisco = discoSpi instanceof TcpClientDiscoverySpi;\n\n            CacheConfiguration[] copies;\n\n            if (cacheCfgs != null && cacheCfgs.length > 0) {\n                if (!U.discoOrdered(discoSpi) && !U.relaxDiscoveryOrdered())\n                    throw new IgniteCheckedException(\"Discovery SPI implementation does not support node ordering and \" +\n                        \"cannot be used with cache (use SPI with @GridDiscoverySpiOrderSupport annotation, \" +\n                        \"like GridTcpDiscoverySpi)\");\n\n                for (CacheConfiguration ccfg : cacheCfgs) {\n                    if (CU.isHadoopSystemCache(ccfg.getName()))\n                        throw new IgniteCheckedException(\"Cache name cannot be \\\"\" + CU.SYS_CACHE_HADOOP_MR +\n                            \"\\\" because it is reserved for internal purposes.\");\n\n                    if (CU.isAtomicsCache(ccfg.getName()))\n                        throw new IgniteCheckedException(\"Cache name cannot be \\\"\" + CU.ATOMICS_CACHE_NAME +\n                            \"\\\" because it is reserved for internal purposes.\");\n\n                    if (CU.isUtilityCache(ccfg.getName()))\n                        throw new IgniteCheckedException(\"Cache name cannot start with \\\"\" + CU.UTILITY_CACHE_NAME +\n                            \"\\\" because this prefix is reserved for internal purposes.\");\n                }\n\n                int addCacheCnt = 1; // Always add utility cache.\n\n                if (hasHadoop)\n                    addCacheCnt++;\n\n                if (hasAtomics)\n                    addCacheCnt++;\n\n                copies = new CacheConfiguration[cacheCfgs.length + addCacheCnt];\n\n                int cloneIdx = 1;\n\n                if (hasHadoop)\n                    copies[cloneIdx++] = CU.hadoopSystemCache();\n\n                if (hasAtomics)\n                    copies[cloneIdx++] = atomicsSystemCache(cfg.getAtomicConfiguration(), clientDisco);\n\n                for (CacheConfiguration ccfg : cacheCfgs)\n                    copies[cloneIdx++] = new CacheConfiguration(ccfg);\n            }\n            else {\n                int cacheCnt = 1; // Always add utility cache.\n\n                if (hasHadoop)\n                    cacheCnt++;\n\n                if (hasAtomics)\n                    cacheCnt++;\n\n                copies = new CacheConfiguration[cacheCnt];\n\n                int cacheIdx = 1;\n\n                if (hasHadoop)\n                    copies[cacheIdx++] = CU.hadoopSystemCache();\n\n                if (hasAtomics)\n                    copies[cacheIdx] = atomicsSystemCache(cfg.getAtomicConfiguration(), clientDisco);\n            }\n\n            // Always add utility cache.\n            copies[0] = utilitySystemCache(clientDisco);\n\n            myCfg.setCacheConfiguration(copies);\n\n            myCfg.setCacheSanityCheckEnabled(cfg.isCacheSanityCheckEnabled());\n\n            try {\n                // Use reflection to avoid loading undesired classes.\n                Class helperCls = Class.forName(\"org.apache.ignite.util.GridConfigurationHelper\");\n\n                helperCls.getMethod(\"overrideConfiguration\", IgniteConfiguration.class, Properties.class,\n                    String.class, IgniteLogger.class).invoke(helperCls, myCfg, System.getProperties(), name, log);\n            }\n            catch (Exception ignored) {\n                // No-op.\n            }\n\n            // Ensure that SPIs support multiple grid instances, if required.\n            if (!startCtx.single()) {\n                ensureMultiInstanceSupport(deploySpi);\n                ensureMultiInstanceSupport(commSpi);\n                ensureMultiInstanceSupport(discoSpi);\n                ensureMultiInstanceSupport(cpSpi);\n                ensureMultiInstanceSupport(evtSpi);\n                ensureMultiInstanceSupport(colSpi);\n                ensureMultiInstanceSupport(failSpi);\n                ensureMultiInstanceSupport(authSpi);\n                ensureMultiInstanceSupport(sesSpi);\n                ensureMultiInstanceSupport(loadBalancingSpi);\n                ensureMultiInstanceSupport(swapspaceSpi);\n            }\n\n            // Register Ignite MBean for current grid instance.\n            registerFactoryMbean(myCfg.getMBeanServer());\n\n            boolean started = false;\n\n            try {\n                IgniteKernal grid0 = new IgniteKernal(startCtx.springContext());\n\n                // Init here to make grid available to lifecycle listeners.\n                grid = grid0;\n\n                grid0.start(myCfg, utilityCacheExecSvc, execSvc, sysExecSvc, p2pExecSvc, mgmtExecSvc, ggfsExecSvc,\n                    restExecSvc,\n                    new CA() {\n                        @Override public void apply() {\n                        startLatch.countDown();\n                    }\n                });\n\n                state = STARTED;\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Grid factory started ok: \" + name);\n\n                started = true;\n            }\n            catch (IgniteCheckedException e) {\n                unregisterFactoryMBean();\n\n                throw e;\n            }\n            // Catch Throwable to protect against any possible failure.\n            catch (Throwable e) {\n                unregisterFactoryMBean();\n\n                throw new IgniteCheckedException(\"Unexpected exception when starting grid.\", e);\n            }\n            finally {\n                if (!started)\n                    // Grid was not started.\n                    grid = null;\n            }\n\n            // Do NOT set it up only if IGNITE_NO_SHUTDOWN_HOOK=TRUE is provided.\n            if (!IgniteSystemProperties.getBoolean(IGNITE_NO_SHUTDOWN_HOOK, false)) {\n                try {\n                    Runtime.getRuntime().addShutdownHook(shutdownHook = new Thread() {\n                        @Override public void run() {\n                            if (log.isInfoEnabled())\n                                log.info(\"Invoking shutdown hook...\");\n\n                            IgniteNamedInstance.this.stop(true);\n                        }\n                    });\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Shutdown hook is installed.\");\n                }\n                catch (IllegalStateException e) {\n                    stop(true);\n\n                    throw new IgniteCheckedException(\"Failed to install shutdown hook.\", e);\n                }\n            }\n            else {\n                if (log.isDebugEnabled())\n                    log.debug(\"Shutdown hook has not been installed because environment \" +\n                        \"or system property \" + IGNITE_NO_SHUTDOWN_HOOK + \" is set.\");\n            }\n        }","id":91049,"modified_method":"/**\n         * @param startCtx Starting context.\n         * @throws IgniteCheckedException If start failed.\n         */\n        @SuppressWarnings({\"unchecked\", \"TooBroadScope\"})\n        private void start0(GridStartContext startCtx) throws IgniteCheckedException {\n            assert grid == null : \"Grid is already started: \" + name;\n\n            IgniteConfiguration cfg = startCtx.config();\n\n            if (cfg == null)\n                cfg = new IgniteConfiguration();\n\n            IgniteConfiguration myCfg = new IgniteConfiguration();\n\n            String ggHome = cfg.getIgniteHome();\n\n            // Set Ignite home.\n            if (ggHome == null)\n                ggHome = U.getIgniteHome();\n            else\n                // If user provided IGNITE_HOME - set it as a system property.\n                U.setIgniteHome(ggHome);\n\n            U.setWorkDirectory(cfg.getWorkDirectory(), ggHome);\n\n            /*\n             * Set up all defaults and perform all checks.\n             */\n\n            // Ensure invariant.\n            // It's a bit dirty - but this is a result of late refactoring\n            // and I don't want to reshuffle a lot of code.\n            assert F.eq(name, cfg.getGridName());\n\n            // Set configuration URL, if any, into system property.\n            if (startCtx.configUrl() != null)\n                System.setProperty(IGNITE_CONFIG_URL, startCtx.configUrl().toString());\n\n            myCfg.setGridName(cfg.getGridName());\n\n            UUID nodeId = cfg.getNodeId();\n\n            if (nodeId == null)\n                nodeId = UUID.randomUUID();\n\n            IgniteLogger cfgLog = initLogger(cfg.getGridLogger(), nodeId);\n\n            assert cfgLog != null;\n\n            cfgLog = new GridLoggerProxy(cfgLog, null, name, U.id8(nodeId));\n\n            // Initialize factory's log.\n            log = cfgLog.getLogger(G.class);\n\n            // Check Ignite home folder (after log is available).\n            if (ggHome != null) {\n                File ggHomeFile = new File(ggHome);\n\n                if (!ggHomeFile.exists() || !ggHomeFile.isDirectory())\n                    throw new IgniteCheckedException(\"Invalid Ignite installation home folder: \" + ggHome);\n            }\n\n            myCfg.setIgniteHome(ggHome);\n\n            // Copy values that don't need extra processing.\n            myCfg.setLicenseUrl(cfg.getLicenseUrl());\n            myCfg.setPeerClassLoadingEnabled(cfg.isPeerClassLoadingEnabled());\n            myCfg.setDeploymentMode(cfg.getDeploymentMode());\n            myCfg.setNetworkTimeout(cfg.getNetworkTimeout());\n            myCfg.setClockSyncSamples(cfg.getClockSyncSamples());\n            myCfg.setClockSyncFrequency(cfg.getClockSyncFrequency());\n            myCfg.setDiscoveryStartupDelay(cfg.getDiscoveryStartupDelay());\n            myCfg.setMetricsHistorySize(cfg.getMetricsHistorySize());\n            myCfg.setMetricsExpireTime(cfg.getMetricsExpireTime());\n            myCfg.setMetricsUpdateFrequency(cfg.getMetricsUpdateFrequency());\n            myCfg.setLifecycleBeans(cfg.getLifecycleBeans());\n            myCfg.setLocalEventListeners(cfg.getLocalEventListeners());\n            myCfg.setPeerClassLoadingMissedResourcesCacheSize(cfg.getPeerClassLoadingMissedResourcesCacheSize());\n            myCfg.setIncludeEventTypes(cfg.getIncludeEventTypes());\n            myCfg.setDaemon(cfg.isDaemon());\n            myCfg.setIncludeProperties(cfg.getIncludeProperties());\n            myCfg.setLifeCycleEmailNotification(cfg.isLifeCycleEmailNotification());\n            myCfg.setMetricsLogFrequency(cfg.getMetricsLogFrequency());\n            myCfg.setNetworkSendRetryDelay(cfg.getNetworkSendRetryDelay());\n            myCfg.setNetworkSendRetryCount(cfg.getNetworkSendRetryCount());\n            myCfg.setSecurityCredentialsProvider(cfg.getSecurityCredentialsProvider());\n            myCfg.setServiceConfiguration(cfg.getServiceConfiguration());\n            myCfg.setWarmupClosure(cfg.getWarmupClosure());\n            myCfg.setPluginConfigurations(cfg.getPluginConfigurations());\n            myCfg.setTransactionConfiguration(new TransactionConfiguration(cfg.getTransactionConfiguration()));\n            myCfg.setQueryConfiguration(cfg.getQueryConfiguration());\n            myCfg.setAtomicConfiguration(cfg.getAtomicConfiguration());\n\n            ClientConnectionConfiguration clientCfg = cfg.getClientConnectionConfiguration();\n\n            if (clientCfg != null)\n                clientCfg = new ClientConnectionConfiguration(clientCfg);\n\n\n            String ntfStr = IgniteSystemProperties.getString(IGNITE_LIFECYCLE_EMAIL_NOTIFY);\n\n            if (ntfStr != null)\n                myCfg.setLifeCycleEmailNotification(Boolean.parseBoolean(ntfStr));\n\n            // Local host.\n            String locHost = IgniteSystemProperties.getString(IGNITE_LOCAL_HOST);\n\n            myCfg.setLocalHost(F.isEmpty(locHost) ? cfg.getLocalHost() : locHost);\n\n            // Override daemon flag if it was set on the factory.\n            if (daemon)\n                myCfg.setDaemon(true);\n\n            // Check for deployment mode override.\n            String depModeName = IgniteSystemProperties.getString(IGNITE_DEP_MODE_OVERRIDE);\n\n            if (!F.isEmpty(depModeName)) {\n                if (!F.isEmpty(cfg.getCacheConfiguration())) {\n                    U.quietAndInfo(log, \"Skipping deployment mode override for caches (custom closure \" +\n                        \"execution may not work for console Visor)\");\n                }\n                else {\n                    try {\n                        DeploymentMode depMode = DeploymentMode.valueOf(depModeName);\n\n                        if (myCfg.getDeploymentMode() != depMode)\n                            myCfg.setDeploymentMode(depMode);\n                    }\n                    catch (IllegalArgumentException e) {\n                        throw new IgniteCheckedException(\"Failed to override deployment mode using system property \" +\n                            \"(are there any misspellings?)\" +\n                            \"[name=\" + IGNITE_DEP_MODE_OVERRIDE + \", value=\" + depModeName + ']', e);\n                    }\n                }\n            }\n\n            Map<String, ?> attrs = cfg.getUserAttributes();\n\n            if (attrs == null)\n                attrs = Collections.emptyMap();\n\n            MBeanServer mbSrv = cfg.getMBeanServer();\n\n            Marshaller marsh = cfg.getMarshaller();\n\n            String[] p2pExclude = cfg.getPeerClassLoadingLocalClassPathExclude();\n\n            CommunicationSpi commSpi = cfg.getCommunicationSpi();\n            DiscoverySpi discoSpi = cfg.getDiscoverySpi();\n            EventStorageSpi evtSpi = cfg.getEventStorageSpi();\n            CollisionSpi colSpi = cfg.getCollisionSpi();\n            AuthenticationSpi authSpi = cfg.getAuthenticationSpi();\n            SecureSessionSpi sesSpi = cfg.getSecureSessionSpi();\n            DeploymentSpi deploySpi = cfg.getDeploymentSpi();\n            CheckpointSpi[] cpSpi = cfg.getCheckpointSpi();\n            FailoverSpi[] failSpi = cfg.getFailoverSpi();\n            LoadBalancingSpi[] loadBalancingSpi = cfg.getLoadBalancingSpi();\n            SwapSpaceSpi swapspaceSpi = cfg.getSwapSpaceSpi();\n            GridIndexingSpi indexingSpi = cfg.getIndexingSpi();\n\n            execSvc = new IgniteThreadPoolExecutor(\n                \"pub-\" + cfg.getGridName(),\n                cfg.getPublicThreadPoolSize(),\n                cfg.getPublicThreadPoolSize(),\n                DFLT_PUBLIC_KEEP_ALIVE_TIME,\n                new LinkedBlockingQueue<Runnable>(DFLT_PUBLIC_THREADPOOL_QUEUE_CAP));\n\n            // Pre-start all threads as they are guaranteed to be needed.\n            ((ThreadPoolExecutor) execSvc).prestartAllCoreThreads();\n\n            // Note that since we use 'LinkedBlockingQueue', number of\n            // maximum threads has no effect.\n            sysExecSvc = new IgniteThreadPoolExecutor(\n                \"sys-\" + cfg.getGridName(),\n                cfg.getSystemThreadPoolSize(),\n                cfg.getSystemThreadPoolSize(),\n                DFLT_SYSTEM_KEEP_ALIVE_TIME,\n                new LinkedBlockingQueue<Runnable>(DFLT_SYSTEM_THREADPOOL_QUEUE_CAP));\n\n            // Pre-start all threads as they are guaranteed to be needed.\n            ((ThreadPoolExecutor) sysExecSvc).prestartAllCoreThreads();\n\n            // Note that since we use 'LinkedBlockingQueue', number of\n            // maximum threads has no effect.\n            // Note, that we do not pre-start threads here as management pool may\n            // not be needed.\n            mgmtExecSvc = new IgniteThreadPoolExecutor(\n                \"mgmt-\" + cfg.getGridName(),\n                cfg.getManagementThreadPoolSize(),\n                cfg.getManagementThreadPoolSize(),\n                0,\n                new LinkedBlockingQueue<Runnable>());\n\n            // Note that since we use 'LinkedBlockingQueue', number of\n            // maximum threads has no effect.\n            // Note, that we do not pre-start threads here as class loading pool may\n            // not be needed.\n            p2pExecSvc = new IgniteThreadPoolExecutor(\n                \"p2p-\" + cfg.getGridName(),\n                cfg.getPeerClassLoadingThreadPoolSize(),\n                cfg.getPeerClassLoadingThreadPoolSize(),\n                0,\n                new LinkedBlockingQueue<Runnable>());\n\n            // Note that we do not pre-start threads here as ggfs pool may not be needed.\n            ggfsExecSvc = new IgniteThreadPoolExecutor(\n                \"ggfs-\" + cfg.getGridName(),\n                cfg.getGgfsThreadPoolSize(),\n                cfg.getGgfsThreadPoolSize(),\n                0,\n                new LinkedBlockingQueue<Runnable>());\n\n            if (clientCfg != null) {\n                restExecSvc = new IgniteThreadPoolExecutor(\n                    \"rest-\" + cfg.getGridName(),\n                    clientCfg.getRestThreadPoolSize(),\n                    clientCfg.getRestThreadPoolSize(),\n                    DFLT_REST_KEEP_ALIVE_TIME,\n                    new LinkedBlockingQueue<Runnable>(DFLT_REST_THREADPOOL_QUEUE_CAP)\n                );\n            }\n\n            utilityCacheExecSvc = new IgniteThreadPoolExecutor(\n                \"utility-\" + cfg.getGridName(),\n                DFLT_SYSTEM_CORE_THREAD_CNT,\n                DFLT_SYSTEM_MAX_THREAD_CNT,\n                DFLT_SYSTEM_KEEP_ALIVE_TIME,\n                new LinkedBlockingQueue<Runnable>(DFLT_SYSTEM_THREADPOOL_QUEUE_CAP));\n\n            if (marsh == null) {\n                if (!U.isHotSpot()) {\n                    U.warn(log, \"GridOptimizedMarshaller is not supported on this JVM \" +\n                        \"(only Java HotSpot VMs are supported). Switching to standard JDK marshalling - \" +\n                        \"object serialization performance will be significantly slower.\",\n                        \"To enable fast marshalling upgrade to recent 1.6 or 1.7 HotSpot VM release.\");\n\n                    marsh = new JdkMarshaller();\n                }\n                else if (!OptimizedMarshaller.available()) {\n                    U.warn(log, \"GridOptimizedMarshaller is not supported on this JVM \" +\n                        \"(only recent 1.6 and 1.7 versions HotSpot VMs are supported). \" +\n                        \"To enable fast marshalling upgrade to recent 1.6 or 1.7 HotSpot VM release. \" +\n                        \"Switching to standard JDK marshalling - \" +\n                        \"object serialization performance will be significantly slower.\",\n                        \"To enable fast marshalling upgrade to recent 1.6 or 1.7 HotSpot VM release.\");\n\n                    marsh = new JdkMarshaller();\n                }\n                else\n                    marsh = new OptimizedMarshaller();\n            }\n            else if (marsh instanceof OptimizedMarshaller && !U.isHotSpot()) {\n                U.warn(log, \"Using GridOptimizedMarshaller on untested JVM (only Java HotSpot VMs were tested) - \" +\n                    \"object serialization behavior could yield unexpected results.\",\n                    \"Using GridOptimizedMarshaller on untested JVM.\");\n            }\n\n            myCfg.setUserAttributes(attrs);\n            myCfg.setMBeanServer(mbSrv == null ? ManagementFactory.getPlatformMBeanServer() : mbSrv);\n            myCfg.setGridLogger(cfgLog);\n            myCfg.setMarshaller(marsh);\n            myCfg.setMarshalLocalJobs(cfg.isMarshalLocalJobs());\n            myCfg.setNodeId(nodeId);\n\n            IgniteFsConfiguration[] ggfsCfgs = cfg.getGgfsConfiguration();\n\n            if (ggfsCfgs != null) {\n                IgniteFsConfiguration[] clone = ggfsCfgs.clone();\n\n                for (int i = 0; i < ggfsCfgs.length; i++)\n                    clone[i] = new IgniteFsConfiguration(ggfsCfgs[i]);\n\n                myCfg.setGgfsConfiguration(clone);\n            }\n\n            StreamerConfiguration[] streamerCfgs = cfg.getStreamerConfiguration();\n\n            if (streamerCfgs != null) {\n                StreamerConfiguration[] clone = streamerCfgs.clone();\n\n                for (int i = 0; i < streamerCfgs.length; i++)\n                    clone[i] = new StreamerConfiguration(streamerCfgs[i]);\n\n                myCfg.setStreamerConfiguration(clone);\n            }\n\n            if (p2pExclude == null)\n                p2pExclude = EMPTY_STR_ARR;\n\n            myCfg.setPeerClassLoadingLocalClassPathExclude(p2pExclude);\n\n            /*\n             * Initialize default SPI implementations.\n             */\n\n            if (commSpi == null)\n                commSpi = new TcpCommunicationSpi();\n\n            if (discoSpi == null)\n                discoSpi = new TcpDiscoverySpi();\n\n            if (discoSpi instanceof TcpDiscoverySpi) {\n                TcpDiscoverySpi tcpDisco = (TcpDiscoverySpi)discoSpi;\n\n                if (tcpDisco.getIpFinder() == null)\n                    tcpDisco.setIpFinder(new TcpDiscoveryMulticastIpFinder());\n            }\n\n            if (evtSpi == null)\n                evtSpi = new MemoryEventStorageSpi();\n\n            if (colSpi == null)\n                colSpi = new NoopCollisionSpi();\n\n            if (authSpi == null)\n                authSpi = new NoopAuthenticationSpi();\n\n            if (sesSpi == null)\n                sesSpi = new NoopSecureSessionSpi();\n\n            if (deploySpi == null)\n                deploySpi = new LocalDeploymentSpi();\n\n            if (cpSpi == null)\n                cpSpi = new CheckpointSpi[] {new NoopCheckpointSpi()};\n\n            if (failSpi == null)\n                failSpi = new FailoverSpi[] {new AlwaysFailoverSpi()};\n\n            if (loadBalancingSpi == null)\n                loadBalancingSpi = new LoadBalancingSpi[] {new RoundRobinLoadBalancingSpi()};\n\n            if (swapspaceSpi == null) {\n                boolean needSwap = false;\n\n                CacheConfiguration[] caches = cfg.getCacheConfiguration();\n\n                if (caches != null) {\n                    for (CacheConfiguration c : caches) {\n                        if (c.isSwapEnabled()) {\n                            needSwap = true;\n\n                            break;\n                        }\n                    }\n                }\n\n                swapspaceSpi = needSwap ? new FileSwapSpaceSpi() : new NoopSwapSpaceSpi();\n            }\n\n            if (indexingSpi == null)\n                indexingSpi = new GridNoopIndexingSpi();\n\n            myCfg.setCommunicationSpi(commSpi);\n            myCfg.setDiscoverySpi(discoSpi);\n            myCfg.setCheckpointSpi(cpSpi);\n            myCfg.setEventStorageSpi(evtSpi);\n            myCfg.setAuthenticationSpi(authSpi);\n            myCfg.setSecureSessionSpi(sesSpi);\n            myCfg.setDeploymentSpi(deploySpi);\n            myCfg.setFailoverSpi(failSpi);\n            myCfg.setCollisionSpi(colSpi);\n            myCfg.setLoadBalancingSpi(loadBalancingSpi);\n            myCfg.setSwapSpaceSpi(swapspaceSpi);\n            myCfg.setIndexingSpi(indexingSpi);\n\n            myCfg.setAddressResolver(cfg.getAddressResolver());\n\n            // Set SMTP configuration.\n            myCfg.setSmtpFromEmail(cfg.getSmtpFromEmail());\n            myCfg.setSmtpHost(cfg.getSmtpHost());\n            myCfg.setSmtpPort(cfg.getSmtpPort());\n            myCfg.setSmtpSsl(cfg.isSmtpSsl());\n            myCfg.setSmtpUsername(cfg.getSmtpUsername());\n            myCfg.setSmtpPassword(cfg.getSmtpPassword());\n            myCfg.setAdminEmails(cfg.getAdminEmails());\n\n            // REST configuration.\n            myCfg.setClientConnectionConfiguration(clientCfg);\n\n            // Portable configuration.\n            myCfg.setPortableConfiguration(cfg.getPortableConfiguration());\n\n            // Hadoop configuration.\n            myCfg.setHadoopConfiguration(cfg.getHadoopConfiguration());\n\n            // Validate segmentation configuration.\n            GridSegmentationPolicy segPlc = cfg.getSegmentationPolicy();\n\n            // 1. Warn on potential configuration problem: grid is not configured to wait\n            // for correct segment after segmentation happens.\n            if (!F.isEmpty(cfg.getSegmentationResolvers()) && segPlc == RESTART_JVM && !cfg.isWaitForSegmentOnStart()) {\n                U.warn(log, \"Found potential configuration problem (forgot to enable waiting for segment\" +\n                    \"on start?) [segPlc=\" + segPlc + \", wait=false]\");\n            }\n\n            myCfg.setSegmentationResolvers(cfg.getSegmentationResolvers());\n            myCfg.setSegmentationPolicy(segPlc);\n            myCfg.setSegmentCheckFrequency(cfg.getSegmentCheckFrequency());\n            myCfg.setWaitForSegmentOnStart(cfg.isWaitForSegmentOnStart());\n            myCfg.setAllSegmentationResolversPassRequired(cfg.isAllSegmentationResolversPassRequired());\n\n            // Override SMTP configuration from system properties\n            // and environment variables, if specified.\n            String fromEmail = IgniteSystemProperties.getString(IGNITE_SMTP_FROM);\n\n            if (fromEmail != null)\n                myCfg.setSmtpFromEmail(fromEmail);\n\n            String smtpHost = IgniteSystemProperties.getString(IGNITE_SMTP_HOST);\n\n            if (smtpHost != null)\n                myCfg.setSmtpHost(smtpHost);\n\n            String smtpUsername = IgniteSystemProperties.getString(IGNITE_SMTP_USERNAME);\n\n            if (smtpUsername != null)\n                myCfg.setSmtpUsername(smtpUsername);\n\n            String smtpPwd = IgniteSystemProperties.getString(IGNITE_SMTP_PWD);\n\n            if (smtpPwd != null)\n                myCfg.setSmtpPassword(smtpPwd);\n\n            int smtpPort = IgniteSystemProperties.getInteger(IGNITE_SMTP_PORT, -1);\n\n            if(smtpPort != -1)\n                myCfg.setSmtpPort(smtpPort);\n\n            myCfg.setSmtpSsl(IgniteSystemProperties.getBoolean(IGNITE_SMTP_SSL));\n\n            String adminEmails = IgniteSystemProperties.getString(IGNITE_ADMIN_EMAILS);\n\n            if (adminEmails != null)\n                myCfg.setAdminEmails(adminEmails.split(\",\"));\n\n            CacheConfiguration[] cacheCfgs = cfg.getCacheConfiguration();\n\n            final boolean hasHadoop = IgniteComponentType.HADOOP.inClassPath();\n\n            final boolean hasAtomics = cfg.getAtomicConfiguration() != null;\n\n            final boolean clientDisco = discoSpi instanceof TcpClientDiscoverySpi;\n\n            CacheConfiguration[] copies;\n\n            if (cacheCfgs != null && cacheCfgs.length > 0) {\n                if (!U.discoOrdered(discoSpi) && !U.relaxDiscoveryOrdered())\n                    throw new IgniteCheckedException(\"Discovery SPI implementation does not support node ordering and \" +\n                        \"cannot be used with cache (use SPI with @GridDiscoverySpiOrderSupport annotation, \" +\n                        \"like GridTcpDiscoverySpi)\");\n\n                for (CacheConfiguration ccfg : cacheCfgs) {\n                    if (CU.isHadoopSystemCache(ccfg.getName()))\n                        throw new IgniteCheckedException(\"Cache name cannot be \\\"\" + CU.SYS_CACHE_HADOOP_MR +\n                            \"\\\" because it is reserved for internal purposes.\");\n\n                    if (CU.isAtomicsCache(ccfg.getName()))\n                        throw new IgniteCheckedException(\"Cache name cannot be \\\"\" + CU.ATOMICS_CACHE_NAME +\n                            \"\\\" because it is reserved for internal purposes.\");\n\n                    if (CU.isUtilityCache(ccfg.getName()))\n                        throw new IgniteCheckedException(\"Cache name cannot start with \\\"\" + CU.UTILITY_CACHE_NAME +\n                            \"\\\" because this prefix is reserved for internal purposes.\");\n                }\n\n                int addCacheCnt = 1; // Always add utility cache.\n\n                if (hasHadoop)\n                    addCacheCnt++;\n\n                if (hasAtomics)\n                    addCacheCnt++;\n\n                copies = new CacheConfiguration[cacheCfgs.length + addCacheCnt];\n\n                int cloneIdx = 1;\n\n                if (hasHadoop)\n                    copies[cloneIdx++] = CU.hadoopSystemCache();\n\n                if (hasAtomics)\n                    copies[cloneIdx++] = atomicsSystemCache(cfg.getAtomicConfiguration(), clientDisco);\n\n                for (CacheConfiguration ccfg : cacheCfgs)\n                    copies[cloneIdx++] = new CacheConfiguration(ccfg);\n            }\n            else {\n                int cacheCnt = 1; // Always add utility cache.\n\n                if (hasHadoop)\n                    cacheCnt++;\n\n                if (hasAtomics)\n                    cacheCnt++;\n\n                copies = new CacheConfiguration[cacheCnt];\n\n                int cacheIdx = 1;\n\n                if (hasHadoop)\n                    copies[cacheIdx++] = CU.hadoopSystemCache();\n\n                if (hasAtomics)\n                    copies[cacheIdx] = atomicsSystemCache(cfg.getAtomicConfiguration(), clientDisco);\n            }\n\n            // Always add utility cache.\n            copies[0] = utilitySystemCache(clientDisco);\n\n            myCfg.setCacheConfiguration(copies);\n\n            myCfg.setCacheSanityCheckEnabled(cfg.isCacheSanityCheckEnabled());\n\n            try {\n                // Use reflection to avoid loading undesired classes.\n                Class helperCls = Class.forName(\"org.apache.ignite.util.GridConfigurationHelper\");\n\n                helperCls.getMethod(\"overrideConfiguration\", IgniteConfiguration.class, Properties.class,\n                    String.class, IgniteLogger.class).invoke(helperCls, myCfg, System.getProperties(), name, log);\n            }\n            catch (Exception ignored) {\n                // No-op.\n            }\n\n            // Ensure that SPIs support multiple grid instances, if required.\n            if (!startCtx.single()) {\n                ensureMultiInstanceSupport(deploySpi);\n                ensureMultiInstanceSupport(commSpi);\n                ensureMultiInstanceSupport(discoSpi);\n                ensureMultiInstanceSupport(cpSpi);\n                ensureMultiInstanceSupport(evtSpi);\n                ensureMultiInstanceSupport(colSpi);\n                ensureMultiInstanceSupport(failSpi);\n                ensureMultiInstanceSupport(authSpi);\n                ensureMultiInstanceSupport(sesSpi);\n                ensureMultiInstanceSupport(loadBalancingSpi);\n                ensureMultiInstanceSupport(swapspaceSpi);\n            }\n\n            // Register Ignite MBean for current grid instance.\n            registerFactoryMbean(myCfg.getMBeanServer());\n\n            boolean started = false;\n\n            try {\n                IgniteKernal grid0 = new IgniteKernal(startCtx.springContext());\n\n                // Init here to make grid available to lifecycle listeners.\n                grid = grid0;\n\n                grid0.start(myCfg, utilityCacheExecSvc, execSvc, sysExecSvc, p2pExecSvc, mgmtExecSvc, ggfsExecSvc,\n                    restExecSvc,\n                    new CA() {\n                        @Override public void apply() {\n                        startLatch.countDown();\n                    }\n                });\n\n                state = STARTED;\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Grid factory started ok: \" + name);\n\n                started = true;\n            }\n            catch (IgniteCheckedException e) {\n                unregisterFactoryMBean();\n\n                throw e;\n            }\n            // Catch Throwable to protect against any possible failure.\n            catch (Throwable e) {\n                unregisterFactoryMBean();\n\n                throw new IgniteCheckedException(\"Unexpected exception when starting grid.\", e);\n            }\n            finally {\n                if (!started)\n                    // Grid was not started.\n                    grid = null;\n            }\n\n            // Do NOT set it up only if IGNITE_NO_SHUTDOWN_HOOK=TRUE is provided.\n            if (!IgniteSystemProperties.getBoolean(IGNITE_NO_SHUTDOWN_HOOK, false)) {\n                try {\n                    Runtime.getRuntime().addShutdownHook(shutdownHook = new Thread() {\n                        @Override public void run() {\n                            if (log.isInfoEnabled())\n                                log.info(\"Invoking shutdown hook...\");\n\n                            IgniteNamedInstance.this.stop(true);\n                        }\n                    });\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Shutdown hook is installed.\");\n                }\n                catch (IllegalStateException e) {\n                    stop(true);\n\n                    throw new IgniteCheckedException(\"Failed to install shutdown hook.\", e);\n                }\n            }\n            else {\n                if (log.isDebugEnabled())\n                    log.debug(\"Shutdown hook has not been installed because environment \" +\n                        \"or system property \" + IGNITE_NO_SHUTDOWN_HOOK + \" is set.\");\n            }\n        }","commit_id":"2307f7404ce1d2069dbaaddc591a4ca4ea8ca3e6","url":"https://github.com/apache/ignite"},{"original_method":"/**\n         * Stops executor services if they has been started.\n         *\n         * @param log Grid logger.\n         */\n        private void stopExecutors0(IgniteLogger log) {\n            assert log != null;\n\n            U.shutdownNow(getClass(), execSvc, log);\n\n            execSvc = null;\n\n            U.shutdownNow(getClass(), sysExecSvc, log);\n\n            sysExecSvc = null;\n\n            U.shutdownNow(getClass(), mgmtExecSvc, log);\n\n            mgmtExecSvc = null;\n\n            U.shutdownNow(getClass(), p2pExecSvc, log);\n\n            p2pExecSvc = null;\n\n            U.shutdownNow(getClass(), ggfsExecSvc, log);\n\n            ggfsExecSvc = null;\n\n            U.shutdownNow(getClass(), restExecSvc, log);\n\n            restExecSvc = null;\n\n            U.shutdownNow(getClass(), utilityCacheExecSvc, log);\n\n            utilityCacheExecSvc = null;\n        }","id":91050,"modified_method":"/**\n         * Stops executor services if they has been started.\n         *\n         * @param log Grid logger.\n         */\n        private void stopExecutors0(IgniteLogger log) {\n            assert log != null;\n\n            U.shutdownNow(getClass(), execSvc, log);\n\n            execSvc = null;\n\n            U.shutdownNow(getClass(), sysExecSvc, log);\n\n            sysExecSvc = null;\n\n            U.shutdownNow(getClass(), mgmtExecSvc, log);\n\n            mgmtExecSvc = null;\n\n            U.shutdownNow(getClass(), p2pExecSvc, log);\n\n            p2pExecSvc = null;\n\n            U.shutdownNow(getClass(), ggfsExecSvc, log);\n\n            ggfsExecSvc = null;\n\n            if (restExecSvc != null)\n                U.shutdownNow(getClass(), restExecSvc, log);\n\n            restExecSvc = null;\n\n            U.shutdownNow(getClass(), utilityCacheExecSvc, log);\n\n            utilityCacheExecSvc = null;\n        }","commit_id":"2307f7404ce1d2069dbaaddc591a4ca4ea8ca3e6","url":"https://github.com/apache/ignite"},{"original_method":"public void stop() {\n    for (StreamSubscriber subscriber : streamSubscribers.values()) {\n      subscriber.stopAndWait();\n    }\n    pollBookingExecutor.shutdownNow();\n    streamPollingExecutor.shutdownNow();\n  }","id":91051,"modified_method":"public void stop() {\n    for (StreamSubscriber subscriber : streamSubscribers.values()) {\n      subscriber.stopAndWait();\n    }\n    if (pollBookingExecutor != null) {\n      pollBookingExecutor.shutdownNow();\n    }\n    if (streamPollingExecutor != null) {\n      streamPollingExecutor.shutdownNow();\n    }\n  }","commit_id":"48a2fb3cbe7869b8b89260925f7894a2b894b93d","url":"https://github.com/caskdata/cdap"},{"original_method":"public void stop() {\n    for (StreamSubscriber subscriber : streamSubscribers.values()) {\n      subscriber.stopAndWait();\n    }\n    pollBookingExecutor.shutdownNow();\n    streamPollingExecutor.shutdownNow();\n  }","id":91052,"modified_method":"public void stop() {\n    for (StreamSubscriber subscriber : streamSubscribers.values()) {\n      subscriber.stopAndWait();\n    }\n    if (pollBookingExecutor != null) {\n      pollBookingExecutor.shutdownNow();\n    }\n    if (streamPollingExecutor != null) {\n      streamPollingExecutor.shutdownNow();\n    }\n    if (taskExecutorService != null) {\n      taskExecutorService.shutdownNow();\n    }\n  }","commit_id":"d4c5b1db7cc17faec18b9d078ae0aeaedbdfd218","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    protected void destroyInternal() throws LifecycleException {\n\n        // Stop the Valves in our pipeline (including the basic), if any\n        if (pipeline instanceof Lifecycle) {\n            ((Lifecycle) pipeline).destroy();\n        }\n\n        // Remove children now this container is being destroyed\n        for (Container child : findChildren()) {\n            removeChild(child);\n        }\n\n        // Required if the child is destroyed directly.\n        if (parent != null) {\n            parent.removeChild(this);\n        }\n\n        startStopExecutor.shutdownNow();\n\n        super.destroyInternal();\n    }","id":91053,"modified_method":"@Override\n    protected void destroyInternal() throws LifecycleException {\n\n        // Stop the Valves in our pipeline (including the basic), if any\n        if (pipeline instanceof Lifecycle) {\n            ((Lifecycle) pipeline).destroy();\n        }\n\n        // Remove children now this container is being destroyed\n        for (Container child : findChildren()) {\n            removeChild(child);\n        }\n\n        // Required if the child is destroyed directly.\n        if (parent != null) {\n            parent.removeChild(this);\n        }\n\n        // If init fails, this may be null\n        if (startStopExecutor != null) {\n            startStopExecutor.shutdownNow();\n        }\n\n        super.destroyInternal();\n    }","commit_id":"f4878ef9e4360cc3e1f0b94cc2e6d110b8defb78","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n  public TimeSeriesTable createTimeSeries(String namespace, int resolution) {\n    try {\n      String tableName = namespace + \".\" +\n                          cConf.get(MetricsConstants.ConfigKeys.METRICS_TABLE_PREFIX,\n                                    MetricsConstants.DEFAULT_METRIC_TABLE_PREFIX) + \".ts.\" + resolution;\n      int ttl =  cConf.getInt(MetricsConstants.ConfigKeys.RETENTION_HOURS + \".\" + resolution, -1);\n\n      OrderedVersionedColumnarTable table;\n      if (ttl > 0 && tableHandle instanceof TimeToLiveOVCTableHandle) {\n        // If TTL exists and the table handle supports it, use the TTL as well.\n        ttl = (int) TimeUnit.SECONDS.convert(ttl, TimeUnit.HOURS);\n        table = ((TimeToLiveOVCTableHandle) tableHandle).getTable(Bytes.toBytes(tableName), ttl);\n      } else {\n        table = tableHandle.getTable(Bytes.toBytes(tableName));\n      }\n\n      return new TimeSeriesTable(table, entityCodec, resolution, getRollTime(resolution));\n    } catch (OperationException e) {\n      throw Throwables.propagate(e);\n    }\n  }","id":91054,"modified_method":"@Override\n  public TimeSeriesTable createTimeSeries(String namespace, int resolution) {\n    try {\n      String tableName = namespace + \".\" +\n                          cConf.get(MetricsConstants.ConfigKeys.METRICS_TABLE_PREFIX,\n                                    MetricsConstants.DEFAULT_METRIC_TABLE_PREFIX) + \".ts.\" + resolution;\n      int ttl =  cConf.getInt(MetricsConstants.ConfigKeys.RETENTION_SECONDS + \".\" + resolution + \".seconds\", -1);\n\n      OrderedVersionedColumnarTable table;\n      if (ttl > 0 && tableHandle instanceof TimeToLiveOVCTableHandle) {\n        // If TTL exists and the table handle supports it, use the TTL as well.\n        table = ((TimeToLiveOVCTableHandle) tableHandle).getTable(Bytes.toBytes(tableName), ttl);\n      } else {\n        table = tableHandle.getTable(Bytes.toBytes(tableName));\n      }\n\n      return new TimeSeriesTable(table, entityCodec, resolution, getRollTime(resolution));\n    } catch (OperationException e) {\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"787f52c5b6a5b777d439e32ab5a80360d1037531","url":"https://github.com/caskdata/cdap"},{"original_method":"public HBaseFilterableOVCTable(CConfiguration cConf, Configuration conf, byte[] tableName, byte[] family,\n                                 IOExceptionHandler exceptionHandler) throws OperationException {\n    super(cConf, conf, tableName, family, exceptionHandler);\n  }","id":91055,"modified_method":"public HBaseFilterableOVCTable(CConfiguration cConf, Configuration conf, byte[] tableName, byte[] family,\n                                 IOExceptionHandler exceptionHandler, int ttl) throws OperationException {\n    super(cConf, conf, tableName, family, exceptionHandler);\n    this.ttl = ttl;\n  }","commit_id":"787f52c5b6a5b777d439e32ab5a80360d1037531","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected HBaseOVCTable createOVCTable(byte[] tableName) throws OperationException {\n    return new HBaseFilterableOVCTable(conf, hConf, tableName, FAMILY, new HBaseIOExceptionHandler());\n  }","id":91056,"modified_method":"@Override\n  protected HBaseOVCTable createOVCTable(byte[] tableName) throws OperationException {\n    return new HBaseFilterableOVCTable(conf, hConf, tableName, FAMILY, new HBaseIOExceptionHandler(), -1);\n  }","commit_id":"787f52c5b6a5b777d439e32ab5a80360d1037531","url":"https://github.com/caskdata/cdap"},{"original_method":"protected HTable createTable(byte [] tableName, byte [] family, int ttl) throws IOException {\n    if (this.admin.tableExists(tableName)) {\n      LOG.debug(\"Attempt to creating table '\" + tableName + \"', which already exists. Opening existing table instead.\");\n      return new HTable(this.hConf, tableName);\n    }\n    HTableDescriptor htd = new HTableDescriptor(tableName);\n    HColumnDescriptor hcd = new HColumnDescriptor(family);\n    if (ttl > 0) {\n      hcd.setTimeToLive(ttl);\n    }\n    htd.addFamily(hcd);\n    try {\n      LOG.info(\"Creating table '\" + new String(tableName) + \"'\");\n      this.admin.createTable(htd);\n    } catch (TableExistsException e) {\n      // table may exist because someone else is creating it at the same\n      // time. But it may not be available yet, and opening it might fail.\n      LOG.info(\"Creating table '\" + new String(tableName) + \"' failed with: \"\n                 + e.getMessage() + \".\");\n      // Wait at most 2 seconds for table to materialize\n      long waitAtMost = 5000;\n      long giveUpTime = System.currentTimeMillis() + waitAtMost;\n      boolean exists = false;\n      while (!exists && System.currentTimeMillis() < giveUpTime) {\n        if (this.admin.tableExists(tableName)) {\n          exists = true;\n        } else {\n          try {\n            Thread.sleep(100);\n          } catch (InterruptedException e1) {\n            LOG.error(\"Thread interrupted: \" + e1.getMessage(), e1);\n            break;\n          }\n        }\n      }\n      if (exists) {\n        LOG.info(\"Table '\" + new String(tableName) + \"' exists now. Assuming \" +\n                   \"that another process concurrently created it. \");\n      } else {\n        com.esotericsoftware.minlog.Log.error(\"Table '\" + new String(tableName) + \"' does not exist after\" +\n                                                \" waiting \" + waitAtMost + \" ms. Giving up. \");\n        throw e;\n      }\n    }\n    return new HTable(this.hConf, tableName);\n  }","id":91057,"modified_method":"protected HTable createTable(byte [] tableName, byte [] family, int ttl) throws IOException, OperationException {\n    if (this.admin.tableExists(tableName)) {\n      LOG.debug(\"Attempt to creating table '\" + tableName + \"', which already exists. Opening existing table instead.\");\n      return new HTable(this.hConf, tableName);\n    }\n    HTableDescriptor htd = new HTableDescriptor(tableName);\n    HColumnDescriptor hcd = new HColumnDescriptor(family);\n    if (ttl > 0) {\n      hcd.setTimeToLive(ttl);\n    }\n    htd.addFamily(hcd);\n    try {\n      LOG.info(\"Creating table '\" + new String(tableName) + \"'\");\n      this.admin.createTable(htd);\n    } catch (TableExistsException e) {\n      // table may exist because someone else is creating it at the same\n      // time. But it may not be available yet, and opening it might fail.\n      LOG.info(\"Creating table '\" + new String(tableName) + \"' failed with: \"\n                 + e.getMessage() + \".\");\n      // Wait at most 2 seconds for table to materialize\n      long waitAtMost = 5000;\n      long giveUpTime = System.currentTimeMillis() + waitAtMost;\n      boolean exists = false;\n      while (!exists && System.currentTimeMillis() < giveUpTime) {\n        if (this.admin.tableExists(tableName)) {\n          exists = true;\n        } else {\n          try {\n            Thread.sleep(100);\n          } catch (InterruptedException e1) {\n            LOG.error(\"Thread interrupted: \" + e1.getMessage(), e1);\n            break;\n          }\n        }\n      }\n      if (exists) {\n        alterTableTTL(tableName, ttl);\n        LOG.info(\"Table '\" + new String(tableName) + \"' exists now. Assuming \" +\n                 \"that another process concurrently created it. \");\n      } else {\n        LOG.error(\"Table '\" + new String(tableName) + \"' does not exist after waiting \" +\n                  waitAtMost + \" ms. Giving up. \");\n        throw e;\n      }\n    }\n    return new HTable(this.hConf, tableName);\n  }","commit_id":"787f52c5b6a5b777d439e32ab5a80360d1037531","url":"https://github.com/caskdata/cdap"},{"original_method":"protected OrderedVersionedColumnarTable createNewTable(byte[] tableName, int ttl) throws OperationException {\n    try {\n      createTable(tableName, FAMILY, ttl);\n      return createOVCTable(tableName);\n    } catch (IOException e) {\n      exceptionHandler.handle(e);\n    }\n    return null;\n  }","id":91058,"modified_method":"protected OrderedVersionedColumnarTable createNewTable(byte[] tableName, int ttl) throws OperationException {\n    try {\n      createTable(tableName, FAMILY, ttl);\n      return createOVCTable(tableName, ttl);\n    } catch (IOException e) {\n      exceptionHandler.handle(e);\n    }\n    return null;\n  }","commit_id":"787f52c5b6a5b777d439e32ab5a80360d1037531","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public OrderedVersionedColumnarTable getTable(byte[] tableName, int ttl) throws OperationException {\n    OrderedVersionedColumnarTable table = this.openTables.get(tableName);\n\n    // we currently have an open table for this name\n    if (table != null) {\n      return table;\n    }\n\n    // the table is not open, but it may exist in the data fabric\n    table = openTable(tableName);\n\n    // table could not be opened, try to create it\n    if (table == null) {\n      table = createNewTable(tableName, ttl);\n    }\n\n    // some other thread may have created/found and added it already\n    OrderedVersionedColumnarTable existing =\n      this.openTables.putIfAbsent(tableName, table);\n\n    return existing != null ? existing : table;\n  }","id":91059,"modified_method":"@Override\n  public OrderedVersionedColumnarTable getTable(byte[] tableName, int ttl) throws OperationException {\n    // Get the table from in memory cache.\n    OrderedVersionedColumnarTable table = this.openTables.get(tableName);\n\n    // we currently have an open table for this name\n    if (table != null) {\n      alterTableTTL(tableName, ttl);\n      return table;\n    }\n\n    // the table is not open, but it may exist in the data fabric\n    table = openTable(tableName, ttl);\n\n    // table could not be opened, try to create it\n    if (table == null) {\n      table = createNewTable(tableName, ttl);\n    }\n\n    // some other thread may have created/found and added it already\n    OrderedVersionedColumnarTable existing =\n      this.openTables.putIfAbsent(tableName, table);\n\n    return existing != null ? existing : table;\n  }","commit_id":"787f52c5b6a5b777d439e32ab5a80360d1037531","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void startUp() throws Exception {\n    super.startUp();\n\n    scheduler = Executors.newSingleThreadScheduledExecutor(Threads.createDaemonThreadFactory(\"metrics-cleanup\"));\n    long retention = cConf.getLong(MetricsConstants.ConfigKeys.RETENTION_HOURS + \".1\",\n                                   MetricsConstants.DEFAULT_RETENTION_HOURS);\n\n    scheduler.scheduleAtFixedRate(\n      createCleanupTask(TimeUnit.SECONDS.convert(retention, TimeUnit.HOURS)), 0, 1, TimeUnit.HOURS);\n  }","id":91060,"modified_method":"@Override\n  protected void startUp() throws Exception {\n    super.startUp();\n\n    // Only do cleanup if the underlying table doesn't supports TTL.\n    if (!tableFactory.isTTLSupported()) {\n      scheduler = Executors.newSingleThreadScheduledExecutor(Threads.createDaemonThreadFactory(\"metrics-cleanup\"));\n      long retention = cConf.getLong(MetricsConstants.ConfigKeys.RETENTION_SECONDS + \".1.seconds\",\n                                     MetricsConstants.DEFAULT_RETENTION_HOURS);\n\n\n      scheduler.scheduleAtFixedRate(createCleanupTask(retention), 0, 1, TimeUnit.HOURS);\n    }\n  }","commit_id":"787f52c5b6a5b777d439e32ab5a80360d1037531","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void shutDown() throws Exception {\n    super.shutDown();\n    scheduler.shutdownNow();\n  }","id":91061,"modified_method":"@Override\n  protected void shutDown() throws Exception {\n    if (scheduler != null) {\n      scheduler.shutdownNow();\n    }\n    super.shutDown();\n  }","commit_id":"787f52c5b6a5b777d439e32ab5a80360d1037531","url":"https://github.com/caskdata/cdap"},{"original_method":"void traverseToRoot(@NotNull PsiElement psiElement, Set<VirtualFile> roots) {\n    if (!psiElement.isValid()) return;\n    final PsiFile containingFile = psiElement.getContainingFile();\n    if (containingFile != null && containingFile.getVirtualFile() == null) return; //non phisycal elements\n    psiElement = psiElement.getOriginalElement();\n    PsiElement resultElement = psiElement;\n    if (containingFile != null) {\n      if (!(psiElement instanceof PsiClass)) {\n        resultElement = containingFile;\n      }\n      final PsiDirectory containingDirectory = containingFile.getContainingDirectory();\n      if (containingDirectory != null) {\n        traverseToRoot(containingDirectory, roots);\n      }\n    }\n    else if (psiElement instanceof PsiDirectory) {\n      final PsiDirectory psiDirectory = (PsiDirectory)psiElement;\n      final PsiDirectory parentDirectory = psiDirectory.getParentDirectory();\n      if (!roots.contains(psiDirectory.getVirtualFile()) && parentDirectory != null) {\n        traverseToRoot(parentDirectory, roots);\n      }\n    }\n    else if (psiElement instanceof PsiPackage) {\n      final PsiPackage psiPackage = (PsiPackage)psiElement;\n      final PsiPackage parentPackage = psiPackage.getParentPackage();\n      if (parentPackage != null) {\n        final String qualifiedName = parentPackage.getQualifiedName();\n        if (qualifiedName.length() > 0) {\n          traverseToRoot(parentPackage, roots);\n        }\n      }\n    }\n    addElement(resultElement);\n  }","id":91062,"modified_method":"private void traverseToRoot(@NotNull PsiElement psiElement, Set<VirtualFile> roots) {\n    if (!psiElement.isValid()) return;\n    final PsiFile containingFile = psiElement.getContainingFile();\n    if (containingFile != null && containingFile.getVirtualFile() == null) return; //non phisycal elements\n    psiElement = psiElement.getOriginalElement();\n    PsiElement resultElement = psiElement;\n    if (containingFile != null) {\n      if (!(psiElement instanceof PsiClass)) {\n        resultElement = containingFile;\n      }\n      final PsiDirectory containingDirectory = containingFile.getContainingDirectory();\n      if (containingDirectory != null) {\n        traverseToRoot(containingDirectory, roots);\n      }\n    }\n    else if (psiElement instanceof PsiDirectory) {\n      final PsiDirectory psiDirectory = (PsiDirectory)psiElement;\n      final PsiDirectory parentDirectory = psiDirectory.getParentDirectory();\n      if (!roots.contains(psiDirectory.getVirtualFile()) && parentDirectory != null) {\n        traverseToRoot(parentDirectory, roots);\n      }\n    }\n    else if (psiElement instanceof PsiPackage) {\n      final PsiPackage psiPackage = (PsiPackage)psiElement;\n      final PsiPackage parentPackage = psiPackage.getParentPackage();\n      if (parentPackage != null) {\n        final String qualifiedName = parentPackage.getQualifiedName();\n        if (qualifiedName.length() > 0) {\n          traverseToRoot(parentPackage, roots);\n        }\n      }\n    }\n    addElement(resultElement);\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void getDirectoryChildren(final PsiDirectory psiDirectory, final Object rootElement, final java.util.List<Object> result) {\n    final ModuleFileIndex moduleFileIndex =\n      rootElement instanceof Module ? ModuleRootManager.getInstance((Module)rootElement).getFileIndex() : null;\n    final PsiElement[] children = psiDirectory.getChildren();\n    for (PsiElement child : children) {\n      if (child != null && child.isValid()) {\n        if (moduleFileIndex != null) {\n          final VirtualFile virtualFile = PsiUtil.getVirtualFile(child);\n          if (virtualFile != null && !moduleFileIndex.isInContent(virtualFile)) continue;\n        }\n        result.add(child);\n      }\n    }\n  }","id":91063,"modified_method":"private static void getDirectoryChildren(final PsiDirectory psiDirectory, final Object rootElement, final List<Object> result) {\n    final ModuleFileIndex moduleFileIndex =\n      rootElement instanceof Module ? ModuleRootManager.getInstance((Module)rootElement).getFileIndex() : null;\n    final PsiElement[] children = psiDirectory.getChildren();\n    for (PsiElement child : children) {\n      if (child != null && child.isValid()) {\n        if (moduleFileIndex != null) {\n          final VirtualFile virtualFile = PsiUtil.getVirtualFile(child);\n          if (virtualFile != null && !moduleFileIndex.isInContent(virtualFile)) continue;\n        }\n        result.add(child);\n      }\n    }\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean updateModel(final PsiElement psiElement) {\n    int oldModelSize = size();\n    java.util.List<Object> oldModel = new ArrayList<Object>();\n    for (int i = 0; i < oldModelSize; i++) {\n      oldModel.add(getElement(i));\n    }\n    removeAllElements();\n    final Project project = psiElement.getProject();\n    addElement(project);\n    final Set<VirtualFile> roots = new HashSet<VirtualFile>();\n    final ProjectRootManager projectRootManager = ProjectRootManager.getInstance(project);\n    Module module = ModuleUtil.findModuleForPsiElement(psiElement);\n    final ProjectFileIndex projectFileIndex = projectRootManager.getFileIndex();\n    if (module != null) {\n      VirtualFile vFile = PsiUtil.getVirtualFile(psiElement);\n      if (vFile != null && (projectFileIndex.isInLibrarySource(vFile) || projectFileIndex.isInLibraryClasses(vFile))) {\n        module = null;\n      }\n    }\n    if (module == null) {\n      roots.addAll(Arrays.asList(projectRootManager.getContentRoots()));\n    }\n    else {\n      ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(module);\n      roots.addAll(Arrays.asList(moduleRootManager.getContentRoots()));\n      addElement(module);\n    }\n    traverseToRoot(psiElement, roots);\n    if (oldModelSize == size()) {\n      for (int i = 0; i < oldModelSize; i++) {\n        if (!Comparing.equal(oldModel.get(i), getElement(i))) return true;\n      }\n      return false;\n    }\n    else {\n      return true;\n    }\n  }","id":91064,"modified_method":"protected boolean updateModel(final PsiElement psiElement) {\n    final int oldModelSize = size();\n    final List<Object> oldModel = new ArrayList<Object>();\n    for (int i = 0; i < oldModelSize; i++) {\n      oldModel.add(getElement(i));\n    }\n    removeAllElements();\n    final Project project = psiElement.getProject();\n    addElement(project);\n    final Set<VirtualFile> roots = new HashSet<VirtualFile>();\n    final ProjectRootManager projectRootManager = ProjectRootManager.getInstance(project);\n    Module module = ModuleUtil.findModuleForPsiElement(psiElement);\n    final ProjectFileIndex projectFileIndex = projectRootManager.getFileIndex();\n    if (module != null) {\n      VirtualFile vFile = PsiUtil.getVirtualFile(psiElement);\n      if (vFile != null && (projectFileIndex.isInLibrarySource(vFile) || projectFileIndex.isInLibraryClasses(vFile))) {\n        module = null;\n      }\n    }\n    if (module == null) {\n      roots.addAll(Arrays.asList(projectRootManager.getContentRoots()));\n    }\n    else {\n      ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(module);\n      roots.addAll(Arrays.asList(moduleRootManager.getContentRoots()));\n      addElement(module);\n    }\n    traverseToRoot(psiElement, roots);\n    if (oldModelSize == size()) {\n      for (int i = 0; i < oldModelSize; i++) {\n        if (!Comparing.equal(oldModel.get(i), getElement(i))) return true;\n      }\n      return false;\n    }\n    else {\n      return true;\n    }\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean hasChildren(Object object) {\n    if (!checkValid(object)) return false;\n    if (object instanceof Project) {\n      return ModuleManager.getInstance((Project)object).getModules().length > 0;\n    }\n    if (object instanceof Module) {\n      final Module module = (Module)object;\n      if (module.isDisposed()) return false;\n      final ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(module);\n      return moduleRootManager.getContentRoots().length > 0;\n    }\n    if (object instanceof PsiClass || object instanceof PsiFile) {\n      return false;\n    }\n    if (object instanceof PsiDirectory) {\n      final java.util.List<Object> result = new ArrayList<Object>();\n      final Object rootElement = size() > 1 ? getElement(1) : null;\n      if (rootElement instanceof Module && ((Module)rootElement).isDisposed()) return false;\n      getDirectoryChildren((PsiDirectory)object, rootElement, result);\n      return result.size() > 0;\n    }\n    if (object instanceof OrderEntry) {\n      final JdkOrderEntry entry = (JdkOrderEntry)object;\n      return entry.getFiles(OrderRootType.SOURCES).length > 0 || entry.getFiles(OrderRootType.CLASSES).length > 0;\n    }\n    return false;\n  }","id":91065,"modified_method":"protected boolean hasChildren(Object object) {\n    if (!checkValid(object)) return false;\n    if (object instanceof Project) {\n      return ModuleManager.getInstance((Project)object).getModules().length > 0;\n    }\n    if (object instanceof Module) {\n      final Module module = (Module)object;\n      if (module.isDisposed()) return false;\n      final ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(module);\n      return moduleRootManager.getContentRoots().length > 0;\n    }\n    if (object instanceof PsiClass || object instanceof PsiFile) {\n      return false;\n    }\n    if (object instanceof PsiDirectory) {\n      final List<Object> result = new ArrayList<Object>();\n      final Object rootElement = size() > 1 ? getElement(1) : null;\n      if (rootElement instanceof Module && ((Module)rootElement).isDisposed()) return false;\n      getDirectoryChildren((PsiDirectory)object, rootElement, result);\n      return result.size() > 0;\n    }\n    if (object instanceof OrderEntry) {\n      final JdkOrderEntry entry = (JdkOrderEntry)object;\n      return entry.getFiles(OrderRootType.SOURCES).length > 0 || entry.getFiles(OrderRootType.CLASSES).length > 0;\n    }\n    return false;\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"java.util.List<Object> calcElementChildren(final Object object) {\n    final java.util.List<Object> result = new ArrayList<Object>();\n    Object rootElement = size() > 1 ? getElement(1) : null;\n    if (!(object instanceof Project) && rootElement instanceof Module && ((Module)rootElement).isDisposed()) return result;\n    final PsiManager psiManager = PsiManager.getInstance(myProject);\n    if (object instanceof Project) {\n      result.addAll(Arrays.asList(ModuleManager.getInstance((Project)object).getModules()));\n    }\n    else if (object instanceof Module) {\n      Module module = (Module)object;\n      if (!module.isDisposed()) {\n        ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(module);\n        VirtualFile[] roots = moduleRootManager.getContentRoots();\n        for (VirtualFile root : roots) {\n          final PsiDirectory psiDirectory = psiManager.findDirectory(root);\n          if (psiDirectory != null) {\n            result.add(psiDirectory);\n          }\n        }\n      }\n    }\n    else if (object instanceof PsiPackage) {\n      final PsiPackage psiPackage = (PsiPackage)object;\n      final PsiDirectory[] psiDirectories = rootElement instanceof Module\n                                            ? psiPackage.getDirectories(GlobalSearchScope.moduleScope((Module)rootElement))\n                                            : psiPackage.getDirectories();\n      for (PsiDirectory psiDirectory : psiDirectories) {\n        getDirectoryChildren(psiDirectory, rootElement, result);\n      }\n    }\n    else if (object instanceof PsiDirectory) {\n      getDirectoryChildren((PsiDirectory)object, rootElement, result);\n    }\n    Collections.sort(result, new SiblingsComparator());\n    return result;\n  }","id":91066,"modified_method":"List<Object> calcElementChildren(final Object object) {\n    final List<Object> result = new ArrayList<Object>();\n    Object rootElement = size() > 1 ? getElement(1) : null;\n    if (!(object instanceof Project) && rootElement instanceof Module && ((Module)rootElement).isDisposed()) return result;\n    final PsiManager psiManager = PsiManager.getInstance(myProject);\n    if (object instanceof Project) {\n      result.addAll(Arrays.asList(ModuleManager.getInstance((Project)object).getModules()));\n    }\n    else if (object instanceof Module) {\n      Module module = (Module)object;\n      if (!module.isDisposed()) {\n        ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(module);\n        VirtualFile[] roots = moduleRootManager.getContentRoots();\n        for (VirtualFile root : roots) {\n          final PsiDirectory psiDirectory = psiManager.findDirectory(root);\n          if (psiDirectory != null) {\n            result.add(psiDirectory);\n          }\n        }\n      }\n    }\n    else if (object instanceof PsiPackage) {\n      final PsiPackage psiPackage = (PsiPackage)object;\n      final PsiDirectory[] psiDirectories = rootElement instanceof Module\n                                            ? psiPackage.getDirectories(GlobalSearchScope.moduleScope((Module)rootElement))\n                                            : psiPackage.getDirectories();\n      for (PsiDirectory psiDirectory : psiDirectories) {\n        getDirectoryChildren(psiDirectory, rootElement, result);\n      }\n    }\n    else if (object instanceof PsiDirectory) {\n      getDirectoryChildren((PsiDirectory)object, rootElement, result);\n    }\n    Collections.sort(result, new SiblingsComparator());\n    return result;\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void paintBorder() {\n    final MyCompositeLabel focusedLabel = myList.get(myModel.getSelectedIndex());\n    final Object o = myModel.getSelectedValue();\n    focusedLabel.getLabel().setIcon(wrapIcon(o, Color.gray));\n    final SimpleColoredComponent simpleColoredComponent = focusedLabel.getColoredComponent();\n    simpleColoredComponent.clear();\n    simpleColoredComponent.append(myModel.getPresentableText(o, getWindow()), myModel.getTextAttributes(o, true));\n    simpleColoredComponent.setBackground(UIUtil.getListSelectionBackground());\n    simpleColoredComponent.setForeground(UIUtil.getListSelectionForeground());\n    installDottedBorder(simpleColoredComponent);\n  }","id":91067,"modified_method":"private void paintBorder() {\n    final MyCompositeLabel focusedLabel = myList.get(myModel.getSelectedIndex());\n    final Object o = myModel.getSelectedValue();\n    final Icon icon = NavBarModel.getIcon(o);\n    focusedLabel.getLabel().setIcon(myModel.hasChildren(o) ? wrapIcon(icon, myModel.getSelectedIndex(), Color.gray) : icon);\n    final SimpleColoredComponent simpleColoredComponent = focusedLabel.getColoredComponent();\n    simpleColoredComponent.clear();\n    simpleColoredComponent.append(myModel.getPresentableText(o, getWindow()), myModel.getTextAttributes(o, true));\n    simpleColoredComponent.setBackground(UIUtil.getListSelectionBackground());\n    simpleColoredComponent.setForeground(UIUtil.getListSelectionForeground());\n    installDottedBorder(simpleColoredComponent);\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void navigateInsideBar(Object object) {\n    if (object instanceof PsiElement) {\n      final Object rootElement = myModel.size() > 1 ? myModel.getElement(1) : null;\n      if (rootElement instanceof Module) {\n        final Module module = (Module)rootElement;\n        myModel.removeAllElements();\n        myModel.addElement(module.getProject());\n        ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(module);\n        myModel.addElement(module);\n        myModel.traverseToRoot((PsiElement)object, new HashSet<VirtualFile>(Arrays.asList(moduleRootManager.getContentRoots())));\n      }\n      else {\n        myModel.updateModel((PsiElement)object);\n      }\n    }\n    else if (object instanceof Module) {\n      myModel.removeAllElements();\n      myModel.addElement(((Module)object).getProject());\n      myModel.addElement(object);\n    }\n    immediateUpdateList(true);\n    select();\n\n    if (myHint != null) {\n      immediateUpdateList(false); //to set up preffered size\n      final Dimension dimension = getPreferredSize();\n      final Rectangle bounds = myHint.getBounds();\n      myHint.setBounds(bounds.x, bounds.y, dimension.width, dimension.height);\n      select(); //restore selection\n    }\n\n    validate(); //calc bounds\n    click();\n  }","id":91068,"modified_method":"private void navigateInsideBar(Object object) {\n    myModel.updateModel(object);\n    immediateUpdateList(true);\n    select();\n\n    if (myHint != null) {\n      immediateUpdateList(false); //to set up preffered size\n      final Dimension dimension = getPreferredSize();\n      final Rectangle bounds = myHint.getBounds();\n      myHint.setBounds(bounds.x, bounds.y, dimension.width, dimension.height);\n      select(); //restore selection\n    }\n\n    validate(); //calc bounds\n    click();\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NavBarPanel(final Project project) {\n    myProject = project;\n    myModel = new NavBarModel(myProject);\n    setLayout(new BorderLayout());\n    setBackground(UIUtil.getListBackground());\n    setBorder(BorderFactory.createEmptyBorder(0, 2, 0, 2));\n\n    myScrollablePanel.setBackground(UIUtil.getListBackground());\n    myScrollablePanel.setBorder(BorderFactory.createEtchedBorder());\n\n    add(myScrollablePanel, BorderLayout.CENTER);\n    add(myLeftButton, BorderLayout.WEST);\n    add(myRightButton, BorderLayout.EAST);\n\n    myLeftButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        selectLast();\n        shiftFocus(-1);\n      }\n    });\n    myLeftButton.setBorder(null);\n\n    myRightButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        selectLast();\n        shiftFocus(1);\n      }\n    });\n    myRightButton.setBorder(null);\n\n    PopupHandler.installPopupHandler(this, IdeActions.GROUP_PROJECT_VIEW_POPUP, ActionPlaces.NAVIGATION_BAR);\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        shiftFocus(-1);\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0), JComponent.WHEN_FOCUSED);\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        shiftFocus(1);\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0), JComponent.WHEN_FOCUSED);\n\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        shiftFocus(-myModel.getSelectedIndex());\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_HOME, 0), JComponent.WHEN_FOCUSED);\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        shiftFocus(myModel.size() - 1 - myModel.getSelectedIndex());\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_END, 0), JComponent.WHEN_FOCUSED);\n\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        if (myModel.getSelectedIndex() != -1) {\n          ctrlClick(myModel.getSelectedIndex());\n        }\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0), JComponent.WHEN_FOCUSED);\n\n    final ActionListener dblClickAction = new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        if (myModel.getSelectedIndex() != -1) {\n          doubleClick(myModel.getSelectedIndex());\n        }\n      }\n    };\n\n    registerKeyboardAction(dblClickAction, KeyStroke.getKeyStroke(KeyEvent.VK_F4, 0), JComponent.WHEN_FOCUSED);\n\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        clearBorder();\n        final int selectedIndex = -1;\n        myModel.setSelectedIndex(selectedIndex);\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), JComponent.WHEN_FOCUSED);\n\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        final Object o = myModel.getSelectedValue();\n        if (myModel.hasChildren(o)) {\n          navigateInsideBar(o);\n        }\n        else {\n          doubleClick(myModel.getSelectedIndex());\n        }\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), JComponent.WHEN_FOCUSED);\n\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        ToolWindowManager.getInstance(project).activateEditorComponent();\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), JComponent.WHEN_FOCUSED);\n\n    addFocusListener(new FocusListener() {\n      public void focusGained(final FocusEvent e) {}\n\n      public void focusLost(final FocusEvent e) {\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            if (myProject.isDisposed()) {\n              hideHint();\n              return;\n            }\n            final Component focusedComponent = WindowManagerEx.getInstanceEx().getFocusedComponent(myProject);\n            if (focusedComponent != NavBarPanel.this && !isAncestorOf(focusedComponent)) {\n              hideHint();\n            }\n          }\n        });\n\n      }\n    });\n\n    updateList();\n  }","id":91069,"modified_method":"public NavBarPanel(final Project project) {\n    myProject = project;\n    myModel = new NavBarModel(myProject);\n    setLayout(new BorderLayout());\n    setBackground(UIUtil.getListBackground());\n    setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));\n\n    myScrollablePanel.setBackground(UIUtil.getListBackground());\n    myScrollablePanel.setBorder(BorderFactory.createEtchedBorder());\n\n    add(myScrollablePanel, BorderLayout.CENTER);\n    add(myLeftButton, BorderLayout.WEST);\n    add(myRightButton, BorderLayout.EAST);\n\n    myLeftButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        selectLast();\n        shiftFocus(-1);\n      }\n    });\n    myLeftButton.setBorder(null);\n\n    myRightButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        selectLast();\n        shiftFocus(1);\n      }\n    });\n    myRightButton.setBorder(null);\n\n    PopupHandler.installPopupHandler(this, IdeActions.GROUP_PROJECT_VIEW_POPUP, ActionPlaces.NAVIGATION_BAR);\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        shiftFocus(-1);\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0), JComponent.WHEN_FOCUSED);\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        shiftFocus(1);\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0), JComponent.WHEN_FOCUSED);\n\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        shiftFocus(-myModel.getSelectedIndex());\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_HOME, 0), JComponent.WHEN_FOCUSED);\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        shiftFocus(myModel.size() - 1 - myModel.getSelectedIndex());\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_END, 0), JComponent.WHEN_FOCUSED);\n\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        if (myModel.getSelectedIndex() != -1) {\n          ctrlClick(myModel.getSelectedIndex());\n        }\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0), JComponent.WHEN_FOCUSED);\n\n    final ActionListener dblClickAction = new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        if (myModel.getSelectedIndex() != -1) {\n          doubleClick(myModel.getSelectedIndex());\n        }\n      }\n    };\n\n    registerKeyboardAction(dblClickAction, KeyStroke.getKeyStroke(KeyEvent.VK_F4, 0), JComponent.WHEN_FOCUSED);\n\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        final Object o = myModel.getSelectedValue();\n        if (myModel.hasChildren(o)) {\n          navigateInsideBar(o);\n        }\n        else {\n          doubleClick(myModel.getSelectedIndex());\n        }\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), JComponent.WHEN_FOCUSED);\n\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        clearBorder();\n        final int selectedIndex = -1;\n        myModel.setSelectedIndex(selectedIndex);\n        ToolWindowManager.getInstance(project).activateEditorComponent();\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), JComponent.WHEN_FOCUSED);\n\n    addFocusListener(new FocusListener() {\n      public void focusGained(final FocusEvent e) {}\n\n      public void focusLost(final FocusEvent e) {\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            if (myProject.isDisposed()) {\n              hideHint();\n              return;\n            }\n            final Component focusedComponent = WindowManagerEx.getInstanceEx().getFocusedComponent(myProject);\n            if (focusedComponent != NavBarPanel.this && !isAncestorOf(focusedComponent)) {\n              hideHint();\n            }\n          }\n        });\n\n      }\n    });\n\n    updateList();\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void clearBorder() {\n    if (myModel.isEmpty()) return;\n    final int index = myModel.getSelectedIndex() != -1 ? myModel.getSelectedIndex() : myModel.size() - 1;\n    final MyCompositeLabel focusLostLabel = myList.get(index);\n    final Object o = myModel.get(index);\n    focusLostLabel.getLabel().setIcon(wrapIcon(o, Color.gray));\n    final SimpleColoredComponent simpleColoredComponent = focusLostLabel.getColoredComponent();\n    simpleColoredComponent.clear();\n    simpleColoredComponent.append(myModel.getPresentableText(o, getWindow()), myModel.getTextAttributes(o, false));\n    simpleColoredComponent.setBackground(UIUtil.getListBackground());\n    simpleColoredComponent.setForeground(UIUtil.getListForeground());\n    clearBorder(simpleColoredComponent);\n  }","id":91070,"modified_method":"private void clearBorder() {\n    if (myModel.isEmpty()) return;\n    final int index = myModel.getSelectedIndex() != -1 ? myModel.getSelectedIndex() : myModel.size() - 1;\n    final MyCompositeLabel focusLostLabel = myList.get(index);\n    final Object o = myModel.get(index);\n    final Icon icon = NavBarModel.getIcon(o);\n    focusLostLabel.getLabel().setIcon(myModel.hasChildren(o) ? wrapIcon(icon, index, Color.gray) : icon);\n    final SimpleColoredComponent simpleColoredComponent = focusLostLabel.getColoredComponent();\n    simpleColoredComponent.clear();\n    simpleColoredComponent.append(myModel.getPresentableText(o, getWindow()), myModel.getTextAttributes(o, false));\n    simpleColoredComponent.setBackground(UIUtil.getListBackground());\n    simpleColoredComponent.setForeground(UIUtil.getListForeground());\n    clearBorder(simpleColoredComponent);\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void clearBorder(SimpleColoredComponent label) {\n    label.setBorder(BorderFactory.createEmptyBorder(0, 2, 0, 4));\n  }","id":91071,"modified_method":"private static void clearBorder(SimpleColoredComponent label) {\n    label.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 1));\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Icon wrapIcon(final Object object, final Color color) {\n    final Icon icon = NavBarModel.getIcon(object);\n    if (icon == null || !myModel.hasChildren(object)) return icon;\n    LayeredIcon layeredIcon = new LayeredIcon(2);\n    layeredIcon.setIcon(icon, 0);\n    Icon plusIcon = new Icon() {\n      public void paintIcon(Component c, Graphics g, int x, int y) {\n        g.setColor(color);\n        g.drawRect(x + 1, y - 4, 8, 8);\n        g.drawLine(x + 3, y, x + 7, y);\n        if (myModel.getSelectedIndex() != myModel.indexOf(object) || myNodePopup == null || !myNodePopup.isVisible()) {\n          g.drawLine(x + 5, y - 2, x + 5, y + 2);\n        }\n      }\n\n      public int getIconWidth() {\n        return 10;\n      }\n\n      public int getIconHeight() {\n        return 8;\n      }\n    };\n    layeredIcon.setIcon(plusIcon, 1, -12, icon.getIconHeight() / 2);\n    return layeredIcon;\n  }","id":91072,"modified_method":"private Icon wrapIcon(final Icon icon, final int idx, final Color color) {\n    LayeredIcon layeredIcon = new LayeredIcon(2);\n    layeredIcon.setIcon(icon, 0);\n    Icon plusIcon = new Icon() {\n      public void paintIcon(Component c, Graphics g, int x, int y) {\n        g.setColor(color);\n        g.drawRect(x + 1, y - 4, 8, 8);\n        g.drawLine(x + 3, y, x + 7, y);\n        if (myModel.getSelectedIndex() != idx || myNodePopup == null || !myNodePopup.isVisible()) {\n          g.drawLine(x + 5, y - 2, x + 5, y + 2);\n        }\n      }\n\n      public int getIconWidth() {\n        return 10;\n      }\n\n      public int getIconHeight() {\n        return 8;\n      }\n    };\n    layeredIcon.setIcon(plusIcon, 1, -12, icon.getIconHeight() / 2);\n    return layeredIcon;\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void installDottedBorder(SimpleColoredComponent label) {\n    label.setBorder(new DottedBorder(new Insets(0, 2, 0, 4), UIUtil.getListForeground()));\n  }","id":91073,"modified_method":"private static void installDottedBorder(SimpleColoredComponent label) {\n    label.setBorder(new DottedBorder(new Insets(0, 0, 0, 1), UIUtil.getListForeground()));\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private MouseListener getMouseListener(final Condition<MouseEvent> condition, final Runnable handler, final int index) {\n    return new MouseAdapter() {\n      public void mouseClicked(MouseEvent e) {\n        onClick(e);\n      }\n\n      public void mousePressed(MouseEvent e) {\n        onClick(e);\n      }\n\n      public void mouseReleased(MouseEvent e) {\n        onClick(e);\n      }\n\n      private void onClick(MouseEvent e) {\n        if (condition.value(e)) {\n          clearBorder();\n          myModel.setSelectedIndex(index);\n          paintBorder();\n          myList.get(myModel.getSelectedIndex()).requestFocusInWindow();\n          handler.run();\n          e.consume();\n        }\n      }\n    };\n  }","id":91074,"modified_method":"private void addMouseListener(final MyCompositeLabel component, final Condition<MouseEvent> condition, final Runnable handler, final int index) {\n    ListenerUtil.addMouseListener(component, new MouseAdapter() {\n      public void mouseClicked(MouseEvent e) {\n        onClick(e);\n      }\n\n      public void mousePressed(MouseEvent e) {\n        onClick(e);\n      }\n\n      public void mouseReleased(MouseEvent e) {\n        onClick(e);\n      }\n\n      private void onClick(MouseEvent e) {\n        if (condition.value(e)) {\n          clearBorder();\n          myModel.setSelectedIndex(index);\n          paintBorder();\n          myList.get(myModel.getSelectedIndex()).requestFocusInWindow();\n          handler.run();\n          e.consume();\n        }\n      }\n    });\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static MyCompositeLabel getDotsLabel() {\n    final MyCompositeLabel dotsLabel = new MyCompositeLabel();\n    dotsLabel.getColoredComponent().setFont(UIUtil.getLabelFont());\n    dotsLabel.getColoredComponent().append(\"...\", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n    dotsLabel.setBackground(UIUtil.getListBackground());\n    return dotsLabel;\n  }","id":91075,"modified_method":"private static MyCompositeLabel getDotsLabel() {\n    return new MyCompositeLabel(null, \"...\", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void immediateUpdateList(boolean update) {\n    if (update) {\n      myFirstIndex = 0;\n      final int selectedIndex1 = -1;\n      myModel.setSelectedIndex(selectedIndex1);\n      myList.clear();\n      for (int index = 0; index < myModel.size(); index++) {\n        final Object object = myModel.get(index);\n        final MyCompositeLabel label = new MyCompositeLabel();\n        label.getLabel().addMouseListener(new MouseAdapter() {\n          public void mouseExited(MouseEvent e) {\n            if (!myModel.hasChildren(object)) return;\n            label.getLabel().setIcon(wrapIcon(object, Color.gray));\n            label.repaint();\n          }\n\n          public void mouseClicked(MouseEvent e) {\n            if (!myModel.hasChildren(object)) return;\n            final int selectedIndex = myModel.indexOf(object);\n            if (myModel.getSelectedIndex() == selectedIndex && myNodePopup != null) {\n              cancelPopup();\n              if (isInsideIcon(e.getPoint(), object)) {\n                label.getLabel().setIcon(wrapIcon(object, Color.black));\n                label.getLabel().repaint();\n              }\n              return;\n            }\n            if (isInsideIcon(e.getPoint(), object)) {\n              ctrlClick(selectedIndex);\n              clearBorder();\n              myModel.setSelectedIndex(selectedIndex);\n              paintBorder();\n              label.getLabel().setIcon(wrapIcon(object, Color.black));\n              label.getLabel().repaint();\n            }\n          }\n        });\n        label.getLabel().addMouseMotionListener(new MouseMotionAdapter() {\n          public void mouseMoved(MouseEvent e) {\n            if (!myModel.hasChildren(object)) return;\n            if (isInsideIcon(e.getPoint(), object)) {\n              label.getLabel().setIcon(wrapIcon(object, Color.black));\n            }\n            else {\n              label.getLabel().setIcon(wrapIcon(object, Color.gray));\n            }\n            label.repaint();\n          }\n        });\n        label.setFont(UIUtil.getLabelFont());\n        label.getLabel().setIcon(wrapIcon(object, Color.gray));\n        label.getColoredComponent().append(myModel.getPresentableText(object, getWindow()), myModel.getTextAttributes(object, false));\n        clearBorder(label.getColoredComponent());\n        label.getLabel().setOpaque(false);\n        label.getColoredComponent().setOpaque(true);\n        label.setBackground(UIUtil.getListBackground());\n        myList.add(label);\n        installActions(index);\n      }\n      paintComponent();\n    }\n  }","id":91076,"modified_method":"private void immediateUpdateList(boolean update) {\n    if (update) {\n      myFirstIndex = 0;\n      final int selectedIndex1 = -1;\n      myModel.setSelectedIndex(selectedIndex1);\n      myList.clear();\n      for (int index = 0; index < myModel.size(); index++) {\n        final int idx = index;\n        final Object object = myModel.get(index);\n        final boolean hasChildren = myModel.hasChildren(object);\n        final Icon icon = NavBarModel.getIcon(object);\n        final MyCompositeLabel label = new MyCompositeLabel(hasChildren ? wrapIcon(icon, idx, Color.gray) : icon,\n                                                            myModel.getPresentableText(object, getWindow()),\n                                                            myModel.getTextAttributes(object, false));\n        ListenerUtil.addMouseListener(label, new MouseAdapter() {\n          public void mouseExited(MouseEvent e) {\n            if (!hasChildren) return;\n            label.getLabel().setIcon(wrapIcon(icon, idx, Color.gray));\n          }\n\n          public void mouseClicked(MouseEvent e) {\n            if (hasChildren) {\n              if (isInsideIcon(e.getPoint(), object)) {\n                label.getLabel().setIcon(wrapIcon(icon, idx, Color.black));\n              }\n              if (myModel.getSelectedIndex() == idx && myNodePopup != null) {\n                cancelPopup();\n                return;\n              }\n              ctrlClick(idx);\n            }\n            clearBorder();\n            myModel.setSelectedIndex(idx);\n            paintBorder();\n          }\n        });\n        ListenerUtil.addMouseMotionListener(label, new MouseMotionAdapter() {\n          public void mouseMoved(MouseEvent e) {\n            if (!hasChildren) return;\n            if (isInsideIcon(e.getPoint(), object)) {\n              label.getLabel().setIcon(wrapIcon(icon, idx, Color.black));\n            }\n            else {\n              label.getLabel().setIcon(wrapIcon(icon, idx, Color.gray));\n            }\n          }\n        });\n        myList.add(label);\n        installActions(index);\n      }\n      paintComponent();\n    }\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void installActions(final int index) {\n    final SimpleColoredComponent label = myList.get(index).getColoredComponent();\n    label.addMouseListener(getMouseListener(new Condition<MouseEvent>() {\n      public boolean value(final MouseEvent e) {\n        return !e.isConsumed() && !e.isPopupTrigger() && e.getClickCount() == 2;\n      }\n    }, new Runnable() {\n      public void run() {\n        doubleClick(index);\n      }\n    }, index));\n\n    label.addMouseListener(getMouseListener(new Condition<MouseEvent>() {\n      public boolean value(final MouseEvent e) {\n        // You cannot distinguish between 3rd mouse button released with Meta down or not. See SunBug: 4029159\n        if (e.getID() != MouseEvent.MOUSE_PRESSED && SystemInfo.isMac) return false;\n\n        final int ex = e.getModifiersEx();\n        return !e.isConsumed() && !e.isPopupTrigger() &&\n               (ex & (SystemInfo.isMac ? InputEvent.META_DOWN_MASK : InputEvent.CTRL_DOWN_MASK)) != 0;\n      }\n    }, new Runnable() {\n      public void run() {\n        ctrlClick(index);\n      }\n    }, index));\n\n    label.addMouseListener(getMouseListener(new Condition<MouseEvent>() {\n      public boolean value(final MouseEvent e) {\n        return !e.isConsumed() && e.isPopupTrigger();\n      }\n    }, new Runnable() {\n      public void run() {\n        rightClick(index);\n      }\n    }, index));\n\n\n    label.addMouseListener(getMouseListener(new Condition<MouseEvent>() {\n      public boolean value(final MouseEvent e) {\n        return !e.isConsumed() && e.getClickCount() == 1 && !e.isPopupTrigger();\n      }\n    }, new Runnable() {\n      public void run() {\n        //just select\n        requestFocusInWindow();\n        cancelPopup();\n      }\n    }, index));\n  }","id":91077,"modified_method":"private void installActions(final int index) {\n    final MyCompositeLabel component = myList.get(index);\n    addMouseListener(component, new Condition<MouseEvent>() {\n      public boolean value(final MouseEvent e) {\n        return !e.isConsumed() && !e.isPopupTrigger() && e.getClickCount() == 2;\n      }\n    }, new Runnable() {\n      public void run() {\n        doubleClick(index);\n      }\n    }, index);\n\n    addMouseListener(component, new Condition<MouseEvent>() {\n      public boolean value(final MouseEvent e) {\n        // You cannot distinguish between 3rd mouse button released with Meta down or not. See SunBug: 4029159\n        if (e.getID() != MouseEvent.MOUSE_PRESSED && SystemInfo.isMac) return false;\n\n        final int ex = e.getModifiersEx();\n        return !e.isConsumed() && !e.isPopupTrigger() &&\n               (ex & (SystemInfo.isMac ? InputEvent.META_DOWN_MASK : InputEvent.CTRL_DOWN_MASK)) != 0;\n      }\n    }, new Runnable() {\n      public void run() {\n        ctrlClick(index);\n      }\n    }, index);\n\n    addMouseListener(component, new Condition<MouseEvent>() {\n      public boolean value(final MouseEvent e) {\n        return !e.isConsumed() && e.isPopupTrigger();\n      }\n    }, new Runnable() {\n      public void run() {\n        rightClick(index);\n      }\n    }, index);\n  }","commit_id":"7b6f7a6f8b52384bd915972d43bae757e318b29e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public JComponent createCenterPanel() {\n    JPanel optionsPanel = new JPanel();\n    optionsPanel.setLayout(new GridBagLayout());\n\n    GridBagConstraints gbConstraints = new GridBagConstraints();\n    gbConstraints.weightx = 1;\n    gbConstraints.weighty = 1;\n    gbConstraints.fill = GridBagConstraints.BOTH;\n    gbConstraints.gridwidth = GridBagConstraints.REMAINDER;\n\n    JPanel topOptionsPanel = new JPanel();\n    topOptionsPanel.setLayout(new GridLayout(1, 2, UIUtil.DEFAULT_HGAP, 0));\n    topOptionsPanel.add(createFindOptionsPanel());\n    optionsPanel.add(topOptionsPanel, gbConstraints);\n    \n    JPanel resultsOptionPanel = null;\n    \n    if (myModel.isMultipleFiles()) {\n      optionsPanel.add(createGlobalScopePanel(), gbConstraints);\n      gbConstraints.weightx = 1;\n      gbConstraints.weighty = 1;\n      gbConstraints.fill = GridBagConstraints.HORIZONTAL;\n\n      gbConstraints.gridwidth = GridBagConstraints.REMAINDER;\n      optionsPanel.add(createFilterPanel(),gbConstraints);\n\n      myCbToSkipResultsWhenOneUsage = createCheckbox(FindSettings.getInstance().isSkipResultsWithOneUsage(), FindBundle.message(\"find.options.skip.results.tab.with.one.occurrence.checkbox\"));\n      resultsOptionPanel = createResultsOptionPanel(optionsPanel, gbConstraints);\n      resultsOptionPanel.add(myCbToSkipResultsWhenOneUsage);\n\n      myCbToSkipResultsWhenOneUsage.setVisible(!myModel.isReplaceState());\n\n      if (haveResultsPreview()) {\n        final JBTable table = new JBTable() {\n          @Override\n          public Dimension getPreferredSize() {\n            return new Dimension(myInputComboBox.getWidth(), super.getPreferredSize().height);\n          }\n        };\n        table.setShowColumns(false);\n        table.setShowGrid(false);\n        table.setIntercellSpacing(JBUI.emptySize());\n        new NavigateToSourceListener().installOn(table);\n\n        Splitter previewSplitter = new Splitter(true, 0.5f, 0.1f, 0.9f);\n        myUsagePreviewPanel = new UsagePreviewPanel(myProject, new UsageViewPresentation(), true);\n        myUsagePreviewPanel.setBorder(IdeBorderFactory.createBorder());\n        registerNavigateToSourceShortcutOnComponent(table, myUsagePreviewPanel);\n        myResultsPreviewTable = table;\n        new TableSpeedSearch(table, new Convertor<Object, String>() {\n          @Override\n          public String convert(Object o) {\n            return ((UsageInfo2UsageAdapter)o).getFile().getName();\n          }\n        });\n        myResultsPreviewTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n          @Override\n          public void valueChanged(ListSelectionEvent e) {\n            if (e.getValueIsAdjusting()) return;\n            int index = myResultsPreviewTable.getSelectionModel().getLeadSelectionIndex();\n            if (index != -1) {\n              UsageInfo usageInfo = ((UsageInfo2UsageAdapter)myResultsPreviewTable.getModel().getValueAt(index, 0)).getUsageInfo();\n              myUsagePreviewPanel.updateLayout(Collections.singletonList(usageInfo));\n            }\n            else {\n              myUsagePreviewPanel.updateLayout(null);\n            }\n          }\n        });\n        mySearchRescheduleOnCancellationsAlarm = new Alarm();\n        previewSplitter.setFirstComponent(new JBScrollPane(myResultsPreviewTable));\n        previewSplitter.setSecondComponent(myUsagePreviewPanel.createComponent());\n        myPreviewSplitter = previewSplitter;\n      }\n    }\n    else {\n      JPanel leftOptionsPanel = new JPanel();\n      leftOptionsPanel.setLayout(new GridLayout(3, 1, 0, 4));\n\n      leftOptionsPanel.add(createDirectionPanel());\n      leftOptionsPanel.add(createOriginPanel());\n      leftOptionsPanel.add(createScopePanel());\n      topOptionsPanel.add(leftOptionsPanel);\n    }\n\n    if (myModel.isOpenInNewTabVisible()){\n      myCbToOpenInNewTab = new JCheckBox(FindBundle.message(\"find.open.in.new.tab.checkbox\"));\n      myCbToOpenInNewTab.setFocusable(false);\n      myCbToOpenInNewTab.setSelected(myModel.isOpenInNewTab());\n      myCbToOpenInNewTab.setEnabled(myModel.isOpenInNewTabEnabled());\n\n      if (resultsOptionPanel == null) resultsOptionPanel = createResultsOptionPanel(optionsPanel, gbConstraints);\n      resultsOptionPanel.add(myCbToOpenInNewTab);\n    }\n\n    if (myPreviewSplitter != null) {\n      TabbedPane pane = new JBTabsPaneImpl(myProject, SwingConstants.TOP, myDisposable);\n      pane.insertTab(\"Options\", null, optionsPanel, null, 0);\n      pane.insertTab(PREVIEW_TITLE, null, myPreviewSplitter, null, RESULTS_PREVIEW_TAB_INDEX);\n      myContent = pane;\n      final AnAction anAction = new DumbAwareAction() {\n        @Override\n        public void actionPerformed(AnActionEvent e) {\n          int selectedIndex = myContent.getSelectedIndex();\n          myContent.setSelectedIndex(1 - selectedIndex);\n        }\n      };\n\n      final ShortcutSet shortcutSet = ActionManager.getInstance().getAction(IdeActions.ACTION_SWITCHER).getShortcutSet();\n\n      anAction.registerCustomShortcutSet(shortcutSet, getRootPane(), myDisposable);\n\n      if (myPreviewResultsTabWasSelected) myContent.setSelectedIndex(RESULTS_PREVIEW_TAB_INDEX);\n\n      return pane.getComponent();\n    }\n\n    return optionsPanel;\n  }","id":91078,"modified_method":"@Override\n  public JComponent createCenterPanel() {\n    JPanel optionsPanel = new JPanel();\n    optionsPanel.setLayout(new GridBagLayout());\n\n    GridBagConstraints gbConstraints = new GridBagConstraints();\n    gbConstraints.weightx = 1;\n    gbConstraints.weighty = 1;\n    gbConstraints.fill = GridBagConstraints.BOTH;\n    gbConstraints.gridwidth = GridBagConstraints.REMAINDER;\n\n    JPanel topOptionsPanel = new JPanel();\n    topOptionsPanel.setLayout(new GridLayout(1, 2, UIUtil.DEFAULT_HGAP, 0));\n    topOptionsPanel.add(createFindOptionsPanel());\n    optionsPanel.add(topOptionsPanel, gbConstraints);\n    \n    JPanel resultsOptionPanel = null;\n    \n    if (myModel.isMultipleFiles()) {\n      optionsPanel.add(createGlobalScopePanel(), gbConstraints);\n      gbConstraints.weightx = 1;\n      gbConstraints.weighty = 1;\n      gbConstraints.fill = GridBagConstraints.HORIZONTAL;\n\n      gbConstraints.gridwidth = GridBagConstraints.REMAINDER;\n      optionsPanel.add(createFilterPanel(),gbConstraints);\n\n      myCbToSkipResultsWhenOneUsage = createCheckbox(FindSettings.getInstance().isSkipResultsWithOneUsage(), FindBundle.message(\"find.options.skip.results.tab.with.one.occurrence.checkbox\"));\n      resultsOptionPanel = createResultsOptionPanel(optionsPanel, gbConstraints);\n      resultsOptionPanel.add(myCbToSkipResultsWhenOneUsage);\n\n      myCbToSkipResultsWhenOneUsage.setVisible(!myModel.isReplaceState());\n\n      if (haveResultsPreview()) {\n        final JBTable table = new JBTable() {\n          @Override\n          public Dimension getPreferredSize() {\n            return new Dimension(myInputComboBox.getWidth(), super.getPreferredSize().height);\n          }\n        };\n        table.setShowColumns(false);\n        table.setShowGrid(false);\n        table.setIntercellSpacing(JBUI.emptySize());\n        new NavigateToSourceListener().installOn(table);\n\n        Splitter previewSplitter = new Splitter(true, 0.5f, 0.1f, 0.9f);\n        myUsagePreviewPanel = new UsagePreviewPanel(myProject, new UsageViewPresentation(), true);\n        myUsagePreviewPanel.setBorder(IdeBorderFactory.createBorder());\n        registerNavigateToSourceShortcutOnComponent(table, myUsagePreviewPanel);\n        myResultsPreviewTable = table;\n        new TableSpeedSearch(table, new Convertor<Object, String>() {\n          @Override\n          public String convert(Object o) {\n            return ((UsageInfo2UsageAdapter)o).getFile().getName();\n          }\n        });\n        myResultsPreviewTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n          @Override\n          public void valueChanged(ListSelectionEvent e) {\n            if (e.getValueIsAdjusting()) return;\n            int index = myResultsPreviewTable.getSelectionModel().getLeadSelectionIndex();\n            if (index != -1) {\n              UsageInfo usageInfo = ((UsageInfo2UsageAdapter)myResultsPreviewTable.getModel().getValueAt(index, 0)).getUsageInfo();\n              myUsagePreviewPanel.updateLayout(Collections.singletonList(usageInfo));\n              VirtualFile file = usageInfo.getVirtualFile();\n              myUsagePreviewPanel.setBorder(IdeBorderFactory.createTitledBorder(file != null ? file.getPath() : \"\", false));\n            }\n            else {\n              myUsagePreviewPanel.updateLayout(null);\n              myUsagePreviewPanel.setBorder(IdeBorderFactory.createBorder());\n            }\n          }\n        });\n        mySearchRescheduleOnCancellationsAlarm = new Alarm();\n        previewSplitter.setFirstComponent(new JBScrollPane(myResultsPreviewTable));\n        previewSplitter.setSecondComponent(myUsagePreviewPanel.createComponent());\n        myPreviewSplitter = previewSplitter;\n      }\n    }\n    else {\n      JPanel leftOptionsPanel = new JPanel();\n      leftOptionsPanel.setLayout(new GridLayout(3, 1, 0, 4));\n\n      leftOptionsPanel.add(createDirectionPanel());\n      leftOptionsPanel.add(createOriginPanel());\n      leftOptionsPanel.add(createScopePanel());\n      topOptionsPanel.add(leftOptionsPanel);\n    }\n\n    if (myModel.isOpenInNewTabVisible()){\n      myCbToOpenInNewTab = new JCheckBox(FindBundle.message(\"find.open.in.new.tab.checkbox\"));\n      myCbToOpenInNewTab.setFocusable(false);\n      myCbToOpenInNewTab.setSelected(myModel.isOpenInNewTab());\n      myCbToOpenInNewTab.setEnabled(myModel.isOpenInNewTabEnabled());\n\n      if (resultsOptionPanel == null) resultsOptionPanel = createResultsOptionPanel(optionsPanel, gbConstraints);\n      resultsOptionPanel.add(myCbToOpenInNewTab);\n    }\n\n    if (myPreviewSplitter != null) {\n      TabbedPane pane = new JBTabsPaneImpl(myProject, SwingConstants.TOP, myDisposable);\n      pane.insertTab(\"Options\", null, optionsPanel, null, 0);\n      pane.insertTab(PREVIEW_TITLE, null, myPreviewSplitter, null, RESULTS_PREVIEW_TAB_INDEX);\n      myContent = pane;\n      final AnAction anAction = new DumbAwareAction() {\n        @Override\n        public void actionPerformed(AnActionEvent e) {\n          int selectedIndex = myContent.getSelectedIndex();\n          myContent.setSelectedIndex(1 - selectedIndex);\n        }\n      };\n\n      final ShortcutSet shortcutSet = ActionManager.getInstance().getAction(IdeActions.ACTION_SWITCHER).getShortcutSet();\n\n      anAction.registerCustomShortcutSet(shortcutSet, getRootPane(), myDisposable);\n\n      if (myPreviewResultsTabWasSelected) myContent.setSelectedIndex(RESULTS_PREVIEW_TAB_INDEX);\n\n      return pane.getComponent();\n    }\n\n    return optionsPanel;\n  }","commit_id":"191e01e166780cc42e9d3dd26b3da371d38bda1a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initCombobox(@NotNull final ComboBox comboBox) {\n    comboBox.setEditable(true);\n    comboBox.setMaximumRowCount(8);\n\n    comboBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        validateFindButton();\n      }\n    });\n\n    final Component editorComponent = comboBox.getEditor().getEditorComponent();\n\n    if (editorComponent instanceof EditorTextField) {\n      final EditorTextField etf = (EditorTextField) editorComponent;\n\n      DocumentAdapter listener = new DocumentAdapter() {\n        @Override\n        public void documentChanged(final DocumentEvent e) {\n          handleComboBoxValueChanged(comboBox);\n        }\n      };\n      etf.addDocumentListener(listener);\n      myComboBoxListeners.put(etf, listener);\n    }\n    else {\n      if (editorComponent instanceof JTextComponent) {\n        final javax.swing.text.Document document = ((JTextComponent)editorComponent).getDocument();\n        final com.intellij.ui.DocumentAdapter documentAdapter = new com.intellij.ui.DocumentAdapter() {\n          @Override\n          protected void textChanged(javax.swing.event.DocumentEvent e) {\n            handleAnyComboBoxValueChanged(comboBox);\n          }\n        };\n        document.addDocumentListener(documentAdapter);\n        Disposer.register(myDisposable, new Disposable() {\n          @Override\n          public void dispose() {\n            document.removeDocumentListener(documentAdapter);\n          }\n        });\n      } else {\n        assert false;\n      }\n    }\n\n    if (!myModel.isReplaceState()) {\n      makeResultsPreviewActionOverride(\n        comboBox,\n        KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0),\n        \"choosePrevious\",\n        () -> {\n          int row = myResultsPreviewTable.getSelectedRow();\n          if (row > 0) myResultsPreviewTable.setRowSelectionInterval(row - 1, row - 1);\n          TableUtil.scrollSelectionToVisible(myResultsPreviewTable);\n        }\n      );\n\n      makeResultsPreviewActionOverride(\n        comboBox,\n        KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0),\n        \"chooseNext\",\n        () -> {\n          int row = myResultsPreviewTable.getSelectedRow();\n          if (row >= -1 && row + 1 < myResultsPreviewTable.getRowCount()) {\n            myResultsPreviewTable.setRowSelectionInterval(row + 1, row + 1);\n            TableUtil.scrollSelectionToVisible(myResultsPreviewTable);\n          }\n        }\n      );\n\n      new AnAction() {\n        @Override\n        public void actionPerformed(AnActionEvent e) {\n          if (isResultsPreviewTabActive()) {\n            navigateToSelectedUsage(myResultsPreviewTable);\n          }\n        }\n      }.registerCustomShortcutSet(CommonShortcuts.getEditSource(), comboBox, myDisposable);\n    }\n  }","id":91079,"modified_method":"private void initCombobox(@NotNull final ComboBox comboBox) {\n    comboBox.setEditable(true);\n    comboBox.setMaximumRowCount(8);\n\n    comboBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        validateFindButton();\n      }\n    });\n\n    final Component editorComponent = comboBox.getEditor().getEditorComponent();\n\n    if (editorComponent instanceof EditorTextField) {\n      final EditorTextField etf = (EditorTextField) editorComponent;\n\n      DocumentAdapter listener = new DocumentAdapter() {\n        @Override\n        public void documentChanged(final DocumentEvent e) {\n          handleComboBoxValueChanged(comboBox);\n        }\n      };\n      etf.addDocumentListener(listener);\n      myComboBoxListeners.put(etf, listener);\n    }\n    else {\n      if (editorComponent instanceof JTextComponent) {\n        final javax.swing.text.Document document = ((JTextComponent)editorComponent).getDocument();\n        final com.intellij.ui.DocumentAdapter documentAdapter = new com.intellij.ui.DocumentAdapter() {\n          @Override\n          protected void textChanged(javax.swing.event.DocumentEvent e) {\n            handleAnyComboBoxValueChanged(comboBox);\n          }\n        };\n        document.addDocumentListener(documentAdapter);\n        Disposer.register(myDisposable, new Disposable() {\n          @Override\n          public void dispose() {\n            document.removeDocumentListener(documentAdapter);\n          }\n        });\n      } else {\n        assert false;\n      }\n    }\n\n    if (!myModel.isReplaceState()) {\n      makeResultsPreviewActionOverride(\n        comboBox,\n        KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0),\n        \"choosePrevious\",\n        () -> {\n          int row = myResultsPreviewTable.getSelectedRow();\n          if (row > 0) myResultsPreviewTable.setRowSelectionInterval(row - 1, row - 1);\n          TableUtil.scrollSelectionToVisible(myResultsPreviewTable);\n        }\n      );\n\n      makeResultsPreviewActionOverride(\n        comboBox,\n        KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0),\n        \"chooseNext\",\n        () -> {\n          int row = myResultsPreviewTable.getSelectedRow();\n          if (row >= -1 && row + 1 < myResultsPreviewTable.getRowCount()) {\n            myResultsPreviewTable.setRowSelectionInterval(row + 1, row + 1);\n            TableUtil.scrollSelectionToVisible(myResultsPreviewTable);\n          }\n        }\n      );\n\n      AnAction action = new AnAction() {\n        @Override\n        public void actionPerformed(AnActionEvent e) {\n          if (isResultsPreviewTabActive()) {\n            navigateToSelectedUsage(myResultsPreviewTable);\n          }\n        }\n      };\n      action.registerCustomShortcutSet(CommonShortcuts.getEditSource(), comboBox, myDisposable);\n      action.registerCustomShortcutSet(CommonShortcuts.ENTER, comboBox, myDisposable);\n    }\n  }","commit_id":"191e01e166780cc42e9d3dd26b3da371d38bda1a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DebuggerEditorImpl(Project project, PsiElement context, String recentsId) {\n    myProject = project;\n    myContext = context;\n    myRecentsId = recentsId;\n  }","id":91080,"modified_method":"public DebuggerEditorImpl(Project project, PsiElement context, String recentsId) {\n    myProject = project;\n    myContext = context;\n    myRecentsId = recentsId;\n    PsiManager.getInstance(project).addPsiTreeChangeListener(myPsiListener);\n  }","commit_id":"3b62ad14b31cd0c59ec22041dab05df3a6e0adc0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void dispose() {\n    PsiManager.getInstance(myProject).removePsiTreeChangeListener(myPsiListener);\n    DebuggerManagerEx.getInstanceEx(myProject).getContextManager().removeListener(myContextListener);\n    myEvaluationPanel.dispose();\n    super.dispose();\n  }","id":91081,"modified_method":"protected void dispose() {\n    for (Runnable runnable : myDisposeRunnables) {\n      runnable.run();\n    }\n    myDisposeRunnables.clear();\n    myEditor.dispose();\n    DebuggerManagerEx.getInstanceEx(myProject).getContextManager().removeListener(myContextListener);\n    myEvaluationPanel.dispose();\n    super.dispose();\n  }","commit_id":"3b62ad14b31cd0c59ec22041dab05df3a6e0adc0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public EvaluationDialog(Project project, TextWithImports text) {\n    super(project, true);\n    myProject = project;\n    setModal(false);\n    setCancelButtonText(\"Close\");\n    setOKButtonText(\"Evaluate\");\n\n    myEditor   = createEditor();\n    myEvaluationPanel = new MyEvaluationPanel(myProject);\n\n    setDebuggerContext(getDebuggerContext());\n    initDialogData(text);\n\n    myContextListener = new DebuggerContextListener() {\n      public void changeEvent(DebuggerContextImpl newContext, int event) {\n        boolean close = true;\n        for (Iterator iterator = DebuggerManagerEx.getInstanceEx(myProject).getSessions().iterator(); iterator.hasNext();) {\n          DebuggerSession session = (DebuggerSession) iterator.next();\n          if(!session.isStopped()) {\n            close = false;\n            break;\n          }\n        }\n\n        if(close) {\n          close(CANCEL_EXIT_CODE);\n        } else {\n          setDebuggerContext(newContext);\n        }\n      }\n    };\n    DebuggerManagerEx.getInstanceEx(myProject).getContextManager().addListener(myContextListener);\n\n    setHorizontalStretch(1f);\n    setVerticalStretch(1f);\n\n    PsiManager.getInstance(myProject).addPsiTreeChangeListener(myPsiListener);\n  }","id":91082,"modified_method":"public EvaluationDialog(Project project, TextWithImports text) {\n    super(project, true);\n    myProject = project;\n    setModal(false);\n    setCancelButtonText(\"Close\");\n    setOKButtonText(\"Evaluate\");\n\n    myEditor   = createEditor();\n    myEvaluationPanel = new MyEvaluationPanel(myProject);\n\n    setDebuggerContext(getDebuggerContext());\n    initDialogData(text);\n\n    myContextListener = new DebuggerContextListener() {\n      public void changeEvent(DebuggerContextImpl newContext, int event) {\n        boolean close = true;\n        for (Iterator iterator = DebuggerManagerEx.getInstanceEx(myProject).getSessions().iterator(); iterator.hasNext();) {\n          DebuggerSession session = (DebuggerSession) iterator.next();\n          if(!session.isStopped()) {\n            close = false;\n            break;\n          }\n        }\n\n        if(close) {\n          close(CANCEL_EXIT_CODE);\n        }\n        else {\n          setDebuggerContext(newContext);\n        }\n      }\n    };\n    DebuggerManagerEx.getInstanceEx(myProject).getContextManager().addListener(myContextListener);\n\n    setHorizontalStretch(1f);\n    setVerticalStretch(1f);\n  }","commit_id":"3b62ad14b31cd0c59ec22041dab05df3a6e0adc0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ExpressionEvaluationDialog(Project project, TextWithImports defaultExpression) {\n    super(project, makeOnLine(defaultExpression));\n    setTitle(\"Expression Evaluation\");\n\n    myWatchViewPlace.setLayout(new BorderLayout());\n    myWatchViewPlace.add(getEvaluationPanel());\n    myExpressionComboPlace.setLayout(new BorderLayout());\n    myExpressionComboPlace.add(getExpressionCombo());\n\n    KeyStroke expressionStroke = KeyStroke.getKeyStroke(KeyEvent.VK_E, KeyEvent.ALT_MASK);\n    KeyStroke resultStroke = KeyStroke.getKeyStroke(KeyEvent.VK_R, KeyEvent.ALT_MASK);\n\n\n    new AnAction() {\n      public void actionPerformed(AnActionEvent e) {\n        getExpressionCombo().requestFocus();\n      }\n    }.registerCustomShortcutSet(new CustomShortcutSet(expressionStroke), getRootPane());\n\n    new AnAction() {\n      public void actionPerformed(AnActionEvent e) {\n        getEvaluationPanel().getWatchTree().requestFocus();\n      }\n    }.registerCustomShortcutSet(new CustomShortcutSet(resultStroke), getRootPane());\n\n    this.init();\n  }","id":91083,"modified_method":"public ExpressionEvaluationDialog(Project project, TextWithImports defaultExpression) {\n    super(project, makeOnLine(defaultExpression));\n    setTitle(\"Expression Evaluation\");\n\n    final KeyStroke expressionStroke = KeyStroke.getKeyStroke(KeyEvent.VK_E, KeyEvent.ALT_MASK);\n    final KeyStroke resultStroke = KeyStroke.getKeyStroke(KeyEvent.VK_R, KeyEvent.ALT_MASK);\n\n    final JRootPane rootPane = getRootPane();\n\n    final AnAction anAction = new AnAction() {\n      public void actionPerformed(AnActionEvent e) {\n        getExpressionCombo().requestFocus();\n      }\n    };\n    anAction.registerCustomShortcutSet(new CustomShortcutSet(expressionStroke), rootPane);\n    addDisposeRunnable(new Runnable() {\n      public void run() {\n        anAction.unregisterCustomShortcutSet(rootPane);\n      }\n    });\n\n    final AnAction anAction2 = new AnAction() {\n      public void actionPerformed(AnActionEvent e) {\n        getEvaluationPanel().getWatchTree().requestFocus();\n      }\n    };\n    anAction2.registerCustomShortcutSet(new CustomShortcutSet(resultStroke), rootPane);\n    addDisposeRunnable(new Runnable() {\n      public void run() {\n        anAction2.unregisterCustomShortcutSet(rootPane);\n      }\n    });\n\n    this.init();\n  }","commit_id":"3b62ad14b31cd0c59ec22041dab05df3a6e0adc0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createCenterPanel() {\n    return myPanel;\n  }","id":91084,"modified_method":"protected JComponent createCenterPanel() {\n    JPanel panel = new JPanel(new GridBagLayout());\n    final JLabel expressionLabel = new JLabel(\"Expression:\");\n    expressionLabel.setDisplayedMnemonic('E');\n    panel.add(expressionLabel, new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(5, 0, 0, 0), 0, 0));\n    panel.add(getExpressionCombo(), new GridBagConstraints(1, 0, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(5, 0, 0, 0), 0, 0));\n\n    final JLabel resultLabel = new JLabel(\"Result:\");\n    resultLabel.setDisplayedMnemonic('R');\n    panel.add(resultLabel, new GridBagConstraints(0, 1, 2, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(5, 0, 0, 0), 0, 0));\n    panel.add(getEvaluationPanel(), new GridBagConstraints(0, 2, 2, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(5, 0, 0, 0), 0, 0));\n\n    return panel;\n  }","commit_id":"3b62ad14b31cd0c59ec22041dab05df3a6e0adc0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Action[] createActions() {\n    return new Action[] { getOKAction(), getCancelAction(), mySwitchAction} ;\n  }","id":91085,"modified_method":"protected Action[] createActions() {\n    return new Action[] { getOKAction(), getCancelAction(), new SwitchAction()} ;\n  }","commit_id":"3b62ad14b31cd0c59ec22041dab05df3a6e0adc0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateSwitchButton(Document document) {\n    PsiDocumentManager.getInstance(getProject()).commitDocument(document);\n    PsiFile psiFile = PsiDocumentManager.getInstance(getProject()).getPsiFile(document);\n    PsiElement[] children = psiFile.getChildren();\n    int nonWhite = 0;\n    for (int i = 0; i < children.length; i++) {\n      PsiElement child = children[i];\n      if(!(child instanceof PsiWhiteSpace)) {\n        nonWhite++;\n        if(nonWhite > 1) {\n          mySwitchAction.setEnabled(false);\n          return;\n        }\n      }\n    }\n\n    mySwitchAction.setEnabled(true);\n  }","id":91086,"modified_method":"private void updateSwitchButton(Document document) {\n    PsiDocumentManager.getInstance(getProject()).commitDocument(document);\n    PsiFile psiFile = PsiDocumentManager.getInstance(getProject()).getPsiFile(document);\n    PsiElement[] children = psiFile.getChildren();\n    int nonWhite = 0;\n    for (PsiElement child : children) {\n      if (!(child instanceof PsiWhiteSpace)) {\n        nonWhite++;\n        if (nonWhite > 1) {\n          mySwitchAction.setEnabled(false);\n          return;\n        }\n      }\n    }\n\n    mySwitchAction.setEnabled(true);\n  }","commit_id":"3b62ad14b31cd0c59ec22041dab05df3a6e0adc0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Object[] updateGroup(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong userId = PortalUtil.getUserId(actionRequest);\n\n\t\tlong liveGroupId = ParamUtil.getLong(actionRequest, \"liveGroupId\");\n\n\t\tlong parentGroupId = ParamUtil.getLong(\n\t\t\tactionRequest, \"parentGroupSearchContainerPrimaryKeys\",\n\t\t\tGroupConstants.DEFAULT_PARENT_GROUP_ID);\n\t\tString name = null;\n\t\tString description = null;\n\t\tint type = 0;\n\t\tString friendlyURL = null;\n\t\tboolean active = false;\n\t\tboolean manualMembership = true;\n\n\t\tint membershipRestriction =\n\t\t\tGroupConstants.DEFAULT_MEMBERSHIP_RESTRICTION;\n\n\t\tboolean actionRequestMembershipRestriction = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"membershipRestriction\");\n\n\t\tif (actionRequestMembershipRestriction &&\n\t\t\t(parentGroupId != GroupConstants.DEFAULT_PARENT_GROUP_ID)) {\n\n\t\t\tmembershipRestriction =\n\t\t\t\tGroupConstants.MEMBERSHIP_RESTRICTION_TO_PARENT_SITE_MEMBERS;\n\t\t}\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tGroup.class.getName(), actionRequest);\n\n\t\tGroup liveGroup = null;\n\t\tString oldFriendlyURL = null;\n\t\tString oldStagingFriendlyURL = null;\n\n\t\tif (liveGroupId <= 0) {\n\n\t\t\t// Add group\n\n\t\t\tname = ParamUtil.getString(actionRequest, \"name\");\n\t\t\tdescription = ParamUtil.getString(actionRequest, \"description\");\n\t\t\ttype = ParamUtil.getInteger(actionRequest, \"type\");\n\t\t\tfriendlyURL = ParamUtil.getString(actionRequest, \"friendlyURL\");\n\t\t\tactive = ParamUtil.getBoolean(actionRequest, \"active\");\n\t\t\tmanualMembership = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"manualMembership\");\n\n\t\t\tliveGroup = GroupServiceUtil.addGroup(\n\t\t\t\tparentGroupId, GroupConstants.DEFAULT_LIVE_GROUP_ID, name,\n\t\t\t\tdescription, type, manualMembership, membershipRestriction,\n\t\t\t\tfriendlyURL, true, active, serviceContext);\n\n\t\t\tLiveUsers.joinGroup(\n\t\t\t\tthemeDisplay.getCompanyId(), liveGroup.getGroupId(), userId);\n\t\t}\n\t\telse {\n\n\t\t\t// Update group\n\n\t\t\tliveGroup = GroupLocalServiceUtil.getGroup(liveGroupId);\n\n\t\t\toldFriendlyURL = liveGroup.getFriendlyURL();\n\n\t\t\tname = ParamUtil.getString(\n\t\t\t\tactionRequest, \"name\", liveGroup.getName());\n\t\t\tdescription = ParamUtil.getString(\n\t\t\t\tactionRequest, \"description\", liveGroup.getDescription());\n\t\t\ttype = ParamUtil.getInteger(\n\t\t\t\tactionRequest, \"type\", liveGroup.getType());\n\t\t\tfriendlyURL = ParamUtil.getString(\n\t\t\t\tactionRequest, \"friendlyURL\", liveGroup.getFriendlyURL());\n\t\t\tactive = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"active\", liveGroup.getActive());\n\t\t\tmanualMembership = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"manualMembership\",\n\t\t\t\tliveGroup.isManualMembership());\n\n\t\t\tliveGroup = GroupServiceUtil.updateGroup(\n\t\t\t\tliveGroupId, parentGroupId, name, description, type,\n\t\t\t\tmanualMembership, membershipRestriction, friendlyURL, active,\n\t\t\t\tserviceContext);\n\n\t\t\tif (type == GroupConstants.TYPE_SITE_OPEN) {\n\t\t\t\tList<MembershipRequest> membershipRequests =\n\t\t\t\t\tMembershipRequestLocalServiceUtil.search(\n\t\t\t\t\t\tliveGroupId, MembershipRequestConstants.STATUS_PENDING,\n\t\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\t\t\tfor (MembershipRequest membershipRequest : membershipRequests) {\n\t\t\t\t\tMembershipRequestServiceUtil.updateStatus(\n\t\t\t\t\t\tmembershipRequest.getMembershipRequestId(),\n\t\t\t\t\t\tthemeDisplay.translate(\n\t\t\t\t\t\t\t\"your-membership-has-been-approved\"),\n\t\t\t\t\t\tMembershipRequestConstants.STATUS_APPROVED,\n\t\t\t\t\t\tserviceContext);\n\n\t\t\t\t\tLiveUsers.joinGroup(\n\t\t\t\t\t\tthemeDisplay.getCompanyId(),\n\t\t\t\t\t\tmembershipRequest.getGroupId(),\n\t\t\t\t\t\tnew long[] {membershipRequest.getUserId()});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Settings\n\n\t\tUnicodeProperties typeSettingsProperties =\n\t\t\tliveGroup.getTypeSettingsProperties();\n\n\t\tString customJspServletContextName = ParamUtil.getString(\n\t\t\tactionRequest, \"customJspServletContextName\",\n\t\t\ttypeSettingsProperties.getProperty(\"customJspServletContextName\"));\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"customJspServletContextName\", customJspServletContextName);\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"defaultSiteRoleIds\",\n\t\t\tListUtil.toString(\n\t\t\t\tgetRoles(actionRequest), Role.ROLE_ID_ACCESSOR,\n\t\t\t\tStringPool.COMMA));\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"defaultTeamIds\",\n\t\t\tListUtil.toString(\n\t\t\t\tgetTeams(actionRequest), Team.TEAM_ID_ACCESSOR,\n\t\t\t\tStringPool.COMMA));\n\n\t\tString[] analyticsTypes = PrefsPropsUtil.getStringArray(\n\t\t\tthemeDisplay.getCompanyId(), PropsKeys.ADMIN_ANALYTICS_TYPES,\n\t\t\tStringPool.NEW_LINE);\n\n\t\tfor (String analyticsType : analyticsTypes) {\n\t\t\tif (StringUtil.equalsIgnoreCase(analyticsType, \"google\")) {\n\t\t\t\tString googleAnalyticsId = ParamUtil.getString(\n\t\t\t\t\tactionRequest, \"googleAnalyticsId\",\n\t\t\t\t\ttypeSettingsProperties.getProperty(\"googleAnalyticsId\"));\n\n\t\t\t\ttypeSettingsProperties.setProperty(\n\t\t\t\t\t\"googleAnalyticsId\", googleAnalyticsId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString analyticsScript = ParamUtil.getString(\n\t\t\t\t\tactionRequest, Sites.ANALYTICS_PREFIX + analyticsType,\n\t\t\t\t\ttypeSettingsProperties.getProperty(analyticsType));\n\n\t\t\t\ttypeSettingsProperties.setProperty(\n\t\t\t\t\tSites.ANALYTICS_PREFIX + analyticsType, analyticsScript);\n\t\t\t}\n\t\t}\n\n\t\tString publicRobots = ParamUtil.getString(\n\t\t\tactionRequest, \"publicRobots\",\n\t\t\tliveGroup.getTypeSettingsProperty(\"false-robots.txt\"));\n\t\tString privateRobots = ParamUtil.getString(\n\t\t\tactionRequest, \"privateRobots\",\n\t\t\tliveGroup.getTypeSettingsProperty(\"true-robots.txt\"));\n\n\t\ttypeSettingsProperties.setProperty(\"false-robots.txt\", publicRobots);\n\t\ttypeSettingsProperties.setProperty(\"true-robots.txt\", privateRobots);\n\n\t\tboolean trashEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"trashEnabled\",\n\t\t\tGetterUtil.getBoolean(\n\t\t\t\ttypeSettingsProperties.getProperty(\"trashEnabled\"), true));\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"trashEnabled\", String.valueOf(trashEnabled));\n\n\t\tint trashEntriesMaxAgeCompany = PrefsPropsUtil.getInteger(\n\t\t\tthemeDisplay.getCompanyId(), PropsKeys.TRASH_ENTRIES_MAX_AGE);\n\n\t\tdouble trashEntriesMaxAgeGroup = ParamUtil.getDouble(\n\t\t\tactionRequest, \"trashEntriesMaxAge\");\n\n\t\tif (trashEntriesMaxAgeGroup > 0) {\n\t\t\ttrashEntriesMaxAgeGroup *= 1440;\n\t\t}\n\t\telse {\n\t\t\ttrashEntriesMaxAgeGroup = GetterUtil.getInteger(\n\t\t\t\ttypeSettingsProperties.getProperty(\"trashEntriesMaxAge\"),\n\t\t\t\ttrashEntriesMaxAgeCompany);\n\t\t}\n\n\t\tif (trashEntriesMaxAgeGroup != trashEntriesMaxAgeCompany) {\n\t\t\ttypeSettingsProperties.setProperty(\n\t\t\t\t\"trashEntriesMaxAge\",\n\t\t\t\tString.valueOf(GetterUtil.getInteger(trashEntriesMaxAgeGroup)));\n\t\t}\n\t\telse {\n\t\t\ttypeSettingsProperties.remove(\"trashEntriesMaxAge\");\n\t\t}\n\n\t\tint contentSharingWithChildrenEnabled = ParamUtil.getInteger(\n\t\t\tactionRequest, \"contentSharingWithChildrenEnabled\",\n\t\t\tGetterUtil.getInteger(\n\t\t\t\ttypeSettingsProperties.getProperty(\n\t\t\t\t\t\"contentSharingWithChildrenEnabled\"),\n\t\t\t\tSites.CONTENT_SHARING_WITH_CHILDREN_DEFAULT_VALUE));\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"contentSharingWithChildrenEnabled\",\n\t\t\tString.valueOf(contentSharingWithChildrenEnabled));\n\n\t\tUnicodeProperties formTypeSettingsProperties =\n\t\t\tPropertiesParamUtil.getProperties(\n\t\t\t\tactionRequest, \"TypeSettingsProperties--\");\n\n\t\ttypeSettingsProperties.putAll(formTypeSettingsProperties);\n\n\t\t// Virtual hosts\n\n\t\tLayoutSet publicLayoutSet = liveGroup.getPublicLayoutSet();\n\n\t\tString publicVirtualHost = ParamUtil.getString(\n\t\t\tactionRequest, \"publicVirtualHost\",\n\t\t\tpublicLayoutSet.getVirtualHostname());\n\n\t\tLayoutSetServiceUtil.updateVirtualHost(\n\t\t\tliveGroup.getGroupId(), false, publicVirtualHost);\n\n\t\tLayoutSet privateLayoutSet = liveGroup.getPrivateLayoutSet();\n\n\t\tString privateVirtualHost = ParamUtil.getString(\n\t\t\tactionRequest, \"privateVirtualHost\",\n\t\t\tprivateLayoutSet.getVirtualHostname());\n\n\t\tLayoutSetServiceUtil.updateVirtualHost(\n\t\t\tliveGroup.getGroupId(), true, privateVirtualHost);\n\n\t\t// Staging\n\n\t\tif (liveGroup.hasStagingGroup()) {\n\t\t\tGroup stagingGroup = liveGroup.getStagingGroup();\n\n\t\t\toldStagingFriendlyURL = stagingGroup.getFriendlyURL();\n\n\t\t\tfriendlyURL = ParamUtil.getString(\n\t\t\t\tactionRequest, \"stagingFriendlyURL\",\n\t\t\t\tstagingGroup.getFriendlyURL());\n\n\t\t\tGroupServiceUtil.updateFriendlyURL(\n\t\t\t\tstagingGroup.getGroupId(), friendlyURL);\n\n\t\t\tLayoutSet stagingPublicLayoutSet =\n\t\t\t\tstagingGroup.getPublicLayoutSet();\n\n\t\t\tpublicVirtualHost = ParamUtil.getString(\n\t\t\t\tactionRequest, \"stagingPublicVirtualHost\",\n\t\t\t\tstagingPublicLayoutSet.getVirtualHostname());\n\n\t\t\tLayoutSetServiceUtil.updateVirtualHost(\n\t\t\t\tstagingGroup.getGroupId(), false, publicVirtualHost);\n\n\t\t\tLayoutSet stagingPrivateLayoutSet =\n\t\t\t\tstagingGroup.getPrivateLayoutSet();\n\n\t\t\tprivateVirtualHost = ParamUtil.getString(\n\t\t\t\tactionRequest, \"stagingPrivateVirtualHost\",\n\t\t\t\tstagingPrivateLayoutSet.getVirtualHostname());\n\n\t\t\tLayoutSetServiceUtil.updateVirtualHost(\n\t\t\t\tstagingGroup.getGroupId(), true, privateVirtualHost);\n\t\t}\n\n\t\tliveGroup = GroupServiceUtil.updateGroup(\n\t\t\tliveGroup.getGroupId(), typeSettingsProperties.toString());\n\n\t\t// Layout set prototypes\n\n\t\tif (!liveGroup.isStaged()) {\n\t\t\tlong privateLayoutSetPrototypeId = ParamUtil.getLong(\n\t\t\t\tactionRequest, \"privateLayoutSetPrototypeId\");\n\t\t\tlong publicLayoutSetPrototypeId = ParamUtil.getLong(\n\t\t\t\tactionRequest, \"publicLayoutSetPrototypeId\");\n\n\t\t\tboolean privateLayoutSetPrototypeLinkEnabled = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"privateLayoutSetPrototypeLinkEnabled\",\n\t\t\t\tprivateLayoutSet.isLayoutSetPrototypeLinkEnabled());\n\t\t\tboolean publicLayoutSetPrototypeLinkEnabled = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"publicLayoutSetPrototypeLinkEnabled\",\n\t\t\t\tpublicLayoutSet.isLayoutSetPrototypeLinkEnabled());\n\n\t\t\tif ((privateLayoutSetPrototypeId == 0) &&\n\t\t\t\t(publicLayoutSetPrototypeId == 0) &&\n\t\t\t\t!privateLayoutSetPrototypeLinkEnabled &&\n\t\t\t\t!publicLayoutSetPrototypeLinkEnabled) {\n\n\t\t\t\tlong layoutSetPrototypeId = ParamUtil.getLong(\n\t\t\t\t\tactionRequest, \"layoutSetPrototypeId\");\n\t\t\t\tint layoutSetVisibility = ParamUtil.getInteger(\n\t\t\t\t\tactionRequest, \"layoutSetVisibility\");\n\t\t\t\tboolean layoutSetPrototypeLinkEnabled = ParamUtil.getBoolean(\n\t\t\t\t\tactionRequest, \"layoutSetPrototypeLinkEnabled\",\n\t\t\t\t\t(layoutSetPrototypeId > 0));\n\n\t\t\t\tif (layoutSetVisibility == _LAYOUT_SET_VISIBILITY_PRIVATE) {\n\t\t\t\t\tprivateLayoutSetPrototypeId = layoutSetPrototypeId;\n\n\t\t\t\t\tprivateLayoutSetPrototypeLinkEnabled =\n\t\t\t\t\t\tlayoutSetPrototypeLinkEnabled;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpublicLayoutSetPrototypeId = layoutSetPrototypeId;\n\n\t\t\t\t\tpublicLayoutSetPrototypeLinkEnabled =\n\t\t\t\t\t\tlayoutSetPrototypeLinkEnabled;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSitesUtil.updateLayoutSetPrototypesLinks(\n\t\t\t\tliveGroup, publicLayoutSetPrototypeId,\n\t\t\t\tprivateLayoutSetPrototypeId,\n\t\t\t\tpublicLayoutSetPrototypeLinkEnabled,\n\t\t\t\tprivateLayoutSetPrototypeLinkEnabled);\n\t\t}\n\n\t\t// Staging\n\n\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\tlong refererPlid = GetterUtil.getLong(\n\t\t\tHttpUtil.getParameter(redirect, \"refererPlid\", false));\n\n\t\tif (!privateLayoutSet.isLayoutSetPrototypeLinkActive() &&\n\t\t\t!publicLayoutSet.isLayoutSetPrototypeLinkActive()) {\n\n\t\t\tif ((refererPlid > 0) && liveGroup.hasStagingGroup() &&\n\t\t\t\t(themeDisplay.getScopeGroupId() != liveGroup.getGroupId())) {\n\n\t\t\t\tLayout firstLayout = LayoutLocalServiceUtil.fetchFirstLayout(\n\t\t\t\t\tliveGroup.getGroupId(), false,\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\t\t\tif (firstLayout == null) {\n\t\t\t\t\tfirstLayout = LayoutLocalServiceUtil.fetchFirstLayout(\n\t\t\t\t\t\tliveGroup.getGroupId(), true,\n\t\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\t\t\t\t}\n\n\t\t\t\tif (firstLayout != null) {\n\t\t\t\t\trefererPlid = firstLayout.getPlid();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trefererPlid = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStagingUtil.updateStaging(actionRequest, liveGroup);\n\t\t}\n\n\t\treturn new Object[] {\n\t\t\tliveGroup, oldFriendlyURL, oldStagingFriendlyURL, refererPlid};\n\t}","id":91087,"modified_method":"protected Object[] updateGroup(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong userId = PortalUtil.getUserId(actionRequest);\n\n\t\tlong liveGroupId = ParamUtil.getLong(actionRequest, \"liveGroupId\");\n\n\t\tlong parentGroupId = ParamUtil.getLong(\n\t\t\tactionRequest, \"parentGroupSearchContainerPrimaryKeys\",\n\t\t\tGroupConstants.DEFAULT_PARENT_GROUP_ID);\n\t\tString name = null;\n\t\tString description = null;\n\t\tint type = 0;\n\t\tString friendlyURL = null;\n\t\tboolean active = false;\n\t\tboolean manualMembership = true;\n\n\t\tint membershipRestriction =\n\t\t\tGroupConstants.DEFAULT_MEMBERSHIP_RESTRICTION;\n\n\t\tboolean actionRequestMembershipRestriction = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"membershipRestriction\");\n\n\t\tif (actionRequestMembershipRestriction &&\n\t\t\t(parentGroupId != GroupConstants.DEFAULT_PARENT_GROUP_ID)) {\n\n\t\t\tmembershipRestriction =\n\t\t\t\tGroupConstants.MEMBERSHIP_RESTRICTION_TO_PARENT_SITE_MEMBERS;\n\t\t}\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tGroup.class.getName(), actionRequest);\n\n\t\tGroup liveGroup = null;\n\t\tString oldFriendlyURL = null;\n\t\tString oldStagingFriendlyURL = null;\n\n\t\tif (liveGroupId <= 0) {\n\n\t\t\t// Add group\n\n\t\t\tname = ParamUtil.getString(actionRequest, \"name\");\n\t\t\tdescription = ParamUtil.getString(actionRequest, \"description\");\n\t\t\ttype = ParamUtil.getInteger(actionRequest, \"type\");\n\t\t\tfriendlyURL = ParamUtil.getString(actionRequest, \"friendlyURL\");\n\t\t\tactive = ParamUtil.getBoolean(actionRequest, \"active\");\n\t\t\tmanualMembership = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"manualMembership\");\n\n\t\t\tliveGroup = GroupServiceUtil.addGroup(\n\t\t\t\tparentGroupId, GroupConstants.DEFAULT_LIVE_GROUP_ID, name,\n\t\t\t\tdescription, type, manualMembership, membershipRestriction,\n\t\t\t\tfriendlyURL, true, active, serviceContext);\n\n\t\t\tLiveUsers.joinGroup(\n\t\t\t\tthemeDisplay.getCompanyId(), liveGroup.getGroupId(), userId);\n\t\t}\n\t\telse {\n\n\t\t\t// Update group\n\n\t\t\tliveGroup = GroupLocalServiceUtil.getGroup(liveGroupId);\n\n\t\t\toldFriendlyURL = liveGroup.getFriendlyURL();\n\n\t\t\tname = ParamUtil.getString(\n\t\t\t\tactionRequest, \"name\", liveGroup.getName());\n\t\t\tdescription = ParamUtil.getString(\n\t\t\t\tactionRequest, \"description\", liveGroup.getDescription());\n\t\t\ttype = ParamUtil.getInteger(\n\t\t\t\tactionRequest, \"type\", liveGroup.getType());\n\t\t\tfriendlyURL = ParamUtil.getString(\n\t\t\t\tactionRequest, \"friendlyURL\", liveGroup.getFriendlyURL());\n\t\t\tactive = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"active\", liveGroup.getActive());\n\t\t\tmanualMembership = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"manualMembership\",\n\t\t\t\tliveGroup.isManualMembership());\n\n\t\t\tliveGroup = GroupServiceUtil.updateGroup(\n\t\t\t\tliveGroupId, parentGroupId, name, description, type,\n\t\t\t\tmanualMembership, membershipRestriction, friendlyURL, active,\n\t\t\t\tserviceContext);\n\n\t\t\tif (type == GroupConstants.TYPE_SITE_OPEN) {\n\t\t\t\tList<MembershipRequest> membershipRequests =\n\t\t\t\t\tMembershipRequestLocalServiceUtil.search(\n\t\t\t\t\t\tliveGroupId, MembershipRequestConstants.STATUS_PENDING,\n\t\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\t\t\tfor (MembershipRequest membershipRequest : membershipRequests) {\n\t\t\t\t\tMembershipRequestServiceUtil.updateStatus(\n\t\t\t\t\t\tmembershipRequest.getMembershipRequestId(),\n\t\t\t\t\t\tthemeDisplay.translate(\n\t\t\t\t\t\t\t\"your-membership-has-been-approved\"),\n\t\t\t\t\t\tMembershipRequestConstants.STATUS_APPROVED,\n\t\t\t\t\t\tserviceContext);\n\n\t\t\t\t\tLiveUsers.joinGroup(\n\t\t\t\t\t\tthemeDisplay.getCompanyId(),\n\t\t\t\t\t\tmembershipRequest.getGroupId(),\n\t\t\t\t\t\tnew long[] {membershipRequest.getUserId()});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Settings\n\n\t\tUnicodeProperties typeSettingsProperties =\n\t\t\tliveGroup.getTypeSettingsProperties();\n\n\t\tString customJspServletContextName = ParamUtil.getString(\n\t\t\tactionRequest, \"customJspServletContextName\",\n\t\t\ttypeSettingsProperties.getProperty(\"customJspServletContextName\"));\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"customJspServletContextName\", customJspServletContextName);\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"defaultSiteRoleIds\",\n\t\t\tListUtil.toString(\n\t\t\t\tgetRoles(actionRequest), Role.ROLE_ID_ACCESSOR,\n\t\t\t\tStringPool.COMMA));\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"defaultTeamIds\",\n\t\t\tListUtil.toString(\n\t\t\t\tgetTeams(actionRequest), Team.TEAM_ID_ACCESSOR,\n\t\t\t\tStringPool.COMMA));\n\n\t\tString[] analyticsTypes = PrefsPropsUtil.getStringArray(\n\t\t\tthemeDisplay.getCompanyId(), PropsKeys.ADMIN_ANALYTICS_TYPES,\n\t\t\tStringPool.NEW_LINE);\n\n\t\tfor (String analyticsType : analyticsTypes) {\n\t\t\tif (StringUtil.equalsIgnoreCase(analyticsType, \"google\")) {\n\t\t\t\tString googleAnalyticsId = ParamUtil.getString(\n\t\t\t\t\tactionRequest, \"googleAnalyticsId\",\n\t\t\t\t\ttypeSettingsProperties.getProperty(\"googleAnalyticsId\"));\n\n\t\t\t\ttypeSettingsProperties.setProperty(\n\t\t\t\t\t\"googleAnalyticsId\", googleAnalyticsId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString analyticsScript = ParamUtil.getString(\n\t\t\t\t\tactionRequest, Sites.ANALYTICS_PREFIX + analyticsType,\n\t\t\t\t\ttypeSettingsProperties.getProperty(analyticsType));\n\n\t\t\t\ttypeSettingsProperties.setProperty(\n\t\t\t\t\tSites.ANALYTICS_PREFIX + analyticsType, analyticsScript);\n\t\t\t}\n\t\t}\n\n\t\tString publicRobots = ParamUtil.getString(\n\t\t\tactionRequest, \"publicRobots\",\n\t\t\tliveGroup.getTypeSettingsProperty(\"false-robots.txt\"));\n\t\tString privateRobots = ParamUtil.getString(\n\t\t\tactionRequest, \"privateRobots\",\n\t\t\tliveGroup.getTypeSettingsProperty(\"true-robots.txt\"));\n\n\t\ttypeSettingsProperties.setProperty(\"false-robots.txt\", publicRobots);\n\t\ttypeSettingsProperties.setProperty(\"true-robots.txt\", privateRobots);\n\n\t\tboolean trashEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"trashEnabled\",\n\t\t\tGetterUtil.getBoolean(\n\t\t\t\ttypeSettingsProperties.getProperty(\"trashEnabled\"), true));\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"trashEnabled\", String.valueOf(trashEnabled));\n\n\t\tint trashEntriesMaxAgeCompany = PrefsPropsUtil.getInteger(\n\t\t\tthemeDisplay.getCompanyId(), PropsKeys.TRASH_ENTRIES_MAX_AGE);\n\n\t\tdouble trashEntriesMaxAgeGroup = ParamUtil.getDouble(\n\t\t\tactionRequest, \"trashEntriesMaxAge\");\n\n\t\tif (trashEntriesMaxAgeGroup > 0) {\n\t\t\ttrashEntriesMaxAgeGroup *= 1440;\n\t\t}\n\t\telse {\n\t\t\ttrashEntriesMaxAgeGroup = GetterUtil.getInteger(\n\t\t\t\ttypeSettingsProperties.getProperty(\"trashEntriesMaxAge\"),\n\t\t\t\ttrashEntriesMaxAgeCompany);\n\t\t}\n\n\t\tif (trashEntriesMaxAgeGroup != trashEntriesMaxAgeCompany) {\n\t\t\ttypeSettingsProperties.setProperty(\n\t\t\t\t\"trashEntriesMaxAge\",\n\t\t\t\tString.valueOf(GetterUtil.getInteger(trashEntriesMaxAgeGroup)));\n\t\t}\n\t\telse {\n\t\t\ttypeSettingsProperties.remove(\"trashEntriesMaxAge\");\n\t\t}\n\n\t\tint contentSharingWithChildrenEnabled = ParamUtil.getInteger(\n\t\t\tactionRequest, \"contentSharingWithChildrenEnabled\",\n\t\t\tGetterUtil.getInteger(\n\t\t\t\ttypeSettingsProperties.getProperty(\n\t\t\t\t\t\"contentSharingWithChildrenEnabled\"),\n\t\t\t\tSites.CONTENT_SHARING_WITH_CHILDREN_DEFAULT_VALUE));\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\t\"contentSharingWithChildrenEnabled\",\n\t\t\tString.valueOf(contentSharingWithChildrenEnabled));\n\n\t\tUnicodeProperties formTypeSettingsProperties =\n\t\t\tPropertiesParamUtil.getProperties(\n\t\t\t\tactionRequest, \"TypeSettingsProperties--\");\n\n\t\ttypeSettingsProperties.putAll(formTypeSettingsProperties);\n\n\t\t// Virtual hosts\n\n\t\tLayoutSet publicLayoutSet = liveGroup.getPublicLayoutSet();\n\n\t\tString publicVirtualHost = ParamUtil.getString(\n\t\t\tactionRequest, \"publicVirtualHost\",\n\t\t\tpublicLayoutSet.getVirtualHostname());\n\n\t\tLayoutSetServiceUtil.updateVirtualHost(\n\t\t\tliveGroup.getGroupId(), false, publicVirtualHost);\n\n\t\tLayoutSet privateLayoutSet = liveGroup.getPrivateLayoutSet();\n\n\t\tString privateVirtualHost = ParamUtil.getString(\n\t\t\tactionRequest, \"privateVirtualHost\",\n\t\t\tprivateLayoutSet.getVirtualHostname());\n\n\t\tLayoutSetServiceUtil.updateVirtualHost(\n\t\t\tliveGroup.getGroupId(), true, privateVirtualHost);\n\n\t\t// Staging\n\n\t\tif (liveGroup.hasStagingGroup()) {\n\t\t\tGroup stagingGroup = liveGroup.getStagingGroup();\n\n\t\t\toldStagingFriendlyURL = stagingGroup.getFriendlyURL();\n\n\t\t\tfriendlyURL = ParamUtil.getString(\n\t\t\t\tactionRequest, \"stagingFriendlyURL\",\n\t\t\t\tstagingGroup.getFriendlyURL());\n\n\t\t\tGroupServiceUtil.updateFriendlyURL(\n\t\t\t\tstagingGroup.getGroupId(), friendlyURL);\n\n\t\t\tLayoutSet stagingPublicLayoutSet =\n\t\t\t\tstagingGroup.getPublicLayoutSet();\n\n\t\t\tpublicVirtualHost = ParamUtil.getString(\n\t\t\t\tactionRequest, \"stagingPublicVirtualHost\",\n\t\t\t\tstagingPublicLayoutSet.getVirtualHostname());\n\n\t\t\tLayoutSetServiceUtil.updateVirtualHost(\n\t\t\t\tstagingGroup.getGroupId(), false, publicVirtualHost);\n\n\t\t\tLayoutSet stagingPrivateLayoutSet =\n\t\t\t\tstagingGroup.getPrivateLayoutSet();\n\n\t\t\tprivateVirtualHost = ParamUtil.getString(\n\t\t\t\tactionRequest, \"stagingPrivateVirtualHost\",\n\t\t\t\tstagingPrivateLayoutSet.getVirtualHostname());\n\n\t\t\tLayoutSetServiceUtil.updateVirtualHost(\n\t\t\t\tstagingGroup.getGroupId(), true, privateVirtualHost);\n\t\t}\n\n\t\tliveGroup = GroupServiceUtil.updateGroup(\n\t\t\tliveGroup.getGroupId(), typeSettingsProperties.toString());\n\n\t\t// Layout set prototypes\n\n\t\tlong privateLayoutSetPrototypeId = ParamUtil.getLong(\n\t\t\tactionRequest, \"privateLayoutSetPrototypeId\");\n\t\tlong publicLayoutSetPrototypeId = ParamUtil.getLong(\n\t\t\tactionRequest, \"publicLayoutSetPrototypeId\");\n\n\t\tboolean privateLayoutSetPrototypeLinkEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"privateLayoutSetPrototypeLinkEnabled\",\n\t\t\tprivateLayoutSet.isLayoutSetPrototypeLinkEnabled());\n\t\tboolean publicLayoutSetPrototypeLinkEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"publicLayoutSetPrototypeLinkEnabled\",\n\t\t\tpublicLayoutSet.isLayoutSetPrototypeLinkEnabled());\n\n\t\tif ((privateLayoutSetPrototypeId == 0) &&\n\t\t\t(publicLayoutSetPrototypeId == 0) &&\n\t\t\t!privateLayoutSetPrototypeLinkEnabled &&\n\t\t\t!publicLayoutSetPrototypeLinkEnabled) {\n\n\t\t\tlong layoutSetPrototypeId = ParamUtil.getLong(\n\t\t\t\tactionRequest, \"layoutSetPrototypeId\");\n\t\t\tint layoutSetVisibility = ParamUtil.getInteger(\n\t\t\t\tactionRequest, \"layoutSetVisibility\");\n\t\t\tboolean layoutSetPrototypeLinkEnabled = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"layoutSetPrototypeLinkEnabled\",\n\t\t\t\t(layoutSetPrototypeId > 0));\n\n\t\t\tif (layoutSetVisibility == _LAYOUT_SET_VISIBILITY_PRIVATE) {\n\t\t\t\tprivateLayoutSetPrototypeId = layoutSetPrototypeId;\n\n\t\t\t\tprivateLayoutSetPrototypeLinkEnabled =\n\t\t\t\t\tlayoutSetPrototypeLinkEnabled;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpublicLayoutSetPrototypeId = layoutSetPrototypeId;\n\n\t\t\t\tpublicLayoutSetPrototypeLinkEnabled =\n\t\t\t\t\tlayoutSetPrototypeLinkEnabled;\n\t\t\t}\n\t\t}\n\n\t\tif (!liveGroup.isStaged() || liveGroup.isStagedRemotely()) {\n\t\t\tSitesUtil.updateLayoutSetPrototypesLinks(\n\t\t\t\tliveGroup, publicLayoutSetPrototypeId,\n\t\t\t\tprivateLayoutSetPrototypeId,\n\t\t\t\tpublicLayoutSetPrototypeLinkEnabled,\n\t\t\t\tprivateLayoutSetPrototypeLinkEnabled);\n\t\t}\n\t\telse {\n\t\t\tSitesUtil.updateLayoutSetPrototypesLinks(\n\t\t\t\tliveGroup.getStagingGroup(), publicLayoutSetPrototypeId,\n\t\t\t\tprivateLayoutSetPrototypeId,\n\t\t\t\tpublicLayoutSetPrototypeLinkEnabled,\n\t\t\t\tprivateLayoutSetPrototypeLinkEnabled);\n\t\t}\n\n\t\t// Staging\n\n\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\tlong refererPlid = GetterUtil.getLong(\n\t\t\tHttpUtil.getParameter(redirect, \"refererPlid\", false));\n\n\t\tif (!privateLayoutSet.isLayoutSetPrototypeLinkActive() &&\n\t\t\t!publicLayoutSet.isLayoutSetPrototypeLinkActive()) {\n\n\t\t\tif ((refererPlid > 0) && liveGroup.hasStagingGroup() &&\n\t\t\t\t(themeDisplay.getScopeGroupId() != liveGroup.getGroupId())) {\n\n\t\t\t\tLayout firstLayout = LayoutLocalServiceUtil.fetchFirstLayout(\n\t\t\t\t\tliveGroup.getGroupId(), false,\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\t\t\tif (firstLayout == null) {\n\t\t\t\t\tfirstLayout = LayoutLocalServiceUtil.fetchFirstLayout(\n\t\t\t\t\t\tliveGroup.getGroupId(), true,\n\t\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\t\t\t\t}\n\n\t\t\t\tif (firstLayout != null) {\n\t\t\t\t\trefererPlid = firstLayout.getPlid();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trefererPlid = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStagingUtil.updateStaging(actionRequest, liveGroup);\n\t\t}\n\n\t\treturn new Object[] {\n\t\t\tliveGroup, oldFriendlyURL, oldStagingFriendlyURL, refererPlid};\n\t}","commit_id":"4dd2420ba86abc9c213e6bcbd0589a3d6cdc00a4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Object[] updateUser(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tUser user = PortalUtil.getSelectedUser(actionRequest);\n\n\t\tContact contact = user.getContact();\n\n\t\tString oldPassword = AdminUtil.getUpdateUserPassword(\n\t\t\tactionRequest, user.getUserId());\n\t\tString newPassword1 = actionRequest.getParameter(\"password1\");\n\t\tString newPassword2 = actionRequest.getParameter(\"password2\");\n\t\tboolean passwordReset = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"passwordReset\");\n\n\t\tString reminderQueryQuestion = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"reminderQueryQuestion\");\n\n\t\tif (reminderQueryQuestion.equals(UsersAdmin.CUSTOM_QUESTION)) {\n\t\t\treminderQueryQuestion = BeanParamUtil.getStringSilent(\n\t\t\t\tuser, actionRequest, \"reminderQueryCustomQuestion\");\n\t\t}\n\n\t\tString reminderQueryAnswer = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"reminderQueryAnswer\");\n\t\tString oldScreenName = user.getScreenName();\n\t\tString screenName = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"screenName\");\n\t\tString oldEmailAddress = user.getEmailAddress();\n\t\tString emailAddress = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"emailAddress\");\n\t\tlong facebookId = user.getFacebookId();\n\t\tString openId = BeanParamUtil.getString(user, actionRequest, \"openId\");\n\t\tboolean deleteLogo = ParamUtil.getBoolean(actionRequest, \"deleteLogo\");\n\n\t\tbyte[] portraitBytes = null;\n\n\t\tlong fileEntryId = ParamUtil.getLong(actionRequest, \"fileEntryId\");\n\n\t\tif (fileEntryId > 0) {\n\t\t\tFileEntry fileEntry = DLAppLocalServiceUtil.getFileEntry(\n\t\t\t\tfileEntryId);\n\n\t\t\tportraitBytes = FileUtil.getBytes(fileEntry.getContentStream());\n\t\t}\n\n\t\tString languageId = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"languageId\");\n\t\tString timeZoneId = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"timeZoneId\");\n\t\tString greeting = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"greeting\");\n\t\tString firstName = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"firstName\");\n\t\tString middleName = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"middleName\");\n\t\tString lastName = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"lastName\");\n\t\tint prefixId = BeanParamUtil.getInteger(\n\t\t\tcontact, actionRequest, \"prefixId\");\n\t\tint suffixId = BeanParamUtil.getInteger(\n\t\t\tcontact, actionRequest, \"suffixId\");\n\t\tboolean male = BeanParamUtil.getBoolean(\n\t\t\tuser, actionRequest, \"male\", true);\n\n\t\tCalendar birthdayCal = CalendarFactoryUtil.getCalendar();\n\n\t\tbirthdayCal.setTime(contact.getBirthday());\n\n\t\tint birthdayMonth = ParamUtil.getInteger(\n\t\t\tactionRequest, \"birthdayMonth\", birthdayCal.get(Calendar.MONTH));\n\t\tint birthdayDay = ParamUtil.getInteger(\n\t\t\tactionRequest, \"birthdayDay\", birthdayCal.get(Calendar.DATE));\n\t\tint birthdayYear = ParamUtil.getInteger(\n\t\t\tactionRequest, \"birthdayYear\", birthdayCal.get(Calendar.YEAR));\n\t\tString comments = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"comments\");\n\t\tString smsSn = BeanParamUtil.getString(contact, actionRequest, \"smsSn\");\n\t\tString aimSn = BeanParamUtil.getString(contact, actionRequest, \"aimSn\");\n\t\tString facebookSn = BeanParamUtil.getString(\n\t\t\tcontact, actionRequest, \"facebookSn\");\n\t\tString icqSn = BeanParamUtil.getString(contact, actionRequest, \"icqSn\");\n\t\tString jabberSn = BeanParamUtil.getString(\n\t\t\tcontact, actionRequest, \"jabberSn\");\n\t\tString msnSn = BeanParamUtil.getString(contact, actionRequest, \"msnSn\");\n\t\tString mySpaceSn = BeanParamUtil.getString(\n\t\t\tcontact, actionRequest, \"mySpaceSn\");\n\t\tString skypeSn = BeanParamUtil.getString(\n\t\t\tcontact, actionRequest, \"skypeSn\");\n\t\tString twitterSn = BeanParamUtil.getString(\n\t\t\tcontact, actionRequest, \"twitterSn\");\n\t\tString ymSn = BeanParamUtil.getString(contact, actionRequest, \"ymSn\");\n\t\tString jobTitle = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"jobTitle\");\n\t\tlong[] groupIds = getLongArray(\n\t\t\tactionRequest, \"groupsSearchContainerPrimaryKeys\");\n\t\tlong[] organizationIds = getLongArray(\n\t\t\tactionRequest, \"organizationsSearchContainerPrimaryKeys\");\n\t\tlong[] roleIds = getLongArray(\n\t\t\tactionRequest, \"rolesSearchContainerPrimaryKeys\");\n\n\t\tList<UserGroupRole> userGroupRoles = null;\n\n\t\tif ((actionRequest.getParameter(\"groupRolesGroupIds\") != null) ||\n\t\t\t(actionRequest.getParameter(\"groupRolesRoleIds\") != null)) {\n\n\t\t\tuserGroupRoles = UsersAdminUtil.getUserGroupRoles(actionRequest);\n\t\t}\n\n\t\tlong[] userGroupIds = getLongArray(\n\t\t\tactionRequest, \"userGroupsSearchContainerPrimaryKeys\");\n\t\tList<Address> addresses = UsersAdminUtil.getAddresses(\n\t\t\tactionRequest, user.getAddresses());\n\t\tList<EmailAddress> emailAddresses = UsersAdminUtil.getEmailAddresses(\n\t\t\tactionRequest, user.getEmailAddresses());\n\t\tList<Phone> phones = UsersAdminUtil.getPhones(\n\t\t\tactionRequest, user.getPhones());\n\t\tList<Website> websites = UsersAdminUtil.getWebsites(\n\t\t\tactionRequest, user.getWebsites());\n\t\tList<AnnouncementsDelivery> announcementsDeliveries =\n\t\t\tgetAnnouncementsDeliveries(actionRequest, user);\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tUser.class.getName(), actionRequest);\n\n\t\tuser = UserServiceUtil.updateUser(\n\t\t\tuser.getUserId(), oldPassword, newPassword1, newPassword2,\n\t\t\tpasswordReset, reminderQueryQuestion, reminderQueryAnswer,\n\t\t\tscreenName, emailAddress, facebookId, openId, !deleteLogo,\n\t\t\tportraitBytes, languageId, timeZoneId, greeting, comments,\n\t\t\tfirstName, middleName, lastName, prefixId, suffixId, male,\n\t\t\tbirthdayMonth, birthdayDay, birthdayYear, smsSn, aimSn, facebookSn,\n\t\t\ticqSn, jabberSn, msnSn, mySpaceSn, skypeSn, twitterSn, ymSn,\n\t\t\tjobTitle, groupIds, organizationIds, roleIds, userGroupRoles,\n\t\t\tuserGroupIds, addresses, emailAddresses, phones, websites,\n\t\t\tannouncementsDeliveries, serviceContext);\n\n\t\tif (oldScreenName.equals(user.getScreenName())) {\n\t\t\toldScreenName = StringPool.BLANK;\n\t\t}\n\n\t\tboolean updateLanguageId = false;\n\n\t\tif (user.getUserId() == themeDisplay.getUserId()) {\n\n\t\t\t// Reset the locale\n\n\t\t\tHttpServletRequest request = PortalUtil.getHttpServletRequest(\n\t\t\t\tactionRequest);\n\t\t\tHttpServletResponse response = PortalUtil.getHttpServletResponse(\n\t\t\t\tactionResponse);\n\t\t\tHttpSession session = request.getSession();\n\n\t\t\tsession.removeAttribute(Globals.LOCALE_KEY);\n\n\t\t\tLocale locale = LocaleUtil.fromLanguageId(languageId);\n\n\t\t\tLanguageUtil.updateCookie(request, response, locale);\n\n\t\t\t// Clear cached portlet responses\n\n\t\t\tPortletSession portletSession = actionRequest.getPortletSession();\n\n\t\t\tInvokerPortletImpl.clearResponses(portletSession);\n\n\t\t\t// Password\n\n\t\t\tif (PropsValues.SESSION_STORE_PASSWORD &&\n\t\t\t\tValidator.isNotNull(newPassword1)) {\n\n\t\t\t\tportletSession.setAttribute(\n\t\t\t\t\tWebKeys.USER_PASSWORD, newPassword1,\n\t\t\t\t\tPortletSession.APPLICATION_SCOPE);\n\t\t\t}\n\n\t\t\tupdateLanguageId = true;\n\t\t}\n\n\t\tString portletId = serviceContext.getPortletId();\n\n\t\tif (!portletId.equals(PortletKeys.MY_ACCOUNT)) {\n\t\t\tlong publicLayoutSetPrototypeId = ParamUtil.getLong(\n\t\t\t\tactionRequest, \"publicLayoutSetPrototypeId\");\n\t\t\tlong privateLayoutSetPrototypeId = ParamUtil.getLong(\n\t\t\t\tactionRequest, \"privateLayoutSetPrototypeId\");\n\t\t\tboolean publicLayoutSetPrototypeLinkEnabled = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"publicLayoutSetPrototypeLinkEnabled\");\n\t\t\tboolean privateLayoutSetPrototypeLinkEnabled = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"privateLayoutSetPrototypeLinkEnabled\");\n\n\t\t\tSitesUtil.updateLayoutSetPrototypesLinks(\n\t\t\t\tuser.getGroup(), publicLayoutSetPrototypeId,\n\t\t\t\tprivateLayoutSetPrototypeId,\n\t\t\t\tpublicLayoutSetPrototypeLinkEnabled,\n\t\t\t\tprivateLayoutSetPrototypeLinkEnabled);\n\t\t}\n\n\t\tCompany company = PortalUtil.getCompany(actionRequest);\n\n\t\tif (company.isStrangersVerify() &&\n\t\t\t!StringUtil.equalsIgnoreCase(oldEmailAddress, emailAddress)) {\n\n\t\t\tSessionMessages.add(actionRequest, \"verificationEmailSent\");\n\t\t}\n\n\t\treturn new Object[] {user, oldScreenName, updateLanguageId};\n\t}","id":91088,"modified_method":"protected Object[] updateUser(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tUser user = PortalUtil.getSelectedUser(actionRequest);\n\n\t\tContact contact = user.getContact();\n\n\t\tString oldPassword = AdminUtil.getUpdateUserPassword(\n\t\t\tactionRequest, user.getUserId());\n\t\tString newPassword1 = actionRequest.getParameter(\"password1\");\n\t\tString newPassword2 = actionRequest.getParameter(\"password2\");\n\t\tboolean passwordReset = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"passwordReset\");\n\n\t\tString reminderQueryQuestion = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"reminderQueryQuestion\");\n\n\t\tif (reminderQueryQuestion.equals(UsersAdmin.CUSTOM_QUESTION)) {\n\t\t\treminderQueryQuestion = BeanParamUtil.getStringSilent(\n\t\t\t\tuser, actionRequest, \"reminderQueryCustomQuestion\");\n\t\t}\n\n\t\tString reminderQueryAnswer = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"reminderQueryAnswer\");\n\t\tString oldScreenName = user.getScreenName();\n\t\tString screenName = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"screenName\");\n\t\tString oldEmailAddress = user.getEmailAddress();\n\t\tString emailAddress = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"emailAddress\");\n\t\tlong facebookId = user.getFacebookId();\n\t\tString openId = BeanParamUtil.getString(user, actionRequest, \"openId\");\n\t\tboolean deleteLogo = ParamUtil.getBoolean(actionRequest, \"deleteLogo\");\n\n\t\tbyte[] portraitBytes = null;\n\n\t\tlong fileEntryId = ParamUtil.getLong(actionRequest, \"fileEntryId\");\n\n\t\tif (fileEntryId > 0) {\n\t\t\tFileEntry fileEntry = DLAppLocalServiceUtil.getFileEntry(\n\t\t\t\tfileEntryId);\n\n\t\t\tportraitBytes = FileUtil.getBytes(fileEntry.getContentStream());\n\t\t}\n\n\t\tString languageId = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"languageId\");\n\t\tString timeZoneId = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"timeZoneId\");\n\t\tString greeting = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"greeting\");\n\t\tString firstName = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"firstName\");\n\t\tString middleName = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"middleName\");\n\t\tString lastName = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"lastName\");\n\t\tint prefixId = BeanParamUtil.getInteger(\n\t\t\tcontact, actionRequest, \"prefixId\");\n\t\tint suffixId = BeanParamUtil.getInteger(\n\t\t\tcontact, actionRequest, \"suffixId\");\n\t\tboolean male = BeanParamUtil.getBoolean(\n\t\t\tuser, actionRequest, \"male\", true);\n\n\t\tCalendar birthdayCal = CalendarFactoryUtil.getCalendar();\n\n\t\tbirthdayCal.setTime(contact.getBirthday());\n\n\t\tint birthdayMonth = ParamUtil.getInteger(\n\t\t\tactionRequest, \"birthdayMonth\", birthdayCal.get(Calendar.MONTH));\n\t\tint birthdayDay = ParamUtil.getInteger(\n\t\t\tactionRequest, \"birthdayDay\", birthdayCal.get(Calendar.DATE));\n\t\tint birthdayYear = ParamUtil.getInteger(\n\t\t\tactionRequest, \"birthdayYear\", birthdayCal.get(Calendar.YEAR));\n\t\tString comments = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"comments\");\n\t\tString smsSn = BeanParamUtil.getString(contact, actionRequest, \"smsSn\");\n\t\tString aimSn = BeanParamUtil.getString(contact, actionRequest, \"aimSn\");\n\t\tString facebookSn = BeanParamUtil.getString(\n\t\t\tcontact, actionRequest, \"facebookSn\");\n\t\tString icqSn = BeanParamUtil.getString(contact, actionRequest, \"icqSn\");\n\t\tString jabberSn = BeanParamUtil.getString(\n\t\t\tcontact, actionRequest, \"jabberSn\");\n\t\tString msnSn = BeanParamUtil.getString(contact, actionRequest, \"msnSn\");\n\t\tString mySpaceSn = BeanParamUtil.getString(\n\t\t\tcontact, actionRequest, \"mySpaceSn\");\n\t\tString skypeSn = BeanParamUtil.getString(\n\t\t\tcontact, actionRequest, \"skypeSn\");\n\t\tString twitterSn = BeanParamUtil.getString(\n\t\t\tcontact, actionRequest, \"twitterSn\");\n\t\tString ymSn = BeanParamUtil.getString(contact, actionRequest, \"ymSn\");\n\t\tString jobTitle = BeanParamUtil.getString(\n\t\t\tuser, actionRequest, \"jobTitle\");\n\t\tlong[] groupIds = getLongArray(\n\t\t\tactionRequest, \"groupsSearchContainerPrimaryKeys\");\n\t\tlong[] organizationIds = getLongArray(\n\t\t\tactionRequest, \"organizationsSearchContainerPrimaryKeys\");\n\t\tlong[] roleIds = getLongArray(\n\t\t\tactionRequest, \"rolesSearchContainerPrimaryKeys\");\n\n\t\tList<UserGroupRole> userGroupRoles = null;\n\n\t\tif ((actionRequest.getParameter(\"groupRolesGroupIds\") != null) ||\n\t\t\t(actionRequest.getParameter(\"groupRolesRoleIds\") != null)) {\n\n\t\t\tuserGroupRoles = UsersAdminUtil.getUserGroupRoles(actionRequest);\n\t\t}\n\n\t\tlong[] userGroupIds = getLongArray(\n\t\t\tactionRequest, \"userGroupsSearchContainerPrimaryKeys\");\n\t\tList<Address> addresses = UsersAdminUtil.getAddresses(\n\t\t\tactionRequest, user.getAddresses());\n\t\tList<EmailAddress> emailAddresses = UsersAdminUtil.getEmailAddresses(\n\t\t\tactionRequest, user.getEmailAddresses());\n\t\tList<Phone> phones = UsersAdminUtil.getPhones(\n\t\t\tactionRequest, user.getPhones());\n\t\tList<Website> websites = UsersAdminUtil.getWebsites(\n\t\t\tactionRequest, user.getWebsites());\n\t\tList<AnnouncementsDelivery> announcementsDeliveries =\n\t\t\tgetAnnouncementsDeliveries(actionRequest, user);\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tUser.class.getName(), actionRequest);\n\n\t\tuser = UserServiceUtil.updateUser(\n\t\t\tuser.getUserId(), oldPassword, newPassword1, newPassword2,\n\t\t\tpasswordReset, reminderQueryQuestion, reminderQueryAnswer,\n\t\t\tscreenName, emailAddress, facebookId, openId, !deleteLogo,\n\t\t\tportraitBytes, languageId, timeZoneId, greeting, comments,\n\t\t\tfirstName, middleName, lastName, prefixId, suffixId, male,\n\t\t\tbirthdayMonth, birthdayDay, birthdayYear, smsSn, aimSn, facebookSn,\n\t\t\ticqSn, jabberSn, msnSn, mySpaceSn, skypeSn, twitterSn, ymSn,\n\t\t\tjobTitle, groupIds, organizationIds, roleIds, userGroupRoles,\n\t\t\tuserGroupIds, addresses, emailAddresses, phones, websites,\n\t\t\tannouncementsDeliveries, serviceContext);\n\n\t\tif (oldScreenName.equals(user.getScreenName())) {\n\t\t\toldScreenName = StringPool.BLANK;\n\t\t}\n\n\t\tboolean updateLanguageId = false;\n\n\t\tif (user.getUserId() == themeDisplay.getUserId()) {\n\n\t\t\t// Reset the locale\n\n\t\t\tHttpServletRequest request = PortalUtil.getHttpServletRequest(\n\t\t\t\tactionRequest);\n\t\t\tHttpServletResponse response = PortalUtil.getHttpServletResponse(\n\t\t\t\tactionResponse);\n\t\t\tHttpSession session = request.getSession();\n\n\t\t\tsession.removeAttribute(Globals.LOCALE_KEY);\n\n\t\t\tLocale locale = LocaleUtil.fromLanguageId(languageId);\n\n\t\t\tLanguageUtil.updateCookie(request, response, locale);\n\n\t\t\t// Clear cached portlet responses\n\n\t\t\tPortletSession portletSession = actionRequest.getPortletSession();\n\n\t\t\tInvokerPortletImpl.clearResponses(portletSession);\n\n\t\t\t// Password\n\n\t\t\tif (PropsValues.SESSION_STORE_PASSWORD &&\n\t\t\t\tValidator.isNotNull(newPassword1)) {\n\n\t\t\t\tportletSession.setAttribute(\n\t\t\t\t\tWebKeys.USER_PASSWORD, newPassword1,\n\t\t\t\t\tPortletSession.APPLICATION_SCOPE);\n\t\t\t}\n\n\t\t\tupdateLanguageId = true;\n\t\t}\n\n\t\tString portletId = serviceContext.getPortletId();\n\n\t\tif (!portletId.equals(PortletKeys.MY_ACCOUNT)) {\n\t\t\tlong publicLayoutSetPrototypeId = ParamUtil.getLong(\n\t\t\t\tactionRequest, \"publicLayoutSetPrototypeId\");\n\t\t\tlong privateLayoutSetPrototypeId = ParamUtil.getLong(\n\t\t\t\tactionRequest, \"privateLayoutSetPrototypeId\");\n\t\t\tboolean publicLayoutSetPrototypeLinkEnabled = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"publicLayoutSetPrototypeLinkEnabled\");\n\t\t\tboolean privateLayoutSetPrototypeLinkEnabled = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"privateLayoutSetPrototypeLinkEnabled\");\n\n\t\t\tif ((publicLayoutSetPrototypeId > 0) ||\n\t\t\t\t(privateLayoutSetPrototypeId > 0)) {\n\n\t\t\t\tSitesUtil.updateLayoutSetPrototypesLinks(\n\t\t\t\t\tuser.getGroup(), publicLayoutSetPrototypeId,\n\t\t\t\t\tprivateLayoutSetPrototypeId,\n\t\t\t\t\tpublicLayoutSetPrototypeLinkEnabled,\n\t\t\t\t\tprivateLayoutSetPrototypeLinkEnabled);\n\t\t\t}\n\t\t}\n\n\t\tCompany company = PortalUtil.getCompany(actionRequest);\n\n\t\tif (company.isStrangersVerify() &&\n\t\t\t!StringUtil.equalsIgnoreCase(oldEmailAddress, emailAddress)) {\n\n\t\t\tSessionMessages.add(actionRequest, \"verificationEmailSent\");\n\t\t}\n\n\t\treturn new Object[] {user, oldScreenName, updateLanguageId};\n\t}","commit_id":"b6800f3780eb6d8175c71b6211985d8b3960592a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateUserGroup(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tlong userGroupId = ParamUtil.getLong(actionRequest, \"userGroupId\");\n\n\t\tString name = ParamUtil.getString(actionRequest, \"name\");\n\t\tString description = ParamUtil.getString(actionRequest, \"description\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tUserGroup.class.getName(), actionRequest);\n\n\t\tUserGroup userGroup = null;\n\n\t\tif (userGroupId <= 0) {\n\n\t\t\t// Add user group\n\n\t\t\tuserGroup = UserGroupServiceUtil.addUserGroup(\n\t\t\t\tname, description, serviceContext);\n\t\t}\n\t\telse {\n\n\t\t\t// Update user group\n\n\t\t\tuserGroup = UserGroupServiceUtil.updateUserGroup(\n\t\t\t\tuserGroupId, name, description, serviceContext);\n\t\t}\n\n\t\t// Layout set prototypes\n\n\t\tlong publicLayoutSetPrototypeId = ParamUtil.getLong(\n\t\t\tactionRequest, \"publicLayoutSetPrototypeId\");\n\t\tlong privateLayoutSetPrototypeId = ParamUtil.getLong(\n\t\t\tactionRequest, \"privateLayoutSetPrototypeId\");\n\t\tboolean publicLayoutSetPrototypeLinkEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"publicLayoutSetPrototypeLinkEnabled\");\n\t\tboolean privateLayoutSetPrototypeLinkEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"privateLayoutSetPrototypeLinkEnabled\");\n\n\t\tSitesUtil.updateLayoutSetPrototypesLinks(\n\t\t\tuserGroup.getGroup(), publicLayoutSetPrototypeId,\n\t\t\tprivateLayoutSetPrototypeId, publicLayoutSetPrototypeLinkEnabled,\n\t\t\tprivateLayoutSetPrototypeLinkEnabled);\n\t}","id":91089,"modified_method":"protected void updateUserGroup(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tlong userGroupId = ParamUtil.getLong(actionRequest, \"userGroupId\");\n\n\t\tString name = ParamUtil.getString(actionRequest, \"name\");\n\t\tString description = ParamUtil.getString(actionRequest, \"description\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tUserGroup.class.getName(), actionRequest);\n\n\t\tUserGroup userGroup = null;\n\n\t\tif (userGroupId <= 0) {\n\n\t\t\t// Add user group\n\n\t\t\tuserGroup = UserGroupServiceUtil.addUserGroup(\n\t\t\t\tname, description, serviceContext);\n\t\t}\n\t\telse {\n\n\t\t\t// Update user group\n\n\t\t\tuserGroup = UserGroupServiceUtil.updateUserGroup(\n\t\t\t\tuserGroupId, name, description, serviceContext);\n\t\t}\n\n\t\t// Layout set prototypes\n\n\t\tlong publicLayoutSetPrototypeId = ParamUtil.getLong(\n\t\t\tactionRequest, \"publicLayoutSetPrototypeId\");\n\t\tlong privateLayoutSetPrototypeId = ParamUtil.getLong(\n\t\t\tactionRequest, \"privateLayoutSetPrototypeId\");\n\t\tboolean publicLayoutSetPrototypeLinkEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"publicLayoutSetPrototypeLinkEnabled\");\n\t\tboolean privateLayoutSetPrototypeLinkEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"privateLayoutSetPrototypeLinkEnabled\");\n\n\t\tif ((privateLayoutSetPrototypeId > 0) ||\n\t\t\t(publicLayoutSetPrototypeId > 0)) {\n\n\t\t\tSitesUtil.updateLayoutSetPrototypesLinks(\n\t\t\t\tuserGroup.getGroup(), publicLayoutSetPrototypeId,\n\t\t\t\tprivateLayoutSetPrototypeId,\n\t\t\t\tpublicLayoutSetPrototypeLinkEnabled,\n\t\t\t\tprivateLayoutSetPrototypeLinkEnabled);\n\t\t}\n\t}","commit_id":"652664802c089ec75a45c0221306b8713f8d4141","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void setLocalRepositoryPath( Artifact artifact, ArtifactRepository localRepository )\n        throws ArtifactPathFormatException\n    {\n        String artifactPath = localPath( artifact, localRepository );\n\n        artifact.setPath( artifactPath );\n    }","id":91090,"modified_method":"protected String getLocalRepositoryArtifactPath( ArtifactRepository localRepository, Artifact artifact )\n        throws ArtifactPathFormatException\n    {\n        for ( Iterator i = artifactTransformations.iterator(); i.hasNext(); )\n        {\n            ArtifactTransformation transform = (ArtifactTransformation) i.next();\n            // TODO: perform transformation\n        }\n\n        String artifactPath = localRepository.getBasedir() + \"/\" + localRepository.pathOf( artifact );\n        return artifactPath;\n    }","commit_id":"2b853505587610f6bae2c2c1bb9cfa201ed832d4","url":"https://github.com/apache/maven"},{"original_method":"protected String path( Artifact artifact, ArtifactRepository remoteRepository )\n        throws ArtifactPathFormatException\n    {\n        return remoteRepository.pathOf( artifact );\n    }","id":91091,"modified_method":"protected String getRemoteRepositoryArtifactPath( Artifact artifact, ArtifactRepository remoteRepository )\n        throws ArtifactPathFormatException\n    {\n        return remoteRepository.pathOf( artifact );\n    }","commit_id":"2b853505587610f6bae2c2c1bb9cfa201ed832d4","url":"https://github.com/apache/maven"},{"original_method":"public void install( File source, Artifact artifact, ArtifactRepository localRepository )\n        throws ArtifactInstallationException\n    {\n        try\n        {\n            setLocalRepositoryPath( artifact, localRepository );\n\n            if ( !artifact.getFile().getParentFile().exists() )\n            {\n                artifact.getFile().getParentFile().mkdirs();\n            }\n\n            getLogger().info( \"Installing \" + source.getPath() + \" to \" + artifact.getPath() );\n\n            FileUtils.copyFile( source, artifact.getFile() );\n        }\n        catch ( IOException e )\n        {\n            throw new ArtifactInstallationException( \"Error installing artifact: \", e );\n        }\n        catch ( ArtifactPathFormatException e )\n        {\n            throw new ArtifactInstallationException( \"Error installing artifact: \", e );\n        }\n    }","id":91092,"modified_method":"public void install( File source, Artifact artifact, ArtifactRepository localRepository )\n        throws ArtifactInstallationException\n    {\n        try\n        {\n            artifact.setPath( getLocalRepositoryArtifactPath( localRepository, artifact ) );\n\n            if ( !artifact.getFile().getParentFile().exists() )\n            {\n                artifact.getFile().getParentFile().mkdirs();\n            }\n\n            getLogger().info( \"Installing \" + source.getPath() + \" to \" + artifact.getPath() );\n\n            FileUtils.copyFile( source, artifact.getFile() );\n        }\n        catch ( IOException e )\n        {\n            throw new ArtifactInstallationException( \"Error installing artifact: \", e );\n        }\n        catch ( ArtifactPathFormatException e )\n        {\n            throw new ArtifactInstallationException( \"Error installing artifact: \", e );\n        }\n    }","commit_id":"2b853505587610f6bae2c2c1bb9cfa201ed832d4","url":"https://github.com/apache/maven"},{"original_method":"private ArtifactResolutionResult collect( Set artifacts, ArtifactRepository localRepository,\n                                              List remoteRepositories, ArtifactMetadataSource source,\n                                              ArtifactFilter filter )\n        throws TransitiveArtifactResolutionException\n    {\n        ArtifactResolutionResult result = new ArtifactResolutionResult();\n\n        Map resolvedArtifacts = new HashMap();\n\n        List queue = new LinkedList();\n\n        queue.add( artifacts );\n\n        while ( !queue.isEmpty() )\n        {\n            Set currentArtifacts = (Set) queue.remove( 0 );\n\n            for ( Iterator i = currentArtifacts.iterator(); i.hasNext(); )\n            {\n                Artifact newArtifact = (Artifact) i.next();\n\n                String id = newArtifact.getConflictId();\n\n                if ( resolvedArtifacts.containsKey( id ) )\n                {\n                    Artifact knownArtifact = (Artifact) resolvedArtifacts.get( id );\n\n                    String newVersion = newArtifact.getVersion();\n\n                    String knownVersion = knownArtifact.getVersion();\n\n                    if ( !newVersion.equals( knownVersion ) )\n                    {\n                        addConflict( result, knownArtifact, newArtifact );\n                    }\n\n                    // TODO: scope handler\n                    boolean updateScope = false;\n                    if ( Artifact.SCOPE_RUNTIME.equals( newArtifact.getScope() ) &&\n                        Artifact.SCOPE_TEST.equals( knownArtifact.getScope() ) )\n                    {\n                        updateScope = true;\n                    }\n\n                    if ( Artifact.SCOPE_COMPILE.equals( newArtifact.getScope() ) &&\n                        !Artifact.SCOPE_COMPILE.equals( knownArtifact.getScope() ) )\n                    {\n                        updateScope = true;\n                    }\n\n                    if ( updateScope )\n                    {\n                        // TODO: Artifact factory?\n                        // TODO: [jc] Is this a better way to centralize artifact construction here?\n                        Artifact artifact = artifactConstructionSupport.createArtifact( knownArtifact.getGroupId(),\n                                                                                        knownArtifact.getArtifactId(),\n                                                                                        knownVersion,\n                                                                                        newArtifact.getScope(),\n                                                                                        knownArtifact.getType() );\n                        resolvedArtifacts.put( artifact.getConflictId(), artifact );\n                    }\n                }\n                else\n                {\n                    // ----------------------------------------------------------------------\n                    // It's the first time we have encountered this artifact\n                    // ----------------------------------------------------------------------\n\n                    if ( filter != null && !filter.include( newArtifact ) )\n                    {\n                        continue;\n                    }\n\n                    resolvedArtifacts.put( id, newArtifact );\n\n                    Set referencedDependencies = null;\n\n                    try\n                    {\n                        referencedDependencies = source.retrieve( newArtifact, localRepository, remoteRepositories );\n                    }\n                    catch ( ArtifactMetadataRetrievalException e )\n                    {\n                        throw new TransitiveArtifactResolutionException( \"Error retrieving metadata [\" + newArtifact +\n                                                                         \"] : \", e );\n                    }\n\n                    // the pom for given dependency exisit we will add it to the\n                    // queue\n                    queue.add( referencedDependencies );\n                }\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // the dependencies list is keyed by groupId+artifactId+type\n        // so it must be 'rekeyed' to the complete id:\n        // groupId+artifactId+type+version\n        // ----------------------------------------------------------------------\n\n        Map artifactResult = result.getArtifacts();\n\n        for ( Iterator it = resolvedArtifacts.values().iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n\n            try\n            {\n                setLocalRepositoryPath( artifact, localRepository );\n            }\n            catch ( ArtifactPathFormatException e )\n            {\n                throw new TransitiveArtifactResolutionException( \"Error collecting artifact: \", e );\n            }\n\n            artifactResult.put( artifact.getId(), artifact );\n        }\n\n        return result;\n    }","id":91093,"modified_method":"private ArtifactResolutionResult collect( Set artifacts, ArtifactRepository localRepository,\n                                              List remoteRepositories, ArtifactMetadataSource source,\n                                              ArtifactFilter filter )\n        throws TransitiveArtifactResolutionException\n    {\n        ArtifactResolutionResult result = new ArtifactResolutionResult();\n\n        Map resolvedArtifacts = new HashMap();\n\n        List queue = new LinkedList();\n\n        queue.add( artifacts );\n\n        while ( !queue.isEmpty() )\n        {\n            Set currentArtifacts = (Set) queue.remove( 0 );\n\n            for ( Iterator i = currentArtifacts.iterator(); i.hasNext(); )\n            {\n                Artifact newArtifact = (Artifact) i.next();\n\n                String id = newArtifact.getConflictId();\n\n                if ( resolvedArtifacts.containsKey( id ) )\n                {\n                    Artifact knownArtifact = (Artifact) resolvedArtifacts.get( id );\n\n                    String newVersion = newArtifact.getVersion();\n\n                    String knownVersion = knownArtifact.getVersion();\n\n                    if ( !newVersion.equals( knownVersion ) )\n                    {\n                        addConflict( result, knownArtifact, newArtifact );\n                    }\n\n                    // TODO: scope handler\n                    boolean updateScope = false;\n                    if ( Artifact.SCOPE_RUNTIME.equals( newArtifact.getScope() ) &&\n                        Artifact.SCOPE_TEST.equals( knownArtifact.getScope() ) )\n                    {\n                        updateScope = true;\n                    }\n\n                    if ( Artifact.SCOPE_COMPILE.equals( newArtifact.getScope() ) &&\n                        !Artifact.SCOPE_COMPILE.equals( knownArtifact.getScope() ) )\n                    {\n                        updateScope = true;\n                    }\n\n                    if ( updateScope )\n                    {\n                        // TODO: Artifact factory?\n                        // TODO: [jc] Is this a better way to centralize artifact construction here?\n                        Artifact artifact = artifactConstructionSupport.createArtifact( knownArtifact.getGroupId(),\n                                                                                        knownArtifact.getArtifactId(),\n                                                                                        knownVersion,\n                                                                                        newArtifact.getScope(),\n                                                                                        knownArtifact.getType() );\n                        resolvedArtifacts.put( artifact.getConflictId(), artifact );\n                    }\n                }\n                else\n                {\n                    // ----------------------------------------------------------------------\n                    // It's the first time we have encountered this artifact\n                    // ----------------------------------------------------------------------\n\n                    if ( filter != null && !filter.include( newArtifact ) )\n                    {\n                        continue;\n                    }\n\n                    resolvedArtifacts.put( id, newArtifact );\n\n                    Set referencedDependencies = null;\n\n                    try\n                    {\n                        referencedDependencies = source.retrieve( newArtifact, localRepository, remoteRepositories );\n                    }\n                    catch ( ArtifactMetadataRetrievalException e )\n                    {\n                        throw new TransitiveArtifactResolutionException( \"Error retrieving metadata [\" + newArtifact +\n                                                                         \"] : \", e );\n                    }\n\n                    // the pom for given dependency exisit we will add it to the\n                    // queue\n                    queue.add( referencedDependencies );\n                }\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // the dependencies list is keyed by groupId+artifactId+type\n        // so it must be 'rekeyed' to the complete id:\n        // groupId+artifactId+type+version\n        // ----------------------------------------------------------------------\n\n        Map artifactResult = result.getArtifacts();\n\n        for ( Iterator it = resolvedArtifacts.values().iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n\n            try\n            {\n                artifact.setPath( getLocalRepositoryArtifactPath( localRepository, artifact ) );\n            }\n            catch ( ArtifactPathFormatException e )\n            {\n                throw new TransitiveArtifactResolutionException( \"Error collecting artifact: \", e );\n            }\n\n            artifactResult.put( artifact.getId(), artifact );\n        }\n\n        return result;\n    }","commit_id":"2b853505587610f6bae2c2c1bb9cfa201ed832d4","url":"https://github.com/apache/maven"},{"original_method":"public Artifact resolve( Artifact artifact, List remoteRepositories, ArtifactRepository localRepository )\n        throws ArtifactResolutionException\n    {\n        // ----------------------------------------------------------------------\n        // Perform any transformation on the artifacts\n        // ----------------------------------------------------------------------\n\n        // ----------------------------------------------------------------------\n        // Check for the existence of the artifact in the specified local\n        // ArtifactRepository. If it is present then simply return as the\n        // request\n        // for resolution has been satisfied.\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            Logger logger = getLogger();\n            logger.debug( \"Resolving: \" + artifact.getId() + \" from:\\n\" + \"{localRepository: \" + localRepository +\n                          \"}\\n\" + \"{remoteRepositories: \" + remoteRepositories + \"}\" );\n\n            setLocalRepositoryPath( artifact, localRepository );\n\n            if ( artifact.exists() )\n            {\n                return artifact;\n            }\n\n            wagonManager.get( artifact, remoteRepositories, localRepository );\n        }\n        catch ( TransferFailedException e )\n        {\n            throw new ArtifactResolutionException( artifactNotFound( artifact, remoteRepositories ), e );\n        }\n        catch ( ArtifactPathFormatException e )\n        {\n            throw new ArtifactResolutionException( \"Error resolving artifact: \", e );\n        }\n\n        return artifact;\n    }","id":91094,"modified_method":"public Artifact resolve( Artifact artifact, List remoteRepositories, ArtifactRepository localRepository )\n        throws ArtifactResolutionException\n    {\n        // ----------------------------------------------------------------------\n        // Perform any transformation on the artifacts\n        // ----------------------------------------------------------------------\n\n        // ----------------------------------------------------------------------\n        // Check for the existence of the artifact in the specified local\n        // ArtifactRepository. If it is present then simply return as the\n        // request\n        // for resolution has been satisfied.\n        // ----------------------------------------------------------------------\n\n        try\n        {\n            Logger logger = getLogger();\n            logger.debug( \"Resolving: \" + artifact.getId() + \" from:\\n\" + \"{localRepository: \" + localRepository +\n                          \"}\\n\" + \"{remoteRepositories: \" + remoteRepositories + \"}\" );\n\n            artifact.setPath( getLocalRepositoryArtifactPath( localRepository, artifact ) );\n\n            if ( artifact.exists() )\n            {\n                return artifact;\n            }\n\n            wagonManager.get( artifact, remoteRepositories, localRepository );\n        }\n        catch ( TransferFailedException e )\n        {\n            throw new ArtifactResolutionException( artifactNotFound( artifact, remoteRepositories ), e );\n        }\n        catch ( ArtifactPathFormatException e )\n        {\n            throw new ArtifactResolutionException( \"Error resolving artifact: \", e );\n        }\n\n        return artifact;\n    }","commit_id":"2b853505587610f6bae2c2c1bb9cfa201ed832d4","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * @param artifact\n     * @param destination\n     * @throws TransferFailedException\n     * @todo I want to somehow plug artifact validators at such low level.\n     * Simply if artifact was downloaded but it was rejected by\n     * validator(s) the loop should continue. Some of the validators can\n     * be feeded directly using events so number of i/o operation could be\n     * limited. <p/>If we won't plug validation process here the question\n     * is what we can do afterwards? We don't know from which\n     * ArtifactRepository artifact was fetched and where we should\n     * restart. We should be also fetching md5 sums and such from the same\n     * exact directory then artifacts <p/>\n     * @todo probably all exceptions should just be logged and continue\n     * @todo is the exception for warnings logged at debug level correct?\n     */\n    public void get( Artifact artifact, File destination, List repositories )\n        throws TransferFailedException\n    {\n        File temp = null;\n\n        // TODO [BP]: do this handling in Wagon itself\n        temp = new File( destination + \".tmp\" );\n        temp.deleteOnExit();\n\n        // TODO [BP]: The exception handling here needs some work\n        for ( Iterator iter = repositories.iterator(); iter.hasNext(); )\n        {\n            ArtifactRepository repository = (ArtifactRepository) iter.next();\n\n            try\n            {\n                Wagon wagon = getWagon( repository.getProtocol() );\n\n                // ----------------------------------------------------------------------\n                // These can certainly be configurable ... registering listeners\n                // ...\n\n                //ChecksumObserver md5SumObserver = new ChecksumObserver();\n\n                // ----------------------------------------------------------------------\n\n                //wagon.addTransferListener( md5SumObserver );\n\n                if ( downloadMonitor != null )\n                {\n                    wagon.addTransferListener( downloadMonitor );\n                }\n\n                wagon.connect( repository, getProxy( repository.getProtocol() ) );\n\n                String remotePath = path( artifact, repository );\n\n                wagon.get( remotePath, temp );\n\n                // TODO [BP]: put all disconnects in finally\n                wagon.disconnect();\n\n                releaseWagon( wagon );\n\n            }\n            catch ( ResourceDoesNotExistException e )\n            {\n                // This one we will eat when looking through remote repositories\n                // because we want to cycle through them all before squawking.\n\n                continue;\n            }\n            catch ( UnsupportedProtocolException e )\n            {\n                throw new TransferFailedException( \"Unsupported Protocol: \", e );\n            }\n            catch ( ConnectionException e )\n            {\n                throw new TransferFailedException( \"Connection failed: \", e );\n            }\n            catch ( AuthenticationException e )\n            {\n                throw new TransferFailedException( \"Authentication failed: \", e );\n            }\n            catch ( AuthorizationException e )\n            {\n                throw new TransferFailedException( \"Authorization failed: \", e );\n            }\n            catch ( TransferFailedException e )\n            {\n                getLogger().warn( \"Failure getting artifact from repository '\" + repository + \"': \" + e );\n\n                getLogger().debug( \"Stack trace\", e );\n\n                continue;\n            }\n            catch ( Exception e )\n            {\n                throw new TransferFailedException( \"Release of wagon failed: \", e );\n            }\n\n            if ( !destination.getParentFile().exists() )\n            {\n                destination.getParentFile().mkdirs();\n            }\n\n            // The temporary file is named destination + \".tmp\" and is done this\n            // way to ensure\n            // that the temporary file is in the same file system as the\n            // destination because the\n            // File.renameTo operation doesn't really work across file systems.\n            // So we will attempt\n            // to do a File.renameTo for efficiency and atomicity, if this fails\n            // then we will use\n            // a brute force copy and delete the temporary file.\n\n            if ( !temp.renameTo( destination ) )\n            {\n                try\n                {\n                    FileUtils.copyFile( temp, destination );\n\n                    temp.delete();\n                }\n                catch ( IOException e )\n                {\n                    throw new TransferFailedException( \"Error copying temporary file to the final destination: \", e );\n                }\n            }\n\n            return;\n        }\n\n        throw new TransferFailedException( \"Unable to download the artifact from any repository\" );\n    }","id":91095,"modified_method":"/**\n     * @param artifact\n     * @param destination\n     * @throws TransferFailedException\n     * @todo I want to somehow plug artifact validators at such low level.\n     * Simply if artifact was downloaded but it was rejected by\n     * validator(s) the loop should continue. Some of the validators can\n     * be feeded directly using events so number of i/o operation could be\n     * limited. <p/>If we won't plug validation process here the question\n     * is what we can do afterwards? We don't know from which\n     * ArtifactRepository artifact was fetched and where we should\n     * restart. We should be also fetching md5 sums and such from the same\n     * exact directory then artifacts <p/>\n     * @todo probably all exceptions should just be logged and continue\n     * @todo is the exception for warnings logged at debug level correct?\n     */\n    public void get( Artifact artifact, File destination, List repositories )\n        throws TransferFailedException\n    {\n        File temp = null;\n\n        // TODO [BP]: do this handling in Wagon itself\n        temp = new File( destination + \".tmp\" );\n        temp.deleteOnExit();\n\n        // TODO [BP]: The exception handling here needs some work\n        for ( Iterator iter = repositories.iterator(); iter.hasNext(); )\n        {\n            ArtifactRepository repository = (ArtifactRepository) iter.next();\n\n            try\n            {\n                Wagon wagon = getWagon( repository.getProtocol() );\n\n                // ----------------------------------------------------------------------\n                // These can certainly be configurable ... registering listeners\n                // ...\n\n                //ChecksumObserver md5SumObserver = new ChecksumObserver();\n\n                // ----------------------------------------------------------------------\n\n                //wagon.addTransferListener( md5SumObserver );\n\n                if ( downloadMonitor != null )\n                {\n                    wagon.addTransferListener( downloadMonitor );\n                }\n\n                wagon.connect( repository, getProxy( repository.getProtocol() ) );\n\n                String remotePath = getRemoteRepositoryArtifactPath( artifact, repository );\n\n                wagon.get( remotePath, temp );\n\n                // TODO [BP]: put all disconnects in finally\n                wagon.disconnect();\n\n                releaseWagon( wagon );\n\n            }\n            catch ( ResourceDoesNotExistException e )\n            {\n                // This one we will eat when looking through remote repositories\n                // because we want to cycle through them all before squawking.\n\n                continue;\n            }\n            catch ( UnsupportedProtocolException e )\n            {\n                throw new TransferFailedException( \"Unsupported Protocol: \", e );\n            }\n            catch ( ConnectionException e )\n            {\n                throw new TransferFailedException( \"Connection failed: \", e );\n            }\n            catch ( AuthenticationException e )\n            {\n                throw new TransferFailedException( \"Authentication failed: \", e );\n            }\n            catch ( AuthorizationException e )\n            {\n                throw new TransferFailedException( \"Authorization failed: \", e );\n            }\n            catch ( TransferFailedException e )\n            {\n                getLogger().warn( \"Failure getting artifact from repository '\" + repository + \"': \" + e );\n\n                getLogger().debug( \"Stack trace\", e );\n\n                continue;\n            }\n            catch ( Exception e )\n            {\n                throw new TransferFailedException( \"Release of wagon failed: \", e );\n            }\n\n            if ( !destination.getParentFile().exists() )\n            {\n                destination.getParentFile().mkdirs();\n            }\n\n            // The temporary file is named destination + \".tmp\" and is done this\n            // way to ensure\n            // that the temporary file is in the same file system as the\n            // destination because the\n            // File.renameTo operation doesn't really work across file systems.\n            // So we will attempt\n            // to do a File.renameTo for efficiency and atomicity, if this fails\n            // then we will use\n            // a brute force copy and delete the temporary file.\n\n            if ( !temp.renameTo( destination ) )\n            {\n                try\n                {\n                    FileUtils.copyFile( temp, destination );\n\n                    temp.delete();\n                }\n                catch ( IOException e )\n                {\n                    throw new TransferFailedException( \"Error copying temporary file to the final destination: \", e );\n                }\n            }\n\n            return;\n        }\n\n        throw new TransferFailedException( \"Unable to download the artifact from any repository\" );\n    }","commit_id":"2b853505587610f6bae2c2c1bb9cfa201ed832d4","url":"https://github.com/apache/maven"},{"original_method":"public void put( File source, Artifact artifact, ArtifactRepository repository )\n        throws Exception\n    {\n        Wagon wagon = getWagon( repository.getProtocol() );\n\n        wagon.connect( repository, getProxy( repository.getProtocol() ) );\n\n        wagon.put( source, path( artifact, repository ) );\n\n        wagon.disconnect();\n\n        releaseWagon( wagon );\n    }","id":91096,"modified_method":"public void put( File source, Artifact artifact, ArtifactRepository repository )\n        throws Exception\n    {\n        Wagon wagon = getWagon( repository.getProtocol() );\n\n        wagon.connect( repository, getProxy( repository.getProtocol() ) );\n\n        wagon.put( source, getRemoteRepositoryArtifactPath( artifact, repository ) );\n\n        wagon.disconnect();\n\n        releaseWagon( wagon );\n    }","commit_id":"2b853505587610f6bae2c2c1bb9cfa201ed832d4","url":"https://github.com/apache/maven"},{"original_method":"public void init()\n    {\n        // unusual propertires handling, so non-standard endpoint registration\n        registerMuleBeanDefinitionParser(\"endpoint\", new TransportGlobalEndpointDefinitionParser(AxisConnector.AXIS, TransportGlobalEndpointDefinitionParser.META, false, new String[]{}, new String[]{})).addMapping(AxisConnector.USE, USE_MAP).addMapping(AxisConnector.STYLE, STYLE_MAP);\n        registerMuleBeanDefinitionParser(\"inbound-endpoint\", new TransportEndpointDefinitionParser(AxisConnector.AXIS, TransportGlobalEndpointDefinitionParser.META, false, InboundEndpointFactoryBean.class, new String[]{}, new String[]{})).addMapping(AxisConnector.USE, USE_MAP).addMapping(AxisConnector.STYLE, STYLE_MAP);\n        registerMuleBeanDefinitionParser(\"outbound-endpoint\", new TransportEndpointDefinitionParser(AxisConnector.AXIS, TransportGlobalEndpointDefinitionParser.META, false, OutboundEndpointFactoryBean.class, new String[]{}, new String[]{})).addMapping(AxisConnector.USE, USE_MAP).addMapping(AxisConnector.STYLE, STYLE_MAP);\n        registerBeanDefinitionParser(\"connector\", new MuleOrphanDefinitionParser(AxisConnector.class, true));\n        registerBeanDefinitionParser(\"supported-scheme\", new ChildListEntryDefinitionParser(\"supportedSchemes\", \"value\"));\n        registerBeanDefinitionParser(\"soap-method\", new ElementInNestedMapDefinitionParser(PROPERTIES, AxisConnector.SOAP_METHODS, \"method\"));\n        registerBeanDefinitionParser(\"soap-parameter\", new SoapParameterDefinitionParser());\n        registerBeanDefinitionParser(\"soap-return\", new SoapReturnDefinitionParser());\n        registerMuleBeanDefinitionParser(\"soap-service\", new NestedListDefinitionParser(PROPERTIES, SoapConstants.SERVICE_INTERFACES, \"interface\"));\n        registerMuleBeanDefinitionParser(\"options\", new NestedMapWithAttributesDefinitionParser(PROPERTIES, AxisMessageReceiver.AXIS_OPTIONS));\n        registerMuleBeanDefinitionParser(\"option\", new SimplePropertyDefinitionParser());\n        registerMuleBeanDefinitionParser(\"bean-type\",\n                new ParentContextDefinitionParser(\"connector\", new ChildListEntryDefinitionParser(AxisMessageReceiver.BEAN_TYPES, \"interface\"))\n                        .otherwise(new NestedListDefinitionParser(PROPERTIES, AxisMessageReceiver.BEAN_TYPES, \"interface\")));\n    }","id":91097,"modified_method":"public void init()\n    {\n        // unusual propertires handling, so non-standard endpoint registration\n        registerMuleBeanDefinitionParser(\"endpoint\", new TransportGlobalEndpointDefinitionParser(AxisConnector.AXIS, TransportGlobalEndpointDefinitionParser.META, false, new String[]{}, new String[]{})).addMapping(AxisConnector.USE, USE_MAP).addMapping(AxisConnector.STYLE, STYLE_MAP).addAlias(SoapConstants.SOAP_ACTION_PROPERTY, SoapConstants.SOAP_ACTION_PROPERTY_CAPS);\n        registerMuleBeanDefinitionParser(\"inbound-endpoint\", new TransportEndpointDefinitionParser(AxisConnector.AXIS, TransportGlobalEndpointDefinitionParser.META, false, InboundEndpointFactoryBean.class, new String[]{}, new String[]{})).addMapping(AxisConnector.USE, USE_MAP).addMapping(AxisConnector.STYLE, STYLE_MAP).addAlias(SoapConstants.SOAP_ACTION_PROPERTY, SoapConstants.SOAP_ACTION_PROPERTY_CAPS);\n        registerMuleBeanDefinitionParser(\"outbound-endpoint\", new TransportEndpointDefinitionParser(AxisConnector.AXIS, TransportGlobalEndpointDefinitionParser.META, false, OutboundEndpointFactoryBean.class, new String[]{}, new String[]{})).addMapping(AxisConnector.USE, USE_MAP).addMapping(AxisConnector.STYLE, STYLE_MAP).addAlias(SoapConstants.SOAP_ACTION_PROPERTY, SoapConstants.SOAP_ACTION_PROPERTY_CAPS);\n        registerBeanDefinitionParser(\"connector\", new MuleOrphanDefinitionParser(AxisConnector.class, true));\n        registerBeanDefinitionParser(\"supported-scheme\", new ChildListEntryDefinitionParser(\"supportedSchemes\", \"value\"));\n        registerBeanDefinitionParser(\"soap-method\", new ElementInNestedMapDefinitionParser(PROPERTIES, AxisConnector.SOAP_METHODS, \"method\"));\n        registerBeanDefinitionParser(\"soap-parameter\", new SoapParameterDefinitionParser());\n        registerBeanDefinitionParser(\"soap-return\", new SoapReturnDefinitionParser());\n        registerMuleBeanDefinitionParser(\"soap-service\", new NestedListDefinitionParser(PROPERTIES, SoapConstants.SERVICE_INTERFACES, \"interface\"));\n        registerMuleBeanDefinitionParser(\"options\", new NestedMapWithAttributesDefinitionParser(PROPERTIES, AxisMessageReceiver.AXIS_OPTIONS));\n        registerMuleBeanDefinitionParser(\"option\", new SimplePropertyDefinitionParser());\n        registerMuleBeanDefinitionParser(\"bean-type\",\n                new ParentContextDefinitionParser(\"connector\", new ChildListEntryDefinitionParser(AxisMessageReceiver.BEAN_TYPES, \"interface\"))\n                        .otherwise(new NestedListDefinitionParser(PROPERTIES, AxisMessageReceiver.BEAN_TYPES, \"interface\")));\n    }","commit_id":"716363c3f7db61180c6e3f6f1e71465610f35ecb","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n   * Running this class will mount the file system according to\n   * the options passed to this function {@link #parseOptions(String[])}.\n   * The user-space fuse application will stay on the foreground and keep\n   * the file system mounted. The user can unmount the file system by\n   * gracefully killing (SIGINT) the process.\n   */\n  public static void main(String[] args) {\n    sTachyonConf = ClientContext.getConf();\n    final TachyonFuseOptions opts = parseOptions(args);\n    if (opts == null) {\n      System.exit(1);\n    }\n\n    final TachyonFileSystem tfs = TachyonFileSystemFactory.get();\n    final TachyonFuseFs fs = new TachyonFuseFs(sTachyonConf, tfs, opts);\n    final List<String> fuseOpts = opts.getFuseOpts();\n    // Force direct_io in FUSE: writes and reads bypass the kernel page\n    // cache and go directly to tachyon. This avoids extra memory copies\n    // in the write path.\n    fuseOpts.add(\"-odirect_io\");\n\n    try {\n      fs.mount(Paths.get(opts.getMountPoint()), true, opts.isDebug(),\n          fuseOpts.toArray(new String[0]));\n    } finally {\n      fs.umount();\n    }\n  }","id":91098,"modified_method":"/**\n   * Running this class will mount the file system according to\n   * the options passed to this function {@link #parseOptions(String[])}.\n   * The user-space fuse application will stay on the foreground and keep\n   * the file system mounted. The user can unmount the file system by\n   * gracefully killing (SIGINT) the process.\n   */\n  public static void main(String[] args) {\n    sTachyonConf = ClientContext.getConf();\n    final TachyonFuseOptions opts = parseOptions(args);\n    if (opts == null) {\n      System.exit(1);\n    }\n\n    final FileSystem tfs = FileSystem.Factory.get();\n    final TachyonFuseFs fs = new TachyonFuseFs(sTachyonConf, tfs, opts);\n    final List<String> fuseOpts = opts.getFuseOpts();\n    // Force direct_io in FUSE: writes and reads bypass the kernel page\n    // cache and go directly to tachyon. This avoids extra memory copies\n    // in the write path.\n    fuseOpts.add(\"-odirect_io\");\n\n    try {\n      fs.mount(Paths.get(opts.getMountPoint()), true, opts.isDebug(),\n          fuseOpts.toArray(new String[0]));\n    } finally {\n      fs.umount();\n    }\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Convenience internal method to remove files or directories.\n   * @param path The path to remove\n   * @param mustBeFile When true, returns an error when trying to\n   *                   remove a directory\n   * @return 0 on success, a negative value on error\n   */\n  private int rmInternal(String path, boolean mustBeFile) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n\n    try {\n      final TachyonFile tf = mTFS.openIfExists(turi);\n      if (tf == null) {\n        LOG.error(\"File {} does not exist\", turi);\n        return -ErrorCodes.ENOENT();\n      }\n      final FileInfo tfi = mTFS.getInfo(tf);\n      if (mustBeFile && tfi.isFolder) {\n        LOG.error(\"File {} is a directory\", turi);\n        return -ErrorCodes.EISDIR();\n      }\n\n      mTFS.delete(tf);\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","id":91099,"modified_method":"/**\n   * Convenience internal method to remove files or directories.\n   * @param path The path to remove\n   * @param mustBeFile When true, returns an error when trying to\n   *                   remove a directory\n   * @return 0 on success, a negative value on error\n   */\n  private int rmInternal(String path, boolean mustBeFile) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n\n    try {\n      if (!mTFS.exists(turi)) {\n        LOG.error(\"File {} does not exist\", turi);\n        return -ErrorCodes.ENOENT();\n      }\n      final URIStatus status = mTFS.getStatus(turi);\n      if (mustBeFile && status.isFolder()) {\n        LOG.error(\"File {} is a directory\", turi);\n        return -ErrorCodes.EISDIR();\n      }\n\n      mTFS.delete(turi);\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"TachyonFuseFs(TachyonConf conf, TachyonFileSystem tfs,\n      TachyonFuseOptions opts) {\n    super();\n    mTachyonConf = conf;\n    mTFS = tfs;\n    mTachyonMaster = mTachyonConf.get(Constants.MASTER_ADDRESS);\n    mTachyonRootPath = Paths.get(opts.getTachyonRoot());\n    mNextOpenFileId = 0L;\n    mOpenFiles = Maps.newHashMap();\n\n    final int maxCachedPaths = mTachyonConf.getInt(Constants.FUSE_PATHCACHE_SIZE);\n    mPathResolverCache = CacheBuilder.newBuilder()\n        .maximumSize(maxCachedPaths)\n        .build(new PathCacheLoader());\n\n    Preconditions.checkArgument(mTachyonRootPath.isAbsolute(),\n        \"tachyon root path should be absolute\");\n  }","id":91100,"modified_method":"TachyonFuseFs(TachyonConf conf, FileSystem tfs, TachyonFuseOptions opts) {\n    super();\n    mTachyonConf = conf;\n    mTFS = tfs;\n    mTachyonMaster = mTachyonConf.get(Constants.MASTER_ADDRESS);\n    mTachyonRootPath = Paths.get(opts.getTachyonRoot());\n    mNextOpenFileId = 0L;\n    mOpenFiles = Maps.newHashMap();\n\n    final int maxCachedPaths = mTachyonConf.getInt(Constants.FUSE_PATHCACHE_SIZE);\n    mPathResolverCache = CacheBuilder.newBuilder()\n        .maximumSize(maxCachedPaths)\n        .build(new PathCacheLoader());\n\n    Preconditions.checkArgument(mTachyonRootPath.isAbsolute(),\n        \"tachyon root path should be absolute\");\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Retrieves file attributes.\n   * @param path The path on the FS of the file\n   * @param stat FUSE data structure to fill with file attrs\n   * @return 0 on success, negative value on error\n   */\n  @Override\n  public int getattr(String path, FileStat stat) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    LOG.trace(\"getattr({}) [Tachyon: {}]\", path, turi);\n    try {\n      final TachyonFile tf = mTFS.openIfExists(turi);\n      if (tf == null) {\n        return -ErrorCodes.ENOENT();\n      }\n      final FileInfo fi = mTFS.getInfo(tf);\n      stat.st_size.set(fi.getLength());\n\n      final long ctime = fi.getLastModificationTimeMs();\n      final long ctime_sec = fi.getLastModificationTimeMs() / 1000;\n      //keeps only the \"residual\" nanoseconds not caputred in\n      // citme_sec\n      final long ctime_nsec = (fi.getLastModificationTimeMs() % 1000) * 1000;\n      stat.st_ctim.tv_sec.set(ctime_sec);\n      stat.st_ctim.tv_nsec.set(ctime_nsec);\n      stat.st_mtim.tv_sec.set(ctime_sec);\n      stat.st_mtim.tv_nsec.set(ctime_nsec);\n\n      // TODO(andreareale): understand how to map FileInfo#getUserName()\n      // and FileInfo#getGroupName() to UIDs and GIDs of the node\n      // where tachyon-fuse is mounted.\n      // While this is not done, just use uid and gid of the user\n      // running tachyon-fuse.\n      stat.st_uid.set(UID_AND_GID[0]);\n      stat.st_gid.set(UID_AND_GID[1]);\n\n      final int mode;\n      if (fi.isFolder) {\n        mode = FileStat.S_IFDIR;\n      } else {\n        mode = FileStat.S_IFREG;\n      }\n      stat.st_mode.set(mode);\n\n    } catch (InvalidPathException e) {\n      LOG.debug(\"Invalid path {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","id":91101,"modified_method":"/**\n   * Retrieves file attributes.\n   * @param path The path on the FS of the file\n   * @param stat FUSE data structure to fill with file attrs\n   * @return 0 on success, negative value on error\n   */\n  @Override\n  public int getattr(String path, FileStat stat) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    LOG.trace(\"getattr({}) [Tachyon: {}]\", path, turi);\n    try {\n      if (!mTFS.exists(turi)) {\n        return -ErrorCodes.ENOENT();\n      }\n      final URIStatus status = mTFS.getStatus(turi);\n      stat.st_size.set(status.getLength());\n\n      final long ctime = status.getLastModificationTimeMs();\n      final long ctime_sec = status.getLastModificationTimeMs() / 1000;\n      //keeps only the \"residual\" nanoseconds not caputred in\n      // citme_sec\n      final long ctime_nsec = (status.getLastModificationTimeMs() % 1000) * 1000;\n      stat.st_ctim.tv_sec.set(ctime_sec);\n      stat.st_ctim.tv_nsec.set(ctime_nsec);\n      stat.st_mtim.tv_sec.set(ctime_sec);\n      stat.st_mtim.tv_nsec.set(ctime_nsec);\n\n      // TODO(andreareale): understand how to map FileInfo#getUserName()\n      // and FileInfo#getGroupName() to UIDs and GIDs of the node\n      // where tachyon-fuse is mounted.\n      // While this is not done, just use uid and gid of the user\n      // running tachyon-fuse.\n      stat.st_uid.set(UID_AND_GID[0]);\n      stat.st_gid.set(UID_AND_GID[1]);\n\n      final int mode;\n      if (status.isFolder()) {\n        mode = FileStat.S_IFDIR;\n      } else {\n        mode = FileStat.S_IFREG;\n      }\n      stat.st_mode.set(mode);\n\n    } catch (InvalidPathException e) {\n      LOG.debug(\"Invalid path {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Renames a path\n   * @param oldPath the source path in the FS\n   * @param newPath the destination path in the FS\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int rename(String oldPath, String newPath) {\n    final TachyonURI oldUri = mPathResolverCache.getUnchecked(oldPath);\n    final TachyonURI newUri = mPathResolverCache.getUnchecked(newPath);\n    LOG.trace(\"rename({}, {}) [Tachyon: {}, {}]\", oldPath, newPath, oldUri, newUri);\n\n    try {\n      final TachyonFile oldFile = mTFS.openIfExists(oldUri);\n      if (oldFile == null) {\n        LOG.error(\"File {} does not exist\", oldPath);\n        return -ErrorCodes.ENOENT();\n      } else {\n        mTFS.rename(oldFile, newUri);\n      }\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File {} does not exist\", oldPath);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException while moving {} to {}\", oldPath, newPath, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"Exception while moving {} to {}\", oldPath, newPath, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on mv {} {}\", oldPath, newPath, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","id":91102,"modified_method":"/**\n   * Renames a path\n   * @param oldPath the source path in the FS\n   * @param newPath the destination path in the FS\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int rename(String oldPath, String newPath) {\n    final TachyonURI oldUri = mPathResolverCache.getUnchecked(oldPath);\n    final TachyonURI newUri = mPathResolverCache.getUnchecked(newPath);\n    LOG.trace(\"rename({}, {}) [Tachyon: {}, {}]\", oldPath, newPath, oldUri, newUri);\n\n    try {\n      if (!mTFS.exists(oldUri)) {\n        LOG.error(\"File {} does not exist\", oldPath);\n        return -ErrorCodes.ENOENT();\n      } else {\n        mTFS.rename(oldUri, newUri);\n      }\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File {} does not exist\", oldPath);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException while moving {} to {}\", oldPath, newPath, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"Exception while moving {} to {}\", oldPath, newPath, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on mv {} {}\", oldPath, newPath, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Reads the contents of a directory.\n   * @param path The FS path of the directory\n   * @param buff The FUSE buffer to fill\n   * @param filter FUSE filter\n   * @param offset Ignored in tachyon-fuse\n   * @param fi FileInfo data structure kept by FUSE\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int readdir(String path, Pointer buff, FuseFillDir filter,\n      @off_t long offset, FuseFileInfo fi) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    LOG.trace(\"readdir({}) [Tachyon: {}]\", path, turi);\n\n    try {\n      final TachyonFile tf = mTFS.openIfExists(turi);\n      if (tf == null) {\n        return -ErrorCodes.ENOENT();\n      }\n      final FileInfo tfi = mTFS.getInfo(tf);\n      if (!tfi.isFolder) {\n        return -ErrorCodes.ENOTDIR();\n      }\n      final List<FileInfo> ls = mTFS.listStatus(tf);\n      // standard . and .. entries\n      filter.apply(buff, \".\", null, 0);\n      filter.apply(buff, \"..\", null, 0);\n\n      for (final FileInfo file : ls) {\n        filter.apply(buff, file.name, null, 0);\n      }\n\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (InvalidPathException e) {\n      LOG.debug(\"Invalid path {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","id":91103,"modified_method":"/**\n   * Reads the contents of a directory.\n   * @param path The FS path of the directory\n   * @param buff The FUSE buffer to fill\n   * @param filter FUSE filter\n   * @param offset Ignored in tachyon-fuse\n   * @param fi FileInfo data structure kept by FUSE\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int readdir(String path, Pointer buff, FuseFillDir filter,\n      @off_t long offset, FuseFileInfo fi) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    LOG.trace(\"readdir({}) [Tachyon: {}]\", path, turi);\n\n    try {\n      if (mTFS.exists(turi)) {\n        return -ErrorCodes.ENOENT();\n      }\n      final URIStatus status = mTFS.getStatus(turi);\n      if (!status.isFolder()) {\n        return -ErrorCodes.ENOTDIR();\n      }\n      final List<URIStatus> ls = mTFS.listStatus(turi);\n      // standard . and .. entries\n      filter.apply(buff, \".\", null, 0);\n      filter.apply(buff, \"..\", null, 0);\n\n      for (final URIStatus file : ls) {\n        filter.apply(buff, file.getName(), null, 0);\n      }\n\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (InvalidPathException e) {\n      LOG.debug(\"Invalid path {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates and opens a new file.\n   * @param path The FS path of the file to open\n   * @param mode mode flags\n   * @param fi FileInfo data struct kept by FUSE\n   * @return 0 on success. A negative value on error\n   */\n  @Override\n  public int create(String path, @mode_t long mode, FuseFileInfo fi) {\n    // mode is ignored in tachyon-fuse\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    // (see {@code man 2 open} for the structure of the flags bitfield)\n    // File creation flags are the last two bits of flags\n    final int flags = fi.flags.get();\n    LOG.trace(\"create({}, {}) [Tachyon: {}]\", path, Integer.toHexString(flags), turi);\n    final int openFlag = flags & 3;\n    if (openFlag != O_WRONLY.intValue()) {\n      OpenFlags flag = OpenFlags.valueOf(openFlag);\n      LOG.error(\"Passed a {} flag to create(). Files can only be created in O_WRONLY mode ({})\",\n          flag.toString(), path);\n      return -ErrorCodes.EACCES();\n    }\n\n    try {\n      synchronized (mOpenFiles) {\n        if (mOpenFiles.size() >= MAX_OPEN_FILES) {\n          LOG.error(\"Cannot open {}: too many open files (MAX_OPEN_FILES: {})\",\n              turi, MAX_OPEN_FILES);\n          return -ErrorCodes.EMFILE();\n        }\n\n        final OpenFileEntry ofe =\n            new OpenFileEntry(null, mTFS.getOutStream(turi));\n        LOG.debug(\"Tachyon OutStream created for {}\", path);\n        mOpenFiles.put(mNextOpenFileId, ofe);\n        fi.fh.set(mNextOpenFileId);\n\n        // Assuming I will never wrap around (2^64 open files are quite a lot anyway)\n        mNextOpenFileId += 1;\n      }\n      LOG.debug(\"{} created and opened in O_WRONLY mode\", path);\n\n    } catch (FileAlreadyExistsException e) {\n      LOG.debug(\"File {} already exists\", turi, e);\n      return -ErrorCodes.EEXIST();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","id":91104,"modified_method":"/**\n   * Creates and opens a new file.\n   * @param path The FS path of the file to open\n   * @param mode mode flags\n   * @param fi FileInfo data struct kept by FUSE\n   * @return 0 on success. A negative value on error\n   */\n  @Override\n  public int create(String path, @mode_t long mode, FuseFileInfo fi) {\n    // mode is ignored in tachyon-fuse\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    // (see {@code man 2 open} for the structure of the flags bitfield)\n    // File creation flags are the last two bits of flags\n    final int flags = fi.flags.get();\n    LOG.trace(\"create({}, {}) [Tachyon: {}]\", path, Integer.toHexString(flags), turi);\n    final int openFlag = flags & 3;\n    if (openFlag != O_WRONLY.intValue()) {\n      OpenFlags flag = OpenFlags.valueOf(openFlag);\n      LOG.error(\"Passed a {} flag to create(). Files can only be created in O_WRONLY mode ({})\",\n          flag.toString(), path);\n      return -ErrorCodes.EACCES();\n    }\n\n    try {\n      synchronized (mOpenFiles) {\n        if (mOpenFiles.size() >= MAX_OPEN_FILES) {\n          LOG.error(\"Cannot open {}: too many open files (MAX_OPEN_FILES: {})\",\n              turi, MAX_OPEN_FILES);\n          return -ErrorCodes.EMFILE();\n        }\n\n        final OpenFileEntry ofe = new OpenFileEntry(null, mTFS.createFile(turi));\n        LOG.debug(\"Tachyon OutStream created for {}\", path);\n        mOpenFiles.put(mNextOpenFileId, ofe);\n        fi.fh.set(mNextOpenFileId);\n\n        // Assuming I will never wrap around (2^64 open files are quite a lot anyway)\n        mNextOpenFileId += 1;\n      }\n      LOG.debug(\"{} created and opened in O_WRONLY mode\", path);\n\n    } catch (FileAlreadyExistsException e) {\n      LOG.debug(\"File {} already exists\", turi, e);\n      return -ErrorCodes.EEXIST();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Opens an existing file for reading.\n   *\n   * Note that the open mode <emph>must<\/emph> be\n   * O_RDONLY, otherwise the open will fail. This is due to\n   * the Tachyon \"write-once/read-many-times\" file model.\n   *\n   * @param path the FS path of the file to open\n   * @param fi FileInfo data structure kept by FUSE\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int open(String path, FuseFileInfo fi) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    // (see {@code man 2 open} for the structure of the flags bitfield)\n    // File creation flags are the last two bits of flags\n    final int flags = fi.flags.get();\n    LOG.trace(\"open({}, 0x{}) [Tachyon: {}]\", path, Integer.toHexString(flags), turi);\n\n    if ((flags & 3) != O_RDONLY.intValue()) {\n      LOG.error(\"Files can only be opened in O_RDONLY mode ({})\", path);\n      return -ErrorCodes.EACCES();\n    }\n    try {\n      final TachyonFile tf = mTFS.openIfExists(turi);\n      if (tf == null) {\n        LOG.error(\"File {} does not exist\", turi);\n        return -ErrorCodes.ENOENT();\n      }\n      final FileInfo tfi = mTFS.getInfo(tf);\n      if (tfi.isFolder) {\n        LOG.error(\"File {} is a directory\", turi);\n        return -ErrorCodes.EISDIR();\n      }\n\n      synchronized (mOpenFiles) {\n        if (mOpenFiles.size() == MAX_OPEN_FILES) {\n          LOG.error(\"Cannot open {}: too many open files\", turi);\n          return ErrorCodes.EMFILE();\n        }\n        final OpenFileEntry ofe =\n            new OpenFileEntry(mTFS.getInStream(tf), null);\n        mOpenFiles.put(mNextOpenFileId, ofe);\n        fi.fh.set(mNextOpenFileId);\n\n        // Assuming I will never wrap around (2^64 open files are quite a lot anyway)\n        mNextOpenFileId += 1;\n      }\n\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","id":91105,"modified_method":"/**\n   * Opens an existing file for reading.\n   *\n   * Note that the open mode <emph>must<\/emph> be\n   * O_RDONLY, otherwise the open will fail. This is due to\n   * the Tachyon \"write-once/read-many-times\" file model.\n   *\n   * @param path the FS path of the file to open\n   * @param fi FileInfo data structure kept by FUSE\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int open(String path, FuseFileInfo fi) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    // (see {@code man 2 open} for the structure of the flags bitfield)\n    // File creation flags are the last two bits of flags\n    final int flags = fi.flags.get();\n    LOG.trace(\"open({}, 0x{}) [Tachyon: {}]\", path, Integer.toHexString(flags), turi);\n\n    if ((flags & 3) != O_RDONLY.intValue()) {\n      LOG.error(\"Files can only be opened in O_RDONLY mode ({})\", path);\n      return -ErrorCodes.EACCES();\n    }\n    try {\n      if (!mTFS.exists(turi)) {\n        LOG.error(\"File {} does not exist\", turi);\n        return -ErrorCodes.ENOENT();\n      }\n      final URIStatus status = mTFS.getStatus(turi);\n      if (status.isFolder()) {\n        LOG.error(\"File {} is a directory\", turi);\n        return -ErrorCodes.EISDIR();\n      }\n\n      synchronized (mOpenFiles) {\n        if (mOpenFiles.size() == MAX_OPEN_FILES) {\n          LOG.error(\"Cannot open {}: too many open files\", turi);\n          return ErrorCodes.EMFILE();\n        }\n        final OpenFileEntry ofe = new OpenFileEntry(mTFS.openFile(turi), null);\n        mOpenFiles.put(mNextOpenFileId, ofe);\n        fi.fh.set(mNextOpenFileId);\n\n        // Assuming I will never wrap around (2^64 open files are quite a lot anyway)\n        mNextOpenFileId += 1;\n      }\n\n    } catch (FileDoesNotExistException e) {\n      LOG.debug(\"File does not exist {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"IOException on {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"TachyonException on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new dir.\n   * @param path the path on the FS of the new dir\n   * @param mode Dir creation flags (IGNORED)\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int mkdir(String path, @mode_t long mode) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    LOG.trace(\"mkdir({}) [Tachyon: {}]\", path, turi);\n    try {\n      mTFS.mkdir(turi);\n    } catch (FileAlreadyExistsException e) {\n      LOG.debug(\"Cannot make dir. {} already exists\", path, e);\n      return -ErrorCodes.EEXIST();\n    } catch (InvalidPathException e) {\n      LOG.debug(\"Cannot make dir. Invalid path: {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"Cannot make dir. IOException: {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"Cannot make dir. {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","id":91106,"modified_method":"/**\n   * Creates a new dir.\n   * @param path the path on the FS of the new dir\n   * @param mode Dir creation flags (IGNORED)\n   * @return 0 on success, a negative value on error\n   */\n  @Override\n  public int mkdir(String path, @mode_t long mode) {\n    final TachyonURI turi = mPathResolverCache.getUnchecked(path);\n    LOG.trace(\"mkdir({}) [Tachyon: {}]\", path, turi);\n    try {\n      mTFS.createDirectory(turi);\n    } catch (FileAlreadyExistsException e) {\n      LOG.debug(\"Cannot make dir. {} already exists\", path, e);\n      return -ErrorCodes.EEXIST();\n    } catch (InvalidPathException e) {\n      LOG.debug(\"Cannot make dir. Invalid path: {}\", path, e);\n      return -ErrorCodes.ENOENT();\n    } catch (IOException e) {\n      LOG.error(\"Cannot make dir. IOException: {}\", path, e);\n      return -ErrorCodes.EIO();\n    } catch (TachyonException e) {\n      LOG.error(\"Cannot make dir. {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    } catch (Throwable e) {\n      LOG.error(\"Unexpected exception on {}\", path, e);\n      return -ErrorCodes.EFAULT();\n    }\n\n    return 0;\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void mkDirTest() throws Exception {\n    mFuseFs.mkdir(\"/foo/bar\", -1);\n    verify(mTFS).mkdir(BASE_EXPECTED_URI.join(\"/foo/bar\"));\n  }","id":91107,"modified_method":"@Test\n  public void mkDirTest() throws Exception {\n    mFuseFs.mkdir(\"/foo/bar\", -1);\n    verify(mTFS).createDirectory(BASE_EXPECTED_URI.join(\"/foo/bar\"));\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void flushTest() throws Exception {\n    FileOutStream fos = mock(FileOutStream.class);\n    TachyonURI anyURI = any();\n    when(mTFS.getOutStream(anyURI)).thenReturn(fos);\n\n    // open a file\n    mFileInfo.flags.set(O_WRONLY.intValue());\n    mFuseFs.create(\"/foo/bar\", 0, mFileInfo);\n\n    //then call flush into it\n    mFuseFs.flush(\"/foo/bar\", mFileInfo);\n    verify(fos).flush();\n  }","id":91108,"modified_method":"@Test\n  public void flushTest() throws Exception {\n    FileOutStream fos = mock(FileOutStream.class);\n    TachyonURI anyURI = any();\n    when(mTFS.createFile(anyURI)).thenReturn(fos);\n\n    // open a file\n    mFileInfo.flags.set(O_WRONLY.intValue());\n    mFuseFs.create(\"/foo/bar\", 0, mFileInfo);\n\n    //then call flush into it\n    mFuseFs.flush(\"/foo/bar\", mFileInfo);\n    verify(fos).flush();\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void createTest() throws Exception {\n    mFileInfo.flags.set(O_WRONLY.intValue());\n    mFuseFs.create(\"/foo/bar\", 0, mFileInfo);\n    TachyonURI expectedPath = BASE_EXPECTED_URI.join(\"/foo/bar\");\n    verify(mTFS).getOutStream(expectedPath);\n  }","id":91109,"modified_method":"@Test\n  public void createTest() throws Exception {\n    mFileInfo.flags.set(O_WRONLY.intValue());\n    mFuseFs.create(\"/foo/bar\", 0, mFileInfo);\n    TachyonURI expectedPath = BASE_EXPECTED_URI.join(\"/foo/bar\");\n    verify(mTFS).createFile(expectedPath);\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"@Before\n  public void setUp() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.MASTER_ADDRESS, TEST_MASTER_ADDRESS);\n    conf.set(Constants.FUSE_PATHCACHE_SIZE, \"0\");\n\n    final List<String> empty = Collections.emptyList();\n    TachyonFuseOptions opts = new TachyonFuseOptions(\n        \"/doesnt/matter\", TEST_ROOT_PATH, false, empty);\n\n    mTFS = mock(TachyonFileSystem.class);\n    mFuseFs = new TachyonFuseFs(conf, mTFS, opts);\n    mFileInfo = allocateNativeFileInfo();\n  }","id":91110,"modified_method":"@Before\n  public void setUp() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.MASTER_ADDRESS, TEST_MASTER_ADDRESS);\n    conf.set(Constants.FUSE_PATHCACHE_SIZE, \"0\");\n\n    final List<String> empty = Collections.emptyList();\n    TachyonFuseOptions opts = new TachyonFuseOptions(\n        \"/doesnt/matter\", TEST_ROOT_PATH, false, empty);\n\n    mTFS = mock(FileSystem.class);\n    mFuseFs = new TachyonFuseFs(conf, mTFS, opts);\n    mFileInfo = allocateNativeFileInfo();\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void readTest() throws Exception {\n    // mocks set-up\n    TachyonURI expectedPath = BASE_EXPECTED_URI.join(\"/foo/bar\");\n    TachyonFile fake = new TachyonFile(42L);\n    FileInfo fi = new FileInfo();\n    fi.isFolder = false;\n\n    when(mTFS.openIfExists(expectedPath)).thenReturn(fake);\n    when(mTFS.getInfo(fake)).thenReturn(fi);\n\n    FileInStream fakeInStream = mock(FileInStream.class);\n    when(fakeInStream.read(any(byte[].class),anyInt(),anyInt())).then(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocationOnMock) throws Throwable {\n        byte[] myDest = (byte[])invocationOnMock.getArguments()[0];\n        for (byte i = 0; i < 4; i++) {\n          myDest[i] = i;\n        }\n        return 4;\n      }\n    });\n    when(mTFS.getInStream(fake)).thenReturn(fakeInStream);\n    mFileInfo.flags.set(O_RDONLY.intValue());\n\n    // prepare something to read to it\n    Runtime r = Runtime.getSystemRuntime();\n    Pointer ptr = r.getMemoryManager().allocateTemporary(4, true);\n\n    // actual test\n    mFuseFs.open(\"/foo/bar\", mFileInfo);\n\n    mFuseFs.read(\"/foo/bar\", ptr, 4, 0, mFileInfo);\n    final byte[] dst = new byte[4];\n    ptr.get(0, dst, 0, 4);\n    final byte[] expected = new byte[] {0, 1, 2, 3};\n\n    assertArrayEquals(\"Source and dst data should be equal\", expected, dst);\n\n  }","id":91111,"modified_method":"@Test\n  public void readTest() throws Exception {\n    // mocks set-up\n    TachyonURI expectedPath = BASE_EXPECTED_URI.join(\"/foo/bar\");\n    FileInfo fi = new FileInfo();\n    fi.isFolder = false;\n    URIStatus status = new URIStatus(fi);\n\n    when(mTFS.exists(expectedPath)).thenReturn(true);\n    when(mTFS.getStatus(expectedPath)).thenReturn(status);\n\n    FileInStream fakeInStream = mock(FileInStream.class);\n    when(fakeInStream.read(any(byte[].class),anyInt(),anyInt())).then(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocationOnMock) throws Throwable {\n        byte[] myDest = (byte[])invocationOnMock.getArguments()[0];\n        for (byte i = 0; i < 4; i++) {\n          myDest[i] = i;\n        }\n        return 4;\n      }\n    });\n    when(mTFS.openFile(expectedPath)).thenReturn(fakeInStream);\n    mFileInfo.flags.set(O_RDONLY.intValue());\n\n    // prepare something to read to it\n    Runtime r = Runtime.getSystemRuntime();\n    Pointer ptr = r.getMemoryManager().allocateTemporary(4, true);\n\n    // actual test\n    mFuseFs.open(\"/foo/bar\", mFileInfo);\n\n    mFuseFs.read(\"/foo/bar\", ptr, 4, 0, mFileInfo);\n    final byte[] dst = new byte[4];\n    ptr.get(0, dst, 0, 4);\n    final byte[] expected = new byte[] {0, 1, 2, 3};\n\n    assertArrayEquals(\"Source and dst data should be equal\", expected, dst);\n\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void writeTest() throws Exception {\n    FileOutStream fos = mock(FileOutStream.class);\n    TachyonURI anyURI = any();\n    when(mTFS.getOutStream(anyURI)).thenReturn(fos);\n\n    // open a file\n    mFileInfo.flags.set(O_WRONLY.intValue());\n    mFuseFs.create(\"/foo/bar\", 0, mFileInfo);\n\n    // prepare something to write into it\n    Runtime r = Runtime.getSystemRuntime();\n    Pointer ptr = r.getMemoryManager().allocateTemporary(4, true);\n    byte[] expected = {42, -128, 1, 3};\n    ptr.put(0, expected, 0, 4);\n\n    mFuseFs.write(\"/foo/bar\", ptr, 4, 0, mFileInfo);\n\n    verify(fos).write(expected);\n  }","id":91112,"modified_method":"@Test\n  public void writeTest() throws Exception {\n    FileOutStream fos = mock(FileOutStream.class);\n    TachyonURI anyURI = any();\n    when(mTFS.createFile(anyURI)).thenReturn(fos);\n\n    // open a file\n    mFileInfo.flags.set(O_WRONLY.intValue());\n    mFuseFs.create(\"/foo/bar\", 0, mFileInfo);\n\n    // prepare something to write into it\n    Runtime r = Runtime.getSystemRuntime();\n    Pointer ptr = r.getMemoryManager().allocateTemporary(4, true);\n    byte[] expected = {42, -128, 1, 3};\n    ptr.put(0, expected, 0, 4);\n\n    mFuseFs.write(\"/foo/bar\", ptr, 4, 0, mFileInfo);\n\n    verify(fos).write(expected);\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void openTest() throws Exception {\n    // mocks set-up\n    TachyonURI expectedPath = BASE_EXPECTED_URI.join(\"/foo/bar\");\n    TachyonFile fake = new TachyonFile(42L);\n    FileInfo fi = new FileInfo();\n    fi.isFolder = false;\n\n    when(mTFS.openIfExists(expectedPath)).thenReturn(fake);\n    when(mTFS.getInfo(fake)).thenReturn(fi);\n    mFileInfo.flags.set(O_RDONLY.intValue());\n\n    // actual test\n    mFuseFs.open(\"/foo/bar\", mFileInfo);\n    verify(mTFS).openIfExists(expectedPath);\n    verify(mTFS).getInStream(fake);\n  }","id":91113,"modified_method":"@Test\n  public void openTest() throws Exception {\n    // mocks set-up\n    TachyonURI expectedPath = BASE_EXPECTED_URI.join(\"/foo/bar\");\n    FileInfo fi = new FileInfo();\n    fi.isFolder = false;\n    URIStatus status = new URIStatus(fi);\n\n    when(mTFS.exists(expectedPath)).thenReturn(true);\n    when(mTFS.getStatus(expectedPath)).thenReturn(status);\n    mFileInfo.flags.set(O_RDONLY.intValue());\n\n    // actual test\n    mFuseFs.open(\"/foo/bar\", mFileInfo);\n    verify(mTFS).exists(expectedPath);\n    verify(mTFS).openFile(expectedPath);\n  }","commit_id":"27ebea6295f52fa2dd32d37b23e867cc8ba84d3e","url":"https://github.com/amplab/tachyon"},{"original_method":"public void run( ) {\n      Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n      try {\n        ListenerRegistry.getInstance( ).fireEvent( new Hertz( ) );\n      } catch ( EventFailedException e ) {} catch ( Exception t ) {\n        LOG.error( t, t );\n      }\n    }","id":91114,"modified_method":"public void run( ) {\n      Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n      try {\n        ListenerRegistry.getInstance( ).fireEventAsync( Hertz.class, new Hertz( ) ).get( SystemClock.EVENT_TIMEOUT, TimeUnit.SECONDS );\n      } catch ( Exception t ) {\n        LOG.error( t, t );\n      }\n    }","commit_id":"ad43dd16956e17bb9e1c9c63803a5f22b6933212","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void setupTimer( ) {\n    synchronized ( SystemClock.class ) {\n      if ( timer == null ) {\n        timer = new Timer( \"SystemClockTimer\" );\n        hzTimer = new Timer( \"SystemHzTimer\" );\n        clock = new SystemClock( );\n        hertz = new HzClock( );\n        ListenerRegistry.getInstance( ).register( ClockTick.class, new Dummy( ) );\n        ListenerRegistry.getInstance( ).register( Hertz.class, new Dummy( ) );\n        timer.scheduleAtFixedRate( clock, 0, 10000 );//TODO: make configurable\n        hzTimer.scheduleAtFixedRate( hertz, 0, 1000 );\n        OrderedShutdown.register( Empyrean.class, new Runnable( ) {\n          @Override\n          public void run( ) {\n            timer.cancel( );\n          }\n        } );\n        OrderedShutdown.register( Empyrean.class, new Runnable( ) {\n          \n          @Override\n          public void run( ) {\n            hzTimer.cancel( );\n          }\n        } );\n      }\n    }\n  }","id":91115,"modified_method":"public static void setupTimer( ) {\n    synchronized ( SystemClock.class ) {\n      if ( timer == null ) {\n        timer = new Timer( \"SystemClockTimer\" );\n        hzTimer = new Timer( \"SystemHzTimer\" );\n        clock = new SystemClock( );\n        hertz = new HzClock( );\n        ListenerRegistry.getInstance( ).register( ClockTick.class, new Dummy( ) );\n        ListenerRegistry.getInstance( ).register( Hertz.class, new Dummy( ) );\n        timer.scheduleAtFixedRate( clock, 0, SYSTEM_CLOCK_TICK );\n        hzTimer.scheduleAtFixedRate( hertz, 0, SYSTEM_HERTZ_TICK );\n        OrderedShutdown.register( Empyrean.class, new Runnable( ) {\n          @Override\n          public void run( ) {\n            timer.cancel( );\n          }\n        } );\n        OrderedShutdown.register( Empyrean.class, new Runnable( ) {\n          \n          @Override\n          public void run( ) {\n            hzTimer.cancel( );\n          }\n        } );\n      }\n    }\n  }","commit_id":"ad43dd16956e17bb9e1c9c63803a5f22b6933212","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void run( ) {\n    Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n    try {\n      long sign = ( long ) ( Math.pow( -1f, ( float ) ( ++phase % 2 ) ) );\n      ListenerRegistry.getInstance( ).fireEvent( new ClockTick( ).setMessage( sign * System.currentTimeMillis( ) ) );\n    } catch ( EventFailedException e ) {} catch ( Exception t ) {\n      LOG.error( t, t );\n    }\n  }","id":91116,"modified_method":"@Override\n  public void run( ) {\n    Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n    try {\n      long sign = ( long ) ( Math.pow( -1f, ( float ) ( ++phase % 2 ) ) );\n      ListenerRegistry.getInstance( ).fireEventAsync( ClockTick.class, new ClockTick( ).setMessage( sign * System.currentTimeMillis( ) ) ).get( EVENT_TIMEOUT,\n                                                                                                                                                TimeUnit.SECONDS );\n    } catch ( Exception t ) {\n      LOG.error( t, t );\n    }\n  }","commit_id":"ad43dd16956e17bb9e1c9c63803a5f22b6933212","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void run( ) {\n      Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n      try {\n        ListenerRegistry.getInstance( ).fireEvent( new Hertz( ) );\n      } catch ( EventFailedException e ) {} catch ( Exception t ) {\n        LOG.error( t, t );\n      }\n    }","id":91117,"modified_method":"public void run( ) {\n      Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n      try {\n        ListenerRegistry.getInstance( ).fireEventAsync( Hertz.class, new Hertz( ) ).get( 2, TimeUnit.MINUTES );\n      } catch ( Exception t ) {\n        LOG.error( t );\n        Logs.extreme( ).error( t, t );\n      }\n    }","commit_id":"3f9ee3a1a8cbe7c135ab774ac8df83e5dc7ceb35","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void run( ) {\n    Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n    try {\n      long sign = ( long ) ( Math.pow( -1f, ( float ) ( ++phase % 2 ) ) );\n      ListenerRegistry.getInstance( ).fireEvent( new ClockTick( ).setMessage( sign * System.currentTimeMillis( ) ) );\n    } catch ( EventFailedException e ) {} catch ( Exception t ) {\n      LOG.error( t, t );\n    }\n  }","id":91118,"modified_method":"@Override\n  public void run( ) {\n    Thread.currentThread( ).setUncaughtExceptionHandler( ( UncaughtExceptionHandler ) this );\n    try {\n      long sign = ( long ) ( Math.pow( -1f, ( float ) ( ++phase % 2 ) ) );\n      ListenerRegistry.getInstance( )\n                      .fireEventAsync( ClockTick.class,\n                                       new ClockTick( ).setMessage( sign * System.currentTimeMillis( ) ) )\n                       .get( 2, TimeUnit.MINUTES );\n    } catch ( Exception t ) {\n      LOG.error( t );\n      Logs.extreme( ).error( t, t );\n    }\n  }","commit_id":"3f9ee3a1a8cbe7c135ab774ac8df83e5dc7ceb35","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n     * An implementation of run() that blocks the site thread\n     * until the streaming snapshot queue is emptied.\n     */\n    void runForCommunityRejoin(SiteProcedureConnection siteConnection)\n    {\n        Pair<Integer, ByteBuffer> rejoinWork = m_rejoinSiteProcessor.poll(m_snapshotBufferAllocator);\n        // poll() could return null if the source indicated enf of stream,\n        // need to check on that before retry\n        if (rejoinWork == null && !m_rejoinSiteProcessor.isEOF()) {\n            m_taskQueue.offer(this);\n            // The source is not set up yet, don't block the site,\n            // return here and retry later.\n            return;\n        }\n\n        // By the time we get here, the snapshot has been successfully started.\n        // We can safely block the site until all snapshot blocks are received.\n        while (rejoinWork != null) {\n            restoreBlock(rejoinWork, siteConnection);\n            try {\n                rejoinWork = m_rejoinSiteProcessor.take(m_snapshotBufferAllocator);\n            } catch (InterruptedException e) {\n                REJOINLOG.warn(\"RejoinProducer interrupted at take()\");\n                rejoinWork = null;\n            }\n        }\n        REJOINLOG.debug(m_whoami + \"Rejoin snapshot transfer is finished\");\n        m_rejoinSiteProcessor.close();\n\n        if (m_streamSnapshotMb != null) {\n            VoltDB.instance().getHostMessenger().removeMailbox(m_streamSnapshotMb.getHSId());\n        }\n\n        // m_rejoinSnapshotBytes = m_rejoinSiteProcessor.bytesTransferred();\n        // m_rejoinSiteProcessor = null;\n\n        // A bit of a hack; in some large database cases with more than 2 nodes,\n        // one of the nodes can finish streaming its sites LONG before the other\n        // nodes.  Since we won't see the SnapshotCompletionMonitor fire until\n        // all sites are done, the watchdog can fire first and abort the rejoin.\n        // Just turn the watchdog off after we've gotten the last block.\n        kickWatchdog(false);\n\n        /*\n         * Don't notify the rejoin coordinator yet. The stream snapshot may\n         * have not finished on all nodes, let the snapshot completion\n         * monitor tell the rejoin coordinator.\n         */\n\n        // Block until the snapshot interest triggers.\n        // -- rtb: not sure this race can happen in the live rejoin case?\n        // Maybe with tiny data sets? I'm going to accept\n        // the simple and correct action of blocking until there\n        // is an indication that a non-blocking wait is necesary.\n        SnapshotCompletionEvent event = null;\n        try {\n            REJOINLOG.debug(m_whoami\n                    + \"waiting on snapshot completion monitor.\");\n            event = m_completionMonitorAwait.get();\n            m_completionAction.setSnapshotTxnId(event.multipartTxnId);\n            REJOINLOG.debug(m_whoami + \" monitor completed. Sending SNAPSHOT_FINISHED \"\n                    + \"and handing off to site.\");\n            RejoinMessage snap_complete = new RejoinMessage(\n                    m_mailbox.getHSId(), Type.SNAPSHOT_FINISHED);\n            m_mailbox.send(m_coordinatorHsId, snap_complete);\n        } catch (InterruptedException crashme) {\n            VoltDB.crashLocalVoltDB(\n                    \"Interrupted awaiting snapshot completion.\", true, crashme);\n        } catch (ExecutionException e) {\n            VoltDB.crashLocalVoltDB(\n                    \"Unexpected exception awaiting snapshot completion.\", true,\n                    e);\n        }\n        setJoinComplete(siteConnection, event.exportSequenceNumbers);\n    }","id":91119,"modified_method":"/**\n     * An implementation of run() that blocks the site thread\n     * until the streaming snapshot queue is emptied.\n     */\n    void runForCommunityRejoin(SiteProcedureConnection siteConnection)\n    {\n        Pair<Integer, ByteBuffer> rejoinWork = m_rejoinSiteProcessor.poll(m_snapshotBufferAllocator);\n        // poll() could return null if the source indicated enf of stream,\n        // need to check on that before retry\n        if (rejoinWork == null && !m_rejoinSiteProcessor.isEOF()) {\n            m_taskQueue.offer(this);\n            // The source is not set up yet, don't block the site,\n            // return here and retry later.\n            return;\n        }\n\n        // By the time we get here, the snapshot has been successfully started.\n        // We can safely block the site until all snapshot blocks are received.\n        while (rejoinWork != null) {\n            restoreBlock(rejoinWork, siteConnection);\n            try {\n                rejoinWork = m_rejoinSiteProcessor.take(m_snapshotBufferAllocator);\n            } catch (InterruptedException e) {\n                REJOINLOG.warn(\"RejoinProducer interrupted at take()\");\n                rejoinWork = null;\n            }\n        }\n        REJOINLOG.debug(m_whoami + \"Rejoin snapshot transfer is finished\");\n        m_rejoinSiteProcessor.close();\n\n        Preconditions.checkNotNull(m_streamSnapshotMb);\n        VoltDB.instance().getHostMessenger().removeMailbox(m_streamSnapshotMb.getHSId());\n\n        // m_rejoinSnapshotBytes = m_rejoinSiteProcessor.bytesTransferred();\n        // m_rejoinSiteProcessor = null;\n\n        // A bit of a hack; in some large database cases with more than 2 nodes,\n        // one of the nodes can finish streaming its sites LONG before the other\n        // nodes.  Since we won't see the SnapshotCompletionMonitor fire until\n        // all sites are done, the watchdog can fire first and abort the rejoin.\n        // Just turn the watchdog off after we've gotten the last block.\n        kickWatchdog(false);\n\n        /*\n         * Don't notify the rejoin coordinator yet. The stream snapshot may\n         * have not finished on all nodes, let the snapshot completion\n         * monitor tell the rejoin coordinator.\n         */\n\n        // Block until the snapshot interest triggers.\n        // -- rtb: not sure this race can happen in the live rejoin case?\n        // Maybe with tiny data sets? I'm going to accept\n        // the simple and correct action of blocking until there\n        // is an indication that a non-blocking wait is necesary.\n        SnapshotCompletionEvent event = null;\n        try {\n            REJOINLOG.debug(m_whoami\n                    + \"waiting on snapshot completion monitor.\");\n            event = m_completionMonitorAwait.get();\n            m_completionAction.setSnapshotTxnId(event.multipartTxnId);\n            REJOINLOG.debug(m_whoami + \" monitor completed. Sending SNAPSHOT_FINISHED \"\n                    + \"and handing off to site.\");\n            RejoinMessage snap_complete = new RejoinMessage(\n                    m_mailbox.getHSId(), Type.SNAPSHOT_FINISHED);\n            m_mailbox.send(m_coordinatorHsId, snap_complete);\n        } catch (InterruptedException crashme) {\n            VoltDB.crashLocalVoltDB(\n                    \"Interrupted awaiting snapshot completion.\", true, crashme);\n        } catch (ExecutionException e) {\n            VoltDB.crashLocalVoltDB(\n                    \"Unexpected exception awaiting snapshot completion.\", true,\n                    e);\n        }\n        setJoinComplete(siteConnection, event.exportSequenceNumbers);\n    }","commit_id":"4cce026ad8e588ba808df9daf7f9207c1d63808f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * An implementation of run() that does not block the site thread.\n     * The Site has responsibility for transactions that occur between\n     * schedulings of this task.\n     */\n    void runForLiveRejoin(SiteProcedureConnection siteConnection)\n    {\n        Pair<Integer, ByteBuffer> rejoinWork = m_rejoinSiteProcessor.poll(m_snapshotBufferAllocator);\n        if (rejoinWork != null) {\n            restoreBlock(rejoinWork, siteConnection);\n        }\n\n        if (m_rejoinSiteProcessor.isEOF() == false) {\n            m_taskQueue.offer(this);\n        } else {\n            REJOINLOG.debug(m_whoami + \"Rejoin snapshot transfer is finished\");\n            m_rejoinSiteProcessor.close();\n\n            if (m_streamSnapshotMb != null) {\n                VoltDB.instance().getHostMessenger().removeMailbox(m_streamSnapshotMb.getHSId());\n            }\n\n            // m_rejoinSnapshotBytes = m_rejoinSiteProcessor.bytesTransferred();\n            // m_rejoinSiteProcessor = null;\n\n            // Don't notify the rejoin coordinator yet. The stream snapshot may\n            // have not finished on all nodes, let the snapshot completion\n            // monitor tell the rejoin coordinator.\n\n            SnapshotCompletionEvent event = null;\n            // Block until the snapshot interest triggers.\n            try {\n                REJOINLOG.debug(m_whoami\n                        + \"waiting on snapshot completion monitor.\");\n                event = m_completionMonitorAwait.get();\n                m_completionAction.setSnapshotTxnId(event.multipartTxnId);\n                REJOINLOG.debug(m_whoami\n                        + \"snapshot monitor completed. \"\n                        + \"Sending SNAPSHOT_FINISHED and Handing off to site.\");\n                RejoinMessage snap_complete = new RejoinMessage(\n                        m_mailbox.getHSId(), Type.SNAPSHOT_FINISHED);\n                m_mailbox.send(m_coordinatorHsId, snap_complete);\n\n            } catch (InterruptedException crashme) {\n                VoltDB.crashLocalVoltDB(\n                        \"Interrupted awaiting snapshot completion.\", true,\n                        crashme);\n            } catch (ExecutionException e) {\n                VoltDB.crashLocalVoltDB(\n                        \"Unexpected exception awaiting snapshot completion.\",\n                        true, e);\n            }\n            setJoinComplete(siteConnection, event.exportSequenceNumbers);\n        }\n    }","id":91120,"modified_method":"/**\n     * An implementation of run() that does not block the site thread.\n     * The Site has responsibility for transactions that occur between\n     * schedulings of this task.\n     */\n    void runForLiveRejoin(SiteProcedureConnection siteConnection)\n    {\n        Pair<Integer, ByteBuffer> rejoinWork = m_rejoinSiteProcessor.poll(m_snapshotBufferAllocator);\n        if (rejoinWork != null) {\n            restoreBlock(rejoinWork, siteConnection);\n        }\n\n        if (m_rejoinSiteProcessor.isEOF() == false) {\n            m_taskQueue.offer(this);\n        } else {\n            REJOINLOG.debug(m_whoami + \"Rejoin snapshot transfer is finished\");\n            m_rejoinSiteProcessor.close();\n\n            Preconditions.checkNotNull(m_streamSnapshotMb);\n            VoltDB.instance().getHostMessenger().removeMailbox(m_streamSnapshotMb.getHSId());\n\n            // m_rejoinSnapshotBytes = m_rejoinSiteProcessor.bytesTransferred();\n            // m_rejoinSiteProcessor = null;\n\n            // Don't notify the rejoin coordinator yet. The stream snapshot may\n            // have not finished on all nodes, let the snapshot completion\n            // monitor tell the rejoin coordinator.\n\n            SnapshotCompletionEvent event = null;\n            // Block until the snapshot interest triggers.\n            try {\n                REJOINLOG.debug(m_whoami\n                        + \"waiting on snapshot completion monitor.\");\n                event = m_completionMonitorAwait.get();\n                m_completionAction.setSnapshotTxnId(event.multipartTxnId);\n                REJOINLOG.debug(m_whoami\n                        + \"snapshot monitor completed. \"\n                        + \"Sending SNAPSHOT_FINISHED and Handing off to site.\");\n                RejoinMessage snap_complete = new RejoinMessage(\n                        m_mailbox.getHSId(), Type.SNAPSHOT_FINISHED);\n                m_mailbox.send(m_coordinatorHsId, snap_complete);\n\n            } catch (InterruptedException crashme) {\n                VoltDB.crashLocalVoltDB(\n                        \"Interrupted awaiting snapshot completion.\", true,\n                        crashme);\n            } catch (ExecutionException e) {\n                VoltDB.crashLocalVoltDB(\n                        \"Unexpected exception awaiting snapshot completion.\",\n                        true, e);\n            }\n            setJoinComplete(siteConnection, event.exportSequenceNumbers);\n        }\n    }","commit_id":"4cce026ad8e588ba808df9daf7f9207c1d63808f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void adjustToNewLambda( double currentLambda, double newLambda, double alpha, boolean intercept) {\n      assert newLambda < currentLambda:\"newLambda = \" + newLambda + \", last lambda = \" + currentLambda;\n      double l2diff = (newLambda - currentLambda) * (1 - alpha);\n      if(_activeCols != null) {\n        int j = 0;\n        for (int i : _activeCols)\n          _ginfo._gradient[i] += l2diff * _beta[j++];\n      } else {\n        for (int i = 0; i < _ginfo._gradient.length - (intercept?1:0); ++i)\n          _ginfo._gradient[i] += l2diff * _beta[i];\n      }\n      _ginfo = new GradientInfo(_ginfo ._objVal + .5 * l2diff * ArrayUtils.l2norm2(_beta, intercept), _ginfo._gradient);\n      _objVal = _ginfo._objVal + newLambda * alpha * ArrayUtils.l1norm(_beta,intercept);\n    }","id":91121,"modified_method":"public void adjustToNewLambda( double currentLambda, double newLambda, double alpha, boolean intercept) {\n      assert newLambda < currentLambda:\"newLambda = \" + newLambda + \", last lambda = \" + currentLambda;\n      double l2diff = (newLambda - currentLambda) * (1 - alpha);\n      Log.info(\"beta size = \" + _beta.length + \", grad size = \" + _ginfo._gradient.length);\n      for (int i = 0; i < _ginfo._gradient.length - (intercept?1:0); ++i)\n        _ginfo._gradient[i] += l2diff * _beta[i];\n      _ginfo = new GradientInfo(_ginfo ._objVal + .5 * l2diff * ArrayUtils.l2norm2(_beta, intercept), _ginfo._gradient);\n      _objVal = _ginfo._objVal + newLambda * alpha * ArrayUtils.l1norm(_beta,intercept);\n    }","commit_id":"3271553cf8c0119fc404dc64179d02f5cbd26832","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public double gradientCheck(double lambda, double alpha){\n      // assuming full-gradient, beta only for active columns\n      double [] beta = expandVec(_beta,_activeCols, _ginfo._gradient.length);\n      double [] subgrad = _ginfo._gradient.clone();\n      double err = 0;\n      ADMM.subgrad(alpha*lambda,beta,subgrad);\n      for(double d: subgrad)\n        if(err < -d) err = -d; else if(err < d) err = d;\n      Log.info(\"gerr at lambda = \" + lambda + \" = \" + err);\n      return err;\n    }","id":91122,"modified_method":"public double gradientCheck(double lambda, double alpha){\n      // assuming full-gradient, beta only for active columns\n      double [] beta = expandVec(_beta,_activeCols, _fullN);\n      double [] subgrad = _ginfo._gradient.clone();\n      double err = 0;\n      ADMM.subgrad(alpha*lambda,beta,subgrad);\n      for(double d: subgrad)\n        if(err < -d) err = -d; else if(err < d) err = d;\n      Log.info(\"gerr at lambda = \" + lambda + \" = \" + err);\n      return err;\n    }","commit_id":"3271553cf8c0119fc404dc64179d02f5cbd26832","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n    protected void compute2() {\n      assert _rowFilter != null;\n      _start_time = System.currentTimeMillis();\n      LogInfo(\"lambda = \" + _parms._lambda[_lambdaId] + \"\\n\");\n      int[] activeCols = activeCols(_parms._lambda[_lambdaId], _lambdaId == 0?_taskInfo._lambdaMax:_parms._lambda[_lambdaId-1], _taskInfo._ginfo._gradient);\n      _taskInfo._beta = resizeVec(_taskInfo._beta, activeCols, _taskInfo._activeCols , _dinfo.fullN() + (_dinfo._intercept ? 1 : 0));\n      _taskInfo._activeCols = activeCols;\n      _activeData = _dinfo.filterExpandedColumns(activeCols);\n      _taskInfo._ginfo = new GradientInfo(_taskInfo._ginfo._objVal,contractVec(_taskInfo._ginfo._gradient,activeCols));\n\n      assert  activeCols == null || _activeData.fullN() == activeCols.length : LogInfo(\"mismatched number of cols, got \" + activeCols.length + \" active cols, but data info claims \" + _activeData.fullN());\n      assert DKV.get(_activeData._key) != null;\n      solve();\n    }","id":91123,"modified_method":"@Override\n    protected void compute2() {\n      if(!isRunning(_key)) throw new JobCancelledException();\n      assert _rowFilter != null;\n      _start_time = System.currentTimeMillis();\n      LogInfo(\"lambda = \" + _parms._lambda[_lambdaId] + \"\\n\");\n      int[] activeCols = activeCols(_parms._lambda[_lambdaId], _lambdaId == 0?_taskInfo._lambdaMax:_parms._lambda[_lambdaId-1], _taskInfo._ginfo._gradient);\n      _taskInfo._activeCols = activeCols;\n      _activeData = _dinfo.filterExpandedColumns(activeCols);\n      _taskInfo._ginfo = new GradientInfo(_taskInfo._ginfo._objVal,contractVec(_taskInfo._ginfo._gradient,activeCols));\n      _taskInfo._beta = contractVec(_taskInfo._beta,activeCols);\n      assert  activeCols == null || _activeData.fullN() == activeCols.length : LogInfo(\"mismatched number of cols, got \" + activeCols.length + \" active cols, but data info claims \" + _activeData.fullN());\n      assert DKV.get(_activeData._key) != null;\n      solve();\n    }","commit_id":"3271553cf8c0119fc404dc64179d02f5cbd26832","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public LBFGS_ProximalSolver(GradientSolver gs, double [] beta, double [] rho){\n      _gSolver = gs;\n      _beta = beta;\n      _rho = rho;\n    }","id":91124,"modified_method":"public LBFGS_ProximalSolver(GradientSolver gs, double [] beta, double [] rho, Key jobKey){\n      _gSolver = gs;\n      _beta = beta;\n      _rho = rho;\n      _jobKey = jobKey;\n    }","commit_id":"3271553cf8c0119fc404dc64179d02f5cbd26832","url":"https://github.com/h2oai/h2o-3"},{"original_method":"protected void checkKKTsAndComplete() {\n      final double [] fullBeta = expandVec(_taskInfo._beta,_activeData._activeCols,_dinfo.fullN()+1);\n      addToPendingCount(1);\n      new GLMTask.GLMGradientTask(_dinfo, _parms, _parms._lambda[_lambdaId], fullBeta, 1.0 / _taskInfo._nobs, _rowFilter, new H2OCallback<GLMGradientTask>(this) {\n        @Override\n        public void callback(final GLMGradientTask gt1) {\n          double[] subgrad = gt1._gradient.clone();\n          ADMM.subgrad(_parms._alpha[0] * _parms._lambda[_lambdaId], fullBeta, subgrad);\n          double err = GLM_GRAD_EPS;\n          if (_taskInfo._activeCols != null) {\n            for (int c : _taskInfo._activeCols)\n              if (subgrad[c] > err) err = subgrad[c];\n              else if (subgrad[c] < -err) err = -subgrad[c];\n            LogInfo(\"solved with gerr = \" + err);\n            int[] failedCols = new int[64];\n            int fcnt = 0;\n            for (int i = 0; i < subgrad.length - 1; ++i) {\n              if (Arrays.binarySearch(_taskInfo._activeCols, i) >= 0) continue;\n              if (subgrad[i] > err || -subgrad[i] > err) {\n                if (fcnt == failedCols.length)\n                  failedCols = Arrays.copyOf(failedCols, failedCols.length << 1);\n                failedCols[fcnt++] = i;\n              }\n            }\n            if (fcnt > 0) {\n              final int n = _taskInfo._activeCols.length;\n              int[] newCols = Arrays.copyOf(_taskInfo._activeCols, _taskInfo._activeCols.length + fcnt);\n              for (int i = 0; i < fcnt; ++i)\n                newCols[n + i] = failedCols[i];\n              Arrays.sort(_taskInfo._activeCols);\n              _taskInfo._beta = resizeVec(gt1._beta, newCols, _taskInfo._activeCols, _dinfo.fullN() + 1);\n              _taskInfo._activeCols = newCols;\n              LogInfo(fcnt + \" variables failed KKT conditions check! Adding them to the model and continuing computation.(grad_eps = \" + err + \", activeCols = \" + (_taskInfo._activeCols.length > 100 ? \"lost\" : Arrays.toString(_taskInfo._activeCols)));\n              _activeData = _dinfo.filterExpandedColumns(_taskInfo._activeCols);\n              // NOTE: tricky completer game here:\n              // We expect 0 pending in this method since this is the end-point, ( actually it's racy, can be 1 with pending 1 decrement from the original Iteration callback, end result is 0 though)\n              // while iteration expects pending count of 1, so we need to increase it here (Iteration itself adds 1 but 1 will be subtracted when we leave this method since we're in the callback which is called by onCompletion!\n              // [unlike at the start of nextLambda call when we're not inside onCompletion]))\n              getCompleter().addToPendingCount(1);\n              solve();\n              return;\n            }\n          }\n          // got valida solution, update the state and complete\n          _taskInfo._ginfo = new GradientInfo(gt1._objVal, gt1._gradient);\n          _taskInfo._objVal = gt1._objVal + (1 - _parms._alpha[0]) * ArrayUtils.l1norm(_taskInfo._beta, _activeData._intercept);\n          // todo get validation on the validation set here\n          if (_valid != null) {\n            final H2OCountedCompleter cmp = this;\n            cmp.addToPendingCount(2);\n            assert cmp.getPendingCount() > 0;\n            // public GLMGradientTask(DataInfo dinfo, GLMParameters params, double lambda, double[] beta, double reg, H2OCountedCompleter cc){\n            new GLMTask.GLMGradientTask(_dinfo, _parms, _parms._lambda[_lambdaId], gt1._beta, 1.0 / _taskInfo._nobs, null /* no rowf filter for validation dataset */, new H2OCallback<GLMGradientTask>(cmp) {\n              @Override\n              public void callback(GLMGradientTask gt2) {\n                LogInfo(\"hold-out set validation: \\n\" + gt2._val.toString());\n                setSubmodel(_taskInfo._beta, gt1._val, gt2._val, cmp);\n                GLMSingleLambdaTsk.this.tryComplete();\n              }\n            }).setValidate(_taskInfo._ymu, true).asyncExec(_validDinfo._adaptedFrame);\n          } else {\n            setSubmodel(_taskInfo._beta, gt1._val, null, null);\n          }\n        }\n      }).setValidate(_taskInfo._ymu,true).asyncExec(_dinfo._adaptedFrame);\n    }","id":91125,"modified_method":"protected void checkKKTsAndComplete() {\n      final double [] fullBeta = expandVec(_taskInfo._beta,_activeData._activeCols,_dinfo.fullN()+1);\n      addToPendingCount(1);\n      new GLMTask.GLMGradientTask(_dinfo, _parms, _parms._lambda[_lambdaId], fullBeta, 1.0 / _taskInfo._nobs, _rowFilter, new H2OCallback<GLMGradientTask>(this) {\n        @Override\n        public void callback(final GLMGradientTask gt1) {\n          double[] subgrad = gt1._gradient.clone();\n          ADMM.subgrad(_parms._alpha[0] * _parms._lambda[_lambdaId], fullBeta, subgrad);\n          double err = GLM_GRAD_EPS;\n          if (_taskInfo._activeCols != null) {\n            for (int c : _taskInfo._activeCols)\n              if (subgrad[c] > err) err = subgrad[c];\n              else if (subgrad[c] < -err) err = -subgrad[c];\n            LogInfo(\"solved with gerr = \" + err);\n            int[] failedCols = new int[64];\n            int fcnt = 0;\n            for (int i = 0; i < subgrad.length - 1; ++i) {\n              if (Arrays.binarySearch(_taskInfo._activeCols, i) >= 0) continue;\n              if (subgrad[i] > err || -subgrad[i] > err) {\n                if (fcnt == failedCols.length)\n                  failedCols = Arrays.copyOf(failedCols, failedCols.length << 1);\n                failedCols[fcnt++] = i;\n              }\n            }\n            if (fcnt > 0) {\n              final int n = _taskInfo._activeCols.length;\n              int[] newCols = Arrays.copyOf(_taskInfo._activeCols, _taskInfo._activeCols.length + fcnt);\n              for (int i = 0; i < fcnt; ++i)\n                newCols[n + i] = failedCols[i];\n              Arrays.sort(_taskInfo._activeCols);\n              _taskInfo._beta = resizeVec(gt1._beta, newCols, _taskInfo._activeCols, _dinfo.fullN() + 1);\n              _taskInfo._activeCols = newCols;\n              LogInfo(fcnt + \" variables failed KKT conditions check! Adding them to the model and continuing computation.(grad_eps = \" + err + \", activeCols = \" + (_taskInfo._activeCols.length > 100 ? \"lost\" : Arrays.toString(_taskInfo._activeCols)));\n              _activeData = _dinfo.filterExpandedColumns(_taskInfo._activeCols);\n              // NOTE: tricky completer game here:\n              // We expect 0 pending in this method since this is the end-point, ( actually it's racy, can be 1 with pending 1 decrement from the original Iteration callback, end result is 0 though)\n              // while iteration expects pending count of 1, so we need to increase it here (Iteration itself adds 1 but 1 will be subtracted when we leave this method since we're in the callback which is called by onCompletion!\n              // [unlike at the start of nextLambda call when we're not inside onCompletion]))\n              getCompleter().addToPendingCount(1);\n              solve();\n              return;\n            }\n          }\n          if (_valid != null) {\n            GLMSingleLambdaTsk.this.addToPendingCount(1);\n            // public GLMGradientTask(DataInfo dinfo, GLMParameters params, double lambda, double[] beta, double reg, H2OCountedCompleter cc){\n            new GLMTask.GLMGradientTask(_dinfo, _parms, _parms._lambda[_lambdaId], gt1._beta, 1.0 / _taskInfo._nobs, null /* no rowf filter for validation dataset */, new H2OCallback<GLMGradientTask>(GLMSingleLambdaTsk.this) {\n              @Override\n              public void callback(GLMGradientTask gt2) {\n                LogInfo(\"hold-out set validation: \\n\" + gt2._val.toString());\n                setSubmodel(_taskInfo._beta, gt1._val, gt2._val, GLMSingleLambdaTsk.this);\n              }\n            }).setValidate(_taskInfo._ymu, true).asyncExec(_validDinfo._adaptedFrame);\n          } else {\n            setSubmodel(_taskInfo._beta, gt1._val, null, null);\n          }\n          // got valida solution, update the state and complete\n          _taskInfo._ginfo = new GradientInfo(gt1._objVal, gt1._gradient);\n          assert _taskInfo._ginfo._gradient.length == _dinfo.fullN() + (_dinfo._intercept?1:0);\n          _taskInfo._objVal = gt1._objVal + (1 - _parms._alpha[0]) * ArrayUtils.l1norm(_taskInfo._beta, _activeData._intercept);\n          _taskInfo._beta = fullBeta;\n        }\n      }).setValidate(_taskInfo._ymu,true).asyncExec(_dinfo._adaptedFrame);\n    }","commit_id":"3271553cf8c0119fc404dc64179d02f5cbd26832","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public void init(boolean expensive) {\n    super.init(expensive);\n    _parms.validate(this);\n    if (expensive) {\n      if (_parms._link == Link.family_default)\n        _parms._link = _parms._family.defaultLink;\n      _dinfo = new DataInfo(Key.make(), _train, _valid, 1, _parms._use_all_factor_levels || _parms._lambda_search, _parms._standardize ? DataInfo.TransformType.STANDARDIZE : DataInfo.TransformType.NONE, DataInfo.TransformType.NONE, true);\n      DKV.put(_dinfo._key, _dinfo);\n      // handle BetaConstraints if I got them\n      double[] betaStart = null;\n      double[] betaGiven = null;\n      double[] betaLB = null;\n      double[] betaUB = null;\n      double[] rho = null;\n      if (_parms._beta_constraint != null) {\n        Frame beta_constraints = _parms._beta_constraint.get();\n        Vec v = beta_constraints.vec(\"names\");\n        String[] dom;\n        int[] map;\n        if (v.isString()) {\n          dom = new String[(int) v.length()];\n          map = new int[dom.length];\n          ValueString vs = new ValueString();\n          for (int i = 0; i < dom.length; ++i) {\n            dom[i] = v.atStr(vs, i).toString();\n            map[i] = i;\n          }\n        } else if (v.isEnum()) {\n          dom = v.domain();\n          map = FrameUtils.asInts(v);\n        } else\n          throw new IllegalArgumentException(\"Illegal beta constraints file, names column expected to contain column names (strings)\");\n        // for now only enums allowed here\n        String[] names = ArrayUtils.append(_dinfo.coefNames(), \"Intercept\");\n        if (!Arrays.deepEquals(dom, names)) { // need mapping\n          HashMap<String, Integer> m = new HashMap<String, Integer>();\n          for (int i = 0; i < names.length; ++i)\n            m.put(names[i], i);\n          int[] newMap = MemoryManager.malloc4(dom.length);\n          for (int i = 0; i < map.length; ++i) {\n            Integer I = m.get(dom[map[i]]);\n            if (I == null)\n              throw new IllegalArgumentException(\"Unrecognized coefficient name in beta-constraint file, unknown name '\" + dom[map[i]] + \"'\");\n            newMap[i] = I == null ? -1 : I;\n          }\n          map = newMap;\n        }\n        final int numoff = _dinfo.numStart();\n        if ((v = beta_constraints.vec(\"beta_start\")) != null) {\n          betaStart = MemoryManager.malloc8d(_dinfo.fullN() + (_dinfo._intercept ? 1 : 0));\n          for (int i = 0; i < (int) v.length(); ++i)\n            betaStart[map == null ? i : map[i]] = v.at(i);\n        }\n        if ((v = beta_constraints.vec(\"beta_given\")) != null) {\n          betaGiven = MemoryManager.malloc8d(_dinfo.fullN() + (_dinfo._intercept ? 1 : 0));\n          for (int i = 0; i < (int) v.length(); ++i)\n            betaGiven[map == null ? i : map[i]] = v.at(i);\n          if (betaStart == null)\n            betaStart = betaGiven;\n        }\n        if ((v = beta_constraints.vec(\"upper_bounds\")) != null) {\n          betaUB = MemoryManager.malloc8d(_dinfo.fullN() + (_dinfo._intercept ? 1 : 0));\n          Arrays.fill(betaUB, Double.POSITIVE_INFINITY);\n          for (int i = 0; i < (int) v.length(); ++i)\n            betaUB[map == null ? i : map[i]] = v.at(i);\n        }\n        if ((v = beta_constraints.vec(\"lower_bounds\")) != null) {\n          betaLB = MemoryManager.malloc8d(_dinfo.fullN() + (_dinfo._intercept ? 1 : 0));\n          Arrays.fill(betaLB, Double.NEGATIVE_INFINITY);\n          for (int i = 0; i < (int) v.length(); ++i)\n            betaLB[map == null ? i : map[i]] = v.at(i);\n        }\n        if ((v = beta_constraints.vec(\"rho\")) != null) {\n          rho = MemoryManager.malloc8d(_dinfo.fullN() + (_dinfo._intercept ? 1 : 0));\n          for (int i = 0; i < (int) v.length(); ++i)\n            rho[map == null ? i : map[i]] = v.at(i);\n        }\n        if (_dinfo._normMul != null) {\n          double normG = 0, normS = 0;\n          for (int i = numoff; i < _dinfo.fullN(); ++i) {\n            double dd = _dinfo._normMul[i - numoff];\n            double d = 1.0 / dd;\n            if (betaUB != null && !Double.isInfinite(betaUB[i]))\n              betaUB[i] *= d;\n            if (betaLB != null && !Double.isInfinite(betaUB[i]))\n              betaLB[i] *= d;\n            if (betaGiven != null) {\n              normG += betaGiven[i] * dd;\n              betaGiven[i] *= d;\n            }\n            if (betaStart != null) {\n              normS += betaStart[i] * dd;\n              betaStart[i] *= d;\n            }\n          }\n          if (_dinfo._intercept) {\n            int n = _dinfo.fullN();\n            if (betaGiven != null)\n              betaGiven[n] -= normG;\n            if (betaStart != null)\n              betaStart[n] -= normS;\n          }\n        }\n        _bc.setBetaStart(betaStart).setLowerBounds(betaLB).setUpperBounds(betaUB).setProximalPenalty(betaGiven, rho);\n      }\n      _tInfos = new GLMTaskInfo[_parms._n_folds + 1];\n      InitTsk itsk = new InitTsk(0, _dinfo._intercept, null);\n      H2O.submitTask(itsk).join();\n      assert itsk._ymut._nobs == itsk._gtNull._nobs:\"unexpected nobs, \" + itsk._ymut._nobs + \" != \" + itsk._gtNull._nobs +\", filterVec = \" + (itsk._gtNull._rowFilter != null) + \", nrows = \" + itsk._gtNull._rowFilter.length() + \", mean = \" + itsk._gtNull._rowFilter.mean();\n      _rowFilter = itsk._ymut._fVec;\n      assert _rowFilter.nChunks() == _dinfo._adaptedFrame.anyVec().nChunks();\n      assert (_dinfo._adaptedFrame.numRows() - _rowFilter.mean() * _rowFilter.length()) == itsk._ymut._nobs:\"unexpected nobs, expected \" + itsk._ymut._nobs + \", but got \" + _rowFilter.mean() * _rowFilter.length();\n      assert _rowFilter != null;\n      if (itsk._ymut._nobs == 0) // can happen if all rows have missing value and we're filtering missing out\n        error(\"training_frame\", \"Got no data to run on after filtering out the rows with missing values.\");\n      if (itsk._ymut._yMin == itsk._ymut._yMax)\n        error(\"response\", \"Can not run glm on dataset with constant response. Response == \" + itsk._ymut._yMin + \" for all rows in the dataset after filtering out rows with NAs, got \" + itsk._ymut._nobs + \" of rows out of \" + _dinfo._adaptedFrame.numRows() + \" rows total.\");\n      if (itsk._ymut._nobs < (_dinfo._adaptedFrame.numRows() >> 1)) { // running less than half of rows?\n        warn(\"training_frame\", \"Dataset has less than 1/2 of the data after filtering out rows with NAs\");\n      }\n      // GLMTaskInfo(Key dstKey, int foldId, long nobs, double ymu, double lmax, double[] beta, GradientInfo ginfo, double objVal){\n      GLMGradientTask gtBetastart = itsk._gtBetaStart != null?itsk._gtBetaStart:itsk._gtNull;\n      double lmax =  lmax(itsk._gtNull);\n      double l1pen = _parms._alpha[0] * lmax * ArrayUtils.l1norm(_bc._betaStart, _dinfo._intercept);\n      _tInfos[0] = new GLMTaskInfo(_dest, 0, itsk._ymut._nobs, itsk._ymut._ymu,lmax,_bc._betaStart, new GradientInfo(gtBetastart._objVal,gtBetastart._gradient),gtBetastart._objVal + l1pen);\n      if (_parms._lambda != null) { // check the lambdas\n        ArrayUtils.mult(_parms._lambda, -1);\n        Arrays.sort(_parms._lambda);\n        ArrayUtils.mult(_parms._lambda, -1);\n        int i = 0;\n        while (i < _parms._lambda.length && _parms._lambda[i] > _tInfos[0]._lambdaMax) ++i;\n        if (i == _parms._lambda.length)\n          error(\"lambda\", \"All passed lambda values are > lambda_max = \" + _tInfos[0]._lambdaMax + \", nothing to compute.\");\n        if (i > 0) {\n          _parms._lambda = Arrays.copyOfRange(_parms._lambda, i, _parms._lambda.length);\n          warn(\"lambda\", \"removed \" + i + \" lambda values which were greater than lambda_max = \" + _tInfos[0]._lambdaMax);\n        }\n      } else { // fill in the default lambda(s)\n        if (_parms._lambda_search) {\n          if (_parms._nlambdas == 1)\n            error(\"nlambdas\", \"Number of lambdas must be > 1 when running with lambda_search!\");\n          if (_parms._lambda_min_ratio == -1)\n            _parms._lambda_min_ratio = _tInfos[0]._nobs > 25 * _dinfo.fullN() ? 1e-4 : 1e-2;\n          final double d = Math.pow(_parms._lambda_min_ratio, 1.0 / (_parms._nlambdas - 1));\n          _parms._lambda = MemoryManager.malloc8d(_parms._nlambdas);\n          _parms._lambda[0] = _tInfos[0]._lambdaMax;\n          for (int i = 1; i < _parms._lambda.length; ++i)\n            _parms._lambda[i] = _parms._lambda[i - 1] * d;\n        } else\n          _parms._lambda = new double[]{_tInfos[0]._lambdaMax * (_dinfo.fullN() < (_tInfos[0]._nobs >> 4) ? 1e-3 : 1e-1)};\n      }\n      GLMModel m = new GLMModel(_dest, _parms, new GLMOutput(GLM.this), _dinfo, _tInfos[0]._ymu, _tInfos[0]._lambdaMax, _tInfos[0]._nobs);\n      m.delete_and_lock(GLM.this._key);\n      m.adaptTestForTrain(_valid,true);\n      // _dinfo = new DataInfo(Key.make(), _train, _valid, 1, _parms._use_all_factor_levels || _parms._lambda_search, _parms._standardize ? DataInfo.TransformType.STANDARDIZE : DataInfo.TransformType.NONE, DataInfo.TransformType.NONE, true);\n      if(_valid != null)\n        _validDinfo = new DataInfo(Key.make(), _valid, null, 1, _parms._use_all_factor_levels || _parms._lambda_search, _parms._standardize ? DataInfo.TransformType.STANDARDIZE : DataInfo.TransformType.NONE, DataInfo.TransformType.NONE, true);\n      if(_parms._lambda_search) // todo add xval/hval for null model?\n        setSubmodel(_dest,0,_bc._betaStart,gtBetastart._val,null,null);\n      if(_parms._max_iter == -1)\n        _parms._max_iter = _parms._lambda_search?6*_parms._nlambdas:50;\n      if(_parms._solver == Solver.COORDINATE_DESCENT) { // make needed vecs\n        double eta = _parms.link(_tInfos[0]._ymu);\n        _tInfos[0]._eVec = _dinfo._adaptedFrame.anyVec().makeCon(eta);\n        _tInfos[0]._wVec = _dinfo._adaptedFrame.anyVec().makeCon(1);\n        _tInfos[0]._zVec = _dinfo._adaptedFrame.lastVec().makeCopy(null);\n        _tInfos[0]._iVec = _dinfo._adaptedFrame.anyVec().makeCon(1);\n      }\n    }\n  }","id":91126,"modified_method":"@Override public void init(boolean expensive) {\n    super.init(expensive);\n    _parms.validate(this);\n    if (expensive) {\n      if (_parms._link == Link.family_default)\n        _parms._link = _parms._family.defaultLink;\n      _dinfo = new DataInfo(Key.make(), _train, _valid, 1, _parms._use_all_factor_levels || _parms._lambda_search, _parms._standardize ? DataInfo.TransformType.STANDARDIZE : DataInfo.TransformType.NONE, DataInfo.TransformType.NONE, true);\n      DKV.put(_dinfo._key, _dinfo);\n      // handle BetaConstraints if I got them\n      double[] betaStart = null;\n      double[] betaGiven = null;\n      double[] betaLB = null;\n      double[] betaUB = null;\n      double[] rho = null;\n      if (_parms._beta_constraint != null) {\n        Frame beta_constraints = _parms._beta_constraint.get();\n        Vec v = beta_constraints.vec(\"names\");\n        String[] dom;\n        int[] map;\n        if (v.isString()) {\n          dom = new String[(int) v.length()];\n          map = new int[dom.length];\n          ValueString vs = new ValueString();\n          for (int i = 0; i < dom.length; ++i) {\n            dom[i] = v.atStr(vs, i).toString();\n            map[i] = i;\n          }\n        } else if (v.isEnum()) {\n          dom = v.domain();\n          map = FrameUtils.asInts(v);\n        } else\n          throw new IllegalArgumentException(\"Illegal beta constraints file, names column expected to contain column names (strings)\");\n        // for now only enums allowed here\n        String[] names = ArrayUtils.append(_dinfo.coefNames(), \"Intercept\");\n        if (!Arrays.deepEquals(dom, names)) { // need mapping\n          HashMap<String, Integer> m = new HashMap<String, Integer>();\n          for (int i = 0; i < names.length; ++i)\n            m.put(names[i], i);\n          int[] newMap = MemoryManager.malloc4(dom.length);\n          for (int i = 0; i < map.length; ++i) {\n            Integer I = m.get(dom[map[i]]);\n            if (I == null)\n              throw new IllegalArgumentException(\"Unrecognized coefficient name in beta-constraint file, unknown name '\" + dom[map[i]] + \"'\");\n            newMap[i] = I == null ? -1 : I;\n          }\n          map = newMap;\n        }\n        final int numoff = _dinfo.numStart();\n        if ((v = beta_constraints.vec(\"beta_start\")) != null) {\n          betaStart = MemoryManager.malloc8d(_dinfo.fullN() + (_dinfo._intercept ? 1 : 0));\n          for (int i = 0; i < (int) v.length(); ++i)\n            betaStart[map == null ? i : map[i]] = v.at(i);\n        }\n        if ((v = beta_constraints.vec(\"beta_given\")) != null) {\n          betaGiven = MemoryManager.malloc8d(_dinfo.fullN() + (_dinfo._intercept ? 1 : 0));\n          for (int i = 0; i < (int) v.length(); ++i)\n            betaGiven[map == null ? i : map[i]] = v.at(i);\n          if (betaStart == null)\n            betaStart = betaGiven;\n        }\n        if ((v = beta_constraints.vec(\"upper_bounds\")) != null) {\n          betaUB = MemoryManager.malloc8d(_dinfo.fullN() + (_dinfo._intercept ? 1 : 0));\n          Arrays.fill(betaUB, Double.POSITIVE_INFINITY);\n          for (int i = 0; i < (int) v.length(); ++i)\n            betaUB[map == null ? i : map[i]] = v.at(i);\n        }\n        if ((v = beta_constraints.vec(\"lower_bounds\")) != null) {\n          betaLB = MemoryManager.malloc8d(_dinfo.fullN() + (_dinfo._intercept ? 1 : 0));\n          Arrays.fill(betaLB, Double.NEGATIVE_INFINITY);\n          for (int i = 0; i < (int) v.length(); ++i)\n            betaLB[map == null ? i : map[i]] = v.at(i);\n        }\n        if ((v = beta_constraints.vec(\"rho\")) != null) {\n          rho = MemoryManager.malloc8d(_dinfo.fullN() + (_dinfo._intercept ? 1 : 0));\n          for (int i = 0; i < (int) v.length(); ++i)\n            rho[map == null ? i : map[i]] = v.at(i);\n        }\n        if (_dinfo._normMul != null) {\n          double normG = 0, normS = 0;\n          for (int i = numoff; i < _dinfo.fullN(); ++i) {\n            double dd = _dinfo._normMul[i - numoff];\n            double d = 1.0 / dd;\n            if (betaUB != null && !Double.isInfinite(betaUB[i]))\n              betaUB[i] *= d;\n            if (betaLB != null && !Double.isInfinite(betaUB[i]))\n              betaLB[i] *= d;\n            if (betaGiven != null) {\n              normG += betaGiven[i] * dd;\n              betaGiven[i] *= d;\n            }\n            if (betaStart != null) {\n              normS += betaStart[i] * dd;\n              betaStart[i] *= d;\n            }\n          }\n          if (_dinfo._intercept) {\n            int n = _dinfo.fullN();\n            if (betaGiven != null)\n              betaGiven[n] -= normG;\n            if (betaStart != null)\n              betaStart[n] -= normS;\n          }\n        }\n        _bc.setBetaStart(betaStart).setLowerBounds(betaLB).setUpperBounds(betaUB).setProximalPenalty(betaGiven, rho);\n      }\n      _tInfos = new GLMTaskInfo[_parms._n_folds + 1];\n      InitTsk itsk = new InitTsk(0, _dinfo._intercept, null);\n      H2O.submitTask(itsk).join();\n      assert itsk._ymut._nobs == itsk._gtNull._nobs:\"unexpected nobs, \" + itsk._ymut._nobs + \" != \" + itsk._gtNull._nobs +\", filterVec = \" + (itsk._gtNull._rowFilter != null) + \", nrows = \" + itsk._gtNull._rowFilter.length() + \", mean = \" + itsk._gtNull._rowFilter.mean();\n      _rowFilter = itsk._ymut._fVec;\n      assert _rowFilter.nChunks() == _dinfo._adaptedFrame.anyVec().nChunks();\n      assert (_dinfo._adaptedFrame.numRows() - _rowFilter.mean() * _rowFilter.length()) == itsk._ymut._nobs:\"unexpected nobs, expected \" + itsk._ymut._nobs + \", but got \" + _rowFilter.mean() * _rowFilter.length();\n      assert _rowFilter != null;\n      if (itsk._ymut._nobs == 0) // can happen if all rows have missing value and we're filtering missing out\n        error(\"training_frame\", \"Got no data to run on after filtering out the rows with missing values.\");\n      if (itsk._ymut._yMin == itsk._ymut._yMax)\n        error(\"response\", \"Can not run glm on dataset with constant response. Response == \" + itsk._ymut._yMin + \" for all rows in the dataset after filtering out rows with NAs, got \" + itsk._ymut._nobs + \" of rows out of \" + _dinfo._adaptedFrame.numRows() + \" rows total.\");\n      if (itsk._ymut._nobs < (_dinfo._adaptedFrame.numRows() >> 1)) { // running less than half of rows?\n        warn(\"training_frame\", \"Dataset has less than 1/2 of the data after filtering out rows with NAs\");\n      }\n      // GLMTaskInfo(Key dstKey, int foldId, long nobs, double ymu, double lmax, double[] beta, GradientInfo ginfo, double objVal){\n      GLMGradientTask gtBetastart = itsk._gtBetaStart != null?itsk._gtBetaStart:itsk._gtNull;\n      double lmax =  lmax(itsk._gtNull);\n      double l1pen = _parms._alpha[0] * lmax * ArrayUtils.l1norm(_bc._betaStart, _dinfo._intercept);\n      _tInfos[0] = new GLMTaskInfo(_dest, 0, itsk._ymut._nobs, itsk._ymut._ymu,lmax,_bc._betaStart, _dinfo.fullN() + (_dinfo._intercept?1:0),new GradientInfo(gtBetastart._objVal,gtBetastart._gradient),gtBetastart._objVal + l1pen);\n      if (_parms._lambda != null) { // check the lambdas\n        ArrayUtils.mult(_parms._lambda, -1);\n        Arrays.sort(_parms._lambda);\n        ArrayUtils.mult(_parms._lambda, -1);\n        int i = 0;\n        while (i < _parms._lambda.length && _parms._lambda[i] > _tInfos[0]._lambdaMax) ++i;\n        if (i == _parms._lambda.length)\n          error(\"lambda\", \"All passed lambda values are > lambda_max = \" + _tInfos[0]._lambdaMax + \", nothing to compute.\");\n        if (i > 0) {\n          _parms._lambda = Arrays.copyOfRange(_parms._lambda, i, _parms._lambda.length);\n          warn(\"lambda\", \"removed \" + i + \" lambda values which were greater than lambda_max = \" + _tInfos[0]._lambdaMax);\n        }\n      } else { // fill in the default lambda(s)\n        if (_parms._lambda_search) {\n          if (_parms._nlambdas == 1)\n            error(\"nlambdas\", \"Number of lambdas must be > 1 when running with lambda_search!\");\n          if (_parms._lambda_min_ratio == -1)\n            _parms._lambda_min_ratio = _tInfos[0]._nobs > 25 * _dinfo.fullN() ? 1e-4 : 1e-2;\n          final double d = Math.pow(_parms._lambda_min_ratio, 1.0 / (_parms._nlambdas - 1));\n          _parms._lambda = MemoryManager.malloc8d(_parms._nlambdas);\n          _parms._lambda[0] = _tInfos[0]._lambdaMax;\n          for (int i = 1; i < _parms._lambda.length; ++i)\n            _parms._lambda[i] = _parms._lambda[i - 1] * d;\n        } else\n          _parms._lambda = new double[]{_tInfos[0]._lambdaMax * (_dinfo.fullN() < (_tInfos[0]._nobs >> 4) ? 1e-3 : 1e-1)};\n      }\n      GLMModel m = new GLMModel(_dest, _parms, new GLMOutput(GLM.this), _dinfo, _tInfos[0]._ymu, _tInfos[0]._lambdaMax, _tInfos[0]._nobs);\n      m.delete_and_lock(GLM.this._key);\n      m.adaptTestForTrain(_valid,true);\n      // _dinfo = new DataInfo(Key.make(), _train, _valid, 1, _parms._use_all_factor_levels || _parms._lambda_search, _parms._standardize ? DataInfo.TransformType.STANDARDIZE : DataInfo.TransformType.NONE, DataInfo.TransformType.NONE, true);\n      if(_valid != null)\n        _validDinfo = new DataInfo(Key.make(), _valid, null, 1, _parms._use_all_factor_levels || _parms._lambda_search, _parms._standardize ? DataInfo.TransformType.STANDARDIZE : DataInfo.TransformType.NONE, DataInfo.TransformType.NONE, true);\n      if(_parms._lambda_search) // todo add xval/hval for null model?\n        setSubmodel(_dest,0,_bc._betaStart,gtBetastart._val,null,null);\n      if(_parms._max_iter == -1)\n        _parms._max_iter = _parms._lambda_search?6*_parms._nlambdas:50;\n      if(_parms._solver == Solver.COORDINATE_DESCENT) { // make needed vecs\n        double eta = _parms.link(_tInfos[0]._ymu);\n        _tInfos[0]._eVec = _dinfo._adaptedFrame.anyVec().makeCon(eta);\n        _tInfos[0]._wVec = _dinfo._adaptedFrame.anyVec().makeCon(1);\n        _tInfos[0]._zVec = _dinfo._adaptedFrame.lastVec().makeCopy(null);\n        _tInfos[0]._iVec = _dinfo._adaptedFrame.anyVec().makeCon(1);\n      }\n    }\n  }","commit_id":"3271553cf8c0119fc404dc64179d02f5cbd26832","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n      public void callback(H2OCountedCompleter h2OCountedCompleter) {\n        Log.info(\"Gradient err at lambda = \" + _parms._lambda[_lambdaId] + \" = \" + _tInfos[0].gradientCheck(_parms._lambda[_lambdaId], _parms._alpha[0]));\n        int rank = 0;\n        for(int i = 0; i < _tInfos[0]._beta.length - (_dinfo._intercept?1:0); ++i)\n          if(_tInfos[0]._beta[i] != 0) ++rank;\n        Log.info(\"Solution at lambda = \" + _parms._lambda[_lambdaId] + \"has \" + rank + \" nonzeros\");\n        if(_parms._n_folds > 1){\n          // copy the state over\n          ParallelTasks<GLMSingleLambdaTsk> t = (ParallelTasks<GLMSingleLambdaTsk>)h2OCountedCompleter;\n          for(int i = 0; i < t._tasks.length; ++i)\n            _tInfos[i] = t._tasks[i]._taskInfo;\n          // launch xval-task to compute validations of xval models\n          // getCompleter().addToPendingCount(1);\n          // TODO ...\n        }\n        // launch the next lambda\n        if(++_lambdaId  < _parms._lambda.length && _tInfos[0]._iter < _parms._max_iter) {\n          getCompleter().addToPendingCount(1);\n          if(_parms._n_folds > 1){\n            GLMSingleLambdaTsk[] tasks = new GLMSingleLambdaTsk[_tInfos.length];\n            H2OCountedCompleter cmp = new LambdaSearchIteration((H2OCountedCompleter)getCompleter());\n            cmp.addToPendingCount(tasks.length-1);\n            for(int i = 0; i < tasks.length; ++i)\n              tasks[i] = new GLMSingleLambdaTsk(cmp,_tInfos[i]);\n            new ParallelTasks(new LambdaSearchIteration((H2OCountedCompleter)getCompleter()),tasks).fork();\n          } else {\n            do {\n              double currentLambda = _parms._lambda[_lambdaId-1];\n              double nextLambda = _parms._lambda[_lambdaId];\n              _tInfos[0].adjustToNewLambda(currentLambda, nextLambda, _parms._alpha[0], _dinfo._intercept);\n            } while((_tInfos[0].gradientCheck(_parms._lambda[_lambdaId],_parms._alpha[0]) < GLM_GRAD_EPS) && ++_lambdaId  < (_parms._lambda.length-1));\n            Log.info(\"GLM next lambdaId = \" + _lambdaId);\n            new GLMSingleLambdaTsk(new LambdaSearchIteration((H2OCountedCompleter) getCompleter()),  _tInfos[0]).fork();\n          }\n        }\n      }","id":91127,"modified_method":"@Override\n      public void callback(H2OCountedCompleter h2OCountedCompleter) {\n        assert _tInfos[0]._ginfo._gradient.length == _dinfo.fullN()+(_dinfo._intercept?1:0);\n        Log.info(\"Gradient err at lambda = \" + _parms._lambda[_lambdaId] + \" = \" + _tInfos[0].gradientCheck(_parms._lambda[_lambdaId], _parms._alpha[0]));\n        int rank = 0;\n        for(int i = 0; i < _tInfos[0]._beta.length - (_dinfo._intercept?1:0); ++i)\n          if(_tInfos[0]._beta[i] != 0) ++rank;\n        Log.info(\"Solution at lambda = \" + _parms._lambda[_lambdaId] + \"has \" + rank + \" nonzeros\");\n        if(_parms._n_folds > 1){\n          // copy the state over\n          ParallelTasks<GLMSingleLambdaTsk> t = (ParallelTasks<GLMSingleLambdaTsk>)h2OCountedCompleter;\n          for(int i = 0; i < t._tasks.length; ++i)\n            _tInfos[i] = t._tasks[i]._taskInfo;\n          // launch xval-task to compute validations of xval models\n          // getCompleter().addToPendingCount(1);\n          // TODO ...\n        }\n        // launch the next lambda\n        if(++_lambdaId  < _parms._lambda.length && _tInfos[0]._iter < _parms._max_iter) {\n          getCompleter().addToPendingCount(1);\n          if(_parms._n_folds > 1){\n            GLMSingleLambdaTsk[] tasks = new GLMSingleLambdaTsk[_tInfos.length];\n            H2OCountedCompleter cmp = new LambdaSearchIteration((H2OCountedCompleter)getCompleter());\n            cmp.addToPendingCount(tasks.length-1);\n            for(int i = 0; i < tasks.length; ++i)\n              tasks[i] = new GLMSingleLambdaTsk(cmp,_tInfos[i]);\n            new ParallelTasks(new LambdaSearchIteration((H2OCountedCompleter)getCompleter()),tasks).fork();\n          } else {\n            do {\n              double currentLambda = _parms._lambda[_lambdaId-1];\n              double nextLambda = _parms._lambda[_lambdaId];\n              _tInfos[0].adjustToNewLambda(currentLambda, nextLambda, _parms._alpha[0], _dinfo._intercept);\n            } while((_tInfos[0].gradientCheck(_parms._lambda[_lambdaId],_parms._alpha[0]) < GLM_GRAD_EPS) && ++_lambdaId  < (_parms._lambda.length-1));\n            Log.info(\"GLM next lambdaId = \" + _lambdaId);\n            assert _tInfos[0]._ginfo._gradient.length == _dinfo.fullN()+(_dinfo._intercept?1:0);\n            new GLMSingleLambdaTsk(new LambdaSearchIteration((H2OCountedCompleter) getCompleter()),  _tInfos[0]).fork();\n          }\n        }\n      }","commit_id":"3271553cf8c0119fc404dc64179d02f5cbd26832","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n    public void solve(double[] beta_given, double[] result) {\n      ProximalGradientSolver s = new ProximalGradientSolver(_gSolver,beta_given,_rho);\n      if(_beta_given == null)\n        _beta_given = MemoryManager.malloc8d(beta_given.length);\n      if(_ginfo != null) { // update the gradient\n        for(int i = 0; i < beta_given.length; ++i) {\n          _ginfo._gradient[i] += _rho[i] * (_beta_given[i] - beta_given[i]);\n          _ginfo._objVal += .5 * _rho[i] *  (((result[i] - beta_given[i]) * (result[i] - beta_given[i])) -( (result[i] - _beta_given[i]) * (result[i] - _beta_given[i])));\n          _beta_given[i] = beta_given[i];\n        }\n      }\n\n      L_BFGS.Result r  = _ginfo == null\n        ? new L_BFGS().solve(s,result.clone())\n        : new L_BFGS().solve(s,result.clone(),_ginfo,new ProgressMonitor());\n//      L_BFGS.Result r  = new L_BFGS().solve(s,result.clone());\n      _ginfo = r.ginfo;\n      _beta = r.coefs;\n      _gradient = r.ginfo._gradient;\n      _iter += r.iter;\n      System.arraycopy(_beta,0,result,0,_beta.length);\n    }","id":91128,"modified_method":"@Override\n    public void solve(double[] beta_given, double[] result) {\n      if(_jobKey != null && !Job.isRunning(_jobKey))\n        throw new JobCancelledException();\n      ProximalGradientSolver s = new ProximalGradientSolver(_gSolver,beta_given,_rho);\n      if(_beta_given == null)\n        _beta_given = MemoryManager.malloc8d(beta_given.length);\n      if(_ginfo != null) { // update the gradient\n        for(int i = 0; i < beta_given.length; ++i) {\n          _ginfo._gradient[i] += _rho[i] * (_beta_given[i] - beta_given[i]);\n          _ginfo._objVal += .5 * _rho[i] *  (((result[i] - beta_given[i]) * (result[i] - beta_given[i])) -( (result[i] - _beta_given[i]) * (result[i] - _beta_given[i])));\n          _beta_given[i] = beta_given[i];\n        }\n      } else _ginfo = s.getGradient(result);\n\n      L_BFGS.Result r  = new L_BFGS().solve(s,result.clone(),_ginfo,new ProgressMonitor(){\n          public boolean progress(double [] beta, GradientInfo ginfo){return _jobKey == null || Job.isRunning(_jobKey);}\n      });\n      _ginfo = r.ginfo;\n      _beta = r.coefs;\n      _gradient = r.ginfo._gradient;\n      _iter += r.iter;\n      System.arraycopy(_beta,0,result,0,_beta.length);\n    }","commit_id":"3271553cf8c0119fc404dc64179d02f5cbd26832","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public GLMTaskInfo(Key dstKey, int foldId, long nobs, double ymu, double lmax, double[] beta, GradientInfo ginfo, double objVal){\n      _dstKey = dstKey;\n      _foldId = foldId;\n      _nobs = nobs;\n      _ymu = ymu;\n      _lambdaMax = lmax;\n      _beta = beta;\n      _ginfo = ginfo;\n      _objVal = objVal;\n    }","id":91129,"modified_method":"public GLMTaskInfo(Key dstKey, int foldId, long nobs, double ymu, double lmax, double[] beta, int fullN, GradientInfo ginfo, double objVal){\n      _dstKey = dstKey;\n      _foldId = foldId;\n      _nobs = nobs;\n      _ymu = ymu;\n      _lambdaMax = lmax;\n      _beta = beta;\n      _ginfo = ginfo;\n      _objVal = objVal;\n      _fullN = fullN;\n    }","commit_id":"3271553cf8c0119fc404dc64179d02f5cbd26832","url":"https://github.com/h2oai/h2o-3"},{"original_method":"protected void solve(){\n      if (_activeData.fullN() > _parms._max_active_predictors)\n        throw new TooManyPredictorsException();\n      switch(_parms._solver) {\n        case L_BFGS: {\n          double[] beta = _taskInfo._beta;\n          assert beta.length == _activeData.fullN()+1;\n          GradientSolver solver = new GLMGradientSolver(_parms, _activeData, _parms._lambda[_lambdaId] * (1 - _parms._alpha[0]), _taskInfo._ymu, _taskInfo._nobs, _rowFilter);\n          if(_bc._betaGiven != null && _bc._rho != null)\n            solver = new ProximalGradientSolver(solver,_bc._betaGiven,_bc._rho);\n          if (beta == null) {\n            beta = MemoryManager.malloc8d(_activeData.fullN() + (_activeData._intercept ? 1 : 0));\n            if (_activeData._intercept)\n              beta[beta.length - 1] = _parms.link(_taskInfo._ymu);\n          }\n          L_BFGS lbfgs = new L_BFGS().setMaxIter(_parms._max_iter);\n          assert beta.length == _taskInfo._ginfo._gradient.length;\n          double l1pen = _parms._lambda[_lambdaId] * _parms._alpha[0];\n          if(l1pen > 0 || _bc.hasBounds()) {\n            // compute gradient at null beta to get estimate for rho\n            double [] nullBeta = MemoryManager.malloc8d(_taskInfo._beta.length);\n            if(_dinfo._intercept)\n              nullBeta[nullBeta.length-1] = _parms.link(_taskInfo._ymu);\n            double [] g = solver.getGradient(nullBeta)._gradient;\n            double [] rho = MemoryManager.malloc8d(beta.length);\n            // compute rhos\n            double avg = 0;\n            for(int i = 0; i < rho.length - (_dinfo._intercept?1:0); ++i)\n              avg += rho[i] = ADMM.L1Solver.estimateRho(-g[i], l1pen);\n//            avg /= rho.length - (_dinfo._intercept?1:0);\n//            for(int i = 0; i < rho.length - (_dinfo._intercept?1:0); ++i)\n//              rho[i] = Math.max(Math.min(rho[i],1.5*avg),0.5*avg);\n            new ADMM.L1Solver(1e-4, 1000).solve(new LBFGS_ProximalSolver(solver,_taskInfo._beta,rho), _taskInfo._beta, l1pen);\n          } else {\n            Result r = lbfgs.solve(solver, beta, _taskInfo._ginfo, new ProgressMonitor() {\n              @Override\n              public boolean progress(double[] beta, GradientInfo ginfo) {\n                if ((_taskInfo._iter & 15) == 0) {\n                  update(16, \"iteration \" + (_taskInfo._iter + 1) + \", objective value = \" + ginfo._objVal, GLM.this._key);\n                  LogInfo(\"LBFGS: objval = \" + ginfo._objVal);\n                }\n                ++_taskInfo._iter;\n                // todo update the model here so we can show intermediate results\n                return isRunning(GLM.this._key);\n              }\n            });\n            _taskInfo._beta = r.coefs;\n          }\n          break;\n        }\n        case COORDINATE_DESCENT:\n          double l1pen = _parms._alpha[0]*_parms._lambda[_lambdaId];\n          double l2pen = (1-_parms._alpha[0])*_parms._lambda[_lambdaId];\n          double [] beta = _taskInfo._beta.clone();\n          int off;\n          double xOldSub;\n          double xOldMul;\n          double xNewSub = 0;\n          double xNewMul = 1;\n          double [] betaUpdate = null;\n          boolean betaChanges = true;\n          int iter = 0;\n          // external loop - each time generate weights based on previous beta, compute new beta as solution to weighted least squares\n          while(betaChanges) {\n            // internal loop - go over each column independently as long as beta keeps changing\n            int it = iter; // to keep track of inner iterations\n            while (betaChanges && ++iter < 1000) {\n              betaChanges = false;\n              // run one iteration of coordinate descent - go over all columns\n              for (int i = 0; i < _activeData._adaptedFrame.numCols(); ++i) {\n                Vec previousVec = i == 0?_taskInfo._iVec:_dinfo._adaptedFrame.vec(i-1);\n                Vec currentVec = i == _dinfo._adaptedFrame.numCols()-1?_taskInfo._iVec:_dinfo._adaptedFrame.vec(i);\n                xOldSub = xNewSub;\n                xOldMul = xNewMul;\n                boolean isCategorical = currentVec.isEnum();\n                int to;\n                if (isCategorical) {\n                  xNewSub = 0;\n                  xNewMul = 1;\n                  off = _dinfo._catOffsets[i];\n                  to = _dinfo._catOffsets[i + 1];\n                } else {\n                  int k = i - _dinfo._cats;\n                  xNewSub = _dinfo._normSub[k];\n                  xNewMul = _dinfo._normMul[k];\n                  off = _dinfo.numStart() + k;\n                  to = off + 1;\n                }\n                double[] currentBeta = Arrays.copyOfRange(_taskInfo._beta, off, to);\n                double[] xy = new GLMCoordinateDescentTask(betaUpdate, currentBeta, xOldSub, xOldMul, xNewSub, xNewMul).doAll(previousVec,currentVec,_taskInfo._eVec,_taskInfo._wVec, _taskInfo._zVec)._xy;\n                for (int j = 0; j < xy.length; ++j) {\n                  betaUpdate = currentBeta;\n                  double updatedCoef = ADMM.shrinkage(xy[j], l1pen) / (1 + l2pen);\n                  betaUpdate[j] = updatedCoef - currentBeta[j];\n                  if (betaUpdate[j] < -1e-4 || betaUpdate[j] > 1e-4)\n                    betaChanges = true;\n                  beta[off + j] = updatedCoef;\n                }\n              }\n            }\n            if(iter > it+1) {\n              betaChanges = true; // beta changed during inner iteration\n              // generate new weights\n              new GLMTask.GLMWeightsTask(_parms).doAll(_dinfo._adaptedFrame.lastVec(), _taskInfo._zVec, _taskInfo._wVec, _taskInfo._eVec);\n            }\n          }\n          // done, compute the gradient and check KKTs\n          break;\n        case ADMM:// fork off ADMM iteration\n          new GLMIterationTask(GLM.this._key, _activeData, _parms._lambda[_lambdaId] * (1 - _parms._alpha[0]), _parms, false, _taskInfo._beta, _taskInfo._ymu, _rowFilter, new Iteration(this, false)).asyncExec(_activeData._adaptedFrame);\n          return;\n        default:\n          throw H2O.unimpl();\n      }\n      checkKKTsAndComplete();\n      tryComplete();\n    }","id":91130,"modified_method":"protected void solve(){\n      if (_activeData.fullN() > _parms._max_active_predictors)\n        throw new TooManyPredictorsException();\n      switch(_parms._solver) {\n        case L_BFGS: {\n          double[] beta = _taskInfo._beta;\n          assert beta.length == _activeData.fullN()+1;\n          GradientSolver solver = new GLMGradientSolver(_parms, _activeData, _parms._lambda[_lambdaId] * (1 - _parms._alpha[0]), _taskInfo._ymu, _taskInfo._nobs, _rowFilter);\n          if(_bc._betaGiven != null && _bc._rho != null)\n            solver = new ProximalGradientSolver(solver,_bc._betaGiven,_bc._rho);\n          if (beta == null) {\n            beta = MemoryManager.malloc8d(_activeData.fullN() + (_activeData._intercept ? 1 : 0));\n            if (_activeData._intercept)\n              beta[beta.length - 1] = _parms.link(_taskInfo._ymu);\n          }\n          L_BFGS lbfgs = new L_BFGS().setMaxIter(_parms._max_iter);\n          assert beta.length == _taskInfo._ginfo._gradient.length;\n          double l1pen = _parms._lambda[_lambdaId] * _parms._alpha[0];\n          if(l1pen > 0 || _bc.hasBounds()) {\n            // compute gradient at null beta to get estimate for rho\n            double [] nullBeta = MemoryManager.malloc8d(_taskInfo._beta.length);\n            if(_dinfo._intercept)\n              nullBeta[nullBeta.length-1] = _parms.link(_taskInfo._ymu);\n            double [] g = solver.getGradient(nullBeta)._gradient;\n            double [] rho = MemoryManager.malloc8d(beta.length);\n            // compute rhos\n            double avg = 0;\n            for(int i = 0; i < rho.length - (_dinfo._intercept?1:0); ++i)\n              avg += rho[i] = ADMM.L1Solver.estimateRho(-g[i], l1pen);\n//            avg /= rho.length - (_dinfo._intercept?1:0);\n//            for(int i = 0; i < rho.length - (_dinfo._intercept?1:0); ++i)\n//              rho[i] = Math.max(Math.min(rho[i],1.5*avg),0.5*avg);\n            new ADMM.L1Solver(1e-4, 1000).solve(new LBFGS_ProximalSolver(solver,_taskInfo._beta,rho, GLM.this._key), _taskInfo._beta, l1pen);\n          } else {\n            Result r = lbfgs.solve(solver, beta, _taskInfo._ginfo, new ProgressMonitor() {\n              @Override\n              public boolean progress(double[] beta, GradientInfo ginfo) {\n                if ((_taskInfo._iter & 15) == 0) {\n                  update(16, \"iteration \" + (_taskInfo._iter + 1) + \", objective value = \" + ginfo._objVal, GLM.this._key);\n                  LogInfo(\"LBFGS: objval = \" + ginfo._objVal);\n                }\n                ++_taskInfo._iter;\n                // todo update the model here so we can show intermediate results\n                return isRunning(GLM.this._key);\n              }\n            });\n            _taskInfo._beta = r.coefs;\n          }\n          break;\n        }\n        case COORDINATE_DESCENT:\n          double l1pen = _parms._alpha[0]*_parms._lambda[_lambdaId];\n          double l2pen = (1-_parms._alpha[0])*_parms._lambda[_lambdaId];\n          double [] beta = _taskInfo._beta.clone();\n          int off;\n          double xOldSub;\n          double xOldMul;\n          double xNewSub = 0;\n          double xNewMul = 1;\n          double [] betaUpdate = null;\n          boolean betaChanges = true;\n          int iter = 0;\n          // external loop - each time generate weights based on previous beta, compute new beta as solution to weighted least squares\n          while(betaChanges) {\n            // internal loop - go over each column independently as long as beta keeps changing\n            int it = iter; // to keep track of inner iterations\n            while (betaChanges && ++iter < 1000) {\n              betaChanges = false;\n              // run one iteration of coordinate descent - go over all columns\n              for (int i = 0; i < _activeData._adaptedFrame.numCols(); ++i) {\n                Vec previousVec = i == 0?_taskInfo._iVec:_dinfo._adaptedFrame.vec(i-1);\n                Vec currentVec = i == _dinfo._adaptedFrame.numCols()-1?_taskInfo._iVec:_dinfo._adaptedFrame.vec(i);\n                xOldSub = xNewSub;\n                xOldMul = xNewMul;\n                boolean isCategorical = currentVec.isEnum();\n                int to;\n                if (isCategorical) {\n                  xNewSub = 0;\n                  xNewMul = 1;\n                  off = _dinfo._catOffsets[i];\n                  to = _dinfo._catOffsets[i + 1];\n                } else {\n                  int k = i - _dinfo._cats;\n                  xNewSub = _dinfo._normSub[k];\n                  xNewMul = _dinfo._normMul[k];\n                  off = _dinfo.numStart() + k;\n                  to = off + 1;\n                }\n                double[] currentBeta = Arrays.copyOfRange(_taskInfo._beta, off, to);\n                double[] xy = new GLMCoordinateDescentTask(betaUpdate, currentBeta, xOldSub, xOldMul, xNewSub, xNewMul).doAll(previousVec,currentVec,_taskInfo._eVec,_taskInfo._wVec, _taskInfo._zVec)._xy;\n                for (int j = 0; j < xy.length; ++j) {\n                  betaUpdate = currentBeta;\n                  double updatedCoef = ADMM.shrinkage(xy[j], l1pen) / (1 + l2pen);\n                  betaUpdate[j] = updatedCoef - currentBeta[j];\n                  if (betaUpdate[j] < -1e-4 || betaUpdate[j] > 1e-4)\n                    betaChanges = true;\n                  beta[off + j] = updatedCoef;\n                }\n              }\n            }\n            if(iter > it+1) {\n              betaChanges = true; // beta changed during inner iteration\n              // generate new weights\n              new GLMTask.GLMWeightsTask(_parms).doAll(_dinfo._adaptedFrame.lastVec(), _taskInfo._zVec, _taskInfo._wVec, _taskInfo._eVec);\n            }\n          }\n          // done, compute the gradient and check KKTs\n          break;\n        case ADMM:// fork off ADMM iteration\n          new GLMIterationTask(GLM.this._key, _activeData, _parms._lambda[_lambdaId] * (1 - _parms._alpha[0]), _parms, false, _taskInfo._beta, _taskInfo._ymu, _rowFilter, new Iteration(this, false)).asyncExec(_activeData._adaptedFrame);\n          return;\n        default:\n          throw H2O.unimpl();\n      }\n      checkKKTsAndComplete();\n      tryComplete();\n    }","commit_id":"3271553cf8c0119fc404dc64179d02f5cbd26832","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n    public void map(Chunk [] chks) {\n      Chunk rowFilter = _rowFilter != null?_rowFilter.chunkForChunkIdx(chks[0].cidx()):null;\n\n      Chunk responseChunk = chks[chks.length-1];\n      boolean[] skip = MemoryManager.mallocZ(chks[0]._len);\n      if(rowFilter != null)\n        for(int r = 0; r < skip.length; ++r)\n          skip[r] = rowFilter.at8(r) == 1;\n      double [][] eta = new double[responseChunk._len][_nSteps];\n      double [] beta = _beta;\n      double [] pk = _direction;\n      // categoricals\n      for(int i = 0; i < _dinfo._cats; ++i) {\n        Chunk c = chks[i];\n        for(int r = 0; r < c._len; ++r) { // categoricals can not be sparse\n          if(skip[r] || c.isNA(r)) {\n            skip[r] = true;\n            continue;\n          }\n          int off = _dinfo.getCategoricalId(i,(int)c.at8(r));\n          if(off != -1) {\n            double t = 1;\n            for (int j = 0; j < _nSteps; ++j, t *= _step)\n              eta[r][j] += beta[off] + pk[off] * t;\n          }\n        }\n      }\n      // compute default eta offset for 0s\n      final int numStart = _dinfo.numStart();\n      double [] off = new double[_nSteps];\n      if(_dinfo._normMul != null && _dinfo._normSub != null) {\n        for (int i = 0; i < _dinfo._nums; ++i) {\n          double b = beta[numStart+i];\n          double s = pk[numStart+i];\n          double d = _dinfo._normSub[i] * _dinfo._normMul[i];\n          for (int j = 0; j < _nSteps; ++j, s *= _step)\n            off[j] -= (b + s) * d;\n        }\n      }\n      // non-zero numbers\n      for (int i = 0; i < _dinfo._nums; ++i) {\n        Chunk c = chks[i + _dinfo._cats];\n        for (int r = c.nextNZ(-1); r < c._len; r = c.nextNZ(r)) {\n          if(skip[r] || c.isNA(r)) {\n            skip[r] = true;\n            continue;\n          }\n          double d = c.atd(r);\n          if (_dinfo._normMul != null)\n            d *= _dinfo._normMul[i];\n          double b = beta[numStart+i];\n          double s = pk[numStart+i];\n          for (int j = 0; j < _nSteps; ++j) {\n            eta[r][j] += (b + s) * d;\n            s *= _step;\n          }\n        }\n      }\n      _likelihoods = MemoryManager.malloc8d(_nSteps);\n      for(int r = 0; r < chks[0]._len; ++r){\n        if(skip[r] || responseChunk.isNA(r))\n          continue;\n        _nobs++;\n        double y = responseChunk.atd(r);\n        double yy = -1 + 2*y;\n        double b = 0, s = 0;\n        if(_dinfo._intercept) {\n          b = beta[beta.length-1];\n          s = pk[pk.length-1];\n        }\n        for(int i = 0; i < _nSteps; ++i, s*= _step) {\n          double e = eta[r][i] + off[i] + b + s;\n          if(_params._family == Family.binomial) {\n            _likelihoods[i] += Math.log(1 + Math.exp(-yy * e));\n            double mu = _params.linkInv(e);\n          } else {\n            double mu = _params.linkInv(e);\n            _likelihoods[i] += _params.likelihood(y, e, mu);\n          }\n        }\n      }\n    }","id":91131,"modified_method":"@Override\n    public void map(Chunk [] chks) {\n      Chunk rowFilter = _rowFilter != null?_rowFilter.chunkForChunkIdx(chks[0].cidx()):null;\n\n      Chunk responseChunk = chks[chks.length-1];\n      boolean[] skip = MemoryManager.mallocZ(chks[0]._len);\n      if(rowFilter != null)\n        for(int r = 0; r < skip.length; ++r)\n          skip[r] = rowFilter.at8(r) == 1;\n      double [][] eta = new double[responseChunk._len][_nSteps];\n      double [] beta = _beta;\n      double [] pk = _direction;\n      // intercept\n      if(_dinfo._intercept) {\n        for (int r = 0; r < eta.length; ++r) {\n          int off = beta.length - 1;\n          double t = 1;\n          for (int j = 0; j < _nSteps; ++j, t *= _step)\n            eta[r][j] += beta[off] + pk[off] * t;\n        }\n      }\n      // categoricals\n      for(int i = 0; i < _dinfo._cats; ++i) {\n        Chunk c = chks[i];\n        for(int r = 0; r < c._len; ++r) { // categoricals can not be sparse\n          if(skip[r] || c.isNA(r)) {\n            skip[r] = true;\n            continue;\n          }\n          int off = _dinfo.getCategoricalId(i,(int)c.at8(r));\n          if(off != -1) {\n            double t = 1;\n            for (int j = 0; j < _nSteps; ++j, t *= _step)\n              eta[r][j] += beta[off] + pk[off] * t;\n          }\n        }\n      }\n      // compute default eta offset for 0s\n      final int numStart = _dinfo.numStart();\n      double [] off = new double[_nSteps];\n      if(_dinfo._normMul != null && _dinfo._normSub != null) {\n        for (int i = 0; i < _dinfo._nums; ++i) {\n          double b = beta[numStart+i];\n          double s = pk[numStart+i];\n          double d = _dinfo._normSub[i] * _dinfo._normMul[i];\n          for (int j = 0; j < _nSteps; ++j, s *= _step)\n            off[j] -= (b + s) * d;\n        }\n      }\n      // non-zero numbers\n      for (int i = 0; i < _dinfo._nums; ++i) {\n        Chunk c = chks[i + _dinfo._cats];\n        for (int r = c.nextNZ(-1); r < c._len; r = c.nextNZ(r)) {\n          if(skip[r] || c.isNA(r)) {\n            skip[r] = true;\n            continue;\n          }\n          double d = c.atd(r);\n          if (_dinfo._normMul != null)\n            d *= _dinfo._normMul[i];\n          double b = beta[numStart+i];\n          double s = pk[numStart+i];\n          for (int j = 0; j < _nSteps; ++j) {\n            eta[r][j] += (b + s) * d;\n            s *= _step;\n          }\n        }\n      }\n      _likelihoods = MemoryManager.malloc8d(_nSteps);\n      for(int r = 0; r < chks[0]._len; ++r){\n        if(skip[r] || responseChunk.isNA(r))\n          continue;\n        _nobs++;\n        double y = responseChunk.atd(r);\n        double yy = -1 + 2*y;\n        double b = 0, s = 0;\n        if(_dinfo._intercept) {\n          b = beta[beta.length-1];\n          s = pk[pk.length-1];\n        }\n        for(int i = 0; i < _nSteps; ++i, s*= _step) {\n          double e = eta[r][i] + off[i] + b + s;\n          if(_params._family == Family.binomial) {\n            _likelihoods[i] += Math.log(1 + Math.exp(-yy * e));\n            double mu = _params.linkInv(e);\n          } else {\n            double mu = _params.linkInv(e);\n            _likelihoods[i] += _params.likelihood(y, e, mu);\n          }\n        }\n      }\n    }","commit_id":"fee502a00b6267ab7b68d9650b062a1246f412de","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public void map(Chunk [] chunks) {\n     boolean [] skip = MemoryManager.mallocZ(chunks[0]._len);\n     for(int i = 0; i < chunks.length-1; ++i)\n       for(int r = chunks[i].nextNZ(-1); r < chunks[i]._len; r = chunks[i].nextNZ(r))\n         skip[r] |= chunks[i].isNA(r);\n     Chunk response = chunks[chunks.length-1];\n     for(int r = 0; r < response._len; ++r) {\n       if(skip[r]) continue;\n       if(skip[r] = response.isNA(r))continue;\n       double d = response.atd(r);\n       assert !Double.isNaN(d);\n       assert !Double.isNaN(_ymu+d):\"got NaN by adding \" + _ymu + \" + \" + d;\n       _ymu += d;\n       if(d < _yMin)\n         _yMin = d;\n       if(d > _yMax)\n         _yMax = d;\n       ++_nobs;\n     }\n     if(_fVec != null)\n       DKV.put(_fVec.chunkKey(chunks[0].cidx()), new CBSChunk(skip));\n   }","id":91132,"modified_method":"@Override public void map(Chunk [] chunks) {\n     boolean [] skip = MemoryManager.mallocZ(chunks[0]._len);\n     for(int i = 0; i < chunks.length; ++i)\n       for(int r = chunks[i].nextNZ(-1); r < chunks[i]._len; r = chunks[i].nextNZ(r))\n         skip[r] |= chunks[i].isNA(r);\n     Chunk response = chunks[chunks.length-1];\n     for(int r = 0; r < response._len; ++r) {\n       if(skip[r]) continue;\n       double d = response.atd(r);\n       assert !Double.isNaN(d);\n       assert !Double.isNaN(_ymu+d):\"got NaN by adding \" + _ymu + \" + \" + d;\n       _ymu += d;\n       if(d < _yMin)\n         _yMin = d;\n       if(d > _yMax)\n         _yMax = d;\n       ++_nobs;\n     }\n     if(_fVec != null)\n       DKV.put(_fVec.chunkKey(chunks[0].cidx()), new CBSChunk(skip));\n   }","commit_id":"fee502a00b6267ab7b68d9650b062a1246f412de","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override   protected void goByRows(Chunk [] chks, boolean [] skp){\n      Row row = _dinfo.newDenseRow();\n      double [] g = _gradient;\n      double [] b = _beta;\n      for(int rid = 0; rid < chks[0]._len; ++rid) {\n        row = _dinfo.extractDenseRow(chks, rid, row);\n        double y = -1 + 2*row.response(0);\n        if(row.bad) continue;\n        double eta = row.innerProduct(b);\n        double gval;\n        double d = 1 + Math.exp(-y * eta);\n        _likelihood += Math.log(d);\n        gval = -y*(1-1.0/d);\n        // categoricals\n        for(int i = 0; i < row.nBins; ++i)\n          g[row.binIds[i]] += gval;\n        int off = _dinfo.numStart();\n        // numbers\n        for(int j = 0; j < _dinfo._nums; ++j)\n          g[j + off] += row.numVals[j] * gval;\n        // intercept\n        if(_dinfo._intercept)\n          g[g.length-1] += gval;\n      }\n    }","id":91133,"modified_method":"@Override   protected void goByRows(Chunk [] chks, boolean [] skp){\n      Row row = _dinfo.newDenseRow();\n      double [] g = _gradient;\n      double [] b = _beta;\n      for(int rid = 0; rid < chks[0]._len; ++rid) {\n        row = _dinfo.extractDenseRow(chks, rid, row);\n        double y = -1 + 2*row.response(0);\n        if(row.bad) continue;\n        ++_nobs;\n        double eta = row.innerProduct(b);\n        double gval;\n        double d = 1 + Math.exp(-y * eta);\n        _likelihood += Math.log(d);\n        gval = -y*(1-1.0/d);\n        // categoricals\n        for(int i = 0; i < row.nBins; ++i)\n          g[row.binIds[i]] += gval;\n        int off = _dinfo.numStart();\n        // numbers\n        for(int j = 0; j < _dinfo._nums; ++j)\n          g[j + off] += row.numVals[j] * gval;\n        // intercept\n        if(_dinfo._intercept)\n          g[g.length-1] += gval;\n      }\n    }","commit_id":"fee502a00b6267ab7b68d9650b062a1246f412de","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override protected void goByCols(Chunk [] chks, boolean [] skp){\n      int numStart = _dinfo.numStart();\n      double  [] eta = computeEtaByCols(chks,skp);\n      double  [] b = _beta;\n      double  [] g = _gradient;\n      Chunk offsetChunk = null;\n      int nxs = chks.length-1; // -1 for response\n      if(_dinfo._offset) {\n        nxs -= 1;\n        offsetChunk = chks[nxs];\n      }\n      Chunk responseChunk = chks[nxs];\n      double eta_sum = 0;\n      // compute the predicted mean and variance and gradient for each row\n      for(int r = 0; r < chks[0]._len; ++r){\n        if(skp[r] || responseChunk.isNA(r))\n          continue;\n        double off = (_dinfo._offset?offsetChunk.atd(r):0);\n\n        double e = eta[r]  + off;\n\n        switch(_params._family) {\n          case gaussian:\n            double diff = e - responseChunk.atd(r);\n            _likelihood += diff*diff;\n            eta[r] = diff;\n            break;\n          case binomial:\n            double y = -1 + 2*responseChunk.atd(r);\n            double d = 1 + Math.exp(-y * e);\n            _likelihood += Math.log(d);\n            eta[r] = -y * (1 - 1.0 / d);\n            break;\n          default:\n            throw H2O.unimpl();\n        }\n        eta_sum += eta[r];\n      }\n      // finally go over the columns again and compute gradient for each column\n      // first handle eta offset and intercept\n      if(_dinfo._intercept)\n        g[g.length-1] = eta_sum;\n      if(_dinfo._normMul != null && _dinfo._normSub != null)\n        for(int i = 0; i < _dinfo._nums; ++i)\n          g[numStart + i] = -_dinfo._normSub[i]*_dinfo._normMul[i]*eta_sum;\n      // categoricals\n      for(int i = 0; i < _dinfo._cats; ++i) {\n        Chunk c = chks[i];\n        for(int r = 0; r < c._len; ++r) { // categoricals can not be sparse\n          if(skp[r]) continue;\n          int off = _dinfo.getCategoricalId(i,(int)chks[i].at8(r));\n          if(off != -1)\n            g[off] += eta[r];\n        }\n      }\n      // numerics\n      for (int i = 0; i < _dinfo._nums; ++i) {\n        Chunk c = chks[i + _dinfo._cats];\n        for (int r = c.nextNZ(-1); r < c._len; r = c.nextNZ(r)) {\n          if(skp[r] || c.isNA(r))\n            continue;\n          double d = c.atd(r);\n          if (_dinfo._normMul != null)\n            d = d*_dinfo._normMul[i];\n          g[numStart + i] += eta[r] * d;\n        }\n      }\n      _skip = skp;\n    }","id":91134,"modified_method":"@Override protected void goByCols(Chunk [] chks, boolean [] skp){\n      int numStart = _dinfo.numStart();\n      double  [] eta = computeEtaByCols(chks,skp);\n      double  [] g = _gradient;\n      Chunk offsetChunk = null;\n      int nxs = chks.length-1; // -1 for response\n      if(_dinfo._offset) {\n        nxs -= 1;\n        offsetChunk = chks[nxs];\n      }\n      Chunk responseChunk = chks[nxs];\n      double eta_sum = 0;\n      // compute the predicted mean and variance and gradient for each row\n      for(int r = 0; r < chks[0]._len; ++r){\n        if(skp[r] || responseChunk.isNA(r))\n          continue;\n        ++_nobs;\n        double off = (_dinfo._offset?offsetChunk.atd(r):0);\n        double e = eta[r]  + off;\n        switch(_params._family) {\n          case gaussian:\n            double diff = e - responseChunk.atd(r);\n            _likelihood += diff*diff;\n            eta[r] = diff;\n            break;\n          case binomial:\n            double y = -1 + 2*responseChunk.atd(r);\n            double d = 1 + Math.exp(-y * e);\n            _likelihood += Math.log(d);\n            eta[r] = -y * (1 - 1.0 / d);\n            break;\n          default:\n            throw H2O.unimpl();\n        }\n        eta_sum += eta[r];\n      }\n      // finally go over the columns again and compute gradient for each column\n      // first handle eta offset and intercept\n      if(_dinfo._intercept)\n        g[g.length-1] = eta_sum;\n      if(_dinfo._normMul != null && _dinfo._normSub != null)\n        for(int i = 0; i < _dinfo._nums; ++i)\n          g[numStart + i] = -_dinfo._normSub[i]*_dinfo._normMul[i]*eta_sum;\n      // categoricals\n      for(int i = 0; i < _dinfo._cats; ++i) {\n        Chunk c = chks[i];\n        for(int r = 0; r < c._len; ++r) { // categoricals can not be sparse\n          if(skp[r]) continue;\n          int off = _dinfo.getCategoricalId(i,(int)chks[i].at8(r));\n          if(off != -1)\n            g[off] += eta[r];\n        }\n      }\n      // numerics\n      for (int i = 0; i < _dinfo._nums; ++i) {\n        Chunk c = chks[i + _dinfo._cats];\n        for (int r = c.nextNZ(-1); r < c._len; r = c.nextNZ(r)) {\n          if(skp[r] || c.isNA(r))\n            continue;\n          double d = c.atd(r);\n          if (_dinfo._normMul != null)\n            d = d*_dinfo._normMul[i];\n          g[numStart + i] += eta[r] * d;\n        }\n      }\n      _skip = skp;\n    }","commit_id":"fee502a00b6267ab7b68d9650b062a1246f412de","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Solve the optimization problem defined by the user-supplied gradient function using L-BFGS algorithm.\n   *\n   * Will result into multiple (10s to 100s or even 1000s) calls of the user-provided gradient function.\n   * Outside of that it does only limited single threaded computation (order of number of coefficients).\n   * The gradient is likely to be the most expensive part and key for good perfomance.\n   *\n   * @param gslvr - user gradient function\n   * @param beta - starting solution\n   * @return Optimal solution (coefficients) + gradient info returned by the user gradient\n   * function evaluated at the found optmimum.\n   */\n  public final Result solve(GradientSolver gslvr, double [] beta, GradientInfo ginfo, ProgressMonitor pm) {\n    if(_hist == null)\n      _hist = new History(_historySz, beta.length);\n    beta = beta.clone();\n    // just loop until good enough or line search can not progress\n    int iter = 0;\n    boolean doLineSearch = true;\n    int ls_switch = 0;\n\n    while(pm.progress(beta, ginfo) && MathUtils.l2norm2(ginfo._gradient) > _gradEps && iter != _maxIter) {\n      double [] pk = _hist.getSearchDirection(ginfo._gradient);\n      if(doLineSearch) {\n        LineSearchSol ls = gslvr.doLineSearch(ginfo, beta, pk, gslvr._stepDec);\n        if(ls.step == 1) {\n          if (++ls_switch == 2) {\n            ls_switch = 0;\n            doLineSearch = false;\n          }\n        } else {\n          ls_switch = 0;\n        }\n        if (ls.madeProgress || _hist._k < 2) {\n          ArrayUtils.wadd(beta, pk, ls.step);\n        } else break; // ls did not make progress => converged\n      } else  ArrayUtils.add(beta, pk);\n      GradientInfo newGinfo = gslvr.getGradient(beta); // expensive / distributed\n      if(!doLineSearch) //{\n        if(!admissibleStep(1,ginfo._objVal,newGinfo._objVal,pk,ginfo._gradient)) {\n          if(++ls_switch == 2) {\n            doLineSearch = true;\n            ls_switch = 0;\n          }\n          if(ginfo._objVal < newGinfo._objVal && (newGinfo._objVal - ginfo._objVal > .001*ginfo._objVal)) {\n            doLineSearch = true;\n            ArrayUtils.subtract(beta,pk,beta);\n            continue;\n          }\n        } else ls_switch = 0;\n//        doLineSearch = true;\n//        Log.info(\"switching line search on\");\n//        ArrayUtils.subtract(beta, pk);\n//        LineSearchSol ls = gslvr.doLineSearch(ginfo, beta, pk);\n//        Log.info(\"ls took \" + (System.currentTimeMillis() - t) + \"ms, found step \" + ls.step);\n//        doLineSearch = ls.step < 1;\n//        if (ls.madeProgress || _hist._k < _hist._m) {\n//          ArrayUtils.mult(pk, ls.step);\n//          ArrayUtils.add(beta, pk);\n//          newGinfo = gslvr.getGradient(beta); // expensive / distributed\n//        } else break;\n//      }\n      ++iter;\n      _hist.update(pk, newGinfo._gradient, ginfo._gradient);\n      ginfo = newGinfo;\n    }\n//    Log.info(\"L_BFGS done after \" + iter + \" iterations, objval = \" + ginfo._objVal + \", gradient norm2 = \" + MathUtils.l2norm2(ginfo._gradient) );\n    return new Result(iter,beta, ginfo);\n  }","id":91135,"modified_method":"/**\n   * Solve the optimization problem defined by the user-supplied gradient function using L-BFGS algorithm.\n   *\n   * Will result into multiple (10s to 100s or even 1000s) calls of the user-provided gradient function.\n   * Outside of that it does only limited single threaded computation (order of number of coefficients).\n   * The gradient is likely to be the most expensive part and key for good perfomance.\n   *\n   * @param gslvr - user gradient function\n   * @param beta - starting solution\n   * @return Optimal solution (coefficients) + gradient info returned by the user gradient\n   * function evaluated at the found optmimum.\n   */\n  public final Result solve(GradientSolver gslvr, double [] beta, GradientInfo ginfo, ProgressMonitor pm) {\n    if(_hist == null)\n      _hist = new History(_historySz, beta.length);\n    beta = beta.clone();\n    // just loop until good enough or line search can not progress\n    int iter = 0;\n    boolean doLineSearch = true;\n    int ls_switch = 0;\n\n    while(pm.progress(beta, ginfo) && MathUtils.l2norm2(ginfo._gradient) > _gradEps && iter != _maxIter) {\n      double [] pk = _hist.getSearchDirection(ginfo._gradient);\n      double lsVal = Double.POSITIVE_INFINITY;\n      if(doLineSearch) {\n        LineSearchSol ls = gslvr.doLineSearch(ginfo, beta, pk, gslvr._stepDec);\n        if(ls.step == 1) {\n          if (++ls_switch == 2) {\n            ls_switch = 0;\n            doLineSearch = false;\n          }\n        } else {\n          ls_switch = 0;\n        }\n        if (ls.madeProgress || _hist._k < 2) {\n          lsVal = ls.objVal;\n          ArrayUtils.wadd(beta, pk, ls.step);\n        } else break; // ls did not make progress => converged\n      } else  ArrayUtils.add(beta, pk);\n      GradientInfo newGinfo = gslvr.getGradient(beta); // expensive / distributed\n      if(doLineSearch)\n        assert Math.abs(lsVal - newGinfo._objVal) < 1e-10:\"objvals from line-search and gradient tasks differ, \" + lsVal + \" != \" + newGinfo._objVal;\n      if(!doLineSearch) //{\n        if(!admissibleStep(1,ginfo._objVal,newGinfo._objVal,pk,ginfo._gradient)) {\n          if(++ls_switch == 2) {\n            doLineSearch = true;\n            ls_switch = 0;\n          }\n          if(ginfo._objVal < newGinfo._objVal && (newGinfo._objVal - ginfo._objVal > .001*ginfo._objVal)) {\n            doLineSearch = true;\n            ArrayUtils.subtract(beta,pk,beta);\n            continue;\n          }\n        } else ls_switch = 0;\n      ++iter;\n      _hist.update(pk, newGinfo._gradient, ginfo._gradient);\n      ginfo = newGinfo;\n    }\n//    Log.info(\"L_BFGS done after \" + iter + \" iterations, objval = \" + ginfo._objVal + \", gradient norm2 = \" + MathUtils.l2norm2(ginfo._gradient) );\n    return new Result(iter,beta, ginfo);\n  }","commit_id":"fee502a00b6267ab7b68d9650b062a1246f412de","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test\n  public void logistic() {\n    Key parsedKey = Key.make(\"prostate\");\n    DataInfo dinfo = null;\n    try {\n      GLMParameters glmp = new GLMParameters(Family.binomial, Family.binomial.defaultLink);\n      glmp._alpha = new double[]{0};\n      glmp._lambda = new double[]{1e-5};\n      Frame source = parse_test_file(parsedKey, \"smalldata/glm_test/prostate_cat_replaced.csv\");\n      source.add(\"CAPSULE\", source.remove(\"CAPSULE\"));\n      source.remove(\"ID\").remove();\n      Frame valid = new Frame(source._names.clone(),source.vecs().clone());\n      dinfo = new DataInfo(Key.make(),source, valid, 1, false, DataInfo.TransformType.STANDARDIZE, DataInfo.TransformType.NONE, true);\n      DKV.put(dinfo._key,dinfo);\n      GLMGradientSolver solver = new GLMGradientSolver(glmp, dinfo, 1e-5,source.vec(\"CAPSULE\").mean(), source.numRows());\n      L_BFGS lbfgs = new L_BFGS().setGradEps(1e-8);\n\n      double [] beta = MemoryManager.malloc8d(dinfo.fullN()+1);\n      beta[beta.length-1] = glmp.link(source.vec(\"CAPSULE\").mean());\n      L_BFGS.Result r = lbfgs.solve(solver, beta);\n      assertEquals(378.34, 2 * r.ginfo._objVal * source.numRows(), 1e-1);\n    } finally {\n      if(dinfo != null)\n        DKV.remove(dinfo._key);\n      Value v = DKV.get(parsedKey);\n      if (v != null) {\n        v.<Frame>get().delete();\n      }\n    }\n  }","id":91136,"modified_method":"@Test\n  public void logistic() {\n    Key parsedKey = Key.make(\"prostate\");\n    DataInfo dinfo = null;\n    try {\n      GLMParameters glmp = new GLMParameters(Family.binomial, Family.binomial.defaultLink);\n      glmp._alpha = new double[]{0};\n      glmp._lambda = new double[]{1e-5};\n      Frame source = parse_test_file(parsedKey, \"smalldata/glm_test/prostate_cat_replaced.csv\");\n      source.add(\"CAPSULE\", source.remove(\"CAPSULE\"));\n      source.remove(\"ID\").remove();\n      Frame valid = new Frame(source._names.clone(),source.vecs().clone());\n      dinfo = new DataInfo(Key.make(),source, valid, 1, false, DataInfo.TransformType.STANDARDIZE, DataInfo.TransformType.NONE, true);\n      DKV.put(dinfo._key,dinfo);\n      GLMGradientSolver solver = new GLMGradientSolver(glmp, dinfo, 1e-5,source.vec(\"CAPSULE\").mean(), source.numRows());\n      L_BFGS lbfgs = new L_BFGS().setGradEps(1e-8);\n\n      double [] beta = MemoryManager.malloc8d(dinfo.fullN()+1);\n      beta[beta.length-1] = glmp.link(source.vec(\"CAPSULE\").mean());\n      L_BFGS.Result r = lbfgs.solve(solver, beta, solver.getGradient(beta),new L_BFGS.ProgressMonitor(){\n        int _i = 0;\n        public boolean progress(double [] beta, GradientInfo ginfo){\n          System.out.println(++_i +\":\" + ginfo._objVal + \", \" + ArrayUtils.l2norm2(ginfo._gradient,false));\n          return true;\n        }\n      });\n      assertEquals(378.34, 2 * r.ginfo._objVal * source.numRows(), 1e-1);\n    } finally {\n      if(dinfo != null)\n        DKV.remove(dinfo._key);\n      Value v = DKV.get(parsedKey);\n      if (v != null) {\n        v.<Frame>get().delete();\n      }\n    }\n  }","commit_id":"fee502a00b6267ab7b68d9650b062a1246f412de","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test\n  public void testArcene() {\n    Key parsedKey = Key.make(\"arcene_parsed\");\n    DataInfo dinfo = null;\n    try {\n      Frame source = parse_test_file(parsedKey, \"smalldata/glm_test/arcene.csv\");\n      Frame valid = new Frame(source._names.clone(),source.vecs().clone());\n      GLMParameters glmp = new GLMParameters(Family.gaussian);\n      glmp._lambda = new double[]{1e-5};\n      dinfo = new DataInfo(Key.make(),source, valid, 1, false, DataInfo.TransformType.STANDARDIZE, DataInfo.TransformType.NONE, true);\n      DKV.put(dinfo._key,dinfo);\n      GradientSolver solver = new GLMGradientSolver(glmp, dinfo, 1e-5,source.lastVec().mean(), source.numRows());\n      L_BFGS lbfgs = new L_BFGS().setMaxIter(20);\n      double [] beta = MemoryManager.malloc8d(dinfo.fullN()+1);\n      beta[beta.length-1] = glmp.link(source.lastVec().mean());\n      L_BFGS.Result r1 = lbfgs.solve(solver, beta.clone());\n      lbfgs.setMaxIter(1000);\n      L_BFGS.Result r2 = lbfgs.solve(solver, r1.coefs, r1.ginfo, new L_BFGS.ProgressMonitor());\n      lbfgs = new L_BFGS();\n      L_BFGS.Result r3 = lbfgs.solve(solver, beta.clone());\n      assertEquals(r1.iter,20);\n//      assertEquals (r1.iter + r2.iter,r3.iter); // should be equal? got mismatch by 2\n      assertEquals(r2.ginfo._objVal,r3.ginfo._objVal,1e-8);\n      assertEquals( .5 * glmp._lambda[0] * ArrayUtils.l2norm(r3.coefs,true) + r3.ginfo._objVal, 1e-4, 5e-4);\n      assertTrue(\"iter# expected < 100, got \" + r3.iter, r3.iter < 100);\n    } finally {\n      if(dinfo != null)\n        DKV.remove(dinfo._key);\n      Value v = DKV.get(parsedKey);\n      if (v != null) {\n        v.<Frame>get().delete();\n      }\n    }\n  }","id":91137,"modified_method":"@Test\n  public void testArcene() {\n    Key parsedKey = Key.make(\"arcene_parsed\");\n    DataInfo dinfo = null;\n    try {\n      Frame source = parse_test_file(parsedKey, \"smalldata/glm_test/arcene.csv\");\n      Frame valid = new Frame(source._names.clone(),source.vecs().clone());\n      GLMParameters glmp = new GLMParameters(Family.gaussian);\n      glmp._lambda = new double[]{1e-5};\n      glmp._alpha = new double[]{0};\n      dinfo = new DataInfo(Key.make(),source, valid, 1, false, DataInfo.TransformType.STANDARDIZE, DataInfo.TransformType.NONE, true);\n      DKV.put(dinfo._key,dinfo);\n      GradientSolver solver = new GLMGradientSolver(glmp, dinfo, 1e-5,source.lastVec().mean(), source.numRows());\n      L_BFGS lbfgs = new L_BFGS().setMaxIter(20);\n      double [] beta = MemoryManager.malloc8d(dinfo.fullN()+1);\n      beta[beta.length-1] = glmp.link(source.lastVec().mean());\n      L_BFGS.Result r1 = lbfgs.solve(solver, beta.clone(), solver.getGradient(beta),new L_BFGS.ProgressMonitor(){\n        int _i = 0;\n        public boolean progress(double [] beta, GradientInfo ginfo){\n          System.out.println(++_i +\":\" + ginfo._objVal);\n          return true;\n        }\n      });\n      lbfgs.setMaxIter(50);\n      final int iter = r1.iter;\n      L_BFGS.Result r2 = lbfgs.solve(solver, r1.coefs, r1.ginfo, new L_BFGS.ProgressMonitor(){\n        int _i = 0;\n        public boolean progress(double [] beta, GradientInfo ginfo){\n          System.out.println(iter + \" + \" + ++_i +\":\" + ginfo._objVal);\n          return true;\n        }\n      });\n      System.out.println();\n      lbfgs = new L_BFGS().setMaxIter(100);\n      L_BFGS.Result r3 = lbfgs.solve(solver, beta.clone(), solver.getGradient(beta),new L_BFGS.ProgressMonitor(){\n        int _i = 0;\n        public boolean progress(double [] beta, GradientInfo ginfo){\n          System.out.println(++_i +\":\" + ginfo._objVal + \", \" + ArrayUtils.l2norm2(ginfo._gradient,false));\n          return true;\n        }\n      });\n      assertEquals(r1.iter,20);\n//      assertEquals (r1.iter + r2.iter,r3.iter); // should be equal? got mismatch by 2\n      assertEquals(r2.ginfo._objVal,r3.ginfo._objVal,1e-8);\n      assertEquals( .5 * glmp._lambda[0] * ArrayUtils.l2norm(r3.coefs,true) + r3.ginfo._objVal, 1e-4, 5e-4);\n      assertTrue(\"iter# expected < 100, got \" + r3.iter, r3.iter < 100);\n    } finally {\n      if(dinfo != null)\n        DKV.remove(dinfo._key);\n      Value v = DKV.get(parsedKey);\n      if (v != null) {\n        v.<Frame>get().delete();\n      }\n    }\n  }","commit_id":"fee502a00b6267ab7b68d9650b062a1246f412de","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, File file, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLValidatorUtil.validateFileSize(sourceFileName, file);\n\n\t\treturn super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, file, serviceContext);\n\t}","id":91138,"modified_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, File file, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tif (file != null) {\n\t\t\tDLValidatorUtil.validateFileSize(sourceFileName, file);\n\t\t}\n\n\t\treturn super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, file, serviceContext);\n\t}","commit_id":"c8be46d1a7e420e9c836daa069c93276aaa5274b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FileEntry addFileEntry(\n\t\t\tlong userId, long folderId, String sourceFileName, String mimeType,\n\t\t\tString title, String description, String changeLog, File file,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLValidatorUtil.validateFileSize(sourceFileName, file);\n\n\t\treturn super.addFileEntry(\n\t\t\tuserId, folderId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, file, serviceContext);\n\t}","id":91139,"modified_method":"@Override\n\tpublic FileEntry addFileEntry(\n\t\t\tlong userId, long folderId, String sourceFileName, String mimeType,\n\t\t\tString title, String description, String changeLog, File file,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tif (file != null) {\n\t\t\tDLValidatorUtil.validateFileSize(sourceFileName, file);\n\t\t}\n\n\t\treturn super.addFileEntry(\n\t\t\tuserId, folderId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, file, serviceContext);\n\t}","commit_id":"c8be46d1a7e420e9c836daa069c93276aaa5274b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FileEntry addFileEntry(\n\t\t\tlong userId, long folderId, String sourceFileName, String mimeType,\n\t\t\tString title, String description, String changeLog, File file,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLValidatorUtil.validateFileSize(sourceFileName, file);\n\n\t\treturn super.addFileEntry(\n\t\t\tuserId, folderId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, file, serviceContext);\n\t}","id":91140,"modified_method":"@Override\n\tpublic FileEntry addFileEntry(\n\t\t\tlong userId, long folderId, String sourceFileName, String mimeType,\n\t\t\tString title, String description, String changeLog, File file,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tif (file != null) {\n\t\t\tDLValidatorUtil.validateFileSize(sourceFileName, file);\n\t\t}\n\n\t\treturn super.addFileEntry(\n\t\t\tuserId, folderId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, file, serviceContext);\n\t}","commit_id":"c8be46d1a7e420e9c836daa069c93276aaa5274b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, File file, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tDLValidatorUtil.validateFileSize(sourceFileName, file);\n\n\t\treturn super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, file, serviceContext);\n\t}","id":91141,"modified_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, File file, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tif (file != null) {\n\t\t\tDLValidatorUtil.validateFileSize(sourceFileName, file);\n\t\t}\n\n\t\treturn super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, file, serviceContext);\n\t}","commit_id":"c8be46d1a7e420e9c836daa069c93276aaa5274b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static LRS_Statement getStatementForTakeAssessment(String assessmentTitle, boolean pastDue, String releaseTo, boolean isViaURL) {\n    \tStringBuffer lrssMetaInfo = new StringBuffer(\"Assesment: \" + assessmentTitle);\n    \tlrssMetaInfo.append(\", Past Due?: \" + pastDue);\n    \tif (isViaURL) {\n    \t\tlrssMetaInfo.append(\", Assesment taken via URL.\");\n    \t}\n    \t\n    \tlrssMetaInfo.append(\", Release to:\" + releaseTo);\n    \t\n        String url = serverConfigurationService.getPortalUrl();\n        LRS_Verb verb = new LRS_Verb(SAKAI_VERB.attempted);\n        LRS_Object lrsObject = new LRS_Object(url + \"/assessment\", \"attempted-assessment\");\n        HashMap<String, String> nameMap = new HashMap<String, String>();\n        nameMap.put(\"en-US\", \"User attempted assessment\");\n        lrsObject.setActivityName(nameMap);\n        HashMap<String, String> descMap = new HashMap<String, String>();\n        descMap.put(\"en-US\", \"User attempted assessment: \" + lrssMetaInfo);\n        lrsObject.setDescription(descMap);\n        return new LRS_Statement(null, verb, lrsObject);\n    }","id":91142,"modified_method":"public static LRS_Statement getStatementForTakeAssessment(String assessmentTitle, boolean pastDue, String releaseTo, boolean isViaURL) {\n    \tStringBuffer lrssMetaInfo = new StringBuffer(\"Assesment: \" + assessmentTitle);\n    \tlrssMetaInfo.append(\", Past Due?: \" + pastDue);\n    \tif (isViaURL) {\n    \t\tlrssMetaInfo.append(\", Assesment taken via URL.\");\n    \t}\n    \t\n    \tlrssMetaInfo.append(\", Release to:\" + AgentFacade.getCurrentSiteId());\n    \t\n        String url = serverConfigurationService.getPortalUrl();\n        LRS_Verb verb = new LRS_Verb(SAKAI_VERB.attempted);\n        LRS_Object lrsObject = new LRS_Object(url + \"/assessment\", \"attempted-assessment\");\n        HashMap<String, String> nameMap = new HashMap<String, String>();\n        nameMap.put(\"en-US\", \"User attempted assessment\");\n        lrsObject.setActivityName(nameMap);\n        HashMap<String, String> descMap = new HashMap<String, String>();\n        descMap.put(\"en-US\", \"User attempted assessment: \" + lrssMetaInfo);\n        lrsObject.setDescription(descMap);\n        return new LRS_Statement(null, verb, lrsObject);\n    }","commit_id":"c9ae680a3b3c3e97b7ea9f9dab2589b75ee92665","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public static LRS_Statement getStatementForStudentScoreUpdate(AssessmentGradingData gradingData, PublishedAssessmentData publishedAssessment) {\n        LRS_Verb verb = new LRS_Verb(SAKAI_VERB.scored);\n        LRS_Object lrsObject = new LRS_Object(serverConfigurationService.getPortalUrl() + \"/assessment\", \"student-score-update\");\n        HashMap<String, String> nameMap = new HashMap<>();\n        nameMap.put(\"en-US\", \"Student score updated\");\n        lrsObject.setActivityName(nameMap);\n        HashMap<String, String> descMap = new HashMap<>();\n        descMap.put(\"en-US\", \"Student score updated for: \" + publishedAssessment.getTitle() + \n        \t\t\"; User Id: \"+ gradingData.getAgentId() + \n        \t\t\"; Release To: \"+ publishedAssessment.getReleaseTo() + \n        \t\t\"; Submitted: \" + (gradingData.getIsLate() ? \"late\" : \"on time\"));\n        lrsObject.setDescription(descMap);\n        LRS_Context context = new LRS_Context(\"other\", \"assessment\");\n        LRS_Statement statement = new LRS_Statement(null, verb, lrsObject, getLRS_Result(gradingData, publishedAssessment), context);\n        return statement;\n    }","id":91143,"modified_method":"public static LRS_Statement getStatementForStudentScoreUpdate(AssessmentGradingData gradingData, PublishedAssessmentData publishedAssessment) {\n        LRS_Verb verb = new LRS_Verb(SAKAI_VERB.scored);\n        LRS_Object lrsObject = new LRS_Object(serverConfigurationService.getPortalUrl() + \"/assessment\", \"student-score-update\");\n        HashMap<String, String> nameMap = new HashMap<>();\n        nameMap.put(\"en-US\", \"Student score updated\");\n        lrsObject.setActivityName(nameMap);\n        HashMap<String, String> descMap = new HashMap<>();\n        String userId = gradingData.getAgentId();\n        String userIdLabel = \"User Id\";\n        try {\n        \tuserId = userDirectoryService.getUserEid(gradingData.getAgentId());\n        \tuserIdLabel = \"User Eid\";\n        \t\n        } catch (UserNotDefinedException e) {\n        \t//This is fine as userId is set by default\n        }\n\n        descMap.put(\"en-US\", \"Student score updated for: \" + publishedAssessment.getTitle() + \n        \t\t\"; \" + userIdLabel + \": \" + userId + \n        \t\t\"; Release To: \"+ AgentFacade.getCurrentSiteId() + \n        \t\t\"; Submitted: \" + (gradingData.getIsLate() ? \"late\" : \"on time\"));\n        lrsObject.setDescription(descMap);\n        LRS_Context context = new LRS_Context(\"other\", \"assessment\");\n        LRS_Statement statement = new LRS_Statement(null, verb, lrsObject, getLRS_Result(gradingData, publishedAssessment), context);\n        return statement;\n    }","commit_id":"c9ae680a3b3c3e97b7ea9f9dab2589b75ee92665","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public static LRS_Statement getStatementForTotalScoreUpdate(AssessmentGradingData gradingData, PublishedAssessmentData publishedAssessment) {\n        LRS_Verb verb = new LRS_Verb(SAKAI_VERB.scored);\n        LRS_Object lrsObject = new LRS_Object(serverConfigurationService.getPortalUrl() + \"/assessment\", \"total-score-update\");\n        HashMap<String, String> nameMap = new HashMap<>();\n        nameMap.put(\"en-US\", \"Total score updated\");\n        lrsObject.setActivityName(nameMap);\n        HashMap<String, String> descMap = new HashMap<>();\n        descMap.put(\"en-US\", \"Total score updated for Assessment Title: \" + publishedAssessment.getTitle() + \n        \t\t\"; User Id: \"+ gradingData.getAgentId() + \n        \t\t\"; Release To: \"+ publishedAssessment.getReleaseTo() + \n        \t\t\"; Submitted: \"+ (gradingData.getIsLate() ? \"late\" : \"on time\"));\n        lrsObject.setDescription(descMap);\n        LRS_Context context = new LRS_Context(\"other\", \"assessment\");\n        LRS_Statement statement = new LRS_Statement(null, verb, lrsObject, getLRS_Result(gradingData, publishedAssessment), context);\n        return statement;\n    }","id":91144,"modified_method":"public static LRS_Statement getStatementForTotalScoreUpdate(AssessmentGradingData gradingData, PublishedAssessmentData publishedAssessment) {\n        LRS_Verb verb = new LRS_Verb(SAKAI_VERB.scored);\n        LRS_Object lrsObject = new LRS_Object(serverConfigurationService.getPortalUrl() + \"/assessment\", \"total-score-update\");\n        HashMap<String, String> nameMap = new HashMap<>();\n        nameMap.put(\"en-US\", \"Total score updated\");\n        lrsObject.setActivityName(nameMap);\n        HashMap<String, String> descMap = new HashMap<>();\n        String userId = gradingData.getAgentId();\n        String userIdLabel = \"User Id\";\n        try {\n        \tuserId = userDirectoryService.getUserEid(gradingData.getAgentId());\n        \tuserIdLabel = \"User Eid\";\n        } catch (UserNotDefinedException e) {\n        \t//This is fine as userId is set by default\n        }\n\n        descMap.put(\"en-US\", \"Total score updated for Assessment Title: \" + publishedAssessment.getTitle() + \n        \t\t\"; \" + userIdLabel + \": \" + userId + \n        \t\t\"; Release To: \"+ AgentFacade.getCurrentSiteId() + \n        \t\t\"; Submitted: \"+ (gradingData.getIsLate() ? \"late\" : \"on time\"));\n        lrsObject.setDescription(descMap);\n        LRS_Context context = new LRS_Context(\"other\", \"assessment\");\n        LRS_Statement statement = new LRS_Statement(null, verb, lrsObject, getLRS_Result(gradingData, publishedAssessment), context);\n        return statement;\n    }","commit_id":"c9ae680a3b3c3e97b7ea9f9dab2589b75ee92665","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public static LRS_Statement getStatementForGradedAssessment(AssessmentGradingData gradingData, PublishedAssessmentFacade publishedAssessment) {\n        LRS_Verb verb = new LRS_Verb(SAKAI_VERB.scored);\n        LRS_Object lrsObject = new LRS_Object(serverConfigurationService.getPortalUrl() + \"/assessment\", \"received-grade-assessment\");\n        HashMap<String, String> nameMap = new HashMap<>();\n        nameMap.put(\"en-US\", \"User received a grade\");\n        lrsObject.setActivityName(nameMap);\n        HashMap<String, String> descMap = new HashMap<>();\n        descMap.put(\"en-US\", \"User received a grade for their assessment: \" + publishedAssessment.getTitle() +\n        \t\t\"; UserId: \"+ gradingData.getAgentId() + \n        \t\t\"; ReleaseTo: \"+ publishedAssessment.getReleaseTo() + \n        \t\t\"; Submitted: \" + (gradingData.getIsLate() ? \"late\" : \"on time\"));\n        lrsObject.setDescription(descMap);\n        LRS_Context context = new LRS_Context(\"other\", \"assessment\");\n        LRS_Statement statement = new LRS_Statement(null, verb, lrsObject, getLRS_Result(gradingData, publishedAssessment), context);\n        return statement;\n\t}","id":91145,"modified_method":"public static LRS_Statement getStatementForGradedAssessment(AssessmentGradingData gradingData, PublishedAssessmentFacade publishedAssessment) {\n        LRS_Verb verb = new LRS_Verb(SAKAI_VERB.scored);\n        LRS_Object lrsObject = new LRS_Object(serverConfigurationService.getPortalUrl() + \"/assessment\", \"received-grade-assessment\");\n        HashMap<String, String> nameMap = new HashMap<>();\n        nameMap.put(\"en-US\", \"User received a grade\");\n        lrsObject.setActivityName(nameMap);\n        HashMap<String, String> descMap = new HashMap<>();\n        String userId = gradingData.getAgentId();\n        String userIdLabel = \"User Id\";\n        try {\n        \tuserId = userDirectoryService.getUserEid(gradingData.getAgentId());\n        \tuserIdLabel = \"User Eid\";\n        } catch (UserNotDefinedException e) {\n        \t//This is fine as userId is set by default\n        }\n       \n        descMap.put(\"en-US\", \"User received a grade for their assessment: \" + publishedAssessment.getTitle() +\n        \t\t\"; \" + userIdLabel + \": \" + userId + \n        \t\t\"; Release To: \"+ AgentFacade.getCurrentSiteId() + \n        \t\t\"; Submitted: \" + (gradingData.getIsLate() ? \"late\" : \"on time\"));\n        lrsObject.setDescription(descMap);\n        LRS_Context context = new LRS_Context(\"other\", \"assessment\");\n        LRS_Statement statement = new LRS_Statement(null, verb, lrsObject, getLRS_Result(gradingData, publishedAssessment), context);\n        return statement;\n\t}","commit_id":"c9ae680a3b3c3e97b7ea9f9dab2589b75ee92665","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\t\r\n\t\tif (cloudOverrides != null) {\r\n\t\t\tif (cloudOverrides.length() >= TEN_K) {\r\n\t\t\t\tthrow new CLIStatusException(CloudifyErrorMessages.CLOUD_OVERRIDES_TO_LONG.getName());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tRecipePathResolver pathResolver = new RecipePathResolver();\r\n\t\t\r\n\t\tFile providerDirectory = null;\r\n\t\tif (pathResolver.resolveCloud(new File(cloudProvider))) {\r\n\t\t\tproviderDirectory = pathResolver.getResolved();\r\n\t\t} else {\r\n\t\t\tthrow new CLIStatusException(\"cloud_driver_file_doesnt_exist\", \r\n\t\t\t\t\tStringUtils.join(pathResolver.getPathsLooked().toArray(), \", \"));\r\n\t\t}\r\n\t\t\r\n\t\tsetSecurityMode();\r\n\t\tif (securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE_NO_SSL)\r\n\t\t\t\t|| securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE)) {\r\n\t\t\tcopySecurityFiles(providerDirectory.getAbsolutePath());\r\n\t\t}\r\n\t\t\r\n\t\t// load the cloud file\r\n\t\tFile cloudFile = findCloudFile(providerDirectory);\r\n\t\t\r\n\t\t// load properties file\r\n\t\tFile cloudPropertiesFile = new File(providerDirectory, cloudFile.getName().split(\"\\\\.\")[0] + DSLUtils.PROPERTIES_FILE_SUFFIX);\r\n\r\n\t\tFile backupCloudPropertiesFile = new File(cloudPropertiesFile.getParentFile(), \r\n\t\t\t\tcloudPropertiesFile.getName() + \".backup\");\r\n\t\t\r\n\t\t// check for overrides file\r\n\t\tCloud cloud = null;\r\n\t\tif (cloudOverrides == null) {\r\n\t\t\tcloud = ServiceReader.readCloud(cloudFile);\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t// read cloud with overrides properties so they reflect during bootstrap.\r\n\t\t\tcloud = ServiceReader.\r\n\t\t\t\t\treadCloudFromDirectory(providerDirectory.getAbsolutePath(), \r\n\t\t\t\t\t\t\tFileUtils.readFileToString(cloudOverrides));\r\n\t\t\t\r\n\t\t\t// create a backup of the existing properties file\r\n\t\t\tif (cloudPropertiesFile.exists()) {\r\n\t\t\t\tFileUtils.copyFile(cloudPropertiesFile, backupCloudPropertiesFile);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// append the overrides file to the existing properties file\r\n\t\t\tFileAppender appender = new FileAppender(cloudPropertiesFile);\r\n\t\t\tappender.append(\"Overrides File Properties\", cloudOverrides);\r\n\t\t\tappender.flush();\r\n\t\t}\r\n\r\n\t\t// start the installer\r\n\t\tCloudGridAgentBootstrapper installer = new CloudGridAgentBootstrapper();\r\n\t\tinstaller.setProviderDirectory(providerDirectory);\r\n\t\tif (this.adminFacade != null) {\r\n\t\t\tinstaller.setAdminFacade(this.adminFacade);\r\n\t\t} else {\r\n\t\t\tinstaller.setAdminFacade((AdminFacade) session.get(Constants.ADMIN_FACADE));\r\n\t\t}\r\n\t\tinstaller.setProgressInSeconds(10);\r\n\t\tinstaller.setVerbose(verbose);\r\n\t\tinstaller.setCloud(cloud);\r\n\t\tinstaller.setCloudFile(cloudFile);\r\n\t\tinstaller.setNoWebServices(noWebServices);\r\n\r\n\t\t// Bootstrap!\r\n\r\n\t\t// Note: The cloud driver may be very verbose. This is EXTEREMELY useful\r\n\t\t// when debugging ESM\r\n\t\t// issues, but can also clutter up the CLI display. It makes more sense to temporarily raise the log level here,\r\n\t\t// so that all of these\r\n\t\t// messages will not be displayed on the console.\r\n\t\tlimitLoggingLevel();\r\n\t\tlogger.info(getFormattedMessage(\"bootstrapping_cloud\", cloudProvider));\r\n\t\ttry {\r\n\t\t\t// TODO: Create the event listeners here and pass them to the installer.\r\n\t\t\tinstaller.boostrapCloudAndWait(securityProfile, username, password, keystorePassword, timeoutInMinutes, \r\n\t\t\t\t\tTimeUnit.MINUTES);\r\n\t\t\treturn getFormattedMessage(\"cloud_started_successfully\", cloudProvider);\r\n\t\t} finally {\r\n\t\t\t// if an overrides file was passed, then the properties file is dirty. delete it.\r\n\t\t\tif (cloudOverrides != null) {\r\n\t\t\t\tcloudPropertiesFile.delete();\r\n\t\t\t}\r\n\t\t\tif (backupCloudPropertiesFile.exists()) {\r\n\t\t\t\t// restore original properties file if it existed in the first place (backup file exists).\r\n\t\t\t\tFileUtils.copyFile(backupCloudPropertiesFile, cloudPropertiesFile);\r\n\t\t\t\t// delete temp backup file\r\n\t\t\t\tbackupCloudPropertiesFile.delete();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tinstaller.close();\r\n\t\t\trestoreLoggingLevel();\r\n\t\t}\r\n\r\n\t}","id":91146,"modified_method":"@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\t\r\n\t\tif (cloudOverrides != null) {\r\n\t\t\tif (cloudOverrides.length() >= TEN_K) {\r\n\t\t\t\tthrow new CLIStatusException(CloudifyErrorMessages.CLOUD_OVERRIDES_TO_LONG.getName());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tRecipePathResolver pathResolver = new RecipePathResolver();\r\n\t\t\r\n\t\tFile providerDirectory = null;\r\n\t\tif (pathResolver.resolveCloud(new File(cloudProvider))) {\r\n\t\t\tproviderDirectory = pathResolver.getResolved();\r\n\t\t} else {\r\n\t\t\tthrow new CLIStatusException(\"cloud_driver_file_doesnt_exist\", \r\n\t\t\t\t\tStringUtils.join(pathResolver.getPathsLooked().toArray(), \", \"));\r\n\t\t}\r\n\t\t\r\n\t\tsetSecurityMode();\r\n\t\tif (securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE_NO_SSL)\r\n\t\t\t\t|| securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE)) {\r\n\t\t\tcopySecurityFiles(providerDirectory.getAbsolutePath());\r\n\t\t}\r\n\t\t\r\n\t\t// load the cloud file\r\n\t\tFile cloudFile = findCloudFile(providerDirectory);\r\n\t\t\r\n\t\t// load properties file\r\n\t\tFile cloudPropertiesFile = new File(providerDirectory, cloudFile.getName().split(\"\\\\.\")[0] + DSLUtils.PROPERTIES_FILE_SUFFIX);\r\n\r\n\t\tFile backupCloudPropertiesFile = new File(cloudPropertiesFile.getParentFile(), \r\n\t\t\t\tcloudPropertiesFile.getName() + \".backup\");\r\n\t\t\r\n\t\t// check for overrides file\r\n\t\tCloud cloud = null;\r\n\t\tif (cloudOverrides == null) {\r\n\t\t\tcloud = ServiceReader.readCloud(cloudFile);\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t// read cloud with overrides properties so they reflect during bootstrap.\r\n\t\t\tcloud = ServiceReader.\r\n\t\t\t\t\treadCloudFromDirectory(providerDirectory.getAbsolutePath(), \r\n\t\t\t\t\t\t\tFileUtils.readFileToString(cloudOverrides));\r\n\t\t\t\r\n\t\t\t// create a backup of the existing properties file\r\n\t\t\tif (cloudPropertiesFile.exists()) {\r\n\t\t\t\tFileUtils.copyFile(cloudPropertiesFile, backupCloudPropertiesFile);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// append the overrides file to the existing properties file\r\n\t\t\tFileAppender appender = new FileAppender(cloudPropertiesFile);\r\n\t\t\tappender.append(\"Overrides File Properties\", cloudOverrides);\r\n\t\t\tappender.flush();\r\n\t\t}\r\n\r\n\t\t// start the installer\r\n\t\tCloudGridAgentBootstrapper installer = new CloudGridAgentBootstrapper();\r\n\t\tinstaller.setProviderDirectory(providerDirectory);\r\n\t\tif (this.adminFacade != null) {\r\n\t\t\tinstaller.setAdminFacade(this.adminFacade);\r\n\t\t} else {\r\n\t\t\tinstaller.setAdminFacade((AdminFacade) session.get(Constants.ADMIN_FACADE));\r\n\t\t}\r\n\t\tinstaller.setProgressInSeconds(10);\r\n\t\tinstaller.setVerbose(verbose);\r\n\t\tinstaller.setCloud(cloud);\r\n\t\tinstaller.setCloudFile(cloudFile);\r\n\t\tinstaller.setNoWebServices(noWebServices);\r\n\r\n\t\t// Bootstrap!\r\n\r\n\t\t// Note: The cloud driver may be very verbose. This is EXTEREMELY useful\r\n\t\t// when debugging ESM\r\n\t\t// issues, but can also clutter up the CLI display. It makes more sense to temporarily raise the log level here,\r\n\t\t// so that all of these\r\n\t\t// messages will not be displayed on the console.\r\n\t\tlimitLoggingLevel();\r\n\t\tlogger.info(getFormattedMessage(\"bootstrapping_cloud\", cloudProvider));\r\n\t\ttry {\r\n\t\t\t// TODO: Create the event listeners here and pass them to the installer.\r\n\t\t\tinstaller.boostrapCloudAndWait(securityProfile, username, password, keystorePassword, timeoutInMinutes, \r\n\t\t\t\t\tTimeUnit.MINUTES);\r\n\t\t\treturn getFormattedMessage(\"cloud_started_successfully\", cloudProvider);\r\n\t\t} finally {\r\n\t\t\t// if an overrides file was passed, then the properties file is dirty. delete it.\r\n\t\t\tif (cloudOverrides != null) {\r\n\t\t\t\tcloudPropertiesFile.delete();\r\n\t\t\t}\r\n\t\t\tif (backupCloudPropertiesFile.exists()) {\r\n\t\t\t\t// restore original properties file if it existed in the first place (backup file exists).\r\n\t\t\t\tFileUtils.copyFile(backupCloudPropertiesFile, cloudPropertiesFile);\r\n\t\t\t\t// delete temp backup file\r\n\t\t\t\tbackupCloudPropertiesFile.delete();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\trevertSecurityFiles(providerDirectory.getAbsolutePath());\r\n\t\t\t} catch (final Exception e) {\r\n\t\t\t\tlogger.log(Level.SEVERE,\r\n\t\t\t\t\t\"Failed to revert security files before finishing bootstrap-cloud command\", e);\r\n\t\t\t}\t\t\t\r\n\t\t\t\r\n\t\t\tinstaller.close();\r\n\t\t\trestoreLoggingLevel();\r\n\t\t}\r\n\r\n\t}","commit_id":"5242b2cc6bebaa6dbe364e6d63c4a42942aa342f","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void copySecurityFiles(final String providerDirectory) throws Exception {\r\n\t\t\r\n\t\t//handle the configuration file\r\n\t\tif (StringUtils.isNotBlank(securityFilePath)) {\r\n\t\t\tFile securitySourceFile = new File(securityFilePath);\r\n\t\t\tif (!securitySourceFile.isFile()) {\r\n\t\t\t\tthrow new Exception(\"Security configuration file not found: \" + securityFilePath);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//copy to the overrides folder, to be copied to all management servers as well\r\n\t\t\tFile securityTargetFile = new File(providerDirectory,  OVERRIDES_FOLDER + PATH_SEPARATOR\r\n\t\t\t\t\t+ \"spring-security.xml\");\r\n\t\t\tFileUtils.copyFile(securitySourceFile, securityTargetFile);\r\n\t\t} else {\r\n\t\t\t//TODO : should we use the default security location and assume it was edited by the user?\r\n\t\t\t//securityFilePath = CLOUDIFY_HOME + \"/config/security/spring-security.xml\";\r\n\t\t\tthrow new IllegalArgumentException(\"-security-file is missing or empty\");\r\n\t\t}\r\n\t\t\r\n\t\t//handle the keystore file\r\n\t\tif (StringUtils.isNotBlank(keystore)) {\r\n\t\t\tFile keystoreSourceFile = new File(keystore);\r\n\t\t\tif (!keystoreSourceFile.isFile()) {\r\n\t\t\t\tthrow new Exception(\"Keystore file not found: \" + keystore);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//copy to the override folder, to be copied to all management servers as well\r\n\t\t\tFile keystoreTargetFile = new File(providerDirectory,  OVERRIDES_FOLDER + PATH_SEPARATOR + \"keystore\");\r\n\t\t\tFileUtils.copyFile(keystoreSourceFile, keystoreTargetFile);\r\n\t\t}\r\n\t\t\r\n\t}","id":91147,"modified_method":"private void copySecurityFiles(final String providerDirectory) throws Exception {\r\n\t\t\r\n\t\t//handle the configuration file\r\n\t\tif (StringUtils.isNotBlank(securityFilePath)) {\r\n\t\t\tFile securitySourceFile = new File(securityFilePath);\r\n\t\t\tif (!securitySourceFile.isFile()) {\r\n\t\t\t\tthrow new Exception(\"Security configuration file not found: \" + securityFilePath);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//copy to the overrides folder, to be copied to all management servers as well\r\n\t\t\tFile defaultSecurityFile = new File(providerDirectory + PATH_SEPARATOR + DEFAULT_SECURITY_FILE_PATH);\r\n\t\t\tFile backupSecurityFile = new File(providerDirectory + PATH_SEPARATOR + BACKUP_SECURITY_FILE_PATH);\r\n\t\t\tif (!(securitySourceFile.getCanonicalFile().equals(defaultSecurityFile.getCanonicalFile()))) {\r\n\t\t\t\tif (defaultSecurityFile.exists()) {\r\n\t\t\t\t\t// create a backup of the existing security configuration file\r\n\t\t\t\t\tFileUtils.copyFile(defaultSecurityFile, backupSecurityFile);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t//overrides if exists\r\n\t\t\t\tthis.securityFileCopied = true;\r\n\t\t\t\tFileUtils.copyFile(securitySourceFile, defaultSecurityFile);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t//TODO : should we use the default security location and assume it was edited by the user?\r\n\t\t\t//securityFilePath = CLOUDIFY_HOME + \"/config/security/spring-security.xml\";\r\n\t\t\tthrow new IllegalArgumentException(\"-security-file is missing or empty\");\r\n\t\t}\r\n\t\t\r\n\t\t//handle the keystore file\r\n\t\tif (StringUtils.isNotBlank(keystore)) {\r\n\t\t\tFile keystoreSourceFile = new File(keystore);\r\n\t\t\tif (!keystoreSourceFile.isFile()) {\r\n\t\t\t\tthrow new Exception(\"Keystore file not found: \" + keystore);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//copy to the override folder, to be copied to all management servers as well\r\n\t\t\tfinal File defaultKeystoreFile = new File(providerDirectory + PATH_SEPARATOR + DEFAULT_KEYSTORE_FILE_PATH);\r\n\t\t\tif (!(keystoreSourceFile.getCanonicalFile().equals(defaultKeystoreFile.getCanonicalFile()))) {\r\n\t\t\t\tif (defaultKeystoreFile.exists()) {\r\n\t\t\t\t\t// create a backup of the existing keystore file\r\n\t\t\t\t\tFileUtils.copyFile(keystoreSourceFile, defaultKeystoreFile);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//overrides if exists\r\n\t\t\t\tthis.keystoreFileCopied = true;\r\n\t\t\t\tFileUtils.copyFile(keystoreSourceFile, defaultKeystoreFile);\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"5242b2cc6bebaa6dbe364e6d63c4a42942aa342f","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute()\r\n\t\t\tthrows Exception {\r\n\r\n\t\ttry {\r\n\t\t\tnew CloudifyLicenseVerifier().verifyLicense();\r\n\r\n\t\t\t// first check java home is correctly configured\r\n\t\t\tfinal String javaHome = System.getenv(\"JAVA_HOME\");\r\n\t\t\tif (javaHome == null || javaHome.trim().length() == 0) {\r\n\t\t\t\treturn messages.getString(\"missing_java_home\");\r\n\t\t\t}\r\n\r\n\t\t\tfinal boolean javaHomeValid = isJavaHomeValid(javaHome);\r\n\t\t\tif (!javaHomeValid) {\r\n\t\t\t\treturn getFormattedMessage(\"incorrect_java_home\", Color.RED, javaHome);\r\n\t\t\t}\r\n\r\n\t\t\tsetSecurityMode();\r\n\t\t\tif (securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE_NO_SSL)\r\n\t\t\t\t\t|| securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE)) {\r\n\t\t\t\tcopySecurityFiles();\r\n\t\t\t}\r\n\r\n\t\t\tfinal LocalhostGridAgentBootstrapper installer = new LocalhostGridAgentBootstrapper();\r\n\t\t\tinstaller.setVerbose(verbose);\r\n\t\t\tinstaller.setLookupGroups(lookupGroups);\r\n\t\t\tinstaller.setNicAddress(nicAddress);\r\n\t\t\tinstaller.setProgressInSeconds(DEFAULT_PROGRESS_INTERVAL);\r\n\t\t\tinstaller.setWaitForWebui(true);\r\n\t\t\tinstaller.addListener(new CLILocalhostBootstrapperListener());\r\n\t\t\tinstaller.setAdminFacade((AdminFacade) session.get(Constants.ADMIN_FACADE));\r\n\t\t\tinstaller.startLocalCloudOnLocalhostAndWait(securityProfile, username, password, keystorePassword,\r\n\t\t\t\t\ttimeoutInMinutes, TimeUnit.MINUTES);\r\n\r\n\t\t\treturn messages.getString(\"local_cloud_started\");\r\n\t\t} finally {\r\n\t\t\ttry {\r\n\t\t\t\trevertSecurityFiles();\r\n\t\t\t} catch (final Exception e) {\r\n\t\t\t\tlogger.log(Level.SEVERE,\r\n\t\t\t\t\t\t\"Failed to revery security files before finishing bootstrap-localcloud command\", e);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}","id":91148,"modified_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute()\r\n\t\t\tthrows Exception {\r\n\r\n\t\ttry {\r\n\t\t\tnew CloudifyLicenseVerifier().verifyLicense();\r\n\r\n\t\t\t// first check java home is correctly configured\r\n\t\t\tfinal String javaHome = System.getenv(\"JAVA_HOME\");\r\n\t\t\tif (javaHome == null || javaHome.trim().length() == 0) {\r\n\t\t\t\treturn messages.getString(\"missing_java_home\");\r\n\t\t\t}\r\n\r\n\t\t\tfinal boolean javaHomeValid = isJavaHomeValid(javaHome);\r\n\t\t\tif (!javaHomeValid) {\r\n\t\t\t\treturn getFormattedMessage(\"incorrect_java_home\", Color.RED, javaHome);\r\n\t\t\t}\r\n\r\n\t\t\tsetSecurityMode();\r\n\t\t\tif (securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE_NO_SSL)\r\n\t\t\t\t\t|| securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE)) {\r\n\t\t\t\tcopySecurityFiles();\r\n\t\t\t}\r\n\r\n\t\t\tfinal LocalhostGridAgentBootstrapper installer = new LocalhostGridAgentBootstrapper();\r\n\t\t\tinstaller.setVerbose(verbose);\r\n\t\t\tinstaller.setLookupGroups(lookupGroups);\r\n\t\t\tinstaller.setNicAddress(nicAddress);\r\n\t\t\tinstaller.setProgressInSeconds(DEFAULT_PROGRESS_INTERVAL);\r\n\t\t\tinstaller.setWaitForWebui(true);\r\n\t\t\tinstaller.addListener(new CLILocalhostBootstrapperListener());\r\n\t\t\tinstaller.setAdminFacade((AdminFacade) session.get(Constants.ADMIN_FACADE));\r\n\t\t\tinstaller.startLocalCloudOnLocalhostAndWait(securityProfile, username, password, keystorePassword,\r\n\t\t\t\t\ttimeoutInMinutes, TimeUnit.MINUTES);\r\n\r\n\t\t\treturn messages.getString(\"local_cloud_started\");\r\n\t\t} finally {\r\n\t\t\ttry {\r\n\t\t\t\trevertSecurityFiles();\r\n\t\t\t} catch (final Exception e) {\r\n\t\t\t\tlogger.log(Level.SEVERE,\r\n\t\t\t\t\t\t\"Failed to revert security files before finishing bootstrap-localcloud command\", e);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}","commit_id":"5242b2cc6bebaa6dbe364e6d63c4a42942aa342f","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private String getConfigFileUrl(BundleContext bundleContext, File homeDir) throws IOException {\n    \tString repoConfigFileUrl = bundleContext.getProperty(\"sling.repository.config.file.url\");\n    \tif (repoConfigFileUrl != null) {\n    \t\t// the repository config file is set\n    \t\tURL configFileUrl = null;\n\t\t\ttry {\n\t\t\t    // verify it is a good url\n\t\t\t\tconfigFileUrl = new URL(repoConfigFileUrl);\n\t\t\t\treturn repoConfigFileUrl;\n\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t// this not an url, trying with \"file:\"\n\t\t\t\tconfigFileUrl = new URL(\"file:///\" + repoConfigFileUrl);\n\t\t\t\tFile configFile = new File(configFileUrl.getFile());\n\t\t\t\tif (configFile.canRead()) {\n\t\t\t\t    return configFileUrl.toString();\n\t\t\t\t}\n\t\t\t}\n    \t}\n\n        // ensure the configuration file (inside the home Dir !)\n        File configFile = new File(homeDir, \"repository.xml\");\n        SlingServerRepository.copyFile(bundleContext.getBundle(), \"repository.xml\", configFile);\n    \treturn configFile.toURI().toURL().toString();\n    }","id":91149,"modified_method":"private String getConfigFileUrl(BundleContext bundleContext, File homeDir) throws IOException {\n    \tString repoConfigFileUrl = bundleContext.getProperty(\"sling.repository.config.file.url\");\n    \tif (repoConfigFileUrl != null) {\n    \t\t// the repository config file is set\n    \t\tURL configFileUrl = null;\n\t\t\ttry {\n\t\t\t    // verify it is a good url\n\t\t\t\tconfigFileUrl = new URL(repoConfigFileUrl);\n\t\t\t\treturn repoConfigFileUrl;\n\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t// this not an url, trying with \"file:\"\n\t\t\t\tconfigFileUrl = new URL(\"file:///\" + repoConfigFileUrl);\n\t\t\t\tFile configFile = new File(configFileUrl.getFile());\n\t\t\t\tif (configFile.canRead()) {\n\t\t\t\t    return configFileUrl.toString();\n\t\t\t\t}\n\t\t\t}\n    \t}\n\n        // ensure the configuration file (inside the home Dir !)\n        File configFile = new File(homeDir, \"repository.xml\");\n        boolean copied = false;\n        \n        try {\n            URL contextConfigURL = new URL(\"context:repository.xml\");\n            InputStream contextConfigStream = contextConfigURL.openStream();\n            if (contextConfigStream != null) {\n                SlingServerRepository.copyStream(contextConfigStream, configFile);\n                copied = true;\n            }\n        } catch (Exception e) {}\n        \n        if (!copied) {\n            SlingServerRepository.copyFile(bundleContext.getBundle(), \"repository.xml\", configFile);\n        }\n        return configFile.toURI().toURL().toString();\n\n    }","commit_id":"9a298b0f18443f9fa68df122a716b624499f38c4","url":"https://github.com/apache/sling"},{"original_method":"public static void copyFile(Bundle bundle, String entryPath, File destFile) throws FileNotFoundException, IOException {\n        if (destFile.canRead()) {\n            // nothing to do, file exists\n            return;\n        }\n\n        // copy from property\n        URL entryURL = bundle.getEntry(entryPath);\n        if (entryURL == null) {\n            throw new FileNotFoundException(entryPath);\n        }\n\n        // check for a file property\n        InputStream source = entryURL.openStream();\n\n        OutputStream dest = null;\n        try {\n\n            // ensure path to parent folder of licFile\n            destFile.getParentFile().mkdirs();\n\n            dest = new FileOutputStream(destFile);\n            byte[] buf = new byte[2048];\n            int rd;\n            while ( (rd = source.read(buf)) >= 0) {\n                dest.write(buf, 0, rd);\n            }\n\n\n        } finally {\n            if (dest != null) {\n                try {\n                    dest.close();\n                } catch (IOException ignore) {\n                }\n            }\n\n            // licSource is not null\n            try {\n                source.close();\n            } catch (IOException ignore) {\n            }\n        }\n    }","id":91150,"modified_method":"public static void copyFile(Bundle bundle, String entryPath, File destFile) throws FileNotFoundException, IOException {\n        if (destFile.canRead()) {\n            // nothing to do, file exists\n            return;\n        }\n\n        // copy from property\n        URL entryURL = bundle.getEntry(entryPath);\n        if (entryURL == null) {\n            throw new FileNotFoundException(entryPath);\n        }\n\n        // check for a file property\n        InputStream source = entryURL.openStream();\n        copyStream(source, destFile);\n    }","commit_id":"9a298b0f18443f9fa68df122a716b624499f38c4","url":"https://github.com/apache/sling"},{"original_method":"DaemonStarter createDaemonStarter(DaemonDir daemonDir, DaemonParameters daemonParameters, ListenerManager listenerManager, DaemonGreeter daemonGreeter) {\n        return new DefaultDaemonStarter(daemonDir, daemonParameters, daemonGreeter, listenerManager.getBroadcaster(DaemonStartListener.class));\n    }","id":91151,"modified_method":"DaemonStarter createDaemonStarter(DaemonDir daemonDir, DaemonParameters daemonParameters, ListenerManager listenerManager, DaemonGreeter daemonGreeter, JvmVersionValidator jvmVersionValidator) {\n        return new DefaultDaemonStarter(daemonDir, daemonParameters, daemonGreeter, listenerManager.getBroadcaster(DaemonStartListener.class), jvmVersionValidator);\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected void doAction(String[] args, ExecutionListener listener) {\n        //The first argument is not really used but it is very useful in diagnosing, i.e. running 'jps -m'\n        if (args.length < 4) {\n            invalidArgs(\"Following arguments are required: <gradle-version> <gradle-home-dir> <daemon-dir> <timeout-millis> <daemonUid> <optional startup jvm opts>\");\n        }\n\n        File gradleHomeDir = new File(args[1]);\n        File daemonBaseDir = new File(args[2]);\n\n        int idleTimeoutMs = 0;\n        try {\n            idleTimeoutMs = Integer.parseInt(args[3]);\n        } catch (NumberFormatException e) {\n            invalidArgs(\"Second argument must be a whole number (i.e. daemon idle timeout in ms)\");\n        }\n\n        String daemonUid = args[4];\n\n        List<String> startupOpts = new ArrayList<String>(args.length - 5);\n        //noinspection ManualArrayToCollectionCopy\n        for (int i = 5; i < args.length; i++) {\n            startupOpts.add(args[i]);\n        }\n        LOGGER.debug(\"Assuming the daemon was started with following jvm opts: {}\", startupOpts);\n\n        NativeServices.initialize(gradleHomeDir);\n        DaemonServerConfiguration parameters = new DefaultDaemonServerConfiguration(daemonUid, daemonBaseDir, idleTimeoutMs, startupOpts);\n        LoggingServiceRegistry loggingRegistry = LoggingServiceRegistry.newCommandLineProcessLogging();\n        LoggingManagerInternal loggingManager = loggingRegistry.newInstance(LoggingManagerInternal.class);\n        DaemonServices daemonServices = new DaemonServices(parameters, loggingRegistry, loggingManager);\n        File daemonLog = daemonServices.getDaemonLogFile();\n\n        initialiseLogging(loggingManager, daemonLog);\n\n        Daemon daemon = daemonServices.get(Daemon.class);\n        daemon.start();\n\n        try {\n            DaemonContext daemonContext = daemonServices.get(DaemonContext.class);\n            Long pid = daemonContext.getPid();\n            daemonStarted(pid, daemon.getUid(), daemon.getAddress(), daemonLog);\n\n            // Block until idle\n            daemon.requestStopOnIdleTimeout(parameters.getIdleTimeout(), TimeUnit.MILLISECONDS);\n        } finally {\n            daemon.stop();\n        }\n    }","id":91152,"modified_method":"@Override\n    protected void doAction(String[] args, ExecutionListener listener) {\n        //The first argument is not really used but it is very useful in diagnosing, i.e. running 'jps -m'\n        if (args.length != 1) {\n            invalidArgs(\"Following arguments are required: <gradle-version>\");\n        }\n\n        // Read configuration from stdin\n\n        List<String> startupOpts;\n        File gradleHomeDir;\n        File daemonBaseDir;\n        int idleTimeoutMs;\n        String daemonUid;\n\n        KryoBackedDecoder decoder = new KryoBackedDecoder(new EncodedStream.EncodedInput(System.in));\n        try {\n            gradleHomeDir = new File(decoder.readString());\n            daemonBaseDir = new File(decoder.readString());\n            idleTimeoutMs = decoder.readSmallInt();\n            daemonUid = decoder.readString();\n            int argCount = decoder.readSmallInt();\n            startupOpts = new ArrayList<String>(argCount);\n            for (int i = 0; i < argCount; i++) {\n                startupOpts.add(decoder.readString());\n            }\n        } catch (EOFException e) {\n            throw new UncheckedIOException(e);\n        }\n\n        LOGGER.debug(\"Assuming the daemon was started with following jvm opts: {}\", startupOpts);\n\n        NativeServices.initialize(gradleHomeDir);\n        DaemonServerConfiguration parameters = new DefaultDaemonServerConfiguration(daemonUid, daemonBaseDir, idleTimeoutMs, startupOpts);\n        LoggingServiceRegistry loggingRegistry = LoggingServiceRegistry.newCommandLineProcessLogging();\n        LoggingManagerInternal loggingManager = loggingRegistry.newInstance(LoggingManagerInternal.class);\n        DaemonServices daemonServices = new DaemonServices(parameters, loggingRegistry, loggingManager);\n        File daemonLog = daemonServices.getDaemonLogFile();\n\n        initialiseLogging(loggingManager, daemonLog);\n\n        Daemon daemon = daemonServices.get(Daemon.class);\n        daemon.start();\n\n        try {\n            DaemonContext daemonContext = daemonServices.get(DaemonContext.class);\n            Long pid = daemonContext.getPid();\n            daemonStarted(pid, daemon.getUid(), daemon.getAddress(), daemonLog);\n\n            // Block until idle\n            daemon.requestStopOnIdleTimeout(parameters.getIdleTimeout(), TimeUnit.MILLISECONDS);\n        } finally {\n            daemon.stop();\n        }\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"public void stop() {\n        if (executor == null || output == null) {\n            throw new IllegalStateException(\"Unable to stop output consumer. Was it started?.\");\n        }\n        executor.stop();\n        processOutput = output.toString();\n    }","id":91153,"modified_method":"public void stop() {\n        if (executor == null || output == null) {\n            throw new IllegalStateException(\"Unable to stop output consumer. Was it started?.\");\n        }\n        try {\n            standardInputRunner.closeInput();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        executor.stop();\n        processOutput = output.toString();\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"public void connectStreams(final Process process, String processName) {\n        if (process == null || processName == null) {\n            throw new IllegalArgumentException(\"Cannot connect streams because provided process or its name is null\");\n        }\n        final InputStream inputStream = process.getInputStream();\n        connectStreams(inputStream, processName);\n    }","id":91154,"modified_method":"public void connectStreams(final Process process, String processName, ExecutorFactory executorFactory) {\n        if (process == null || processName == null) {\n            throw new IllegalArgumentException(\"Cannot connect streams because provided process or its name is null\");\n        }\n        standardInputRunner = new ExecOutputHandleRunner(\"write standard input into: \" + processName, stdInput, process.getOutputStream());\n        executor = executorFactory.create(\"Read output from: \" + processName);\n        final InputStream inputStream = process.getInputStream();\n        streamConsumer = new Runnable() {\n            public void run() {\n                Scanner scanner = new Scanner(inputStream);\n                PrintWriter printer = new PrintWriter(output);\n                try {\n                    while (scanner.hasNext()) {\n                        String line = scanner.nextLine();\n                        LOGGER.debug(\"daemon out: {}\", line);\n                        printer.println(line);\n                        if (startupCommunication.containsGreeting(line)) {\n                            break;\n                        }\n                    }\n                } finally {\n                    scanner.close();\n                }\n            }\n        };\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"public void start() {\n        if (executor == null || streamConsumer == null) {\n            throw new IllegalStateException(\"Cannot start consuming daemon output because streams have not been connected first.\");\n        }\n        LOGGER.debug(\"Starting consuming the daemon process output.\");\n        output = new StringWriter();\n        executor.execute(streamConsumer);\n    }","id":91155,"modified_method":"public void start() {\n        if (executor == null || streamConsumer == null) {\n            throw new IllegalStateException(\"Cannot start consuming daemon output because streams have not been connected first.\");\n        }\n        LOGGER.debug(\"Starting consuming the daemon process output.\");\n        output = new StringWriter();\n        executor.execute(standardInputRunner);\n        executor.execute(streamConsumer);\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"public String getEffectiveJavaExecutable() {\n        if (javaHome == null) {\n            return Jvm.current().getJavaExecutable().getAbsolutePath();\n        }\n        return Jvm.forHome(javaHome).getJavaExecutable().getAbsolutePath();\n    }","id":91156,"modified_method":"public File getEffectiveJavaExecutable() {\n        if (javaHome == null) {\n            return Jvm.current().getJavaExecutable();\n        }\n        return Jvm.forHome(javaHome).getJavaExecutable();\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"private DaemonStartupInfo startProcess(final List<String> args, final File workingDir) {\n        LOGGER.info(\"Starting daemon process: workingDir = {}, daemonArgs: {}\", workingDir, args);\n        Clock clock = new Clock();\n        try {\n            GFileUtils.mkdirs(workingDir);\n\n            DaemonOutputConsumer outputConsumer = new DaemonOutputConsumer();\n            ExecHandle handle = new DaemonExecHandleBuilder().build(args, workingDir, outputConsumer);\n\n            handle.start();\n            LOGGER.debug(\"Gradle daemon process is starting. Waiting for the daemon to detach...\");\n            ExecResult result = handle.waitForFinish();\n            LOGGER.debug(\"Gradle daemon process is now detached.\");\n\n            return daemonGreeter.parseDaemonOutput(outputConsumer.getProcessOutput(), result);\n        } catch (GradleException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new GradleException(\"Could not start Gradle daemon.\", e);\n        } finally {\n            LOGGER.info(\"An attempt to start the daemon took {}.\", clock.getTime());\n        }\n    }","id":91157,"modified_method":"private DaemonStartupInfo startProcess(List<String> args, File workingDir, InputStream stdInput) {\n        LOGGER.info(\"Starting daemon process: workingDir = {}, daemonArgs: {}\", workingDir, args);\n        Clock clock = new Clock();\n        try {\n            GFileUtils.mkdirs(workingDir);\n\n            DaemonOutputConsumer outputConsumer = new DaemonOutputConsumer(stdInput);\n            ExecHandle handle = new DaemonExecHandleBuilder().build(args, workingDir, outputConsumer);\n\n            handle.start();\n            LOGGER.debug(\"Gradle daemon process is starting. Waiting for the daemon to detach...\");\n            ExecResult result = handle.waitForFinish();\n            LOGGER.debug(\"Gradle daemon process is now detached.\");\n\n            return daemonGreeter.parseDaemonOutput(outputConsumer.getProcessOutput(), result);\n        } catch (GradleException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new GradleException(\"Could not start Gradle daemon.\", e);\n        } finally {\n            LOGGER.info(\"An attempt to start the daemon took {}.\", clock.getTime());\n        }\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"public DaemonStartupInfo startDaemon() {\n        DefaultModuleRegistry registry = new DefaultModuleRegistry();\n        Set<File> bootstrapClasspath = new LinkedHashSet<File>();\n        bootstrapClasspath.addAll(registry.getModule(\"gradle-launcher\").getImplementationClasspath().getAsFiles());\n        if (registry.getGradleHome() == null) {\n            // Running from the classpath - chuck in everything we can find\n            bootstrapClasspath.addAll(registry.getFullClasspath());\n        }\n        if (bootstrapClasspath.isEmpty()) {\n            throw new IllegalStateException(\"Unable to construct a bootstrap classpath when starting the daemon\");\n        }\n\n        new JvmVersionValidator().validate(daemonParameters);\n\n        List<String> daemonArgs = new ArrayList<String>();\n        daemonArgs.add(daemonParameters.getEffectiveJavaExecutable());\n\n        List<String> daemonOpts = daemonParameters.getEffectiveJvmArgs();\n        LOGGER.debug(\"Using daemon opts: {}\", daemonOpts);\n        daemonArgs.addAll(daemonOpts);\n        //Useful for debugging purposes - simply uncomment and connect to debug\n//        daemonArgs.add(\"-Xdebug\");\n//        daemonArgs.add(\"-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5006\");\n        daemonArgs.add(\"-cp\");\n        daemonArgs.add(CollectionUtils.join(File.pathSeparator, bootstrapClasspath));\n        daemonArgs.add(GradleDaemon.class.getName());\n        daemonArgs.add(GradleVersion.current().getVersion());\n        daemonArgs.add(daemonParameters.getGradleUserHomeDir().getAbsolutePath());\n        daemonArgs.add(daemonDir.getBaseDir().getAbsolutePath());\n        daemonArgs.add(String.valueOf(daemonParameters.getIdleTimeout()));\n        daemonArgs.add(daemonParameters.getUid());\n\n        //all remaining arguments are daemon startup jvm opts.\n        //we need to pass them as *program* arguments to avoid problems with getInputArguments().\n        daemonArgs.addAll(daemonOpts);\n\n        DaemonStartupInfo daemonInfo = startProcess(daemonArgs, daemonDir.getVersionedDir());\n        listener.daemonStarted(daemonInfo);\n        return daemonInfo;\n    }","id":91158,"modified_method":"public DaemonStartupInfo startDaemon() {\n        DefaultModuleRegistry registry = new DefaultModuleRegistry();\n        Set<File> bootstrapClasspath = new LinkedHashSet<File>();\n        bootstrapClasspath.addAll(registry.getModule(\"gradle-launcher\").getImplementationClasspath().getAsFiles());\n        if (registry.getGradleHome() == null) {\n            // Running from the classpath - chuck in everything we can find\n            bootstrapClasspath.addAll(registry.getFullClasspath());\n        }\n        if (bootstrapClasspath.isEmpty()) {\n            throw new IllegalStateException(\"Unable to construct a bootstrap classpath when starting the daemon\");\n        }\n\n        versionValidator.validate(daemonParameters);\n\n        List<String> daemonArgs = new ArrayList<String>();\n        daemonArgs.add(daemonParameters.getEffectiveJavaExecutable().getAbsolutePath());\n\n        List<String> daemonOpts = daemonParameters.getEffectiveJvmArgs();\n        LOGGER.debug(\"Using daemon opts: {}\", daemonOpts);\n        daemonArgs.addAll(daemonOpts);\n        //Useful for debugging purposes - simply uncomment and connect to debug\n        if (System.getProperty(\"org.gradle.daemon.debug\", \"false\").equalsIgnoreCase(\"true\")) {\n            daemonArgs.add(\"-Xdebug\");\n            daemonArgs.add(\"-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5006\");\n        }\n        daemonArgs.add(\"-cp\");\n        daemonArgs.add(CollectionUtils.join(File.pathSeparator, bootstrapClasspath));\n        daemonArgs.add(GradleDaemon.class.getName());\n        // Version isn't used, except by a human looking at the output of jps.\n        daemonArgs.add(GradleVersion.current().getVersion());\n\n        // Serialize configuration to daemon via the process' stdin\n        ByteArrayOutputStream serializedConfig = new ByteArrayOutputStream();\n        FlushableEncoder encoder = new KryoBackedEncoder(new EncodedStream.EncodedOutput(serializedConfig));\n        try {\n            encoder.writeString(daemonParameters.getGradleUserHomeDir().getAbsolutePath());\n            encoder.writeString(daemonDir.getBaseDir().getAbsolutePath());\n            encoder.writeSmallInt(daemonParameters.getIdleTimeout());\n            encoder.writeString(daemonParameters.getUid());\n            encoder.writeSmallInt(daemonOpts.size());\n            for (String daemonOpt : daemonOpts) {\n                encoder.writeString(daemonOpt);\n            }\n            encoder.flush();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n        ByteArrayInputStream stdInput = new ByteArrayInputStream(serializedConfig.toByteArray());\n\n        DaemonStartupInfo daemonInfo = startProcess(daemonArgs, daemonDir.getVersionedDir(), stdInput);\n        listener.daemonStarted(daemonInfo);\n        return daemonInfo;\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultDaemonStarter(DaemonDir daemonDir, DaemonParameters daemonParameters, DaemonGreeter daemonGreeter, DaemonStartListener listener) {\n        this.daemonDir = daemonDir;\n        this.daemonParameters = daemonParameters;\n        this.daemonGreeter = daemonGreeter;\n        this.listener = listener;\n    }","id":91159,"modified_method":"public DefaultDaemonStarter(DaemonDir daemonDir, DaemonParameters daemonParameters, DaemonGreeter daemonGreeter, DaemonStartListener listener, JvmVersionValidator versionValidator) {\n        this.daemonDir = daemonDir;\n        this.daemonParameters = daemonParameters;\n        this.daemonGreeter = daemonGreeter;\n        this.listener = listener;\n        this.versionValidator = versionValidator;\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"public ExecHandle start() {\n        LOGGER.info(\"Starting process '{}'. Working directory: {} Command: {}\",\n                displayName, directory, command + ' ' + Joiner.on(' ').useForNull(\"null\").join(arguments));\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Environment for process '{}': {}\", displayName, environment);\n        }\n        lock.lock();\n        try {\n            if (!stateIn(ExecHandleState.INIT)) {\n                throw new IllegalStateException(String.format(\"Cannot start process '%s' because it has already been started\", displayName));\n            }\n            setState(ExecHandleState.STARTING);\n\n            execHandleRunner = new ExecHandleRunner(this, streamsHandler, processLauncher);\n            executor.execute(execHandleRunner);\n\n            while(stateIn(ExecHandleState.STARTING)) {\n                LOGGER.debug(\"Waiting until process started: {}.\", displayName);\n                try {\n                    condition.await();\n                } catch (InterruptedException e) {\n                    //ok, wrapping up\n                }\n            }\n\n            if (execResult != null) {\n                execResult.rethrowFailure();\n            }\n\n            LOGGER.info(\"Successfully started process '{}'\", displayName);\n        } finally {\n            lock.unlock();\n        }\n        return this;\n    }","id":91160,"modified_method":"public ExecHandle start() {\n        LOGGER.info(\"Starting process '{}'. Working directory: {} Command: {}\",\n                displayName, directory, command + ' ' + Joiner.on(' ').useForNull(\"null\").join(arguments));\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Environment for process '{}': {}\", displayName, environment);\n        }\n        lock.lock();\n        try {\n            if (!stateIn(ExecHandleState.INIT)) {\n                throw new IllegalStateException(String.format(\"Cannot start process '%s' because it has already been started\", displayName));\n            }\n            setState(ExecHandleState.STARTING);\n\n            execHandleRunner = new ExecHandleRunner(this, streamsHandler, processLauncher, executorFactory);\n            executor.execute(execHandleRunner);\n\n            while(stateIn(ExecHandleState.STARTING)) {\n                LOGGER.debug(\"Waiting until process started: {}.\", displayName);\n                try {\n                    condition.await();\n                } catch (InterruptedException e) {\n                    //ok, wrapping up\n                }\n            }\n\n            if (execResult != null) {\n                execResult.rethrowFailure();\n            }\n\n            LOGGER.info(\"Successfully started process '{}'\", displayName);\n        } finally {\n            lock.unlock();\n        }\n        return this;\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"DefaultExecHandle(String displayName, File directory, String command, List<String> arguments,\n                      Map<String, String> environment, StreamsHandler streamsHandler,\n                      List<ExecHandleListener> listeners, boolean redirectErrorStream, int timeoutMillis, boolean daemon) {\n        this.displayName = displayName;\n        this.directory = directory;\n        this.command = command;\n        this.arguments = arguments;\n        this.environment = environment;\n        this.streamsHandler = streamsHandler;\n        this.redirectErrorStream = redirectErrorStream;\n        this.timeoutMillis = timeoutMillis;\n        this.daemon = daemon;\n        this.lock = new ReentrantLock();\n        this.condition = lock.newCondition();\n        this.state = ExecHandleState.INIT;\n        executor = new DefaultExecutorFactory().create(String.format(\"Run %s\", displayName));\n        processLauncher = NativeServices.getInstance().get(ProcessLauncher.class);\n        shutdownHookAction = new ExecHandleShutdownHookAction(this);\n        broadcast = new ListenerBroadcast<ExecHandleListener>(ExecHandleListener.class);\n        broadcast.addAll(listeners);\n    }","id":91161,"modified_method":"DefaultExecHandle(String displayName, File directory, String command, List<String> arguments,\n                      Map<String, String> environment, StreamsHandler streamsHandler,\n                      List<ExecHandleListener> listeners, boolean redirectErrorStream, int timeoutMillis, boolean daemon) {\n        this.displayName = displayName;\n        this.directory = directory;\n        this.command = command;\n        this.arguments = arguments;\n        this.environment = environment;\n        this.streamsHandler = streamsHandler;\n        this.redirectErrorStream = redirectErrorStream;\n        this.timeoutMillis = timeoutMillis;\n        this.daemon = daemon;\n        this.lock = new ReentrantLock();\n        this.condition = lock.newCondition();\n        this.state = ExecHandleState.INIT;\n        executor = executorFactory.create(String.format(\"Run %s\", displayName));\n        processLauncher = NativeServices.getInstance().get(ProcessLauncher.class);\n        shutdownHookAction = new ExecHandleShutdownHookAction(this);\n        broadcast = new ListenerBroadcast<ExecHandleListener>(ExecHandleListener.class);\n        broadcast.addAll(listeners);\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"public void run() {\n        try {\n            ProcessBuilder processBuilder = processBuilderFactory.createProcessBuilder(execHandle);\n            Process process = processLauncher.start(processBuilder);\n            streamsHandler.connectStreams(process, execHandle.getDisplayName());\n            setProcess(process);\n\n            execHandle.started();\n\n            LOGGER.debug(\"waiting until streams are handled...\");\n            streamsHandler.start();\n\n            if (execHandle.isDaemon()) {\n                streamsHandler.stop();\n                detached();\n            } else {\n                int exitValue = process.waitFor();\n                streamsHandler.stop();\n                completed(exitValue);\n            }\n        } catch (Throwable t) {\n            execHandle.failed(t);\n        }\n    }","id":91162,"modified_method":"public void run() {\n        try {\n            ProcessBuilder processBuilder = processBuilderFactory.createProcessBuilder(execHandle);\n            Process process = processLauncher.start(processBuilder);\n            streamsHandler.connectStreams(process, execHandle.getDisplayName(), executorFactory);\n            setProcess(process);\n\n            execHandle.started();\n\n            LOGGER.debug(\"waiting until streams are handled...\");\n            streamsHandler.start();\n\n            if (execHandle.isDaemon()) {\n                streamsHandler.stop();\n                detached();\n            } else {\n                int exitValue = process.waitFor();\n                streamsHandler.stop();\n                completed(exitValue);\n            }\n        } catch (Throwable t) {\n            execHandle.failed(t);\n        }\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"public ExecHandleRunner(DefaultExecHandle execHandle, StreamsHandler streamsHandler, ProcessLauncher processLauncher) {\n        this.processLauncher = processLauncher;\n        if (execHandle == null) {\n            throw new IllegalArgumentException(\"execHandle == null!\");\n        }\n        this.streamsHandler = streamsHandler;\n        this.processBuilderFactory = new ProcessBuilderFactory();\n        this.execHandle = execHandle;\n    }","id":91163,"modified_method":"public ExecHandleRunner(DefaultExecHandle execHandle, StreamsHandler streamsHandler, ProcessLauncher processLauncher, ExecutorFactory executorFactory) {\n        this.processLauncher = processLauncher;\n        this.executorFactory = executorFactory;\n        if (execHandle == null) {\n            throw new IllegalArgumentException(\"execHandle == null!\");\n        }\n        this.streamsHandler = streamsHandler;\n        this.processBuilderFactory = new ProcessBuilderFactory();\n        this.execHandle = execHandle;\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"void validate(DaemonParameters parameters) {\n        if (parameters.getEffectiveJavaHome().equals(Jvm.current().getJavaHome())) {\n            return;\n        }\n\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n\n        ExecHandleBuilder builder = new ExecHandleBuilder();\n        builder.setWorkingDir(new File(\".\").getAbsolutePath());\n        builder.setCommandLine(parameters.getEffectiveJavaExecutable(), \"-version\");\n        builder.setStandardOutput(new ByteArrayOutputStream());\n        builder.setErrorOutput(outputStream);\n        builder.build().start().waitForFinish().assertNormalExitValue();\n\n        JavaVersion javaVersion = parseJavaVersionCommandOutput(new BufferedReader(new InputStreamReader(new ByteArrayInputStream(outputStream.toByteArray()))));\n        if (!javaVersion.isJava6Compatible()) {\n            throw UnsupportedJavaRuntimeException.configuredWithUnsupportedVersion(\"Gradle\", JavaVersion.VERSION_1_6, javaVersion);\n        }\n    }","id":91164,"modified_method":"void validate(DaemonParameters parameters) {\n        if (parameters.getEffectiveJavaHome().equals(Jvm.current().getJavaHome())) {\n            return;\n        }\n\n        JavaVersion javaVersion = getJavaVersion(parameters);\n        if (!javaVersion.isJava6Compatible()) {\n            throw UnsupportedJavaRuntimeException.configuredWithUnsupportedVersion(\"Gradle\", JavaVersion.VERSION_1_6, javaVersion);\n        }\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"public void connectStreams(Process process, String processName) {\n        /*\n            There's a potential problem here in that DisconnectableInputStream reads from input in the background.\n            This won't automatically stop when the process is over. Therefore, if input is not closed then this thread\n            will run forever. It would be better to ensure that this thread stops when the process does.\n         */\n        InputStream instr = new DisconnectableInputStream(input);\n\n        standardOutputRunner = new ExecOutputHandleRunner(\"read standard output of: \" + processName,\n                process.getInputStream(), standardOutput);\n        errorOutputRunner = new ExecOutputHandleRunner(\"read error output of: \" + processName, process.getErrorStream(),\n                errorOutput);\n        standardInputRunner = new ExecOutputHandleRunner(\"write standard input into: \" + processName,\n                instr, process.getOutputStream());\n\n        this.executor = new DefaultExecutorFactory().create(String.format(\"Forward streams with process: %s\", processName));\n    }","id":91165,"modified_method":"public void connectStreams(Process process, String processName, ExecutorFactory executorFactory) {\n        /*\n            There's a potential problem here in that DisconnectableInputStream reads from input in the background.\n            This won't automatically stop when the process is over. Therefore, if input is not closed then this thread\n            will run forever. It would be better to ensure that this thread stops when the process does.\n         */\n        InputStream instr = new DisconnectableInputStream(input);\n\n        standardOutputRunner = new ExecOutputHandleRunner(\"read standard output of: \" + processName,\n                process.getInputStream(), standardOutput);\n        errorOutputRunner = new ExecOutputHandleRunner(\"read error output of: \" + processName, process.getErrorStream(),\n                errorOutput);\n        standardInputRunner = new ExecOutputHandleRunner(\"write standard input into: \" + processName,\n                instr, process.getOutputStream());\n\n        this.executor = executorFactory.create(String.format(\"Forward streams with process: %s\", processName));\n    }","commit_id":"a896793511e900e5f3ffd477c3e62a28c893f8d0","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {\n        messageReceived = true;\n\n        Exchange exchange = getExchange(ctx);\n        AsyncCallback callback = getAsyncCallback(ctx);\n\n        Object body = messageEvent.getMessage();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Channel: {} received body: {}\", new Object[]{messageEvent.getChannel(), body});\n        }\n\n        // if textline enabled then covert to a String which must be used for textline\n        if (producer.getConfiguration().isTextline()) {\n            try {\n                body = producer.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body);\n            } catch (NoTypeConversionAvailableException e) {\n                exchange.setException(e);\n                callback.done(false);\n            }\n        }\n\n\n        // set the result on either IN or OUT on the original exchange depending on its pattern\n        if (ExchangeHelper.isOutCapable(exchange)) {\n            NettyPayloadHelper.setOut(exchange, body);\n        } else {\n            NettyPayloadHelper.setIn(exchange, body);\n        }\n\n        try {\n            // should channel be closed after complete?\n            Boolean close;\n            if (ExchangeHelper.isOutCapable(exchange)) {\n                close = exchange.getOut().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);\n            } else {\n                close = exchange.getIn().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);\n            }\n\n            // should we disconnect, the header can override the configuration\n            boolean disconnect = producer.getConfiguration().isDisconnect();\n            if (close != null) {\n                disconnect = close;\n            }\n            if (disconnect) {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Closing channel when complete at address: {}\", producer.getConfiguration().getAddress());\n                }\n                NettyHelper.close(ctx.getChannel());\n            }\n        } finally {\n            // signal callback\n            callback.done(false);\n        }\n    }","id":91166,"modified_method":"@Override\n    public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {\n        messageReceived = true;\n\n        Exchange exchange = getExchange(ctx);\n        AsyncCallback callback = getAsyncCallback(ctx);\n\n        Message message;\n        try {\n            message = getResponseMessage(exchange, messageEvent);\n        } catch (Exception e) {\n            exchange.setException(e);\n            callback.done(false);\n            return;\n        }\n\n        // set the result on either IN or OUT on the original exchange depending on its pattern\n        if (ExchangeHelper.isOutCapable(exchange)) {\n            exchange.setOut(message);\n        } else {\n            exchange.setIn(message);\n        }\n\n        try {\n            // should channel be closed after complete?\n            Boolean close;\n            if (ExchangeHelper.isOutCapable(exchange)) {\n                close = exchange.getOut().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);\n            } else {\n                close = exchange.getIn().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE, Boolean.class);\n            }\n\n            // should we disconnect, the header can override the configuration\n            boolean disconnect = producer.getConfiguration().isDisconnect();\n            if (close != null) {\n                disconnect = close;\n            }\n            if (disconnect) {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Closing channel when complete at address: {}\", producer.getConfiguration().getAddress());\n                }\n                NettyHelper.close(ctx.getChannel());\n            }\n        } finally {\n            // signal callback\n            callback.done(false);\n        }\n    }","commit_id":"b0ccd947445df66a980034bb87f3fdbdb8066d02","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Message toCamelMessage(HttpRequest request, Exchange exchange) throws Exception {\n        LOG.trace(\"toCamelMessage: {}\", request);\n\n        NettyHttpMessage answer = new NettyHttpMessage(request, this);\n        // force getting headers which will populate them\n        answer.getHeaders();\n\n        // keep the body as is, and use type converters\n        answer.setBody(request.getContent());\n        return answer;\n    }","id":91167,"modified_method":"@Override\n    public Message toCamelMessage(HttpRequest request, Exchange exchange) throws Exception {\n        LOG.trace(\"toCamelMessage: {}\", request);\n\n        NettyHttpMessage answer = new NettyHttpMessage(request, null, this);\n        // force getting headers which will populate them\n        answer.getHeaders();\n\n        // keep the body as is, and use type converters\n        answer.setBody(request.getContent());\n        return answer;\n    }","commit_id":"b0ccd947445df66a980034bb87f3fdbdb8066d02","url":"https://github.com/apache/camel"},{"original_method":"public HttpClientChannelHandler(NettyProducer producer) {\n        super(producer);\n    }","id":91168,"modified_method":"public HttpClientChannelHandler(NettyHttpProducer producer) {\n        super(producer);\n        this.producer = producer;\n    }","commit_id":"b0ccd947445df66a980034bb87f3fdbdb8066d02","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {\n        super.messageReceived(ctx, messageEvent);    //To change body of overridden methods use File | Settings | File Templates.\n    }","id":91169,"modified_method":"@Override\n    public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {\n        // store response, as this channel handler is created per pipeline\n        response = (HttpResponse) messageEvent.getMessage();\n\n        super.messageReceived(ctx, messageEvent);\n    }","commit_id":"b0ccd947445df66a980034bb87f3fdbdb8066d02","url":"https://github.com/apache/camel"},{"original_method":"public HttpClientPipelineFactory(NettyProducer nettyProducer) {\n        this.producer = nettyProducer;\n        try {\n            this.sslContext = createSSLContext(producer);\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n\n        LOG.info(\"Created SslContext {}\", sslContext);\n    }","id":91170,"modified_method":"public HttpClientPipelineFactory(NettyHttpProducer nettyProducer) {\n        this.producer = nettyProducer;\n        try {\n            this.sslContext = createSSLContext(producer);\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n\n        if (sslContext != null) {\n            LOG.info(\"Created SslContext {}\", sslContext);\n        }\n    }","commit_id":"b0ccd947445df66a980034bb87f3fdbdb8066d02","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public ClientPipelineFactory createPipelineFactory(NettyProducer nettyProducer) {\n        return new HttpClientPipelineFactory(nettyProducer);\n    }","id":91171,"modified_method":"@Override\n    public ClientPipelineFactory createPipelineFactory(NettyProducer nettyProducer) {\n        return new HttpClientPipelineFactory((NettyHttpProducer) nettyProducer);\n    }","commit_id":"b0ccd947445df66a980034bb87f3fdbdb8066d02","url":"https://github.com/apache/camel"},{"original_method":"public HttpServerPipelineFactory(NettyHttpConsumer nettyConsumer) {\n        this.consumer = nettyConsumer;\n        try {\n            this.sslContext = createSSLContext(consumer);\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n\n        LOG.info(\"Created SslContext {}\", sslContext);\n    }","id":91172,"modified_method":"public HttpServerPipelineFactory(NettyHttpConsumer nettyConsumer) {\n        this.consumer = nettyConsumer;\n        try {\n            this.sslContext = createSSLContext(consumer);\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n\n        if (sslContext != null) {\n            LOG.info(\"Created SslContext {}\", sslContext);\n        }\n    }","commit_id":"b0ccd947445df66a980034bb87f3fdbdb8066d02","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * A fallback converter that allows us to easily call Java beans and use the raw Netty {@link HttpRequest} as parameter types.\n     */\n    @FallbackConverter\n    public static Object convertToHttpRequest(Class<?> type, Exchange exchange, Object value, TypeConverterRegistry registry) {\n        // if we want to covert to HttpRequest\n        if (value != null && HttpRequest.class.isAssignableFrom(type)) {\n\n            // okay we may need to cheat a bit when we want to grab the HttpRequest as its stored on the NettyHttpMessage\n            // so if the message instance is a NettyHttpMessage and its body is the value, then we can grab the\n            // HttpRequest from the NettyHttpMessage\n            NettyHttpMessage msg = exchange.getIn(NettyHttpMessage.class);\n            if (msg != null && msg.getBody() == value) {\n                return msg.getHttpRequest();\n            }\n        }\n\n        return null;\n    }","id":91173,"modified_method":"/**\n     * A fallback converter that allows us to easily call Java beans and use the raw Netty {@link HttpRequest} as parameter types.\n     */\n    @FallbackConverter\n    public static Object convertToHttpRequest(Class<?> type, Exchange exchange, Object value, TypeConverterRegistry registry) {\n        // if we want to covert to HttpRequest\n        if (value != null && HttpRequest.class.isAssignableFrom(type)) {\n\n            // okay we may need to cheat a bit when we want to grab the HttpRequest as its stored on the NettyHttpMessage\n            // so if the message instance is a NettyHttpMessage and its body is the value, then we can grab the\n            // HttpRequest from the NettyHttpMessage\n            NettyHttpMessage msg;\n            if (exchange.hasOut()) {\n                msg = exchange.getOut(NettyHttpMessage.class);\n            } else {\n                msg = exchange.getIn(NettyHttpMessage.class);\n            }\n            if (msg != null && msg.getBody() == value) {\n                return msg.getHttpRequest();\n            }\n        }\n\n        return null;\n    }","commit_id":"b0ccd947445df66a980034bb87f3fdbdb8066d02","url":"https://github.com/apache/camel"},{"original_method":"public NettyHttpMessage(HttpRequest httpRequest, NettyHttpBinding httpBinding) {\n        this.httpRequest = httpRequest;\n        this.httpBinding = httpBinding;\n    }","id":91174,"modified_method":"public NettyHttpMessage(HttpRequest httpRequest, HttpResponse httpResponse, NettyHttpBinding httpBinding) {\n        this.httpRequest = httpRequest;\n        this.httpResponse = httpResponse;\n        this.httpBinding = httpBinding;\n    }","commit_id":"b0ccd947445df66a980034bb87f3fdbdb8066d02","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void populateInitialHeaders(Map<String, Object> map) {\n        try {\n            httpBinding.populateCamelHeaders(httpRequest, map, getExchange());\n        } catch (Exception e) {\n            throw new RuntimeCamelException(\"Error populating initial headers\", e);\n        }\n    }","id":91175,"modified_method":"@Override\n    protected void populateInitialHeaders(Map<String, Object> map) {\n        try {\n            if (httpRequest != null) {\n                httpBinding.populateCamelHeaders(httpRequest, map, getExchange());\n            } else {\n                httpBinding.populateCamelHeaders(httpResponse, map, getExchange());\n            }\n        } catch (Exception e) {\n            throw new RuntimeCamelException(\"Error populating initial headers\", e);\n        }\n    }","commit_id":"b0ccd947445df66a980034bb87f3fdbdb8066d02","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public DefaultMessage newInstance() {\n        return new NettyHttpMessage(httpRequest, httpBinding);\n    }","id":91176,"modified_method":"@Override\n    public DefaultMessage newInstance() {\n        return new NettyHttpMessage(httpRequest, httpResponse, httpBinding);\n    }","commit_id":"b0ccd947445df66a980034bb87f3fdbdb8066d02","url":"https://github.com/apache/camel"},{"original_method":"public StreamCache cache(Exchange exchange) {\n        StreamCache cache = exchange.getIn().getBody(StreamCache.class);\n        if (cache != null) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cached stream to {} -> {}\", cache.inMemory() ? \"memory\" : \"spool\", cache);\n            }\n            if (statistics.isStatisticsEnabled()) {\n                try {\n                    if (cache.inMemory()) {\n                        statistics.updateMemory(cache.length());\n                    } else {\n                        statistics.updateSpool(cache.length());\n                    }\n                } catch (Exception e) {\n                    LOG.debug(\"Error updating cache statistics. This exception is ignored.\", e);\n                }\n            }\n        }\n        return cache;\n    }","id":91177,"modified_method":"public StreamCache cache(Exchange exchange) {\n        Message message = exchange.hasOut() ? exchange.getOut() : exchange.getIn();\n        StreamCache cache = message.getBody(StreamCache.class);\n        if (cache != null) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cached stream to {} -> {}\", cache.inMemory() ? \"memory\" : \"spool\", cache);\n            }\n            if (statistics.isStatisticsEnabled()) {\n                try {\n                    if (cache.inMemory()) {\n                        statistics.updateMemory(cache.length());\n                    } else {\n                        statistics.updateSpool(cache.length());\n                    }\n                } catch (Exception e) {\n                    LOG.debug(\"Error updating cache statistics. This exception is ignored.\", e);\n                }\n            }\n        }\n        return cache;\n    }","commit_id":"41805bb8493cbff1d208d6eaed92676d1ade86b9","url":"https://github.com/apache/camel"},{"original_method":"/**\r\n     * This fuction should be called to specify working set of relations\r\n     */\r\n    public void setRelations(Collection<Relation> relations) {\r\n        if (relations==null) {\r\n            this.relations = Collections.<Relation>emptySet();\r\n        } else {\r\n            this.relations = relations;\r\n        }\r\n        updateEnabledState();\r\n    }","id":91178,"modified_method":"/**\r\n     * Specifies the working set of relations.\r\n     * @param relations The new working set of relations. Can be null or empty\r\n     */\r\n    public void setRelations(Collection<Relation> relations) {\r\n        if (relations==null) {\r\n            this.relations = Collections.<Relation>emptySet();\r\n        } else {\r\n            this.relations = relations;\r\n        }\r\n        updateEnabledState();\r\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void actionPerformed(ActionEvent e) {\r\n        if (!isEnabled() || relations.isEmpty()) return;\r\n        Main.worker.submit(new DownloadRelationTask(relations, Main.map.mapView.getEditLayer()));\r\n    }","id":91179,"modified_method":"public void actionPerformed(ActionEvent e) {\r\n        if (!isEnabled() || relations.isEmpty() || Main.map==null || Main.map.mapView==null) return;\r\n        Main.worker.submit(new DownloadRelationTask(relations, Main.map.mapView.getEditLayer()));\r\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"public DownloadMembersAction() {\r\n        putValue(SHORT_DESCRIPTION, tr(\"Download all members of the selected relations\"));\r\n        putValue(NAME, tr(\"Download members\"));\r\n        putValue(SMALL_ICON, ImageProvider.get(\"dialogs\", \"downloadincomplete\"));\r\n        putValue(\"help\", ht(\"/Dialog/RelationList#DownloadMembers\"));\r\n    }","id":91180,"modified_method":"/**\r\n     * Constructs a new <code>DownloadMembersAction<\/code>.\r\n     */\r\n    public DownloadMembersAction() {\r\n        putValue(SHORT_DESCRIPTION, tr(\"Download all members of the selected relations\"));\r\n        putValue(NAME, tr(\"Download members\"));\r\n        putValue(SMALL_ICON, ImageProvider.get(\"dialogs\", \"downloadincomplete\"));\r\n        putValue(\"help\", ht(\"/Dialog/RelationList#DownloadMembers\"));\r\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"public DownloadSelectedIncompleteMembersAction() {\r\n        putValue(SHORT_DESCRIPTION, tr(\"Download incomplete members of selected relations\"));\r\n        putValue(SMALL_ICON, ImageProvider.get(\"dialogs/relation\", \"downloadincompleteselected\"));\r\n        putValue(NAME, tr(\"Download incomplete members\"));\r\n    }","id":91181,"modified_method":"/**\r\n     * Constructs a new <code>DownloadSelectedIncompleteMembersAction<\/code>.\r\n     */\r\n    public DownloadSelectedIncompleteMembersAction() {\r\n        putValue(SHORT_DESCRIPTION, tr(\"Download incomplete members of selected relations\"));\r\n        putValue(SMALL_ICON, ImageProvider.get(\"dialogs/relation\", \"downloadincompleteselected\"));\r\n        putValue(NAME, tr(\"Download incomplete members\"));\r\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Set<OsmPrimitive> buildSetOfIncompleteMembers(Collection<Relation> rels) {\r\n        Set<OsmPrimitive> ret = new HashSet<OsmPrimitive>();\r\n        for (Relation r : rels) {\r\n            ret.addAll(r.getIncompleteMembers());\r\n        }\r\n        return ret;\r\n    }","id":91182,"modified_method":"/**\r\n     * Returns the set of incomplete members of the given relations.\r\n     * @param rels The relations to inspect.\r\n     * @return The set of incomplete members of the given relations.\r\n     */\r\n    public Set<OsmPrimitive> buildSetOfIncompleteMembers(Collection<Relation> rels) {\r\n        Set<OsmPrimitive> ret = new HashSet<OsmPrimitive>();\r\n        for (Relation r : rels) {\r\n            ret.addAll(r.getIncompleteMembers());\r\n        }\r\n        return ret;\r\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void actionPerformed(ActionEvent e) {\r\n        if (!isEnabled() || relations.isEmpty()) return;\r\n        Main.worker.submit(new DownloadRelationMemberTask(\r\n                relations,\r\n                buildSetOfIncompleteMembers(relations),\r\n                Main.map.mapView.getEditLayer()));\r\n    }","id":91183,"modified_method":"public void actionPerformed(ActionEvent e) {\r\n        if (!isEnabled() || relations.isEmpty() || Main.map==null || Main.map.mapView==null) return;\r\n        Main.worker.submit(new DownloadRelationMemberTask(\r\n                relations,\r\n                buildSetOfIncompleteMembers(relations),\r\n                Main.map.mapView.getEditLayer()));\r\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static void launchEditor(Relation toEdit) {\r\n        if (toEdit == null) return;\r\n        RelationEditor.getEditor(Main.map.mapView.getEditLayer(), toEdit,\r\n                getMembersForCurrentSelection(toEdit)).setVisible(true);\r\n    }","id":91184,"modified_method":"/**\r\n     * Launches relation editor for the given relation.\r\n     * @param toEdit The relation to edit\r\n     */\r\n    public static void launchEditor(Relation toEdit) {\r\n        if (toEdit == null || Main.map==null || Main.map.mapView==null) return;\r\n        RelationEditor.getEditor(Main.map.mapView.getEditLayer(), toEdit,\r\n                getMembersForCurrentSelection(toEdit)).setVisible(true);\r\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"public EditRelationAction() {\r\n        putValue(NAME, tr(\"Edit\"));\r\n        putValue(SHORT_DESCRIPTION, tr(\"Call relation editor for selected relation\"));\r\n        putValue(SMALL_ICON, ImageProvider.get(\"dialogs\", \"edit\"));\r\n    }","id":91185,"modified_method":"/**\r\n     * Constructs a new <code>EditRelationAction<\/code>.\r\n     */\r\n    public EditRelationAction() {\r\n        putValue(NAME, tr(\"Edit\"));\r\n        putValue(SHORT_DESCRIPTION, tr(\"Call relation editor for selected relation\"));\r\n        putValue(SMALL_ICON, ImageProvider.get(\"dialogs\", \"edit\"));\r\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static Collection<RelationMember> getMembersForCurrentSelection(Relation r) {\r\n        Collection<RelationMember> members = new HashSet<RelationMember>();\r\n        Collection<OsmPrimitive> selection = Main.map.mapView.getEditLayer().data.getSelected();\r\n        for (RelationMember member: r.getMembers()) {\r\n            if (selection.contains(member.getMember())) {\r\n                members.add(member);\r\n            }\r\n        }\r\n        return members;\r\n    }","id":91186,"modified_method":"/**\r\n     * Returns the set of currently selected relation members for the given relation. \r\n     * @param r The relation to inspect\r\n     * @return The set of currently selected relation members for the given relation.\r\n     */\r\n    public static Set<RelationMember> getMembersForCurrentSelection(Relation r) {\r\n        Set<RelationMember> members = new HashSet<RelationMember>();\r\n        if (Main.map != null && Main.map.mapView != null) {\r\n            OsmDataLayer editLayer = Main.map.mapView.getEditLayer();\r\n            if (editLayer != null && editLayer.data != null) {\r\n                Collection<OsmPrimitive> selection = editLayer.data.getSelected();\r\n                for (RelationMember member: r.getMembers()) {\r\n                    if (selection.contains(member.getMember())) {\r\n                        members.add(member);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return members;\r\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"public SelectInRelationListAction() {\r\n        putValue(NAME, tr(\"Select in relation list\"));\r\n        putValue(SHORT_DESCRIPTION, tr(\"Select relation in relation list.\"));\r\n        putValue(SMALL_ICON, ImageProvider.get(\"dialogs\", \"selectionlist\"));\r\n    }","id":91187,"modified_method":"/**\r\n     * Constructs a new <code>SelectInRelationListAction<\/code>.\r\n     */\r\n    public SelectInRelationListAction() {\r\n        putValue(NAME, tr(\"Select in relation list\"));\r\n        putValue(SHORT_DESCRIPTION, tr(\"Select relation in relation list.\"));\r\n        putValue(SMALL_ICON, ImageProvider.get(\"dialogs\", \"selectionlist\"));\r\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void actionPerformed(ActionEvent e) {\r\n        if (!isEnabled() || relations.isEmpty()) return;\r\n        if (Main.map.relationListDialog!=null)\r\n            Main.map.relationListDialog.selectRelations(relations);\r\n    }","id":91188,"modified_method":"public void actionPerformed(ActionEvent e) {\r\n        if (!isEnabled() || relations.isEmpty() || Main.map==null || Main.map.relationListDialog==null) return;\r\n        Main.map.relationListDialog.selectRelations(relations);\r\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\r\n    public void actionPerformed(ActionEvent e) {\r\n        if (!isEnabled() || relations.isEmpty()) return;\r\n        \r\n        HashSet<OsmPrimitive> members = new HashSet<OsmPrimitive>();\r\n        for(Relation r: relations) {\r\n            members.addAll(r.getMemberPrimitives());\r\n        }\r\n        if(add) {\r\n            Main.map.mapView.getEditLayer().data.addSelected(members);\r\n        } else {\r\n            Main.map.mapView.getEditLayer().data.setSelected(members);\r\n        }\r\n    }","id":91189,"modified_method":"@Override\r\n    public void actionPerformed(ActionEvent e) {\r\n        if (!isEnabled() || relations.isEmpty() || Main.map==null || Main.map.mapView==null) return;\r\n        \r\n        HashSet<OsmPrimitive> members = new HashSet<OsmPrimitive>();\r\n        for (Relation r: relations) {\r\n            members.addAll(r.getMemberPrimitives());\r\n        }\r\n        if (add) {\r\n            Main.map.mapView.getEditLayer().data.addSelected(members);\r\n        } else {\r\n            Main.map.mapView.getEditLayer().data.setSelected(members);\r\n        }\r\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"public SelectMembersAction(boolean add) {\r\n        putValue(SHORT_DESCRIPTION,add ? tr(\"Add the members of all selected relations to current selection\")\r\n                : tr(\"Select the members of all selected relations\"));\r\n        putValue(SMALL_ICON, ImageProvider.get(\"selectall\"));\r\n        putValue(NAME, add ? tr(\"Select members (add)\") : tr(\"Select members\"));\r\n        this.add = add;\r\n    }","id":91190,"modified_method":"/**\r\n     * Constructs a new <code>SelectMembersAction<\/code>.\r\n     * @param add if <code>true<\/code>, the members will be added to current selection. If <code>false<\/code>, the members will replace the current selection.\r\n     */\r\n    public SelectMembersAction(boolean add) {\r\n        putValue(SHORT_DESCRIPTION,add ? tr(\"Add the members of all selected relations to current selection\")\r\n                : tr(\"Select the members of all selected relations\"));\r\n        putValue(SMALL_ICON, ImageProvider.get(\"selectall\"));\r\n        putValue(NAME, add ? tr(\"Select members (add)\") : tr(\"Select members\"));\r\n        this.add = add;\r\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"public SelectRelationAction(boolean add) {\n        putValue(SHORT_DESCRIPTION, add ? tr(\"Add the selected relations to the current selection\") : tr(\"Set the current selection to the list of selected relations\"));\n        putValue(SMALL_ICON, ImageProvider.get(\"dialogs\", \"select\"));\n        putValue(NAME, add ? tr(\"Select relation (add)\") : tr(\"Select relation\"));\n        this.add = add;\n    }","id":91191,"modified_method":"/**\n     * Constructs a new <code>SelectRelationAction<\/code>.\n     * @param add if <code>true<\/code>, the relation will be added to current selection. If <code>false<\/code>, the relation will replace the current selection.\n     */\n    public SelectRelationAction(boolean add) {\n        putValue(SHORT_DESCRIPTION, add ? tr(\"Add the selected relations to the current selection\") : tr(\"Set the current selection to the list of selected relations\"));\n        putValue(SMALL_ICON, ImageProvider.get(\"dialogs\", \"select\"));\n        putValue(NAME, add ? tr(\"Select relation (add)\") : tr(\"Select relation\"));\n        this.add = add;\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void actionPerformed(ActionEvent e) {\n        if (!isEnabled() || relations.isEmpty()) return;\n        OsmDataLayer editLayer = Main.map.mapView.getEditLayer();\n        if (editLayer==null || editLayer.data==null) return;\n        if (add) {\n            editLayer.data.addSelected(relations);\n        } else {\n            editLayer.data.setSelected(relations);\n        }\n    }","id":91192,"modified_method":"public void actionPerformed(ActionEvent e) {\n        if (!isEnabled() || relations.isEmpty() || Main.map==null || Main.map.mapView==null) return;\n        OsmDataLayer editLayer = Main.map.mapView.getEditLayer();\n        if (editLayer==null || editLayer.data==null) return;\n        if (add) {\n            editLayer.data.addSelected(relations);\n        } else {\n            editLayer.data.setSelected(relations);\n        }\n    }","commit_id":"bf6d45530f2dc3e7b83facab3dc6c7c093525f59","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Lets other commands access the original version\n     * of the object. Usually for undoing.\n     */\n    public PrimitiveData getOrig(OsmPrimitive osm) {\n        PrimitiveData o = cloneMap.get(osm);\n        if (o != null)\n            return o;\n        for (OsmPrimitive t : cloneMap.keySet()) {\n            PrimitiveData to = cloneMap.get(t);\n        }\n        return o;\n    }","id":91193,"modified_method":"/**\n     * Lets other commands access the original version\n     * of the object. Usually for undoing.\n     * @param osm The requested OSM object\n     * @return The original version of the requested object, if any\n     */\n    public PrimitiveData getOrig(OsmPrimitive osm) {\n        return cloneMap.get(osm);\n    }","commit_id":"b7b9186fc28d2df225a6c7a46b7c09900f987669","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Executes the command on the dataset. This implementation will remember all\n     * primitives returned by fillModifiedData for restoring them on undo.\n     */\n    public boolean executeCommand() {\n        CloneVisitor visitor = new CloneVisitor();\n        Collection<OsmPrimitive> all = new ArrayList<OsmPrimitive>();\n        fillModifiedData(all, all, all);\n        for (OsmPrimitive osm : all) {\n            osm.visit(visitor);\n        }\n        cloneMap = visitor.orig;\n        return true;\n    }","id":91194,"modified_method":"/**\n     * Executes the command on the dataset. This implementation will remember all\n     * primitives returned by fillModifiedData for restoring them on undo.\n     * @return true\n     */\n    public boolean executeCommand() {\n        CloneVisitor visitor = new CloneVisitor();\n        Collection<OsmPrimitive> all = new ArrayList<OsmPrimitive>();\n        fillModifiedData(all, all, all);\n        for (OsmPrimitive osm : all) {\n            osm.visit(visitor);\n        }\n        cloneMap = visitor.orig;\n        return true;\n    }","commit_id":"b7b9186fc28d2df225a6c7a46b7c09900f987669","url":"https://github.com/openstreetmap/josm"},{"original_method":"public Command() {\n        this.layer = Main.map.mapView.getEditLayer();\n    }","id":91195,"modified_method":"/**\n     * Creates a new command in the context of the current edit layer, if any\n     */\n    public Command() {\n        this.layer = Main.map != null && Main.map.mapView != null ? Main.map.mapView.getEditLayer() : null;\n    }","commit_id":"b7b9186fc28d2df225a6c7a46b7c09900f987669","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n        public void actionPerformed(ActionEvent arg0) {\n            if (!isEnabled())\n                return;\n            if (Main.main == null || !Main.main.hasEditLayer()) return;\n            OsmDataLayer layer = Main.main.getEditLayer();\n            Set<HistoryOsmPrimitive> selected = model.getSelectedPrimitives();\n            Set<OsmPrimitive> target = new HashSet<>();\n            for (HistoryOsmPrimitive p : model.getSelectedPrimitives()) {\n                OsmPrimitive op = layer.data.getPrimitiveById(p.getPrimitiveId());\n                if (op != null) {\n                    target.add(op);\n                }\n            }\n            if (target.isEmpty()) {\n                alertNoPrimitivesTo(selected, tr(\"Nothing to zoom to\"),\n                        HelpUtil.ht(\"/Dialog/ChangesetCacheManager#NothingToZoomTo\"));\n                return;\n            }\n            layer.data.setSelected(target);\n            AutoScaleAction.zoomToSelection();\n        }","id":91196,"modified_method":"@Override\n        public void actionPerformed(ActionEvent arg0) {\n            final Set<OsmPrimitive> target = getTarget();\n            if (target == null) {\n                return;\n            } else if (target.isEmpty()) {\n                alertNoPrimitivesTo(model.getSelectedPrimitives(), tr(\"Nothing to zoom to\"),\n                        HelpUtil.ht(\"/Dialog/ChangesetCacheManager#NothingToZoomTo\"));\n                return;\n            }\n            Main.main.getEditLayer().data.setSelected(target);\n            AutoScaleAction.zoomToSelection();\n        }","commit_id":"1e3be06aec5681767851bbecc1f341b87e7dc4cf","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n        public void actionPerformed(ActionEvent arg0) {\n            if (!isEnabled())\n                return;\n            if (Main.main == null || !Main.main.hasEditLayer()) return;\n            OsmDataLayer layer = Main.main.getEditLayer();\n            Set<HistoryOsmPrimitive> selected = model.getSelectedPrimitives();\n            Set<OsmPrimitive> target = new HashSet<>();\n            for (HistoryOsmPrimitive p : model.getSelectedPrimitives()) {\n                OsmPrimitive op = layer.data.getPrimitiveById(p.getPrimitiveId());\n                if (op != null) {\n                    target.add(op);\n                }\n            }\n            if (target.isEmpty()) {\n                alertNoPrimitivesTo(selected, tr(\"Nothing to select\"),\n                        HelpUtil.ht(\"/Dialog/ChangesetCacheManager#NothingToSelectInLayer\"));\n                return;\n            }\n            layer.data.setSelected(target);\n        }","id":91197,"modified_method":"@Override\n        public void actionPerformed(ActionEvent arg0) {\n            final Set<OsmPrimitive> target = getTarget();\n            if (target == null) {\n                return;\n            } else if (target.isEmpty()) {\n                alertNoPrimitivesTo(model.getSelectedPrimitives(), tr(\"Nothing to select\"),\n                        HelpUtil.ht(\"/Dialog/ChangesetCacheManager#NothingToSelectInLayer\"));\n                return;\n            }\n            Main.main.getEditLayer().data.setSelected(target);\n        }","commit_id":"1e3be06aec5681767851bbecc1f341b87e7dc4cf","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override @ActionEvent (eventType=EventTypes.EVENT_LOAD_BALANCER_DELETE, eventDescription=\"deleting load balancer\", async=true) \n    public boolean deleteLoadBalancerRule(long loadBalancerId, boolean apply) {\n        UserContext caller = UserContext.current();\n        \n        LoadBalancerVO lb = _lbDao.findById(loadBalancerId);\n        if (lb == null) {\n            throw new InvalidParameterException(\"Invalid load balancer value: \" + loadBalancerId);\n        }\n        \n        _accountMgr.checkAccess(caller.getCaller(), lb);\n        \n        lb.setState(FirewallRule.State.Revoke);\n        _lbDao.persist(lb);\n        \n        List<LoadBalancerVMMapVO> maps = _lb2VmMapDao.listByLoadBalancerId(loadBalancerId);\n        if (maps != null) {\n            for (LoadBalancerVMMapVO map : maps) {\n                map.setRevoke(true);\n                _lb2VmMapDao.persist(map);\n                s_logger.debug(\"Set load balancer rule for revoke: rule id \" + loadBalancerId + \", vmId \" + map.getInstanceId());\n            }  \n        }\n        \n        if (apply) {\n            try {\n                applyLoadBalancerConfig(loadBalancerId);\n            } catch (ResourceUnavailableException e) {\n                s_logger.warn(\"Unable to apply the load balancer config because resource is unavaliable.\", e);\n                return false;\n            }\n        }\n        \n        _rulesDao.remove(lb.getId());\n        UsageEventVO usageEvent = new UsageEventVO(EventTypes.EVENT_LOAD_BALANCER_DELETE, lb.getAccountId(), 0 , lb.getId(), null);\n        _usageEventDao.persist(usageEvent);\n        s_logger.debug(\"Load balancer with id \" + lb.getId() + \" is removed successfully\");\n        return true;\n    }","id":91198,"modified_method":"@Override @ActionEvent (eventType=EventTypes.EVENT_LOAD_BALANCER_DELETE, eventDescription=\"deleting load balancer\", async=true) \n    public boolean deleteLoadBalancerRule(long loadBalancerId, boolean apply) {\n        UserContext caller = UserContext.current();\n        LoadBalancerVO loadBalancerLock = null;\n\n        LoadBalancerVO lb = _lbDao.findById(loadBalancerId);\n        if (lb == null) {\n            throw new InvalidParameterException(\"Invalid load balancer value: \" + loadBalancerId);\n        }\n        \n        _accountMgr.checkAccess(caller.getCaller(), lb);\n        \n        loadBalancerLock = _lbDao.acquireInLockTable(loadBalancerId);\n        if(loadBalancerLock == null)\n\t\t{\n\t\t\ts_logger.warn(\"Failed to acquire lock to delete load balance rule id \" + loadBalancerId);\n\t\t\treturn false;\n\t\t}        \t\n        \n        lb.setState(FirewallRule.State.Revoke);\n        _lbDao.persist(lb);\n        \n        List<LoadBalancerVMMapVO> maps = _lb2VmMapDao.listByLoadBalancerId(loadBalancerId);\n        if (maps != null) {\n            for (LoadBalancerVMMapVO map : maps) {\n                map.setRevoke(true);\n                _lb2VmMapDao.persist(map);\n                s_logger.debug(\"Set load balancer rule for revoke: rule id \" + loadBalancerId + \", vmId \" + map.getInstanceId());\n            }  \n        }\n        \n        if (apply) {\n            try {\n                applyLoadBalancerConfig(loadBalancerId);\n            } catch (ResourceUnavailableException e) {\n                s_logger.warn(\"Unable to apply the load balancer config because resource is unavaliable.\", e);\n                return false;\n            } finally {\n            \tif (loadBalancerLock != null)\n            \t\t_lbDao.releaseFromLockTable(loadBalancerId);\n            }\n        }\n\n        _rulesDao.remove(lb.getId());\n\n        UsageEventVO usageEvent = new UsageEventVO(EventTypes.EVENT_LOAD_BALANCER_DELETE, lb.getAccountId(), 0 , lb.getId(), null);\n        _usageEventDao.persist(usageEvent);\n        s_logger.debug(\"Load balancer with id \" + lb.getId() + \" is removed successfully\");\n        return true;\n    }","commit_id":"368289aa122c33afdb2a433b829a0075f32a083d","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override @DB @ActionEvent (eventType=EventTypes.EVENT_ASSIGN_TO_LOAD_BALANCER_RULE, eventDescription=\"assigning to load balancer\", async=true)\n    public boolean assignToLoadBalancer(long loadBalancerId, List<Long> instanceIds) {\n        UserContext ctx = UserContext.current();\n        Account caller = ctx.getCaller();\n\n        LoadBalancerVO loadBalancer = _lbDao.findById(loadBalancerId);\n        if (loadBalancer == null) {\n            throw new InvalidParameterValueException(\"Failed to assign to load balancer \" + loadBalancerId + \", the load balancer was not found.\");\n        }\n\n        List<LoadBalancerVMMapVO> mappedInstances = _lb2VmMapDao.listByLoadBalancerId(loadBalancerId, false);\n        Set<Long> mappedInstanceIds = new HashSet<Long>();\n        for (LoadBalancerVMMapVO mappedInstance : mappedInstances) {\n            mappedInstanceIds.add(Long.valueOf(mappedInstance.getInstanceId()));\n        }\n        \n        List<UserVm> vmsToAdd = new ArrayList<UserVm>();\n        \n        for (Long instanceId : instanceIds) {\n            if (mappedInstanceIds.contains(instanceId)) {\n                throw new InvalidParameterValueException(\"VM \" + instanceId + \" is already mapped to load balancer.\");\n            }\n            \n            UserVm vm = _vmDao.findById(instanceId);\n            if (vm == null || vm.getState() == State.Destroyed || vm.getState() == State.Expunging) {\n                throw new InvalidParameterValueException(\"Invalid instance id: \" + instanceId);\n            }\n            \n            _rulesMgr.checkRuleAndUserVm(loadBalancer, vm, caller);\n            \n            if (vm.getAccountId() != loadBalancer.getAccountId()) {\n                throw new PermissionDeniedException(\"Cannot add virtual machines that do not belong to the same owner.\");\n            }\n            \n            // Let's check to make sure the vm has a nic in the same network as the load balancing rule.\n            List<? extends Nic> nics = _networkMgr.getNics(vm);\n            Nic nicInSameNetwork = null;\n            for (Nic nic : nics) {\n                if (nic.getNetworkId() == loadBalancer.getNetworkId()) {\n                    nicInSameNetwork = nic;\n                    break;\n                }\n            }\n            \n            if (nicInSameNetwork == null) {\n                throw new InvalidParameterValueException(\"VM \" + instanceId + \" cannot be added because it doesn't belong in the same network.\");\n            }\n            \n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Adding \" + vm + \" to the load balancer pool\");\n            }\n            vmsToAdd.add(vm);\n        }\n        \n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n        \n        for (UserVm vm : vmsToAdd) {\n            LoadBalancerVMMapVO map = new LoadBalancerVMMapVO(loadBalancer.getId(), vm.getId(), false);\n            map = _lb2VmMapDao.persist(map);\n        }\n        txn.commit();\n        \n        try {\n            loadBalancer.setState(FirewallRule.State.Add);\n            _lbDao.persist(loadBalancer);\n            applyLoadBalancerConfig(loadBalancerId);\n        } catch (ResourceUnavailableException e) {\n            s_logger.warn(\"Unable to apply the load balancer config because resource is unavaliable.\", e);\n            return false;\n        }\n       \n        return true;\n    }","id":91199,"modified_method":"@Override @DB @ActionEvent (eventType=EventTypes.EVENT_ASSIGN_TO_LOAD_BALANCER_RULE, eventDescription=\"assigning to load balancer\", async=true)\n    public boolean assignToLoadBalancer(long loadBalancerId, List<Long> instanceIds) {\n        UserContext ctx = UserContext.current();\n        Account caller = ctx.getCaller();\n        LoadBalancerVO loadBalancerLock = null;\n\n        LoadBalancerVO loadBalancer = _lbDao.findById(loadBalancerId);\n        if (loadBalancer == null) {\n            throw new InvalidParameterValueException(\"Failed to assign to load balancer \" + loadBalancerId + \", the load balancer was not found.\");\n        }\n\n        List<LoadBalancerVMMapVO> mappedInstances = _lb2VmMapDao.listByLoadBalancerId(loadBalancerId, false);\n        Set<Long> mappedInstanceIds = new HashSet<Long>();\n        for (LoadBalancerVMMapVO mappedInstance : mappedInstances) {\n            mappedInstanceIds.add(Long.valueOf(mappedInstance.getInstanceId()));\n        }\n        \n        List<UserVm> vmsToAdd = new ArrayList<UserVm>();\n        \n        for (Long instanceId : instanceIds) {\n            if (mappedInstanceIds.contains(instanceId)) {\n                throw new InvalidParameterValueException(\"VM \" + instanceId + \" is already mapped to load balancer.\");\n            }\n            \n            UserVm vm = _vmDao.findById(instanceId);\n            if (vm == null || vm.getState() == State.Destroyed || vm.getState() == State.Expunging) {\n                throw new InvalidParameterValueException(\"Invalid instance id: \" + instanceId);\n            }\n            \n            _rulesMgr.checkRuleAndUserVm(loadBalancer, vm, caller);\n            \n            if (vm.getAccountId() != loadBalancer.getAccountId()) {\n                throw new PermissionDeniedException(\"Cannot add virtual machines that do not belong to the same owner.\");\n            }\n            \n            // Let's check to make sure the vm has a nic in the same network as the load balancing rule.\n            List<? extends Nic> nics = _networkMgr.getNics(vm);\n            Nic nicInSameNetwork = null;\n            for (Nic nic : nics) {\n                if (nic.getNetworkId() == loadBalancer.getNetworkId()) {\n                    nicInSameNetwork = nic;\n                    break;\n                }\n            }\n            \n            if (nicInSameNetwork == null) {\n                throw new InvalidParameterValueException(\"VM \" + instanceId + \" cannot be added because it doesn't belong in the same network.\");\n            }\n            \n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Adding \" + vm + \" to the load balancer pool\");\n            }\n            vmsToAdd.add(vm);\n        }\n        \n        try {\n        \tloadBalancerLock = _lbDao.acquireInLockTable(loadBalancerId);\n        \tif(loadBalancerLock == null)\n    \t\t{\n    \t\t\ts_logger.warn(\"Failed to acquire lock to assign VM to load balance rule id \" + loadBalancerId);\n    \t\t\treturn false;\n    \t\t}\n\n        \tTransaction txn = Transaction.currentTxn();\n            txn.start();\n            \n            for (UserVm vm : vmsToAdd) {\n                LoadBalancerVMMapVO map = new LoadBalancerVMMapVO(loadBalancer.getId(), vm.getId(), false);\n                map = _lb2VmMapDao.persist(map);\n            }\n            txn.commit();\n\n            loadBalancer.setState(FirewallRule.State.Add);\n            _lbDao.persist(loadBalancer);\n            applyLoadBalancerConfig(loadBalancerId);\n        } catch (ResourceUnavailableException e) {\n            s_logger.warn(\"Unable to apply the load balancer config because resource is unavaliable.\", e);\n            return false;\n        } finally {\n        \tif (loadBalancerLock != null) {\n        \t\t_lbDao.releaseFromLockTable(loadBalancerId);\n        \t}\n        }\n       \n        return true;\n    }","commit_id":"368289aa122c33afdb2a433b829a0075f32a083d","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override @ActionEvent (eventType=EventTypes.EVENT_REMOVE_FROM_LOAD_BALANCER_RULE, eventDescription=\"removing from load balancer\", async=true)\n    public boolean removeFromLoadBalancer(long loadBalancerId, List<Long> instanceIds) {\n        UserContext caller = UserContext.current();\n\n        LoadBalancerVO loadBalancer = _lbDao.findById(Long.valueOf(loadBalancerId));\n        if (loadBalancer == null) {\n            throw new InvalidParameterException(\"Invalid load balancer value: \" + loadBalancerId);\n        } \n        \n        _accountMgr.checkAccess(caller.getCaller(), loadBalancer);\n       \n        try {\n            loadBalancer.setState(FirewallRule.State.Add);\n            _lbDao.persist(loadBalancer);\n            \n            for (long instanceId : instanceIds) {\n                LoadBalancerVMMapVO map = _lb2VmMapDao.findByLoadBalancerIdAndVmId(loadBalancerId, instanceId);\n                map.setRevoke(true);\n                _lb2VmMapDao.persist(map);\n                s_logger.debug(\"Set load balancer rule for revoke: rule id \" + loadBalancerId + \", vmId \" + instanceId);\n            }\n            \n            if (applyLoadBalancerConfig(loadBalancerId)) {\n                _lb2VmMapDao.remove(loadBalancerId, instanceIds, null);\n                s_logger.debug(\"Load balancer rule id \" + loadBalancerId + \" is removed for vms \" + instanceIds);\n            } else {\n                s_logger.warn(\"Failed to remove load balancer rule id \" + loadBalancerId + \" for vms \" + instanceIds);\n                throw new CloudRuntimeException(\"Failed to remove load balancer rule id \" + loadBalancerId + \" for vms \" + instanceIds);\n            }\n            \n        } catch (ResourceUnavailableException e) {\n            s_logger.warn(\"Unable to apply the load balancer config because resource is unavaliable.\", e);\n            return false;\n        }\n       \n        return true;\n    }","id":91200,"modified_method":"@Override @ActionEvent (eventType=EventTypes.EVENT_REMOVE_FROM_LOAD_BALANCER_RULE, eventDescription=\"removing from load balancer\", async=true)\n    public boolean removeFromLoadBalancer(long loadBalancerId, List<Long> instanceIds) {\n        UserContext caller = UserContext.current();\n        LoadBalancerVO loadBalancerLock = null;\n\n        LoadBalancerVO loadBalancer = _lbDao.findById(Long.valueOf(loadBalancerId));\n        if (loadBalancer == null) {\n            throw new InvalidParameterException(\"Invalid load balancer value: \" + loadBalancerId);\n        } \n        \n        _accountMgr.checkAccess(caller.getCaller(), loadBalancer);\n\n        try {\n        \tloadBalancerLock = _lbDao.acquireInLockTable(loadBalancerId); \n            if (loadBalancerLock == null)\n    \t\t{\n    \t\t\ts_logger.warn(\"Failed to acquire lock to delete load balance rule id \" + loadBalancerId);\n    \t\t\treturn false;\n    \t\t}\n\n            loadBalancer.setState(FirewallRule.State.Add);\n            _lbDao.persist(loadBalancer);\n            \n            for (long instanceId : instanceIds) {\n                LoadBalancerVMMapVO map = _lb2VmMapDao.findByLoadBalancerIdAndVmId(loadBalancerId, instanceId);\n                map.setRevoke(true);\n                _lb2VmMapDao.persist(map);\n                s_logger.debug(\"Set load balancer rule for revoke: rule id \" + loadBalancerId + \", vmId \" + instanceId);\n            }\n            \n            if (applyLoadBalancerConfig(loadBalancerId)) {\n                _lb2VmMapDao.remove(loadBalancerId, instanceIds, null);\n                s_logger.debug(\"Load balancer rule id \" + loadBalancerId + \" is removed for vms \" + instanceIds);\n            } else {\n                s_logger.warn(\"Failed to remove load balancer rule id \" + loadBalancerId + \" for vms \" + instanceIds);\n                throw new CloudRuntimeException(\"Failed to remove load balancer rule id \" + loadBalancerId + \" for vms \" + instanceIds);\n            }\n            \n        } catch (ResourceUnavailableException e) {\n            s_logger.warn(\"Unable to apply the load balancer config because resource is unavaliable.\", e);\n            return false;\n        } finally {\n        \tif (loadBalancerLock != null) {\n        \t\t_lbDao.releaseFromLockTable(loadBalancerId);\n        \t}\n        }\n       \n        return true;\n    }","commit_id":"368289aa122c33afdb2a433b829a0075f32a083d","url":"https://github.com/apache/cloudstack"},{"original_method":"public void setStateInOldStorage(Object component, final String componentName, Object state) throws StateStorage.StateStorageException {\n      assert mySession == this;\n      StateStorage stateStorage = getOldStorage(component, componentName, StateStorageOperation.WRITE);\n      myCompoundExternalizationSession.getExternalizationSession(stateStorage).setState(component, componentName, state, null);\n    }","id":91201,"modified_method":"public void setStateInOldStorage(Object component, final String componentName, Object state) throws StateStorage.StateStorageException {\n      assert mySession == this;\n      StateStorage stateStorage = getOldStorage(component, componentName, StateStorageOperation.WRITE);\n      if (stateStorage != null) {\n        myCompoundExternalizationSession.getExternalizationSession(stateStorage).setState(component, componentName, state, null);\n      }\n    }","commit_id":"872c3d7132942057fcf482b829385904b1aafaea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Used to convert HistoryRecord in CallReord and CallParticipantRecord\n     * which are returned by the finder methods\n     *\n     * @param hr HistoryRecord\n     * @return Object CallRecord\n     */\n    private Object convertHistoryRecordToCallRecord(HistoryRecord hr)\n    {\n        CallRecordImpl result = new CallRecordImpl();\n\n        LinkedList callParticipantIDs = null;\n        LinkedList callParticipantStart = null;\n        LinkedList callParticipantEnd = null;\n        LinkedList callParticipantStates = null;\n\n        // History structure\n        // 0 - callStart\n        // 1 - callEnd\n        // 2 - dir\n        // 3 - callParticipantIDs\n        // 4 - callParticipantStart\n        // 5 - callParticipantEnd\n\n        for (int i = 0; i < hr.getPropertyNames().length; i++)\n        {\n            String propName = hr.getPropertyNames()[i];\n            String value = hr.getPropertyValues()[i];\n\n            if(propName.equals(STRUCTURE_NAMES[0]))\n                result.setStartTime(new Date(Long.parseLong(value)));\n            else if(propName.equals(STRUCTURE_NAMES[1]))\n                result.setEndTime(new Date(Long.parseLong(value)));\n            else if(propName.equals(STRUCTURE_NAMES[2]))\n                result.setDirection(value);\n            else if(propName.equals(STRUCTURE_NAMES[3]))\n                callParticipantIDs = getCSVs(value);\n            else if(propName.equals(STRUCTURE_NAMES[4]))\n                callParticipantStart = getCSVs(value);\n            else if(propName.equals(STRUCTURE_NAMES[5]))\n                callParticipantEnd = getCSVs(value);\n            else if(propName.equals(STRUCTURE_NAMES[6]))\n                callParticipantStates = getStates(value);\n        }\n\n        for (int i = 0; i < callParticipantIDs.size(); i++)\n        {\n\n            CallParticipantRecordImpl cpr = new CallParticipantRecordImpl(\n                (String)callParticipantIDs.get(i),\n                new Date(Long.parseLong((String)callParticipantStart.get(i))),\n                new Date(Long.parseLong((String)callParticipantEnd.get(i)))\n                );\n            cpr.setState((CallParticipantState)callParticipantStates.get(i));\n            result.getParticipantRecords().add(cpr);\n        }\n\n        return result;\n    }","id":91202,"modified_method":"/**\n     * Used to convert HistoryRecord in CallReord and CallParticipantRecord\n     * which are returned by the finder methods\n     *\n     * @param hr HistoryRecord\n     * @return Object CallRecord\n     */\n    private Object convertHistoryRecordToCallRecord(HistoryRecord hr)\n    {\n        CallRecordImpl result = new CallRecordImpl();\n\n        LinkedList callParticipantIDs = null;\n        LinkedList callParticipantStart = null;\n        LinkedList callParticipantEnd = null;\n        LinkedList callParticipantStates = null;\n\n        // History structure\n        // 0 - callStart\n        // 1 - callEnd\n        // 2 - dir\n        // 3 - callParticipantIDs\n        // 4 - callParticipantStart\n        // 5 - callParticipantEnd\n\n        for (int i = 0; i < hr.getPropertyNames().length; i++)\n        {\n            String propName = hr.getPropertyNames()[i];\n            String value = hr.getPropertyValues()[i];\n\n            if(propName.equals(STRUCTURE_NAMES[0]))\n                result.setStartTime(new Date(Long.parseLong(value)));\n            else if(propName.equals(STRUCTURE_NAMES[1]))\n                result.setEndTime(new Date(Long.parseLong(value)));\n            else if(propName.equals(STRUCTURE_NAMES[2]))\n                result.setDirection(value);\n            else if(propName.equals(STRUCTURE_NAMES[3]))\n                callParticipantIDs = getCSVs(value);\n            else if(propName.equals(STRUCTURE_NAMES[4]))\n                callParticipantStart = getCSVs(value);\n            else if(propName.equals(STRUCTURE_NAMES[5]))\n                callParticipantEnd = getCSVs(value);\n            else if(propName.equals(STRUCTURE_NAMES[6]))\n                callParticipantStates = getStates(value);\n        }\n\n        for (int i = 0; i < callParticipantIDs.size(); i++)\n        {\n\n            CallParticipantRecordImpl cpr = new CallParticipantRecordImpl(\n                (String)callParticipantIDs.get(i),\n                new Date(Long.parseLong((String)callParticipantStart.get(i))),\n                new Date(Long.parseLong((String)callParticipantEnd.get(i)))\n                );\n\n            // if there is no record about the states (backward compability)\n            if(callParticipantStates != null)\n                cpr.setState((CallParticipantState)callParticipantStates.get(i));\n\n            result.getParticipantRecords().add(cpr);\n        }\n\n        return result;\n    }","commit_id":"33f5693ed617d7df620d8a9b5c4d7c22de8102f3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Cancels this <tt>ContactQuery<\/tt>.\n     *\n     * @see ContactQuery#cancel()\n     */\n    @Override\n    public void cancel()\n    {\n        ldapQuery.setState(LdapQuery.State.CANCELLED);\n        super.cancel();\n    }","id":91203,"modified_method":"/**\n     * Cancels this <tt>ContactQuery<\/tt>.\n     *\n     * @see ContactQuery#cancel()\n     */\n    @Override\n    public void cancel()\n    {\n        if(ldapQuery != null)\n        {\n            ldapQuery.setState(LdapQuery.State.CANCELLED);\n        }\n        super.cancel();\n    }","commit_id":"6e40d168a544fdc716f467f7bdc22d863fe71eed","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n    public HostResponse createHostResponse(Host host, EnumSet<HostDetails> details) {\n        HostResponse hostResponse = new HostResponse();\n        hostResponse.setId(host.getUuid());\n        hostResponse.setCapabilities(host.getCapabilities());\n        ClusterVO cluster = null;\n        if (host.getClusterId() != null) {\n            cluster = ApiDBUtils.findClusterById(host.getClusterId());\n            if (cluster != null) {\n                hostResponse.setClusterId(cluster.getUuid());\n            }\n        }\n        hostResponse.setCpuNumber(host.getCpus());\n        DataCenter zone = ApiDBUtils.findZoneById(host.getDataCenterId());\n        if (zone != null) {\n            hostResponse.setZoneId(zone.getUuid());\n        }\n        hostResponse.setDisconnectedOn(host.getDisconnectedOn());\n        hostResponse.setHypervisor(host.getHypervisorType());\n        hostResponse.setHostType(host.getType());\n        hostResponse.setLastPinged(new Date(host.getLastPinged()));\n        hostResponse.setManagementServerId(host.getManagementServerId());\n        hostResponse.setName(host.getName());\n        HostPodVO pod = ApiDBUtils.findPodById(host.getPodId());\n        if (pod != null) {\n            hostResponse.setPodId(pod.getUuid());\n        }\n        hostResponse.setRemoved(host.getRemoved());\n        hostResponse.setCpuSpeed(host.getSpeed());\n        hostResponse.setState(host.getStatus());\n        hostResponse.setIpAddress(host.getPrivateIpAddress());\n        hostResponse.setVersion(host.getVersion());\n        hostResponse.setCreated(host.getCreated());\n\n        if (details.contains(HostDetails.all) || details.contains(HostDetails.capacity)\n                || details.contains(HostDetails.stats) || details.contains(HostDetails.events)) {\n\n            GuestOSCategoryVO guestOSCategory = ApiDBUtils.getHostGuestOSCategory(host.getId());\n            if (guestOSCategory != null) {\n                hostResponse.setOsCategoryId(guestOSCategory.getUuid());\n                hostResponse.setOsCategoryName(guestOSCategory.getName());\n            }\n            if (zone != null) {\n                hostResponse.setZoneName(zone.getName());\n            }\n\n            if (pod != null) {\n                hostResponse.setPodName(pod.getName());\n            }\n\n            if (cluster != null) {\n                hostResponse.setClusterName(cluster.getName());\n                hostResponse.setClusterType(cluster.getClusterType().toString());\n            }\n        }\n\n        DecimalFormat decimalFormat = new DecimalFormat(\"#.##\");\n        if (host.getType() == Host.Type.Routing) {\n            if (details.contains(HostDetails.all) || details.contains(HostDetails.capacity)) {\n                // set allocated capacities\n                Long mem = ApiDBUtils.getMemoryOrCpuCapacitybyHost(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n                Long cpu = ApiDBUtils.getMemoryOrCpuCapacitybyHost(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n\n                hostResponse.setMemoryAllocated(mem);\n                hostResponse.setMemoryTotal(host.getTotalMemory());\n                String hostTags = ApiDBUtils.getHostTags(host.getId());\n                hostResponse.setHostTags(hostTags);\n\n                String haTag = ApiDBUtils.getHaTag();\n                if (haTag != null && !haTag.isEmpty() && hostTags != null && !hostTags.isEmpty()) {\n                    if (haTag.equalsIgnoreCase(hostTags)) {\n                        hostResponse.setHaHost(true);\n                    } else {\n                        hostResponse.setHaHost(false);\n                    }\n                } else {\n                    hostResponse.setHaHost(false);\n                }\n\n                hostResponse.setHypervisorVersion(host.getHypervisorVersion());\n\n                String cpuAlloc = decimalFormat.format(((float) cpu / (float) (host.getCpus() * host.getSpeed())) * 100f) + \"%\";\n                hostResponse.setCpuAllocated(cpuAlloc);\n                String cpuWithOverprovisioning = new Float(host.getCpus() * host.getSpeed() * ApiDBUtils.getCpuOverprovisioningFactor()).toString();\n                hostResponse.setCpuWithOverprovisioning(cpuWithOverprovisioning);\n            }\n\n            if (details.contains(HostDetails.all) || details.contains(HostDetails.stats)) {\n                // set CPU/RAM/Network stats\n                String cpuUsed = null;\n                HostStats hostStats = ApiDBUtils.getHostStatistics(host.getId());\n                if (hostStats != null) {\n                    float cpuUtil = (float) hostStats.getCpuUtilization();\n                    cpuUsed = decimalFormat.format(cpuUtil) + \"%\";\n                    hostResponse.setCpuUsed(cpuUsed);\n                    hostResponse.setMemoryUsed((new Double(hostStats.getUsedMemory())).longValue());\n                    hostResponse.setNetworkKbsRead((new Double(hostStats.getNetworkReadKBs())).longValue());\n                    hostResponse.setNetworkKbsWrite((new Double(hostStats.getNetworkWriteKBs())).longValue());\n\n                }\n            }\n\n        } else if (host.getType() == Host.Type.SecondaryStorage) {\n            StorageStats secStorageStats = ApiDBUtils.getSecondaryStorageStatistics(host.getId());\n            if (secStorageStats != null) {\n                hostResponse.setDiskSizeTotal(secStorageStats.getCapacityBytes());\n                hostResponse.setDiskSizeAllocated(secStorageStats.getByteUsed());\n            }\n        }\n\n        hostResponse.setLocalStorageActive(ApiDBUtils.isLocalStorageActiveOnHost(host));\n\n        if (details.contains(HostDetails.all) || details.contains(HostDetails.events)) {\n            Set<com.cloud.host.Status.Event> possibleEvents = host.getStatus().getPossibleEvents();\n            if ((possibleEvents != null) && !possibleEvents.isEmpty()) {\n                String events = \"\";\n                Iterator<com.cloud.host.Status.Event> iter = possibleEvents.iterator();\n                while (iter.hasNext()) {\n                    com.cloud.host.Status.Event event = iter.next();\n                    events += event.toString();\n                    if (iter.hasNext()) {\n                        events += \"; \";\n                    }\n                }\n                hostResponse.setEvents(events);\n            }\n        }\n\n        hostResponse.setResourceState(host.getResourceState().toString());\n        hostResponse.setObjectName(\"host\");\n\n        return hostResponse;\n    }","id":91204,"modified_method":"@Override\n    public HostResponse createHostResponse(Host host, EnumSet<HostDetails> details) {\n        HostResponse hostResponse = new HostResponse();\n        hostResponse.setId(host.getUuid());\n        hostResponse.setCapabilities(host.getCapabilities());\n        ClusterVO cluster = null;\n        if (host.getClusterId() != null) {\n            cluster = ApiDBUtils.findClusterById(host.getClusterId());\n            if (cluster != null) {\n                hostResponse.setClusterId(cluster.getUuid());\n            }\n        }\n        hostResponse.setCpuNumber(host.getCpus());\n        DataCenter zone = ApiDBUtils.findZoneById(host.getDataCenterId());\n        if (zone != null) {\n            hostResponse.setZoneId(zone.getUuid());\n        }\n        hostResponse.setDisconnectedOn(host.getDisconnectedOn());\n        hostResponse.setHypervisor(host.getHypervisorType());\n        hostResponse.setHostType(host.getType());\n        hostResponse.setLastPinged(new Date(host.getLastPinged()));\n        hostResponse.setManagementServerId(host.getManagementServerId());\n        hostResponse.setName(host.getName());\n        HostPodVO pod = ApiDBUtils.findPodById(host.getPodId());\n        if (pod != null) {\n            hostResponse.setPodId(pod.getUuid());\n        }\n        hostResponse.setRemoved(host.getRemoved());\n        hostResponse.setCpuSpeed(host.getSpeed());\n        hostResponse.setState(host.getStatus());\n        hostResponse.setIpAddress(host.getPrivateIpAddress());\n        hostResponse.setVersion(host.getVersion());\n        hostResponse.setCreated(host.getCreated());\n\n        if (details.contains(HostDetails.all) || details.contains(HostDetails.capacity)\n                || details.contains(HostDetails.stats) || details.contains(HostDetails.events)) {\n\n            GuestOSCategoryVO guestOSCategory = ApiDBUtils.getHostGuestOSCategory(host.getId());\n            if (guestOSCategory != null) {\n                hostResponse.setOsCategoryId(guestOSCategory.getUuid());\n                hostResponse.setOsCategoryName(guestOSCategory.getName());\n            }\n            if (zone != null) {\n                hostResponse.setZoneName(zone.getName());\n            }\n\n            if (pod != null) {\n                hostResponse.setPodName(pod.getName());\n            }\n\n            if (cluster != null) {\n                hostResponse.setClusterName(cluster.getName());\n                if (cluster.getClusterType() != null) {\n                    hostResponse.setClusterType(cluster.getClusterType().toString());\n                }\n            }\n        }\n\n        DecimalFormat decimalFormat = new DecimalFormat(\"#.##\");\n        if (host.getType() == Host.Type.Routing) {\n            if (details.contains(HostDetails.all) || details.contains(HostDetails.capacity)) {\n                // set allocated capacities\n                Long mem = ApiDBUtils.getMemoryOrCpuCapacitybyHost(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n                Long cpu = ApiDBUtils.getMemoryOrCpuCapacitybyHost(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n\n                hostResponse.setMemoryAllocated(mem);\n                hostResponse.setMemoryTotal(host.getTotalMemory());\n                String hostTags = ApiDBUtils.getHostTags(host.getId());\n                hostResponse.setHostTags(hostTags);\n\n                String haTag = ApiDBUtils.getHaTag();\n                if (haTag != null && !haTag.isEmpty() && hostTags != null && !hostTags.isEmpty()) {\n                    if (haTag.equalsIgnoreCase(hostTags)) {\n                        hostResponse.setHaHost(true);\n                    } else {\n                        hostResponse.setHaHost(false);\n                    }\n                } else {\n                    hostResponse.setHaHost(false);\n                }\n\n                hostResponse.setHypervisorVersion(host.getHypervisorVersion());\n\n                String cpuAlloc = decimalFormat.format(((float) cpu / (float) (host.getCpus() * host.getSpeed())) * 100f) + \"%\";\n                hostResponse.setCpuAllocated(cpuAlloc);\n                String cpuWithOverprovisioning = new Float(host.getCpus() * host.getSpeed() * ApiDBUtils.getCpuOverprovisioningFactor()).toString();\n                hostResponse.setCpuWithOverprovisioning(cpuWithOverprovisioning);\n            }\n\n            if (details.contains(HostDetails.all) || details.contains(HostDetails.stats)) {\n                // set CPU/RAM/Network stats\n                String cpuUsed = null;\n                HostStats hostStats = ApiDBUtils.getHostStatistics(host.getId());\n                if (hostStats != null) {\n                    float cpuUtil = (float) hostStats.getCpuUtilization();\n                    cpuUsed = decimalFormat.format(cpuUtil) + \"%\";\n                    hostResponse.setCpuUsed(cpuUsed);\n                    hostResponse.setMemoryUsed((new Double(hostStats.getUsedMemory())).longValue());\n                    hostResponse.setNetworkKbsRead((new Double(hostStats.getNetworkReadKBs())).longValue());\n                    hostResponse.setNetworkKbsWrite((new Double(hostStats.getNetworkWriteKBs())).longValue());\n\n                }\n            }\n\n        } else if (host.getType() == Host.Type.SecondaryStorage) {\n            StorageStats secStorageStats = ApiDBUtils.getSecondaryStorageStatistics(host.getId());\n            if (secStorageStats != null) {\n                hostResponse.setDiskSizeTotal(secStorageStats.getCapacityBytes());\n                hostResponse.setDiskSizeAllocated(secStorageStats.getByteUsed());\n            }\n        }\n\n        hostResponse.setLocalStorageActive(ApiDBUtils.isLocalStorageActiveOnHost(host));\n\n        if (details.contains(HostDetails.all) || details.contains(HostDetails.events)) {\n            Set<com.cloud.host.Status.Event> possibleEvents = host.getStatus().getPossibleEvents();\n            if ((possibleEvents != null) && !possibleEvents.isEmpty()) {\n                String events = \"\";\n                Iterator<com.cloud.host.Status.Event> iter = possibleEvents.iterator();\n                while (iter.hasNext()) {\n                    com.cloud.host.Status.Event event = iter.next();\n                    events += event.toString();\n                    if (iter.hasNext()) {\n                        events += \"; \";\n                    }\n                }\n                hostResponse.setEvents(events);\n            }\n        }\n\n        if (host.getResourceState() != null) {\n            hostResponse.setResourceState(host.getResourceState().toString());\n        }\n        hostResponse.setObjectName(\"host\");\n\n        return hostResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public StaticRouteResponse createStaticRouteResponse(StaticRoute result) {\n        StaticRouteResponse response = new StaticRouteResponse();\n        response.setId(result.getUuid());\n        if (result.getVpcId() != null) {\n            Vpc vpc = ApiDBUtils.findVpcById(result.getVpcId());\n            if (vpc != null) {\n                response.setVpcId(vpc.getUuid());\n            }\n        }\n        response.setCidr(result.getCidr());\n\n        StaticRoute.State state = result.getState();\n        String stateToSet = state.toString();\n        if (state.equals(FirewallRule.State.Revoke)) {\n            stateToSet = \"Deleting\";\n        }\n        response.setState(stateToSet);\n        populateAccount(response, result.getAccountId());\n        populateDomain(response, result.getDomainId());\n\n        //set tag information\n        List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.StaticRoute, result.getId());\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        response.setTags(tagResponses);\n        response.setObjectName(\"staticroute\");\n\n        return response;\n    }","id":91205,"modified_method":"@Override\n    public StaticRouteResponse createStaticRouteResponse(StaticRoute result) {\n        StaticRouteResponse response = new StaticRouteResponse();\n        response.setId(result.getUuid());\n        if (result.getVpcId() != null) {\n            Vpc vpc = ApiDBUtils.findVpcById(result.getVpcId());\n            if (vpc != null) {\n                response.setVpcId(vpc.getUuid());\n            }\n        }\n        response.setCidr(result.getCidr());\n\n        StaticRoute.State state = result.getState();\n        if (state != null) {\n            String stateToSet = state.toString();\n            if (state.equals(FirewallRule.State.Revoke)) {\n                stateToSet = \"Deleting\";\n            }\n            response.setState(stateToSet);\n        }\n        populateAccount(response, result.getAccountId());\n        populateDomain(response, result.getDomainId());\n\n        //set tag information\n        List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.StaticRoute, result.getId());\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        response.setTags(tagResponses);\n        response.setObjectName(\"staticroute\");\n\n        return response;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public VolumeResponse createVolumeResponse(Volume volume) {\n        VolumeResponse volResponse = new VolumeResponse();\n        volResponse.setId(volume.getId());\n\n        if (volume.getName() != null) {\n            volResponse.setName(volume.getName());\n        } else {\n            volResponse.setName(\"\");\n        }\n\n        volResponse.setZoneId(volume.getDataCenterId());\n        volResponse.setZoneName(ApiDBUtils.findZoneById(volume.getDataCenterId()).getName());\n\n        volResponse.setVolumeType(volume.getVolumeType().toString());\n        volResponse.setDeviceId(volume.getDeviceId());\n\n            Long instanceId = volume.getInstanceId();\n            if (instanceId != null && volume.getState() != Volume.State.Destroy) {\n                VMInstanceVO vm = ApiDBUtils.findVMInstanceById(instanceId);\n                if (vm != null) {\n                    volResponse.setVirtualMachineId(vm.getId());\n                    volResponse.setVirtualMachineName(vm.getHostName());\n                    UserVm userVm = ApiDBUtils.findUserVmById(vm.getId());\n                    if (userVm != null) {\n                        if (userVm.getDisplayName() != null) {\n                            volResponse.setVirtualMachineDisplayName(userVm.getDisplayName());\n                        } else {\n                            volResponse.setVirtualMachineDisplayName(userVm.getHostName());\n                        }\n                        volResponse.setVirtualMachineState(vm.getState().toString());\n                    } else {\n                        s_logger.error(\"User Vm with Id: \" + instanceId + \" does not exist for volume \" + volume.getId());\n                    }\n                } else {\n                    s_logger.error(\"Vm with Id: \" + instanceId + \" does not exist for volume \" + volume.getId());\n                }\n            }\n\n        // Show the virtual size of the volume\n        volResponse.setSize(volume.getSize());\n\n        volResponse.setCreated(volume.getCreated());\n        volResponse.setState(volume.getState().toString());\n        if(volume.getState() == Volume.State.UploadOp){\n            com.cloud.storage.VolumeHostVO volumeHostRef = ApiDBUtils.findVolumeHostRef(volume.getId(), volume.getDataCenterId());\n            volResponse.setSize(volumeHostRef.getSize());\n            volResponse.setCreated(volumeHostRef.getCreated());\n            Account caller = UserContext.current().getCaller();\n            if (caller.getType() == Account.ACCOUNT_TYPE_ADMIN || caller.getType() == Account.ACCOUNT_TYPE_RESOURCE_DOMAIN_ADMIN)\n                volResponse.setHypervisor(ApiDBUtils.getHypervisorTypeFromFormat(volumeHostRef.getFormat()).toString());\n            if (volumeHostRef.getDownloadState() != Status.DOWNLOADED) {\n                String volumeStatus = \"Processing\";\n                if (volumeHostRef.getDownloadState() == VMTemplateHostVO.Status.DOWNLOAD_IN_PROGRESS) {\n                    if (volumeHostRef.getDownloadPercent() == 100) {\n                        volumeStatus = \"Checking Volume\";\n                    } else {\n                        volumeStatus = volumeHostRef.getDownloadPercent() + \"% Uploaded\";\n                    }\n                    volResponse.setState(\"Uploading\");\n                } else {\n                    volumeStatus = volumeHostRef.getErrorString();\n                    if(volumeHostRef.getDownloadState() == VMTemplateHostVO.Status.NOT_DOWNLOADED){\n                        volResponse.setState(\"UploadNotStarted\");\n                    }else {\n                        volResponse.setState(\"UploadError\");\n                    }\n                }\n                volResponse.setStatus(volumeStatus);\n            } else if (volumeHostRef.getDownloadState() == VMTemplateHostVO.Status.DOWNLOADED) {\n                volResponse.setStatus(\"Upload Complete\");\n                volResponse.setState(\"Uploaded\");\n            } else {\n                volResponse.setStatus(\"Successfully Installed\");\n            }\n        }\n\n        populateOwner(volResponse, volume);\n\n        if (volume.getVolumeType().equals(Volume.Type.ROOT)) {\n            volResponse.setServiceOfferingId(volume.getDiskOfferingId());\n        } else {\n            volResponse.setDiskOfferingId(volume.getDiskOfferingId());\n        }\n\n        DiskOfferingVO diskOffering = ApiDBUtils.findDiskOfferingById(volume.getDiskOfferingId());\n        if (volume.getVolumeType().equals(Volume.Type.ROOT)) {\n            volResponse.setServiceOfferingName(diskOffering.getName());\n            volResponse.setServiceOfferingDisplayText(diskOffering.getDisplayText());\n        } else {\n            volResponse.setDiskOfferingName(diskOffering.getName());\n            volResponse.setDiskOfferingDisplayText(diskOffering.getDisplayText());\n        }\n        volResponse.setStorageType(diskOffering.getUseLocalStorage() ? ServiceOffering.StorageType.local.toString() : ServiceOffering.StorageType.shared.toString());\n\n        Long poolId = volume.getPoolId();\n        String poolName = (poolId == null) ? \"none\" : ApiDBUtils.findStoragePoolById(poolId).getName();\n        volResponse.setStoragePoolName(poolName);\n        // volResponse.setSourceId(volume.getSourceId());\n        // if (volume.getSourceType() != null) {\n        // volResponse.setSourceType(volume.getSourceType().toString());\n        // }\n\n        // return hypervisor for ROOT and Resource domain only\n        Account caller = UserContext.current().getCaller();\n        if ((caller.getType() == Account.ACCOUNT_TYPE_ADMIN || caller.getType() == Account.ACCOUNT_TYPE_RESOURCE_DOMAIN_ADMIN) && volume.getState() != Volume.State.UploadOp) {\n            volResponse.setHypervisor(ApiDBUtils.getVolumeHyperType(volume.getId()).toString());\n        }\n\n        volResponse.setAttached(volume.getAttached());\n        volResponse.setDestroyed(volume.getState() == Volume.State.Destroy);\n            boolean isExtractable = true;\n            if (volume.getVolumeType() != Volume.Type.DATADISK) { // Datadisk dont have any template dependence.\n                VMTemplateVO template = ApiDBUtils.findTemplateById(volume.getTemplateId());\n            if (template != null) { // For ISO based volumes template = null and we allow extraction of all ISO based volumes\n                    isExtractable = template.isExtractable() && template.getTemplateType() != Storage.TemplateType.SYSTEM;\n                }\n            }\n\n            //set tag information\n            List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.Volume, volume.getId());\n            List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n            for (ResourceTag tag : tags) {\n                ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n                tagResponses.add(tagResponse);\n            }\n            volResponse.setTags(tagResponses);\n\n        volResponse.setExtractable(isExtractable);\n        volResponse.setObjectName(\"volume\");\n        return volResponse;\n    }","id":91206,"modified_method":"@Override\n    public VolumeResponse createVolumeResponse(Volume volume) {\n        VolumeResponse volResponse = new VolumeResponse();\n        volResponse.setId(volume.getId());\n\n        if (volume.getName() != null) {\n            volResponse.setName(volume.getName());\n        } else {\n            volResponse.setName(\"\");\n        }\n\n        volResponse.setZoneId(volume.getDataCenterId());\n        volResponse.setZoneName(ApiDBUtils.findZoneById(volume.getDataCenterId()).getName());\n\n        if (volume.getVolumeType() != null) {\n            volResponse.setVolumeType(volume.getVolumeType().toString());\n        }\n        volResponse.setDeviceId(volume.getDeviceId());\n\n        Long instanceId = volume.getInstanceId();\n        if (instanceId != null && volume.getState() != Volume.State.Destroy) {\n            VMInstanceVO vm = ApiDBUtils.findVMInstanceById(instanceId);\n            if (vm != null) {\n                volResponse.setVirtualMachineId(vm.getId());\n                volResponse.setVirtualMachineName(vm.getHostName());\n                if (vm.getState() != null) {\n                    volResponse.setVirtualMachineState(vm.getState().toString());\n                }\n\n                UserVm userVm = ApiDBUtils.findUserVmById(vm.getId());\n                if (userVm != null) {\n                    if (userVm.getDisplayName() != null) {\n                        volResponse.setVirtualMachineDisplayName(userVm.getDisplayName());\n                    } else {\n                        volResponse.setVirtualMachineDisplayName(userVm.getHostName());\n                    }\n                } else {\n                    s_logger.error(\"User Vm with Id: \" + instanceId + \" does not exist for volume \" + volume.getId());\n                }\n            } else {\n                s_logger.error(\"Vm with Id: \" + instanceId + \" does not exist for volume \" + volume.getId());\n            }\n        }\n\n        // Show the virtual size of the volume\n        volResponse.setSize(volume.getSize());\n\n        volResponse.setCreated(volume.getCreated());\n        if (volume.getState() != null) {\n            volResponse.setState(volume.getState().toString());\n        }\n        if(volume.getState() == Volume.State.UploadOp){\n            com.cloud.storage.VolumeHostVO volumeHostRef = ApiDBUtils.findVolumeHostRef(volume.getId(), volume.getDataCenterId());\n            volResponse.setSize(volumeHostRef.getSize());\n            volResponse.setCreated(volumeHostRef.getCreated());\n            Account caller = UserContext.current().getCaller();\n            if (caller.getType() == Account.ACCOUNT_TYPE_ADMIN || caller.getType() == Account.ACCOUNT_TYPE_RESOURCE_DOMAIN_ADMIN)\n                volResponse.setHypervisor(ApiDBUtils.getHypervisorTypeFromFormat(volumeHostRef.getFormat()).toString());\n            if (volumeHostRef.getDownloadState() != Status.DOWNLOADED) {\n                String volumeStatus = \"Processing\";\n                if (volumeHostRef.getDownloadState() == VMTemplateHostVO.Status.DOWNLOAD_IN_PROGRESS) {\n                    if (volumeHostRef.getDownloadPercent() == 100) {\n                        volumeStatus = \"Checking Volume\";\n                    } else {\n                        volumeStatus = volumeHostRef.getDownloadPercent() + \"% Uploaded\";\n                    }\n                    volResponse.setState(\"Uploading\");\n                } else {\n                    volumeStatus = volumeHostRef.getErrorString();\n                    if(volumeHostRef.getDownloadState() == VMTemplateHostVO.Status.NOT_DOWNLOADED){\n                        volResponse.setState(\"UploadNotStarted\");\n                    }else {\n                        volResponse.setState(\"UploadError\");\n                    }\n                }\n                volResponse.setStatus(volumeStatus);\n            } else if (volumeHostRef.getDownloadState() == VMTemplateHostVO.Status.DOWNLOADED) {\n                volResponse.setStatus(\"Upload Complete\");\n                volResponse.setState(\"Uploaded\");\n            } else {\n                volResponse.setStatus(\"Successfully Installed\");\n            }\n        }\n\n        populateOwner(volResponse, volume);\n\n        if (volume.getVolumeType().equals(Volume.Type.ROOT)) {\n            volResponse.setServiceOfferingId(volume.getDiskOfferingId());\n        } else {\n            volResponse.setDiskOfferingId(volume.getDiskOfferingId());\n        }\n\n        DiskOfferingVO diskOffering = ApiDBUtils.findDiskOfferingById(volume.getDiskOfferingId());\n        if (volume.getVolumeType().equals(Volume.Type.ROOT)) {\n            volResponse.setServiceOfferingName(diskOffering.getName());\n            volResponse.setServiceOfferingDisplayText(diskOffering.getDisplayText());\n        } else {\n            volResponse.setDiskOfferingName(diskOffering.getName());\n            volResponse.setDiskOfferingDisplayText(diskOffering.getDisplayText());\n        }\n        volResponse.setStorageType(diskOffering.getUseLocalStorage() ? ServiceOffering.StorageType.local.toString() : ServiceOffering.StorageType.shared.toString());\n\n        Long poolId = volume.getPoolId();\n        String poolName = (poolId == null) ? \"none\" : ApiDBUtils.findStoragePoolById(poolId).getName();\n        volResponse.setStoragePoolName(poolName);\n        // volResponse.setSourceId(volume.getSourceId());\n        // if (volume.getSourceType() != null) {\n        // volResponse.setSourceType(volume.getSourceType().toString());\n        // }\n\n        // return hypervisor for ROOT and Resource domain only\n        Account caller = UserContext.current().getCaller();\n        if ((caller.getType() == Account.ACCOUNT_TYPE_ADMIN || caller.getType() == Account.ACCOUNT_TYPE_RESOURCE_DOMAIN_ADMIN) && volume.getState() != Volume.State.UploadOp) {\n            HypervisorType ht = ApiDBUtils.getVolumeHyperType(volume.getId());\n            if (ht != null) {\n                volResponse.setHypervisor(ht.toString());\n            }\n        }\n\n        volResponse.setAttached(volume.getAttached());\n        volResponse.setDestroyed(volume.getState() == Volume.State.Destroy);\n            boolean isExtractable = true;\n            if (volume.getVolumeType() != Volume.Type.DATADISK) { // Datadisk dont have any template dependence.\n                VMTemplateVO template = ApiDBUtils.findTemplateById(volume.getTemplateId());\n            if (template != null) { // For ISO based volumes template = null and we allow extraction of all ISO based volumes\n                    isExtractable = template.isExtractable() && template.getTemplateType() != Storage.TemplateType.SYSTEM;\n                }\n            }\n\n            //set tag information\n            List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.Volume, volume.getId());\n            List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n            for (ResourceTag tag : tags) {\n                ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n                tagResponses.add(tagResponse);\n            }\n            volResponse.setTags(tagResponses);\n\n        volResponse.setExtractable(isExtractable);\n        volResponse.setObjectName(\"volume\");\n        return volResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public PodResponse createPodResponse(Pod pod, Boolean showCapacities) {\n        String[] ipRange = new String[2];\n        if (pod.getDescription() != null && pod.getDescription().length() > 0) {\n            ipRange = pod.getDescription().split(\"-\");\n        } else {\n            ipRange[0] = pod.getDescription();\n        }\n\n        PodResponse podResponse = new PodResponse();\n        podResponse.setId(pod.getUuid());\n        podResponse.setName(pod.getName());\n        DataCenter zone = ApiDBUtils.findZoneById(pod.getDataCenterId());\n        if (zone != null) {\n            podResponse.setZoneId(zone.getUuid());\n            podResponse.setZoneName(zone.getName());\n        }\n        podResponse.setNetmask(NetUtils.getCidrNetmask(pod.getCidrSize()));\n        podResponse.setStartIp(ipRange[0]);\n        podResponse.setEndIp(((ipRange.length > 1) && (ipRange[1] != null)) ? ipRange[1] : \"\");\n        podResponse.setGateway(pod.getGateway());\n        podResponse.setAllocationState(pod.getAllocationState().toString());\n        if (showCapacities != null && showCapacities) {\n            List<SummedCapacity> capacities = ApiDBUtils.getCapacityByClusterPodZone(null, pod.getId(), null);\n            Set<CapacityResponse> capacityResponses = new HashSet<CapacityResponse>();\n            float cpuOverprovisioningFactor = ApiDBUtils.getCpuOverprovisioningFactor();\n\n            for (SummedCapacity capacity : capacities) {\n                CapacityResponse capacityResponse = new CapacityResponse();\n                capacityResponse.setCapacityType(capacity.getCapacityType());\n                capacityResponse.setCapacityUsed(capacity.getUsedCapacity());\n                if (capacity.getCapacityType() == Capacity.CAPACITY_TYPE_CPU) {\n                    capacityResponse.setCapacityTotal(new Long((long) (capacity.getTotalCapacity() * cpuOverprovisioningFactor)));\n                } else if (capacity.getCapacityType() == Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED) {\n                    List<SummedCapacity> c = ApiDBUtils.findNonSharedStorageForClusterPodZone(null, pod.getId(), null);\n                    capacityResponse.setCapacityTotal(capacity.getTotalCapacity() - c.get(0).getTotalCapacity());\n                    capacityResponse.setCapacityUsed(capacity.getUsedCapacity() - c.get(0).getUsedCapacity());\n                } else {\n                    capacityResponse.setCapacityTotal(capacity.getTotalCapacity());\n                }\n                if (capacityResponse.getCapacityTotal() != 0) {\n                    capacityResponse.setPercentUsed(s_percentFormat.format((float) capacityResponse.getCapacityUsed() / (float) capacityResponse.getCapacityTotal() * 100f));\n                } else {\n                    capacityResponse.setPercentUsed(s_percentFormat.format(0L));\n                }\n                capacityResponses.add(capacityResponse);\n            }\n            // Do it for stats as well.\n            capacityResponses.addAll(getStatsCapacityresponse(null, null, pod.getId(), pod.getDataCenterId()));\n            podResponse.setCapacitites(new ArrayList<CapacityResponse>(capacityResponses));\n        }\n        podResponse.setObjectName(\"pod\");\n        return podResponse;\n    }","id":91207,"modified_method":"@Override\n    public PodResponse createPodResponse(Pod pod, Boolean showCapacities) {\n        String[] ipRange = new String[2];\n        if (pod.getDescription() != null && pod.getDescription().length() > 0) {\n            ipRange = pod.getDescription().split(\"-\");\n        } else {\n            ipRange[0] = pod.getDescription();\n        }\n\n        PodResponse podResponse = new PodResponse();\n        podResponse.setId(pod.getUuid());\n        podResponse.setName(pod.getName());\n        DataCenter zone = ApiDBUtils.findZoneById(pod.getDataCenterId());\n        if (zone != null) {\n            podResponse.setZoneId(zone.getUuid());\n            podResponse.setZoneName(zone.getName());\n        }\n        podResponse.setNetmask(NetUtils.getCidrNetmask(pod.getCidrSize()));\n        podResponse.setStartIp(ipRange[0]);\n        podResponse.setEndIp(((ipRange.length > 1) && (ipRange[1] != null)) ? ipRange[1] : \"\");\n        podResponse.setGateway(pod.getGateway());\n        if (pod.getAllocationState() != null) {\n            podResponse.setAllocationState(pod.getAllocationState().toString());\n        }\n        if (showCapacities != null && showCapacities) {\n            List<SummedCapacity> capacities = ApiDBUtils.getCapacityByClusterPodZone(null, pod.getId(), null);\n            Set<CapacityResponse> capacityResponses = new HashSet<CapacityResponse>();\n            float cpuOverprovisioningFactor = ApiDBUtils.getCpuOverprovisioningFactor();\n\n            for (SummedCapacity capacity : capacities) {\n                CapacityResponse capacityResponse = new CapacityResponse();\n                capacityResponse.setCapacityType(capacity.getCapacityType());\n                capacityResponse.setCapacityUsed(capacity.getUsedCapacity());\n                if (capacity.getCapacityType() == Capacity.CAPACITY_TYPE_CPU) {\n                    capacityResponse.setCapacityTotal(new Long((long) (capacity.getTotalCapacity() * cpuOverprovisioningFactor)));\n                } else if (capacity.getCapacityType() == Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED) {\n                    List<SummedCapacity> c = ApiDBUtils.findNonSharedStorageForClusterPodZone(null, pod.getId(), null);\n                    capacityResponse.setCapacityTotal(capacity.getTotalCapacity() - c.get(0).getTotalCapacity());\n                    capacityResponse.setCapacityUsed(capacity.getUsedCapacity() - c.get(0).getUsedCapacity());\n                } else {\n                    capacityResponse.setCapacityTotal(capacity.getTotalCapacity());\n                }\n                if (capacityResponse.getCapacityTotal() != 0) {\n                    capacityResponse.setPercentUsed(s_percentFormat.format((float) capacityResponse.getCapacityUsed() / (float) capacityResponse.getCapacityTotal() * 100f));\n                } else {\n                    capacityResponse.setPercentUsed(s_percentFormat.format(0L));\n                }\n                capacityResponses.add(capacityResponse);\n            }\n            // Do it for stats as well.\n            capacityResponses.addAll(getStatsCapacityresponse(null, null, pod.getId(), pod.getDataCenterId()));\n            podResponse.setCapacitites(new ArrayList<CapacityResponse>(capacityResponses));\n        }\n        podResponse.setObjectName(\"pod\");\n        return podResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public SystemVmInstanceResponse createSystemVmInstanceResponse(VirtualMachine vm) {\n        SystemVmInstanceResponse vmResponse = new SystemVmInstanceResponse();\n        vmResponse.setId(vm.getUuid());\n        vmResponse.setSystemVmType(vm.getType().toString().toLowerCase());\n        vmResponse.setName(vm.getHostName());\n        if (vm.getHostId() != null) {\n            Host host = ApiDBUtils.findHostById(vm.getHostId());\n            if (host != null) {\n                vmResponse.setHostId(host.getUuid());\n            }\n        }\n        if (vm.getState() != null) {\n            vmResponse.setState(vm.getState().toString());\n        }\n        if (vm.getType() == Type.DomainRouter) {\n            VirtualRouter router = (VirtualRouter) vm;\n            if (router.getRole() != null) {\n                vmResponse.setRole(router.getRole().toString());\n            }\n        }\n        vmResponse.setObjectName(\"systemvminstance\");\n        return vmResponse;\n    }","id":91208,"modified_method":"@Override\n    public SystemVmInstanceResponse createSystemVmInstanceResponse(VirtualMachine vm) {\n        SystemVmInstanceResponse vmResponse = new SystemVmInstanceResponse();\n        vmResponse.setId(vm.getUuid());\n        if (vm.getType() != null) {\n            vmResponse.setSystemVmType(vm.getType().toString().toLowerCase());\n        }\n        vmResponse.setName(vm.getHostName());\n        if (vm.getHostId() != null) {\n            Host host = ApiDBUtils.findHostById(vm.getHostId());\n            if (host != null) {\n                vmResponse.setHostId(host.getUuid());\n            }\n        }\n        if (vm.getState() != null) {\n            vmResponse.setState(vm.getState().toString());\n        }\n        if (vm.getType() == Type.DomainRouter) {\n            VirtualRouter router = (VirtualRouter) vm;\n            if (router.getRole() != null) {\n                vmResponse.setRole(router.getRole().toString());\n            }\n        }\n        vmResponse.setObjectName(\"systemvminstance\");\n        return vmResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public DomainResponse createDomainResponse(Domain domain) {\n        DomainResponse domainResponse = new DomainResponse();\n        domainResponse.setDomainName(domain.getName());\n        domainResponse.setId(domain.getUuid());\n        domainResponse.setLevel(domain.getLevel());\n        domainResponse.setNetworkDomain(domain.getNetworkDomain());\n        Domain parentDomain = ApiDBUtils.findDomainById(domain.getParent());\n        if (parentDomain != null) {\n            domainResponse.setParentDomainId(parentDomain.getUuid());\n        }\n        StringBuilder domainPath = new StringBuilder(\"ROOT\");\n        (domainPath.append(domain.getPath())).deleteCharAt(domainPath.length() - 1);\n        domainResponse.setPath(domainPath.toString());\n        if (domain.getParent() != null) {\n            domainResponse.setParentDomainName(ApiDBUtils.findDomainById(domain.getParent()).getName());\n        }\n        if (domain.getChildCount() > 0) {\n            domainResponse.setHasChild(true);\n        }\n        domainResponse.setObjectName(\"domain\");\n        return domainResponse;\n    }","id":91209,"modified_method":"@Override\n    public DomainResponse createDomainResponse(Domain domain) {\n        DomainResponse domainResponse = new DomainResponse();\n        domainResponse.setDomainName(domain.getName());\n        domainResponse.setId(domain.getUuid());\n        domainResponse.setLevel(domain.getLevel());\n        domainResponse.setNetworkDomain(domain.getNetworkDomain());\n        if (domain.getParent() != null) {\n            Domain parentDomain = ApiDBUtils.findDomainById(domain.getParent());\n            if (parentDomain != null) {\n                domainResponse.setParentDomainId(parentDomain.getUuid());\n                domainResponse.setParentDomainName(parentDomain.getName());\n            }\n        }\n        StringBuilder domainPath = new StringBuilder(\"ROOT\");\n        (domainPath.append(domain.getPath())).deleteCharAt(domainPath.length() - 1);\n        domainResponse.setPath(domainPath.toString());\n\n        if (domain.getChildCount() > 0) {\n            domainResponse.setHasChild(true);\n        }\n        domainResponse.setObjectName(\"domain\");\n        return domainResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public List<CapacityResponse> createCapacityResponse(List<? extends Capacity> result, DecimalFormat format) {\n        List<CapacityResponse> capacityResponses = new ArrayList<CapacityResponse>();\n\n        for (Capacity summedCapacity : result) {\n            CapacityResponse capacityResponse = new CapacityResponse();\n            capacityResponse.setCapacityTotal(summedCapacity.getTotalCapacity());\n            capacityResponse.setCapacityType(summedCapacity.getCapacityType());\n            capacityResponse.setCapacityUsed(summedCapacity.getUsedCapacity());\n            if (summedCapacity.getPodId() != null) {\n                capacityResponse.setPodId(ApiDBUtils.findPodById(summedCapacity.getPodId()).getUuid());\n                HostPodVO pod = ApiDBUtils.findPodById(summedCapacity.getPodId());\n                if (pod != null) {\n                    capacityResponse.setPodId(pod.getUuid());\n                    capacityResponse.setPodName(pod.getName());\n                }\n            }\n            if (summedCapacity.getClusterId() != null) {\n                ClusterVO cluster = ApiDBUtils.findClusterById(summedCapacity.getClusterId());\n                if (cluster != null) {\n                    capacityResponse.setClusterId(cluster.getUuid());\n                    capacityResponse.setClusterName(cluster.getName());\n                    if (summedCapacity.getPodId() == null) {\n                        HostPodVO pod = ApiDBUtils.findPodById(cluster.getPodId());\n                        capacityResponse.setPodId(pod.getUuid());\n                        capacityResponse.setPodName(pod.getName());\n                    }\n                }\n            }\n            DataCenter zone = ApiDBUtils.findZoneById(summedCapacity.getDataCenterId());\n            if (zone != null) {\n                capacityResponse.setZoneId(zone.getUuid());\n                capacityResponse.setZoneName(zone.getName());\n            }\n            if (summedCapacity.getUsedPercentage() != null){\n                capacityResponse.setPercentUsed(format.format(summedCapacity.getUsedPercentage() * 100f));\n            } else if (summedCapacity.getTotalCapacity() != 0) {\n                capacityResponse.setPercentUsed(format.format((float) summedCapacity.getUsedCapacity() / (float) summedCapacity.getTotalCapacity() * 100f));\n            } else {\n                capacityResponse.setPercentUsed(format.format(0L));\n            }\n\n            capacityResponse.setObjectName(\"capacity\");\n            capacityResponses.add(capacityResponse);\n        }\n\n        return capacityResponses;\n    }","id":91210,"modified_method":"@Override\n    public List<CapacityResponse> createCapacityResponse(List<? extends Capacity> result, DecimalFormat format) {\n        List<CapacityResponse> capacityResponses = new ArrayList<CapacityResponse>();\n\n        for (Capacity summedCapacity : result) {\n            CapacityResponse capacityResponse = new CapacityResponse();\n            capacityResponse.setCapacityTotal(summedCapacity.getTotalCapacity());\n            capacityResponse.setCapacityType(summedCapacity.getCapacityType());\n            capacityResponse.setCapacityUsed(summedCapacity.getUsedCapacity());\n            if (summedCapacity.getPodId() != null) {\n                HostPodVO pod = ApiDBUtils.findPodById(summedCapacity.getPodId());\n                if (pod != null) {\n                    capacityResponse.setPodId(pod.getUuid());\n                    capacityResponse.setPodName(pod.getName());\n                }\n            }\n            if (summedCapacity.getClusterId() != null) {\n                ClusterVO cluster = ApiDBUtils.findClusterById(summedCapacity.getClusterId());\n                if (cluster != null) {\n                    capacityResponse.setClusterId(cluster.getUuid());\n                    capacityResponse.setClusterName(cluster.getName());\n                    if (summedCapacity.getPodId() == null) {\n                        HostPodVO pod = ApiDBUtils.findPodById(cluster.getPodId());\n                        capacityResponse.setPodId(pod.getUuid());\n                        capacityResponse.setPodName(pod.getName());\n                    }\n                }\n            }\n            DataCenter zone = ApiDBUtils.findZoneById(summedCapacity.getDataCenterId());\n            if (zone != null) {\n                capacityResponse.setZoneId(zone.getUuid());\n                capacityResponse.setZoneName(zone.getName());\n            }\n            if (summedCapacity.getUsedPercentage() != null){\n                capacityResponse.setPercentUsed(format.format(summedCapacity.getUsedPercentage() * 100f));\n            } else if (summedCapacity.getTotalCapacity() != 0) {\n                capacityResponse.setPercentUsed(format.format((float) summedCapacity.getUsedCapacity() / (float) summedCapacity.getTotalCapacity() * 100f));\n            } else {\n                capacityResponse.setPercentUsed(format.format(0L));\n            }\n\n            capacityResponse.setObjectName(\"capacity\");\n            capacityResponses.add(capacityResponse);\n        }\n\n        return capacityResponses;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public ClusterResponse createClusterResponse(Cluster cluster, Boolean showCapacities) {\n        ClusterResponse clusterResponse = new ClusterResponse();\n        clusterResponse.setId(cluster.getUuid());\n        clusterResponse.setName(cluster.getName());\n        HostPodVO pod = ApiDBUtils.findPodById(cluster.getPodId());\n        if (pod != null) {\n            clusterResponse.setPodId(pod.getUuid());\n            clusterResponse.setPodName(pod.getName());\n        }\n        DataCenter dc = ApiDBUtils.findZoneById(cluster.getDataCenterId());\n        if (dc != null) {\n            clusterResponse.setZoneId(dc.getUuid());\n            clusterResponse.setZoneName(dc.getName());\n        }\n        clusterResponse.setHypervisorType(cluster.getHypervisorType().toString());\n        clusterResponse.setClusterType(cluster.getClusterType().toString());\n        clusterResponse.setAllocationState(cluster.getAllocationState().toString());\n        clusterResponse.setManagedState(cluster.getManagedState().toString());\n\n\n        if (showCapacities != null && showCapacities) {\n            List<SummedCapacity> capacities = ApiDBUtils.getCapacityByClusterPodZone(null, null, cluster.getId());\n            Set<CapacityResponse> capacityResponses = new HashSet<CapacityResponse>();\n            float cpuOverprovisioningFactor = ApiDBUtils.getCpuOverprovisioningFactor();\n\n            for (SummedCapacity capacity : capacities) {\n                CapacityResponse capacityResponse = new CapacityResponse();\n                capacityResponse.setCapacityType(capacity.getCapacityType());\n                capacityResponse.setCapacityUsed(capacity.getUsedCapacity());\n\n                if (capacity.getCapacityType() == Capacity.CAPACITY_TYPE_CPU) {\n                    capacityResponse.setCapacityTotal(new Long((long) (capacity.getTotalCapacity() * cpuOverprovisioningFactor)));\n                } else if (capacity.getCapacityType() == Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED) {\n                    List<SummedCapacity> c = ApiDBUtils.findNonSharedStorageForClusterPodZone(null, null, cluster.getId());\n                    capacityResponse.setCapacityTotal(capacity.getTotalCapacity() - c.get(0).getTotalCapacity());\n                    capacityResponse.setCapacityUsed(capacity.getUsedCapacity() - c.get(0).getUsedCapacity());\n                } else {\n                    capacityResponse.setCapacityTotal(capacity.getTotalCapacity());\n                }\n                if (capacityResponse.getCapacityTotal() != 0) {\n                    capacityResponse.setPercentUsed(s_percentFormat.format((float) capacityResponse.getCapacityUsed() / (float) capacityResponse.getCapacityTotal() * 100f));\n                } else {\n                    capacityResponse.setPercentUsed(s_percentFormat.format(0L));\n                }\n                capacityResponses.add(capacityResponse);\n            }\n            // Do it for stats as well.\n            capacityResponses.addAll(getStatsCapacityresponse(null, cluster.getId(), pod.getId(), pod.getDataCenterId()));\n            clusterResponse.setCapacitites(new ArrayList<CapacityResponse>(capacityResponses));\n        }\n        clusterResponse.setObjectName(\"cluster\");\n        return clusterResponse;\n    }","id":91211,"modified_method":"@Override\n    public ClusterResponse createClusterResponse(Cluster cluster, Boolean showCapacities) {\n        ClusterResponse clusterResponse = new ClusterResponse();\n        clusterResponse.setId(cluster.getUuid());\n        clusterResponse.setName(cluster.getName());\n        HostPodVO pod = ApiDBUtils.findPodById(cluster.getPodId());\n        if (pod != null) {\n            clusterResponse.setPodId(pod.getUuid());\n            clusterResponse.setPodName(pod.getName());\n        }\n        DataCenter dc = ApiDBUtils.findZoneById(cluster.getDataCenterId());\n        if (dc != null) {\n            clusterResponse.setZoneId(dc.getUuid());\n            clusterResponse.setZoneName(dc.getName());\n        }\n        if (cluster.getHypervisorType() != null) {\n            clusterResponse.setHypervisorType(cluster.getHypervisorType().toString());\n        }\n        if (cluster.getClusterType() != null) {\n            clusterResponse.setClusterType(cluster.getClusterType().toString());\n        }\n        if (cluster.getAllocationState() != null) {\n            clusterResponse.setAllocationState(cluster.getAllocationState().toString());\n        }\n        if (cluster.getManagedState() != null) {\n            clusterResponse.setManagedState(cluster.getManagedState().toString());\n        }\n\n\n        if (showCapacities != null && showCapacities) {\n            List<SummedCapacity> capacities = ApiDBUtils.getCapacityByClusterPodZone(null, null, cluster.getId());\n            Set<CapacityResponse> capacityResponses = new HashSet<CapacityResponse>();\n            float cpuOverprovisioningFactor = ApiDBUtils.getCpuOverprovisioningFactor();\n\n            for (SummedCapacity capacity : capacities) {\n                CapacityResponse capacityResponse = new CapacityResponse();\n                capacityResponse.setCapacityType(capacity.getCapacityType());\n                capacityResponse.setCapacityUsed(capacity.getUsedCapacity());\n\n                if (capacity.getCapacityType() == Capacity.CAPACITY_TYPE_CPU) {\n                    capacityResponse.setCapacityTotal(new Long((long) (capacity.getTotalCapacity() * cpuOverprovisioningFactor)));\n                } else if (capacity.getCapacityType() == Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED) {\n                    List<SummedCapacity> c = ApiDBUtils.findNonSharedStorageForClusterPodZone(null, null, cluster.getId());\n                    capacityResponse.setCapacityTotal(capacity.getTotalCapacity() - c.get(0).getTotalCapacity());\n                    capacityResponse.setCapacityUsed(capacity.getUsedCapacity() - c.get(0).getUsedCapacity());\n                } else {\n                    capacityResponse.setCapacityTotal(capacity.getTotalCapacity());\n                }\n                if (capacityResponse.getCapacityTotal() != 0) {\n                    capacityResponse.setPercentUsed(s_percentFormat.format((float) capacityResponse.getCapacityUsed() / (float) capacityResponse.getCapacityTotal() * 100f));\n                } else {\n                    capacityResponse.setPercentUsed(s_percentFormat.format(0L));\n                }\n                capacityResponses.add(capacityResponse);\n            }\n            // Do it for stats as well.\n            capacityResponses.addAll(getStatsCapacityresponse(null, cluster.getId(), pod.getId(), pod.getDataCenterId()));\n            clusterResponse.setCapacitites(new ArrayList<CapacityResponse>(capacityResponses));\n        }\n        clusterResponse.setObjectName(\"cluster\");\n        return clusterResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public List<TemplateResponse> createTemplateResponses(long templateId, long zoneId, boolean readyOnly) {\n        VirtualMachineTemplate template = findTemplateById(templateId);\n        List<TemplateResponse> responses = new ArrayList<TemplateResponse>();\n        VMTemplateHostVO templateHostRef = ApiDBUtils.findTemplateHostRef(templateId, zoneId, readyOnly);\n        if (templateHostRef == null) {\n            return responses;\n        }\n\n        HostVO host = ApiDBUtils.findHostById(templateHostRef.getHostId());\n        if (host.getType() == Host.Type.LocalSecondaryStorage && host.getStatus() != com.cloud.host.Status.Up) {\n            return responses;\n        }\n\n        TemplateResponse templateResponse = new TemplateResponse();\n        templateResponse.setId(template.getUuid());\n        templateResponse.setName(template.getName());\n        templateResponse.setDisplayText(template.getDisplayText());\n        templateResponse.setPublic(template.isPublicTemplate());\n        templateResponse.setCreated(templateHostRef.getCreated());\n\n        templateResponse.setReady(templateHostRef.getDownloadState() == Status.DOWNLOADED);\n        templateResponse.setFeatured(template.isFeatured());\n        templateResponse.setExtractable(template.isExtractable() && !(template.getTemplateType() == TemplateType.SYSTEM));\n        templateResponse.setPasswordEnabled(template.getEnablePassword());\n        templateResponse.setCrossZones(template.isCrossZones());\n        templateResponse.setFormat(template.getFormat());\n        if (template.getTemplateType() != null) {\n            templateResponse.setTemplateType(template.getTemplateType().toString());\n        }\n\n        templateResponse.setHypervisor(template.getHypervisorType().toString());\n        templateResponse.setDetails(template.getDetails());\n\n        GuestOS os = ApiDBUtils.findGuestOSById(template.getGuestOSId());\n        if (os != null) {\n            templateResponse.setOsTypeId(os.getUuid());\n            templateResponse.setOsTypeName(os.getDisplayName());\n        } else {\n            templateResponse.setOsTypeId(\"-1\");\n            templateResponse.setOsTypeName(\"\");\n        }\n\n        Account account = ApiDBUtils.findAccountByIdIncludingRemoved(template.getAccountId());\n        populateAccount(templateResponse, account.getId());\n        populateDomain(templateResponse, account.getDomainId());\n\n        DataCenter datacenter = ApiDBUtils.findZoneById(zoneId);\n\n        if (datacenter != null) {\n            // Add the zone ID\n            templateResponse.setZoneId(datacenter.getUuid());\n            templateResponse.setZoneName(datacenter.getName());\n        }\n\n        boolean isAdmin = false;\n        Account caller = UserContext.current().getCaller();\n        if ((caller == null) || BaseCmd.isAdmin(caller.getType())) {\n            isAdmin = true;\n        }\n\n        // If the user is an Admin, add the template download status\n        if (isAdmin || caller.getId() == template.getAccountId()) {\n            // add download status\n            if (templateHostRef.getDownloadState() != Status.DOWNLOADED) {\n                String templateStatus = \"Processing\";\n                if (templateHostRef.getDownloadState() == VMTemplateHostVO.Status.DOWNLOAD_IN_PROGRESS) {\n                    if (templateHostRef.getDownloadPercent() == 100) {\n                        templateStatus = \"Installing Template\";\n                    } else {\n                        templateStatus = templateHostRef.getDownloadPercent() + \"% Downloaded\";\n                    }\n                } else {\n                    templateStatus = templateHostRef.getErrorString();\n                }\n                templateResponse.setStatus(templateStatus);\n            } else if (templateHostRef.getDownloadState() == VMTemplateHostVO.Status.DOWNLOADED) {\n                templateResponse.setStatus(\"Download Complete\");\n            } else {\n                templateResponse.setStatus(\"Successfully Installed\");\n            }\n        }\n\n        Long templateSize = templateHostRef.getSize();\n        if (templateSize > 0) {\n            templateResponse.setSize(templateSize);\n        }\n\n        templateResponse.setChecksum(template.getChecksum());\n        if (template.getSourceTemplateId() != null) {\n            VirtualMachineTemplate tmpl = ApiDBUtils.findTemplateById(template.getSourceTemplateId());\n            if (tmpl != null) {\n                templateResponse.setSourceTemplateId(tmpl.getUuid());\n            }\n        }\n\n        templateResponse.setChecksum(template.getChecksum());\n\n        templateResponse.setTemplateTag(template.getTemplateTag());\n\n        //set tag information\n        List<? extends ResourceTag> tags = null;\n        if (template.getFormat() == ImageFormat.ISO) {\n            tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.ISO, template.getId());\n        } else {\n            tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.Template, template.getId());\n        }\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        templateResponse.setTags(tagResponses);\n\n        templateResponse.setObjectName(\"template\");\n        responses.add(templateResponse);\n        return responses;\n    }","id":91212,"modified_method":"@Override\n    public List<TemplateResponse> createTemplateResponses(long templateId, long zoneId, boolean readyOnly) {\n        VirtualMachineTemplate template = findTemplateById(templateId);\n        List<TemplateResponse> responses = new ArrayList<TemplateResponse>();\n        VMTemplateHostVO templateHostRef = ApiDBUtils.findTemplateHostRef(templateId, zoneId, readyOnly);\n        if (templateHostRef == null) {\n            return responses;\n        }\n\n        HostVO host = ApiDBUtils.findHostById(templateHostRef.getHostId());\n        if (host.getType() == Host.Type.LocalSecondaryStorage && host.getStatus() != com.cloud.host.Status.Up) {\n            return responses;\n        }\n\n        TemplateResponse templateResponse = new TemplateResponse();\n        templateResponse.setId(template.getUuid());\n        templateResponse.setName(template.getName());\n        templateResponse.setDisplayText(template.getDisplayText());\n        templateResponse.setPublic(template.isPublicTemplate());\n        templateResponse.setCreated(templateHostRef.getCreated());\n\n        templateResponse.setReady(templateHostRef.getDownloadState() == Status.DOWNLOADED);\n        templateResponse.setFeatured(template.isFeatured());\n        templateResponse.setExtractable(template.isExtractable() && !(template.getTemplateType() == TemplateType.SYSTEM));\n        templateResponse.setPasswordEnabled(template.getEnablePassword());\n        templateResponse.setCrossZones(template.isCrossZones());\n        templateResponse.setFormat(template.getFormat());\n        if (template.getTemplateType() != null) {\n            templateResponse.setTemplateType(template.getTemplateType().toString());\n        }\n\n        if (template.getHypervisorType() != null) {\n            templateResponse.setHypervisor(template.getHypervisorType().toString());\n        }\n        templateResponse.setDetails(template.getDetails());\n\n        GuestOS os = ApiDBUtils.findGuestOSById(template.getGuestOSId());\n        if (os != null) {\n            templateResponse.setOsTypeId(os.getUuid());\n            templateResponse.setOsTypeName(os.getDisplayName());\n        } else {\n            templateResponse.setOsTypeId(\"-1\");\n            templateResponse.setOsTypeName(\"\");\n        }\n\n        Account account = ApiDBUtils.findAccountByIdIncludingRemoved(template.getAccountId());\n        populateAccount(templateResponse, account.getId());\n        populateDomain(templateResponse, account.getDomainId());\n\n        DataCenter datacenter = ApiDBUtils.findZoneById(zoneId);\n\n        if (datacenter != null) {\n            // Add the zone ID\n            templateResponse.setZoneId(datacenter.getUuid());\n            templateResponse.setZoneName(datacenter.getName());\n        }\n\n        boolean isAdmin = false;\n        Account caller = UserContext.current().getCaller();\n        if ((caller == null) || BaseCmd.isAdmin(caller.getType())) {\n            isAdmin = true;\n        }\n\n        // If the user is an Admin, add the template download status\n        if (isAdmin || caller.getId() == template.getAccountId()) {\n            // add download status\n            if (templateHostRef.getDownloadState() != Status.DOWNLOADED) {\n                String templateStatus = \"Processing\";\n                if (templateHostRef.getDownloadState() == VMTemplateHostVO.Status.DOWNLOAD_IN_PROGRESS) {\n                    if (templateHostRef.getDownloadPercent() == 100) {\n                        templateStatus = \"Installing Template\";\n                    } else {\n                        templateStatus = templateHostRef.getDownloadPercent() + \"% Downloaded\";\n                    }\n                } else {\n                    templateStatus = templateHostRef.getErrorString();\n                }\n                templateResponse.setStatus(templateStatus);\n            } else if (templateHostRef.getDownloadState() == VMTemplateHostVO.Status.DOWNLOADED) {\n                templateResponse.setStatus(\"Download Complete\");\n            } else {\n                templateResponse.setStatus(\"Successfully Installed\");\n            }\n        }\n\n        Long templateSize = templateHostRef.getSize();\n        if (templateSize > 0) {\n            templateResponse.setSize(templateSize);\n        }\n\n        templateResponse.setChecksum(template.getChecksum());\n        if (template.getSourceTemplateId() != null) {\n            VirtualMachineTemplate tmpl = ApiDBUtils.findTemplateById(template.getSourceTemplateId());\n            if (tmpl != null) {\n                templateResponse.setSourceTemplateId(tmpl.getUuid());\n            }\n        }\n\n        templateResponse.setChecksum(template.getChecksum());\n\n        templateResponse.setTemplateTag(template.getTemplateTag());\n\n        //set tag information\n        List<? extends ResourceTag> tags = null;\n        if (template.getFormat() == ImageFormat.ISO) {\n            tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.ISO, template.getId());\n        } else {\n            tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.Template, template.getId());\n        }\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        templateResponse.setTags(tagResponses);\n\n        templateResponse.setObjectName(\"template\");\n        responses.add(templateResponse);\n        return responses;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public ConditionResponse createConditionResponse(Condition condition) {\n        ConditionResponse response = new ConditionResponse();\n        response.setId(condition.getUuid());\n        List<CounterResponse> counterResponseList = new ArrayList<CounterResponse>();\n        counterResponseList.add(createCounterResponse(ApiDBUtils.getCounter(condition.getCounterid())));\n        response.setCounterResponse(counterResponseList);\n        response.setRelationalOperator(condition.getRelationalOperator().toString());\n        response.setThreshold(condition.getThreshold());\n        response.setObjectName(\"condition\");\n        populateOwner(response, condition);\n        return response;\n    }","id":91213,"modified_method":"@Override\n    public ConditionResponse createConditionResponse(Condition condition) {\n        ConditionResponse response = new ConditionResponse();\n        response.setId(condition.getUuid());\n        List<CounterResponse> counterResponseList = new ArrayList<CounterResponse>();\n        counterResponseList.add(createCounterResponse(ApiDBUtils.getCounter(condition.getCounterid())));\n        response.setCounterResponse(counterResponseList);\n        if (condition.getRelationalOperator() != null) {\n            response.setRelationalOperator(condition.getRelationalOperator().toString());\n        }\n        response.setThreshold(condition.getThreshold());\n        response.setObjectName(\"condition\");\n        populateOwner(response, condition);\n        return response;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"private List<TemplateResponse> createSwiftTemplateResponses(long templateId) {\n        VirtualMachineTemplate template = findTemplateById(templateId);\n        List<TemplateResponse> responses = new ArrayList<TemplateResponse>();\n        VMTemplateSwiftVO templateSwiftRef = ApiDBUtils.findTemplateSwiftRef(templateId);\n        if (templateSwiftRef == null) {\n            return responses;\n        }\n\n        TemplateResponse templateResponse = new TemplateResponse();\n        templateResponse.setId(template.getUuid());\n        templateResponse.setName(template.getName());\n        templateResponse.setDisplayText(template.getDisplayText());\n        templateResponse.setPublic(template.isPublicTemplate());\n        templateResponse.setCreated(templateSwiftRef.getCreated());\n\n        templateResponse.setReady(true);\n        templateResponse.setFeatured(template.isFeatured());\n        templateResponse.setExtractable(template.isExtractable() && !(template.getTemplateType() == TemplateType.SYSTEM));\n        templateResponse.setPasswordEnabled(template.getEnablePassword());\n        templateResponse.setCrossZones(template.isCrossZones());\n        templateResponse.setFormat(template.getFormat());\n        templateResponse.setDetails(template.getDetails());\n        if (template.getTemplateType() != null) {\n            templateResponse.setTemplateType(template.getTemplateType().toString());\n        }\n\n        templateResponse.setHypervisor(template.getHypervisorType().toString());\n\n        GuestOS os = ApiDBUtils.findGuestOSById(template.getGuestOSId());\n        if (os != null) {\n            templateResponse.setOsTypeId(os.getUuid());\n            templateResponse.setOsTypeName(os.getDisplayName());\n        } else {\n            templateResponse.setOsTypeId(\"-1\");\n            templateResponse.setOsTypeName(\"\");\n        }\n\n        Account account = ApiDBUtils.findAccountByIdIncludingRemoved(template.getAccountId());\n        populateAccount(templateResponse, account.getId());\n        populateDomain(templateResponse, account.getDomainId());\n\n        Account caller = UserContext.current().getCaller();\n        boolean isAdmin = false;\n        if (BaseCmd.isAdmin(caller.getType())) {\n            isAdmin = true;\n        }\n\n        // If the user is an Admin, add the template download status\n        if (isAdmin || caller.getId() == template.getAccountId()) {\n            // add download status\n            templateResponse.setStatus(\"Successfully Installed\");\n        }\n\n        Long templateSize = templateSwiftRef.getSize();\n        if (templateSize > 0) {\n            templateResponse.setSize(templateSize);\n        }\n\n        templateResponse.setChecksum(template.getChecksum());\n        if (template.getSourceTemplateId() != null) {\n            VirtualMachineTemplate tmpl = ApiDBUtils.findTemplateById(template.getSourceTemplateId());\n            if (tmpl != null) {\n                templateResponse.setSourceTemplateId(tmpl.getUuid());\n            }\n        }\n\n        templateResponse.setChecksum(template.getChecksum());\n\n        templateResponse.setTemplateTag(template.getTemplateTag());\n\n        templateResponse.setObjectName(\"template\");\n        responses.add(templateResponse);\n        return responses;\n    }","id":91214,"modified_method":"private List<TemplateResponse> createSwiftTemplateResponses(long templateId) {\n        VirtualMachineTemplate template = findTemplateById(templateId);\n        List<TemplateResponse> responses = new ArrayList<TemplateResponse>();\n        VMTemplateSwiftVO templateSwiftRef = ApiDBUtils.findTemplateSwiftRef(templateId);\n        if (templateSwiftRef == null) {\n            return responses;\n        }\n\n        TemplateResponse templateResponse = new TemplateResponse();\n        templateResponse.setId(template.getUuid());\n        templateResponse.setName(template.getName());\n        templateResponse.setDisplayText(template.getDisplayText());\n        templateResponse.setPublic(template.isPublicTemplate());\n        templateResponse.setCreated(templateSwiftRef.getCreated());\n\n        templateResponse.setReady(true);\n        templateResponse.setFeatured(template.isFeatured());\n        templateResponse.setExtractable(template.isExtractable() && !(template.getTemplateType() == TemplateType.SYSTEM));\n        templateResponse.setPasswordEnabled(template.getEnablePassword());\n        templateResponse.setCrossZones(template.isCrossZones());\n        templateResponse.setFormat(template.getFormat());\n        templateResponse.setDetails(template.getDetails());\n        if (template.getTemplateType() != null) {\n            templateResponse.setTemplateType(template.getTemplateType().toString());\n        }\n\n        if (template.getHypervisorType() != null) {\n            templateResponse.setHypervisor(template.getHypervisorType().toString());\n        }\n\n        GuestOS os = ApiDBUtils.findGuestOSById(template.getGuestOSId());\n        if (os != null) {\n            templateResponse.setOsTypeId(os.getUuid());\n            templateResponse.setOsTypeName(os.getDisplayName());\n        } else {\n            templateResponse.setOsTypeId(\"-1\");\n            templateResponse.setOsTypeName(\"\");\n        }\n\n        Account account = ApiDBUtils.findAccountByIdIncludingRemoved(template.getAccountId());\n        populateAccount(templateResponse, account.getId());\n        populateDomain(templateResponse, account.getDomainId());\n\n        Account caller = UserContext.current().getCaller();\n        boolean isAdmin = false;\n        if (BaseCmd.isAdmin(caller.getType())) {\n            isAdmin = true;\n        }\n\n        // If the user is an Admin, add the template download status\n        if (isAdmin || caller.getId() == template.getAccountId()) {\n            // add download status\n            templateResponse.setStatus(\"Successfully Installed\");\n        }\n\n        Long templateSize = templateSwiftRef.getSize();\n        if (templateSize > 0) {\n            templateResponse.setSize(templateSize);\n        }\n\n        templateResponse.setChecksum(template.getChecksum());\n        if (template.getSourceTemplateId() != null) {\n            VirtualMachineTemplate tmpl = ApiDBUtils.findTemplateById(template.getSourceTemplateId());\n            if (tmpl != null) {\n                templateResponse.setSourceTemplateId(tmpl.getUuid());\n            }\n        }\n\n        templateResponse.setChecksum(template.getChecksum());\n\n        templateResponse.setTemplateTag(template.getTemplateTag());\n\n        templateResponse.setObjectName(\"template\");\n        responses.add(templateResponse);\n        return responses;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public PrivateGatewayResponse createPrivateGatewayResponse(PrivateGateway result) {\n        PrivateGatewayResponse response = new PrivateGatewayResponse();\n        response.setId(result.getUuid());\n        response.setVlan(result.getVlanTag());\n        response.setGateway(result.getGateway());\n        response.setNetmask(result.getNetmask());\n        if (result.getVpcId() != null) {\n            Vpc vpc = ApiDBUtils.findVpcById(result.getVpcId());\n            response.setVpcId(vpc.getUuid());\n        }\n\n        DataCenter zone = ApiDBUtils.findZoneById(result.getZoneId());\n        if (zone != null) {\n            response.setZoneId(zone.getUuid());\n            response.setZoneName(zone.getName());\n        }\n        response.setAddress(result.getIp4Address());\n        PhysicalNetwork pnet = ApiDBUtils.findPhysicalNetworkById(result.getPhysicalNetworkId());\n        if (pnet != null) {\n            response.setPhysicalNetworkId(pnet.getUuid());\n        }\n\n        populateAccount(response, result.getAccountId());\n        populateDomain(response, result.getDomainId());\n        response.setState(result.getState().toString());\n\n        response.setObjectName(\"privategateway\");\n\n\n        return response;\n    }","id":91215,"modified_method":"@Override\n    public PrivateGatewayResponse createPrivateGatewayResponse(PrivateGateway result) {\n        PrivateGatewayResponse response = new PrivateGatewayResponse();\n        response.setId(result.getUuid());\n        response.setVlan(result.getVlanTag());\n        response.setGateway(result.getGateway());\n        response.setNetmask(result.getNetmask());\n        if (result.getVpcId() != null) {\n            Vpc vpc = ApiDBUtils.findVpcById(result.getVpcId());\n            response.setVpcId(vpc.getUuid());\n        }\n\n        DataCenter zone = ApiDBUtils.findZoneById(result.getZoneId());\n        if (zone != null) {\n            response.setZoneId(zone.getUuid());\n            response.setZoneName(zone.getName());\n        }\n        response.setAddress(result.getIp4Address());\n        PhysicalNetwork pnet = ApiDBUtils.findPhysicalNetworkById(result.getPhysicalNetworkId());\n        if (pnet != null) {\n            response.setPhysicalNetworkId(pnet.getUuid());\n        }\n\n        populateAccount(response, result.getAccountId());\n        populateDomain(response, result.getDomainId());\n        if (result.getState() != null) {\n            response.setState(result.getState().toString());\n        }\n\n        response.setObjectName(\"privategateway\");\n\n\n        return response;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public ResourceLimitResponse createResourceLimitResponse(ResourceLimit limit) {\n        ResourceLimitResponse resourceLimitResponse = new ResourceLimitResponse();\n        if (limit.getResourceOwnerType() == ResourceOwnerType.Domain) {\n            populateDomain(resourceLimitResponse, limit.getOwnerId());\n        } else if (limit.getResourceOwnerType() == ResourceOwnerType.Account) {\n            Account accountTemp = ApiDBUtils.findAccountById(limit.getOwnerId());\n            populateAccount(resourceLimitResponse, limit.getOwnerId());\n            populateDomain(resourceLimitResponse, accountTemp.getDomainId());\n        }\n        resourceLimitResponse.setResourceType(Integer.valueOf(limit.getType().getOrdinal()).toString());\n        resourceLimitResponse.setMax(limit.getMax());\n        resourceLimitResponse.setObjectName(\"resourcelimit\");\n\n        return resourceLimitResponse;\n    }","id":91216,"modified_method":"@Override\n    public ResourceLimitResponse createResourceLimitResponse(ResourceLimit limit) {\n        ResourceLimitResponse resourceLimitResponse = new ResourceLimitResponse();\n        if (limit.getResourceOwnerType() == ResourceOwnerType.Domain) {\n            populateDomain(resourceLimitResponse, limit.getOwnerId());\n        } else if (limit.getResourceOwnerType() == ResourceOwnerType.Account) {\n            Account accountTemp = ApiDBUtils.findAccountById(limit.getOwnerId());\n            populateAccount(resourceLimitResponse, limit.getOwnerId());\n            populateDomain(resourceLimitResponse, accountTemp.getDomainId());\n        }\n        if (limit.getType() != null) {\n            resourceLimitResponse.setResourceType(Integer.valueOf(limit.getType().getOrdinal()).toString());\n        }\n        resourceLimitResponse.setMax(limit.getMax());\n        resourceLimitResponse.setObjectName(\"resourcelimit\");\n\n        return resourceLimitResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public RemoteAccessVpnResponse createRemoteAccessVpnResponse(RemoteAccessVpn vpn) {\n        RemoteAccessVpnResponse vpnResponse = new RemoteAccessVpnResponse();\n        IpAddress ip = ApiDBUtils.findIpAddressById(vpn.getServerAddressId());\n        if (ip != null) {\n            vpnResponse.setPublicIpId(ip.getUuid());\n            vpnResponse.setPublicIp(ip.getAddress().addr());\n        }\n        vpnResponse.setIpRange(vpn.getIpRange());\n        vpnResponse.setPresharedKey(vpn.getIpsecPresharedKey());\n\n        populateOwner(vpnResponse, vpn);\n\n        vpnResponse.setState(vpn.getState().toString());\n        vpnResponse.setObjectName(\"remoteaccessvpn\");\n\n        return vpnResponse;\n    }","id":91217,"modified_method":"@Override\n    public RemoteAccessVpnResponse createRemoteAccessVpnResponse(RemoteAccessVpn vpn) {\n        RemoteAccessVpnResponse vpnResponse = new RemoteAccessVpnResponse();\n        IpAddress ip = ApiDBUtils.findIpAddressById(vpn.getServerAddressId());\n        if (ip != null) {\n            vpnResponse.setPublicIpId(ip.getUuid());\n            vpnResponse.setPublicIp(ip.getAddress().addr());\n        }\n        vpnResponse.setIpRange(vpn.getIpRange());\n        vpnResponse.setPresharedKey(vpn.getIpsecPresharedKey());\n\n        populateOwner(vpnResponse, vpn);\n\n        if (vpn.getState() != null) {\n            vpnResponse.setState(vpn.getState().toString());\n        }\n        vpnResponse.setObjectName(\"remoteaccessvpn\");\n\n        return vpnResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public FirewallRuleResponse createPortForwardingRuleResponse(PortForwardingRule fwRule) {\n        FirewallRuleResponse response = new FirewallRuleResponse();\n        response.setId(fwRule.getUuid());\n        response.setPrivateStartPort(Integer.toString(fwRule.getDestinationPortStart()));\n        response.setPrivateEndPort(Integer.toString(fwRule.getDestinationPortEnd()));\n        response.setProtocol(fwRule.getProtocol());\n        response.setPublicStartPort(Integer.toString(fwRule.getSourcePortStart()));\n        response.setPublicEndPort(Integer.toString(fwRule.getSourcePortEnd()));\n        List<String> cidrs = ApiDBUtils.findFirewallSourceCidrs(fwRule.getId());\n        response.setCidrList(StringUtils.join(cidrs, \",\"));\n\n        IpAddress ip = ApiDBUtils.findIpAddressById(fwRule.getSourceIpAddressId());\n        response.setPublicIpAddressId(ip.getUuid());\n        response.setPublicIpAddress(ip.getAddress().addr());\n\n        if (ip != null && fwRule.getDestinationIpAddress() != null) {\n            UserVm vm = ApiDBUtils.findUserVmById(fwRule.getVirtualMachineId());\n            if (vm != null) {\n                response.setVirtualMachineId(vm.getUuid());\n                response.setVirtualMachineName(vm.getHostName());\n\n                if (vm.getDisplayName() != null) {\n                    response.setVirtualMachineDisplayName(vm.getDisplayName());\n                } else {\n                    response.setVirtualMachineDisplayName(vm.getHostName());\n                }\n            }\n        }\n        FirewallRule.State state = fwRule.getState();\n        String stateToSet = state.toString();\n        if (state.equals(FirewallRule.State.Revoke)) {\n            stateToSet = \"Deleting\";\n        }\n\n        //set tag information\n        List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.PortForwardingRule, fwRule.getId());\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        response.setTags(tagResponses);\n\n        response.setState(stateToSet);\n        response.setObjectName(\"portforwardingrule\");\n        return response;\n    }","id":91218,"modified_method":"@Override\n    public FirewallRuleResponse createPortForwardingRuleResponse(PortForwardingRule fwRule) {\n        FirewallRuleResponse response = new FirewallRuleResponse();\n        response.setId(fwRule.getUuid());\n        response.setPrivateStartPort(Integer.toString(fwRule.getDestinationPortStart()));\n        response.setPrivateEndPort(Integer.toString(fwRule.getDestinationPortEnd()));\n        response.setProtocol(fwRule.getProtocol());\n        response.setPublicStartPort(Integer.toString(fwRule.getSourcePortStart()));\n        response.setPublicEndPort(Integer.toString(fwRule.getSourcePortEnd()));\n        List<String> cidrs = ApiDBUtils.findFirewallSourceCidrs(fwRule.getId());\n        response.setCidrList(StringUtils.join(cidrs, \",\"));\n\n        IpAddress ip = ApiDBUtils.findIpAddressById(fwRule.getSourceIpAddressId());\n        response.setPublicIpAddressId(ip.getUuid());\n        response.setPublicIpAddress(ip.getAddress().addr());\n\n        if (ip != null && fwRule.getDestinationIpAddress() != null) {\n            UserVm vm = ApiDBUtils.findUserVmById(fwRule.getVirtualMachineId());\n            if (vm != null) {\n                response.setVirtualMachineId(vm.getUuid());\n                response.setVirtualMachineName(vm.getHostName());\n\n                if (vm.getDisplayName() != null) {\n                    response.setVirtualMachineDisplayName(vm.getDisplayName());\n                } else {\n                    response.setVirtualMachineDisplayName(vm.getHostName());\n                }\n            }\n        }\n        FirewallRule.State state = fwRule.getState();\n        if (state != null) {\n            String stateToSet = state.toString();\n            if (state.equals(FirewallRule.State.Revoke)) {\n                stateToSet = \"Deleting\";\n            }\n            response.setState(stateToSet);\n        }\n\n        //set tag information\n        List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.PortForwardingRule, fwRule.getId());\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        response.setTags(tagResponses);\n        response.setObjectName(\"portforwardingrule\");\n        return response;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public FirewallResponse createFirewallResponse(FirewallRule fwRule) {\n        FirewallResponse response = new FirewallResponse();\n\n        response.setId(fwRule.getUuid());\n        response.setProtocol(fwRule.getProtocol());\n        if (fwRule.getSourcePortStart() != null) {\n            response.setStartPort(Integer.toString(fwRule.getSourcePortStart()));\n        }\n\n        if (fwRule.getSourcePortEnd() != null) {\n            response.setEndPort(Integer.toString(fwRule.getSourcePortEnd()));\n        }\n\n        List<String> cidrs = ApiDBUtils.findFirewallSourceCidrs(fwRule.getId());\n        response.setCidrList(StringUtils.join(cidrs, \",\"));\n\n        IpAddress ip = ApiDBUtils.findIpAddressById(fwRule.getSourceIpAddressId());\n        response.setPublicIpAddressId(ip.getId());\n        response.setPublicIpAddress(ip.getAddress().addr());\n\n        FirewallRule.State state = fwRule.getState();\n        String stateToSet = state.toString();\n        if (state.equals(FirewallRule.State.Revoke)) {\n            stateToSet = \"Deleting\";\n        }\n\n        response.setIcmpCode(fwRule.getIcmpCode());\n        response.setIcmpType(fwRule.getIcmpType());\n\n        //set tag information\n        List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.FirewallRule, fwRule.getId());\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        response.setTags(tagResponses);\n\n        response.setState(stateToSet);\n        response.setObjectName(\"firewallrule\");\n        return response;\n    }","id":91219,"modified_method":"@Override\n    public FirewallResponse createFirewallResponse(FirewallRule fwRule) {\n        FirewallResponse response = new FirewallResponse();\n\n        response.setId(fwRule.getUuid());\n        response.setProtocol(fwRule.getProtocol());\n        if (fwRule.getSourcePortStart() != null) {\n            response.setStartPort(Integer.toString(fwRule.getSourcePortStart()));\n        }\n\n        if (fwRule.getSourcePortEnd() != null) {\n            response.setEndPort(Integer.toString(fwRule.getSourcePortEnd()));\n        }\n\n        List<String> cidrs = ApiDBUtils.findFirewallSourceCidrs(fwRule.getId());\n        response.setCidrList(StringUtils.join(cidrs, \",\"));\n\n        IpAddress ip = ApiDBUtils.findIpAddressById(fwRule.getSourceIpAddressId());\n        response.setPublicIpAddressId(ip.getId());\n        response.setPublicIpAddress(ip.getAddress().addr());\n\n        FirewallRule.State state = fwRule.getState();\n        if (state != null) {\n            String stateToSet = state.toString();\n            if (state.equals(FirewallRule.State.Revoke)) {\n                stateToSet = \"Deleting\";\n            }\n            response.setState(stateToSet);\n        }\n\n        response.setIcmpCode(fwRule.getIcmpCode());\n        response.setIcmpType(fwRule.getIcmpType());\n\n        //set tag information\n        List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.FirewallRule, fwRule.getId());\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        response.setTags(tagResponses);\n\n        response.setObjectName(\"firewallrule\");\n        return response;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Site2SiteVpnGatewayResponse createSite2SiteVpnGatewayResponse(Site2SiteVpnGateway result) {\n        Site2SiteVpnGatewayResponse response = new Site2SiteVpnGatewayResponse();\n        response.setId(result.getUuid());\n        response.setIp(ApiDBUtils.findIpAddressById(result.getAddrId()).getAddress().toString());\n        Vpc vpc = ApiDBUtils.findVpcById(result.getVpcId());\n        if (vpc != null) {\n            response.setVpcId(result.getUuid());\n        }\n        response.setRemoved(result.getRemoved());\n        response.setObjectName(\"vpngateway\");\n\n        populateAccount(response, result.getAccountId());\n        populateDomain(response, result.getDomainId());\n        return response;\n    }","id":91220,"modified_method":"@Override\n    public Site2SiteVpnGatewayResponse createSite2SiteVpnGatewayResponse(Site2SiteVpnGateway result) {\n        Site2SiteVpnGatewayResponse response = new Site2SiteVpnGatewayResponse();\n        response.setId(result.getUuid());\n        IpAddress ip = ApiDBUtils.findIpAddressById(result.getAddrId());\n        if (ip != null && ip.getAddress() != null) {\n            response.setIp(ip.getAddress().toString());\n        }\n        Vpc vpc = ApiDBUtils.findVpcById(result.getVpcId());\n        if (vpc != null) {\n            response.setVpcId(result.getUuid());\n        }\n        response.setRemoved(result.getRemoved());\n        response.setObjectName(\"vpngateway\");\n\n        populateAccount(response, result.getAccountId());\n        populateDomain(response, result.getDomainId());\n        return response;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public ResourceCountResponse createResourceCountResponse(ResourceCount resourceCount) {\n        ResourceCountResponse resourceCountResponse = new ResourceCountResponse();\n\n        if (resourceCount.getResourceOwnerType() == ResourceOwnerType.Account) {\n            Account accountTemp = ApiDBUtils.findAccountById(resourceCount.getOwnerId());\n            if (accountTemp != null) {\n                populateAccount(resourceCountResponse, accountTemp.getId());\n                populateDomain(resourceCountResponse, accountTemp.getDomainId());\n            }\n        } else if (resourceCount.getResourceOwnerType() == ResourceOwnerType.Domain) {\n            populateDomain(resourceCountResponse, resourceCount.getOwnerId());\n        }\n\n        resourceCountResponse.setResourceType(Integer.valueOf(resourceCount.getType().getOrdinal()).toString());\n        resourceCountResponse.setResourceCount(resourceCount.getCount());\n        resourceCountResponse.setObjectName(\"resourcecount\");\n        return resourceCountResponse;\n    }","id":91221,"modified_method":"@Override\n    public ResourceCountResponse createResourceCountResponse(ResourceCount resourceCount) {\n        ResourceCountResponse resourceCountResponse = new ResourceCountResponse();\n\n        if (resourceCount.getResourceOwnerType() == ResourceOwnerType.Account) {\n            Account accountTemp = ApiDBUtils.findAccountById(resourceCount.getOwnerId());\n            if (accountTemp != null) {\n                populateAccount(resourceCountResponse, accountTemp.getId());\n                populateDomain(resourceCountResponse, accountTemp.getDomainId());\n            }\n        } else if (resourceCount.getResourceOwnerType() == ResourceOwnerType.Domain) {\n            populateDomain(resourceCountResponse, resourceCount.getOwnerId());\n        }\n\n        if (resourceCount.getType() != null) {\n            resourceCountResponse.setResourceType(Integer.valueOf(resourceCount.getType().getOrdinal()).toString());\n        }\n        resourceCountResponse.setResourceCount(resourceCount.getCount());\n        resourceCountResponse.setObjectName(\"resourcecount\");\n        return resourceCountResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public IPAddressResponse createIPAddressResponse(IpAddress ipAddr) {\n        VlanVO vlan = ApiDBUtils.findVlanById(ipAddr.getVlanId());\n        boolean forVirtualNetworks = vlan.getVlanType().equals(VlanType.VirtualNetwork);\n        long zoneId = ipAddr.getDataCenterId();\n\n        IPAddressResponse ipResponse = new IPAddressResponse();\n        ipResponse.setId(ipAddr.getUuid());\n        ipResponse.setIpAddress(ipAddr.getAddress().toString());\n        if (ipAddr.getAllocatedTime() != null) {\n            ipResponse.setAllocated(ipAddr.getAllocatedTime());\n        }\n        DataCenter zone = ApiDBUtils.findZoneById(ipAddr.getDataCenterId());\n        if (zone != null) {\n            ipResponse.setZoneId(zone.getUuid());\n            ipResponse.setZoneName(zone.getName());\n        }\n        ipResponse.setSourceNat(ipAddr.isSourceNat());\n        ipResponse.setIsSystem(ipAddr.getSystem());\n\n        // get account information\n        if (ipAddr.getAllocatedToAccountId() != null) {\n            populateOwner(ipResponse, ipAddr);\n        }\n\n        ipResponse.setForVirtualNetwork(forVirtualNetworks);\n        ipResponse.setStaticNat(ipAddr.isOneToOneNat());\n\n        if (ipAddr.getAssociatedWithVmId() != null) {\n            UserVm vm = ApiDBUtils.findUserVmById(ipAddr.getAssociatedWithVmId());\n            if (vm != null) {\n                ipResponse.setVirtualMachineId(vm.getUuid());\n                ipResponse.setVirtualMachineName(vm.getHostName());\n                if (vm.getDisplayName() != null) {\n                    ipResponse.setVirtualMachineDisplayName(vm.getDisplayName());\n                } else {\n                    ipResponse.setVirtualMachineDisplayName(vm.getHostName());\n                }\n            }\n        }\n\n        if (ipAddr.getAssociatedWithNetworkId() != null) {\n            Network ntwk = ApiDBUtils.findNetworkById(ipAddr.getAssociatedWithNetworkId());\n            if (ntwk != null) {\n                ipResponse.setAssociatedNetworkId(ntwk.getUuid());\n                ipResponse.setAssociatedNetworkName(ntwk.getName());\n            }\n        }\n\n        if (ipAddr.getVpcId() != null) {\n            Vpc vpc = ApiDBUtils.findVpcById(ipAddr.getVpcId());\n            if (vpc != null) {\n                ipResponse.setVpcId(vpc.getUuid());\n            }\n        }\n\n        // Network id the ip is associated with (if associated networkId is\n        // null, try to get this information from vlan)\n        Long vlanNetworkId = ApiDBUtils.getVlanNetworkId(ipAddr.getVlanId());\n\n        // Network id the ip belongs to\n        Long networkId;\n        if (vlanNetworkId != null) {\n            networkId = vlanNetworkId;\n        } else {\n            networkId = ApiDBUtils.getPublicNetworkIdByZone(zoneId);\n        }\n\n        if (networkId != null) {\n            NetworkVO nw = ApiDBUtils.findNetworkById(networkId);\n            if (nw != null) {\n                ipResponse.setNetworkId(nw.getUuid());\n            }\n        }\n        ipResponse.setState(ipAddr.getState().toString());\n\n        if (ipAddr.getPhysicalNetworkId() != null) {\n            PhysicalNetworkVO pnw = ApiDBUtils.findPhysicalNetworkById(ipAddr.getPhysicalNetworkId());\n            if (pnw != null) {\n                ipResponse.setPhysicalNetworkId(pnw.getUuid());\n            }\n        }\n\n        // show this info to admin only\n        Account account = UserContext.current().getCaller();\n        if (account.getType() == Account.ACCOUNT_TYPE_ADMIN) {\n            VlanVO vl = ApiDBUtils.findVlanById(ipAddr.getVlanId());\n            if (vl != null) {\n                ipResponse.setVlanId(vl.getUuid());\n                ipResponse.setVlanName(vl.getVlanTag());\n            }\n        }\n\n        if (ipAddr.getSystem()) {\n            if (ipAddr.isOneToOneNat()) {\n                ipResponse.setPurpose(IpAddress.Purpose.StaticNat.toString());\n            } else {\n                ipResponse.setPurpose(IpAddress.Purpose.Lb.toString());\n            }\n        }\n\n        //set tag information\n        List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.PublicIpAddress, ipAddr.getId());\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        ipResponse.setTags(tagResponses);\n\n        ipResponse.setObjectName(\"ipaddress\");\n        return ipResponse;\n    }","id":91222,"modified_method":"@Override\n    public IPAddressResponse createIPAddressResponse(IpAddress ipAddr) {\n        VlanVO vlan = ApiDBUtils.findVlanById(ipAddr.getVlanId());\n        boolean forVirtualNetworks = vlan.getVlanType().equals(VlanType.VirtualNetwork);\n        long zoneId = ipAddr.getDataCenterId();\n\n        IPAddressResponse ipResponse = new IPAddressResponse();\n        ipResponse.setId(ipAddr.getUuid());\n        if (ipAddr.getAddress() != null) {\n            ipResponse.setIpAddress(ipAddr.getAddress().toString());\n        }\n        if (ipAddr.getAllocatedTime() != null) {\n            ipResponse.setAllocated(ipAddr.getAllocatedTime());\n        }\n        DataCenter zone = ApiDBUtils.findZoneById(ipAddr.getDataCenterId());\n        if (zone != null) {\n            ipResponse.setZoneId(zone.getUuid());\n            ipResponse.setZoneName(zone.getName());\n        }\n        ipResponse.setSourceNat(ipAddr.isSourceNat());\n        ipResponse.setIsSystem(ipAddr.getSystem());\n\n        // get account information\n        if (ipAddr.getAllocatedToAccountId() != null) {\n            populateOwner(ipResponse, ipAddr);\n        }\n\n        ipResponse.setForVirtualNetwork(forVirtualNetworks);\n        ipResponse.setStaticNat(ipAddr.isOneToOneNat());\n\n        if (ipAddr.getAssociatedWithVmId() != null) {\n            UserVm vm = ApiDBUtils.findUserVmById(ipAddr.getAssociatedWithVmId());\n            if (vm != null) {\n                ipResponse.setVirtualMachineId(vm.getUuid());\n                ipResponse.setVirtualMachineName(vm.getHostName());\n                if (vm.getDisplayName() != null) {\n                    ipResponse.setVirtualMachineDisplayName(vm.getDisplayName());\n                } else {\n                    ipResponse.setVirtualMachineDisplayName(vm.getHostName());\n                }\n            }\n        }\n\n        if (ipAddr.getAssociatedWithNetworkId() != null) {\n            Network ntwk = ApiDBUtils.findNetworkById(ipAddr.getAssociatedWithNetworkId());\n            if (ntwk != null) {\n                ipResponse.setAssociatedNetworkId(ntwk.getUuid());\n                ipResponse.setAssociatedNetworkName(ntwk.getName());\n            }\n        }\n\n        if (ipAddr.getVpcId() != null) {\n            Vpc vpc = ApiDBUtils.findVpcById(ipAddr.getVpcId());\n            if (vpc != null) {\n                ipResponse.setVpcId(vpc.getUuid());\n            }\n        }\n\n        // Network id the ip is associated with (if associated networkId is\n        // null, try to get this information from vlan)\n        Long vlanNetworkId = ApiDBUtils.getVlanNetworkId(ipAddr.getVlanId());\n\n        // Network id the ip belongs to\n        Long networkId;\n        if (vlanNetworkId != null) {\n            networkId = vlanNetworkId;\n        } else {\n            networkId = ApiDBUtils.getPublicNetworkIdByZone(zoneId);\n        }\n\n        if (networkId != null) {\n            NetworkVO nw = ApiDBUtils.findNetworkById(networkId);\n            if (nw != null) {\n                ipResponse.setNetworkId(nw.getUuid());\n            }\n        }\n        if (ipAddr.getState() != null) {\n            ipResponse.setState(ipAddr.getState().toString());\n        }\n\n        if (ipAddr.getPhysicalNetworkId() != null) {\n            PhysicalNetworkVO pnw = ApiDBUtils.findPhysicalNetworkById(ipAddr.getPhysicalNetworkId());\n            if (pnw != null) {\n                ipResponse.setPhysicalNetworkId(pnw.getUuid());\n            }\n        }\n\n        // show this info to admin only\n        Account account = UserContext.current().getCaller();\n        if (account.getType() == Account.ACCOUNT_TYPE_ADMIN) {\n            VlanVO vl = ApiDBUtils.findVlanById(ipAddr.getVlanId());\n            if (vl != null) {\n                ipResponse.setVlanId(vl.getUuid());\n                ipResponse.setVlanName(vl.getVlanTag());\n            }\n        }\n\n        if (ipAddr.getSystem()) {\n            if (ipAddr.isOneToOneNat()) {\n                ipResponse.setPurpose(IpAddress.Purpose.StaticNat.toString());\n            } else {\n                ipResponse.setPurpose(IpAddress.Purpose.Lb.toString());\n            }\n        }\n\n        //set tag information\n        List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.PublicIpAddress, ipAddr.getId());\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        ipResponse.setTags(tagResponses);\n\n        ipResponse.setObjectName(\"ipaddress\");\n        return ipResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public CounterResponse createCounterResponse(Counter counter) {\n        CounterResponse response = new CounterResponse();\n        response.setId(counter.getUuid());\n        response.setSource(counter.getSource().toString());\n        response.setName(counter.getName());\n        response.setValue(counter.getValue());\n        response.setObjectName(\"counter\");\n        return response;\n    }","id":91223,"modified_method":"@Override\n    public CounterResponse createCounterResponse(Counter counter) {\n        CounterResponse response = new CounterResponse();\n        response.setId(counter.getUuid());\n        if (counter.getSource() != null) {\n            response.setSource(counter.getSource().toString());\n        }\n        response.setName(counter.getName());\n        response.setValue(counter.getValue());\n        response.setObjectName(\"counter\");\n        return response;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public NetworkACLResponse createNetworkACLResponse(FirewallRule networkACL) {\n        NetworkACLResponse response = new NetworkACLResponse();\n\n        response.setId(networkACL.getUuid());\n        response.setProtocol(networkACL.getProtocol());\n        if (networkACL.getSourcePortStart() != null) {\n            response.setStartPort(Integer.toString(networkACL.getSourcePortStart()));\n        }\n\n        if (networkACL.getSourcePortEnd() != null) {\n            response.setEndPort(Integer.toString(networkACL.getSourcePortEnd()));\n        }\n\n        List<String> cidrs = ApiDBUtils.findFirewallSourceCidrs(networkACL.getId());\n        response.setCidrList(StringUtils.join(cidrs, \",\"));\n\n        response.setTrafficType(networkACL.getTrafficType().toString());\n\n        FirewallRule.State state = networkACL.getState();\n        String stateToSet = state.toString();\n        if (state.equals(FirewallRule.State.Revoke)) {\n            stateToSet = \"Deleting\";\n        }\n\n        response.setIcmpCode(networkACL.getIcmpCode());\n        response.setIcmpType(networkACL.getIcmpType());\n\n        response.setState(stateToSet);\n\n        //set tag information\n        List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.NetworkACL, networkACL.getId());\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        response.setTags(tagResponses);\n\n        response.setObjectName(\"networkacl\");\n        return response;\n    }","id":91224,"modified_method":"@Override\n    public NetworkACLResponse createNetworkACLResponse(FirewallRule networkACL) {\n        NetworkACLResponse response = new NetworkACLResponse();\n\n        response.setId(networkACL.getUuid());\n        response.setProtocol(networkACL.getProtocol());\n        if (networkACL.getSourcePortStart() != null) {\n            response.setStartPort(Integer.toString(networkACL.getSourcePortStart()));\n        }\n\n        if (networkACL.getSourcePortEnd() != null) {\n            response.setEndPort(Integer.toString(networkACL.getSourcePortEnd()));\n        }\n\n        List<String> cidrs = ApiDBUtils.findFirewallSourceCidrs(networkACL.getId());\n        response.setCidrList(StringUtils.join(cidrs, \",\"));\n\n        if (networkACL.getTrafficType() != null) {\n            response.setTrafficType(networkACL.getTrafficType().toString());\n        }\n\n        FirewallRule.State state = networkACL.getState();\n        if (state != null) {\n            String stateToSet = state.toString();\n            if (state.equals(FirewallRule.State.Revoke)) {\n                stateToSet = \"Deleting\";\n            }\n            response.setState(stateToSet);\n        }\n\n        response.setIcmpCode(networkACL.getIcmpCode());\n        response.setIcmpType(networkACL.getIcmpType());\n\n\n\n        //set tag information\n        List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.NetworkACL, networkACL.getId());\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        response.setTags(tagResponses);\n\n        response.setObjectName(\"networkacl\");\n        return response;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public TrafficTypeResponse createTrafficTypeResponse(PhysicalNetworkTrafficType result) {\n        TrafficTypeResponse response = new TrafficTypeResponse();\n        response.setId(result.getUuid());\n        response.setPhysicalNetworkId(result.getPhysicalNetworkId());\n        response.setTrafficType(result.getTrafficType().toString());\n        response.setXenLabel(result.getXenNetworkLabel());\n        response.setKvmLabel(result.getKvmNetworkLabel());\n        response.setVmwareLabel(result.getVmwareNetworkLabel());\n\n        response.setObjectName(\"traffictype\");\n        return response;\n    }","id":91225,"modified_method":"@Override\n    public TrafficTypeResponse createTrafficTypeResponse(PhysicalNetworkTrafficType result) {\n        TrafficTypeResponse response = new TrafficTypeResponse();\n        response.setId(result.getUuid());\n        response.setPhysicalNetworkId(result.getPhysicalNetworkId());\n        if (result.getTrafficType() != null) {\n            response.setTrafficType(result.getTrafficType().toString());\n        }\n        response.setXenLabel(result.getXenNetworkLabel());\n        response.setKvmLabel(result.getKvmNetworkLabel());\n        response.setVmwareLabel(result.getVmwareNetworkLabel());\n\n        response.setObjectName(\"traffictype\");\n        return response;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public ZoneResponse createZoneResponse(DataCenter dataCenter, Boolean showCapacities) {\n        Account account = UserContext.current().getCaller();\n        ZoneResponse zoneResponse = new ZoneResponse();\n        zoneResponse.setId(dataCenter.getUuid());\n        zoneResponse.setName(dataCenter.getName());\n        zoneResponse.setSecurityGroupsEnabled(ApiDBUtils.isSecurityGroupEnabledInZone(dataCenter.getId()));\n        zoneResponse.setLocalStorageEnabled(dataCenter.isLocalStorageEnabled());\n\n        if ((dataCenter.getDescription() != null) && !dataCenter.getDescription().equalsIgnoreCase(\"null\")) {\n            zoneResponse.setDescription(dataCenter.getDescription());\n        }\n\n        if ((account == null) || (account.getType() == Account.ACCOUNT_TYPE_ADMIN)) {\n            zoneResponse.setDns1(dataCenter.getDns1());\n            zoneResponse.setDns2(dataCenter.getDns2());\n            zoneResponse.setInternalDns1(dataCenter.getInternalDns1());\n            zoneResponse.setInternalDns2(dataCenter.getInternalDns2());\n            // FIXME zoneResponse.setVlan(dataCenter.get.getVnet());\n            zoneResponse.setGuestCidrAddress(dataCenter.getGuestNetworkCidr());\n        }\n\n        if (showCapacities != null && showCapacities) {\n            List<SummedCapacity> capacities = ApiDBUtils.getCapacityByClusterPodZone(dataCenter.getId(), null, null);\n            Set<CapacityResponse> capacityResponses = new HashSet<CapacityResponse>();\n            float cpuOverprovisioningFactor = ApiDBUtils.getCpuOverprovisioningFactor();\n\n            for (SummedCapacity capacity : capacities) {\n                CapacityResponse capacityResponse = new CapacityResponse();\n                capacityResponse.setCapacityType(capacity.getCapacityType());\n                capacityResponse.setCapacityUsed(capacity.getUsedCapacity());\n                if (capacity.getCapacityType() == Capacity.CAPACITY_TYPE_CPU) {\n                    capacityResponse.setCapacityTotal(new Long((long) (capacity.getTotalCapacity() * cpuOverprovisioningFactor)));\n                } else if (capacity.getCapacityType() == Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED) {\n                    List<SummedCapacity> c = ApiDBUtils.findNonSharedStorageForClusterPodZone(dataCenter.getId(), null, null);\n                    capacityResponse.setCapacityTotal(capacity.getTotalCapacity() - c.get(0).getTotalCapacity());\n                    capacityResponse.setCapacityUsed(capacity.getUsedCapacity() - c.get(0).getUsedCapacity());\n                } else {\n                    capacityResponse.setCapacityTotal(capacity.getTotalCapacity());\n                }\n                if (capacityResponse.getCapacityTotal() != 0) {\n                    capacityResponse.setPercentUsed(s_percentFormat.format((float) capacityResponse.getCapacityUsed() / (float) capacityResponse.getCapacityTotal() * 100f));\n                } else {\n                    capacityResponse.setPercentUsed(s_percentFormat.format(0L));\n                }\n                capacityResponses.add(capacityResponse);\n            }\n            // Do it for stats as well.\n            capacityResponses.addAll(getStatsCapacityresponse(null, null, null, dataCenter.getId()));\n\n            zoneResponse.setCapacitites(new ArrayList<CapacityResponse>(capacityResponses));\n        }\n\n        // set network domain info\n        zoneResponse.setDomain(dataCenter.getDomain());\n\n        // set domain info\n        Long domainId = dataCenter.getDomainId();\n        if (domainId != null) {\n            Domain domain = ApiDBUtils.findDomainById(domainId);\n            zoneResponse.setDomainId(domain.getId());\n            zoneResponse.setDomainName(domain.getName());\n        }\n\n        zoneResponse.setType(dataCenter.getNetworkType().toString());\n        zoneResponse.setAllocationState(dataCenter.getAllocationState().toString());\n        zoneResponse.setZoneToken(dataCenter.getZoneToken());\n        zoneResponse.setDhcpProvider(dataCenter.getDhcpProvider());\n        zoneResponse.setObjectName(\"zone\");\n        return zoneResponse;\n    }","id":91226,"modified_method":"@Override\n    public ZoneResponse createZoneResponse(DataCenter dataCenter, Boolean showCapacities) {\n        Account account = UserContext.current().getCaller();\n        ZoneResponse zoneResponse = new ZoneResponse();\n        zoneResponse.setId(dataCenter.getUuid());\n        zoneResponse.setName(dataCenter.getName());\n        zoneResponse.setSecurityGroupsEnabled(ApiDBUtils.isSecurityGroupEnabledInZone(dataCenter.getId()));\n        zoneResponse.setLocalStorageEnabled(dataCenter.isLocalStorageEnabled());\n\n        if ((dataCenter.getDescription() != null) && !dataCenter.getDescription().equalsIgnoreCase(\"null\")) {\n            zoneResponse.setDescription(dataCenter.getDescription());\n        }\n\n        if ((account == null) || (account.getType() == Account.ACCOUNT_TYPE_ADMIN)) {\n            zoneResponse.setDns1(dataCenter.getDns1());\n            zoneResponse.setDns2(dataCenter.getDns2());\n            zoneResponse.setInternalDns1(dataCenter.getInternalDns1());\n            zoneResponse.setInternalDns2(dataCenter.getInternalDns2());\n            // FIXME zoneResponse.setVlan(dataCenter.get.getVnet());\n            zoneResponse.setGuestCidrAddress(dataCenter.getGuestNetworkCidr());\n        }\n\n        if (showCapacities != null && showCapacities) {\n            List<SummedCapacity> capacities = ApiDBUtils.getCapacityByClusterPodZone(dataCenter.getId(), null, null);\n            Set<CapacityResponse> capacityResponses = new HashSet<CapacityResponse>();\n            float cpuOverprovisioningFactor = ApiDBUtils.getCpuOverprovisioningFactor();\n\n            for (SummedCapacity capacity : capacities) {\n                CapacityResponse capacityResponse = new CapacityResponse();\n                capacityResponse.setCapacityType(capacity.getCapacityType());\n                capacityResponse.setCapacityUsed(capacity.getUsedCapacity());\n                if (capacity.getCapacityType() == Capacity.CAPACITY_TYPE_CPU) {\n                    capacityResponse.setCapacityTotal(new Long((long) (capacity.getTotalCapacity() * cpuOverprovisioningFactor)));\n                } else if (capacity.getCapacityType() == Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED) {\n                    List<SummedCapacity> c = ApiDBUtils.findNonSharedStorageForClusterPodZone(dataCenter.getId(), null, null);\n                    capacityResponse.setCapacityTotal(capacity.getTotalCapacity() - c.get(0).getTotalCapacity());\n                    capacityResponse.setCapacityUsed(capacity.getUsedCapacity() - c.get(0).getUsedCapacity());\n                } else {\n                    capacityResponse.setCapacityTotal(capacity.getTotalCapacity());\n                }\n                if (capacityResponse.getCapacityTotal() != 0) {\n                    capacityResponse.setPercentUsed(s_percentFormat.format((float) capacityResponse.getCapacityUsed() / (float) capacityResponse.getCapacityTotal() * 100f));\n                } else {\n                    capacityResponse.setPercentUsed(s_percentFormat.format(0L));\n                }\n                capacityResponses.add(capacityResponse);\n            }\n            // Do it for stats as well.\n            capacityResponses.addAll(getStatsCapacityresponse(null, null, null, dataCenter.getId()));\n\n            zoneResponse.setCapacitites(new ArrayList<CapacityResponse>(capacityResponses));\n        }\n\n        // set network domain info\n        zoneResponse.setDomain(dataCenter.getDomain());\n\n        // set domain info\n        Long domainId = dataCenter.getDomainId();\n        if (domainId != null) {\n            Domain domain = ApiDBUtils.findDomainById(domainId);\n            zoneResponse.setDomainId(domain.getId());\n            zoneResponse.setDomainName(domain.getName());\n        }\n\n        if (dataCenter.getNetworkType() != null) {\n            zoneResponse.setType(dataCenter.getNetworkType().toString());\n        }\n        if (dataCenter.getAllocationState() != null) {\n            zoneResponse.setAllocationState(dataCenter.getAllocationState().toString());\n        }\n        zoneResponse.setZoneToken(dataCenter.getZoneToken());\n        zoneResponse.setDhcpProvider(dataCenter.getDhcpProvider());\n        zoneResponse.setObjectName(\"zone\");\n        return zoneResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public AsyncJobResponse createAsyncJobResponse(AsyncJob job) {\n        AsyncJobResponse jobResponse = new AsyncJobResponse();\n        Account account = ApiDBUtils.findAccountById(job.getAccountId());\n        if (account != null) {\n            jobResponse.setAccountId(account.getUuid());\n        }\n        User user = ApiDBUtils.findUserById(job.getUserId());\n        if (user != null) {\n            jobResponse.setUserId(user.getUuid());\n        }\n        jobResponse.setCmd(job.getCmd());\n        jobResponse.setCreated(job.getCreated());\n        jobResponse.setJobId(job.getId());\n        jobResponse.setJobStatus(job.getStatus());\n        jobResponse.setJobProcStatus(job.getProcessStatus());\n\n        if (job.getInstanceType() != null && job.getInstanceId() != null) {\n            jobResponse.setJobInstanceType(job.getInstanceType().toString());\n            String jobInstanceId = null;\n            if (job.getInstanceType() == AsyncJob.Type.Volume) {\n                VolumeVO volume = ApiDBUtils.findVolumeById(job.getInstanceId());\n                if (volume != null) {\n                    jobInstanceId = volume.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.Template || job.getInstanceType() == AsyncJob.Type.Iso) {\n                VMTemplateVO template = ApiDBUtils.findTemplateById(job.getInstanceId());\n                if (template != null) {\n                    jobInstanceId = template.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.VirtualMachine || job.getInstanceType() == AsyncJob.Type.ConsoleProxy\n                    || job.getInstanceType() == AsyncJob.Type.SystemVm || job.getInstanceType() == AsyncJob.Type.DomainRouter) {\n                VMInstanceVO vm = ApiDBUtils.findVMInstanceById(job.getInstanceId());\n                if (vm != null) {\n                    jobInstanceId = vm.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.Snapshot) {\n                Snapshot snapshot = ApiDBUtils.findSnapshotById(job.getInstanceId());\n                if (snapshot != null) {\n                    jobInstanceId = snapshot.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.Host) {\n                Host host = ApiDBUtils.findHostById(job.getInstanceId());\n                if (host != null) {\n                    jobInstanceId = host.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.StoragePool) {\n                StoragePoolVO spool = ApiDBUtils.findStoragePoolById(job.getInstanceId());\n                if (spool != null) {\n                    jobInstanceId = spool.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.IpAddress) {\n                IPAddressVO ip = ApiDBUtils.findIpAddressById(job.getInstanceId());\n                if (ip != null) {\n                    jobInstanceId = ip.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.SecurityGroup) {\n                SecurityGroup sg = ApiDBUtils.findSecurityGroupById(job.getInstanceId());\n                if (sg != null) {\n                    jobInstanceId = sg.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.PhysicalNetwork) {\n                PhysicalNetworkVO pnet = ApiDBUtils.findPhysicalNetworkById(job.getInstanceId());\n                if (pnet != null) {\n                    jobInstanceId = pnet.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.TrafficType) {\n                PhysicalNetworkTrafficTypeVO trafficType = ApiDBUtils.findPhysicalNetworkTrafficTypeById(job.getInstanceId());\n                if (trafficType != null) {\n                    jobInstanceId = trafficType.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.PhysicalNetworkServiceProvider) {\n                PhysicalNetworkServiceProvider sp = ApiDBUtils.findPhysicalNetworkServiceProviderById(job.getInstanceId());\n                if (sp != null) {\n                    jobInstanceId = sp.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.FirewallRule) {\n                FirewallRuleVO fw = ApiDBUtils.findFirewallRuleById(job.getInstanceId());\n                if (fw != null) {\n                    jobInstanceId = fw.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.Account) {\n                Account acct = ApiDBUtils.findAccountById(job.getInstanceId());\n                if (acct != null) {\n                    jobInstanceId = acct.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.User) {\n                User usr = ApiDBUtils.findUserById(job.getInstanceId());\n                if (usr != null) {\n                    jobInstanceId = usr.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.StaticRoute) {\n                StaticRouteVO route = ApiDBUtils.findStaticRouteById(job.getInstanceId());\n                if (route != null) {\n                    jobInstanceId = route.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.PrivateGateway) {\n                VpcGatewayVO gateway = ApiDBUtils.findVpcGatewayById(job.getInstanceId());\n                if (gateway != null) {\n                    jobInstanceId = gateway.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.Counter) {\n                CounterVO counter = ApiDBUtils.getCounter(job.getInstanceId());\n                if (counter != null) {\n                    jobInstanceId = counter.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.Condition) {\n                ConditionVO condition = ApiDBUtils.findConditionById(job.getInstanceId());\n                if (condition != null) {\n                    jobInstanceId = condition.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.AutoScalePolicy) {\n                AutoScalePolicyVO policy = ApiDBUtils.findAutoScalePolicyById(job.getInstanceId());\n                if (policy != null) {\n                    jobInstanceId = policy.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.AutoScaleVmProfile) {\n                AutoScaleVmProfileVO profile = ApiDBUtils.findAutoScaleVmProfileById(job.getInstanceId());\n                if (profile != null) {\n                    jobInstanceId = profile.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.AutoScaleVmGroup) {\n                AutoScaleVmGroupVO group = ApiDBUtils.findAutoScaleVmGroupById(job.getInstanceId());\n                if (group != null) {\n                    jobInstanceId = group.getUuid();\n                }\n            } else if (job.getInstanceType() != AsyncJob.Type.None) {\n                // TODO : when we hit here, we need to add instanceType -> UUID\n                // entity table mapping\n                assert (false);\n            }\n            if (jobInstanceId != null) {\n                jobResponse.setJobInstanceId(jobInstanceId);\n            }\n        }\n        jobResponse.setJobResultCode(job.getResultCode());\n\n        boolean savedValue = SerializationContext.current().getUuidTranslation();\n        SerializationContext.current().setUuidTranslation(false);\n\n        Object resultObject = ApiSerializerHelper.fromSerializedString(job.getResult());\n        jobResponse.setJobResult((ResponseObject) resultObject);\n        SerializationContext.current().setUuidTranslation(savedValue);\n\n        if (resultObject != null) {\n            Class<?> clz = resultObject.getClass();\n            if (clz.isPrimitive() || clz.getSuperclass() == Number.class || clz == String.class || clz == Date.class) {\n                jobResponse.setJobResultType(\"text\");\n            } else {\n                jobResponse.setJobResultType(\"object\");\n            }\n        }\n\n        jobResponse.setObjectName(\"asyncjobs\");\n        return jobResponse;\n    }","id":91227,"modified_method":"@Override\n    public AsyncJobResponse createAsyncJobResponse(AsyncJob job) {\n        AsyncJobResponse jobResponse = new AsyncJobResponse();\n        Account account = ApiDBUtils.findAccountById(job.getAccountId());\n        if (account != null) {\n            jobResponse.setAccountId(account.getUuid());\n        }\n        User user = ApiDBUtils.findUserById(job.getUserId());\n        if (user != null) {\n            jobResponse.setUserId(user.getUuid());\n        }\n        jobResponse.setCmd(job.getCmd());\n        jobResponse.setCreated(job.getCreated());\n        jobResponse.setJobId(job.getId());\n        jobResponse.setJobStatus(job.getStatus());\n        jobResponse.setJobProcStatus(job.getProcessStatus());\n\n        if (job.getInstanceType() != null && job.getInstanceId() != null) {\n            if (job.getInstanceType() != null) {\n                jobResponse.setJobInstanceType(job.getInstanceType().toString());\n            }\n            String jobInstanceId = null;\n            if (job.getInstanceType() == AsyncJob.Type.Volume) {\n                VolumeVO volume = ApiDBUtils.findVolumeById(job.getInstanceId());\n                if (volume != null) {\n                    jobInstanceId = volume.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.Template || job.getInstanceType() == AsyncJob.Type.Iso) {\n                VMTemplateVO template = ApiDBUtils.findTemplateById(job.getInstanceId());\n                if (template != null) {\n                    jobInstanceId = template.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.VirtualMachine || job.getInstanceType() == AsyncJob.Type.ConsoleProxy\n                    || job.getInstanceType() == AsyncJob.Type.SystemVm || job.getInstanceType() == AsyncJob.Type.DomainRouter) {\n                VMInstanceVO vm = ApiDBUtils.findVMInstanceById(job.getInstanceId());\n                if (vm != null) {\n                    jobInstanceId = vm.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.Snapshot) {\n                Snapshot snapshot = ApiDBUtils.findSnapshotById(job.getInstanceId());\n                if (snapshot != null) {\n                    jobInstanceId = snapshot.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.Host) {\n                Host host = ApiDBUtils.findHostById(job.getInstanceId());\n                if (host != null) {\n                    jobInstanceId = host.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.StoragePool) {\n                StoragePoolVO spool = ApiDBUtils.findStoragePoolById(job.getInstanceId());\n                if (spool != null) {\n                    jobInstanceId = spool.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.IpAddress) {\n                IPAddressVO ip = ApiDBUtils.findIpAddressById(job.getInstanceId());\n                if (ip != null) {\n                    jobInstanceId = ip.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.SecurityGroup) {\n                SecurityGroup sg = ApiDBUtils.findSecurityGroupById(job.getInstanceId());\n                if (sg != null) {\n                    jobInstanceId = sg.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.PhysicalNetwork) {\n                PhysicalNetworkVO pnet = ApiDBUtils.findPhysicalNetworkById(job.getInstanceId());\n                if (pnet != null) {\n                    jobInstanceId = pnet.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.TrafficType) {\n                PhysicalNetworkTrafficTypeVO trafficType = ApiDBUtils.findPhysicalNetworkTrafficTypeById(job.getInstanceId());\n                if (trafficType != null) {\n                    jobInstanceId = trafficType.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.PhysicalNetworkServiceProvider) {\n                PhysicalNetworkServiceProvider sp = ApiDBUtils.findPhysicalNetworkServiceProviderById(job.getInstanceId());\n                if (sp != null) {\n                    jobInstanceId = sp.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.FirewallRule) {\n                FirewallRuleVO fw = ApiDBUtils.findFirewallRuleById(job.getInstanceId());\n                if (fw != null) {\n                    jobInstanceId = fw.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.Account) {\n                Account acct = ApiDBUtils.findAccountById(job.getInstanceId());\n                if (acct != null) {\n                    jobInstanceId = acct.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.User) {\n                User usr = ApiDBUtils.findUserById(job.getInstanceId());\n                if (usr != null) {\n                    jobInstanceId = usr.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.StaticRoute) {\n                StaticRouteVO route = ApiDBUtils.findStaticRouteById(job.getInstanceId());\n                if (route != null) {\n                    jobInstanceId = route.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.PrivateGateway) {\n                VpcGatewayVO gateway = ApiDBUtils.findVpcGatewayById(job.getInstanceId());\n                if (gateway != null) {\n                    jobInstanceId = gateway.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.Counter) {\n                CounterVO counter = ApiDBUtils.getCounter(job.getInstanceId());\n                if (counter != null) {\n                    jobInstanceId = counter.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.Condition) {\n                ConditionVO condition = ApiDBUtils.findConditionById(job.getInstanceId());\n                if (condition != null) {\n                    jobInstanceId = condition.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.AutoScalePolicy) {\n                AutoScalePolicyVO policy = ApiDBUtils.findAutoScalePolicyById(job.getInstanceId());\n                if (policy != null) {\n                    jobInstanceId = policy.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.AutoScaleVmProfile) {\n                AutoScaleVmProfileVO profile = ApiDBUtils.findAutoScaleVmProfileById(job.getInstanceId());\n                if (profile != null) {\n                    jobInstanceId = profile.getUuid();\n                }\n            } else if (job.getInstanceType() == AsyncJob.Type.AutoScaleVmGroup) {\n                AutoScaleVmGroupVO group = ApiDBUtils.findAutoScaleVmGroupById(job.getInstanceId());\n                if (group != null) {\n                    jobInstanceId = group.getUuid();\n                }\n            } else if (job.getInstanceType() != AsyncJob.Type.None) {\n                // TODO : when we hit here, we need to add instanceType -> UUID\n                // entity table mapping\n                assert (false);\n            }\n            if (jobInstanceId != null) {\n                jobResponse.setJobInstanceId(jobInstanceId);\n            }\n        }\n        jobResponse.setJobResultCode(job.getResultCode());\n\n        boolean savedValue = SerializationContext.current().getUuidTranslation();\n        SerializationContext.current().setUuidTranslation(false);\n\n        Object resultObject = ApiSerializerHelper.fromSerializedString(job.getResult());\n        jobResponse.setJobResult((ResponseObject) resultObject);\n        SerializationContext.current().setUuidTranslation(savedValue);\n\n        if (resultObject != null) {\n            Class<?> clz = resultObject.getClass();\n            if (clz.isPrimitive() || clz.getSuperclass() == Number.class || clz == String.class || clz == Date.class) {\n                jobResponse.setJobResultType(\"text\");\n            } else {\n                jobResponse.setJobResultType(\"object\");\n            }\n        }\n\n        jobResponse.setObjectName(\"asyncjobs\");\n        return jobResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public ExtractResponse createExtractResponse(Long uploadId, Long id, Long zoneId, Long accountId, String mode) {\n        UploadVO uploadInfo = ApiDBUtils.findUploadById(uploadId);\n        ExtractResponse response = new ExtractResponse();\n        response.setObjectName(\"template\");\n        response.setId(id);\n        response.setName(ApiDBUtils.findTemplateById(id).getName());\n        if (zoneId != null) {\n            response.setZoneId(zoneId);\n            response.setZoneName(ApiDBUtils.findZoneById(zoneId).getName());\n        }\n        response.setMode(mode);\n        response.setUploadId(uploadId);\n        response.setState(uploadInfo.getUploadState().toString());\n        response.setAccountId(accountId);\n        response.setUrl(uploadInfo.getUploadUrl());\n        return response;\n\n    }","id":91228,"modified_method":"@Override\n    public ExtractResponse createExtractResponse(Long uploadId, Long id, Long zoneId, Long accountId, String mode) {\n        UploadVO uploadInfo = ApiDBUtils.findUploadById(uploadId);\n        ExtractResponse response = new ExtractResponse();\n        response.setObjectName(\"template\");\n        response.setId(id);\n        response.setName(ApiDBUtils.findTemplateById(id).getName());\n        if (zoneId != null) {\n            response.setZoneId(zoneId);\n            response.setZoneName(ApiDBUtils.findZoneById(zoneId).getName());\n        }\n        response.setMode(mode);\n        response.setUploadId(uploadId);\n        if (uploadInfo.getUploadState() != null) {\n            response.setState(uploadInfo.getUploadState().toString());\n        }\n        response.setAccountId(accountId);\n        response.setUrl(uploadInfo.getUploadUrl());\n        return response;\n\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public SystemVmResponse createSystemVmResponse(VirtualMachine vm) {\n        SystemVmResponse vmResponse = new SystemVmResponse();\n        if (vm.getType() == Type.SecondaryStorageVm || vm.getType() == Type.ConsoleProxy) {\n            // SystemVm vm = (SystemVm) systemVM;\n            vmResponse.setId(vm.getUuid());\n            vmResponse.setObjectId(vm.getId());\n            vmResponse.setSystemVmType(vm.getType().toString().toLowerCase());\n\n            vmResponse.setName(vm.getHostName());\n            if ( vm.getPodIdToDeployIn() != null ){\n                HostPodVO pod = ApiDBUtils.findPodById(vm.getPodIdToDeployIn());\n                if ( pod != null ){\n            vmResponse.setPodId(pod.getUuid());\n                }\n            }\n            VMTemplateVO template = ApiDBUtils.findTemplateById(vm.getTemplateId());\n            if (template != null){\n            vmResponse.setTemplateId(template.getUuid());\n            }\n            vmResponse.setCreated(vm.getCreated());\n\n            if (vm.getHostId() != null) {\n                Host host = ApiDBUtils.findHostById(vm.getHostId());\n                if (host != null) {\n                    vmResponse.setHostId(host.getUuid());\n                    vmResponse.setHostName(host.getName());\n                }\n            }\n\n            if (vm.getState() != null) {\n                vmResponse.setState(vm.getState().toString());\n            }\n\n            // for console proxies, add the active sessions\n            if (vm.getType() == Type.ConsoleProxy) {\n                ConsoleProxyVO proxy = ApiDBUtils.findConsoleProxy(vm.getId());\n                // proxy can be already destroyed\n                if (proxy != null) {\n                    vmResponse.setActiveViewerSessions(proxy.getActiveSession());\n                }\n            }\n\n            DataCenter zone = ApiDBUtils.findZoneById(vm.getDataCenterIdToDeployIn());\n            if (zone != null) {\n                vmResponse.setZoneId(zone.getUuid());\n                vmResponse.setZoneName(zone.getName());\n                vmResponse.setDns1(zone.getDns1());\n                vmResponse.setDns2(zone.getDns2());\n            }\n\n            List<NicProfile> nicProfiles = ApiDBUtils.getNics(vm);\n            for (NicProfile singleNicProfile : nicProfiles) {\n                Network network = ApiDBUtils.findNetworkById(singleNicProfile.getNetworkId());\n                if (network != null) {\n                    if (network.getTrafficType() == TrafficType.Management) {\n                        vmResponse.setPrivateIp(singleNicProfile.getIp4Address());\n                        vmResponse.setPrivateMacAddress(singleNicProfile.getMacAddress());\n                        vmResponse.setPrivateNetmask(singleNicProfile.getNetmask());\n                    } else if (network.getTrafficType() == TrafficType.Control) {\n                        vmResponse.setLinkLocalIp(singleNicProfile.getIp4Address());\n                        vmResponse.setLinkLocalMacAddress(singleNicProfile.getMacAddress());\n                        vmResponse.setLinkLocalNetmask(singleNicProfile.getNetmask());\n                    } else if (network.getTrafficType() == TrafficType.Public || network.getTrafficType() == TrafficType.Guest) {\n                        /*In basic zone, public ip has TrafficType.Guest*/\n                        vmResponse.setPublicIp(singleNicProfile.getIp4Address());\n                        vmResponse.setPublicMacAddress(singleNicProfile.getMacAddress());\n                        vmResponse.setPublicNetmask(singleNicProfile.getNetmask());\n                        vmResponse.setGateway(singleNicProfile.getGateway());\n                    }\n                }\n            }\n        }\n        vmResponse.setObjectName(\"systemvm\");\n        return vmResponse;\n    }","id":91229,"modified_method":"@Override\n    public SystemVmResponse createSystemVmResponse(VirtualMachine vm) {\n        SystemVmResponse vmResponse = new SystemVmResponse();\n        if (vm.getType() == Type.SecondaryStorageVm || vm.getType() == Type.ConsoleProxy) {\n            // SystemVm vm = (SystemVm) systemVM;\n            vmResponse.setId(vm.getUuid());\n            vmResponse.setObjectId(vm.getId());\n            if (vm.getType() != null) {\n                vmResponse.setSystemVmType(vm.getType().toString().toLowerCase());\n            }\n\n            vmResponse.setName(vm.getHostName());\n            if ( vm.getPodIdToDeployIn() != null ){\n                HostPodVO pod = ApiDBUtils.findPodById(vm.getPodIdToDeployIn());\n                if ( pod != null ){\n            vmResponse.setPodId(pod.getUuid());\n                }\n            }\n            VMTemplateVO template = ApiDBUtils.findTemplateById(vm.getTemplateId());\n            if (template != null){\n            vmResponse.setTemplateId(template.getUuid());\n            }\n            vmResponse.setCreated(vm.getCreated());\n\n            if (vm.getHostId() != null) {\n                Host host = ApiDBUtils.findHostById(vm.getHostId());\n                if (host != null) {\n                    vmResponse.setHostId(host.getUuid());\n                    vmResponse.setHostName(host.getName());\n                }\n            }\n\n            if (vm.getState() != null) {\n                vmResponse.setState(vm.getState().toString());\n            }\n\n            // for console proxies, add the active sessions\n            if (vm.getType() == Type.ConsoleProxy) {\n                ConsoleProxyVO proxy = ApiDBUtils.findConsoleProxy(vm.getId());\n                // proxy can be already destroyed\n                if (proxy != null) {\n                    vmResponse.setActiveViewerSessions(proxy.getActiveSession());\n                }\n            }\n\n            DataCenter zone = ApiDBUtils.findZoneById(vm.getDataCenterIdToDeployIn());\n            if (zone != null) {\n                vmResponse.setZoneId(zone.getUuid());\n                vmResponse.setZoneName(zone.getName());\n                vmResponse.setDns1(zone.getDns1());\n                vmResponse.setDns2(zone.getDns2());\n            }\n\n            List<NicProfile> nicProfiles = ApiDBUtils.getNics(vm);\n            for (NicProfile singleNicProfile : nicProfiles) {\n                Network network = ApiDBUtils.findNetworkById(singleNicProfile.getNetworkId());\n                if (network != null) {\n                    if (network.getTrafficType() == TrafficType.Management) {\n                        vmResponse.setPrivateIp(singleNicProfile.getIp4Address());\n                        vmResponse.setPrivateMacAddress(singleNicProfile.getMacAddress());\n                        vmResponse.setPrivateNetmask(singleNicProfile.getNetmask());\n                    } else if (network.getTrafficType() == TrafficType.Control) {\n                        vmResponse.setLinkLocalIp(singleNicProfile.getIp4Address());\n                        vmResponse.setLinkLocalMacAddress(singleNicProfile.getMacAddress());\n                        vmResponse.setLinkLocalNetmask(singleNicProfile.getNetmask());\n                    } else if (network.getTrafficType() == TrafficType.Public || network.getTrafficType() == TrafficType.Guest) {\n                        /*In basic zone, public ip has TrafficType.Guest*/\n                        vmResponse.setPublicIp(singleNicProfile.getIp4Address());\n                        vmResponse.setPublicMacAddress(singleNicProfile.getMacAddress());\n                        vmResponse.setPublicNetmask(singleNicProfile.getNetmask());\n                        vmResponse.setGateway(singleNicProfile.getGateway());\n                    }\n                }\n            }\n        }\n        vmResponse.setObjectName(\"systemvm\");\n        return vmResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public NetworkOfferingResponse createNetworkOfferingResponse(NetworkOffering offering) {\n        NetworkOfferingResponse response = new NetworkOfferingResponse();\n        response.setId(offering.getUuid());\n        response.setName(offering.getName());\n        response.setDisplayText(offering.getDisplayText());\n        response.setTags(offering.getTags());\n        response.setTrafficType(offering.getTrafficType().toString());\n        response.setIsDefault(offering.isDefault());\n        response.setSpecifyVlan(offering.getSpecifyVlan());\n        response.setConserveMode(offering.isConserveMode());\n        response.setSpecifyIpRanges(offering.getSpecifyIpRanges());\n        response.setAvailability(offering.getAvailability().toString());\n        response.setNetworkRate(ApiDBUtils.getNetworkRate(offering.getId()));\n        Long so = null;\n        if (offering.getServiceOfferingId() != null) {\n            so = offering.getServiceOfferingId();\n        } else {\n            so = ApiDBUtils.findDefaultRouterServiceOffering();\n        }\n        if (so != null) {\n            ServiceOffering soffering = ApiDBUtils.findServiceOfferingById(so);\n            if (soffering != null)\n                response.setServiceOfferingId(soffering.getUuid());\n        }\n\n        if (offering.getGuestType() != null) {\n            response.setGuestIpType(offering.getGuestType().toString());\n        }\n\n        response.setState(offering.getState().name());\n\n        Map<Service, Set<Provider>> serviceProviderMap = ApiDBUtils.listNetworkOfferingServices(offering.getId());\n        List<ServiceResponse> serviceResponses = new ArrayList<ServiceResponse>();\n        for (Service service : serviceProviderMap.keySet()) {\n            ServiceResponse svcRsp = new ServiceResponse();\n            // skip gateway service\n            if (service == Service.Gateway) {\n                continue;\n            }\n            svcRsp.setName(service.getName());\n            List<ProviderResponse> providers = new ArrayList<ProviderResponse>();\n            for (Provider provider : serviceProviderMap.get(service)) {\n                if (provider != null) {\n                    ProviderResponse providerRsp = new ProviderResponse();\n                    providerRsp.setName(provider.getName());\n                    providers.add(providerRsp);\n                }\n            }\n            svcRsp.setProviders(providers);\n\n            if (Service.Lb == service) {\n                List<CapabilityResponse> lbCapResponse = new ArrayList<CapabilityResponse>();\n\n                CapabilityResponse lbIsoaltion = new CapabilityResponse();\n                lbIsoaltion.setName(Capability.SupportedLBIsolation.getName());\n                lbIsoaltion.setValue(offering.getDedicatedLB() ? \"dedicated\" : \"shared\");\n                lbCapResponse.add(lbIsoaltion);\n\n                CapabilityResponse eLb = new CapabilityResponse();\n                eLb.setName(Capability.ElasticLb.getName());\n                eLb.setValue(offering.getElasticLb() ? \"true\" : \"false\");\n                lbCapResponse.add(eLb);\n\n                svcRsp.setCapabilities(lbCapResponse);\n            } else if (Service.SourceNat == service) {\n                List<CapabilityResponse> capabilities = new ArrayList<CapabilityResponse>();\n                CapabilityResponse sharedSourceNat = new CapabilityResponse();\n                sharedSourceNat.setName(Capability.SupportedSourceNatTypes.getName());\n                sharedSourceNat.setValue(offering.getSharedSourceNat() ? \"perzone\" : \"peraccount\");\n                capabilities.add(sharedSourceNat);\n\n                CapabilityResponse redundantRouter = new CapabilityResponse();\n                redundantRouter.setName(Capability.RedundantRouter.getName());\n                redundantRouter.setValue(offering.getRedundantRouter() ? \"true\" : \"false\");\n                capabilities.add(redundantRouter);\n\n                svcRsp.setCapabilities(capabilities);\n            } else if (service == Service.StaticNat) {\n                List<CapabilityResponse> staticNatCapResponse = new ArrayList<CapabilityResponse>();\n\n                CapabilityResponse eIp = new CapabilityResponse();\n                eIp.setName(Capability.ElasticIp.getName());\n                eIp.setValue(offering.getElasticLb() ? \"true\" : \"false\");\n                staticNatCapResponse.add(eIp);\n\n                svcRsp.setCapabilities(staticNatCapResponse);\n            }\n\n            serviceResponses.add(svcRsp);\n        }\n        response.setForVpc(ApiDBUtils.isOfferingForVpc(offering));\n\n        response.setServices(serviceResponses);\n        response.setObjectName(\"networkoffering\");\n        return response;\n    }","id":91230,"modified_method":"@Override\n    public NetworkOfferingResponse createNetworkOfferingResponse(NetworkOffering offering) {\n        NetworkOfferingResponse response = new NetworkOfferingResponse();\n        response.setId(offering.getUuid());\n        response.setName(offering.getName());\n        response.setDisplayText(offering.getDisplayText());\n        response.setTags(offering.getTags());\n        if (offering.getTrafficType() != null) {\n            response.setTrafficType(offering.getTrafficType().toString());\n        }\n        response.setIsDefault(offering.isDefault());\n        response.setSpecifyVlan(offering.getSpecifyVlan());\n        response.setConserveMode(offering.isConserveMode());\n        response.setSpecifyIpRanges(offering.getSpecifyIpRanges());\n        if (offering.getAvailability() != null) {\n            response.setAvailability(offering.getAvailability().toString());\n        }\n        response.setNetworkRate(ApiDBUtils.getNetworkRate(offering.getId()));\n        Long so = null;\n        if (offering.getServiceOfferingId() != null) {\n            so = offering.getServiceOfferingId();\n        } else {\n            so = ApiDBUtils.findDefaultRouterServiceOffering();\n        }\n        if (so != null) {\n            ServiceOffering soffering = ApiDBUtils.findServiceOfferingById(so);\n            if (soffering != null)\n                response.setServiceOfferingId(soffering.getUuid());\n        }\n\n        if (offering.getGuestType() != null) {\n            response.setGuestIpType(offering.getGuestType().toString());\n        }\n\n        response.setState(offering.getState().name());\n\n        Map<Service, Set<Provider>> serviceProviderMap = ApiDBUtils.listNetworkOfferingServices(offering.getId());\n        List<ServiceResponse> serviceResponses = new ArrayList<ServiceResponse>();\n        for (Service service : serviceProviderMap.keySet()) {\n            ServiceResponse svcRsp = new ServiceResponse();\n            // skip gateway service\n            if (service == Service.Gateway) {\n                continue;\n            }\n            svcRsp.setName(service.getName());\n            List<ProviderResponse> providers = new ArrayList<ProviderResponse>();\n            for (Provider provider : serviceProviderMap.get(service)) {\n                if (provider != null) {\n                    ProviderResponse providerRsp = new ProviderResponse();\n                    providerRsp.setName(provider.getName());\n                    providers.add(providerRsp);\n                }\n            }\n            svcRsp.setProviders(providers);\n\n            if (Service.Lb == service) {\n                List<CapabilityResponse> lbCapResponse = new ArrayList<CapabilityResponse>();\n\n                CapabilityResponse lbIsoaltion = new CapabilityResponse();\n                lbIsoaltion.setName(Capability.SupportedLBIsolation.getName());\n                lbIsoaltion.setValue(offering.getDedicatedLB() ? \"dedicated\" : \"shared\");\n                lbCapResponse.add(lbIsoaltion);\n\n                CapabilityResponse eLb = new CapabilityResponse();\n                eLb.setName(Capability.ElasticLb.getName());\n                eLb.setValue(offering.getElasticLb() ? \"true\" : \"false\");\n                lbCapResponse.add(eLb);\n\n                svcRsp.setCapabilities(lbCapResponse);\n            } else if (Service.SourceNat == service) {\n                List<CapabilityResponse> capabilities = new ArrayList<CapabilityResponse>();\n                CapabilityResponse sharedSourceNat = new CapabilityResponse();\n                sharedSourceNat.setName(Capability.SupportedSourceNatTypes.getName());\n                sharedSourceNat.setValue(offering.getSharedSourceNat() ? \"perzone\" : \"peraccount\");\n                capabilities.add(sharedSourceNat);\n\n                CapabilityResponse redundantRouter = new CapabilityResponse();\n                redundantRouter.setName(Capability.RedundantRouter.getName());\n                redundantRouter.setValue(offering.getRedundantRouter() ? \"true\" : \"false\");\n                capabilities.add(redundantRouter);\n\n                svcRsp.setCapabilities(capabilities);\n            } else if (service == Service.StaticNat) {\n                List<CapabilityResponse> staticNatCapResponse = new ArrayList<CapabilityResponse>();\n\n                CapabilityResponse eIp = new CapabilityResponse();\n                eIp.setName(Capability.ElasticIp.getName());\n                eIp.setValue(offering.getElasticLb() ? \"true\" : \"false\");\n                staticNatCapResponse.add(eIp);\n\n                svcRsp.setCapabilities(staticNatCapResponse);\n            }\n\n            serviceResponses.add(svcRsp);\n        }\n        response.setForVpc(ApiDBUtils.isOfferingForVpc(offering));\n\n        response.setServices(serviceResponses);\n        response.setObjectName(\"networkoffering\");\n        return response;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public ProviderResponse createNetworkServiceProviderResponse(PhysicalNetworkServiceProvider result) {\n        ProviderResponse response = new ProviderResponse();\n        response.setId(result.getUuid());\n        response.setName(result.getProviderName());\n        PhysicalNetwork pnw = ApiDBUtils.findPhysicalNetworkById(result.getPhysicalNetworkId());\n        if (pnw != null) {\n            response.setPhysicalNetworkId(pnw.getUuid());\n        }\n        PhysicalNetwork dnw = ApiDBUtils.findPhysicalNetworkById(result.getDestinationPhysicalNetworkId());\n        if (dnw != null) {\n            response.setDestinationPhysicalNetworkId(dnw.getUuid());\n        }\n        response.setState(result.getState().toString());\n\n        // set enabled services\n        List<String> services = new ArrayList<String>();\n        for (Service service : result.getEnabledServices()) {\n            services.add(service.getName());\n        }\n        response.setServices(services);\n\n        response.setObjectName(\"networkserviceprovider\");\n        return response;\n    }","id":91231,"modified_method":"@Override\n    public ProviderResponse createNetworkServiceProviderResponse(PhysicalNetworkServiceProvider result) {\n        ProviderResponse response = new ProviderResponse();\n        response.setId(result.getUuid());\n        response.setName(result.getProviderName());\n        PhysicalNetwork pnw = ApiDBUtils.findPhysicalNetworkById(result.getPhysicalNetworkId());\n        if (pnw != null) {\n            response.setPhysicalNetworkId(pnw.getUuid());\n        }\n        PhysicalNetwork dnw = ApiDBUtils.findPhysicalNetworkById(result.getDestinationPhysicalNetworkId());\n        if (dnw != null) {\n            response.setDestinationPhysicalNetworkId(dnw.getUuid());\n        }\n        if (result.getState() != null) {\n            response.setState(result.getState().toString());\n        }\n\n        // set enabled services\n        List<String> services = new ArrayList<String>();\n        for (Service service : result.getEnabledServices()) {\n            services.add(service.getName());\n        }\n        response.setServices(services);\n\n        response.setObjectName(\"networkserviceprovider\");\n        return response;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public NetworkResponse createNetworkResponse(Network network) {\n        // need to get network profile in order to retrieve dns information from there\n        NetworkProfile profile = ApiDBUtils.getNetworkProfile(network.getId());\n        NetworkResponse response = new NetworkResponse();\n        response.setId(network.getUuid());\n        response.setName(network.getName());\n        response.setDisplaytext(network.getDisplayText());\n        if (network.getBroadcastDomainType() != null) {\n            response.setBroadcastDomainType(network.getBroadcastDomainType().toString());\n        }\n\n        if (network.getTrafficType() != null) {\n            response.setTrafficType(network.getTrafficType().name());\n        }\n\n        if (network.getGuestType() != null) {\n            response.setType(network.getGuestType().toString());\n        }\n\n        response.setGateway(network.getGateway());\n\n        // FIXME - either set netmask or cidr\n        response.setCidr(network.getCidr());\n        if (network.getCidr() != null) {\n            response.setNetmask(NetUtils.cidr2Netmask(network.getCidr()));\n        }\n\n        //return vlan information only to Root admin\n        if (network.getBroadcastUri() != null && UserContext.current().getCaller().getType() == Account.ACCOUNT_TYPE_ADMIN) {\n            String broadcastUri = network.getBroadcastUri().toString();\n            response.setBroadcastUri(broadcastUri);\n            String vlan=\"N/A\";\n            if (broadcastUri.startsWith(\"vlan\")) {\n                vlan = broadcastUri.substring(\"vlan://\".length(), broadcastUri.length());\n            }\n            //return vlan information only to Root admin\n            response.setVlan(vlan);\n\n        }\n\n        DataCenter zone = ApiDBUtils.findZoneById(network.getDataCenterId());\n        if (zone != null) {\n            response.setZoneId(zone.getUuid());\n            response.setZoneName(zone.getName());\n        }\n        if (network.getPhysicalNetworkId() != null) {\n            PhysicalNetworkVO pnet = ApiDBUtils.findPhysicalNetworkById(network.getPhysicalNetworkId());\n            response.setPhysicalNetworkId(pnet.getUuid());\n        }\n\n        // populate network offering information\n        NetworkOffering networkOffering = ApiDBUtils.findNetworkOfferingById(network.getNetworkOfferingId());\n        if (networkOffering != null) {\n            response.setNetworkOfferingId(networkOffering.getUuid());\n            response.setNetworkOfferingName(networkOffering.getName());\n            response.setNetworkOfferingDisplayText(networkOffering.getDisplayText());\n            response.setIsSystem(networkOffering.isSystemOnly());\n            response.setNetworkOfferingAvailability(networkOffering.getAvailability().toString());\n        }\n\n        if (network.getAclType() != null) {\n            response.setAclType(network.getAclType().toString());\n        }\n        response.setState(network.getState().toString());\n        response.setRestartRequired(network.isRestartRequired());\n        NetworkVO nw = ApiDBUtils.findNetworkById(network.getRelated());\n        if (nw != null) {\n            response.setRelated(nw.getUuid());\n        }\n        response.setNetworkDomain(network.getNetworkDomain());\n\n        response.setDns1(profile.getDns1());\n        response.setDns2(profile.getDns2());\n        // populate capability\n        Map<Service, Map<Capability, String>> serviceCapabilitiesMap = ApiDBUtils.getNetworkCapabilities(network.getId(), network.getDataCenterId());\n        List<ServiceResponse> serviceResponses = new ArrayList<ServiceResponse>();\n        if (serviceCapabilitiesMap != null) {\n            for (Service service : serviceCapabilitiesMap.keySet()) {\n                ServiceResponse serviceResponse = new ServiceResponse();\n                // skip gateway service\n                if (service == Service.Gateway) {\n                    continue;\n                }\n                serviceResponse.setName(service.getName());\n\n                // set list of capabilities for the service\n                List<CapabilityResponse> capabilityResponses = new ArrayList<CapabilityResponse>();\n                Map<Capability, String> serviceCapabilities = serviceCapabilitiesMap.get(service);\n                if (serviceCapabilities != null) {\n                    for (Capability capability : serviceCapabilities.keySet()) {\n                        CapabilityResponse capabilityResponse = new CapabilityResponse();\n                        String capabilityValue = serviceCapabilities.get(capability);\n                        capabilityResponse.setName(capability.getName());\n                        capabilityResponse.setValue(capabilityValue);\n                        capabilityResponse.setObjectName(\"capability\");\n                        capabilityResponses.add(capabilityResponse);\n                    }\n                    serviceResponse.setCapabilities(capabilityResponses);\n                }\n\n                serviceResponse.setObjectName(\"service\");\n                serviceResponses.add(serviceResponse);\n            }\n        }\n        response.setServices(serviceResponses);\n\n        if (network.getAclType() == null || network.getAclType() == ACLType.Account) {\n            populateOwner(response, network);\n        } else {\n            // get domain from network_domain table\n            Pair<Long, Boolean> domainNetworkDetails = ApiDBUtils.getDomainNetworkDetails(network.getId());\n            if (domainNetworkDetails.first() != null) {\n                Domain domain = ApiDBUtils.findDomainById(domainNetworkDetails.first());\n                if (domain != null) {\n                    response.setDomainId(domain.getUuid());\n                }\n            }\n            response.setSubdomainAccess(domainNetworkDetails.second());\n        }\n\n        Long dedicatedDomainId = ApiDBUtils.getDedicatedNetworkDomain(network.getId());\n        if (dedicatedDomainId != null) {\n            Domain domain = ApiDBUtils.findDomainById(dedicatedDomainId);\n            if (domain != null) {\n                response.setDomainId(domain.getUuid());\n            }\n            response.setDomainName(domain.getName());\n        }\n\n        response.setSpecifyIpRanges(network.getSpecifyIpRanges());\n        if (network.getVpcId() != null) {\n            Vpc vpc = ApiDBUtils.findVpcById(network.getVpcId());\n            if (vpc != null) {\n                response.setVpcId(vpc.getUuid());\n            }\n        }\n        response.setCanUseForDeploy(ApiDBUtils.canUseForDeploy(network));\n\n        //set tag information\n        List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.Network, network.getId());\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        response.setTags(tagResponses);\n\n        response.setObjectName(\"network\");\n        return response;\n    }","id":91232,"modified_method":"@Override\n    public NetworkResponse createNetworkResponse(Network network) {\n        // need to get network profile in order to retrieve dns information from there\n        NetworkProfile profile = ApiDBUtils.getNetworkProfile(network.getId());\n        NetworkResponse response = new NetworkResponse();\n        response.setId(network.getUuid());\n        response.setName(network.getName());\n        response.setDisplaytext(network.getDisplayText());\n        if (network.getBroadcastDomainType() != null) {\n            response.setBroadcastDomainType(network.getBroadcastDomainType().toString());\n        }\n\n        if (network.getTrafficType() != null) {\n            response.setTrafficType(network.getTrafficType().name());\n        }\n\n        if (network.getGuestType() != null) {\n            response.setType(network.getGuestType().toString());\n        }\n\n        response.setGateway(network.getGateway());\n\n        // FIXME - either set netmask or cidr\n        response.setCidr(network.getCidr());\n        if (network.getCidr() != null) {\n            response.setNetmask(NetUtils.cidr2Netmask(network.getCidr()));\n        }\n\n        //return vlan information only to Root admin\n        if (network.getBroadcastUri() != null && UserContext.current().getCaller().getType() == Account.ACCOUNT_TYPE_ADMIN) {\n            String broadcastUri = network.getBroadcastUri().toString();\n            response.setBroadcastUri(broadcastUri);\n            String vlan=\"N/A\";\n            if (broadcastUri.startsWith(\"vlan\")) {\n                vlan = broadcastUri.substring(\"vlan://\".length(), broadcastUri.length());\n            }\n            //return vlan information only to Root admin\n            response.setVlan(vlan);\n\n        }\n\n        DataCenter zone = ApiDBUtils.findZoneById(network.getDataCenterId());\n        if (zone != null) {\n            response.setZoneId(zone.getUuid());\n            response.setZoneName(zone.getName());\n        }\n        if (network.getPhysicalNetworkId() != null) {\n            PhysicalNetworkVO pnet = ApiDBUtils.findPhysicalNetworkById(network.getPhysicalNetworkId());\n            response.setPhysicalNetworkId(pnet.getUuid());\n        }\n\n        // populate network offering information\n        NetworkOffering networkOffering = ApiDBUtils.findNetworkOfferingById(network.getNetworkOfferingId());\n        if (networkOffering != null) {\n            response.setNetworkOfferingId(networkOffering.getUuid());\n            response.setNetworkOfferingName(networkOffering.getName());\n            response.setNetworkOfferingDisplayText(networkOffering.getDisplayText());\n            response.setIsSystem(networkOffering.isSystemOnly());\n            if (networkOffering.getAvailability() != null) {\n                response.setNetworkOfferingAvailability(networkOffering.getAvailability().toString());\n            }\n        }\n\n        if (network.getAclType() != null) {\n            response.setAclType(network.getAclType().toString());\n        }\n        if (network.getState() != null) {\n            response.setState(network.getState().toString());\n        }\n        response.setRestartRequired(network.isRestartRequired());\n        NetworkVO nw = ApiDBUtils.findNetworkById(network.getRelated());\n        if (nw != null) {\n            response.setRelated(nw.getUuid());\n        }\n        response.setNetworkDomain(network.getNetworkDomain());\n\n        response.setDns1(profile.getDns1());\n        response.setDns2(profile.getDns2());\n        // populate capability\n        Map<Service, Map<Capability, String>> serviceCapabilitiesMap = ApiDBUtils.getNetworkCapabilities(network.getId(), network.getDataCenterId());\n        List<ServiceResponse> serviceResponses = new ArrayList<ServiceResponse>();\n        if (serviceCapabilitiesMap != null) {\n            for (Service service : serviceCapabilitiesMap.keySet()) {\n                ServiceResponse serviceResponse = new ServiceResponse();\n                // skip gateway service\n                if (service == Service.Gateway) {\n                    continue;\n                }\n                serviceResponse.setName(service.getName());\n\n                // set list of capabilities for the service\n                List<CapabilityResponse> capabilityResponses = new ArrayList<CapabilityResponse>();\n                Map<Capability, String> serviceCapabilities = serviceCapabilitiesMap.get(service);\n                if (serviceCapabilities != null) {\n                    for (Capability capability : serviceCapabilities.keySet()) {\n                        CapabilityResponse capabilityResponse = new CapabilityResponse();\n                        String capabilityValue = serviceCapabilities.get(capability);\n                        capabilityResponse.setName(capability.getName());\n                        capabilityResponse.setValue(capabilityValue);\n                        capabilityResponse.setObjectName(\"capability\");\n                        capabilityResponses.add(capabilityResponse);\n                    }\n                    serviceResponse.setCapabilities(capabilityResponses);\n                }\n\n                serviceResponse.setObjectName(\"service\");\n                serviceResponses.add(serviceResponse);\n            }\n        }\n        response.setServices(serviceResponses);\n\n        if (network.getAclType() == null || network.getAclType() == ACLType.Account) {\n            populateOwner(response, network);\n        } else {\n            // get domain from network_domain table\n            Pair<Long, Boolean> domainNetworkDetails = ApiDBUtils.getDomainNetworkDetails(network.getId());\n            if (domainNetworkDetails.first() != null) {\n                Domain domain = ApiDBUtils.findDomainById(domainNetworkDetails.first());\n                if (domain != null) {\n                    response.setDomainId(domain.getUuid());\n                }\n            }\n            response.setSubdomainAccess(domainNetworkDetails.second());\n        }\n\n        Long dedicatedDomainId = ApiDBUtils.getDedicatedNetworkDomain(network.getId());\n        if (dedicatedDomainId != null) {\n            Domain domain = ApiDBUtils.findDomainById(dedicatedDomainId);\n            if (domain != null) {\n                response.setDomainId(domain.getUuid());\n            }\n            response.setDomainName(domain.getName());\n        }\n\n        response.setSpecifyIpRanges(network.getSpecifyIpRanges());\n        if (network.getVpcId() != null) {\n            Vpc vpc = ApiDBUtils.findVpcById(network.getVpcId());\n            if (vpc != null) {\n                response.setVpcId(vpc.getUuid());\n            }\n        }\n        response.setCanUseForDeploy(ApiDBUtils.canUseForDeploy(network));\n\n        //set tag information\n        List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.Network, network.getId());\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        response.setTags(tagResponses);\n\n        response.setObjectName(\"network\");\n        return response;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public TemplateResponse createIsoResponse(VirtualMachineTemplate result) {\n        TemplateResponse response = new TemplateResponse();\n        response.setId(result.getUuid());\n        response.setName(result.getName());\n        response.setDisplayText(result.getDisplayText());\n        response.setPublic(result.isPublicTemplate());\n        response.setCreated(result.getCreated());\n        response.setFormat(result.getFormat());\n        GuestOS os = ApiDBUtils.findGuestOSById(result.getGuestOSId());\n        if (os != null) {\n            response.setOsTypeId(os.getUuid());\n            response.setOsTypeName(os.getDisplayName());\n        }\n        response.setDetails(result.getDetails());\n        Account caller = UserContext.current().getCaller();\n\n        if (result.getFormat() == ImageFormat.ISO) { // Templates are always bootable\n            response.setBootable(result.isBootable());\n        } else {\n            response.setHypervisor(result.getHypervisorType().toString());// hypervisors are associated with templates\n        }\n\n        // add account ID and name\n        Account owner = ApiDBUtils.findAccountById(result.getAccountId());\n        populateAccount(response, owner.getId());\n        populateDomain(response, owner.getDomainId());\n\n        //set tag information\n        List<? extends ResourceTag> tags = null;\n        if (result.getFormat() == ImageFormat.ISO) {\n            tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.ISO, result.getId());\n        } else {\n            tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.Template, result.getId());\n        }\n\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        response.setTags(tagResponses);\n\n        response.setObjectName(\"iso\");\n        return response;\n    }","id":91233,"modified_method":"@Override\n    public TemplateResponse createIsoResponse(VirtualMachineTemplate result) {\n        TemplateResponse response = new TemplateResponse();\n        response.setId(result.getUuid());\n        response.setName(result.getName());\n        response.setDisplayText(result.getDisplayText());\n        response.setPublic(result.isPublicTemplate());\n        response.setCreated(result.getCreated());\n        response.setFormat(result.getFormat());\n        GuestOS os = ApiDBUtils.findGuestOSById(result.getGuestOSId());\n        if (os != null) {\n            response.setOsTypeId(os.getUuid());\n            response.setOsTypeName(os.getDisplayName());\n        }\n        response.setDetails(result.getDetails());\n        Account caller = UserContext.current().getCaller();\n\n        if (result.getFormat() == ImageFormat.ISO) { // Templates are always bootable\n            response.setBootable(result.isBootable());\n        } else {\n            if (result.getHypervisorType() != null) {\n                response.setHypervisor(result.getHypervisorType().toString());// hypervisors\n                                                                              // are\n                                                                              // associated\n                                                                              // with\n                                                                              // templates\n            }\n        }\n\n        // add account ID and name\n        Account owner = ApiDBUtils.findAccountById(result.getAccountId());\n        populateAccount(response, owner.getId());\n        populateDomain(response, owner.getDomainId());\n\n        //set tag information\n        List<? extends ResourceTag> tags = null;\n        if (result.getFormat() == ImageFormat.ISO) {\n            tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.ISO, result.getId());\n        } else {\n            tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.Template, result.getId());\n        }\n\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        response.setTags(tagResponses);\n\n        response.setObjectName(\"iso\");\n        return response;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public LoadBalancerResponse createLoadBalancerResponse(LoadBalancer loadBalancer) {\n        LoadBalancerResponse lbResponse = new LoadBalancerResponse();\n        lbResponse.setId(loadBalancer.getUuid());\n        lbResponse.setName(loadBalancer.getName());\n        lbResponse.setDescription(loadBalancer.getDescription());\n        List<String> cidrs = ApiDBUtils.findFirewallSourceCidrs(loadBalancer.getId());\n        lbResponse.setCidrList(StringUtils.join(cidrs, \",\"));\n\n        IPAddressVO publicIp = ApiDBUtils.findIpAddressById(loadBalancer.getSourceIpAddressId());\n        lbResponse.setPublicIpId(publicIp.getUuid());\n        lbResponse.setPublicIp(publicIp.getAddress().addr());\n        lbResponse.setPublicPort(Integer.toString(loadBalancer.getSourcePortStart()));\n        lbResponse.setPrivatePort(Integer.toString(loadBalancer.getDefaultPortStart()));\n        lbResponse.setAlgorithm(loadBalancer.getAlgorithm());\n        FirewallRule.State state = loadBalancer.getState();\n        String stateToSet = state.toString();\n        if (state.equals(FirewallRule.State.Revoke)) {\n            stateToSet = \"Deleting\";\n        }\n        lbResponse.setState(stateToSet);\n        populateOwner(lbResponse, loadBalancer);\n        DataCenter zone = ApiDBUtils.findZoneById(publicIp.getDataCenterId());\n        if (zone != null) {\n            lbResponse.setZoneId(zone.getUuid());\n        }\n\n        //set tag information\n        List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.UserVm, loadBalancer.getId());\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        lbResponse.setTags(tagResponses);\n\n        lbResponse.setObjectName(\"loadbalancer\");\n        return lbResponse;\n    }","id":91234,"modified_method":"@Override\n    public LoadBalancerResponse createLoadBalancerResponse(LoadBalancer loadBalancer) {\n        LoadBalancerResponse lbResponse = new LoadBalancerResponse();\n        lbResponse.setId(loadBalancer.getUuid());\n        lbResponse.setName(loadBalancer.getName());\n        lbResponse.setDescription(loadBalancer.getDescription());\n        List<String> cidrs = ApiDBUtils.findFirewallSourceCidrs(loadBalancer.getId());\n        lbResponse.setCidrList(StringUtils.join(cidrs, \",\"));\n\n        IPAddressVO publicIp = ApiDBUtils.findIpAddressById(loadBalancer.getSourceIpAddressId());\n        lbResponse.setPublicIpId(publicIp.getUuid());\n        lbResponse.setPublicIp(publicIp.getAddress().addr());\n        lbResponse.setPublicPort(Integer.toString(loadBalancer.getSourcePortStart()));\n        lbResponse.setPrivatePort(Integer.toString(loadBalancer.getDefaultPortStart()));\n        lbResponse.setAlgorithm(loadBalancer.getAlgorithm());\n        FirewallRule.State state = loadBalancer.getState();\n        if (state != null) {\n            String stateToSet = state.toString();\n            if (state.equals(FirewallRule.State.Revoke)) {\n                stateToSet = \"Deleting\";\n            }\n            lbResponse.setState(stateToSet);\n        }\n        populateOwner(lbResponse, loadBalancer);\n        DataCenter zone = ApiDBUtils.findZoneById(publicIp.getDataCenterId());\n        if (zone != null) {\n            lbResponse.setZoneId(zone.getUuid());\n        }\n\n        //set tag information\n        List<? extends ResourceTag> tags = ApiDBUtils.listByResourceTypeAndId(TaggedResourceType.UserVm, loadBalancer.getId());\n        List<ResourceTagResponse> tagResponses = new ArrayList<ResourceTagResponse>();\n        for (ResourceTag tag : tags) {\n            ResourceTagResponse tagResponse = createResourceTagResponse(tag, true);\n            tagResponses.add(tagResponse);\n        }\n        lbResponse.setTags(tagResponses);\n\n        lbResponse.setObjectName(\"loadbalancer\");\n        return lbResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public AccountResponse createAccountResponse(Account account) {\n        boolean accountIsAdmin = (account.getType() == Account.ACCOUNT_TYPE_ADMIN);\n        AccountResponse accountResponse = new AccountResponse();\n        accountResponse.setId(account.getUuid());\n        accountResponse.setName(account.getAccountName());\n        accountResponse.setAccountType(account.getType());\n        Domain domain = ApiDBUtils.findDomainById(account.getDomainId());\n        if (domain != null) {\n            accountResponse.setDomainId(domain.getUuid());\n            accountResponse.setDomainName(domain.getName());\n        }\n        accountResponse.setState(account.getState().toString());\n        accountResponse.setNetworkDomain(account.getNetworkDomain());\n        DataCenter dc = ApiDBUtils.findZoneById(account.getDefaultZoneId());\n        if (dc != null) {\n            accountResponse.setDefaultZone(dc.getUuid());\n        }\n\n        // get network stat\n        List<UserStatisticsVO> stats = ApiDBUtils.listUserStatsBy(account.getId());\n        if (stats == null) {\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Internal error searching for user stats\");\n        }\n\n        Long bytesSent = 0L;\n        Long bytesReceived = 0L;\n        for (UserStatisticsVO stat : stats) {\n            Long rx = stat.getNetBytesReceived() + stat.getCurrentBytesReceived();\n            Long tx = stat.getNetBytesSent() + stat.getCurrentBytesSent();\n            bytesReceived = bytesReceived + Long.valueOf(rx);\n            bytesSent = bytesSent + Long.valueOf(tx);\n        }\n        accountResponse.setBytesReceived(bytesReceived);\n        accountResponse.setBytesSent(bytesSent);\n\n        // Get resource limits and counts\n\n        Long vmLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.user_vm, account.getId());\n        String vmLimitDisplay = (accountIsAdmin || vmLimit == -1) ? \"Unlimited\" : String.valueOf(vmLimit);\n        Long vmTotal = ApiDBUtils.getResourceCount(ResourceType.user_vm, account.getId());\n        String vmAvail = (accountIsAdmin || vmLimit == -1) ? \"Unlimited\" : String.valueOf(vmLimit - vmTotal);\n        accountResponse.setVmLimit(vmLimitDisplay);\n        accountResponse.setVmTotal(vmTotal);\n        accountResponse.setVmAvailable(vmAvail);\n\n        Long ipLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.public_ip, account.getId());\n        String ipLimitDisplay = (accountIsAdmin || ipLimit == -1) ? \"Unlimited\" : String.valueOf(ipLimit);\n        Long ipTotal = ApiDBUtils.getResourceCount(ResourceType.public_ip, account.getId());\n\n        Long ips = ipLimit - ipTotal;\n        // check how many free ips are left, and if it's less than max allowed number of ips from account - use this\n        // value\n        Long ipsLeft = ApiDBUtils.countFreePublicIps();\n        boolean unlimited = true;\n        if (ips.longValue() > ipsLeft.longValue()) {\n            ips = ipsLeft;\n            unlimited = false;\n        }\n\n        String ipAvail = ((accountIsAdmin || ipLimit == -1) && unlimited) ? \"Unlimited\" : String.valueOf(ips);\n\n        accountResponse.setIpLimit(ipLimitDisplay);\n        accountResponse.setIpTotal(ipTotal);\n        accountResponse.setIpAvailable(ipAvail);\n\n        Long volumeLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.volume, account.getId());\n        String volumeLimitDisplay = (accountIsAdmin || volumeLimit == -1) ? \"Unlimited\" : String.valueOf(volumeLimit);\n        Long volumeTotal = ApiDBUtils.getResourceCount(ResourceType.volume, account.getId());\n        String volumeAvail = (accountIsAdmin || volumeLimit == -1) ? \"Unlimited\" : String.valueOf(volumeLimit - volumeTotal);\n        accountResponse.setVolumeLimit(volumeLimitDisplay);\n        accountResponse.setVolumeTotal(volumeTotal);\n        accountResponse.setVolumeAvailable(volumeAvail);\n\n        Long snapshotLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.snapshot, account.getId());\n        String snapshotLimitDisplay = (accountIsAdmin || snapshotLimit == -1) ? \"Unlimited\" : String.valueOf(snapshotLimit);\n        Long snapshotTotal = ApiDBUtils.getResourceCount(ResourceType.snapshot, account.getId());\n        String snapshotAvail = (accountIsAdmin || snapshotLimit == -1) ? \"Unlimited\" : String.valueOf(snapshotLimit - snapshotTotal);\n        accountResponse.setSnapshotLimit(snapshotLimitDisplay);\n        accountResponse.setSnapshotTotal(snapshotTotal);\n        accountResponse.setSnapshotAvailable(snapshotAvail);\n\n        Long templateLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.template, account.getId());\n        String templateLimitDisplay = (accountIsAdmin || templateLimit == -1) ? \"Unlimited\" : String.valueOf(templateLimit);\n        Long templateTotal = ApiDBUtils.getResourceCount(ResourceType.template, account.getId());\n        String templateAvail = (accountIsAdmin || templateLimit == -1) ? \"Unlimited\" : String.valueOf(templateLimit - templateTotal);\n        accountResponse.setTemplateLimit(templateLimitDisplay);\n        accountResponse.setTemplateTotal(templateTotal);\n        accountResponse.setTemplateAvailable(templateAvail);\n\n        // Get stopped and running VMs\n        int vmStopped = 0;\n        int vmRunning = 0;\n\n        List<Long> permittedAccounts = new ArrayList<Long>();\n        permittedAccounts.add(account.getId());\n\n        List<UserVmJoinVO> virtualMachines = ApiDBUtils.searchForUserVMs(new Criteria(), permittedAccounts);\n\n        // get Running/Stopped VMs\n        for (Iterator<UserVmJoinVO> iter = virtualMachines.iterator(); iter.hasNext();) {\n            // count how many stopped/running vms we have\n            UserVmJoinVO vm = iter.next();\n\n            if (vm.getState() == State.Stopped) {\n                vmStopped++;\n            } else if (vm.getState() == State.Running) {\n                vmRunning++;\n            }\n        }\n\n        accountResponse.setVmStopped(vmStopped);\n        accountResponse.setVmRunning(vmRunning);\n        accountResponse.setObjectName(\"account\");\n\n        //get resource limits for projects\n        Long projectLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.project, account.getId());\n        String projectLimitDisplay = (accountIsAdmin || projectLimit == -1) ? \"Unlimited\" : String.valueOf(projectLimit);\n        Long projectTotal = ApiDBUtils.getResourceCount(ResourceType.project, account.getId());\n        String projectAvail = (accountIsAdmin || projectLimit == -1) ? \"Unlimited\" : String.valueOf(projectLimit - projectTotal);\n        accountResponse.setProjectLimit(projectLimitDisplay);\n        accountResponse.setProjectTotal(projectTotal);\n        accountResponse.setProjectAvailable(projectAvail);\n\n        //get resource limits for networks\n        Long networkLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.network, account.getId());\n        String networkLimitDisplay = (accountIsAdmin || networkLimit == -1) ? \"Unlimited\" : String.valueOf(networkLimit);\n        Long networkTotal = ApiDBUtils.getResourceCount(ResourceType.network, account.getId());\n        String networkAvail = (accountIsAdmin || networkLimit == -1) ? \"Unlimited\" : String.valueOf(networkLimit - networkTotal);\n        accountResponse.setNetworkLimit(networkLimitDisplay);\n        accountResponse.setNetworkTotal(networkTotal);\n        accountResponse.setNetworkAvailable(networkAvail);\n\n        //get resource limits for vpcs\n        Long vpcLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.vpc, account.getId());\n        String vpcLimitDisplay = (accountIsAdmin || vpcLimit == -1) ? \"Unlimited\" : String.valueOf(vpcLimit);\n        Long vpcTotal = ApiDBUtils.getResourceCount(ResourceType.vpc, account.getId());\n        String vpcAvail = (accountIsAdmin || vpcLimit == -1) ? \"Unlimited\" : String.valueOf(vpcLimit - vpcTotal);\n        accountResponse.setNetworkLimit(vpcLimitDisplay);\n        accountResponse.setNetworkTotal(vpcTotal);\n        accountResponse.setNetworkAvailable(vpcAvail);\n\n        // adding all the users for an account as part of the response obj\n        List<UserVO> usersForAccount = ApiDBUtils.listUsersByAccount(account.getAccountId());\n        List<UserResponse> userResponseList = new ArrayList<UserResponse>();\n        for (UserVO user : usersForAccount) {\n            UserResponse userResponse = createUserResponse(user);\n            userResponseList.add(userResponse);\n        }\n\n        accountResponse.setUsers(userResponseList);\n        accountResponse.setDetails(ApiDBUtils.getAccountDetails(account.getId()));\n        return accountResponse;\n    }","id":91235,"modified_method":"@Override\n    public AccountResponse createAccountResponse(Account account) {\n        boolean accountIsAdmin = (account.getType() == Account.ACCOUNT_TYPE_ADMIN);\n        AccountResponse accountResponse = new AccountResponse();\n        accountResponse.setId(account.getUuid());\n        accountResponse.setName(account.getAccountName());\n        accountResponse.setAccountType(account.getType());\n        Domain domain = ApiDBUtils.findDomainById(account.getDomainId());\n        if (domain != null) {\n            accountResponse.setDomainId(domain.getUuid());\n            accountResponse.setDomainName(domain.getName());\n        }\n        if (account.getState() != null) {\n            accountResponse.setState(account.getState().toString());\n        }\n        accountResponse.setNetworkDomain(account.getNetworkDomain());\n        DataCenter dc = ApiDBUtils.findZoneById(account.getDefaultZoneId());\n        if (dc != null) {\n            accountResponse.setDefaultZone(dc.getUuid());\n        }\n\n        // get network stat\n        List<UserStatisticsVO> stats = ApiDBUtils.listUserStatsBy(account.getId());\n        if (stats == null) {\n            throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Internal error searching for user stats\");\n        }\n\n        Long bytesSent = 0L;\n        Long bytesReceived = 0L;\n        for (UserStatisticsVO stat : stats) {\n            Long rx = stat.getNetBytesReceived() + stat.getCurrentBytesReceived();\n            Long tx = stat.getNetBytesSent() + stat.getCurrentBytesSent();\n            bytesReceived = bytesReceived + Long.valueOf(rx);\n            bytesSent = bytesSent + Long.valueOf(tx);\n        }\n        accountResponse.setBytesReceived(bytesReceived);\n        accountResponse.setBytesSent(bytesSent);\n\n        // Get resource limits and counts\n\n        Long vmLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.user_vm, account.getId());\n        String vmLimitDisplay = (accountIsAdmin || vmLimit == -1) ? \"Unlimited\" : String.valueOf(vmLimit);\n        Long vmTotal = ApiDBUtils.getResourceCount(ResourceType.user_vm, account.getId());\n        String vmAvail = (accountIsAdmin || vmLimit == -1) ? \"Unlimited\" : String.valueOf(vmLimit - vmTotal);\n        accountResponse.setVmLimit(vmLimitDisplay);\n        accountResponse.setVmTotal(vmTotal);\n        accountResponse.setVmAvailable(vmAvail);\n\n        Long ipLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.public_ip, account.getId());\n        String ipLimitDisplay = (accountIsAdmin || ipLimit == -1) ? \"Unlimited\" : String.valueOf(ipLimit);\n        Long ipTotal = ApiDBUtils.getResourceCount(ResourceType.public_ip, account.getId());\n\n        Long ips = ipLimit - ipTotal;\n        // check how many free ips are left, and if it's less than max allowed number of ips from account - use this\n        // value\n        Long ipsLeft = ApiDBUtils.countFreePublicIps();\n        boolean unlimited = true;\n        if (ips.longValue() > ipsLeft.longValue()) {\n            ips = ipsLeft;\n            unlimited = false;\n        }\n\n        String ipAvail = ((accountIsAdmin || ipLimit == -1) && unlimited) ? \"Unlimited\" : String.valueOf(ips);\n\n        accountResponse.setIpLimit(ipLimitDisplay);\n        accountResponse.setIpTotal(ipTotal);\n        accountResponse.setIpAvailable(ipAvail);\n\n        Long volumeLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.volume, account.getId());\n        String volumeLimitDisplay = (accountIsAdmin || volumeLimit == -1) ? \"Unlimited\" : String.valueOf(volumeLimit);\n        Long volumeTotal = ApiDBUtils.getResourceCount(ResourceType.volume, account.getId());\n        String volumeAvail = (accountIsAdmin || volumeLimit == -1) ? \"Unlimited\" : String.valueOf(volumeLimit - volumeTotal);\n        accountResponse.setVolumeLimit(volumeLimitDisplay);\n        accountResponse.setVolumeTotal(volumeTotal);\n        accountResponse.setVolumeAvailable(volumeAvail);\n\n        Long snapshotLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.snapshot, account.getId());\n        String snapshotLimitDisplay = (accountIsAdmin || snapshotLimit == -1) ? \"Unlimited\" : String.valueOf(snapshotLimit);\n        Long snapshotTotal = ApiDBUtils.getResourceCount(ResourceType.snapshot, account.getId());\n        String snapshotAvail = (accountIsAdmin || snapshotLimit == -1) ? \"Unlimited\" : String.valueOf(snapshotLimit - snapshotTotal);\n        accountResponse.setSnapshotLimit(snapshotLimitDisplay);\n        accountResponse.setSnapshotTotal(snapshotTotal);\n        accountResponse.setSnapshotAvailable(snapshotAvail);\n\n        Long templateLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.template, account.getId());\n        String templateLimitDisplay = (accountIsAdmin || templateLimit == -1) ? \"Unlimited\" : String.valueOf(templateLimit);\n        Long templateTotal = ApiDBUtils.getResourceCount(ResourceType.template, account.getId());\n        String templateAvail = (accountIsAdmin || templateLimit == -1) ? \"Unlimited\" : String.valueOf(templateLimit - templateTotal);\n        accountResponse.setTemplateLimit(templateLimitDisplay);\n        accountResponse.setTemplateTotal(templateTotal);\n        accountResponse.setTemplateAvailable(templateAvail);\n\n        // Get stopped and running VMs\n        int vmStopped = 0;\n        int vmRunning = 0;\n\n        List<Long> permittedAccounts = new ArrayList<Long>();\n        permittedAccounts.add(account.getId());\n\n        List<UserVmJoinVO> virtualMachines = ApiDBUtils.searchForUserVMs(new Criteria(), permittedAccounts);\n\n        // get Running/Stopped VMs\n        for (Iterator<UserVmJoinVO> iter = virtualMachines.iterator(); iter.hasNext();) {\n            // count how many stopped/running vms we have\n            UserVmJoinVO vm = iter.next();\n\n            if (vm.getState() == State.Stopped) {\n                vmStopped++;\n            } else if (vm.getState() == State.Running) {\n                vmRunning++;\n            }\n        }\n\n        accountResponse.setVmStopped(vmStopped);\n        accountResponse.setVmRunning(vmRunning);\n        accountResponse.setObjectName(\"account\");\n\n        //get resource limits for projects\n        Long projectLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.project, account.getId());\n        String projectLimitDisplay = (accountIsAdmin || projectLimit == -1) ? \"Unlimited\" : String.valueOf(projectLimit);\n        Long projectTotal = ApiDBUtils.getResourceCount(ResourceType.project, account.getId());\n        String projectAvail = (accountIsAdmin || projectLimit == -1) ? \"Unlimited\" : String.valueOf(projectLimit - projectTotal);\n        accountResponse.setProjectLimit(projectLimitDisplay);\n        accountResponse.setProjectTotal(projectTotal);\n        accountResponse.setProjectAvailable(projectAvail);\n\n        //get resource limits for networks\n        Long networkLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.network, account.getId());\n        String networkLimitDisplay = (accountIsAdmin || networkLimit == -1) ? \"Unlimited\" : String.valueOf(networkLimit);\n        Long networkTotal = ApiDBUtils.getResourceCount(ResourceType.network, account.getId());\n        String networkAvail = (accountIsAdmin || networkLimit == -1) ? \"Unlimited\" : String.valueOf(networkLimit - networkTotal);\n        accountResponse.setNetworkLimit(networkLimitDisplay);\n        accountResponse.setNetworkTotal(networkTotal);\n        accountResponse.setNetworkAvailable(networkAvail);\n\n        //get resource limits for vpcs\n        Long vpcLimit = ApiDBUtils.findCorrectResourceLimit(ResourceType.vpc, account.getId());\n        String vpcLimitDisplay = (accountIsAdmin || vpcLimit == -1) ? \"Unlimited\" : String.valueOf(vpcLimit);\n        Long vpcTotal = ApiDBUtils.getResourceCount(ResourceType.vpc, account.getId());\n        String vpcAvail = (accountIsAdmin || vpcLimit == -1) ? \"Unlimited\" : String.valueOf(vpcLimit - vpcTotal);\n        accountResponse.setNetworkLimit(vpcLimitDisplay);\n        accountResponse.setNetworkTotal(vpcTotal);\n        accountResponse.setNetworkAvailable(vpcAvail);\n\n        // adding all the users for an account as part of the response obj\n        List<UserVO> usersForAccount = ApiDBUtils.listUsersByAccount(account.getAccountId());\n        List<UserResponse> userResponseList = new ArrayList<UserResponse>();\n        for (UserVO user : usersForAccount) {\n            UserResponse userResponse = createUserResponse(user);\n            userResponseList.add(userResponse);\n        }\n\n        accountResponse.setUsers(userResponseList);\n        accountResponse.setDetails(ApiDBUtils.getAccountDetails(account.getId()));\n        return accountResponse;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public IpForwardingRuleResponse createIpForwardingRuleResponse(StaticNatRule fwRule) {\n        IpForwardingRuleResponse response = new IpForwardingRuleResponse();\n        response.setId(fwRule.getUuid());\n        response.setProtocol(fwRule.getProtocol());\n\n        IpAddress ip = ApiDBUtils.findIpAddressById(fwRule.getSourceIpAddressId());\n        response.setPublicIpAddressId(ip.getId());\n        response.setPublicIpAddress(ip.getAddress().addr());\n\n        if (ip != null && fwRule.getDestIpAddress() != null) {\n            UserVm vm = ApiDBUtils.findUserVmById(ip.getAssociatedWithVmId());\n            if (vm != null) {// vm might be destroyed\n                response.setVirtualMachineId(vm.getUuid());\n                response.setVirtualMachineName(vm.getHostName());\n                if (vm.getDisplayName() != null) {\n                    response.setVirtualMachineDisplayName(vm.getDisplayName());\n                } else {\n                    response.setVirtualMachineDisplayName(vm.getHostName());\n                }\n            }\n        }\n        FirewallRule.State state = fwRule.getState();\n        String stateToSet = state.toString();\n        if (state.equals(FirewallRule.State.Revoke)) {\n            stateToSet = \"Deleting\";\n        }\n\n        response.setStartPort(fwRule.getSourcePortStart());\n        response.setEndPort(fwRule.getSourcePortEnd());\n        response.setProtocol(fwRule.getProtocol());\n        response.setState(stateToSet);\n        response.setObjectName(\"ipforwardingrule\");\n        return response;\n    }","id":91236,"modified_method":"@Override\n    public IpForwardingRuleResponse createIpForwardingRuleResponse(StaticNatRule fwRule) {\n        IpForwardingRuleResponse response = new IpForwardingRuleResponse();\n        response.setId(fwRule.getUuid());\n        response.setProtocol(fwRule.getProtocol());\n\n        IpAddress ip = ApiDBUtils.findIpAddressById(fwRule.getSourceIpAddressId());\n        response.setPublicIpAddressId(ip.getId());\n        response.setPublicIpAddress(ip.getAddress().addr());\n\n        if (ip != null && fwRule.getDestIpAddress() != null) {\n            UserVm vm = ApiDBUtils.findUserVmById(ip.getAssociatedWithVmId());\n            if (vm != null) {// vm might be destroyed\n                response.setVirtualMachineId(vm.getUuid());\n                response.setVirtualMachineName(vm.getHostName());\n                if (vm.getDisplayName() != null) {\n                    response.setVirtualMachineDisplayName(vm.getDisplayName());\n                } else {\n                    response.setVirtualMachineDisplayName(vm.getHostName());\n                }\n            }\n        }\n        FirewallRule.State state = fwRule.getState();\n        if (state != null) {\n            String stateToSet = state.toString();\n            if (state.equals(FirewallRule.State.Revoke)) {\n                stateToSet = \"Deleting\";\n            }\n            response.setState(stateToSet);\n        }\n\n        response.setStartPort(fwRule.getSourcePortStart());\n        response.setEndPort(fwRule.getSourcePortEnd());\n        response.setProtocol(fwRule.getProtocol());\n        response.setObjectName(\"ipforwardingrule\");\n        return response;\n    }","commit_id":"fc56e29a3ec22035c744e276538e8a20e5923996","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n  public double[] score0(Chunk[] chks, int row_in_chunk, double[] tmp, double[] preds) {\n    double eta = 0.0;\n    final double [] b = beta();\n    if(!_parms._use_all_factor_levels){ // good level 0 of all factors\n      for(int i = 0; i < _dinfo._catOffsets.length-1; ++i) if(chks[i].atd(row_in_chunk) != 0)\n        eta += b[_dinfo._catOffsets[i] + (int)(chks[i].atd(row_in_chunk))-1];\n    } else { // do not skip any levels\n      for(int i = 0; i < _dinfo._catOffsets.length-1; ++i)\n        eta += b[_dinfo._catOffsets[i] + (int)chks[i].atd(row_in_chunk)];\n    }\n    final int noff = _dinfo.numStart() - _dinfo._cats ;\n    for(int i = _dinfo._cats; i < b.length-1-noff; ++i)\n      eta += b[noff+i]*chks[i].atd(row_in_chunk);\n    eta += b[b.length-1]; // intercept\n    double mu = _parms.linkInv(eta);\n    preds[0] = mu;\n    if( _parms._family == Family.binomial ) { // threshold for prediction\n      if(Double.isNaN(mu)){\n        preds[0] = Double.NaN;\n        preds[1] = Double.NaN;\n        preds[2] = Double.NaN;\n      } else {\n        preds[0] = (mu >= _output._threshold ? 1 : 0);\n        preds[1] = 1.0 - mu; // class 0\n        preds[2] =       mu; // class 1\n      }\n    }\n    return preds;\n  }","id":91237,"modified_method":"@Override\n  public double[] score0(Chunk[] chks, int row_in_chunk, double[] tmp, double[] preds) {\n    double eta = 0.0;\n    final double [] b = beta();\n    for(int i = 0; i < _dinfo._catOffsets.length-1; ++i) {\n      if(chks[i].isNA(row_in_chunk)) {\n        eta = Double.NaN;\n        break;\n      }\n      long lval = chks[i].at8(row_in_chunk);\n      int ival = (int)lval;\n      if(ival != lval) throw new IllegalArgumentException(\"categorical value out of range\");\n      if(_parms._use_all_factor_levels)\n        eta += b[_dinfo._catOffsets[i] + ival];\n      else if(ival != 0)\n        eta += b[_dinfo._catOffsets[i] + ival - 1];\n    }\n    final int noff = _dinfo.numStart() - _dinfo._cats ;\n    for(int i = _dinfo._cats; i < b.length-1-noff; ++i)\n      eta += b[noff+i]*chks[i].atd(row_in_chunk);\n    eta += b[b.length-1]; // intercept\n    double mu = _parms.linkInv(eta);\n    preds[0] = mu;\n    if( _parms._family == Family.binomial ) { // threshold for prediction\n      if(Double.isNaN(mu)){\n        preds[0] = Double.NaN;\n        preds[1] = Double.NaN;\n        preds[2] = Double.NaN;\n      } else {\n        preds[0] = (mu >= _output._threshold ? 1 : 0);\n        preds[1] = 1.0 - mu; // class 0\n        preds[2] =       mu; // class 1\n      }\n    }\n    return preds;\n  }","commit_id":"c7b322aba675374a1687b58dbec611af1e9daa94","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public boolean equals( Object o ) {\n      assert o instanceof Row;\n      Row r = (Row)o;\n      if( _hash != r._hash ) return false;\n      if( _chks == r._chks && _row == r._row ) return true;\n      // Now must check field contents\n      int len = _enum_maps.length;\n      for( int i=0; i<len; i++ ) {\n        if( _enum_maps[i] == null ) {\n          if( _chks[i].atd(_row) != r._chks[i].atd(_row) ) return false;\n        } else {\n          if( _enum_maps[i][(int) _chks[i].at8(_row)] != r._enum_maps[i][(int) r._chks[i].at8(r._row)] ) return false;\n        }\n      }\n      return true;\n    }","id":91238,"modified_method":"@Override public boolean equals( Object o ) {\n      assert o instanceof Row;\n      Row r = (Row)o;\n      if( _hash != r._hash ) return false;\n      if( _chks == r._chks && _row == r._row ) return true;\n      // Now must check field contents\n      int len = _enum_maps.length;\n      for( int c=0; c<len; c++ ) {\n        boolean lb = _chks[c].isNA(_row), rb = r._chks[c].isNA(r._row);\n        if( lb && rb ) continue;     // Both NA, count as equal\n        if( lb || rb ) return false; // One NA, one not - count as unequal\n        // Check longs for equality (thru the enum maps, if needed)\n        long ll = _chks[c].at8(_row), rl = r._chks[c].at8(r._row);\n        if( _enum_maps[c] == null ) {\n          if( ll != rl ) return false;\n        } else {\n          if( _enum_maps[c][(int) ll] != r._enum_maps[c][(int) rl] ) return false;\n        }\n      }\n      return true;\n    }","commit_id":"7645785e218c61e8c23ced6797b2225abd44675d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override void apply(Env env) {\n    Frame l = env.popAry();\n    Frame r = env.popAry();\n\n    // Look for the set of columns in common; resort left & right to make the\n    // leading prefix of column names match.  Bail out if we find any weird\n    // column types.\n    int ncols=0;                // Number of columns in common\n    for( int i=0; i<l._names.length; i++ ) {\n      int idx = r.find(l._names[i]);\n      if( idx != -1 ) {\n        l.swap(i  ,ncols);\n        r.swap(idx,ncols);\n        Vec lv = l.vecs()[ncols];\n        Vec rv = r.vecs()[ncols];\n        if( lv.get_type() != rv.get_type() )\n          throw new IllegalArgumentException(\"Merging columns must be the same type, column \"+l._names[ncols]+\n                                             \" found types \"+lv.get_type_str()+\" and \"+rv.get_type_str());\n        if( lv.isString() )\n          throw new IllegalArgumentException(\"Cannot merge Strings; flip toEnum first\");\n        ncols++;\n      }\n    }\n    if( ncols == 0 ) \n      throw new IllegalArgumentException(\"Frames must have at least one column in common to merge them\");\n\n    // Pick the frame to replicate & hash; smallest bytesize of the non-key\n    // columns.  Hashed dataframe is completely replicated per-node\n    long lsize = 0, rsize = 0;\n    for( int i=ncols; i<l.numCols(); i++ ) lsize += l.vecs()[i].byteSize();\n    for( int i=ncols; i<r.numCols(); i++ ) rsize += r.vecs()[i].byteSize();\n    Frame small = lsize < rsize ? l : r;\n    Frame large = lsize < rsize ? r : l;\n\n    // Build enum mappings, to rapidly convert enums from the larger\n    // distributed set to the smaller hashed & replicated set.\n    int[][] enum_maps = new int[ncols][];\n    int[][]   id_maps = new int[ncols][];\n    for( int i=0; i<ncols; i++ ) {\n      Vec lv = large.vecs()[i];\n      if( lv.isEnum() ) {\n        EnumWrappedVec ewv = new EnumWrappedVec(lv.domain(),small.vecs()[i].domain());\n        int[] ids = enum_maps[i] = ewv.enum_map();\n        DKV.remove(ewv._key);\n        // Build an Identity map for the smaller hash\n        id_maps[i] = new int[ids.length];\n        for( int j=0; j<ids.length; j++ )  id_maps[i][j] = j;\n      }\n    }\n\n    // MergeSet is from local (non-replicated) chunks/row to other-chunks/row.\n    // Row object in table has e.g. chunks and a row number; passed-in Row\n    // object can also have chunks & a row number.  Hash based on contents of\n    // chunks.  Returns matched Row object (which has replicated chunk ptrs & row).\n    Key uniq = new MergeSet(ncols,id_maps,small).doAllNodes()._uniq;\n\n    // run a global parallel work: lookup non-hashed rows in hashSet; find\n    // matching row; append matching column data\n    String[]   names  = Arrays.copyOfRange(small._names   ,ncols,small._names.length-ncols+1);\n    String[][] domains= Arrays.copyOfRange(small.domains(),ncols,small._names.length-ncols+1);\n    Frame res = new DoJoin(ncols,uniq,enum_maps,_allLeft).doAll(small.numCols()-ncols,large).outputFrame(names,domains);\n    Frame res2 = large.add(res);\n    System.out.println(res2);\n    env.push(new ValFrame(res2));\n  }","id":91239,"modified_method":"@Override void apply(Env env) {\n    Frame l = env.popAry();\n    Frame r = env.popAry();\n\n    // Look for the set of columns in common; resort left & right to make the\n    // leading prefix of column names match.  Bail out if we find any weird\n    // column types.\n    int ncols=0;                // Number of columns in common\n    for( int i=0; i<l._names.length; i++ ) {\n      int idx = r.find(l._names[i]);\n      if( idx != -1 ) {\n        l.swap(i  ,ncols);\n        r.swap(idx,ncols);\n        Vec lv = l.vecs()[ncols];\n        Vec rv = r.vecs()[ncols];\n        if( lv.get_type() != rv.get_type() )\n          throw new IllegalArgumentException(\"Merging columns must be the same type, column \"+l._names[ncols]+\n                                             \" found types \"+lv.get_type_str()+\" and \"+rv.get_type_str());\n        if( lv.isString() )  \n          throw new IllegalArgumentException(\"Cannot merge Strings; flip toEnum first\");\n        if( lv.isNumeric() && !lv.isInt())  \n          throw new IllegalArgumentException(\"Equality tests on doubles rarely work, please round to integers only before merging\");\n        ncols++;\n      }\n    }\n    if( ncols == 0 ) \n      throw new IllegalArgumentException(\"Frames must have at least one column in common to merge them\");\n\n    // Pick the frame to replicate & hash; smallest bytesize of the non-key\n    // columns.  Hashed dataframe is completely replicated per-node\n    long lsize = 0, rsize = 0;\n    for( int i=ncols; i<l.numCols(); i++ ) lsize += l.vecs()[i].byteSize();\n    for( int i=ncols; i<r.numCols(); i++ ) rsize += r.vecs()[i].byteSize();\n    Frame small = lsize < rsize ? l : r;\n    Frame large = lsize < rsize ? r : l;\n\n    // Build enum mappings, to rapidly convert enums from the larger\n    // distributed set to the smaller hashed & replicated set.\n    int[][] enum_maps = new int[ncols][];\n    int[][]   id_maps = new int[ncols][];\n    for( int i=0; i<ncols; i++ ) {\n      Vec lv = large.vecs()[i];\n      if( lv.isEnum() ) {\n        EnumWrappedVec ewv = new EnumWrappedVec(lv.domain(),small.vecs()[i].domain());\n        int[] ids = enum_maps[i] = ewv.enum_map();\n        DKV.remove(ewv._key);\n        // Build an Identity map for the smaller hash\n        id_maps[i] = new int[ids.length];\n        for( int j=0; j<ids.length; j++ )  id_maps[i][j] = j;\n      }\n    }\n\n    // MergeSet is from local (non-replicated) chunks/row to other-chunks/row.\n    // Row object in table has e.g. chunks and a row number; passed-in Row\n    // object can also have chunks & a row number.  Hash based on contents of\n    // chunks.  Returns matched Row object (which has replicated chunk ptrs & row).\n    Key uniq = new MergeSet(ncols,id_maps,small).doAllNodes()._uniq;\n\n    // run a global parallel work: lookup non-hashed rows in hashSet; find\n    // matching row; append matching column data\n    String[]   names  = Arrays.copyOfRange(small._names   ,ncols,small._names.length-ncols+1);\n    String[][] domains= Arrays.copyOfRange(small.domains(),ncols,small._names.length-ncols+1);\n    Frame res = new DoJoin(ncols,uniq,enum_maps,_allLeft).doAll(small.numCols()-ncols,large).outputFrame(names,domains);\n    Frame res2 = large.add(res);\n    System.out.println(res2);\n    env.push(new ValFrame(res2));\n  }","commit_id":"7645785e218c61e8c23ced6797b2225abd44675d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"Row fill( int row, int ncols, int[][] enum_maps ) {\n      _row = row; \n      _enum_maps = enum_maps;\n      long hash = 0;\n      for( int i=0; i<ncols; i++ )\n        hash += enum_maps[i]==null ? Double.doubleToLongBits(_chks[i].atd(row)) : enum_maps[i][(int)(_chks[i].at8(row))];\n      _hash = (int)(hash^(hash>>32));\n      return this;\n    }","id":91240,"modified_method":"Row fill( int row, int ncols, int[][] enum_maps ) {\n      _row = row; \n      _enum_maps = enum_maps;\n      // Precompute hash: columns are integer only (checked before we started\n      // here).  NAs count as a zero for hashing.\n      long hash = 0;\n      for( int i=0; i<ncols; i++ ) {\n        if( _chks[i].isNA(_row) ) continue;\n        long l = _chks[i].at8(_row);\n        hash += enum_maps[i]==null ? l : enum_maps[i][(int)l];\n      }\n      _hash = (int)(hash^(hash>>32));\n      return this;\n    }","commit_id":"7645785e218c61e8c23ced6797b2225abd44675d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public String toString( long off, int len ) {\n    if( off > numRows() ) off = numRows();\n    if( off+len > numRows() ) len = (int)(numRows()-off);\n\n    String[] rowHeaders = new String[len+4];\n    rowHeaders[0] = \"min\";\n    rowHeaders[1] = \"mean\";\n    rowHeaders[2] = \"stddev\";\n    rowHeaders[3] = \"max\";\n    for( int i=0; i<len; i++ ) rowHeaders[i+4]=\"\"+(off+i);\n\n    final int ncols = numCols();\n    final Vec[] vecs = vecs();\n    String[] coltypes = new String[ncols];\n    String[][] strCells = new String[len+4][ncols];\n    double[][] dblCells = new double[len+4][ncols];\n    for( int i=0; i<ncols; i++ ) {\n      Vec vec = vecs[i];\n      dblCells[0][i] = vec.min();\n      dblCells[1][i] = vec.mean();\n      dblCells[2][i] = vec.sigma();\n      dblCells[3][i] = vec.max();\n      switch( vec.get_type() ) {\n      case Vec.T_BAD:\n        coltypes[i] = \"string\";\n        for( int j=0; j<len; j++ ) { strCells[j+4][i] = null; dblCells[j+4][i] = TwoDimTable.emptyDouble; }\n        break;\n      case Vec.T_STR :\n        coltypes[i] = \"string\"; \n        ValueString vstr = new ValueString();\n        for( int j=0; j<len; j++ ) { strCells[j+4][i] = vec.atStr(vstr,off+j).toString(); dblCells[j+4][i] = TwoDimTable.emptyDouble; }\n        break;\n      case Vec.T_ENUM:\n        coltypes[i] = \"string\"; \n        for( int j=0; j<len; j++ ) { strCells[j+4][i] = vec.isNA(off+j) ? \"\" : vec.factor(vec.at8(off+j));  dblCells[j+4][i] = TwoDimTable.emptyDouble; }\n        break;\n      case Vec.T_TIME:\n      case Vec.T_TIME+1:\n      case Vec.T_TIME+2:\n        coltypes[i] = \"string\"; \n        DateTimeFormatter fmt = DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss\");\n        for( int j=0; j<len; j++ ) { strCells[j+4][i] = fmt.print(vec.at8(off+j)); dblCells[j+4][i] = TwoDimTable.emptyDouble; }\n        break;\n      case Vec.T_NUM:\n        coltypes[i] = vec.isInt() ? \"long\" : \"double\"; \n        for( int j=0; j<len; j++ ) { dblCells[j+4][i] = vec.isNA(off+j) ? TwoDimTable.emptyDouble : vec.at(off + j); strCells[j+4][i] = null; }\n        break;\n      case Vec.T_UUID:\n        throw H2O.unimpl();\n      default:\n        System.err.println(\"bad vector type during debug print: \"+vec.get_type());\n        throw H2O.fail();\n      }\n    }\n\n    return new TwoDimTable(\"Frame \"+_key+\" with \"+numRows()+\" rows and \"+numCols()+\" cols\",rowHeaders,_names,coltypes,null, \"\", strCells, dblCells).toString();\n  }","id":91241,"modified_method":"public String toString( long off, int len ) {\n    if( off > numRows() ) off = numRows();\n    if( off+len > numRows() ) len = (int)(numRows()-off);\n\n    String[] rowHeaders = new String[len+5];\n    rowHeaders[0] = \"min\";\n    rowHeaders[1] = \"mean\";\n    rowHeaders[2] = \"stddev\";\n    rowHeaders[3] = \"max\";\n    rowHeaders[4] = \"missing\";\n    for( int i=0; i<len; i++ ) rowHeaders[i+5]=\"\"+(off+i);\n\n    final int ncols = numCols();\n    final Vec[] vecs = vecs();\n    String[] coltypes = new String[ncols];\n    String[][] strCells = new String[len+5][ncols];\n    double[][] dblCells = new double[len+5][ncols];\n    for( int i=0; i<ncols; i++ ) {\n      Vec vec = vecs[i];\n      dblCells[0][i] = vec.min();\n      dblCells[1][i] = vec.mean();\n      dblCells[2][i] = vec.sigma();\n      dblCells[3][i] = vec.max();\n      dblCells[4][i] = vec.naCnt();\n      switch( vec.get_type() ) {\n      case Vec.T_BAD:\n        coltypes[i] = \"string\";\n        for( int j=0; j<len; j++ ) { strCells[j+5][i] = null; dblCells[j+5][i] = TwoDimTable.emptyDouble; }\n        break;\n      case Vec.T_STR :\n        coltypes[i] = \"string\"; \n        ValueString vstr = new ValueString();\n        for( int j=0; j<len; j++ ) { strCells[j+5][i] = vec.atStr(vstr,off+j).toString(); dblCells[j+5][i] = TwoDimTable.emptyDouble; }\n        break;\n      case Vec.T_ENUM:\n        coltypes[i] = \"string\"; \n        for( int j=0; j<len; j++ ) { strCells[j+5][i] = vec.isNA(off+j) ? \"\" : vec.factor(vec.at8(off+j));  dblCells[j+5][i] = TwoDimTable.emptyDouble; }\n        break;\n      case Vec.T_TIME:\n      case Vec.T_TIME+1:\n      case Vec.T_TIME+2:\n        coltypes[i] = \"string\"; \n        DateTimeFormatter fmt = DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss\");\n        for( int j=0; j<len; j++ ) { strCells[j+5][i] = fmt.print(vec.at8(off+j)); dblCells[j+5][i] = TwoDimTable.emptyDouble; }\n        break;\n      case Vec.T_NUM:\n        coltypes[i] = vec.isInt() ? \"long\" : \"double\"; \n        for( int j=0; j<len; j++ ) { dblCells[j+5][i] = vec.isNA(off+j) ? TwoDimTable.emptyDouble : vec.at(off + j); strCells[j+5][i] = null; }\n        break;\n      case Vec.T_UUID:\n        throw H2O.unimpl();\n      default:\n        System.err.println(\"bad vector type during debug print: \"+vec.get_type());\n        throw H2O.fail();\n      }\n    }\n\n    return new TwoDimTable(\"Frame \"+_key+\" with \"+numRows()+\" rows and \"+numCols()+\" cols\",rowHeaders,_names,coltypes,null, \"\", strCells, dblCells).toString();\n  }","commit_id":"7645785e218c61e8c23ced6797b2225abd44675d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public void map( Chunk chks[], NewChunk nchks[] ) {\n      Chunk pred = chks[chks.length-1];\n      for(int i = 0; i < pred._len; ++i) {\n        if(pred.atd(i) != 0) {\n          for( int j = 0; j < chks.length - 1; j++ ) {\n            Chunk chk = chks[j];\n            if( chk._vec.isUUID() ) nchks[j].addUUID(chk, i);\n            else if(chk._vec.isString()) nchks[j].addStr((chk.atStr(new ValueString(), i)));\n            else nchks[j].addNum(chk.atd(i));\n          }\n        }\n      }\n    }","id":91242,"modified_method":"@Override public void map( Chunk chks[], NewChunk nchks[] ) {\n      Chunk pred = chks[chks.length-1];\n      for(int i = 0; i < pred._len; ++i) {\n        if( pred.atd(i) != 0 && !pred.isNA(i) ) {\n          for( int j = 0; j < chks.length - 1; j++ ) {\n            Chunk chk = chks[j];\n            if( chk._vec.isUUID() ) nchks[j].addUUID(chk, i);\n            else if(chk._vec.isString()) nchks[j].addStr((chk.atStr(new ValueString(), i)));\n            else nchks[j].addNum(chk.atd(i));\n          }\n        }\n      }\n    }","commit_id":"7645785e218c61e8c23ced6797b2225abd44675d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void printNode(HostStat hostStat,\n                boolean hasEffectiveOwns, boolean isTokenPerNode) throws UnknownHostException\n        {\n            String status, state, load, strOwns, hostID, rack, fmt;\n            fmt = getFormat(hasEffectiveOwns, isTokenPerNode);\n            String endpoint = hostStat.ip;\n            if      (liveNodes.contains(endpoint))        status = \"U\";\n            else if (unreachableNodes.contains(endpoint)) status = \"D\";\n            else                                          status = \"?\";\n            if      (joiningNodes.contains(endpoint))     state = \"J\";\n            else if (leavingNodes.contains(endpoint))     state = \"L\";\n            else if (movingNodes.contains(endpoint))      state = \"M\";\n            else                                          state = \"N\";\n\n            load = loadMap.containsKey(endpoint) ? loadMap.get(endpoint) : \"?\";\n            strOwns = new DecimalFormat(\"##0.0%\").format(hostStat.owns);\n            hostID = hostIDMap.get(endpoint);\n            rack = epSnitchInfo.getRack(endpoint);\n\n            if (isTokenPerNode)\n            {\n                outs.printf(fmt, status, state, hostStat.ipOrDns(), load, strOwns, hostID, probe.getTokens(endpoint).get(0), rack);\n            }\n            else\n            {\n                int tokens = probe.getTokens(endpoint).size();\n                outs.printf(fmt, status, state, hostStat.ipOrDns(), load, tokens, strOwns, hostID, rack);\n            }\n        }","id":91243,"modified_method":"private void printNode(String endpoint, Float owns, List<String> tokens, boolean hasEffectiveOwns, boolean isTokenPerNode) throws UnknownHostException\n        {\n            String status, state, load, strOwns, hostID, rack, fmt;\n            fmt = getFormat(hasEffectiveOwns, isTokenPerNode);\n            if      (liveNodes.contains(endpoint))        status = \"U\";\n            else if (unreachableNodes.contains(endpoint)) status = \"D\";\n            else                                          status = \"?\";\n            if      (joiningNodes.contains(endpoint))     state = \"J\";\n            else if (leavingNodes.contains(endpoint))     state = \"L\";\n            else if (movingNodes.contains(endpoint))      state = \"M\";\n            else                                          state = \"N\";\n\n            load = loadMap.containsKey(endpoint) ? loadMap.get(endpoint) : \"?\";\n            strOwns = owns != null ? new DecimalFormat(\"##0.0%\").format(owns) : \"?\";\n            hostID = hostIDMap.get(endpoint);\n            rack = epSnitchInfo.getRack(endpoint);\n\n            if (isTokenPerNode)\n            {\n                outs.printf(fmt, status, state, endpoint, load, strOwns, hostID, tokens.get(0), rack);\n            }\n            else\n            {\n                outs.printf(fmt, status, state, endpoint, load, tokens.size(), strOwns, hostID, rack);\n            }\n        }","commit_id":"91d220b350f512ef283748dfcbcc304bde2f9db2","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Write a textual representation of the Cassandra ring.\n     *\n     * @param outs\n     *            the stream to write to\n     */\n    public void printRing(PrintStream outs, String keyspace)\n    {\n        Map<String, String> tokensToEndpoints = probe.getTokenToEndpointMap();\n        LinkedHashMultimap<String, String> endpointsToTokens = LinkedHashMultimap.create();\n        for (Map.Entry<String, String> entry : tokensToEndpoints.entrySet())\n            endpointsToTokens.put(entry.getValue(), entry.getKey());\n\n        int maxAddressLength = Collections.max(endpointsToTokens.keys(), new Comparator<String>() {\n            @Override\n            public int compare(String first, String second)\n            {\n                return ((Integer)first.length()).compareTo((Integer)second.length());\n            }\n        }).length();\n\n        String formatPlaceholder = \"%%-%ds  %%-12s%%-7s%%-8s%%-16s%%-20s%%-44s%%n\";\n        String format = String.format(formatPlaceholder, maxAddressLength);\n\n        // Calculate per-token ownership of the ring\n        Map<InetAddress, Float> ownerships;\n        boolean keyspaceSelected;\n        try\n        {\n            ownerships = probe.effectiveOwnership(keyspace);\n            keyspaceSelected = true;\n        }\n        catch (IllegalStateException ex)\n        {\n            ownerships = probe.getOwnership();\n            outs.printf(\"Note: Ownership information does not include topology; for complete information, specify a keyspace%n\");\n            keyspaceSelected = false;\n        }\n        try\n        {\n            outs.println();\n            Map<String, Map<InetAddress, Float>> perDcOwnerships = Maps.newLinkedHashMap();\n            // get the different datasets and map to tokens\n            for (Map.Entry<InetAddress, Float> ownership : ownerships.entrySet())\n            {\n                String dc = probe.getEndpointSnitchInfoProxy().getDatacenter(ownership.getKey().getHostAddress());\n                if (!perDcOwnerships.containsKey(dc))\n                    perDcOwnerships.put(dc, new LinkedHashMap<InetAddress, Float>());\n                perDcOwnerships.get(dc).put(ownership.getKey(), ownership.getValue());\n            }\n            for (Map.Entry<String, Map<InetAddress, Float>> entry : perDcOwnerships.entrySet())\n                printDc(outs, format, entry.getKey(), endpointsToTokens, keyspaceSelected, entry.getValue());\n        }\n        catch (UnknownHostException e)\n        {\n            throw new RuntimeException(e);\n        }\n\n        if(DatabaseDescriptor.getNumTokens() > 1)\n        {\n            outs.println(\"  Warning: \\\"nodetool ring\\\" is used to output all the tokens of a node.\");\n            outs.println(\"  To view status related info of a node use \\\"nodetool status\\\" instead.\\n\");\n        }\n    }","id":91244,"modified_method":"/**\n     * Write a textual representation of the Cassandra ring.\n     *\n     * @param outs\n     *            the stream to write to\n     */\n    public void printRing(PrintStream outs, String keyspace)\n    {\n        Map<String, String> tokensToEndpoints = probe.getTokenToEndpointMap();\n        LinkedHashMultimap<String, String> endpointsToTokens = LinkedHashMultimap.create();\n        for (Map.Entry<String, String> entry : tokensToEndpoints.entrySet())\n            endpointsToTokens.put(entry.getValue(), entry.getKey());\n\n        int maxAddressLength = Collections.max(endpointsToTokens.keys(), new Comparator<String>() {\n            @Override\n            public int compare(String first, String second)\n            {\n                return ((Integer)first.length()).compareTo((Integer)second.length());\n            }\n        }).length();\n\n        String formatPlaceholder = \"%%-%ds  %%-12s%%-7s%%-8s%%-16s%%-20s%%-44s%%n\";\n        String format = String.format(formatPlaceholder, maxAddressLength);\n\n        // Calculate per-token ownership of the ring\n        Map<InetAddress, Float> ownerships;\n        boolean keyspaceSelected;\n        try\n        {\n            ownerships = probe.effectiveOwnership(keyspace);\n            keyspaceSelected = true;\n        }\n        catch (IllegalStateException ex)\n        {\n            ownerships = probe.getOwnership();\n            outs.printf(\"Note: Ownership information does not include topology; for complete information, specify a keyspace%n\");\n            keyspaceSelected = false;\n        }\n        try\n        {\n            outs.println();\n            for (Entry<String, SetHostStat> entry : getOwnershipByDc(false, tokensToEndpoints, ownerships).entrySet())\n                printDc(outs, format, entry.getKey(), endpointsToTokens, keyspaceSelected, entry.getValue());\n        }\n        catch (UnknownHostException e)\n        {\n            throw new RuntimeException(e);\n        }\n\n        if(DatabaseDescriptor.getNumTokens() > 1)\n        {\n            outs.println(\"  Warning: \\\"nodetool ring\\\" is used to output all the tokens of a node.\");\n            outs.println(\"  To view status related info of a node use \\\"nodetool status\\\" instead.\\n\");\n        }\n    }","commit_id":"91d220b350f512ef283748dfcbcc304bde2f9db2","url":"https://github.com/apache/cassandra"},{"original_method":"void print() throws UnknownHostException\n        {\n            SetHostStat ownerships;\n            boolean hasEffectiveOwns = false, isTokenPerNode = true;\n\n            try\n            {\n                ownerships = new SetHostStat(probe.effectiveOwnership(kSpace));\n                hasEffectiveOwns = true;\n            }\n            catch (IllegalStateException e)\n            {\n                ownerships = new SetHostStat(probe.getOwnership());\n            }\n\n            // More tokens then nodes (aka vnodes)?\n            if (new HashSet<String>(tokensToEndpoints.values()).size() < tokensToEndpoints.keySet().size())\n                isTokenPerNode = false;\n\n            Map<String, SetHostStat> dcs = getOwnershipByDc(ownerships);\n\n            findMaxAddressLength(dcs);\n\n            // Datacenters\n            for (Map.Entry<String, SetHostStat> dc : dcs.entrySet())\n            {\n                String dcHeader = String.format(\"Datacenter: %s%n\", dc.getKey());\n                outs.printf(dcHeader);\n                for (int i=0; i < (dcHeader.length() - 1); i++) outs.print('=');\n                outs.println();\n\n                printStatusLegend();\n                printNodesHeader(hasEffectiveOwns, isTokenPerNode);\n\n                // Nodes\n                for (HostStat entry : dc.getValue())\n                    printNode(entry, hasEffectiveOwns, isTokenPerNode);\n            }\n        }","id":91245,"modified_method":"void print() throws UnknownHostException\n        {\n            Map<InetAddress, Float> ownerships;\n            boolean hasEffectiveOwns = false, isTokenPerNode = true;\n\n            try\n            {\n                ownerships = probe.effectiveOwnership(kSpace);\n                hasEffectiveOwns = true;\n            }\n            catch (IllegalStateException e)\n            {\n                ownerships = probe.getOwnership();\n            }\n\n            // More tokens then nodes (aka vnodes)?\n            if (tokensToEndpoints.values().size() < tokensToEndpoints.keySet().size())\n                isTokenPerNode = false;\n\n            Map<String, SetHostStat> dcs = getOwnershipByDc(resolveIp, tokensToEndpoints, ownerships);\n\n            findMaxAddressLength(dcs);\n\n            // Datacenters\n            for (Map.Entry<String, SetHostStat> dc : dcs.entrySet())\n            {\n                String dcHeader = String.format(\"Datacenter: %s%n\", dc.getKey());\n                outs.printf(dcHeader);\n                for (int i=0; i < (dcHeader.length() - 1); i++) outs.print('=');\n                outs.println();\n\n                printStatusLegend();\n                printNodesHeader(hasEffectiveOwns, isTokenPerNode);\n\n                ArrayListMultimap<String, String> hostToTokens = ArrayListMultimap.create();\n                for (HostStat stat : dc.getValue())\n                    hostToTokens.put(stat.ipOrDns(), stat.token);\n\n                // Nodes\n                for (String endpoint : hostToTokens.keySet())\n                {\n                    Float owns = ownerships.get(InetAddress.getByName(endpoint));\n                    List<String> tokens = hostToTokens.get(endpoint);\n                    printNode(endpoint, owns, tokens, hasEffectiveOwns, isTokenPerNode);\n                }\n            }\n        }","commit_id":"91d220b350f512ef283748dfcbcc304bde2f9db2","url":"https://github.com/apache/cassandra"},{"original_method":"private void printDc(PrintStream outs, String format, String dc, LinkedHashMultimap<String, String> endpointsToTokens,\n            boolean keyspaceSelected, Map<InetAddress, Float> filteredOwnerships)\n    {\n        Collection<String> liveNodes = probe.getLiveNodes();\n        Collection<String> deadNodes = probe.getUnreachableNodes();\n        Collection<String> joiningNodes = probe.getJoiningNodes();\n        Collection<String> leavingNodes = probe.getLeavingNodes();\n        Collection<String> movingNodes = probe.getMovingNodes();\n        Map<String, String> loadMap = probe.getLoadMap();\n\n        outs.println(\"Datacenter: \" + dc);\n        outs.println(\"==========\");\n\n        // get the total amount of replicas for this dc and the last token in this dc's ring\n        List<String> tokens = new ArrayList<String>();\n        float totalReplicas = 0f;\n        String lastToken = \"\";\n\n        for (Map.Entry<InetAddress, Float> entry : filteredOwnerships.entrySet())\n        {\n            tokens.addAll(endpointsToTokens.get(entry.getKey().getHostAddress()));\n            lastToken = tokens.get(tokens.size() - 1);\n            totalReplicas += entry.getValue();\n        }\n\n\n        if (keyspaceSelected)\n            outs.print(\"Replicas: \" + (int) totalReplicas + \"\\n\\n\");\n\n        outs.printf(format, \"Address\", \"Rack\", \"Status\", \"State\", \"Load\", \"Owns\", \"Token\");\n\n        if (filteredOwnerships.size() > 1)\n            outs.printf(format, \"\", \"\", \"\", \"\", \"\", \"\", lastToken);\n        else\n            outs.println();\n\n        for (Map.Entry<String, String> entry : endpointsToTokens.entries())\n        {\n            String endpoint = entry.getKey();\n            String rack;\n            try\n            {\n                rack = probe.getEndpointSnitchInfoProxy().getRack(endpoint);\n            }\n            catch (UnknownHostException e)\n            {\n                rack = \"Unknown\";\n            }\n\n            String status = liveNodes.contains(endpoint)\n                    ? \"Up\"\n                    : deadNodes.contains(endpoint)\n                            ? \"Down\"\n                            : \"?\";\n\n            String state = \"Normal\";\n\n            if (joiningNodes.contains(endpoint))\n                state = \"Joining\";\n            else if (leavingNodes.contains(endpoint))\n                state = \"Leaving\";\n            else if (movingNodes.contains(endpoint))\n                state = \"Moving\";\n\n            String load = loadMap.containsKey(endpoint)\n                    ? loadMap.get(endpoint)\n                    : \"?\";\n            String owns;\n            try\n            {\n                InetAddress ep = InetAddress.getByName(endpoint);\n                Float percent = filteredOwnerships.get(ep);\n                owns = (percent != null) ? new DecimalFormat(\"##0.00%\").format(percent) : \"?\";\n            }\n            catch (UnknownHostException e)\n            {\n                throw new RuntimeException(e);\n            }\n            outs.printf(format, endpoint, rack, status, state, load, owns, entry.getValue());\n        }\n        outs.println();\n    }","id":91246,"modified_method":"private void printDc(PrintStream outs, String format, String dc, LinkedHashMultimap<String, String> endpointsToTokens,\n                         boolean keyspaceSelected, SetHostStat hoststats)\n    {\n        Collection<String> liveNodes = probe.getLiveNodes();\n        Collection<String> deadNodes = probe.getUnreachableNodes();\n        Collection<String> joiningNodes = probe.getJoiningNodes();\n        Collection<String> leavingNodes = probe.getLeavingNodes();\n        Collection<String> movingNodes = probe.getMovingNodes();\n        Map<String, String> loadMap = probe.getLoadMap();\n\n        outs.println(\"Datacenter: \" + dc);\n        outs.println(\"==========\");\n\n        // get the total amount of replicas for this dc and the last token in this dc's ring\n        List<String> tokens = new ArrayList<String>();\n        float totalReplicas = 0f;\n        String lastToken = \"\";\n\n        for (HostStat stat : hoststats)\n        {\n            tokens.addAll(endpointsToTokens.get(stat.ip));\n            lastToken = tokens.get(tokens.size() - 1);\n            if (stat.owns != null)\n                totalReplicas += stat.owns;\n        }\n\n        if (keyspaceSelected)\n            outs.print(\"Replicas: \" + (int) totalReplicas + \"\\n\\n\");\n\n        outs.printf(format, \"Address\", \"Rack\", \"Status\", \"State\", \"Load\", \"Owns\", \"Token\");\n\n        if (hoststats.size() > 1)\n            outs.printf(format, \"\", \"\", \"\", \"\", \"\", \"\", lastToken);\n        else\n            outs.println();\n\n        for (HostStat stat : hoststats)\n        {\n            String endpoint = stat.ip;\n            String rack;\n            try\n            {\n                rack = probe.getEndpointSnitchInfoProxy().getRack(endpoint);\n            }\n            catch (UnknownHostException e)\n            {\n                rack = \"Unknown\";\n            }\n\n            String status = liveNodes.contains(endpoint)\n                    ? \"Up\"\n                    : deadNodes.contains(endpoint)\n                            ? \"Down\"\n                            : \"?\";\n\n            String state = \"Normal\";\n\n            if (joiningNodes.contains(endpoint))\n                state = \"Joining\";\n            else if (leavingNodes.contains(endpoint))\n                state = \"Leaving\";\n            else if (movingNodes.contains(endpoint))\n                state = \"Moving\";\n\n            String load = loadMap.containsKey(endpoint)\n                    ? loadMap.get(endpoint)\n                    : \"?\";\n            String owns = stat.owns != null ? new DecimalFormat(\"##0.00%\").format(stat.owns) : \"?\";\n            outs.printf(format, endpoint, rack, status, state, load, owns, stat.token);\n        }\n        outs.println();\n    }","commit_id":"91d220b350f512ef283748dfcbcc304bde2f9db2","url":"https://github.com/apache/cassandra"},{"original_method":"public static void main(String[] args) throws IOException, InterruptedException, ConfigurationException, ParseException\n    {\n        CommandLineParser parser = new PosixParser();\n        ToolCommandLine cmd = null;\n\n        try\n        {\n            cmd = new ToolCommandLine(parser.parse(options, args));\n        }\n        catch (ParseException p)\n        {\n            badUse(p.getMessage());\n        }\n\n        String host = cmd.hasOption(HOST_OPT.left) ? cmd.getOptionValue(HOST_OPT.left) : DEFAULT_HOST;\n\n        int port = DEFAULT_PORT;\n\n        String portNum = cmd.getOptionValue(PORT_OPT.left);\n        if (portNum != null)\n        {\n            try\n            {\n                port = Integer.parseInt(portNum);\n            }\n            catch (NumberFormatException e)\n            {\n                throw new ParseException(\"Port must be a number\");\n            }\n        }\n\n        String username = cmd.getOptionValue(USERNAME_OPT.left);\n        String password = cmd.getOptionValue(PASSWORD_OPT.left);\n\n        NodeProbe probe = null;\n        try\n        {\n            probe = username == null ? new NodeProbe(host, port) : new NodeProbe(host, port, username, password);\n        }\n        catch (IOException ioe)\n        {\n            Throwable inner = findInnermostThrowable(ioe);\n            if (inner instanceof ConnectException)\n            {\n                System.err.printf(\"Failed to connect to '%s:%d': %s%n\", host, port, inner.getMessage());\n                System.exit(1);\n            }\n            else if (inner instanceof UnknownHostException)\n            {\n                System.err.printf(\"Cannot resolve '%s': unknown host%n\", host);\n                System.exit(1);\n            }\n            else\n            {\n                err(ioe, \"Error connecting to remote JMX agent!\");\n            }\n        }\n        try\n        {\n            //print history here after we've already determined we can reasonably call cassandra\n            printHistory(args, cmd);\n            NodeCommand command = null;\n\n            try\n            {\n                command = cmd.getCommand();\n            }\n            catch (IllegalArgumentException e)\n            {\n                badUse(e.getMessage());\n            }\n\n            NodeCmd nodeCmd = new NodeCmd(probe);\n\n            // Execute the requested command.\n            String[] arguments = cmd.getCommandArguments();\n            String tag;\n            String columnFamilyName = null;\n\n            switch (command)\n            {\n                case HELP : printUsage(); break;\n                case RING :\n                    if (arguments.length > 0) { nodeCmd.printRing(System.out, arguments[0]); }\n                    else                      { nodeCmd.printRing(System.out, null); };\n                    break;\n\n                case INFO            : nodeCmd.printInfo(System.out, cmd); break;\n                case CFSTATS         :\n                    boolean ignoreMode = cmd.hasOption(CFSTATS_IGNORE_OPT.left);\n                    if (arguments.length > 0) { nodeCmd.printColumnFamilyStats(System.out, ignoreMode, arguments); }\n                    else                      { nodeCmd.printColumnFamilyStats(System.out, false, null); }\n                    break;\n                case TPSTATS         : nodeCmd.printThreadPoolStats(System.out); break;\n                case VERSION         : nodeCmd.printReleaseVersion(System.out); break;\n                case COMPACTIONSTATS : nodeCmd.printCompactionStats(System.out); break;\n                case DESCRIBECLUSTER : nodeCmd.printClusterDescription(System.out, host); break;\n                case DISABLEBINARY   : probe.stopNativeTransport(); break;\n                case ENABLEBINARY    : probe.startNativeTransport(); break;\n                case STATUSBINARY    : nodeCmd.printIsNativeTransportRunning(System.out); break;\n                case DISABLEGOSSIP   : probe.stopGossiping(); break;\n                case ENABLEGOSSIP    : probe.startGossiping(); break;\n                case DISABLEHANDOFF  : probe.disableHintedHandoff(); break;\n                case ENABLEHANDOFF   : probe.enableHintedHandoff(); break;\n                case PAUSEHANDOFF    : probe.pauseHintsDelivery(); break;\n                case RESUMEHANDOFF   : probe.resumeHintsDelivery(); break;\n                case DISABLETHRIFT   : probe.stopThriftServer(); break;\n                case ENABLETHRIFT    : probe.startThriftServer(); break;\n                case STATUSTHRIFT    : nodeCmd.printIsThriftServerRunning(System.out); break;\n                case RESETLOCALSCHEMA: probe.resetLocalSchema(); break;\n                case ENABLEBACKUP    : probe.setIncrementalBackupsEnabled(true); break;\n                case DISABLEBACKUP   : probe.setIncrementalBackupsEnabled(false); break;\n                    \n\n                case STATUS :\n                    if (arguments.length > 0) nodeCmd.printClusterStatus(System.out, arguments[0]);\n                    else                      nodeCmd.printClusterStatus(System.out, null);\n                    break;\n\n                case DECOMMISSION :\n                    if (arguments.length > 0)\n                    {\n                        System.err.println(\"Decommission will decommission the node you are connected to and does not take arguments!\");\n                        System.exit(1);\n                    }\n                    probe.decommission();\n                    break;\n\n                case DRAIN :\n                    try { probe.drain(); }\n                    catch (ExecutionException ee) { err(ee, \"Error occured during flushing\"); }\n                    break;\n\n                case NETSTATS :\n                    if (arguments.length > 0) { nodeCmd.printNetworkStats(InetAddress.getByName(arguments[0]), System.out); }\n                    else                      { nodeCmd.printNetworkStats(null, System.out); }\n                    break;\n\n                case SNAPSHOT :\n                    columnFamilyName = cmd.getOptionValue(SNAPSHOT_COLUMNFAMILY_OPT.left);\n                    /* FALL THRU */\n                case CLEARSNAPSHOT :\n                    tag = cmd.getOptionValue(TAG_OPT.left);\n                    handleSnapshots(command, tag, arguments, columnFamilyName, probe);\n                    break;\n\n                case MOVE :\n                    if (arguments.length != 1) { badUse(\"Missing token argument for move.\"); }\n                    try\n                    {\n                        probe.move(arguments[0]);\n                    }\n                    catch (UnsupportedOperationException uoerror)\n                    {\n                        System.err.println(uoerror.getMessage());\n                        System.exit(1);\n                    }\n                    break;\n\n                case JOIN:\n                    if (probe.isJoined())\n                    {\n                        System.err.println(\"This node has already joined the ring.\");\n                        System.exit(1);\n                    }\n\n                    probe.joinRing();\n                    break;\n\n                case SETCOMPACTIONTHROUGHPUT :\n                    if (arguments.length != 1) { badUse(\"Missing value argument.\"); }\n                    probe.setCompactionThroughput(Integer.parseInt(arguments[0]));\n                    break;\n\n                case SETSTREAMTHROUGHPUT :\n                    if (arguments.length != 1) { badUse(\"Missing value argument.\"); }\n                    probe.setStreamThroughput(Integer.parseInt(arguments[0]));\n                    break;\n\n                case SETTRACEPROBABILITY :\n                    if (arguments.length != 1) { badUse(\"Missing value argument.\"); }\n                    probe.setTraceProbability(Double.parseDouble(arguments[0]));\n                    break;\n\n                case REBUILD :\n                    if (arguments.length > 1) { badUse(\"Too many arguments.\"); }\n                    probe.rebuild(arguments.length == 1 ? arguments[0] : null);\n                    break;\n\n                case REMOVETOKEN :\n                    System.err.println(\"Warn: removetoken is deprecated, please use removenode instead\");\n                case REMOVENODE  :\n                    if (arguments.length != 1) { badUse(\"Missing an argument for removenode (either status, force, or an ID)\"); }\n                    else if (arguments[0].equals(\"status\")) { nodeCmd.printRemovalStatus(System.out); }\n                    else if (arguments[0].equals(\"force\"))  { nodeCmd.printRemovalStatus(System.out); probe.forceRemoveCompletion(); }\n                    else                                    { probe.removeNode(arguments[0]); }\n                    break;\n\n                case INVALIDATEKEYCACHE :\n                    probe.invalidateKeyCache();\n                    break;\n\n                case INVALIDATEROWCACHE :\n                    probe.invalidateRowCache();\n                    break;\n\n                case CLEANUP :\n                case COMPACT :\n                case REPAIR  :\n                case FLUSH   :\n                case SCRUB   :\n                case UPGRADESSTABLES   :\n                    optionalKSandCFs(command, cmd, arguments, probe);\n                    break;\n\n                case GETCOMPACTIONTHRESHOLD :\n                    if (arguments.length != 2) { badUse(\"getcompactionthreshold requires ks and cf args.\"); }\n                    nodeCmd.printCompactionThreshold(System.out, arguments[0], arguments[1]);\n                    break;\n\n                case GETCOMPACTIONTHROUGHPUT : nodeCmd.printCompactionThroughput(System.out); break;\n                case GETSTREAMTHROUGHPUT : nodeCmd.printStreamThroughput(System.out); break;\n\n                case CFHISTOGRAMS :\n                    if (arguments.length != 2) { badUse(\"cfhistograms requires ks and cf args\"); }\n                    nodeCmd.printCfHistograms(arguments[0], arguments[1], System.out);\n                    break;\n\n                case SETCACHECAPACITY :\n                    if (arguments.length != 2) { badUse(\"setcachecapacity requires key-cache-capacity, and row-cache-capacity args.\"); }\n                    probe.setCacheCapacities(Integer.parseInt(arguments[0]), Integer.parseInt(arguments[1]));\n                    break;\n\n                case SETCACHEKEYSTOSAVE :\n                    if (arguments.length != 2) { badUse(\"setcachekeystosave requires key-cache-keys-to-save, and row-cache-keys-to-save args.\"); }\n                    probe.setCacheKeysToSave(Integer.parseInt(arguments[0]), Integer.parseInt(arguments[1]));\n                    break;\n\n                case SETCOMPACTIONTHRESHOLD :\n                    if (arguments.length != 4) { badUse(\"setcompactionthreshold requires ks, cf, min, and max threshold args.\"); }\n                    int minthreshold = Integer.parseInt(arguments[2]);\n                    int maxthreshold = Integer.parseInt(arguments[3]);\n                    if ((minthreshold < 0) || (maxthreshold < 0)) { badUse(\"Thresholds must be positive integers\"); }\n                    if (minthreshold > maxthreshold)              { badUse(\"Min threshold cannot be greater than max.\"); }\n                    if (minthreshold < 2 && maxthreshold != 0)    { badUse(\"Min threshold must be at least 2\"); }\n                    probe.setCompactionThreshold(arguments[0], arguments[1], minthreshold, maxthreshold);\n                    break;\n\n                case GETENDPOINTS :\n                    if (arguments.length != 3) { badUse(\"getendpoints requires ks, cf and key args\"); }\n                    nodeCmd.printEndPoints(arguments[0], arguments[1], arguments[2], System.out);\n                    break;\n\n                case PROXYHISTOGRAMS :\n                    if (arguments.length != 0) { badUse(\"proxyhistograms does not take arguments\"); }\n                    nodeCmd.printProxyHistograms(System.out);\n                    break;\n\n                case GETSSTABLES:\n                    if (arguments.length != 3) { badUse(\"getsstables requires ks, cf and key args\"); }\n                    nodeCmd.printSSTables(arguments[0], arguments[1], arguments[2], System.out);\n                    break;\n\n                case REFRESH:\n                    if (arguments.length != 2) { badUse(\"load_new_sstables requires ks and cf args\"); }\n                    probe.loadNewSSTables(arguments[0], arguments[1]);\n                    break;\n\n                case REBUILD_INDEX:\n                    if (arguments.length < 2) { badUse(\"rebuild_index requires ks and cf args\"); }\n                    if (arguments.length >= 3)\n                        probe.rebuildIndex(arguments[0], arguments[1], arguments[2].split(\",\"));\n                    else\n                        probe.rebuildIndex(arguments[0], arguments[1]);\n\n                    break;\n\n                case GOSSIPINFO : nodeCmd.printGossipInfo(System.out); break;\n\n                case STOP:\n                    if (arguments.length != 1) { badUse(\"stop requires a type.\"); }\n                    probe.stop(arguments[0].toUpperCase());\n                    break;\n\n                case DESCRIBERING :\n                    if (arguments.length != 1) { badUse(\"Missing keyspace argument for describering.\"); }\n                    nodeCmd.printDescribeRing(arguments[0], System.out);\n                    break;\n\n                case RANGEKEYSAMPLE :\n                    nodeCmd.printRangeKeySample(System.out);\n                    break;\n\n                case PREDICTCONSISTENCY:\n                    if (arguments.length < 2) { badUse(\"Requires replication factor and time\"); }\n                    int numVersions = 1;\n                    if (arguments.length == 3) { numVersions = Integer.parseInt(arguments[2]); }\n                    float percentileLatency = .999f;\n                    if (arguments.length == 4) { percentileLatency = Float.parseFloat(arguments[3]); }\n\n                    nodeCmd.predictConsistency(Integer.parseInt(arguments[0]),\n                                               Integer.parseInt(arguments[1]),\n                                               numVersions,\n                                               percentileLatency,\n                                               System.out);\n                    break;\n\n                default :\n                    throw new RuntimeException(\"Unreachable code.\");\n            }\n        }\n        finally\n        {\n            if (probe != null)\n            {\n                try\n                {\n                    probe.close();\n                }\n                catch (IOException ex)\n                {\n                    // swallow the exception so the user will see the real one.\n                }\n            }\n        }\n        System.exit(probe.isFailed() ? 1 : 0);\n    }","id":91247,"modified_method":"public static void main(String[] args) throws IOException, InterruptedException, ConfigurationException, ParseException\n    {\n        CommandLineParser parser = new PosixParser();\n        ToolCommandLine cmd = null;\n\n        try\n        {\n            cmd = new ToolCommandLine(parser.parse(options, args));\n        }\n        catch (ParseException p)\n        {\n            badUse(p.getMessage());\n        }\n\n        String host = cmd.hasOption(HOST_OPT.left) ? cmd.getOptionValue(HOST_OPT.left) : DEFAULT_HOST;\n\n        int port = DEFAULT_PORT;\n\n        String portNum = cmd.getOptionValue(PORT_OPT.left);\n        if (portNum != null)\n        {\n            try\n            {\n                port = Integer.parseInt(portNum);\n            }\n            catch (NumberFormatException e)\n            {\n                throw new ParseException(\"Port must be a number\");\n            }\n        }\n\n        String username = cmd.getOptionValue(USERNAME_OPT.left);\n        String password = cmd.getOptionValue(PASSWORD_OPT.left);\n\n        NodeProbe probe = null;\n        try\n        {\n            probe = username == null ? new NodeProbe(host, port) : new NodeProbe(host, port, username, password);\n        }\n        catch (IOException ioe)\n        {\n            Throwable inner = findInnermostThrowable(ioe);\n            if (inner instanceof ConnectException)\n            {\n                System.err.printf(\"Failed to connect to '%s:%d': %s%n\", host, port, inner.getMessage());\n                System.exit(1);\n            }\n            else if (inner instanceof UnknownHostException)\n            {\n                System.err.printf(\"Cannot resolve '%s': unknown host%n\", host);\n                System.exit(1);\n            }\n            else\n            {\n                err(ioe, \"Error connecting to remote JMX agent!\");\n            }\n        }\n        try\n        {\n            //print history here after we've already determined we can reasonably call cassandra\n            printHistory(args, cmd);\n            NodeCommand command = null;\n\n            try\n            {\n                command = cmd.getCommand();\n            }\n            catch (IllegalArgumentException e)\n            {\n                badUse(e.getMessage());\n            }\n\n            NodeCmd nodeCmd = new NodeCmd(probe);\n\n            // Execute the requested command.\n            String[] arguments = cmd.getCommandArguments();\n            String tag;\n            String columnFamilyName = null;\n\n            switch (command)\n            {\n                case HELP : printUsage(); break;\n                case RING :\n                    if (arguments.length > 0) { nodeCmd.printRing(System.out, arguments[0]); }\n                    else                      { nodeCmd.printRing(System.out, null); };\n                    break;\n\n                case INFO            : nodeCmd.printInfo(System.out, cmd); break;\n                case CFSTATS         :\n                    boolean ignoreMode = cmd.hasOption(CFSTATS_IGNORE_OPT.left);\n                    if (arguments.length > 0) { nodeCmd.printColumnFamilyStats(System.out, ignoreMode, arguments); }\n                    else                      { nodeCmd.printColumnFamilyStats(System.out, false, null); }\n                    break;\n                case TPSTATS         : nodeCmd.printThreadPoolStats(System.out); break;\n                case VERSION         : nodeCmd.printReleaseVersion(System.out); break;\n                case COMPACTIONSTATS : nodeCmd.printCompactionStats(System.out); break;\n                case DESCRIBECLUSTER : nodeCmd.printClusterDescription(System.out, host); break;\n                case DISABLEBINARY   : probe.stopNativeTransport(); break;\n                case ENABLEBINARY    : probe.startNativeTransport(); break;\n                case STATUSBINARY    : nodeCmd.printIsNativeTransportRunning(System.out); break;\n                case DISABLEGOSSIP   : probe.stopGossiping(); break;\n                case ENABLEGOSSIP    : probe.startGossiping(); break;\n                case DISABLEHANDOFF  : probe.disableHintedHandoff(); break;\n                case ENABLEHANDOFF   : probe.enableHintedHandoff(); break;\n                case PAUSEHANDOFF    : probe.pauseHintsDelivery(); break;\n                case RESUMEHANDOFF   : probe.resumeHintsDelivery(); break;\n                case DISABLETHRIFT   : probe.stopThriftServer(); break;\n                case ENABLETHRIFT    : probe.startThriftServer(); break;\n                case STATUSTHRIFT    : nodeCmd.printIsThriftServerRunning(System.out); break;\n                case RESETLOCALSCHEMA: probe.resetLocalSchema(); break;\n                case ENABLEBACKUP    : probe.setIncrementalBackupsEnabled(true); break;\n                case DISABLEBACKUP   : probe.setIncrementalBackupsEnabled(false); break;\n                    \n\n                case STATUS :\n                    boolean resolveIp = cmd.hasOption(RESOLVE_IP.left);\n                    if (arguments.length > 0) nodeCmd.printClusterStatus(System.out, arguments[0], resolveIp);\n                    else                      nodeCmd.printClusterStatus(System.out, null, resolveIp);\n                    break;\n\n                case DECOMMISSION :\n                    if (arguments.length > 0)\n                    {\n                        System.err.println(\"Decommission will decommission the node you are connected to and does not take arguments!\");\n                        System.exit(1);\n                    }\n                    probe.decommission();\n                    break;\n\n                case DRAIN :\n                    try { probe.drain(); }\n                    catch (ExecutionException ee) { err(ee, \"Error occured during flushing\"); }\n                    break;\n\n                case NETSTATS :\n                    if (arguments.length > 0) { nodeCmd.printNetworkStats(InetAddress.getByName(arguments[0]), System.out); }\n                    else                      { nodeCmd.printNetworkStats(null, System.out); }\n                    break;\n\n                case SNAPSHOT :\n                    columnFamilyName = cmd.getOptionValue(SNAPSHOT_COLUMNFAMILY_OPT.left);\n                    /* FALL THRU */\n                case CLEARSNAPSHOT :\n                    tag = cmd.getOptionValue(TAG_OPT.left);\n                    handleSnapshots(command, tag, arguments, columnFamilyName, probe);\n                    break;\n\n                case MOVE :\n                    if (arguments.length != 1) { badUse(\"Missing token argument for move.\"); }\n                    try\n                    {\n                        probe.move(arguments[0]);\n                    }\n                    catch (UnsupportedOperationException uoerror)\n                    {\n                        System.err.println(uoerror.getMessage());\n                        System.exit(1);\n                    }\n                    break;\n\n                case JOIN:\n                    if (probe.isJoined())\n                    {\n                        System.err.println(\"This node has already joined the ring.\");\n                        System.exit(1);\n                    }\n\n                    probe.joinRing();\n                    break;\n\n                case SETCOMPACTIONTHROUGHPUT :\n                    if (arguments.length != 1) { badUse(\"Missing value argument.\"); }\n                    probe.setCompactionThroughput(Integer.parseInt(arguments[0]));\n                    break;\n\n                case SETSTREAMTHROUGHPUT :\n                    if (arguments.length != 1) { badUse(\"Missing value argument.\"); }\n                    probe.setStreamThroughput(Integer.parseInt(arguments[0]));\n                    break;\n\n                case SETTRACEPROBABILITY :\n                    if (arguments.length != 1) { badUse(\"Missing value argument.\"); }\n                    probe.setTraceProbability(Double.parseDouble(arguments[0]));\n                    break;\n\n                case REBUILD :\n                    if (arguments.length > 1) { badUse(\"Too many arguments.\"); }\n                    probe.rebuild(arguments.length == 1 ? arguments[0] : null);\n                    break;\n\n                case REMOVETOKEN :\n                    System.err.println(\"Warn: removetoken is deprecated, please use removenode instead\");\n                case REMOVENODE  :\n                    if (arguments.length != 1) { badUse(\"Missing an argument for removenode (either status, force, or an ID)\"); }\n                    else if (arguments[0].equals(\"status\")) { nodeCmd.printRemovalStatus(System.out); }\n                    else if (arguments[0].equals(\"force\"))  { nodeCmd.printRemovalStatus(System.out); probe.forceRemoveCompletion(); }\n                    else                                    { probe.removeNode(arguments[0]); }\n                    break;\n\n                case INVALIDATEKEYCACHE :\n                    probe.invalidateKeyCache();\n                    break;\n\n                case INVALIDATEROWCACHE :\n                    probe.invalidateRowCache();\n                    break;\n\n                case CLEANUP :\n                case COMPACT :\n                case REPAIR  :\n                case FLUSH   :\n                case SCRUB   :\n                case UPGRADESSTABLES   :\n                    optionalKSandCFs(command, cmd, arguments, probe);\n                    break;\n\n                case GETCOMPACTIONTHRESHOLD :\n                    if (arguments.length != 2) { badUse(\"getcompactionthreshold requires ks and cf args.\"); }\n                    nodeCmd.printCompactionThreshold(System.out, arguments[0], arguments[1]);\n                    break;\n\n                case GETCOMPACTIONTHROUGHPUT : nodeCmd.printCompactionThroughput(System.out); break;\n                case GETSTREAMTHROUGHPUT : nodeCmd.printStreamThroughput(System.out); break;\n\n                case CFHISTOGRAMS :\n                    if (arguments.length != 2) { badUse(\"cfhistograms requires ks and cf args\"); }\n                    nodeCmd.printCfHistograms(arguments[0], arguments[1], System.out);\n                    break;\n\n                case SETCACHECAPACITY :\n                    if (arguments.length != 2) { badUse(\"setcachecapacity requires key-cache-capacity, and row-cache-capacity args.\"); }\n                    probe.setCacheCapacities(Integer.parseInt(arguments[0]), Integer.parseInt(arguments[1]));\n                    break;\n\n                case SETCACHEKEYSTOSAVE :\n                    if (arguments.length != 2) { badUse(\"setcachekeystosave requires key-cache-keys-to-save, and row-cache-keys-to-save args.\"); }\n                    probe.setCacheKeysToSave(Integer.parseInt(arguments[0]), Integer.parseInt(arguments[1]));\n                    break;\n\n                case SETCOMPACTIONTHRESHOLD :\n                    if (arguments.length != 4) { badUse(\"setcompactionthreshold requires ks, cf, min, and max threshold args.\"); }\n                    int minthreshold = Integer.parseInt(arguments[2]);\n                    int maxthreshold = Integer.parseInt(arguments[3]);\n                    if ((minthreshold < 0) || (maxthreshold < 0)) { badUse(\"Thresholds must be positive integers\"); }\n                    if (minthreshold > maxthreshold)              { badUse(\"Min threshold cannot be greater than max.\"); }\n                    if (minthreshold < 2 && maxthreshold != 0)    { badUse(\"Min threshold must be at least 2\"); }\n                    probe.setCompactionThreshold(arguments[0], arguments[1], minthreshold, maxthreshold);\n                    break;\n\n                case GETENDPOINTS :\n                    if (arguments.length != 3) { badUse(\"getendpoints requires ks, cf and key args\"); }\n                    nodeCmd.printEndPoints(arguments[0], arguments[1], arguments[2], System.out);\n                    break;\n\n                case PROXYHISTOGRAMS :\n                    if (arguments.length != 0) { badUse(\"proxyhistograms does not take arguments\"); }\n                    nodeCmd.printProxyHistograms(System.out);\n                    break;\n\n                case GETSSTABLES:\n                    if (arguments.length != 3) { badUse(\"getsstables requires ks, cf and key args\"); }\n                    nodeCmd.printSSTables(arguments[0], arguments[1], arguments[2], System.out);\n                    break;\n\n                case REFRESH:\n                    if (arguments.length != 2) { badUse(\"load_new_sstables requires ks and cf args\"); }\n                    probe.loadNewSSTables(arguments[0], arguments[1]);\n                    break;\n\n                case REBUILD_INDEX:\n                    if (arguments.length < 2) { badUse(\"rebuild_index requires ks and cf args\"); }\n                    if (arguments.length >= 3)\n                        probe.rebuildIndex(arguments[0], arguments[1], arguments[2].split(\",\"));\n                    else\n                        probe.rebuildIndex(arguments[0], arguments[1]);\n\n                    break;\n\n                case GOSSIPINFO : nodeCmd.printGossipInfo(System.out); break;\n\n                case STOP:\n                    if (arguments.length != 1) { badUse(\"stop requires a type.\"); }\n                    probe.stop(arguments[0].toUpperCase());\n                    break;\n\n                case DESCRIBERING :\n                    if (arguments.length != 1) { badUse(\"Missing keyspace argument for describering.\"); }\n                    nodeCmd.printDescribeRing(arguments[0], System.out);\n                    break;\n\n                case RANGEKEYSAMPLE :\n                    nodeCmd.printRangeKeySample(System.out);\n                    break;\n\n                case PREDICTCONSISTENCY:\n                    if (arguments.length < 2) { badUse(\"Requires replication factor and time\"); }\n                    int numVersions = 1;\n                    if (arguments.length == 3) { numVersions = Integer.parseInt(arguments[2]); }\n                    float percentileLatency = .999f;\n                    if (arguments.length == 4) { percentileLatency = Float.parseFloat(arguments[3]); }\n\n                    nodeCmd.predictConsistency(Integer.parseInt(arguments[0]),\n                                               Integer.parseInt(arguments[1]),\n                                               numVersions,\n                                               percentileLatency,\n                                               System.out);\n                    break;\n\n                default :\n                    throw new RuntimeException(\"Unreachable code.\");\n            }\n        }\n        finally\n        {\n            if (probe != null)\n            {\n                try\n                {\n                    probe.close();\n                }\n                catch (IOException ex)\n                {\n                    // swallow the exception so the user will see the real one.\n                }\n            }\n        }\n        System.exit(probe.isFailed() ? 1 : 0);\n    }","commit_id":"2f63bbadfa2fad66e04bc17edc66ce8be7497157","url":"https://github.com/apache/cassandra"},{"original_method":"/** Writes a table of cluster-wide node information to a PrintStream\n     * @throws UnknownHostException */\n    public void printClusterStatus(PrintStream outs, String keyspace) throws UnknownHostException\n    {\n        new ClusterStatus(outs, keyspace).print();\n    }","id":91248,"modified_method":"/** Writes a table of cluster-wide node information to a PrintStream\n     * @throws UnknownHostException */\n    public void printClusterStatus(PrintStream outs, String keyspace, boolean resolveIp) throws UnknownHostException\n    {\n        new ClusterStatus(outs, keyspace, resolveIp).print();\n    }","commit_id":"2f63bbadfa2fad66e04bc17edc66ce8be7497157","url":"https://github.com/apache/cassandra"},{"original_method":"void print() throws UnknownHostException\n        {\n            Map<InetAddress, Float> ownerships;\n            boolean hasEffectiveOwns = false, isTokenPerNode = true;\n\n            try\n            {\n                ownerships = probe.effectiveOwnership(kSpace);\n                hasEffectiveOwns = true;\n            }\n            catch (IllegalStateException e)\n            {\n                ownerships = probe.getOwnership();\n            }\n\n            // More tokens then nodes (aka vnodes)?\n            if (new HashSet<String>(tokensToEndpoints.values()).size() < tokensToEndpoints.keySet().size())\n                isTokenPerNode = false;\n\n            maxAddressLength = 0;\n            for (Map.Entry<String, Map<InetAddress, Float>> dc : getOwnershipByDc(ownerships).entrySet())\n            {\n                int dcMaxAddressLength = Collections.max(dc.getValue().keySet(), new Comparator<InetAddress>() {\n                    @Override\n                    public int compare(InetAddress first, InetAddress second)\n                    {\n                        return ((Integer)first.getHostAddress().length()).compareTo((Integer)second.getHostAddress().length());\n                    }\n                }).getHostAddress().length();\n\n                if(dcMaxAddressLength > maxAddressLength)\n                    maxAddressLength = dcMaxAddressLength;\n            }\n\n            // Datacenters\n            for (Map.Entry<String, Map<InetAddress, Float>> dc : getOwnershipByDc(ownerships).entrySet())\n            {\n                String dcHeader = String.format(\"Datacenter: %s%n\", dc.getKey());\n                outs.printf(dcHeader);\n                for (int i=0; i < (dcHeader.length() - 1); i++) outs.print('=');\n                outs.println();\n\n                printStatusLegend();\n                printNodesHeader(hasEffectiveOwns, isTokenPerNode);\n\n                // Nodes\n                for (Map.Entry<InetAddress, Float> entry : dc.getValue().entrySet())\n                    printNode(entry.getKey().getHostAddress(),\n                              entry.getValue(),\n                              ownerships,\n                              hasEffectiveOwns,\n                              isTokenPerNode);\n            }\n        }","id":91249,"modified_method":"void print() throws UnknownHostException\n        {\n            SetHostStat ownerships;\n            boolean hasEffectiveOwns = false, isTokenPerNode = true;\n\n            try\n            {\n                ownerships = new SetHostStat(probe.effectiveOwnership(kSpace));\n                hasEffectiveOwns = true;\n            }\n            catch (IllegalStateException e)\n            {\n                ownerships = new SetHostStat(probe.getOwnership());\n            }\n\n            // More tokens then nodes (aka vnodes)?\n            if (new HashSet<String>(tokensToEndpoints.values()).size() < tokensToEndpoints.keySet().size())\n                isTokenPerNode = false;\n\n            Map<String, SetHostStat> dcs = getOwnershipByDc(ownerships);\n\n            findMaxAddressLength(dcs);\n\n            // Datacenters\n            for (Map.Entry<String, SetHostStat> dc : dcs.entrySet())\n            {\n                String dcHeader = String.format(\"Datacenter: %s%n\", dc.getKey());\n                outs.printf(dcHeader);\n                for (int i=0; i < (dcHeader.length() - 1); i++) outs.print('=');\n                outs.println();\n\n                printStatusLegend();\n                printNodesHeader(hasEffectiveOwns, isTokenPerNode);\n\n                // Nodes\n                for (HostStat entry : dc.getValue())\n                    printNode(entry, hasEffectiveOwns, isTokenPerNode);\n            }\n        }","commit_id":"2f63bbadfa2fad66e04bc17edc66ce8be7497157","url":"https://github.com/apache/cassandra"},{"original_method":"ClusterStatus(PrintStream outs, String kSpace)\n        {\n            this.kSpace = kSpace;\n            this.outs = outs;\n            joiningNodes = probe.getJoiningNodes();\n            leavingNodes = probe.getLeavingNodes();\n            movingNodes = probe.getMovingNodes();\n            loadMap = probe.getLoadMap();\n            tokensToEndpoints = probe.getTokenToEndpointMap();\n            liveNodes = probe.getLiveNodes();\n            unreachableNodes = probe.getUnreachableNodes();\n            hostIDMap = probe.getHostIdMap();\n            epSnitchInfo = probe.getEndpointSnitchInfoProxy();\n        }","id":91250,"modified_method":"ClusterStatus(PrintStream outs, String kSpace, boolean resolveIp)\n        {\n            this.kSpace = kSpace;\n            this.outs = outs;\n            this.resolveIp = resolveIp;\n            joiningNodes = probe.getJoiningNodes();\n            leavingNodes = probe.getLeavingNodes();\n            movingNodes = probe.getMovingNodes();\n            loadMap = probe.getLoadMap();\n            tokensToEndpoints = probe.getTokenToEndpointMap();\n            liveNodes = probe.getLiveNodes();\n            unreachableNodes = probe.getUnreachableNodes();\n            hostIDMap = probe.getHostIdMap();\n            epSnitchInfo = probe.getEndpointSnitchInfoProxy();\n        }","commit_id":"2f63bbadfa2fad66e04bc17edc66ce8be7497157","url":"https://github.com/apache/cassandra"},{"original_method":"ClusterStatus(PrintStream outs, String kSpace)\n        {\n            this.kSpace = kSpace;\n            this.outs = outs;\n            joiningNodes = probe.getJoiningNodes();\n            leavingNodes = probe.getLeavingNodes();\n            movingNodes = probe.getMovingNodes();\n            loadMap = probe.getLoadMap();\n            tokensToEndpoints = probe.getTokenToEndpointMap();\n            liveNodes = probe.getLiveNodes();\n            unreachableNodes = probe.getUnreachableNodes();\n            hostIDMap = probe.getHostIdMap();\n            epSnitchInfo = probe.getEndpointSnitchInfoProxy();\n        }","id":91251,"modified_method":"ClusterStatus(PrintStream outs, String kSpace, boolean resolveIp)\n        {\n            this.kSpace = kSpace;\n            this.outs = outs;\n            this.resolveIp = resolveIp;\n            joiningNodes = probe.getJoiningNodes();\n            leavingNodes = probe.getLeavingNodes();\n            movingNodes = probe.getMovingNodes();\n            loadMap = probe.getLoadMap();\n            tokensToEndpoints = probe.getTokenToEndpointMap();\n            liveNodes = probe.getLiveNodes();\n            unreachableNodes = probe.getUnreachableNodes();\n            hostIDMap = probe.getHostIdMap();\n            epSnitchInfo = probe.getEndpointSnitchInfoProxy();\n        }","commit_id":"c5ca8de4dfd512e971f9bba100dfcc3709f70786","url":"https://github.com/apache/cassandra"},{"original_method":"void print() throws UnknownHostException\n        {\n            Map<InetAddress, Float> ownerships;\n            boolean hasEffectiveOwns = false, isTokenPerNode = true;\n\n            try\n            {\n                ownerships = probe.effectiveOwnership(kSpace);\n                hasEffectiveOwns = true;\n            }\n            catch (IllegalStateException e)\n            {\n                ownerships = probe.getOwnership();\n            }\n\n            // More tokens then nodes (aka vnodes)?\n            if (new HashSet<String>(tokensToEndpoints.values()).size() < tokensToEndpoints.keySet().size())\n                isTokenPerNode = false;\n\n            maxAddressLength = 0;\n            for (Map.Entry<String, Map<InetAddress, Float>> dc : getOwnershipByDc(ownerships).entrySet())\n            {\n                int dcMaxAddressLength = Collections.max(dc.getValue().keySet(), new Comparator<InetAddress>() {\n                    @Override\n                    public int compare(InetAddress first, InetAddress second)\n                    {\n                        return ((Integer)first.getHostAddress().length()).compareTo((Integer)second.getHostAddress().length());\n                    }\n                }).getHostAddress().length();\n\n                if(dcMaxAddressLength > maxAddressLength)\n                    maxAddressLength = dcMaxAddressLength;\n            }\n\n            // Datacenters\n            for (Map.Entry<String, Map<InetAddress, Float>> dc : getOwnershipByDc(ownerships).entrySet())\n            {\n                String dcHeader = String.format(\"Datacenter: %s%n\", dc.getKey());\n                outs.printf(dcHeader);\n                for (int i=0; i < (dcHeader.length() - 1); i++) outs.print('=');\n                outs.println();\n\n                printStatusLegend();\n                printNodesHeader(hasEffectiveOwns, isTokenPerNode);\n\n                // Nodes\n                for (Map.Entry<InetAddress, Float> entry : dc.getValue().entrySet())\n                    printNode(entry.getKey().getHostAddress(),\n                              entry.getValue(),\n                              ownerships,\n                              hasEffectiveOwns,\n                              isTokenPerNode);\n            }\n        }","id":91252,"modified_method":"void print() throws UnknownHostException\n        {\n            SetHostStat ownerships;\n            boolean hasEffectiveOwns = false, isTokenPerNode = true;\n\n            try\n            {\n                ownerships = new SetHostStat(probe.effectiveOwnership(kSpace));\n                hasEffectiveOwns = true;\n            }\n            catch (IllegalStateException e)\n            {\n                ownerships = new SetHostStat(probe.getOwnership());\n            }\n\n            // More tokens then nodes (aka vnodes)?\n            if (new HashSet<String>(tokensToEndpoints.values()).size() < tokensToEndpoints.keySet().size())\n                isTokenPerNode = false;\n\n            Map<String, SetHostStat> dcs = getOwnershipByDc(ownerships);\n\n            findMaxAddressLength(dcs);\n\n            // Datacenters\n            for (Map.Entry<String, SetHostStat> dc : dcs.entrySet())\n            {\n                String dcHeader = String.format(\"Datacenter: %s%n\", dc.getKey());\n                outs.printf(dcHeader);\n                for (int i=0; i < (dcHeader.length() - 1); i++) outs.print('=');\n                outs.println();\n\n                printStatusLegend();\n                printNodesHeader(hasEffectiveOwns, isTokenPerNode);\n\n                // Nodes\n                for (HostStat entry : dc.getValue())\n                    printNode(entry, hasEffectiveOwns, isTokenPerNode);\n            }\n        }","commit_id":"c5ca8de4dfd512e971f9bba100dfcc3709f70786","url":"https://github.com/apache/cassandra"},{"original_method":"public static void main(String[] args) throws IOException, InterruptedException, ParseException\n    {\n        CommandLineParser parser = new PosixParser();\n        ToolCommandLine cmd = null;\n\n        try\n        {\n            cmd = new ToolCommandLine(parser.parse(options, args));\n        }\n        catch (ParseException p)\n        {\n            badUse(p.getMessage());\n        }\n\n        String host = cmd.hasOption(HOST_OPT.left) ? cmd.getOptionValue(HOST_OPT.left) : DEFAULT_HOST;\n\n        int port = DEFAULT_PORT;\n\n        String portNum = cmd.getOptionValue(PORT_OPT.left);\n        if (portNum != null)\n        {\n            try\n            {\n                port = Integer.parseInt(portNum);\n            }\n            catch (NumberFormatException e)\n            {\n                throw new ParseException(\"Port must be a number\");\n            }\n        }\n\n        NodeCommand command = null;\n\n        try\n        {\n            command = cmd.getCommand();\n        }\n        catch (IllegalArgumentException e)\n        {\n            badUse(e.getMessage());\n        }\n\n        if(NodeCommand.HELP.equals(command))\n        {\n            printUsage();\n            System.exit(0);\n        }\n\n        NodeProbe probe = null;\n\n        try\n        {\n            String username = cmd.getOptionValue(USERNAME_OPT.left);\n            String password = cmd.getOptionValue(PASSWORD_OPT.left);\n\n            try\n            {\n                probe = username == null ? new NodeProbe(host, port) : new NodeProbe(host, port, username, password);\n            }\n            catch (IOException ioe)\n            {\n                Throwable inner = findInnermostThrowable(ioe);\n                if (inner instanceof ConnectException)\n                {\n                    System.err.printf(\"Failed to connect to '%s:%d': %s%n\", host, port, inner.getMessage());\n                    System.exit(1);\n                }\n                else if (inner instanceof UnknownHostException)\n                {\n                    System.err.printf(\"Cannot resolve '%s': unknown host%n\", host);\n                    System.exit(1);\n                }\n                else\n                {\n                    err(ioe, \"Error connecting to remote JMX agent!\");\n                }\n            }\n\n            NodeCmd nodeCmd = new NodeCmd(probe);\n\n            //print history here after we've already determined we can reasonably call cassandra\n            printHistory(args, cmd);\n\n            // Execute the requested command.\n            String[] arguments = cmd.getCommandArguments();\n            String tag;\n            String columnFamilyName = null;\n\n            switch (command)\n            {\n                case RING :\n                    if (arguments.length > 0) { nodeCmd.printRing(System.out, arguments[0]); }\n                    else                      { nodeCmd.printRing(System.out, null); };\n                    break;\n\n                case INFO            : nodeCmd.printInfo(System.out, cmd); break;\n                case CFSTATS         :\n                    boolean ignoreMode = cmd.hasOption(CFSTATS_IGNORE_OPT.left);\n                    if (arguments.length > 0) { nodeCmd.printColumnFamilyStats(System.out, ignoreMode, arguments); }\n                    else                      { nodeCmd.printColumnFamilyStats(System.out, false, null); }\n                    break;\n                case TPSTATS         : nodeCmd.printThreadPoolStats(System.out); break;\n                case VERSION         : nodeCmd.printReleaseVersion(System.out); break;\n                case COMPACTIONSTATS : nodeCmd.printCompactionStats(System.out); break;\n                case COMPACTIONHISTORY:nodeCmd.printCompactionHistory(System.out); break;\n                case DESCRIBECLUSTER : nodeCmd.printClusterDescription(System.out, host); break;\n                case DISABLEBINARY   : probe.stopNativeTransport(); break;\n                case ENABLEBINARY    : probe.startNativeTransport(); break;\n                case STATUSBINARY    : nodeCmd.printIsNativeTransportRunning(System.out); break;\n                case DISABLEGOSSIP   : probe.stopGossiping(); break;\n                case ENABLEGOSSIP    : probe.startGossiping(); break;\n                case DISABLEHANDOFF  : probe.disableHintedHandoff(); break;\n                case ENABLEHANDOFF   : probe.enableHintedHandoff(); break;\n                case PAUSEHANDOFF    : probe.pauseHintsDelivery(); break;\n                case RESUMEHANDOFF   : probe.resumeHintsDelivery(); break;\n                case DISABLETHRIFT   : probe.stopThriftServer(); break;\n                case ENABLETHRIFT    : probe.startThriftServer(); break;\n                case STATUSTHRIFT    : nodeCmd.printIsThriftServerRunning(System.out); break;\n                case RESETLOCALSCHEMA: probe.resetLocalSchema(); break;\n                case ENABLEBACKUP    : probe.setIncrementalBackupsEnabled(true); break;\n                case DISABLEBACKUP   : probe.setIncrementalBackupsEnabled(false); break;\n\n                case TRUNCATEHINTS:\n                    if (arguments.length > 1) badUse(\"Too many arguments.\");\n                    else if (arguments.length == 1) probe.truncateHints(arguments[0]);\n                    else probe.truncateHints();\n                    break;\n\n                case STATUS :\n                    if (arguments.length > 0) nodeCmd.printClusterStatus(System.out, arguments[0]);\n                    else                      nodeCmd.printClusterStatus(System.out, null);\n                    break;\n\n                case DECOMMISSION :\n                    if (arguments.length > 0)\n                    {\n                        System.err.println(\"Decommission will decommission the node you are connected to and does not take arguments!\");\n                        System.exit(1);\n                    }\n                    probe.decommission();\n                    break;\n\n                case DRAIN :\n                    try { probe.drain(); }\n                    catch (ExecutionException ee) { err(ee, \"Error occured during flushing\"); }\n                    break;\n\n                case NETSTATS :\n                    if (arguments.length > 0) { nodeCmd.printNetworkStats(InetAddress.getByName(arguments[0]), System.out); }\n                    else                      { nodeCmd.printNetworkStats(null, System.out); }\n                    break;\n\n                case SNAPSHOT :\n                    columnFamilyName = cmd.getOptionValue(SNAPSHOT_COLUMNFAMILY_OPT.left);\n                    /* FALL THRU */\n                case CLEARSNAPSHOT :\n                    tag = cmd.getOptionValue(TAG_OPT.left);\n                    handleSnapshots(command, tag, arguments, columnFamilyName, probe);\n                    break;\n\n                case MOVE :\n                    if (arguments.length != 1) { badUse(\"Missing token argument for move.\"); }\n                    try\n                    {\n                        probe.move(arguments[0]);\n                    }\n                    catch (UnsupportedOperationException uoerror)\n                    {\n                        System.err.println(uoerror.getMessage());\n                        System.exit(1);\n                    }\n                    break;\n\n                case JOIN:\n                    if (probe.isJoined())\n                    {\n                        System.err.println(\"This node has already joined the ring.\");\n                        System.exit(1);\n                    }\n\n                    probe.joinRing();\n                    break;\n\n                case SETCOMPACTIONTHROUGHPUT :\n                    if (arguments.length != 1) { badUse(\"Missing value argument.\"); }\n                    probe.setCompactionThroughput(Integer.parseInt(arguments[0]));\n                    break;\n\n                case SETSTREAMTHROUGHPUT :\n                    if (arguments.length != 1) { badUse(\"Missing value argument.\"); }\n                    probe.setStreamThroughput(Integer.parseInt(arguments[0]));\n                    break;\n\n                case SETTRACEPROBABILITY :\n                    if (arguments.length != 1) { badUse(\"Missing value argument.\"); }\n                    probe.setTraceProbability(Double.parseDouble(arguments[0]));\n                    break;\n\n                case REBUILD :\n                    if (arguments.length > 1) { badUse(\"Too many arguments.\"); }\n                    probe.rebuild(arguments.length == 1 ? arguments[0] : null);\n                    break;\n\n                case REMOVETOKEN :\n                    System.err.println(\"Warn: removetoken is deprecated, please use removenode instead\");\n                case REMOVENODE  :\n                    if (arguments.length != 1) { badUse(\"Missing an argument for removenode (either status, force, or an ID)\"); }\n                    else if (arguments[0].equals(\"status\")) { nodeCmd.printRemovalStatus(System.out); }\n                    else if (arguments[0].equals(\"force\"))  { nodeCmd.printRemovalStatus(System.out); probe.forceRemoveCompletion(); }\n                    else                                    { probe.removeNode(arguments[0]); }\n                    break;\n\n                case INVALIDATEKEYCACHE :\n                    probe.invalidateKeyCache();\n                    break;\n\n                case INVALIDATEROWCACHE :\n                    probe.invalidateRowCache();\n                    break;\n\n                case CLEANUP :\n                case COMPACT :\n                case REPAIR  :\n                case FLUSH   :\n                case SCRUB   :\n                case UPGRADESSTABLES   :\n                case DISABLEAUTOCOMPACTION:\n                case ENABLEAUTOCOMPACTION:\n                    optionalKSandCFs(command, cmd, arguments, probe);\n                    break;\n\n                case GETCOMPACTIONTHRESHOLD :\n                    if (arguments.length != 2) { badUse(\"getcompactionthreshold requires ks and cf args.\"); }\n                    nodeCmd.printCompactionThreshold(System.out, arguments[0], arguments[1]);\n                    break;\n\n                case GETCOMPACTIONTHROUGHPUT : nodeCmd.printCompactionThroughput(System.out); break;\n                case GETSTREAMTHROUGHPUT : nodeCmd.printStreamThroughput(System.out); break;\n\n                case CFHISTOGRAMS :\n                    if (arguments.length != 2) { badUse(\"cfhistograms requires ks and cf args\"); }\n                    nodeCmd.printCfHistograms(arguments[0], arguments[1], System.out);\n                    break;\n\n                case SETCACHECAPACITY :\n                    if (arguments.length != 2) { badUse(\"setcachecapacity requires key-cache-capacity, and row-cache-capacity args.\"); }\n                    probe.setCacheCapacities(Integer.parseInt(arguments[0]), Integer.parseInt(arguments[1]));\n                    break;\n\n                case SETCACHEKEYSTOSAVE :\n                    if (arguments.length != 2) { badUse(\"setcachekeystosave requires key-cache-keys-to-save, and row-cache-keys-to-save args.\"); }\n                    probe.setCacheKeysToSave(Integer.parseInt(arguments[0]), Integer.parseInt(arguments[1]));\n                    break;\n\n                case SETCOMPACTIONTHRESHOLD :\n                    if (arguments.length != 4) { badUse(\"setcompactionthreshold requires ks, cf, min, and max threshold args.\"); }\n                    int minthreshold = Integer.parseInt(arguments[2]);\n                    int maxthreshold = Integer.parseInt(arguments[3]);\n                    if ((minthreshold < 0) || (maxthreshold < 0)) { badUse(\"Thresholds must be positive integers\"); }\n                    if (minthreshold > maxthreshold)              { badUse(\"Min threshold cannot be greater than max.\"); }\n                    if (minthreshold < 2 && maxthreshold != 0)    { badUse(\"Min threshold must be at least 2\"); }\n                    probe.setCompactionThreshold(arguments[0], arguments[1], minthreshold, maxthreshold);\n                    break;\n                case GETENDPOINTS :\n                    if (arguments.length != 3) { badUse(\"getendpoints requires ks, cf and key args\"); }\n                    nodeCmd.printEndPoints(arguments[0], arguments[1], arguments[2], System.out);\n                    break;\n\n                case PROXYHISTOGRAMS :\n                    if (arguments.length != 0) { badUse(\"proxyhistograms does not take arguments\"); }\n                    nodeCmd.printProxyHistograms(System.out);\n                    break;\n\n                case GETSSTABLES:\n                    if (arguments.length != 3) { badUse(\"getsstables requires ks, cf and key args\"); }\n                    nodeCmd.printSSTables(arguments[0], arguments[1], arguments[2], System.out);\n                    break;\n\n                case REFRESH:\n                    if (arguments.length != 2) { badUse(\"load_new_sstables requires ks and cf args\"); }\n                    probe.loadNewSSTables(arguments[0], arguments[1]);\n                    break;\n\n                case REBUILD_INDEX:\n                    if (arguments.length < 2) { badUse(\"rebuild_index requires ks and cf args\"); }\n                    if (arguments.length >= 3)\n                        probe.rebuildIndex(arguments[0], arguments[1], arguments[2].split(\",\"));\n                    else\n                        probe.rebuildIndex(arguments[0], arguments[1]);\n\n                    break;\n\n                case GOSSIPINFO : nodeCmd.printGossipInfo(System.out); break;\n\n                case STOP:\n                    if (arguments.length != 1) { badUse(\"stop requires a type.\"); }\n                    probe.stop(arguments[0].toUpperCase());\n                    break;\n\n                case STOPDAEMON:\n                    if (arguments.length != 0) { badUse(\"stopdaemon does not take arguments.\"); }\n                    try { probe.stopCassandraDaemon(); }\n                    catch (Throwable t) { System.out.println(\"Cassandra has shut down.\\n\"); }\n                    break;\n\n                case DESCRIBERING :\n                    if (arguments.length != 1) { badUse(\"Missing keyspace argument for describering.\"); }\n                    nodeCmd.printDescribeRing(arguments[0], System.out);\n                    break;\n\n                case RANGEKEYSAMPLE :\n                    nodeCmd.printRangeKeySample(System.out);\n                    break;\n\n                case RELOADTRIGGERS :\n                    probe.reloadTriggers();\n                    break;\n\n                default :\n                    throw new RuntimeException(\"Unreachable code.\");\n            }\n        }\n        finally\n        {\n            if (probe != null)\n            {\n                try\n                {\n                    probe.close();\n                }\n                catch (IOException ex)\n                {\n                    // swallow the exception so the user will see the real one.\n                }\n            }\n        }\n        System.exit(probe.isFailed() ? 1 : 0);\n    }","id":91253,"modified_method":"public static void main(String[] args) throws IOException, InterruptedException, ParseException\n    {\n        CommandLineParser parser = new PosixParser();\n        ToolCommandLine cmd = null;\n\n        try\n        {\n            cmd = new ToolCommandLine(parser.parse(options, args));\n        }\n        catch (ParseException p)\n        {\n            badUse(p.getMessage());\n        }\n\n        String host = cmd.hasOption(HOST_OPT.left) ? cmd.getOptionValue(HOST_OPT.left) : DEFAULT_HOST;\n\n        int port = DEFAULT_PORT;\n\n        String portNum = cmd.getOptionValue(PORT_OPT.left);\n        if (portNum != null)\n        {\n            try\n            {\n                port = Integer.parseInt(portNum);\n            }\n            catch (NumberFormatException e)\n            {\n                throw new ParseException(\"Port must be a number\");\n            }\n        }\n\n        NodeCommand command = null;\n\n        try\n        {\n            command = cmd.getCommand();\n        }\n        catch (IllegalArgumentException e)\n        {\n            badUse(e.getMessage());\n        }\n\n        if(NodeCommand.HELP.equals(command))\n        {\n            printUsage();\n            System.exit(0);\n        }\n\n        NodeProbe probe = null;\n\n        try\n        {\n            String username = cmd.getOptionValue(USERNAME_OPT.left);\n            String password = cmd.getOptionValue(PASSWORD_OPT.left);\n\n            try\n            {\n                probe = username == null ? new NodeProbe(host, port) : new NodeProbe(host, port, username, password);\n            }\n            catch (IOException ioe)\n            {\n                Throwable inner = findInnermostThrowable(ioe);\n                if (inner instanceof ConnectException)\n                {\n                    System.err.printf(\"Failed to connect to '%s:%d': %s%n\", host, port, inner.getMessage());\n                    System.exit(1);\n                }\n                else if (inner instanceof UnknownHostException)\n                {\n                    System.err.printf(\"Cannot resolve '%s': unknown host%n\", host);\n                    System.exit(1);\n                }\n                else\n                {\n                    err(ioe, \"Error connecting to remote JMX agent!\");\n                }\n            }\n\n            NodeCmd nodeCmd = new NodeCmd(probe);\n\n            //print history here after we've already determined we can reasonably call cassandra\n            printHistory(args, cmd);\n\n            // Execute the requested command.\n            String[] arguments = cmd.getCommandArguments();\n            String tag;\n            String columnFamilyName = null;\n\n            switch (command)\n            {\n                case RING :\n                    if (arguments.length > 0) { nodeCmd.printRing(System.out, arguments[0]); }\n                    else                      { nodeCmd.printRing(System.out, null); };\n                    break;\n\n                case INFO            : nodeCmd.printInfo(System.out, cmd); break;\n                case CFSTATS         :\n                    boolean ignoreMode = cmd.hasOption(CFSTATS_IGNORE_OPT.left);\n                    if (arguments.length > 0) { nodeCmd.printColumnFamilyStats(System.out, ignoreMode, arguments); }\n                    else                      { nodeCmd.printColumnFamilyStats(System.out, false, null); }\n                    break;\n                case TPSTATS         : nodeCmd.printThreadPoolStats(System.out); break;\n                case VERSION         : nodeCmd.printReleaseVersion(System.out); break;\n                case COMPACTIONSTATS : nodeCmd.printCompactionStats(System.out); break;\n                case COMPACTIONHISTORY:nodeCmd.printCompactionHistory(System.out); break;\n                case DESCRIBECLUSTER : nodeCmd.printClusterDescription(System.out, host); break;\n                case DISABLEBINARY   : probe.stopNativeTransport(); break;\n                case ENABLEBINARY    : probe.startNativeTransport(); break;\n                case STATUSBINARY    : nodeCmd.printIsNativeTransportRunning(System.out); break;\n                case DISABLEGOSSIP   : probe.stopGossiping(); break;\n                case ENABLEGOSSIP    : probe.startGossiping(); break;\n                case DISABLEHANDOFF  : probe.disableHintedHandoff(); break;\n                case ENABLEHANDOFF   : probe.enableHintedHandoff(); break;\n                case PAUSEHANDOFF    : probe.pauseHintsDelivery(); break;\n                case RESUMEHANDOFF   : probe.resumeHintsDelivery(); break;\n                case DISABLETHRIFT   : probe.stopThriftServer(); break;\n                case ENABLETHRIFT    : probe.startThriftServer(); break;\n                case STATUSTHRIFT    : nodeCmd.printIsThriftServerRunning(System.out); break;\n                case RESETLOCALSCHEMA: probe.resetLocalSchema(); break;\n                case ENABLEBACKUP    : probe.setIncrementalBackupsEnabled(true); break;\n                case DISABLEBACKUP   : probe.setIncrementalBackupsEnabled(false); break;\n\n                case TRUNCATEHINTS:\n                    if (arguments.length > 1) badUse(\"Too many arguments.\");\n                    else if (arguments.length == 1) probe.truncateHints(arguments[0]);\n                    else probe.truncateHints();\n                    break;\n\n                case STATUS :\n                    boolean resolveIp = cmd.hasOption(RESOLVE_IP.left);\n                    if (arguments.length > 0) nodeCmd.printClusterStatus(System.out, arguments[0], resolveIp);\n                    else                      nodeCmd.printClusterStatus(System.out, null, resolveIp);\n                    break;\n\n                case DECOMMISSION :\n                    if (arguments.length > 0)\n                    {\n                        System.err.println(\"Decommission will decommission the node you are connected to and does not take arguments!\");\n                        System.exit(1);\n                    }\n                    probe.decommission();\n                    break;\n\n                case DRAIN :\n                    try { probe.drain(); }\n                    catch (ExecutionException ee) { err(ee, \"Error occured during flushing\"); }\n                    break;\n\n                case NETSTATS :\n                    if (arguments.length > 0) { nodeCmd.printNetworkStats(InetAddress.getByName(arguments[0]), System.out); }\n                    else                      { nodeCmd.printNetworkStats(null, System.out); }\n                    break;\n\n                case SNAPSHOT :\n                    columnFamilyName = cmd.getOptionValue(SNAPSHOT_COLUMNFAMILY_OPT.left);\n                    /* FALL THRU */\n                case CLEARSNAPSHOT :\n                    tag = cmd.getOptionValue(TAG_OPT.left);\n                    handleSnapshots(command, tag, arguments, columnFamilyName, probe);\n                    break;\n\n                case MOVE :\n                    if (arguments.length != 1) { badUse(\"Missing token argument for move.\"); }\n                    try\n                    {\n                        probe.move(arguments[0]);\n                    }\n                    catch (UnsupportedOperationException uoerror)\n                    {\n                        System.err.println(uoerror.getMessage());\n                        System.exit(1);\n                    }\n                    break;\n\n                case JOIN:\n                    if (probe.isJoined())\n                    {\n                        System.err.println(\"This node has already joined the ring.\");\n                        System.exit(1);\n                    }\n\n                    probe.joinRing();\n                    break;\n\n                case SETCOMPACTIONTHROUGHPUT :\n                    if (arguments.length != 1) { badUse(\"Missing value argument.\"); }\n                    probe.setCompactionThroughput(Integer.parseInt(arguments[0]));\n                    break;\n\n                case SETSTREAMTHROUGHPUT :\n                    if (arguments.length != 1) { badUse(\"Missing value argument.\"); }\n                    probe.setStreamThroughput(Integer.parseInt(arguments[0]));\n                    break;\n\n                case SETTRACEPROBABILITY :\n                    if (arguments.length != 1) { badUse(\"Missing value argument.\"); }\n                    probe.setTraceProbability(Double.parseDouble(arguments[0]));\n                    break;\n\n                case REBUILD :\n                    if (arguments.length > 1) { badUse(\"Too many arguments.\"); }\n                    probe.rebuild(arguments.length == 1 ? arguments[0] : null);\n                    break;\n\n                case REMOVETOKEN :\n                    System.err.println(\"Warn: removetoken is deprecated, please use removenode instead\");\n                case REMOVENODE  :\n                    if (arguments.length != 1) { badUse(\"Missing an argument for removenode (either status, force, or an ID)\"); }\n                    else if (arguments[0].equals(\"status\")) { nodeCmd.printRemovalStatus(System.out); }\n                    else if (arguments[0].equals(\"force\"))  { nodeCmd.printRemovalStatus(System.out); probe.forceRemoveCompletion(); }\n                    else                                    { probe.removeNode(arguments[0]); }\n                    break;\n\n                case INVALIDATEKEYCACHE :\n                    probe.invalidateKeyCache();\n                    break;\n\n                case INVALIDATEROWCACHE :\n                    probe.invalidateRowCache();\n                    break;\n\n                case CLEANUP :\n                case COMPACT :\n                case REPAIR  :\n                case FLUSH   :\n                case SCRUB   :\n                case UPGRADESSTABLES   :\n                case DISABLEAUTOCOMPACTION:\n                case ENABLEAUTOCOMPACTION:\n                    optionalKSandCFs(command, cmd, arguments, probe);\n                    break;\n\n                case GETCOMPACTIONTHRESHOLD :\n                    if (arguments.length != 2) { badUse(\"getcompactionthreshold requires ks and cf args.\"); }\n                    nodeCmd.printCompactionThreshold(System.out, arguments[0], arguments[1]);\n                    break;\n\n                case GETCOMPACTIONTHROUGHPUT : nodeCmd.printCompactionThroughput(System.out); break;\n                case GETSTREAMTHROUGHPUT : nodeCmd.printStreamThroughput(System.out); break;\n\n                case CFHISTOGRAMS :\n                    if (arguments.length != 2) { badUse(\"cfhistograms requires ks and cf args\"); }\n                    nodeCmd.printCfHistograms(arguments[0], arguments[1], System.out);\n                    break;\n\n                case SETCACHECAPACITY :\n                    if (arguments.length != 2) { badUse(\"setcachecapacity requires key-cache-capacity, and row-cache-capacity args.\"); }\n                    probe.setCacheCapacities(Integer.parseInt(arguments[0]), Integer.parseInt(arguments[1]));\n                    break;\n\n                case SETCACHEKEYSTOSAVE :\n                    if (arguments.length != 2) { badUse(\"setcachekeystosave requires key-cache-keys-to-save, and row-cache-keys-to-save args.\"); }\n                    probe.setCacheKeysToSave(Integer.parseInt(arguments[0]), Integer.parseInt(arguments[1]));\n                    break;\n\n                case SETCOMPACTIONTHRESHOLD :\n                    if (arguments.length != 4) { badUse(\"setcompactionthreshold requires ks, cf, min, and max threshold args.\"); }\n                    int minthreshold = Integer.parseInt(arguments[2]);\n                    int maxthreshold = Integer.parseInt(arguments[3]);\n                    if ((minthreshold < 0) || (maxthreshold < 0)) { badUse(\"Thresholds must be positive integers\"); }\n                    if (minthreshold > maxthreshold)              { badUse(\"Min threshold cannot be greater than max.\"); }\n                    if (minthreshold < 2 && maxthreshold != 0)    { badUse(\"Min threshold must be at least 2\"); }\n                    probe.setCompactionThreshold(arguments[0], arguments[1], minthreshold, maxthreshold);\n                    break;\n                case GETENDPOINTS :\n                    if (arguments.length != 3) { badUse(\"getendpoints requires ks, cf and key args\"); }\n                    nodeCmd.printEndPoints(arguments[0], arguments[1], arguments[2], System.out);\n                    break;\n\n                case PROXYHISTOGRAMS :\n                    if (arguments.length != 0) { badUse(\"proxyhistograms does not take arguments\"); }\n                    nodeCmd.printProxyHistograms(System.out);\n                    break;\n\n                case GETSSTABLES:\n                    if (arguments.length != 3) { badUse(\"getsstables requires ks, cf and key args\"); }\n                    nodeCmd.printSSTables(arguments[0], arguments[1], arguments[2], System.out);\n                    break;\n\n                case REFRESH:\n                    if (arguments.length != 2) { badUse(\"load_new_sstables requires ks and cf args\"); }\n                    probe.loadNewSSTables(arguments[0], arguments[1]);\n                    break;\n\n                case REBUILD_INDEX:\n                    if (arguments.length < 2) { badUse(\"rebuild_index requires ks and cf args\"); }\n                    if (arguments.length >= 3)\n                        probe.rebuildIndex(arguments[0], arguments[1], arguments[2].split(\",\"));\n                    else\n                        probe.rebuildIndex(arguments[0], arguments[1]);\n\n                    break;\n\n                case GOSSIPINFO : nodeCmd.printGossipInfo(System.out); break;\n\n                case STOP:\n                    if (arguments.length != 1) { badUse(\"stop requires a type.\"); }\n                    probe.stop(arguments[0].toUpperCase());\n                    break;\n\n                case STOPDAEMON:\n                    if (arguments.length != 0) { badUse(\"stopdaemon does not take arguments.\"); }\n                    try { probe.stopCassandraDaemon(); }\n                    catch (Throwable t) { System.out.println(\"Cassandra has shut down.\\n\"); }\n                    break;\n\n                case DESCRIBERING :\n                    if (arguments.length != 1) { badUse(\"Missing keyspace argument for describering.\"); }\n                    nodeCmd.printDescribeRing(arguments[0], System.out);\n                    break;\n\n                case RANGEKEYSAMPLE :\n                    nodeCmd.printRangeKeySample(System.out);\n                    break;\n\n                case RELOADTRIGGERS :\n                    probe.reloadTriggers();\n                    break;\n\n                default :\n                    throw new RuntimeException(\"Unreachable code.\");\n            }\n        }\n        finally\n        {\n            if (probe != null)\n            {\n                try\n                {\n                    probe.close();\n                }\n                catch (IOException ex)\n                {\n                    // swallow the exception so the user will see the real one.\n                }\n            }\n        }\n        System.exit(probe.isFailed() ? 1 : 0);\n    }","commit_id":"c5ca8de4dfd512e971f9bba100dfcc3709f70786","url":"https://github.com/apache/cassandra"},{"original_method":"/** Writes a keyspaceName of cluster-wide node information to a PrintStream\n     * @throws UnknownHostException */\n    public void printClusterStatus(PrintStream outs, String keyspace) throws UnknownHostException\n    {\n        new ClusterStatus(outs, keyspace).print();\n    }","id":91254,"modified_method":"/** Writes a keyspaceName of cluster-wide node information to a PrintStream\n     * @throws UnknownHostException */\n    public void printClusterStatus(PrintStream outs, String keyspace, boolean resolveIp) throws UnknownHostException\n    {\n        new ClusterStatus(outs, keyspace, resolveIp).print();\n    }","commit_id":"c5ca8de4dfd512e971f9bba100dfcc3709f70786","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n  public void visitPosixBracketExpression(RegExpPosixBracketExpression posixBracketExpression) {\n    final String className = posixBracketExpression.getClassName();\n    if (!POSIX_CHARACTER_CLASSES.contains(className)) {\n      final Annotation annotation = myHolder.createErrorAnnotation(posixBracketExpression, \"Unknown POSIX character class\");\n      if (annotation != null) {\n        annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n      }\n    }\n  }","id":91255,"modified_method":"@Override\n  public void visitPosixBracketExpression(RegExpPosixBracketExpression posixBracketExpression) {\n    final String className = posixBracketExpression.getClassName();\n    if (!POSIX_CHARACTER_CLASSES.contains(className)) {\n      final Annotation annotation = myHolder.createErrorAnnotation(posixBracketExpression, \"Unknown POSIX character class\");\n      annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n    }\n  }","commit_id":"25b24b59df94ce59029635dee06f10d77451fedd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitRegExpBackref(final RegExpBackref backref) {\n    final RegExpGroup group = backref.resolve();\n    if (group == null) {\n      final Annotation a = myHolder.createErrorAnnotation(backref, \"Unresolved back reference\");\n      if (a != null) {\n        // IDEA-9381\n        a.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n      }\n    }\n    else if (PsiTreeUtil.isAncestor(group, backref, true)) {\n      myHolder.createWarningAnnotation(backref, \"Back reference is nested into the capturing group it refers to\");\n    }\n  }","id":91256,"modified_method":"@Override\n  public void visitRegExpBackref(final RegExpBackref backref) {\n    final RegExpGroup group = backref.resolve();\n    if (group == null) {\n      final Annotation a = myHolder.createErrorAnnotation(backref, \"Unresolved back reference\");\n      a.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n    }\n    else if (PsiTreeUtil.isAncestor(group, backref, true)) {\n      myHolder.createWarningAnnotation(backref, \"Back reference is nested into the capturing group it refers to\");\n    }\n  }","commit_id":"25b24b59df94ce59029635dee06f10d77451fedd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitRegExpNamedGroupRef(RegExpNamedGroupRef groupRef) {\n    if (!myLanguageHosts.supportsNamedGroupRefSyntax(groupRef)) {\n      myHolder.createErrorAnnotation(groupRef, \"This named group reference syntax is not supported\");\n      return;\n    }\n    if (groupRef.getGroupName() == null) {\n      return;\n    }\n    final RegExpGroup group = groupRef.resolve();\n    if (group == null) {\n      final ASTNode node = groupRef.getNode().findChildByType(RegExpTT.NAME);\n      final Annotation a = myHolder.createErrorAnnotation(node, \"Unresolved named group reference\");\n      if (a != null) {\n        // IDEA-9381\n        a.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n      }\n    }\n    else if (PsiTreeUtil.isAncestor(group, groupRef, true)) {\n      myHolder.createWarningAnnotation(groupRef, \"Group reference is nested into the named group it refers to\");\n    }\n  }","id":91257,"modified_method":"@Override\n  public void visitRegExpNamedGroupRef(RegExpNamedGroupRef groupRef) {\n    if (!myLanguageHosts.supportsNamedGroupRefSyntax(groupRef)) {\n      myHolder.createErrorAnnotation(groupRef, \"This named group reference syntax is not supported\");\n      return;\n    }\n    if (groupRef.getGroupName() == null) {\n      return;\n    }\n    final RegExpGroup group = groupRef.resolve();\n    if (group == null) {\n      final ASTNode node = groupRef.getNode().findChildByType(RegExpTT.NAME);\n      if (node != null) {\n        final Annotation a = myHolder.createErrorAnnotation(node, \"Unresolved named group reference\");\n        a.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n      }\n    }\n    else if (PsiTreeUtil.isAncestor(group, groupRef, true)) {\n      myHolder.createWarningAnnotation(groupRef, \"Group reference is nested into the named group it refers to\");\n    }\n  }","commit_id":"25b24b59df94ce59029635dee06f10d77451fedd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitRegExpGroup(RegExpGroup group) {\n    final RegExpPattern pattern = group.getPattern();\n    if (pattern != null) {\n      final RegExpBranch[] branches = pattern.getBranches();\n      if (isEmpty(branches)) {\n        // catches \"()\" as well as \"(|)\"\n        myHolder.createWarningAnnotation(group, \"Empty group\");\n      }\n      else if (branches.length == 1) {\n        final RegExpAtom[] atoms = branches[0].getAtoms();\n        if (atoms.length == 1 && atoms[0] instanceof RegExpGroup) {\n          if (group.isSimple()) {\n            final RegExpGroup innerGroup = (RegExpGroup)atoms[0];\n            if (group.isCapturing() == innerGroup.isCapturing()) {\n              myHolder.createWarningAnnotation(group, \"Redundant group nesting\");\n            }\n          }\n        }\n      }\n    }\n    if (group.isPythonNamedGroup() || group.isRubyNamedGroup()) {\n      if (!myLanguageHosts.supportsNamedGroupSyntax(group)) {\n        myHolder.createErrorAnnotation(group, \"This named group syntax is not supported\");\n      }\n    }\n  }","id":91258,"modified_method":"@Override\n  public void visitRegExpGroup(RegExpGroup group) {\n    final RegExpPattern pattern = group.getPattern();\n    if (pattern != null) {\n      final RegExpBranch[] branches = pattern.getBranches();\n      if (isEmpty(branches)) {\n        // catches \"()\" as well as \"(|)\"\n        myHolder.createWarningAnnotation(group, \"Empty group\");\n      }\n      else if (branches.length == 1) {\n        final RegExpAtom[] atoms = branches[0].getAtoms();\n        if (atoms.length == 1 && atoms[0] instanceof RegExpGroup) {\n          if (group.isSimple()) {\n            final RegExpGroup innerGroup = (RegExpGroup)atoms[0];\n            if (group.isCapturing() == innerGroup.isCapturing()) {\n              myHolder.createWarningAnnotation(group, \"Redundant group nesting\");\n            }\n          }\n        }\n      }\n    }\n    if (group.isPythonNamedGroup() || group.isRubyNamedGroup()) {\n      if (!myLanguageHosts.supportsNamedGroupSyntax(group)) {\n        myHolder.createErrorAnnotation(group, \"This named group syntax is not supported\");\n      }\n    }\n    final String name = group.getName();\n    if (name != null && !myLanguageHosts.isValidGroupName(name, group)) {\n      final ASTNode node = group.getNode().findChildByType(RegExpTT.NAME);\n      if (node != null) myHolder.createErrorAnnotation(node, \"Invalid group name\");\n    }\n  }","commit_id":"25b24b59df94ce59029635dee06f10d77451fedd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitRegExpProperty(RegExpProperty property) {\n    final ASTNode category = property.getCategoryNode();\n    if (category == null) {\n      return;\n    }\n    if(!myLanguageHosts.isValidCategory(category.getPsi(), category.getText())) {\n      final Annotation a = myHolder.createErrorAnnotation(category, \"Unknown character category\");\n      if (a != null) {\n        // IDEA-9381\n        a.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n      }\n    }\n  }","id":91259,"modified_method":"@Override\n  public void visitRegExpProperty(RegExpProperty property) {\n    final ASTNode category = property.getCategoryNode();\n    if (category == null) {\n      return;\n    }\n    if(!myLanguageHosts.isValidCategory(category.getPsi(), category.getText())) {\n      final Annotation a = myHolder.createErrorAnnotation(category, \"Unknown character category\");\n      a.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n    }\n  }","commit_id":"25b24b59df94ce59029635dee06f10d77451fedd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void updateProperties(Id.Stream streamId, Callable<CoordinatorStreamProperties> action) throws Exception {\n    Lock lock = getLock(streamId);\n    lock.lock();\n    try {\n      final CoordinatorStreamProperties properties = action.call();\n      propertyStore.update(streamId.toId(), new SyncPropertyUpdater<CoordinatorStreamProperties>() {\n\n        @Override\n        protected CoordinatorStreamProperties compute(@Nullable CoordinatorStreamProperties oldProperties) {\n          if (oldProperties == null) {\n            return properties;\n          }\n          // Merge the old and new properties.\n          return new CoordinatorStreamProperties(\n            firstNotNull(properties.getTTL(), oldProperties.getTTL()),\n            firstNotNull(properties.getFormat(), oldProperties.getFormat()),\n            firstNotNull(properties.getNotificationThresholdMB(), oldProperties.getNotificationThresholdMB()),\n            firstNotNull(properties.getGeneration(), oldProperties.getGeneration()));\n        }\n      }).get();\n    } finally {\n      lock.unlock();\n    }\n  }","id":91260,"modified_method":"@Override\n  public void updateProperties(Id.Stream streamId, Callable<CoordinatorStreamProperties> action) throws Exception {\n    Lock lock = getLock(streamId);\n    lock.lock();\n    try {\n      updateProperties(streamId, action.call()).get();\n    } finally {\n      lock.unlock();\n    }\n  }","commit_id":"818acb3cecb98a3823711a73637107f224a9e8c1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void deleteStream(Id.Stream streamId, Callable<Id.Stream> action) throws Exception {\n    Lock lock = getLock(streamId);\n    lock.lock();\n    try {\n      action.call();\n      streamDeleted(streamId);\n    } finally {\n      lock.unlock();\n    }\n  }","id":91261,"modified_method":"@Override\n  public void deleteStream(Id.Stream streamId, Callable<CoordinatorStreamProperties> action) throws Exception {\n    Lock lock = getLock(streamId);\n    lock.lock();\n    try {\n      CoordinatorStreamProperties properties = action.call();\n      if (properties != null) {\n        updateProperties(streamId, properties).get();\n        streamDeleted(streamId);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }","commit_id":"818acb3cecb98a3823711a73637107f224a9e8c1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void generationDeleted(Id.Stream streamId) {\n      // Generation deleted. Remove the cache.\n      // This makes creation of file writer resort to scanning the stream directory for generation id.\n      LOG.debug(\"Generation for stream '{}' deleted for stream writer\", streamId);\n      generations.remove(streamId);\n    }","id":91262,"modified_method":"@Override\n    public void generationDeleted(Id.Stream streamId) {\n      LOG.debug(\"Generation for stream '{}' deleted for stream writer\", streamId);\n    }","commit_id":"818acb3cecb98a3823711a73637107f224a9e8c1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void generationChanged(Id.Stream streamId, int generation) {\n      LOG.debug(\"Generation for stream '{}' changed to {} for stream writer\", streamId, generation);\n      generations.put(streamId, generation);\n\n      EventQueue eventQueue = eventQueues.remove(streamId);\n      if (eventQueue != null) {\n        try {\n          eventQueue.close();\n        } catch (IOException e) {\n          LOG.warn(\"Failed to close writer.\", e);\n        }\n      }\n    }","id":91263,"modified_method":"@Override\n    public void generationChanged(Id.Stream streamId, int generation) {\n      LOG.debug(\"Generation for stream '{}' changed to {} for stream writer\", streamId, generation);\n\n      EventQueue eventQueue = eventQueues.remove(streamId);\n      if (eventQueue != null) {\n        try {\n          eventQueue.close();\n        } catch (IOException e) {\n          LOG.warn(\"Failed to close writer.\", e);\n        }\n      }\n    }","commit_id":"818acb3cecb98a3823711a73637107f224a9e8c1","url":"https://github.com/caskdata/cdap"},{"original_method":"StreamFileFactory(StreamFileWriterFactory writerFactory) {\n      this.writerFactory = writerFactory;\n      this.generations = Collections.synchronizedMap(Maps.<Id.Stream, Integer>newHashMap());\n    }","id":91264,"modified_method":"StreamFileFactory(StreamFileWriterFactory writerFactory) {\n      this.writerFactory = writerFactory;\n    }","commit_id":"818acb3cecb98a3823711a73637107f224a9e8c1","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Appends a stream file to the given stream. When this method completed successfully, the given event and index\n     * file locations will be renamed (hence removed) to the final stream file locations. Note that only stream file\n     * that are written with the {@link StreamDataFileConstants.Property.Key#UNI_TIMESTAMP} property set to\n     * {@link StreamDataFileConstants.Property.Value#CLOSE_TIMESTAMP} should be appended, although this method\n     * doesn't do explicit check (for performance reason).\n     *\n     * @param config configuration about the stream to append to\n     * @param eventFile location of the new event file\n     * @param indexFile location of the new index file\n     * @param timestamp close timestamp of the stream file\n     * @throws IOException if failed to append the file to the stream\n     */\n    void appendFile(StreamConfig config, Location eventFile, Location indexFile, long timestamp) throws IOException {\n      Integer generation = generations.get(config.getStreamId());\n      if (generation == null) {\n        generation = StreamUtils.getGeneration(config);\n      }\n\n      // Figure out the partition directory based on generation and timestamp\n      Location baseLocation = StreamUtils.createGenerationLocation(config.getLocation(), generation);\n      long partitionDuration = config.getPartitionDuration();\n      long partitionStartTime = StreamUtils.getPartitionStartTime(timestamp, partitionDuration);\n      Location partitionLocation = StreamUtils.createPartitionLocation(baseLocation,\n                                                                       partitionStartTime, partitionDuration);\n      partitionLocation.mkdirs();\n\n      // Figure out the final stream file name\n      String filePrefix = writerFactory.getFileNamePrefix();\n      int fileSequence = StreamUtils.getNextSequenceId(partitionLocation, filePrefix);\n\n      Location destEventFile = StreamUtils.createStreamLocation(partitionLocation, filePrefix,\n                                                            fileSequence, StreamFileType.EVENT);\n      Location destIndexFile = StreamUtils.createStreamLocation(partitionLocation, filePrefix,\n                                                            fileSequence, StreamFileType.INDEX);\n      // The creation should succeed, as it's expected to only have one process running per fileNamePrefix.\n      if (!destEventFile.createNew() || !destIndexFile.createNew()) {\n        throw new IOException(String.format(\"Failed to create new file at %s and %s\",\n                                            destEventFile.toURI(), destIndexFile.toURI()));\n      }\n\n      // Rename the index file first, then the event file\n      indexFile.renameTo(destIndexFile);\n      eventFile.renameTo(destEventFile);\n    }","id":91265,"modified_method":"/**\n     * Appends a stream file to the given stream. When this method completed successfully, the given event and index\n     * file locations will be renamed (hence removed) to the final stream file locations. Note that only stream file\n     * that are written with the {@link StreamDataFileConstants.Property.Key#UNI_TIMESTAMP} property set to\n     * {@link StreamDataFileConstants.Property.Value#CLOSE_TIMESTAMP} should be appended, although this method\n     * doesn't do explicit check (for performance reason).\n     *\n     * @param config configuration about the stream to append to\n     * @param eventFile location of the new event file\n     * @param indexFile location of the new index file\n     * @param timestamp close timestamp of the stream file\n     * @throws IOException if failed to append the file to the stream\n     */\n    void appendFile(StreamConfig config, Location eventFile, Location indexFile, long timestamp) throws IOException {\n      int generation = StreamUtils.getGeneration(config);\n\n      // Figure out the partition directory based on generation and timestamp\n      Location baseLocation = StreamUtils.createGenerationLocation(config.getLocation(), generation);\n      long partitionDuration = config.getPartitionDuration();\n      long partitionStartTime = StreamUtils.getPartitionStartTime(timestamp, partitionDuration);\n      Location partitionLocation = StreamUtils.createPartitionLocation(baseLocation,\n                                                                       partitionStartTime, partitionDuration);\n      partitionLocation.mkdirs();\n\n      // Figure out the final stream file name\n      String filePrefix = writerFactory.getFileNamePrefix();\n      int fileSequence = StreamUtils.getNextSequenceId(partitionLocation, filePrefix);\n\n      Location destEventFile = StreamUtils.createStreamLocation(partitionLocation, filePrefix,\n                                                            fileSequence, StreamFileType.EVENT);\n      Location destIndexFile = StreamUtils.createStreamLocation(partitionLocation, filePrefix,\n                                                            fileSequence, StreamFileType.INDEX);\n      // The creation should succeed, as it's expected to only have one process running per fileNamePrefix.\n      if (!destEventFile.createNew() || !destIndexFile.createNew()) {\n        throw new IOException(String.format(\"Failed to create new file at %s and %s\",\n                                            destEventFile.toURI(), destIndexFile.toURI()));\n      }\n\n      // Rename the index file first, then the event file\n      indexFile.renameTo(destIndexFile);\n      eventFile.renameTo(destEventFile);\n    }","commit_id":"818acb3cecb98a3823711a73637107f224a9e8c1","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Creates a new {@link FileWriter} for the given stream.\n     *\n     * @param streamId identifier of the stream\n     * @return A {@link FileWriter} for writing {@link StreamEvent} to the given stream\n     * @throws IOException if failed to create the file writer\n     */\n    FileWriter<StreamEvent> create(Id.Stream streamId) throws IOException {\n      StreamConfig streamConfig = streamAdmin.getConfig(streamId);\n      Integer generation = generations.get(streamId);\n      if (generation == null) {\n        generation = StreamUtils.getGeneration(streamConfig);\n      }\n\n      LOG.info(\"Create stream writer for {} with generation {}\", streamId, generation);\n      return writerFactory.create(streamConfig, generation);\n    }","id":91266,"modified_method":"/**\n     * Creates a new {@link FileWriter} for the given stream.\n     *\n     * @param streamId identifier of the stream\n     * @return A {@link FileWriter} for writing {@link StreamEvent} to the given stream\n     * @throws IOException if failed to create the file writer\n     */\n    FileWriter<StreamEvent> create(Id.Stream streamId) throws IOException {\n      StreamConfig streamConfig = streamAdmin.getConfig(streamId);\n      int generation = StreamUtils.getGeneration(streamConfig);\n\n      LOG.info(\"Create stream writer for {} with generation {}\", streamId, generation);\n      return writerFactory.create(streamConfig, generation);\n    }","commit_id":"818acb3cecb98a3823711a73637107f224a9e8c1","url":"https://github.com/caskdata/cdap"},{"original_method":"private void doDrop(final Id.Stream streamId, final Location streamLocation) throws Exception {\n    streamCoordinatorClient.deleteStream(streamId, new Callable<Id.Stream>() {\n      @Override\n      public Id.Stream call() throws Exception {\n        Location configLocation = getConfigLocation(streamId);\n        if (configLocation.exists()) {\n          alterExploreStream(StreamUtils.getStreamIdFromLocation(streamLocation), false);\n          int newGeneration = StreamUtils.getGeneration(streamLocation) + 1;\n          Locations.mkdirsIfNotExists(StreamUtils.createGenerationLocation(streamLocation, newGeneration));\n          configLocation.delete();\n        }\n        return streamId;\n      }\n    });\n  }","id":91267,"modified_method":"private void doDrop(final Id.Stream streamId, final Location streamLocation) throws Exception {\n    streamCoordinatorClient.deleteStream(streamId, new Callable<CoordinatorStreamProperties>() {\n      @Override\n      public CoordinatorStreamProperties call() throws Exception {\n        Location configLocation = getConfigLocation(streamId);\n        if (!configLocation.exists()) {\n          return null;\n        }\n        alterExploreStream(StreamUtils.getStreamIdFromLocation(streamLocation), false);\n        configLocation.delete();\n        int newGeneration = StreamUtils.getGeneration(streamLocation) + 1;\n        Locations.mkdirsIfNotExists(StreamUtils.createGenerationLocation(streamLocation, newGeneration));\n        return new CoordinatorStreamProperties(null, null, null, newGeneration);\n      }\n    });\n  }","commit_id":"818acb3cecb98a3823711a73637107f224a9e8c1","url":"https://github.com/caskdata/cdap"},{"original_method":"private void assertNamespaceHomeExists(Id.Namespace namespaceId) throws IOException {\n    Location namespaceHomeLocation = Locations.getParent(getNamespaceLocation(namespaceId));\n    Preconditions.checkArgument(namespaceHomeLocation == null || namespaceHomeLocation.exists(),\n                                \"Home directory %s for namespace %s not found\", namespaceHomeLocation, namespaceId);\n  }","id":91268,"modified_method":"private void assertNamespaceHomeExists(Id.Namespace namespaceId) throws IOException {\n    Location namespaceHomeLocation = Locations.getParent(getNamespaceLocation(namespaceId));\n    Preconditions.checkArgument(namespaceHomeLocation != null && namespaceHomeLocation.exists(),\n                                \"Home directory %s for namespace %s not found\", namespaceHomeLocation, namespaceId);\n  }","commit_id":"818acb3cecb98a3823711a73637107f224a9e8c1","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void init() throws Exception {\n    InMemoryZKServer zkServer = InMemoryZKServer.builder().setDataDir(tmpFolder.newFolder()).build();\n    zkServer.startAndWait();\n\n    testHBase = new HBaseTestFactory().get();\n    testHBase.startHBase();\n\n    Configuration hConf = testHBase.getConfiguration();\n\n    CConfiguration cConf = CConfiguration.create();\n    cConf.setInt(Constants.Stream.CONTAINER_INSTANCES, 1);\n    cConf.set(Constants.CFG_LOCAL_DATA_DIR, tmpFolder.newFolder().getAbsolutePath());\n    cConf.set(Constants.Zookeeper.QUORUM, zkServer.getConnectionStr());\n\n    Injector injector = Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new ZKClientModule(),\n      new LocationRuntimeModule().getInMemoryModules(),\n      new DiscoveryRuntimeModule().getInMemoryModules(),\n      new TransactionMetricsModule(),\n      new DataSetsModules().getInMemoryModules(),\n      new SystemDatasetRuntimeModule().getInMemoryModules(),\n      Modules.override(new DataFabricDistributedModule(), new StreamAdminModules().getDistributedModules())\n        .with(new AbstractModule() {\n          @Override\n          protected void configure() {\n            bind(TransactionStateStorage.class).to(NoOpTransactionStateStorage.class);\n            bind(TransactionSystemClient.class).to(InMemoryTxSystemClient.class).in(Singleton.class);\n            bind(StreamMetaStore.class).to(InMemoryStreamMetaStore.class);\n            bind(NotificationFeedManager.class).to(NoOpNotificationFeedManager.class);\n          }\n        })\n    );\n    ZKClientService zkClientService = injector.getInstance(ZKClientService.class);\n    zkClientService.startAndWait();\n\n    streamAdmin = injector.getInstance(StreamAdmin.class);\n    txManager = injector.getInstance(TransactionManager.class);\n    fileWriterFactory = injector.getInstance(StreamFileWriterFactory.class);\n\n    setupNamespaces(injector.getInstance(LocationFactory.class));\n    txManager.startAndWait();\n  }","id":91269,"modified_method":"@BeforeClass\n  public static void init() throws Exception {\n    InMemoryZKServer zkServer = InMemoryZKServer.builder().setDataDir(tmpFolder.newFolder()).build();\n    zkServer.startAndWait();\n\n    testHBase = new HBaseTestFactory().get();\n    testHBase.startHBase();\n\n    Configuration hConf = testHBase.getConfiguration();\n\n    CConfiguration cConf = CConfiguration.create();\n    cConf.setInt(Constants.Stream.CONTAINER_INSTANCES, 1);\n    cConf.set(Constants.CFG_LOCAL_DATA_DIR, tmpFolder.newFolder().getAbsolutePath());\n    cConf.set(Constants.Zookeeper.QUORUM, zkServer.getConnectionStr());\n\n    Injector injector = Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new ZKClientModule(),\n      new LocationRuntimeModule().getInMemoryModules(),\n      new DiscoveryRuntimeModule().getInMemoryModules(),\n      new TransactionMetricsModule(),\n      new DataSetsModules().getInMemoryModules(),\n      new SystemDatasetRuntimeModule().getInMemoryModules(),\n      Modules.override(new DataFabricDistributedModule(), new StreamAdminModules().getDistributedModules())\n        .with(new AbstractModule() {\n          @Override\n          protected void configure() {\n            bind(TransactionStateStorage.class).to(NoOpTransactionStateStorage.class);\n            bind(TransactionSystemClient.class).to(InMemoryTxSystemClient.class).in(Singleton.class);\n            bind(StreamMetaStore.class).to(InMemoryStreamMetaStore.class);\n            bind(NotificationFeedManager.class).to(NoOpNotificationFeedManager.class);\n          }\n        })\n    );\n    ZKClientService zkClientService = injector.getInstance(ZKClientService.class);\n    zkClientService.startAndWait();\n\n    streamAdmin = injector.getInstance(StreamAdmin.class);\n    txManager = injector.getInstance(TransactionManager.class);\n    fileWriterFactory = injector.getInstance(StreamFileWriterFactory.class);\n    streamCoordinatorClient = injector.getInstance(StreamCoordinatorClient.class);\n\n    setupNamespaces(injector.getInstance(LocationFactory.class));\n    txManager.startAndWait();\n    streamCoordinatorClient.startAndWait();\n  }","commit_id":"818acb3cecb98a3823711a73637107f224a9e8c1","url":"https://github.com/caskdata/cdap"},{"original_method":"@AfterClass\n  public static void finish() throws Exception {\n    txManager.stopAndWait();\n    testHBase.stopHBase();\n  }","id":91270,"modified_method":"@AfterClass\n  public static void finish() throws Exception {\n    streamCoordinatorClient.stopAndWait();\n    txManager.stopAndWait();\n    testHBase.stopHBase();\n  }","commit_id":"818acb3cecb98a3823711a73637107f224a9e8c1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ListenableFuture<Integer> nextGeneration(final StreamConfig streamConfig, final int lowerBound) {\n    return Futures.transform(propertyStore.get().update(streamConfig.getName(), new PropertyUpdater<StreamProperty>() {\n      @Override\n      public ListenableFuture<StreamProperty> apply(@Nullable final StreamProperty property) {\n        final SettableFuture<StreamProperty> resultFuture = SettableFuture.create();\n        updateExecutor.execute(new Runnable() {\n\n          @Override\n          public void run() {\n            try {\n              int newGeneration = ((property == null) ? lowerBound : property.getGeneration()) + 1;\n              // Create the generation directory\n              Locations.mkdirsIfNotExists(StreamUtils.createGenerationLocation(streamConfig.getLocation(),\n                                                                               newGeneration));\n              resultFuture.set(new StreamProperty(newGeneration));\n            } catch (IOException e) {\n              resultFuture.setException(e);\n            }\n          }\n        });\n        return resultFuture;\n      }\n    }), new Function<StreamProperty, Integer>() {\n      @Override\n      public Integer apply(StreamProperty property) {\n        return property.getGeneration();\n      }\n    });\n  }","id":91271,"modified_method":"@Override\n  public ListenableFuture<Integer> nextGeneration(final StreamConfig streamConfig, final int lowerBound) {\n    return Futures.transform(propertyStore.get().update(streamConfig.getName(), new PropertyUpdater<StreamProperty>() {\n      @Override\n      public ListenableFuture<StreamProperty> apply(@Nullable final StreamProperty property) {\n        final SettableFuture<StreamProperty> resultFuture = SettableFuture.create();\n        updateExecutor.execute(new Runnable() {\n\n          @Override\n          public void run() {\n            try {\n              int newGeneration = ((property == null) ? lowerBound : property.getGeneration()) + 1;\n              // Create the generation directory\n              Locations.mkdirsIfNotExists(StreamUtils.createGenerationLocation(streamConfig.getLocation(),\n                                                                               newGeneration));\n              resultFuture.set(new StreamProperty(newGeneration, null));\n            } catch (IOException e) {\n              resultFuture.setException(e);\n            }\n          }\n        });\n        return resultFuture;\n      }\n    }), new Function<StreamProperty, Integer>() {\n      @Override\n      public Integer apply(StreamProperty property) {\n        return property.getGeneration();\n      }\n    });\n  }","commit_id":"6a22207340f180f6488767f60a4657331e9fc782","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void generationDeleted(String streamName) {\n      try {\n        listener.generationDeleted(streamName);\n      } catch (Throwable t) {\n        LOG.error(\"Exception while calling StreamPropertyListener\", t);\n      }\n    }","id":91272,"modified_method":"@Override\n    public void generationDeleted(String streamName) {\n      try {\n        listener.generationDeleted(streamName);\n      } catch (Throwable t) {\n        LOG.error(\"Exception while calling StreamPropertyListener.generationDeleted\", t);\n      }\n    }","commit_id":"6a22207340f180f6488767f60a4657331e9fc782","url":"https://github.com/caskdata/cdap"},{"original_method":"private StreamPropertyChangeListener(StreamPropertyListener listener) {\n      this.listener = listener;\n    }","id":91273,"modified_method":"private StreamPropertyChangeListener(StreamPropertyListener listener) {\n      this.listener = listener;\n      this.currentProperty = new StreamProperty(null, null);\n    }","commit_id":"6a22207340f180f6488767f60a4657331e9fc782","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void onChange(String name, StreamProperty property) {\n      try {\n        if (property == null) {\n          // Property is deleted\n          if (currentProperty != null) {\n            // Fire all delete events\n            generationDeleted(name);\n          }\n          return;\n        }\n\n        if (currentProperty == null) {\n          // Fire all events\n          generationChanged(name, property.getGeneration());\n          return;\n        }\n\n        // Inspect individual stream property to determine what needs to be fired\n        if (currentProperty.getGeneration() < property.getGeneration()) {\n          generationChanged(name, property.getGeneration());\n        }\n      } finally {\n        currentProperty = property;\n      }\n    }","id":91274,"modified_method":"@Override\n    public void onChange(String name, StreamProperty newProperty) {\n      try {\n        if (newProperty == null) {\n          generationDeleted(name);\n          return;\n        }\n\n        Integer currGeneration = currentProperty.getGeneration();\n        Long currTTL = currentProperty.getTTL();\n\n        Integer newGeneration = newProperty.getGeneration();\n        Long newTTL = newProperty.getTTL();\n\n        if (newGeneration != null) {\n          if (currGeneration == null || currGeneration < newGeneration) {\n            generationChanged(name, newGeneration);\n          }\n        }\n\n        if (newTTL != null) {\n          if (currTTL == null || !currTTL.equals(newTTL)) {\n            ttlChanged(name, newTTL);\n          }\n        }\n      } finally {\n        currentProperty = newProperty;\n      }\n    }","commit_id":"6a22207340f180f6488767f60a4657331e9fc782","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void generationChanged(String streamName, int generation) {\n      try {\n        listener.generationChanged(streamName, generation);\n      } catch (Throwable t) {\n        LOG.error(\"Exception while calling StreamPropertyListener\", t);\n      }\n    }","id":91275,"modified_method":"@Override\n    public void generationChanged(String streamName, int generation) {\n      try {\n        listener.generationChanged(streamName, generation);\n      } catch (Throwable t) {\n        LOG.error(\"Exception while calling StreamPropertyListener.generationChanged\", t);\n      }\n    }","commit_id":"6a22207340f180f6488767f60a4657331e9fc782","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public String toString() {\n      return Objects.toStringHelper(this)\n        .add(\"generation\", generation)\n        .toString();\n    }","id":91276,"modified_method":"@Override\n    public String toString() {\n      return Objects.toStringHelper(this)\n        .add(\"generation\", generation)\n        .add(\"ttl\", ttl)\n        .toString();\n    }","commit_id":"6a22207340f180f6488767f60a4657331e9fc782","url":"https://github.com/caskdata/cdap"},{"original_method":"public int getGeneration() {\n      return generation;\n    }","id":91277,"modified_method":"public @Nullable Integer getGeneration() {\n      return generation;\n    }","commit_id":"6a22207340f180f6488767f60a4657331e9fc782","url":"https://github.com/caskdata/cdap"},{"original_method":"private StreamProperty(int generation) {\n      this.generation = generation;\n    }","id":91278,"modified_method":"private StreamProperty(@Nullable Integer generation, @Nullable Long ttl) {\n      this.generation = generation;\n      this.ttl = ttl;\n    }","commit_id":"6a22207340f180f6488767f60a4657331e9fc782","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void updateConfig(String streamName, StreamConfig config) throws IOException {\n    Location streamLocation = streamBaseLocation.append(streamName);\n    Preconditions.checkArgument(streamLocation.isDirectory(), \"Stream '{}' not exists.\", streamName);\n\n    StreamConfig originalConfig = loadConfig(streamLocation);\n    Preconditions.checkArgument(isValidConfigUpdate(originalConfig, config),\n                                \"Configuration update for stream '{}' was not valid (can only update ttl)\", streamName);\n\n    Location configLocation = streamLocation.append(CONFIG_FILE_NAME);\n    Location tempLocation = configLocation.getTempFile(\"tmp\");\n    try {\n      CharStreams.write(GSON.toJson(config), CharStreams.newWriterSupplier(\n        Locations.newOutputSupplier(tempLocation), Charsets.UTF_8));\n\n      Preconditions.checkState(tempLocation.renameTo(configLocation) != null,\n                               \"Rename {} to {} failed\", tempLocation, configLocation);\n    } finally {\n      if (tempLocation.exists()) {\n        tempLocation.delete();\n      }\n    }\n  }","id":91279,"modified_method":"@Override\n  public void updateConfig(String streamName, StreamConfig config) throws IOException {\n    Location streamLocation = streamBaseLocation.append(streamName);\n    Preconditions.checkArgument(streamLocation.isDirectory(), \"Stream '{}' not exists.\", streamName);\n\n    StreamConfig originalConfig = loadConfig(streamLocation);\n    Preconditions.checkArgument(isValidConfigUpdate(originalConfig, config),\n                                \"Configuration update for stream '{}' was not valid (can only update ttl)\", streamName);\n\n    Location configLocation = streamLocation.append(CONFIG_FILE_NAME);\n    Location tempLocation = configLocation.getTempFile(\"tmp\");\n    try {\n      CharStreams.write(GSON.toJson(config), CharStreams.newWriterSupplier(\n        Locations.newOutputSupplier(tempLocation), Charsets.UTF_8));\n\n      Preconditions.checkState(tempLocation.renameTo(configLocation) != null,\n                               \"Rename {} to {} failed\", tempLocation, configLocation);\n    } finally {\n      if (tempLocation.exists()) {\n        tempLocation.delete();\n      }\n    }\n\n    if (originalConfig.getTTL() != config.getTTL()) {\n      streamCoordinator.changeTTL(config, config.getTTL());\n    }\n  }","commit_id":"6a22207340f180f6488767f60a4657331e9fc782","url":"https://github.com/caskdata/cdap"},{"original_method":"private FlowletServiceHook(final String flowletName, StreamCoordinator streamCoordinator, List<String> streams,\n                               AtomicReference<FlowletProgramController> controller) {\n      this.streamCoordinator = streamCoordinator;\n      this.streams = streams;\n      this.controller = controller;\n      this.executor = ExecutorUtils.newThreadExecutor(Threads.createDaemonThreadFactory(\"flowlet-stream-update-%d\"));\n      this.propertyListener = new StreamPropertyListener() {\n        @Override\n        public void generationChanged(String streamName, int generation) {\n          LOG.debug(\"Generation for stream '{}' changed to {} for flowlet '{}'\", streamName, generation, flowletName);\n          suspendAndResume();\n        }\n\n        @Override\n        public void generationDeleted(String streamName) {\n          LOG.debug(\"Generation for stream '{}' deleted for flowlet '{}'\", streamName, flowletName);\n          suspendAndResume();\n        }\n      };\n    }","id":91280,"modified_method":"private FlowletServiceHook(final String flowletName, StreamCoordinator streamCoordinator, List<String> streams,\n                               AtomicReference<FlowletProgramController> controller) {\n      this.streamCoordinator = streamCoordinator;\n      this.streams = streams;\n      this.controller = controller;\n      this.executor = ExecutorUtils.newThreadExecutor(Threads.createDaemonThreadFactory(\"flowlet-stream-update-%d\"));\n      this.propertyListener = new StreamPropertyListener() {\n        @Override\n        public void ttlChanged(String streamName, long ttl) {\n          LOG.debug(\"TTL for stream '{}' changed to {} for flowlet '{}'\", streamName, ttl, flowletName);\n          suspendAndResume();\n        }\n\n        @Override\n        public void generationChanged(String streamName, int generation) {\n          LOG.debug(\"Generation for stream '{}' changed to {} for flowlet '{}'\", streamName, generation, flowletName);\n          suspendAndResume();\n        }\n\n        @Override\n        public void generationDeleted(String streamName) {\n          LOG.debug(\"Generation for stream '{}' deleted for flowlet '{}'\", streamName, flowletName);\n          suspendAndResume();\n        }\n      };\n    }","commit_id":"6a22207340f180f6488767f60a4657331e9fc782","url":"https://github.com/caskdata/cdap"},{"original_method":"private static void restoreInstance( final String cluster, final VmInfo runVm ) {\n    try {\n      String instanceId = runVm.getInstanceId( );\n      String reservationId = runVm.getReservationId( );\n      String ownerId = runVm.getOwnerId( );\n      String placement = cluster;\n      String userData = runVm.getUserData( );\n      Integer launchIndex = 0;\n      try {\n        launchIndex = Integer.parseInt( runVm.getLaunchIndex( ) );\n      } catch ( NumberFormatException e ) {}\n      \n      VmImageInfo imgInfo = null;\n      //FIXME: really need to populate these asynchronously for multi-cluster/split component... \n      try {\n        imgInfo = ( VmImageInfo ) Messaging.send( \"vm://ImageResolve\", runVm );\n      } catch ( EucalyptusCloudException e ) {\n        imgInfo = new VmImageInfo( runVm.getImageId( ), runVm.getKernelId( ), runVm.getRamdiskId( ), null, null, null, null );\n      }\n      VmKeyInfo keyInfo = null;\n      try {\n        keyInfo = ( VmKeyInfo ) Messaging.send( \"vm://KeyPairResolve\", runVm );\n      } catch ( EucalyptusCloudException e ) {\n        keyInfo = new VmKeyInfo( \"unknown\", runVm.getKeyValue( ), null );\n      }\n      VmTypeInfo vmType = runVm.getInstanceType( );\n      List<Network> networks = new ArrayList<Network>( );\n      \n      for ( String netName : runVm.getGroupNames( ) ) {\n        Network notwork = null;\n        try {\n          notwork = Networks.getInstance( ).lookup( runVm.getOwnerId( ) + \"-\" + netName );\n          networks.add( notwork );\n          try {\n            NetworkToken netToken = Clusters.getInstance( ).lookup( runVm.getPlacement( ) ).getState( ).extantAllocation( runVm.getOwnerId( ), netName,\n                                                                                                                          runVm.getNetParams( ).getVlan( ) );\n            notwork.addTokenIfAbsent( netToken );\n          } catch ( NetworkAlreadyExistsException e ) {\n            LOG.trace( e );\n          }\n          notwork.extantNetworkIndex( runVm.getPlacement( ), runVm.getNetParams( ).getNetworkIndex( ) );\n        } catch ( NoSuchElementException e1 ) {\n          try {\n            notwork = SystemState.getUserNetwork( runVm.getOwnerId( ), netName );\n            networks.add( notwork );\n            NetworkToken netToken = Clusters.getInstance( ).lookup( runVm.getPlacement( ) ).getState( ).extantAllocation( runVm.getOwnerId( ), netName,\n                                                                                                                          runVm.getNetParams( ).getVlan( ) );\n            notwork.addTokenIfAbsent( netToken );\n            Networks.getInstance( ).registerIfAbsent( notwork, Networks.State.ACTIVE );\n          } catch ( EucalyptusCloudException e ) {\n            LOG.error( e );\n            ClusterConfiguration config = Clusters.getInstance( ).lookup( runVm.getPlacement( ) ).getConfiguration( );\n            new TerminateCallback( runVm.getInstanceId( ) ).dispatch( runVm.getPlacement( ) );\n          } catch ( NetworkAlreadyExistsException e ) {\n            LOG.trace( e );\n          }\n        }\n      }\n      VmInstance vm = new VmInstance( reservationId, launchIndex, instanceId, ownerId, placement, Base64.decode( userData ), imgInfo, keyInfo, vmType, networks,\n                                      Integer.toString( runVm.getNetParams( ).getNetworkIndex( ) ) );\n      vm.clearPending( );\n      vm.setLaunchTime( runVm.getLaunchTime( ) );\n      vm.updatePublicAddress( VmInstance.DEFAULT_IP );\n      vm.setKeyInfo( keyInfo );\n      vm.setImageInfo( imgInfo );\n      VmInstances.getInstance( ).register( vm );\n    } catch ( NoSuchElementException e ) {\n      ClusterConfiguration config = Clusters.getInstance( ).lookup( runVm.getPlacement( ) ).getConfiguration( );\n      new TerminateCallback( runVm.getInstanceId( ) ).dispatch( runVm.getPlacement( ) );\n    }\n  }","id":91281,"modified_method":"private static void restoreInstance( final String cluster, final VmInfo runVm ) {\n    try {\n      String instanceId = runVm.getInstanceId( );\n      String reservationId = runVm.getReservationId( );\n      String ownerId = runVm.getOwnerId( );\n      String placement = cluster;\n      String userData = runVm.getUserData( );\n      Integer launchIndex = 0;\n      try {\n        launchIndex = Integer.parseInt( runVm.getLaunchIndex( ) );\n      } catch ( NumberFormatException e ) {}\n      \n      VmImageInfo imgInfo = null;\n      //FIXME: really need to populate these asynchronously for multi-cluster/split component... \n      try {\n        imgInfo = resolveImage( runVm );\n      } catch ( EucalyptusCloudException e ) {\n        imgInfo = new VmImageInfo( runVm.getImageId( ), runVm.getKernelId( ), runVm.getRamdiskId( ), null, null, null, null );\n      }\n      VmKeyInfo keyInfo = null;\n      SshKeyPair key = null;\n      if ( runVm.getKeyValue( ) != null || !\"\".equals( runVm.getKeyValue( ) ) ) {\n        try {\n          EntityWrapper<SshKeyPair> db = EntityWrapper.get( SshKeyPair.class );\n          try {\n            SshKeyPair searchKey = new SshKeyPair( runVm.getOwnerId( ) ) {\n              {\n                setPublicKey( runVm.getKeyValue( ) );\n              }\n            };\n            key = db.getUnique( searchKey );\n            db.commit( );\n          } catch ( Throwable e ) {\n            db.rollback( );\n            throw new EucalyptusCloudException( \"Failed to find key pair associated with public key \" + runVm.getKeyValue( ), e );\n          }\n        } catch ( Throwable e ) {\n          key = SshKeyPair.NO_KEY;\n        }\n      } else {\n        key = SshKeyPair.NO_KEY;\n      }\n      keyInfo = new VmKeyInfo( key.getDisplayName( ), key.getPublicKey( ), key.getFingerPrint( ) );\n      VmTypeInfo vmType = runVm.getInstanceType( );\n      List<Network> networks = new ArrayList<Network>( );\n      \n      for ( String netName : runVm.getGroupNames( ) ) {\n        Network notwork = null;\n        try {\n          notwork = Networks.getInstance( ).lookup( runVm.getOwnerId( ) + \"-\" + netName );\n          networks.add( notwork );\n          try {\n            NetworkToken netToken = Clusters.getInstance( ).lookup( runVm.getPlacement( ) ).getState( ).extantAllocation( runVm.getOwnerId( ), netName,\n                                                                                                                          runVm.getNetParams( ).getVlan( ) );\n            notwork.addTokenIfAbsent( netToken );\n          } catch ( NetworkAlreadyExistsException e ) {\n            LOG.trace( e );\n          }\n          notwork.extantNetworkIndex( runVm.getPlacement( ), runVm.getNetParams( ).getNetworkIndex( ) );\n        } catch ( NoSuchElementException e1 ) {\n          try {\n            notwork = SystemState.getUserNetwork( runVm.getOwnerId( ), netName );\n            networks.add( notwork );\n            NetworkToken netToken = Clusters.getInstance( ).lookup( runVm.getPlacement( ) ).getState( ).extantAllocation( runVm.getOwnerId( ), netName,\n                                                                                                                          runVm.getNetParams( ).getVlan( ) );\n            notwork.addTokenIfAbsent( netToken );\n            Networks.getInstance( ).registerIfAbsent( notwork, Networks.State.ACTIVE );\n          } catch ( EucalyptusCloudException e ) {\n            LOG.error( e );\n            ClusterConfiguration config = Clusters.getInstance( ).lookup( runVm.getPlacement( ) ).getConfiguration( );\n            new TerminateCallback( runVm.getInstanceId( ) ).dispatch( runVm.getPlacement( ) );\n          } catch ( NetworkAlreadyExistsException e ) {\n            LOG.trace( e );\n          }\n        }\n      }\n      VmInstance vm = new VmInstance( reservationId, launchIndex, instanceId, ownerId, placement, Base64.decode( userData ), imgInfo, keyInfo, vmType, networks,\n                                      Integer.toString( runVm.getNetParams( ).getNetworkIndex( ) ) );\n      vm.clearPending( );\n      vm.setLaunchTime( runVm.getLaunchTime( ) );\n      vm.updatePublicAddress( VmInstance.DEFAULT_IP );\n      vm.setKeyInfo( keyInfo );\n      vm.setImageInfo( imgInfo );\n      VmInstances.getInstance( ).register( vm );\n    } catch ( NoSuchElementException e ) {\n      ClusterConfiguration config = Clusters.getInstance( ).lookup( runVm.getPlacement( ) ).getConfiguration( );\n      new TerminateCallback( runVm.getInstanceId( ) ).dispatch( runVm.getPlacement( ) );\n    } catch ( Throwable t ) {\n      LOG.error( t, t );\n    }\n  }","commit_id":"9ee5ce0365b006bf758d9d9fa0086f3fe6406f2b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public List<UpdateRequest> normalize(ActiveRuleKey key) {\n    DbSession dbSession = db.openSession(false);\n    List<UpdateRequest> requests = new ArrayList<UpdateRequest>();\n    try {\n      requests.addAll(normalize(db.activeRuleDao().getNullableByKey(dbSession, key)));\n      for (ActiveRuleParamDto param : db.activeRuleDao().findParamsByActiveRuleKey(dbSession, key)) {\n        requests.addAll(normalizeNested(param, key));\n      }\n    } finally {\n      dbSession.close();\n    }\n    return requests;\n  }","id":91282,"modified_method":"@Override\n  public List<UpdateRequest> normalize(ActiveRuleKey key) {\n    DbSession dbSession = db.openSession(false);\n    List<UpdateRequest> requests = new ArrayList<UpdateRequest>();\n    try {\n      ActiveRuleDto activeRule = db.activeRuleDao().getByKey(dbSession, key);\n      requests.addAll(normalize(activeRule));\n      for (ActiveRuleParamDto param : db.activeRuleDao().findParamsByActiveRuleKey(dbSession, key)) {\n        requests.addAll(normalizeNested(param, key));\n      }\n    } finally {\n      dbSession.close();\n    }\n    return requests;\n  }","commit_id":"87b720fbd3f2369694fcfe2ecc8886be8eba92eb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void deleteByDto(DTO item, DTO... items) {\n    try {\n      this.deleteDocument(item.getKey());\n      for (DTO additionalItem : items) {\n        this.deleteDocument(additionalItem.getKey());\n      }\n    } catch (Exception e) {\n      LOG.error(\"Could not DELETE _id:{} for index {}: {}\",\n        this.getKeyValue(item.getKey()), this.getIndexName(), e.getMessage());\n    }\n  }","id":91283,"modified_method":"@Override\n  public void deleteByDto(DTO item, DTO... items) {\n    try {\n      this.deleteDocument(item.getKey());\n      for (DTO additionalItem : items) {\n        this.deleteDocument(additionalItem.getKey());\n      }\n    } catch (Exception e) {\n      throw new IllegalStateException(\"Could not DELETE _id = '\" + this.getKeyValue(item.getKey()) + \"' \" +\n        \"for index '\" + this.getIndexName() + \"': \" + e.getMessage());\n    }\n  }","commit_id":"87b720fbd3f2369694fcfe2ecc8886be8eba92eb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void deleteByKey(KEY key, KEY... keys) {\n    try {\n      this.deleteDocument(key);\n      for (KEY additionalKey : keys) {\n        this.deleteDocument(additionalKey);\n      }\n    } catch (Exception e) {\n      LOG.error(\"Could not DELETE _id = '{}' for index '{}': {}\",\n        this.getKeyValue(key), this.getIndexName(), e.getMessage());\n    }\n  }","id":91284,"modified_method":"@Override\n  public void deleteByKey(KEY key, KEY... keys) {\n    try {\n      this.deleteDocument(key);\n      for (KEY additionalKey : keys) {\n        this.deleteDocument(additionalKey);\n      }\n    } catch (Exception e) {\n      throw new IllegalStateException(\"Could not DELETE _id = '\" + this.getKeyValue(key) + \"' \" +\n        \"for index '\" + this.getIndexName() + \"': \" + e.getMessage());\n    }\n  }","commit_id":"87b720fbd3f2369694fcfe2ecc8886be8eba92eb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected Multimap<String, FacetValue> processAggregations(Aggregations aggregations) {\n    Multimap<String, FacetValue> stats = ArrayListMultimap.create();\n    if (aggregations != null) {\n      for (Aggregation aggregation : aggregations.asList()) {\n        if (aggregation.getClass().isAssignableFrom(StringTerms.class)) {\n          for (Terms.Bucket value : ((Terms) aggregation).getBuckets()) {\n\n            FacetValue facetValue = new FacetValue(value.getKey(), (int) value.getDocCount());\n            facetValue.setSubFacets(processAggregations(value.getAggregations()));\n            stats.put(aggregation.getName(), facetValue);\n          }\n        } else if (aggregation.getClass().isAssignableFrom(InternalValueCount.class)) {\n          InternalValueCount count = ((InternalValueCount) aggregation);\n          FacetValue facetValue = new FacetValue(count.getName(), (int) count.getValue());\n          stats.put(count.getName(), facetValue);\n        }\n      }\n    }\n    return stats;\n  }","id":91285,"modified_method":"protected Multimap<String, FacetValue> processAggregations(Aggregations aggregations) {\n    Multimap<String, FacetValue> stats = ArrayListMultimap.create();\n    if (aggregations != null) {\n      for (Aggregation aggregation : aggregations.asList()) {\n        if (aggregation.getClass().isAssignableFrom(StringTerms.class)) {\n          for (Terms.Bucket value : ((Terms) aggregation).getBuckets()) {\n\n            FacetValue facetValue = new FacetValue(value.getKey(), (int) value.getDocCount());\n            facetValue.setSubFacets(processAggregations(value.getAggregations()));\n            stats.put(aggregation.getName(), facetValue);\n          }\n        } else if (aggregation.getClass().isAssignableFrom(InternalValueCount.class)) {\n          InternalValueCount count = (InternalValueCount) aggregation;\n          FacetValue facetValue = new FacetValue(count.getName(), (int) count.getValue());\n          stats.put(count.getName(), facetValue);\n        }\n      }\n    }\n    return stats;\n  }","commit_id":"87b720fbd3f2369694fcfe2ecc8886be8eba92eb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected QueryBuilder getQuery(RuleQuery query, QueryOptions options) {\n\n    // No contextual query case\n    if (query.getQueryText() == null || query.getQueryText().isEmpty()) {\n      return QueryBuilders.matchAllQuery();\n    }\n\n    // Build RuleBased contextual query\n    BoolQueryBuilder qb = QueryBuilders.boolQuery();\n    String queryString = query.getQueryText();\n\n    // Human readable type of querying\n    qb.should(QueryBuilders.queryString(query.getQueryText())\n      .field(RuleNormalizer.RuleField.NAME.field() + \".\" + IndexField.SEARCH_WORDS_SUFFIX, 20f)\n      .field(RuleNormalizer.RuleField.HTML_DESCRIPTION.field() + \".\" + IndexField.SEARCH_WORDS_SUFFIX, 3f)\n      .enablePositionIncrements(true)\n      .defaultOperator(QueryStringQueryBuilder.Operator.AND)\n      .fuzziness(Fuzziness.ONE)\n      .autoGeneratePhraseQueries(true)\n      .lenient(false)\n      .useDisMax(true)\n      .boost(20f));\n\n    // Match and partial Match queries\n    qb.should(this.termQuery(RuleNormalizer.RuleField.KEY, queryString, 15f));\n    qb.should(this.termQuery(RuleNormalizer.RuleField._KEY, queryString, 35f));\n    qb.should(this.termQuery(RuleNormalizer.RuleField.LANGUAGE, queryString, 3f));\n    qb.should(this.termQuery(RuleNormalizer.RuleField.CHARACTERISTIC, queryString, 5f));\n    qb.should(this.termQuery(RuleNormalizer.RuleField.SUB_CHARACTERISTIC, queryString, 5f));\n    qb.should(this.termQuery(RuleNormalizer.RuleField._TAGS, queryString, 10f));\n    qb.should(this.termAnyQuery(RuleNormalizer.RuleField.CHARACTERISTIC, queryString, 1f));\n    qb.should(this.termAnyQuery(RuleNormalizer.RuleField.SUB_CHARACTERISTIC, queryString, 1f));\n    qb.should(this.termAnyQuery(RuleNormalizer.RuleField._TAGS, queryString, 1f));\n\n    return qb;\n  }","id":91286,"modified_method":"protected QueryBuilder getQuery(RuleQuery query, QueryOptions options) {\n\n    // No contextual query case\n    String queryText = query.getQueryText();\n    if (query.getQueryText() == null || query.getQueryText().isEmpty()) {\n      return QueryBuilders.matchAllQuery();\n    }\n\n    // Build RuleBased contextual query\n    BoolQueryBuilder qb = QueryBuilders.boolQuery();\n    String queryString = query.getQueryText();\n\n    // Human readable type of querying\n    qb.should(QueryBuilders.queryString(query.getQueryText())\n      .field(RuleNormalizer.RuleField.NAME.field() + \".\" + IndexField.SEARCH_WORDS_SUFFIX, 20f)\n      .field(RuleNormalizer.RuleField.HTML_DESCRIPTION.field() + \".\" + IndexField.SEARCH_WORDS_SUFFIX, 3f)\n      .enablePositionIncrements(true)\n      .defaultOperator(QueryStringQueryBuilder.Operator.AND)\n      .fuzziness(Fuzziness.ONE)\n      .autoGeneratePhraseQueries(true)\n      .lenient(false)\n      .useDisMax(true)\n      .boost(20f));\n\n    // Match and partial Match queries\n    qb.should(this.termQuery(RuleNormalizer.RuleField.KEY, queryString, 15f));\n    qb.should(this.termQuery(RuleNormalizer.RuleField._KEY, queryString, 35f));\n    qb.should(this.termQuery(RuleNormalizer.RuleField.LANGUAGE, queryString, 3f));\n    qb.should(this.termQuery(RuleNormalizer.RuleField.CHARACTERISTIC, queryString, 5f));\n    qb.should(this.termQuery(RuleNormalizer.RuleField.SUB_CHARACTERISTIC, queryString, 5f));\n    qb.should(this.termQuery(RuleNormalizer.RuleField._TAGS, queryString, 10f));\n    qb.should(this.termAnyQuery(RuleNormalizer.RuleField.CHARACTERISTIC, queryString, 1f));\n    qb.should(this.termAnyQuery(RuleNormalizer.RuleField.SUB_CHARACTERISTIC, queryString, 1f));\n    qb.should(this.termAnyQuery(RuleNormalizer.RuleField._TAGS, queryString, 1f));\n\n    return qb;\n  }","commit_id":"87b720fbd3f2369694fcfe2ecc8886be8eba92eb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected FilterBuilder getFilter(RuleQuery query, QueryOptions options) {\n\n    BoolFilterBuilder fb = FilterBuilders.boolFilter();\n\n    /* Add enforced filter on rules that are REMOVED */\n    fb.mustNot(FilterBuilders\n      .termFilter(RuleNormalizer.RuleField.STATUS.field(),\n        RuleStatus.REMOVED.toString()));\n\n    this.addTermFilter(fb, RuleNormalizer.RuleField.INTERNAL_KEY.field(), query.getInternalKey());\n    this.addTermFilter(fb, RuleNormalizer.RuleField.RULE_KEY.field(), query.getRuleKey());\n    this.addTermFilter(fb, RuleNormalizer.RuleField.LANGUAGE.field(), query.getLanguages());\n    this.addTermFilter(fb, RuleNormalizer.RuleField.REPOSITORY.field(), query.getRepositories());\n    this.addTermFilter(fb, RuleNormalizer.RuleField.SEVERITY.field(), query.getSeverities());\n    this.addTermFilter(fb, RuleNormalizer.RuleField.KEY.field(), query.getKey());\n    this.addTermFilter(fb, RuleNormalizer.RuleField._TAGS.field(), query.getTags());\n\n    // Construct the debt filter on effective char and subChar\n    Collection<String> characteristics = query.getDebtCharacteristics();\n    if (characteristics != null && !characteristics.isEmpty()) {\n      fb.must(\n        FilterBuilders.orFilter(\n          // Match only when NOT NONE overriden\n          FilterBuilders.andFilter(\n            FilterBuilders.notFilter(\n              FilterBuilders.termsFilter(RuleNormalizer.RuleField.SUB_CHARACTERISTIC.field(), DebtCharacteristic.NONE)),\n            FilterBuilders.orFilter(\n              FilterBuilders.termsFilter(RuleNormalizer.RuleField.SUB_CHARACTERISTIC.field(), characteristics),\n              FilterBuilders.termsFilter(RuleNormalizer.RuleField.CHARACTERISTIC.field(), characteristics))\n            ),\n\n          // Match only when NOT NONE overriden\n          FilterBuilders.andFilter(\n            FilterBuilders.orFilter(\n              FilterBuilders.termsFilter(RuleNormalizer.RuleField.SUB_CHARACTERISTIC.field(), \"\"),\n              FilterBuilders.notFilter(FilterBuilders.existsFilter(RuleNormalizer.RuleField.SUB_CHARACTERISTIC.field()))),\n            FilterBuilders.orFilter(\n              FilterBuilders.termsFilter(RuleNormalizer.RuleField.DEFAULT_SUB_CHARACTERISTIC.field(), characteristics),\n              FilterBuilders.termsFilter(RuleNormalizer.RuleField.DEFAULT_CHARACTERISTIC.field(), characteristics)))\n          )\n        );\n    }\n\n    // Debt char exist filter\n    if (Boolean.TRUE.equals(query.getHasDebtCharacteristic())) {\n      fb.must(FilterBuilders.existsFilter(RuleNormalizer.RuleField.SUB_CHARACTERISTIC.field()));\n    }\n\n    if (query.getAvailableSince() != null) {\n      fb.must(FilterBuilders.rangeFilter(RuleNormalizer.RuleField.CREATED_AT.field())\n        .gte(query.getAvailableSince()));\n    }\n\n    Collection<RuleStatus> statuses = query.getStatuses();\n    if (statuses != null && !statuses.isEmpty()) {\n      Collection<String> stringStatus = new ArrayList<String>();\n      for (RuleStatus status : statuses) {\n        stringStatus.add(status.name());\n      }\n      this.addTermFilter(fb, RuleNormalizer.RuleField.STATUS.field(), stringStatus);\n    }\n\n    Boolean isTemplate = query.isTemplate();\n    if (isTemplate != null) {\n      this.addTermFilter(fb, RuleNormalizer.RuleField.IS_TEMPLATE.field(), Boolean.toString(isTemplate));\n    }\n\n    String template = query.templateKey();\n    if (template != null) {\n      this.addTermFilter(fb, RuleNormalizer.RuleField.TEMPLATE_KEY.field(), template);\n    }\n\n    // ActiveRule Filter (profile and inheritance)\n    BoolFilterBuilder childrenFilter = FilterBuilders.boolFilter();\n    this.addTermFilter(childrenFilter, ActiveRuleNormalizer.ActiveRuleField.PROFILE_KEY.field(), query.getQProfileKey());\n    this.addTermFilter(childrenFilter, ActiveRuleNormalizer.ActiveRuleField.INHERITANCE.field(), query.getInheritance());\n\n    // ChildQuery\n    QueryBuilder childQuery;\n    if (childrenFilter.hasClauses()) {\n      childQuery = QueryBuilders.constantScoreQuery(childrenFilter);\n    } else {\n      childQuery = QueryBuilders.matchAllQuery();\n    }\n\n    /** Implementation of activation query */\n    if (query.getActivation() == Boolean.TRUE) {\n      fb.must(FilterBuilders.hasChildFilter(IndexDefinition.ACTIVE_RULE.getIndexType(),\n        childQuery));\n    } else if (query.getActivation() == Boolean.FALSE) {\n      fb.mustNot(FilterBuilders.hasChildFilter(IndexDefinition.ACTIVE_RULE.getIndexType(),\n        childQuery));\n    }\n\n    return fb;\n  }","id":91287,"modified_method":"protected FilterBuilder getFilter(RuleQuery query, QueryOptions options) {\n\n    BoolFilterBuilder fb = FilterBuilders.boolFilter();\n\n    /* Add enforced filter on rules that are REMOVED */\n    fb.mustNot(FilterBuilders\n      .termFilter(RuleNormalizer.RuleField.STATUS.field(),\n        RuleStatus.REMOVED.toString()));\n\n    this.addTermFilter(fb, RuleNormalizer.RuleField.INTERNAL_KEY.field(), query.getInternalKey());\n    this.addTermFilter(fb, RuleNormalizer.RuleField.RULE_KEY.field(), query.getRuleKey());\n    this.addTermFilter(fb, RuleNormalizer.RuleField.LANGUAGE.field(), query.getLanguages());\n    this.addTermFilter(fb, RuleNormalizer.RuleField.REPOSITORY.field(), query.getRepositories());\n    this.addTermFilter(fb, RuleNormalizer.RuleField.SEVERITY.field(), query.getSeverities());\n    this.addTermFilter(fb, RuleNormalizer.RuleField.KEY.field(), query.getKey());\n    this.addTermFilter(fb, RuleNormalizer.RuleField._TAGS.field(), query.getTags());\n\n    // Construct the debt filter on effective char and subChar\n    Collection<String> debtCharacteristics = query.getDebtCharacteristics();\n    if (debtCharacteristics != null && !debtCharacteristics.isEmpty()) {\n      fb.must(\n        FilterBuilders.orFilter(\n          // Match only when NOT NONE overriden\n          FilterBuilders.andFilter(\n            FilterBuilders.notFilter(\n              FilterBuilders.termsFilter(RuleNormalizer.RuleField.SUB_CHARACTERISTIC.field(), DebtCharacteristic.NONE)),\n            FilterBuilders.orFilter(\n              FilterBuilders.termsFilter(RuleNormalizer.RuleField.SUB_CHARACTERISTIC.field(), debtCharacteristics),\n              FilterBuilders.termsFilter(RuleNormalizer.RuleField.CHARACTERISTIC.field(), debtCharacteristics))\n            ),\n\n          // Match only when NOT NONE overriden\n          FilterBuilders.andFilter(\n            FilterBuilders.orFilter(\n              FilterBuilders.termsFilter(RuleNormalizer.RuleField.SUB_CHARACTERISTIC.field(), \"\"),\n              FilterBuilders.notFilter(FilterBuilders.existsFilter(RuleNormalizer.RuleField.SUB_CHARACTERISTIC.field()))),\n            FilterBuilders.orFilter(\n              FilterBuilders.termsFilter(RuleNormalizer.RuleField.DEFAULT_SUB_CHARACTERISTIC.field(), debtCharacteristics),\n              FilterBuilders.termsFilter(RuleNormalizer.RuleField.DEFAULT_CHARACTERISTIC.field(), debtCharacteristics)))\n          )\n        );\n    }\n\n    // Debt char exist filter\n    Boolean hasDebtCharacteristic = query.getHasDebtCharacteristic();\n    if (hasDebtCharacteristic != null && hasDebtCharacteristic) {\n      fb.must(FilterBuilders.existsFilter(RuleNormalizer.RuleField.SUB_CHARACTERISTIC.field()));\n    }\n\n    if (query.getAvailableSince() != null) {\n      fb.must(FilterBuilders.rangeFilter(RuleNormalizer.RuleField.CREATED_AT.field())\n        .gte(query.getAvailableSince()));\n    }\n\n    Collection<RuleStatus> statusValues = query.getStatuses();\n    if (statusValues != null && !statusValues.isEmpty()) {\n      Collection<String> stringStatus = new ArrayList<String>();\n      for (RuleStatus status : statusValues) {\n        stringStatus.add(status.name());\n      }\n      this.addTermFilter(fb, RuleNormalizer.RuleField.STATUS.field(), stringStatus);\n    }\n\n    Boolean isTemplate = query.isTemplate();\n    if (isTemplate != null) {\n      this.addTermFilter(fb, RuleNormalizer.RuleField.IS_TEMPLATE.field(), Boolean.toString(isTemplate));\n    }\n\n    String template = query.templateKey();\n    if (template != null) {\n      this.addTermFilter(fb, RuleNormalizer.RuleField.TEMPLATE_KEY.field(), template);\n    }\n\n    // ActiveRule Filter (profile and inheritance)\n    BoolFilterBuilder childrenFilter = FilterBuilders.boolFilter();\n    this.addTermFilter(childrenFilter, ActiveRuleNormalizer.ActiveRuleField.PROFILE_KEY.field(), query.getQProfileKey());\n    this.addTermFilter(childrenFilter, ActiveRuleNormalizer.ActiveRuleField.INHERITANCE.field(), query.getInheritance());\n\n    // ChildQuery\n    QueryBuilder childQuery;\n    if (childrenFilter.hasClauses()) {\n      childQuery = QueryBuilders.constantScoreQuery(childrenFilter);\n    } else {\n      childQuery = QueryBuilders.matchAllQuery();\n    }\n\n    /** Implementation of activation query */\n    if (query.getActivation().equals(Boolean.TRUE)) {\n      fb.must(FilterBuilders.hasChildFilter(IndexDefinition.ACTIVE_RULE.getIndexType(),\n        childQuery));\n    } else if (query.getActivation().equals(Boolean.FALSE)) {\n      fb.mustNot(FilterBuilders.hasChildFilter(IndexDefinition.ACTIVE_RULE.getIndexType(),\n        childQuery));\n    }\n\n    return fb;\n  }","commit_id":"87b720fbd3f2369694fcfe2ecc8886be8eba92eb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void setSorting(RuleQuery query, SearchRequestBuilder esSearch) {\n    /* integrate Query Sort */\n    if (query.getSortField() != null) {\n      FieldSortBuilder sort = SortBuilders.fieldSort(query.getSortField().sortField());\n      if (query.isAscendingSort()) {\n        sort.order(SortOrder.ASC);\n      } else {\n        sort.order(SortOrder.DESC);\n      }\n      esSearch.addSort(sort);\n    } else if (query.getQueryText() != null && !query.getQueryText().isEmpty()) {\n      esSearch.addSort(SortBuilders.scoreSort());\n    } else {\n      esSearch.addSort(RuleNormalizer.RuleField.UPDATED_AT.sortField(), SortOrder.DESC);\n      // deterministic sort when exactly the same updated_at (same millisecond)\n      esSearch.addSort(RuleNormalizer.RuleField.KEY.sortField()\n        , SortOrder.ASC);\n    }\n  }","id":91288,"modified_method":"private void setSorting(RuleQuery query, SearchRequestBuilder esSearch) {\n    /* integrate Query Sort */\n    String queryText = query.getQueryText();\n    if (query.getSortField() != null) {\n      FieldSortBuilder sort = SortBuilders.fieldSort(query.getSortField().sortField());\n      if (query.isAscendingSort()) {\n        sort.order(SortOrder.ASC);\n      } else {\n        sort.order(SortOrder.DESC);\n      }\n      esSearch.addSort(sort);\n    } else if (queryText != null && !queryText.isEmpty()) {\n      esSearch.addSort(SortBuilders.scoreSort());\n    } else {\n      esSearch.addSort(RuleNormalizer.RuleField.UPDATED_AT.sortField(), SortOrder.DESC);\n      // deterministic sort when exactly the same updated_at (same millisecond)\n      esSearch.addSort(RuleNormalizer.RuleField.KEY.sortField()\n        , SortOrder.ASC);\n    }\n  }","commit_id":"87b720fbd3f2369694fcfe2ecc8886be8eba92eb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  protected List<MenuPart<TransformationMenuItem, TransformationMenuContext>> getParts(TransformationMenuContext _context) {\n    List<MenuPart<TransformationMenuItem, TransformationMenuContext>> result = new ArrayList<MenuPart<TransformationMenuItem, TransformationMenuContext>>();\n    if (ListSequence.fromListAndArray(new ArrayList<String>(), MenuLocations.CONTEXT_ASSISTANT).contains(_context.getMenuLocation())) {\n      result.add(new ConceptDeclaration_TransformationMenu.TransformationMenuPart_Action_dubn3u_a0());\n      result.add(new ConceptDeclaration_TransformationMenu.TransformationMenuPart_Action_dubn3u_b0());\n      result.add(new ConceptDeclaration_TransformationMenu.TransformationMenuPart_Action_dubn3u_c0());\n    }\n    return result;\n  }","id":91289,"modified_method":"@Override\n  protected List<MenuPart<TransformationMenuItem, TransformationMenuContext>> getParts(TransformationMenuContext _context) {\n    List<MenuPart<TransformationMenuItem, TransformationMenuContext>> result = new ArrayList<MenuPart<TransformationMenuItem, TransformationMenuContext>>();\n    if (ListSequence.fromListAndArray(new ArrayList<String>(), MenuLocations.CONTEXT_ASSISTANT).contains(_context.getMenuLocation())) {\n      result.add(new ConceptDeclaration_TransformationMenu.TransformationMenuPart_Action_dubn3u_a0());\n      result.add(new ConceptDeclaration_TransformationMenu.TransformationMenuPart_Action_dubn3u_b0());\n      result.add(new ConceptDeclaration_TransformationMenu.TransformationMenuPart_Action_dubn3u_c0());\n      result.add(new ConceptDeclaration_TransformationMenu.TransformationMenuPart_Action_dubn3u_d0());\n    }\n    return result;\n  }","commit_id":"0665b84c1fc0717a16550852c69a4c5278894a7e","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n      public boolean canExecute(@NotNull String pattern) {\n        if (_context.getEditorContext().getEditorPanelManager() == null || SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")) == null) {\n          return false;\n        }\n\n        Queue<SNode> toCheck = QueueSequence.fromQueue(new LinkedList<SNode>());\n        QueueSequence.fromQueue(toCheck).addLastElement(_context.getNode());\n        while (QueueSequence.fromQueue(toCheck).isNotEmpty()) {\n          SNode acd = QueueSequence.fromQueue(toCheck).removeFirstElement();\n          if (acd == SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590288(jetbrains.mps.lang.core.structure)\", \"1133920641626\")) {\n            continue;\n          }\n          List<SNode> aspects = AbstractConceptDeclaration__BehaviorDescriptor.findConceptAspectCollection_id1n18fON7w20.invoke(acd, LanguageAspect.EDITOR);\n          if (ListSequence.fromList(aspects).any(new IWhereFilter<SNode>() {\n            public boolean accept(SNode a) {\n              return SNodeOperations.isInstanceOf(a, MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9845363abL, \"jetbrains.mps.lang.editor.structure.ConceptEditorDeclaration\"));\n            }\n          })) {\n            return false;\n          }\n          QueueSequence.fromQueue(toCheck).addSequence(ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getImmediateSuperconcepts_idhMuxyK2.invoke(acd)));\n        }\n        return true;\n      }","id":91290,"modified_method":"@Override\n      public boolean canExecute(@NotNull String pattern) {\n        if (_context.getEditorContext().getEditorPanelManager() == null || SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")) == null || _context.getNode() == MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, \"jetbrains.mps.lang.core.structure.BaseConcept\").getDeclarationNode()) {\n          return false;\n        }\n\n        Queue<SNode> toCheck = QueueSequence.fromQueueAndArray(new LinkedList<SNode>(), _context.getNode());\n        while (QueueSequence.fromQueue(toCheck).isNotEmpty()) {\n          SNode acd = QueueSequence.fromQueue(toCheck).removeFirstElement();\n          if (acd == SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590288(jetbrains.mps.lang.core.structure)\", \"1133920641626\")) {\n            continue;\n          }\n          List<SNode> aspects = AbstractConceptDeclaration__BehaviorDescriptor.findConceptAspectCollection_id1n18fON7w20.invoke(acd, LanguageAspect.EDITOR);\n          if (ListSequence.fromList(aspects).any(new IWhereFilter<SNode>() {\n            public boolean accept(SNode a) {\n              return SNodeOperations.isInstanceOf(a, MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9845363abL, \"jetbrains.mps.lang.editor.structure.ConceptEditorDeclaration\"));\n            }\n          })) {\n            return false;\n          }\n          QueueSequence.fromQueue(toCheck).addSequence(ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getImmediateSuperconcepts_idhMuxyK2.invoke(acd)));\n        }\n        return true;\n      }","commit_id":"0665b84c1fc0717a16550852c69a4c5278894a7e","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n      public void execute(@NotNull String pattern) {\n        SPropertyOperations.set(_context.getNode(), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0x46ab0ad5826c74caL, \"conceptAlias\"), \"<\" + SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")) + \"_Alias>\");\n        SelectionUtil.selectLabelCellWithSelection(_context.getEditorContext(), _context.getNode(), \"*\" + CellIdManager.createPropertyId(\"conceptAlias\"), 0, -1);\n      }","id":91291,"modified_method":"@Override\n      public void execute(@NotNull String pattern) {\n        SPropertyOperations.set(_context.getNode(), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xff49c1d648L, \"rootable\"), \"\" + (true));\n      }","commit_id":"0665b84c1fc0717a16550852c69a4c5278894a7e","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n      public boolean canExecute(@NotNull String pattern) {\n        // Suggesting to make the concept rootable if: \n        // 1. Concept has no super-concepts \n        // 2. There is no other ceoncepts in this model with the containment link to this concept \n        if (SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")) == null || SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xf979be93cfL, \"extends\")) != SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590288(jetbrains.mps.lang.core.structure)\", \"1133920641626\") || SPropertyOperations.getBoolean(_context.getNode(), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xff49c1d648L, \"rootable\")) || SPropertyOperations.getBoolean(_context.getNode(), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0x403a32c5772c7ec2L, \"abstract\"))) {\n          return false;\n        }\n        return ListSequence.fromList(SModelOperations.roots(SNodeOperations.getModel(_context.getNode()), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))).translate(new ITranslator2<SNode, SNode>() {\n          public Iterable<SNode> translate(SNode it) {\n            return SLinkOperations.getChildren(it, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\"));\n          }\n        }).where(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"aggregation\", \"reference\");\n          }\n        }).where(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SLinkOperations.getTarget(it, MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98055fef0L, \"target\")) == _context.getNode();\n          }\n        }).isEmpty();\n      }","id":91292,"modified_method":"@Override\n      public boolean canExecute(@NotNull String pattern) {\n        if (_context.getEditorContext().getEditorPanelManager() == null || SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")) == null || _context.getNode() == MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, \"jetbrains.mps.lang.core.structure.BaseConcept\").getDeclarationNode()) {\n          return false;\n        }\n        if (!(ListSequence.fromList(SLinkOperations.getChildren(_context.getNode(), MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, \"propertyDeclaration\"))).isEmpty()) || !(ListSequence.fromList(SLinkOperations.getChildren(_context.getNode(), MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\"))).isEmpty())) {\n          return false;\n        }\n\n        Queue<SNode> toCheck = QueueSequence.fromQueueAndArray(new LinkedList<SNode>(), _context.getNode());\n        while (QueueSequence.fromQueue(toCheck).isNotEmpty()) {\n          SNode acd = QueueSequence.fromQueue(toCheck).removeFirstElement();\n          if (acd == SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590288(jetbrains.mps.lang.core.structure)\", \"1133920641626\")) {\n            continue;\n          }\n          List<SNode> aspects = AbstractConceptDeclaration__BehaviorDescriptor.findConceptAspectCollection_id1n18fON7w20.invoke(acd, LanguageAspect.EDITOR);\n          if (ListSequence.fromList(aspects).any(new IWhereFilter<SNode>() {\n            public boolean accept(SNode a) {\n              return SNodeOperations.isInstanceOf(a, MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9845363abL, \"jetbrains.mps.lang.editor.structure.ConceptEditorDeclaration\"));\n            }\n          })) {\n            return false;\n          }\n          QueueSequence.fromQueue(toCheck).addSequence(ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getImmediateSuperconcepts_idhMuxyK2.invoke(acd)));\n        }\n\n        return new ConceptDeclarationAssistantUtil(_context.getNode()).getNotEmptySuperConcept() != null;\n      }","commit_id":"0665b84c1fc0717a16550852c69a4c5278894a7e","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n      public void execute(@NotNull String pattern) {\n        SPropertyOperations.set(_context.getNode(), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xff49c1d648L, \"rootable\"), \"\" + (true));\n      }","id":91293,"modified_method":"@Override\n      public void execute(@NotNull String pattern) {\n        SNode concept = new ConceptDeclarationAssistantUtil(_context.getNode()).getNotEmptySuperConcept();\n        SNode editor = ConceptAspectsHelper.attachNewConceptAspect(LanguageAspect.EDITOR, concept, SNodeFactoryOperations.createNewNode(SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x18bc659203a64e29L, 0xa83a7ff23bde13baL, 0xf9845363abL, \"jetbrains.mps.lang.editor.structure.ConceptEditorDeclaration\")), null));\n        _context.getEditorContext().getEditorPanelManager().openEditor(editor);\n      }","commit_id":"0665b84c1fc0717a16550852c69a4c5278894a7e","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n      @Override\n      public String getLabelText(String pattern) {\n        return \"Make rootable\";\n      }","id":91294,"modified_method":"@Nullable\n      @Override\n      public String getLabelText(String pattern) {\n        return \"Create Editor for \" + SPropertyOperations.getString(new ConceptDeclarationAssistantUtil(_context.getNode()).getNotEmptySuperConcept(), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\"));\n      }","commit_id":"0665b84c1fc0717a16550852c69a4c5278894a7e","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n      @Override\n      public String getLabelText(String pattern) {\n        return \"Set Alias\";\n      }","id":91295,"modified_method":"@Nullable\n      @Override\n      public String getLabelText(String pattern) {\n        return \"Make rootable\";\n      }","commit_id":"0665b84c1fc0717a16550852c69a4c5278894a7e","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n      public boolean canExecute(@NotNull String pattern) {\n        if (SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")) == null || SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0x46ab0ad5826c74caL, \"conceptAlias\")) != null || SPropertyOperations.getBoolean(_context.getNode(), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0x403a32c5772c7ec2L, \"abstract\"))) {\n          return false;\n        }\n        Iterable<SNode> links = ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getLinkDeclarations_idhEwILKK.invoke(_context.getNode())).where(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return it != SLinkOperations.findLinkDeclaration(MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, \"smodelAttribute\"));\n          }\n        });\n        if (Sequence.fromIterable(links).count() == 1 && SPropertyOperations.hasValue(Sequence.fromIterable(links).first(), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"reference\", \"reference\")) {\n          // skipping smart references \n          return false;\n        }\n\n        return Sequence.fromIterable(AbstractConceptDeclaration__BehaviorDescriptor.getAllSuperConcepts_id2A8AB0rAWpG.invoke(_context.getNode(), ((boolean) false))).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0x46ab0ad5826c74caL, \"conceptAlias\")) != null;\n          }\n        }) || !(Sequence.fromIterable(AbstractConceptDeclaration__BehaviorDescriptor.getAllSuperConcepts_id2A8AB0rAWpG.invoke(_context.getNode(), ((boolean) false))).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return it == MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, \"jetbrains.mps.lang.core.structure.INamedConcept\").getDeclarationNode();\n          }\n        }));\n      }","id":91296,"modified_method":"@Override\n      public boolean canExecute(@NotNull String pattern) {\n        // Suggesting to make the concept rootable if: \n        // 1. Concept has no super-concepts \n        // 2. There is no other ceoncepts in this model with the containment link to this concept \n        if (SPropertyOperations.getString(_context.getNode(), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, \"name\")) == null || SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xf979be93cfL, \"extends\")) != SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590288(jetbrains.mps.lang.core.structure)\", \"1133920641626\") || SPropertyOperations.getBoolean(_context.getNode(), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xff49c1d648L, \"rootable\")) || SPropertyOperations.getBoolean(_context.getNode(), MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0x403a32c5772c7ec2L, \"abstract\"))) {\n          return false;\n        }\n        return ListSequence.fromList(SModelOperations.roots(SNodeOperations.getModel(_context.getNode()), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))).translate(new ITranslator2<SNode, SNode>() {\n          public Iterable<SNode> translate(SNode it) {\n            return SLinkOperations.getChildren(it, MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, \"linkDeclaration\"));\n          }\n        }).where(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SPropertyOperations.hasValue(it, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf980556927L, \"metaClass\"), \"aggregation\", \"reference\");\n          }\n        }).where(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SLinkOperations.getTarget(it, MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98055fef0L, \"target\")) == _context.getNode();\n          }\n        }).isEmpty();\n      }","commit_id":"0665b84c1fc0717a16550852c69a4c5278894a7e","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode createNode(@NotNull SAbstractConcept nodeConcept, SNode sampleNode, SNode enclosingNode, @Nullable SModel model,\n      Set<SAbstractConcept> visitedNonOptionalChildConcepts) {\n    SNode newNode = SModelUtil_new.instantiateConceptDeclaration(nodeConcept.getQualifiedName(), model, false);\n    if (newNode == null) return null;\n    if (nodeConcept instanceof SInterfaceConcept) {\n      return newNode;\n    }\n    BehaviorReflection.initNode(newNode);\n    if (sampleNode != null) {\n      sampleNode = CopyUtil.copy(sampleNode);\n    }\n    nodeConcept = newNode.getConcept(); // XXX is it possible to get another concept on creation?\n    setupNode(nodeConcept, newNode, sampleNode, enclosingNode, model);\n    createNodeStructure(nodeConcept, newNode, sampleNode, enclosingNode, model, visitedNonOptionalChildConcepts);\n    return newNode;\n  }","id":91297,"modified_method":"private static SNode createNode(@NotNull SAbstractConcept nodeConcept, SNode sampleNode, SNode enclosingNode, @Nullable SModel model,\n      Set<SAbstractConcept> visitedNonOptionalChildConcepts) {\n    SNode newNode = SModelUtil_new.instantiateConceptDeclaration(nodeConcept, model, null, false);\n    if (newNode == null) return null;\n    if (nodeConcept instanceof SInterfaceConcept) {\n      return newNode;\n    }\n    BehaviorReflection.initNode(newNode);\n    if (sampleNode != null) {\n      sampleNode = CopyUtil.copy(sampleNode);\n    }\n    nodeConcept = newNode.getConcept(); // XXX is it possible to get another concept on creation?\n    setupNode(nodeConcept, newNode, sampleNode, enclosingNode, model);\n    createNodeStructure(nodeConcept, newNode, sampleNode, enclosingNode, model, visitedNonOptionalChildConcepts);\n    return newNode;\n  }","commit_id":"764af5a04c66c453bcd4eb03993b75335d0220a3","url":"https://github.com/JetBrains/MPS"},{"original_method":"static SNode create_id7PoJpZpIp9n(@NotNull SAbstractConcept __thisConcept__, SModel where, SNode n) {\n    SNode rv = SModelOperations.createNewNode(where, null, SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, \"jetbrains.mps.lang.generator.structure.TrivialNodeId\")));\n    SPropertyOperations.set(rv, MetaAdapterFactory.getProperty(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, 0x7d58bd9fd9b64466L, \"conceptId\"), n.getConcept().getQualifiedName());\n    SPropertyOperations.set(rv, MetaAdapterFactory.getProperty(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, 0x7d58bd9fd9b64468L, \"nodeId\"), n.getNodeId().toString());\n    return rv;\n  }","id":91298,"modified_method":"static SNode create_id7PoJpZpIp9n(@NotNull SAbstractConcept __thisConcept__, SModel where, SNode n) {\n    SNode rv = SModelOperations.createNewNode(where, null, SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, \"jetbrains.mps.lang.generator.structure.TrivialNodeId\")));\n    SLinkOperations.setTarget(rv, MetaAdapterFactory.getContainmentLink(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, 0x76c27c67a4605f07L, \"cncpt\"), SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x5fea1eb9fefb6fe7L, \"jetbrains.mps.lang.smodel.structure.ConceptId\"))));\n    ConceptId__BehaviorDescriptor.setConcept_id5ZE7FBYYR6j.invoke(SNodeOperations.cast(SLinkOperations.getTarget(rv, MetaAdapterFactory.getContainmentLink(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, 0x76c27c67a4605f07L, \"cncpt\")), MetaAdapterFactory.getConcept(0x7866978ea0f04cc7L, 0x81bc4d213d9375e1L, 0x5fea1eb9fefb6fe7L, \"jetbrains.mps.lang.smodel.structure.ConceptId\")), n.getConcept());\n    SPropertyOperations.set(rv, MetaAdapterFactory.getProperty(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, 0x7d58bd9fd9b64468L, \"nodeId\"), n.getNodeId().toString());\n    return rv;\n  }","commit_id":"764af5a04c66c453bcd4eb03993b75335d0220a3","url":"https://github.com/JetBrains/MPS"},{"original_method":"static SNode instantiate_id7PoJpZpHuTR(@NotNull SNode __thisNode__, SModel model) {\n    SNodeId identity = PersistenceFacade.getInstance().createNodeId(SPropertyOperations.getString(__thisNode__, MetaAdapterFactory.getProperty(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, 0x7d58bd9fd9b64468L, \"nodeId\")));\n    // could use SModelOperations.createNewNode (which does Behavior.init() in addition to instantiation) \n    // want to be minimalistic, yet not adding new API (#createNode(SConcept) is way too tempting) \n    return SModelUtil_new.instantiateConceptDeclaration(SPropertyOperations.getString(__thisNode__, MetaAdapterFactory.getProperty(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, 0x7d58bd9fd9b64466L, \"conceptId\")), model, identity, false);\n  }","id":91299,"modified_method":"static SNode instantiate_id7PoJpZpHuTR(@NotNull SNode __thisNode__, SModel model) {\n    SNodeId identity = PersistenceFacade.getInstance().createNodeId(SPropertyOperations.getString(__thisNode__, MetaAdapterFactory.getProperty(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, 0x7d58bd9fd9b64468L, \"nodeId\")));\n    // could use SModelOperations.createNewNode (which does Behavior.init() in addition to instantiation) \n    // want to be minimalistic, yet not adding new API (#createNode(SConcept) is way too tempting) \n    return SModelUtil_new.instantiateConceptDeclaration(ConceptIdentity__BehaviorDescriptor.getConcept_id5ZE7FBYYOpv.invoke(SLinkOperations.getTarget(__thisNode__, MetaAdapterFactory.getContainmentLink(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, 0x76c27c67a4605f07L, \"cncpt\"))), model, identity, false);\n  }","commit_id":"764af5a04c66c453bcd4eb03993b75335d0220a3","url":"https://github.com/JetBrains/MPS"},{"original_method":"static boolean match_id1si_nSrb46O(@NotNull SNode __thisNode__, SNode n) {\n    return n.getConcept().getQualifiedName().equals(SPropertyOperations.getString(__thisNode__, MetaAdapterFactory.getProperty(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, 0x7d58bd9fd9b64466L, \"conceptId\"))) && n.getNodeId().toString().equals(SPropertyOperations.getString(__thisNode__, MetaAdapterFactory.getProperty(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, 0x7d58bd9fd9b64468L, \"nodeId\")));\n  }","id":91300,"modified_method":"static boolean match_id1si_nSrb46O(@NotNull SNode __thisNode__, SNode n) {\n    return n.getConcept().equals(ConceptIdentity__BehaviorDescriptor.getConcept_id5ZE7FBYYOpv.invoke(SLinkOperations.getTarget(__thisNode__, MetaAdapterFactory.getContainmentLink(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, 0x76c27c67a4605f07L, \"cncpt\")))) && n.getNodeId().toString().equals(SPropertyOperations.getString(__thisNode__, MetaAdapterFactory.getProperty(0xb401a68083254110L, 0x8fd384331ff25befL, 0x7d58bd9fd9b64463L, 0x7d58bd9fd9b64468L, \"nodeId\")));\n  }","commit_id":"764af5a04c66c453bcd4eb03993b75335d0220a3","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteException {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        // To start ignite with desired configuration uncomment the appropriate line.\n        try (Ignite ignite = Ignition.start(\"examples/config/example-ignite.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache store example started.\");\n\n            CacheConfiguration<Long, Person> cacheCfg = new CacheConfiguration<>();\n\n            // Set atomicity as transaction, since we are showing transactions in example.\n            cacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n            cacheCfg.setCacheStoreFactory(new Factory<CacheStore<? super Long, ? super Person>>() {\n                @Override public CacheStore<? super Long, ? super Person> create() {\n                    return new CacheDummyPersonStore();\n                }\n            });\n\n            cacheCfg.setReadThrough(true);\n            cacheCfg.setWriteThrough(true);\n\n            try (IgniteCache<Long, Person> cache = ignite.createCache(cacheCfg)) {\n                long start = System.currentTimeMillis();\n\n                // Start loading cache from persistent store on all caching nodes.\n                cache.loadCache(null, ENTRY_COUNT);\n\n                long end = System.currentTimeMillis();\n\n                System.out.println(\">>> Loaded \" + cache.size() + \" keys with backups in \" + (end - start) + \"ms.\");\n\n                // Start transaction and make several operations with write/read-through.\n                try (Transaction tx = ignite.transactions().txStart()) {\n                    Person val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    val = cache.getAndPut(id, new Person(id, \"Isaac\", \"Newton\"));\n\n                    System.out.println(\"Overwrote old value: \" + val);\n\n                    val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    tx.commit();\n                }\n\n                System.out.println(\"Read value after commit: \" + cache.get(id));\n            }\n        }\n    }","id":91301,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteException {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        // To start ignite with desired configuration uncomment the appropriate line.\n        try (Ignite ignite = Ignition.start(\"examples/config/example-ignite.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache store example started.\");\n\n            CacheConfiguration<Long, Person> cacheCfg = new CacheConfiguration<>();\n\n            // Set atomicity as transaction, since we are showing transactions in example.\n            cacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n            // Configure Dummy store.\n            cacheCfg.setCacheStoreFactory(FactoryBuilder.factoryOf(CacheDummyPersonStore.class));\n\n            cacheCfg.setReadThrough(true);\n            cacheCfg.setWriteThrough(true);\n\n            try (IgniteCache<Long, Person> cache = ignite.getOrCreateCache(cacheCfg)) {\n                long start = System.currentTimeMillis();\n\n                // Start loading cache from persistent store on all caching nodes.\n                cache.loadCache(null, ENTRY_COUNT);\n\n                long end = System.currentTimeMillis();\n\n                System.out.println(\">>> Loaded \" + cache.size() + \" keys with backups in \" + (end - start) + \"ms.\");\n\n                // Start transaction and make several operations with write/read-through.\n                try (Transaction tx = ignite.transactions().txStart()) {\n                    Person val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    val = cache.getAndPut(id, new Person(id, \"Isaac\", \"Newton\"));\n\n                    System.out.println(\"Overwrote old value: \" + val);\n\n                    val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    tx.commit();\n                }\n\n                System.out.println(\"Read value after commit: \" + cache.get(id));\n            }\n        }\n    }","commit_id":"a628cb921b4458b9b4cbf55fdd34ac28fb009555","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteException {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        // To start ignite with desired configuration uncomment the appropriate line.\n        try (Ignite ignite = Ignition.start(\"examples/config/example-ignite.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache store example started.\");\n\n            CacheConfiguration<Long, Person> cacheCfg = new CacheConfiguration<>();\n\n            // Set atomicity as transaction, since we are showing transactions in example.\n            cacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n            cacheCfg.setCacheStoreFactory(new Factory<CacheStore<? super Long, ? super Person>>() {\n                @Override public CacheStore<? super Long, ? super Person> create() {\n                    return new CacheHibernatePersonStore();\n                }\n            });\n\n            cacheCfg.setReadThrough(true);\n            cacheCfg.setWriteThrough(true);\n\n            try (IgniteCache<Long, Person> cache = ignite.createCache(cacheCfg)) {\n                long start = System.currentTimeMillis();\n\n                // Start loading cache from persistent store on all caching nodes.\n                cache.loadCache(null, ENTRY_COUNT);\n\n                long end = System.currentTimeMillis();\n\n                System.out.println(\">>> Loaded \" + cache.size() + \" keys with backups in \" + (end - start) + \"ms.\");\n\n                // Start transaction and make several operations with write/read-through.\n                try (Transaction tx = ignite.transactions().txStart()) {\n                    Person val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    val = cache.getAndPut(id, new Person(id, \"Isaac\", \"Newton\"));\n\n                    System.out.println(\"Overwrote old value: \" + val);\n\n                    val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    tx.commit();\n                }\n\n                System.out.println(\"Read value after commit: \" + cache.get(id));\n            }\n        }\n    }","id":91302,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteException {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        // To start ignite with desired configuration uncomment the appropriate line.\n        try (Ignite ignite = Ignition.start(\"examples/config/example-ignite.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache store example started.\");\n\n            CacheConfiguration<Long, Person> cacheCfg = new CacheConfiguration<>();\n\n            // Set atomicity as transaction, since we are showing transactions in example.\n            cacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n            // Configure Hibernate store.\n            cacheCfg.setCacheStoreFactory(FactoryBuilder.factoryOf(CacheHibernatePersonStore.class));\n\n            cacheCfg.setReadThrough(true);\n            cacheCfg.setWriteThrough(true);\n\n            try (IgniteCache<Long, Person> cache = ignite.getOrCreateCache(cacheCfg)) {\n                long start = System.currentTimeMillis();\n\n                // Start loading cache from persistent store on all caching nodes.\n                cache.loadCache(null, ENTRY_COUNT);\n\n                long end = System.currentTimeMillis();\n\n                System.out.println(\">>> Loaded \" + cache.size() + \" keys with backups in \" + (end - start) + \"ms.\");\n\n                // Start transaction and make several operations with write/read-through.\n                try (Transaction tx = ignite.transactions().txStart()) {\n                    Person val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    val = cache.getAndPut(id, new Person(id, \"Isaac\", \"Newton\"));\n\n                    System.out.println(\"Overwrote old value: \" + val);\n\n                    val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    tx.commit();\n                }\n\n                System.out.println(\"Read value after commit: \" + cache.get(id));\n            }\n        }\n    }","commit_id":"a628cb921b4458b9b4cbf55fdd34ac28fb009555","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteException {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        // To start ignite with desired configuration uncomment the appropriate line.\n        try (Ignite ignite = Ignition.start(\"examples/config/example-ignite.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache store example started.\");\n\n            CacheConfiguration<Long, Person> cacheCfg = new CacheConfiguration<>();\n\n            // Set atomicity as transaction, since we are showing transactions in example.\n            cacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n            cacheCfg.setCacheStoreFactory(new Factory<CacheStore<? super Long, ? super Person>>() {\n                @Override public CacheStore<? super Long, ? super Person> create() {\n                    return new CacheJdbcPersonStore();\n                }\n            });\n\n            cacheCfg.setReadThrough(true);\n            cacheCfg.setWriteThrough(true);\n\n            try (IgniteCache<Long, Person> cache = ignite.createCache(cacheCfg)) {\n                long start = System.currentTimeMillis();\n\n                // Start loading cache from persistent store on all caching nodes.\n                cache.loadCache(null, ENTRY_COUNT);\n\n                long end = System.currentTimeMillis();\n\n                System.out.println(\">>> Loaded \" + cache.size() + \" keys with backups in \" + (end - start) + \"ms.\");\n\n                // Start transaction and make several operations with write/read-through.\n                try (Transaction tx = ignite.transactions().txStart()) {\n                    Person val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    val = cache.getAndPut(id, new Person(id, \"Isaac\", \"Newton\"));\n\n                    System.out.println(\"Overwrote old value: \" + val);\n\n                    val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    tx.commit();\n                }\n\n                System.out.println(\"Read value after commit: \" + cache.get(id));\n            }\n        }\n    }","id":91303,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteException {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        // To start ignite with desired configuration uncomment the appropriate line.\n        try (Ignite ignite = Ignition.start(\"examples/config/example-ignite.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache store example started.\");\n\n            CacheConfiguration<Long, Person> cacheCfg = new CacheConfiguration<>();\n\n            // Set atomicity as transaction, since we are showing transactions in example.\n            cacheCfg.setAtomicityMode(TRANSACTIONAL);\n\n            // Configure JDBC store.\n            cacheCfg.setCacheStoreFactory(FactoryBuilder.factoryOf(CacheJdbcPersonStore.class));\n\n            cacheCfg.setReadThrough(true);\n            cacheCfg.setWriteThrough(true);\n\n            try (IgniteCache<Long, Person> cache = ignite.getOrCreateCache(cacheCfg)) {\n                long start = System.currentTimeMillis();\n\n                // Start loading cache from persistent store on all caching nodes.\n                cache.loadCache(null, ENTRY_COUNT);\n\n                long end = System.currentTimeMillis();\n\n                System.out.println(\">>> Loaded \" + cache.size() + \" keys with backups in \" + (end - start) + \"ms.\");\n\n                // Start transaction and make several operations with write/read-through.\n                try (Transaction tx = ignite.transactions().txStart()) {\n                    Person val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    val = cache.getAndPut(id, new Person(id, \"Isaac\", \"Newton\"));\n\n                    System.out.println(\"Overwrote old value: \" + val);\n\n                    val = cache.get(id);\n\n                    System.out.println(\"Read value: \" + val);\n\n                    tx.commit();\n                }\n\n                System.out.println(\"Read value after commit: \" + cache.get(id));\n            }\n        }\n    }","commit_id":"a628cb921b4458b9b4cbf55fdd34ac28fb009555","url":"https://github.com/apache/ignite"},{"original_method":"@Test\n    public void testParserAndGenerator() throws Exception\n    {\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        StandardByteBufferPool bufferPool = new StandardByteBufferPool();\n        Generator gen = new Generator(policy);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n\n        String message = \"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF\";\n\n        ByteBuffer out = bufferPool.acquire(policy.getBufferSize(),false);\n        try\n        {\n            // Generate Buffer\n            BufferUtil.flipToFill(out);\n            gen.generate(out,FrameBuilder.text().payload(message.getBytes()).asFrame());\n\n            // Parse Buffer\n            BufferUtil.flipToFlush(out,0);\n            parser.parse(out);\n        }\n        finally\n        {\n            bufferPool.release(out);\n        }\n\n        // Validate\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame txt = capture.getFrames().get(0);\n        Assert.assertThat(\"Text parsed\",txt.getPayloadAsUTF8(),is(message));\n    }","id":91304,"modified_method":"@Test\n    public void testParserAndGenerator() throws Exception\n    {\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        StandardByteBufferPool bufferPool = new StandardByteBufferPool();\n        Generator gen = new Generator(policy,bufferPool);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n\n        String message = \"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF\";\n\n        ByteBuffer out = bufferPool.acquire(policy.getBufferSize(),false);\n        try\n        {\n            // Generate Buffer\n            BufferUtil.flipToFill(out);\n            out = gen.generate(FrameBuilder.text().payload(message.getBytes()).asFrame());\n\n            // Parse Buffer\n            BufferUtil.flipToFlush(out,0);\n            parser.parse(out);\n        }\n        finally\n        {\n            bufferPool.release(out);\n        }\n\n        // Validate\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame txt = capture.getFrames().get(0);\n        Assert.assertThat(\"Text parsed\",txt.getPayloadAsUTF8(),is(message));\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParserAndGeneratorMasked() throws Exception\n    {\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        policy.setMasker(new RandomMasker());\n\n        StandardByteBufferPool bufferPool = new StandardByteBufferPool();\n        Generator gen = new Generator(policy);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n\n        String message = \"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF\";\n\n        ByteBuffer out = bufferPool.acquire(policy.getBufferSize(),false);\n        try\n        {\n            // Setup Frame\n            WebSocketFrame txt = FrameBuilder.text().payload(message.getBytes()).asFrame();\n\n            // Add masking\n            byte mask[] = new byte[4];\n            new FixedMasker().genMask(mask);\n            txt.setMask(mask);\n\n            // Generate Buffer\n            BufferUtil.flipToFill(out);\n            gen.generate(out,txt);\n\n            // Parse Buffer\n            BufferUtil.flipToFlush(out,0);\n            parser.parse(out);\n        }\n        finally\n        {\n            bufferPool.release(out);\n        }\n\n        // Validate\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame txt = capture.getFrames().get(0);\n        Assert.assertTrue(\"Text.isMasked\",txt.isMasked());\n        Assert.assertThat(\"Text parsed\",txt.getPayloadAsUTF8(),is(message));\n    }","id":91305,"modified_method":"@Test\n    public void testParserAndGeneratorMasked() throws Exception\n    {\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        policy.setMasker(new RandomMasker());\n\n        StandardByteBufferPool bufferPool = new StandardByteBufferPool();\n        Generator gen = new Generator(policy,bufferPool);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n\n        String message = \"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF\";\n\n        ByteBuffer out = bufferPool.acquire(policy.getBufferSize(),false);\n        try\n        {\n            // Setup Frame\n            WebSocketFrame txt = FrameBuilder.text().payload(message.getBytes()).asFrame();\n\n            // Add masking\n            byte mask[] = new byte[4];\n            new FixedMasker().genMask(mask);\n            txt.setMask(mask);\n\n            // Generate Buffer\n            out = gen.generate(policy.getBufferSize(),txt);\n\n            // Parse Buffer\n            BufferUtil.flipToFlush(out,0);\n            parser.parse(out);\n        }\n        finally\n        {\n            bufferPool.release(out);\n        }\n\n        // Validate\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame txt = capture.getFrames().get(0);\n        Assert.assertTrue(\"Text.isMasked\",txt.isMasked());\n        Assert.assertThat(\"Text parsed\",txt.getPayloadAsUTF8(),is(message));\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public <C> void write(C context, Callback<C> callback, String... messages) throws IOException\n    {\n    }","id":91306,"modified_method":"@Override\n    public <C> void write(C context, Callback<C> callback, String message) throws IOException\n    {\n        // TODO Auto-generated method stub\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testFragmentedUnmaskedTextMessage()\n    {\n        WebSocketFrame text1 = FrameBuilder.text(\"Hel\").fin(false).asFrame();\n        WebSocketFrame text2 = FrameBuilder.continuation(\"lo\").asFrame();\n\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n\n        Generator generator = new Generator(policy);\n\n        ByteBuffer actual1 = ByteBuffer.allocate(32);\n        ByteBuffer actual2 = ByteBuffer.allocate(32);\n\n        generator.generate(actual1,text1);\n        generator.generate(actual2,text2);\n\n        ByteBuffer expected1 = ByteBuffer.allocate(5);\n\n        expected1.put(new byte[]\n                { (byte)0x01, (byte)0x03, (byte)0x48, (byte)0x65, (byte)0x6c });\n\n        ByteBuffer expected2 = ByteBuffer.allocate(4);\n\n        expected2.put(new byte[]\n                { (byte)0x80, (byte)0x02, (byte)0x6c, (byte)0x6f });\n\n        expected1.flip();\n        actual1.flip();\n        expected2.flip();\n        actual2.flip();\n\n        ByteBufferAssert.assertEquals(\"t1 buffers are not equal\",expected1,actual1);\n        ByteBufferAssert.assertEquals(\"t2 buffers are not equal\",expected2,actual2);\n    }","id":91307,"modified_method":"@Test\n    public void testFragmentedUnmaskedTextMessage()\n    {\n        WebSocketFrame text1 = FrameBuilder.text(\"Hel\").fin(false).asFrame();\n        WebSocketFrame text2 = FrameBuilder.continuation(\"lo\").asFrame();\n\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n\n        Generator generator = new Generator(policy);\n\n        ByteBuffer actual1 = generator.generate(text1);\n        ByteBuffer actual2 = generator.generate(text2);\n\n        ByteBuffer expected1 = ByteBuffer.allocate(5);\n\n        expected1.put(new byte[]\n                { (byte)0x01, (byte)0x03, (byte)0x48, (byte)0x65, (byte)0x6c });\n\n        ByteBuffer expected2 = ByteBuffer.allocate(4);\n\n        expected2.put(new byte[]\n                { (byte)0x80, (byte)0x02, (byte)0x6c, (byte)0x6f });\n\n        expected1.flip();\n        actual1.flip();\n        expected2.flip();\n        actual2.flip();\n\n        ByteBufferAssert.assertEquals(\"t1 buffers are not equal\",expected1,actual1);\n        ByteBufferAssert.assertEquals(\"t2 buffers are not equal\",expected2,actual2);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleUnmasked64KBinaryMessage()\n    {\n        int dataSize = 1024 * 64;\n\n        WebSocketFrame binary = FrameBuilder.binary().asFrame();\n        byte payload[] = new byte[dataSize];\n        Arrays.fill(payload,(byte)0x44);\n        binary.setPayload(payload);\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        Generator gen = new Generator(policy);\n\n        ByteBuffer actual = ByteBuffer.allocate(dataSize + 10);\n        gen.generate(actual,binary);\n\n        ByteBuffer expected = ByteBuffer.allocate(dataSize + 10);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 64k bytes binary message in a single unmasked frame\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x7F });\n        expected.putInt(0x00_00_00_00);\n        expected.putInt(0x00_01_00_00);\n\n        for (int i = 0; i < dataSize; i++)\n        {\n            expected.put((byte)0x44);\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"binary buffers are not equal\",expected,actual);\n    }","id":91308,"modified_method":"@Test\n    public void testSingleUnmasked64KBinaryMessage()\n    {\n        int dataSize = 1024 * 64;\n\n        WebSocketFrame binary = FrameBuilder.binary().asFrame();\n        byte payload[] = new byte[dataSize];\n        Arrays.fill(payload,(byte)0x44);\n        binary.setPayload(payload);\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        Generator gen = new Generator(policy);\n\n        ByteBuffer actual = gen.generate(binary);\n\n        ByteBuffer expected = ByteBuffer.allocate(dataSize + 10);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 64k bytes binary message in a single unmasked frame\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x7F });\n        expected.putInt(0x00_00_00_00);\n        expected.putInt(0x00_01_00_00);\n\n        for (int i = 0; i < dataSize; i++)\n        {\n            expected.put((byte)0x44);\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"binary buffers are not equal\",expected,actual);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleUnmaskedPingRequest() throws Exception\n    {\n        WebSocketFrame ping = FrameBuilder.ping(\"Hello\").asFrame();\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n\n        Generator gen = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(32);\n        gen.generate(actual,ping);\n        actual.flip(); // make readable\n\n        ByteBuffer expected = ByteBuffer.allocate(10);\n        expected.put(new byte[]\n                { (byte)0x89, (byte)0x05, (byte)0x48, (byte)0x65, (byte)0x6c, (byte)0x6c, (byte)0x6f });\n        expected.flip(); // make readable\n\n        ByteBufferAssert.assertEquals(\"Ping buffers\",expected,actual);\n    }","id":91309,"modified_method":"@Test\n    public void testSingleUnmaskedPingRequest() throws Exception\n    {\n        WebSocketFrame ping = FrameBuilder.ping(\"Hello\").asFrame();\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n\n        Generator gen = new Generator(policy);\n        ByteBuffer actual = gen.generate(ping);\n        actual.flip(); // make readable\n\n        ByteBuffer expected = ByteBuffer.allocate(10);\n        expected.put(new byte[]\n                { (byte)0x89, (byte)0x05, (byte)0x48, (byte)0x65, (byte)0x6c, (byte)0x6c, (byte)0x6f });\n        expected.flip(); // make readable\n\n        ByteBufferAssert.assertEquals(\"Ping buffers\",expected,actual);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleMaskedTextMessage()\n    {\n        WebSocketFrame text = FrameBuilder.text(\"Hello\").mask(new byte[]\n                { 0x37, (byte)0xfa, 0x21, 0x3d }).asFrame();\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n\n        Generator gen = new Generator(policy);\n\n        ByteBuffer actual = ByteBuffer.allocate(32);\n        gen.generate(actual,text);\n        actual.flip(); // make readable\n\n        ByteBuffer expected = ByteBuffer.allocate(11);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // A single-frame masked text message\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x85, 0x37, (byte)0xfa, 0x21, 0x3d, 0x7f, (byte)0x9f, 0x4d, 0x51, 0x58 });\n        expected.flip(); // make readable\n\n        ByteBufferAssert.assertEquals(\"masked text buffers are not equal\",expected,actual);\n    }","id":91310,"modified_method":"@Test\n    public void testSingleMaskedTextMessage()\n    {\n        WebSocketFrame text = FrameBuilder.text(\"Hello\").mask(new byte[]\n                { 0x37, (byte)0xfa, 0x21, 0x3d }).asFrame();\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n\n        Generator gen = new Generator(policy);\n        ByteBuffer actual = gen.generate(text);\n\n        actual.flip(); // make readable\n\n        ByteBuffer expected = ByteBuffer.allocate(11);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // A single-frame masked text message\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x85, 0x37, (byte)0xfa, 0x21, 0x3d, 0x7f, (byte)0x9f, 0x4d, 0x51, 0x58 });\n        expected.flip(); // make readable\n\n        ByteBufferAssert.assertEquals(\"masked text buffers are not equal\",expected,actual);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleUnmasked256ByteBinaryMessage()\n    {\n        int dataSize = 256;\n\n        WebSocketFrame binary = FrameBuilder.binary().asFrame();\n        byte payload[] = new byte[dataSize];\n        Arrays.fill(payload,(byte)0x44);\n        binary.setPayload(payload);\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        Generator gen = new Generator(policy);\n\n        ByteBuffer actual = ByteBuffer.allocate(dataSize + FUDGE);\n        gen.generate(actual,binary);\n\n        ByteBuffer expected = ByteBuffer.allocate(dataSize + FUDGE);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 256 bytes binary message in a single unmasked frame\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x7E });\n        expected.putShort((short)0x01_00);\n\n        for (int i = 0; i < dataSize; i++)\n        {\n            expected.put((byte)0x44);\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"binary buffers are not equal\",expected,actual);\n    }","id":91311,"modified_method":"@Test\n    public void testSingleUnmasked256ByteBinaryMessage()\n    {\n        int dataSize = 256;\n\n        WebSocketFrame binary = FrameBuilder.binary().asFrame();\n        byte payload[] = new byte[dataSize];\n        Arrays.fill(payload,(byte)0x44);\n        binary.setPayload(payload);\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        Generator gen = new Generator(policy);\n\n        ByteBuffer actual = gen.generate(binary);\n\n        ByteBuffer expected = ByteBuffer.allocate(dataSize + FUDGE);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 256 bytes binary message in a single unmasked frame\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x7E });\n        expected.putShort((short)0x01_00);\n\n        for (int i = 0; i < dataSize; i++)\n        {\n            expected.put((byte)0x44);\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"binary buffers are not equal\",expected,actual);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleMaskedPongRequest()\n    {\n        WebSocketFrame pong = FrameBuilder.pong(\"Hello\").mask(new byte[]\n                { 0x37, (byte)0xfa, 0x21, 0x3d }).asFrame();\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        Generator gen = new Generator(policy);\n\n        ByteBuffer actual = ByteBuffer.allocate(32);\n        gen.generate(actual,pong);\n        actual.flip(); // make readable\n\n        ByteBuffer expected = ByteBuffer.allocate(11);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // Unmasked Pong request\n        expected.put(new byte[]\n                { (byte)0x8a, (byte)0x85, 0x37, (byte)0xfa, 0x21, 0x3d, 0x7f, (byte)0x9f, 0x4d, 0x51, 0x58 });\n        expected.flip(); // make readable\n\n        ByteBufferAssert.assertEquals(\"pong buffers are not equal\",expected,actual);\n    }","id":91312,"modified_method":"@Test\n    public void testSingleMaskedPongRequest()\n    {\n        WebSocketFrame pong = FrameBuilder.pong(\"Hello\").mask(new byte[]\n                { 0x37, (byte)0xfa, 0x21, 0x3d }).asFrame();\n\n        WebSocketPolicy policy = WebSocketPolicy.newServerPolicy();\n        Generator gen = new Generator(policy);\n\n        ByteBuffer actual = gen.generate(pong);\n        actual.flip(); // make readable\n\n        ByteBuffer expected = ByteBuffer.allocate(11);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // Unmasked Pong request\n        expected.put(new byte[]\n                { (byte)0x8a, (byte)0x85, 0x37, (byte)0xfa, 0x21, 0x3d, 0x7f, (byte)0x9f, 0x4d, 0x51, 0x58 });\n        expected.flip(); // make readable\n\n        ByteBufferAssert.assertEquals(\"pong buffers are not equal\",expected,actual);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleUnmaskedTextMessage()\n    {\n        WebSocketFrame text = FrameBuilder.text(\"Hello\").asFrame();\n\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n\n        Generator generator = new Generator(policy);\n\n        ByteBuffer actual = ByteBuffer.allocate(32);\n        generator.generate(actual,text);\n\n        ByteBuffer expected = ByteBuffer.allocate(10);\n\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x05, (byte)0x48, (byte)0x65, (byte)0x6c, (byte)0x6c, (byte)0x6f });\n\n        expected.flip();\n        actual.flip();\n\n        ByteBufferAssert.assertEquals(\"t1 buffers are not equal\",expected,actual);\n    }","id":91313,"modified_method":"@Test\n    public void testSingleUnmaskedTextMessage()\n    {\n        WebSocketFrame text = FrameBuilder.text(\"Hello\").asFrame();\n\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n\n        Generator generator = new Generator(policy);\n\n        ByteBuffer actual = generator.generate(text);\n\n        ByteBuffer expected = ByteBuffer.allocate(10);\n\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x05, (byte)0x48, (byte)0x65, (byte)0x6c, (byte)0x6c, (byte)0x6f });\n\n        expected.flip();\n        actual.flip();\n\n        ByteBufferAssert.assertEquals(\"t1 buffers are not equal\",expected,actual);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse65536ByteTextCase1_1_7()\n    {\n        int length = 65536;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 11);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= 0x7F;\n        expected.put(b);\n        expected.put(new byte[]\n                { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n        policy.setMaxTextMessageSize(length);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","id":91314,"modified_method":"@Test\n    public void testParse65536ByteTextCase1_1_7()\n    {\n        int length = 65536;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 11);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= 0x7F;\n        expected.put(b);\n        expected.put(new byte[]\n                { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n        policy.setMaxTextMessageSize(length);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        // Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate126ByteTextCase1_1_3()\n    {\n        int length = 126;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(length + 16);\n        generator.generate(actual,textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        // expected.put((byte)((length>>8) & 0xFF));\n        // expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":91315,"modified_method":"@Test\n    public void testGenerate126ByteTextCase1_1_3()\n    {\n        int length = 126;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        // expected.put((byte)((length>>8) & 0xFF));\n        // expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse126ByteTextCase1_1_3()\n    {\n        int length = 126;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","id":91316,"modified_method":"@Test\n    public void testParse126ByteTextCase1_1_3()\n    {\n        int length = 126;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        // Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate128ByteTextCase1_1_5()\n    {\n        int length = 128;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(length + 16);\n        generator.generate(actual,textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n\n        expected.put((byte)(length >> 8));\n        expected.put((byte)(length & 0xFF));\n        // expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":91317,"modified_method":"@Test\n    public void testGenerate128ByteTextCase1_1_5()\n    {\n        int length = 128;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n\n        expected.put((byte)(length >> 8));\n        expected.put((byte)(length & 0xFF));\n        // expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate65535ByteTextCase1_1_6()\n    {\n        int length = 65535;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(length + 16);\n        generator.generate(actual,textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.put(new byte[]\n                { (byte)0xff, (byte)0xff });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":91318,"modified_method":"@Test\n    public void testGenerate65535ByteTextCase1_1_6()\n    {\n        int length = 65535;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.put(new byte[]\n                { (byte)0xff, (byte)0xff });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate65536ByteTextCase1_1_7()\n    {\n        int length = 65536;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(length + 16);\n        generator.generate(actual,textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 11);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7F;\n        expected.put(b);\n        expected.put(new byte[]\n                { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":91319,"modified_method":"@Test\n    public void testGenerate65536ByteTextCase1_1_7()\n    {\n        int length = 65536;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 11);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7F;\n        expected.put(b);\n        expected.put(new byte[]\n                { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateEmptyTextCase1_1_1()\n    {\n        WebSocketFrame textFrame = FrameBuilder.text(\"\").asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(10);\n        generator.generate(actual,textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x00 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":91320,"modified_method":"@Test\n    public void testGenerateEmptyTextCase1_1_1()\n    {\n        WebSocketFrame textFrame = FrameBuilder.text(\"\").asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x81, (byte)0x00 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse65535ByteTextCase1_1_6()\n    {\n        // Debug.enableDebugLogging(Parser.class);\n        // Debug.enableDebugLogging(TextPayloadParser.class);\n\n        int length = 65535;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.put(new byte[]\n                { (byte)0xff, (byte)0xff });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n        policy.setMaxTextMessageSize(length);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","id":91321,"modified_method":"@Test\n    public void testParse65535ByteTextCase1_1_6()\n    {\n        // Debug.enableDebugLogging(Parser.class);\n        // Debug.enableDebugLogging(TextPayloadParser.class);\n\n        int length = 65535;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.put(new byte[]\n                { (byte)0xff, (byte)0xff });\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n        policy.setMaxTextMessageSize(length);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        // Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse127ByteTextCase1_1_4()\n    {\n        int length = 127;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","id":91322,"modified_method":"@Test\n    public void testParse127ByteTextCase1_1_4()\n    {\n        int length = 127;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        // Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate125ByteTextCase1_1_2()\n    {\n        int length = 125;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(length + 16);\n        generator.generate(actual,textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7F;\n        expected.put(b);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":91323,"modified_method":"@Test\n    public void testGenerate125ByteTextCase1_1_2()\n    {\n        int length = 125;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7F;\n        expected.put(b);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse128ByteTextCase1_1_5()\n    {\n        int length = 128;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","id":91324,"modified_method":"@Test\n    public void testParse128ByteTextCase1_1_5()\n    {\n        int length = 128;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        // .assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate127ByteTextCase1_1_4()\n    {\n        int length = 127;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(length + 16);\n        generator.generate(actual,textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        // expected.put((byte)((length>>8) & 0xFF));\n        // expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":91325,"modified_method":"@Test\n    public void testGenerate127ByteTextCase1_1_4()\n    {\n        int length = 127;\n\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < length; ++i)\n        {\n            builder.append(\"*\");\n        }\n\n        WebSocketFrame textFrame = FrameBuilder.text(builder.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(textFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        // expected.put((byte)((length>>8) & 0xFF));\n        // expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse125ByteTextCase1_1_2()\n    {\n        int length = 125;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7F;\n        expected.put(b);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","id":91326,"modified_method":"@Test\n    public void testParse125ByteTextCase1_1_2()\n    {\n        int length = 125;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x81 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7F;\n        expected.put(b);\n\n        for (int i = 0; i < length; ++i)\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.TEXT,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        // Assert.assertEquals(\"TextFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate128ByteBinaryCase1_2_5()\n    {\n        int length = 128;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(length + 11);\n        generator.generate(actual,binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n\n        expected.put((byte)(length>>8));\n        expected.put((byte)(length & 0xFF));\n        //expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":91327,"modified_method":"@Test\n    public void testGenerate128ByteBinaryCase1_2_5()\n    {\n        int length = 128;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n\n        expected.put((byte)(length>>8));\n        expected.put((byte)(length & 0xFF));\n        //expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate65536ByteBinaryCase1_2_7()\n    {\n        int length = 65536;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(length + 32);\n        generator.generate(actual,binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 11);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7F;\n        expected.put(b);\n        expected.put(new byte[]{0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00});\n\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":91328,"modified_method":"@Test\n    public void testGenerate65536ByteBinaryCase1_2_7()\n    {\n        int length = 65536;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 11);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7F;\n        expected.put(b);\n        expected.put(new byte[]{0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00});\n\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate125ByteBinaryCase1_2_2()\n    {\n        int length = 125;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n\n        ByteBuffer actual = ByteBuffer.allocate(length + 11);\n\n        generator.generate(actual, binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7F;\n        expected.put(b);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":91329,"modified_method":"@Test\n    public void testGenerate125ByteBinaryCase1_2_2()\n    {\n        int length = 125;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7F;\n        expected.put(b);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateEmptyBinaryCase1_2_1()\n    {\n        WebSocketFrame binaryFrame = FrameBuilder.binary(new byte[] {}).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(32);\n        generator.generate(actual, binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x00 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":91330,"modified_method":"@Test\n    public void testGenerateEmptyBinaryCase1_2_1()\n    {\n        WebSocketFrame binaryFrame = FrameBuilder.binary(new byte[] {}).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x00 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse65536ByteBinaryCase1_2_7()\n    {\n        int length = 65536;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 11);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n        byte b = 0x00; // no masking\n        b |= 0x7F;\n        expected.put(b);\n        expected.put(new byte[]{0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00});\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n        policy.setMaxTextMessageSize(length);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.BINARY,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"BinaryFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"BinaryFrame.payload\",length,pActual.getPayloadData().length);\n    }","id":91331,"modified_method":"@Test\n    public void testParse65536ByteBinaryCase1_2_7()\n    {\n        int length = 65536;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 11);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n        byte b = 0x00; // no masking\n        b |= 0x7F;\n        expected.put(b);\n        expected.put(new byte[]{0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00});\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n        policy.setMaxTextMessageSize(length);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.BINARY,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"BinaryFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        // Assert.assertEquals(\"BinaryFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate126ByteBinaryCase1_2_3()\n    {\n        int length = 126;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n\n        ByteBuffer actual = ByteBuffer.allocate(length + 11);\n\n        generator.generate(actual, binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        //expected.put((byte)((length>>8) & 0xFF));\n        //expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":91332,"modified_method":"@Test\n    public void testGenerate126ByteBinaryCase1_2_3()\n    {\n        int length = 126;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        //expected.put((byte)((length>>8) & 0xFF));\n        //expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse65535ByteBinaryCase1_2_6()\n    {\n        int length = 65535;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.put(new byte[]{ (byte)0xff, (byte)0xff});\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n        policy.setMaxTextMessageSize(length);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.BINARY,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"BinaryFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"BinaryFrame.payload\",length,pActual.getPayloadData().length);\n    }","id":91333,"modified_method":"@Test\n    public void testParse65535ByteBinaryCase1_2_6()\n    {\n        int length = 65535;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.put(new byte[]{ (byte)0xff, (byte)0xff});\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\n        policy.setMaxTextMessageSize(length);\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.BINARY,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"BinaryFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        // Assert.assertEquals(\"BinaryFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate127ByteBinaryCase1_2_4()\n    {\n        int length = 127;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n\n        ByteBuffer actual = ByteBuffer.allocate(length + 11);\n        generator.generate(actual, binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        //expected.put((byte)((length>>8) & 0xFF));\n        //expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":91334,"modified_method":"@Test\n    public void testGenerate127ByteBinaryCase1_2_4()\n    {\n        int length = 127;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n\n        //expected.put((byte)((length>>8) & 0xFF));\n        //expected.put((byte)(length & 0xFF));\n        expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParseEmptyBinaryCase1_2_1()\n    {\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x00 });\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.BINARY,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"BinaryFrame.payloadLength\",pActual.getPayloadLength(),is(0));\n        Assert.assertNull(\"BinaryFrame.payload\",pActual.getPayloadData());\n    }","id":91335,"modified_method":"@Test\n    public void testParseEmptyBinaryCase1_2_1()\n    {\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x82, (byte)0x00 });\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.BINARY,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"BinaryFrame.payloadLength\",pActual.getPayloadLength(),is(0));\n        // Assert.assertNull(\"BinaryFrame.payload\",pActual.getPayloadData());\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate65535ByteBinaryCase1_2_6()\n    {\n        int length = 65535;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(length + 11);\n        generator.generate(actual,binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.put(new byte[]{ (byte)0xff, (byte)0xff});\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","id":91336,"modified_method":"@Test\n    public void testGenerate65535ByteBinaryCase1_2_6()\n    {\n        int length = 65535;\n\n        ByteBuffer bb = ByteBuffer.allocate(length);\n\n        for ( int i = 0 ; i < length ; ++i)\n        {\n            bb.put(\"*\".getBytes());\n\n        }\n\n        bb.flip();\n\n        WebSocketFrame binaryFrame = FrameBuilder.binary(BufferUtil.toArray(bb)).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(binaryFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.put(new byte[]{ (byte)0xff, (byte)0xff});\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse125ByteBinaryCase1_2_2()\n    {\n        int length = 125;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7F;\n        expected.put(b);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.BINARY,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"BinaryFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"BinaryFrame.payload\",length,pActual.getPayloadData().length);\n    }","id":91337,"modified_method":"@Test\n    public void testParse125ByteBinaryCase1_2_2()\n    {\n        int length = 125;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7F;\n        expected.put(b);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.BINARY,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"BinaryFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        // Assert.assertEquals(\"BinaryFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse127ByteBinaryCase1_2_4()\n    {\n        int length = 127;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.BINARY,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"BinaryFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"BinaryFrame.payload\",length,pActual.getPayloadData().length);\n    }","id":91338,"modified_method":"@Test\n    public void testParse127ByteBinaryCase1_2_4()\n    {\n        int length = 127;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.BINARY,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"BinaryFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        // .assertEquals(\"BinaryFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse126ByteBinaryCase1_2_3()\n    {\n        int length = 126;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.BINARY,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"BinaryFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"BinaryFrame.payload\",length,pActual.getPayloadData().length);\n    }","id":91339,"modified_method":"@Test\n    public void testParse126ByteBinaryCase1_2_3()\n    {\n        int length = 126;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n        byte b = 0x00; // no masking\n        b |= length & 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.BINARY,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"BinaryFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        // Assert.assertEquals(\"BinaryFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParse128ByteBinaryCase1_2_5()\n    {\n        int length = 128;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.BINARY,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"BinaryFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        Assert.assertEquals(\"BinaryFrame.payload\",length,pActual.getPayloadData().length);\n    }","id":91340,"modified_method":"@Test\n    public void testParse128ByteBinaryCase1_2_5()\n    {\n        int length = 128;\n\n        ByteBuffer expected = ByteBuffer.allocate(length + 5);\n\n        expected.put(new byte[]\n                { (byte)0x82 });\n        byte b = 0x00; // no masking\n        b |= 0x7E;\n        expected.put(b);\n        expected.putShort((short)length);\n\n        for ( int i = 0 ; i < length ; ++i )\n        {\n            expected.put(\"*\".getBytes());\n        }\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(OpCode.BINARY,1);\n\n        WebSocketFrame pActual = capture.getFrames().get(0);\n        Assert.assertThat(\"BinaryFrame.payloadLength\",pActual.getPayloadLength(),is(length));\n        // Assert.assertEquals(\"BinaryFrame.payload\",length,pActual.getPayloadData().length);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateEmptyPingCase2_1()\n    {\n        WebSocketFrame pingFrame = FrameBuilder.ping().asFrame();\n\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(32);\n        generator.generate(actual, pingFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x89, (byte)0x00 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","id":91341,"modified_method":"@Test\n    public void testGenerateEmptyPingCase2_1()\n    {\n        WebSocketFrame pingFrame = FrameBuilder.ping().asFrame();\n\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(pingFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x89, (byte)0x00 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerate125OctetPingCase2_4()\n    {\n        byte[] bytes = new byte[125];\n\n        for ( int i = 0 ; i < bytes.length ; ++i )\n        {\n            bytes[i] = Integer.valueOf(Integer.toOctalString(i)).byteValue();\n        }\n\n        WebSocketFrame pingFrame = FrameBuilder.ping().payload(bytes).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(bytes.length + 32);\n        generator.generate(actual, pingFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(bytes.length + 32);\n\n        expected.put(new byte[]\n                { (byte)0x89 });\n\n        byte b = 0x00; // no masking\n        b |= bytes.length & 0x7F;\n        expected.put(b);\n        expected.put(bytes);\n\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","id":91342,"modified_method":"@Test\n    public void testGenerate125OctetPingCase2_4()\n    {\n        byte[] bytes = new byte[125];\n\n        for ( int i = 0 ; i < bytes.length ; ++i )\n        {\n            bytes[i] = Integer.valueOf(Integer.toOctalString(i)).byteValue();\n        }\n\n        WebSocketFrame pingFrame = FrameBuilder.ping().payload(bytes).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(pingFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(bytes.length + 32);\n\n        expected.put(new byte[]\n                { (byte)0x89 });\n\n        byte b = 0x00; // no masking\n        b |= bytes.length & 0x7F;\n        expected.put(b);\n        expected.put(bytes);\n\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test( expected=WebSocketException.class )\n    public void testGenerateOversizedBinaryPingCase2_5_B()\n    {\n        byte[] bytes = new byte[126];\n\n        for ( int i = 0 ; i < bytes.length ; ++i )\n        {\n            bytes[i] = 0x00;\n        }\n\n        WebSocketFrame pingFrame = FrameBuilder.ping().payload(bytes).asFrame();\n\n        Generator generator = new Generator(WebSocketPolicy.newServerPolicy());\n        generator.generate(ByteBuffer.allocate(bytes.length + 32),pingFrame);\n    }","id":91343,"modified_method":"@Test( expected=WebSocketException.class )\n    public void testGenerateOversizedBinaryPingCase2_5_B()\n    {\n        byte[] bytes = new byte[126];\n\n        for ( int i = 0 ; i < bytes.length ; ++i )\n        {\n            bytes[i] = 0x00;\n        }\n\n        WebSocketFrame pingFrame = FrameBuilder.ping().payload(bytes).asFrame();\n\n        Generator generator = new Generator(WebSocketPolicy.newServerPolicy());\n        generator.generate(pingFrame);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateBinaryPingCase2_3()\n    {\n        byte[] bytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };\n\n        WebSocketFrame pingFrame = FrameBuilder.ping().payload(bytes).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(32);\n        generator.generate(actual, pingFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(32);\n\n        expected.put(new byte[]\n                { (byte)0x89 });\n\n        byte b = 0x00; // no masking\n        b |= bytes.length & 0x7F;\n        expected.put(b);\n        expected.put(bytes);\n\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","id":91344,"modified_method":"@Test\n    public void testGenerateBinaryPingCase2_3()\n    {\n        byte[] bytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };\n\n        WebSocketFrame pingFrame = FrameBuilder.ping().payload(bytes).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(pingFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(32);\n\n        expected.put(new byte[]\n                { (byte)0x89 });\n\n        byte b = 0x00; // no masking\n        b |= bytes.length & 0x7F;\n        expected.put(b);\n        expected.put(bytes);\n\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testParseOversizedBinaryPingCase2_5()\n    {\n        byte[] bytes = new byte[126];\n        Arrays.fill(bytes,(byte)0x00);\n\n        ByteBuffer expected = ByteBuffer.allocate(bytes.length + FrameGenerator.OVERHEAD);\n\n        byte b;\n\n        // fin + op\n        b = 0x00;\n        b |= 0x80; // fin on\n        b |= 0x09; // ping\n        expected.put(b);\n\n        // mask + len\n        b = 0x00;\n        b |= 0x00; // no masking\n        b |= 0x7E; // 2 byte len\n        expected.put(b);\n\n        // 2 byte len\n        expected.putChar((char)bytes.length);\n\n        // payload\n        expected.put(bytes);\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        Assert.assertEquals(\"error should be returned for too large of ping payload\",1,capture.getErrorCount(ProtocolException.class));\n    }","id":91345,"modified_method":"@Test\n    public void testParseOversizedBinaryPingCase2_5()\n    {\n        byte[] bytes = new byte[126];\n        Arrays.fill(bytes,(byte)0x00);\n\n        ByteBuffer expected = ByteBuffer.allocate(bytes.length + Generator.OVERHEAD);\n\n        byte b;\n\n        // fin + op\n        b = 0x00;\n        b |= 0x80; // fin on\n        b |= 0x09; // ping\n        expected.put(b);\n\n        // mask + len\n        b = 0x00;\n        b |= 0x00; // no masking\n        b |= 0x7E; // 2 byte len\n        expected.put(b);\n\n        // 2 byte len\n        expected.putChar((char)bytes.length);\n\n        // payload\n        expected.put(bytes);\n\n        expected.flip();\n\n        Parser parser = new Parser(policy);\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(expected);\n\n        Assert.assertEquals(\"error should be returned for too large of ping payload\",1,capture.getErrorCount(ProtocolException.class));\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateHelloPingCase2_2()\n    {\n        String message = \"Hello, world!\";\n        byte[] messageBytes = message.getBytes();\n\n        WebSocketFrame pingFrame = FrameBuilder.ping(message).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(32);\n        generator.generate(actual, pingFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(32);\n\n        expected.put(new byte[]\n                { (byte)0x89 });\n\n        byte b = 0x00; // no masking\n        b |= messageBytes.length & 0x7F;\n        expected.put(b);\n        expected.put(messageBytes);\n\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","id":91346,"modified_method":"@Test\n    public void testGenerateHelloPingCase2_2()\n    {\n        String message = \"Hello, world!\";\n        byte[] messageBytes = message.getBytes();\n\n        WebSocketFrame pingFrame = FrameBuilder.ping(message).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(pingFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(32);\n\n        expected.put(new byte[]\n                { (byte)0x89 });\n\n        byte b = 0x00; // no masking\n        b |= messageBytes.length & 0x7F;\n        expected.put(b);\n        expected.put(messageBytes);\n\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test(expected = ProtocolException.class)\n    public void testGenerateInvalidControlFrame()\n    {\n        Generator generator = new Generator(WebSocketPolicy.newServerPolicy());\n\n        generator.generate(ByteBuffer.allocate(32),invalidFrame);\n    }","id":91347,"modified_method":"@Test(expected = ProtocolException.class)\n    public void testGenerateInvalidControlFrame()\n    {\n        Generator generator = new Generator(WebSocketPolicy.newServerPolicy());\n\n        generator.generate(invalidFrame);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testCase7_3_3GenerateCloseWithStatus()\n    {\n        WebSocketFrame closeFrame = FrameBuilder.close(1000).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(32);\n        generator.generate(actual, closeFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x88, (byte)0x02, 0x03, (byte)0xe8 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","id":91348,"modified_method":"@Test\n    public void testCase7_3_3GenerateCloseWithStatus()\n    {\n        WebSocketFrame closeFrame = FrameBuilder.close(1000).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(closeFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x88, (byte)0x02, 0x03, (byte)0xe8 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testCase7_3_1GenerateEmptyClose()\n    {\n        WebSocketFrame closeFrame = FrameBuilder.close().asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(32);\n        generator.generate(actual, closeFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x88, (byte)0x00 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","id":91349,"modified_method":"@Test\n    public void testCase7_3_1GenerateEmptyClose()\n    {\n        WebSocketFrame closeFrame = FrameBuilder.close().asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(closeFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(5);\n\n        expected.put(new byte[]\n                { (byte)0x88, (byte)0x00 });\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test(expected = ProtocolException.class)\n    public void testCase7_3_6GenerateCloseWithInvalidStatusReason()\n    {\n        StringBuilder message = new StringBuilder();\n        for ( int i = 0 ; i < 124 ; ++i )\n        {\n            message.append(\"*\");\n        }\n\n        byte[] messageBytes = message.toString().getBytes();\n\n        WebSocketFrame closeFrame = FrameBuilder.close().asFrame();\n\n        ByteBuffer bb = ByteBuffer.allocate(WebSocketFrame.MAX_CONTROL_PAYLOAD + 1); // 126 which is too big for control\n\n        bb.putChar((char)1000);\n        bb.put(messageBytes);\n\n        BufferUtil.flipToFlush(bb,0);\n\n        closeFrame.setPayload(BufferUtil.toArray(bb));\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(32);\n        generator.generate(actual,closeFrame);\n    }","id":91350,"modified_method":"@Test(expected = ProtocolException.class)\n    public void testCase7_3_6GenerateCloseWithInvalidStatusReason()\n    {\n        StringBuilder message = new StringBuilder();\n        for ( int i = 0 ; i < 124 ; ++i )\n        {\n            message.append(\"*\");\n        }\n\n        byte[] messageBytes = message.toString().getBytes();\n\n        WebSocketFrame closeFrame = FrameBuilder.close().asFrame();\n\n        ByteBuffer bb = ByteBuffer.allocate(WebSocketFrame.MAX_CONTROL_PAYLOAD + 1); // 126 which is too big for control\n\n        bb.putChar((char)1000);\n        bb.put(messageBytes);\n\n        BufferUtil.flipToFlush(bb,0);\n\n        closeFrame.setPayload(BufferUtil.toArray(bb));\n\n        Generator generator = new Generator(policy);\n        generator.generate(closeFrame);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test (expected = WebSocketException.class)\n    public void testCase7_3_2Generate1BytePayloadClose()\n    {\n        WebSocketFrame closeFrame = FrameBuilder.close().payload(new byte[]\n                { 0x00 }).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(32);\n        generator.generate(actual, closeFrame);\n    }","id":91351,"modified_method":"@Test (expected = WebSocketException.class)\n    public void testCase7_3_2Generate1BytePayloadClose()\n    {\n        WebSocketFrame closeFrame = FrameBuilder.close().payload(new byte[]\n                { 0x00 }).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(closeFrame);\n\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testCase7_3_4GenerateCloseWithStatusReason()\n    {\n        String message = \"bad cough\";\n        byte[] messageBytes = message.getBytes();\n\n        WebSocketFrame closeFrame = FrameBuilder.close(1000,message.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(32);\n        generator.generate(actual, closeFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(32);\n\n        expected.put(new byte[]\n                { (byte)0x88 });\n\n        byte b = 0x00; // no masking\n        b |= (message.length() + 2) & 0x7F;\n        expected.put(b);\n        expected.putShort((short)1000);\n        expected.put(messageBytes);\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","id":91352,"modified_method":"@Test\n    public void testCase7_3_4GenerateCloseWithStatusReason()\n    {\n        String message = \"bad cough\";\n        byte[] messageBytes = message.getBytes();\n\n        WebSocketFrame closeFrame = FrameBuilder.close(1000,message.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(closeFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(32);\n\n        expected.put(new byte[]\n                { (byte)0x88 });\n\n        byte b = 0x00; // no masking\n        b |= (message.length() + 2) & 0x7F;\n        expected.put(b);\n        expected.putShort((short)1000);\n        expected.put(messageBytes);\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testCase7_3_5GenerateCloseWithStatusMaxReason()\n    {\n        StringBuilder message = new StringBuilder();\n        for ( int i = 0 ; i < 123 ; ++i )\n        {\n            message.append(\"*\");\n        }\n\n        byte[] messageBytes = message.toString().getBytes();\n\n        WebSocketFrame closeFrame = FrameBuilder.close(1000,message.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = ByteBuffer.allocate(132);\n        generator.generate(actual, closeFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(132);\n\n\n        expected.put(new byte[]\n                { (byte)0x88 });\n\n        byte b = 0x00; // no masking\n        b |= (messageBytes.length + 2) & 0x7F;\n        expected.put(b);\n        expected.putShort((short)1000);\n\n        expected.put(messageBytes);\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","id":91353,"modified_method":"@Test\n    public void testCase7_3_5GenerateCloseWithStatusMaxReason()\n    {\n        StringBuilder message = new StringBuilder();\n        for ( int i = 0 ; i < 123 ; ++i )\n        {\n            message.append(\"*\");\n        }\n\n        byte[] messageBytes = message.toString().getBytes();\n\n        WebSocketFrame closeFrame = FrameBuilder.close(1000,message.toString()).asFrame();\n\n        Generator generator = new Generator(policy);\n        ByteBuffer actual = generator.generate(closeFrame);\n\n        ByteBuffer expected = ByteBuffer.allocate(132);\n\n\n        expected.put(new byte[]\n                { (byte)0x88 });\n\n        byte b = 0x00; // no masking\n        b |= (messageBytes.length + 2) & 0x7F;\n        expected.put(b);\n        expected.putShort((short)1000);\n\n        expected.put(messageBytes);\n\n        actual.flip();\n        expected.flip();\n\n        ByteBufferAssert.assertEquals(\"buffers do not match\",expected,actual);\n    }","commit_id":"3754f9e04cab017deace8306b22f89df4c98b83b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void readExistingNodes() {\n        FetchNodesAction action = new FetchNodesAction(nodeStore, affectedPaths,\n                mongoSync.getHeadRevisionId());\n        action.setBranchId(branchId);\n        action.setValidCommits(validCommits);\n        existingNodes = action.execute();\n    }","id":91354,"modified_method":"private void readExistingNodes() {\n        FetchNodesAction action = new FetchNodesAction(nodeStore, affectedPaths,\n                branchId == null? mongoSync.getHeadRevisionId() : baseRevisionId);\n        action.setBranchId(branchId);\n        action.setValidCommits(validCommits);\n        existingNodes = action.execute();\n    }","commit_id":"7fd960b93601b1a4a7966d3fe46789308800e78b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Protected for testing purposed only.\n     *\n     * @return True if the operation was successful.\n     * @throws Exception If an exception happens.\n     */\n    protected boolean saveAndSetHeadRevision() throws Exception {\n        long assumedHeadRevision = this.mongoSync.getHeadRevisionId();\n        MongoSync mongoSync = new SaveAndSetHeadRevisionAction(nodeStore,\n                assumedHeadRevision, revisionId).execute();\n        if (mongoSync == null) {\n            // There have been commit(s) in the meantime. If it's a conflicting\n            // update, retry the whole operation and count against number of retries.\n            // If not, need to retry again (in order to write commits and nodes properly)\n            // but don't count these retries against number of retries.\n            if (conflictingCommitsExist(assumedHeadRevision)) {\n                String message = String.format(\"Commit @%s: failed due to a conflicting commit.\"\n                        + \" Affected paths: %s\", revisionId, commit.getAffectedPaths());\n                logger.warn(message);\n                markAsFailed();\n                throw new ConflictingCommitException(message);\n            } else {\n                logger.info(\"Commit @{}: failed due to a concurrent commit.\"\n                        + \" Affected paths: {}\", revisionId, commit.getAffectedPaths());\n                markAsFailed();\n                return false;\n            }\n        }\n        return true;\n    }","id":91355,"modified_method":"/**\n     * Protected for testing purposed only.\n     *\n     * @return True if the operation was successful.\n     * @throws Exception If an exception happens.\n     */\n    protected boolean saveAndSetHeadRevision() throws Exception {\n        // Don't update the head revision id for branches.\n        if (branchId != null) {\n            return true;\n        }\n\n        long assumedHeadRevision = this.mongoSync.getHeadRevisionId();\n        MongoSync mongoSync = new SaveAndSetHeadRevisionAction(nodeStore,\n                assumedHeadRevision, revisionId).execute();\n        if (mongoSync == null) {\n            // There have been commit(s) in the meantime. If it's a conflicting\n            // update, retry the whole operation and count against number of retries.\n            // If not, need to retry again (in order to write commits and nodes properly)\n            // but don't count these retries against number of retries.\n            if (conflictingCommitsExist(assumedHeadRevision)) {\n                String message = String.format(\"Commit @%s: failed due to a conflicting commit.\"\n                        + \" Affected paths: %s\", revisionId, commit.getAffectedPaths());\n                logger.warn(message);\n                markAsFailed();\n                throw new ConflictingCommitException(message);\n            } else {\n                logger.info(\"Commit @{}: failed due to a concurrent commit.\"\n                        + \" Affected paths: {}\", revisionId, commit.getAffectedPaths());\n                markAsFailed();\n                return false;\n            }\n        }\n        return true;\n    }","commit_id":"7fd960b93601b1a4a7966d3fe46789308800e78b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void prepareCommit() throws Exception {\n        commit.setAffectedPaths(affectedPaths);\n        commit.setBaseRevisionId(mongoSync.getHeadRevisionId());\n        commit.setRevisionId(revisionId);\n        if (commit.getBranchId() == null && branchId != null) {\n            commit.setBranchId(branchId);\n        }\n        commit.removeField(\"_id\"); // In case this is a retry.\n    }","id":91356,"modified_method":"private void prepareCommit() throws Exception {\n        commit.setAffectedPaths(affectedPaths);\n        commit.setBaseRevisionId(branchId == null?\n                mongoSync.getHeadRevisionId() : baseRevisionId);\n        commit.setRevisionId(revisionId);\n        if (commit.getBranchId() == null && branchId != null) {\n            commit.setBranchId(branchId);\n        }\n        commit.removeField(\"_id\"); // In case this is a retry.\n    }","commit_id":"7fd960b93601b1a4a7966d3fe46789308800e78b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void prepareCommit() throws Exception {\n        commit.setAffectedPaths(affectedPaths);\n        commit.setBaseRevisionId(mongoSync.getHeadRevisionId());\n        commit.setRevisionId(revisionId);\n        if (commit.getBranchId() == null && branchId != null) {\n            commit.setBranchId(branchId);\n        }\n        commit.removeField(\"_id\"); // In case this is a retry.\n    }","id":91357,"modified_method":"private void prepareCommit() throws Exception {\n        commit.setAffectedPaths(affectedPaths);\n        commit.setBaseRevisionId(branchId == null?\n                mongoSync.getHeadRevisionId() : baseRevisionId);\n        commit.setRevisionId(revisionId);\n        if (commit.getBranchId() == null && branchId != null) {\n            commit.setBranchId(branchId);\n        }\n        commit.removeField(\"_id\"); // In case this is a retry.\n    }","commit_id":"7fd960b93601b1a4a7966d3fe46789308800e78b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void readExistingNodes() throws Exception {\n        if (affectedPaths == null || affectedPaths.isEmpty()) {\n            existingNodes = Collections.emptyMap();\n        }\n\n        existingNodes = new HashMap<String, MongoNode>();\n        for (String path : affectedPaths) {\n            NodeExistsCommand command = new NodeExistsCommand(\n                    nodeStore, path, mongoSync.getHeadRevisionId());\n            command.setBranchId(branchId);\n            if (command.execute()) {\n                existingNodes.put(path, command.getNode());\n            }\n        }\n    }","id":91358,"modified_method":"private void readExistingNodes() throws Exception {\n        if (affectedPaths == null || affectedPaths.isEmpty()) {\n            existingNodes = Collections.emptyMap();\n        }\n\n        existingNodes = new HashMap<String, MongoNode>();\n        for (String path : affectedPaths) {\n            NodeExistsCommand command;\n            if (branchId == null) {\n                command = new NodeExistsCommand(nodeStore, path, mongoSync.getHeadRevisionId());\n            } else {\n                command = new NodeExistsCommand(nodeStore, path, baseRevisionId);\n                command.setBranchId(branchId);\n            }\n            if (command.execute()) {\n                existingNodes.put(path, command.getNode());\n            }\n        }\n    }","commit_id":"7fd960b93601b1a4a7966d3fe46789308800e78b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Protected for testing purposed only.\n     *\n     * @return True if the operation was successful.\n     * @throws Exception If an exception happens.\n     */\n    protected boolean saveAndSetHeadRevision() throws Exception {\n        long assumedHeadRevision = this.mongoSync.getHeadRevisionId();\n        MongoSync mongoSync = new SaveAndSetHeadRevisionAction(nodeStore,\n                assumedHeadRevision, revisionId).execute();\n        if (mongoSync == null) {\n            // There have been commit(s) in the meantime. If it's a conflicting\n            // update, retry the whole operation and count against number of retries.\n            // If not, need to retry again (in order to write commits and nodes properly)\n            // but don't count these retries against number of retries.\n            if (conflictingCommitsExist(assumedHeadRevision)) {\n                String message = String.format(\"Commit @%s: failed due to a conflicting commit.\"\n                        + \" Affected paths: %s\", revisionId, commit.getAffectedPaths());\n                logger.warn(message);\n                markAsFailed();\n                throw new ConflictingCommitException(message);\n            } else {\n                logger.info(\"Commit @{}: failed due to a concurrent commit.\" + \" Affected paths: {}\", revisionId, commit.getAffectedPaths());\n                markAsFailed();\n                return false;\n            }\n        }\n        return true;\n    }","id":91359,"modified_method":"/**\n     * Protected for testing purposed only.\n     *\n     * @return True if the operation was successful.\n     * @throws Exception If an exception happens.\n     */\n    protected boolean saveAndSetHeadRevision() throws Exception {\n        // Don't update the head revision id for branches.\n        if (branchId != null) {\n            return true;\n        }\n\n        long assumedHeadRevision = this.mongoSync.getHeadRevisionId();\n        MongoSync mongoSync = new SaveAndSetHeadRevisionAction(nodeStore,\n                assumedHeadRevision, revisionId).execute();\n        if (mongoSync == null) {\n            // There have been commit(s) in the meantime. If it's a conflicting\n            // update, retry the whole operation and count against number of retries.\n            // If not, need to retry again (in order to write commits and nodes properly)\n            // but don't count these retries against number of retries.\n            if (conflictingCommitsExist(assumedHeadRevision)) {\n                String message = String.format(\"Commit @%s: failed due to a conflicting commit.\"\n                        + \" Affected paths: %s\", revisionId, commit.getAffectedPaths());\n                logger.warn(message);\n                markAsFailed();\n                throw new ConflictingCommitException(message);\n            } else {\n                logger.info(\"Commit @{}: failed due to a concurrent commit.\" + \" Affected paths: {}\", revisionId, commit.getAffectedPaths());\n                markAsFailed();\n                return false;\n            }\n        }\n        return true;\n    }","commit_id":"7fd960b93601b1a4a7966d3fe46789308800e78b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private List<MongoCommit> convertToCommits(DBCursor dbCursor) {\n        Map<Long, MongoCommit> commits = new HashMap<Long, MongoCommit>();\n        while (dbCursor.hasNext()) {\n            MongoCommit commitMongo = (MongoCommit) dbCursor.next();\n            commits.put(commitMongo.getRevisionId(), commitMongo);\n        }\n        dbCursor.close();\n\n        List<MongoCommit> validCommits = new LinkedList<MongoCommit>();\n        if (commits.isEmpty()) {\n            return validCommits;\n        }\n\n        Set<Long> revisions = commits.keySet();\n        long currentRevision = (toRevisionId != -1 && revisions.contains(toRevisionId)) ?\n                toRevisionId : Collections.max(revisions);\n\n        while (true) {\n            MongoCommit commitMongo = commits.get(currentRevision);\n            if (commitMongo == null) {\n                break;\n            }\n            validCommits.add(commitMongo);\n            long baseRevision = commitMongo.getBaseRevisionId();\n            if (currentRevision == 0L || baseRevision < fromRevisionId) {\n                break;\n            }\n            currentRevision = baseRevision;\n        }\n\n        LOG.debug(\"Found list of valid revisions for max revision {}: {}\",\n                toRevisionId, validCommits);\n\n        return validCommits;\n    }","id":91360,"modified_method":"private List<MongoCommit> convertToCommits(DBCursor dbCursor) {\n        try {\n            List<MongoCommit> commits = new ArrayList<MongoCommit>();\n            while (dbCursor.hasNext()) {\n                commits.add((MongoCommit) dbCursor.next());\n            }\n            LOG.debug(\"Found list of valid revisions for max revision {}: {}\",\n                    toRevisionId, commits);\n\n            return commits;\n        } finally {\n            dbCursor.close();\n        }\n    }","commit_id":"7fd960b93601b1a4a7966d3fe46789308800e78b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static void processNotFound(final Editor editor, String stringToFind, FindModel model, Project project) {\n\n    String message = FindBundle.message(\"find.search.string.not.found.message\", stringToFind);\n\n    if (model.isGlobal()) {\n      final FindModel newModel = (FindModel)model.clone();\n      FindManager findManager = FindManager.getInstance(project);\n      Document document = editor.getDocument();\n      FindResult result;\n      if (newModel.isForward()) {\n        result = findManager.findString(document.getCharsSequence(), 0, model, getVirtualFile(editor));\n      }\n      else {\n        result = findManager.findString(document.getCharsSequence(), document.getTextLength(), model, getVirtualFile(editor));\n      }\n      if (!result.isStringFound()) {\n        result = null;\n      }\n\n      FindModel modelForNextSearch = findManager.getFindNextModel(editor);\n      if (modelForNextSearch == null) {\n        modelForNextSearch = findManager.getFindInFileModel();\n      }\n\n      if (result != null) {\n        if (newModel.isForward()) {\n          AnAction action = ActionManager.getInstance().getAction(\n            modelForNextSearch.isForward() ? IdeActions.ACTION_FIND_NEXT : IdeActions.ACTION_FIND_PREVIOUS);\n          String shortcutsText = KeymapUtil.getFirstKeyboardShortcutText(action);\n          if (shortcutsText.length() > 0) {\n            message = FindBundle.message(\"find.search.again.from.top.hotkey.message\", message, shortcutsText);\n          }\n          else {\n            message = FindBundle.message(\"find.search.again.from.top.action.message\", message);\n          }\n          editor.putUserData(KEY, Direction.DOWN);\n        }\n        else {\n          AnAction action = ActionManager.getInstance().getAction(\n            modelForNextSearch.isForward() ? IdeActions.ACTION_FIND_PREVIOUS : IdeActions.ACTION_FIND_NEXT);\n          String shortcutsText = KeymapUtil.getFirstKeyboardShortcutText(action);\n          if (shortcutsText.length() > 0) {\n            message = FindBundle.message(\"find.search.again.from.bottom.hotkey.message\", message, shortcutsText);\n          }\n          else {\n            message = FindBundle.message(\"find.search.again.from.bottom.action.message\", message);\n          }\n          editor.putUserData(KEY, Direction.UP);\n        }\n      }\n      CaretListener listener = new CaretListener() {\n        public void caretPositionChanged(CaretEvent e) {\n          editor.putUserData(KEY, null);\n          editor.getCaretModel().removeCaretListener(this);\n        }\n      };\n      editor.getCaretModel().addCaretListener(listener);\n    }\n    JComponent component = HintUtil.createInformationLabel(message);\n    final LightweightHint hint = new LightweightHint(component);\n    HintManagerImpl.getInstanceImpl().showEditorHint(hint, editor, HintManager.UNDER,\n                               HintManager.HIDE_BY_ANY_KEY | HintManager.HIDE_BY_TEXT_CHANGE | HintManager.HIDE_BY_SCROLLING,\n                               0, false);\n  }","id":91361,"modified_method":"private static void processNotFound(final Editor editor, String stringToFind, FindModel model, Project project) {\n    String message = FindBundle.message(\"find.search.string.not.found.message\", stringToFind);\n\n    if (model.isGlobal()) {\n      final FindModel newModel = (FindModel)model.clone();\n      FindManager findManager = FindManager.getInstance(project);\n      Document document = editor.getDocument();\n      FindResult result = findManager.findString(document.getCharsSequence(),\n                                                 newModel.isForward() ? 0 : document.getTextLength(), model, getVirtualFile(editor));\n      if (!result.isStringFound()) {\n        result = null;\n      }\n\n      FindModel modelForNextSearch = findManager.getFindNextModel(editor);\n      if (modelForNextSearch == null) {\n        modelForNextSearch = findManager.getFindInFileModel();\n      }\n\n      if (result != null) {\n        if (newModel.isForward()) {\n          AnAction action = ActionManager.getInstance().getAction(\n            modelForNextSearch.isForward() ? IdeActions.ACTION_FIND_NEXT : IdeActions.ACTION_FIND_PREVIOUS);\n          String shortcutsText = KeymapUtil.getFirstKeyboardShortcutText(action);\n          if (shortcutsText.length() > 0) {\n            message = FindBundle.message(\"find.search.again.from.top.hotkey.message\", message, shortcutsText);\n          }\n          else {\n            message = FindBundle.message(\"find.search.again.from.top.action.message\", message);\n          }\n          editor.putUserData(KEY, Direction.DOWN);\n        }\n        else {\n          AnAction action = ActionManager.getInstance().getAction(\n            modelForNextSearch.isForward() ? IdeActions.ACTION_FIND_PREVIOUS : IdeActions.ACTION_FIND_NEXT);\n          String shortcutsText = KeymapUtil.getFirstKeyboardShortcutText(action);\n          if (shortcutsText.length() > 0) {\n            message = FindBundle.message(\"find.search.again.from.bottom.hotkey.message\", message, shortcutsText);\n          }\n          else {\n            message = FindBundle.message(\"find.search.again.from.bottom.action.message\", message);\n          }\n          editor.putUserData(KEY, Direction.UP);\n        }\n      }\n      CaretListener listener = new CaretListener() {\n        public void caretPositionChanged(CaretEvent e) {\n          editor.putUserData(KEY, null);\n          editor.getCaretModel().removeCaretListener(this);\n        }\n      };\n      editor.getCaretModel().addCaretListener(listener);\n    }\n    JComponent component = HintUtil.createInformationLabel(message);\n    final LightweightHint hint = new LightweightHint(component);\n    HintManagerImpl.getInstanceImpl().showEditorHint(hint, editor, HintManager.UNDER,\n                               HintManager.HIDE_BY_ANY_KEY | HintManager.HIDE_BY_TEXT_CHANGE | HintManager.HIDE_BY_SCROLLING,\n                               0, false);\n  }","commit_id":"08acec8ee4b32a963625ac8d0e8add5dd1687c1d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static FindResult doSearch(Project project,\n                                     final Editor editor,\n                                     int offset,\n                                     boolean toWarn,\n                                     FindModel model, boolean adjustEditor) {\n    FindManager findManager = FindManager.getInstance(project);\n    Document document = editor.getDocument();\n\n    final FindResult result = findManager.findString(document.getCharsSequence(), offset, model, getVirtualFile(editor));\n\n    boolean isFound = result.isStringFound();\n    if (!model.isGlobal()) {\n      if (result.getEndOffset() > editor.getSelectionModel().getSelectionEnd() ||\n          result.getStartOffset() < editor.getSelectionModel().getSelectionStart()) {\n        isFound = false;\n      }\n    }\n    if (!isFound) {\n      if (toWarn) {\n        processNotFound(editor, model.getStringToFind(), model, project);\n      }\n      return null;\n    }\n\n    if (adjustEditor) {\n      final CaretModel caretModel = editor.getCaretModel();\n      final ScrollingModel scrollingModel = editor.getScrollingModel();\n      int oldCaretOffset = caretModel.getOffset();\n      boolean forward = oldCaretOffset < result.getStartOffset();\n      final ScrollType scrollType = forward ? ScrollType.CENTER_DOWN : ScrollType.CENTER_UP;\n\n      if (model.isGlobal()) {\n        caretModel.moveToOffset(result.getEndOffset());\n        editor.getSelectionModel().removeSelection();\n        scrollingModel.scrollToCaret(scrollType);\n        scrollingModel.runActionOnScrollingFinished(\n          new Runnable() {\n            public void run() {\n              scrollingModel.scrollTo(editor.offsetToLogicalPosition(result.getStartOffset()), scrollType);\n              scrollingModel.scrollTo(editor.offsetToLogicalPosition(result.getEndOffset()), scrollType);\n            }\n          }\n        );\n      }\n      else {\n        moveCaretAndDontChangeSelection(editor, result.getStartOffset(), scrollType);\n        moveCaretAndDontChangeSelection(editor, result.getEndOffset(), scrollType);\n      }\n      IdeDocumentHistory.getInstance(project).includeCurrentCommandAsNavigation();\n\n      EditorColorsManager manager = EditorColorsManager.getInstance();\n      TextAttributes selectionAttributes = manager.getGlobalScheme().getAttributes(EditorColors.SEARCH_RESULT_ATTRIBUTES);\n\n      if (!model.isGlobal()) {\n        final RangeHighlighterEx segmentHighlighter = (RangeHighlighterEx)editor.getMarkupModel().addRangeHighlighter(\n          result.getStartOffset(),\n          result.getEndOffset(),\n          HighlighterLayer.SELECTION + 1,\n          selectionAttributes, HighlighterTargetArea.EXACT_RANGE);\n        MyListener listener = new MyListener(editor, segmentHighlighter);\n        editor.getContentComponent().addFocusListener(listener);\n        caretModel.addCaretListener(listener);\n      }\n      else {\n        editor.getSelectionModel().setSelection(result.getStartOffset(), result.getEndOffset());\n      }\n    }\n\n    return result;\n  }","id":91362,"modified_method":"@Nullable\n  private static FindResult doSearch(Project project,\n                                     final Editor editor,\n                                     int offset,\n                                     boolean toWarn,\n                                     FindModel model, boolean adjustEditor) {\n    FindManager findManager = FindManager.getInstance(project);\n    Document document = editor.getDocument();\n\n    final FindResult result = findManager.findString(document.getCharsSequence(), offset, model, getVirtualFile(editor));\n\n    boolean isFound = result.isStringFound();\n    if (!model.isGlobal()) {\n      if (result.getEndOffset() > editor.getSelectionModel().getSelectionEnd() ||\n          result.getStartOffset() < editor.getSelectionModel().getSelectionStart()) {\n        isFound = false;\n      }\n    }\n    if (!isFound) {\n      if (toWarn) {\n        processNotFound(editor, model.getStringToFind(), model, project);\n      }\n      return null;\n    }\n\n    if (adjustEditor) {\n      final CaretModel caretModel = editor.getCaretModel();\n      final ScrollingModel scrollingModel = editor.getScrollingModel();\n      int oldCaretOffset = caretModel.getOffset();\n      boolean forward = oldCaretOffset < result.getStartOffset();\n      final ScrollType scrollType = forward ? ScrollType.CENTER_DOWN : ScrollType.CENTER_UP;\n\n      if (model.isGlobal()) {\n        caretModel.moveToOffset(result.getEndOffset());\n        editor.getSelectionModel().removeSelection();\n        scrollingModel.scrollToCaret(scrollType);\n        scrollingModel.runActionOnScrollingFinished(\n          new Runnable() {\n            public void run() {\n              scrollingModel.scrollTo(editor.offsetToLogicalPosition(result.getStartOffset()), scrollType);\n              scrollingModel.scrollTo(editor.offsetToLogicalPosition(result.getEndOffset()), scrollType);\n            }\n          }\n        );\n      }\n      else {\n        moveCaretAndDontChangeSelection(editor, result.getStartOffset(), scrollType);\n        moveCaretAndDontChangeSelection(editor, result.getEndOffset(), scrollType);\n      }\n      IdeDocumentHistory.getInstance(project).includeCurrentCommandAsNavigation();\n\n      EditorColorsManager manager = EditorColorsManager.getInstance();\n      TextAttributes selectionAttributes = manager.getGlobalScheme().getAttributes(EditorColors.SEARCH_RESULT_ATTRIBUTES);\n\n      if (!model.isGlobal()) {\n        final RangeHighlighterEx segmentHighlighter = (RangeHighlighterEx)editor.getMarkupModel().addRangeHighlighter(\n          result.getStartOffset(),\n          result.getEndOffset(),\n          HighlighterLayer.SELECTION + 1,\n          selectionAttributes, HighlighterTargetArea.EXACT_RANGE);\n        MyListener listener = new MyListener(editor, segmentHighlighter);\n        caretModel.addCaretListener(listener);\n      }\n      else {\n        editor.getSelectionModel().setSelection(result.getStartOffset(), result.getEndOffset());\n      }\n    }\n\n    return result;\n  }","commit_id":"08acec8ee4b32a963625ac8d0e8add5dd1687c1d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void removeAll() {\n      myEditor.getMarkupModel().removeHighlighter(mySegmentHighlighter);\n      myEditor.getContentComponent().addFocusListener(this);\n      myEditor.getCaretModel().removeCaretListener(this);\n    }","id":91363,"modified_method":"private void removeAll() {\n      myEditor.getCaretModel().removeCaretListener(this);\n      myEditor.getMarkupModel().removeHighlighter(mySegmentHighlighter);\n    }","commit_id":"08acec8ee4b32a963625ac8d0e8add5dd1687c1d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean doReplace(Project project, Editor editor, FindModel model, final Document document, int caretOffset, boolean toPrompt) {\n    FindManager findManager = FindManager.getInstance(project);\n    model = (FindModel)model.clone();\n    int occurrences = 0;\n\n    List<Pair<TextRange,String>> rangesToChange = new ArrayList<Pair<TextRange, String>>();\n\n    boolean replaced = false;\n    int offset = caretOffset;\n    while (offset >= 0 && offset < editor.getDocument().getTextLength()) {\n      caretOffset = offset;\n      FindResult result = doSearch(project, editor, offset, !replaced, model, toPrompt);\n      if (result == null) {\n        break;\n      }\n      int startResultOffset = result.getStartOffset();\n      model.setFromCursor(true);\n      if (toPrompt) {\n        int promptResult = findManager.showPromptDialog(model, FindBundle.message(\"find.replace.dialog.title\"));\n        if (promptResult == FindManager.PromptResult.SKIP) {\n          offset = model.isForward() ? result.getEndOffset() : startResultOffset;\n          continue;\n        }\n        if (promptResult == FindManager.PromptResult.CANCEL) {\n          break;\n        }\n        if (promptResult == FindManager.PromptResult.ALL) {\n          toPrompt = false;\n          ((DocumentEx) document).setInBulkUpdate(true);\n        }\n      }\n\n      int startOffset = result.getStartOffset();\n      int endOffset = result.getEndOffset();\n      String foundString = document.getCharsSequence().subSequence(startOffset, endOffset).toString();\n      String toReplace = findManager.getStringToReplace(foundString, model);\n      if (toReplace == null) break;\n\n      boolean reallyReplace = toPrompt;\n      TextRange textRange = doReplace(project, document, model, result, toReplace, reallyReplace);\n      if (!reallyReplace) {\n        rangesToChange.add(Pair.create(textRange,toReplace));\n      }\n\n      offset = model.isForward()\n               ? textRange.getEndOffset()\n               : textRange.getStartOffset();\n      occurrences++;\n\n      //[SCR 7258]\n      if (!replaced) {\n        editor.getCaretModel().moveToOffset(0);\n      }\n\n      replaced = true;\n    }\n\n    if (replaced) {\n      if (!toPrompt) {\n        int offsetBefore = 0;\n        CharSequence text = document.getCharsSequence();\n        final StringBuilder newText = new StringBuilder(document.getTextLength());\n        Collections.sort(rangesToChange, new Comparator<Pair<TextRange, String>>() {\n          public int compare(Pair<TextRange, String> o1, Pair<TextRange, String> o2) {\n            return o1.getFirst().getStartOffset() - o2.getFirst().getStartOffset();\n          }\n        });\n        for (Pair<TextRange, String> pair : rangesToChange) {\n          TextRange range = pair.getFirst();\n          String replace = pair.getSecond();\n          newText.append(text, offsetBefore, range.getStartOffset()); //before change\n          newText.append(replace);\n          offsetBefore = range.getEndOffset();\n          if (offsetBefore < caretOffset) {\n            caretOffset += replace.length() - range.getLength();\n          }\n        }\n        newText.append(text, offsetBefore, text.length()); //tail\n        CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n          public void run() {\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              public void run() {\n                document.setText(newText);\n              }\n            });\n          }\n        }, null, document);\n\n        if (caretOffset > document.getTextLength()) caretOffset = document.getTextLength();\n      }\n      editor.getCaretModel().moveToOffset(caretOffset);\n    }\n\n    ReplaceInProjectManager.reportNumberReplacedOccurences(project, occurrences);\n    return replaced;\n  }","id":91364,"modified_method":"private static boolean doReplace(Project project, Editor editor, FindModel model, final Document document, int caretOffset, boolean toPrompt) {\n    FindManager findManager = FindManager.getInstance(project);\n    model = (FindModel)model.clone();\n    int occurrences = 0;\n\n    List<Pair<TextRange,String>> rangesToChange = new ArrayList<Pair<TextRange, String>>();\n\n    boolean replaced = false;\n    int offset = caretOffset;\n    while (offset >= 0 && offset < editor.getDocument().getTextLength()) {\n      caretOffset = offset;\n      FindResult result = doSearch(project, editor, offset, !replaced, model, toPrompt);\n      if (result == null) {\n        break;\n      }\n      int startResultOffset = result.getStartOffset();\n      model.setFromCursor(true);\n      if (toPrompt) {\n        int promptResult = findManager.showPromptDialog(model, FindBundle.message(\"find.replace.dialog.title\"));\n        if (promptResult == FindManager.PromptResult.SKIP) {\n          offset = model.isForward() ? result.getEndOffset() : startResultOffset;\n          continue;\n        }\n        if (promptResult == FindManager.PromptResult.CANCEL) {\n          break;\n        }\n        if (promptResult == FindManager.PromptResult.ALL) {\n          toPrompt = false;\n          ((DocumentEx) document).setInBulkUpdate(true);\n        }\n      }\n\n      int startOffset = result.getStartOffset();\n      int endOffset = result.getEndOffset();\n      String foundString = document.getCharsSequence().subSequence(startOffset, endOffset).toString();\n      String toReplace = findManager.getStringToReplace(foundString, model);\n      if (toReplace == null) break;\n\n      boolean reallyReplace = toPrompt;\n      TextRange textRange = doReplace(project, document, model, result, toReplace, reallyReplace, rangesToChange);\n\n      int newOffset = model.isForward() ? textRange.getEndOffset() : textRange.getStartOffset();\n      if (newOffset == offset) {\n        newOffset += model.isForward() ? 1 : -1;\n      }\n      offset = newOffset;\n      occurrences++;\n\n      //[SCR 7258]\n      if (!replaced) {\n        editor.getCaretModel().moveToOffset(0);\n      }\n\n      replaced = true;\n    }\n\n    if (replaced) {\n      if (!toPrompt) {\n        CharSequence text = document.getCharsSequence();\n        final StringBuilder newText = new StringBuilder(document.getTextLength());\n        Collections.sort(rangesToChange, new Comparator<Pair<TextRange, String>>() {\n          public int compare(Pair<TextRange, String> o1, Pair<TextRange, String> o2) {\n            return o1.getFirst().getStartOffset() - o2.getFirst().getStartOffset();\n          }\n        });\n        int offsetBefore = 0;\n        for (Pair<TextRange, String> pair : rangesToChange) {\n          TextRange range = pair.getFirst();\n          String replace = pair.getSecond();\n          newText.append(text, offsetBefore, range.getStartOffset()); //before change\n          newText.append(replace);\n          offsetBefore = range.getEndOffset();\n          if (offsetBefore < caretOffset) {\n            caretOffset += replace.length() - range.getLength();\n          }\n        }\n        newText.append(text, offsetBefore, text.length()); //tail\n        CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n          public void run() {\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              public void run() {\n                document.setText(newText);\n              }\n            });\n          }\n        }, null, document);\n\n        if (caretOffset > document.getTextLength()) caretOffset = document.getTextLength();\n      }\n      editor.getCaretModel().moveToOffset(caretOffset);\n    }\n\n    ReplaceInProjectManager.reportNumberReplacedOccurences(project, occurrences);\n    return replaced;\n  }","commit_id":"e4b693d3c991ea41a8a6a2b108342c0f7dcdce7d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void find(Project project, Editor editor) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    FindManager findManager = FindManager.getInstance(project);\n    String s = editor.getSelectionModel().getSelectedText();\n\n    FindModel model = (FindModel)findManager.getFindInFileModel().clone();\n    if (s != null) {\n      if (s.indexOf('\\n') >= 0) {\n        model.setGlobal(false);\n      }\n      else {\n        model.setStringToFind(s);\n        model.setGlobal(true);\n      }\n    }\n    else {\n      model.setGlobal(true);\n    }\n\n    model.setReplaceState(false);\n    model.setFindAllEnabled(PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument()) != null);\n\n    if (!findManager.showFindDialog(model)) {\n      return;\n    }\n\n    if (model.isFindAll()) {\n      findManager.setFindNextModel(model);\n      findAll(project, editor, model);\n      return;\n    }\n\n    if (!model.isGlobal() && editor.getSelectionModel().hasSelection()) {\n      int offset = model.isForward()\n                   ? editor.getSelectionModel().getSelectionStart()\n                   : editor.getSelectionModel().getSelectionEnd();\n      ScrollType scrollType = model.isForward() ? ScrollType.CENTER_DOWN : ScrollType.CENTER_UP;\n      moveCaretAndDontChangeSelection(editor, offset, scrollType);\n    }\n\n    int offset;\n    if (model.isGlobal()) {\n      if (model.isFromCursor()) {\n        offset = editor.getCaretModel().getOffset();\n      }\n      else {\n        if (model.isForward()) {\n          offset = 0;\n        }\n        else {\n          offset = editor.getDocument().getTextLength();\n        }\n      }\n    }\n    else {\n      // in selection\n\n      if (!editor.getSelectionModel().hasSelection()) {\n        // TODO[anton] actually, this should never happen - Find dialog should not allow such combination\n        findManager.setFindNextModel(null);\n        return;\n      }\n\n      if (model.isForward()) {\n        offset = editor.getSelectionModel().getSelectionStart();\n      }\n      else {\n        offset = editor.getSelectionModel().getSelectionEnd();\n      }\n    }\n\n    findManager.setFindNextModel(null);\n    findManager.getFindInFileModel().copyFrom(model);\n    doSearch(project, editor, offset, true, model, true);\n  }","id":91365,"modified_method":"public static void find(Project project, Editor editor) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    FindManager findManager = FindManager.getInstance(project);\n    String s = editor.getSelectionModel().getSelectedText();\n\n    FindModel model = (FindModel)findManager.getFindInFileModel().clone();\n    if (s != null) {\n      if (s.indexOf('\\n') >= 0) {\n        model.setGlobal(false);\n      }\n      else {\n        model.setStringToFind(s);\n        model.setGlobal(true);\n      }\n    }\n    else {\n      model.setGlobal(true);\n    }\n\n    model.setReplaceState(false);\n    model.setFindAllEnabled(PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument()) != null);\n\n    if (!findManager.showFindDialog(model)) {\n      return;\n    }\n\n    if (model.isFindAll()) {\n      findManager.setFindNextModel(model);\n      findAll(project, editor, model);\n      return;\n    }\n\n    if (!model.isGlobal() && editor.getSelectionModel().hasSelection()) {\n      int offset = model.isForward()\n                   ? editor.getSelectionModel().getSelectionStart()\n                   : editor.getSelectionModel().getSelectionEnd();\n      ScrollType scrollType = model.isForward() ? ScrollType.CENTER_DOWN : ScrollType.CENTER_UP;\n      moveCaretAndDontChangeSelection(editor, offset, scrollType);\n    }\n\n    int offset;\n    if (model.isGlobal()) {\n      if (model.isFromCursor()) {\n        offset = editor.getCaretModel().getOffset();\n      }\n      else {\n        offset = model.isForward() ? 0 : editor.getDocument().getTextLength();\n      }\n    }\n    else {\n      // in selection\n\n      if (!editor.getSelectionModel().hasSelection()) {\n        // TODO[anton] actually, this should never happen - Find dialog should not allow such combination\n        findManager.setFindNextModel(null);\n        return;\n      }\n\n      offset = model.isForward() ? editor.getSelectionModel().getSelectionStart() : editor.getSelectionModel().getSelectionEnd();\n    }\n\n    findManager.setFindNextModel(null);\n    findManager.getFindInFileModel().copyFrom(model);\n    doSearch(project, editor, offset, true, model, true);\n  }","commit_id":"e4b693d3c991ea41a8a6a2b108342c0f7dcdce7d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MyListener(Editor editor, RangeHighlighter segmentHighlighter) {\n      myEditor = editor;\n      mySegmentHighlighter = segmentHighlighter;\n    }","id":91366,"modified_method":"private MyListener(Editor editor, RangeHighlighter segmentHighlighter) {\n      myEditor = editor;\n      mySegmentHighlighter = segmentHighlighter;\n    }","commit_id":"e4b693d3c991ea41a8a6a2b108342c0f7dcdce7d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static TextRange doReplace(final Project project, final Document document, final FindModel model, FindResult result, @NotNull final String stringToReplace, boolean reallyReplace) {\n    final int startOffset = result.getStartOffset();\n    final int endOffset = result.getEndOffset();\n\n    int newOffset;\n    if (reallyReplace) {\n      final String converted = StringUtil.convertLineSeparators(stringToReplace);\n      CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              //[ven] I doubt converting is a good solution to SCR 21224\n              document.replaceString(startOffset, endOffset, converted);\n            }\n          });\n        }\n      }, null, document);\n      newOffset = startOffset + converted.length();\n    }\n    else {\n      newOffset = endOffset;\n    }\n\n    int start = startOffset;\n    int end = newOffset;\n    if (model.isRegularExpressions()) {\n      String toFind = model.getStringToFind();\n      if (model.isForward()) {\n        if (StringUtil.endsWithChar(toFind, '$')) {\n          int i = 0;\n          int length = toFind.length();\n          while (i + 2 <= length && toFind.charAt(length - i - 2) == '\\\\') i++;\n          if (i % 2 == 0) end++; //This $ is a special symbol in regexp syntax\n        }\n        else if (StringUtil.startsWithChar(toFind, '^')) {\n          while (end < document.getTextLength() && document.getCharsSequence().charAt(end) != '\\n') end++;\n        }\n      }\n      else {\n        if (StringUtil.startsWithChar(toFind, '^')) {\n          start--;\n        }\n        else if (StringUtil.endsWithChar(toFind, '$')) {\n          while (start >= 0 && document.getCharsSequence().charAt(start) != '\\n') start--;\n        }\n      }\n    }\n    return new TextRange(start, end);\n  }","id":91367,"modified_method":"private static TextRange doReplace(final Project project, final Document document, final FindModel model, FindResult result, @NotNull final String stringToReplace,\n                                     boolean reallyReplace,\n                                     List<Pair<TextRange, String>> rangesToChange) {\n    final int startOffset = result.getStartOffset();\n    final int endOffset = result.getEndOffset();\n\n    int newOffset;\n    final String converted = StringUtil.convertLineSeparators(stringToReplace);\n    if (reallyReplace) {\n      CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              //[ven] I doubt converting is a good solution to SCR 21224\n              document.replaceString(startOffset, endOffset, converted);\n            }\n          });\n        }\n      }, null, document);\n      newOffset = startOffset + converted.length();\n    }\n    else {\n      TextRange textRange = new TextRange(startOffset, endOffset);\n      rangesToChange.add(Pair.create(textRange,converted));\n\n      newOffset = endOffset;\n    }\n\n    int start = startOffset;\n    int end = newOffset;\n    if (model.isRegularExpressions()) {\n      String toFind = model.getStringToFind();\n      if (model.isForward()) {\n        if (StringUtil.endsWithChar(toFind, '$')) {\n          int i = 0;\n          int length = toFind.length();\n          while (i + 2 <= length && toFind.charAt(length - i - 2) == '\\\\') i++;\n          if (i % 2 == 0) end++; //This $ is a special symbol in regexp syntax\n        }\n        else if (StringUtil.startsWithChar(toFind, '^')) {\n          while (end < document.getTextLength() && document.getCharsSequence().charAt(end) != '\\n') end++;\n        }\n      }\n      else {\n        if (StringUtil.startsWithChar(toFind, '^')) {\n          start--;\n        }\n        else if (StringUtil.endsWithChar(toFind, '$')) {\n          while (start >= 0 && document.getCharsSequence().charAt(start) != '\\n') start--;\n        }\n      }\n    }\n    return new TextRange(start, end);\n  }","commit_id":"e4b693d3c991ea41a8a6a2b108342c0f7dcdce7d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean replace(Project project, Editor editor) {\n    FindManager findManager = FindManager.getInstance(project);\n    FindModel model = (FindModel)findManager.getFindInFileModel().clone();\n    String s = editor.getSelectionModel().getSelectedText();\n    if (s != null) {\n      if (s.indexOf('\\n') >= 0) {\n        model.setGlobal(false);\n      }\n      else {\n        model.setStringToFind(s);\n        model.setGlobal(true);\n      }\n    }\n    else {\n      model.setGlobal(true);\n    }\n    model.setReplaceState(true);\n\n    if (!findManager.showFindDialog(model)) {\n      return false;\n    }\n    if (!model.isGlobal() && editor.getSelectionModel().hasSelection()) {\n      int offset = model.isForward()\n                   ? editor.getSelectionModel().getSelectionStart()\n                   : editor.getSelectionModel().getSelectionEnd();\n      ScrollType scrollType = model.isForward() ? ScrollType.CENTER_DOWN : ScrollType.CENTER_UP;\n      moveCaretAndDontChangeSelection(editor, offset, scrollType);\n    }\n    int offset;\n    if (model.isGlobal()) {\n      if (model.isFromCursor()) {\n        offset = editor.getCaretModel().getOffset();\n        if (!model.isForward()) {\n          offset++;\n        }\n      }\n      else {\n        if (model.isForward()) {\n          offset = 0;\n        }\n        else {\n          offset = editor.getDocument().getTextLength();\n        }\n      }\n    }\n    else {\n      // in selection\n\n      if (!editor.getSelectionModel().hasSelection()) {\n        // TODO[anton] actually, this should never happen - Find dialog should not allow such combination\n        findManager.setFindNextModel(null);\n        return false;\n      }\n\n      if (model.isForward()) {\n        offset = editor.getSelectionModel().getSelectionStart();\n      }\n      else {\n        offset = editor.getSelectionModel().getSelectionEnd();\n      }\n    }\n\n    if (s != null && editor.getSelectionModel().hasSelection() && s.equals(model.getStringToFind())) {\n      if (model.isFromCursor() && model.isForward()) {\n        offset = Math.min(editor.getSelectionModel().getSelectionStart(), offset);\n      }\n      else if (model.isFromCursor() && !model.isForward()) {\n        offset = Math.max(editor.getSelectionModel().getSelectionEnd(), offset);\n      }\n    }\n    findManager.setFindNextModel(null);\n    findManager.getFindInFileModel().copyFrom(model);\n    return replace(project, editor, offset, model);\n  }","id":91368,"modified_method":"public static boolean replace(Project project, Editor editor) {\n    FindManager findManager = FindManager.getInstance(project);\n    FindModel model = (FindModel)findManager.getFindInFileModel().clone();\n    String s = editor.getSelectionModel().getSelectedText();\n    if (s != null) {\n      if (s.indexOf('\\n') >= 0) {\n        model.setGlobal(false);\n      }\n      else {\n        model.setStringToFind(s);\n        model.setGlobal(true);\n      }\n    }\n    else {\n      model.setGlobal(true);\n    }\n    model.setReplaceState(true);\n\n    if (!findManager.showFindDialog(model)) {\n      return false;\n    }\n    if (!model.isGlobal() && editor.getSelectionModel().hasSelection()) {\n      int offset = model.isForward()\n                   ? editor.getSelectionModel().getSelectionStart()\n                   : editor.getSelectionModel().getSelectionEnd();\n      ScrollType scrollType = model.isForward() ? ScrollType.CENTER_DOWN : ScrollType.CENTER_UP;\n      moveCaretAndDontChangeSelection(editor, offset, scrollType);\n    }\n    int offset;\n    if (model.isGlobal()) {\n      if (model.isFromCursor()) {\n        offset = editor.getCaretModel().getOffset();\n        if (!model.isForward()) {\n          offset++;\n        }\n      }\n      else {\n        offset = model.isForward() ? 0 : editor.getDocument().getTextLength();\n      }\n    }\n    else {\n      // in selection\n\n      if (!editor.getSelectionModel().hasSelection()) {\n        // TODO[anton] actually, this should never happen - Find dialog should not allow such combination\n        findManager.setFindNextModel(null);\n        return false;\n      }\n\n      offset = model.isForward() ? editor.getSelectionModel().getSelectionStart() : editor.getSelectionModel().getSelectionEnd();\n    }\n\n    if (s != null && editor.getSelectionModel().hasSelection() && s.equals(model.getStringToFind())) {\n      if (model.isFromCursor() && model.isForward()) {\n        offset = Math.min(editor.getSelectionModel().getSelectionStart(), offset);\n      }\n      else if (model.isFromCursor() && !model.isForward()) {\n        offset = Math.max(editor.getSelectionModel().getSelectionEnd(), offset);\n      }\n    }\n    findManager.setFindNextModel(null);\n    findManager.getFindInFileModel().copyFrom(model);\n    return replace(project, editor, offset, model);\n  }","commit_id":"e4b693d3c991ea41a8a6a2b108342c0f7dcdce7d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void findAll(final Project project, final Editor editor, final FindModel findModel) {\n    final Document document = editor.getDocument();\n    final PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(document);\n    if (psiFile == null) return;\n\n    CharSequence text = document.getCharsSequence();\n    int textLength = document.getTextLength();\n    final List<Usage> usages = new ArrayList<Usage>();\n    if (text != null) {\n      FindManager findManager = FindManager.getInstance(project);\n      findModel.setForward(true); // when find all there is no diff in direction\n\n      int offset = 0;\n      while (offset < textLength) {\n        FindResult result = findManager.findString(text, offset, findModel);\n        if (!result.isStringFound()) break;\n\n        usages.add(new UsageInfo2UsageAdapter(new UsageInfo(psiFile, result.getStartOffset(), result.getEndOffset())));\n\n        final int prevOffset = offset;\n        offset = result.getEndOffset();\n\n        if (prevOffset == offset) {\n          // for regular expr the size of the match could be zero -> could be infinite loop in finding usages!\n          ++offset;\n        }\n      }\n    }\n    final UsageTarget[] usageTargets = new UsageTarget[]{ new FindInProjectUtil.StringUsageTarget(findModel.getStringToFind()) };\n    final UsageViewPresentation usageViewPresentation = FindInProjectUtil.setupViewPresentation(false, findModel);\n    UsageViewManager.getInstance(project).showUsages(usageTargets, usages.toArray(new Usage[usages.size()]), usageViewPresentation);\n  }","id":91369,"modified_method":"public static void findAll(final Project project, final Editor editor, final FindModel findModel) {\n    final Document document = editor.getDocument();\n    final PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(document);\n    if (psiFile == null) return;\n\n    CharSequence text = document.getCharsSequence();\n    int textLength = document.getTextLength();\n    final List<Usage> usages = new ArrayList<Usage>();\n    if (text != null) {\n      FindManager findManager = FindManager.getInstance(project);\n      findModel.setForward(true); // when find all there is no diff in direction\n\n      int offset = 0;\n      while (offset < textLength) {\n        FindResult result = findManager.findString(text, offset, findModel);\n        if (!result.isStringFound()) break;\n\n        usages.add(new UsageInfo2UsageAdapter(new UsageInfo(psiFile, result.getStartOffset(), result.getEndOffset())));\n\n        final int prevOffset = offset;\n        offset = result.getEndOffset();\n\n        if (prevOffset == offset) {\n          // for regular expr the size of the match could be zero -> could be infinite loop in finding usages!\n          ++offset;\n        }\n      }\n    }\n    final UsageTarget[] usageTargets = { new FindInProjectUtil.StringUsageTarget(findModel.getStringToFind()) };\n    final UsageViewPresentation usageViewPresentation = FindInProjectUtil.setupViewPresentation(false, findModel);\n    UsageViewManager.getInstance(project).showUsages(usageTargets, usages.toArray(new Usage[usages.size()]), usageViewPresentation);\n  }","commit_id":"e4b693d3c991ea41a8a6a2b108342c0f7dcdce7d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Convert the input object into an output object of the specified type.\n     * <p>\n     * Typical implementations will provide a minimum of <code>String --> type<\/code> conversion.\n     * \n     * @param <T> the type in which the provided value has o be converted\n     * @param targetType Data type to which this value should be converted.\n     * @param value The input value to be converted.\n     * @return The converted value.\n     * @since 3.0M1\n     */\n    protected <T> T convertToType(Type targetType, Object value)\n    {\n        // Call #convertToType(Class<T> type, Object value) for retro compatibility\n        return convertToType(targetType, value);\n    }","id":91370,"modified_method":"/**\n     * Convert the input object into an output object of the specified type.\n     * <p>\n     * Typical implementations will provide a minimum of <code>String --> type<\/code> conversion.\n     * \n     * @param <T> the type in which the provided value has o be converted\n     * @param targetType Data type to which this value should be converted.\n     * @param value The input value to be converted.\n     * @return The converted value.\n     * @since 3.0M1\n     */\n    protected <T> T convertToType(Type targetType, Object value)\n    {\n        Class<T> clazz;\n        if (targetType instanceof Class) {\n            clazz = (Class) targetType;\n        } else if (targetType instanceof ParameterizedType) {\n            clazz = (Class) ((ParameterizedType) targetType).getRawType();\n        } else {\n            throw new ConversionException(\"Unknown type [\" + targetType + \"]\");\n        }\n\n        // Call #convertToType(Class<T> type, Object value) for retro-compatibility\n        return convertToType(clazz, value);\n    }","commit_id":"2fc7ca815032d621d8d9fc13e113051f6024adc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.properties.converter.Converter#convert(java.lang.reflect.Type, java.lang.Object)\n     */\n    public <T> T convert(Type targetType, Object sourceValue)\n    {\n        Class< ? > sourceType = sourceValue == null ? null : sourceValue.getClass();\n\n        if (targetType.equals(String.class)) {\n            // Convert --> String\n            return (T) ((Class) targetType).cast(convertToString(sourceValue));\n        } else if (targetType.equals(sourceType)) {\n            // No conversion necessary\n            return (T) sourceValue;\n        } else {\n            // Convert --> Type\n            return convertToType(targetType, sourceValue);\n        }\n    }","id":91371,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.properties.converter.Converter#convert(java.lang.reflect.Type, java.lang.Object)\n     */\n    public <T> T convert(Type targetType, Object sourceValue)\n    {\n        Class< ? > sourceType = sourceValue == null ? null : sourceValue.getClass();\n\n        T result;\n        if (targetType.equals(String.class)) {\n            // Convert --> String\n            result = (T) ((Class) targetType).cast(convertToString(sourceValue));\n        } else if (targetType.equals(sourceType)) {\n            // No conversion necessary\n            result = (T) sourceValue;\n        } else {\n            // Convert --> Type\n            result = (T) convertToType(targetType, sourceValue);\n        }\n        \n        return result;\n    }","commit_id":"2fc7ca815032d621d8d9fc13e113051f6024adc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.properties.ConverterManager#convert(java.lang.reflect.Type, java.lang.Object)\n     */\n    public <T> T convert(Type targetType, Object value)\n    {\n        // Convert\n        Converter converter = lookupConverter(targetType);\n\n        if (converter != null) {\n            return converter.convert(targetType, value);\n        } else {\n            throw new ConversionException(\"Can't find converter to convert value [\" + value + \"] to type [\"\n                + targetType + \"] \");\n        }\n    }","id":91372,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.properties.ConverterManager#convert(java.lang.reflect.Type, java.lang.Object)\n     */\n    public <T> T convert(Type targetType, Object value)\n    {\n        // Convert\n        Converter converter = lookupConverter(targetType);\n\n        if (converter != null) {\n            return (T) converter.convert(targetType, value);\n        } else {\n            throw new ConversionException(\"Can't find converter to convert value [\" + value + \"] to type [\"\n                + targetType + \"] \");\n        }\n    }","commit_id":"2fc7ca815032d621d8d9fc13e113051f6024adc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Find the right {@link Converter} for the provided {@link Class}.\n     * \n     * @param targetType the type to convert to\n     * @return the {@link Converter} corresponding to the class\n     */\n    private Converter lookupConverter(Type targetType)\n    {\n        Converter converter = null;\n\n        String typeGenericName = getTypeGenericName(targetType);\n        try {\n            converter = this.componentManager.lookup(Converter.class, getTypeGenericName(targetType));\n        } catch (ComponentLookupException e) {\n            getLogger().debug(\"Failed to find a proper Converter for type [\" + typeGenericName + \"]\", e);\n\n            if (targetType instanceof ParameterizedType) {\n                String typeName = getTypeName(targetType);\n                try {\n                    converter = this.componentManager.lookup(Converter.class, typeName);\n                } catch (ComponentLookupException e2) {\n                    getLogger().debug(\"Failed to find a proper Converter for class [\" + typeName + \"]\", e);\n                }\n            }\n        }\n\n        if (converter == null) {\n            if (Enum.class.isAssignableFrom(targetType.getClass())) {\n                converter = this.enumConverter;\n            } else {\n                getLogger().debug(\"Trying default Converter for target type [\" + typeGenericName + \"]\");\n\n                converter = this.defaultConverter;\n            }\n        }\n\n        return converter;\n    }","id":91373,"modified_method":"/**\n     * Find the right {@link Converter} for the provided {@link Class}.\n     * \n     * @param targetType the type to convert to\n     * @return the {@link Converter} corresponding to the class\n     */\n    private Converter lookupConverter(Type targetType)\n    {\n        Converter converter = null;\n\n        String typeGenericName = getTypeGenericName(targetType);\n        try {\n            converter = this.componentManager.lookup(Converter.class, getTypeGenericName(targetType));\n        } catch (ComponentLookupException e) {\n            getLogger().debug(\"Failed to find a proper Converter for type [\" + typeGenericName + \"]\", e);\n\n            if (targetType instanceof ParameterizedType) {\n                String typeName = getTypeName(targetType);\n                try {\n                    converter = this.componentManager.lookup(Converter.class, typeName);\n                } catch (ComponentLookupException e2) {\n                    getLogger().debug(\"Failed to find a proper Converter for class [\" + typeName + \"]\", e);\n                }\n            }\n        }\n\n        if (converter == null) {\n            if (targetType instanceof Class && Enum.class.isAssignableFrom((Class< ? >) targetType)) {\n                converter = this.enumConverter;\n            } else {\n                getLogger().debug(\"Trying default Converter for target type [\" + typeGenericName + \"]\");\n\n                converter = this.defaultConverter;\n            }\n        }\n\n        return converter;\n    }","commit_id":"2fc7ca815032d621d8d9fc13e113051f6024adc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public boolean haveBlock(int blockNo) {\n\t\tif(blockNo < dataBuckets.length)\n\t\t\treturn dataBuckets[blockNo] != null && dataBuckets[blockNo].hasData();\n\t\telse {\n\t\t\tblockNo -= dataBuckets.length;\n\t\t\treturn checkBuckets[blockNo] != null && checkBuckets[blockNo].hasData();\n\t\t}\n\t}","id":91374,"modified_method":"public boolean haveBlock(int blockNo, ObjectContainer container) {\n\t\tif(blockNo < dataBuckets.length) {\n\t\t\tif(dataBuckets[blockNo] == null) return false;\n\t\t\tif(persistent) container.activate(dataBuckets[blockNo], 1);\n\t\t\treturn dataBuckets[blockNo].hasData();\n\t\t} else {\n\t\t\tblockNo -= dataBuckets.length;\n\t\t\tif(checkBuckets[blockNo] != null) return false;\n\t\t\tif(persistent) container.activate(checkBuckets[blockNo], 1);\n\t\t\treturn checkBuckets[blockNo].hasData();\n\t\t}\n\t}","commit_id":"b726e5ad0705d7d6eea0b6021c446dfbfa485db2","url":"https://github.com/freenet/fred"},{"original_method":"private Object removeRandomBlockNum(KeysFetchingLocally keys, ClientContext context, ObjectContainer container) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(blockNums, 1);\n\t\t\tcontainer.activate(segment, 1);\n\t\t}\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tsynchronized(segment) {\n\t\t\tif(blockNums.isEmpty()) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"No blocks to remove\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfor(int i=0;i<10;i++) {\n\t\t\t\tObject ret;\n\t\t\t\tint x;\n\t\t\t\tx = context.random.nextInt(blockNums.size());\n\t\t\t\tret = (Integer) blockNums.remove(x);\n\t\t\t\tKey key = segment.getBlockNodeKey(((Integer)ret).intValue(), container);\n\t\t\t\tif(key == null) {\n\t\t\t\t\tif(segment.isFinishing(container) || segment.isFinished(container)) return null;\n\t\t\t\t\tif(segment.haveBlock(((Integer)ret).intValue()))\n\t\t\t\t\t\tLogger.error(this, \"Already have block \"+ret+\" but was in blockNums on \"+this);\n\t\t\t\t\telse\n\t\t\t\t\t\tLogger.error(this, \"Key is null for block \"+ret+\" for \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(keys.hasKey(key)) {\n\t\t\t\t\tblockNums.add(ret);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Removing block \"+x+\" of \"+(blockNums.size()+1)+ \" : \"+ret+ \" on \"+this);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.set(blockNums);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}","id":91375,"modified_method":"private Object removeRandomBlockNum(KeysFetchingLocally keys, ClientContext context, ObjectContainer container) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(blockNums, 1);\n\t\t\tcontainer.activate(segment, 1);\n\t\t}\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tsynchronized(segment) {\n\t\t\tif(blockNums.isEmpty()) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"No blocks to remove\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfor(int i=0;i<10;i++) {\n\t\t\t\tObject ret;\n\t\t\t\tint x;\n\t\t\t\tx = context.random.nextInt(blockNums.size());\n\t\t\t\tret = (Integer) blockNums.remove(x);\n\t\t\t\tKey key = segment.getBlockNodeKey(((Integer)ret).intValue(), container);\n\t\t\t\tif(key == null) {\n\t\t\t\t\tif(segment.isFinishing(container) || segment.isFinished(container)) return null;\n\t\t\t\t\tif(segment.haveBlock(((Integer)ret).intValue(), container))\n\t\t\t\t\t\tLogger.error(this, \"Already have block \"+ret+\" but was in blockNums on \"+this);\n\t\t\t\t\telse\n\t\t\t\t\t\tLogger.error(this, \"Key is null for block \"+ret+\" for \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(keys.hasKey(key)) {\n\t\t\t\t\tblockNums.add(ret);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Removing block \"+x+\" of \"+(blockNums.size()+1)+ \" : \"+ret+ \" on \"+this);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.set(blockNums);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"b726e5ad0705d7d6eea0b6021c446dfbfa485db2","url":"https://github.com/freenet/fred"},{"original_method":"public int read() throws IOException {\n        if (this.shutdown) {\n            return -1;\n        }\n        this.lock.lock();\n        try {\n            if (!hasData()) {\n                waitForData();\n            }\n            if (isEndOfStream()) {\n                return -1;\n            }\n            return this.buffer.get() & 0xff;\n        } finally {\n            this.lock.unlock();\n        }\n    }","id":91376,"modified_method":"public int read() throws IOException {\n        if (this.shutdown) {\n            return -1;\n        }\n        this.lock.lock();\n        try {\n            if (!super.hasData()) {\n                waitForData(0);\n            }\n            if (isEndOfStream()) {\n                return -1;\n            }\n            setOutputMode();\n            return this.buffer.get() & 0xff;\n        } finally {\n            this.lock.unlock();\n        }\n    }","commit_id":"e8afadaf94b7ca176774979b56b4d98d67d93cc8","url":"https://github.com/apache/cxf"},{"original_method":"public int read(final byte[] b, int off, int len) throws IOException {\n        if (this.shutdown) {\n            return -1;\n        }\n        if (b == null) {\n            return 0;\n        }\n        this.lock.lock();\n        try {\n            if (!hasData()) {\n                this.waitingBuffer = ByteBuffer.wrap(b, off, len);\n                waitForData();\n                int i = waitingBuffer.position() - off;\n                waitingBuffer = null;\n                if (i > 0) {\n                    //++waitCnt;\n                    return i;\n                }\n            }\n            if (isEndOfStream()) {\n                //System.out.println(waitCnt + \" \" + nowaitCnt);\n                return -1;\n            }\n            setOutputMode();\n            int chunk = len;\n            if (chunk > this.buffer.remaining()) {\n                chunk = this.buffer.remaining();\n            }\n            this.buffer.get(b, off, chunk);\n            if (this.buffer.position() >= this.requestInputSize && !this.endOfStream && this.ioctrl != null) {\n                //we have a significant amount of space empty in the buffer, we'll turn on \n                //the input so maybe we'll get another chunk by the time the next read happens\n                //and we can then avoid waiting for input\n                this.ioctrl.requestInput();\n            }\n            //++nowaitCnt;\n            return chunk;\n        } finally {\n            this.lock.unlock();\n        }\n    }","id":91377,"modified_method":"public int read(final byte[] b, int off, int len) throws IOException {\n        if (this.shutdown) {\n            return -1;\n        }\n        if (b == null) {\n            return 0;\n        }\n        this.lock.lock();\n        try {\n            if (!hasData()) {\n                this.waitingBuffer = ByteBuffer.wrap(b, off, len);\n                waitForData(off);\n                int i = waitingBuffer.position() - off;\n                waitingBuffer = null;\n                if (i > 0) {\n                    //++waitCnt;\n                    return i;\n                }\n            }\n            if (isEndOfStream()) {\n                //System.out.println(waitCnt + \" \" + nowaitCnt);\n                return -1;\n            }\n            setOutputMode();\n            int chunk = len;\n            if (chunk > this.buffer.remaining()) {\n                chunk = this.buffer.remaining();\n            }\n            this.buffer.get(b, off, chunk);\n            if (this.buffer.position() >= this.requestInputSize && !this.endOfStream && this.ioctrl != null) {\n                //we have a significant amount of space empty in the buffer, we'll turn on \n                //the input so maybe we'll get another chunk by the time the next read happens\n                //and we can then avoid waiting for input\n                this.ioctrl.requestInput();\n            }\n            //++nowaitCnt;\n            return chunk;\n        } finally {\n            this.lock.unlock();\n        }\n    }","commit_id":"e8afadaf94b7ca176774979b56b4d98d67d93cc8","url":"https://github.com/apache/cxf"},{"original_method":"protected void waitForData() throws IOException {\n        this.lock.lock();\n        try {\n            try {\n                while ((this.waitingBuffer != null && this.waitingBuffer.position() == 0) \n                    && !super.hasData() && !this.endOfStream) {\n                    if (this.shutdown) {\n                        throw new InterruptedIOException(\"Input operation aborted\");\n                    }\n                    if (this.ioctrl != null) {\n                        this.ioctrl.requestInput();\n                    }\n                    this.condition.await();\n                }\n            } catch (InterruptedException ex) {\n                throw new IOException(\"Interrupted while waiting for more data\");\n            }\n        } finally {\n            this.lock.unlock();\n        }\n    }","id":91378,"modified_method":"protected void waitForData(int waitPos) throws IOException {\n        this.lock.lock();\n        try {\n            try {\n                while (true) {\n                    if (this.waitingBuffer != null && this.waitingBuffer.position() > waitPos) {\n                        return;\n                    }\n                    if (super.hasData()) {\n                        return;\n                    }\n                    if (this.endOfStream) {\n                        return;\n                    }\n                    if (this.shutdown) {\n                        throw new InterruptedIOException(\"Input operation aborted\");\n                    }\n                    if (this.ioctrl != null) {\n                        this.ioctrl.requestInput();\n                    }\n                    this.condition.await();\n                }\n            } catch (InterruptedException ex) {\n                throw new IOException(\"Interrupted while waiting for more data\");\n            }\n        } finally {\n            this.lock.unlock();\n        }\n    }","commit_id":"e8afadaf94b7ca176774979b56b4d98d67d93cc8","url":"https://github.com/apache/cxf"},{"original_method":"private RemoveRandomReturn removeRandomExhaustiveSearch(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tObjectContainer container, ClientContext context, long now) {\n\t\tif(logMINOR && persistent) \n\t\t\tLogger.minor(this, \"Doing exhaustive search and compaction on \"+this);\n\t\tboolean changedMe = false;\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\tRandomGrabArrayItem ret = null;\n\t\tint random = -1;\n\t\tif(persistent) container.activate(blocks[0], 1);\n\t\tRandomGrabArrayItem[] reqsReading = blocks[0].reqs;\n\t\tRandomGrabArrayItem[] reqsWriting = blocks[0].reqs;\n\t\tint blockNumReading = 0;\n\t\tint blockNumWriting = 0;\n\t\tint offset = -1;\n\t\tint writeOffset = -1;\n\t\twhile(true) {\n\t\t\tint exclude = 0;\n\t\t\tint valid = 0;\n\t\t\tint validIndex = -1;\n\t\t\tint target = 0;\n\t\t\tint chosenIndex = -1;\n\t\t\tRandomGrabArrayItem chosenItem = null;\n\t\t\tRandomGrabArrayItem validItem = null;\n\t\t\tfor(int i=0;i<index;i++) {\n\t\t\t\toffset++;\n\t\t\t\t// Compact the array.\n\t\t\t\tRandomGrabArrayItem item;\n\t\t\t\tif(offset == BLOCK_SIZE) {\n\t\t\t\t\toffset = -1;\n\t\t\t\t\tif(persistent && changedMe)\n\t\t\t\t\t\tcontainer.store(blocks[blockNumReading]);\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.deactivate(blocks[blockNumReading], 1);\n\t\t\t\t\tblockNumReading++;\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.activate(blocks[blockNumReading], 1);\n\t\t\t\t\treqsReading = blocks[blockNumReading].reqs;\n\t\t\t\t}\n\t\t\t\titem = reqsReading[offset];\n\t\t\t\tif(item == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tboolean excludeItem = false;\n\t\t\t\tboolean activated = false;\n\t\t\t\tlong excludeTime = excluding.excludeSummarily(item, this, container, persistent, now);\n\t\t\t\tif(excludeTime > 0) {\n\t\t\t\t\t// In cooldown, will be wanted later.\n\t\t\t\t\texcludeItem = true;\n\t\t\t\t\tif(wakeupTime > excludeTime) wakeupTime = excludeTime;\n\t\t\t\t} else {\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.activate(item, 1);\n\t\t\t\t\tactivated = true;\n\t\t\t\t\tboolean broken = false;\n\t\t\t\t\tbroken = persistent && item.isStorageBroken(container);\n\t\t\t\t\tlong itemWakeTime = -1;\n\t\t\t\t\tif(broken) {\n\t\t\t\t\t\tLogger.error(this, \"Storage broken on \"+item);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\titem.removeFrom(container, context);\n\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\tcontainer.delete(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else itemWakeTime = item.getCooldownTime(container, context, now);\n\t\t\t\t\tif(itemWakeTime == -1 || broken) {\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Removing \"+item+\" on \"+this);\n\t\t\t\t\t\tchangedMe = true;\n\t\t\t\t\t\t// We are doing compaction here. We don't need to swap with the end; we write valid ones to the target location.\n\t\t\t\t\t\treqsReading[offset] = null;\n\t\t\t\t\t\titem.setParentGrabArray(null, container);\n\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\tcontainer.deactivate(item, 1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if(itemWakeTime > 0) {\n\t\t\t\t\t\tif(itemWakeTime < wakeupTime) wakeupTime = itemWakeTime;\n\t\t\t\t\t\texcludeItem = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(!excludeItem)\n\t\t\t\t\t\texcludeItem = excluding.exclude(item, container, context);\n\t\t\t\t}\n\t\t\t\twriteOffset++;\n\t\t\t\tif(writeOffset == BLOCK_SIZE) {\n\t\t\t\t\twriteOffset = 0;\n\t\t\t\t\tif(persistent && changedMe)\n\t\t\t\t\t\tcontainer.store(blocks[blockNumWriting]);\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.deactivate(blocks[blockNumWriting], 1);\n\t\t\t\t\tblockNumWriting++;\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.activate(blocks[blockNumWriting], 1);\n\t\t\t\t\treqsWriting = blocks[blockNumWriting].reqs;\n\t\t\t\t}\n\t\t\t\tif(i != target) {\n\t\t\t\t\tchangedMe = true;\n\t\t\t\t\treqsReading[offset] = null;\n\t\t\t\t\treqsWriting[writeOffset] = item;\n\t\t\t\t} // else the request can happily stay where it is\n\t\t\t\ttarget++;\n\t\t\t\tif(excludeItem) {\n\t\t\t\t\texclude++;\n\t\t\t\t} else {\n\t\t\t\t\tif(valid == random) { // Picked on previous round\n\t\t\t\t\t\tchosenIndex = target-1;\n\t\t\t\t\t\tchosenItem = item;\n\t\t\t\t\t}\n\t\t\t\t\tif(validIndex == -1) {\n\t\t\t\t\t\t// Take the first valid item\n\t\t\t\t\t\tvalidIndex = target-1;\n\t\t\t\t\t\tvalidItem = item;\n\t\t\t\t\t}\n\t\t\t\t\tvalid++;\n\t\t\t\t}\n\t\t\t\tif(persistent && activated && item != chosenItem && item != validItem) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Deactivating \"+item);\n\t\t\t\t\tcontainer.deactivate(item, 1);\n\t\t\t\t\tif(container.ext().isActive(item))\n\t\t\t\t\t\tLogger.error(this, \"Still active after deactivation: \"+item);\n\t\t\t\t\telse if(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Deactivated: \"+item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(index != target) {\n\t\t\t\tchangedMe = true;\n\t\t\t\tindex = target;\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.deactivate(blocks[blockNumReading], 1);\n\t\t\t\t\tif(blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.deactivate(blocks[blockNumWriting], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// We reach this point if 1) the random number we picked last round is invalid because an item became cancelled or excluded\n\t\t\t// or 2) we are on the first round anyway.\n\t\t\tif(chosenItem != null) {\n\t\t\t\tif(persistent && validItem != null && validItem != chosenItem)\n\t\t\t\t\tcontainer.deactivate(validItem, 1);\n\t\t\t\tchangedMe = true;\n\t\t\t\tret = chosenItem;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Chosen random item \"+ret+\" out of \"+valid+\" total \"+index);\n\t\t\t\tif(persistent && changedMe) {\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\treturn new RemoveRandomReturn(ret);\n\t\t\t}\n\t\t\tif(valid == 0 && exclude == 0) {\n\t\t\t\tindex = 0;\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No valid or excluded items total \"+index);\n\t\t\t\treturn null; // Caller should remove the whole RGA\n\t\t\t} else if(valid == 0) {\n\t\t\t\tif(persistent && changedMe) {\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No valid items, \"+exclude+\" excluded items total \"+index);\n\t\t\t\tcontext.cooldownTracker.setCachedWakeup(wakeupTime, this, parent, persistent, container);\n\t\t\t\treturn new RemoveRandomReturn(wakeupTime);\n\t\t\t} else if(valid == 1) {\n\t\t\t\tret = validItem;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No valid or excluded items apart from \"+ret+\" total \"+index);\n\t\t\t\tif(persistent && changedMe) {\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\treturn new RemoveRandomReturn(ret);\n\t\t\t} else {\n\t\t\t\trandom = context.fastWeakRandom.nextInt(valid);\n\t\t\t}\n\t\t}\n\t}","id":91379,"modified_method":"private RemoveRandomReturn removeRandomExhaustiveSearch(\n\t\t\tRandomGrabArrayItemExclusionList excluding,\n\t\t\tObjectContainer container, ClientContext context, long now) {\n\t\tif(logMINOR && persistent) \n\t\t\tLogger.minor(this, \"Doing exhaustive search and compaction on \"+this);\n\t\tboolean changedMe = false;\n\t\tlong wakeupTime = Long.MAX_VALUE;\n\t\tRandomGrabArrayItem ret = null;\n\t\tint random = -1;\n\t\tif(persistent) container.activate(blocks[0], 1);\n\t\tRandomGrabArrayItem[] reqsReading = blocks[0].reqs;\n\t\tRandomGrabArrayItem[] reqsWriting = blocks[0].reqs;\n\t\tint blockNumReading = 0;\n\t\tint blockNumWriting = 0;\n\t\tint offset = -1;\n\t\tint writeOffset = -1;\n\t\twhile(true) {\n\t\t\tint exclude = 0;\n\t\t\tint valid = 0;\n\t\t\tint validIndex = -1;\n\t\t\tint target = 0;\n\t\t\tint chosenIndex = -1;\n\t\t\tRandomGrabArrayItem chosenItem = null;\n\t\t\tRandomGrabArrayItem validItem = null;\n\t\t\tfor(int i=0;i<index;i++) {\n\t\t\t\toffset++;\n\t\t\t\t// Compact the array.\n\t\t\t\tRandomGrabArrayItem item;\n\t\t\t\tif(offset == BLOCK_SIZE) {\n\t\t\t\t\toffset = -1;\n\t\t\t\t\tif(persistent && changedMe)\n\t\t\t\t\t\tcontainer.store(blocks[blockNumReading]);\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.deactivate(blocks[blockNumReading], 1);\n\t\t\t\t\tblockNumReading++;\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.activate(blocks[blockNumReading], 1);\n\t\t\t\t\treqsReading = blocks[blockNumReading].reqs;\n\t\t\t\t}\n\t\t\t\titem = reqsReading[offset];\n\t\t\t\tif(item == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tboolean excludeItem = false;\n\t\t\t\tboolean activated = false;\n\t\t\t\tlong excludeTime = excluding.excludeSummarily(item, this, container, persistent, now);\n\t\t\t\tif(excludeTime > 0) {\n\t\t\t\t\t// In cooldown, will be wanted later.\n\t\t\t\t\texcludeItem = true;\n\t\t\t\t\tif(wakeupTime > excludeTime) wakeupTime = excludeTime;\n\t\t\t\t} else {\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.activate(item, 1);\n\t\t\t\t\tactivated = true;\n\t\t\t\t\tboolean broken = false;\n\t\t\t\t\tbroken = persistent && item.isStorageBroken(container);\n\t\t\t\t\tlong itemWakeTime = -1;\n\t\t\t\t\tif(broken) {\n\t\t\t\t\t\tLogger.error(this, \"Storage broken on \"+item);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\titem.removeFrom(container, context);\n\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\tcontainer.delete(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else itemWakeTime = item.getCooldownTime(container, context, now);\n\t\t\t\t\tif(itemWakeTime == -1 || broken) {\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Removing \"+item+\" on \"+this);\n\t\t\t\t\t\tchangedMe = true;\n\t\t\t\t\t\t// We are doing compaction here. We don't need to swap with the end; we write valid ones to the target location.\n\t\t\t\t\t\treqsReading[offset] = null;\n\t\t\t\t\t\titem.setParentGrabArray(null, container);\n\t\t\t\t\t\tif(persistent)\n\t\t\t\t\t\t\tcontainer.deactivate(item, 1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if(itemWakeTime > 0) {\n\t\t\t\t\t\tif(itemWakeTime < wakeupTime) wakeupTime = itemWakeTime;\n\t\t\t\t\t\texcludeItem = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(!excludeItem)\n\t\t\t\t\t\texcludeItem = excluding.exclude(item, container, context);\n\t\t\t\t}\n\t\t\t\twriteOffset++;\n\t\t\t\tif(writeOffset == BLOCK_SIZE) {\n\t\t\t\t\twriteOffset = 0;\n\t\t\t\t\tif(persistent && changedMe)\n\t\t\t\t\t\tcontainer.store(blocks[blockNumWriting]);\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.deactivate(blocks[blockNumWriting], 1);\n\t\t\t\t\tblockNumWriting++;\n\t\t\t\t\tif(persistent && blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.activate(blocks[blockNumWriting], 1);\n\t\t\t\t\treqsWriting = blocks[blockNumWriting].reqs;\n\t\t\t\t}\n\t\t\t\tif(i != target) {\n\t\t\t\t\tchangedMe = true;\n\t\t\t\t\treqsReading[offset] = null;\n\t\t\t\t\treqsWriting[writeOffset] = item;\n\t\t\t\t} // else the request can happily stay where it is\n\t\t\t\ttarget++;\n\t\t\t\tif(excludeItem) {\n\t\t\t\t\texclude++;\n\t\t\t\t} else {\n\t\t\t\t\tif(valid == random) { // Picked on previous round\n\t\t\t\t\t\tchosenIndex = target-1;\n\t\t\t\t\t\tchosenItem = item;\n\t\t\t\t\t}\n\t\t\t\t\tif(validIndex == -1) {\n\t\t\t\t\t\t// Take the first valid item\n\t\t\t\t\t\tvalidIndex = target-1;\n\t\t\t\t\t\tvalidItem = item;\n\t\t\t\t\t}\n\t\t\t\t\tvalid++;\n\t\t\t\t}\n\t\t\t\tif(persistent && activated && item != chosenItem && item != validItem) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Deactivating \"+item);\n\t\t\t\t\tcontainer.deactivate(item, 1);\n\t\t\t\t\tif(container.ext().isActive(item))\n\t\t\t\t\t\tLogger.error(this, \"Still active after deactivation: \"+item);\n\t\t\t\t\telse if(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Deactivated: \"+item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(index != target) {\n\t\t\t\tchangedMe = true;\n\t\t\t\tindex = target;\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.deactivate(blocks[blockNumReading], 1);\n\t\t\t\t\tif(blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.deactivate(blocks[blockNumWriting], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// We reach this point if 1) the random number we picked last round is invalid because an item became cancelled or excluded\n\t\t\t// or 2) we are on the first round anyway.\n\t\t\tif(chosenItem != null) {\n\t\t\t\tif(persistent && validItem != null && validItem != chosenItem)\n\t\t\t\t\tcontainer.deactivate(validItem, 1);\n\t\t\t\tchangedMe = true;\n\t\t\t\tret = chosenItem;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Chosen random item \"+ret+\" out of \"+valid+\" total \"+index);\n\t\t\t\tif(persistent && changedMe) {\n\t\t\t\t\tcontainer.store(blocks[blockNumReading]);\n\t\t\t\t\tif(blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.store(blocks[blockNumWriting]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\treturn new RemoveRandomReturn(ret);\n\t\t\t}\n\t\t\tif(valid == 0 && exclude == 0) {\n\t\t\t\tindex = 0;\n\t\t\t\tif(persistent) {\n\t\t\t\t\tif(blocks.length != 0)\n\t\t\t\t\t\tblocks = new Block[] { blocks[0] };\n\t\t\t\t\tcontainer.store(blocks[0]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No valid or excluded items total \"+index);\n\t\t\t\treturn null; // Caller should remove the whole RGA\n\t\t\t} else if(valid == 0) {\n\t\t\t\tif(persistent && changedMe) {\n\t\t\t\t\tcontainer.store(blocks[blockNumReading]);\n\t\t\t\t\tif(blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.store(blocks[blockNumWriting]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No valid items, \"+exclude+\" excluded items total \"+index);\n\t\t\t\tcontext.cooldownTracker.setCachedWakeup(wakeupTime, this, parent, persistent, container);\n\t\t\t\treturn new RemoveRandomReturn(wakeupTime);\n\t\t\t} else if(valid == 1) {\n\t\t\t\tret = validItem;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No valid or excluded items apart from \"+ret+\" total \"+index);\n\t\t\t\tif(persistent && changedMe) {\n\t\t\t\t\tcontainer.store(blocks[blockNumReading]);\n\t\t\t\t\tif(blockNumReading != blockNumWriting)\n\t\t\t\t\t\tcontainer.store(blocks[blockNumWriting]);\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\t}\n\t\t\t\treturn new RemoveRandomReturn(ret);\n\t\t\t} else {\n\t\t\t\trandom = context.fastWeakRandom.nextInt(valid);\n\t\t\t}\n\t\t}\n\t}","commit_id":"0c3209b773d98ebe45631a9001a5363b9e753cd1","url":"https://github.com/freenet/fred"},{"original_method":"public SolrInputDocument storeDocument(\n            final DigestURL url,\n            final DigestURL referrerURL,\n            final Map<String, Pattern> collections,\n            final CrawlProfile crawlProfile,\n            final ResponseHeader responseHeader,\n            final Document document,\n            final Condenser condenser,\n            final SearchEvent searchEvent,\n            final String sourceName, // contains the crawl profile hash if this comes from a web crawl\n            final boolean storeToRWI,\n            final String proxy,\n            final String acceptLanguage\n            ) {\n        final long startTime = System.currentTimeMillis();\n        \n        // CREATE INDEX\n        // load some document metadata\n        final Date loadDate = new Date();\n        final String id = ASCII.String(url.hash());\n        final String dc_title = document.dc_title();\n        final String urlNormalform = url.toNormalform(true);\n        final String language = votedLanguage(url, urlNormalform, document, condenser); // identification of the language\n\n        // STORE URL TO LOADED-URL-DB\n        Date modDate = responseHeader == null ? new Date() : responseHeader.lastModified();\n        if (modDate == null) modDate = new Date();\n        if (modDate.getTime() > loadDate.getTime()) modDate = loadDate;\n        char docType = Response.docType(document.dc_format());\n        \n        // CREATE SOLR DOCUMENT\n        final CollectionConfiguration collectionConfig = this.fulltext.getDefaultConfiguration();\n        final CollectionConfiguration.SolrVector vector = collectionConfig.yacy2solr(this, collections, responseHeader, document, condenser, referrerURL, language, this.fulltext().useWebgraph() ? this.fulltext.getWebgraphConfiguration() : null, sourceName);\n        \n        // ENRICH DOCUMENT WITH RANKING INFORMATION\n        this.fulltext.getDefaultConfiguration().postprocessing_references(this.getReferenceReportCache(), vector, url, null);\n        \n        // CREATE SNAPSHOT\n        if ((url.getProtocol().equals(\"http\") || url.getProtocol().equals(\"https\")) &&\n                crawlProfile != null && document.getDepth() <= crawlProfile.snapshotMaxdepth()) {\n            // load pdf in case that is wanted. This can later be used to compute a web page preview in the search results\n            String ext = MultiProtocolURL.getFileExtension(url.getFile()).toLowerCase();\n            if (ext.length() == 0 || url.getFile().length() <= 1 || htmlParser.htmlExtensionsSet.contains(ext)) {\n                // STORE IMAGE AND METADATA\n                Transactions.store(vector, crawlProfile.snapshotLoadImage(), crawlProfile.snapshotReplaceold(), proxy, crawlProfile.getAgent(), acceptLanguage);\n            }\n        }\n        \n        // STORE TO SOLR\n        this.putDocument(vector);\n        List<SolrInputDocument> webgraph = vector.getWebgraphDocuments();\n        String error = null;\n        if (webgraph != null && webgraph.size() > 0) {\n            \n            // write the edges to the webgraph solr index\n            if (this.fulltext.useWebgraph()) {\n                tryloop: for (int i = 0; i < 20; i++) {\n                    try {\n                        error = null;\n                        this.fulltext.putEdges(webgraph);\n                        break tryloop;\n                    } catch (final IOException e ) {\n                        error = \"failed to send \" + urlNormalform + \" to solr: \" + e.getMessage();\n                        ConcurrentLog.warn(\"SOLR\", error);\n                        if (i == 10) this.fulltext.commit(true);\n                        try {Thread.sleep(1000);} catch (final InterruptedException e1) {}\n                        continue tryloop;\n                    }\n                }\n            }\n        \n        }\n        \n        // REMEMBER FIRST SEEN\n        setFirstSeenTime(url.hash(), Math.min(document.getLastModified().getTime(), System.currentTimeMillis())); // should exist already in the index at this time, but just to make sure\n\n        // write the edges to the citation reference index\n        if (this.connectedCitation()) try {\n            // we use the subgraph to write the citation index, that shall cause that the webgraph and the citation index is identical\n            \n            if (collectionConfig.contains(CollectionSchema.inboundlinks_protocol_sxt) || collectionConfig.contains(CollectionSchema.inboundlinks_urlstub_sxt)) {\n                Collection<Object> inboundlinks_urlstub = vector.getFieldValues(CollectionSchema.inboundlinks_urlstub_sxt.getSolrFieldName());\n                List<String> inboundlinks_protocol = inboundlinks_urlstub == null ? null : CollectionConfiguration.indexedList2protocolList(vector.getFieldValues(CollectionSchema.inboundlinks_protocol_sxt.getSolrFieldName()), inboundlinks_urlstub.size());\n                if (inboundlinks_protocol != null && inboundlinks_urlstub != null && inboundlinks_protocol.size() == inboundlinks_urlstub.size() && inboundlinks_urlstub instanceof List<?>) {\n                    for (int i = 0; i < inboundlinks_protocol.size(); i++) {\n                        String targetURL = inboundlinks_protocol.get(i) + \"://\" + ((String) ((List<?>) inboundlinks_urlstub).get(i));\n                        String referrerhash = id;\n                        String anchorhash = ASCII.String(new DigestURL(targetURL).hash());\n                        if (referrerhash != null && anchorhash != null) {\n                            urlCitationIndex.add(ASCII.getBytes(anchorhash), new CitationReference(ASCII.getBytes(referrerhash), loadDate.getTime()));\n                        }\n                    }\n                }\n            }\n            if (collectionConfig.contains(CollectionSchema.outboundlinks_protocol_sxt) || collectionConfig.contains(CollectionSchema.outboundlinks_urlstub_sxt)) {\n                Collection<Object> outboundlinks_urlstub = vector.getFieldValues(CollectionSchema.outboundlinks_urlstub_sxt.getSolrFieldName());\n                List<String> outboundlinks_protocol = outboundlinks_urlstub == null ? null : CollectionConfiguration.indexedList2protocolList(vector.getFieldValues(CollectionSchema.outboundlinks_protocol_sxt.getSolrFieldName()), outboundlinks_urlstub.size());\n                if (outboundlinks_protocol != null && outboundlinks_urlstub != null && outboundlinks_protocol.size() == outboundlinks_urlstub.size() && outboundlinks_urlstub instanceof List<?>) {\n                    for (int i = 0; i < outboundlinks_protocol.size(); i++) {\n                        String targetURL = outboundlinks_protocol.get(i) + \"://\" + ((String) ((List<?>) outboundlinks_urlstub).get(i));\n                        String referrerhash = id;\n                        String anchorhash = ASCII.String(new DigestURL(targetURL).hash());\n                        if (referrerhash != null && anchorhash != null) {\n                            urlCitationIndex.add(ASCII.getBytes(anchorhash), new CitationReference(ASCII.getBytes(referrerhash), loadDate.getTime()));\n                        }\n                    }\n                }\n            }\n        } catch (Throwable e) {\n            ConcurrentLog.logException(e);\n        }\n        \n        if (error != null) {\n            ConcurrentLog.severe(\"SOLR\", error + \", PLEASE REPORT TO bugs.yacy.net\");\n            //Switchboard.getSwitchboard().pauseCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, error);\n            //Switchboard.getSwitchboard().pauseCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, error);\n        }\n        final long storageEndTime = System.currentTimeMillis();\n\n        // STORE PAGE INDEX INTO WORD INDEX DB\n        int outlinksSame = document.inboundLinks().size();\n        int outlinksOther = document.outboundLinks().size();\n        final int urlLength = urlNormalform.length();\n        final int urlComps = MultiProtocolURL.urlComps(url.toNormalform(false)).length;\n\n        // create a word prototype which is re-used for all entries\n        if ((this.termIndex != null && storeToRWI) || searchEvent != null) {\n            final int len = (document == null) ? urlLength : document.dc_title().length();\n            final WordReferenceRow ientry = new WordReferenceRow(\n                            url.hash(),\n                            urlLength, urlComps, len,\n                            condenser.RESULT_NUMB_WORDS,\n                            condenser.RESULT_NUMB_SENTENCES,\n                            modDate.getTime(),\n                            System.currentTimeMillis(),\n                            UTF8.getBytes(language),\n                            docType,\n                            outlinksSame, outlinksOther);\n    \n            // iterate over all words of content text\n            Word wprop = null;\n            byte[] wordhash;\n            String word;\n            for (Map.Entry<String, Word> wentry: condenser.words().entrySet()) {\n                word = wentry.getKey();\n                wprop = wentry.getValue();\n                assert (wprop.flags != null);\n                ientry.setWord(wprop);\n                wordhash = Word.word2hash(word);\n                if (this.termIndex != null && storeToRWI) try {\n                    this.termIndex.add(wordhash, ientry);\n                } catch (final Exception e) {\n                    ConcurrentLog.logException(e);\n                }\n    \n                // during a search event it is possible that a heuristic is used which aquires index\n                // data during search-time. To transfer indexed data directly to the search process\n                // the following lines push the index data additionally to the search process\n                // this is done only for searched words\n                if (searchEvent != null && !searchEvent.query.getQueryGoal().getExcludeHashes().has(wordhash) && searchEvent.query.getQueryGoal().getIncludeHashes().has(wordhash)) {\n                    // if the page was added in the context of a heuristic this shall ensure that findings will fire directly into the search result\n                    ReferenceContainer<WordReference> container;\n                    try {\n                        container = ReferenceContainer.emptyContainer(Segment.wordReferenceFactory, wordhash, 1);\n                        container.add(ientry);\n                        searchEvent.addRWIs(container, true, sourceName, 1, 5000);\n                    } catch (final SpaceExceededException e) {\n                        continue;\n                    }\n                }\n            }\n            if (searchEvent != null) searchEvent.addFinalize();\n    \n            // assign the catchall word\n            ientry.setWord(wprop == null ? catchallWord : wprop); // we use one of the word properties as template to get the document characteristics\n            if (this.termIndex != null) try {this.termIndex.add(catchallHash, ientry);} catch (final Throwable e) {ConcurrentLog.logException(e);}\n        }\n\n        // finish index time\n        final long indexingEndTime = System.currentTimeMillis();\n\n        if (this.log.isInfo()) {\n            this.log.info(\"*Indexed \" + condenser.words().size() + \" words in URL \" + url +\n                    \" [\" + id + \"]\" +\n                    \"\\n\\tDescription:  \" + dc_title +\n                    \"\\n\\tMimeType: \"  + document.dc_format() + \" | Charset: \" + document.getCharset() + \" | \" +\n                    \"Size: \" + document.getTextLength() + \" bytes | \" +\n                    //\"Anchors: \" + refs +\n                    \"\\n\\tLinkStorageTime: \" + (storageEndTime - startTime) + \" ms | \" +\n                    \"indexStorageTime: \" + (indexingEndTime - storageEndTime) + \" ms\");\n        }\n\n        // finished\n        return vector;\n    }","id":91380,"modified_method":"public SolrInputDocument storeDocument(\n            final DigestURL url,\n            final DigestURL referrerURL,\n            final Map<String, Pattern> collections,\n            final CrawlProfile crawlProfile,\n            final ResponseHeader responseHeader,\n            final Document document,\n            final Condenser condenser,\n            final SearchEvent searchEvent,\n            final String sourceName, // contains the crawl profile hash if this comes from a web crawl\n            final boolean storeToRWI,\n            final String proxy,\n            final String acceptLanguage\n            ) {\n        final long startTime = System.currentTimeMillis();\n        \n        // CREATE INDEX\n        // load some document metadata\n        final Date loadDate = new Date();\n        final String id = ASCII.String(url.hash());\n        final String dc_title = document.dc_title();\n        final String urlNormalform = url.toNormalform(true);\n        final String language = votedLanguage(url, urlNormalform, document, condenser); // identification of the language\n\n        // STORE URL TO LOADED-URL-DB\n        Date modDate = responseHeader == null ? new Date() : responseHeader.lastModified();\n        if (modDate == null) modDate = new Date();\n        if (modDate.getTime() > loadDate.getTime()) modDate = loadDate;\n        char docType = Response.docType(document.dc_format());\n        \n        // CREATE SOLR DOCUMENT\n        final CollectionConfiguration collectionConfig = this.fulltext.getDefaultConfiguration();\n        final CollectionConfiguration.SolrVector vector = collectionConfig.yacy2solr(this, collections, responseHeader, document, condenser, referrerURL, language, this.fulltext().useWebgraph() ? this.fulltext.getWebgraphConfiguration() : null, sourceName);\n        \n        // ENRICH DOCUMENT WITH RANKING INFORMATION\n        this.fulltext.getDefaultConfiguration().postprocessing_references(this.getReferenceReportCache(), vector, url, null);\n        \n        // CREATE SNAPSHOT\n        if ((url.getProtocol().equals(\"http\") || url.getProtocol().equals(\"https\")) &&\n                crawlProfile != null && document.getDepth() <= crawlProfile.snapshotMaxdepth()) {\n            // load pdf in case that is wanted. This can later be used to compute a web page preview in the search results\n            String ext = MultiProtocolURL.getFileExtension(url.getFile()).toLowerCase();\n            if (ext.length() == 0 || url.getFile().length() <= 1 || htmlParser.htmlExtensionsSet.contains(ext)) {\n                // STORE IMAGE AND METADATA\n                Transactions.store(vector, true, crawlProfile.snapshotLoadImage(), crawlProfile.snapshotReplaceold(), proxy, crawlProfile.getAgent(), acceptLanguage);\n            }\n        }\n        \n        // STORE TO SOLR\n        this.putDocument(vector);\n        List<SolrInputDocument> webgraph = vector.getWebgraphDocuments();\n        String error = null;\n        if (webgraph != null && webgraph.size() > 0) {\n            \n            // write the edges to the webgraph solr index\n            if (this.fulltext.useWebgraph()) {\n                tryloop: for (int i = 0; i < 20; i++) {\n                    try {\n                        error = null;\n                        this.fulltext.putEdges(webgraph);\n                        break tryloop;\n                    } catch (final IOException e ) {\n                        error = \"failed to send \" + urlNormalform + \" to solr: \" + e.getMessage();\n                        ConcurrentLog.warn(\"SOLR\", error);\n                        if (i == 10) this.fulltext.commit(true);\n                        try {Thread.sleep(1000);} catch (final InterruptedException e1) {}\n                        continue tryloop;\n                    }\n                }\n            }\n        \n        }\n        \n        // REMEMBER FIRST SEEN\n        setFirstSeenTime(url.hash(), Math.min(document.getLastModified().getTime(), System.currentTimeMillis())); // should exist already in the index at this time, but just to make sure\n\n        // write the edges to the citation reference index\n        if (this.connectedCitation()) try {\n            // we use the subgraph to write the citation index, that shall cause that the webgraph and the citation index is identical\n            \n            if (collectionConfig.contains(CollectionSchema.inboundlinks_protocol_sxt) || collectionConfig.contains(CollectionSchema.inboundlinks_urlstub_sxt)) {\n                Collection<Object> inboundlinks_urlstub = vector.getFieldValues(CollectionSchema.inboundlinks_urlstub_sxt.getSolrFieldName());\n                List<String> inboundlinks_protocol = inboundlinks_urlstub == null ? null : CollectionConfiguration.indexedList2protocolList(vector.getFieldValues(CollectionSchema.inboundlinks_protocol_sxt.getSolrFieldName()), inboundlinks_urlstub.size());\n                if (inboundlinks_protocol != null && inboundlinks_urlstub != null && inboundlinks_protocol.size() == inboundlinks_urlstub.size() && inboundlinks_urlstub instanceof List<?>) {\n                    for (int i = 0; i < inboundlinks_protocol.size(); i++) {\n                        String targetURL = inboundlinks_protocol.get(i) + \"://\" + ((String) ((List<?>) inboundlinks_urlstub).get(i));\n                        String referrerhash = id;\n                        String anchorhash = ASCII.String(new DigestURL(targetURL).hash());\n                        if (referrerhash != null && anchorhash != null) {\n                            urlCitationIndex.add(ASCII.getBytes(anchorhash), new CitationReference(ASCII.getBytes(referrerhash), loadDate.getTime()));\n                        }\n                    }\n                }\n            }\n            if (collectionConfig.contains(CollectionSchema.outboundlinks_protocol_sxt) || collectionConfig.contains(CollectionSchema.outboundlinks_urlstub_sxt)) {\n                Collection<Object> outboundlinks_urlstub = vector.getFieldValues(CollectionSchema.outboundlinks_urlstub_sxt.getSolrFieldName());\n                List<String> outboundlinks_protocol = outboundlinks_urlstub == null ? null : CollectionConfiguration.indexedList2protocolList(vector.getFieldValues(CollectionSchema.outboundlinks_protocol_sxt.getSolrFieldName()), outboundlinks_urlstub.size());\n                if (outboundlinks_protocol != null && outboundlinks_urlstub != null && outboundlinks_protocol.size() == outboundlinks_urlstub.size() && outboundlinks_urlstub instanceof List<?>) {\n                    for (int i = 0; i < outboundlinks_protocol.size(); i++) {\n                        String targetURL = outboundlinks_protocol.get(i) + \"://\" + ((String) ((List<?>) outboundlinks_urlstub).get(i));\n                        String referrerhash = id;\n                        String anchorhash = ASCII.String(new DigestURL(targetURL).hash());\n                        if (referrerhash != null && anchorhash != null) {\n                            urlCitationIndex.add(ASCII.getBytes(anchorhash), new CitationReference(ASCII.getBytes(referrerhash), loadDate.getTime()));\n                        }\n                    }\n                }\n            }\n        } catch (Throwable e) {\n            ConcurrentLog.logException(e);\n        }\n        \n        if (error != null) {\n            ConcurrentLog.severe(\"SOLR\", error + \", PLEASE REPORT TO bugs.yacy.net\");\n            //Switchboard.getSwitchboard().pauseCrawlJob(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL, error);\n            //Switchboard.getSwitchboard().pauseCrawlJob(SwitchboardConstants.CRAWLJOB_REMOTE_TRIGGERED_CRAWL, error);\n        }\n        final long storageEndTime = System.currentTimeMillis();\n\n        // STORE PAGE INDEX INTO WORD INDEX DB\n        int outlinksSame = document.inboundLinks().size();\n        int outlinksOther = document.outboundLinks().size();\n        final int urlLength = urlNormalform.length();\n        final int urlComps = MultiProtocolURL.urlComps(url.toNormalform(false)).length;\n\n        // create a word prototype which is re-used for all entries\n        if ((this.termIndex != null && storeToRWI) || searchEvent != null) {\n            final int len = (document == null) ? urlLength : document.dc_title().length();\n            final WordReferenceRow ientry = new WordReferenceRow(\n                            url.hash(),\n                            urlLength, urlComps, len,\n                            condenser.RESULT_NUMB_WORDS,\n                            condenser.RESULT_NUMB_SENTENCES,\n                            modDate.getTime(),\n                            System.currentTimeMillis(),\n                            UTF8.getBytes(language),\n                            docType,\n                            outlinksSame, outlinksOther);\n    \n            // iterate over all words of content text\n            Word wprop = null;\n            byte[] wordhash;\n            String word;\n            for (Map.Entry<String, Word> wentry: condenser.words().entrySet()) {\n                word = wentry.getKey();\n                wprop = wentry.getValue();\n                assert (wprop.flags != null);\n                ientry.setWord(wprop);\n                wordhash = Word.word2hash(word);\n                if (this.termIndex != null && storeToRWI) try {\n                    this.termIndex.add(wordhash, ientry);\n                } catch (final Exception e) {\n                    ConcurrentLog.logException(e);\n                }\n    \n                // during a search event it is possible that a heuristic is used which aquires index\n                // data during search-time. To transfer indexed data directly to the search process\n                // the following lines push the index data additionally to the search process\n                // this is done only for searched words\n                if (searchEvent != null && !searchEvent.query.getQueryGoal().getExcludeHashes().has(wordhash) && searchEvent.query.getQueryGoal().getIncludeHashes().has(wordhash)) {\n                    // if the page was added in the context of a heuristic this shall ensure that findings will fire directly into the search result\n                    ReferenceContainer<WordReference> container;\n                    try {\n                        container = ReferenceContainer.emptyContainer(Segment.wordReferenceFactory, wordhash, 1);\n                        container.add(ientry);\n                        searchEvent.addRWIs(container, true, sourceName, 1, 5000);\n                    } catch (final SpaceExceededException e) {\n                        continue;\n                    }\n                }\n            }\n            if (searchEvent != null) searchEvent.addFinalize();\n    \n            // assign the catchall word\n            ientry.setWord(wprop == null ? catchallWord : wprop); // we use one of the word properties as template to get the document characteristics\n            if (this.termIndex != null) try {this.termIndex.add(catchallHash, ientry);} catch (final Throwable e) {ConcurrentLog.logException(e);}\n        }\n\n        // finish index time\n        final long indexingEndTime = System.currentTimeMillis();\n\n        if (this.log.isInfo()) {\n            this.log.info(\"*Indexed \" + condenser.words().size() + \" words in URL \" + url +\n                    \" [\" + id + \"]\" +\n                    \"\\n\\tDescription:  \" + dc_title +\n                    \"\\n\\tMimeType: \"  + document.dc_format() + \" | Charset: \" + document.getCharset() + \" | \" +\n                    \"Size: \" + document.getTextLength() + \" bytes | \" +\n                    //\"Anchors: \" + refs +\n                    \"\\n\\tLinkStorageTime: \" + (storageEndTime - startTime) + \" ms | \" +\n                    \"indexStorageTime: \" + (indexingEndTime - storageEndTime) + \" ms\");\n        }\n\n        // finished\n        return vector;\n    }","commit_id":"932faafffebfab27708d47afb51cf2a614a040c2","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static boolean store(final SolrInputDocument doc, final boolean loadImage, final boolean replaceOld, final String proxy, final ClientIdentification.Agent agent, final String acceptLanguage) {\n\n        // GET METADATA FROM DOC\n        final String urls = (String) doc.getFieldValue(CollectionSchema.sku.getSolrFieldName());\n        final Date date = (Date) doc.getFieldValue(CollectionSchema.load_date_dt.getSolrFieldName());\n        final int depth = (Integer) doc.getFieldValue(CollectionSchema.crawldepth_i.getSolrFieldName());\n        DigestURL url;\n        try {\n            url = new DigestURL(urls);\n        } catch (MalformedURLException e) {\n            ConcurrentLog.logException(e);\n            return false;\n        }\n        \n        // CLEAN UP OLD DATA (if wanted)\n        Collection<File> oldPaths = Transactions.findPaths(url, depth, null, Transactions.State.INVENTORY);\n        if (replaceOld) {\n            for (File oldPath: oldPaths) oldPath.delete();\n        }\n        \n        \n        // STORE METADATA FOR THE IMAGE\n        File metadataPath = Transactions.definePath(url, depth, date, \"xml\", Transactions.State.INVENTORY);\n        metadataPath.getParentFile().mkdirs();\n        boolean success = true;\n        try {\n            if (doc != null) {\n                FileOutputStream fos = new FileOutputStream(metadataPath);\n                OutputStreamWriter osw = new OutputStreamWriter(fos);\n                osw.write(XML_PREFIX);\n                osw.write(WHITESPACE); osw.write(\"\\n-->\\n\"); // placeholder for transaction information properties (a hack to attach metadata to metadata)\n                osw.write(\"<result name=\\\"response\\\" numFound=\\\"1\\\" start=\\\"0\\\">\\n\");\n                EnhancedXMLResponseWriter.writeDoc(osw, doc);\n                osw.write(\"<\/result>\\n\");\n                osw.write(\"<\/response>\\n\");\n                osw.close();\n                fos.close();\n                Transactions.announceStorage(url, depth, date, State.INVENTORY);\n            }\n        } catch (IOException e) {\n            ConcurrentLog.logException(e);\n            success = false;\n        }\n        \n        // STORE AN IMAGE\n        if (success && loadImage) {\n            final File pdfPath = Transactions.definePath(url, depth, date, \"pdf\", Transactions.State.INVENTORY);\n            if (executorRunning.intValue() < Runtime.getRuntime().availableProcessors()) {\n                Thread t = new Thread(){\n                    @Override\n                    public void run() {\n                        executorRunning.incrementAndGet();\n                        try {\n                            Html2Image.writeWkhtmltopdf(urls, proxy, agent.userAgent, acceptLanguage, pdfPath);\n                        } catch (Throwable e) {} finally {\n                        executorRunning.decrementAndGet();\n                        }\n                    }\n                };\n                executor.execute(t);\n            } else {\n                success = Html2Image.writeWkhtmltopdf(urls, proxy, agent.userAgent, acceptLanguage, pdfPath);\n            }\n        }\n        \n        return success;\n    }","id":91381,"modified_method":"public static boolean store(final SolrInputDocument doc, final boolean concurrency, final boolean loadImage, final boolean replaceOld, final String proxy, final ClientIdentification.Agent agent, final String acceptLanguage) {\n\n        // GET METADATA FROM DOC\n        final String urls = (String) doc.getFieldValue(CollectionSchema.sku.getSolrFieldName());\n        final Date date = (Date) doc.getFieldValue(CollectionSchema.load_date_dt.getSolrFieldName());\n        final int depth = (Integer) doc.getFieldValue(CollectionSchema.crawldepth_i.getSolrFieldName());\n        DigestURL url;\n        try {\n            url = new DigestURL(urls);\n        } catch (MalformedURLException e) {\n            ConcurrentLog.logException(e);\n            return false;\n        }\n        \n        boolean success = loadImage ? store(url, date, depth, concurrency, replaceOld, proxy, agent, acceptLanguage) : true;\n        if (success) {\n            // STORE METADATA FOR THE IMAGE\n            File metadataPath = Transactions.definePath(url, depth, date, \"xml\", Transactions.State.INVENTORY);\n            metadataPath.getParentFile().mkdirs();\n            try {\n                if (doc != null) {\n                    FileOutputStream fos = new FileOutputStream(metadataPath);\n                    OutputStreamWriter osw = new OutputStreamWriter(fos);\n                    osw.write(XML_PREFIX);\n                    osw.write(WHITESPACE); osw.write(\"\\n-->\\n\"); // placeholder for transaction information properties (a hack to attach metadata to metadata)\n                    osw.write(\"<result name=\\\"response\\\" numFound=\\\"1\\\" start=\\\"0\\\">\\n\");\n                    EnhancedXMLResponseWriter.writeDoc(osw, doc);\n                    osw.write(\"<\/result>\\n\");\n                    osw.write(\"<\/response>\\n\");\n                    osw.close();\n                    fos.close();\n                    Transactions.announceStorage(url, depth, date, State.INVENTORY);\n                }\n            } catch (IOException e) {\n                ConcurrentLog.logException(e);\n                success = false;\n            }\n        }\n        \n        return success;\n    }","commit_id":"932faafffebfab27708d47afb51cf2a614a040c2","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static Object respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        final String ext = header.get(\"EXT\", \"\");\n        \n        \n        if (ext.equals(\"rss\")) {\n            // create a report about the content of the snapshot directory\n            if (!authenticated) return null;\n            int maxcount = post == null ? 10 : post.getInt(\"maxcount\", 10);\n            int depthx = post == null ? -1 : post.getInt(\"depth\", -1);\n            Integer depth = depthx == -1 ? null : depthx;\n            String orderx = post == null ? \"ANY\" : post.get(\"order\", \"ANY\");\n            Snapshots.Order order = Snapshots.Order.valueOf(orderx);\n            String statex = post == null ? Transactions.State.INVENTORY.name() : post.get(\"state\", Transactions.State.INVENTORY.name());\n            Transactions.State state = Transactions.State.valueOf(statex);\n            String host = post == null ? null : post.get(\"host\");\n            Map<String, Revisions> iddate = Transactions.select(host, depth, order, maxcount, state);\n            // now select the URL from the index for these ids in iddate and make an RSS feed\n            RSSFeed rssfeed = new RSSFeed(Integer.MAX_VALUE);\n            rssfeed.setChannel(new RSSMessage(\"Snapshot list for host = \" + host + \", depth = \" + depth + \", order = \" + order + \", maxcount = \" + maxcount, \"\", \"\"));\n            for (Map.Entry<String, Revisions> e: iddate.entrySet()) {\n                try {\n                    DigestURL u = e.getValue().url == null ? sb.index.fulltext().getURL(e.getKey()) : new DigestURL(e.getValue().url);\n                    if (u == null) continue;\n                    RSSMessage message = new RSSMessage(u.toNormalform(true), \"\", u, e.getKey());\n                    message.setPubDate(e.getValue().dates[0]);\n                    rssfeed.addMessage(message);\n                } catch (IOException ee) {\n                    ConcurrentLog.logException(ee);\n                }\n            }\n            byte[] rssBinary = UTF8.getBytes(rssfeed.toString());\n            return new ByteArrayInputStream(rssBinary);\n        }\n\n        // for the following methods we (mostly) need an url or a url hash\n        if (post == null) return null;\n        final boolean xml = ext.equals(\"xml\");\n        final boolean pdf = ext.equals(\"pdf\");\n        if (pdf && !authenticated) return null;\n        final boolean pngjpg = ext.equals(\"png\") || ext.equals(\"jpg\");\n        String urlhash = post.get(\"urlhash\", \"\");\n        String url = post.get(\"url\", \"\");\n        DigestURL durl = null;\n        if (urlhash.length() == 0 && url.length() > 0) {\n            try {\n                durl = new DigestURL(url);\n                urlhash = ASCII.String(durl.hash());\n            } catch (MalformedURLException e) {\n            }\n        }\n        if (durl == null && urlhash.length() > 0) {\n            try {\n                durl = sb.index.fulltext().getURL(urlhash);\n            } catch (IOException e) {\n                ConcurrentLog.logException(e);\n            }\n        }\n        if (url.length() == 0 && durl != null) url = durl.toNormalform(true);\n\n        if (ext.equals(\"json\")) {\n            // command interface: view and change a transaction state, get metadata about transactions in the past\n            String command = post.get(\"command\", \"metadata\");\n            String statename = post.get(\"state\");\n            JSONObject result = new JSONObject();\n            try {\n                if (command.equals(\"status\")) {\n                    // return a status of the transaction archive\n                    JSONObject sizes = new JSONObject();\n                    for (Map.Entry<String, Integer> state: Transactions.sizes().entrySet()) sizes.put(state.getKey(), state.getValue());\n                    result.put(\"size\", sizes);\n                } else if (command.equals(\"list\")) {\n                    if (!authenticated) return null;\n                    // return a status of the transaction archive\n                    String host = post.get(\"host\");\n                    String depth = post.get(\"depth\");\n                    int depthi = depth == null ? -1 : Integer.parseInt(depth);\n                    for (Transactions.State state: statename == null ?\n                            new Transactions.State[]{Transactions.State.INVENTORY, Transactions.State.ARCHIVE} :\n                            new Transactions.State[]{Transactions.State.valueOf(statename)}) {\n                        if (host == null) {\n                            JSONObject hostCountInventory = new JSONObject();\n                            for (String h: Transactions.listHosts(state)) {\n                                int size = Transactions.listIDsSize(h, depthi, state);\n                                if (size > 0) hostCountInventory.put(h, size);\n                            }\n                            result.put(\"count.\" + state.name(), hostCountInventory);\n                        } else {\n                            TreeMap<Integer, Collection<Revisions>> ids = Transactions.listIDs(host, depthi, state);\n                            if (ids == null) {\n                                result.put(\"result\", \"fail\");\n                                result.put(\"comment\", \"no entries for host \" + host + \" found\");\n                            } else {\n                                for (Map.Entry<Integer, Collection<Revisions>> entry: ids.entrySet()) {\n                                    for (Revisions r: entry.getValue()) {\n                                        try {\n                                            JSONObject metadata = new JSONObject();\n                                            DigestURL u = r.url != null ? new DigestURL(r.url) : sb.index.fulltext().getURL(r.urlhash);\n                                            metadata.put(\"url\", u == null ? \"unknown\" : u.toNormalform(true));\n                                            metadata.put(\"dates\", r.dates);\n                                            assert r.depth == entry.getKey().intValue();\n                                            metadata.put(\"depth\", entry.getKey().intValue());\n                                            result.put(r.urlhash, metadata);\n                                        } catch (IOException e) {}\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else if (command.equals(\"commit\")) {\n                    if (!authenticated) return null;\n                    Revisions r = Transactions.commit(urlhash);\n                    if (r != null) {\n                        result.put(\"result\", \"success\");\n                        result.put(\"depth\", r.depth);\n                        result.put(\"url\", r.url);\n                        result.put(\"dates\", r.dates);\n                    } else {\n                        result.put(\"result\", \"fail\");\n                    }\n                    result.put(\"urlhash\", urlhash);\n                } else if (command.equals(\"rollback\")) {\n                    if (!authenticated) return null;\n                    Revisions r = Transactions.rollback(urlhash);\n                    if (r != null) {\n                        result.put(\"result\", \"success\");\n                        result.put(\"depth\", r.depth);\n                        result.put(\"url\", r.url);\n                        result.put(\"dates\", r.dates);\n                    } else {\n                        result.put(\"result\", \"fail\");\n                    }\n                    result.put(\"urlhash\", urlhash);\n                } else if (command.equals(\"metadata\")) {\n                    try {\n                        Revisions r;\n                        Transactions.State state = statename == null || statename.length() == 0 ? null : Transactions.State.valueOf(statename);\n                        if (state == null) {\n                            r = Transactions.getRevisions(Transactions.State.INVENTORY, urlhash);\n                            if (r != null) state = Transactions.State.INVENTORY;\n                            r = Transactions.getRevisions(Transactions.State.ARCHIVE, urlhash);\n                            if (r != null) state = Transactions.State.ARCHIVE;\n                        } else {\n                            r = Transactions.getRevisions(state, urlhash);\n                        }\n                        if (r != null) {\n                            JSONObject metadata = new JSONObject();\n                            DigestURL u;\n                            u = r.url != null ? new DigestURL(r.url) : sb.index.fulltext().getURL(r.urlhash);\n                            metadata.put(\"url\", u == null ? \"unknown\" : u.toNormalform(true));\n                            metadata.put(\"dates\", r.dates);\n                            metadata.put(\"depth\", r.depth);\n                            metadata.put(\"state\", state.name());\n                            result.put(r.urlhash, metadata);\n                        }\n                    } catch (IOException |IllegalArgumentException e) {}\n                }\n            } catch (JSONException e) {\n                ConcurrentLog.logException(e);\n            }\n            String json = result.toString();\n            if (post.containsKey(\"callback\")) json = post.get(\"callback\") + \"([\" + json + \"]);\";\n            return new ByteArrayInputStream(UTF8.getBytes(json));\n        }\n        \n        // for the following methods we always need the durl to fetch data\n        if (durl == null) return null;\n        \n        if (xml) {\n            Collection<File> xmlSnapshots = Transactions.findPaths(durl, \"xml\", Transactions.State.ANY);\n            File xmlFile = null;\n            if (xmlSnapshots.size() == 0) {\n                return null;\n            }\n            xmlFile = xmlSnapshots.iterator().next();\n            try {\n                byte[] xmlBinary = FileUtils.read(xmlFile);\n                return new ByteArrayInputStream(xmlBinary);\n            } catch (IOException e) {\n                ConcurrentLog.logException(e);\n                return null;\n            }\n        }\n        \n        if (pdf || pngjpg) {\n            Collection<File> pdfSnapshots = Transactions.findPaths(durl, \"pdf\", Transactions.State.ANY);\n            File pdfFile = null;\n            if (pdfSnapshots.size() == 0) {\n                // if the client is authenticated, we create the pdf on the fly!\n                if (!authenticated) return null;\n                SolrDocument sd = sb.index.fulltext().getMetadata(durl.hash());\n                SolrInputDocument sid = sb.index.fulltext().getDefaultConfiguration().toSolrInputDocument(sd);\n                boolean success = Transactions.store(sid, true, true, sb.getConfigBool(\"isTransparentProxy\", false) ? \"http://127.0.0.1:\" + sb.getConfigInt(\"port\", 8090) : null, ClientIdentification.yacyProxyAgent, sb.getConfig(\"crawler.http.acceptLanguage\", null));\n                if (success) {\n                    pdfSnapshots = Transactions.findPaths(durl, \"pdf\", Transactions.State.INVENTORY);\n                    if (pdfSnapshots.size() != 0) pdfFile = pdfSnapshots.iterator().next();\n                }\n            } else {\n                pdfFile = pdfSnapshots.iterator().next();\n            }\n            if (pdfFile == null) return null;\n            if (pdf) {\n                try {\n                    byte[] pdfBinary = FileUtils.read(pdfFile);\n                    return new ByteArrayInputStream(pdfBinary);\n                } catch (IOException e) {\n                    ConcurrentLog.logException(e);\n                    return null;\n                }\n            }\n            \n            if (pngjpg) {\n                int width = Math.min(post.getInt(\"width\", DEFAULT_WIDTH), DEFAULT_WIDTH);\n                int height = Math.min(post.getInt(\"height\", DEFAULT_HEIGHT), DEFAULT_HEIGHT);\n                String imageFileStub = pdfFile.getAbsolutePath(); imageFileStub = imageFileStub.substring(0, imageFileStub.length() - 3); // cut off extension\n                File imageFile = new File(imageFileStub + DEFAULT_WIDTH + \".\" + DEFAULT_HEIGHT + \".\" + DEFAULT_EXT);\n                if (!imageFile.exists() && authenticated) {\n                    Html2Image.pdf2image(pdfFile, imageFile, DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_DENSITY, DEFAULT_QUALITY);\n                }\n                if (!imageFile.exists()) return null;\n                if (width == DEFAULT_WIDTH && height == DEFAULT_HEIGHT) {\n                    try {\n                        byte[] imageBinary = FileUtils.read(imageFile);\n                        return new ByteArrayInputStream(imageBinary);\n                    } catch (IOException e) {\n                        ConcurrentLog.logException(e);\n                        return null;\n                    }\n                }\n                // lets read the file and scale\n                Image image;\n                try {\n                    image = ImageParser.parse(imageFile.getAbsolutePath(), FileUtils.read(imageFile));\n                    final Image scaled = image.getScaledInstance(width, height, Image.SCALE_AREA_AVERAGING);\n                    final MediaTracker mediaTracker = new MediaTracker(new Container());\n                    mediaTracker.addImage(scaled, 0);\n                    try {mediaTracker.waitForID(0);} catch (final InterruptedException e) {}\n                    return scaled;\n                } catch (IOException e) {\n                    ConcurrentLog.logException(e);\n                    return null;\n                }\n    \n            }\n        }\n        \n        return null;\n    }","id":91382,"modified_method":"public static Object respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        final String ext = header.get(\"EXT\", \"\");\n        \n        \n        if (ext.equals(\"rss\")) {\n            // create a report about the content of the snapshot directory\n            if (!authenticated) return null;\n            int maxcount = post == null ? 10 : post.getInt(\"maxcount\", 10);\n            int depthx = post == null ? -1 : post.getInt(\"depth\", -1);\n            Integer depth = depthx == -1 ? null : depthx;\n            String orderx = post == null ? \"ANY\" : post.get(\"order\", \"ANY\");\n            Snapshots.Order order = Snapshots.Order.valueOf(orderx);\n            String statex = post == null ? Transactions.State.INVENTORY.name() : post.get(\"state\", Transactions.State.INVENTORY.name());\n            Transactions.State state = Transactions.State.valueOf(statex);\n            String host = post == null ? null : post.get(\"host\");\n            Map<String, Revisions> iddate = Transactions.select(host, depth, order, maxcount, state);\n            // now select the URL from the index for these ids in iddate and make an RSS feed\n            RSSFeed rssfeed = new RSSFeed(Integer.MAX_VALUE);\n            rssfeed.setChannel(new RSSMessage(\"Snapshot list for host = \" + host + \", depth = \" + depth + \", order = \" + order + \", maxcount = \" + maxcount, \"\", \"\"));\n            for (Map.Entry<String, Revisions> e: iddate.entrySet()) {\n                try {\n                    DigestURL u = e.getValue().url == null ? sb.index.fulltext().getURL(e.getKey()) : new DigestURL(e.getValue().url);\n                    if (u == null) continue;\n                    RSSMessage message = new RSSMessage(u.toNormalform(true), \"\", u, e.getKey());\n                    message.setPubDate(e.getValue().dates[0]);\n                    rssfeed.addMessage(message);\n                } catch (IOException ee) {\n                    ConcurrentLog.logException(ee);\n                }\n            }\n            byte[] rssBinary = UTF8.getBytes(rssfeed.toString());\n            return new ByteArrayInputStream(rssBinary);\n        }\n\n        // for the following methods we (mostly) need an url or a url hash\n        if (post == null) return null;\n        final boolean xml = ext.equals(\"xml\");\n        final boolean pdf = ext.equals(\"pdf\");\n        if (pdf && !authenticated) return null;\n        final boolean pngjpg = ext.equals(\"png\") || ext.equals(\"jpg\");\n        String urlhash = post.get(\"urlhash\", \"\");\n        String url = post.get(\"url\", \"\");\n        DigestURL durl = null;\n        if (urlhash.length() == 0 && url.length() > 0) {\n            try {\n                durl = new DigestURL(url);\n                urlhash = ASCII.String(durl.hash());\n            } catch (MalformedURLException e) {\n            }\n        }\n        if (durl == null && urlhash.length() > 0) {\n            try {\n                durl = sb.index.fulltext().getURL(urlhash);\n            } catch (IOException e) {\n                ConcurrentLog.logException(e);\n            }\n        }\n        if (url.length() == 0 && durl != null) url = durl.toNormalform(true);\n\n        if (ext.equals(\"json\")) {\n            // command interface: view and change a transaction state, get metadata about transactions in the past\n            String command = post.get(\"command\", \"metadata\");\n            String statename = post.get(\"state\");\n            JSONObject result = new JSONObject();\n            try {\n                if (command.equals(\"status\")) {\n                    // return a status of the transaction archive\n                    JSONObject sizes = new JSONObject();\n                    for (Map.Entry<String, Integer> state: Transactions.sizes().entrySet()) sizes.put(state.getKey(), state.getValue());\n                    result.put(\"size\", sizes);\n                } else if (command.equals(\"list\")) {\n                    if (!authenticated) return null;\n                    // return a status of the transaction archive\n                    String host = post.get(\"host\");\n                    String depth = post.get(\"depth\");\n                    int depthi = depth == null ? -1 : Integer.parseInt(depth);\n                    for (Transactions.State state: statename == null ?\n                            new Transactions.State[]{Transactions.State.INVENTORY, Transactions.State.ARCHIVE} :\n                            new Transactions.State[]{Transactions.State.valueOf(statename)}) {\n                        if (host == null) {\n                            JSONObject hostCountInventory = new JSONObject();\n                            for (String h: Transactions.listHosts(state)) {\n                                int size = Transactions.listIDsSize(h, depthi, state);\n                                if (size > 0) hostCountInventory.put(h, size);\n                            }\n                            result.put(\"count.\" + state.name(), hostCountInventory);\n                        } else {\n                            TreeMap<Integer, Collection<Revisions>> ids = Transactions.listIDs(host, depthi, state);\n                            if (ids == null) {\n                                result.put(\"result\", \"fail\");\n                                result.put(\"comment\", \"no entries for host \" + host + \" found\");\n                            } else {\n                                for (Map.Entry<Integer, Collection<Revisions>> entry: ids.entrySet()) {\n                                    for (Revisions r: entry.getValue()) {\n                                        try {\n                                            JSONObject metadata = new JSONObject();\n                                            DigestURL u = r.url != null ? new DigestURL(r.url) : sb.index.fulltext().getURL(r.urlhash);\n                                            metadata.put(\"url\", u == null ? \"unknown\" : u.toNormalform(true));\n                                            metadata.put(\"dates\", r.dates);\n                                            assert r.depth == entry.getKey().intValue();\n                                            metadata.put(\"depth\", entry.getKey().intValue());\n                                            result.put(r.urlhash, metadata);\n                                        } catch (IOException e) {}\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else if (command.equals(\"commit\")) {\n                    if (!authenticated) return null;\n                    Revisions r = Transactions.commit(urlhash);\n                    if (r != null) {\n                        result.put(\"result\", \"success\");\n                        result.put(\"depth\", r.depth);\n                        result.put(\"url\", r.url);\n                        result.put(\"dates\", r.dates);\n                    } else {\n                        result.put(\"result\", \"fail\");\n                    }\n                    result.put(\"urlhash\", urlhash);\n                } else if (command.equals(\"rollback\")) {\n                    if (!authenticated) return null;\n                    Revisions r = Transactions.rollback(urlhash);\n                    if (r != null) {\n                        result.put(\"result\", \"success\");\n                        result.put(\"depth\", r.depth);\n                        result.put(\"url\", r.url);\n                        result.put(\"dates\", r.dates);\n                    } else {\n                        result.put(\"result\", \"fail\");\n                    }\n                    result.put(\"urlhash\", urlhash);\n                } else if (command.equals(\"metadata\")) {\n                    try {\n                        Revisions r;\n                        Transactions.State state = statename == null || statename.length() == 0 ? null : Transactions.State.valueOf(statename);\n                        if (state == null) {\n                            r = Transactions.getRevisions(Transactions.State.INVENTORY, urlhash);\n                            if (r != null) state = Transactions.State.INVENTORY;\n                            r = Transactions.getRevisions(Transactions.State.ARCHIVE, urlhash);\n                            if (r != null) state = Transactions.State.ARCHIVE;\n                        } else {\n                            r = Transactions.getRevisions(state, urlhash);\n                        }\n                        if (r != null) {\n                            JSONObject metadata = new JSONObject();\n                            DigestURL u;\n                            u = r.url != null ? new DigestURL(r.url) : sb.index.fulltext().getURL(r.urlhash);\n                            metadata.put(\"url\", u == null ? \"unknown\" : u.toNormalform(true));\n                            metadata.put(\"dates\", r.dates);\n                            metadata.put(\"depth\", r.depth);\n                            metadata.put(\"state\", state.name());\n                            result.put(r.urlhash, metadata);\n                        }\n                    } catch (IOException |IllegalArgumentException e) {}\n                }\n            } catch (JSONException e) {\n                ConcurrentLog.logException(e);\n            }\n            String json = result.toString();\n            if (post.containsKey(\"callback\")) json = post.get(\"callback\") + \"([\" + json + \"]);\";\n            return new ByteArrayInputStream(UTF8.getBytes(json));\n        }\n        \n        // for the following methods we always need the durl to fetch data\n        if (durl == null) return null;\n        \n        if (xml) {\n            Collection<File> xmlSnapshots = Transactions.findPaths(durl, \"xml\", Transactions.State.ANY);\n            File xmlFile = null;\n            if (xmlSnapshots.size() == 0) {\n                return null;\n            }\n            xmlFile = xmlSnapshots.iterator().next();\n            try {\n                byte[] xmlBinary = FileUtils.read(xmlFile);\n                return new ByteArrayInputStream(xmlBinary);\n            } catch (IOException e) {\n                ConcurrentLog.logException(e);\n                return null;\n            }\n        }\n        \n        if (pdf || pngjpg) {\n            Collection<File> pdfSnapshots = Transactions.findPaths(durl, \"pdf\", Transactions.State.INVENTORY);\n            File pdfFile = null;\n            if (pdfSnapshots.size() == 0) {\n                // if the client is authenticated, we create the pdf on the fly!\n                if (!authenticated) return null;\n                SolrDocument sd = sb.index.fulltext().getMetadata(durl.hash());\n                boolean success = false;\n                if (sd == null) {\n                    success = Transactions.store(durl, new Date(), 99, false, true, sb.getConfigBool(\"isTransparentProxy\", false) ? \"http://127.0.0.1:\" + sb.getConfigInt(\"port\", 8090) : null, ClientIdentification.yacyProxyAgent, sb.getConfig(\"crawler.http.acceptLanguage\", null));\n                } else {\n                    SolrInputDocument sid = sb.index.fulltext().getDefaultConfiguration().toSolrInputDocument(sd);\n                    success = Transactions.store(sid, false, true, true, sb.getConfigBool(\"isTransparentProxy\", false) ? \"http://127.0.0.1:\" + sb.getConfigInt(\"port\", 8090) : null, ClientIdentification.yacyProxyAgent, sb.getConfig(\"crawler.http.acceptLanguage\", null));\n                }\n                if (success) {\n                    pdfSnapshots = Transactions.findPaths(durl, \"pdf\", Transactions.State.ANY);\n                    if (pdfSnapshots.size() != 0) pdfFile = pdfSnapshots.iterator().next();\n                }\n            } else {\n                pdfFile = pdfSnapshots.iterator().next();\n            }\n            if (pdfFile == null) return null;\n            if (pdf) {\n                try {\n                    byte[] pdfBinary = FileUtils.read(pdfFile);\n                    return new ByteArrayInputStream(pdfBinary);\n                } catch (IOException e) {\n                    ConcurrentLog.logException(e);\n                    return null;\n                }\n            }\n            \n            if (pngjpg) {\n                int width = Math.min(post.getInt(\"width\", DEFAULT_WIDTH), DEFAULT_WIDTH);\n                int height = Math.min(post.getInt(\"height\", DEFAULT_HEIGHT), DEFAULT_HEIGHT);\n                String imageFileStub = pdfFile.getAbsolutePath(); imageFileStub = imageFileStub.substring(0, imageFileStub.length() - 3); // cut off extension\n                File imageFile = new File(imageFileStub + DEFAULT_WIDTH + \".\" + DEFAULT_HEIGHT + \".\" + DEFAULT_EXT);\n                if (!imageFile.exists() && authenticated) {\n                    Html2Image.pdf2image(pdfFile, imageFile, DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_DENSITY, DEFAULT_QUALITY);\n                }\n                if (!imageFile.exists()) return null;\n                if (width == DEFAULT_WIDTH && height == DEFAULT_HEIGHT) {\n                    try {\n                        byte[] imageBinary = FileUtils.read(imageFile);\n                        return new ByteArrayInputStream(imageBinary);\n                    } catch (IOException e) {\n                        ConcurrentLog.logException(e);\n                        return null;\n                    }\n                }\n                // lets read the file and scale\n                Image image;\n                try {\n                    image = ImageParser.parse(imageFile.getAbsolutePath(), FileUtils.read(imageFile));\n                    final Image scaled = image.getScaledInstance(width, height, Image.SCALE_AREA_AVERAGING);\n                    final MediaTracker mediaTracker = new MediaTracker(new Container());\n                    mediaTracker.addImage(scaled, 0);\n                    try {mediaTracker.waitForID(0);} catch (final InterruptedException e) {}\n                    return scaled;\n                } catch (IOException e) {\n                    ConcurrentLog.logException(e);\n                    return null;\n                }\n    \n            }\n        }\n        \n        return null;\n    }","commit_id":"932faafffebfab27708d47afb51cf2a614a040c2","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n\t * Change the PhysicalPosition of the logical record iPosition.\r\n\t * \r\n\t * @throws IOException\r\n\t */\r\n\tpublic void setPhysicalPosition(long iPosition, final int iDataId, final long iDataPosition, final byte iRecordType)\r\n\t\t\tthrows IOException {\r\n\t\tiPosition = iPosition * RECORD_SIZE;\r\n\r\n\t\ttry {\r\n\t\t\tacquireExclusiveLock();\r\n\r\n\t\t\tint[] pos = getRelativePosition(iPosition);\r\n\r\n\t\t\tint p = pos[1];\r\n\r\n\t\t\tfiles[pos[0]].writeShort(p, (short) iDataId);\r\n\t\t\tfiles[pos[0]].writeLong(p += OConstants.SIZE_SHORT, iDataPosition);\r\n\t\t\tfiles[pos[0]].writeByte(p += OConstants.SIZE_LONG, iRecordType);\r\n\r\n\t\t} finally {\r\n\t\t\treleaseExclusiveLock();\r\n\t\t}\r\n\t}","id":91383,"modified_method":"/**\r\n\t * Change the PhysicalPosition of the logical record iPosition.\r\n\t * \r\n\t * @throws IOException\r\n\t */\r\n\tpublic void setPhysicalPosition(long iPosition, final int iDataId, final long iDataPosition, final byte iRecordType) throws IOException {\r\n\t\tiPosition = iPosition * RECORD_SIZE;\r\n\r\n\t\ttry {\r\n\t\t\tacquireExclusiveLock();\r\n\r\n\t\t\tfinal int[] pos = getRelativePosition(iPosition);\r\n\r\n\t\t\tint p = pos[1];\r\n\r\n\t\t\tfiles[pos[0]].writeShort(p, (short) iDataId);\r\n\t\t\tfiles[pos[0]].writeLong(p += OConstants.SIZE_SHORT, iDataPosition);\r\n\t\t\tfiles[pos[0]].writeByte(p += OConstants.SIZE_LONG, iRecordType);\r\n\r\n\t\t} finally {\r\n\t\t\treleaseExclusiveLock();\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Fill and return the PhysicalPosition object received as parameter with the physical position of logical record iPosition\r\n\t * \r\n\t * @throws IOException\r\n\t */\r\n\tpublic OPhysicalPosition getPhysicalPosition(long iPosition, final OPhysicalPosition iPPosition) throws IOException {\r\n\t\tiPosition = iPosition * RECORD_SIZE;\r\n\r\n\t\ttry {\r\n\t\t\tacquireSharedLock();\r\n\r\n\t\t\tint[] pos = getRelativePosition(iPosition);\r\n\r\n\t\t\tint p = pos[1];\r\n\r\n\t\t\tiPPosition.dataSegment = files[pos[0]].readShort(p);\r\n\t\t\tiPPosition.dataPosition = files[pos[0]].readLong(p += OConstants.SIZE_SHORT);\r\n\t\t\tiPPosition.type = files[pos[0]].readByte(p += OConstants.SIZE_LONG);\r\n\t\t\tiPPosition.version = files[pos[0]].readInt(p += OConstants.SIZE_BYTE);\r\n\t\t\treturn iPPosition;\r\n\r\n\t\t} finally {\r\n\t\t\treleaseSharedLock();\r\n\t\t}\r\n\t}","id":91384,"modified_method":"/**\r\n\t * Fill and return the PhysicalPosition object received as parameter with the physical position of logical record iPosition\r\n\t * \r\n\t * @throws IOException\r\n\t */\r\n\tpublic OPhysicalPosition getPhysicalPosition(long iPosition, final OPhysicalPosition iPPosition) throws IOException {\r\n\t\tiPosition = iPosition * RECORD_SIZE;\r\n\r\n\t\ttry {\r\n\t\t\tacquireSharedLock();\r\n\r\n\t\t\tfinal int[] pos = getRelativePosition(iPosition);\r\n\r\n\t\t\tint p = pos[1];\r\n\r\n\t\t\tiPPosition.dataSegment = files[pos[0]].readShort(p);\r\n\t\t\tiPPosition.dataPosition = files[pos[0]].readLong(p += OConstants.SIZE_SHORT);\r\n\t\t\tiPPosition.type = files[pos[0]].readByte(p += OConstants.SIZE_LONG);\r\n\t\t\tiPPosition.version = files[pos[0]].readInt(p += OConstants.SIZE_BYTE);\r\n\t\t\treturn iPPosition;\r\n\r\n\t\t} finally {\r\n\t\t\treleaseSharedLock();\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Remove the Logical position entry. Add to the hole segment and change the version to -1.\r\n\t * \r\n\t * @throws IOException\r\n\t */\r\n\tpublic void removePhysicalPosition(long iPosition, final OPhysicalPosition iPPosition) throws IOException {\r\n\t\tfinal long position = iPosition * RECORD_SIZE;\r\n\t\ttry {\r\n\t\t\tacquireExclusiveLock();\r\n\r\n\t\t\tint[] pos = getRelativePosition(position);\r\n\t\t\tOFile file = files[pos[0]];\r\n\t\t\tint p = pos[1];\r\n\r\n\t\t\t// SAVE THE OLD DATA AND RETRIEVE THEM TO THE CALLER\r\n\t\t\tiPPosition.dataSegment = file.readShort(p);\r\n\t\t\tiPPosition.dataPosition = file.readLong(p += OConstants.SIZE_SHORT);\r\n\t\t\tiPPosition.type = file.readByte(p += OConstants.SIZE_LONG);\r\n\t\t\tiPPosition.version = file.readInt(p += OConstants.SIZE_BYTE);\r\n\r\n\t\t\tholeSegment.pushPosition(position);\r\n\r\n\t\t\t// SET VERSION = -1\r\n\t\t\tfile.writeInt(p, -1);\r\n\r\n\t\t\tif (iPosition == beginOffsetData) {\r\n\t\t\t\tif (getEntries() == 0)\r\n\t\t\t\t\tbeginOffsetData = -1;\r\n\t\t\t\telse {\r\n\t\t\t\t\t// DISCOVER THE BEGIN OF DATA\r\n\t\t\t\t\tbeginOffsetData++;\r\n\r\n\t\t\t\t\tint[] fetchPos;\r\n\t\t\t\t\tfor (long currentPos = position + RECORD_SIZE; currentPos < getFilledUpTo(); currentPos += RECORD_SIZE) {\r\n\t\t\t\t\t\tfetchPos = getRelativePosition(currentPos);\r\n\r\n\t\t\t\t\t\tif (files[fetchPos[0]].readShort(fetchPos[1]) != -1)\r\n\t\t\t\t\t\t\t// GOOD RECORD: SET IT AS BEGIN\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tbeginOffsetData++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfiles[0].writeHeaderLong(0, beginOffsetData);\r\n\t\t\t}\r\n\r\n\t\t\tif (iPosition == endOffsetData) {\r\n\t\t\t\tif (getEntries() == 0)\r\n\t\t\t\t\tendOffsetData = -1;\r\n\t\t\t\telse {\r\n\t\t\t\t\t// DISCOVER THE END OF DATA\r\n\t\t\t\t\tendOffsetData--;\r\n\r\n\t\t\t\t\tint[] fetchPos;\r\n\t\t\t\t\tfor (long currentPos = position - RECORD_SIZE; currentPos >= beginOffsetData; currentPos -= RECORD_SIZE) {\r\n\r\n\t\t\t\t\t\tfetchPos = getRelativePosition(currentPos);\r\n\r\n\t\t\t\t\t\tif (files[fetchPos[0]].readShort(fetchPos[1]) != -1)\r\n\t\t\t\t\t\t\t// GOOD RECORD: SET IT AS BEGIN\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tendOffsetData--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfiles[0].writeHeaderLong(OConstants.SIZE_LONG, endOffsetData);\r\n\t\t\t}\r\n\r\n\t\t} finally {\r\n\t\t\treleaseExclusiveLock();\r\n\t\t}\r\n\t}","id":91385,"modified_method":"/**\r\n\t * Remove the Logical position entry. Add to the hole segment and change the version to -1.\r\n\t * \r\n\t * @throws IOException\r\n\t */\r\n\tpublic void removePhysicalPosition(long iPosition, final OPhysicalPosition iPPosition) throws IOException {\r\n\t\tfinal long position = iPosition * RECORD_SIZE;\r\n\t\ttry {\r\n\t\t\tacquireExclusiveLock();\r\n\r\n\t\t\tfinal int[] pos = getRelativePosition(position);\r\n\t\t\tOFile file = files[pos[0]];\r\n\t\t\tint p = pos[1];\r\n\r\n\t\t\t// SAVE THE OLD DATA AND RETRIEVE THEM TO THE CALLER\r\n\t\t\tiPPosition.dataSegment = file.readShort(p);\r\n\t\t\tiPPosition.dataPosition = file.readLong(p += OConstants.SIZE_SHORT);\r\n\t\t\tiPPosition.type = file.readByte(p += OConstants.SIZE_LONG);\r\n\t\t\tiPPosition.version = file.readInt(p += OConstants.SIZE_BYTE);\r\n\r\n\t\t\tholeSegment.pushPosition(position);\r\n\r\n\t\t\t// SET VERSION = -1\r\n\t\t\tfile.writeInt(p, -1);\r\n\r\n\t\t\tif (iPosition == beginOffsetData) {\r\n\t\t\t\tif (getEntries() == 0)\r\n\t\t\t\t\tbeginOffsetData = -1;\r\n\t\t\t\telse {\r\n\t\t\t\t\t// DISCOVER THE BEGIN OF DATA\r\n\t\t\t\t\tbeginOffsetData++;\r\n\r\n\t\t\t\t\tint[] fetchPos;\r\n\t\t\t\t\tfor (long currentPos = position + RECORD_SIZE; currentPos < getFilledUpTo(); currentPos += RECORD_SIZE) {\r\n\t\t\t\t\t\tfetchPos = getRelativePosition(currentPos);\r\n\r\n\t\t\t\t\t\tif (files[fetchPos[0]].readShort(fetchPos[1]) != -1)\r\n\t\t\t\t\t\t\t// GOOD RECORD: SET IT AS BEGIN\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tbeginOffsetData++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfiles[0].writeHeaderLong(0, beginOffsetData);\r\n\t\t\t}\r\n\r\n\t\t\tif (iPosition == endOffsetData) {\r\n\t\t\t\tif (getEntries() == 0)\r\n\t\t\t\t\tendOffsetData = -1;\r\n\t\t\t\telse {\r\n\t\t\t\t\t// DISCOVER THE END OF DATA\r\n\t\t\t\t\tendOffsetData--;\r\n\r\n\t\t\t\t\tint[] fetchPos;\r\n\t\t\t\t\tfor (long currentPos = position - RECORD_SIZE; currentPos >= beginOffsetData; currentPos -= RECORD_SIZE) {\r\n\r\n\t\t\t\t\t\tfetchPos = getRelativePosition(currentPos);\r\n\r\n\t\t\t\t\t\tif (files[fetchPos[0]].readShort(fetchPos[1]) != -1)\r\n\t\t\t\t\t\t\t// GOOD RECORD: SET IT AS BEGIN\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tendOffsetData--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfiles[0].writeHeaderLong(OConstants.SIZE_LONG, endOffsetData);\r\n\t\t\t}\r\n\r\n\t\t} finally {\r\n\t\t\treleaseExclusiveLock();\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void updateVersion(long iPosition, final int iVersion) throws IOException {\r\n\t\tiPosition = iPosition * RECORD_SIZE;\r\n\r\n\t\ttry {\r\n\t\t\tacquireExclusiveLock();\r\n\r\n\t\t\tint[] pos = getRelativePosition(iPosition);\r\n\r\n\t\t\tfiles[pos[0]].writeInt(pos[1] + OConstants.SIZE_SHORT + OConstants.SIZE_LONG + OConstants.SIZE_BYTE, iVersion);\r\n\r\n\t\t} finally {\r\n\t\t\treleaseExclusiveLock();\r\n\t\t}\r\n\t}","id":91386,"modified_method":"public void updateVersion(long iPosition, final int iVersion) throws IOException {\r\n\t\tiPosition = iPosition * RECORD_SIZE;\r\n\r\n\t\ttry {\r\n\t\t\tacquireExclusiveLock();\r\n\r\n\t\t\tfinal int[] pos = getRelativePosition(iPosition);\r\n\r\n\t\t\tfiles[pos[0]].writeInt(pos[1] + OConstants.SIZE_SHORT + OConstants.SIZE_LONG + OConstants.SIZE_BYTE, iVersion);\r\n\r\n\t\t} finally {\r\n\t\t\treleaseExclusiveLock();\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void updateRecordType(long iPosition, final byte iRecordType) throws IOException {\r\n\t\tiPosition = iPosition * RECORD_SIZE;\r\n\r\n\t\ttry {\r\n\t\t\tacquireExclusiveLock();\r\n\r\n\t\t\tint[] pos = getRelativePosition(iPosition);\r\n\r\n\t\t\tfiles[pos[0]].writeByte(pos[1] + OConstants.SIZE_SHORT + OConstants.SIZE_LONG, iRecordType);\r\n\r\n\t\t} finally {\r\n\t\t\treleaseExclusiveLock();\r\n\t\t}\r\n\t}","id":91387,"modified_method":"public void updateRecordType(long iPosition, final byte iRecordType) throws IOException {\r\n\t\tiPosition = iPosition * RECORD_SIZE;\r\n\r\n\t\ttry {\r\n\t\t\tacquireExclusiveLock();\r\n\r\n\t\t\tfinal int[] pos = getRelativePosition(iPosition);\r\n\r\n\t\t\tfiles[pos[0]].writeByte(pos[1] + OConstants.SIZE_SHORT + OConstants.SIZE_LONG, iRecordType);\r\n\r\n\t\t} finally {\r\n\t\t\treleaseExclusiveLock();\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic short readShort(int iOffset) {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_SHORT);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_SHORT, OPERATION_TYPE.READ);\r\n\t\treturn entry.buffer.getShort(iOffset - entry.beginOffset);\r\n\t}","id":91388,"modified_method":"@Override\r\n\tpublic short readShort(int iOffset) throws IOException {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_SHORT);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_SHORT, OPERATION_TYPE.READ);\r\n\t\tif (entry != null) {\r\n\t\t\t// MMAP READ\r\n\t\t\treturn entry.buffer.getShort(iOffset - entry.beginOffset);\r\n\t\t} else {\r\n\t\t\t// DIRECT READ\r\n\t\t\tfinal ByteBuffer buffer = acquireByteBuffer(OConstants.SIZE_SHORT);\r\n\t\t\tchannel.read(buffer, iOffset + HEADER_SIZE);\r\n\t\t\tbuffer.rewind();\r\n\t\t\tfinal short value = buffer.getShort();\r\n\t\t\treleaseByteBuffer(buffer);\r\n\t\t\treturn value;\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic long readLong(int iOffset) {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_LONG);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_LONG, OPERATION_TYPE.READ);\r\n\t\treturn entry.buffer.getLong(iOffset - entry.beginOffset);\r\n\t}","id":91389,"modified_method":"@Override\r\n\tpublic long readLong(int iOffset) throws IOException {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_LONG);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_LONG, OPERATION_TYPE.READ);\r\n\t\tif (entry != null) {\r\n\t\t\t// MMAP READ\r\n\t\t\treturn entry.buffer.getLong(iOffset - entry.beginOffset);\r\n\t\t} else {\r\n\t\t\t// DIRECT READ\r\n\t\t\tfinal ByteBuffer buffer = acquireByteBuffer(OConstants.SIZE_LONG);\r\n\t\t\tchannel.read(buffer, iOffset + HEADER_SIZE);\r\n\t\t\tbuffer.rewind();\r\n\t\t\tfinal long value = buffer.getLong();\r\n\t\t\treleaseByteBuffer(buffer);\r\n\t\t\treturn value;\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic void read(int iOffset, final byte[] iDestBuffer, final int iLenght) {\r\n\t\tiOffset = checkRegions(iOffset, iLenght);\r\n\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, iLenght, OPERATION_TYPE.READ);\r\n\t\tentry.buffer.position(iOffset - entry.beginOffset);\r\n\t\tentry.buffer.get(iDestBuffer, 0, iLenght);\r\n\t}","id":91390,"modified_method":"@Override\r\n\tpublic void read(int iOffset, final byte[] iDestBuffer, final int iLenght) throws IOException {\r\n\t\tiOffset = checkRegions(iOffset, iLenght);\r\n\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, iLenght, OPERATION_TYPE.READ);\r\n\t\tif (entry != null) {\r\n\t\t\t// MMAP READ\r\n\t\t\tentry.buffer.position(iOffset - entry.beginOffset);\r\n\t\t\tentry.buffer.get(iDestBuffer, 0, iLenght);\r\n\t\t} else {\r\n\t\t\t// DIRECT READ\r\n\t\t\tfinal ByteBuffer buffer = acquireByteBuffer(iLenght);\r\n\t\t\tchannel.read(buffer, iOffset + HEADER_SIZE);\r\n\t\t\tbuffer.rewind();\r\n\t\t\tbuffer.get(iDestBuffer);\r\n\t\t\treleaseByteBuffer(buffer);\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OFileMMap(String iFileName, String iMode) throws IOException {\r\n\t\tsuper(iFileName, iMode);\r\n\t}","id":91391,"modified_method":"public OFileMMap(String iFileName, String iMode) throws IOException {\r\n\t\tsuper(iFileName, iMode);\r\n\t\tBYTEBUFFER_POOLABLE_SIZE = OGlobalConfiguration.FILE_MMAP_BUFFER_SIZE.getValueAsInteger();\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic void writeByte(int iOffset, final byte iValue) {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_BYTE);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_BYTE, OPERATION_TYPE.WRITE);\r\n\t\tentry.buffer.put(iOffset - entry.beginOffset, iValue);\r\n\t}","id":91392,"modified_method":"@Override\r\n\tpublic void writeByte(int iOffset, final byte iValue) throws IOException {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_BYTE);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_BYTE, OPERATION_TYPE.WRITE);\r\n\t\tif (entry != null) {\r\n\t\t\t// MMAP WRITE\r\n\t\t\tentry.buffer.put(iOffset - entry.beginOffset, iValue);\r\n\t\t} else {\r\n\t\t\t// DIRECT WRITE\r\n\t\t\tfinal ByteBuffer buffer = acquireByteBuffer(OConstants.SIZE_BYTE);\r\n\t\t\tbuffer.put(iValue);\r\n\t\t\tbuffer.rewind();\r\n\t\t\tchannel.write(buffer, iOffset + HEADER_SIZE);\r\n\t\t\treleaseByteBuffer(buffer);\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic byte readByte(int iOffset) {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_BYTE);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_BYTE, OPERATION_TYPE.READ);\r\n\t\treturn entry.buffer.get(iOffset - entry.beginOffset);\r\n\t}","id":91393,"modified_method":"@Override\r\n\tpublic byte readByte(int iOffset) throws IOException {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_BYTE);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_BYTE, OPERATION_TYPE.READ);\r\n\t\tif (entry != null) {\r\n\t\t\t// MMAP READ\r\n\t\t\treturn entry.buffer.get(iOffset - entry.beginOffset);\r\n\t\t} else {\r\n\t\t\t// DIRECT READ\r\n\t\t\tfinal ByteBuffer buffer = acquireByteBuffer(OConstants.SIZE_BYTE);\r\n\t\t\tchannel.read(buffer, iOffset + HEADER_SIZE);\r\n\t\t\tbuffer.rewind();\r\n\t\t\tfinal byte value = buffer.get();\r\n\t\t\treleaseByteBuffer(buffer);\r\n\t\t\treturn value;\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic void writeLong(int iOffset, final long iValue) {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_LONG);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_LONG, OPERATION_TYPE.WRITE);\r\n\t\tentry.buffer.putLong(iOffset - entry.beginOffset, iValue);\r\n\t}","id":91394,"modified_method":"@Override\r\n\tpublic void writeLong(int iOffset, final long iValue) throws IOException {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_LONG);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_LONG, OPERATION_TYPE.WRITE);\r\n\t\tif (entry != null) {\r\n\t\t\t// MMAP WRITE\r\n\t\t\tentry.buffer.putLong(iOffset - entry.beginOffset, iValue);\r\n\t\t} else {\r\n\t\t\t// DIRECT WRITE\r\n\t\t\tfinal ByteBuffer buffer = acquireByteBuffer(OConstants.SIZE_LONG);\r\n\t\t\tbuffer.putLong(iValue);\r\n\t\t\tbuffer.rewind();\r\n\t\t\tchannel.write(buffer, iOffset + HEADER_SIZE);\r\n\t\t\treleaseByteBuffer(buffer);\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic void write(int iOffset, final byte[] iSourceBuffer) {\r\n\t\tif (iSourceBuffer.length == 0)\r\n\t\t\treturn;\r\n\r\n\t\tiOffset = checkRegions(iOffset, iSourceBuffer.length);\r\n\r\n\t\ttry {\r\n\t\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, iSourceBuffer.length, OPERATION_TYPE.WRITE);\r\n\t\t\tentry.buffer.position(iOffset - entry.beginOffset);\r\n\t\t\tentry.buffer.put(iSourceBuffer);\r\n\t\t} catch (BufferOverflowException e) {\r\n\t\t\tOLogManager.instance().error(this, \"Error on write in the range \" + iOffset + \"-\" + iOffset + iSourceBuffer.length + \".\" + toString(), e,\r\n\t\t\t\t\tOIOException.class);\r\n\t\t}\r\n\t}","id":91395,"modified_method":"@Override\r\n\tpublic void write(int iOffset, final byte[] iSourceBuffer) throws IOException {\r\n\t\tif (iSourceBuffer.length == 0)\r\n\t\t\treturn;\r\n\r\n\t\tiOffset = checkRegions(iOffset, iSourceBuffer.length);\r\n\r\n\t\ttry {\r\n\t\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, iSourceBuffer.length, OPERATION_TYPE.WRITE);\r\n\t\t\tif (entry != null) {\r\n\t\t\t\t// MMAP WRITE\r\n\t\t\t\tentry.buffer.position(iOffset - entry.beginOffset);\r\n\t\t\t\tentry.buffer.put(iSourceBuffer);\r\n\t\t\t} else {\r\n\t\t\t\t// DIRECT WRITE\r\n\t\t\t\tfinal ByteBuffer buffer = acquireByteBuffer(iSourceBuffer.length);\r\n\t\t\t\tbuffer.put(iSourceBuffer);\r\n\t\t\t\tbuffer.rewind();\r\n\t\t\t\tchannel.write(buffer, iOffset + HEADER_SIZE);\r\n\t\t\t\treleaseByteBuffer(buffer);\r\n\t\t\t}\r\n\t\t} catch (BufferOverflowException e) {\r\n\t\t\tOLogManager.instance().error(this, \"Error on write in the range \" + iOffset + \"-\" + iOffset + iSourceBuffer.length + \".\" + toString(), e,\r\n\t\t\t\t\tOIOException.class);\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic int readInt(int iOffset) {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_INT);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_INT, OPERATION_TYPE.READ);\r\n\t\treturn entry.buffer.getInt(iOffset - entry.beginOffset);\r\n\t}","id":91396,"modified_method":"@Override\r\n\tpublic int readInt(int iOffset) throws IOException {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_INT);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_INT, OPERATION_TYPE.READ);\r\n\t\tif (entry != null) {\r\n\t\t\t// MMAP READ\r\n\t\t\treturn entry.buffer.getInt(iOffset - entry.beginOffset);\r\n\t\t} else {\r\n\t\t\t// DIRECT READ\r\n\t\t\tfinal ByteBuffer buffer = acquireByteBuffer(OConstants.SIZE_INT);\r\n\t\t\tchannel.read(buffer, iOffset + HEADER_SIZE);\r\n\t\t\tbuffer.rewind();\r\n\t\t\tfinal int value = buffer.getInt();\r\n\t\t\treleaseByteBuffer(buffer);\r\n\t\t\treturn value;\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic void writeShort(int iOffset, final short iValue) {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_SHORT);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_SHORT, OPERATION_TYPE.WRITE);\r\n\t\tentry.buffer.putShort(iOffset - entry.beginOffset, iValue);\r\n\t}","id":91397,"modified_method":"@Override\r\n\tpublic void writeShort(int iOffset, final short iValue) throws IOException {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_SHORT);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_SHORT, OPERATION_TYPE.WRITE);\r\n\t\tif (entry != null) {\r\n\t\t\t// MMAP WRITE\r\n\t\t\tentry.buffer.putShort(iOffset - entry.beginOffset, iValue);\r\n\t\t} else {\r\n\t\t\t// DIRECT WRITE\r\n\t\t\tfinal ByteBuffer buffer = acquireByteBuffer(OConstants.SIZE_SHORT);\r\n\t\t\tbuffer.putShort(iValue);\r\n\t\t\tbuffer.rewind();\r\n\t\t\tchannel.write(buffer, iOffset + HEADER_SIZE);\r\n\t\t\treleaseByteBuffer(buffer);\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic void writeInt(int iOffset, final int iValue) {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_INT);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_INT, OPERATION_TYPE.WRITE);\r\n\t\tentry.buffer.putInt(iOffset - entry.beginOffset, iValue);\r\n\t}","id":91398,"modified_method":"@Override\r\n\tpublic void writeInt(int iOffset, final int iValue) throws IOException {\r\n\t\tiOffset = checkRegions(iOffset, OConstants.SIZE_INT);\r\n\t\tfinal OMMapBufferEntry entry = OMMapManager.request(this, iOffset, OConstants.SIZE_INT, OPERATION_TYPE.WRITE);\r\n\t\tif (entry != null) {\r\n\t\t\t// MMAP WRITE\r\n\t\t\tentry.buffer.putInt(iOffset - entry.beginOffset, iValue);\r\n\t\t} else {\r\n\t\t\t// DIRECT WRITE\r\n\t\t\tfinal ByteBuffer buffer = acquireByteBuffer(OConstants.SIZE_INT);\r\n\t\t\tbuffer.putInt(iValue);\r\n\t\t\tbuffer.rewind();\r\n\t\t\tchannel.write(buffer, iOffset + HEADER_SIZE);\r\n\t\t\treleaseByteBuffer(buffer);\r\n\t\t}\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Requests a mmap buffer to use.\r\n\t * \r\n\t * @param iFile\r\n\t *          MMap file\r\n\t * @param iBeginOffset\r\n\t *          Begin offset\r\n\t * @param iSize\r\n\t *          Portion size requested\r\n\t * @param iForce\r\n\t *          Tells if the size is mandatory or can be rounded to the next segment\r\n\t * @param iOperationType\r\n\t *          READ or WRITE\r\n\t * @return The mmap buffer entry if found, or null if the operation is READ and the buffer pool is full.\r\n\t */\r\n\tpublic synchronized static OMMapBufferEntry request(final OFileMMap iFile, final int iBeginOffset, final int iSize, final boolean iForce,\r\n\t\t\tfinal OPERATION_TYPE iOperationType) {\r\n\r\n\t\tif (bufferPoolLRU.size() > 0) {\r\n\t\t\t// SEARCH IF IT'S BETWEEN THE LAST 10 BLOCK USED: THIS IS THE COMMON CASE ON MASSIVE INSERTION\r\n\t\t\tOMMapBufferEntry e;\r\n\t\t\tfinal int min = Math.max(bufferPoolLRU.size() - 10, -1);\r\n\t\t\tfor (int i = bufferPoolLRU.size() - 1; i > min; --i) {\r\n\t\t\t\te = bufferPoolLRU.get(i);\r\n\r\n\t\t\t\tif (e.file == iFile && iBeginOffset >= e.beginOffset && iBeginOffset + iSize <= e.beginOffset + e.size) {\r\n\t\t\t\t\t// FOUND: USE IT\r\n\t\t\t\t\tOProfiler.getInstance().updateCounter(\"OMMapManager.usePage\", 1);\r\n\t\t\t\t\te.counter++;\r\n\t\t\t\t\treturn e;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// SEARCH THE REQUESTED RANGE IN THE CACHED BUFFERS\r\n\t\tList<OMMapBufferEntry> fileEntries = bufferPoolPerFile.get(iFile);\r\n\t\tif (fileEntries == null) {\r\n\t\t\tfileEntries = new ArrayList<OMMapBufferEntry>();\r\n\t\t\tbufferPoolPerFile.put(iFile, fileEntries);\r\n\t\t}\r\n\r\n\t\tint position = searchEntry(fileEntries, iBeginOffset, iSize);\r\n\t\tif (position > -1)\r\n\t\t\t// FOUND\r\n\t\t\treturn fileEntries.get(position);\r\n\r\n\t\tint bufferSize = iForce ? iSize : iSize <= DEF_BLOCK_SIZE ? DEF_BLOCK_SIZE : iSize;\r\n\t\tif (iBeginOffset + bufferSize > iFile.getFileSize())\r\n\t\t\t// REQUESTED BUFFER IS TOO LARGE: GET AS MAXIMUM AS POSSIBLE\r\n\t\t\tbufferSize = iFile.getFileSize() - iBeginOffset;\r\n\r\n\t\tif (bufferSize <= 0)\r\n\t\t\tthrow new IllegalArgumentException(\"Invalid range requested for file \" + iFile + \". Requested \" + iSize + \" bytes from the address \"\r\n\t\t\t\t\t+ iBeginOffset + \" while the total file size is \" + iFile.getFileSize());\r\n\r\n\t\ttotalMemory += bufferSize;\r\n\r\n\t\t// FREE LESS-USED BUFFERS UNTIL THE FREE-MEMORY IS DOWN THE CONFIGURED MAX LIMIT\r\n\t\tOMMapBufferEntry entry = null;\r\n\t\tboolean forceSucceed;\r\n\t\tdo {\r\n\t\t\tif (totalMemory > maxMemory) {\r\n\t\t\t\tint pagesUnloaded = 0;\r\n\r\n\t\t\t\t// SORT AS LRU, FIRT = MOST USED\r\n\t\t\t\tCollections.sort(bufferPoolLRU, new Comparator<OMMapBufferEntry>() {\r\n\t\t\t\t\tpublic int compare(final OMMapBufferEntry o1, final OMMapBufferEntry o2) {\r\n\t\t\t\t\t\treturn (int) (o1.counter - o2.counter);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// REMOVE THE LESS USED ENTRY AND UPDATE THE TOTAL MEMORY\r\n\t\t\t\tfor (Iterator<OMMapBufferEntry> it = bufferPoolLRU.iterator(); it.hasNext();) {\r\n\t\t\t\t\tentry = it.next();\r\n\t\t\t\t\tif (!entry.pin) {\r\n\t\t\t\t\t\t// FORCE THE WRITE OF THE BUFFER\r\n\t\t\t\t\t\tforceSucceed = false;\r\n\t\t\t\t\t\tfor (int i = 0; i < FORCE_RETRY; ++i) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tentry.buffer.force();\r\n\t\t\t\t\t\t\t\tforceSucceed = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\t\t\t\tOLogManager.instance().debug(entry.buffer, \"Can't write memory buffer to disk. Retrying (\" + (i + 1) + \"/\" + FORCE_RETRY + \")...\");\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\tSystem.gc();\r\n\t\t\t\t\t\t\t\t\tThread.sleep(FORCE_DELAY);\r\n\t\t\t\t\t\t\t\t} catch (InterruptedException e1) {\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!forceSucceed)\r\n\t\t\t\t\t\t\tentry.buffer.force();\r\n\r\n\t\t\t\t\t\t// REMOVE FROM COLLECTIONS\r\n\t\t\t\t\t\tit.remove();\r\n\t\t\t\t\t\tbufferPoolPerFile.get(entry.file).remove(entry);\r\n\r\n\t\t\t\t\t\tpagesUnloaded++;\r\n\r\n\t\t\t\t\t\tentry.buffer = null;\r\n\r\n\t\t\t\t\t\ttotalMemory -= entry.size;\r\n\r\n\t\t\t\t\t\tif (totalMemory < maxMemory)\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tOProfiler.getInstance().updateCounter(\"OMMapManager.pagesUnloaded\", pagesUnloaded);\r\n\r\n\t\t\t\t// RECOMPUTE THE POSITION AFTER REMOVING\r\n\t\t\t\tposition = searchEntry(fileEntries, iBeginOffset, iSize);\r\n\t\t\t}\r\n\r\n\t\t\t// LOAD THE PAGE\r\n\t\t\ttry {\r\n\t\t\t\tentry = mapBuffer(iFile, iBeginOffset, bufferSize);\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\t// REDUCE MAX MEMORY TO FORCE EMPTY BUFFERS\r\n\t\t\t\tmaxMemory = maxMemory * 90 / 100;\r\n\t\t\t\tOLogManager.instance().warn(OMMapManager.class, \"Memory mapping error, try to reduce max memory to %d and retry...\", maxMemory);\r\n\t\t\t}\r\n\t\t} while (entry == null && maxMemory > MIN_MEMORY);\r\n\r\n\t\tif (entry == null)\r\n\t\t\tthrow new OIOException(\"You can't access to the file portion \" + iBeginOffset + \"-\" + iBeginOffset + iSize + \" bytes\");\r\n\r\n\t\tbufferPoolLRU.add(entry);\r\n\t\tfileEntries.add((position + 1) * -1, entry);\r\n\r\n\t\treturn entry;\r\n\t}","id":91399,"modified_method":"/**\r\n\t * Requests a mmap buffer to use.\r\n\t * \r\n\t * @param iFile\r\n\t *          MMap file\r\n\t * @param iBeginOffset\r\n\t *          Begin offset\r\n\t * @param iSize\r\n\t *          Portion size requested\r\n\t * @param iForce\r\n\t *          Tells if the size is mandatory or can be rounded to the next segment\r\n\t * @param iOperationType\r\n\t *          READ or WRITE\r\n\t * @return The mmap buffer entry if found, or null if the operation is READ and the buffer pool is full.\r\n\t */\r\n\tpublic synchronized static OMMapBufferEntry request(final OFileMMap iFile, final int iBeginOffset, final int iSize, final boolean iForce,\r\n\t\t\tfinal OPERATION_TYPE iOperationType) {\r\n\r\n\t\tif (bufferPoolLRU.size() > 0) {\r\n\t\t\t// SEARCH IF IT'S BETWEEN THE LAST 10 BLOCK USED: THIS IS THE COMMON CASE ON MASSIVE INSERTION\r\n\t\t\tOMMapBufferEntry e;\r\n\t\t\tfinal int min = Math.max(bufferPoolLRU.size() - 10, -1);\r\n\t\t\tfor (int i = bufferPoolLRU.size() - 1; i > min; --i) {\r\n\t\t\t\te = bufferPoolLRU.get(i);\r\n\r\n\t\t\t\tif (e.file == iFile && iBeginOffset >= e.beginOffset && iBeginOffset + iSize <= e.beginOffset + e.size) {\r\n\t\t\t\t\t// FOUND: USE IT\r\n\t\t\t\t\tOProfiler.getInstance().updateCounter(\"OMMapManager.usePage\", 1);\r\n\t\t\t\t\te.counter++;\r\n\t\t\t\t\treturn e;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// SEARCH THE REQUESTED RANGE IN THE CACHED BUFFERS\r\n\t\tList<OMMapBufferEntry> fileEntries = bufferPoolPerFile.get(iFile);\r\n\t\tif (fileEntries == null) {\r\n\t\t\tfileEntries = new ArrayList<OMMapBufferEntry>();\r\n\t\t\tbufferPoolPerFile.put(iFile, fileEntries);\r\n\t\t}\r\n\r\n\t\tint position = searchEntry(fileEntries, iBeginOffset, iSize);\r\n\t\tif (position > -1)\r\n\t\t\t// FOUND\r\n\t\t\treturn fileEntries.get(position);\r\n\r\n\t\tint bufferSize = iForce ? iSize : iSize <= DEF_BLOCK_SIZE ? DEF_BLOCK_SIZE : iSize;\r\n\t\tif (iBeginOffset + bufferSize > iFile.getFileSize())\r\n\t\t\t// REQUESTED BUFFER IS TOO LARGE: GET AS MAXIMUM AS POSSIBLE\r\n\t\t\tbufferSize = iFile.getFileSize() - iBeginOffset;\r\n\r\n\t\tif (bufferSize <= 0)\r\n\t\t\tthrow new IllegalArgumentException(\"Invalid range requested for file \" + iFile + \". Requested \" + iSize + \" bytes from the address \"\r\n\t\t\t\t\t+ iBeginOffset + \" while the total file size is \" + iFile.getFileSize());\r\n\r\n\t\tif (totalMemory + bufferSize > maxMemory) {\r\n\t\t\t// BUFFER POOL FULL: SINCE IT'S A READ RETURN NULL TO LET TO THE CALLER TO EXECUTE A DIRECT READ WITHOUT MMAP\r\n\r\n\t\t\tfinal int p = (position + 2) * -1;\r\n\t\t\tif (p > -1 && p <= fileEntries.size()) {\r\n\t\t\t\t// CHECK IF THERE IS A BUFFER TO COMMIT TO DISK\r\n\t\t\t\tfinal OMMapBufferEntry entry = fileEntries.get(p);\r\n\t\t\t\tif (entry.beginOffset <= iBeginOffset && entry.beginOffset + entry.size >= iBeginOffset)\r\n\t\t\t\t\tcommitBuffer(entry);\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\ttotalMemory += bufferSize;\r\n\r\n\t\t// FREE LESS-USED BUFFERS UNTIL THE FREE-MEMORY IS DOWN THE CONFIGURED MAX LIMIT\r\n\t\tOMMapBufferEntry entry = null;\r\n\t\tdo {\r\n\t\t\tif (totalMemory > maxMemory) {\r\n\t\t\t\tint pagesUnloaded = 0;\r\n\r\n\t\t\t\t// SORT AS LRU, FIRT = MOST USED\r\n\t\t\t\tCollections.sort(bufferPoolLRU, new Comparator<OMMapBufferEntry>() {\r\n\t\t\t\t\tpublic int compare(final OMMapBufferEntry o1, final OMMapBufferEntry o2) {\r\n\t\t\t\t\t\treturn (int) (o1.counter - o2.counter);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// REMOVE THE LESS USED ENTRY AND UPDATE THE TOTAL MEMORY\r\n\t\t\t\tfor (Iterator<OMMapBufferEntry> it = bufferPoolLRU.iterator(); it.hasNext();) {\r\n\t\t\t\t\tentry = it.next();\r\n\t\t\t\t\tif (!entry.pin) {\r\n\t\t\t\t\t\tcommitBuffer(entry);\r\n\r\n\t\t\t\t\t\t// REMOVE FROM COLLECTIONS\r\n\t\t\t\t\t\tit.remove();\r\n\t\t\t\t\t\tbufferPoolPerFile.get(entry.file).remove(entry);\r\n\r\n\t\t\t\t\t\tpagesUnloaded++;\r\n\r\n\t\t\t\t\t\tentry.buffer = null;\r\n\r\n\t\t\t\t\t\ttotalMemory -= entry.size;\r\n\r\n\t\t\t\t\t\tif (totalMemory < maxMemory)\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tOProfiler.getInstance().updateCounter(\"OMMapManager.pagesUnloaded\", pagesUnloaded);\r\n\r\n\t\t\t\t// RECOMPUTE THE POSITION AFTER REMOVING\r\n\t\t\t\tposition = searchEntry(fileEntries, iBeginOffset, iSize);\r\n\t\t\t}\r\n\r\n\t\t\t// LOAD THE PAGE\r\n\t\t\ttry {\r\n\t\t\t\tentry = mapBuffer(iFile, iBeginOffset, bufferSize);\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\t// REDUCE MAX MEMORY TO FORCE EMPTY BUFFERS\r\n\t\t\t\tmaxMemory = maxMemory * 90 / 100;\r\n\t\t\t\tOLogManager.instance().warn(OMMapManager.class, \"Memory mapping error, try to reduce max memory to %d and retry...\", maxMemory);\r\n\t\t\t}\r\n\t\t} while (entry == null && maxMemory > MIN_MEMORY);\r\n\r\n\t\tif (entry == null)\r\n\t\t\tthrow new OIOException(\"You can't access to the file portion \" + iBeginOffset + \"-\" + iBeginOffset + iSize + \" bytes\");\r\n\r\n\t\tbufferPoolLRU.add(entry);\r\n\t\tfileEntries.add((position + 1) * -1, entry);\r\n\r\n\t\treturn entry;\r\n\t}","commit_id":"c047ca3d9359adf531d5dce53ac82ab10f95fc3e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private List<DataTargetInfo> createDataTargets(List<StreamSnapshotRequestConfig.Stream> localStreams,\n                                                   HashinatorSnapshotData hashinatorData,\n                                                   Map<Integer, byte[]> schemas)\n    {\n        ByteBuffer hashinatorConfigBuf = ByteBuffer.allocate(8 + hashinatorData.m_serData.length);\n        hashinatorConfigBuf.putLong(hashinatorData.m_version);\n        hashinatorConfigBuf.put(hashinatorData.m_serData);\n\n        List<DataTargetInfo> sdts = Lists.newArrayList();\n\n        if (!localStreams.isEmpty()) {\n            Mailbox mb = VoltDB.instance().getHostMessenger().createMailbox();\n            StreamSnapshotDataTarget.SnapshotSender sender = new StreamSnapshotDataTarget.SnapshotSender(mb);\n            StreamSnapshotAckReceiver ackReceiver = new StreamSnapshotAckReceiver(mb);\n            new Thread(sender, \"Stream Snapshot Sender\").start();\n            new Thread(ackReceiver, \"Stream Snapshot Ack Receiver\").start();\n            // The mailbox will be removed after all snapshot data targets are finished\n            SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(createCompletionTask(mb));\n\n            // Create data target for each source HSID in each stream\n            for (StreamSnapshotRequestConfig.Stream stream : localStreams) {\n                SNAP_LOG.debug(\"Sites to stream from: \" +\n                               CoreUtils.hsIdCollectionToString(stream.streamPairs.keySet()));\n                for (Entry<Long, Long> entry : stream.streamPairs.entries()) {\n                    long srcHSId = entry.getKey();\n                    long destHSId = entry.getValue();\n\n                    sdts.add(new DataTargetInfo(stream,\n                                                srcHSId,\n                                                destHSId,\n                                                new StreamSnapshotDataTarget(destHSId, hashinatorConfigBuf.array(),\n                                                                             schemas, sender, ackReceiver)));\n                }\n            }\n        }\n\n        return sdts;\n    }","id":91400,"modified_method":"private List<DataTargetInfo> createDataTargets(List<StreamSnapshotRequestConfig.Stream> localStreams,\n                                                   HashinatorSnapshotData hashinatorData,\n                                                   Map<Integer, byte[]> schemas)\n    {\n        byte[] hashinatorConfig = null;\n        if (hashinatorData != null) {\n            ByteBuffer hashinatorConfigBuf = ByteBuffer.allocate(8 + hashinatorData.m_serData.length);\n            hashinatorConfigBuf.putLong(hashinatorData.m_version);\n            hashinatorConfigBuf.put(hashinatorData.m_serData);\n            hashinatorConfig =  hashinatorConfigBuf.array();\n        }\n\n        List<DataTargetInfo> sdts = Lists.newArrayList();\n\n        if (!localStreams.isEmpty()) {\n            Mailbox mb = VoltDB.instance().getHostMessenger().createMailbox();\n            StreamSnapshotDataTarget.SnapshotSender sender = new StreamSnapshotDataTarget.SnapshotSender(mb);\n            StreamSnapshotAckReceiver ackReceiver = new StreamSnapshotAckReceiver(mb);\n            new Thread(sender, \"Stream Snapshot Sender\").start();\n            new Thread(ackReceiver, \"Stream Snapshot Ack Receiver\").start();\n            // The mailbox will be removed after all snapshot data targets are finished\n            SnapshotSiteProcessor.m_tasksOnSnapshotCompletion.offer(createCompletionTask(mb));\n\n            // Create data target for each source HSID in each stream\n            for (StreamSnapshotRequestConfig.Stream stream : localStreams) {\n                SNAP_LOG.debug(\"Sites to stream from: \" +\n                               CoreUtils.hsIdCollectionToString(stream.streamPairs.keySet()));\n                for (Entry<Long, Long> entry : stream.streamPairs.entries()) {\n                    long srcHSId = entry.getKey();\n                    long destHSId = entry.getValue();\n\n                    sdts.add(new DataTargetInfo(stream,\n                                                srcHSId,\n                                                destHSId,\n                                                new StreamSnapshotDataTarget(destHSId, hashinatorConfig,\n                                                                             schemas, sender, ackReceiver)));\n                }\n            }\n        }\n\n        return sdts;\n    }","commit_id":"07d521d810d36840ca651adf679468b26cb7accf","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\r\n\tpublic void writeHeaderLong(final int iPosition, final long iValue) {\r\n\t\theaderBuffer.putLong(HEADER_DATA_OFFSET + iPosition, iValue);\r\n\t}","id":91401,"modified_method":"@Override\r\n\tpublic void writeHeaderLong(final int iPosition, final long iValue) {\r\n\t\tif (headerBuffer != null)\r\n\t\t\theaderBuffer.putLong(HEADER_DATA_OFFSET + iPosition, iValue);\r\n\t}","commit_id":"adcd64a114f2522161384ed0ff086603b46da314","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * @param min\n     * @param snapshots\n     * @return\n     */\n    private ByteBuffer serializeRestoreInformation(long min, Set<SnapshotInfo> snapshots) {\n        // minTxnId + recover + snapshotCount\n        int size = 8 + 1 + 4;\n        for (SnapshotInfo i : snapshots) {\n            size += i.size();\n        }\n\n        ByteBuffer buf = ByteBuffer.allocate(size);\n        buf.putLong(min);\n        // 1 means recover, 0 means to create new DB\n        buf.put(m_action != START_ACTION.CREATE ? (byte) 1 : 0);\n\n        buf.putInt(snapshots.size());\n        for (SnapshotInfo snapshot : snapshots) {\n            buf.putLong(snapshot.txnId);\n            buf.putInt(snapshot.nonce.length());\n            buf.put(snapshot.nonce.getBytes());\n            buf.putInt(snapshot.path.length());\n            buf.put(snapshot.path.getBytes());\n            buf.putInt(snapshot.partitionCount);\n            buf.putInt(snapshot.partitions.size());\n            for (Entry<String, Set<Integer>> p : snapshot.partitions.entrySet()) {\n                buf.putInt(p.getKey().length());\n                buf.put(p.getKey().getBytes());\n                buf.putInt(p.getValue().size());\n                for (int id : p.getValue()) {\n                    buf.putInt(id);\n                }\n            }\n        }\n        return buf;\n    }","id":91402,"modified_method":"/**\n     * @param min\n     * @param snapshots\n     * @return\n     */\n    private ByteBuffer serializeRestoreInformation(Long min, Set<SnapshotInfo> snapshots) {\n        // hasLog + recover + snapshotCount\n        int size = 1 + 1 + 4;\n        if (min != null) {\n            // we need to add the size of the min number to the total size\n            size += 8;\n        }\n        for (SnapshotInfo i : snapshots) {\n            size += i.size();\n        }\n\n        ByteBuffer buf = ByteBuffer.allocate(size);\n        if (min == null) {\n            buf.put((byte) 0);\n        } else {\n            buf.put((byte) 1);\n            buf.putLong(min);\n        }\n        // 1 means recover, 0 means to create new DB\n        buf.put(m_action != START_ACTION.CREATE ? (byte) 1 : 0);\n\n        buf.putInt(snapshots.size());\n        for (SnapshotInfo snapshot : snapshots) {\n            buf.putLong(snapshot.txnId);\n            buf.putInt(snapshot.nonce.length());\n            buf.put(snapshot.nonce.getBytes());\n            buf.putInt(snapshot.path.length());\n            buf.put(snapshot.path.getBytes());\n            buf.putInt(snapshot.partitionCount);\n            buf.putInt(snapshot.partitions.size());\n            for (Entry<String, Set<Integer>> p : snapshot.partitions.entrySet()) {\n                buf.putInt(p.getKey().length());\n                buf.put(p.getKey().getBytes());\n                buf.putInt(p.getValue().size());\n                for (int id : p.getValue()) {\n                    buf.putInt(id);\n                }\n            }\n        }\n        return buf;\n    }","commit_id":"ef30b220ef1707de204482fe23f15f97bb6b32b6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Pick the snapshot to restore from based on the global snapshot\n     * information.\n     *\n     * @return The snapshot to restore from, null if none.\n     */\n    private Entry<Long, Set<SnapshotInfo>> getRestorePlan() {\n        /*\n         * Only let the first host do the rest, so we don't end up having\n         * multiple hosts trying to initiate a snapshot restore\n         */\n        if (!isLowestHost()) {\n            return null;\n        }\n\n        LOG.debug(\"Waiting for all hosts to send their snapshot information\");\n        List<String> children = null;\n        while (true) {\n            try {\n                children = m_zk.getChildren(RESTORE, false);\n            } catch (KeeperException e2) {\n                LOG.fatal(e2.getMessage());\n                VoltDB.crashVoltDB();\n            } catch (InterruptedException e2) {\n                continue;\n            }\n\n            Set<Integer> liveHosts = m_context.siteTracker.getAllLiveHosts();\n            if (children.size() < liveHosts.size()) {\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e1) {}\n            } else {\n                break;\n            }\n        }\n\n        if (children == null) {\n            LOG.fatal(\"Unable to read agreement messages from other hosts for\" +\n                      \" restore plan\");\n            VoltDB.crashVoltDB();\n        }\n\n        TreeMap<Long, Set<SnapshotInfo>> snapshotFragments = new TreeMap<Long, Set<SnapshotInfo>>();\n        long clStartTxnId = deserializeRestoreInformation(children, snapshotFragments);\n\n        // If we're not recovering, skip the rest\n        if (m_action == START_ACTION.CREATE) {\n            return null;\n        }\n\n        // Filter all snapshots that are not viable\n        Iterator<Long> iter = snapshotFragments.keySet().iterator();\n        while (iter.hasNext()) {\n            Long txnId = iter.next();\n            if (txnId < clStartTxnId) {\n                iter.remove();\n            }\n        }\n\n        LOG.debug(\"There are \" + snapshotFragments.size() +\n                  \" snapshots available in the cluster\");\n        if (clStartTxnId > 0 && snapshotFragments.size() == 0) {\n            LOG.fatal(\"No viable snapshots to restore\");\n            VoltDB.crashVoltDB();\n        }\n\n        // Find the last complete snapshot and use it\n        HashMap<Long, Map<String, Set<Integer>>> snapshotTablePartitions =\n            new HashMap<Long, Map<String,Set<Integer>>>();\n        Iterator<Entry<Long, Set<SnapshotInfo>>> it = snapshotFragments.entrySet().iterator();\n        while (it.hasNext()) {\n            Entry<Long, Set<SnapshotInfo>> e = it.next();\n            long txnId = e.getKey();\n            Map<String, Set<Integer>> tablePartitions = snapshotTablePartitions.get(txnId);\n            if (tablePartitions == null) {\n                tablePartitions = new HashMap<String, Set<Integer>>();\n                snapshotTablePartitions.put(txnId, tablePartitions);\n            }\n\n            int totalPartitions = -1;\n            boolean inconsistent = false;\n            Set<SnapshotInfo> fragments = e.getValue();\n            for (SnapshotInfo s : fragments) {\n                if (totalPartitions == -1) {\n                    totalPartitions = s.partitionCount;\n                } else if (totalPartitions != s.partitionCount) {\n                    inconsistent = true;\n                    break;\n                }\n\n                for (Entry<String, Set<Integer>> entry : s.partitions.entrySet()) {\n                    Set<Integer> partitions = tablePartitions.get(entry.getKey());\n                    if (partitions == null) {\n                        tablePartitions.put(entry.getKey(), entry.getValue());\n                    } else {\n                        partitions.addAll(entry.getValue());\n                    }\n                }\n\n                if (inconsistent) {\n                    break;\n                }\n            }\n\n            // Check if we have all the partitions\n            for (Set<Integer> partitions : tablePartitions.values()) {\n                if (partitions.size() != totalPartitions) {\n                    inconsistent = true;\n                    break;\n                }\n            }\n\n            if (inconsistent) {\n                it.remove();\n            }\n        }\n\n        if (clStartTxnId > 0 && snapshotFragments.size() == 0) {\n            LOG.fatal(\"No viable snapshots to restore\");\n            VoltDB.crashVoltDB();\n        }\n\n        return snapshotFragments.lastEntry();\n    }","id":91403,"modified_method":"/**\n     * Pick the snapshot to restore from based on the global snapshot\n     * information.\n     *\n     * @return The snapshot to restore from, null if none.\n     */\n    private Entry<Long, Set<SnapshotInfo>> getRestorePlan() {\n        /*\n         * Only let the first host do the rest, so we don't end up having\n         * multiple hosts trying to initiate a snapshot restore\n         */\n        if (!isLowestHost()) {\n            return null;\n        }\n\n        LOG.debug(\"Waiting for all hosts to send their snapshot information\");\n        List<String> children = null;\n        while (true) {\n            try {\n                children = m_zk.getChildren(RESTORE, false);\n            } catch (KeeperException e2) {\n                LOG.fatal(e2.getMessage());\n                VoltDB.crashVoltDB();\n            } catch (InterruptedException e2) {\n                continue;\n            }\n\n            Set<Integer> liveHosts = m_context.siteTracker.getAllLiveHosts();\n            if (children.size() < liveHosts.size()) {\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e1) {}\n            } else {\n                break;\n            }\n        }\n\n        if (children == null) {\n            LOG.fatal(\"Unable to read agreement messages from other hosts for\" +\n                      \" restore plan\");\n            VoltDB.crashVoltDB();\n        }\n\n        TreeMap<Long, Set<SnapshotInfo>> snapshotFragments = new TreeMap<Long, Set<SnapshotInfo>>();\n        Long clStartTxnId = deserializeRestoreInformation(children, snapshotFragments);\n\n        // If we're not recovering, skip the rest\n        if (m_action == START_ACTION.CREATE) {\n            return null;\n        }\n\n        // Filter all snapshots that are not viable\n        Iterator<Long> iter = snapshotFragments.keySet().iterator();\n        while (iter.hasNext()) {\n            Long txnId = iter.next();\n            if (clStartTxnId != null &&\n                (clStartTxnId < 0 || txnId < clStartTxnId)) {\n                iter.remove();\n            }\n        }\n\n        if (clStartTxnId != null && clStartTxnId > 0 &&\n            snapshotFragments.size() == 0) {\n            LOG.fatal(\"No viable snapshots to restore\");\n            VoltDB.crashVoltDB();\n        }\n        LOG.debug(\"There are \" + snapshotFragments.size() +\n                  \" snapshots available in the cluster\");\n\n        // Find the last complete snapshot and use it\n        HashMap<Long, Map<String, Set<Integer>>> snapshotTablePartitions =\n            new HashMap<Long, Map<String,Set<Integer>>>();\n        Iterator<Entry<Long, Set<SnapshotInfo>>> it = snapshotFragments.entrySet().iterator();\n        while (it.hasNext()) {\n            Entry<Long, Set<SnapshotInfo>> e = it.next();\n            long txnId = e.getKey();\n            Map<String, Set<Integer>> tablePartitions = snapshotTablePartitions.get(txnId);\n            if (tablePartitions == null) {\n                tablePartitions = new HashMap<String, Set<Integer>>();\n                snapshotTablePartitions.put(txnId, tablePartitions);\n            }\n\n            int totalPartitions = -1;\n            boolean inconsistent = false;\n            Set<SnapshotInfo> fragments = e.getValue();\n            for (SnapshotInfo s : fragments) {\n                if (totalPartitions == -1) {\n                    totalPartitions = s.partitionCount;\n                } else if (totalPartitions != s.partitionCount) {\n                    inconsistent = true;\n                    break;\n                }\n\n                for (Entry<String, Set<Integer>> entry : s.partitions.entrySet()) {\n                    Set<Integer> partitions = tablePartitions.get(entry.getKey());\n                    if (partitions == null) {\n                        tablePartitions.put(entry.getKey(), entry.getValue());\n                    } else {\n                        partitions.addAll(entry.getValue());\n                    }\n                }\n\n                if (inconsistent) {\n                    break;\n                }\n            }\n\n            // Check if we have all the partitions\n            for (Set<Integer> partitions : tablePartitions.values()) {\n                if (partitions.size() != totalPartitions) {\n                    inconsistent = true;\n                    break;\n                }\n            }\n\n            if (inconsistent) {\n                it.remove();\n            }\n        }\n\n        if (clStartTxnId != null && clStartTxnId > 0 &&\n            snapshotFragments.size() == 0) {\n            LOG.fatal(\"No viable snapshots to restore\");\n            VoltDB.crashVoltDB();\n        }\n\n        return snapshotFragments.lastEntry();\n    }","commit_id":"ef30b220ef1707de204482fe23f15f97bb6b32b6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Send the information about the local snapshot files to the other hosts to\n     * generate restore plan.\n     *\n     * @param min\n     *            The minimum txnId of the last txn across all initiators in the\n     *            local command log.\n     * @param snapshots\n     *            The information of the local snapshot files.\n     */\n    private void sendLocalRestoreInformation(long min, Set<SnapshotInfo> snapshots) {\n        ByteBuffer buf = serializeRestoreInformation(min, snapshots);\n\n        String zkNode = RESTORE + \"/\" + m_hostId;\n        try {\n            m_zk.create(zkNode, buf.array(),\n                        Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n        } catch (Exception e) {\n            LOG.fatal(\"Failed to create Zookeeper node: \" + e.getMessage());\n            VoltDB.crashVoltDB();\n        }\n    }","id":91404,"modified_method":"/**\n     * Send the information about the local snapshot files to the other hosts to\n     * generate restore plan.\n     *\n     * @param min\n     *            The minimum txnId of the last txn across all initiators in the\n     *            local command log.\n     * @param snapshots\n     *            The information of the local snapshot files.\n     */\n    private void sendLocalRestoreInformation(Long min, Set<SnapshotInfo> snapshots) {\n        ByteBuffer buf = serializeRestoreInformation(min, snapshots);\n\n        String zkNode = RESTORE + \"/\" + m_hostId;\n        try {\n            m_zk.create(zkNode, buf.array(),\n                        Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n        } catch (Exception e) {\n            LOG.fatal(\"Failed to create Zookeeper node: \" + e.getMessage());\n            VoltDB.crashVoltDB();\n        }\n    }","commit_id":"ef30b220ef1707de204482fe23f15f97bb6b32b6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * @param children\n     * @param snapshotFragments\n     * @return\n     */\n    private long deserializeRestoreInformation(List<String> children,\n                                               Map<Long, Set<SnapshotInfo>> snapshotFragments) {\n        byte recover = m_action != START_ACTION.CREATE ? (byte) 1 : 0;\n        long clStartTxnId = 0;\n        ByteBuffer buf;\n        for (String node : children) {\n            byte[] data = null;\n            try {\n                data = m_zk.getData(RESTORE + \"/\" + node, false, null);\n            } catch (Exception e) {\n                LOG.fatal(e.getMessage());\n                VoltDB.crashVoltDB();\n            }\n\n            buf = ByteBuffer.wrap(data);\n            long minTxnId = buf.getLong();\n            if (minTxnId > clStartTxnId) {\n                clStartTxnId = minTxnId;\n            }\n\n            byte recoverByte = buf.get();\n            if (recoverByte != recover) {\n                LOG.fatal(\"Database actions are not consistent, please enter \" +\n                          \"the same database action on the command-line.\");\n                VoltDB.crashVoltDB();\n            }\n\n            int count = buf.getInt();\n            for (int i = 0; i < count; i++) {\n                long txnId = buf.getLong();\n                Set<SnapshotInfo> fragments = snapshotFragments.get(txnId);\n                if (fragments == null) {\n                    fragments = new HashSet<SnapshotInfo>();\n                    snapshotFragments.put(txnId, fragments);\n                }\n\n                int len = buf.getInt();\n                byte[] nonceBytes = new byte[len];\n                buf.get(nonceBytes);\n\n                len = buf.getInt();\n                byte[] pathBytes = new byte[len];\n                buf.get(pathBytes);\n\n                int totalPartitionCount = buf.getInt();\n\n                SnapshotInfo info = new SnapshotInfo(txnId, new String(pathBytes),\n                                                     new String(nonceBytes),\n                                                     totalPartitionCount);\n                fragments.add(info);\n\n                int tableCount = buf.getInt();\n                for (int j = 0; j < tableCount; j++) {\n                    len = buf.getInt();\n                    byte[] tableNameBytes = new byte[len];\n                    buf.get(tableNameBytes);\n\n                    int partitionCount = buf.getInt();\n                    HashSet<Integer> partitions = new HashSet<Integer>(partitionCount);\n                    info.partitions.put(new String(tableNameBytes), partitions);\n                    for (int k = 0; k < partitionCount; k++) {\n                        partitions.add(buf.getInt());\n                    }\n                }\n            }\n        }\n        return clStartTxnId;\n    }","id":91405,"modified_method":"/**\n     * @param children\n     * @param snapshotFragments\n     * @return null if there is no log to replay in the whole cluster\n     */\n    private Long deserializeRestoreInformation(List<String> children,\n                                               Map<Long, Set<SnapshotInfo>> snapshotFragments) {\n        byte recover = m_action != START_ACTION.CREATE ? (byte) 1 : 0;\n        Long clStartTxnId = null;\n        ByteBuffer buf;\n        for (String node : children) {\n            byte[] data = null;\n            try {\n                data = m_zk.getData(RESTORE + \"/\" + node, false, null);\n            } catch (Exception e) {\n                LOG.fatal(e.getMessage());\n                VoltDB.crashVoltDB();\n            }\n\n            buf = ByteBuffer.wrap(data);\n            // Check if there is log to replay\n            boolean hasLog = buf.get() == 1;\n            if (hasLog) {\n                long minTxnId = buf.getLong();\n                if (clStartTxnId == null || minTxnId > clStartTxnId) {\n                    clStartTxnId = minTxnId;\n                }\n            }\n\n            byte recoverByte = buf.get();\n            if (recoverByte != recover) {\n                LOG.fatal(\"Database actions are not consistent, please enter \" +\n                          \"the same database action on the command-line.\");\n                VoltDB.crashVoltDB();\n            }\n\n            int count = buf.getInt();\n            for (int i = 0; i < count; i++) {\n                long txnId = buf.getLong();\n                Set<SnapshotInfo> fragments = snapshotFragments.get(txnId);\n                if (fragments == null) {\n                    fragments = new HashSet<SnapshotInfo>();\n                    snapshotFragments.put(txnId, fragments);\n                }\n\n                int len = buf.getInt();\n                byte[] nonceBytes = new byte[len];\n                buf.get(nonceBytes);\n\n                len = buf.getInt();\n                byte[] pathBytes = new byte[len];\n                buf.get(pathBytes);\n\n                int totalPartitionCount = buf.getInt();\n\n                SnapshotInfo info = new SnapshotInfo(txnId, new String(pathBytes),\n                                                     new String(nonceBytes),\n                                                     totalPartitionCount);\n                fragments.add(info);\n\n                int tableCount = buf.getInt();\n                for (int j = 0; j < tableCount; j++) {\n                    len = buf.getInt();\n                    byte[] tableNameBytes = new byte[len];\n                    buf.get(tableNameBytes);\n\n                    int partitionCount = buf.getInt();\n                    HashSet<Integer> partitions = new HashSet<Integer>(partitionCount);\n                    info.partitions.put(new String(tableNameBytes), partitions);\n                    for (int k = 0; k < partitionCount; k++) {\n                        partitions.add(buf.getInt());\n                    }\n                }\n            }\n        }\n        return clStartTxnId;\n    }","commit_id":"ef30b220ef1707de204482fe23f15f97bb6b32b6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Write DOAP description.\n     *\n     * @param writer not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#description\">http://usefulinc.com/ns/doap#description<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#shortdesc\">http://usefulinc.com/ns/doap#shortdesc<\/a>\n     */\n    private void writeDescription( XMLWriter writer )\n    {\n        if ( StringUtils.isEmpty( project.getDescription() ) )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"Plain text description of a project, of 2-4 sentences in length.\", 2 );\n        DoapUtil.writeElement( writer, \"description\", project.getDescription() );\n        DoapUtil.writeElement( writer, \"shortdesc\", project.getDescription() );\n    }","id":91406,"modified_method":"/**\n     * Write DOAP description.\n     *\n     * @param writer not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#description\">http://usefulinc.com/ns/doap#description<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#shortdesc\">http://usefulinc.com/ns/doap#shortdesc<\/a>\n     */\n    private void writeDescription( XMLWriter writer )\n    {\n        if ( StringUtils.isEmpty( project.getDescription() ) )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"Plain text description of a project, of 2-4 sentences in length.\", 2 );\n        DoapUtil.writeElement( writer, \"description\", project.getDescription() );\n        if ( StringUtils.isNotEmpty( doapOptions.getShortdesc() ) )\n        {\n            DoapUtil.writeElement( writer, \"shortdesc\", doapOptions.getShortdesc() );\n        }\n        else\n        {\n            DoapUtil.writeElement( writer, \"shortdesc\", project.getDescription() );\n        }\n    }","commit_id":"79693dffe5affa39b5206855860bbadb7dc091e5","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Write DOAP category.\n     *\n     * @param writer not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#category\">http://usefulinc.com/ns/doap#category<\/a>\n     */\n    private void writeCategory( XMLWriter writer )\n    {\n        if ( StringUtils.isEmpty( doapOptions.getCategory() ) && StringUtils.isEmpty( category ) )\n        {\n            return;\n        }\n\n        //TODO: how to lookup category, map it, or just declare it.\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"A category of project.\", 2 );\n\n        if ( StringUtils.isNotEmpty( category ) ) // backward compatible\n        {\n            DoapUtil.writeRdfResourceElement( writer, \"category\", \"http://projects.apache.org/category/\" + category );\n        }\n\n        if ( StringUtils.isNotEmpty( doapOptions.getCategory() ) )\n        {\n            String[] categories = StringUtils.split( doapOptions.getCategory(), \",\" );\n            for ( int i = 0; i < categories.length; i++ )\n            {\n                DoapUtil.writeRdfResourceElement( writer, \"category\", \"http://projects.apache.org/category/\"\n                    + categories[i].trim() );\n            }\n        }\n    }","id":91407,"modified_method":"/**\n     * Write DOAP category.\n     *\n     * @param writer not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#category\">http://usefulinc.com/ns/doap#category<\/a>\n     */\n    private void writeCategory( XMLWriter writer )\n    {\n        if ( StringUtils.isEmpty( doapOptions.getCategory() ) && StringUtils.isEmpty( category ) )\n        {\n            return;\n        }\n\n        //TODO: how to lookup category, map it, or just declare it.\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"A category of project.\", 2 );\n\n        if ( StringUtils.isNotEmpty( category ) ) // backward compatible\n        {\n            if ( asfExtOptions.isIncluded() && !ASFExtOptions.isCategorySupportedByASF( category ) )\n            {\n                getLog().warn(\n                               \"The given category '\" + category + \"' is not supported by ASF. \"\n                                   + \"Refer you to http://projects.apache.org/categories.html\" );\n            }\n\n            if ( asfExtOptions.isIncluded() )\n            {\n                DoapUtil\n                    .writeRdfResourceElement( writer, \"category\", \"http://projects.apache.org/category/\" + category );\n            }\n            else\n            {\n                DoapUtil.writeRdfResourceElement( writer, \"category\", category );\n            }\n        }\n\n        if ( StringUtils.isNotEmpty( doapOptions.getCategory() ) )\n        {\n            String[] categories = StringUtils.split( doapOptions.getCategory(), \",\" );\n            for ( int i = 0; i < categories.length; i++ )\n            {\n                if ( asfExtOptions.isIncluded() && !ASFExtOptions.isCategorySupportedByASF( categories[i] ) )\n                {\n                    getLog().warn(\n                                   \"The given category '\" + categories[i] + \"' is not supported by ASF. \"\n                                       + \"Refer you to http://projects.apache.org/categories.html\" );\n                }\n\n                if ( asfExtOptions.isIncluded() )\n                {\n                    DoapUtil.writeRdfResourceElement( writer, \"category\", \"http://projects.apache.org/category/\"\n                        + categories[i].trim() );\n                }\n                else\n                {\n                    DoapUtil.writeRdfResourceElement( writer, \"category\", categories[i].trim() );\n                }\n            }\n        }\n    }","commit_id":"79693dffe5affa39b5206855860bbadb7dc091e5","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Write DOAP programming-language.\n     *\n     * @param writer not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#programming-language\">http://usefulinc.com/ns/doap#programming-language<\/a>\n     */\n    private void writeProgrammingLanguage( XMLWriter writer )\n    {\n        if ( StringUtils.isEmpty( doapOptions.getProgrammingLanguage() ) && StringUtils.isEmpty( language ) )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"Programming language.\", 2 );\n\n        if ( StringUtils.isNotEmpty( language ) ) // backward compatible\n        {\n            DoapUtil.writeRdfResourceElement( writer, \"programming-language\", language );\n        }\n\n        if ( StringUtils.isNotEmpty( doapOptions.getProgrammingLanguage() ) )\n        {\n            String[] languages = StringUtils.split( doapOptions.getProgrammingLanguage(), \",\" );\n            for ( int i = 0; i < languages.length; i++ )\n            {\n                DoapUtil.writeRdfResourceElement( writer, \"programming-language\", languages[i].trim() );\n            }\n        }\n    }","id":91408,"modified_method":"/**\n     * Write DOAP programming-language.\n     *\n     * @param writer not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#programming-language\">http://usefulinc.com/ns/doap#programming-language<\/a>\n     */\n    private void writeProgrammingLanguage( XMLWriter writer )\n    {\n        if ( StringUtils.isEmpty( doapOptions.getProgrammingLanguage() ) && StringUtils.isEmpty( language ) )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"Programming language.\", 2 );\n\n        if ( StringUtils.isNotEmpty( language ) ) // backward compatible\n        {\n            if ( asfExtOptions.isIncluded() && !ASFExtOptions.isProgrammingLanguageSupportedByASF( language ) )\n            {\n                getLog().warn(\n                               \"The programming language '\" + language + \"' is not supported by ASF. \"\n                                   + \"Refer you to http://projects.apache.org/languages.html\" );\n            }\n\n            DoapUtil.writeRdfResourceElement( writer, \"programming-language\", language );\n        }\n\n        if ( StringUtils.isNotEmpty( doapOptions.getProgrammingLanguage() ) )\n        {\n            String[] languages = StringUtils.split( doapOptions.getProgrammingLanguage(), \",\" );\n            for ( int i = 0; i < languages.length; i++ )\n            {\n                if ( asfExtOptions.isIncluded() && !ASFExtOptions.isProgrammingLanguageSupportedByASF( languages[i].trim() ) )\n                {\n                    getLog().warn(\n                                   \"The programming language '\" + languages[i].trim() + \"' is not supported by ASF. \"\n                                       + \"Refer you to http://projects.apache.org/languages.html\" );\n                }\n\n                DoapUtil.writeRdfResourceElement( writer, \"programming-language\", languages[i].trim() );\n            }\n        }\n    }","commit_id":"79693dffe5affa39b5206855860bbadb7dc091e5","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Write DOAP name.\n     *\n     * @param writer not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#name\">http://usefulinc.com/ns/doap#name<\/a>\n     */\n    private void writeName( XMLWriter writer )\n    {\n        if ( StringUtils.isEmpty( project.getName() ) )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"A name of something.\", 2 );\n        DoapUtil.writeElement( writer, \"name\", project.getName() );\n    }","id":91409,"modified_method":"/**\n     * Write DOAP name.\n     *\n     * @param writer not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#name\">http://usefulinc.com/ns/doap#name<\/a>\n     */\n    private void writeName( XMLWriter writer )\n    {\n        if ( StringUtils.isEmpty( project.getName() ) )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"A name of something.\", 2 );\n\n        if ( asfExtOptions.isIncluded() && !project.getName().toLowerCase().trim().startsWith( \"apache\" ) )\n        {\n            DoapUtil.writeRdfResourceElement( writer, \"name\", \"Apache \" + project.getName() );\n        }\n        else\n        {\n            DoapUtil.writeRdfResourceElement( writer, \"name\", project.getName() );\n        }\n    }","commit_id":"79693dffe5affa39b5206855860bbadb7dc091e5","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Write DOAP licenses.\n     *\n     * @param writer not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#license\">http://usefulinc.com/ns/doap#license<\/a>\n     */\n    private void writeLicenses( XMLWriter writer )\n    {\n        if ( project.getLicenses() == null || project.getLicenses().size() == 0 )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"The URI of the license the software is distributed under.\", 2 );\n        //TODO: how to map to usefulinc site, or if this is necessary, the OSI page might\n        //      be more appropriate.\n        for ( Iterator it = project.getLicenses().iterator(); it.hasNext(); )\n        {\n            License license = (License) it.next();\n\n            if ( StringUtils.isNotEmpty( license.getUrl() ) )\n            {\n                DoapUtil.writeRdfResourceElement( writer, \"license\", license.getUrl() );\n            }\n            else\n            {\n                getLog().warn( \"No URL was specified for license \" + license.getName() );\n            }\n        }\n    }","id":91410,"modified_method":"/**\n     * Write DOAP licenses.\n     *\n     * @param writer not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#license\">http://usefulinc.com/ns/doap#license<\/a>\n     */\n    private void writeLicenses( XMLWriter writer )\n    {\n        if ( project.getLicenses() == null || project.getLicenses().isEmpty() )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"The URI of the license the software is distributed under.\", 2 );\n        //TODO: how to map to usefulinc site, or if this is necessary, the OSI page might\n        //      be more appropriate.\n        for ( Iterator it = project.getLicenses().iterator(); it.hasNext(); )\n        {\n            License license = (License) it.next();\n\n            if ( StringUtils.isNotEmpty( license.getUrl() ) )\n            {\n                DoapUtil.writeRdfResourceElement( writer, \"license\", license.getUrl() );\n            }\n            else\n            {\n                getLog().warn( \"No URL was specified for license \" + license.getName() );\n            }\n        }\n    }","commit_id":"79693dffe5affa39b5206855860bbadb7dc091e5","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Write a DOAP maintainer or developer or documenter or translator or tester or helper, for instance:\n     * <pre>\n     *   &lt;maintainer&gt;\n     *     &lt;foaf:Person&gt;\n     *       &lt;foaf:name&gt;Emmanuel Venisse&lt;/foaf:name&gt;\n     *       &lt;foaf:mbox rdf:resource=\"mailto:evenisse@apache.org\"/&gt;\n     *     &lt;/foaf:Person&gt;\n     *   &lt;/maintainer&gt;\n     * <\/pre>\n     *\n     * @param writer not null\n     * @param developersOrContributors not null\n     * @param doapType not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#maintainer\">http://usefulinc.com/ns/doap#maintainer<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#developer\">http://usefulinc.com/ns/doap#developer<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#documenter\">http://usefulinc.com/ns/doap#documenter<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#translator\">http://usefulinc.com/ns/doap#translator<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#tester\">http://usefulinc.com/ns/doap#tester<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#helper\">http://usefulinc.com/ns/doap#helper<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/Person\">http://xmlns.com/foaf/0.1/Person<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/name\">http://xmlns.com/foaf/0.1/name<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/mbox\">http://xmlns.com/foaf/0.1/mbox<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/Organization\">http://xmlns.com/foaf/0.1/Organization<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/homepage\">http://xmlns.com/foaf/0.1/homepage<\/a>\n     */\n    private void writeDeveloperOrContributor( XMLWriter writer, List developersOrContributors, String doapType )\n    {\n        if ( developersOrContributors == null || developersOrContributors.size() == 0 )\n        {\n            return;\n        }\n\n        // Sort list by names\n        Collections.sort( developersOrContributors, new Comparator()\n        {\n            /**\n             * {@inheritDoc}\n             */\n            public int compare( Object arg0, Object arg1 )\n            {\n                if ( Developer.class.isAssignableFrom( arg0.getClass() ) )\n                {\n                    Developer developer0 = (Developer) arg0;\n                    Developer developer1 = (Developer) arg1;\n\n                    if ( developer0.getName() == null )\n                    {\n                        return -1;\n                    }\n                    if ( developer1.getName() == null )\n                    {\n                        return +1;\n                    }\n\n                    return developer0.getName().compareTo( developer1.getName() );\n                }\n\n                Contributor contributor0 = (Contributor) arg0;\n                Contributor contributor1 = (Contributor) arg1;\n\n                if ( contributor0.getName() == null )\n                {\n                    return -1;\n                }\n                if ( contributor1.getName() == null )\n                {\n                    return +1;\n                }\n\n                return contributor0.getName().compareTo( contributor1.getName() );\n            }\n        } );\n\n        for ( Iterator it = developersOrContributors.iterator(); it.hasNext(); )\n        {\n            Object obj = it.next();\n\n            String name;\n            String email;\n            String organization;\n            String homepage;\n\n            if ( Developer.class.isAssignableFrom( obj.getClass() ) )\n            {\n                Developer d = (Developer) obj;\n                name = d.getName();\n                email = d.getEmail();\n                organization = d.getOrganization();\n                homepage = d.getUrl();\n            }\n            else\n            {\n                Contributor c = (Contributor) obj;\n                name = c.getName();\n                email = c.getEmail();\n                organization = c.getOrganization();\n                homepage = c.getUrl();\n            }\n\n            // Name is required to write doap\n            if ( StringUtils.isEmpty( name ) )\n            {\n                continue;\n            }\n\n            writer.startElement( doapType );\n            writer.startElement( \"foaf:Person\" );\n            writer.startElement( \"foaf:name\" );\n            writer.writeText( name );\n            writer.endElement(); // foaf:name\n            if ( StringUtils.isNotEmpty( email ) )\n            {\n                DoapUtil.writeRdfResourceElement( writer, \"foaf:mbox\", \"mailto:\" + email );\n            }\n            if ( StringUtils.isNotEmpty( organization ) )\n            {\n                DoapUtil.writeRdfResourceElement( writer, \"foaf:Organization\", organization );\n            }\n            if ( StringUtils.isNotEmpty( homepage ) )\n            {\n                DoapUtil.writeRdfResourceElement( writer, \"foaf:homepage\", homepage );\n            }\n            writer.endElement(); // foaf:Person\n            writer.endElement(); // doapType\n        }\n    }","id":91411,"modified_method":"/**\n     * Write a DOAP maintainer or developer or documenter or translator or tester or helper, for instance:\n     * <pre>\n     *   &lt;maintainer&gt;\n     *     &lt;foaf:Person&gt;\n     *       &lt;foaf:name&gt;Emmanuel Venisse&lt;/foaf:name&gt;\n     *       &lt;foaf:mbox rdf:resource=\"mailto:evenisse@apache.org\"/&gt;\n     *     &lt;/foaf:Person&gt;\n     *   &lt;/maintainer&gt;\n     * <\/pre>\n     *\n     * @param writer not null\n     * @param developersOrContributors list of <code>{@link Developer}/{@link Contributor}<\/code>\n     * @param doapType not null\n     * @see #writeDeveloperOrContributor(XMLWriter, Object, String)\n     */\n    private void writeDeveloperOrContributor( XMLWriter writer, List developersOrContributors, String doapType )\n    {\n        if ( developersOrContributors == null || developersOrContributors.isEmpty() )\n        {\n            return;\n        }\n\n        // Sort list by names\n        Collections.sort( developersOrContributors, new Comparator()\n        {\n            /**\n             * {@inheritDoc}\n             */\n            public int compare( Object arg0, Object arg1 )\n            {\n                if ( Developer.class.isAssignableFrom( arg0.getClass() ) )\n                {\n                    Developer developer0 = (Developer) arg0;\n                    Developer developer1 = (Developer) arg1;\n\n                    if ( developer0.getName() == null )\n                    {\n                        return -1;\n                    }\n                    if ( developer1.getName() == null )\n                    {\n                        return +1;\n                    }\n\n                    return developer0.getName().compareTo( developer1.getName() );\n                }\n\n                Contributor contributor0 = (Contributor) arg0;\n                Contributor contributor1 = (Contributor) arg1;\n\n                if ( contributor0.getName() == null )\n                {\n                    return -1;\n                }\n                if ( contributor1.getName() == null )\n                {\n                    return +1;\n                }\n\n                return contributor0.getName().compareTo( contributor1.getName() );\n            }\n        } );\n\n        for ( Iterator it = developersOrContributors.iterator(); it.hasNext(); )\n        {\n            Object obj = it.next();\n            writeDeveloperOrContributor( writer, obj, doapType );\n        }\n    }","commit_id":"79693dffe5affa39b5206855860bbadb7dc091e5","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Write all DOAP persons.\n     *\n     * @param writer not null\n     * @param developersOrContributors list of developers or contributors\n     */\n    private void writeDevelopersOrContributors( XMLWriter writer, List developersOrContributors )\n    {\n        if ( developersOrContributors == null || developersOrContributors.size() == 0 )\n        {\n            return;\n        }\n\n        boolean isDeveloper = Developer.class.isAssignableFrom( developersOrContributors.get( 0 ).getClass() );\n        if ( isDeveloper )\n        {\n            XmlWriterUtil.writeLineBreak( writer );\n            XmlWriterUtil.writeCommentText( writer, \"Main committers\", 2 );\n        }\n        else\n        {\n            XmlWriterUtil.writeLineBreak( writer );\n            XmlWriterUtil.writeCommentText( writer, \"Contributed persons\", 2 );\n        }\n\n        List maintainers = (List) DoapUtil.filterDevelopersOrContributorsByDoapRoles( developersOrContributors )\n            .get( \"maintainers\" );\n        List developers = (List) DoapUtil.filterDevelopersOrContributorsByDoapRoles( developersOrContributors )\n            .get( \"developers\" );\n        List documenters = (List) DoapUtil.filterDevelopersOrContributorsByDoapRoles( developersOrContributors )\n            .get( \"documenters\" );\n        List translators = (List) DoapUtil.filterDevelopersOrContributorsByDoapRoles( developersOrContributors )\n            .get( \"translators\" );\n        List testers = (List) DoapUtil.filterDevelopersOrContributorsByDoapRoles( developersOrContributors )\n            .get( \"testers\" );\n        List helpers = (List) DoapUtil.filterDevelopersOrContributorsByDoapRoles( developersOrContributors )\n            .get( \"helpers\" );\n        List unknowns = (List) DoapUtil.filterDevelopersOrContributorsByDoapRoles( developersOrContributors )\n            .get( \"unknowns\" );\n\n        // By default, all developers are maintainers and contributors are helpers\n        if ( isDeveloper )\n        {\n            maintainers.addAll( unknowns );\n        }\n        else\n        {\n            helpers.addAll( unknowns );\n        }\n\n        // all alphabetical\n        if ( developers.size() != 0 )\n        {\n            writeDeveloperOrContributor( writer, developers, \"developer\" );\n        }\n        if ( documenters.size() != 0 )\n        {\n            writeDeveloperOrContributor( writer, documenters, \"documenter\" );\n        }\n        if ( helpers.size() != 0 )\n        {\n            writeDeveloperOrContributor( writer, helpers, \"helper\" );\n        }\n        if ( maintainers.size() != 0 )\n        {\n            writeDeveloperOrContributor( writer, maintainers, \"maintainer\" );\n        }\n        if ( testers.size() != 0 )\n        {\n            writeDeveloperOrContributor( writer, testers, \"tester\" );\n        }\n        if ( translators.size() != 0 )\n        {\n            writeDeveloperOrContributor( writer, translators, \"translator\" );\n        }\n    }","id":91412,"modified_method":"/**\n     * Write all DOAP persons.\n     *\n     * @param writer not null\n     * @param developersOrContributors list of developers or contributors\n     */\n    private void writeDevelopersOrContributors( XMLWriter writer, List developersOrContributors )\n    {\n        if ( developersOrContributors == null || developersOrContributors.isEmpty() )\n        {\n            return;\n        }\n\n        boolean isDeveloper = Developer.class.isAssignableFrom( developersOrContributors.get( 0 ).getClass() );\n        if ( isDeveloper )\n        {\n            XmlWriterUtil.writeLineBreak( writer );\n            XmlWriterUtil.writeCommentText( writer, \"Main committers\", 2 );\n        }\n        else\n        {\n            XmlWriterUtil.writeLineBreak( writer );\n            XmlWriterUtil.writeCommentText( writer, \"Contributed persons\", 2 );\n        }\n\n        List maintainers = (List) DoapUtil.filterDevelopersOrContributorsByDoapRoles( developersOrContributors )\n            .get( \"maintainers\" );\n        List developers = (List) DoapUtil.filterDevelopersOrContributorsByDoapRoles( developersOrContributors )\n            .get( \"developers\" );\n        List documenters = (List) DoapUtil.filterDevelopersOrContributorsByDoapRoles( developersOrContributors )\n            .get( \"documenters\" );\n        List translators = (List) DoapUtil.filterDevelopersOrContributorsByDoapRoles( developersOrContributors )\n            .get( \"translators\" );\n        List testers = (List) DoapUtil.filterDevelopersOrContributorsByDoapRoles( developersOrContributors )\n            .get( \"testers\" );\n        List helpers = (List) DoapUtil.filterDevelopersOrContributorsByDoapRoles( developersOrContributors )\n            .get( \"helpers\" );\n        List unknowns = (List) DoapUtil.filterDevelopersOrContributorsByDoapRoles( developersOrContributors )\n            .get( \"unknowns\" );\n\n        // By default, all developers are maintainers and contributors are helpers\n        if ( isDeveloper )\n        {\n            maintainers.addAll( unknowns );\n        }\n        else\n        {\n            helpers.addAll( unknowns );\n        }\n\n        // all alphabetical\n        if ( developers.size() != 0 )\n        {\n            writeDeveloperOrContributor( writer, developers, \"developer\" );\n        }\n        if ( documenters.size() != 0 )\n        {\n            writeDeveloperOrContributor( writer, documenters, \"documenter\" );\n        }\n        if ( helpers.size() != 0 )\n        {\n            writeDeveloperOrContributor( writer, helpers, \"helper\" );\n        }\n        if ( maintainers.size() != 0 )\n        {\n            writeDeveloperOrContributor( writer, maintainers, \"maintainer\" );\n        }\n        if ( testers.size() != 0 )\n        {\n            writeDeveloperOrContributor( writer, testers, \"tester\" );\n        }\n        if ( translators.size() != 0 )\n        {\n            writeDeveloperOrContributor( writer, translators, \"translator\" );\n        }\n    }","commit_id":"79693dffe5affa39b5206855860bbadb7dc091e5","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        // ----------------------------------------------------------------------------\n        // setup pretty print xml writer\n        // ----------------------------------------------------------------------------\n\n        Writer w;\n        try\n        {\n            w = WriterFactory.newXmlWriter( doapFile );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error creating DOAP file.\", e );\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w, project.getModel().getModelEncoding(), null );\n\n        // ----------------------------------------------------------------------------\n        // Convert POM to DOAP\n        // ----------------------------------------------------------------------------\n\n        DoapUtil.writeHeader( writer );\n\n        // Heading\n        writer.startElement( \"rdf:RDF\" );\n        writer.addAttribute( \"xml:lang\", \"en\" );\n        writer.addAttribute( \"xmlns\", \"http://usefulinc.com/ns/doap#\" );\n        writer.addAttribute( \"xmlns:rdf\", \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" );\n        writer.addAttribute( \"xmlns:asfext\", \"http://projects.apache.org/ns/asfext#\" );\n        writer.addAttribute( \"xmlns:foaf\", \"http://xmlns.com/foaf/0.1/\" );\n\n        // Project\n        writer.startElement( \"Project\" );\n        writer.addAttribute( \"rdf:about\", \"http://Maven.rdf.apache.org/\" );\n\n        // name\n        writeName( writer );\n\n        // description\n        writeDescription( writer );\n\n        // created\n        writeCreated( writer );\n\n        // homepage and old-homepage\n        writeHomepage( writer );\n\n        // licenses\n        writeLicenses( writer );\n\n        DoapUtil.writeRdfResourceElement( writer, \"asfext:pmc\", project.getUrl() );\n\n        // programming-language\n        writeProgrammingLanguage( writer );\n\n        // category\n        writeCategory( writer );\n\n        // os\n        writeOS( writer );\n\n        // SCM\n        writeSourceRepositories( writer );\n\n        // bug-database\n        writeBugDatabase( writer );\n\n        // mailing list\n        writeMailingList( writer );\n\n        // download-page and download-mirror\n        writeDownloadPage( writer );\n\n        // screenshots\n        writeScreenshots( writer );\n\n        // wiki\n        writeWiki( writer );\n\n        // Releases\n        writeReleases( writer );\n\n        // Developers\n        writeDevelopersOrContributors( writer, project.getDevelopers() );\n\n        // Contributors\n        writeDevelopersOrContributors( writer, project.getContributors() );\n\n        writer.endElement(); // Project\n        writer.endElement(); // rdf:RDF\n\n        try\n        {\n            w.close();\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error when closing the writer.\", e );\n        }\n    }","id":91413,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        // ----------------------------------------------------------------------------\n        // setup pretty print xml writer\n        // ----------------------------------------------------------------------------\n\n        Writer w;\n        try\n        {\n            w = WriterFactory.newXmlWriter( doapFile );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error creating DOAP file.\", e );\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w, project.getModel().getModelEncoding(), null );\n\n        // ----------------------------------------------------------------------------\n        // Convert POM to DOAP\n        // ----------------------------------------------------------------------------\n\n        DoapUtil.writeHeader( writer );\n\n        // Heading\n        writer.startElement( \"rdf:RDF\" );\n        writer.addAttribute( \"xml:lang\", \"en\" );\n        writer.addAttribute( \"xmlns\", \"http://usefulinc.com/ns/doap#\" );\n        writer.addAttribute( \"xmlns:rdf\", \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" );\n        writer.addAttribute( \"xmlns:foaf\", \"http://xmlns.com/foaf/0.1/\" );\n        if ( asfExtOptions.isIncluded() )\n        {\n            writer.addAttribute( \"xmlns:asfext\", ASFExtOptions.ASFEXT_NAMESPACE );\n        }\n\n        // Project\n        writer.startElement( \"Project\" );\n        writer.addAttribute( \"rdf:about\", \"http://Maven.rdf.apache.org/\" );\n\n        // name\n        writeName( writer );\n\n        // description\n        writeDescription( writer );\n\n        // created\n        writeCreated( writer );\n\n        // homepage and old-homepage\n        writeHomepage( writer );\n\n        // licenses\n        writeLicenses( writer );\n\n        // programming-language\n        writeProgrammingLanguage( writer );\n\n        // category\n        writeCategory( writer );\n\n        // os\n        writeOS( writer );\n\n        // SCM\n        writeSourceRepositories( writer );\n\n        // bug-database\n        writeBugDatabase( writer );\n\n        // mailing list\n        writeMailingList( writer );\n\n        // download-page and download-mirror\n        writeDownloadPage( writer );\n\n        // screenshots\n        writeScreenshots( writer );\n\n        // wiki\n        writeWiki( writer );\n\n        // Releases\n        writeReleases( writer );\n\n        // Developers\n        writeDevelopersOrContributors( writer, project.getDevelopers() );\n\n        // Contributors\n        writeDevelopersOrContributors( writer, project.getContributors() );\n\n        // ASFext\n        if ( asfExtOptions.isIncluded() )\n        {\n            writeASFext( writer );\n        }\n\n        writer.endElement(); // Project\n        writer.endElement(); // rdf:RDF\n\n        try\n        {\n            w.close();\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error when closing the writer.\", e );\n        }\n    }","commit_id":"79693dffe5affa39b5206855860bbadb7dc091e5","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Write DOAP mailing-list.\n     *\n     * @param writer not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#mailing-list\">http://usefulinc.com/ns/doap#mailing-list<\/a>\n     */\n    private void writeMailingList( XMLWriter writer )\n    {\n        if ( project.getMailingLists() == null || project.getMailingLists().size() == 0 )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"mailing list.\", 2 );\n        for ( Iterator it = project.getMailingLists().iterator(); it.hasNext(); )\n        {\n            MailingList mailingList = (MailingList) it.next();\n\n            if ( StringUtils.isNotEmpty( mailingList.getArchive() ) )\n            {\n                DoapUtil.writeRdfResourceElement( writer, \"mailing-list\", mailingList.getArchive() );\n            }\n            else\n            {\n                getLog().warn( \"No archive was specified for mailing list \" + mailingList.getName() );\n            }\n\n            if ( mailingList.getOtherArchives() != null )\n            {\n                for ( Iterator it2 = mailingList.getOtherArchives().iterator(); it2.hasNext(); )\n                {\n                    String otherArchive = (String) it2.next();\n\n                    if ( StringUtils.isNotEmpty( otherArchive ) )\n                    {\n                        DoapUtil.writeRdfResourceElement( writer, \"mailing-list\", otherArchive );\n                    }\n                    else\n                    {\n                        getLog().warn( \"No other archive was specified for mailing list \" + mailingList.getName() );\n                    }\n                }\n            }\n        }\n    }","id":91414,"modified_method":"/**\n     * Write DOAP mailing-list.\n     *\n     * @param writer not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#mailing-list\">http://usefulinc.com/ns/doap#mailing-list<\/a>\n     */\n    private void writeMailingList( XMLWriter writer )\n    {\n        if ( project.getMailingLists() == null || project.getMailingLists().isEmpty() )\n        {\n            return;\n        }\n\n        XmlWriterUtil.writeLineBreak( writer );\n        XmlWriterUtil.writeCommentText( writer, \"mailing list.\", 2 );\n        for ( Iterator it = project.getMailingLists().iterator(); it.hasNext(); )\n        {\n            MailingList mailingList = (MailingList) it.next();\n\n            if ( StringUtils.isNotEmpty( mailingList.getArchive() ) )\n            {\n                DoapUtil.writeRdfResourceElement( writer, \"mailing-list\", mailingList.getArchive() );\n            }\n            else\n            {\n                getLog().warn( \"No archive was specified for mailing list \" + mailingList.getName() );\n            }\n\n            if ( mailingList.getOtherArchives() != null )\n            {\n                for ( Iterator it2 = mailingList.getOtherArchives().iterator(); it2.hasNext(); )\n                {\n                    String otherArchive = (String) it2.next();\n\n                    if ( StringUtils.isNotEmpty( otherArchive ) )\n                    {\n                        DoapUtil.writeRdfResourceElement( writer, \"mailing-list\", otherArchive );\n                    }\n                    else\n                    {\n                        getLog().warn( \"No other archive was specified for mailing list \" + mailingList.getName() );\n                    }\n                }\n            }\n        }\n    }","commit_id":"79693dffe5affa39b5206855860bbadb7dc091e5","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Filter the developers/contributors role by the keys in {@link #DEVELOPER_OR_CONTRIBUTOR_ROLES_I18N}\n     *\n     * @param developersOrContributors list of <code>{@link Developer}/{@link Contributor}<\/code>\n     * @return a none null map with <code>maintainers<\/code>, <code>developers<\/code>, <code>documenters<\/code>,\n     * <code>translators<\/code>, <code>testers<\/code>, <code>helpers<\/code>, <code>unknowns<\/code> as keys and list of\n     * <code>{@link Developer}/{@link Contributor}<\/code> as value.\n     */\n    public static Map filterDevelopersOrContributorsByDoapRoles( List developersOrContributors )\n    {\n        Map returnMap = new HashMap( 7 );\n        returnMap.put( \"maintainers\", new ArrayList() );\n        returnMap.put( \"developers\", new ArrayList() );\n        returnMap.put( \"documenters\", new ArrayList() );\n        returnMap.put( \"translators\", new ArrayList() );\n        returnMap.put( \"testers\", new ArrayList() );\n        returnMap.put( \"helpers\", new ArrayList() );\n        returnMap.put( \"unknowns\", new ArrayList() );\n\n        if ( developersOrContributors == null || developersOrContributors.size() == 0 )\n        {\n            return returnMap;\n        }\n\n        for ( Iterator it = developersOrContributors.iterator(); it.hasNext(); )\n        {\n            Object obj = it.next();\n\n            List roles;\n            if ( Developer.class.isAssignableFrom( obj.getClass() ) )\n            {\n                Developer developer = (Developer) obj;\n                roles = developer.getRoles();\n            }\n            else\n            {\n                Contributor contributor = (Contributor) obj;\n                roles = contributor.getRoles();\n            }\n\n            if ( roles != null && roles.size() != 0 )\n            {\n                for ( Iterator it2 = roles.iterator(); it2.hasNext(); )\n                {\n                    String role = (String) it2.next();\n\n                    if ( role.toLowerCase().indexOf(\n                                                     DEVELOPER_OR_CONTRIBUTOR_ROLES_I18N.getString( \"doap.maintainer\" )\n                                                         .toLowerCase() ) != -1 )\n                    {\n                        ( (List) returnMap.get( \"maintainers\" ) ).add( obj );\n                    }\n                    else if ( role.toLowerCase().indexOf(\n                                                           DEVELOPER_OR_CONTRIBUTOR_ROLES_I18N\n                                                               .getString( \"doap.developer\" ).toLowerCase() ) != -1 )\n                    {\n                        ( (List) returnMap.get( \"developers\" ) ).add( obj );\n                    }\n                    else if ( role.toLowerCase().indexOf(\n                                                           DEVELOPER_OR_CONTRIBUTOR_ROLES_I18N\n                                                               .getString( \"doap.documenter\" ).toLowerCase() ) != -1 )\n                    {\n                        ( (List) returnMap.get( \"documenters\" ) ).add( obj );\n                    }\n                    else if ( role.toLowerCase().indexOf(\n                                                           DEVELOPER_OR_CONTRIBUTOR_ROLES_I18N\n                                                               .getString( \"doap.translator\" ).toLowerCase() ) != -1 )\n                    {\n                        ( (List) returnMap.get( \"translators\" ) ).add( obj );\n                    }\n                    else if ( role.toLowerCase().indexOf(\n                                                           DEVELOPER_OR_CONTRIBUTOR_ROLES_I18N\n                                                               .getString( \"doap.tester\" ).toLowerCase() ) != -1 )\n                    {\n                        ( (List) returnMap.get( \"testers\" ) ).add( obj );\n                    }\n                    else if ( role.toLowerCase().indexOf(\n                                                           DEVELOPER_OR_CONTRIBUTOR_ROLES_I18N\n                                                               .getString( \"doap.helper\" ).toLowerCase() ) != -1 )\n                    {\n                        ( (List) returnMap.get( \"helpers\" ) ).add( obj );\n                    }\n                    else\n                    {\n                        ( (List) returnMap.get( \"unknowns\" ) ).add( obj );\n                    }\n                }\n            }\n            else\n            {\n                ( (List) returnMap.get( \"unknowns\" ) ).add( obj );\n            }\n        }\n\n        return returnMap;\n    }","id":91415,"modified_method":"/**\n     * Filter the developers/contributors role by the keys in {@link #DEVELOPER_OR_CONTRIBUTOR_ROLES_I18N}\n     *\n     * @param developersOrContributors list of <code>{@link Developer}/{@link Contributor}<\/code>\n     * @return a none null map with <code>maintainers<\/code>, <code>developers<\/code>, <code>documenters<\/code>,\n     * <code>translators<\/code>, <code>testers<\/code>, <code>helpers<\/code>, <code>unknowns<\/code> as keys and list of\n     * <code>{@link Developer}/{@link Contributor}<\/code> as value.\n     */\n    public static Map filterDevelopersOrContributorsByDoapRoles( List developersOrContributors )\n    {\n        Map returnMap = new HashMap( 7 );\n        returnMap.put( \"maintainers\", new ArrayList() );\n        returnMap.put( \"developers\", new ArrayList() );\n        returnMap.put( \"documenters\", new ArrayList() );\n        returnMap.put( \"translators\", new ArrayList() );\n        returnMap.put( \"testers\", new ArrayList() );\n        returnMap.put( \"helpers\", new ArrayList() );\n        returnMap.put( \"unknowns\", new ArrayList() );\n\n        if ( developersOrContributors == null || developersOrContributors.isEmpty() )\n        {\n            return returnMap;\n        }\n\n        for ( Iterator it = developersOrContributors.iterator(); it.hasNext(); )\n        {\n            Object obj = it.next();\n\n            List roles;\n            if ( Developer.class.isAssignableFrom( obj.getClass() ) )\n            {\n                Developer developer = (Developer) obj;\n                roles = developer.getRoles();\n            }\n            else\n            {\n                Contributor contributor = (Contributor) obj;\n                roles = contributor.getRoles();\n            }\n\n            if ( roles != null && roles.size() != 0 )\n            {\n                for ( Iterator it2 = roles.iterator(); it2.hasNext(); )\n                {\n                    String role = (String) it2.next();\n\n                    if ( role.toLowerCase().indexOf(\n                                                     DEVELOPER_OR_CONTRIBUTOR_ROLES_I18N.getString( \"doap.maintainer\" )\n                                                         .toLowerCase() ) != -1 )\n                    {\n                        ( (List) returnMap.get( \"maintainers\" ) ).add( obj );\n                    }\n                    else if ( role.toLowerCase().indexOf(\n                                                           DEVELOPER_OR_CONTRIBUTOR_ROLES_I18N\n                                                               .getString( \"doap.developer\" ).toLowerCase() ) != -1 )\n                    {\n                        ( (List) returnMap.get( \"developers\" ) ).add( obj );\n                    }\n                    else if ( role.toLowerCase().indexOf(\n                                                           DEVELOPER_OR_CONTRIBUTOR_ROLES_I18N\n                                                               .getString( \"doap.documenter\" ).toLowerCase() ) != -1 )\n                    {\n                        ( (List) returnMap.get( \"documenters\" ) ).add( obj );\n                    }\n                    else if ( role.toLowerCase().indexOf(\n                                                           DEVELOPER_OR_CONTRIBUTOR_ROLES_I18N\n                                                               .getString( \"doap.translator\" ).toLowerCase() ) != -1 )\n                    {\n                        ( (List) returnMap.get( \"translators\" ) ).add( obj );\n                    }\n                    else if ( role.toLowerCase().indexOf(\n                                                           DEVELOPER_OR_CONTRIBUTOR_ROLES_I18N\n                                                               .getString( \"doap.tester\" ).toLowerCase() ) != -1 )\n                    {\n                        ( (List) returnMap.get( \"testers\" ) ).add( obj );\n                    }\n                    else if ( role.toLowerCase().indexOf(\n                                                           DEVELOPER_OR_CONTRIBUTOR_ROLES_I18N\n                                                               .getString( \"doap.helper\" ).toLowerCase() ) != -1 )\n                    {\n                        ( (List) returnMap.get( \"helpers\" ) ).add( obj );\n                    }\n                    else\n                    {\n                        ( (List) returnMap.get( \"unknowns\" ) ).add( obj );\n                    }\n                }\n            }\n            else\n            {\n                ( (List) returnMap.get( \"unknowns\" ) ).add( obj );\n            }\n        }\n\n        return returnMap;\n    }","commit_id":"79693dffe5affa39b5206855860bbadb7dc091e5","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Override\n        public Class<?> loadClass(String name) throws ClassNotFoundException {\n            for (ClassLoader loader : loaders) {\n                try {\n                    return loader.loadClass(name);\n                } catch(ClassNotFoundException ce){\n                    // do nothing, see if another loader can do this.\n                }\n            }\n            throw new ClassNotFoundException(name);\n        }","id":91416,"modified_method":"@Override\n        public Class<?> loadClass(String name) throws ClassNotFoundException {\n            Class<?> theClass = null;\n            try {\n                theClass = first.loadClass(name);\n            } catch(ClassNotFoundException ce){\n                theClass = second.loadClass(name);\n            }\n\n            return theClass;\n        }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public URL getResource(String name) {\n            URL resource = null;\n            for (ClassLoader loader : loaders) {\n                resource = loader.getResource(name);\n                if(resource != null){\n                    break;\n                }\n            }\n            return resource;\n        }","id":91417,"modified_method":"@Override\n        public URL getResource(String name) {\n            URL resource = null;\n            resource = first.getResource(name);\n            if(resource == null){\n                resource = second.getResource(name);\n            }\n            return resource;\n        }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ClassLoader get(Set<String> configuredModules) {\n        try {\n            List<ClassLoader> classLoaders = new ArrayList<>();\n            for (String module : configuredModules) {\n                if (module != null && !module.isEmpty()) {\n                    classLoaders.add(SecurityActions.getModuleClassLoader(moduleLoader, module));\n                }\n            }\n            classLoaders.add(WildFlySecurityManager.getCurrentContextClassLoaderPrivileged());\n            /**\n             * A Login Module can be in a custom user module.\n             * The local resources (such as users.properties) can be present in a web deployment,\n             * whose CL is available on the TCCL.\n             */\n            return new CombinedClassLoader(classLoaders.toArray(new ClassLoader[classLoaders.size()]));\n        } catch (ModuleLoadException e) {\n            throw SecurityLogger.ROOT_LOGGER.runtimeException(e);\n        }\n    }","id":91418,"modified_method":"public CombinedClassLoader(ClassLoader firstCL, ClassLoader secondCL){\n            this.first = firstCL;\n            this.second = secondCL;\n        }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public InputStream getResourceAsStream(String name) {\n            InputStream is = null;\n            for (ClassLoader loader : loaders) {\n                is = loader.getResourceAsStream(name);\n                if (is != null) {\n                    break;\n                }\n            }\n            return is;\n        }","id":91419,"modified_method":"@Override\n        public InputStream getResourceAsStream(String name) {\n            InputStream is = null;\n            is = first.getResourceAsStream(name);\n            if(is == null){\n                is = second.getResourceAsStream(name);\n            }\n            return is;\n        }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public Enumeration<URL> getResources(String name) throws IOException {\n            List<URL> combinedList = new ArrayList<URL>();\n            for (ClassLoader loader : loaders) {\n                combinedList.addAll(Collections.list(loader.getResources(name)));\n            }\n            return Collections.enumeration(combinedList);\n        }","id":91420,"modified_method":"@Override\n        public Enumeration<URL> getResources(String name) throws IOException {\n            List<URL> combinedList = new ArrayList<URL>();\n            combinedList.addAll(Collections.list(first.getResources(name)));\n            combinedList.addAll(Collections.list(second.getResources(name)));\n            return Collections.enumeration(combinedList);\n        }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"private boolean processAuthorization(OperationContext context, String securityDomain, ModelNode node, ApplicationPolicy applicationPolicy)\n            throws OperationFailedException {\n        node = peek(node, AUTHORIZATION, CLASSIC, POLICY_MODULE);\n        if (node == null) { return false; }\n\n        AuthorizationInfo authzInfo = new AuthorizationInfo(securityDomain);\n        for (Property moduleProperty : node.asPropertyList()) {\n            ModelNode module = moduleProperty.getValue();\n            String codeName = extractCode(context, module, ModulesMap.AUTHORIZATION_MAP);\n            String flag = LoginModuleResourceDefinition.FLAG.resolveModelAttribute(context, module).asString();\n            ControlFlag controlFlag = ControlFlag.valueOf(flag);\n            Map<String, Object> options = extractOptions(context, module);\n            AuthorizationModuleEntry authzModuleEntry = new AuthorizationModuleEntry(codeName, options);\n            authzModuleEntry.setControlFlag(controlFlag);\n            authzInfo.add(authzModuleEntry);\n\n            ModelNode moduleName = LoginModuleResourceDefinition.MODULE.resolveModelAttribute(context, module);\n            if (moduleName.isDefined() && !moduleName.asString().isEmpty()) {\n                authzInfo.addJBossModuleName(moduleName.asString());\n            } else {\n                authzInfo.addJBossModuleName(DEFAULT_MODULE);\n            }\n        }\n\n        applicationPolicy.setAuthorizationInfo(authzInfo);\n        return true;\n    }","id":91421,"modified_method":"private boolean processAuthorization(OperationContext context, String securityDomain, ModelNode node, ApplicationPolicy applicationPolicy)\n            throws OperationFailedException {\n        node = peek(node, AUTHORIZATION, CLASSIC, POLICY_MODULE);\n        if (node == null) { return false; }\n\n        AuthorizationInfo authzInfo = new AuthorizationInfo(securityDomain);\n        for (Property moduleProperty : node.asPropertyList()) {\n            ModelNode module = moduleProperty.getValue();\n            String codeName = extractCode(context, module, ModulesMap.AUTHORIZATION_MAP);\n            String flag = LoginModuleResourceDefinition.FLAG.resolveModelAttribute(context, module).asString();\n            ControlFlag controlFlag = ControlFlag.valueOf(flag);\n            Map<String, Object> options = extractOptions(context, module);\n            AuthorizationModuleEntry authzModuleEntry = new AuthorizationModuleEntry(codeName, options);\n            authzModuleEntry.setControlFlag(controlFlag);\n            authzInfo.add(authzModuleEntry);\n\n            ModelNode moduleName = LoginModuleResourceDefinition.MODULE.resolveModelAttribute(context, module);\n            if (moduleName.isDefined() && moduleName.asString().length() > 0) {\n                authzInfo.setJBossModuleName(moduleName.asString());\n            }\n        }\n\n        applicationPolicy.setAuthorizationInfo(authzInfo);\n        return true;\n    }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"private JSSESecurityDomain createJSSESecurityDomain(OperationContext context, String securityDomain, ModelNode node)\n            throws OperationFailedException {\n        node = peek(node, JSSE, CLASSIC);\n        if (node == null) { return null; }\n\n        final JBossJSSESecurityDomain jsseSecurityDomain = new JBossJSSESecurityDomain(securityDomain);\n\n\n        processKeyStore(context, node, KEYSTORE, new KeyStoreConfig() {\n            @Override\n            public void setKeyStorePassword(String value) throws Exception {\n                jsseSecurityDomain.setKeyStorePassword(value);\n            }\n\n            @Override\n            public void setKeyStoreType(String value) {\n                jsseSecurityDomain.setKeyStoreType(value);\n            }\n\n            @Override\n            public void setKeyStoreURL(String value) throws IOException {\n                jsseSecurityDomain.setKeyStoreURL(value);\n            }\n\n            @Override\n            public void setKeyStoreProvider(String value) {\n                jsseSecurityDomain.setKeyStoreProvider(value);\n            }\n\n            @Override\n            public void setKeyStoreProviderArgument(String value) {\n                jsseSecurityDomain.setKeyStoreProviderArgument(value);\n            }\n        });\n\n        processKeyStore(context, node, Constants.TRUSTSTORE, new KeyStoreConfig() {\n            @Override\n            public void setKeyStorePassword(String value) throws Exception {\n                jsseSecurityDomain.setTrustStorePassword(value);\n            }\n\n            @Override\n            public void setKeyStoreType(String value) {\n                jsseSecurityDomain.setTrustStoreType(value);\n            }\n\n            @Override\n            public void setKeyStoreURL(String value) throws IOException {\n                jsseSecurityDomain.setTrustStoreURL(value);\n            }\n\n            @Override\n            public void setKeyStoreProvider(String value) {\n                jsseSecurityDomain.setTrustStoreProvider(value);\n            }\n\n            @Override\n            public void setKeyStoreProviderArgument(String value) {\n                jsseSecurityDomain.setTrustStoreProviderArgument(value);\n            }\n        });\n\n        processKeyManager(context, node, Constants.KEY_MANAGER, new KeyManagerConfig() {\n            @Override\n            public void setKeyManagerFactoryAlgorithm(String value) {\n                jsseSecurityDomain.setKeyManagerFactoryAlgorithm(value);\n            }\n\n            @Override\n            public void setKeyManagerFactoryProvider(String value) {\n                jsseSecurityDomain.setKeyManagerFactoryProvider(value);\n            }\n        });\n\n        processKeyManager(context, node, Constants.TRUST_MANAGER, new KeyManagerConfig() {\n            @Override\n            public void setKeyManagerFactoryAlgorithm(String value) {\n                jsseSecurityDomain.setTrustManagerFactoryAlgorithm(value);\n            }\n\n            @Override\n            public void setKeyManagerFactoryProvider(String value) {\n                jsseSecurityDomain.setTrustManagerFactoryProvider(value);\n            }\n        });\n        String value;\n        if (node.hasDefined(CLIENT_ALIAS)) {\n            value = JSSEResourceDefinition.CLIENT_ALIAS.resolveModelAttribute(context, node).asString();\n            jsseSecurityDomain.setClientAlias(value);\n        }\n        if (node.hasDefined(SERVER_ALIAS)) {\n            value = JSSEResourceDefinition.SERVER_ALIAS.resolveModelAttribute(context, node).asString();\n            jsseSecurityDomain.setServerAlias(value);\n        }\n        if (node.hasDefined(CLIENT_AUTH)) {\n            boolean clientAuth = JSSEResourceDefinition.CLIENT_AUTH.resolveModelAttribute(context, node).asBoolean();\n            jsseSecurityDomain.setClientAuth(clientAuth);\n        }\n        if (node.hasDefined(SERVICE_AUTH_TOKEN)) {\n            value = JSSEResourceDefinition.SERVICE_AUTH_TOKEN.resolveModelAttribute(context, node).asString();\n            try {\n                jsseSecurityDomain.setServiceAuthToken(value);\n            } catch (Exception e) {\n                throw SecurityLogger.ROOT_LOGGER.runtimeException(e);\n            }\n        }\n        if (node.hasDefined(CIPHER_SUITES)) {\n            value = JSSEResourceDefinition.CIPHER_SUITES.resolveModelAttribute(context, node).asString();\n            jsseSecurityDomain.setCipherSuites(value);\n        }\n        if (node.hasDefined(PROTOCOLS)) {\n            value = JSSEResourceDefinition.PROTOCOLS.resolveModelAttribute(context, node).asString();\n            jsseSecurityDomain.setProtocols(value);\n        }\n        if (node.hasDefined(ADDITIONAL_PROPERTIES)) {\n            Properties properties = new Properties();\n            properties.putAll(JSSEResourceDefinition.ADDITIONAL_PROPERTIES.unwrap(context, node));\n            jsseSecurityDomain.setAdditionalProperties(properties);\n        }\n\n        return jsseSecurityDomain;\n    }","id":91422,"modified_method":"private JSSESecurityDomain createJSSESecurityDomain(OperationContext context, String securityDomain, ModelNode node)\n            throws OperationFailedException {\n        node = peek(node, JSSE, CLASSIC);\n        if (node == null) { return null; }\n\n        final JBossJSSESecurityDomain jsseSecurityDomain = new JBossJSSESecurityDomain(securityDomain);\n\n\n        processKeyStore(context, node, KEYSTORE, new KeyStoreConfig() {\n            public void setKeyStorePassword(String value) throws Exception {\n                jsseSecurityDomain.setKeyStorePassword(value);\n            }\n\n            public void setKeyStoreType(String value) {\n                jsseSecurityDomain.setKeyStoreType(value);\n            }\n\n            public void setKeyStoreURL(String value) throws IOException {\n                jsseSecurityDomain.setKeyStoreURL(value);\n            }\n\n            public void setKeyStoreProvider(String value) {\n                jsseSecurityDomain.setKeyStoreProvider(value);\n            }\n\n            public void setKeyStoreProviderArgument(String value) {\n                jsseSecurityDomain.setKeyStoreProviderArgument(value);\n            }\n        });\n\n        processKeyStore(context, node, Constants.TRUSTSTORE, new KeyStoreConfig() {\n            public void setKeyStorePassword(String value) throws Exception {\n                jsseSecurityDomain.setTrustStorePassword(value);\n            }\n\n            public void setKeyStoreType(String value) {\n                jsseSecurityDomain.setTrustStoreType(value);\n            }\n\n            public void setKeyStoreURL(String value) throws IOException {\n                jsseSecurityDomain.setTrustStoreURL(value);\n            }\n\n            public void setKeyStoreProvider(String value) {\n                jsseSecurityDomain.setTrustStoreProvider(value);\n            }\n\n            public void setKeyStoreProviderArgument(String value) {\n                jsseSecurityDomain.setTrustStoreProviderArgument(value);\n            }\n        });\n\n        processKeyManager(context, node, Constants.KEY_MANAGER, new KeyManagerConfig() {\n            public void setKeyManagerFactoryAlgorithm(String value) {\n                jsseSecurityDomain.setKeyManagerFactoryAlgorithm(value);\n            }\n\n            public void setKeyManagerFactoryProvider(String value) {\n                jsseSecurityDomain.setKeyManagerFactoryProvider(value);\n            }\n        });\n\n        processKeyManager(context, node, Constants.TRUST_MANAGER, new KeyManagerConfig() {\n            public void setKeyManagerFactoryAlgorithm(String value) {\n                jsseSecurityDomain.setTrustManagerFactoryAlgorithm(value);\n            }\n\n            public void setKeyManagerFactoryProvider(String value) {\n                jsseSecurityDomain.setTrustManagerFactoryProvider(value);\n            }\n        });\n        String value;\n        if (node.hasDefined(CLIENT_ALIAS)) {\n            value = JSSEResourceDefinition.CLIENT_ALIAS.resolveModelAttribute(context, node).asString();\n            jsseSecurityDomain.setClientAlias(value);\n        }\n        if (node.hasDefined(SERVER_ALIAS)) {\n            value = JSSEResourceDefinition.SERVER_ALIAS.resolveModelAttribute(context, node).asString();\n            jsseSecurityDomain.setServerAlias(value);\n        }\n        if (node.hasDefined(CLIENT_AUTH)) {\n            boolean clientAuth = JSSEResourceDefinition.CLIENT_AUTH.resolveModelAttribute(context, node).asBoolean();\n            jsseSecurityDomain.setClientAuth(clientAuth);\n        }\n        if (node.hasDefined(SERVICE_AUTH_TOKEN)) {\n            value = JSSEResourceDefinition.SERVICE_AUTH_TOKEN.resolveModelAttribute(context, node).asString();\n            try {\n                jsseSecurityDomain.setServiceAuthToken(value);\n            } catch (Exception e) {\n                throw SecurityLogger.ROOT_LOGGER.runtimeException(e);\n            }\n        }\n        if (node.hasDefined(CIPHER_SUITES)) {\n            value = JSSEResourceDefinition.CIPHER_SUITES.resolveModelAttribute(context, node).asString();\n            jsseSecurityDomain.setCipherSuites(value);\n        }\n        if (node.hasDefined(PROTOCOLS)) {\n            value = JSSEResourceDefinition.PROTOCOLS.resolveModelAttribute(context, node).asString();\n            jsseSecurityDomain.setProtocols(value);\n        }\n        if (node.hasDefined(ADDITIONAL_PROPERTIES)) {\n            Properties properties = new Properties();\n            properties.putAll(JSSEResourceDefinition.ADDITIONAL_PROPERTIES.unwrap(context, node));\n            jsseSecurityDomain.setAdditionalProperties(properties);\n        }\n\n        return jsseSecurityDomain;\n    }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processLoginModules(OperationContext context, ModelNode node, BaseAuthenticationInfo authInfo, LoginModuleContainer container)\n            throws OperationFailedException {\n        for (Property moduleProperty : node.asPropertyList()) {\n            ModelNode module = moduleProperty.getValue();\n            String codeName = extractCode(context, module, ModulesMap.AUTHENTICATION_MAP);\n            String flag = LoginModuleResourceDefinition.FLAG.resolveModelAttribute(context, module).asString();\n            LoginModuleControlFlag controlFlag = getControlFlag(flag);\n            Map<String, Object> options = extractOptions(context, module);\n            AppConfigurationEntry entry = new AppConfigurationEntry(codeName, controlFlag, options);\n            container.addAppConfigurationEntry(entry);\n            ModelNode moduleName = LoginModuleResourceDefinition.MODULE.resolveModelAttribute(context, module);\n            if (moduleName.isDefined() && !moduleName.asString().isEmpty()) {\n                authInfo.addJBossModuleName(moduleName.asString());\n            } else {\n                authInfo.addJBossModuleName(DEFAULT_MODULE);\n            }\n        }\n    }","id":91423,"modified_method":"private void processLoginModules(OperationContext context, ModelNode node, BaseAuthenticationInfo authInfo, LoginModuleContainer container)\n            throws OperationFailedException {\n        for (Property moduleProperty : node.asPropertyList()) {\n            ModelNode module = moduleProperty.getValue();\n            String codeName = extractCode(context, module, ModulesMap.AUTHENTICATION_MAP);\n            String flag = LoginModuleResourceDefinition.FLAG.resolveModelAttribute(context, module).asString();\n            LoginModuleControlFlag controlFlag = getControlFlag(flag);\n            Map<String, Object> options = extractOptions(context, module);\n            AppConfigurationEntry entry = new AppConfigurationEntry(codeName, controlFlag, options);\n            container.addAppConfigurationEntry(entry);\n            ModelNode moduleName = LoginModuleResourceDefinition.MODULE.resolveModelAttribute(context, module);\n            if (moduleName.isDefined() && moduleName.asString().length() > 0) {\n                authInfo.setJBossModuleName(moduleName.asString());\n            }\n        }\n    }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"private boolean processIdentityTrust(OperationContext context, String securityDomain, ModelNode node, ApplicationPolicy applicationPolicy)\n            throws OperationFailedException {\n        node = peek(node, IDENTITY_TRUST, CLASSIC, TRUST_MODULE);\n        if (node == null) { return false; }\n\n        IdentityTrustInfo identityTrustInfo = new IdentityTrustInfo(securityDomain);\n        for (Property moduleProperty : node.asPropertyList()) {\n            ModelNode module = moduleProperty.getValue();\n            String codeName = LoginModuleResourceDefinition.CODE.resolveModelAttribute(context, module).asString();\n            String flag = LoginModuleResourceDefinition.FLAG.resolveModelAttribute(context, module).asString();\n            ControlFlag controlFlag = ControlFlag.valueOf(flag);\n            Map<String, Object> options = extractOptions(context, module);\n            IdentityTrustModuleEntry entry = new IdentityTrustModuleEntry(codeName, options);\n            entry.setControlFlag(controlFlag);\n            identityTrustInfo.add(entry);\n\n            ModelNode moduleName = LoginModuleResourceDefinition.MODULE.resolveModelAttribute(context, module);\n            if (moduleName.isDefined() && !moduleName.asString().isEmpty()) {\n                identityTrustInfo.addJBossModuleName(moduleName.asString());\n            } else {\n                identityTrustInfo.addJBossModuleName(DEFAULT_MODULE);\n            }\n        }\n        applicationPolicy.setIdentityTrustInfo(identityTrustInfo);\n        return true;\n    }","id":91424,"modified_method":"private boolean processIdentityTrust(OperationContext context, String securityDomain, ModelNode node, ApplicationPolicy applicationPolicy)\n            throws OperationFailedException {\n        node = peek(node, IDENTITY_TRUST, CLASSIC, TRUST_MODULE);\n        if (node == null) { return false; }\n\n        IdentityTrustInfo identityTrustInfo = new IdentityTrustInfo(securityDomain);\n        for (Property moduleProperty : node.asPropertyList()) {\n            ModelNode module = moduleProperty.getValue();\n            String codeName = LoginModuleResourceDefinition.CODE.resolveModelAttribute(context, module).asString();\n            String flag = LoginModuleResourceDefinition.FLAG.resolveModelAttribute(context, module).asString();\n            ControlFlag controlFlag = ControlFlag.valueOf(flag);\n            Map<String, Object> options = extractOptions(context, module);\n            IdentityTrustModuleEntry entry = new IdentityTrustModuleEntry(codeName, options);\n            entry.setControlFlag(controlFlag);\n            identityTrustInfo.add(entry);\n\n            ModelNode moduleName = LoginModuleResourceDefinition.MODULE.resolveModelAttribute(context, module);\n            if (moduleName.isDefined() && moduleName.asString().length() > 0) {\n                identityTrustInfo.setJBossModuleName(moduleName.asString());\n            }\n        }\n        applicationPolicy.setIdentityTrustInfo(identityTrustInfo);\n        return true;\n    }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"private boolean processAudit(OperationContext context, String securityDomain, ModelNode node, ApplicationPolicy applicationPolicy)\n            throws OperationFailedException {\n        node = peek(node, AUDIT, CLASSIC, PROVIDER_MODULE);\n        if (node == null) { return false; }\n\n        AuditInfo auditInfo = new AuditInfo(securityDomain);\n        for (Property moduleProperty : node.asPropertyList()) {\n            ModelNode module = moduleProperty.getValue();\n            String codeName = LoginModuleResourceDefinition.CODE.resolveModelAttribute(context, module).asString();\n            Map<String, Object> options = extractOptions(context, module);\n            AuditProviderEntry entry = new AuditProviderEntry(codeName, options);\n            auditInfo.add(entry);\n\n            ModelNode moduleName = LoginModuleResourceDefinition.MODULE.resolveModelAttribute(context, module);\n            if (moduleName.isDefined() && !moduleName.asString().isEmpty()) {\n                auditInfo.addJBossModuleName(moduleName.asString());\n            } else {\n                auditInfo.addJBossModuleName(DEFAULT_MODULE);\n            }\n        }\n        applicationPolicy.setAuditInfo(auditInfo);\n        return true;\n    }","id":91425,"modified_method":"private boolean processAudit(OperationContext context, String securityDomain, ModelNode node, ApplicationPolicy applicationPolicy)\n            throws OperationFailedException {\n        node = peek(node, AUDIT, CLASSIC, PROVIDER_MODULE);\n        if (node == null) { return false; }\n\n        AuditInfo auditInfo = new AuditInfo(securityDomain);\n        for (Property moduleProperty : node.asPropertyList()) {\n            ModelNode module = moduleProperty.getValue();\n            String codeName = LoginModuleResourceDefinition.CODE.resolveModelAttribute(context, module).asString();\n            Map<String, Object> options = extractOptions(context, module);\n            AuditProviderEntry entry = new AuditProviderEntry(codeName, options);\n            auditInfo.add(entry);\n\n            ModelNode moduleName = LoginModuleResourceDefinition.MODULE.resolveModelAttribute(context, module);\n            if (moduleName.isDefined() && moduleName.asString().length() > 0) {\n                auditInfo.setJBossModuleName(moduleName.asString());\n            }\n        }\n        applicationPolicy.setAuditInfo(auditInfo);\n        return true;\n    }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        for (AttributeDefinition attribute : SecurityDomainResourceDefinition.ATTRIBUTES) {\n            attribute.validateAndSet(operation, model);\n        }\n    }","id":91426,"modified_method":"protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        SecurityDomainResourceDefinition.CACHE_TYPE.validateAndSet(operation, model);\n    }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"private boolean processMapping(OperationContext context, String securityDomain, ModelNode node, ApplicationPolicy applicationPolicy)\n            throws OperationFailedException {\n        node = peek(node, MAPPING, CLASSIC, MAPPING_MODULE);\n        if (node == null) { return false; }\n\n        for (Property moduleProperty : node.asPropertyList()) {\n            ModelNode module = moduleProperty.getValue();\n            MappingInfo mappingInfo = new MappingInfo(securityDomain);\n            String codeName = extractCode(context, module, ModulesMap.MAPPING_MAP);\n\n            String mappingType;\n            if (module.hasDefined(TYPE)) {\n                mappingType = MappingModuleDefinition.TYPE.resolveModelAttribute(context, module).asString();\n            } else {\n                mappingType = MappingType.ROLE.toString();\n            }\n\n            Map<String, Object> options = extractOptions(context, module);\n            MappingModuleEntry entry = new MappingModuleEntry(codeName, options, mappingType);\n            mappingInfo.add(entry);\n            applicationPolicy.setMappingInfo(mappingType, mappingInfo);\n\n            ModelNode moduleName = LoginModuleResourceDefinition.MODULE.resolveModelAttribute(context, module);\n            if (moduleName.isDefined() && !moduleName.asString().isEmpty()) {\n                mappingInfo.addJBossModuleName(moduleName.asString());\n            } else {\n                mappingInfo.addJBossModuleName(DEFAULT_MODULE);\n            }\n        }\n\n        return true;\n    }","id":91427,"modified_method":"private boolean processMapping(OperationContext context, String securityDomain, ModelNode node, ApplicationPolicy applicationPolicy)\n            throws OperationFailedException {\n        node = peek(node, MAPPING, CLASSIC, MAPPING_MODULE);\n        if (node == null) { return false; }\n\n        for (Property moduleProperty : node.asPropertyList()) {\n            ModelNode module = moduleProperty.getValue();\n            MappingInfo mappingInfo = new MappingInfo(securityDomain);\n            String codeName = extractCode(context, module, ModulesMap.MAPPING_MAP);\n\n            String mappingType;\n            if (module.hasDefined(TYPE)) {\n                mappingType = MappingModuleDefinition.TYPE.resolveModelAttribute(context, module).asString();\n            } else {\n                mappingType = MappingType.ROLE.toString();\n            }\n\n            Map<String, Object> options = extractOptions(context, module);\n            MappingModuleEntry entry = new MappingModuleEntry(codeName, options, mappingType);\n            mappingInfo.add(entry);\n            applicationPolicy.setMappingInfo(mappingType, mappingInfo);\n\n            ModelNode moduleName = LoginModuleResourceDefinition.MODULE.resolveModelAttribute(context, module);\n            if (moduleName.isDefined() && moduleName.asString().length() > 0) {\n                mappingInfo.setJBossModuleName(moduleName.asString());\n            }\n        }\n\n        return true;\n    }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"private boolean processClassicAuth(OperationContext context, String securityDomain, ModelNode node, ApplicationPolicy applicationPolicy)\n            throws OperationFailedException {\n        node = peek(node, AUTHENTICATION, CLASSIC);\n        if (node == null) { return false; }\n\n        final AuthenticationInfo authenticationInfo = new AuthenticationInfo(securityDomain);\n        if (node.hasDefined(Constants.LOGIN_MODULE)) {\n            processLoginModules(context, node.get(LOGIN_MODULE), authenticationInfo, new LoginModuleContainer() {\n                @Override\n                public void addAppConfigurationEntry(AppConfigurationEntry entry) {\n                    authenticationInfo.add(entry);\n                }\n            });\n        }\n        //Check for module\n        applicationPolicy.setAuthenticationInfo(authenticationInfo);\n\n        return true;\n    }","id":91428,"modified_method":"private boolean processClassicAuth(OperationContext context, String securityDomain, ModelNode node, ApplicationPolicy applicationPolicy)\n            throws OperationFailedException {\n        node = peek(node, AUTHENTICATION, CLASSIC);\n        if (node == null) { return false; }\n\n        final AuthenticationInfo authenticationInfo = new AuthenticationInfo(securityDomain);\n        if (node.hasDefined(Constants.LOGIN_MODULE)) {\n            processLoginModules(context, node.get(LOGIN_MODULE), authenticationInfo, new LoginModuleContainer() {\n                public void addAppConfigurationEntry(AppConfigurationEntry entry) {\n                    authenticationInfo.add(entry);\n                }\n            });\n        }\n        //Check for module\n        applicationPolicy.setAuthenticationInfo(authenticationInfo);\n\n        return true;\n    }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"private boolean processACL(OperationContext context, String securityDomain, ModelNode node, ApplicationPolicy applicationPolicy)\n            throws OperationFailedException {\n        node = peek(node, ACL, CLASSIC, ACL_MODULE);\n        if (node == null) { return false; }\n\n        ACLInfo aclInfo = new ACLInfo(securityDomain);\n        for (Property moduleProperty : node.asPropertyList()) {\n            ModelNode module = moduleProperty.getValue();\n            String codeName = LoginModuleResourceDefinition.CODE.resolveModelAttribute(context, module).asString();\n            String flag = LoginModuleResourceDefinition.FLAG.resolveModelAttribute(context, module).asString();\n            ControlFlag controlFlag = ControlFlag.valueOf(flag);\n            Map<String, Object> options = extractOptions(context, module);\n            ACLProviderEntry entry = new ACLProviderEntry(codeName, options);\n            entry.setControlFlag(controlFlag);\n            aclInfo.add(entry);\n\n            ModelNode moduleName = LoginModuleResourceDefinition.MODULE.resolveModelAttribute(context, module);\n            if (moduleName.isDefined() && !moduleName.asString().isEmpty()) {\n                aclInfo.addJBossModuleName(moduleName.asString());\n            } else {\n                aclInfo.addJBossModuleName(DEFAULT_MODULE);\n            }\n\n        }\n        applicationPolicy.setAclInfo(aclInfo);\n        return true;\n    }","id":91429,"modified_method":"private boolean processACL(OperationContext context, String securityDomain, ModelNode node, ApplicationPolicy applicationPolicy)\n            throws OperationFailedException {\n        node = peek(node, ACL, CLASSIC, ACL_MODULE);\n        if (node == null) { return false; }\n\n        ACLInfo aclInfo = new ACLInfo(securityDomain);\n        for (Property moduleProperty : node.asPropertyList()) {\n            ModelNode module = moduleProperty.getValue();\n            String codeName = LoginModuleResourceDefinition.CODE.resolveModelAttribute(context, module).asString();\n            String flag = LoginModuleResourceDefinition.FLAG.resolveModelAttribute(context, module).asString();\n            ControlFlag controlFlag = ControlFlag.valueOf(flag);\n            Map<String, Object> options = extractOptions(context, module);\n            ACLProviderEntry entry = new ACLProviderEntry(codeName, options);\n            entry.setControlFlag(controlFlag);\n            aclInfo.add(entry);\n\n            ModelNode moduleName = LoginModuleResourceDefinition.MODULE.resolveModelAttribute(context, module);\n            if (moduleName.isDefined() && moduleName.asString().length() > 0) {\n                aclInfo.setJBossModuleName(moduleName.asString());\n            }\n\n        }\n        applicationPolicy.setAclInfo(aclInfo);\n        return true;\n    }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"private boolean processJASPIAuth(OperationContext context, String securityDomain, ModelNode node, ApplicationPolicy applicationPolicy)\n            throws OperationFailedException {\n        node = peek(node, AUTHENTICATION, JASPI);\n        if (node == null) { return false; }\n\n        JASPIAuthenticationInfo authenticationInfo = new JASPIAuthenticationInfo(securityDomain);\n        Map<String, LoginModuleStackHolder> holders = new HashMap<String, LoginModuleStackHolder>();\n        if(node.hasDefined(LOGIN_MODULE_STACK)){\n            List<Property> stacks = node.get(LOGIN_MODULE_STACK).asPropertyList();\n            for (Property stack : stacks) {\n                String name = stack.getName();\n                ModelNode stackNode = stack.getValue();\n\n                final LoginModuleStackHolder holder = new LoginModuleStackHolder(name, null);\n                holders.put(name, holder);\n                authenticationInfo.add(holder);\n                if (stackNode.hasDefined(LOGIN_MODULE)) {\n                    processLoginModules(context, stackNode.get(LOGIN_MODULE), authenticationInfo, new LoginModuleContainer() {\n                        @Override\n                        public void addAppConfigurationEntry(AppConfigurationEntry entry) {\n                            holder.addAppConfigurationEntry(entry);\n                        }\n                    });\n                }\n            }\n        }\n        for (Property moduleProperty : node.get(AUTH_MODULE).asPropertyList()) {\n            ModelNode authModule = moduleProperty.getValue();\n            String code = extractCode(context, authModule, ModulesMap.AUTHENTICATION_MAP);\n            String loginStackRef = null;\n            if (authModule.hasDefined(LOGIN_MODULE_STACK_REF)) {\n                loginStackRef = JASPIMappingModuleDefinition.LOGIN_MODULE_STACK_REF.resolveModelAttribute(context, authModule).asString();\n            }\n            Map<String, Object> options = extractOptions(context, authModule);\n            AuthModuleEntry entry = new AuthModuleEntry(code, options, loginStackRef);\n            if (authModule.hasDefined(FLAG)) {\n                String flag = LoginModuleResourceDefinition.FLAG.resolveModelAttribute(context, authModule).asString();\n                entry.setControlFlag(ControlFlag.valueOf(flag));\n            }\n            if (loginStackRef != null) {\n                if (!holders.containsKey(loginStackRef)) {\n                    throw SecurityLogger.ROOT_LOGGER.loginModuleStackIllegalArgument(loginStackRef);\n                }\n                entry.setLoginModuleStackHolder(holders.get(loginStackRef));\n            }\n            authenticationInfo.add(entry);\n\n            ModelNode moduleName = LoginModuleResourceDefinition.MODULE.resolveModelAttribute(context, authModule);\n            if (moduleName.isDefined() && !moduleName.asString().isEmpty()) {\n                authenticationInfo.addJBossModuleName(moduleName.asString());\n            } else {\n                authenticationInfo.addJBossModuleName(DEFAULT_MODULE);\n            }\n        }\n        applicationPolicy.setAuthenticationInfo(authenticationInfo);\n        return true;\n    }","id":91430,"modified_method":"private boolean processJASPIAuth(OperationContext context, String securityDomain, ModelNode node, ApplicationPolicy applicationPolicy)\n            throws OperationFailedException {\n        node = peek(node, AUTHENTICATION, JASPI);\n        if (node == null) { return false; }\n\n        JASPIAuthenticationInfo authenticationInfo = new JASPIAuthenticationInfo(securityDomain);\n        Map<String, LoginModuleStackHolder> holders = new HashMap<String, LoginModuleStackHolder>();\n        if(node.hasDefined(LOGIN_MODULE_STACK)){\n            List<Property> stacks = node.get(LOGIN_MODULE_STACK).asPropertyList();\n            for (Property stack : stacks) {\n                String name = stack.getName();\n                ModelNode stackNode = stack.getValue();\n\n                final LoginModuleStackHolder holder = new LoginModuleStackHolder(name, null);\n                holders.put(name, holder);\n                authenticationInfo.add(holder);\n                if (stackNode.hasDefined(LOGIN_MODULE)) {\n                    processLoginModules(context, stackNode.get(LOGIN_MODULE), authenticationInfo, new LoginModuleContainer() {\n                        public void addAppConfigurationEntry(AppConfigurationEntry entry) {\n                            holder.addAppConfigurationEntry(entry);\n                        }\n                    });\n                }\n            }\n        }\n        for (Property moduleProperty : node.get(AUTH_MODULE).asPropertyList()) {\n            ModelNode authModule = moduleProperty.getValue();\n            String code = extractCode(context, authModule, ModulesMap.AUTHENTICATION_MAP);\n            String loginStackRef = null;\n            if (authModule.hasDefined(LOGIN_MODULE_STACK_REF)) {\n                loginStackRef = JASPIMappingModuleDefinition.LOGIN_MODULE_STACK_REF.resolveModelAttribute(context, authModule).asString();\n            }\n            Map<String, Object> options = extractOptions(context, authModule);\n            AuthModuleEntry entry = new AuthModuleEntry(code, options, loginStackRef);\n            if (authModule.hasDefined(FLAG)) {\n                String flag = LoginModuleResourceDefinition.FLAG.resolveModelAttribute(context, authModule).asString();\n                entry.setControlFlag(ControlFlag.valueOf(flag));\n            }\n            if (loginStackRef != null) {\n                if (!holders.containsKey(loginStackRef)) {\n                    throw SecurityLogger.ROOT_LOGGER.loginModuleStackIllegalArgument(loginStackRef);\n                }\n                entry.setLoginModuleStackHolder(holders.get(loginStackRef));\n            }\n            authenticationInfo.add(entry);\n\n            ModelNode moduleName = LoginModuleResourceDefinition.MODULE.resolveModelAttribute(context, authModule);\n            if (moduleName.isDefined() && moduleName.asString().length() > 0) {\n                authenticationInfo.setJBossModuleName(moduleName.asString());\n            }\n        }\n        applicationPolicy.setAuthenticationInfo(authenticationInfo);\n        return true;\n    }","commit_id":"34822760d5c37f4cade5e1bb3f6147b6cda083cd","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** This looks to see whether any of the children is a preterminal headed by a word\n   *  which is within the set verbalSet (which in practice is either\n   *  auxiliary or copula verbs).  It only returns true if it's a preterminal head, since\n   *  you don't want to pick things up in phrasal daughters.  That is an error.\n   *\n   * @param kids The child trees\n   * @param verbalSet The set of words\n   * @return Returns true if one of the child trees is a preterminal verb headed\n   *      by a word in verbalSet\n   */\n  private boolean hasVerbalAuxiliary(Tree[] kids, Set<String> verbalSet) {\n    if (DEBUG) {\n      System.err.println(\"Checking for verbal auxiliary\");\n    }\n    for (Tree kid : kids) {\n      if (DEBUG) {\n        System.err.println(\"  checking in \" + kid);\n      }\n      if (kid.isPreTerminal()) {\n        Label kidLabel = kid.label();\n        String tag = null;\n        if (kidLabel instanceof HasTag) {\n          tag = ((HasTag) kidLabel).tag();\n        }\n        if (tag == null) {\n          tag = kid.value();\n        }\n        Label wordLabel = kid.firstChild().label();\n        String word = null;\n        if (wordLabel instanceof HasWord) {\n          word = ((HasWord) wordLabel).word();\n        }\n        if (word == null) {\n          word = wordLabel.value();\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Checking \" + kid.value() + \" head is \" + word + '/' + tag);\n        }\n        String lcWord = word.toLowerCase();\n        if (verbalTags.contains(tag) && verbalSet.contains(lcWord)) {\n          if (DEBUG) {\n            System.err.println(\"hasVerbalAuxiliary returns true\");\n          }\n          return true;\n        }\n      }\n    }\n    if (DEBUG) {\n      System.err.println(\"hasVerbalAuxiliary returns false\");\n    }\n    return false;\n  }","id":91431,"modified_method":"/** This looks to see whether any of the children is a preterminal headed by a word\n   *  which is within the set verbalSet (which in practice is either\n   *  auxiliary or copula verbs).  It only returns true if it's a preterminal head, since\n   *  you don't want to pick things up in phrasal daughters.  That is an error.\n   *\n   * @param kids The child trees\n   * @param verbalSet The set of words\n   * @return Returns true if one of the child trees is a preterminal verb headed\n   *      by a word in verbalSet\n   */\n  private boolean hasVerbalAuxiliary(Tree[] kids, Set<String> verbalSet) {\n    if (DEBUG) {\n      System.err.println(\"Checking for verbal auxiliary\");\n    }\n    for (Tree kid : kids) {\n      if (DEBUG) {\n        System.err.println(\"  checking in \" + kid);\n      }\n      if (isVerbalAuxiliary(kid, verbalSet)) {\n        return true;\n      }\n    }\n    if (DEBUG) {\n      System.err.println(\"hasVerbalAuxiliary returns false\");\n    }\n    return false;\n  }","commit_id":"13b580bacf3b50c7468ee2f90873816370c41e2c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Reinserted so samples.GetSubcats compiles ... should rework if\n   * this is going to stay.\n   *\n   * @param t A tree to examine for being an auxiliary.\n   * @return Whether it is a verbal auxiliary (be, do, have, get)\n   */\n  public boolean isVerbalAuxiliary(Tree t) {\n    Tree[] trees = { t };\n    return hasVerbalAuxiliary(trees, verbalAuxiliaries);\n  }","id":91432,"modified_method":"/**\n   * Returns true if this tree is a preterminal that is a verbal auxiliary.\n   *\n   * @param t A tree to examine for being an auxiliary.\n   * @return Whether it is a verbal auxiliary (be, do, have, get)\n   */\n  public boolean isVerbalAuxiliary(Tree t) {\n    return isVerbalAuxiliary(t, verbalAuxiliaries);\n  }","commit_id":"13b580bacf3b50c7468ee2f90873816370c41e2c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** Create a SemanticHeadFinder.\n   *\n   * @param tlp The TreebankLanguagePack, used by the superclass to get basic\n   *     category of constituents.\n   * @param cop If true, a copular verb (be, seem, appear, stay, remain, resemble, become)\n   *     is not treated as head when it has an AdjP or NP complement.  If false,\n   *     a copula verb is still always treated as a head.  But it will still\n   *     be treated as an auxiliary in periphrastic tenses with a VP complement.\n   */\n  public SemanticHeadFinder(TreebankLanguagePack tlp, boolean cop) {\n    super(tlp);\n    ruleChanges();\n\n    // make a distinction between auxiliaries and copula verbs to\n    // get the NP has semantic head in sentences like \"Bill is an honest man\".  (Added \"sha\" for \"shan't\" May 2009\n    verbalAuxiliaries = Generics.newHashSet();\n    verbalAuxiliaries.addAll(Arrays.asList(auxiliaries));\n\n    passiveAuxiliaries = Generics.newHashSet();\n    passiveAuxiliaries.addAll(Arrays.asList(beGetVerbs));\n\n    //copula verbs having an NP complement\n    copulars = Generics.newHashSet();\n    if (cop) {\n      copulars.addAll(Arrays.asList(copulaVerbs));\n    } // a few times the apostrophe is missing on \"'s\"\n\n    verbalTags = Generics.newHashSet();\n    // include Charniak tags so can do BLLIP right\n    verbalTags.addAll(Arrays.asList(verbTags));\n\n  }","id":91433,"modified_method":"/** Create a SemanticHeadFinder.\n   *\n   * @param tlp The TreebankLanguagePack, used by the superclass to get basic\n   *     category of constituents.\n   * @param cop If true, a copular verb (be, seem, appear, stay, remain, resemble, become)\n   *     is not treated as head when it has an AdjP or NP complement.  If false,\n   *     a copula verb is still always treated as a head.  But it will still\n   *     be treated as an auxiliary in periphrastic tenses with a VP complement.\n   */\n  public SemanticHeadFinder(TreebankLanguagePack tlp, boolean cop) {\n    super(tlp);\n    ruleChanges();\n\n    // make a distinction between auxiliaries and copula verbs to\n    // get the NP has semantic head in sentences like \"Bill is an honest man\".  (Added \"sha\" for \"shan't\" May 2009\n    verbalAuxiliaries = Generics.newHashSet(Arrays.asList(auxiliaries));\n\n    passiveAuxiliaries = Generics.newHashSet(Arrays.asList(beGetVerbs));\n\n    //copula verbs having an NP complement\n    copulars = Generics.newHashSet();\n    if (cop) {\n      copulars.addAll(Arrays.asList(copulaVerbs));\n    }\n\n    verbalTags = Generics.newHashSet(Arrays.asList(verbTags));\n    unambiguousAuxiliaryTags = Generics.newHashSet(Arrays.asList(unambiguousAuxTags));\n\n\n  }","commit_id":"13b580bacf3b50c7468ee2f90873816370c41e2c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Determine which daughter of the current parse tree is the\n   * head.  It assumes that the daughters already have had their\n   * heads determined.  Uses special rule for VP heads\n   *\n   * @param t The parse tree to examine the daughters of.\n   *          This is assumed to never be a leaf\n   * @return The parse tree that is the head\n   */\n  @Override\n  protected Tree determineNonTrivialHead(Tree t, Tree parent) {\n    String motherCat = tlp.basicCategory(t.label().value());\n\n    if (DEBUG) {\n      System.err.println(\"At \" + motherCat + \", my parent is \" + parent);\n    }\n\n    // do VPs with auxiliary as special case\n    if ((motherCat.equals(\"VP\") || motherCat.equals(\"SQ\") || motherCat.equals(\"SINV\"))) {\n      Tree[] kids = t.children();\n      // try to find if there is an auxiliary verb\n\n      if (DEBUG) {\n        System.err.println(\"Semantic head finder: at VP\");\n        System.err.println(\"Class is \" + t.getClass().getName());\n        t.pennPrint(System.err);\n        //System.err.println(\"hasVerbalAuxiliary = \" + hasVerbalAuxiliary(kids, verbalAuxiliaries));\n      }\n\n      // looks for auxiliaries\n      if (hasVerbalAuxiliary(kids, verbalAuxiliaries) || hasPassiveProgressiveAuxiliary(kids, passiveAuxiliaries)) {\n        // String[] how = new String[] {\"left\", \"VP\", \"ADJP\", \"NP\"};\n        // Including NP etc seems okay for copular sentences but is\n        // problematic for other auxiliaries, like 'he has an answer'\n        // But maybe doing ADJP is fine!\n        String[] how = { \"left\", \"VP\", \"ADJP\" };\n        Tree pti = traverseLocate(kids, how, false);\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 1) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        } else {\n          // System.err.println(\"------\");\n          // System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n          // t.pennPrint(System.err);\n          // System.err.println(\"------\");\n        }\n      }\n\n      // looks for copular verbs\n      if (hasVerbalAuxiliary(kids, copulars) && ! isExistential(t, parent) && ! isWHQ(t, parent)) {\n        String[] how;\n        if (motherCat.equals(\"SQ\")) {\n          how = new String[]{\"right\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        } else {\n          how = new String[]{\"left\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        }\n        Tree pti = traverseLocate(kids, how, false);\n        // don't allow a temporal to become head\n        if (pti != null && pti.label() != null && pti.label().value().contains(\"-TMP\")) {\n          pti = null;\n        }\n        // In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative)\n        if (motherCat.equals(\"SQ\") && pti != null && pti.label() != null && pti.label().value().startsWith(\"NP\")) {\n            boolean foundAnotherNp = false;\n            for (Tree kid : kids) {\n              if (kid == pti) {\n                break;\n              } else if (kid.label() != null && kid.label().value().startsWith(\"NP\")) {\n                foundAnotherNp = true;\n                break;\n              }\n            }\n          if ( ! foundAnotherNp) {\n            pti = null;\n          }\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 2) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        } else {\n          if (DEBUG) {\n            System.err.println(\"------\");\n            System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n            t.pennPrint(System.err);\n            System.err.println(\"------\");\n          }\n        }\n      }\n    }\n\n    Tree hd = super.determineNonTrivialHead(t, parent);\n\n    // Heuristically repair punctuation heads\n    Tree[] hdChildren = hd.children();\n    if (hdChildren != null && hdChildren.length > 0 &&\n        hdChildren[0].isLeaf()) {\n      if (tlp.isPunctuationWord(hdChildren[0].label().value())) {\n         Tree[] tChildren = t.children();\n         if (DEBUG) {\n           System.err.printf(\"head is punct: %s\\n\", hdChildren[0].label());\n         }\n         for (int i = tChildren.length - 1; i >= 0; i--) {\n           if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) {\n             hd = tChildren[i];\n             if (DEBUG) {\n               System.err.printf(\"New head: %s %s\", hd.label(), hd.children()[0].label());\n             }\n             break;\n           }\n         }\n      }\n    }\n\n    if (DEBUG) {\n      System.err.println(\"Determined head (case 3) for \" + t.value() + \" is: \" + hd);\n    }\n    return hd;\n  }","id":91434,"modified_method":"/**\n   * Determine which daughter of the current parse tree is the\n   * head.  It assumes that the daughters already have had their\n   * heads determined.  Uses special rule for VP heads\n   *\n   * @param t The parse tree to examine the daughters of.\n   *          This is assumed to never be a leaf\n   * @return The parse tree that is the head\n   */\n  @Override\n  protected Tree determineNonTrivialHead(Tree t, Tree parent) {\n    String motherCat = tlp.basicCategory(t.label().value());\n\n    if (DEBUG) {\n      System.err.println(\"At \" + motherCat + \", my parent is \" + parent);\n    }\n\n    // do VPs with auxiliary as special case\n    if ((motherCat.equals(\"VP\") || motherCat.equals(\"SQ\") || motherCat.equals(\"SINV\"))) {\n      Tree[] kids = t.children();\n      // try to find if there is an auxiliary verb\n\n      if (DEBUG) {\n        System.err.println(\"Semantic head finder: at VP\");\n        System.err.println(\"Class is \" + t.getClass().getName());\n        t.pennPrint(System.err);\n        //System.err.println(\"hasVerbalAuxiliary = \" + hasVerbalAuxiliary(kids, verbalAuxiliaries));\n      }\n\n      // looks for auxiliaries\n      if (hasVerbalAuxiliary(kids, verbalAuxiliaries) || hasPassiveProgressiveAuxiliary(kids)) {\n        // String[] how = new String[] {\"left\", \"VP\", \"ADJP\", \"NP\"};\n        // Including NP etc seems okay for copular sentences but is\n        // problematic for other auxiliaries, like 'he has an answer'\n        // But maybe doing ADJP is fine!\n        String[] how = { \"left\", \"VP\", \"ADJP\" };\n        Tree pti = traverseLocate(kids, how, false);\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 1) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        // } else {\n          // System.err.println(\"------\");\n          // System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n          // t.pennPrint(System.err);\n          // System.err.println(\"------\");\n        }\n      }\n\n      // looks for copular verbs\n      if (hasVerbalAuxiliary(kids, copulars) && ! isExistential(t, parent) && ! isWHQ(t, parent)) {\n        String[] how;\n        if (motherCat.equals(\"SQ\")) {\n          how = new String[]{\"right\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        } else {\n          how = new String[]{\"left\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        }\n        Tree pti = traverseLocate(kids, how, false);\n        // don't allow a temporal to become head\n        if (pti != null && pti.label() != null && pti.label().value().contains(\"-TMP\")) {\n          pti = null;\n        }\n        // In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative)\n        if (motherCat.equals(\"SQ\") && pti != null && pti.label() != null && pti.label().value().startsWith(\"NP\")) {\n            boolean foundAnotherNp = false;\n            for (Tree kid : kids) {\n              if (kid == pti) {\n                break;\n              } else if (kid.label() != null && kid.label().value().startsWith(\"NP\")) {\n                foundAnotherNp = true;\n                break;\n              }\n            }\n          if ( ! foundAnotherNp) {\n            pti = null;\n          }\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 2) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        } else {\n          if (DEBUG) {\n            System.err.println(\"------\");\n            System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n            t.pennPrint(System.err);\n            System.err.println(\"------\");\n          }\n        }\n      }\n    }\n\n    Tree hd = super.determineNonTrivialHead(t, parent);\n\n    // Heuristically repair punctuation heads\n    Tree[] hdChildren = hd.children();\n    if (hdChildren != null && hdChildren.length > 0 &&\n        hdChildren[0].isLeaf()) {\n      if (tlp.isPunctuationWord(hdChildren[0].label().value())) {\n         Tree[] tChildren = t.children();\n         if (DEBUG) {\n           System.err.printf(\"head is punct: %s\\n\", hdChildren[0].label());\n         }\n         for (int i = tChildren.length - 1; i >= 0; i--) {\n           if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) {\n             hd = tChildren[i];\n             if (DEBUG) {\n               System.err.printf(\"New head: %s %s\", hd.label(), hd.children()[0].label());\n             }\n             break;\n           }\n         }\n      }\n    }\n\n    if (DEBUG) {\n      System.err.println(\"Determined head (case 3) for \" + t.value() + \" is: \" + hd);\n    }\n    return hd;\n  }","commit_id":"13b580bacf3b50c7468ee2f90873816370c41e2c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private boolean hasPassiveProgressiveAuxiliary(Tree[] kids, Set<String> verbalSet) {\n    if (DEBUG) {\n      System.err.println(\"Checking for passive/progressive auxiliary\");\n    }\n    boolean foundPassiveVP = false;\n    boolean foundPassiveAux = false;\n    for (Tree kid : kids) {\n      if (DEBUG) {\n        System.err.println(\"  checking in \" + kid);\n      }\n      if (kid.isPreTerminal()) {\n        Label kidLabel = kid.label();\n        String tag = null;\n        if (kidLabel instanceof HasTag) {\n          tag = ((HasTag) kidLabel).tag();\n        }\n        if (tag == null) {\n          tag = kid.value();\n        }\n        Label wordLabel = kid.firstChild().label();\n        String word = null;\n        if (wordLabel instanceof HasWord) {\n          word = ((HasWord) wordLabel).word();\n        }\n        if (word == null) {\n          word = wordLabel.value();\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Checking \" + kid.value() + \" head is \" + word + '/' + tag);\n        }\n        String lcWord = word.toLowerCase();\n        if (verbalTags.contains(tag) && verbalSet.contains(lcWord)) {\n          if (DEBUG) {\n            System.err.println(\"hasPassiveProgressiveAuxiliary found passive aux\");\n          }\n          foundPassiveAux = true;\n        }\n      } else if (kid.isPhrasal()) {\n        Label kidLabel = kid.label();\n        String cat = null;\n        if (kidLabel instanceof HasCategory) {\n          cat = ((HasCategory) kidLabel).category();\n        }\n        if (cat == null) {\n          cat = kid.value();\n        }\n        if ( ! cat.startsWith(\"VP\")) {\n          continue;\n        }\n        if (DEBUG) {\n          System.err.println(\"hasPassiveProgressiveAuxiliary found VP\");\n        }\n        Tree[] kidkids = kid.children();\n        boolean foundParticipleInVp = false;\n        for (Tree kidkid : kidkids) {\n          if (DEBUG) {\n            System.err.println(\"  hasPassiveProgressiveAuxiliary examining \" + kidkid);\n          }\n          if (kidkid.isPreTerminal()) {\n            Label kidkidLabel = kidkid.label();\n            String tag = null;\n            if (kidkidLabel instanceof HasTag) {\n              tag = ((HasTag) kidkidLabel).tag();\n            }\n            if (tag == null) {\n              tag = kidkid.value();\n            }\n            // we allow in VBD because of frequent tagging mistakes\n            if (\"VBN\".equals(tag) || \"VBG\".equals(tag) || \"VBD\".equals(tag)) {\n              foundPassiveVP = true;\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary found VBN/VBG/VBD VP\");\n              }\n              break;\n            } else if (\"CC\".equals(tag) && foundParticipleInVp) {\n              foundPassiveVP = true;\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary [coordination] found (VP (VP[VBN/VBG/VBD] CC\");\n              }\n              break;\n            }\n          } else if (kidkid.isPhrasal()) {\n            String catcat = null;\n            if (kidLabel instanceof HasCategory) {\n              catcat = ((HasCategory) kidLabel).category();\n            }\n            if (catcat == null) {\n              catcat = kid.value();\n            }\n            if (\"VP\".equals(catcat)) {\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary found (VP (VP)), recursing\");\n              }\n              foundParticipleInVp = vpContainsParticiple(kidkid);\n            } else if ((\"CONJP\".equals(catcat) || \"PRN\".equals(catcat)) && foundParticipleInVp) { // occasionally get PRN in CONJ-like structures\n              foundPassiveVP = true;\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary [coordination] found (VP (VP[VBN/VBG/VBD] CONJP\");\n              }\n              break;\n            }\n          }\n        }\n      }\n      if (foundPassiveAux && foundPassiveVP) {\n        break;\n      }\n    } // end for (Tree kid : kids)\n    if (DEBUG) {\n      System.err.println(\"hasPassiveProgressiveAuxiliary returns \" + (foundPassiveAux && foundPassiveVP));\n    }\n    return foundPassiveAux && foundPassiveVP;\n  }","id":91435,"modified_method":"private boolean hasPassiveProgressiveAuxiliary(Tree[] kids) {\n    if (DEBUG) {\n      System.err.println(\"Checking for passive/progressive auxiliary\");\n    }\n    boolean foundPassiveVP = false;\n    boolean foundPassiveAux = false;\n    for (Tree kid : kids) {\n      if (DEBUG) {\n        System.err.println(\"  checking in \" + kid);\n      }\n      if (isVerbalAuxiliary(kid, passiveAuxiliaries)) {\n          foundPassiveAux = true;\n      } else if (kid.isPhrasal()) {\n        Label kidLabel = kid.label();\n        String cat = null;\n        if (kidLabel instanceof HasCategory) {\n          cat = ((HasCategory) kidLabel).category();\n        }\n        if (cat == null) {\n          cat = kid.value();\n        }\n        if ( ! cat.startsWith(\"VP\")) {\n          continue;\n        }\n        if (DEBUG) {\n          System.err.println(\"hasPassiveProgressiveAuxiliary found VP\");\n        }\n        Tree[] kidkids = kid.children();\n        boolean foundParticipleInVp = false;\n        for (Tree kidkid : kidkids) {\n          if (DEBUG) {\n            System.err.println(\"  hasPassiveProgressiveAuxiliary examining \" + kidkid);\n          }\n          if (kidkid.isPreTerminal()) {\n            Label kidkidLabel = kidkid.label();\n            String tag = null;\n            if (kidkidLabel instanceof HasTag) {\n              tag = ((HasTag) kidkidLabel).tag();\n            }\n            if (tag == null) {\n              tag = kidkid.value();\n            }\n            // we allow in VBD because of frequent tagging mistakes\n            if (\"VBN\".equals(tag) || \"VBG\".equals(tag) || \"VBD\".equals(tag)) {\n              foundPassiveVP = true;\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary found VBN/VBG/VBD VP\");\n              }\n              break;\n            } else if (\"CC\".equals(tag) && foundParticipleInVp) {\n              foundPassiveVP = true;\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary [coordination] found (VP (VP[VBN/VBG/VBD] CC\");\n              }\n              break;\n            }\n          } else if (kidkid.isPhrasal()) {\n            String catcat = null;\n            if (kidLabel instanceof HasCategory) {\n              catcat = ((HasCategory) kidLabel).category();\n            }\n            if (catcat == null) {\n              catcat = kid.value();\n            }\n            if (\"VP\".equals(catcat)) {\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary found (VP (VP)), recursing\");\n              }\n              foundParticipleInVp = vpContainsParticiple(kidkid);\n            } else if ((\"CONJP\".equals(catcat) || \"PRN\".equals(catcat)) && foundParticipleInVp) { // occasionally get PRN in CONJ-like structures\n              foundPassiveVP = true;\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary [coordination] found (VP (VP[VBN/VBG/VBD] CONJP\");\n              }\n              break;\n            }\n          }\n        }\n      }\n      if (foundPassiveAux && foundPassiveVP) {\n        break;\n      }\n    } // end for (Tree kid : kids)\n    if (DEBUG) {\n      System.err.println(\"hasPassiveProgressiveAuxiliary returns \" + (foundPassiveAux && foundPassiveVP));\n    }\n    return foundPassiveAux && foundPassiveVP;\n  }","commit_id":"13b580bacf3b50c7468ee2f90873816370c41e2c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void printOptimizationResults(LikelihoodFunction df, MonitorFunction monitor) {\n    double negLogLike = df.valueAt(prob.lambda);\n    System.err.println(\"After optimization neg (penalized) log likelihood is: \" + negLogLike);\n    if (monitor != null) {\n      monitor.reportMonitoring(negLogLike);\n    }\n    int numNonZero = 0;\n    for (int i = 0; i < prob.lambda.length; i++) {\n      if (prob.lambda[i] != 0.0) {\n        // 0.0 == -0.0 in IEEE math!\n        numNonZero++;\n      }\n    }\n    System.err.printf(\"Non-zero parameters: %d/%d (%0.2f%%)%n\", numNonZero, prob.lambda.length,\n        ((double) numNonZero) / prob.lambda.length);\n  }","id":91436,"modified_method":"private void printOptimizationResults(LikelihoodFunction df, MonitorFunction monitor) {\n    double negLogLike = df.valueAt(prob.lambda);\n    System.err.printf(\"After optimization neg (penalized) log cond likelihood: %1.2f%n\", negLogLike);\n    if (monitor != null) {\n      monitor.reportMonitoring(negLogLike);\n    }\n    int numNonZero = 0;\n    for (int i = 0; i < prob.lambda.length; i++) {\n      if (prob.lambda[i] != 0.0) {\n        // 0.0 == -0.0 in IEEE math!\n        numNonZero++;\n      }\n    }\n    System.err.printf(\"Non-zero parameters: %d/%d (%1.2f%%)%n\", numNonZero, prob.lambda.length,\n        (100.0 * numNonZero) / prob.lambda.length);\n  }","commit_id":"da683d4b1b8ccd4503337ace188b3b6074ddcb01","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public ModCollinsHeadFinder(TreebankLanguagePack tlp) {\n    super(tlp, tlp.punctuationTags()); // avoid punctuation as head in final default rule\n\n    nonTerminalInfo = Generics.newHashMap();\n\n    // This version from Collins' diss (1999: 236-238)\n    // NNS, NN is actually sensible (money, etc.)!\n    // QP early isn't; should prefer JJR NN RB\n    // remove ADVP; it just shouldn't be there.\n    // if two JJ, should take right one (e.g. South Korean)\n    // nonTerminalInfo.put(\"ADJP\", new String[][]{{\"left\", \"NNS\", \"NN\", \"$\", \"QP\"}, {\"right\", \"JJ\"}, {\"left\", \"VBN\", \"VBG\", \"ADJP\", \"JJP\", \"JJR\", \"NP\", \"JJS\", \"DT\", \"FW\", \"RBR\", \"RBS\", \"SBAR\", \"RB\"}});\n    nonTerminalInfo.put(\"ADJP\", new String[][]{{\"left\", \"$\"}, {\"rightdis\", \"NNS\", \"NN\", \"JJ\", \"QP\", \"VBN\", \"VBG\"}, {\"left\", \"ADJP\"}, {\"rightdis\", \"JJP\", \"JJR\", \"JJS\", \"DT\", \"RB\", \"RBR\", \"CD\", \"IN\", \"VBD\"}, {\"left\", \"ADVP\", \"NP\"}});\n    nonTerminalInfo.put(\"JJP\", new String[][]{{\"left\", \"NNS\", \"NN\", \"$\", \"QP\", \"JJ\", \"VBN\", \"VBG\", \"ADJP\", \"JJP\", \"JJR\", \"NP\", \"JJS\", \"DT\", \"FW\", \"RBR\", \"RBS\", \"SBAR\", \"RB\"}});  // JJP is introduced for NML-like adjective phrases in Vadas' treebank; Chris wishes he hadn't used JJP which should be a POS-tag.\n    // ADVP rule rewritten by Chris in Nov 2010 to be rightdis.  This is right! JJ.* is often head and rightmost.\n    nonTerminalInfo.put(\"ADVP\", new String[][]{{\"left\", \"ADVP\", \"IN\"},\n                                               {\"rightdis\", \"RB\", \"RBR\", \"RBS\", \"JJ\", \"JJR\", \"JJS\"},\n                                               {\"rightdis\", \"RP\", \"DT\", \"NN\", \"CD\", \"NP\", \"VBN\", \"NNP\", \"CC\", \"FW\", \"NNS\", \"ADJP\", \"NML\"}});\n    nonTerminalInfo.put(\"CONJP\", new String[][]{{\"right\", \"CC\", \"RB\", \"IN\"}});\n    nonTerminalInfo.put(\"FRAG\", new String[][]{{\"right\"}}); // crap\n    nonTerminalInfo.put(\"INTJ\", new String[][]{{\"left\"}});\n    nonTerminalInfo.put(\"LST\", new String[][]{{\"right\", \"LS\", \":\"}});\n\n    // NML is head in: (NAC-LOC (NML San Antonio) (, ,) (NNP Texas))\n    // TODO: NNP should be head (rare cases, could be ignored):\n    //   (NAC (NML New York) (NNP Court) (PP of Appeals))\n    //   (NAC (NML Prudential Insurance) (NNP Co.) (PP Of America))\n    // Chris: This could maybe still do with more thought, but NAC is rare.\n    nonTerminalInfo.put(\"NAC\", new String[][]{{\"left\", \"NN\", \"NNS\", \"NML\", \"NNP\", \"NNPS\", \"NP\", \"NAC\", \"EX\", \"$\", \"CD\", \"QP\", \"PRP\", \"VBG\", \"JJ\", \"JJS\", \"JJR\", \"ADJP\", \"JJP\", \"FW\"}});\n    nonTerminalInfo.put(\"NX\", new String[][]{{\"right\", \"NP\", \"NX\"}});\n\n    // Added JJ to PP head table, since it is a head in several cases, e.g.:\n    // (PP (JJ next) (PP to them))\n    // When you have both JJ and IN daughters, it is invariably \"such as\" -- not so clear which should be head, but leave as IN\n    // should prefer JJ? (PP (JJ such) (IN as) (NP (NN crocidolite)))  Michel thinks we should make JJ a head of PP\n    // added SYM as used in new treebanks for symbols filling role of IN\n    // Changed PP search to left -- just what you want for conjunction (and consistent with SemanticHeadFinder)\n    nonTerminalInfo.put(\"PP\", new String[][]{{\"right\", \"IN\", \"TO\", \"VBG\", \"VBN\", \"RP\", \"FW\", \"JJ\", \"SYM\"}, {\"left\", \"PP\"}});\n\n    nonTerminalInfo.put(\"PRN\", new String[][]{{\"left\", \"VP\", \"NP\", \"PP\", \"SQ\", \"S\", \"SINV\", \"SBAR\", \"ADJP\", \"JJP\", \"ADVP\", \"INTJ\", \"WHNP\", \"NAC\", \"VBP\", \"JJ\", \"NN\", \"NNP\"}});\n    nonTerminalInfo.put(\"PRT\", new String[][]{{\"right\", \"RP\"}});\n    // add '#' for pounds!!\n    nonTerminalInfo.put(\"QP\", new String[][]{{\"left\", \"$\", \"IN\", \"NNS\", \"NN\", \"JJ\", \"CD\", \"PDT\", \"DT\", \"RB\", \"NCD\", \"QP\", \"JJR\", \"JJS\"}});\n    nonTerminalInfo.put(\"RRC\", new String[][]{{\"right\", \"VP\", \"NP\", \"ADVP\", \"ADJP\", \"JJP\", \"PP\"}});\n\n    // delete IN -- go for main part of sentence; add FRAG\n\n    nonTerminalInfo.put(\"S\", new String[][]{{\"left\", \"TO\", \"VP\", \"S\", \"FRAG\", \"SBAR\", \"ADJP\", \"JJP\", \"UCP\", \"NP\"}});\n    nonTerminalInfo.put(\"SBAR\", new String[][]{{\"left\", \"WHNP\", \"WHPP\", \"WHADVP\", \"WHADJP\", \"IN\", \"DT\", \"S\", \"SQ\", \"SINV\", \"SBAR\", \"FRAG\"}});\n    nonTerminalInfo.put(\"SBARQ\", new String[][]{{\"left\", \"SQ\", \"S\", \"SINV\", \"SBARQ\", \"FRAG\", \"SBAR\"}});\n    // cdm: if you have 2 VP under an SINV, you should really take the 2nd as syntactic head, because the first is a topicalized VP complement of the second, but for now I didn't change this, since it didn't help parsing.  (If it were changed, it'd need to be also changed to the opposite in SemanticHeadFinder.)\n    nonTerminalInfo.put(\"SINV\", new String[][]{{\"left\", \"VBZ\", \"VBD\", \"VBP\", \"VB\", \"MD\", \"VBN\", \"VP\", \"S\", \"SINV\", \"ADJP\", \"JJP\", \"NP\"}});\n    nonTerminalInfo.put(\"SQ\", new String[][]{{\"left\", \"VBZ\", \"VBD\", \"VBP\", \"VB\", \"MD\", \"AUX\", \"AUXG\", \"VP\", \"SQ\"}});  // TODO: Should maybe put S before SQ for tag questions. Check.\n    nonTerminalInfo.put(\"UCP\", new String[][]{{\"right\"}});\n    // below is weird!! Make 2 lists, one for good and one for bad heads??\n    // VP: added AUX and AUXG to work with Charniak tags\n    nonTerminalInfo.put(\"VP\", new String[][]{{\"left\", \"TO\", \"VBD\", \"VBN\", \"MD\", \"VBZ\", \"VB\", \"VBG\", \"VBP\", \"VP\", \"AUX\", \"AUXG\", \"ADJP\", \"JJP\", \"NN\", \"NNS\", \"JJ\", \"NP\", \"NNP\"}});\n    nonTerminalInfo.put(\"WHADJP\", new String[][]{{\"left\", \"WRB\", \"WHADVP\", \"RB\", \"JJ\", \"ADJP\", \"JJP\", \"JJR\"}});\n    nonTerminalInfo.put(\"WHADVP\", new String[][]{{\"right\", \"WRB\", \"WHADVP\"}});\n    nonTerminalInfo.put(\"WHNP\", new String[][]{{\"left\", \"WDT\", \"WP\", \"WP$\", \"WHADJP\", \"WHPP\", \"WHNP\"}});\n    nonTerminalInfo.put(\"WHPP\", new String[][]{{\"right\", \"IN\", \"TO\", \"FW\"}});\n    nonTerminalInfo.put(\"X\", new String[][]{{\"right\", \"S\", \"VP\", \"ADJP\", \"JJP\", \"NP\", \"SBAR\", \"PP\", \"X\"}});\n    nonTerminalInfo.put(\"NP\", new String[][]{{\"rightdis\", \"NN\", \"NNP\", \"NNPS\", \"NNS\", \"NML\", \"NX\", \"POS\", \"JJR\"}, {\"left\", \"NP\", \"PRP\"}, {\"rightdis\", \"$\", \"ADJP\", \"JJP\", \"PRN\", \"FW\"}, {\"right\", \"CD\"}, {\"rightdis\", \"JJ\", \"JJS\", \"RB\", \"QP\", \"DT\", \"WDT\", \"RBR\", \"ADVP\"}});\n    // TODO: seems JJ should be head of NML in this case:\n    // (NP (NML (JJ former) (NML Red Sox) (JJ great)) (NNP Luis) (NNP Tiant)),\n    nonTerminalInfo.put(\"NML\", new String[][]{{\"rightdis\", \"NN\", \"NNP\", \"NNPS\", \"NNS\", \"NX\", \"NML\", \"POS\", \"JJR\"}, {\"left\", \"NP\", \"PRP\"}, {\"rightdis\", \"$\", \"ADJP\", \"JJP\", \"PRN\"}, {\"right\", \"CD\"}, {\"rightdis\", \"JJ\", \"JJS\", \"RB\", \"QP\", \"DT\", \"WDT\", \"RBR\", \"ADVP\"}});\n\n    nonTerminalInfo.put(\"POSSP\", new String[][]{{\"right\", \"POS\"}});\n\n    /* HJT: Adding the following to deal with oddly formed data in (for example) the Brown corpus */\n    nonTerminalInfo.put(\"ROOT\", new String[][]{{\"left\", \"S\", \"SQ\", \"SINV\", \"SBAR\", \"FRAG\"}});\n    nonTerminalInfo.put(\"TYPO\", new String[][]{{\"left\", \"NN\", \"NP\", \"NML\", \"NNP\", \"NNPS\", \"TO\",\n      \"VBD\", \"VBN\", \"MD\", \"VBZ\", \"VB\", \"VBG\", \"VBP\", \"VP\", \"ADJP\", \"JJP\", \"FRAG\"}}); // for Brown (Roger)\n    nonTerminalInfo.put(\"ADV\", new String[][]{{\"right\", \"RB\", \"RBR\", \"RBS\", \"FW\",\n      \"ADVP\", \"TO\", \"CD\", \"JJR\", \"JJ\", \"IN\", \"NP\", \"NML\", \"JJS\", \"NN\"}});\n\n    // SWBD\n    nonTerminalInfo.put(\"EDITED\", new String[][] {{\"left\"}});  // crap rule for Switchboard (if don't delete EDITED nodes)\n    // in sw2756, a \"VB\". (copy \"VP\" to handle this problem, though should really fix it on reading)\n    nonTerminalInfo.put(\"VB\", new String[][]{{\"left\", \"TO\", \"VBD\", \"VBN\", \"MD\", \"VBZ\", \"VB\", \"VBG\", \"VBP\", \"VP\", \"AUX\", \"AUXG\", \"ADJP\", \"JJP\", \"NN\", \"NNS\", \"JJ\", \"NP\", \"NNP\"}});\n\n    nonTerminalInfo.put(\"META\", new String[][] {{\"left\"}});  // rule for OntoNotes, but maybe should just be deleted in TreeReader??\n    nonTerminalInfo.put(\"XS\", new String[][] {{\"right\", \"IN\"}}); // rule for new structure in QP, introduced by Stanford in QPTreeTransformer\n    // nonTerminalInfo.put(null, new String[][] {{\"left\"}});  // rule for OntoNotes from Michel, but it would be better to fix this in TreeReader or to use a default rule?\n\n    // todo: Uncomment this line if we always want to take the leftmost if no head rule is defined for the mother category.\n    // defaultRule = defaultLeftRule; // Don't exception, take leftmost if no rule defined for a certain parent category\n  }","id":91437,"modified_method":"public ModCollinsHeadFinder(TreebankLanguagePack tlp) {\n    super(tlp, tlp.punctuationTags()); // avoid punctuation as head in final default rule\n\n    nonTerminalInfo = Generics.newHashMap();\n\n    // This version from Collins' diss (1999: 236-238)\n    // NNS, NN is actually sensible (money, etc.)!\n    // QP early isn't; should prefer JJR NN RB\n    // remove ADVP; it just shouldn't be there.\n    // if two JJ, should take right one (e.g. South Korean)\n    // nonTerminalInfo.put(\"ADJP\", new String[][]{{\"left\", \"NNS\", \"NN\", \"$\", \"QP\"}, {\"right\", \"JJ\"}, {\"left\", \"VBN\", \"VBG\", \"ADJP\", \"JJP\", \"JJR\", \"NP\", \"JJS\", \"DT\", \"FW\", \"RBR\", \"RBS\", \"SBAR\", \"RB\"}});\n    nonTerminalInfo.put(\"ADJP\", new String[][]{{\"left\", \"$\"}, {\"rightdis\", \"NNS\", \"NN\", \"JJ\", \"QP\", \"VBN\", \"VBG\"}, {\"left\", \"ADJP\"}, {\"rightdis\", \"JJP\", \"JJR\", \"JJS\", \"DT\", \"RB\", \"RBR\", \"CD\", \"IN\", \"VBD\"}, {\"left\", \"ADVP\", \"NP\"}});\n    nonTerminalInfo.put(\"JJP\", new String[][]{{\"left\", \"NNS\", \"NN\", \"$\", \"QP\", \"JJ\", \"VBN\", \"VBG\", \"ADJP\", \"JJP\", \"JJR\", \"NP\", \"JJS\", \"DT\", \"FW\", \"RBR\", \"RBS\", \"SBAR\", \"RB\"}});  // JJP is introduced for NML-like adjective phrases in Vadas' treebank; Chris wishes he hadn't used JJP which should be a POS-tag.\n    // ADVP rule rewritten by Chris in Nov 2010 to be rightdis.  This is right! JJ.* is often head and rightmost.\n    nonTerminalInfo.put(\"ADVP\", new String[][]{{\"left\", \"ADVP\", \"IN\"},\n                                               {\"rightdis\", \"RB\", \"RBR\", \"RBS\", \"JJ\", \"JJR\", \"JJS\"},\n                                               {\"rightdis\", \"RP\", \"DT\", \"NN\", \"CD\", \"NP\", \"VBN\", \"NNP\", \"CC\", \"FW\", \"NNS\", \"ADJP\", \"NML\"}});\n    nonTerminalInfo.put(\"CONJP\", new String[][]{{\"right\", \"CC\", \"RB\", \"IN\"}});\n    nonTerminalInfo.put(\"FRAG\", new String[][]{{\"right\"}}); // crap\n    nonTerminalInfo.put(\"INTJ\", new String[][]{{\"left\"}});\n    nonTerminalInfo.put(\"LST\", new String[][]{{\"right\", \"LS\", \":\"}});\n\n    // NML is head in: (NAC-LOC (NML San Antonio) (, ,) (NNP Texas))\n    // TODO: NNP should be head (rare cases, could be ignored):\n    //   (NAC (NML New York) (NNP Court) (PP of Appeals))\n    //   (NAC (NML Prudential Insurance) (NNP Co.) (PP Of America))\n    // Chris: This could maybe still do with more thought, but NAC is rare.\n    nonTerminalInfo.put(\"NAC\", new String[][]{{\"left\", \"NN\", \"NNS\", \"NML\", \"NNP\", \"NNPS\", \"NP\", \"NAC\", \"EX\", \"$\", \"CD\", \"QP\", \"PRP\", \"VBG\", \"JJ\", \"JJS\", \"JJR\", \"ADJP\", \"JJP\", \"FW\"}});\n    nonTerminalInfo.put(\"NX\", new String[][]{{\"right\", \"NP\", \"NX\"}});\n\n    // Added JJ to PP head table, since it is a head in several cases, e.g.:\n    // (PP (JJ next) (PP to them))\n    // When you have both JJ and IN daughters, it is invariably \"such as\" -- not so clear which should be head, but leave as IN\n    // should prefer JJ? (PP (JJ such) (IN as) (NP (NN crocidolite)))  Michel thinks we should make JJ a head of PP\n    // added SYM as used in new treebanks for symbols filling role of IN\n    // Changed PP search to left -- just what you want for conjunction (and consistent with SemanticHeadFinder)\n    nonTerminalInfo.put(\"PP\", new String[][]{{\"right\", \"IN\", \"TO\", \"VBG\", \"VBN\", \"RP\", \"FW\", \"JJ\", \"SYM\"}, {\"left\", \"PP\"}});\n\n    nonTerminalInfo.put(\"PRN\", new String[][]{{\"left\", \"VP\", \"NP\", \"PP\", \"SQ\", \"S\", \"SINV\", \"SBAR\", \"ADJP\", \"JJP\", \"ADVP\", \"INTJ\", \"WHNP\", \"NAC\", \"VBP\", \"JJ\", \"NN\", \"NNP\"}});\n    nonTerminalInfo.put(\"PRT\", new String[][]{{\"right\", \"RP\"}});\n    // add '#' for pounds!!\n    nonTerminalInfo.put(\"QP\", new String[][]{{\"left\", \"$\", \"IN\", \"NNS\", \"NN\", \"JJ\", \"CD\", \"PDT\", \"DT\", \"RB\", \"NCD\", \"QP\", \"JJR\", \"JJS\"}});\n    // reduced relative clause can be any predicate VP, ADJP, NP, PP.\n    // For choosing between NP and PP, really need to know which one is temporal and to choose the other.\n    // It's not clear ADVP needs to be in the list at all (delete?).\n    nonTerminalInfo.put(\"RRC\", new String[][]{{\"left\", \"RRC\"}, {\"right\", \"VP\", \"ADJP\", \"JJP\", \"NP\", \"PP\", \"ADVP\"}});\n\n    // delete IN -- go for main part of sentence; add FRAG\n\n    nonTerminalInfo.put(\"S\", new String[][]{{\"left\", \"TO\", \"VP\", \"S\", \"FRAG\", \"SBAR\", \"ADJP\", \"JJP\", \"UCP\", \"NP\"}});\n    nonTerminalInfo.put(\"SBAR\", new String[][]{{\"left\", \"WHNP\", \"WHPP\", \"WHADVP\", \"WHADJP\", \"IN\", \"DT\", \"S\", \"SQ\", \"SINV\", \"SBAR\", \"FRAG\"}});\n    nonTerminalInfo.put(\"SBARQ\", new String[][]{{\"left\", \"SQ\", \"S\", \"SINV\", \"SBARQ\", \"FRAG\", \"SBAR\"}});\n    // cdm: if you have 2 VP under an SINV, you should really take the 2nd as syntactic head, because the first is a topicalized VP complement of the second, but for now I didn't change this, since it didn't help parsing.  (If it were changed, it'd need to be also changed to the opposite in SemanticHeadFinder.)\n    nonTerminalInfo.put(\"SINV\", new String[][]{{\"left\", \"VBZ\", \"VBD\", \"VBP\", \"VB\", \"MD\", \"VBN\", \"VP\", \"S\", \"SINV\", \"ADJP\", \"JJP\", \"NP\"}});\n    nonTerminalInfo.put(\"SQ\", new String[][]{{\"left\", \"VBZ\", \"VBD\", \"VBP\", \"VB\", \"MD\", \"AUX\", \"AUXG\", \"VP\", \"SQ\"}});  // TODO: Should maybe put S before SQ for tag questions. Check.\n    nonTerminalInfo.put(\"UCP\", new String[][]{{\"right\"}});\n    // below is weird!! Make 2 lists, one for good and one for bad heads??\n    // VP: added AUX and AUXG to work with Charniak tags\n    nonTerminalInfo.put(\"VP\", new String[][]{{\"left\", \"TO\", \"VBD\", \"VBN\", \"MD\", \"VBZ\", \"VB\", \"VBG\", \"VBP\", \"VP\", \"AUX\", \"AUXG\", \"ADJP\", \"JJP\", \"NN\", \"NNS\", \"JJ\", \"NP\", \"NNP\"}});\n    nonTerminalInfo.put(\"WHADJP\", new String[][]{{\"left\", \"WRB\", \"WHADVP\", \"RB\", \"JJ\", \"ADJP\", \"JJP\", \"JJR\"}});\n    nonTerminalInfo.put(\"WHADVP\", new String[][]{{\"right\", \"WRB\", \"WHADVP\"}});\n    nonTerminalInfo.put(\"WHNP\", new String[][]{{\"left\", \"WDT\", \"WP\", \"WP$\", \"WHADJP\", \"WHPP\", \"WHNP\"}});\n    nonTerminalInfo.put(\"WHPP\", new String[][]{{\"right\", \"IN\", \"TO\", \"FW\"}});\n    nonTerminalInfo.put(\"X\", new String[][]{{\"right\", \"S\", \"VP\", \"ADJP\", \"JJP\", \"NP\", \"SBAR\", \"PP\", \"X\"}});\n    nonTerminalInfo.put(\"NP\", new String[][]{{\"rightdis\", \"NN\", \"NNP\", \"NNPS\", \"NNS\", \"NML\", \"NX\", \"POS\", \"JJR\"}, {\"left\", \"NP\", \"PRP\"}, {\"rightdis\", \"$\", \"ADJP\", \"JJP\", \"PRN\", \"FW\"}, {\"right\", \"CD\"}, {\"rightdis\", \"JJ\", \"JJS\", \"RB\", \"QP\", \"DT\", \"WDT\", \"RBR\", \"ADVP\"}});\n    // TODO: seems JJ should be head of NML in this case:\n    // (NP (NML (JJ former) (NML Red Sox) (JJ great)) (NNP Luis) (NNP Tiant)),\n    nonTerminalInfo.put(\"NML\", new String[][]{{\"rightdis\", \"NN\", \"NNP\", \"NNPS\", \"NNS\", \"NX\", \"NML\", \"POS\", \"JJR\"}, {\"left\", \"NP\", \"PRP\"}, {\"rightdis\", \"$\", \"ADJP\", \"JJP\", \"PRN\"}, {\"right\", \"CD\"}, {\"rightdis\", \"JJ\", \"JJS\", \"RB\", \"QP\", \"DT\", \"WDT\", \"RBR\", \"ADVP\"}});\n\n    nonTerminalInfo.put(\"POSSP\", new String[][]{{\"right\", \"POS\"}});\n\n    /* HJT: Adding the following to deal with oddly formed data in (for example) the Brown corpus */\n    nonTerminalInfo.put(\"ROOT\", new String[][]{{\"left\", \"S\", \"SQ\", \"SINV\", \"SBAR\", \"FRAG\"}});\n    nonTerminalInfo.put(\"TYPO\", new String[][]{{\"left\", \"NN\", \"NP\", \"NML\", \"NNP\", \"NNPS\", \"TO\",\n      \"VBD\", \"VBN\", \"MD\", \"VBZ\", \"VB\", \"VBG\", \"VBP\", \"VP\", \"ADJP\", \"JJP\", \"FRAG\"}}); // for Brown (Roger)\n    nonTerminalInfo.put(\"ADV\", new String[][]{{\"right\", \"RB\", \"RBR\", \"RBS\", \"FW\",\n      \"ADVP\", \"TO\", \"CD\", \"JJR\", \"JJ\", \"IN\", \"NP\", \"NML\", \"JJS\", \"NN\"}});\n\n    // SWBD\n    nonTerminalInfo.put(\"EDITED\", new String[][] {{\"left\"}});  // crap rule for Switchboard (if don't delete EDITED nodes)\n    // in sw2756, a \"VB\". (copy \"VP\" to handle this problem, though should really fix it on reading)\n    nonTerminalInfo.put(\"VB\", new String[][]{{\"left\", \"TO\", \"VBD\", \"VBN\", \"MD\", \"VBZ\", \"VB\", \"VBG\", \"VBP\", \"VP\", \"AUX\", \"AUXG\", \"ADJP\", \"JJP\", \"NN\", \"NNS\", \"JJ\", \"NP\", \"NNP\"}});\n\n    nonTerminalInfo.put(\"META\", new String[][] {{\"left\"}});  // rule for OntoNotes, but maybe should just be deleted in TreeReader??\n    nonTerminalInfo.put(\"XS\", new String[][] {{\"right\", \"IN\"}}); // rule for new structure in QP, introduced by Stanford in QPTreeTransformer\n    // nonTerminalInfo.put(null, new String[][] {{\"left\"}});  // rule for OntoNotes from Michel, but it would be better to fix this in TreeReader or to use a default rule?\n\n    // todo: Uncomment this line if we always want to take the leftmost if no head rule is defined for the mother category.\n    // defaultRule = defaultLeftRule; // Don't exception, take leftmost if no rule defined for a certain parent category\n  }","commit_id":"da683d4b1b8ccd4503337ace188b3b6074ddcb01","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Determine which daughter of the current parse tree is the\n   * head.  It assumes that the daughters already have had their\n   * heads determined.  Uses special rule for VP heads\n   *\n   * @param t The parse tree to examine the daughters of.\n   *          This is assumed to never be a leaf\n   * @return The parse tree that is the head\n   */\n  @Override\n  protected Tree determineNonTrivialHead(Tree t, Tree parent) {\n    String motherCat = tlp.basicCategory(t.label().value());\n\n    if (DEBUG) {\n      System.err.println(\"At \" + motherCat + \", my parent is \" + parent);\n    }\n\n    // do VPs with auxiliary as special case\n    if ((motherCat.equals(\"VP\") || motherCat.equals(\"SQ\") || motherCat.equals(\"SINV\"))) {\n      Tree[] kids = t.children();\n      // try to find if there is an auxiliary verb\n\n      if (DEBUG) {\n        System.err.println(\"Semantic head finder: at VP\");\n        System.err.println(\"Class is \" + t.getClass().getName());\n        t.pennPrint(System.err);\n        //System.err.println(\"hasVerbalAuxiliary = \" + hasVerbalAuxiliary(kids, verbalAuxiliaries));\n      }\n\n      // looks for auxiliaries\n      if (hasVerbalAuxiliary(kids, verbalAuxiliaries) || hasPassiveProgressiveAuxiliary(kids, passiveAuxiliaries)) {\n        // String[] how = new String[] {\"left\", \"VP\", \"ADJP\", \"NP\"};\n        // Including NP etc seems okay for copular sentences but is\n        // problematic for other auxiliaries, like 'he has an answer'\n        // But maybe doing ADJP is fine!\n        String[] how = { \"left\", \"VP\", \"ADJP\" };\n        Tree pti = traverseLocate(kids, how, false);\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 1) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        } else {\n          // System.err.println(\"------\");\n          // System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n          // t.pennPrint(System.err);\n          // System.err.println(\"------\");\n        }\n      }\n\n      // looks for copular verbs\n      if (hasVerbalAuxiliary(kids, copulars) && ! isExistential(t, parent) && ! isWHQ(t, parent)) {\n        String[] how;\n        if (motherCat.equals(\"SQ\")) {\n          how = new String[]{\"right\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        } else {\n          how = new String[]{\"left\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        }\n        Tree pti = traverseLocate(kids, how, false);\n        // don't allow a temporal to become head\n        if (pti != null && pti.label() != null && pti.label().value().contains(\"-TMP\")) {\n          pti = null;\n        }\n        // In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative)\n        if (motherCat.equals(\"SQ\") && pti != null && pti.label() != null && pti.label().value().startsWith(\"NP\")) {\n            boolean foundAnotherNp = false;\n            for (Tree kid : kids) {\n              if (kid == pti) {\n                break;\n              } else if (kid.label() != null && kid.label().value().startsWith(\"NP\")) {\n                foundAnotherNp = true;\n                break;\n              }\n            }\n          if ( ! foundAnotherNp) {\n            pti = null;\n          }\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 2) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        } else {\n          if (DEBUG) {\n            System.err.println(\"------\");\n            System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n            t.pennPrint(System.err);\n            System.err.println(\"------\");\n          }\n        }\n      }\n    }\n\n    Tree hd = super.determineNonTrivialHead(t, parent);\n\n    // Heuristically repair punctuation heads\n    Tree[] hdChildren = hd.children();\n    if (hdChildren != null && hdChildren.length > 0 &&\n        hdChildren[0].isLeaf()) {\n      if (tlp.isPunctuationWord(hdChildren[0].label().value())) {\n         Tree[] tChildren = t.children();\n         if (DEBUG) {\n           System.err.printf(\"head is punct: %s\\n\", hdChildren[0].label());\n         }\n         for (int i = tChildren.length - 1; i >= 0; i--) {\n           if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) {\n             hd = tChildren[i];\n             if (DEBUG) {\n               System.err.printf(\"New head: %s %s\", hd.label(), hd.children()[0].label());\n             }\n             break;\n           }\n         }\n      }\n    }\n\n    if (DEBUG) {\n      System.err.println(\"Determined head (case 3) for \" + t.value() + \" is: \" + hd);\n    }\n    return hd;\n  }","id":91438,"modified_method":"/**\n   * Determine which daughter of the current parse tree is the\n   * head.  It assumes that the daughters already have had their\n   * heads determined.  Uses special rule for VP heads\n   *\n   * @param t The parse tree to examine the daughters of.\n   *          This is assumed to never be a leaf\n   * @return The parse tree that is the head\n   */\n  @Override\n  protected Tree determineNonTrivialHead(Tree t, Tree parent) {\n    String motherCat = tlp.basicCategory(t.label().value());\n\n    if (DEBUG) {\n      System.err.println(\"At \" + motherCat + \", my parent is \" + parent);\n    }\n\n    // do VPs with auxiliary as special case\n    if ((motherCat.equals(\"VP\") || motherCat.equals(\"SQ\") || motherCat.equals(\"SINV\"))) {\n      Tree[] kids = t.children();\n      // try to find if there is an auxiliary verb\n\n      if (DEBUG) {\n        System.err.println(\"Semantic head finder: at VP\");\n        System.err.println(\"Class is \" + t.getClass().getName());\n        t.pennPrint(System.err);\n        //System.err.println(\"hasVerbalAuxiliary = \" + hasVerbalAuxiliary(kids, verbalAuxiliaries));\n      }\n\n      // looks for auxiliaries\n      if (hasVerbalAuxiliary(kids, verbalAuxiliaries, true) || hasPassiveProgressiveAuxiliary(kids)) {\n        // String[] how = new String[] {\"left\", \"VP\", \"ADJP\", \"NP\"};\n        // Including NP etc seems okay for copular sentences but is\n        // problematic for other auxiliaries, like 'he has an answer'\n        // But maybe doing ADJP is fine!\n        String[] how = { \"left\", \"VP\", \"ADJP\" };\n        Tree pti = traverseLocate(kids, how, false);\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 1) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        // } else {\n          // System.err.println(\"------\");\n          // System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n          // t.pennPrint(System.err);\n          // System.err.println(\"------\");\n        }\n      }\n\n      // looks for copular verbs\n      if (hasVerbalAuxiliary(kids, copulars, false) && ! isExistential(t, parent) && ! isWHQ(t, parent)) {\n        String[] how;\n        if (motherCat.equals(\"SQ\")) {\n          how = new String[]{\"right\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        } else {\n          how = new String[]{\"left\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        }\n        Tree pti = traverseLocate(kids, how, false);\n        // don't allow a temporal to become head\n        if (pti != null && pti.label() != null && pti.label().value().contains(\"-TMP\")) {\n          pti = null;\n        }\n        // In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative)\n        if (motherCat.equals(\"SQ\") && pti != null && pti.label() != null && pti.label().value().startsWith(\"NP\")) {\n            boolean foundAnotherNp = false;\n            for (Tree kid : kids) {\n              if (kid == pti) {\n                break;\n              } else if (kid.label() != null && kid.label().value().startsWith(\"NP\")) {\n                foundAnotherNp = true;\n                break;\n              }\n            }\n          if ( ! foundAnotherNp) {\n            pti = null;\n          }\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 2) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        } else {\n          if (DEBUG) {\n            System.err.println(\"------\");\n            System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n            t.pennPrint(System.err);\n            System.err.println(\"------\");\n          }\n        }\n      }\n    }\n\n    Tree hd = super.determineNonTrivialHead(t, parent);\n\n    // Heuristically repair punctuation heads\n    Tree[] hdChildren = hd.children();\n    if (hdChildren != null && hdChildren.length > 0 &&\n        hdChildren[0].isLeaf()) {\n      if (tlp.isPunctuationWord(hdChildren[0].label().value())) {\n         Tree[] tChildren = t.children();\n         if (DEBUG) {\n           System.err.printf(\"head is punct: %s\\n\", hdChildren[0].label());\n         }\n         for (int i = tChildren.length - 1; i >= 0; i--) {\n           if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) {\n             hd = tChildren[i];\n             if (DEBUG) {\n               System.err.printf(\"New head: %s %s\", hd.label(), hd.children()[0].label());\n             }\n             break;\n           }\n         }\n      }\n    }\n\n    if (DEBUG) {\n      System.err.println(\"Determined head (case 3) for \" + t.value() + \" is: \" + hd);\n    }\n    return hd;\n  }","commit_id":"da683d4b1b8ccd4503337ace188b3b6074ddcb01","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Reinserted so samples.GetSubcats compiles ... should rework if\n   * this is going to stay.\n   *\n   * @param t A tree to examine for being an auxiliary.\n   * @return Whether it is a verbal auxiliary (be, do, have, get)\n   */\n  public boolean isVerbalAuxiliary(Tree t) {\n    Tree[] trees = { t };\n    return hasVerbalAuxiliary(trees, verbalAuxiliaries);\n  }","id":91439,"modified_method":"/**\n   * Returns true if this tree is a preterminal that is a verbal auxiliary.\n   *\n   * @param t A tree to examine for being an auxiliary.\n   * @return Whether it is a verbal auxiliary (be, do, have, get)\n   */\n  public boolean isVerbalAuxiliary(Tree t) {\n    return isVerbalAuxiliary(t, verbalAuxiliaries, true);\n  }","commit_id":"da683d4b1b8ccd4503337ace188b3b6074ddcb01","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** Create a SemanticHeadFinder.\n   *\n   * @param tlp The TreebankLanguagePack, used by the superclass to get basic\n   *     category of constituents.\n   * @param cop If true, a copular verb (be, seem, appear, stay, remain, resemble, become)\n   *     is not treated as head when it has an AdjP or NP complement.  If false,\n   *     a copula verb is still always treated as a head.  But it will still\n   *     be treated as an auxiliary in periphrastic tenses with a VP complement.\n   */\n  public SemanticHeadFinder(TreebankLanguagePack tlp, boolean cop) {\n    super(tlp);\n    ruleChanges();\n\n    // make a distinction between auxiliaries and copula verbs to\n    // get the NP has semantic head in sentences like \"Bill is an honest man\".  (Added \"sha\" for \"shan't\" May 2009\n    verbalAuxiliaries = Generics.newHashSet();\n    verbalAuxiliaries.addAll(Arrays.asList(auxiliaries));\n\n    passiveAuxiliaries = Generics.newHashSet();\n    passiveAuxiliaries.addAll(Arrays.asList(beGetVerbs));\n\n    //copula verbs having an NP complement\n    copulars = Generics.newHashSet();\n    if (cop) {\n      copulars.addAll(Arrays.asList(copulaVerbs));\n    } // a few times the apostrophe is missing on \"'s\"\n\n    verbalTags = Generics.newHashSet();\n    // include Charniak tags so can do BLLIP right\n    verbalTags.addAll(Arrays.asList(verbTags));\n\n  }","id":91440,"modified_method":"/** Create a SemanticHeadFinder.\n   *\n   * @param tlp The TreebankLanguagePack, used by the superclass to get basic\n   *     category of constituents.\n   * @param cop If true, a copular verb (be, seem, appear, stay, remain, resemble, become)\n   *     is not treated as head when it has an AdjP or NP complement.  If false,\n   *     a copula verb is still always treated as a head.  But it will still\n   *     be treated as an auxiliary in periphrastic tenses with a VP complement.\n   */\n  public SemanticHeadFinder(TreebankLanguagePack tlp, boolean cop) {\n    super(tlp);\n    ruleChanges();\n\n    // make a distinction between auxiliaries and copula verbs to\n    // get the NP has semantic head in sentences like \"Bill is an honest man\".  (Added \"sha\" for \"shan't\" May 2009\n    verbalAuxiliaries = Generics.newHashSet(Arrays.asList(auxiliaries));\n\n    passiveAuxiliaries = Generics.newHashSet(Arrays.asList(beGetVerbs));\n\n    //copula verbs having an NP complement\n    copulars = Generics.newHashSet();\n    if (cop) {\n      copulars.addAll(Arrays.asList(copulaVerbs));\n    }\n\n    verbalTags = Generics.newHashSet(Arrays.asList(verbTags));\n    unambiguousAuxiliaryTags = Generics.newHashSet(Arrays.asList(unambiguousAuxTags));\n\n\n  }","commit_id":"da683d4b1b8ccd4503337ace188b3b6074ddcb01","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private boolean hasPassiveProgressiveAuxiliary(Tree[] kids, Set<String> verbalSet) {\n    if (DEBUG) {\n      System.err.println(\"Checking for passive/progressive auxiliary\");\n    }\n    boolean foundPassiveVP = false;\n    boolean foundPassiveAux = false;\n    for (Tree kid : kids) {\n      if (DEBUG) {\n        System.err.println(\"  checking in \" + kid);\n      }\n      if (kid.isPreTerminal()) {\n        Label kidLabel = kid.label();\n        String tag = null;\n        if (kidLabel instanceof HasTag) {\n          tag = ((HasTag) kidLabel).tag();\n        }\n        if (tag == null) {\n          tag = kid.value();\n        }\n        Label wordLabel = kid.firstChild().label();\n        String word = null;\n        if (wordLabel instanceof HasWord) {\n          word = ((HasWord) wordLabel).word();\n        }\n        if (word == null) {\n          word = wordLabel.value();\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Checking \" + kid.value() + \" head is \" + word + '/' + tag);\n        }\n        String lcWord = word.toLowerCase();\n        if (verbalTags.contains(tag) && verbalSet.contains(lcWord)) {\n          if (DEBUG) {\n            System.err.println(\"hasPassiveProgressiveAuxiliary found passive aux\");\n          }\n          foundPassiveAux = true;\n        }\n      } else if (kid.isPhrasal()) {\n        Label kidLabel = kid.label();\n        String cat = null;\n        if (kidLabel instanceof HasCategory) {\n          cat = ((HasCategory) kidLabel).category();\n        }\n        if (cat == null) {\n          cat = kid.value();\n        }\n        if ( ! cat.startsWith(\"VP\")) {\n          continue;\n        }\n        if (DEBUG) {\n          System.err.println(\"hasPassiveProgressiveAuxiliary found VP\");\n        }\n        Tree[] kidkids = kid.children();\n        boolean foundParticipleInVp = false;\n        for (Tree kidkid : kidkids) {\n          if (DEBUG) {\n            System.err.println(\"  hasPassiveProgressiveAuxiliary examining \" + kidkid);\n          }\n          if (kidkid.isPreTerminal()) {\n            Label kidkidLabel = kidkid.label();\n            String tag = null;\n            if (kidkidLabel instanceof HasTag) {\n              tag = ((HasTag) kidkidLabel).tag();\n            }\n            if (tag == null) {\n              tag = kidkid.value();\n            }\n            // we allow in VBD because of frequent tagging mistakes\n            if (\"VBN\".equals(tag) || \"VBG\".equals(tag) || \"VBD\".equals(tag)) {\n              foundPassiveVP = true;\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary found VBN/VBG/VBD VP\");\n              }\n              break;\n            } else if (\"CC\".equals(tag) && foundParticipleInVp) {\n              foundPassiveVP = true;\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary [coordination] found (VP (VP[VBN/VBG/VBD] CC\");\n              }\n              break;\n            }\n          } else if (kidkid.isPhrasal()) {\n            String catcat = null;\n            if (kidLabel instanceof HasCategory) {\n              catcat = ((HasCategory) kidLabel).category();\n            }\n            if (catcat == null) {\n              catcat = kid.value();\n            }\n            if (\"VP\".equals(catcat)) {\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary found (VP (VP)), recursing\");\n              }\n              foundParticipleInVp = vpContainsParticiple(kidkid);\n            } else if ((\"CONJP\".equals(catcat) || \"PRN\".equals(catcat)) && foundParticipleInVp) { // occasionally get PRN in CONJ-like structures\n              foundPassiveVP = true;\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary [coordination] found (VP (VP[VBN/VBG/VBD] CONJP\");\n              }\n              break;\n            }\n          }\n        }\n      }\n      if (foundPassiveAux && foundPassiveVP) {\n        break;\n      }\n    } // end for (Tree kid : kids)\n    if (DEBUG) {\n      System.err.println(\"hasPassiveProgressiveAuxiliary returns \" + (foundPassiveAux && foundPassiveVP));\n    }\n    return foundPassiveAux && foundPassiveVP;\n  }","id":91441,"modified_method":"private boolean hasPassiveProgressiveAuxiliary(Tree[] kids) {\n    if (DEBUG) {\n      System.err.println(\"Checking for passive/progressive auxiliary\");\n    }\n    boolean foundPassiveVP = false;\n    boolean foundPassiveAux = false;\n    for (Tree kid : kids) {\n      if (DEBUG) {\n        System.err.println(\"  checking in \" + kid);\n      }\n      if (isVerbalAuxiliary(kid, passiveAuxiliaries, false)) {\n          foundPassiveAux = true;\n      } else if (kid.isPhrasal()) {\n        Label kidLabel = kid.label();\n        String cat = null;\n        if (kidLabel instanceof HasCategory) {\n          cat = ((HasCategory) kidLabel).category();\n        }\n        if (cat == null) {\n          cat = kid.value();\n        }\n        if ( ! cat.startsWith(\"VP\")) {\n          continue;\n        }\n        if (DEBUG) {\n          System.err.println(\"hasPassiveProgressiveAuxiliary found VP\");\n        }\n        Tree[] kidkids = kid.children();\n        boolean foundParticipleInVp = false;\n        for (Tree kidkid : kidkids) {\n          if (DEBUG) {\n            System.err.println(\"  hasPassiveProgressiveAuxiliary examining \" + kidkid);\n          }\n          if (kidkid.isPreTerminal()) {\n            Label kidkidLabel = kidkid.label();\n            String tag = null;\n            if (kidkidLabel instanceof HasTag) {\n              tag = ((HasTag) kidkidLabel).tag();\n            }\n            if (tag == null) {\n              tag = kidkid.value();\n            }\n            // we allow in VBD because of frequent tagging mistakes\n            if (\"VBN\".equals(tag) || \"VBG\".equals(tag) || \"VBD\".equals(tag)) {\n              foundPassiveVP = true;\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary found VBN/VBG/VBD VP\");\n              }\n              break;\n            } else if (\"CC\".equals(tag) && foundParticipleInVp) {\n              foundPassiveVP = true;\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary [coordination] found (VP (VP[VBN/VBG/VBD] CC\");\n              }\n              break;\n            }\n          } else if (kidkid.isPhrasal()) {\n            String catcat = null;\n            if (kidLabel instanceof HasCategory) {\n              catcat = ((HasCategory) kidLabel).category();\n            }\n            if (catcat == null) {\n              catcat = kid.value();\n            }\n            if (\"VP\".equals(catcat)) {\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary found (VP (VP)), recursing\");\n              }\n              foundParticipleInVp = vpContainsParticiple(kidkid);\n            } else if ((\"CONJP\".equals(catcat) || \"PRN\".equals(catcat)) && foundParticipleInVp) { // occasionally get PRN in CONJ-like structures\n              foundPassiveVP = true;\n              if (DEBUG) {\n                System.err.println(\"hasPassiveAuxiliary [coordination] found (VP (VP[VBN/VBG/VBD] CONJP\");\n              }\n              break;\n            }\n          }\n        }\n      }\n      if (foundPassiveAux && foundPassiveVP) {\n        break;\n      }\n    } // end for (Tree kid : kids)\n    if (DEBUG) {\n      System.err.println(\"hasPassiveProgressiveAuxiliary returns \" + (foundPassiveAux && foundPassiveVP));\n    }\n    return foundPassiveAux && foundPassiveVP;\n  }","commit_id":"da683d4b1b8ccd4503337ace188b3b6074ddcb01","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** This looks to see whether any of the children is a preterminal headed by a word\n   *  which is within the set verbalSet (which in practice is either\n   *  auxiliary or copula verbs).  It only returns true if it's a preterminal head, since\n   *  you don't want to pick things up in phrasal daughters.  That is an error.\n   *\n   * @param kids The child trees\n   * @param verbalSet The set of words\n   * @return Returns true if one of the child trees is a preterminal verb headed\n   *      by a word in verbalSet\n   */\n  private boolean hasVerbalAuxiliary(Tree[] kids, Set<String> verbalSet) {\n    if (DEBUG) {\n      System.err.println(\"Checking for verbal auxiliary\");\n    }\n    for (Tree kid : kids) {\n      if (DEBUG) {\n        System.err.println(\"  checking in \" + kid);\n      }\n      if (kid.isPreTerminal()) {\n        Label kidLabel = kid.label();\n        String tag = null;\n        if (kidLabel instanceof HasTag) {\n          tag = ((HasTag) kidLabel).tag();\n        }\n        if (tag == null) {\n          tag = kid.value();\n        }\n        Label wordLabel = kid.firstChild().label();\n        String word = null;\n        if (wordLabel instanceof HasWord) {\n          word = ((HasWord) wordLabel).word();\n        }\n        if (word == null) {\n          word = wordLabel.value();\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Checking \" + kid.value() + \" head is \" + word + '/' + tag);\n        }\n        String lcWord = word.toLowerCase();\n        if (verbalTags.contains(tag) && verbalSet.contains(lcWord)) {\n          if (DEBUG) {\n            System.err.println(\"hasVerbalAuxiliary returns true\");\n          }\n          return true;\n        }\n      }\n    }\n    if (DEBUG) {\n      System.err.println(\"hasVerbalAuxiliary returns false\");\n    }\n    return false;\n  }","id":91442,"modified_method":"/** This looks to see whether any of the children is a preterminal headed by a word\n   *  which is within the set verbalSet (which in practice is either\n   *  auxiliary or copula verbs).  It only returns true if it's a preterminal head, since\n   *  you don't want to pick things up in phrasal daughters.  That is an error.\n   *\n   * @param kids The child trees\n   * @param verbalSet The set of words\n   * @param allowTagOnlyMatch If true, it's sufficient to match on an unambiguous auxiliary tag.\n   *                          Make true iff verbalSet is \"all auxiliaries\"\n   * @return Returns true if one of the child trees is a preterminal verb headed\n   *      by a word in verbalSet\n   */\n  private boolean hasVerbalAuxiliary(Tree[] kids, Set<String> verbalSet, boolean allowTagOnlyMatch) {\n    if (DEBUG) {\n      System.err.println(\"Checking for verbal auxiliary\");\n    }\n    for (Tree kid : kids) {\n      if (DEBUG) {\n        System.err.println(\"  checking in \" + kid);\n      }\n      if (isVerbalAuxiliary(kid, verbalSet, allowTagOnlyMatch)) {\n        return true;\n      }\n    }\n    if (DEBUG) {\n      System.err.println(\"hasVerbalAuxiliary returns false\");\n    }\n    return false;\n  }","commit_id":"da683d4b1b8ccd4503337ace188b3b6074ddcb01","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"protected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\r\n\tthrows java.io.IOException {\r\n\t\tsuper.renderProperties(renderer);\r\n\r\n\t\tif (_tabindex >= 0)\r\n\t\t\trenderer.render(\"tabindex\", _tabindex);\r\n\t\tif (!\"normal\".equals(_dir)) render(renderer, \"dir\", _dir);\r\n\r\n\t\trender(renderer, \"disabled\", _disabled);\r\n\t\trender(renderer, \"href\", getEncodedHref());\r\n\t\trender(renderer, \"target\", _target);\r\n\t}","id":91443,"modified_method":"protected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\tthrows java.io.IOException {\n\t\tsuper.renderProperties(renderer);\n\n\t\tif (_tabindex >= 0)\n\t\t\trenderer.render(\"tabindex\", _tabindex);\n\t\tif (!\"normal\".equals(_dir)) render(renderer, \"dir\", _dir);\n\n\t\trender(renderer, \"disabled\", _disabled);\n\t\tfinal String href;\n\t\trender(renderer, \"href\", href = getEncodedHref());\n\t\trender(renderer, \"target\", _target);\n\n\t\torg.zkoss.zul.impl.Utils.renderCrawlableA(href, getLabel());\n\t}","commit_id":"f3759ce505e5c3f765590595811417d31ce09e7b","url":"https://github.com/zkoss/zk"},{"original_method":"protected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\tthrows java.io.IOException {\n\t\tsuper.renderProperties(renderer);\n\n\t\tif (_tabindex >= 0)\n\t\t\trenderer.render(\"tabindex\", _tabindex);\n\t\tif (!\"normal\".equals(_dir)) render(renderer, \"dir\", _dir);\n\t\tif (!\"horizontal\".equals(_orient)) render(renderer, \"orient\", _orient);\n\n\t\trender(renderer, \"disabled\", _disabled);\n\t\trender(renderer, \"autodisable\", _autodisable);\n\t\trender(renderer, \"href\", getEncodedHref());\n\t\trender(renderer, \"target\", _target);\n\t\trender(renderer, \"upload\", _upload);\n\t}","id":91444,"modified_method":"protected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\tthrows java.io.IOException {\n\t\tsuper.renderProperties(renderer);\n\n\t\tif (_tabindex >= 0)\n\t\t\trenderer.render(\"tabindex\", _tabindex);\n\t\tif (!\"normal\".equals(_dir)) render(renderer, \"dir\", _dir);\n\t\tif (!\"horizontal\".equals(_orient)) render(renderer, \"orient\", _orient);\n\n\t\trender(renderer, \"disabled\", _disabled);\n\t\trender(renderer, \"autodisable\", _autodisable);\n\t\tfinal String href;\n\t\trender(renderer, \"href\", href = getEncodedHref());\n\t\trender(renderer, \"target\", _target);\n\t\trender(renderer, \"upload\", _upload);\n\n\t\torg.zkoss.zul.impl.Utils.renderCrawlableA(href, getLabel());\n\t}","commit_id":"f3759ce505e5c3f765590595811417d31ce09e7b","url":"https://github.com/zkoss/zk"},{"original_method":"protected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\tthrows IOException {\n\t\tsuper.renderProperties(renderer);\n\n\t\tif (_maxlength > 0) renderer.render(\"maxlength\", _maxlength);\n\t\trender(renderer, \"multiline\", _multiline);\n\t\trender(renderer, \"pre\", _pre);\n\n\t\tif (_value.length() > 0) {\n\t\t\tboolean outed = false;\n\t\t\tfinal HtmlPageRenders.RenderContext rc =\n\t\t\t\tHtmlPageRenders.getRenderContext(null);\n\t\t\tif (rc != null && rc.crawlable) {\n\t\t\t\trc.extra.write(\"<div id=\\\"\");\n\t\t\t\trc.extra.write(getUuid());\n\t\t\t\trc.extra.write(\"\\\">\");\n\t\t\t\trc.extra.write(XMLs.encodeText(_value));\n\t\t\t\t\t//encode required since it might not be valid HTML\n\t\t\t\trc.extra.write(\"<\/div>\\n\");\n\t\t\t\touted = true;\n\t\t\t}\n\t\t\tif (outed) renderer.render(\"z_ea\", \"$value\"); //decode required\n\t\t\telse render(renderer, \"value\", _value); //no need to encode\n\t\t}\n\t}","id":91445,"modified_method":"protected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\tthrows IOException {\n\t\tsuper.renderProperties(renderer);\n\n\t\tif (_maxlength > 0) renderer.render(\"maxlength\", _maxlength);\n\t\trender(renderer, \"multiline\", _multiline);\n\t\trender(renderer, \"pre\", _pre);\n\t\trender(renderer, \"value\", _value); //no need to encode\n\n\t\torg.zkoss.zul.impl.Utils.renderCrawlableText(_value);\n\t}","commit_id":"f3759ce505e5c3f765590595811417d31ce09e7b","url":"https://github.com/zkoss/zk"},{"original_method":"protected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\tthrows java.io.IOException {\n\t\tsuper.renderProperties(renderer);\n\t\t\n\t\tif (_checkmark) render(renderer, \"checkmark\", _checkmark);\n\t\tif (_disabled) render(renderer, \"disabled\", _disabled);\n\t\tif (_checked) render(renderer, \"checked\", _checked);\n\t\tif (_autocheck) render(renderer, \"autocheck\", _autocheck);\n\t\tif (_href != null) render(renderer, \"href\", getEncodedHref()); //Bug #2871082\n\t\tif (_target != null) render(renderer, \"target\", _target);\n\t\trender(renderer, \"upload\", _upload);\n\t\trender(renderer, \"value\", _value);\n\t}","id":91446,"modified_method":"protected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\tthrows java.io.IOException {\n\t\tsuper.renderProperties(renderer);\n\t\t\n\t\tif (_checkmark) render(renderer, \"checkmark\", _checkmark);\n\t\tif (_disabled) render(renderer, \"disabled\", _disabled);\n\t\tif (_checked) render(renderer, \"checked\", _checked);\n\t\tif (_autocheck) render(renderer, \"autocheck\", _autocheck);\n\t\tString href = null;\n\t\tif (_href != null) render(renderer, \"href\", href = getEncodedHref()); //Bug #2871082\n\t\tif (_target != null) render(renderer, \"target\", _target);\n\t\trender(renderer, \"upload\", _upload);\n\t\trender(renderer, \"value\", _value);\n\n\t\tUtils.renderCrawlableA(href, getLabel());\n\t}","commit_id":"f3759ce505e5c3f765590595811417d31ce09e7b","url":"https://github.com/zkoss/zk"},{"original_method":"public Object getVariable(String iName, final Object iDefault) {\r\n    if (iName == null)\r\n      return iDefault;\r\n\r\n    if (iName.startsWith(\"$\"))\r\n      iName = iName.substring(1);\r\n\r\n    int pos = OStringSerializerHelper.getLowerIndexOf(iName, 0, \".\", \"[\");\r\n\r\n    String firstPart;\r\n    String lastPart;\r\n    if (pos > -1) {\r\n      firstPart = iName.substring(0, pos);\r\n      if (iName.charAt(pos) == '.')\r\n        pos++;\r\n      lastPart = iName.substring(pos);\r\n      if (firstPart.equalsIgnoreCase(\"PARENT\") && parent != null) {\r\n        // UP TO THE PARENT\r\n        if (lastPart.startsWith(\"$\"))\r\n          return parent.getVariable(lastPart.substring(1));\r\n        else\r\n          return ODocumentHelper.getFieldValue(parent, lastPart);\r\n      } else if (firstPart.equalsIgnoreCase(\"ROOT\")) {\r\n        OCommandContext p = this;\r\n        while (p.getParent() != null)\r\n          p = p.getParent();\r\n        if (lastPart.startsWith(\"$\"))\r\n          return p.getVariable(lastPart.substring(1));\r\n        else\r\n          return ODocumentHelper.getFieldValue(p, lastPart, this);\r\n      }\r\n    } else {\r\n      firstPart = iName;\r\n      lastPart = null;\r\n    }\r\n\r\n    Object result = iDefault;\r\n    if (firstPart.equalsIgnoreCase(\"CONTEXT\"))\r\n      result = getVariables();\r\n    else if (firstPart.equalsIgnoreCase(\"PARENT\"))\r\n      return parent;\r\n    else if (firstPart.equalsIgnoreCase(\"ROOT\")) {\r\n      OCommandContext p = this;\r\n      while (p.getParent() != null)\r\n        p = p.getParent();\r\n      return p;\r\n    } else {\r\n      if (variables != null && variables.containsKey(firstPart))\r\n        result = variables.get(firstPart);\r\n      else if (child != null)\r\n        result = child.getVariable(firstPart);\r\n    }\r\n\r\n    if (pos > -1)\r\n      result = ODocumentHelper.getFieldValue(result, lastPart, this);\r\n\r\n    return result;\r\n  }","id":91447,"modified_method":"public Object getVariable(String iName, final Object iDefault) {\r\n    if (iName == null)\r\n      return iDefault;\r\n\r\n    Object result = null;\r\n\r\n    if (iName.startsWith(\"$\"))\r\n      iName = iName.substring(1);\r\n\r\n    int pos = OStringSerializerHelper.getLowerIndexOf(iName, 0, \".\", \"[\");\r\n\r\n    String firstPart;\r\n    String lastPart;\r\n    if (pos > -1) {\r\n      firstPart = iName.substring(0, pos);\r\n      if (iName.charAt(pos) == '.')\r\n        pos++;\r\n      lastPart = iName.substring(pos);\r\n      if (firstPart.equalsIgnoreCase(\"PARENT\") && parent != null) {\r\n        // UP TO THE PARENT\r\n        if (lastPart.startsWith(\"$\"))\r\n          result = parent.getVariable(lastPart.substring(1));\r\n        else\r\n          result = ODocumentHelper.getFieldValue(parent, lastPart);\r\n\r\n        return result != null ? result : iDefault;\r\n\r\n      } else if (firstPart.equalsIgnoreCase(\"ROOT\")) {\r\n        OCommandContext p = this;\r\n        while (p.getParent() != null)\r\n          p = p.getParent();\r\n\r\n        if (lastPart.startsWith(\"$\"))\r\n          result = p.getVariable(lastPart.substring(1));\r\n        else\r\n          result = ODocumentHelper.getFieldValue(p, lastPart, this);\r\n\r\n        return result != null ? result : iDefault;\r\n      }\r\n    } else {\r\n      firstPart = iName;\r\n      lastPart = null;\r\n    }\r\n\r\n    if (firstPart.equalsIgnoreCase(\"CONTEXT\"))\r\n      result = getVariables();\r\n    else if (firstPart.equalsIgnoreCase(\"PARENT\"))\r\n      result = parent;\r\n    else if (firstPart.equalsIgnoreCase(\"ROOT\")) {\r\n      OCommandContext p = this;\r\n      while (p.getParent() != null)\r\n        p = p.getParent();\r\n      result = p;\r\n    } else {\r\n      if (variables != null && variables.containsKey(firstPart))\r\n        result = variables.get(firstPart);\r\n      else if (child != null)\r\n        result = child.getVariable(firstPart);\r\n    }\r\n\r\n    if (pos > -1)\r\n      result = ODocumentHelper.getFieldValue(result, lastPart, this);\r\n\r\n    return result != null ? result : iDefault;\r\n  }","commit_id":"9309271756d43a98543824f1def9c0366779cd01","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public ODatabaseObject delete(final Object iContent) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tif (iContent == null)\r\n\t\t\treturn this;\r\n\r\n\t\tfinal ODocument record = getRecordByUserObject(iContent, true);\r\n\r\n\t\tunderlying.delete(record);\r\n\r\n\t\tunregisterPojo(iContent, record);\r\n\r\n\t\treturn this;\r\n\t}","id":91448,"modified_method":"public ODatabaseObject delete(final Object iContent) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tif (iContent == null)\r\n\t\t\treturn this;\r\n\r\n\t\tODocument record = getRecordByUserObject(iContent, false);\r\n\t\tif (record == null)\r\n\t\t\trecord = (ODocument) underlying.load(OObjectSerializerHelper.getObjectID(this, iContent));\r\n\r\n\t\tunderlying.delete(record);\r\n\t\tunregisterPojo(iContent, record);\r\n\r\n\t\treturn this;\r\n\t}","commit_id":"7a88ff46108533f2fecd519a8aac7c0cbee3b881","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public ODocument getRecordByUserObject(final Object iPojo, final boolean iIsMandatory) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tif (iPojo instanceof ODocument)\r\n\t\t\treturn (ODocument) iPojo;\r\n\r\n\t\tODocument record = objects2Records.get(System.identityHashCode(iPojo));\r\n\r\n\t\tif (record == null) {\r\n\t\t\tif (iIsMandatory)\r\n\t\t\t\tthrow new OObjectNotManagedException(\"The object \" + iPojo + \" is not managed by the current database\");\r\n\r\n\t\t\trecord = underlying.newInstance(iPojo.getClass().getSimpleName());\r\n\r\n\t\t\tregisterPojo((T) iPojo, record);\r\n\t\t\tpojo2Stream((T) iPojo, record);\r\n\t\t}\r\n\r\n\t\treturn record;\r\n\t}","id":91449,"modified_method":"public ODocument getRecordByUserObject(final Object iPojo, final boolean iCreateIfNotAvailable) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tif (iPojo instanceof ODocument)\r\n\t\t\treturn (ODocument) iPojo;\r\n\r\n\t\tODocument record = objects2Records.get(System.identityHashCode(iPojo));\r\n\r\n\t\tif (record == null && iCreateIfNotAvailable) {\r\n\t\t\trecord = underlying.newInstance(iPojo.getClass().getSimpleName());\r\n\t\t\tregisterPojo((T) iPojo, record);\r\n\t\t\tpojo2Stream((T) iPojo, record);\r\n\t\t}\r\n\r\n\t\treturn record;\r\n\t}","commit_id":"7a88ff46108533f2fecd519a8aac7c0cbee3b881","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Sets as dirty a POJO. This is useful when you change the object and need to tell to the engine to treat as dirty.\r\n\t * \r\n\t * @param iPojo\r\n\t *          User object\r\n\t */\r\n\tpublic void setDirty(final Object iPojo) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal ODocument record = getRecordByUserObject(iPojo, true);\r\n\r\n\t\tif (record == null)\r\n\t\t\tthrow new OObjectNotManagedException(\"The object \" + iPojo + \" is not managed by the current database\");\r\n\r\n\t\trecord.setDirty();\r\n\t}","id":91450,"modified_method":"/**\r\n\t * Sets as dirty a POJO. This is useful when you change the object and need to tell to the engine to treat as dirty.\r\n\t * \r\n\t * @param iPojo\r\n\t *          User object\r\n\t */\r\n\tpublic void setDirty(final Object iPojo) {\r\n\t\tcheckOpeness();\r\n\r\n\t\tfinal ODocument record = getRecordByUserObject(iPojo, false);\r\n\t\tif (record == null)\r\n\t\t\tthrow new OObjectNotManagedException(\"The object \" + iPojo + \" is not managed by the current database\");\r\n\r\n\t\trecord.setDirty();\r\n\t}","commit_id":"7a88ff46108533f2fecd519a8aac7c0cbee3b881","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static Object getObjectVersion(final Object iPojo) {\r\n\t\tfinal String idFieldName = fieldVersions.get(iPojo.getClass());\r\n\t\tif (idFieldName != null) {\r\n\t\t\treturn getFieldValue(iPojo, idFieldName);\r\n\t\t}\r\n\t\treturn null;\r\n\t}","id":91451,"modified_method":"public static int getObjectVersion(final Object iPojo) {\r\n\t\tfinal String idFieldName = fieldVersions.get(iPojo.getClass());\r\n\t\tif (idFieldName != null) {\r\n\t\t\tObject ver = getFieldValue(iPojo, idFieldName);\r\n\r\n\t\t\tif (ver != null) {\r\n\t\t\t\t// FOUND\r\n\t\t\t\tif (ver instanceof Number) {\r\n\t\t\t\t\t// TREATS AS CLUSTER POSITION\r\n\t\t\t\t\treturn ((Number) ver).intValue();\r\n\t\t\t\t} else if (ver instanceof String)\r\n\t\t\t\t\treturn Integer.parseInt((String) ver);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow new OObjectNotDetachedException(\"Can't retrieve the object's VERSION for '\" + iPojo + \"' because hasn't been detached\");\r\n\t}","commit_id":"7a88ff46108533f2fecd519a8aac7c0cbee3b881","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private static Object typeToStream(Object iFieldValue, OType iType, final OEntityManager iEntityManager,\r\n\t\t\tfinal OUserObject2RecordHandler iObj2RecHandler, final ODatabaseObjectTx db, final boolean iSaveOnlyDirty) {\r\n\t\tif (iFieldValue == null)\r\n\t\t\treturn null;\r\n\r\n\t\tClass<?> fieldClass = iFieldValue.getClass();\r\n\r\n\t\tif (!OType.isSimpleType(fieldClass)) {\r\n\t\t\tif (fieldClass.isArray()) {\r\n\t\t\t\t// ARRAY\r\n\t\t\t\tiFieldValue = multiValueToStream(Arrays.asList(iFieldValue), iType, iEntityManager, iObj2RecHandler, db, iSaveOnlyDirty);\r\n\t\t\t} else if (Collection.class.isAssignableFrom(fieldClass)) {\r\n\t\t\t\t// COLLECTION (LIST OR SET)\r\n\t\t\t\tiFieldValue = multiValueToStream(iFieldValue, iType, iEntityManager, iObj2RecHandler, db, iSaveOnlyDirty);\r\n\t\t\t} else if (Map.class.isAssignableFrom(fieldClass)) {\r\n\t\t\t\t// MAP\r\n\t\t\t\tiFieldValue = multiValueToStream(iFieldValue, iType, iEntityManager, iObj2RecHandler, db, iSaveOnlyDirty);\r\n\t\t\t} else if (fieldClass.isEnum()) {\r\n\t\t\t\t// ENUM\r\n\t\t\t\tiFieldValue = ((Enum<?>) iFieldValue).name();\r\n\t\t\t\tiType = OType.STRING;\r\n\t\t\t} else {\r\n\t\t\t\t// LINK OR EMBEDDED\r\n\t\t\t\tfieldClass = iEntityManager.getEntityClass(fieldClass.getSimpleName());\r\n\t\t\t\tif (fieldClass != null) {\r\n\t\t\t\t\t// RECOGNIZED TYPE, SERIALIZE IT\r\n\t\t\t\t\tfinal ODocument linkedDocument = (ODocument) iObj2RecHandler.getRecordByUserObject(iFieldValue, false);\r\n\r\n\t\t\t\t\tiFieldValue = toStream(iFieldValue, linkedDocument, iEntityManager, linkedDocument.getSchemaClass(), iObj2RecHandler, db,\r\n\t\t\t\t\t\t\tiSaveOnlyDirty);\r\n\r\n\t\t\t\t} else\r\n\t\t\t\t\tthrow new OSerializationException(\"Linked type [\" + iFieldValue.getClass() + \":\" + iFieldValue\r\n\t\t\t\t\t\t\t+ \"] can't be serialized because is not part of registered entities\");\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn iFieldValue;\r\n\t}","id":91452,"modified_method":"private static Object typeToStream(Object iFieldValue, OType iType, final OEntityManager iEntityManager,\r\n\t\t\tfinal OUserObject2RecordHandler iObj2RecHandler, final ODatabaseObjectTx db, final boolean iSaveOnlyDirty) {\r\n\t\tif (iFieldValue == null)\r\n\t\t\treturn null;\r\n\r\n\t\tClass<?> fieldClass = iFieldValue.getClass();\r\n\r\n\t\tif (!OType.isSimpleType(fieldClass)) {\r\n\t\t\tif (fieldClass.isArray()) {\r\n\t\t\t\t// ARRAY\r\n\t\t\t\tiFieldValue = multiValueToStream(Arrays.asList(iFieldValue), iType, iEntityManager, iObj2RecHandler, db, iSaveOnlyDirty);\r\n\t\t\t} else if (Collection.class.isAssignableFrom(fieldClass)) {\r\n\t\t\t\t// COLLECTION (LIST OR SET)\r\n\t\t\t\tiFieldValue = multiValueToStream(iFieldValue, iType, iEntityManager, iObj2RecHandler, db, iSaveOnlyDirty);\r\n\t\t\t} else if (Map.class.isAssignableFrom(fieldClass)) {\r\n\t\t\t\t// MAP\r\n\t\t\t\tiFieldValue = multiValueToStream(iFieldValue, iType, iEntityManager, iObj2RecHandler, db, iSaveOnlyDirty);\r\n\t\t\t} else if (fieldClass.isEnum()) {\r\n\t\t\t\t// ENUM\r\n\t\t\t\tiFieldValue = ((Enum<?>) iFieldValue).name();\r\n\t\t\t\tiType = OType.STRING;\r\n\t\t\t} else {\r\n\t\t\t\t// LINK OR EMBEDDED\r\n\t\t\t\tfieldClass = iEntityManager.getEntityClass(fieldClass.getSimpleName());\r\n\t\t\t\tif (fieldClass != null) {\r\n\t\t\t\t\t// RECOGNIZED TYPE, SERIALIZE IT\r\n\t\t\t\t\tfinal ODocument linkedDocument = (ODocument) iObj2RecHandler.getRecordByUserObject(iFieldValue, true);\r\n\r\n\t\t\t\t\tiFieldValue = toStream(iFieldValue, linkedDocument, iEntityManager, linkedDocument.getSchemaClass(), iObj2RecHandler, db,\r\n\t\t\t\t\t\t\tiSaveOnlyDirty);\r\n\r\n\t\t\t\t} else\r\n\t\t\t\t\tthrow new OSerializationException(\"Linked type [\" + iFieldValue.getClass() + \":\" + iFieldValue\r\n\t\t\t\t\t\t\t+ \"] can't be serialized because is not part of registered entities\");\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn iFieldValue;\r\n\t}","commit_id":"7a88ff46108533f2fecd519a8aac7c0cbee3b881","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static Object getObjectID(final Object iPojo) {\r\n\t\tfinal String idFieldName = fieldIds.get(iPojo.getClass());\r\n\t\tif (idFieldName != null) {\r\n\t\t\treturn getFieldValue(iPojo, idFieldName);\r\n\t\t}\r\n\t\treturn null;\r\n\t}","id":91453,"modified_method":"public static ORecordId getObjectID(final ODatabaseObjectTx iDb, final Object iPojo) {\r\n\t\tfinal String idFieldName = fieldIds.get(iPojo.getClass());\r\n\t\tif (idFieldName != null) {\r\n\t\t\tfinal Object id = getFieldValue(iPojo, idFieldName);\r\n\r\n\t\t\tif (id != null) {\r\n\t\t\t\t// FOUND\r\n\t\t\t\tif (id instanceof ORecordId) {\r\n\t\t\t\t\treturn (ORecordId) id;\r\n\t\t\t\t} else if (id instanceof Number) {\r\n\t\t\t\t\t// TREATS AS CLUSTER POSITION\r\n\t\t\t\t\tfinal OClass cls = iDb.getMetadata().getSchema().getClass(iPojo.getClass());\r\n\t\t\t\t\tif (cls == null)\r\n\t\t\t\t\t\tthrow new OConfigurationException(\"Class \" + iPojo.getClass() + \" is not managed by current database\");\r\n\r\n\t\t\t\t\treturn new ORecordId(cls.getDefaultClusterId(), ((Number) id).longValue());\r\n\t\t\t\t} else if (id instanceof String)\r\n\t\t\t\t\treturn new ORecordId((String) id);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthrow new OObjectNotDetachedException(\"Can't retrieve the object's ID for '\" + iPojo + \"' because hasn't been detached\");\r\n\t}","commit_id":"7a88ff46108533f2fecd519a8aac7c0cbee3b881","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public double getCost(Iterable<String> nodeTypes) {\n        PropertyValue ntNames = PropertyValues.newName(nodeTypes);\n        Property2IndexLookup lookup = new Property2IndexLookup(root);\n        return lookup.getCost(JCR_PRIMARYTYPE, ntNames)\n                + lookup.getCost(JCR_MIXINTYPES, ntNames);\n    }","id":91454,"modified_method":"public double getCost(Iterable<String> nodeTypes) {\n        PropertyValue ntNames = PropertyValues.newName(nodeTypes);\n        Property2IndexLookup lookup = new Property2IndexLookup(root);\n        return lookup.getCost(null, JCR_PRIMARYTYPE, ntNames)\n                + lookup.getCost(null, JCR_MIXINTYPES, ntNames);\n    }","commit_id":"896df80a8e6eae08811188221e797e88cb789ef7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Returns <code>true<\/code> if a node type index lookup exists at the given\n     * <code>path<\/code> or further up the tree.\n     *\n     * @param path the path to check.\n     * @return <code>true<\/code> if a node type index exists; <code>false<\/code>\n     *         otherwise.\n     */\n    public boolean isIndexed(String path) {\n        Property2IndexLookup lookup = new Property2IndexLookup(root);\n        if (lookup.isIndexed(JCR_PRIMARYTYPE, path)\n                && lookup.isIndexed(JCR_MIXINTYPES, path)) {\n            return true;\n        }\n\n        if (path.startsWith(\"/\")) {\n            path = path.substring(1);\n        }\n        int slash = path.indexOf('/');\n        if (slash == -1) {\n            return false;\n        }\n\n        NodeState child = root.getChildNode(path.substring(0, slash));\n        return new NodeTypeIndexLookup(child).isIndexed(\n                path.substring(slash));\n    }","id":91455,"modified_method":"/**\n     * Returns <code>true<\/code> if a node type index lookup exists at the given\n     * <code>path<\/code> or further up the tree.\n     *\n     * @param path the path to check.\n     * @return <code>true<\/code> if a node type index exists; <code>false<\/code>\n     *         otherwise.\n     */\n    public boolean isIndexed(String path) {\n        Property2IndexLookup lookup = new Property2IndexLookup(root);\n        if (lookup.isIndexed(JCR_PRIMARYTYPE, path, null)\n                && lookup.isIndexed(JCR_MIXINTYPES, path, null)) {\n            return true;\n        }\n\n        if (path.startsWith(\"/\")) {\n            path = path.substring(1);\n        }\n        int slash = path.indexOf('/');\n        if (slash == -1) {\n            return false;\n        }\n\n        NodeState child = root.getChildNode(path.substring(0, slash));\n        return new NodeTypeIndexLookup(child).isIndexed(\n                path.substring(slash));\n    }","commit_id":"896df80a8e6eae08811188221e797e88cb789ef7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Cursor query(Filter filter, NodeState root) {\n        Iterable<String> paths = null;\n\n        Property2IndexLookup lookup = new Property2IndexLookup(root);\n        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n            // TODO support indexes on a path\n            // currently, only indexes on the root node are supported\n            if (lookup.isIndexed(pr.propertyName, \"/\")) {\n                // equality\n                if (pr.firstIncluding && pr.lastIncluding\n                    && pr.first != null && pr.first.equals(pr.last)) {\n                    // \"[property] = $value\"\n                    paths = lookup.query(filter, pr.propertyName, pr.first);\n                    break;\n                } else if (pr.first == null && pr.last == null) {\n                    // \"[property] is not null\"\n                    paths = lookup.query(filter, pr.propertyName, null);\n                    break;\n                }\n            }\n        }\n        if (paths == null) {\n            throw new IllegalStateException(\"Property index is used even when no index is available for filter \" + filter);\n        }\n        return Cursors.newPathCursor(paths);\n    }","id":91456,"modified_method":"@Override\n    public Cursor query(Filter filter, NodeState root) {\n        Iterable<String> paths = null;\n\n        Property2IndexLookup lookup = new Property2IndexLookup(root);\n        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n            // TODO support indexes on a path\n            // currently, only indexes on the root node are supported\n            if (lookup.isIndexed(pr.propertyName, \"/\", filter)) {\n                // equality\n                if (pr.firstIncluding && pr.lastIncluding\n                    && pr.first != null && pr.first.equals(pr.last)) {\n                    // \"[property] = $value\"\n                    paths = lookup.query(filter, pr.propertyName, pr.first);\n                    break;\n                } else if (pr.first == null && pr.last == null) {\n                    // \"[property] is not null\"\n                    paths = lookup.query(filter, pr.propertyName, null);\n                    break;\n                }\n            }\n        }\n        if (paths == null) {\n            throw new IllegalStateException(\"Property index is used even when no index is available for filter \" + filter);\n        }\n        return Cursors.newPathCursor(paths);\n    }","commit_id":"896df80a8e6eae08811188221e797e88cb789ef7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public String getPlan(Filter filter, NodeState root) {\n        StringBuilder buff = new StringBuilder(\"p2\");\n        Property2IndexLookup lookup = new Property2IndexLookup(root);\n        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n            // TODO support indexes on a path\n            // currently, only indexes on the root node are supported\n            if (lookup.isIndexed(pr.propertyName, \"/\")) {\n                if (pr.firstIncluding && pr.lastIncluding\n                    && pr.first != null && pr.first.equals(pr.last)) {\n                    buff.append(' ').append(pr.propertyName).append('=').append(pr.first);\n                } else if (pr.first == null && pr.last == null) {\n                    buff.append(' ').append(pr.propertyName);\n                }\n            }\n        }\n        return buff.toString();\n    }","id":91457,"modified_method":"@Override\n    public String getPlan(Filter filter, NodeState root) {\n        StringBuilder buff = new StringBuilder(\"p2\");\n        Property2IndexLookup lookup = new Property2IndexLookup(root);\n        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n            // TODO support indexes on a path\n            // currently, only indexes on the root node are supported\n            if (lookup.isIndexed(pr.propertyName, \"/\", filter)) {\n                if (pr.firstIncluding && pr.lastIncluding\n                    && pr.first != null && pr.first.equals(pr.last)) {\n                    buff.append(' ').append(pr.propertyName).append('=').append(pr.first);\n                } else if (pr.first == null && pr.last == null) {\n                    buff.append(' ').append(pr.propertyName);\n                }\n            }\n        }\n        return buff.toString();\n    }","commit_id":"896df80a8e6eae08811188221e797e88cb789ef7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public double getCost(Filter filter, NodeState root) {\n        Property2IndexLookup lookup = new Property2IndexLookup(root);\n        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n            // TODO support indexes on a path\n            // currently, only indexes on the root node are supported\n            if (lookup.isIndexed(pr.propertyName, \"/\")) {\n                if (pr.firstIncluding && pr.lastIncluding\n                    && pr.first != null && pr.first.equals(pr.last)) {\n                    // \"[property] = $value\"\n                    return lookup.getCost(pr.propertyName, pr.first);\n                } else if (pr.first == null && pr.last == null) {\n                    // \"[property] is not null\"\n                    return lookup.getCost(pr.propertyName, null);\n                }\n            }\n        }\n        // not an appropriate index\n        return Double.POSITIVE_INFINITY;\n    }","id":91458,"modified_method":"@Override\n    public double getCost(Filter filter, NodeState root) {\n        Property2IndexLookup lookup = new Property2IndexLookup(root);\n        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n            // TODO support indexes on a path\n            // currently, only indexes on the root node are supported\n            if (lookup.isIndexed(pr.propertyName, \"/\", filter)) {\n                if (pr.firstIncluding && pr.lastIncluding\n                    && pr.first != null && pr.first.equals(pr.last)) {\n                    // \"[property] = $value\"\n                    return lookup.getCost(filter, pr.propertyName, pr.first);\n                } else if (pr.first == null && pr.last == null) {\n                    // \"[property] is not null\"\n                    return lookup.getCost(filter, pr.propertyName, null);\n                }\n            }\n        }\n        // not an appropriate index\n        return Double.POSITIVE_INFINITY;\n    }","commit_id":"896df80a8e6eae08811188221e797e88cb789ef7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Add the index definitions to the in-memory set of known index definitions.\n     * \n     * @param builder the node builder that contains the index definition\n     * @param indexName the name of the index\n     */\n    private void addIndexes(NodeBuilder builder, String indexName) {\n        List<String> typeNames = ImmutableList.of();\n        PropertyState appliesTo = builder.getProperty(declaringNodeTypes);\n        if (appliesTo != null) {\n            typeNames = newArrayList(appliesTo.getValue(Type.STRINGS));\n        }\n        PropertyState ps = builder.getProperty(propertyNames);\n\n        Iterable<String> propertyNames = ps != null ? ps.getValue(Type.STRINGS)\n                : ImmutableList.of(indexName);\n        for (String pname : propertyNames) {\n            List<Property2IndexUpdate> list = this.indexMap.get(pname);\n            if (list == null) {\n                list = newArrayList();\n                this.indexMap.put(pname, list);\n            }\n            boolean exists = false;\n            for (Property2IndexUpdate piu : list) {\n                if (piu.getPath().equals(getPath())) {\n                    exists = true;\n                    break;\n                }\n            }\n            if (!exists) {\n                list.add(new Property2IndexUpdate(getPath(), builder, store, typeNames));\n            }\n        }\n    }","id":91459,"modified_method":"/**\n     * Add the index definitions to the in-memory set of known index definitions.\n     * \n     * @param builder the node builder that contains the index definition\n     * @param indexName the name of the index\n     */\n    private void addIndexes(NodeBuilder builder, String indexName) {\n        List<String> typeNames = ImmutableList.of();\n        PropertyState appliesTo = builder.getProperty(declaringNodeTypes);\n        if (appliesTo != null) {\n            typeNames = newArrayList(appliesTo.getValue(Type.STRINGS));\n            Collections.sort(typeNames);\n        }\n        PropertyState ps = builder.getProperty(propertyNames);\n\n        Iterable<String> propertyNames = ps != null ? ps.getValue(Type.STRINGS)\n                : ImmutableList.of(indexName);\n        for (String pname : propertyNames) {\n            List<Property2IndexUpdate> list = this.indexMap.get(pname);\n            if (list == null) {\n                list = newArrayList();\n                this.indexMap.put(pname, list);\n            }\n            boolean exists = false;\n            String localPath = getPath();\n            for (Property2IndexUpdate piu : list) {\n                if (localPath.equals(piu.getPath())\n                        && typeNames.equals(piu.getNodeTypeNames())) {\n                    exists = true;\n                    break;\n                }\n            }\n            if (!exists) {\n                list.add(new Property2IndexUpdate(getPath(), builder, store, typeNames));\n            }\n        }\n    }","commit_id":"896df80a8e6eae08811188221e797e88cb789ef7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Checks whether the named property is indexed somewhere along the given\n     * path. Lookup starts at the current path (at the root of this object) and\n     * traverses down the path.\n     * \n     * @param propertyName property name\n     * @param path lookup path\n     * @return true if the property is indexed\n     */\n    public boolean isIndexed(String propertyName, String path) {\n        return isIndexed(root, propertyName, path);\n    }","id":91460,"modified_method":"/**\n     * Checks whether the named property is indexed somewhere along the given\n     * path. Lookup starts at the current path (at the root of this object) and\n     * traverses down the path.\n     * \n     * @param propertyName property name\n     * @param path lookup path\n     * @return true if the property is indexed\n     */\n    public boolean isIndexed(String propertyName, String path, Filter filter) {\n        if(PathUtils.denotesRoot(path)){\n            return getIndexDataNode(root, propertyName, filter) != null;\n        }\n        NodeState node = root;\n        Iterator<String> it = PathUtils.elements(path).iterator();\n        while (it.hasNext()) {\n            if (getIndexDataNode(node, propertyName, filter) != null) {\n                return true;\n            }\n            node = node.getChildNode(it.next());\n        }\n        return false;\n    }","commit_id":"896df80a8e6eae08811188221e797e88cb789ef7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Iterable<String> query(Filter filter, String propertyName, PropertyValue value) {\n        NodeState state = getIndexDataNode(root, propertyName);\n        if (state == null) {\n            throw new IllegalArgumentException(\"No index for \" + propertyName);\n        }\n        List<String> values = value == null ? null : Property2Index.encode(value);\n        return store.query(filter, propertyName, state, values);\n    }","id":91461,"modified_method":"public Iterable<String> query(Filter filter, String propertyName, PropertyValue value) {\n        NodeState state = getIndexDataNode(root, propertyName, filter);\n        if (state == null) {\n            throw new IllegalArgumentException(\"No index for \" + propertyName);\n        }\n        List<String> values = value == null ? null : Property2Index.encode(value);\n        return store.query(filter, propertyName, state, values);\n    }","commit_id":"896df80a8e6eae08811188221e797e88cb789ef7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public double getCost(String name, PropertyValue value) {\n        NodeState state = getIndexDataNode(root, name);\n        if (state == null) {\n            return Double.POSITIVE_INFINITY;\n        }\n        List<String> it = value == null ? null : Property2Index.encode(value);\n        return store.count(state, it, MAX_COST);\n    }","id":91462,"modified_method":"public double getCost(Filter filter, String name, PropertyValue value) {\n        NodeState state = getIndexDataNode(root, name, filter);\n        if (state == null) {\n            return Double.POSITIVE_INFINITY;\n        }\n        List<String> it = value == null ? null : Property2Index.encode(value);\n        return store.count(state, it, MAX_COST);\n    }","commit_id":"896df80a8e6eae08811188221e797e88cb789ef7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Get the node with the index data for the given property, if there is an\n     * applicable index with data.\n     * \n     * @param propertyName the property name\n     * @return the node where the index data is stored, or null if no index\n     *         definition or index data node was found\n     */\n    @Nullable\n    private static NodeState getIndexDataNode(NodeState node, String propertyName) {\n        NodeState state = node.getChildNode(INDEX_DEFINITIONS_NAME);\n        if (state != null) {\n            for (ChildNodeEntry entry : state.getChildNodeEntries()) {\n                PropertyState type = entry.getNodeState().getProperty(IndexConstants.TYPE_PROPERTY_NAME);\n                if (type == null || type.isArray() || !Property2Index.TYPE.equals(type.getValue(Type.STRING))) {\n                    continue;\n                }\n                PropertyState names = entry.getNodeState().getProperty(\"propertyNames\");\n                if (names != null) {\n                    for (int i = 0; i < names.count(); i++) {\n                        if (propertyName.equals(names.getValue(Type.STRING, i))) {\n                            NodeState indexDef = entry.getNodeState();\n                            NodeState index = indexDef.getChildNode(\":index\");\n                            if (index != null) {\n                                return index;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }","id":91463,"modified_method":"/**\n     * Get the node with the index data for the given property, if there is an\n     * applicable index with data.\n     * \n     * @param propertyName the property name\n     * @param filter for the node type restriction\n     * @return the node where the index data is stored, or null if no index\n     *         definition or index data node was found\n     */\n    @Nullable\n    private static NodeState getIndexDataNode(NodeState node, String propertyName, Filter filter) {\n        NodeState state = node.getChildNode(INDEX_DEFINITIONS_NAME);\n        if (state == null) {\n            return null;\n        }\n        String filterNodeType = null;\n        if (filter != null) {\n            filterNodeType = filter.getNodeType();\n        }\n        //keep a fallback to a matching index def that has *no* node type constraints\n        NodeState fallback = null;\n        for (ChildNodeEntry entry : state.getChildNodeEntries()) {\n            NodeState ns = entry.getNodeState();\n            PropertyState type = ns.getProperty(TYPE_PROPERTY_NAME);\n            if (type == null || type.isArray() || !Property2Index.TYPE.equals(type.getValue(Type.STRING))) {\n                continue;\n            }\n            if (containsValue(ns.getProperty(PROPERTY_NAMES), propertyName)) {\n                if (filterNodeType == null\n                        || containsValue(ns.getProperty(DECLARING_NODE_TYPES),\n                                filterNodeType)) {\n                    return ns.getChildNode(\":index\");\n                }\n                if (ns.getProperty(DECLARING_NODE_TYPES) == null) {\n                    fallback = ns.getChildNode(\":index\");\n                }\n            }\n        }\n        return fallback;\n    }","commit_id":"896df80a8e6eae08811188221e797e88cb789ef7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static Set<String> find(Property2IndexLookup lookup, String name, String value) {\n        return Sets.newHashSet(lookup.query(null, name, value == null ? null : PropertyValues.newString(value)));\n    }","id":91464,"modified_method":"private static Set<String> find(Property2IndexLookup lookup, String name, String value) {\n        return find(lookup, name, value, null);\n    }","commit_id":"896df80a8e6eae08811188221e797e88cb789ef7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testPropertyLookup() throws Exception {\n        NodeState root = MemoryNodeState.EMPTY_NODE;\n\n        // Add index definition\n        NodeBuilder builder = root.builder();\n        builder.child(\"oak:index\").child(\"foo\")\n                .setProperty(\"jcr:primaryType\", \"oak:queryIndexDefinition\", Type.NAME)\n                .setProperty(\"type\", \"p2\")\n                .setProperty(\"propertyNames\", \"foo\");\n        NodeState before = builder.getNodeState();\n\n        // Add some content and process it through the property index hook\n        builder = before.builder();\n        builder.child(\"a\").setProperty(\"foo\", \"abc\");\n        builder.child(\"b\").setProperty(\"foo\", Arrays.asList(\"abc\", \"def\"), Type.STRINGS);\n        // plus lots of dummy content to highlight the benefit of indexing\n        for (int i = 0; i < MANY; i++) {\n            builder.child(\"n\" + i).setProperty(\"foo\", \"xyz\");\n        }\n        NodeState after = builder.getNodeState();\n\n        // Add an index\n        IndexHook p = new Property2IndexDiff(builder);\n        after.compareAgainstBaseState(before, p);\n        p.apply();\n        p.close();\n\n        // Query the index\n        Property2IndexLookup lookup = new Property2IndexLookup(builder.getNodeState());\n        assertEquals(ImmutableSet.of(\"a\", \"b\"), find(lookup, \"foo\", \"abc\"));\n        assertEquals(ImmutableSet.of(\"b\"), find(lookup, \"foo\", \"def\"));\n        assertEquals(ImmutableSet.of(), find(lookup, \"foo\", \"ghi\"));\n        assertEquals(MANY, find(lookup, \"foo\", \"xyz\").size());\n        assertEquals(MANY + 2, find(lookup, \"foo\", null).size());\n\n        double cost;\n        cost = lookup.getCost(\"foo\", PropertyValues.newString(\"xyz\"));\n        assertTrue(\"cost: \" + cost, cost >= MANY);\n        cost = lookup.getCost(\"foo\", null);\n        assertTrue(\"cost: \" + cost, cost >= MANY);\n    }","id":91465,"modified_method":"@Test\n    public void testPropertyLookup() throws Exception {\n        NodeState root = MemoryNodeState.EMPTY_NODE;\n\n        // Add index definition\n        NodeBuilder builder = root.builder();\n        builder.child(\"oak:index\").child(\"foo\")\n                .setProperty(\"jcr:primaryType\", \"oak:queryIndexDefinition\", Type.NAME)\n                .setProperty(\"type\", \"p2\")\n                .setProperty(\"propertyNames\", \"foo\");\n        NodeState before = builder.getNodeState();\n\n        // Add some content and process it through the property index hook\n        builder = before.builder();\n        builder.child(\"a\").setProperty(\"foo\", \"abc\");\n        builder.child(\"b\").setProperty(\"foo\", Arrays.asList(\"abc\", \"def\"), Type.STRINGS);\n        // plus lots of dummy content to highlight the benefit of indexing\n        for (int i = 0; i < MANY; i++) {\n            builder.child(\"n\" + i).setProperty(\"foo\", \"xyz\");\n        }\n        NodeState after = builder.getNodeState();\n\n        // Add an index\n        IndexHook p = new Property2IndexDiff(builder);\n        after.compareAgainstBaseState(before, p);\n        p.apply();\n        p.close();\n\n        // Query the index\n        Property2IndexLookup lookup = new Property2IndexLookup(builder.getNodeState());\n        assertEquals(ImmutableSet.of(\"a\", \"b\"), find(lookup, \"foo\", \"abc\"));\n        assertEquals(ImmutableSet.of(\"b\"), find(lookup, \"foo\", \"def\"));\n        assertEquals(ImmutableSet.of(), find(lookup, \"foo\", \"ghi\"));\n        assertEquals(MANY, find(lookup, \"foo\", \"xyz\").size());\n        assertEquals(MANY + 2, find(lookup, \"foo\", null).size());\n\n        double cost;\n        cost = lookup.getCost(null, \"foo\", PropertyValues.newString(\"xyz\"));\n        assertTrue(\"cost: \" + cost, cost >= MANY);\n        cost = lookup.getCost(null, \"foo\", null);\n        assertTrue(\"cost: \" + cost, cost >= MANY);\n    }","commit_id":"896df80a8e6eae08811188221e797e88cb789ef7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void setNode(String name, NodeState state) {\n        MutableNodeState mstate = write();\n\n        MemoryNodeStateBuilder builder = mstate.builders.get(name);\n        if (builder != null) {\n            builder.reset(state);\n        } else {\n            createChildBuilder(name, state).write();\n        }\n\n        updated();\n    }","id":91466,"modified_method":"@Override\n    public void setNode(String name, NodeState state) {\n        MutableNodeState mstate = write();\n\n        MutableNodeState cstate = mstate.nodes.get(name);\n        if (cstate != null) {\n            cstate.reset(state);\n        } else {\n            mstate.nodes.remove(name);\n            createChildBuilder(name, state).write();\n        }\n\n        updated();\n    }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void reset(NodeState newBase) {\n        MutableNodeState mstate = write();\n\n        mstate.base = newBase;\n\n        mstate.properties.clear();\n\n        Iterator<Map.Entry<String, MemoryNodeStateBuilder>> iterator =\n                mstate.builders.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<String, MemoryNodeStateBuilder> entry = iterator.next();\n            MemoryNodeStateBuilder childBuilder = entry.getValue();\n            NodeState childBase = newBase.getChildNode(entry.getKey());\n            if (childBase == null || childBuilder == null) {\n                iterator.remove();\n            } else {\n                childBuilder.reset(childBase);\n            }\n        }\n    }","id":91467,"modified_method":"protected void reset(NodeState newBase) {\n        write().reset(newBase);\n    }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private NodeState read() {\n        if (parent != null) {\n            NodeState pstate = parent.read();\n            if (pstate instanceof MutableNodeState) {\n                MutableNodeState mstate = (MutableNodeState) pstate;\n                MemoryNodeStateBuilder existing = mstate.builders.get(name);\n                if (existing != null) {\n                    state = existing.state;\n                    parent = null;\n                    name = null;\n                }\n            }\n        }\n        return state;\n    }","id":91468,"modified_method":"private NodeState read() {\n        if (writeState == null) {\n            parent.read();\n            MutableNodeState pstate = parent.writeState;\n            if (pstate != null) {\n                MutableNodeState mstate = pstate.nodes.get(name);\n                if (mstate == null && pstate.nodes.containsKey(name)) {\n                    mstate = new MutableNodeState(NULL_STATE);\n                }\n                if (mstate != null) {\n                    parent = null;\n                    name = null;\n                    readState = mstate;\n                    writeState = mstate;\n                }\n            }\n        }\n        return readState;\n    }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public Iterable<String> getChildNodeNames() {\n            Iterable<String> unmodified = base.getChildNodeNames();\n            Predicate<String> unmodifiedFilter = Predicates.not(Predicates.in(\n                    ImmutableSet.copyOf(builders.keySet())));\n            Set<String> modified = ImmutableSet.copyOf(\n                    Maps.filterValues(builders, Predicates.notNull()).keySet());\n            return Iterables.concat(\n                    Iterables.filter(unmodified, unmodifiedFilter),\n                    modified);\n        }","id":91469,"modified_method":"@Override\n        public Iterable<String> getChildNodeNames() {\n            Iterable<String> unmodified = base.getChildNodeNames();\n            Predicate<String> unmodifiedFilter = Predicates.not(Predicates.in(\n                    ImmutableSet.copyOf(nodes.keySet())));\n            Set<String> modified = ImmutableSet.copyOf(\n                    Maps.filterValues(nodes, Predicates.notNull()).keySet());\n            return Iterables.concat(\n                    Iterables.filter(unmodified, unmodifiedFilter),\n                    modified);\n        }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private MutableNodeState write() {\n        if (parent != null) {\n            MutableNodeState mstate = parent.write();\n            MemoryNodeStateBuilder existing = mstate.builders.get(name);\n            if (existing != null) {\n                state = existing.state;\n            } else {\n                state = new MutableNodeState(state);\n                mstate.builders.put(name, this);\n            }\n            parent = null;\n            name = null;\n        }\n        return (MutableNodeState) state;\n    }","id":91470,"modified_method":"private MutableNodeState write() {\n        if (writeState == null) {\n            MutableNodeState pstate = parent.write();\n            MutableNodeState mstate = pstate.nodes.get(name);\n            if (mstate == null) {\n                if (pstate.nodes.containsKey(name)) {\n                    mstate = new MutableNodeState(NULL_STATE);\n                } else {\n                    mstate = new MutableNodeState(readState);\n                    pstate.nodes.put(name, mstate);\n                }\n            }\n            parent = null;\n            name = null;\n            readState = mstate;\n            writeState = mstate;\n        }\n        return writeState;\n    }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void removeNode(String name) {\n        MutableNodeState mstate = write();\n\n        if (mstate.base.getChildNode(name) != null) {\n            mstate.builders.put(name, null);\n        } else {\n            mstate.builders.remove(name);\n        }\n\n        updated();\n    }","id":91471,"modified_method":"@Override\n    public void removeNode(String name) {\n        MutableNodeState mstate = write();\n\n        if (mstate.base.getChildNode(name) != null) {\n            mstate.nodes.put(name, null);\n        } else {\n            mstate.nodes.remove(name);\n        }\n\n        updated();\n    }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected NodeState getBaseState() {\n        NodeState state = read();\n        if (state instanceof MutableNodeState) { \n            return ((MutableNodeState) state).base;\n        } else {\n            return state;\n        }\n    }","id":91472,"modified_method":"protected NodeState getBaseState() {\n        NodeState state = read();\n        if (writeState != null) {\n            return writeState.base;\n        } else {\n            return state;\n        }\n    }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public NodeState snapshot() {\n            Map<String, PropertyState> props = Maps.newHashMap(properties);\n            Map<String, NodeState> nodes = Maps.newHashMap();\n            for (Map.Entry<String, MemoryNodeStateBuilder> entry\n                    : builders.entrySet()) {\n                NodeStateBuilder builder = entry.getValue();\n                if (builder != null) {\n                    nodes.put(entry.getKey(), builder.getNodeState());\n                } else {\n                    nodes.put(entry.getKey(), null);\n                }\n            }\n            return new ModifiedNodeState(base, props, nodes);\n        }","id":91473,"modified_method":"private NodeState snapshot() {\n            Map<String, PropertyState> props = Maps.newHashMap(properties);\n            Map<String, NodeState> snapshots = Maps.newHashMap();\n            for (Map.Entry<String, MutableNodeState> entry : nodes.entrySet()) {\n                String name = entry.getKey();\n                MutableNodeState node = entry.getValue();\n                if (node != null) {\n                    snapshots.put(name, node.snapshot());\n                } else {\n                    snapshots.put(name, null);\n                }\n            }\n            return new ModifiedNodeState(base, props, snapshots);\n        }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeStateBuilder getChildBuilder(String name) {\n        NodeState state = read();\n\n        if (!(state instanceof MutableNodeState)) {\n            NodeState base = state.getChildNode(name);\n            if (base != null) {\n                return createChildBuilder(name, base); // shortcut\n            }\n        }\n\n        MutableNodeState mstate = write();\n        MemoryNodeStateBuilder builder = mstate.builders.get(name);\n        if (builder == null) {\n            if (mstate.builders.containsKey(name)) {\n                builder = createChildBuilder(name, NULL_STATE);\n                builder.write();\n            } else {\n                NodeState base = mstate.base.getChildNode(name);\n                if (base == null) {\n                    base = NULL_STATE;\n                }\n                builder = createChildBuilder(name, base);\n            }\n        }\n        return builder;\n    }","id":91474,"modified_method":"@Override\n    public NodeStateBuilder getChildBuilder(String name) {\n        NodeState state = read();\n\n        if (writeState == null) {\n            NodeState base = state.getChildNode(name);\n            if (base != null) {\n                return createChildBuilder(name, base); // shortcut\n            }\n        }\n\n        NodeState cbase = NULL_STATE;\n        MutableNodeState mstate = write();\n        MutableNodeState cstate = mstate.nodes.get(name);\n        if (cstate != null) {\n            cbase = cstate.base;\n        } else if (!mstate.nodes.containsKey(name)\n                && mstate.base.hasChildNode(name)) {\n            return createChildBuilder(name, mstate.base.getChildNode(name));\n        }\n\n        MemoryNodeStateBuilder builder = createChildBuilder(name, cbase);\n        builder.write();\n        return builder;\n    }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates a new in-memory node state builder.\n     *\n     * @param base base state of the new builder\n     */\n    public MemoryNodeStateBuilder(NodeState base) {\n        this.parent = null;\n        this.name = null;\n        this.state = new MutableNodeState(checkNotNull(base));\n    }","id":91475,"modified_method":"/**\n     * Creates a new in-memory node state builder.\n     *\n     * @param base base state of the new builder\n     */\n    public MemoryNodeStateBuilder(NodeState base) {\n        this.parent = null;\n        this.name = null;\n        MutableNodeState mstate = new MutableNodeState(checkNotNull(base));\n        this.readState = mstate;\n        this.writeState = mstate;\n    }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public long getChildNodeCount() {\n            long count = base.getChildNodeCount();\n\n            for (Map.Entry<String, MemoryNodeStateBuilder> entry\n                    : builders.entrySet()) {\n                if (base.getChildNode(entry.getKey()) != null) {\n                    count--;\n                }\n                if (entry.getValue() != null) {\n                    count++;\n                }\n            }\n\n            return count;\n        }","id":91476,"modified_method":"@Override\n        public long getChildNodeCount() {\n            long count = base.getChildNodeCount();\n\n            for (Map.Entry<String, MutableNodeState> entry : nodes.entrySet()) {\n                if (base.getChildNode(entry.getKey()) != null) {\n                    count--;\n                }\n                if (entry.getValue() != null) {\n                    count++;\n                }\n            }\n\n            return count;\n        }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public boolean hasChildNode(String name) {\n            NodeStateBuilder builder = builders.get(name);\n            if (builder != null) {\n                return true;\n            } else if (builders.containsKey(name)) {\n                return false;\n            }\n\n            return base.getChildNode(name) != null;\n        }","id":91477,"modified_method":"@Override\n        public boolean hasChildNode(String name) {\n            MutableNodeState node = nodes.get(name);\n            if (node != null) {\n                return true;\n            } else if (nodes.containsKey(name)) {\n                return false;\n            }\n\n            return base.hasChildNode(name);\n        }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeState getNodeState() {\n        NodeState state = read();\n        if (state instanceof MutableNodeState) {\n            return ((MutableNodeState) state).snapshot();\n        } else {\n            return state;\n        }\n    }","id":91478,"modified_method":"@Override\n    public NodeState getNodeState() {\n        NodeState state = read();\n        if (writeState != null) {\n            return writeState.snapshot();\n        } else {\n            return state;\n        }\n    }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public MutableNodeState(NodeState base) {\n            this.base = base;\n        }","id":91479,"modified_method":"public MutableNodeState(NodeState base) {\n            this.base = checkNotNull(base);\n        }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates a new in-memory node state builder.\n     *\n     * @param parent parent node state builder\n     * @param name name of this node\n     * @param base base state of this node\n     */\n    protected MemoryNodeStateBuilder(\n            MemoryNodeStateBuilder parent, String name, NodeState base) {\n        this.parent = checkNotNull(parent);\n        this.name = checkNotNull(name);\n        this.state = checkNotNull(base);\n    }","id":91480,"modified_method":"/**\n     * Creates a new in-memory node state builder.\n     *\n     * @param parent parent node state builder\n     * @param name name of this node\n     * @param base base state of this node\n     */\n    protected MemoryNodeStateBuilder(\n            MemoryNodeStateBuilder parent, String name, NodeState base) {\n        this.parent = checkNotNull(parent);\n        this.name = checkNotNull(name);\n        this.readState = checkNotNull(base);\n        this.writeState = null;\n    }","commit_id":"4c15daf6218072e6aa717a07676ca6b1bbf8f0a1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void refresh() {\n        root = workspaceName == null\n            ? store.getRoot()\n            : store.getRoot().getChildNode(workspaceName);\n    }","id":91481,"modified_method":"@Override\n    public void refresh() {\n        root = store.getRoot().getChildNode(workspaceName);\n    }","commit_id":"79e1dcaf994ee9c72ee91740fce3b49c213f1a3a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void validateChooseType(ChannelDefinitionForm def, MessageContext context) {\n\t\tif(def.getTypeId() == 0) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"typeId\")\n\t\t\t\t\t.code(\"errors.channelDefinition.type.empty\")\n\t\t\t\t\t.defaultText(\"Please choose a channel type\").build());\n\t\t}\n\t}","id":91482,"modified_method":"public void validateChooseType(ChannelDefinitionForm def, MessageContext context) {\n\t\tif(def.getTypeId() == 0) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"typeId\")\n\t\t\t\t\t.code(\"please.choose.channel.type\").build());\n\t\t}\n\t}","commit_id":"8636d5e5417acaba5a52809379f8c465f1a67ab9","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void validateSetParameters(ChannelDefinitionForm def, MessageContext context) {\n\t\tChannelPublishingDefinition cpd = channelPublishingDefinitionDao.getChannelPublishingDefinition(def.getTypeId());\n\t\tfor (CPDStep step : cpd.getParams().getSteps()) {\n\t\t\tif (step.getParameters() != null) {\n\t\t\t\tfor (CPDParameter param : step.getParameters()) {\n\t\t\t\t\t\n\t\t\t\t\t// if the user has entered a value for this parameter, \n\t\t\t\t\t// check it against the CPD\n\t\t\t\t\tif (def.getParameters().containsKey(param.getName()) && \n\t\t\t\t\t\t\t!StringUtils.isEmpty(def.getParameters().get(param.getName()).getValue())) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tString paramValue = def.getParameters().get(param.getName()).getValue();\n\t\t\t\t\t\tString paramPath = \"parameters['\" + param.getName() + \"'].value\";\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if this parameter is intended to be a number, ensure\n\t\t\t\t\t\t// that it is\n\t\t\t\t\t\tString base = param.getType().getBase();\n\t\t\t\t\t\tif (\"integer\".equals(base)) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tInteger.parseInt(paramValue);\n\t\t\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\t\t\tcontext.addMessage(new MessageBuilder().error().source(paramPath)\n\t\t\t\t\t\t\t\t\t\t.code(\"errors.channelDefinition.param.int\")\n\t\t\t\t\t\t\t\t\t\t.defaultText(\"Value must be an integer\").build());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (\"float\".equals(base)) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tFloat.parseFloat(paramValue);\n\t\t\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\t\t\tcontext.addMessage(new MessageBuilder().error().source(paramPath)\n\t\t\t\t\t\t\t\t\t\t.code(\"errors.channelDefinition.param.float\")\n\t\t\t\t\t\t\t\t\t\t.defaultText(\"Value must be a number\").build());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if this parameter has a restriction in the CPD, \n\t\t\t\t\t\t// check it against the restriction\n\t\t\t\t\t\tif (param.getType().getRestriction() != null \n\t\t\t\t\t\t\t\t&& def.getParameters().containsKey(param.getName())) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tCPDParameterTypeRestriction restriction = param.getType().getRestriction();\n\t\t\t\t\t\t\tif (\"range\".equals(restriction.getType())) {\n\t\t\t\t\t\t\t\t// For now, lets just not do anything.  It doesn't \n\t\t\t\t\t\t\t\t// look like the existing channel manager logic \n\t\t\t\t\t\t\t\t// actually uses this restriction for validation\n\t\t\t\t\t\t\t} else if (\"enumeration\".equals(restriction.getType())) {\n\t\t\t\t\t\t\t\t// if this restriction is an enumeration of allowed values, check to\n\t\t\t\t\t\t\t\t// make sure the entered value is in the enumerated list\n\t\t\t\t\t\t\t\tif (!restriction.getValues().contains(paramValue)) {\n\t\t\t\t\t\t\t\t\tcontext.addMessage(new MessageBuilder().error().source(paramPath)\n\t\t\t\t\t\t\t\t\t\t\t.code(\"errors.channelDefinition.param.enum\")\n\t\t\t\t\t\t\t\t\t\t\t.defaultText(\"Invalid selection\").build());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":91483,"modified_method":"public void validateSetParameters(ChannelDefinitionForm def, MessageContext context) {\n\t\tChannelPublishingDefinition cpd = channelPublishingDefinitionDao.getChannelPublishingDefinition(def.getTypeId());\n\t\tfor (CPDStep step : cpd.getParams().getSteps()) {\n\t\t\tif (step.getParameters() != null) {\n\t\t\t\tfor (CPDParameter param : step.getParameters()) {\n\t\t\t\t\t\n\t\t\t\t\t// if the user has entered a value for this parameter, \n\t\t\t\t\t// check it against the CPD\n\t\t\t\t\tif (def.getParameters().containsKey(param.getName()) && \n\t\t\t\t\t\t\t!StringUtils.isEmpty(def.getParameters().get(param.getName()).getValue())) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tString paramValue = def.getParameters().get(param.getName()).getValue();\n\t\t\t\t\t\tString paramPath = \"parameters['\" + param.getName() + \"'].value\";\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if this parameter is intended to be a number, ensure\n\t\t\t\t\t\t// that it is\n\t\t\t\t\t\tString base = param.getType().getBase();\n\t\t\t\t\t\tif (\"integer\".equals(base)) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tInteger.parseInt(paramValue);\n\t\t\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\t\t\tcontext.addMessage(new MessageBuilder().error().source(paramPath)\n\t\t\t\t\t\t\t\t\t\t.code(\"value.must.be.int\").build());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (\"float\".equals(base)) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tFloat.parseFloat(paramValue);\n\t\t\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\t\t\tcontext.addMessage(new MessageBuilder().error().source(paramPath)\n\t\t\t\t\t\t\t\t\t\t.code(\"value.must.be.num\").build());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if this parameter has a restriction in the CPD, \n\t\t\t\t\t\t// check it against the restriction\n\t\t\t\t\t\tif (param.getType().getRestriction() != null \n\t\t\t\t\t\t\t\t&& def.getParameters().containsKey(param.getName())) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tCPDParameterTypeRestriction restriction = param.getType().getRestriction();\n\t\t\t\t\t\t\tif (\"range\".equals(restriction.getType())) {\n\t\t\t\t\t\t\t\t// For now, lets just not do anything.  It doesn't \n\t\t\t\t\t\t\t\t// look like the existing channel manager logic \n\t\t\t\t\t\t\t\t// actually uses this restriction for validation\n\t\t\t\t\t\t\t} else if (\"enumeration\".equals(restriction.getType())) {\n\t\t\t\t\t\t\t\t// if this restriction is an enumeration of allowed values, check to\n\t\t\t\t\t\t\t\t// make sure the entered value is in the enumerated list\n\t\t\t\t\t\t\t\tif (!restriction.getValues().contains(paramValue)) {\n\t\t\t\t\t\t\t\t\tcontext.addMessage(new MessageBuilder().error().source(paramPath)\n\t\t\t\t\t\t\t\t\t\t\t.code(\"invalid.selection\").build());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"8636d5e5417acaba5a52809379f8c465f1a67ab9","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void validateBasicInfo(ChannelDefinitionForm def, MessageContext context) {\n\t\tMatcher matcher = FunctionalNameType.VALID_FNAME_PATTERN.matcher(def.getFname());\n\t\tif (StringUtils.isEmpty(def.getFname())) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"fName\")\n\t\t\t\t\t.code(\"errors.channelDefinition.fName.empty\")\n\t\t\t\t\t.defaultText(\"Please enter an fname\").build());\n\t\t} else if (!matcher.matches()) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"fName\")\n\t\t\t\t\t.code(\"errors.channelDefinition.fName.invalid\")\n\t\t\t\t\t.defaultText(\"Fnames may only contain letters, numbers, dashes, and underscores\").build());\t\t\n\t\t} \n\t\t\n\t\t// if this is a new channel and the fname is already taken\n\t\telse if (def.getId() == -1 && channelStore.getChannelDefinition(def.getFname()) != null) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"fName\")\n\t\t\t\t\t.code(\"errors.channelDefinition.fName.duplicate\")\n\t\t\t\t\t.defaultText(\"This fname is already in use\").build());\n\t\t}\n\t\t\n\t\tif (StringUtils.isEmpty(def.getTitle())) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"title\")\n\t\t\t\t\t.code(\"errors.channelDefinition.title.empty\")\n\t\t\t\t\t.defaultText(\"Please enter a title\").build());\n\t\t}\n\t\t\n\t\tif (StringUtils.isEmpty(def.getName())) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"name\")\n\t\t\t\t\t.code(\"errors.channelDefinition.name.empty\")\n\t\t\t\t\t.defaultText(\"Please enter a name\").build());\n\t\t}\n\n\t\t// if this is a new channel and the name is already taken\n\t\tif (def.getId() == -1 && channelStore.getChannelDefinitionByName(def.getName()) != null) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"name\")\n\t\t\t\t\t.code(\"errors.channelDefinition.name.duplicate\")\n\t\t\t\t\t.defaultText(\"This name is already in use\").build());\n\t\t}\n\t\t\n\n\t}","id":91484,"modified_method":"public void validateBasicInfo(ChannelDefinitionForm def, MessageContext context) {\n\t\tMatcher matcher = FunctionalNameType.VALID_FNAME_PATTERN.matcher(def.getFname());\n\t\tif (StringUtils.isEmpty(def.getFname())) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"fName\")\n\t\t\t\t\t.code(\"please.enter.fname\").build());\n\t\t} else if (!matcher.matches()) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"fName\")\n\t\t\t\t\t.code(\"fname.invalid\").build());\t\t\n\t\t} \n\t\t\n\t\t// if this is a new channel and the fname is already taken\n\t\telse if (def.getId() == -1 && channelStore.getChannelDefinition(def.getFname()) != null) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"fName\")\n\t\t\t\t\t.code(\"fname.in.use\").build());\n\t\t}\n\t\t\n\t\tif (StringUtils.isEmpty(def.getTitle())) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"title\")\n\t\t\t\t\t.code(\"please.enter.title\").build());\n\t\t}\n\t\t\n\t\tif (StringUtils.isEmpty(def.getName())) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"name\")\n\t\t\t\t\t.code(\"please.enter.name\").build());\n\t\t}\n\n\t\t// if this is a new channel and the name is already taken\n\t\tif (def.getId() == -1 && channelStore.getChannelDefinitionByName(def.getName()) != null) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"name\")\n\t\t\t\t\t.code(\"name.in.use\").build());\n\t\t}\n\t\t\n\n\t}","commit_id":"8636d5e5417acaba5a52809379f8c465f1a67ab9","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void validateChooseGroup(ChannelDefinitionForm def, MessageContext context) {\n\t\t// make sure the user has picked at least one group\n\t\tif (def.getGroups().size() == 0) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"groups\")\n\t\t\t\t\t.code(\"errors.channelDefinition.groups.empty\")\n\t\t\t\t\t.defaultText(\"Please choose at least one group\").build());\n\t\t}\n\t}","id":91485,"modified_method":"public void validateChooseGroup(ChannelDefinitionForm def, MessageContext context) {\n\t\t// make sure the user has picked at least one group\n\t\tif (def.getGroups().size() == 0) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"groups\")\n\t\t\t\t\t.code(\"please.choose.at.least.one.group\").build());\n\t\t}\n\t}","commit_id":"8636d5e5417acaba5a52809379f8c465f1a67ab9","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void validateChooseCategory(ChannelDefinitionForm def, MessageContext context) {\n\t\t// make sure the user has picked at least one category\n\t\tif (def.getCategories().size() == 0) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"categories\")\n\t\t\t\t\t.code(\"errors.channelDefinition.param.categories.empty\")\n\t\t\t\t\t.defaultText(\"Please choose at least one category\").build());\n\t\t}\n\t}","id":91486,"modified_method":"public void validateChooseCategory(ChannelDefinitionForm def, MessageContext context) {\n\t\t// make sure the user has picked at least one category\n\t\tif (def.getCategories().size() == 0) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"categories\")\n\t\t\t\t\t.code(\"please.choose.at.least.one.category\").build());\n\t\t}\n\t}","commit_id":"8636d5e5417acaba5a52809379f8c465f1a67ab9","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void validateLifecycle(ChannelDefinitionForm def, ValidationContext context) {\n\t\tMessageContext messageContext = context.getMessageContext();\n\t\t\n\t\tif (def.getLifecycleState() == null) {\n\t\t\tmessageContext.addMessage(new MessageBuilder().error().source(\"lifecycle\")\n\t\t\t\t\t.code(\"lifecycle.error.selectLifecycle\")\n\t\t\t\t\t.defaultText(\"Please select a lifecycle stage\").build());\n\t\t}\n\t\tDate now = new Date();\n\t\tif (def.getPublishDate() != null) {\n\t\t\tif (def.getPublishDateTime().before(now)) {\n\t\t\t\tmessageContext.addMessage(new MessageBuilder().error().source(\"publishDate\")\n\t\t\t\t\t\t.code(\"lifecycle.error.invalidPublishDate\")\n\t\t\t\t\t\t.defaultText(\"The auto-publishing date must be in the future\").build());\n\t\t\t}\n\t\t}\n\t\tif (def.getExpirationDate() != null) {\n\t\t\tif (def.getExpirationDateTime().before(now)) {\n\t\t\t\tmessageContext.addMessage(new MessageBuilder().error().source(\"expirationDate\")\n\t\t\t\t\t\t.code(\"lifecycle.error.invalidExpirationDate\")\n\t\t\t\t\t\t.defaultText(\"The auto-expiration date must be in the future\").build());\n\t\t\t}\n\t\t}\n\t\tif (def.getPublishDate() != null && def.getExpirationDate() != null) {\n\t\t\tif (def.getExpirationDateTime().before(def.getPublishDateTime())) {\n\t\t\t\tmessageContext.addMessage(new MessageBuilder().error().source(\"expirationDate\")\n\t\t\t\t\t\t.code(\"lifecycle.error.invalidPublishAndExpirationDate\")\n\t\t\t\t\t\t.defaultText(\"The auto-expiration date must be after the auto-publish date\").build());\n\t\t\t}\n\t\t}\n\t}","id":91487,"modified_method":"public void validateLifecycle(ChannelDefinitionForm def, ValidationContext context) {\n\t\tMessageContext messageContext = context.getMessageContext();\n\t\t\n\t\tif (def.getLifecycleState() == null) {\n\t\t\tmessageContext.addMessage(new MessageBuilder().error().source(\"lifecycle\")\n\t\t\t\t\t.code(\"please.select.lifecycle.stage\").build());\n\t\t}\n\t\tDate now = new Date();\n\t\tif (def.getPublishDate() != null) {\n\t\t\tif (def.getPublishDateTime().before(now)) {\n\t\t\t\tmessageContext.addMessage(new MessageBuilder().error().source(\"publishDate\")\n\t\t\t\t\t\t.code(\"auto.publish.date.must.be.future\").build());\n\t\t\t}\n\t\t}\n\t\tif (def.getExpirationDate() != null) {\n\t\t\tif (def.getExpirationDateTime().before(now)) {\n\t\t\t\tmessageContext.addMessage(new MessageBuilder().error().source(\"expirationDate\")\n\t\t\t\t\t\t.code(\"auto.expire.date.must.be.future\").build());\n\t\t\t}\n\t\t}\n\t\tif (def.getPublishDate() != null && def.getExpirationDate() != null) {\n\t\t\tif (def.getExpirationDateTime().before(def.getPublishDateTime())) {\n\t\t\t\tmessageContext.addMessage(new MessageBuilder().error().source(\"expirationDate\")\n\t\t\t\t\t\t.code(\"auto.expire.date.must.be.after.publish\").build());\n\t\t\t}\n\t\t}\n\t}","commit_id":"8636d5e5417acaba5a52809379f8c465f1a67ab9","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n\t * Validate the detail editing group view\n\t * \n\t * @param group\t\n\t * @param context   \n\t */\n\tpublic void validateEditDetails(GroupForm group, MessageContext context) {\n\t\t\n\t\t// ensure the group name is set\n\t\tif(StringUtils.isBlank(group.getName())) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"name\")\n\t\t\t\t\t.code(\"errors.group.name.empty\")\n\t\t\t\t\t.defaultText(\"Please choose a group name\").build());\n\t\t}\n\t\t\n\t}","id":91488,"modified_method":"/**\n\t * Validate the detail editing group view\n\t * \n\t * @param group\t\n\t * @param context   \n\t */\n\tpublic void validateEditDetails(GroupForm group, MessageContext context) {\n\t\t\n\t\t// ensure the group name is set\n\t\tif(StringUtils.isBlank(group.getName())) {\n\t\t\tcontext.addMessage(new MessageBuilder().error().source(\"name\")\n\t\t\t\t\t.code(\"please.enter.name\").build());\n\t\t}\n\t\t\n\t}","commit_id":"8636d5e5417acaba5a52809379f8c465f1a67ab9","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void validateEditPermission(PermissionDefinitionForm form, MessageContext messageContext) {\n\n        // ensure at least one principal has been assigned\n        if (form.getPermissions().isEmpty()) {\n            messageContext.addMessage(new MessageBuilder().error().source(\"principal\")\n                .defaultText(\"Specify one or more principals\").build());\n        }\n\n    }","id":91489,"modified_method":"public void validateEditPermission(PermissionDefinitionForm form, MessageContext messageContext) {\n\n        // ensure at least one principal has been assigned\n        if (form.getPermissions().isEmpty()) {\n            messageContext.addMessage(new MessageBuilder().error().source(\"principal\")\n                .code(\"please.choose.at.least.one.principal\").build());\n        }\n\n    }","commit_id":"8636d5e5417acaba5a52809379f8c465f1a67ab9","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void validateEditLocalAccount(PersonForm person, MessageContext context) {\n        \n        // ensure that this username isn't already taken\n        if (person.getId() < 0 && accountDao.getPerson(person.getUsername()) != null) {\n            context.addMessage(new MessageBuilder().error().source(\"username\")\n                    .code(\"username.already.in.use\")\n                    .defaultText(\"This username is already in use\").build());\n        } \n        \n        if (StringUtils.isNotBlank(person.getPassword()) || StringUtils.isNotBlank(person.getConfirmPassword())) {\n            if (person.getPassword() == null || !person.getPassword().equals(person.getConfirmPassword())) {\n                context.addMessage(new MessageBuilder().error().source(\"password\")\n                        .code(\"passwords.must.match\")\n                        .defaultText(\"Passwords must match\").build());\n            }\n        }\n        \n    }","id":91490,"modified_method":"public void validateEditLocalAccount(PersonForm person, MessageContext context) {\n        \n        // ensure that this username isn't already taken\n        if (person.getId() < 0 && accountDao.getPerson(person.getUsername()) != null) {\n            context.addMessage(new MessageBuilder().error().source(\"username\")\n                    .code(\"username.in.use\").build());\n        } \n        \n        if (StringUtils.isNotBlank(person.getPassword()) || StringUtils.isNotBlank(person.getConfirmPassword())) {\n            if (person.getPassword() == null || !person.getPassword().equals(person.getConfirmPassword())) {\n                context.addMessage(new MessageBuilder().error().source(\"password\")\n                        .code(\"passwords.must.match\").build());\n            }\n        }\n        \n    }","commit_id":"8636d5e5417acaba5a52809379f8c465f1a67ab9","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void checkEqualsComparison(Location location, JavaClass jclass, Method method, MethodGen methodGen,\n            ConstantPoolGen cpg, TypeDataflow typeDataflow) throws DataflowAnalysisException {\n\n        InstructionHandle handle = location.getHandle();\n        InstructionHandle next = handle.getNext();\n        if (next != null && next.getInstruction() instanceof INVOKESTATIC) {\n            INVOKESTATIC is = (INVOKESTATIC) next.getInstruction();\n            if (is.getMethodName(cpg).equals(\"assertFalse\")) {\n                return;\n            }\n        }\n        String sourceFile = jclass.getSourceFileName();\n\n        TypeFrame frame = typeDataflow.getFactAtLocation(location);\n        if (frame.getStackDepth() < 2) {\n            throw new DataflowAnalysisException(\"Stack underflow\", methodGen, handle);\n        }\n\n        int numSlots = frame.getNumSlots();\n        Type lhsType_ = frame.getValue(numSlots - 2);\n        Type rhsType_ = frame.getValue(numSlots - 1);\n\n        // Ignore top and bottom values\n        if (lhsType_.getType() == T_TOP || lhsType_.getType() == T_BOTTOM || rhsType_.getType() == T_TOP\n                || rhsType_.getType() == T_BOTTOM) {\n            return;\n        }\n\n        boolean looksLikeTestCase = TestCaseDetector.likelyTestCase(XFactory.createXMethod(methodGen));\n        int priorityModifier = 0;\n        if (looksLikeTestCase) {\n            priorityModifier = 2;\n        }\n\n        if (rhsType_.getType() == T_NULL) {\n            // A literal null value was passed directly to equals().\n            if (!looksLikeTestCase) {\n\n                try {\n                    IsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n                    IsNullValueFrame isNullFrame = isNullDataflow.getFactAtLocation(location);\n                    BugAnnotation a = BugInstance.getSourceForTopStackValue(classContext, method, location);\n                    int priority = NORMAL_PRIORITY;\n                    if (a instanceof FieldAnnotation && ((FieldAnnotation) a).isStatic())\n                        priority = LOW_PRIORITY;\n                    if (isNullFrame.isValid() && isNullFrame.getTopValue().isDefinitelyNull())\n                        bugAccumulator.accumulateBug(\n                                new BugInstance(this, \"EC_NULL_ARG\", priority).addClassAndMethod(methodGen, sourceFile),\n                                SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                        location.getHandle()));\n                } catch (CFGBuilderException e) {\n                    AnalysisContext.logError(\"Error getting null value analysis\", e);\n                }\n\n            }\n            return;\n        } else if (lhsType_.getType() == T_NULL) {\n            // Hmm...in this case, equals() is being invoked on\n            // a literal null value. This is really the\n            // purview of FindNullDeref. So, we'll just do nothing.\n            return;\n        } else if (!(lhsType_ instanceof ReferenceType) || !(rhsType_ instanceof ReferenceType)) {\n            bugReporter.logError(\"equals() used to compare non-object type(s) \" + lhsType_ + \" and \" + rhsType_ + \" in \"\n                    + SignatureConverter.convertMethodSignature(methodGen) + \" at \" + location.getHandle());\n            return;\n        }\n        IncompatibleTypes result = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_);\n\n        if (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType) {\n            String pattern = \"EC_BAD_ARRAY_COMPARE\";\n            IncompatibleTypes result2 = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_, true);\n            if (result2.getPriority() <= Priorities.NORMAL_PRIORITY)\n                pattern = \"EC_INCOMPATIBLE_ARRAY_COMPARE\";\n            bugAccumulator.accumulateBug(new BugInstance(this, pattern, NORMAL_PRIORITY).addClassAndMethod(methodGen, sourceFile)\n                    .addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        }\n\n        if (result == IncompatibleTypes.SEEMS_OK) return;\n\n        if (result.getPriority() >= Priorities.LOW_PRIORITY) {\n            comparedForEqualityInThisMethod.add(lhsType_.getSignature());\n            comparedForEqualityInThisMethod.add(rhsType_.getSignature());\n        }\n        if (result.getPriority() > Priorities.LOW_PRIORITY)\n            return;\n\n         if (result == IncompatibleTypes.ARRAY_AND_NON_ARRAY || result == IncompatibleTypes.ARRAY_AND_OBJECT) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, new HashSet<XMethod>());\n            if (allOk)\n                priorityModifier += 2;\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.INCOMPATIBLE_CLASSES) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean core = lhsSig.startsWith(\"Ljava\") && rhsSig.startsWith(\"Ljava\");\n            if (core) {\n                looksLikeTestCase = false;\n                priorityModifier = 0;\n            }\n            if (!looksLikeTestCase) {\n                Set<XMethod> targets = new HashSet<XMethod>();\n                boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, targets);\n                if (allOk)\n                    priorityModifier += 2;\n                bugAccumulator.accumulateBug(\n                        new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n                                .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                                .addSomeSourceForTopTwoStackValues(classContext, method, location).addEqualsMethodUsed(targets),\n                        SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                location.getHandle()));\n            }\n        } else if (result == IncompatibleTypes.UNRELATED_CLASS_AND_INTERFACE\n                || result == IncompatibleTypes.UNRELATED_FINAL_CLASS_AND_INTERFACE) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_CLASS_AND_INTERFACE\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature())),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.UNRELATED_INTERFACES) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_INTERFACES\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature())),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result != IncompatibleTypes.UNCHECKED && result.getPriority() <= Priorities.LOW_PRIORITY) {\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        }\n\n    }","id":91491,"modified_method":"private void checkEqualsComparison(Location location, JavaClass jclass, Method method, MethodGen methodGen,\n            ConstantPoolGen cpg, TypeDataflow typeDataflow) throws DataflowAnalysisException {\n\n        InstructionHandle handle = location.getHandle();\n        InstructionHandle next = handle.getNext();\n        if (next != null && next.getInstruction() instanceof INVOKESTATIC) {\n            INVOKESTATIC is = (INVOKESTATIC) next.getInstruction();\n            if (is.getMethodName(cpg).equals(\"assertFalse\")) {\n                return;\n            }\n        }\n        String sourceFile = jclass.getSourceFileName(); \n\n        TypeFrame frame = typeDataflow.getFactAtLocation(location);\n        if (frame.getStackDepth() < 2) {\n            throw new DataflowAnalysisException(\"Stack underflow\", methodGen, handle);\n        }\n\n        int numSlots = frame.getNumSlots();\n        Type lhsType_ = frame.getValue(numSlots - 2);\n        Type rhsType_ = frame.getValue(numSlots - 1);\n\n        // Ignore top and bottom values\n        if (lhsType_.getType() == T_TOP || lhsType_.getType() == T_BOTTOM || rhsType_.getType() == T_TOP\n                || rhsType_.getType() == T_BOTTOM) {\n            return;\n        }\n        InvokeInstruction inv = (InvokeInstruction) handle.getInstruction();\n        MethodAnnotation calledMethodAnnotation = getMethodCalledAnnotation(cpg, inv);\n        boolean looksLikeTestCase = TestCaseDetector.likelyTestCase(XFactory.createXMethod(methodGen));\n        int priorityModifier = 0;\n        if (looksLikeTestCase) {\n            priorityModifier = 2;\n        }\n\n        if (rhsType_.getType() == T_NULL) {\n            // A literal null value was passed directly to equals().\n            if (!looksLikeTestCase) {\n\n                try {\n                    IsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n                    IsNullValueFrame isNullFrame = isNullDataflow.getFactAtLocation(location);\n                    BugAnnotation a = BugInstance.getSourceForTopStackValue(classContext, method, location);\n                    int priority = NORMAL_PRIORITY;\n                    if (a instanceof FieldAnnotation && ((FieldAnnotation) a).isStatic())\n                        priority = LOW_PRIORITY;\n                    if (isNullFrame.isValid() && isNullFrame.getTopValue().isDefinitelyNull())\n                        bugAccumulator.accumulateBug(\n                                new BugInstance(this, \"EC_NULL_ARG\", priority).addClassAndMethod(methodGen, sourceFile),\n                                SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                        location.getHandle()));\n                } catch (CFGBuilderException e) {\n                    AnalysisContext.logError(\"Error getting null value analysis\", e);\n                }\n\n            }\n            return;\n        } else if (lhsType_.getType() == T_NULL) {\n            // Hmm...in this case, equals() is being invoked on\n            // a literal null value. This is really the\n            // purview of FindNullDeref. So, we'll just do nothing.\n            return;\n        } else if (!(lhsType_ instanceof ReferenceType) || !(rhsType_ instanceof ReferenceType)) {\n            bugReporter.logError(\"equals() used to compare non-object type(s) \" + lhsType_ + \" and \" + rhsType_ + \" in \"\n                    + SignatureConverter.convertMethodSignature(methodGen) + \" at \" + location.getHandle());\n            return;\n        }\n        IncompatibleTypes result = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_);\n\n        if (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType) {\n            String pattern = \"EC_BAD_ARRAY_COMPARE\";\n            IncompatibleTypes result2 = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_, true);\n            if (result2.getPriority() <= Priorities.NORMAL_PRIORITY)\n                pattern = \"EC_INCOMPATIBLE_ARRAY_COMPARE\";\n            bugAccumulator.accumulateBug(new BugInstance(this, pattern, NORMAL_PRIORITY).addClassAndMethod(methodGen, sourceFile)\n                    .addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        }\n\n        if (result == IncompatibleTypes.SEEMS_OK) return;\n\n        if (result.getPriority() >= Priorities.LOW_PRIORITY) {\n            comparedForEqualityInThisMethod.add(lhsType_.getSignature());\n            comparedForEqualityInThisMethod.add(rhsType_.getSignature());\n        }\n        if (result.getPriority() > Priorities.LOW_PRIORITY)\n            return;\n\n         if (result == IncompatibleTypes.ARRAY_AND_NON_ARRAY || result == IncompatibleTypes.ARRAY_AND_OBJECT) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, new HashSet<XMethod>());\n            if (allOk)\n                priorityModifier += 2;\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.INCOMPATIBLE_CLASSES) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean core = lhsSig.startsWith(\"Ljava\") && rhsSig.startsWith(\"Ljava\");\n            if (core) {\n                looksLikeTestCase = false;\n                priorityModifier = 0;\n            }\n            if (!looksLikeTestCase) {\n                Set<XMethod> targets = new HashSet<XMethod>();\n                boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, targets);\n                if (allOk)\n                    priorityModifier += 2;\n                bugAccumulator.accumulateBug(\n                        new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n                                .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                                .addSomeSourceForTopTwoStackValues(classContext, method, location).addEqualsMethodUsed(targets)\n                                .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                        SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                location.getHandle()));\n            }\n        } else if (result == IncompatibleTypes.UNRELATED_CLASS_AND_INTERFACE\n                || result == IncompatibleTypes.UNRELATED_FINAL_CLASS_AND_INTERFACE) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_CLASS_AND_INTERFACE\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature()))\n                            .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.UNRELATED_INTERFACES) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_INTERFACES\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature()))\n                            .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result != IncompatibleTypes.UNCHECKED && result.getPriority() <= Priorities.LOW_PRIORITY) {\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        }\n\n    }","commit_id":"82baa4f66f16e9aafffe90ca375f0016ef317ed8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * Create a MethodAnnotation from a MethodDescriptor.\n     * \n     * @param methodDescriptor\n     *            the MethodDescriptor\n     * @return the MethodAnnotation\n     */\n    public static BugAnnotation fromMethodDescriptor(MethodDescriptor methodDescriptor) {\n        return fromForeignMethod(methodDescriptor.getSlashedClassName(), methodDescriptor.getName(),\n                methodDescriptor.getSignature(), methodDescriptor.isStatic());\n    }","id":91492,"modified_method":"/**\n     * Create a MethodAnnotation from a MethodDescriptor.\n     * \n     * @param methodDescriptor\n     *            the MethodDescriptor\n     * @return the MethodAnnotation\n     */\n    public static MethodAnnotation fromMethodDescriptor(MethodDescriptor methodDescriptor) {\n        return fromForeignMethod(methodDescriptor.getSlashedClassName(), methodDescriptor.getName(),\n                methodDescriptor.getSignature(), methodDescriptor.isStatic());\n    }","commit_id":"82baa4f66f16e9aafffe90ca375f0016ef317ed8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public DelegatingVariableResolver() {\r\n\t\tfVariableResolverX = new DelegatingVariableResolverManager();\r\n\t\t// DelegatingVariableResolverManager\r\n\t\t// DelegatingVariableResolverEL\r\n\t}","id":91493,"modified_method":"public DelegatingVariableResolver() {\r\n\t\tfVariableResolverX = new DelegatingVariableResolverEL();\r\n\t\t// DelegatingVariableResolverManager\r\n\t\t// DelegatingVariableResolverEL\r\n\t}","commit_id":"f3930744d2d77a36e43cf66aa7cac73737371eb2","url":"https://github.com/zkoss/zk"},{"original_method":"public Object resolveVariable(XelContext ctx, Object base, Object name)\r\n\tthrows XelException {\r\n\t\tif (!_resolving) { //recursive back, return null.\r\n\t\t\tfinal boolean old = _resolving;\r\n\t\t\t_resolving = true;\r\n\t\t\ttry {\r\n\t\t\t\tfinal ELContext elctx = new CDIELContext(ctx, _cdiResolver);\r\n\t\t\t\treturn _cdiResolver.getValue(elctx, base, name); //might cause recursive\r\n\t\t\t} finally {\r\n\t\t\t\t_resolving = old;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}","id":91494,"modified_method":"public Object resolveVariable(XelContext ctx, Object base, Object name)\r\n\tthrows XelException {\r\n\t\tif (!_resolving) { //recursive back, return null.\r\n\t\t\tfinal boolean old = _resolving;\r\n\t\t\t_resolving = true;\r\n\t\t\tfinal CDIELContext elctx = new CDIELContext(ctx, _cdiResolver);\r\n\t\t\ttry {\r\n\t\t\t\treturn _cdiResolver.getValue(elctx, base, name); //might cause recursive\r\n\t\t\t} finally {\r\n\t\t\t\t_resolving = old;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}","commit_id":"f3930744d2d77a36e43cf66aa7cac73737371eb2","url":"https://github.com/zkoss/zk"},{"original_method":"@SuppressWarnings(\"rawtypes\")\r\n\tpublic Object resolveVariable(XelContext ctx, Object base, Object name)\r\n\tthrows XelException {\r\n\t\tif(base!=null || !(name instanceof String)) return null;\r\n\t\t\r\n\t\tfinal Set<Bean<?>> beans = _beanMgr.getBeans((String)name);\r\n\t\tif(beans == null || beans.size()==0) return null;\r\n\r\n\t\t\r\n\t\t//I(Dennis) think we don't need to check(if there are more than one bean has same name), CDI should check this when startup\r\n\t\t//However, Since it returns a Set, so I just check it.\r\n\t\t//Note, I do some test, the alternative bean will not be returned by the getBeans api with the name.\r\n\t\tBean bean = null;\r\n\t\tfor(Bean b:beans){\r\n\t\t\tif(b.isAlternative()) continue;//(Ian Tsai) alternative is the bean with explicit declaration in bean.xml. they are reserved for Bean \r\n\t\t\tif(bean != null){\r\n\t\t\t\tthrow new XelException(\"more than one non-alternative bean have same name \"+bean+\" and \"+b+\", name \"+name);\r\n\t\t\t}\r\n\t\t\tbean = b;\r\n\t\t}\r\n\t\tif(bean==null) return null;\r\n\r\n\t\tCreationalContext context = ctx==null?\r\n\t\t\tnull:(CreationalContext)ctx.getAttribute(CREATIONAL_CONTEXT);\r\n\t\tif(context==null){\r\n\t\t\tSystem.out.println(\">>>>>create a new CreationalContext\");\r\n\t\t\tcontext = _beanMgr.createCreationalContext(null);\r\n\t\t\tif(ctx!=null){\r\n\t\t\t\tctx.setAttribute(CREATIONAL_CONTEXT,context);\r\n\t\t\t}else{\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(\">>>>>CreationalContext: \"+context);\t\t\r\n\t\tObject value = _beanMgr.getReference(bean, bean.getBeanClass(), context);\r\n\t\tcontext.release();\r\n\r\n\t\treturn value;\r\n\t}","id":91495,"modified_method":"@SuppressWarnings(\"rawtypes\")\r\n\tpublic Object resolveVariable(XelContext ctx, Object base, Object name)\r\n\tthrows XelException {\r\n\t\tif(base!=null || !(name instanceof String)) return null;\r\n\t\t\r\n\t\tfinal Set<Bean<?>> beans = _beanMgr.getBeans((String)name);\r\n\t\tif(beans == null || beans.size()==0) return null;\r\n\r\n\t\t\r\n\t\t//I(Dennis) think we don't need to check(if there are more than one bean has same name), CDI should check this when startup\r\n\t\t//However, Since it returns a Set, so I just check it.\r\n\t\t//Note, I do some test, the alternative bean will not be returned by the getBeans api with the name.\r\n\t\tBean bean = null;\r\n\t\tfor(Bean b:beans){\r\n\t\t\tif(b.isAlternative()) continue;//(Ian Tsai) alternative is the bean with explicit declaration in bean.xml. they are reserved for Bean \r\n\t\t\tif(bean != null){\r\n\t\t\t\tthrow new XelException(\"more than one non-alternative bean have same name \"+bean+\" and \"+b+\", name \"+name);\r\n\t\t\t}\r\n\t\t\tbean = b;\r\n\t\t}\r\n\t\tif(bean==null) return null;\r\n\r\n\t\t\r\n\t\tCreationalContext context = _beanMgr.createCreationalContext(null);\r\n\t\t\r\n\t\t/*\r\n\t\t * Ian Tsai & Dennis\r\n\t\t * \r\n\t\t * We are not sure what is the best way to handle the life cycle of CreationalContext.\r\n\t\t * CreationalContext is the context designed to serve  \r\n\t\t * if we put it in Desktop, then if the bean is \r\n\t\t */\r\n//\t\tCreationalContext context = ctx==null?\r\n//\t\t\tnull:(CreationalContext)ctx.getAttribute(CREATIONAL_CONTEXT);\r\n//\t\tif(context==null){\r\n//\t\t\tSystem.out.println(\">>>>>create a new CreationalContext\");\r\n//\t\t\tcontext = _beanMgr.createCreationalContext(null);\r\n//\t\t\tif(ctx!=null){\r\n//\t\t\t\tctx.setAttribute(CREATIONAL_CONTEXT,context);\r\n//\t\t\t}else{\r\n//\t\t\t\t\r\n//\t\t\t}\r\n//\t\t}\r\n\t\tSystem.out.println(\">>>>>CreationalContext: \"+context);\t\t\r\n\t\tObject value = _beanMgr.getReference(bean, bean.getBeanClass(), context);\r\n\t\tcontext.release();\r\n\r\n\t\treturn value;\r\n\t}","commit_id":"f3930744d2d77a36e43cf66aa7cac73737371eb2","url":"https://github.com/zkoss/zk"},{"original_method":"public String greet(String name){\n\t\treturn \"Hello, \"+name+\".\";\n\t}","id":91496,"modified_method":"public String greet(String name){\n\t\treturn \"Hello, \"+name+\". bean: \"+this.getClass()+System.identityHashCode(this);\n\t}","commit_id":"f3930744d2d77a36e43cf66aa7cac73737371eb2","url":"https://github.com/zkoss/zk"},{"original_method":"public String sayHello(String yourName){\n\t\treturn greeting.greet(yourName);\n\t}","id":91497,"modified_method":"public String sayHello(String yourName){\n\t\tSystem.out.println(\">>>>>>>>>>[inside Hello] greeting Bean:\"+greeting.getClass()+System.identityHashCode(greeting));\n\t\treturn greeting.greet(yourName);\n\t}","commit_id":"f3930744d2d77a36e43cf66aa7cac73737371eb2","url":"https://github.com/zkoss/zk"},{"original_method":"@PreDestroy\n\tpublic void dispose(){\n\t\tSystem.out.println(\">>>>>>>>>> Hello disposed\");\n\t}","id":91498,"modified_method":"@PreDestroy\n\tpublic void dispose(){\n\t\tSystem.out.println(\">>>>>>>>>> @PreDestroy:\"+this);\n\t}","commit_id":"f3930744d2d77a36e43cf66aa7cac73737371eb2","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n     * As the weld based instantiator needs access to the bean manager it is installed as a service.\n     */\n    private void addWeldIntegration(final ServiceTarget target, final ComponentConfiguration configuration, final ComponentDescription description, final Class<?> componentClass, final String beanName, final ServiceName weldServiceName, final Set<Class<?>> interceptorClasses, final ClassLoader classLoader, final String beanDeploymentArchiveId) {\n\n        final ServiceName serviceName = configuration.getComponentDescription().getServiceName().append(\"WeldInstantiator\");\n\n        final WeldManagedReferenceFactory factory = new WeldManagedReferenceFactory(componentClass, beanName, interceptorClasses, classLoader, beanDeploymentArchiveId);\n\n        ServiceBuilder<WeldManagedReferenceFactory> builder = target.addService(serviceName, factory)\n                .addDependency(weldServiceName, WeldContainer.class, factory.getWeldContainer());\n\n\n        configuration.setInstanceFactory(factory);\n        configuration.getStartDependencies().add(new DependencyConfigurator<ComponentStartService>() {\n            @Override\n            public void configureDependency(final ServiceBuilder<?> serviceBuilder, ComponentStartService service) throws DeploymentUnitProcessingException {\n                serviceBuilder.addDependency(serviceName);\n            }\n        });\n\n        //if this is an ejb add the EJB interceptors\n        if (description instanceof EJBComponentDescription) {\n\n            //add interceptor to activate the request scope if required\n            final EjbRequestScopeActivationInterceptor.Factory requestFactory = new EjbRequestScopeActivationInterceptor.Factory(weldServiceName);\n            configuration.addComponentInterceptor(requestFactory, InterceptorOrder.Component.CDI_REQUEST_SCOPE, false);\n\n            final Jsr299BindingsInterceptor.Factory aroundInvokeFactory = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.AROUND_INVOKE, classLoader);\n            final Jsr299BindingsInterceptor.Factory aroundTimeoutFactory = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.AROUND_TIMEOUT, classLoader);\n\n            builder.addDependency(weldServiceName, WeldContainer.class, aroundTimeoutFactory.getWeldContainer());\n            builder.addDependency(weldServiceName, WeldContainer.class, aroundInvokeFactory.getWeldContainer());\n\n            configuration.addComponentInterceptor(new UserInterceptorFactory(aroundInvokeFactory, aroundTimeoutFactory), InterceptorOrder.Component.CDI_INTERCEPTORS, false);\n\n            final Jsr299BindingsInterceptor.Factory preDestroyInterceptor = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.PRE_DESTROY, classLoader);\n            builder.addDependency(weldServiceName, WeldContainer.class, preDestroyInterceptor.getWeldContainer());\n            configuration.addPreDestroyInterceptor(preDestroyInterceptor, InterceptorOrder.ComponentPreDestroy.CDI_INTERCEPTORS);\n\n            if (description.isPassivationApplicable()) {\n                final Jsr299BindingsInterceptor.Factory prePassivateInterceptor = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.PRE_PASSIVATE, classLoader);\n                builder.addDependency(weldServiceName, WeldContainer.class, prePassivateInterceptor.getWeldContainer());\n                configuration.addPrePassivateInterceptor(prePassivateInterceptor, InterceptorOrder.ComponentPassivation.CDI_INTERCEPTORS);\n                final Jsr299BindingsInterceptor.Factory postActivateInterceptor = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.POST_ACTIVATE, classLoader);\n                builder.addDependency(weldServiceName, WeldContainer.class, postActivateInterceptor.getWeldContainer());\n                configuration.addPostActivateInterceptor(postActivateInterceptor, InterceptorOrder.ComponentPassivation.CDI_INTERCEPTORS);\n            }\n\n            final Jsr299BindingsInterceptor.Factory postConstruct = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.POST_CONSTRUCT, classLoader);\n            builder.addDependency(weldServiceName, WeldContainer.class, postConstruct.getWeldContainer());\n            configuration.addPostConstructInterceptor(postConstruct, InterceptorOrder.ComponentPostConstruct.CDI_INTERCEPTORS);\n\n        }\n\n        builder.install();\n\n    }","id":91499,"modified_method":"/**\n     * As the weld based instantiator needs access to the bean manager it is installed as a service.\n     */\n    private void addWeldIntegration(final ServiceTarget target, final ComponentConfiguration configuration, final ComponentDescription description, final Class<?> componentClass, final String beanName, final ServiceName weldServiceName, final Set<Class<?>> interceptorClasses, final ClassLoader classLoader, final String beanDeploymentArchiveId) {\n\n        final ServiceName serviceName = configuration.getComponentDescription().getServiceName().append(\"WeldInstantiator\");\n\n        final WeldManagedReferenceFactory factory = new WeldManagedReferenceFactory(componentClass, beanName, interceptorClasses, classLoader, beanDeploymentArchiveId, description.isCDIInterceptorEnabled());\n\n        ServiceBuilder<WeldManagedReferenceFactory> builder = target.addService(serviceName, factory)\n                .addDependency(weldServiceName, WeldContainer.class, factory.getWeldContainer());\n\n\n        configuration.setInstanceFactory(factory);\n        configuration.getStartDependencies().add(new DependencyConfigurator<ComponentStartService>() {\n            @Override\n            public void configureDependency(final ServiceBuilder<?> serviceBuilder, ComponentStartService service) throws DeploymentUnitProcessingException {\n                serviceBuilder.addDependency(serviceName);\n            }\n        });\n\n        //if this is an ejb add the EJB interceptors\n        if (description instanceof EJBComponentDescription) {\n\n            //add interceptor to activate the request scope if required\n            final EjbRequestScopeActivationInterceptor.Factory requestFactory = new EjbRequestScopeActivationInterceptor.Factory(weldServiceName);\n            configuration.addComponentInterceptor(requestFactory, InterceptorOrder.Component.CDI_REQUEST_SCOPE, false);\n\n            final Jsr299BindingsInterceptor.Factory aroundInvokeFactory = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.AROUND_INVOKE, classLoader);\n            final Jsr299BindingsInterceptor.Factory aroundTimeoutFactory = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.AROUND_TIMEOUT, classLoader);\n\n            builder.addDependency(weldServiceName, WeldContainer.class, aroundTimeoutFactory.getWeldContainer());\n            builder.addDependency(weldServiceName, WeldContainer.class, aroundInvokeFactory.getWeldContainer());\n\n            configuration.addComponentInterceptor(new UserInterceptorFactory(aroundInvokeFactory, aroundTimeoutFactory), InterceptorOrder.Component.CDI_INTERCEPTORS, false);\n\n            final Jsr299BindingsInterceptor.Factory preDestroyInterceptor = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.PRE_DESTROY, classLoader);\n            builder.addDependency(weldServiceName, WeldContainer.class, preDestroyInterceptor.getWeldContainer());\n            configuration.addPreDestroyInterceptor(preDestroyInterceptor, InterceptorOrder.ComponentPreDestroy.CDI_INTERCEPTORS);\n\n            if (description.isPassivationApplicable()) {\n                final Jsr299BindingsInterceptor.Factory prePassivateInterceptor = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.PRE_PASSIVATE, classLoader);\n                builder.addDependency(weldServiceName, WeldContainer.class, prePassivateInterceptor.getWeldContainer());\n                configuration.addPrePassivateInterceptor(prePassivateInterceptor, InterceptorOrder.ComponentPassivation.CDI_INTERCEPTORS);\n                final Jsr299BindingsInterceptor.Factory postActivateInterceptor = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.POST_ACTIVATE, classLoader);\n                builder.addDependency(weldServiceName, WeldContainer.class, postActivateInterceptor.getWeldContainer());\n                configuration.addPostActivateInterceptor(postActivateInterceptor, InterceptorOrder.ComponentPassivation.CDI_INTERCEPTORS);\n            }\n\n            final Jsr299BindingsInterceptor.Factory postConstruct = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.POST_CONSTRUCT, classLoader);\n            builder.addDependency(weldServiceName, WeldContainer.class, postConstruct.getWeldContainer());\n            configuration.addPostConstructInterceptor(postConstruct, InterceptorOrder.ComponentPostConstruct.CDI_INTERCEPTORS);\n\n        }\n\n        builder.install();\n\n    }","commit_id":"fc56c69e730a92e174077e4a9463387f0ae24900","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ManagedReference injectExistingReference(final ManagedReference existing) {\n        final CreationalContext<?> ctx;\n        if (bean == null) {\n            ctx = beanManager.createCreationalContext(null);\n        } else {\n            ctx = beanManager.createCreationalContext(bean);\n        }\n        final Object instance = existing.getInstance();\n\n        injectionTarget.inject(instance, ctx);\n\n        return new ManagedReference() {\n            @Override\n            public void release() {\n                try {\n                    existing.release();\n                } finally {\n                    ctx.release();\n                }\n            }\n\n            @Override\n            public Object getInstance() {\n                return instance;\n            }\n        };\n    }","id":91500,"modified_method":"public ManagedReference injectExistingReference(final ManagedReference existing) {\n        final CreationalContext<?> ctx = beanManager.createCreationalContext(bean);\n        final Object instance = existing.getInstance();\n\n        injectionTarget.inject(instance, ctx);\n\n        return new ManagedReference() {\n            @Override\n            public void release() {\n                try {\n                    existing.release();\n                } finally {\n                    ctx.release();\n                }\n            }\n\n            @Override\n            public Object getInstance() {\n                return instance;\n            }\n        };\n    }","commit_id":"fc56c69e730a92e174077e4a9463387f0ae24900","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public synchronized void start(final StartContext context) throws StartException {\n        final ClassLoader cl = SecurityActions.getContextClassLoader();\n        try {\n            SecurityActions.setContextClassLoader(classLoader);\n            beanManager = (BeanManagerImpl) weldContainer.getValue().getBeanManager(beanDeploymentArchiveId);\n\n            for (final Class<?> interceptor : interceptorClasses) {\n                interceptorInjections.put(interceptor, WeldEEInjection.createWeldEEInjection(interceptor, null, beanManager));\n            }\n\n            if (ejbName != null) {\n                EjbDescriptor<Object> descriptor = beanManager.getEjbDescriptor(ejbName);\n                //may happen if the EJB was vetoed\n                if (descriptor != null) {\n                    bean = beanManager.getBean(descriptor);\n                }\n            }\n            injectionTarget = WeldEEInjection.createWeldEEInjection(componentClass, bean, beanManager);\n\n        } finally {\n            SecurityActions.setContextClassLoader(cl);\n        }\n\n    }","id":91501,"modified_method":"@Override\n    public synchronized void start(final StartContext context) throws StartException {\n        final ClassLoader cl = SecurityActions.getContextClassLoader();\n        try {\n            SecurityActions.setContextClassLoader(classLoader);\n            beanManager = (BeanManagerImpl) weldContainer.getValue().getBeanManager(beanDeploymentArchiveId);\n\n            for (final Class<?> interceptor : interceptorClasses) {\n                interceptorInjections.put(interceptor, WeldEEInjection.createWeldEEInjection(interceptor, null, beanManager));\n            }\n\n            if (ejbName != null) {\n                EjbDescriptor<Object> descriptor = beanManager.getEjbDescriptor(ejbName);\n                //may happen if the EJB was vetoed\n                if (descriptor != null) {\n                    bean = beanManager.getBean(descriptor);\n                }\n            } else if (delegateProduce) {\n                final Set<Annotation> qualifiers = new HashSet<Annotation>();\n                for(Annotation annotation : componentClass.getAnnotations()) {\n                    if(beanManager.isQualifier(annotation.annotationType())) {\n                        qualifiers.add(annotation);\n                    }\n                }\n                Set<Bean<?>> beans = beanManager.getBeans(componentClass, qualifiers);\n                boolean found = false;\n                for(Bean<?> bean : beans) {\n                    if(bean instanceof ManagedBean) {\n                        found = true;\n                        this.bean = bean;\n                        break;\n                    }\n                }\n                if(!found){\n                    WeldLogger.DEPLOYMENT_LOGGER.debugf(\"Could not find bean for %s, interception and decoration will be unavailable\", componentClass);\n                }\n            }\n            injectionTarget = WeldEEInjection.createWeldEEInjection(componentClass, bean, beanManager);\n\n        } finally {\n            SecurityActions.setContextClassLoader(cl);\n        }\n\n    }","commit_id":"fc56c69e730a92e174077e4a9463387f0ae24900","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ManagedReference getReference() {\n        final CreationalContext<?> ctx;\n        if (bean == null) {\n            ctx = beanManager.createCreationalContext(null);\n        } else {\n            ctx = beanManager.createCreationalContext(bean);\n        }\n        final Object instance = injectionTarget.produce(ctx);\n        return new WeldManagedReference(ctx, instance, injectionTarget, interceptorInjections);\n    }","id":91502,"modified_method":"@Override\n    public ManagedReference getReference() {\n        final CreationalContext<?> ctx = beanManager.createCreationalContext(bean);\n        if(delegateProduce && bean instanceof ManagedBean) {\n            final Object instance = ((ManagedBean)bean).getInjectionTarget().produce(ctx);\n            return new WeldManagedReference(ctx, instance, injectionTarget, interceptorInjections);\n        } else {\n            final Object instance = injectionTarget.produce(ctx);\n            return new WeldManagedReference(ctx, instance, injectionTarget, interceptorInjections);\n        }\n    }","commit_id":"fc56c69e730a92e174077e4a9463387f0ae24900","url":"https://github.com/wildfly/wildfly"},{"original_method":"public WeldManagedReferenceFactory(Class<?> componentClass, String ejbName, final Set<Class<?>> interceptorClasses, final ClassLoader classLoader, final String beanDeploymentArchiveId) {\n        this.componentClass = componentClass;\n        this.ejbName = ejbName;\n        this.beanDeploymentArchiveId = beanDeploymentArchiveId;\n        this.weldContainer = new InjectedValue<WeldContainer>();\n        this.interceptorClasses = interceptorClasses;\n        this.classLoader = classLoader;\n    }","id":91503,"modified_method":"public WeldManagedReferenceFactory(Class<?> componentClass, String ejbName, final Set<Class<?>> interceptorClasses, final ClassLoader classLoader, final String beanDeploymentArchiveId, final boolean delegateProduce) {\n        this.componentClass = componentClass;\n        this.ejbName = ejbName;\n        this.beanDeploymentArchiveId = beanDeploymentArchiveId;\n        this.delegateProduce = delegateProduce;\n        this.weldContainer = new InjectedValue<WeldContainer>();\n        this.interceptorClasses = interceptorClasses;\n        this.classLoader = classLoader;\n    }","commit_id":"fc56c69e730a92e174077e4a9463387f0ae24900","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void receiveRtpPackets() {    \r\n        int packetReceivedCounter = 0;\r\n        int internalBufferLength = payloadLength + RTP_HEADER_SIZE;\r\n        byte[] internalBuffer = new byte[internalBufferLength];\r\n\t\tRtpPacket rtpPacket = new RtpPacket(internalBuffer, internalBufferLength);\r\n\t\t\r\n        while (receivePackets) {\r\n        \ttry {        \t\t      \r\n        \t\trtpSocket.receive(rtpPacket);\r\n        \t\tpacketReceivedCounter++;  \r\n        \t\tif (rtpPacket.getSeqNum() > lastSequenceNumber) {\r\n        \t\t\tlastSequenceNumber = rtpPacket.getSeqNum();\r\n//        \t\t\tSystem.out.println(\"      RX RTP ts=\" + rtpPacket.getTimestamp() + \" length=\" + rtpPacket.getPayload().length);\r\n        \t\t\tAudioByteData audioData = new AudioByteData(rtpPacket.getPayload());\r\n            \t\tif (listener != null) listener.onAudioDataReceived(audioData);\r\n            \t\telse log.debug(\"No listener for incoming audio packet\");\r\n        \t\t} else {\r\n//        \t\t\tSystem.out.println(\"SequenceNumber < lastSequence (\" + rtpPacket.getSeqNum() + \" < \" + lastSequenceNumber + \")\");\r\n        \t\t}\r\n        \t} catch (IOException e) {\r\n        \t\t// We get this when the socket closes when the call hangs up.\r\n        \t\treceivePackets = false;\r\n        \t}\r\n        }\r\n        log.debug(\"Rtp Receiver stopped.\" );\r\n        log.debug(\"Packet Received = \" + packetReceivedCounter + \".\" );\r\n        if (listener != null) listener.onStoppedReceiving();\r\n    }","id":91504,"modified_method":"public void receiveRtpPackets() {    \r\n        int packetReceivedCounter = 0;\r\n        int internalBufferLength = payloadLength + RTP_HEADER_SIZE;\r\n        byte[] internalBuffer = new byte[internalBufferLength];\r\n\t\tRtpPacket rtpPacket = new RtpPacket(internalBuffer, internalBufferLength);\r\n\t\t\r\n        while (receivePackets) {\r\n        \ttry {        \t\t      \r\n        \t\trtpSocket.receive(rtpPacket);\r\n        \t\tpacketReceivedCounter++;  \r\n        \t\tif (shouldHandlePacket(rtpPacket)) {        \t\t\t\r\n        \t\t\t\tprocessRtpPacket(rtpPacket);\r\n        \t\t} else {\r\n        \t\t\tif (isFirstPacket()) {\r\n        \t\t\t\tprocessRtpPacket(rtpPacket);\r\n        \t\t\t} else {\r\n           \t\t\t\tlog.info(\"Corrupt packet seqNum[rtpSeqNum=\" + rtpPacket.getSeqNum() + \",lastSeqNum=\" + lastSequenceNumber +\"][rtpTS=\" + rtpPacket.getTimestamp() + \",lastTS=\" + lastPacketTimestamp + \"]\");       \t\t\t\t\r\n        \t\t\t}\r\n         \t\t}\r\n        \t} catch (IOException e) {\r\n        \t\t// We get this when the socket closes when the call hangs up.\r\n        \t\treceivePackets = false;\r\n        \t}\r\n        }\r\n        log.debug(\"Rtp Receiver stopped.\" );\r\n        log.debug(\"Packet Received = \" + packetReceivedCounter + \".\" );\r\n        if (listener != null) listener.onStoppedReceiving();\r\n    }","commit_id":"1fe65660fdbe56ba2eb07c47840946e8b2fafab6","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void started(Component c)\n        {\n            if (m_registered != null)\n            {\n                Object instance = c.getService();\n                try\n                {\n                    InvocationUtil\n                        .invokeCallbackMethod(instance,\n                                              m_registered, \n                                              new Class[][]  {{ ServiceRegistration.class },  {}},\n                                              new Object[][] {{ c.getServiceRegistration() }, {}});\n                }\n                catch (Throwable t)\n                {\n                    Log.instance().error(\"Exception caught while invoking method %s on component %s\", t, m_registered, instance);\n                }\n            }\n        }","id":91505,"modified_method":"public void started(Component c)\n        {\n            if (m_registered != null)\n            {\n                // The component has registered a service: notify all component instances\n                Object[] componentInstances = c.getCompositionInstances();\n                for (Object instance : componentInstances)\n                {\n                    try\n                    {\n                        Class[][] signatures = new Class[][] { { ServiceRegistration.class }, {} };\n                        Object[][] params = new Object[][] { { c.getServiceRegistration() }, {} };\n                        InvocationUtil.invokeCallbackMethod(instance, m_registered, signatures, params);\n                    }\n                    catch (Throwable t)\n                    {\n                        Log.instance().error(\"Exception caught while invoking method %s on component %s\",\n                                             t,\n                                             m_registered,\n                                             instance);\n                    }\n                }\n            }\n        }","commit_id":"ba7157dc9d25247b37c00893a431032a51ab4a81","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Parses a BundleAdapterService annotation.\n     * @param annotation\n     */\n    private void parseResourceAdapterService(Annotation annotation)\n    {\n        EntryWriter writer = new EntryWriter(EntryType.ResourceAdapterService);\n        m_writers.add(writer);\n\n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(writer);\n\n        // Generate Adapter Implementation\n        writer.put(EntryParam.impl, m_className);\n\n        // Parse resource filter\n        String filter = annotation.get(EntryParam.filter.toString());\n        if (filter != null)\n        {\n            Verifier.verifyFilter(filter, 0);\n            writer.put(EntryParam.filter, filter);\n        }\n\n        // Parse Adapter properties.\n        parseProperties(annotation, EntryParam.properties, writer);\n\n        // Parse the provided adapter service (use directly implemented interface by default).\n        writer.putClassArray(annotation, EntryParam.provides, m_interfaces, m_exportService);\n\n        // Parse propagate attribute\n        writer.putString(annotation, EntryParam.propagate, Boolean.FALSE.toString());\n        \n        // Parse changed attribute\n        writer.putString(annotation, EntryParam.changed, null);\n    }","id":91506,"modified_method":"/**\n     * Parses a BundleAdapterService annotation.\n     * @param annotation\n     */\n    private void parseResourceAdapterService(Annotation annotation)\n    {\n        EntryWriter writer = new EntryWriter(EntryType.ResourceAdapterService);\n        m_writers.add(writer);\n\n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(writer);\n\n        // Generate Adapter Implementation\n        writer.put(EntryParam.impl, m_className);\n\n        // Parse resource filter\n        String filter = annotation.get(EntryParam.filter.toString());\n        if (filter != null)\n        {\n            Verifier.verifyFilter(filter, 0);\n            writer.put(EntryParam.filter, filter);\n        }\n\n        // Parse Adapter properties.\n        parseProperties(annotation, EntryParam.properties, writer);\n\n        // Parse the provided adapter service (use directly implemented interface by default).\n        if (writer.putClassArray(annotation, EntryParam.provides, m_interfaces, m_exportService) == 0)\n        {\n            checkRegisteredUnregisteredNotPresent();\n        }\n\n        // Parse propagate attribute\n        writer.putString(annotation, EntryParam.propagate, Boolean.FALSE.toString());\n        \n        // Parse changed attribute\n        writer.putString(annotation, EntryParam.changed, null);\n    }","commit_id":"ba7157dc9d25247b37c00893a431032a51ab4a81","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Parses an AspectService annotation.\n     * @param annotation\n     */\n    private void parseAdapterService(Annotation annotation)\n    {\n        EntryWriter writer = new EntryWriter(EntryType.AdapterService);\n        m_writers.add(writer);\n\n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(writer);\n\n        // Generate Adapter Implementation\n        writer.put(EntryParam.impl, m_className);\n\n        // Parse adaptee filter\n        String adapteeFilter = annotation.get(EntryParam.adapteeFilter.toString());\n        if (adapteeFilter != null)\n        {\n            Verifier.verifyFilter(adapteeFilter, 0);\n            writer.put(EntryParam.adapteeFilter, adapteeFilter);\n        }\n\n        // Parse the mandatory adapted service interface.\n        writer.putClass(annotation, EntryParam.adapteeService, null);\n\n        // Parse Adapter properties.\n        parseProperties(annotation, EntryParam.properties, writer);\n\n        // Parse the provided adapter service (use directly implemented interface by default).\n        writer.putClassArray(annotation, EntryParam.provides, m_interfaces, m_exportService);\n        \n        // Parse factoryMethod attribute\n        writer.putString(annotation, EntryParam.factoryMethod, null);\n        \n        // Parse field/added/changed/removed attributes\n        parseAspectOrAdapterCallbackMethods(annotation, writer);\n    }","id":91507,"modified_method":"/**\n     * Parses an AspectService annotation.\n     * @param annotation\n     */\n    private void parseAdapterService(Annotation annotation)\n    {\n        EntryWriter writer = new EntryWriter(EntryType.AdapterService);\n        m_writers.add(writer);\n\n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(writer);\n\n        // Generate Adapter Implementation\n        writer.put(EntryParam.impl, m_className);\n\n        // Parse adaptee filter\n        String adapteeFilter = annotation.get(EntryParam.adapteeFilter.toString());\n        if (adapteeFilter != null)\n        {\n            Verifier.verifyFilter(adapteeFilter, 0);\n            writer.put(EntryParam.adapteeFilter, adapteeFilter);\n        }\n\n        // Parse the mandatory adapted service interface.\n        writer.putClass(annotation, EntryParam.adapteeService, null);\n\n        // Parse Adapter properties.\n        parseProperties(annotation, EntryParam.properties, writer);\n\n        // Parse the provided adapter service (use directly implemented interface by default).\n        if (writer.putClassArray(annotation, EntryParam.provides, m_interfaces, m_exportService) == 0)\n        {\n            checkRegisteredUnregisteredNotPresent();\n        }\n        \n        // Parse factoryMethod attribute\n        writer.putString(annotation, EntryParam.factoryMethod, null);\n        \n        // Parse field/added/changed/removed attributes\n        parseAspectOrAdapterCallbackMethods(annotation, writer);\n    }","commit_id":"ba7157dc9d25247b37c00893a431032a51ab4a81","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Parses a Factory Configuration Adapter annotation.\n     * @param annotation\n     */\n    private void parseFactoryConfigurationAdapterService(Annotation annotation)\n    {\n        EntryWriter writer = new EntryWriter(EntryType.FactoryConfigurationAdapterService);\n        m_writers.add(writer);\n\n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(writer);\n\n        // Generate Adapter Implementation\n        writer.put(EntryParam.impl, m_className);\n\n        // Parse factory Pid\n        writer.putString(annotation, EntryParam.factoryPid, m_className);\n\n        // Parse updated callback\n        writer.putString(annotation, EntryParam.updated, \"updated\");\n\n        // propagate attribute\n        writer.putString(annotation, EntryParam.propagate, Boolean.FALSE.toString());\n\n        // Parse the provided adapter service (use directly implemented interface by default).\n        writer.putClassArray(annotation, EntryParam.provides, m_interfaces, m_exportService);\n\n        // Parse Adapter properties.\n        parseProperties(annotation, EntryParam.properties, writer);\n\n        // Parse optional meta types for configuration description.\n        String factoryPid = get(annotation, EntryParam.factoryPid.toString(), m_className);\n        parseMetaTypes(annotation, factoryPid, true);\n        \n        // Parse factoryMethod attribute\n        writer.putString(annotation, EntryParam.factoryMethod, null);\n    }","id":91508,"modified_method":"/**\n     * Parses a Factory Configuration Adapter annotation.\n     * @param annotation\n     */\n    private void parseFactoryConfigurationAdapterService(Annotation annotation)\n    {\n        EntryWriter writer = new EntryWriter(EntryType.FactoryConfigurationAdapterService);\n        m_writers.add(writer);\n\n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(writer);\n\n        // Generate Adapter Implementation\n        writer.put(EntryParam.impl, m_className);\n\n        // Parse factory Pid\n        writer.putString(annotation, EntryParam.factoryPid, m_className);\n\n        // Parse updated callback\n        writer.putString(annotation, EntryParam.updated, \"updated\");\n\n        // propagate attribute\n        writer.putString(annotation, EntryParam.propagate, Boolean.FALSE.toString());\n\n        // Parse the provided adapter service (use directly implemented interface by default).\n        if (writer.putClassArray(annotation, EntryParam.provides, m_interfaces, m_exportService) == 0)\n        {\n            checkRegisteredUnregisteredNotPresent();\n        }\n\n        // Parse Adapter properties.\n        parseProperties(annotation, EntryParam.properties, writer);\n\n        // Parse optional meta types for configuration description.\n        String factoryPid = get(annotation, EntryParam.factoryPid.toString(), m_className);\n        parseMetaTypes(annotation, factoryPid, true);\n        \n        // Parse factoryMethod attribute\n        writer.putString(annotation, EntryParam.factoryMethod, null);\n    }","commit_id":"ba7157dc9d25247b37c00893a431032a51ab4a81","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Parses a BundleAdapterService annotation.\n     * @param annotation\n     */\n    private void parseBundleAdapterService(Annotation annotation)\n    {\n        EntryWriter writer = new EntryWriter(EntryType.BundleAdapterService);\n        m_writers.add(writer);\n\n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(writer);\n\n        // Generate Adapter Implementation\n        writer.put(EntryParam.impl, m_className);\n\n        // Parse bundle filter\n        String filter = annotation.get(EntryParam.filter.toString());\n        if (filter != null)\n        {\n            Verifier.verifyFilter(filter, 0);\n            writer.put(EntryParam.filter, filter);\n        }\n\n        // Parse stateMask attribute\n        writer.putString(annotation, EntryParam.stateMask, Integer.valueOf(\n            Bundle.INSTALLED | Bundle.RESOLVED | Bundle.ACTIVE).toString());\n\n        // Parse Adapter properties.\n        parseProperties(annotation, EntryParam.properties, writer);\n\n        // Parse the optional adapter service (use directly implemented interface by default).\n        writer.putClassArray(annotation, EntryParam.provides, m_interfaces, m_exportService);\n\n        // Parse propagate attribute\n        writer.putString(annotation, EntryParam.propagate, Boolean.FALSE.toString());\n        \n        // Parse factoryMethod attribute\n        writer.putString(annotation, EntryParam.factoryMethod, null);\n    }","id":91509,"modified_method":"/**\n     * Parses a BundleAdapterService annotation.\n     * @param annotation\n     */\n    private void parseBundleAdapterService(Annotation annotation)\n    {\n        EntryWriter writer = new EntryWriter(EntryType.BundleAdapterService);\n        m_writers.add(writer);\n\n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(writer);\n\n        // Generate Adapter Implementation\n        writer.put(EntryParam.impl, m_className);\n\n        // Parse bundle filter\n        String filter = annotation.get(EntryParam.filter.toString());\n        if (filter != null)\n        {\n            Verifier.verifyFilter(filter, 0);\n            writer.put(EntryParam.filter, filter);\n        }\n\n        // Parse stateMask attribute\n        writer.putString(annotation, EntryParam.stateMask, Integer.valueOf(\n            Bundle.INSTALLED | Bundle.RESOLVED | Bundle.ACTIVE).toString());\n\n        // Parse Adapter properties.\n        parseProperties(annotation, EntryParam.properties, writer);\n\n        // Parse the optional adapter service (use directly implemented interface by default).\n        if (writer.putClassArray(annotation, EntryParam.provides, m_interfaces, m_exportService) == 0)\n        {\n            checkRegisteredUnregisteredNotPresent();\n        }\n\n        // Parse propagate attribute\n        writer.putString(annotation, EntryParam.propagate, Boolean.FALSE.toString());\n        \n        // Parse factoryMethod attribute\n        writer.putString(annotation, EntryParam.factoryMethod, null);\n    }","commit_id":"ba7157dc9d25247b37c00893a431032a51ab4a81","url":"https://github.com/apache/felix"},{"original_method":"private void parseComponentAnnotation(Annotation annotation)\n    {\n        EntryWriter writer = new EntryWriter(EntryType.Component);\n        m_writers.add(writer);\n\n        // Register previously parsed annotations common to services (Init/Start/...)\n        addCommonServiceParams(writer);\n\n        // impl attribute\n        writer.put(EntryParam.impl, m_className);\n\n        // properties attribute\n        parseProperties(annotation, EntryParam.properties, writer);\n\n        // provides attribute\n        writer.putClassArray(annotation, EntryParam.provides, m_interfaces, m_exportService);\n\n        // factorySet attribute\n        String factorySetName = writer.putString(annotation, EntryParam.factorySet, null);\n        if (factorySetName != null)\n        {\n            // When a component defines a factorySet, it means that a java.util.Set will \n            // be provided into the OSGi registry, in order to let anoter component add\n            // some component instance configurations into it.\n            // So, we have to indicate that the Set is provided as a service, in the Export-Serviec\n            // header.\n            m_exportService.add(\"java.util.Set\");\n        }\n\n        // factoryConfigure attribute\n        writer.putString(annotation, EntryParam.factoryConfigure, null);\n        \n        // factoryMethod attribute\n        writer.putString(annotation, EntryParam.factoryMethod, null);\n    }","id":91510,"modified_method":"private void parseComponentAnnotation(Annotation annotation)\n    {\n        EntryWriter writer = new EntryWriter(EntryType.Component);\n        m_writers.add(writer);\n\n        // Register previously parsed annotations common to services (Init/Start/...)\n        addCommonServiceParams(writer);\n\n        // impl attribute\n        writer.put(EntryParam.impl, m_className);\n\n        // properties attribute\n        parseProperties(annotation, EntryParam.properties, writer);\n\n        // provides attribute.\n        if (writer.putClassArray(annotation, EntryParam.provides, m_interfaces, m_exportService) == 0)\n        {\n            // no service provided: check if @Registered/@Unregistered annotation are used\n            // and raise an error if true.\n            checkRegisteredUnregisteredNotPresent();\n        }\n\n        // factorySet attribute\n        String factorySetName = writer.putString(annotation, EntryParam.factorySet, null);\n        if (factorySetName != null)\n        {\n            // When a component defines a factorySet, it means that a java.util.Set will \n            // be provided into the OSGi registry, in order to let anoter component add\n            // some component instance configurations into it.\n            // So, we have to indicate that the Set is provided as a service, in the Export-Serviec\n            // header.\n            m_exportService.add(\"java.util.Set\");\n        }\n\n        // factoryConfigure attribute\n        writer.putString(annotation, EntryParam.factoryConfigure, null);\n        \n        // factoryMethod attribute\n        writer.putString(annotation, EntryParam.factoryMethod, null);\n    }","commit_id":"ba7157dc9d25247b37c00893a431032a51ab4a81","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void testComposite(BundleContext context)\n    {\n        DependencyManager m = new DependencyManager(context);\n        // Provide the Sequencer service to the \"Component\" service.\n        m.add(makeSequencer(m, \"CompositeService\"));\n        m.add(makeSequencer(m, \"Dependency1\"));\n        m.add(makeSequencer(m, \"Dependency2\"));\n        // Check if the components have been initialized orderly\n        m_ensure.waitForStep(4, 10000);\n        // Stop the bundle\n        stopBundle(\"CompositeAnnotationsTest\", context);\n        // And check if the components lifecycle callbacks are called orderly\n        m_ensure.waitForStep(10, 10000);\n    }","id":91511,"modified_method":"@Test\n    public void testComposite(BundleContext context)\n    {\n        DependencyManager m = new DependencyManager(context);\n        // Provide the Sequencer service to the \"Component\" service.\n        m.add(makeSequencer(m, \"C1\"));\n        m.add(makeSequencer(m, \"Dependency1\"));\n        m.add(makeSequencer(m, \"Dependency2\"));\n        // Check if the components have been initialized orderly\n        m_ensure.waitForStep(4, 10000);\n        // Stop the bundle\n        stopBundle(\"CompositeAnnotationsTest\", context);\n        // And check if the components lifecycle callbacks are called orderly\n        m_ensure.waitForStep(12, 10000);\n    }","commit_id":"ba7157dc9d25247b37c00893a431032a51ab4a81","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Get a class array attribute value from an annotation and write it into this descriptor entry.\n     * Also collect classes found from the array into a given Set.\n     */\n    public void putClassArray(Annotation annotation, EntryParam param, Object def, Set<String> collect)\n    {\n        checkType(param.toString());\n\n        Pattern pattern = Patterns.CLASS;\n        Object value = annotation.get(param.toString());\n        if (value == null && def != null)\n        {\n            value = def;\n            pattern = null;\n        }\n        if (value != null)\n        {\n            if (!(value instanceof Object[]))\n            {\n                throw new IllegalArgumentException(\"annotation parameter \" + param\n                    + \" has not a class array type\");\n            }\n\n            for (Object v: ((Object[]) value))\n            {\n                if (pattern != null)\n                {\n                    v = Patterns.parseClass(v.toString(), pattern, 1);\n                }\n                try\n                {\n                    m_json.append(param.toString(), v.toString());\n                    collect.add(v.toString());\n                }\n                catch (JSONException e)\n                {\n                    throw new IllegalArgumentException(\"Could not add param \" + param + \":\"\n                            + value.toString(), e);\n                }\n            }\n        }\n    }","id":91512,"modified_method":"/**\n     * Get a class array attribute value from an annotation and write it into this descriptor entry.\n     * Also collect classes found from the array into a given Set.\n     * @return the class array size.\n     */\n    public int putClassArray(Annotation annotation, EntryParam param, Object def, Set<String> collect)\n    {\n        checkType(param.toString());\n\n        Pattern pattern = Patterns.CLASS;\n        Object value = annotation.get(param.toString());\n        if (value == null && def != null)\n        {\n            value = def;\n            pattern = null;\n        }\n        if (value != null)\n        {\n            if (!(value instanceof Object[]))\n            {\n                throw new IllegalArgumentException(\"annotation parameter \" + param\n                    + \" has not a class array type\");\n            }\n\n            for (Object v: ((Object[]) value))\n            {\n                if (pattern != null)\n                {\n                    v = Patterns.parseClass(v.toString(), pattern, 1);\n                }\n                try\n                {\n                    m_json.append(param.toString(), v.toString());\n                    collect.add(v.toString());\n                }\n                catch (JSONException e)\n                {\n                    throw new IllegalArgumentException(\"Could not add param \" + param + \":\"\n                            + value.toString(), e);\n                }\n            }\n            \n            return ((Object[]) value).length;\n        }\n        \n        return 0;\n    }","commit_id":"ba7157dc9d25247b37c00893a431032a51ab4a81","url":"https://github.com/apache/felix"},{"original_method":"private void forAllSdks(Processor<Sdk> processor) {\n    final Sdk[] allSdks = ProjectJdkTable.getInstance().getAllJdks();\n    for (Sdk sdk : allSdks) {\n      if (!myNames.contains(sdk.getName())) {\n        continue;\n      }\n\n      if (!processor.process(sdk)) {\n        return;\n      }\n    }\n  }","id":91513,"modified_method":"private void forAllSdks(Processor<Sdk> processor) {\n    if (mySdks == null) {\n      List<Sdk> sdks = ContainerUtil.findAll(ProjectJdkTable.getInstance().getAllJdks(), new Condition<Sdk>() {\n        @Override\n        public boolean value(final Sdk sdk) {\n          return ArrayUtil.contains(sdk.getName(), myNames);\n        }\n      });\n      mySdks = sdks.toArray(new Sdk[sdks.size()]);\n    }\n\n    for (Sdk sdk : mySdks) {\n      if (!processor.process(sdk)) {\n        return;\n      }\n    }\n  }","commit_id":"212e5b24e7bde77339949cd34a848f833c83c0a9","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public Sdk findSdk(final String name, final String sdkType) {\n      if (TYPE.getName().equals(sdkType)) {\n        final List<String> sdksNames = StringUtil.split(name, NAME_DELIM);\n        return new FlexCompositeSdk(sdksNames);\n      }\n      return null;\n    }","id":91514,"modified_method":"public Sdk findSdk(final String name, final String sdkType) {\n      if (TYPE.getName().equals(sdkType)) {\n        final List<String> sdksNames = StringUtil.split(name, NAME_DELIM);\n        return new FlexCompositeSdk(ArrayUtil.toStringArray(sdksNames));\n      }\n      return null;\n    }","commit_id":"212e5b24e7bde77339949cd34a848f833c83c0a9","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public FlexCompositeSdk(Collection<String> names) {\n    myNames = names;\n  }","id":91515,"modified_method":"public FlexCompositeSdk(String[] names) {\n    myNames = names;\n    init();\n  }","commit_id":"212e5b24e7bde77339949cd34a848f833c83c0a9","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  public Object clone() {\n    return super.clone();\n  }","id":91516,"modified_method":"@NotNull\n  public Object clone() {\n    throw new UnsupportedOperationException();\n  }","commit_id":"212e5b24e7bde77339949cd34a848f833c83c0a9","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void commit() throws ConfigurationException {\n    for (Module module : myModule2Editors.keySet()) {\n      ModifiableRootModel modifiableModel = myProvider.getModuleModifiableModel(module);\n      Collection<String> usedModulesLibrariesIds = new ArrayList<String>();\n      \n      // ---------------- SDK and shared libraries entries ----------------------\n      Map<Library, Boolean> librariesToAdd = new HashMap<Library, Boolean>(); // Library -> add_library_entry_flag\n      Collection<String> sdksNames = new HashSet<String>();\n      for (Editor editor : myModule2Editors.get(module)) {\n        final SdkEntry sdkEntry = editor.getDependencies().getSdkEntry();\n        if (sdkEntry != null) {\n          sdksNames.add(sdkEntry.getName());\n        }\n\n        for (DependencyEntry dependencyEntry : editor.getDependencies().getEntries()) {\n          if (dependencyEntry instanceof ModuleLibraryEntry) {\n            ModuleLibraryEntry moduleLibraryEntry = (ModuleLibraryEntry)dependencyEntry;\n            usedModulesLibrariesIds.add(moduleLibraryEntry.getLibraryId());\n          }\n          if (dependencyEntry instanceof SharedLibraryEntry) {\n            SharedLibraryEntry sharedLibraryEntry = (SharedLibraryEntry)dependencyEntry;\n            Library library =\n              myProvider.findSourceLibraryForLiveName(sharedLibraryEntry.getLibraryName(), sharedLibraryEntry.getLibraryLevel());\n            if (library != null) {\n              librariesToAdd.put(library, true);\n            }\n          }\n        }\n      }\n\n      modifiableModel.setSdk(sdksNames.isEmpty() ? null : new FlexCompositeSdk(sdksNames));\n\n      Collection<OrderEntry> entriesToRemove = new ArrayList<OrderEntry>();\n      for (OrderEntry orderEntry : modifiableModel.getOrderEntries()) {\n        if (orderEntry instanceof LibraryOrderEntry) {\n          if (((LibraryOrderEntry)orderEntry).isModuleLevel()) {\n            LibraryEx library = (LibraryEx)((LibraryOrderEntry)orderEntry).getLibrary();\n            if (FlexProjectRootsUtil.isFlexLibrary(library) &&\n                !usedModulesLibrariesIds.contains(FlexProjectRootsUtil.getLibraryId(library))) {\n              entriesToRemove.add(orderEntry);\n            }\n          }\n          else {\n            LibraryEx library = (LibraryEx)((LibraryOrderEntry)orderEntry).getLibrary();\n            if (librariesToAdd.containsKey(library)) {\n              librariesToAdd.put(library, false); // entry already exists for this library\n            }\n            else if (library != null && FlexProjectRootsUtil.isFlexLibrary(library)) {\n              entriesToRemove.add(orderEntry);\n            }\n          }\n        }\n      }\n      for (OrderEntry e : entriesToRemove) {\n        modifiableModel.removeOrderEntry(e);\n      }\n\n      for (Library library : librariesToAdd.keySet()) {\n        if (!((LibraryEx)library).isDisposed() && librariesToAdd.get(library) &&\n            myProvider.findSourceLibrary(library.getName(), library.getTable().getTableLevel()) != null) {\n          modifiableModel.addLibraryEntry(library);\n        }\n      }\n\n      // ---------------- modules entries ----------------------\n      final Map<Module, Boolean> modulesToAdd = new HashMap<Module, Boolean>(); // Module -> add_module_entry_flag\n      for (Editor editor : myModule2Editors.get(module)) {\n        for (DependencyEntry dependencyEntry : editor.getDependencies().getEntries()) {\n          if (dependencyEntry instanceof BuildConfigurationEntry) {\n            final Module dependencyModule = findModuleWithBC((BuildConfigurationEntry)dependencyEntry);\n            if (dependencyModule != null && dependencyModule != module) {\n              modulesToAdd.put(dependencyModule, true);\n            }\n          }\n        }\n      }\n\n      List<OrderEntry> moduleOrderEntriesToRemove = ContainerUtil.filter(modifiableModel.getOrderEntries(), new Condition<OrderEntry>() {\n        @Override\n        public boolean value(OrderEntry orderEntry) {\n          if (orderEntry instanceof ModuleOrderEntry) {\n            Module m = ((ModuleOrderEntry)orderEntry).getModule();\n            if (modulesToAdd.containsKey(m)) {\n              modulesToAdd.put(m, false);\n              return false;\n            }\n            else {\n              return true;\n            }\n          }\n          return false;\n        }\n      });\n\n      for (OrderEntry orderEntry : moduleOrderEntriesToRemove) {\n        modifiableModel.removeOrderEntry(orderEntry);\n      }\n      for (Module m : modulesToAdd.keySet()) {\n        if (modulesToAdd.get(m)) {\n          modifiableModel.addModuleOrderEntry(m);\n        }\n      }\n    }\n\n    // ---------------- do commit ----------------------\n    Collection<Module> modulesWithChangedModifiableModel = ContainerUtil.findAll(myModule2Editors.keySet(), new Condition<Module>() {\n      @Override\n      public boolean value(Module module) {\n        return myProvider.getModuleModifiableModel(module).isChanged();\n      }\n    });\n\n    if (!modulesWithChangedModifiableModel.isEmpty()) {\n      myProvider.commitModifiableModels();\n      myModulesModelChangeEventDispatcher.getMulticaster().modulesModelsChanged(modulesWithChangedModifiableModel);\n    }\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        for (Module module : myModule2Editors.keySet()) {\n          Function<Editor, FlexIdeBuildConfigurationImpl> f = new Function<Editor, FlexIdeBuildConfigurationImpl>() {\n            @Override\n            public FlexIdeBuildConfigurationImpl fun(Editor editor) {\n              return editor.commit();\n            }\n          };\n          FlexIdeBuildConfigurationImpl[] current =\n            ContainerUtil.map2Array(myModule2Editors.get(module), FlexIdeBuildConfigurationImpl.class, f);\n          ((FlexBuildConfigurationManagerImpl)FlexBuildConfigurationManager.getInstance(module)).setBuildConfigurations(current);\n        }\n\n        //if (mySdksEditor.isModified()) {\n        //  mySdksEditor.commit();\n        //}\n\n        if (myProject != null) {\n          FlexBuildConfigurationManagerImpl.resetHighlighting(myProject);\n        }\n      }\n    });\n  }","id":91517,"modified_method":"public void commit() throws ConfigurationException {\n    for (Module module : myModule2Editors.keySet()) {\n      ModifiableRootModel modifiableModel = myProvider.getModuleModifiableModel(module);\n      Collection<String> usedModulesLibrariesIds = new ArrayList<String>();\n      \n      // ---------------- SDK and shared libraries entries ----------------------\n      Map<Library, Boolean> librariesToAdd = new HashMap<Library, Boolean>(); // Library -> add_library_entry_flag\n\n      Collection<Sdk> sdks = new HashSet<Sdk>();\n      final Sdk[] allSdks = myProvider.getAllSdks();\n      for (Editor editor : myModule2Editors.get(module)) {\n        final SdkEntry sdkEntry = editor.getDependencies().getSdkEntry();\n        if (sdkEntry != null) {\n          sdks.add(ContainerUtil.find(allSdks, new Condition<Sdk>() {\n            @Override\n            public boolean value(final Sdk sdk) {\n              return sdkEntry.getName().equals(sdk.getName());\n            }\n          }));\n        }\n\n        for (DependencyEntry dependencyEntry : editor.getDependencies().getEntries()) {\n          if (dependencyEntry instanceof ModuleLibraryEntry) {\n            ModuleLibraryEntry moduleLibraryEntry = (ModuleLibraryEntry)dependencyEntry;\n            usedModulesLibrariesIds.add(moduleLibraryEntry.getLibraryId());\n          }\n          if (dependencyEntry instanceof SharedLibraryEntry) {\n            SharedLibraryEntry sharedLibraryEntry = (SharedLibraryEntry)dependencyEntry;\n            Library library =\n              myProvider.findSourceLibraryForLiveName(sharedLibraryEntry.getLibraryName(), sharedLibraryEntry.getLibraryLevel());\n            if (library != null) {\n              librariesToAdd.put(library, true);\n            }\n          }\n        }\n      }\n\n      modifiableModel.setSdk(sdks.isEmpty() ? null : new FlexCompositeSdk(sdks.toArray(new Sdk[sdks.size()])));\n\n      Collection<OrderEntry> entriesToRemove = new ArrayList<OrderEntry>();\n      for (OrderEntry orderEntry : modifiableModel.getOrderEntries()) {\n        if (orderEntry instanceof LibraryOrderEntry) {\n          if (((LibraryOrderEntry)orderEntry).isModuleLevel()) {\n            LibraryEx library = (LibraryEx)((LibraryOrderEntry)orderEntry).getLibrary();\n            if (FlexProjectRootsUtil.isFlexLibrary(library) &&\n                !usedModulesLibrariesIds.contains(FlexProjectRootsUtil.getLibraryId(library))) {\n              entriesToRemove.add(orderEntry);\n            }\n          }\n          else {\n            LibraryEx library = (LibraryEx)((LibraryOrderEntry)orderEntry).getLibrary();\n            if (librariesToAdd.containsKey(library)) {\n              librariesToAdd.put(library, false); // entry already exists for this library\n            }\n            else if (library != null && FlexProjectRootsUtil.isFlexLibrary(library)) {\n              entriesToRemove.add(orderEntry);\n            }\n          }\n        }\n      }\n      for (OrderEntry e : entriesToRemove) {\n        modifiableModel.removeOrderEntry(e);\n      }\n\n      for (Library library : librariesToAdd.keySet()) {\n        if (!((LibraryEx)library).isDisposed() && librariesToAdd.get(library) &&\n            myProvider.findSourceLibrary(library.getName(), library.getTable().getTableLevel()) != null) {\n          modifiableModel.addLibraryEntry(library);\n        }\n      }\n\n      // ---------------- modules entries ----------------------\n      final Map<Module, Boolean> modulesToAdd = new HashMap<Module, Boolean>(); // Module -> add_module_entry_flag\n      for (Editor editor : myModule2Editors.get(module)) {\n        for (DependencyEntry dependencyEntry : editor.getDependencies().getEntries()) {\n          if (dependencyEntry instanceof BuildConfigurationEntry) {\n            final Module dependencyModule = findModuleWithBC((BuildConfigurationEntry)dependencyEntry);\n            if (dependencyModule != null && dependencyModule != module) {\n              modulesToAdd.put(dependencyModule, true);\n            }\n          }\n        }\n      }\n\n      List<OrderEntry> moduleOrderEntriesToRemove = ContainerUtil.filter(modifiableModel.getOrderEntries(), new Condition<OrderEntry>() {\n        @Override\n        public boolean value(OrderEntry orderEntry) {\n          if (orderEntry instanceof ModuleOrderEntry) {\n            Module m = ((ModuleOrderEntry)orderEntry).getModule();\n            if (modulesToAdd.containsKey(m)) {\n              modulesToAdd.put(m, false);\n              return false;\n            }\n            else {\n              return true;\n            }\n          }\n          return false;\n        }\n      });\n\n      for (OrderEntry orderEntry : moduleOrderEntriesToRemove) {\n        modifiableModel.removeOrderEntry(orderEntry);\n      }\n      for (Module m : modulesToAdd.keySet()) {\n        if (modulesToAdd.get(m)) {\n          modifiableModel.addModuleOrderEntry(m);\n        }\n      }\n    }\n\n    // ---------------- do commit ----------------------\n    Collection<Module> modulesWithChangedModifiableModel = ContainerUtil.findAll(myModule2Editors.keySet(), new Condition<Module>() {\n      @Override\n      public boolean value(Module module) {\n        return myProvider.getModuleModifiableModel(module).isChanged();\n      }\n    });\n\n    if (!modulesWithChangedModifiableModel.isEmpty()) {\n      myProvider.commitModifiableModels();\n      myModulesModelChangeEventDispatcher.getMulticaster().modulesModelsChanged(modulesWithChangedModifiableModel);\n    }\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        for (Module module : myModule2Editors.keySet()) {\n          Function<Editor, FlexIdeBuildConfigurationImpl> f = new Function<Editor, FlexIdeBuildConfigurationImpl>() {\n            @Override\n            public FlexIdeBuildConfigurationImpl fun(Editor editor) {\n              return editor.commit();\n            }\n          };\n          FlexIdeBuildConfigurationImpl[] current =\n            ContainerUtil.map2Array(myModule2Editors.get(module), FlexIdeBuildConfigurationImpl.class, f);\n          ((FlexBuildConfigurationManagerImpl)FlexBuildConfigurationManager.getInstance(module)).setBuildConfigurations(current);\n        }\n\n        //if (mySdksEditor.isModified()) {\n        //  mySdksEditor.commit();\n        //}\n\n        if (myProject != null) {\n          FlexBuildConfigurationManagerImpl.resetHighlighting(myProject);\n        }\n      }\n    });\n  }","commit_id":"212e5b24e7bde77339949cd34a848f833c83c0a9","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static Sdk showDialog(final Project project, String title, final Component parent, Sdk jdkToSelect) {\n    final JdkChooserPanel jdkChooserPanel = new JdkChooserPanel(project);\n    jdkChooserPanel.fillList(null);\n    final MyDialog dialog = jdkChooserPanel.new MyDialog(parent);\n    if (title != null) {\n      dialog.setTitle(title);\n    }\n    if (jdkToSelect != null) {\n      jdkChooserPanel.selectJdk(jdkToSelect);\n    } else {\n      ListScrollingUtil.ensureSelectionExists(jdkChooserPanel.myList);\n    }\n    new DoubleClickListener() {\n      @Override\n      protected boolean onDoubleClick(MouseEvent e) {\n        dialog.clickDefaultButton();\n        return true;\n      }\n    }.installOn(jdkChooserPanel.myList);\n    dialog.show();\n    return dialog.isOK() ? jdkChooserPanel.getChosenJdk() : null;\n  }","id":91518,"modified_method":"private static Sdk showDialog(final Project project, String title, final Component parent, Sdk jdkToSelect) {\n    final JdkChooserPanel jdkChooserPanel = new JdkChooserPanel(project);\n    jdkChooserPanel.fillList(null, null);\n    final MyDialog dialog = jdkChooserPanel.new MyDialog(parent);\n    if (title != null) {\n      dialog.setTitle(title);\n    }\n    if (jdkToSelect != null) {\n      jdkChooserPanel.selectJdk(jdkToSelect);\n    } else {\n      ListScrollingUtil.ensureSelectionExists(jdkChooserPanel.myList);\n    }\n    new DoubleClickListener() {\n      @Override\n      protected boolean onDoubleClick(MouseEvent e) {\n        dialog.clickDefaultButton();\n        return true;\n      }\n    }.installOn(jdkChooserPanel.myList);\n    dialog.show();\n    return dialog.isOK() ? jdkChooserPanel.getChosenJdk() : null;\n  }","commit_id":"c0333e473154f7b27c00f3ba97ec087f7243a73a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void editJdkTable() {\n    ProjectJdksEditor editor = new ProjectJdksEditor((Sdk)myList.getSelectedValue(),\n                                                     myProject != null ? myProject : ProjectManager.getInstance().getDefaultProject(),\n                                                     myList);\n    editor.show();\n    if (editor.isOK()) {\n      Sdk selectedJdk = editor.getSelectedJdk();\n      updateList(selectedJdk, null);\n    }\n  }","id":91519,"modified_method":"public void editJdkTable() {\n    ProjectJdksEditor editor = new ProjectJdksEditor((Sdk)myList.getSelectedValue(),\n                                                     myProject != null ? myProject : ProjectManager.getInstance().getDefaultProject(),\n                                                     myList);\n    editor.show();\n    if (editor.isOK()) {\n      Sdk selectedJdk = editor.getSelectedJdk();\n      updateList(selectedJdk, null, null);\n    }\n  }","commit_id":"c0333e473154f7b27c00f3ba97ec087f7243a73a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void fillList(final SdkType type) {\n    myListModel.clear();\n    final Sdk[] jdks;\n    if (myProject == null || myProject.isDefault()) {\n      final Sdk[] allJdks = ProjectJdkTable.getInstance().getAllJdks();\n      jdks = getCompatibleJdks(type, Arrays.asList(allJdks));\n    }\n    else {\n      final ProjectSdksModel projectJdksModel = ProjectStructureConfigurable.getInstance(myProject).getProjectJdksModel();\n      if (!projectJdksModel.isInitialized()){ //should be initialized\n        projectJdksModel.reset(myProject);\n      }\n      final Collection<Sdk> collection = projectJdksModel.getProjectSdks().values();\n      jdks = getCompatibleJdks(type, collection);\n    }\n    Arrays.sort(jdks, new Comparator<Sdk>() {\n      public int compare(final Sdk o1, final Sdk o2) {\n        return o1.getName().compareToIgnoreCase(o2.getName());\n      }\n    });\n    for (Sdk jdk : jdks) {\n      myListModel.addElement(jdk);\n    }\n  }","id":91520,"modified_method":"public void fillList(final SdkType type, final @Nullable Sdk[] globalSdks) {\n    myListModel.clear();\n    final Sdk[] jdks;\n    if (myProject == null || myProject.isDefault()) {\n      final Sdk[] allJdks = globalSdks != null ? globalSdks : ProjectJdkTable.getInstance().getAllJdks();\n      jdks = getCompatibleJdks(type, Arrays.asList(allJdks));\n    }\n    else {\n      final ProjectSdksModel projectJdksModel = ProjectStructureConfigurable.getInstance(myProject).getProjectJdksModel();\n      if (!projectJdksModel.isInitialized()){ //should be initialized\n        projectJdksModel.reset(myProject);\n      }\n      final Collection<Sdk> collection = projectJdksModel.getProjectSdks().values();\n      jdks = getCompatibleJdks(type, collection);\n    }\n    Arrays.sort(jdks, new Comparator<Sdk>() {\n      public int compare(final Sdk o1, final Sdk o2) {\n        return o1.getName().compareToIgnoreCase(o2.getName());\n      }\n    });\n    for (Sdk jdk : jdks) {\n      myListModel.addElement(jdk);\n    }\n  }","commit_id":"c0333e473154f7b27c00f3ba97ec087f7243a73a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateList(final Sdk selectedJdk, final SdkType type) {\n    final int[] selectedIndices = myList.getSelectedIndices();\n    fillList(type);\n    // restore selection\n    if (selectedJdk != null) {\n      TIntArrayList list = new TIntArrayList();\n      for (int i = 0; i < myListModel.size(); i++) {\n        final Sdk jdk = (Sdk)myListModel.getElementAt(i);\n        if (Comparing.strEqual(jdk.getName(), selectedJdk.getName())){\n          list.add(i);\n        }\n      }\n      final int[] indicesToSelect = list.toNativeArray();\n      if (indicesToSelect.length > 0) {\n        myList.setSelectedIndices(indicesToSelect);\n      }\n      else if (myList.getModel().getSize() > 0) {\n        myList.setSelectedIndex(0);\n      }\n    }\n    else {\n      if (selectedIndices.length > 0) {\n        myList.setSelectedIndices(selectedIndices);\n      }\n      else {\n        myList.setSelectedIndex(0);\n      }\n    }\n\n    myCurrentJdk = (Sdk)myList.getSelectedValue();\n  }","id":91521,"modified_method":"public void updateList(final Sdk selectedJdk, final SdkType type, final @Nullable Sdk[] globalSdks) {\n    final int[] selectedIndices = myList.getSelectedIndices();\n    fillList(type, globalSdks);\n    // restore selection\n    if (selectedJdk != null) {\n      TIntArrayList list = new TIntArrayList();\n      for (int i = 0; i < myListModel.size(); i++) {\n        final Sdk jdk = (Sdk)myListModel.getElementAt(i);\n        if (Comparing.strEqual(jdk.getName(), selectedJdk.getName())){\n          list.add(i);\n        }\n      }\n      final int[] indicesToSelect = list.toNativeArray();\n      if (indicesToSelect.length > 0) {\n        myList.setSelectedIndices(indicesToSelect);\n      }\n      else if (myList.getModel().getSize() > 0) {\n        myList.setSelectedIndex(0);\n      }\n    }\n    else {\n      if (selectedIndices.length > 0) {\n        myList.setSelectedIndices(selectedIndices);\n      }\n      else {\n        myList.setSelectedIndex(0);\n      }\n    }\n\n    myCurrentJdk = (Sdk)myList.getSelectedValue();\n  }","commit_id":"c0333e473154f7b27c00f3ba97ec087f7243a73a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ProjectJdkForModuleStep(final WizardContext context, final SdkType type) {\n    myContext = context;\n    myType = type;\n    myJdkChooser = new JdkChooserPanel(getProject(context, type));\n\n    myPanel = new JPanel(new GridBagLayout());\n    myPanel.setBorder(BorderFactory.createEtchedBorder());\n\n    final JLabel label = new JLabel(IdeBundle.message(\"prompt.please.select.module.jdk\", type.getPresentableName()));\n    label.setUI(new MultiLineLabelUI());\n    myPanel.add(label, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 2, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST,\n                                              GridBagConstraints.HORIZONTAL, new Insets(8, 10, 8, 10), 0, 0));\n\n    final JLabel jdklabel = new JLabel(IdeBundle.message(\"label.project.jdk\"));\n    jdklabel.setFont(UIUtil.getLabelFont().deriveFont(Font.BOLD));\n    myPanel.add(jdklabel, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 2, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST,\n                                                 GridBagConstraints.NONE, new Insets(8, 10, 0, 10), 0, 0));\n\n    myPanel.add(myJdkChooser, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 2, 1.0, 1.0, GridBagConstraints.NORTHWEST,\n                                                     GridBagConstraints.BOTH, new Insets(2, 10, 10, 5), 0, 0));\n    JButton configureButton = new JButton(IdeBundle.message(\"button.configure\"));\n    myPanel.add(configureButton, new GridBagConstraints(1, GridBagConstraints.RELATIVE, 1, 1, 0.0, 0.0, GridBagConstraints.NORTHWEST,\n                                                        GridBagConstraints.NONE, new Insets(2, 0, 5, 5), 0, 0));\n    mySetAsDefaultButton = new JButton(\"Set Default\");\n    mySetAsDefaultButton.setMnemonic('D');\n    myPanel.add(mySetAsDefaultButton, new GridBagConstraints(1, GridBagConstraints.RELATIVE, 1, 1, 0.0, 1.0, GridBagConstraints.NORTHWEST,\n                                                 GridBagConstraints.NONE, new Insets(2, 0, 10, 5), 0, 0));\n\n    configureButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n\n        final Project project = getProject(context, type);\n        final ProjectStructureConfigurable projectConfig = ProjectStructureConfigurable.getInstance(project);\n        final JdkListConfigurable jdkConfig = JdkListConfigurable.getInstance(project);\n        final ProjectSdksModel projectJdksModel = projectConfig.getProjectJdksModel();\n        final boolean[] successfullyAdded = new boolean[1];\n        projectJdksModel.doAdd(type, new Consumer<Sdk>() {\n          public void consume(final Sdk jdk) {\n            successfullyAdded[0] = jdkConfig.addJdkNode(jdk, false);\n            myJdkChooser.updateList(jdk, type);\n\n            if (!successfullyAdded[0]) {\n              try {\n                projectJdksModel.apply(jdkConfig);\n              }\n              catch (ConfigurationException e1) {\n                //name can't be wrong\n              }\n            }\n          }\n        });\n      }\n    });\n\n    final Project defaultProject = ProjectManagerEx.getInstanceEx().getDefaultProject();\n    mySetAsDefaultButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        \n        final Sdk jdk = getJdk();\n        final Runnable runnable = new Runnable() {\n          public void run() {\n            ProjectRootManagerEx.getInstanceEx(defaultProject).setProjectSdk(jdk);\n          }\n        };\n        ApplicationManager.getApplication().runWriteAction(runnable);\n        mySetAsDefaultButton.setEnabled(false);\n      }\n    });\n\n    myJdkChooser.addSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        mySetAsDefaultButton.setEnabled(getJdk() != ProjectRootManagerEx.getInstanceEx(defaultProject).getProjectSdk());\n      }\n    });\n  }","id":91522,"modified_method":"public ProjectJdkForModuleStep(final WizardContext context, final SdkType type) {\n    myContext = context;\n    myType = type;\n    myJdkChooser = new JdkChooserPanel(getProject(context, type));\n\n    myPanel = new JPanel(new GridBagLayout());\n    myPanel.setBorder(BorderFactory.createEtchedBorder());\n\n    final JLabel label = new JLabel(IdeBundle.message(\"prompt.please.select.module.jdk\", type.getPresentableName()));\n    label.setUI(new MultiLineLabelUI());\n    myPanel.add(label, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 2, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST,\n                                              GridBagConstraints.HORIZONTAL, new Insets(8, 10, 8, 10), 0, 0));\n\n    final JLabel jdklabel = new JLabel(IdeBundle.message(\"label.project.jdk\"));\n    jdklabel.setFont(UIUtil.getLabelFont().deriveFont(Font.BOLD));\n    myPanel.add(jdklabel, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 2, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST,\n                                                 GridBagConstraints.NONE, new Insets(8, 10, 0, 10), 0, 0));\n\n    myPanel.add(myJdkChooser, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 2, 1.0, 1.0, GridBagConstraints.NORTHWEST,\n                                                     GridBagConstraints.BOTH, new Insets(2, 10, 10, 5), 0, 0));\n    JButton configureButton = new JButton(IdeBundle.message(\"button.configure\"));\n    myPanel.add(configureButton, new GridBagConstraints(1, GridBagConstraints.RELATIVE, 1, 1, 0.0, 0.0, GridBagConstraints.NORTHWEST,\n                                                        GridBagConstraints.NONE, new Insets(2, 0, 5, 5), 0, 0));\n    mySetAsDefaultButton = new JButton(\"Set Default\");\n    mySetAsDefaultButton.setMnemonic('D');\n    myPanel.add(mySetAsDefaultButton, new GridBagConstraints(1, GridBagConstraints.RELATIVE, 1, 1, 0.0, 1.0, GridBagConstraints.NORTHWEST,\n                                                 GridBagConstraints.NONE, new Insets(2, 0, 10, 5), 0, 0));\n\n    configureButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n\n        final Project project = getProject(context, type);\n        final ProjectStructureConfigurable projectConfig = ProjectStructureConfigurable.getInstance(project);\n        final JdkListConfigurable jdkConfig = JdkListConfigurable.getInstance(project);\n        final ProjectSdksModel projectJdksModel = projectConfig.getProjectJdksModel();\n        final boolean[] successfullyAdded = new boolean[1];\n        projectJdksModel.doAdd(type, new Consumer<Sdk>() {\n          public void consume(final Sdk jdk) {\n            successfullyAdded[0] = jdkConfig.addJdkNode(jdk, false);\n            myJdkChooser.updateList(jdk, type, projectJdksModel.getSdks());\n\n            if (!successfullyAdded[0]) {\n              try {\n                projectJdksModel.apply(jdkConfig);\n              }\n              catch (ConfigurationException e1) {\n                //name can't be wrong\n              }\n            }\n          }\n        });\n      }\n    });\n\n    final Project defaultProject = ProjectManagerEx.getInstanceEx().getDefaultProject();\n    mySetAsDefaultButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        \n        final Sdk jdk = getJdk();\n        final Runnable runnable = new Runnable() {\n          public void run() {\n            ProjectRootManagerEx.getInstanceEx(defaultProject).setProjectSdk(jdk);\n          }\n        };\n        ApplicationManager.getApplication().runWriteAction(runnable);\n        mySetAsDefaultButton.setEnabled(false);\n      }\n    });\n\n    myJdkChooser.addSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        mySetAsDefaultButton.setEnabled(getJdk() != ProjectRootManagerEx.getInstanceEx(defaultProject).getProjectSdk());\n      }\n    });\n  }","commit_id":"c0333e473154f7b27c00f3ba97ec087f7243a73a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateStep() {\n    if (!myInitialized) { //lazy default project initialization\n      myJdkChooser.fillList(myType);\n      final Sdk defaultJdk = getDefaultJdk(myContext);\n      if (defaultJdk != null) {\n        myJdkChooser.selectJdk(defaultJdk);\n      }\n      mySetAsDefaultButton.setEnabled(defaultJdk != null);\n      myInitialized = true;\n    }\n  }","id":91523,"modified_method":"public void updateStep() {\n    if (!myInitialized) { //lazy default project initialization\n      myJdkChooser.fillList(myType, null);\n      final Sdk defaultJdk = getDefaultJdk(myContext);\n      if (defaultJdk != null) {\n        myJdkChooser.selectJdk(defaultJdk);\n      }\n      mySetAsDefaultButton.setEnabled(defaultJdk != null);\n      myInitialized = true;\n    }\n  }","commit_id":"c0333e473154f7b27c00f3ba97ec087f7243a73a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Sdk[] getSdks() {\n    if (mySdks != null) {\n      return mySdks;\n    }\n\n    List<Sdk> sdks = ContainerUtil.findAll(ProjectJdkTable.getInstance().getAllJdks(), new Condition<Sdk>() {\n      @Override\n      public boolean value(final Sdk sdk) {\n        return ArrayUtil.contains(sdk.getName(), myNames);\n      }\n    });\n    return mySdks = sdks.toArray(new Sdk[sdks.size()]);\n  }","id":91524,"modified_method":"@NotNull\n  public Sdk[] getSdks() {\n    if (mySdks != null) {\n      return mySdks;\n    }\n\n    Sdk[] allSdks;\n    boolean cache;\n    final FlexProjectConfigurationEditor currentEditor = FlexBuildConfigurationsExtension.getInstance().getConfigurator().getConfigEditor();\n    if (currentEditor == null) {\n      allSdks = ProjectJdkTable.getInstance().getAllJdks();\n      cache = true;\n    }\n    else {\n      final Collection<Sdk> sdks =\n        ProjectStructureConfigurable.getInstance(currentEditor.getProject()).getProjectJdksModel().getProjectSdks().values();\n      allSdks = sdks.toArray(new Sdk[sdks.size()]);\n      cache = false;\n    }\n\n    List<Sdk> result = ContainerUtil.findAll(allSdks, new Condition<Sdk>() {\n      @Override\n      public boolean value(final Sdk sdk) {\n        return ArrayUtil.contains(sdk.getName(), myNames);\n      }\n    });\n\n    Sdk[] resultArray = result.toArray(new Sdk[result.size()]);\n    if (cache) {\n      mySdks = resultArray;\n    }\n    return resultArray;\n  }","commit_id":"1227b7771944984846860c2c7ba3833adefbdf75","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void commit() throws ConfigurationException {\n    for (Module module : myModule2Editors.keySet()) {\n      ModifiableRootModel modifiableModel = myProvider.getModuleModifiableModel(module);\n      Collection<String> usedModulesLibrariesIds = new ArrayList<String>();\n\n      // ---------------- SDK and shared libraries entries ----------------------\n      Map<Library, Boolean> librariesToAdd = new HashMap<Library, Boolean>(); // Library -> add_library_entry_flag\n\n      Collection<Sdk> sdks = new HashSet<Sdk>();\n      final Sdk[] allSdks = myProvider.getAllSdks();\n      for (Editor editor : myModule2Editors.get(module)) {\n        final SdkEntry sdkEntry = editor.getDependencies().getSdkEntry();\n        if (sdkEntry != null) {\n          ContainerUtil.addIfNotNull(sdks, ContainerUtil.find(allSdks, new Condition<Sdk>() {\n            @Override\n            public boolean value(final Sdk sdk) {\n              return sdkEntry.getName().equals(sdk.getName());\n            }\n          }));\n        }\n\n        for (DependencyEntry dependencyEntry : editor.getDependencies().getEntries()) {\n          if (dependencyEntry instanceof ModuleLibraryEntry) {\n            ModuleLibraryEntry moduleLibraryEntry = (ModuleLibraryEntry)dependencyEntry;\n            usedModulesLibrariesIds.add(moduleLibraryEntry.getLibraryId());\n          }\n          if (dependencyEntry instanceof SharedLibraryEntry) {\n            SharedLibraryEntry sharedLibraryEntry = (SharedLibraryEntry)dependencyEntry;\n            Library library =\n              myProvider.findSourceLibraryForLiveName(sharedLibraryEntry.getLibraryName(), sharedLibraryEntry.getLibraryLevel());\n            if (library != null) {\n              librariesToAdd.put(library, true);\n            }\n          }\n        }\n      }\n\n      modifiableModel.setSdk(sdks.isEmpty() ? null : new FlexCompositeSdk(sdks.toArray(new Sdk[sdks.size()])));\n\n      Collection<OrderEntry> entriesToRemove = new ArrayList<OrderEntry>();\n      for (OrderEntry orderEntry : modifiableModel.getOrderEntries()) {\n        if (orderEntry instanceof LibraryOrderEntry) {\n          if (((LibraryOrderEntry)orderEntry).isModuleLevel()) {\n            LibraryEx library = (LibraryEx)((LibraryOrderEntry)orderEntry).getLibrary();\n            if (FlexProjectRootsUtil.isFlexLibrary(library) &&\n                !usedModulesLibrariesIds.contains(FlexProjectRootsUtil.getLibraryId(library))) {\n              entriesToRemove.add(orderEntry);\n            }\n          }\n          else {\n            LibraryEx library = (LibraryEx)((LibraryOrderEntry)orderEntry).getLibrary();\n            if (librariesToAdd.containsKey(library)) {\n              librariesToAdd.put(library, false); // entry already exists for this library\n            }\n            else if (library != null && FlexProjectRootsUtil.isFlexLibrary(library)) {\n              entriesToRemove.add(orderEntry);\n            }\n          }\n        }\n      }\n      for (OrderEntry e : entriesToRemove) {\n        modifiableModel.removeOrderEntry(e);\n      }\n\n      for (Library library : librariesToAdd.keySet()) {\n        if (!((LibraryEx)library).isDisposed() && librariesToAdd.get(library) &&\n            myProvider.findSourceLibrary(library.getName(), library.getTable().getTableLevel()) != null) {\n          modifiableModel.addLibraryEntry(library);\n        }\n      }\n\n      // ---------------- modules entries ----------------------\n      final Map<Module, Boolean> modulesToAdd = new HashMap<Module, Boolean>(); // Module -> add_module_entry_flag\n      for (Editor editor : myModule2Editors.get(module)) {\n        for (DependencyEntry dependencyEntry : editor.getDependencies().getEntries()) {\n          if (dependencyEntry instanceof BuildConfigurationEntry) {\n            final Module dependencyModule = findModuleWithBC((BuildConfigurationEntry)dependencyEntry);\n            if (dependencyModule != null && dependencyModule != module) {\n              modulesToAdd.put(dependencyModule, true);\n            }\n          }\n        }\n      }\n\n      List<OrderEntry> moduleOrderEntriesToRemove = ContainerUtil.filter(modifiableModel.getOrderEntries(), new Condition<OrderEntry>() {\n        @Override\n        public boolean value(OrderEntry orderEntry) {\n          if (orderEntry instanceof ModuleOrderEntry) {\n            Module m = ((ModuleOrderEntry)orderEntry).getModule();\n            if (modulesToAdd.containsKey(m)) {\n              modulesToAdd.put(m, false);\n              return false;\n            }\n            else {\n              return true;\n            }\n          }\n          return false;\n        }\n      });\n\n      for (OrderEntry orderEntry : moduleOrderEntriesToRemove) {\n        modifiableModel.removeOrderEntry(orderEntry);\n      }\n      for (Module m : modulesToAdd.keySet()) {\n        if (modulesToAdd.get(m)) {\n          modifiableModel.addModuleOrderEntry(m);\n        }\n      }\n    }\n\n    // ---------------- do commit ----------------------\n    Collection<Module> modulesWithChangedModifiableModel = ContainerUtil.findAll(myModule2Editors.keySet(), new Condition<Module>() {\n      @Override\n      public boolean value(Module module) {\n        return myProvider.getModuleModifiableModel(module).isChanged();\n      }\n    });\n\n    if (!modulesWithChangedModifiableModel.isEmpty()) {\n      myProvider.commitModifiableModels();\n      myModulesModelChangeEventDispatcher.getMulticaster().modulesModelsChanged(modulesWithChangedModifiableModel);\n    }\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        for (Module module : myModule2Editors.keySet()) {\n          Function<Editor, FlexIdeBuildConfigurationImpl> f = new Function<Editor, FlexIdeBuildConfigurationImpl>() {\n            @Override\n            public FlexIdeBuildConfigurationImpl fun(Editor editor) {\n              return editor.commit();\n            }\n          };\n          FlexIdeBuildConfigurationImpl[] current =\n            ContainerUtil.map2Array(myModule2Editors.get(module), FlexIdeBuildConfigurationImpl.class, f);\n          ((FlexBuildConfigurationManagerImpl)FlexBuildConfigurationManager.getInstance(module)).setBuildConfigurations(current);\n        }\n\n        //if (mySdksEditor.isModified()) {\n        //  mySdksEditor.commit();\n        //}\n\n        if (myProject != null) {\n          FlexBuildConfigurationManagerImpl.resetHighlighting(myProject);\n        }\n      }\n    });\n  }","id":91525,"modified_method":"public void commit() throws ConfigurationException {\n    for (Module module : myModule2Editors.keySet()) {\n      ModifiableRootModel modifiableModel = myProvider.getModuleModifiableModel(module);\n      Collection<String> usedModulesLibrariesIds = new ArrayList<String>();\n\n      // ---------------- SDK and shared libraries entries ----------------------\n      Map<Library, Boolean> librariesToAdd = new HashMap<Library, Boolean>(); // Library -> add_library_entry_flag\n\n      final Collection<String> sdkNames = new HashSet<String>();\n      for (Editor editor : myModule2Editors.get(module)) {\n        final SdkEntry sdkEntry = editor.getDependencies().getSdkEntry();\n        if (sdkEntry != null) {\n          sdkNames.add(sdkEntry.getName());\n        }\n\n        for (DependencyEntry dependencyEntry : editor.getDependencies().getEntries()) {\n          if (dependencyEntry instanceof ModuleLibraryEntry) {\n            ModuleLibraryEntry moduleLibraryEntry = (ModuleLibraryEntry)dependencyEntry;\n            usedModulesLibrariesIds.add(moduleLibraryEntry.getLibraryId());\n          }\n          if (dependencyEntry instanceof SharedLibraryEntry) {\n            SharedLibraryEntry sharedLibraryEntry = (SharedLibraryEntry)dependencyEntry;\n            Library library =\n              myProvider.findSourceLibraryForLiveName(sharedLibraryEntry.getLibraryName(), sharedLibraryEntry.getLibraryLevel());\n            if (library != null) {\n              librariesToAdd.put(library, true);\n            }\n          }\n        }\n      }\n\n      modifiableModel.setSdk(sdkNames.isEmpty() ? null : new FlexCompositeSdk(ArrayUtil.toStringArray(sdkNames)));\n\n      Collection<OrderEntry> entriesToRemove = new ArrayList<OrderEntry>();\n      for (OrderEntry orderEntry : modifiableModel.getOrderEntries()) {\n        if (orderEntry instanceof LibraryOrderEntry) {\n          if (((LibraryOrderEntry)orderEntry).isModuleLevel()) {\n            LibraryEx library = (LibraryEx)((LibraryOrderEntry)orderEntry).getLibrary();\n            if (FlexProjectRootsUtil.isFlexLibrary(library) &&\n                !usedModulesLibrariesIds.contains(FlexProjectRootsUtil.getLibraryId(library))) {\n              entriesToRemove.add(orderEntry);\n            }\n          }\n          else {\n            LibraryEx library = (LibraryEx)((LibraryOrderEntry)orderEntry).getLibrary();\n            if (librariesToAdd.containsKey(library)) {\n              librariesToAdd.put(library, false); // entry already exists for this library\n            }\n            else if (library != null && FlexProjectRootsUtil.isFlexLibrary(library)) {\n              entriesToRemove.add(orderEntry);\n            }\n          }\n        }\n      }\n      for (OrderEntry e : entriesToRemove) {\n        modifiableModel.removeOrderEntry(e);\n      }\n\n      for (Library library : librariesToAdd.keySet()) {\n        if (!((LibraryEx)library).isDisposed() && librariesToAdd.get(library) &&\n            myProvider.findSourceLibrary(library.getName(), library.getTable().getTableLevel()) != null) {\n          modifiableModel.addLibraryEntry(library);\n        }\n      }\n\n      // ---------------- modules entries ----------------------\n      final Map<Module, Boolean> modulesToAdd = new HashMap<Module, Boolean>(); // Module -> add_module_entry_flag\n      for (Editor editor : myModule2Editors.get(module)) {\n        for (DependencyEntry dependencyEntry : editor.getDependencies().getEntries()) {\n          if (dependencyEntry instanceof BuildConfigurationEntry) {\n            final Module dependencyModule = findModuleWithBC((BuildConfigurationEntry)dependencyEntry);\n            if (dependencyModule != null && dependencyModule != module) {\n              modulesToAdd.put(dependencyModule, true);\n            }\n          }\n        }\n      }\n\n      List<OrderEntry> moduleOrderEntriesToRemove = ContainerUtil.filter(modifiableModel.getOrderEntries(), new Condition<OrderEntry>() {\n        @Override\n        public boolean value(OrderEntry orderEntry) {\n          if (orderEntry instanceof ModuleOrderEntry) {\n            Module m = ((ModuleOrderEntry)orderEntry).getModule();\n            if (modulesToAdd.containsKey(m)) {\n              modulesToAdd.put(m, false);\n              return false;\n            }\n            else {\n              return true;\n            }\n          }\n          return false;\n        }\n      });\n\n      for (OrderEntry orderEntry : moduleOrderEntriesToRemove) {\n        modifiableModel.removeOrderEntry(orderEntry);\n      }\n      for (Module m : modulesToAdd.keySet()) {\n        if (modulesToAdd.get(m)) {\n          modifiableModel.addModuleOrderEntry(m);\n        }\n      }\n    }\n\n    // ---------------- do commit ----------------------\n    Collection<Module> modulesWithChangedModifiableModel = ContainerUtil.findAll(myModule2Editors.keySet(), new Condition<Module>() {\n      @Override\n      public boolean value(Module module) {\n        return myProvider.getModuleModifiableModel(module).isChanged();\n      }\n    });\n\n    if (!modulesWithChangedModifiableModel.isEmpty()) {\n      myProvider.commitModifiableModels();\n      myModulesModelChangeEventDispatcher.getMulticaster().modulesModelsChanged(modulesWithChangedModifiableModel);\n    }\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        for (Module module : myModule2Editors.keySet()) {\n          Function<Editor, FlexIdeBuildConfigurationImpl> f = new Function<Editor, FlexIdeBuildConfigurationImpl>() {\n            @Override\n            public FlexIdeBuildConfigurationImpl fun(Editor editor) {\n              return editor.commit();\n            }\n          };\n          FlexIdeBuildConfigurationImpl[] current =\n            ContainerUtil.map2Array(myModule2Editors.get(module), FlexIdeBuildConfigurationImpl.class, f);\n          ((FlexBuildConfigurationManagerImpl)FlexBuildConfigurationManager.getInstance(module)).setBuildConfigurations(current);\n        }\n\n        //if (mySdksEditor.isModified()) {\n        //  mySdksEditor.commit();\n        //}\n\n        if (myProject != null) {\n          FlexBuildConfigurationManagerImpl.resetHighlighting(myProject);\n        }\n      }\n    });\n  }","commit_id":"1227b7771944984846860c2c7ba3833adefbdf75","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public Collection<BuildTarget<?>> computeDependencies(final BuildTargetRegistry registry, TargetOutputIndex outputIndex) {\n    final List<BuildTarget<?>> result = new ArrayList<BuildTarget<?>>(3);\n\n    if (myTargetType == TargetType.PACKAGING) {\n      result.add(new AndroidBuildTarget(TargetType.DEX, myModule));\n    }\n    result.add(new ModuleBuildTarget(myModule, JavaModuleBuildTargetType.PRODUCTION));\n\n    final JpsAndroidModuleExtension extension = AndroidJpsUtil.getExtension(myModule);\n    if (extension != null && extension.isPackTestCode()) {\n      result.add(new ModuleBuildTarget(myModule, JavaModuleBuildTargetType.TEST));\n    }\n    return result;\n  }","id":91526,"modified_method":"@Override\n  public Collection<BuildTarget<?>> computeDependencies(final BuildTargetRegistry registry, TargetOutputIndex outputIndex) {\n    final List<BuildTarget<?>> result = new ArrayList<BuildTarget<?>>(3);\n\n    fillDependencies(result);\n    result.add(new ModuleBuildTarget(myModule, JavaModuleBuildTargetType.PRODUCTION));\n\n    final JpsAndroidModuleExtension extension = AndroidJpsUtil.getExtension(myModule);\n    if (extension != null && extension.isPackTestCode()) {\n      result.add(new ModuleBuildTarget(myModule, JavaModuleBuildTargetType.TEST));\n    }\n    return result;\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AndroidBuildTarget(@NotNull TargetType targetType, @NotNull JpsModule module) {\n    super(targetType, module);\n    myTargetType = targetType;\n  }","id":91527,"modified_method":"public AndroidBuildTarget(@NotNull AndroidBuildTargetType targetType, @NotNull JpsModule module) {\n    super(targetType, module);\n    myTargetType = targetType;\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public BuildRootDescriptor findRootDescriptor(String rootId, BuildRootIndex rootIndex) {\n    return null;\n  }","id":91528,"modified_method":"@Nullable\n  @Override\n  public BuildRootDescriptor findRootDescriptor(String rootId, BuildRootIndex rootIndex) {\n    for (BuildRootDescriptor descriptor : rootIndex.getTargetRoots(this, null)) {\n      if (descriptor.getRootId().equals(rootId)) {\n        return descriptor;\n      }\n    }\n    return null;\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public List<? extends BuildTargetType<?>> getTargetTypes() {\n    return Arrays.asList(AndroidBuildTarget.TargetType.DEX, AndroidBuildTarget.TargetType.PACKAGING);\n  }","id":91529,"modified_method":"@Override\n  public List<? extends BuildTargetType<?>> getTargetTypes() {\n    return Arrays.<BuildTargetType<?>>asList(\n      AndroidDexBuildTarget.MyTargetType.INSTANCE,\n      AndroidPackagingBuildTarget.MyTargetType.INSTANCE);\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean doDexBuild(@NotNull JpsModule module,\n                                    @NotNull CompileContext context,\n                                    @NotNull AndroidFileSetStorage dexStateStorage,\n                                    @NotNull AndroidFileSetStorage proguardStateStorage) throws IOException {\n    final JpsAndroidModuleExtension extension = AndroidJpsUtil.getExtension(module);\n    assert extension != null;\n    if (extension.isLibrary()) {\n      return true;\n    }\n\n    final AndroidPlatform platform = AndroidJpsUtil.getAndroidPlatform(module, context, BUILDER_NAME);\n    if (platform == null) {\n      return false;\n    }\n\n    final ProjectPaths projectPaths = context.getProjectPaths();\n    File dexOutputDir = AndroidJpsUtil.getDirectoryForIntermediateArtifacts(context, module);\n    dexOutputDir = AndroidJpsUtil.createDirIfNotExist(dexOutputDir, context, BUILDER_NAME);\n    if (dexOutputDir == null) {\n      return false;\n    }\n\n    final File classesDir = projectPaths.getModuleOutputDir(module, false);\n    if (classesDir == null || !classesDir.isDirectory()) {\n      context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.INFO, AndroidJpsBundle\n        .message(\"android.jps.warnings.dex.no.compiled.files\", module.getName())));\n      return true;\n    }\n    final Set<String> externalLibraries = AndroidJpsUtil.getExternalLibraries(context, module, platform);\n    final ProGuardOptions proGuardOptions = AndroidJpsUtil.getProGuardConfigIfShouldRun(context, extension);\n\n    if (proGuardOptions != null) {\n      if (proGuardOptions.getCfgFile() == null) {\n        context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR,\n                                                   AndroidJpsBundle\n                                                     .message(\"android.jps.errors.cannot.find.proguard.cfg\", module.getName())));\n        return false;\n      }\n    }\n    final Set<String> fileSet;\n    final Set<String> jars;\n    final Set<String> outputDirs;\n\n    try {\n      if (proGuardOptions != null) {\n        final File proguardCfgOutputFile = new File(dexOutputDir, AndroidCommonUtils.PROGUARD_CFG_OUTPUT_FILE_NAME);\n        final String[] proguardCfgFilePaths = new String[]{proGuardOptions.getCfgFile().getAbsolutePath(), proguardCfgOutputFile.getPath()};\n        final String outputJarPath =\n          FileUtil.toSystemDependentName(dexOutputDir.getPath() + '/' + AndroidCommonUtils.PROGUARD_OUTPUT_JAR_NAME);\n\n        if (!runProguardIfNecessary(extension, classesDir, platform, externalLibraries, context, outputJarPath,\n                                    proguardCfgFilePaths, proGuardOptions.isIncludeSystemCfgFile(), proguardStateStorage)) {\n          return false;\n        }\n        fileSet = jars = Collections.singleton(outputJarPath);\n        outputDirs = Collections.emptySet();\n      }\n      else {\n        fileSet = new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY);\n        jars = new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY);\n        outputDirs = new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY);\n\n        AndroidJpsUtil.addSubdirectories(classesDir, fileSet);\n        outputDirs.add(FileUtil.toSystemIndependentName(classesDir.getPath()));\n\n        fileSet.addAll(externalLibraries);\n        jars.addAll(externalLibraries);\n\n        AndroidJpsUtil.processClasspath(context, module, new AndroidDependencyProcessor() {\n          @Override\n          public void processExternalLibrary(@NotNull File file) {\n            fileSet.add(file.getPath());\n            jars.add(file.getPath());\n          }\n\n          @Override\n          public void processAndroidLibraryPackage(@NotNull File file) {\n            fileSet.add(file.getPath());\n            jars.add(file.getPath());\n          }\n\n          @Override\n          public void processJavaModuleOutputDirectory(@NotNull File dir) {\n            fileSet.add(dir.getPath());\n            outputDirs.add(FileUtil.toSystemIndependentName(dir.getPath()));\n          }\n\n          @Override\n          public boolean isToProcess(@NotNull AndroidDependencyType type) {\n            return type == AndroidDependencyType.JAVA_MODULE_OUTPUT_DIR ||\n                   type == AndroidDependencyType.ANDROID_LIBRARY_PACKAGE ||\n                   type == AndroidDependencyType.EXTERNAL_LIBRARY;\n          }\n        });\n\n        if (extension.isPackTestCode()) {\n          final File testsClassDir = projectPaths.getModuleOutputDir(module, true);\n\n          if (testsClassDir != null && testsClassDir.isDirectory()) {\n            AndroidJpsUtil.addSubdirectories(testsClassDir, fileSet);\n            outputDirs.add(FileUtil.toSystemIndependentName(testsClassDir.getPath()));\n          }\n        }\n      }\n      final AndroidFileSetState newState = new AndroidFileSetState(jars, AndroidJpsUtil.CLASSES_AND_JARS_FILTER, true);\n\n      if (context.isMake()) {\n        final AndroidFileSetState oldState = dexStateStorage.getState(module.getName());\n        if (oldState != null && oldState.equalsTo(newState)) {\n          final Set<String> dirtyOutputDirs = context.getUserData(DIRTY_OUTPUT_DIRS);\n          assert dirtyOutputDirs != null;\n          boolean outputDirsDirty = false;\n\n          for (String outputDir : outputDirs) {\n            if (dirtyOutputDirs.contains(outputDir)) {\n              outputDirsDirty = true;\n              break;\n            }\n          }\n          if (!outputDirsDirty) {\n            return true;\n          }\n        }\n      }\n\n      if (fileSet.size() == 0) {\n        return true;\n      }\n\n      final String[] files = new String[fileSet.size()];\n      int i = 0;\n      for (String filePath : fileSet) {\n        files[i++] = FileUtil.toSystemDependentName(filePath);\n      }\n\n      context.processMessage(new ProgressMessage(AndroidJpsBundle.message(\"android.jps.progress.dex\", module.getName())));\n\n      if (!runDex(platform, dexOutputDir.getPath(), files, context, module)) {\n        dexStateStorage.update(module.getName(), null);\n        return false;\n      }\n      else {\n        dexStateStorage.update(module.getName(), newState);\n      }\n    }\n    catch (IOException e) {\n      AndroidJpsUtil.reportExceptionError(context, null, e, BUILDER_NAME);\n      return false;\n    }\n    return true;\n  }","id":91530,"modified_method":"private static boolean doDexBuild(@NotNull AndroidDexBuildTarget target,\n                                    @NotNull CompileContext context,\n                                    boolean hasDirtyFiles) throws IOException {\n    final JpsModule module = target.getModule();\n\n    final JpsAndroidModuleExtension extension = AndroidJpsUtil.getExtension(module);\n    assert extension != null;\n    if (extension.isLibrary()) {\n      return true;\n    }\n\n\n    final AndroidPlatform platform = AndroidJpsUtil.getAndroidPlatform(module, context, DEX_BUILDER_NAME);\n    if (platform == null) {\n      return false;\n    }\n\n    File dexOutputDir = AndroidJpsUtil.getDirectoryForIntermediateArtifacts(context, module);\n    dexOutputDir = AndroidJpsUtil.createDirIfNotExist(dexOutputDir, context, DEX_BUILDER_NAME);\n    if (dexOutputDir == null) {\n      return false;\n    }\n\n    final ProGuardOptions proGuardOptions = AndroidJpsUtil.getProGuardConfigIfShouldRun(context, extension);\n\n    if (proGuardOptions != null) {\n      if (proGuardOptions.getCfgFile() == null) {\n        context.processMessage(new CompilerMessage(DEX_BUILDER_NAME, BuildMessage.Kind.ERROR,\n                                                   AndroidJpsBundle\n                                                     .message(\"android.jps.errors.cannot.find.proguard.cfg\", module.getName())));\n        return false;\n      }\n    }\n    final File proguardCfgOutputFile = new File(dexOutputDir, AndroidCommonUtils.PROGUARD_CFG_OUTPUT_FILE_NAME);\n\n    final AndroidProGuardStateStorage proGuardOptionsStorage =\n      context.getProjectDescriptor().dataManager.getStorage(target, AndroidProGuardOptionsStorageProvider.INSTANCE);\n\n    final AndroidProGuardStateStorage.MyState oldProGuardState = proGuardOptionsStorage.read();\n\n    final Set<String> fileSet;\n    AndroidProGuardStateStorage.MyState newProGuardState = null;\n\n    try {\n      if (proGuardOptions != null) {\n        final String[] proguardCfgFilePaths = new String[]{\n          proGuardOptions.getCfgFile().getAbsolutePath(),\n          proguardCfgOutputFile.getPath()};\n        final String outputJarPath =\n          FileUtil.toSystemDependentName(dexOutputDir.getPath() + '/' + AndroidCommonUtils.PROGUARD_OUTPUT_JAR_NAME);\n\n        final Pair<Boolean, AndroidProGuardStateStorage.MyState> pair = runProguardIfNecessary(\n          extension, target, platform, context, outputJarPath, proguardCfgFilePaths,\n          proGuardOptions.isIncludeSystemCfgFile(), hasDirtyFiles, oldProGuardState);\n\n        if (pair == null) {\n          // error reported\n          return false;\n        }\n\n        if (!pair.getFirst()) {\n          // nothing changed\n          return true;\n        }\n        newProGuardState = pair.getSecond();\n        assert newProGuardState != null;\n        fileSet = Collections.singleton(outputJarPath);\n      }\n      else {\n        if (!hasDirtyFiles && oldProGuardState == null) {\n          return true;\n        }\n        final List<BuildRootDescriptor> roots = context.getProjectDescriptor().getBuildRootIndex().getTargetRoots(target, context);\n        fileSet = new HashSet<String>();\n\n        for (BuildRootDescriptor root : roots) {\n          final File rootFile = root.getRootFile();\n\n          if (!rootFile.exists()) {\n            continue;\n          }\n\n          if (root instanceof AndroidDexBuildTarget.MyClassesDirBuildRootDescriptor) {\n            final AndroidDexBuildTarget.ClassesDirType type =\n              ((AndroidDexBuildTarget.MyClassesDirBuildRootDescriptor)root).getClassesDirType();\n\n            if (type == AndroidDexBuildTarget.ClassesDirType.JAVA) {\n              fileSet.add(rootFile.getPath());\n            }\n            else if (type == AndroidDexBuildTarget.ClassesDirType.ANDROID_APP) {\n              AndroidJpsUtil.addSubdirectories(rootFile, fileSet);\n            }\n          }\n          else if (root instanceof AndroidDexBuildTarget.MyJarBuildRootDescriptor) {\n            fileSet.add(rootFile.getPath());\n          }\n        }\n      }\n      final boolean success;\n\n      if (fileSet.size() > 0) {\n        final String[] files = new String[fileSet.size()];\n        int i = 0;\n        for (String filePath : fileSet) {\n          files[i++] = FileUtil.toSystemDependentName(filePath);\n        }\n        context.processMessage(new ProgressMessage(AndroidJpsBundle.message(\"android.jps.progress.dex\", module.getName())));\n\n        success = runDex(platform, dexOutputDir.getPath(), files, context, module);\n      }\n      else {\n        success = true;\n      }\n\n      if (success) {\n        proGuardOptionsStorage.update(newProGuardState);\n      }\n      return success;\n    }\n    catch (IOException e) {\n      AndroidJpsUtil.reportExceptionError(context, null, e, DEX_BUILDER_NAME);\n      return false;\n    }\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean runDex(@NotNull AndroidPlatform platform,\n                                @NotNull String outputDir,\n                                @NotNull String[] compileTargets,\n                                @NotNull CompileContext context,\n                                @NotNull JpsModule module) throws IOException {\n    @SuppressWarnings(\"deprecation\")\n    final String dxJarPath = FileUtil.toSystemDependentName(platform.getTarget().getPath(IAndroidTarget.DX_JAR));\n\n    final File dxJar = new File(dxJarPath);\n    if (!dxJar.isFile()) {\n      context.processMessage(\n        new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR, AndroidJpsBundle.message(\"android.jps.cannot.find.file\", dxJarPath)));\n      return false;\n    }\n    final String outFilePath = outputDir + File.separatorChar + AndroidCommonUtils.CLASSES_FILE_NAME;\n\n    final List<String> programParamList = new ArrayList<String>();\n    programParamList.add(dxJarPath);\n    programParamList.add(outFilePath);\n\n    final JpsAndroidDexCompilerConfiguration configuration =\n      JpsAndroidExtensionService.getInstance().getDexCompilerConfiguration(module.getProject());\n    final List<String> vmOptions;\n\n    if (configuration != null) {\n      vmOptions = new ArrayList<String>();\n      vmOptions.addAll(ParametersListUtil.parse(configuration.getVmOptions()));\n\n      if (!AndroidCommonUtils.hasXmxParam(vmOptions)) {\n        vmOptions.add(\"-Xmx\" + configuration.getMaxHeapSize() + \"M\");\n      }\n      programParamList.addAll(Arrays.asList(\"--optimize\", Boolean.toString(configuration.isOptimize())));\n    }\n    else {\n      vmOptions = Collections.singletonList(\"-Xmx1024M\");\n    }\n    programParamList.addAll(Arrays.asList(compileTargets));\n    programParamList.add(\"--exclude\");\n\n    final List<String> classPath = new ArrayList<String>();\n    classPath.add(ClasspathBootstrap.getResourcePath(AndroidDxRunner.class));\n    classPath.add(ClasspathBootstrap.getResourcePath(FileUtilRt.class));\n\n    final File outFile = new File(outFilePath);\n    if (outFile.exists() && !outFile.delete()) {\n      context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.WARNING,\n                                                 AndroidJpsBundle.message(\"android.jps.cannot.delete.file\", outFilePath)));\n    }\n\n    final JpsSdk<JpsSimpleElement<JpsAndroidSdkProperties>> sdk = platform.getSdk();\n    final String jdkName = sdk.getSdkProperties().getData().getJdkName();\n    final JpsLibrary javaSdk = context.getProjectDescriptor().getModel().getGlobal().getLibraryCollection().findLibrary(jdkName);\n    if (javaSdk == null || !javaSdk.getType().equals(JpsJavaSdkType.INSTANCE)) {\n      context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR,\n                                                 AndroidJpsBundle.message(\"android.jps.errors.java.sdk.not.specified\", jdkName)));\n      return false;\n    }\n\n    final List<String> commandLine = ExternalProcessUtil\n      .buildJavaCommandLine(JpsJavaSdkType.getJavaExecutable((JpsSdk<?>)javaSdk.getProperties()), AndroidDxRunner.class.getName(),\n                            Collections.<String>emptyList(), classPath, vmOptions, programParamList);\n\n    LOG.info(AndroidCommonUtils.command2string(commandLine));\n\n    final Process process = Runtime.getRuntime().exec(ArrayUtil.toStringArray(commandLine));\n\n    final HashMap<AndroidCompilerMessageKind, List<String>> messages = new HashMap<AndroidCompilerMessageKind, List<String>>(3);\n    messages.put(AndroidCompilerMessageKind.ERROR, new ArrayList<String>());\n    messages.put(AndroidCompilerMessageKind.WARNING, new ArrayList<String>());\n    messages.put(AndroidCompilerMessageKind.INFORMATION, new ArrayList<String>());\n\n    AndroidCommonUtils.handleDexCompilationResult(process, outFilePath, messages);\n\n    AndroidJpsUtil.addMessages(context, messages, BUILDER_NAME, module.getName());\n\n    return messages.get(AndroidCompilerMessageKind.ERROR).size() == 0;\n  }","id":91531,"modified_method":"private static boolean runDex(@NotNull AndroidPlatform platform,\n                                @NotNull String outputDir,\n                                @NotNull String[] compileTargets,\n                                @NotNull CompileContext context,\n                                @NotNull JpsModule module) throws IOException {\n    @SuppressWarnings(\"deprecation\")\n    final String dxJarPath = FileUtil.toSystemDependentName(platform.getTarget().getPath(IAndroidTarget.DX_JAR));\n\n    final File dxJar = new File(dxJarPath);\n    if (!dxJar.isFile()) {\n      context.processMessage(\n        new CompilerMessage(DEX_BUILDER_NAME, BuildMessage.Kind.ERROR, AndroidJpsBundle.message(\"android.jps.cannot.find.file\", dxJarPath)));\n      return false;\n    }\n    final String outFilePath = outputDir + File.separatorChar + AndroidCommonUtils.CLASSES_FILE_NAME;\n\n    final List<String> programParamList = new ArrayList<String>();\n    programParamList.add(dxJarPath);\n    programParamList.add(outFilePath);\n\n    final JpsAndroidDexCompilerConfiguration configuration =\n      JpsAndroidExtensionService.getInstance().getDexCompilerConfiguration(module.getProject());\n    final List<String> vmOptions;\n\n    if (configuration != null) {\n      vmOptions = new ArrayList<String>();\n      vmOptions.addAll(ParametersListUtil.parse(configuration.getVmOptions()));\n\n      if (!AndroidCommonUtils.hasXmxParam(vmOptions)) {\n        vmOptions.add(\"-Xmx\" + configuration.getMaxHeapSize() + \"M\");\n      }\n      programParamList.addAll(Arrays.asList(\"--optimize\", Boolean.toString(configuration.isOptimize())));\n    }\n    else {\n      vmOptions = Collections.singletonList(\"-Xmx1024M\");\n    }\n    programParamList.addAll(Arrays.asList(compileTargets));\n    programParamList.add(\"--exclude\");\n\n    final List<String> classPath = new ArrayList<String>();\n    classPath.add(ClasspathBootstrap.getResourcePath(AndroidDxRunner.class));\n    classPath.add(ClasspathBootstrap.getResourcePath(FileUtilRt.class));\n\n    final File outFile = new File(outFilePath);\n    if (outFile.exists() && !outFile.delete()) {\n      context.processMessage(new CompilerMessage(DEX_BUILDER_NAME, BuildMessage.Kind.WARNING,\n                                                 AndroidJpsBundle.message(\"android.jps.cannot.delete.file\", outFilePath)));\n    }\n\n    final JpsSdk<JpsSimpleElement<JpsAndroidSdkProperties>> sdk = platform.getSdk();\n    final String jdkName = sdk.getSdkProperties().getData().getJdkName();\n    final JpsLibrary javaSdk = context.getProjectDescriptor().getModel().getGlobal().getLibraryCollection().findLibrary(jdkName);\n    if (javaSdk == null || !javaSdk.getType().equals(JpsJavaSdkType.INSTANCE)) {\n      context.processMessage(new CompilerMessage(DEX_BUILDER_NAME, BuildMessage.Kind.ERROR,\n                                                 AndroidJpsBundle.message(\"android.jps.errors.java.sdk.not.specified\", jdkName)));\n      return false;\n    }\n\n    final List<String> commandLine = ExternalProcessUtil\n      .buildJavaCommandLine(JpsJavaSdkType.getJavaExecutable((JpsSdk<?>)javaSdk.getProperties()), AndroidDxRunner.class.getName(),\n                            Collections.<String>emptyList(), classPath, vmOptions, programParamList);\n\n    LOG.info(AndroidCommonUtils.command2string(commandLine));\n\n    final Process process = Runtime.getRuntime().exec(ArrayUtil.toStringArray(commandLine));\n\n    final HashMap<AndroidCompilerMessageKind, List<String>> messages = new HashMap<AndroidCompilerMessageKind, List<String>>(3);\n    messages.put(AndroidCompilerMessageKind.ERROR, new ArrayList<String>());\n    messages.put(AndroidCompilerMessageKind.WARNING, new ArrayList<String>());\n    messages.put(AndroidCompilerMessageKind.INFORMATION, new ArrayList<String>());\n\n    AndroidCommonUtils.handleDexCompilationResult(process, outFilePath, messages);\n\n    AndroidJpsUtil.addMessages(context, messages, DEX_BUILDER_NAME, module.getName());\n\n    return messages.get(AndroidCompilerMessageKind.ERROR).size() == 0;\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AndroidDexBuilder() {\n    super(Collections.singletonList(AndroidBuildTarget.TargetType.DEX));\n  }","id":91532,"modified_method":"public AndroidDexBuilder() {\n    super(Collections.singletonList(AndroidDexBuildTarget.MyTargetType.INSTANCE));\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public String getPresentableName() {\n    return BUILDER_NAME;\n  }","id":91533,"modified_method":"@NotNull\n  @Override\n  public String getPresentableName() {\n    return DEX_BUILDER_NAME;\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void build(@NotNull AndroidBuildTarget target,\n                    @NotNull DirtyFilesHolder<BuildRootDescriptor, AndroidBuildTarget> holder,\n                    @NotNull BuildOutputConsumer outputConsumer,\n                    @NotNull CompileContext context) throws ProjectBuildException {\n    if (AndroidJpsUtil.isLightBuild(context)) {\n      return;\n    }\n\n    try {\n      doBuild(target.getModule(), context);\n    }\n    catch (ProjectBuildException e) {\n      throw e;\n    }\n    catch (Exception e) {\n      AndroidJpsUtil.handleException(context, e, BUILDER_NAME);\n    }\n  }","id":91534,"modified_method":"@Override\n  public void build(@NotNull final AndroidDexBuildTarget buildTarget,\n                    @NotNull DirtyFilesHolder<BuildRootDescriptor, AndroidDexBuildTarget> holder,\n                    @NotNull BuildOutputConsumer outputConsumer,\n                    @NotNull CompileContext context) throws ProjectBuildException, IOException {\n    if (AndroidJpsUtil.isLightBuild(context)) {\n      return;\n    }\n    final boolean[] hasDirtyFiles = {false};\n\n    holder.processDirtyFiles(new FileProcessor<BuildRootDescriptor, AndroidDexBuildTarget>() {\n      @Override\n      public boolean apply(AndroidDexBuildTarget target, File file, BuildRootDescriptor root) throws IOException {\n        assert target == buildTarget;\n        hasDirtyFiles[0] = true;\n        return false;\n      }\n    });\n\n    try {\n      if (!doDexBuild(buildTarget, context, hasDirtyFiles[0])) {\n        throw new ProjectBuildException();\n      }\n    }\n    catch (ProjectBuildException e) {\n      throw e;\n    }\n    catch (Exception e) {\n      AndroidJpsUtil.handleException(context, e, DEX_BUILDER_NAME);\n    }\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean runProguardIfNecessary(@NotNull JpsAndroidModuleExtension extension,\n                                                @NotNull File classesDir,\n                                                @NotNull AndroidPlatform platform,\n                                                @NotNull Set<String> externalJars,\n                                                @NotNull CompileContext context,\n                                                @NotNull String outputJarPath,\n                                                @NotNull String[] proguardCfgPaths,\n                                                boolean includeSystemProguardCfg,\n                                                @NotNull AndroidFileSetStorage proguardStateStorage) throws IOException {\n    final JpsModule module = extension.getModule();\n    final File[] proguardCfgFiles = new File[proguardCfgPaths.length];\n\n    for (int i = 0; i < proguardCfgFiles.length; i++) {\n      proguardCfgFiles[i] = new File(proguardCfgPaths[i]);\n\n      if (!proguardCfgFiles[i].exists()) {\n        context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR,\n                                                   AndroidJpsBundle.message(\"android.jps.cannot.find.file\", proguardCfgPaths[i])));\n        return false;\n      }\n    }\n\n    final File mainContentRoot = AndroidJpsUtil.getMainContentRoot(extension);\n    if (mainContentRoot == null) {\n      context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR, AndroidJpsBundle\n        .message(\"android.jps.errors.main.content.root.not.found\", module.getName())));\n      return false;\n    }\n\n    final Set<String> classFilesDirs = new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY);\n    final Set<String> libClassFilesDirs = new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY);\n    final Set<String> outputDirs = new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY);\n\n    AndroidJpsUtil.addSubdirectories(classesDir, classFilesDirs);\n    outputDirs.add(FileUtil.toSystemIndependentName(classesDir.getPath()));\n\n    AndroidJpsUtil.processClasspath(context, module, new AndroidDependencyProcessor() {\n\n      @Override\n      public void processAndroidLibraryOutputDirectory(@NotNull File dir) {\n        AndroidJpsUtil.addSubdirectories(dir, libClassFilesDirs);\n        outputDirs.add(FileUtil.toSystemIndependentName(dir.getPath()));\n      }\n\n      @Override\n      public void processJavaModuleOutputDirectory(@NotNull File dir) {\n        AndroidJpsUtil.addSubdirectories(dir, classFilesDirs);\n        outputDirs.add(FileUtil.toSystemIndependentName(dir.getPath()));\n      }\n\n      @Override\n      public boolean isToProcess(@NotNull AndroidDependencyType type) {\n        return type == AndroidDependencyType.ANDROID_LIBRARY_OUTPUT_DIRECTORY ||\n               type == AndroidDependencyType.JAVA_MODULE_OUTPUT_DIR;\n      }\n    });\n\n    final String logsDirOsPath =\n          FileUtil.toSystemDependentName(mainContentRoot.getPath() + '/' + AndroidCommonUtils.DIRECTORY_FOR_LOGS_NAME);\n    final AndroidFileSetState newState = new AndroidFileSetState(externalJars, AndroidJpsUtil.CLASSES_AND_JARS_FILTER, true);\n\n    if (context.isMake()) {\n      final AndroidFileSetState oldState = proguardStateStorage.getState(module.getName());\n\n      if (!areFilesChanged(proguardCfgFiles, module, context) && newState.equalsTo(oldState)) {\n        final Set<String> dirtyOutputDirs = context.getUserData(DIRTY_OUTPUT_DIRS);\n        assert dirtyOutputDirs != null;\n        boolean outputDirsDirty = false;\n        for (String outputDir : outputDirs) {\n          if (dirtyOutputDirs.contains(outputDir)) {\n            outputDirsDirty = true;\n          }\n        }\n        if (!outputDirsDirty) {\n          return true;\n        }\n      }\n    }\n    final String[] classFilesDirOsPaths = ArrayUtil.toStringArray(classFilesDirs);\n    final String[] libClassFilesDirOsPaths = ArrayUtil.toStringArray(libClassFilesDirs);\n    final String[] externalJarOsPaths = ArrayUtil.toStringArray(externalJars);\n    final String inputJarOsPath = AndroidCommonUtils.buildTempInputJar(classFilesDirOsPaths, libClassFilesDirOsPaths);\n\n    final File logsDir = new File(logsDirOsPath);\n    if (!logsDir.exists()) {\n      if (!logsDir.mkdirs()) {\n        context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR,\n                                                   AndroidJpsBundle.message(\"android.jps.cannot.create.directory\", logsDirOsPath)));\n        return false;\n      }\n    }\n\n    context.processMessage(new ProgressMessage(AndroidJpsBundle.message(\"android.jps.progress.proguard\", module.getName())));\n\n    final Map<AndroidCompilerMessageKind, List<String>> messages =\n      AndroidCommonUtils.launchProguard(platform.getTarget(), platform.getSdkToolsRevision(), platform.getSdk().getHomePath(),\n                                        proguardCfgPaths, includeSystemProguardCfg, inputJarOsPath, externalJarOsPaths,\n                                        outputJarPath, logsDirOsPath);\n    AndroidJpsUtil.addMessages(context, messages, BUILDER_NAME, module.getName());\n    final boolean success = messages.get(AndroidCompilerMessageKind.ERROR).isEmpty();\n\n    proguardStateStorage.update(module.getName(), success ? newState : null);\n\n    if (success) {\n      final Timestamps timestamps = context.getProjectDescriptor().timestamps.getStorage();\n\n      for (File file : proguardCfgFiles) {\n        timestamps.saveStamp(file, new ModuleBuildTarget(module, JavaModuleBuildTargetType.PRODUCTION), file.lastModified());\n      }\n    }\n    return success;\n  }","id":91535,"modified_method":"private static Pair<Boolean, AndroidProGuardStateStorage.MyState>\n  runProguardIfNecessary(@NotNull JpsAndroidModuleExtension extension,\n                         @NotNull AndroidDexBuildTarget target,\n                         @NotNull AndroidPlatform platform,\n                         @NotNull CompileContext context,\n                         @NotNull String outputJarPath,\n                         @NotNull String[] proguardCfgPaths,\n                         boolean includeSystemProguardCfg,\n                         boolean hasDirtyFiles,\n                         @Nullable AndroidProGuardStateStorage.MyState oldState)\n    throws IOException {\n    final JpsModule module = extension.getModule();\n    final File[] proguardCfgFiles = new File[proguardCfgPaths.length];\n\n    for (int i = 0; i < proguardCfgFiles.length; i++) {\n      proguardCfgFiles[i] = new File(proguardCfgPaths[i]);\n\n      if (!proguardCfgFiles[i].exists()) {\n        context.processMessage(new CompilerMessage(PRO_GUARD_BUILDER_NAME, BuildMessage.Kind.ERROR,\n                                                   AndroidJpsBundle.message(\"android.jps.cannot.find.file\", proguardCfgPaths[i])));\n        return null;\n      }\n    }\n\n    final File mainContentRoot = AndroidJpsUtil.getMainContentRoot(extension);\n    if (mainContentRoot == null) {\n      context.processMessage(new CompilerMessage(PRO_GUARD_BUILDER_NAME, BuildMessage.Kind.ERROR, AndroidJpsBundle\n        .message(\"android.jps.errors.main.content.root.not.found\", module.getName())));\n      return null;\n    }\n\n    final String logsDirOsPath =\n          FileUtil.toSystemDependentName(mainContentRoot.getPath() + '/' + AndroidCommonUtils.DIRECTORY_FOR_LOGS_NAME);\n    final AndroidProGuardStateStorage.MyState newState = new AndroidProGuardStateStorage.MyState(\n      proguardCfgFiles, includeSystemProguardCfg);\n\n    if (context.isMake() && !hasDirtyFiles && newState.equals(oldState)) {\n      return Pair.create(false, null);\n    }\n    final List<String> classesDirs = new ArrayList<String>();\n    final List<String> libClassesDirs = new ArrayList<String>();\n    final List<String> externalJars = new ArrayList<String>();\n\n    final List<BuildRootDescriptor> roots = context.getProjectDescriptor().getBuildRootIndex().getTargetRoots(target, context);\n\n    for (BuildRootDescriptor root : roots) {\n      final File rootFile = root.getRootFile();\n\n      if (!rootFile.exists()) {\n        continue;\n      }\n\n      if (root instanceof AndroidDexBuildTarget.MyClassesDirBuildRootDescriptor) {\n        final AndroidDexBuildTarget.ClassesDirType type =\n          ((AndroidDexBuildTarget.MyClassesDirBuildRootDescriptor)root).getClassesDirType();\n\n        if (type == AndroidDexBuildTarget.ClassesDirType.JAVA) {\n          classesDirs.add(rootFile.getPath());\n        }\n        else if (type == AndroidDexBuildTarget.ClassesDirType.ANDROID_APP) {\n          AndroidJpsUtil.addSubdirectories(rootFile, classesDirs);\n        }\n        else {\n          AndroidJpsUtil.addSubdirectories(rootFile, libClassesDirs);\n        }\n      }\n      else if (root instanceof AndroidDexBuildTarget.MyJarBuildRootDescriptor) {\n        if (!((AndroidDexBuildTarget.MyJarBuildRootDescriptor)root).isLibPackage()) {\n          externalJars.add(rootFile.getPath());\n        }\n      }\n    }\n    final String[] classFilesDirOsPaths = ArrayUtil.toStringArray(classesDirs);\n    final String[] libClassFilesDirOsPaths = ArrayUtil.toStringArray(libClassesDirs);\n    final String[] externalJarOsPaths = ArrayUtil.toStringArray(externalJars);\n    final String inputJarOsPath = AndroidCommonUtils.buildTempInputJar(classFilesDirOsPaths, libClassFilesDirOsPaths);\n\n    final File logsDir = new File(logsDirOsPath);\n    if (!logsDir.exists()) {\n      if (!logsDir.mkdirs()) {\n        context.processMessage(new CompilerMessage(PRO_GUARD_BUILDER_NAME, BuildMessage.Kind.ERROR,\n                                                   AndroidJpsBundle.message(\"android.jps.cannot.create.directory\", logsDirOsPath)));\n        return null;\n      }\n    }\n\n    context.processMessage(new ProgressMessage(AndroidJpsBundle.message(\"android.jps.progress.proguard\", module.getName())));\n\n    final Map<AndroidCompilerMessageKind, List<String>> messages =\n      AndroidCommonUtils.launchProguard(platform.getTarget(), platform.getSdkToolsRevision(), platform.getSdk().getHomePath(),\n                                        proguardCfgPaths, includeSystemProguardCfg, inputJarOsPath, externalJarOsPaths,\n                                        outputJarPath, logsDirOsPath);\n    AndroidJpsUtil.addMessages(context, messages, PRO_GUARD_BUILDER_NAME, module.getName());\n    return messages.get(AndroidCompilerMessageKind.ERROR).isEmpty()\n           ? Pair.create(true, newState) : null;\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Collection<? extends BuildTarget<?>> getDependencies(@NotNull JpsAndroidFinalPackageElement element, TargetOutputIndex outputIndex) {\n    final JpsModule module = element.getModuleReference().resolve();\n    return module != null\n           ? Collections.singletonList(new AndroidBuildTarget(AndroidBuildTarget.TargetType.PACKAGING, module))\n           : Collections.<BuildTarget<?>>emptyList();\n  }","id":91536,"modified_method":"@Override\n  public Collection<? extends BuildTarget<?>> getDependencies(@NotNull JpsAndroidFinalPackageElement element, TargetOutputIndex outputIndex) {\n    final JpsModule module = element.getModuleReference().resolve();\n    return module != null\n           ? Collections.singletonList(new AndroidPackagingBuildTarget(module))\n           : Collections.<BuildTarget<?>>emptyList();\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void processClasspath(@NotNull CompileContext context,\n                                       @NotNull final JpsModule module,\n                                       @NotNull final AndroidDependencyProcessor processor,\n                                       @NotNull final Set<String> visitedModules,\n                                       final boolean exportedLibrariesOnly,\n                                       final boolean recursive) {\n    if (!visitedModules.add(module.getName())) {\n      return;\n    }\n    final ProjectPaths paths = context.getProjectPaths();\n\n    if (processor.isToProcess(AndroidDependencyType.EXTERNAL_LIBRARY)) {\n      for (JpsDependencyElement item : JpsJavaExtensionService.getInstance().getDependencies(module, JpsJavaClasspathKind.PRODUCTION_RUNTIME, exportedLibrariesOnly)) {\n        if (item instanceof JpsLibraryDependency) {\n          final JpsLibrary library = ((JpsLibraryDependency)item).getLibrary();\n          if (library != null) {\n            for (JpsLibraryRoot root : library.getRoots(JpsOrderRootType.COMPILED)) {\n              final File file = JpsPathUtil.urlToFile(root.getUrl());\n\n              if (file.exists()) {\n                processClassFilesAndJarsRecursively(file, new Processor<File>() {\n                  @Override\n                  public boolean process(File file) {\n                    processor.processExternalLibrary(file);\n                    return true;\n                  }\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    for (JpsDependencyElement item : JpsJavaExtensionService.getInstance().getDependencies(module, JpsJavaClasspathKind.PRODUCTION_RUNTIME, false)) {\n      if (item instanceof JpsModuleDependency) {\n        final JpsModule depModule = ((JpsModuleDependency)item).getModule();\n        if (depModule == null) continue;\n        final JpsAndroidModuleExtension depExtension = getExtension(depModule);\n        final boolean depLibrary = depExtension != null && depExtension.isLibrary();\n        final File depClassDir = paths.getModuleOutputDir(depModule, false);\n\n        if (depLibrary) {\n          if (processor.isToProcess(AndroidDependencyType.ANDROID_LIBRARY_PACKAGE)) {\n            final File intArtifactsDir = getDirectoryForIntermediateArtifacts(context, depModule);\n            final File packagedClassesJar = new File(intArtifactsDir, AndroidCommonUtils.CLASSES_JAR_FILE_NAME);\n\n            if (packagedClassesJar.isFile()) {\n              processor.processAndroidLibraryPackage(packagedClassesJar);\n            }\n          }\n          if (processor.isToProcess(AndroidDependencyType.ANDROID_LIBRARY_OUTPUT_DIRECTORY)) {\n            if (depClassDir != null && depClassDir.isDirectory()) {\n              processor.processAndroidLibraryOutputDirectory(depClassDir);\n            }\n          }\n        }\n        else if (processor.isToProcess(AndroidDependencyType.JAVA_MODULE_OUTPUT_DIR) &&\n                 depExtension == null &&\n                 depClassDir != null &&\n                 depClassDir.isDirectory()) {\n          // do not support android-app->android-app compile dependencies\n          processor.processJavaModuleOutputDirectory(depClassDir);\n        }\n        if (recursive) {\n          processClasspath(context, depModule, processor, visitedModules, !depLibrary || exportedLibrariesOnly, recursive);\n        }\n      }\n    }\n  }","id":91537,"modified_method":"private static void processClasspath(@NotNull BuildDataPaths paths,\n                                       @NotNull final JpsModule module,\n                                       @NotNull final AndroidDependencyProcessor processor,\n                                       @NotNull final Set<String> visitedModules,\n                                       final boolean exportedLibrariesOnly,\n                                       final boolean recursive) {\n    if (!visitedModules.add(module.getName())) {\n      return;\n    }\n    if (processor.isToProcess(AndroidDependencyType.EXTERNAL_LIBRARY)) {\n      for (JpsDependencyElement item : JpsJavaExtensionService.getInstance().getDependencies(module, JpsJavaClasspathKind.PRODUCTION_RUNTIME, exportedLibrariesOnly)) {\n        if (item instanceof JpsLibraryDependency) {\n          final JpsLibrary library = ((JpsLibraryDependency)item).getLibrary();\n          if (library != null) {\n            for (JpsLibraryRoot root : library.getRoots(JpsOrderRootType.COMPILED)) {\n              final File file = JpsPathUtil.urlToFile(root.getUrl());\n\n              if (file.exists()) {\n                processClassFilesAndJarsRecursively(file, new Processor<File>() {\n                  @Override\n                  public boolean process(File file) {\n                    processor.processExternalLibrary(file);\n                    return true;\n                  }\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    for (JpsDependencyElement item : JpsJavaExtensionService.getInstance().getDependencies(module, JpsJavaClasspathKind.PRODUCTION_RUNTIME, false)) {\n      if (item instanceof JpsModuleDependency) {\n        final JpsModule depModule = ((JpsModuleDependency)item).getModule();\n        if (depModule == null) continue;\n        final JpsAndroidModuleExtension depExtension = getExtension(depModule);\n        final boolean depLibrary = depExtension != null && depExtension.isLibrary();\n        final File depClassDir = new ModuleBuildTarget(depModule, JavaModuleBuildTargetType.PRODUCTION).getOutputDir();\n\n        if (depLibrary) {\n          if (processor.isToProcess(AndroidDependencyType.ANDROID_LIBRARY_PACKAGE)) {\n            final File intArtifactsDir = getDirectoryForIntermediateArtifacts(paths, depModule);\n            final File packagedClassesJar = new File(intArtifactsDir, AndroidCommonUtils.CLASSES_JAR_FILE_NAME);\n            processor.processAndroidLibraryPackage(packagedClassesJar);\n          }\n          if (processor.isToProcess(AndroidDependencyType.ANDROID_LIBRARY_OUTPUT_DIRECTORY)) {\n            if (depClassDir != null) {\n              processor.processAndroidLibraryOutputDirectory(depClassDir);\n            }\n          }\n        }\n        else if (processor.isToProcess(AndroidDependencyType.JAVA_MODULE_OUTPUT_DIR) &&\n                 depExtension == null &&\n                 depClassDir != null) {\n          // do not support android-app->android-app compile dependencies\n          processor.processJavaModuleOutputDirectory(depClassDir);\n        }\n        if (recursive) {\n          processClasspath(paths, depModule, processor, visitedModules, !depLibrary || exportedLibrariesOnly, recursive);\n        }\n      }\n    }\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static IAndroidTarget parseAndroidTarget(@NotNull JpsSdk<JpsSimpleElement<JpsAndroidSdkProperties>> sdk,\n                                                  @NotNull CompileContext context,\n                                                  @NotNull String builderName) {\n    JpsAndroidSdkProperties sdkProperties = sdk.getSdkProperties().getData();\n    final String targetHashString = sdkProperties.getBuildTargetHashString();\n    if (targetHashString == null) {\n      context.processMessage(new CompilerMessage(builderName, BuildMessage.Kind.ERROR,\n                                                 \"Cannot parse SDK \" + sdk.getParent().getName() + \": build target is not specified\"));\n      return null;\n    }\n\n    final MessageBuildingSdkLog log = new MessageBuildingSdkLog();\n    final SdkManager manager = AndroidCommonUtils.createSdkManager(sdk.getHomePath(), log);\n\n    if (manager == null) {\n      final String message = log.getErrorMessage();\n      context.processMessage(new CompilerMessage(builderName, BuildMessage.Kind.ERROR,\n                                                 \"Android SDK is parsed incorrectly.\" +\n                                                 (message.length() > 0 ? \" Parsing log:\\n\" + message : \"\")));\n      return null;\n    }\n\n    final IAndroidTarget target = manager.getTargetFromHashString(targetHashString);\n    if (target == null) {\n      context.processMessage(new CompilerMessage(builderName, BuildMessage.Kind.ERROR,\n                                                 \"Cannot parse SDK '\" + sdk.getParent().getName() + \"': unknown target \" + targetHashString));\n      return null;\n    }\n    return target;\n  }","id":91538,"modified_method":"@Nullable\n  public static IAndroidTarget parseAndroidTarget(@NotNull JpsSdk<JpsSimpleElement<JpsAndroidSdkProperties>> sdk,\n                                                  @Nullable CompileContext context,\n                                                  String builderName) {\n    JpsAndroidSdkProperties sdkProperties = sdk.getSdkProperties().getData();\n    final String targetHashString = sdkProperties.getBuildTargetHashString();\n    if (targetHashString == null) {\n      if (context != null) {\n        context.processMessage(new CompilerMessage(builderName, BuildMessage.Kind.ERROR,\n                                                   \"Cannot parse SDK \" + sdk.getParent().getName() + \": build target is not specified\"));\n      }\n      return null;\n    }\n\n    final MessageBuildingSdkLog log = new MessageBuildingSdkLog();\n    final SdkManager manager = AndroidCommonUtils.createSdkManager(sdk.getHomePath(), log);\n\n    if (manager == null) {\n      final String message = log.getErrorMessage();\n      if (context != null) {\n        context.processMessage(new CompilerMessage(builderName, BuildMessage.Kind.ERROR,\n                                                   \"Android SDK is parsed incorrectly.\" +\n                                                   (message.length() > 0 ? \" Parsing log:\\n\" + message : \"\")));\n      }\n      return null;\n    }\n\n    final IAndroidTarget target = manager.getTargetFromHashString(targetHashString);\n    if (target == null) {\n      if (context != null) {\n        context.processMessage(new CompilerMessage(builderName, BuildMessage.Kind.ERROR,\n                                                   \"Cannot parse SDK '\" + sdk.getParent().getName() +\n                                                   \"': unknown target \" + targetHashString));\n      }\n      return null;\n    }\n    return target;\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static File getDirectoryForIntermediateArtifacts(@NotNull CompileContext context,\n                                                          @NotNull JpsModule module) {\n    final File androidStorage = new File(context.getProjectDescriptor().dataManager.getDataPaths().getDataStorageRoot(), ANDROID_STORAGE_DIR);\n    return new File(new File(androidStorage, INTERMEDIATE_ARTIFACTS_STORAGE), module.getName());\n  }","id":91539,"modified_method":"@NotNull\n  public static File getDirectoryForIntermediateArtifacts(@NotNull CompileContext context,\n                                                          @NotNull JpsModule module) {\n    return getDirectoryForIntermediateArtifacts(context.getProjectDescriptor().dataManager.getDataPaths(), module);\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static Set<String> getExternalLibraries(@NotNull CompileContext context,\n                                                 @NotNull JpsModule module,\n                                                 @NotNull AndroidPlatform platform) {\n    final Set<String> result = new HashSet<String>();\n    final AndroidDependencyProcessor processor = new AndroidDependencyProcessor() {\n      @Override\n      public void processExternalLibrary(@NotNull File file) {\n        result.add(file.getPath());\n      }\n\n      @Override\n      public boolean isToProcess(@NotNull AndroidDependencyType type) {\n        return type == AndroidDependencyType.EXTERNAL_LIBRARY;\n      }\n    };\n    processClasspath(context, module, processor);\n    addAnnotationsJarIfNecessary(platform, result);\n    return result;\n  }","id":91540,"modified_method":"@NotNull\n  public static Set<String> getExternalLibraries(@NotNull CompileContext context,\n                                                 @NotNull JpsModule module,\n                                                 @NotNull AndroidPlatform platform) {\n    final BuildDataPaths paths = context.getProjectDescriptor().dataManager.getDataPaths();\n    return getExternalLibraries(paths, module, platform);\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static AndroidPlatform getAndroidPlatform(@NotNull JpsModule module,\n                                                   @NotNull CompileContext context,\n                                                   @NotNull String builderName) {\n    final JpsSdk<JpsSimpleElement<JpsAndroidSdkProperties>> sdk = module.getSdk(JpsAndroidSdkType.INSTANCE);\n    if (sdk == null) {\n      context.processMessage(new CompilerMessage(builderName, BuildMessage.Kind.ERROR,\n                                                 AndroidJpsBundle.message(\"android.jps.errors.sdk.not.specified\", module.getName())));\n      return null;\n    }\n\n    final IAndroidTarget target = parseAndroidTarget(sdk, context, builderName);\n    if (target == null) {\n      context.processMessage(new CompilerMessage(builderName, BuildMessage.Kind.ERROR,\n                                                 AndroidJpsBundle.message(\"android.jps.errors.sdk.invalid\", module.getName())));\n      return null;\n    }\n    return new AndroidPlatform(sdk, target);\n  }","id":91541,"modified_method":"@Nullable\n  public static AndroidPlatform getAndroidPlatform(@NotNull JpsModule module,\n                                                   @Nullable CompileContext context,\n                                                   String builderName) {\n    final JpsSdk<JpsSimpleElement<JpsAndroidSdkProperties>> sdk = module.getSdk(JpsAndroidSdkType.INSTANCE);\n    if (sdk == null) {\n      if (context != null) {\n        context.processMessage(new CompilerMessage(builderName, BuildMessage.Kind.ERROR,\n                                                   AndroidJpsBundle.message(\"android.jps.errors.sdk.not.specified\", module.getName())));\n      }\n      return null;\n    }\n\n    final IAndroidTarget target = parseAndroidTarget(sdk, context, builderName);\n    if (target == null) {\n      if (context != null) {\n        context.processMessage(new CompilerMessage(builderName, BuildMessage.Kind.ERROR,\n                                                   AndroidJpsBundle.message(\"android.jps.errors.sdk.invalid\", module.getName())));\n      }\n      return null;\n    }\n    return new AndroidPlatform(sdk, target);\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void processClasspath(@NotNull CompileContext context,\n                                      @NotNull JpsModule module,\n                                      @NotNull AndroidDependencyProcessor processor) {\n    // In a module imported from Maven dependencies are transitive, so we don't need to traverse all dependency tree\n    // and compute all jars referred by library modules. Moreover it would be incorrect,\n    // because Maven has dependency resolving algorithm based on versioning\n    final boolean recursive = shouldProcessDependenciesRecursively(module);\n    processClasspath(context, module, processor, new HashSet<String>(), false, recursive);\n  }","id":91542,"modified_method":"public static void processClasspath(@NotNull CompileContext context,\n                                      @NotNull JpsModule module,\n                                      @NotNull AndroidDependencyProcessor processor) {\n    final BuildDataPaths paths = context.getProjectDescriptor().dataManager.getDataPaths();\n    processClasspath(paths, module, processor);\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void build(@NotNull AndroidBuildTarget target,\n                    @NotNull DirtyFilesHolder<BuildRootDescriptor, AndroidBuildTarget> holder,\n                    @NotNull BuildOutputConsumer outputConsumer,\n                    @NotNull CompileContext context) throws ProjectBuildException {\n    if (AndroidJpsUtil.isLightBuild(context)) {\n      return;\n    }\n    final JpsModule module = target.getModule();\n\n    // todo: simplify\n    final Collection<JpsModule> modules = Collections.singletonList(module);\n\n    final Map<JpsModule, AndroidFileSetState> resourcesStates = new HashMap<JpsModule, AndroidFileSetState>();\n    final Map<JpsModule, AndroidFileSetState> assetsStates = new HashMap<JpsModule, AndroidFileSetState>();\n    final Map<JpsModule, File> manifestFiles = new HashMap<JpsModule, File>();\n\n    try {\n      fillStates(modules, resourcesStates, assetsStates, manifestFiles);\n\n      if (!doCaching(context, modules, resourcesStates)) {\n        throw new ProjectBuildException();\n      }\n\n      if (!doResourcePackaging(context, modules, resourcesStates, assetsStates, manifestFiles)) {\n        throw new ProjectBuildException();\n      }\n\n      if (!doPackaging(context, modules)) {\n        throw new ProjectBuildException();\n      }\n    }\n    catch (ProjectBuildException e) {\n      throw e;\n    }\n    catch (Exception e) {\n      AndroidJpsUtil.handleException(context, e, BUILDER_NAME);\n    }\n  }","id":91543,"modified_method":"@Override\n  public void build(@NotNull AndroidPackagingBuildTarget target,\n                    @NotNull DirtyFilesHolder<BuildRootDescriptor, AndroidPackagingBuildTarget> holder,\n                    @NotNull BuildOutputConsumer outputConsumer,\n                    @NotNull CompileContext context) throws ProjectBuildException {\n    if (AndroidJpsUtil.isLightBuild(context)) {\n      return;\n    }\n    final JpsModule module = target.getModule();\n\n    // todo: simplify\n    final Collection<JpsModule> modules = Collections.singletonList(module);\n\n    final Map<JpsModule, AndroidFileSetState> resourcesStates = new HashMap<JpsModule, AndroidFileSetState>();\n    final Map<JpsModule, AndroidFileSetState> assetsStates = new HashMap<JpsModule, AndroidFileSetState>();\n    final Map<JpsModule, File> manifestFiles = new HashMap<JpsModule, File>();\n\n    try {\n      fillStates(modules, resourcesStates, assetsStates, manifestFiles);\n\n      if (!doCaching(context, modules, resourcesStates)) {\n        throw new ProjectBuildException();\n      }\n\n      if (!doResourcePackaging(context, modules, resourcesStates, assetsStates, manifestFiles)) {\n        throw new ProjectBuildException();\n      }\n\n      if (!doPackaging(context, modules)) {\n        throw new ProjectBuildException();\n      }\n    }\n    catch (ProjectBuildException e) {\n      throw e;\n    }\n    catch (Exception e) {\n      AndroidJpsUtil.handleException(context, e, BUILDER_NAME);\n    }\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AndroidPackagingBuilder() {\n    super(Collections.singletonList(AndroidBuildTarget.TargetType.PACKAGING));\n  }","id":91544,"modified_method":"public AndroidPackagingBuilder() {\n    super(Collections.singletonList(AndroidPackagingBuildTarget.MyTargetType.INSTANCE));\n  }","commit_id":"1c3e5923d8d72f02f3a714d96aa238652a3e5ac5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n    // Suspend incoming traffic until connected to the outbound service.\n    final Channel inboundChannel = e.getChannel();\n    inboundChannel.setReadable(false);\n\n    // Discover endpoint.\n    Discoverable discoverable = discoverableEndpoints.pick();\n    if (discoverable == null) {\n      LOG.error(\"No discoverable endpoints found for service {}\", serviceName);\n      inboundChannel.close();\n      return;\n    }\n\n    // Connect to outbound service.\n    final InetSocketAddress address = discoverable.getSocketAddress();\n    LOG.trace(\"Opening connection from {} to {} for {}\",\n              inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress());\n    ChannelFuture outFuture = clientBootstrap.connect(address);\n\n    outboundChannel = outFuture.getChannel();\n    outFuture.addListener(new ChannelFutureListener() {\n      public void operationComplete(ChannelFuture future) throws Exception {\n        if (future.isSuccess()) {\n          outboundChannel.getPipeline().addLast(\"outbound-handler\", new OutboundHandler(inboundChannel));\n\n          // Connection attempt succeeded:\n          // Begin to accept incoming traffic.\n          inboundChannel.setReadable(true);\n          LOG.trace(\"Connection opened from {} to {} for {}\",\n                    inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress());\n        } else {\n          // Close the connection if the connection attempt has failed.\n          inboundChannel.close();\n          LOG.trace(\"Failed to open connection from {} to {} for {}\",\n                    inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress(), future.getCause());\n        }\n      }\n    });\n  }","id":91545,"modified_method":"@Override\n  public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n    // Suspend incoming traffic until connected to the outbound service.\n    final Channel inboundChannel = e.getChannel();\n    inboundChannel.setReadable(false);\n\n    // Discover endpoint.\n    int inboundPort = ((InetSocketAddress) inboundChannel.getLocalAddress()).getPort();\n    DiscoverableService discoverableService = discoverablesMap.get(inboundPort);\n    if (discoverableService == null) {\n      LOG.error(\"Cannot find forward rule for port {}\", inboundPort);\n      inboundChannel.close();\n      return;\n    }\n\n    Discoverable discoverable = discoverableService.getEndpointStrategy().pick();\n    if (discoverable == null) {\n      LOG.error(\"No discoverable endpoints found for service {}\", discoverableService.getServiceName());\n      inboundChannel.close();\n      return;\n    }\n\n    // Connect to outbound service.\n    final InetSocketAddress address = discoverable.getSocketAddress();\n    LOG.trace(\"Opening connection from {} to {} for {}\",\n              inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress());\n    ChannelFuture outFuture = clientBootstrap.connect(address);\n\n    outboundChannel = outFuture.getChannel();\n    outFuture.addListener(new ChannelFutureListener() {\n      public void operationComplete(ChannelFuture future) throws Exception {\n        if (future.isSuccess()) {\n          outboundChannel.getPipeline().addLast(\"outbound-handler\", new OutboundHandler(inboundChannel));\n\n          // Connection attempt succeeded:\n          // Begin to accept incoming traffic.\n          inboundChannel.setReadable(true);\n          LOG.trace(\"Connection opened from {} to {} for {}\",\n                    inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress());\n        } else {\n          // Close the connection if the connection attempt has failed.\n          inboundChannel.close();\n          LOG.trace(\"Failed to open connection from {} to {} for {}\",\n                    inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress(), future.getCause());\n        }\n      }\n    });\n  }","commit_id":"30eea409c8cdc6973550858cc6743bfc7644d078","url":"https://github.com/caskdata/cdap"},{"original_method":"public InboundHandler(ClientBootstrap clientBootstrap, EndpointStrategy discoverableEndpoints,\n                        String serviceName) {\n    this.clientBootstrap = clientBootstrap;\n    this.discoverableEndpoints = discoverableEndpoints;\n    this.serviceName = serviceName;\n  }","id":91546,"modified_method":"public InboundHandler(ClientBootstrap clientBootstrap, Map<Integer, DiscoverableService> discoverablesMap) {\n    this.clientBootstrap = clientBootstrap;\n    this.discoverablesMap = discoverablesMap;\n  }","commit_id":"30eea409c8cdc6973550858cc6743bfc7644d078","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void shutDown() throws Exception {\n    LOG.info(\"Stopping Netty Router for service {} on address {}...\", destinationServiceName, boundAddress);\n\n    try {\n      if (!channelGroup.close().await(CLOSE_CHANNEL_TIMEOUT_SECS, TimeUnit.SECONDS)) {\n        LOG.warn(\"Timeout when closing all channels.\");\n      }\n    } finally {\n      serverBootstrap.shutdown();\n      clientBootstrap.shutdown();\n      clientBootstrap.releaseExternalResources();\n      serverBootstrap.releaseExternalResources();\n    }\n\n    LOG.info(\"Stopped Netty Router for service {} on address {}.\", destinationServiceName, boundAddress);\n  }","id":91547,"modified_method":"@Override\n  protected void shutDown() throws Exception {\n    LOG.info(\"Stopping Netty Router...\");\n\n    try {\n      if (!channelGroup.close().await(CLOSE_CHANNEL_TIMEOUT_SECS, TimeUnit.SECONDS)) {\n        LOG.warn(\"Timeout when closing all channels.\");\n      }\n    } finally {\n      serverBootstrap.shutdown();\n      clientBootstrap.shutdown();\n      clientBootstrap.releaseExternalResources();\n      serverBootstrap.releaseExternalResources();\n    }\n\n    LOG.info(\"Stopped Netty Router.\");\n  }","commit_id":"30eea409c8cdc6973550858cc6743bfc7644d078","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void startUp() throws Exception {\n    InetAddress address = hostname;\n    if (address.isAnyLocalAddress()) {\n      try {\n        address = InetAddress.getLocalHost();\n      } catch (UnknownHostException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    InetSocketAddress bindAddress = new InetSocketAddress(address.getCanonicalHostName(), port);\n    LOG.info(\"Starting Netty Router for service {} on address {}...\", destinationServiceName, bindAddress);\n\n    ExecutorService serverBossExecutor = createExecutorService(serverBossThreadPoolSize,\n                                                               \"router-server-boss-thread-%d\");\n    ExecutorService serverWorkerExecutor = createExecutorService(serverWorkerThreadPoolSize,\n                                                                 \"router-server-worker-thread-%d\");\n    ExecutorService clientBossExecutor = createExecutorService(clientBossThreadPoolSize,\n                                                               \"router-client-boss-thread-%d\");\n    ExecutorService clientWorkerExecutor = createExecutorService(clientWorkerThreadPoolSize,\n                                                                 \"router-client-worker-thread-%d\");\n\n    final EndpointStrategy discoverableEndpoints = new RandomEndpointStrategy(\n      discoveryServiceClient.discover(destinationServiceName));\n\n    serverBootstrap = new ServerBootstrap(\n      new NioServerSocketChannelFactory(serverBossExecutor, serverWorkerExecutor));\n    serverBootstrap.setOption(\"backlog\", serverConnectionBacklog);\n\n    clientBootstrap = new ClientBootstrap(\n      new NioClientSocketChannelFactory(\n        new NioClientBossPool(clientBossExecutor, clientBossThreadPoolSize),\n        new ShareableWorkerPool<NioWorker>(new NioWorkerPool(clientWorkerExecutor, clientWorkerThreadPoolSize))));\n\n    final ChannelUpstreamHandler connectionTracker =  new SimpleChannelUpstreamHandler() {\n      @Override\n      public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e)\n        throws Exception {\n        channelGroup.add(e.getChannel());\n        super.handleUpstream(ctx, e);\n      }\n    };\n\n    serverBootstrap.setPipelineFactory(\n      new ChannelPipelineFactory() {\n        @Override\n        public ChannelPipeline getPipeline() throws Exception {\n          ChannelPipeline pipeline = Channels.pipeline();\n          pipeline.addLast(\"tracker\", connectionTracker);\n          pipeline.addLast(\"inbound-handler\",\n                           new InboundHandler(clientBootstrap, discoverableEndpoints, destinationServiceName));\n          return pipeline;\n        }\n      }\n    );\n\n    serverBootstrap.setOption(\"bufferFactory\", new DirectChannelBufferFactory());\n\n    clientBootstrap.setPipelineFactory(\n      new ChannelPipelineFactory() {\n        @Override\n        public ChannelPipeline getPipeline() throws Exception {\n          ChannelPipeline pipeline = Channels.pipeline();\n          pipeline.addLast(\"tracker\", connectionTracker);\n          return pipeline;\n        }\n      }\n    );\n\n    clientBootstrap.setOption(\"bufferFactory\", new DirectChannelBufferFactory());\n\n    Channel channel = serverBootstrap.bind(bindAddress);\n    channelGroup.add(channel);\n\n    boundAddress = (InetSocketAddress) channel.getLocalAddress();\n    LOG.info(\"Started Netty Router for service {} on address {}.\", destinationServiceName, boundAddress);\n  }","id":91548,"modified_method":"@Override\n  protected void startUp() throws Exception {\n    InetAddress address = hostname;\n    if (address.isAnyLocalAddress()) {\n      try {\n        address = InetAddress.getLocalHost();\n      } catch (UnknownHostException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    ExecutorService serverBossExecutor = createExecutorService(serverBossThreadPoolSize,\n                                                               \"router-server-boss-thread-%d\");\n    ExecutorService serverWorkerExecutor = createExecutorService(serverWorkerThreadPoolSize,\n                                                                 \"router-server-worker-thread-%d\");\n    ExecutorService clientBossExecutor = createExecutorService(clientBossThreadPoolSize,\n                                                               \"router-client-boss-thread-%d\");\n    ExecutorService clientWorkerExecutor = createExecutorService(clientWorkerThreadPoolSize,\n                                                                 \"router-client-worker-thread-%d\");\n\n    serverBootstrap = new ServerBootstrap(\n      new NioServerSocketChannelFactory(serverBossExecutor, serverWorkerExecutor));\n    serverBootstrap.setOption(\"backlog\", serverConnectionBacklog);\n\n    clientBootstrap = new ClientBootstrap(\n      new NioClientSocketChannelFactory(\n        new NioClientBossPool(clientBossExecutor, clientBossThreadPoolSize),\n        new ShareableWorkerPool<NioWorker>(new NioWorkerPool(clientWorkerExecutor, clientWorkerThreadPoolSize))));\n\n    final ChannelUpstreamHandler connectionTracker =  new SimpleChannelUpstreamHandler() {\n      @Override\n      public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e)\n        throws Exception {\n        channelGroup.add(e.getChannel());\n        super.handleUpstream(ctx, e);\n      }\n    };\n\n    final Map<Integer, DiscoverableService> discoverablesMap = Maps.newConcurrentMap();\n    serverBootstrap.setPipelineFactory(\n      new ChannelPipelineFactory() {\n        @Override\n        public ChannelPipeline getPipeline() throws Exception {\n          ChannelPipeline pipeline = Channels.pipeline();\n          pipeline.addLast(\"tracker\", connectionTracker);\n          pipeline.addLast(\"inbound-handler\",\n                           new InboundHandler(clientBootstrap, discoverablesMap));\n          return pipeline;\n        }\n      }\n    );\n\n    serverBootstrap.setOption(\"bufferFactory\", new DirectChannelBufferFactory());\n\n    clientBootstrap.setPipelineFactory(\n      new ChannelPipelineFactory() {\n        @Override\n        public ChannelPipeline getPipeline() throws Exception {\n          ChannelPipeline pipeline = Channels.pipeline();\n          pipeline.addLast(\"tracker\", connectionTracker);\n          return pipeline;\n        }\n      }\n    );\n\n    clientBootstrap.setOption(\"bufferFactory\", new DirectChannelBufferFactory());\n\n    ImmutableMap.Builder<Integer, String> serviceMapBuilder = ImmutableMap.builder();\n    for (String forward : forwards) {\n      int ind = forward.indexOf(':');\n      int port = Integer.parseInt(forward.substring(0, ind));\n      String service = forward.substring(ind + 1);\n\n      InetSocketAddress bindAddress = new InetSocketAddress(address.getCanonicalHostName(), port);\n      LOG.info(\"Starting Netty Router for service {} on address {}...\", service, bindAddress);\n      Channel channel = serverBootstrap.bind(bindAddress);\n      InetSocketAddress boundAddress = (InetSocketAddress) channel.getLocalAddress();\n      discoverablesMap.put(boundAddress.getPort(),\n                           new DiscoverableService(service,\n                                                   new RandomEndpointStrategy(\n                                                     discoveryServiceClient.discover(service))));\n      channelGroup.add(channel);\n\n      serviceMapBuilder.put(boundAddress.getPort(), service);\n      LOG.info(\"Started Netty Router for service {} on address {}.\", service, boundAddress);\n    }\n    boundServiceMap = serviceMapBuilder.build();\n  }","commit_id":"30eea409c8cdc6973550858cc6743bfc7644d078","url":"https://github.com/caskdata/cdap"},{"original_method":"private void testSync() throws Exception {\n    for (int i = 0; i < 25; ++i) {\n      LOG.trace(\"Sending request \" + i);\n      DefaultHttpClient client = new DefaultHttpClient();\n      HttpGet get = new HttpGet(String.format(\"http://%s:%d%s/%s-%d\",\n                                              hostname, router.getPort(), \"/v1/ping\", \"sync\", i));\n      HttpResponse response = client.execute(get);\n      Assert.assertEquals(HttpResponseStatus.OK.getCode(), response.getStatusLine().getStatusCode());\n    }\n  }","id":91549,"modified_method":"private void testSync() throws Exception {\n    for (int i = 0; i < 25; ++i) {\n      LOG.trace(\"Sending request \" + i);\n      HttpResponse response = get(String.format(\"http://%s:%d%s/%s-%d\",\n                                                hostname, router.getServiceMap().get(service1), \"/v1/ping\", \"sync\", i));\n      Assert.assertEquals(HttpResponseStatus.OK.getCode(), response.getStatusLine().getStatusCode());\n    }\n  }","commit_id":"30eea409c8cdc6973550858cc6743bfc7644d078","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    protected void before() throws Throwable {\n      CConfiguration cConf = CConfiguration.create();\n      cConf.set(Constants.Router.DEST_SERVICE_NAME, serviceName);\n      cConf.set(Constants.Router.ADDRESS, hostname);\n      cConf.setInt(Constants.Router.PORT, 0);\n      router = new NettyRouter(cConf, InetAddresses.forString(hostname),\n                               (DiscoveryServiceClient) discoveryService);\n      router.startAndWait();\n    }","id":91550,"modified_method":"@Override\n    protected void before() throws Throwable {\n      CConfiguration cConf = CConfiguration.create();\n      cConf.set(Constants.Router.ADDRESS, hostname);\n      cConf.setStrings(Constants.Router.FORWARD, forwards.toArray(new String[forwards.size()]));\n      router = new NettyRouter(cConf, InetAddresses.forString(hostname),\n                               (DiscoveryServiceClient) discoveryService);\n      router.startAndWait();\n\n      for (Map.Entry<Integer, String> entry : router.getBoundServiceMap().entrySet()) {\n        serviceMap.put(entry.getValue(), entry.getKey());\n      }\n    }","commit_id":"30eea409c8cdc6973550858cc6743bfc7644d078","url":"https://github.com/caskdata/cdap"},{"original_method":"private RouterResource(String hostname, DiscoveryService discoveryService, String serviceName) {\n      this.hostname = hostname;\n      this.discoveryService = discoveryService;\n      this.serviceName = serviceName;\n    }","id":91551,"modified_method":"private RouterResource(String hostname, DiscoveryService discoveryService, Set<String> forwards) {\n      this.hostname = hostname;\n      this.discoveryService = discoveryService;\n      this.forwards = forwards;\n    }","commit_id":"30eea409c8cdc6973550858cc6743bfc7644d078","url":"https://github.com/caskdata/cdap"},{"original_method":"@Before\n  public void clearNumRequests() throws Exception {\n    server1.clearNumRequests();\n    server2.clearNumRequests();\n\n    // Wait for both servers to be registered\n    Iterable<Discoverable> discoverables = ((DiscoveryServiceClient) discoveryService).discover(serviceName);\n    for (int i = 0; i < 50 && Iterables.size(discoverables) != 2; ++i) {\n      TimeUnit.MILLISECONDS.sleep(50);\n    }\n  }","id":91552,"modified_method":"@Before\n  public void clearNumRequests() throws Exception {\n    server1.clearNumRequests();\n    server2.clearNumRequests();\n    server3.clearNumRequests();\n\n    // Wait for both servers of service1 to be registered\n    Iterable<Discoverable> discoverables = ((DiscoveryServiceClient) discoveryService).discover(service1);\n    for (int i = 0; i < 50 && Iterables.size(discoverables) != 2; ++i) {\n      TimeUnit.MILLISECONDS.sleep(50);\n    }\n\n    // Wait for server of service2 to be registered\n    discoverables = ((DiscoveryServiceClient) discoveryService).discover(service2);\n    for (int i = 0; i < 50 && Iterables.size(discoverables) != 1; ++i) {\n      TimeUnit.MILLISECONDS.sleep(50);\n    }\n  }","commit_id":"30eea409c8cdc6973550858cc6743bfc7644d078","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testRouterAsync() throws Exception {\n    int NUM_ELEMENTS = 123;\n    AsyncHttpClientConfig.Builder configBuilder = new AsyncHttpClientConfig.Builder();\n\n    final AsyncHttpClient asyncHttpClient = new AsyncHttpClient(\n      new NettyAsyncHttpProvider(configBuilder.build()),\n      configBuilder.build());\n\n    final CountDownLatch latch = new CountDownLatch(NUM_ELEMENTS);\n    final AtomicInteger numSuccessfulRequests = new AtomicInteger(0);\n    for (int i = 0; i < NUM_ELEMENTS; ++i) {\n      final int elem = i;\n      final Request request = new RequestBuilder(\"GET\")\n        .setUrl(String.format(\"http://%s:%d%s/%s-%d\",\n                              hostname, router.getPort(), \"/v1/ping\", \"async\", i))\n        .build();\n      asyncHttpClient.executeRequest(request,\n                                     new AsyncCompletionHandler<Void>() {\n                                       @Override\n                                       public Void onCompleted(Response response) throws Exception {\n                                         latch.countDown();\n                                         Assert.assertEquals(HttpResponseStatus.OK.getCode(),\n                                                             response.getStatusCode());\n                                         numSuccessfulRequests.incrementAndGet();\n                                         return null;\n                                       }\n\n                                       @Override\n                                       public void onThrowable(Throwable t) {\n                                         LOG.error(\"Got exception while posting {}\", elem, t);\n                                         latch.countDown();\n                                       }\n                                     });\n\n      // Sleep so as not to overrun the server.\n      TimeUnit.MILLISECONDS.sleep(1);\n    }\n    latch.await();\n    asyncHttpClient.close();\n\n    Assert.assertEquals(NUM_ELEMENTS, numSuccessfulRequests.get());\n    Assert.assertTrue(server1.getNumRequests() > 0);\n    Assert.assertTrue(server2.getNumRequests() > 0);\n  }","id":91553,"modified_method":"@Test\n  public void testRouterAsync() throws Exception {\n    int NUM_ELEMENTS = 123;\n    AsyncHttpClientConfig.Builder configBuilder = new AsyncHttpClientConfig.Builder();\n\n    final AsyncHttpClient asyncHttpClient = new AsyncHttpClient(\n      new NettyAsyncHttpProvider(configBuilder.build()),\n      configBuilder.build());\n\n    final CountDownLatch latch = new CountDownLatch(NUM_ELEMENTS);\n    final AtomicInteger numSuccessfulRequests = new AtomicInteger(0);\n    for (int i = 0; i < NUM_ELEMENTS; ++i) {\n      final int elem = i;\n      final Request request = new RequestBuilder(\"GET\")\n        .setUrl(String.format(\"http://%s:%d%s/%s-%d\",\n                              hostname, router.getServiceMap().get(service1), \"/v1/ping\", \"async\", i))\n        .build();\n      asyncHttpClient.executeRequest(request,\n                                     new AsyncCompletionHandler<Void>() {\n                                       @Override\n                                       public Void onCompleted(Response response) throws Exception {\n                                         latch.countDown();\n                                         Assert.assertEquals(HttpResponseStatus.OK.getCode(),\n                                                             response.getStatusCode());\n                                         numSuccessfulRequests.incrementAndGet();\n                                         return null;\n                                       }\n\n                                       @Override\n                                       public void onThrowable(Throwable t) {\n                                         LOG.error(\"Got exception while posting {}\", elem, t);\n                                         latch.countDown();\n                                       }\n                                     });\n\n      // Sleep so as not to overrun the server.\n      TimeUnit.MILLISECONDS.sleep(1);\n    }\n    latch.await();\n    asyncHttpClient.close();\n\n    Assert.assertEquals(NUM_ELEMENTS, numSuccessfulRequests.get());\n    Assert.assertTrue(server1.getNumRequests() > 0);\n    Assert.assertTrue(server2.getNumRequests() > 0);\n  }","commit_id":"30eea409c8cdc6973550858cc6743bfc7644d078","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public LiveInfo getLiveInfo(Id.Program program, Type type) {\n    String twillAppName = String.format(\"%s.%s.%s.%s\", type.name().toLowerCase(),\n                                      program.getAccountId(), program.getApplicationId(), program.getId());\n    Iterator<TwillController> controllers = twillRunner.lookup(twillAppName).iterator();\n    JsonObject json = new JsonObject();\n    // this will return an empty Json if there is no live instance\n    if (controllers.hasNext()) {\n      TwillController controller = controllers.next();\n      if (controllers.hasNext()) {\n        LOG.warn(\"Expected at most one live instance of Twill app {} but found at least two.\", twillAppName);\n      }\n      ResourceReport report = controller.getResourceReport();\n      if (report != null) {\n        DistributedLiveInfo liveInfo = new DistributedLiveInfo(program, type, report.getApplicationId());\n        Containers.ContainerType containerType = Type.FLOW.equals(type) ? FLOWLET :\n                                                 Type.PROCEDURE.equals(type) ? PROCEDURE : SERVICE;\n        for (Map.Entry<String, Collection<TwillRunResources>> entry : report.getResources().entrySet()) {\n          for (TwillRunResources resources : entry.getValue()) {\n            liveInfo.addContainer(new ContainerInfo(containerType,\n                                                    entry.getKey(),\n                                                    resources.getInstanceId(),\n                                                    resources.getContainerId(),\n                                                    resources.getHost(),\n                                                    resources.getMemoryMB(),\n                                                    resources.getVirtualCores(),\n                                                    resources.getDebugPort()));\n          }\n        }\n        return liveInfo;\n      }\n    }\n    return new NotRunningLiveInfo(program, type);\n  }","id":91554,"modified_method":"@Override\n  public LiveInfo getLiveInfo(Id.Program program, Type type) {\n    String twillAppName = String.format(\"%s.%s.%s.%s\", type.name().toLowerCase(),\n                                      program.getAccountId(), program.getApplicationId(), program.getId());\n    Iterator<TwillController> controllers = twillRunner.lookup(twillAppName).iterator();\n    JsonObject json = new JsonObject();\n    // this will return an empty Json if there is no live instance\n    if (controllers.hasNext()) {\n      TwillController controller = controllers.next();\n      if (controllers.hasNext()) {\n        LOG.warn(\"Expected at most one live instance of Twill app {} but found at least two.\", twillAppName);\n      }\n      ResourceReport report = controller.getResourceReport();\n      if (report != null) {\n        DistributedLiveInfo liveInfo = new DistributedLiveInfo(program, type, report.getApplicationId());\n\n        // if program type is flow then the container type is flowlet.\n        Containers.ContainerType containerType = Type.FLOW.equals(type) ? FLOWLET :\n                                                 Containers.ContainerType.valueOf(type.name());\n\n        for (Map.Entry<String, Collection<TwillRunResources>> entry : report.getResources().entrySet()) {\n          for (TwillRunResources resources : entry.getValue()) {\n            liveInfo.addContainer(new ContainerInfo(containerType,\n                                                    entry.getKey(),\n                                                    resources.getInstanceId(),\n                                                    resources.getContainerId(),\n                                                    resources.getHost(),\n                                                    resources.getMemoryMB(),\n                                                    resources.getVirtualCores(),\n                                                    resources.getDebugPort()));\n          }\n        }\n        return liveInfo;\n      }\n    }\n    return new NotRunningLiveInfo(program, type);\n  }","commit_id":"117ec9495673a2849d663dd8d177c1515d0267e3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Before\n  public void before() throws Exception {\n    CConfiguration cConf = CConfiguration.create();\n    File datasetDir = new File(tmpFolder.newFolder(), \"dataset\");\n    datasetDir.mkdirs();\n    cConf.set(Constants.Dataset.Manager.OUTPUT_DIR, datasetDir.getAbsolutePath());\n    cConf.set(Constants.Dataset.Manager.ADDRESS, \"localhost\");\n    cConf.setInt(Constants.Dataset.Manager.PORT, Networks.getRandomPort());\n\n    // Starting DatasetManagerService service\n    InMemoryDiscoveryService discoveryService = new InMemoryDiscoveryService();\n    MetricsCollectionService metricsCollectionService = new NoOpMetricsCollectionService();\n\n    DatasetUserService userService = new DatasetUserService(cConf, discoveryService, metricsCollectionService,\n                                                            Collections.EMPTY_SET);\n\n    // Tx Manager to support working with datasets\n    InMemoryTransactionManager txManager = new InMemoryTransactionManager();\n    txManager.startAndWait();\n    InMemoryTxSystemClient txSystemClient = new InMemoryTxSystemClient(txManager);\n\n    datasetManager = new DatasetManagerService(cConf,\n                                               new LocalLocationFactory(),\n                                               discoveryService,\n                                               discoveryService,\n                                               new InMemoryDatasetManager(),\n                                               ImmutableSortedMap.<String, Class<? extends DatasetModule>>of(\n                                                 \"memoryTable\", InMemoryTableModule.class),\n                                               txSystemClient,\n                                               metricsCollectionService,\n                                               userService);\n    datasetManager.startAndWait();\n\n    DatasetManagerServiceClient dsManagerClient = new DatasetManagerServiceClient(discoveryService);\n    manager = new DataFabricDatasetManager(dsManagerClient, cConf,\n                                           new LocalLocationFactory(),\n                                           new InMemoryDatasetDefinitionRegistry());\n  }","id":91555,"modified_method":"@Before\n  public void before() throws Exception {\n    CConfiguration cConf = CConfiguration.create();\n    File datasetDir = new File(tmpFolder.newFolder(), \"dataset\");\n    datasetDir.mkdirs();\n    cConf.set(Constants.Dataset.Manager.OUTPUT_DIR, datasetDir.getAbsolutePath());\n    cConf.set(Constants.Dataset.Manager.ADDRESS, \"localhost\");\n    cConf.setInt(Constants.Dataset.Manager.PORT, Networks.getRandomPort());\n\n    // Starting DatasetManagerService service\n    InMemoryDiscoveryService discoveryService = new InMemoryDiscoveryService();\n    MetricsCollectionService metricsCollectionService = new NoOpMetricsCollectionService();\n    InMemoryDatasetOpExecutor opExecutorClient = new InMemoryDatasetOpExecutor();\n\n    // Tx Manager to support working with datasets\n    InMemoryTransactionManager txManager = new InMemoryTransactionManager();\n    txManager.startAndWait();\n    InMemoryTxSystemClient txSystemClient = new InMemoryTxSystemClient(txManager);\n\n    datasetManager = new DatasetManagerService(cConf,\n                                               new LocalLocationFactory(),\n                                               discoveryService,\n                                               discoveryService,\n                                               new InMemoryDatasetManager(),\n                                               ImmutableSortedMap.<String, Class<? extends DatasetModule>>of(\n                                                 \"memoryTable\", InMemoryTableModule.class),\n                                               txSystemClient,\n                                               metricsCollectionService,\n                                               opExecutorClient);\n    datasetManager.startAndWait();\n\n    DatasetManagerServiceClient dsManagerClient = new DatasetManagerServiceClient(discoveryService);\n    manager = new DataFabricDatasetManager(dsManagerClient, cConf,\n                                           new LocalLocationFactory(),\n                                           new InMemoryDatasetDefinitionRegistry());\n    opExecutorClient.setClient(manager);\n  }","commit_id":"025920e120188a36569897a8e9cde3bc0b0670a3","url":"https://github.com/caskdata/cdap"},{"original_method":"public Module getDistributedModule() {\n    return new PrivateModule() {\n      @Override\n      protected void configure() {\n        bind(new TypeLiteral<SortedMap<String, Class<? extends DatasetModule>>>() { })\n          .annotatedWith(Names.named(\"defaultDatasetModules\")).toInstance(\n          ImmutableSortedMap.<String, Class<? extends DatasetModule>>of(\n            \"orderedTable-hbase\", HBaseTableModule.class,\n            \"table\", TableModule.class)\n        );\n        bind(DatasetDefinitionRegistry.class).to(DefaultDatasetDefinitionRegistry.class);\n        // NOTE: it is fine to use in-memory dataset manager for direct access to dataset MDS even in distributed mode\n        //       as long as the data is durably persisted\n        bind(DatasetManager.class).annotatedWith(Names.named(\"datasetMDS\")).to(InMemoryDatasetManager.class);\n        bind(DatasetManagerService.class);\n\n        expose(DatasetManagerService.class);\n\n        // UserService todo: move out when UserService is separate from DataSetService\n        // TODO: remove once DatasetUserService is run on-demand\n        Named datasetUserName = Names.named(Constants.Service.DATASET_USER);\n        Multibinder<HttpHandler> handlerBinder = Multibinder.newSetBinder(binder(), HttpHandler.class, datasetUserName);\n        handlerBinder.addBinding().to(DatasetAdminHTTPHandler.class);\n        handlerBinder.addBinding().to(PingHandler.class);\n        bind(DatasetUserService.class).in(Scopes.SINGLETON);\n        expose(DatasetUserService.class);\n      }\n    };\n  }","id":91556,"modified_method":"public Module getDistributedModule() {\n    return new PrivateModule() {\n      @Override\n      protected void configure() {\n        bind(new TypeLiteral<SortedMap<String, Class<? extends DatasetModule>>>() { })\n          .annotatedWith(Names.named(\"defaultDatasetModules\")).toInstance(\n          ImmutableSortedMap.<String, Class<? extends DatasetModule>>of(\n            \"orderedTable-hbase\", HBaseTableModule.class,\n            \"table\", TableModule.class)\n        );\n        bind(DatasetDefinitionRegistry.class).to(DefaultDatasetDefinitionRegistry.class);\n        // NOTE: it is fine to use in-memory dataset manager for direct access to dataset MDS even in distributed mode\n        //       as long as the data is durably persisted\n        bind(DatasetManager.class).annotatedWith(Names.named(\"datasetMDS\")).to(InMemoryDatasetManager.class);\n        bind(DatasetManagerService.class);\n        expose(DatasetManagerService.class);\n\n        bind(DatasetOpExecutor.class).to(YarnDatasetOpExecutor.class);\n        expose(DatasetOpExecutor.class);\n      }\n    };\n  }","commit_id":"025920e120188a36569897a8e9cde3bc0b0670a3","url":"https://github.com/caskdata/cdap"},{"original_method":"public Module getLocalModule() {\n    return new PrivateModule() {\n      @Override\n      protected void configure() {\n        bind(new TypeLiteral<SortedMap<String, Class<? extends DatasetModule>>>() { })\n          .annotatedWith(Names.named(\"defaultDatasetModules\")).toInstance(\n          ImmutableSortedMap.<String, Class<? extends DatasetModule>>of(\n            \"orderedTable-memory\", LevelDBTableModule.class,\n            \"table\", TableModule.class)\n        );\n        bind(DatasetDefinitionRegistry.class).to(DefaultDatasetDefinitionRegistry.class);\n        // NOTE: it is fine to use in-memory dataset manager for direct access to dataset MDS even in distributed mode\n        //       as long as the data is durably persisted\n        bind(DatasetManager.class).annotatedWith(Names.named(\"datasetMDS\")).to(InMemoryDatasetManager.class);\n        bind(DatasetManagerService.class);\n\n        expose(DatasetManagerService.class);\n\n        // UserService todo: move out when UserService is separate from DataSetService\n        // TODO: remove once DatasetUserService is run on-demand\n        Named datasetUserName = Names.named(Constants.Service.DATASET_USER);\n        Multibinder<HttpHandler> handlerBinder = Multibinder.newSetBinder(binder(), HttpHandler.class, datasetUserName);\n        handlerBinder.addBinding().to(DatasetAdminHTTPHandler.class);\n        handlerBinder.addBinding().to(PingHandler.class);\n        bind(DatasetUserService.class).in(Scopes.SINGLETON);\n        expose(DatasetUserService.class);\n      }\n    };\n\n  }","id":91557,"modified_method":"public Module getLocalModule() {\n    return new PrivateModule() {\n      @Override\n      protected void configure() {\n        bind(new TypeLiteral<SortedMap<String, Class<? extends DatasetModule>>>() { })\n          .annotatedWith(Names.named(\"defaultDatasetModules\")).toInstance(\n          ImmutableSortedMap.<String, Class<? extends DatasetModule>>of(\n            \"orderedTable-memory\", LevelDBTableModule.class,\n            \"table\", TableModule.class)\n        );\n        bind(DatasetDefinitionRegistry.class).to(DefaultDatasetDefinitionRegistry.class);\n        // NOTE: it is fine to use in-memory dataset manager for direct access to dataset MDS even in distributed mode\n        //       as long as the data is durably persisted\n        bind(DatasetManager.class).annotatedWith(Names.named(\"datasetMDS\")).to(InMemoryDatasetManager.class);\n        bind(DatasetManagerService.class);\n        expose(DatasetManagerService.class);\n\n        bind(DatasetOpExecutor.class).to(LocalDatasetOpExecutor.class);\n        expose(DatasetOpExecutor.class);\n      }\n    };\n\n  }","commit_id":"025920e120188a36569897a8e9cde3bc0b0670a3","url":"https://github.com/caskdata/cdap"},{"original_method":"public Module getInMemoryModule() {\n    return new PrivateModule() {\n      @Override\n      protected void configure() {\n        bind(new TypeLiteral<SortedMap<String, Class<? extends DatasetModule>>>() { })\n          .annotatedWith(Names.named(\"defaultDatasetModules\")).toInstance(\n          ImmutableSortedMap.<String, Class<? extends DatasetModule>>of(\n            \"orderedTable-memory\", InMemoryTableModule.class,\n            \"table\", TableModule.class)\n        );\n\n        bind(DatasetDefinitionRegistry.class).to(DefaultDatasetDefinitionRegistry.class);\n        // NOTE: it is fine to use in-memory dataset manager for direct access to dataset MDS even in distributed mode\n        //       as long as the data is durably persisted\n        bind(DatasetManager.class).annotatedWith(Names.named(\"datasetMDS\")).to(InMemoryDatasetManager.class);\n        bind(DatasetManagerService.class);\n\n        expose(DatasetManagerService.class);\n\n        // UserService todo: move out when UserService is separate from DataSetService\n        // TODO: remove once DatasetUserService is run on-demand\n        Named datasetUserName = Names.named(Constants.Service.DATASET_USER);\n        Multibinder<HttpHandler> handlerBinder = Multibinder.newSetBinder(binder(), HttpHandler.class, datasetUserName);\n        handlerBinder.addBinding().to(DatasetAdminHTTPHandler.class);\n        handlerBinder.addBinding().to(PingHandler.class);\n        bind(DatasetUserService.class).in(Scopes.SINGLETON);\n        expose(DatasetUserService.class);\n      }\n    };\n\n  }","id":91558,"modified_method":"public Module getInMemoryModule() {\n    return new PrivateModule() {\n      @Override\n      protected void configure() {\n        bind(new TypeLiteral<SortedMap<String, Class<? extends DatasetModule>>>() { })\n          .annotatedWith(Names.named(\"defaultDatasetModules\")).toInstance(\n          ImmutableSortedMap.<String, Class<? extends DatasetModule>>of(\n            \"orderedTable-memory\", InMemoryTableModule.class,\n            \"table\", TableModule.class)\n        );\n\n        bind(DatasetDefinitionRegistry.class).to(DefaultDatasetDefinitionRegistry.class);\n        // NOTE: it is fine to use in-memory dataset manager for direct access to dataset MDS even in distributed mode\n        //       as long as the data is durably persisted\n        bind(DatasetManager.class).annotatedWith(Names.named(\"datasetMDS\")).to(InMemoryDatasetManager.class);\n        bind(DatasetManagerService.class);\n        expose(DatasetManagerService.class);\n\n        bind(DatasetOpExecutor.class).to(InMemoryDatasetOpExecutor.class);\n        expose(DatasetOpExecutor.class);\n      }\n    };\n\n  }","commit_id":"025920e120188a36569897a8e9cde3bc0b0670a3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public DatasetInstanceHandler(DiscoveryServiceClient discoveryClient,\n                                DatasetTypeManager implManager, DatasetInstanceManager instanceManager) {\n    this.discoveryClient = discoveryClient;\n    this.implManager = implManager;\n    this.instanceManager = instanceManager;\n  }","id":91559,"modified_method":"@Inject\n  public DatasetInstanceHandler(DiscoveryServiceClient discoveryClient,\n                                DatasetTypeManager implManager, DatasetInstanceManager instanceManager,\n                                DatasetOpExecutor opExecutorClient) {\n    this.opExecutorClient = opExecutorClient;\n    this.implManager = implManager;\n    this.instanceManager = instanceManager;\n  }","commit_id":"025920e120188a36569897a8e9cde3bc0b0670a3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void startUp() throws Exception {\n    LOG.info(\"Starting DatasetManagerService...\");\n\n    // adding default modules to init dataset manager used by mds (directly)\n    for (Map.Entry<String, Class<? extends DatasetModule>> module : defaultModules.entrySet()) {\n      mdsDatasetManager.register(module.getKey(), module.getValue());\n    }\n\n    typeManager.startAndWait();\n    instanceManager.startAndWait();\n\n    userService.startAndWait();\n    httpService.startAndWait();\n\n    // Register the service\n    cancelDiscovery = discoveryService.register(new Discoverable() {\n      @Override\n      public String getName() {\n        return Constants.Service.DATASET_MANAGER;\n      }\n\n      @Override\n      public InetSocketAddress getSocketAddress() {\n        return httpService.getBindAddress();\n      }\n    });\n\n    LOG.info(\"DatasetManagerService started successfully on {}\", httpService.getBindAddress());\n  }","id":91560,"modified_method":"@Override\n  protected void startUp() throws Exception {\n    LOG.info(\"Starting DatasetManagerService...\");\n\n    // adding default modules to init dataset manager used by mds (directly)\n    for (Map.Entry<String, Class<? extends DatasetModule>> module : defaultModules.entrySet()) {\n      mdsDatasetManager.register(module.getKey(), module.getValue());\n    }\n\n    typeManager.startAndWait();\n    instanceManager.startAndWait();\n\n    opExecutorClient.startAndWait();\n    httpService.startAndWait();\n\n    // Register the service\n    cancelDiscovery = discoveryService.register(new Discoverable() {\n      @Override\n      public String getName() {\n        return Constants.Service.DATASET_MANAGER;\n      }\n\n      @Override\n      public InetSocketAddress getSocketAddress() {\n        return httpService.getBindAddress();\n      }\n    });\n\n    LOG.info(\"DatasetManagerService started successfully on {}\", httpService.getBindAddress());\n  }","commit_id":"025920e120188a36569897a8e9cde3bc0b0670a3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void shutDown() throws Exception {\n    LOG.info(\"Stopping DatasetManagerService...\");\n\n    typeManager.stopAndWait();\n    instanceManager.stopAndWait();\n\n    // Unregister the service\n    cancelDiscovery.cancel();\n    // Wait for a few seconds for requests to stop\n    try {\n      TimeUnit.SECONDS.sleep(3);\n    } catch (InterruptedException e) {\n      LOG.error(\"Interrupted while waiting...\", e);\n    }\n\n    httpService.stopAndWait();\n    userService.stopAndWait();\n  }","id":91561,"modified_method":"@Override\n  protected void shutDown() throws Exception {\n    LOG.info(\"Stopping DatasetManagerService...\");\n\n    typeManager.stopAndWait();\n    instanceManager.stopAndWait();\n\n    // Unregister the service\n    cancelDiscovery.cancel();\n    // Wait for a few seconds for requests to stop\n    try {\n      TimeUnit.SECONDS.sleep(3);\n    } catch (InterruptedException e) {\n      LOG.error(\"Interrupted while waiting...\", e);\n    }\n\n    httpService.stopAndWait();\n    opExecutorClient.stopAndWait();\n  }","commit_id":"025920e120188a36569897a8e9cde3bc0b0670a3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Before\n  public void before() throws Exception {\n    CConfiguration cConf = CConfiguration.create();\n    File datasetDir = new File(tmpFolder.newFolder(), \"dataset\");\n    if (!datasetDir.mkdirs()) {\n      throw new RuntimeException(String.format(\"Could not create DatasetManager output dir %s\", datasetDir.getPath()));\n    }\n    cConf.set(Constants.Dataset.Manager.OUTPUT_DIR, datasetDir.getAbsolutePath());\n    cConf.set(Constants.Dataset.Manager.ADDRESS, \"localhost\");\n    port = Networks.getRandomPort();\n    cConf.setInt(Constants.Dataset.Manager.PORT, port);\n\n    // Starting DatasetManagerService service\n    InMemoryDiscoveryService discoveryService = new InMemoryDiscoveryService();\n    MetricsCollectionService metricsCollectionService = new NoOpMetricsCollectionService();\n\n    DatasetUserService userService = new DatasetUserService(cConf, discoveryService,\n                                                            metricsCollectionService, Collections.EMPTY_SET);\n    userService.startAndWait();\n\n    // Tx Manager to support working with datasets\n    txManager = new InMemoryTransactionManager();\n    txManager.startAndWait();\n    InMemoryTxSystemClient txSystemClient = new InMemoryTxSystemClient(txManager);\n\n    service = new DatasetManagerService(cConf,\n                                        new LocalLocationFactory(),\n                                        discoveryService,\n                                        discoveryService,\n                                        new InMemoryDatasetManager(),\n                                        ImmutableSortedMap.<String, Class<? extends DatasetModule>>of(\n                                          \"memoryTable\", InMemoryTableModule.class),\n                                        txSystemClient,\n                                        metricsCollectionService,\n                                        userService);\n    service.startAndWait();\n  }","id":91562,"modified_method":"@Before\n  public void before() throws Exception {\n    CConfiguration cConf = CConfiguration.create();\n    File datasetDir = new File(tmpFolder.newFolder(), \"dataset\");\n    if (!datasetDir.mkdirs()) {\n      throw new RuntimeException(String.format(\"Could not create DatasetManager output dir %s\", datasetDir.getPath()));\n    }\n    cConf.set(Constants.Dataset.Manager.OUTPUT_DIR, datasetDir.getAbsolutePath());\n    cConf.set(Constants.Dataset.Manager.ADDRESS, \"localhost\");\n    port = Networks.getRandomPort();\n    cConf.setInt(Constants.Dataset.Manager.PORT, port);\n\n    // Starting DatasetManagerService service\n    InMemoryDiscoveryService discoveryService = new InMemoryDiscoveryService();\n    MetricsCollectionService metricsCollectionService = new NoOpMetricsCollectionService();\n\n    // Tx Manager to support working with datasets\n    txManager = new InMemoryTransactionManager();\n    txManager.startAndWait();\n    InMemoryTxSystemClient txSystemClient = new InMemoryTxSystemClient(txManager);\n\n    service = new DatasetManagerService(cConf,\n                                        new LocalLocationFactory(),\n                                        discoveryService,\n                                        discoveryService,\n                                        new InMemoryDatasetManager(),\n                                        ImmutableSortedMap.<String, Class<? extends DatasetModule>>of(\n                                          \"memoryTable\", InMemoryTableModule.class),\n                                        txSystemClient,\n                                        metricsCollectionService,\n                                        new NoOpDatasetOpExecutor());\n    service.startAndWait();\n  }","commit_id":"025920e120188a36569897a8e9cde3bc0b0670a3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void init(String[] args) {\n    twillApplication = createTwillApplication();\n    if (twillApplication == null) {\n      throw new IllegalArgumentException(\"TwillApplication cannot be null\");\n    }\n\n    serviceName = twillApplication.configure().getName();\n\n    cConf.set(Constants.Dataset.Manager.ADDRESS, getLocalHost().getCanonicalHostName());\n    // TODO(alvin): remove once DatasetUserService runs outside of DatasetManagerService\n    cConf.set(Constants.Dataset.User.ADDRESS, getLocalHost().getCanonicalHostName());\n\n    baseInjector = Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new ZKClientModule(),\n      new LocationRuntimeModule().getDistributedModules(),\n      new IOModule(),\n      new AuthModule(),\n      new KafkaClientModule(),\n      new TwillModule(),\n      new DiscoveryRuntimeModule().getDistributedModules(),\n      new AppFabricServiceRuntimeModule().getDistributedModules(),\n      new ProgramRunnerRuntimeModule().getDistributedModules(),\n      new DataSetServiceModules().getDistributedModule(),\n      new DataFabricModules(cConf, hConf).getDistributedModules(),\n      new MetricsClientRuntimeModule().getDistributedModules()\n    );\n    // Initialize ZK client\n    zkClientService = baseInjector.getInstance(ZKClientService.class);\n    kafkaClientService = baseInjector.getInstance(KafkaClientService.class);\n    metricsCollectionService = baseInjector.getInstance(MetricsCollectionService.class);\n    dsService = baseInjector.getInstance(DatasetManagerService.class);\n  }","id":91563,"modified_method":"@Override\n  public void init(String[] args) {\n    twillApplication = createTwillApplication();\n    if (twillApplication == null) {\n      throw new IllegalArgumentException(\"TwillApplication cannot be null\");\n    }\n\n    serviceName = twillApplication.configure().getName();\n\n    cConf.set(Constants.Dataset.Manager.ADDRESS, getLocalHost().getCanonicalHostName());\n\n    baseInjector = Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new ZKClientModule(),\n      new LocationRuntimeModule().getDistributedModules(),\n      new IOModule(),\n      new AuthModule(),\n      new KafkaClientModule(),\n      new TwillModule(),\n      new DiscoveryRuntimeModule().getDistributedModules(),\n      new AppFabricServiceRuntimeModule().getDistributedModules(),\n      new ProgramRunnerRuntimeModule().getDistributedModules(),\n      new DataSetServiceModules().getDistributedModule(),\n      new DataFabricModules(cConf, hConf).getDistributedModules(),\n      new MetricsClientRuntimeModule().getDistributedModules()\n    );\n    // Initialize ZK client\n    zkClientService = baseInjector.getInstance(ZKClientService.class);\n    kafkaClientService = baseInjector.getInstance(KafkaClientService.class);\n    metricsCollectionService = baseInjector.getInstance(MetricsCollectionService.class);\n    dsService = baseInjector.getInstance(DatasetManagerService.class);\n  }","commit_id":"025920e120188a36569897a8e9cde3bc0b0670a3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public TwillSpecification configure() {\n    // It is always present in continuuity-default.xml\n    final long noContainerTimeout = cConf.getLong(Constants.CFG_TWILL_NO_CONTAINER_TIMEOUT, Long.MAX_VALUE);\n\n    return\n      addLogSaverService(\n       addStreamService(\n         addTransactionService(\n           addMetricsProcessor (\n             addMetricsService(\n              TwillSpecification.Builder.with().setName(NAME).withRunnable())))))\n        .anyOrder()\n        .withEventHandler(new AbortOnTimeoutEventHandler(noContainerTimeout))\n        .build();\n  }","id":91564,"modified_method":"@Override\n  public TwillSpecification configure() {\n    // It is always present in continuuity-default.xml\n    final long noContainerTimeout = cConf.getLong(Constants.CFG_TWILL_NO_CONTAINER_TIMEOUT, Long.MAX_VALUE);\n\n    return\n      addDatasetOpExecutor(\n        addLogSaverService(\n         addStreamService(\n           addTransactionService(\n             addMetricsProcessor (\n               addMetricsService(\n                TwillSpecification.Builder.with().setName(NAME).withRunnable()))))))\n        .anyOrder()\n        .withEventHandler(new AbortOnTimeoutEventHandler(noContainerTimeout))\n        .build();\n  }","commit_id":"025920e120188a36569897a8e9cde3bc0b0670a3","url":"https://github.com/caskdata/cdap"},{"original_method":"protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        scmManager = new ScmManagerStub();\n    }","id":91565,"modified_method":"/** {@inheritDoc} */\n    protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        scmManager = new ScmManagerStub();\n    }","commit_id":"7a57bd9316f4e2df554576aa6c1b28d21f55664d","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testNoSource()\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(), \"src/test/plugin-configs/changelog/no-source-plugin-config.xml\" );\n\n        Mojo mojo = lookupMojo( \"changelog\", pluginXmlFile );\n\n        assertNotNull( \"Mojo found.\", mojo );\n\n        this.setVariableValueToObject( mojo, \"manager\", scmManager );\n\n        mojo.execute();\n\n        File outputDir = (File) getVariableValueFromObject( mojo, \"outputDirectory\" );\n\n        File outputHtml = new File( outputDir, \"changelog.html\" );\n\n        assertTrue( \"Test html generated\", outputHtml.exists() );\n    }","id":91566,"modified_method":"public void testNoSource()\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(), \"src/test/plugin-configs/changelog/no-source-plugin-config.xml\" );\n\n        ChangeLogReport mojo = (ChangeLogReport)lookupMojo( \"changelog\", pluginXmlFile );\n\n        assertNotNull( \"Mojo found.\", mojo );\n\n        this.setVariableValueToObject( mojo, \"manager\", scmManager );\n\n        mojo.execute();\n\n        File outputDir = (File) getVariableValueFromObject( mojo, \"outputDirectory\" );\n\n        File outputHtml = new File( outputDir, \"changelog.html\" );\n\n        renderer( mojo, outputHtml );\n\n        assertTrue( outputHtml.getAbsolutePath() + \" not generated!\", outputHtml.exists() );\n\n        assertTrue( outputHtml.getAbsolutePath() + \" is empty!\", outputHtml.length() > 0 );\n    }","commit_id":"7a57bd9316f4e2df554576aa6c1b28d21f55664d","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void executeMojo( String pluginXml )\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(), \"src/test/plugin-configs/changelog/\" + pluginXml );\n\n        Mojo mojo = lookupMojo( \"changelog\", pluginXmlFile );\n\n        assertNotNull( \"Mojo found.\", mojo );\n\n        this.setVariableValueToObject( mojo, \"manager\", scmManager );\n\n        mojo.execute();\n\n        File outputXML = (File) getVariableValueFromObject( mojo, \"outputXML\" );\n\n        String encoding = (String) getVariableValueFromObject( mojo, \"outputEncoding\" );\n\n        assertTrue( \"Test if changelog.xml is created\", outputXML.exists() );\n\n        String changelogXml = FileUtils.fileRead( outputXML );\n\n        assertTrue( \"Test for xml header\", changelogXml.startsWith( \"<?xml version=\\\"1.0\\\" encoding=\\\"\" +\n                    encoding + \"\\\"?>\" ) );\n\n        assertTrue( \"Test for xml footer\", changelogXml.endsWith( \"<\/changelog>\" ) );\n\n        File outputDir = (File) getVariableValueFromObject( mojo, \"outputDirectory\" );\n\n        File outputHtml = new File( outputDir, \"changelog.html\" );\n\n        assertTrue( \"Test html generated\", outputHtml.exists() );\n    }","id":91567,"modified_method":"private void executeMojo( String pluginXml )\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(), \"src/test/plugin-configs/changelog/\" + pluginXml );\n\n        ChangeLogReport mojo = (ChangeLogReport)lookupMojo( \"changelog\", pluginXmlFile );\n\n        assertNotNull( \"Mojo found.\", mojo );\n\n        this.setVariableValueToObject( mojo, \"manager\", scmManager );\n\n        mojo.execute();\n\n        File outputXML = (File) getVariableValueFromObject( mojo, \"outputXML\" );\n\n        String encoding = (String) getVariableValueFromObject( mojo, \"outputEncoding\" );\n\n        assertTrue( \"Test if changelog.xml is created\", outputXML.exists() );\n\n        String changelogXml = FileUtils.fileRead( outputXML );\n\n        assertTrue( \"Test for xml header\", changelogXml.startsWith( \"<?xml version=\\\"1.0\\\" encoding=\\\"\" +\n                    encoding + \"\\\"?>\" ) );\n\n        assertTrue( \"Test for xml footer\", changelogXml.endsWith( \"<\/changelog>\" ) );\n\n        File outputDir = (File) getVariableValueFromObject( mojo, \"outputDirectory\" );\n\n        File outputHtml = new File( outputDir, \"changelog.html\" );\n\n        renderer( mojo, outputHtml );\n\n        assertTrue( outputHtml.getAbsolutePath() + \" not generated!\", outputHtml.exists() );\n\n        assertTrue( outputHtml.getAbsolutePath() + \" is empty!\", outputHtml.length() > 0 );\n    }","commit_id":"7a57bd9316f4e2df554576aa6c1b28d21f55664d","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void tearDown()\n        throws Exception\n    {\n        super.tearDown();\n    }","id":91568,"modified_method":"/** {@inheritDoc} */\n    protected void tearDown()\n        throws Exception\n    {\n        super.tearDown();\n\n        scmManager = null;\n    }","commit_id":"7a57bd9316f4e2df554576aa6c1b28d21f55664d","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        scmManager = new ScmManagerStub();\n    }","id":91569,"modified_method":"/** {@inheritDoc} */\n    protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        scmManager = new ScmManagerStub();\n    }","commit_id":"7a57bd9316f4e2df554576aa6c1b28d21f55664d","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testNoSource()\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(),\n                                       \"src/test/plugin-configs/dev-activity/no-source-plugin-config.xml\" );\n\n        Mojo mojo = lookupMojo( \"dev-activity\", pluginXmlFile );\n\n        assertNotNull( \"Mojo found.\", mojo );\n\n        this.setVariableValueToObject( mojo, \"manager\", scmManager );\n\n        mojo.execute();\n\n        File outputDir = (File) getVariableValueFromObject( mojo, \"outputDirectory\" );\n\n        File outputHtml = new File( outputDir, \"dev-activity.html\" );\n\n        assertTrue( \"Test html generated\", outputHtml.exists() );\n    }","id":91570,"modified_method":"public void testNoSource()\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(),\n                                       \"src/test/plugin-configs/dev-activity/no-source-plugin-config.xml\" );\n\n        DeveloperActivityReport mojo = (DeveloperActivityReport) lookupMojo( \"dev-activity\", pluginXmlFile );\n\n        assertNotNull( \"Mojo found.\", mojo );\n\n        this.setVariableValueToObject( mojo, \"manager\", scmManager );\n\n        mojo.execute();\n\n        File outputDir = (File) getVariableValueFromObject( mojo, \"outputDirectory\" );\n\n        File outputHtml = new File( outputDir, \"dev-activity.html\" );\n\n        renderer( mojo, outputHtml );\n\n        assertTrue( outputHtml.getAbsolutePath() + \" not generated!\", outputHtml.exists() );\n\n        assertTrue( outputHtml.getAbsolutePath() + \" is empty!\", outputHtml.length() > 0 );\n    }","commit_id":"7a57bd9316f4e2df554576aa6c1b28d21f55664d","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void executeMojo( String pluginXml )\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(), \"src/test/plugin-configs/dev-activity/\" + pluginXml );\n\n        Mojo mojo = lookupMojo( \"dev-activity\", pluginXmlFile );\n\n        assertNotNull( \"Mojo found.\", mojo );\n\n        this.setVariableValueToObject( mojo, \"manager\", scmManager );\n\n        mojo.execute();\n\n        File outputXML = (File) getVariableValueFromObject( mojo, \"outputXML\" );\n\n        String encoding = (String) getVariableValueFromObject( mojo, \"outputEncoding\" );\n\n        assertTrue( \"Test if changelog.xml is created\", outputXML.exists() );\n\n        String changelogXml = FileUtils.fileRead( outputXML );\n\n        assertTrue( \"Test for xml header\", changelogXml.startsWith( \"<?xml version=\\\"1.0\\\" encoding=\\\"\" +\n                    encoding + \"\\\"?>\" ) );\n\n        assertTrue( \"Test for xml footer\", changelogXml.endsWith( \"<\/changelog>\" ) );\n\n        File outputDir = (File) getVariableValueFromObject( mojo, \"outputDirectory\" );\n\n        File outputHtml = new File( outputDir, \"dev-activity.html\" );\n\n        assertTrue( \"Test html generated\", outputHtml.exists() );\n    }","id":91571,"modified_method":"private void executeMojo( String pluginXml )\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(), \"src/test/plugin-configs/dev-activity/\" + pluginXml );\n\n        DeveloperActivityReport mojo = (DeveloperActivityReport)lookupMojo( \"dev-activity\", pluginXmlFile );\n\n        assertNotNull( \"Mojo found.\", mojo );\n\n        this.setVariableValueToObject( mojo, \"manager\", scmManager );\n\n        mojo.execute();\n\n        File outputXML = (File) getVariableValueFromObject( mojo, \"outputXML\" );\n\n        String encoding = (String) getVariableValueFromObject( mojo, \"outputEncoding\" );\n\n        assertTrue( \"Test if changelog.xml is created\", outputXML.exists() );\n\n        String changelogXml = FileUtils.fileRead( outputXML );\n\n        assertTrue( \"Test for xml header\", changelogXml.startsWith( \"<?xml version=\\\"1.0\\\" encoding=\\\"\" +\n                    encoding + \"\\\"?>\" ) );\n\n        assertTrue( \"Test for xml footer\", changelogXml.endsWith( \"<\/changelog>\" ) );\n\n        File outputDir = (File) getVariableValueFromObject( mojo, \"outputDirectory\" );\n\n        File outputHtml = new File( outputDir, \"dev-activity.html\" );\n\n        renderer( mojo, outputHtml );\n\n        assertTrue( outputHtml.getAbsolutePath() + \" not generated!\", outputHtml.exists() );\n\n        assertTrue( outputHtml.getAbsolutePath() + \" is empty!\", outputHtml.length() > 0 );\n    }","commit_id":"7a57bd9316f4e2df554576aa6c1b28d21f55664d","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void executeMojo( String pluginXml )\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(), \"src/test/plugin-configs/file-activity/\" + pluginXml );\n\n        Mojo mojo = lookupMojo( \"file-activity\", pluginXmlFile );\n\n        assertNotNull( \"Mojo found.\", mojo );\n\n        this.setVariableValueToObject( mojo, \"manager\", scmManager );\n\n        mojo.execute();\n\n        File outputXML = (File) getVariableValueFromObject( mojo, \"outputXML\" );\n\n        String encoding = (String) getVariableValueFromObject( mojo, \"outputEncoding\" );\n\n        assertTrue( \"Test if changelog.xml is created\", outputXML.exists() );\n\n        String changelogXml = FileUtils.fileRead( outputXML );\n\n        assertTrue( \"Test for xml header\", changelogXml.startsWith( \"<?xml version=\\\"1.0\\\" encoding=\\\"\" +\n                    encoding + \"\\\"?>\" ) );\n\n        assertTrue( \"Test for xml footer\", changelogXml.endsWith( \"<\/changelog>\" ) );\n\n        File outputDir = (File) getVariableValueFromObject( mojo, \"outputDirectory\" );\n\n        File outputHtml = new File( outputDir, \"file-activity.html\" );\n\n        assertTrue( \"Test html generated\", outputHtml.exists() );\n    }","id":91572,"modified_method":"private void executeMojo( String pluginXml )\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(), \"src/test/plugin-configs/file-activity/\" + pluginXml );\n\n        FileActivityReport mojo = (FileActivityReport) lookupMojo( \"file-activity\", pluginXmlFile );\n\n        assertNotNull( \"Mojo found.\", mojo );\n\n        this.setVariableValueToObject( mojo, \"manager\", scmManager );\n\n        mojo.execute();\n\n        File outputXML = (File) getVariableValueFromObject( mojo, \"outputXML\" );\n\n        String encoding = (String) getVariableValueFromObject( mojo, \"outputEncoding\" );\n\n        assertTrue( \"Test if changelog.xml is created\", outputXML.exists() );\n\n        String changelogXml = FileUtils.fileRead( outputXML );\n\n        assertTrue( \"Test for xml header\", changelogXml.startsWith( \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + encoding\n            + \"\\\"?>\" ) );\n\n        assertTrue( \"Test for xml footer\", changelogXml.endsWith( \"<\/changelog>\" ) );\n\n        File outputDir = (File) getVariableValueFromObject( mojo, \"outputDirectory\" );\n\n        File outputHtml = new File( outputDir, \"file-activity.html\" );\n\n        renderer( mojo, outputHtml );\n\n        assertTrue( outputHtml.getAbsolutePath() + \" not generated!\", outputHtml.exists() );\n\n        assertTrue( outputHtml.getAbsolutePath() + \" is empty!\", outputHtml.length() > 0 );\n    }","commit_id":"7a57bd9316f4e2df554576aa6c1b28d21f55664d","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        scmManager = new ScmManagerStub();\n    }","id":91573,"modified_method":"/** {@inheritDoc} */\n    protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        scmManager = new ScmManagerStub();\n    }","commit_id":"7a57bd9316f4e2df554576aa6c1b28d21f55664d","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testNoSource()\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(),\n                                               \"src/test/plugin-configs/file-activity/no-source-plugin-config.xml\" );\n\n        Mojo mojo = lookupMojo( \"file-activity\", pluginXmlFile );\n\n        assertNotNull( \"Mojo found.\", mojo );\n\n        this.setVariableValueToObject( mojo, \"manager\", scmManager );\n\n        mojo.execute();\n\n        File outputDir = (File) getVariableValueFromObject( mojo, \"outputDirectory\" );\n\n        File outputHtml = new File( outputDir, \"file-activity.html\" );\n\n        assertTrue( \"Test html generated\", outputHtml.exists() );\n    }","id":91574,"modified_method":"public void testNoSource()\n        throws Exception\n    {\n        File pluginXmlFile =\n            new File( getBasedir(), \"src/test/plugin-configs/file-activity/no-source-plugin-config.xml\" );\n\n        FileActivityReport mojo = (FileActivityReport) lookupMojo( \"file-activity\", pluginXmlFile );\n\n        assertNotNull( \"Mojo found.\", mojo );\n\n        this.setVariableValueToObject( mojo, \"manager\", scmManager );\n\n        mojo.execute();\n\n        File outputDir = (File) getVariableValueFromObject( mojo, \"outputDirectory\" );\n\n        File outputHtml = new File( outputDir, \"file-activity.html\" );\n\n        renderer( mojo, outputHtml );\n\n        assertTrue( outputHtml.getAbsolutePath() + \" not generated!\", outputHtml.exists() );\n\n        assertTrue( outputHtml.getAbsolutePath() + \" is empty!\", outputHtml.length() > 0 );\n    }","commit_id":"7a57bd9316f4e2df554576aa6c1b28d21f55664d","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#getSiteRenderer()\n     */\n    protected SiteRenderer getSiteRenderer()\n    {\n        return siteRenderer;\n    }","id":91575,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#getSiteRenderer()\n     */\n    protected Renderer getSiteRenderer()\n    {\n        return siteRenderer;\n    }","commit_id":"b1e25673ef4ba3804a184525b6c1497d3bff2c31","url":"https://github.com/apache/maven-plugins"},{"original_method":"private File generateReport( String pluginXml )\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(), \"src/test/plugin-configs/\" + pluginXml );\n        ResourceBundle bundle = ResourceBundle.getBundle( \"checkstyle-report\", Locale.ENGLISH, this.getClassLoader() );\n\n        Mojo mojo = lookupMojo( \"checkstyle\", pluginXmlFile );\n\n        assertNotNull( \"Mojo found.\", mojo );\n\n        mojo.execute();\n\n        File outputFile = (File) getVariableValueFromObject( mojo, \"outputFile\" );\n        assertNotNull( \"Test output file\", outputFile );\n        assertTrue( \"Test output file exists\", outputFile.exists() );\n\n        String cacheFile = (String) getVariableValueFromObject( mojo, \"cacheFile\" );\n        if ( cacheFile != null )\n        {\n            assertTrue( \"Test cache file exists\", new File( cacheFile ).exists() );\n        }\n\n        MavenReport reportMojo = (MavenReport) mojo;\n        File outputDir = reportMojo.getReportOutputDirectory();\n\n        Boolean rss = (Boolean) getVariableValueFromObject( mojo, \"enableRSS\" );\n        if ( rss.booleanValue() )\n        {\n            File rssFile = new File( outputDir, \"checkstyle.rss\" );\n            assertTrue( \"Test rss file exists\", rssFile.exists() );\n        }\n\n        File useFile = (File) getVariableValueFromObject( mojo, \"useFile\" );\n        if ( useFile != null )\n        {\n            assertTrue( \"Test useFile exists\", useFile.exists() );\n        }\n\n        String filename = reportMojo.getOutputName() + \".html\";\n        File outputHtml = new File( outputDir, filename );\n        assertTrue( \"Test output html file exists\", outputHtml.exists() );\n        String htmlString = FileUtils.fileRead( outputHtml );\n\n        boolean searchHeaderFound = ( htmlString.indexOf( \"<h2>\" + bundle.getString( \"report.checkstyle.rules\" )\n            + \"<\/h2>\" ) > 0 );\n        Boolean rules = (Boolean) getVariableValueFromObject( mojo, \"enableRulesSummary\" );\n        if ( rules.booleanValue() )\n        {\n            assertTrue( \"Test for Rules Summary\", searchHeaderFound );\n        }\n        else\n        {\n            assertFalse( \"Test for Rules Summary\", searchHeaderFound );\n        }\n\n        searchHeaderFound = ( htmlString.indexOf( \"<h2>\" + bundle.getString( \"report.checkstyle.summary\" ) + \"<\/h2>\" ) > 0 );\n        Boolean severity = (Boolean) getVariableValueFromObject( mojo, \"enableSeveritySummary\" );\n        if ( severity.booleanValue() )\n        {\n            assertTrue( \"Test for Severity Summary\", searchHeaderFound );\n        }\n        else\n        {\n            assertFalse( \"Test for Severity Summary\", searchHeaderFound );\n        }\n\n        searchHeaderFound = ( htmlString.indexOf( \"<h2>\" + bundle.getString( \"report.checkstyle.files\" ) + \"<\/h2>\" ) > 0 );\n        Boolean files = (Boolean) getVariableValueFromObject( mojo, \"enableFilesSummary\" );\n        if ( files.booleanValue() )\n        {\n            assertTrue( \"Test for Files Summary\", searchHeaderFound );\n        }\n        else\n        {\n            assertFalse( \"Test for Files Summary\", searchHeaderFound );\n        }\n\n        return outputHtml;\n    }","id":91576,"modified_method":"private File generateReport( String pluginXml )\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(), \"src/test/plugin-configs/\" + pluginXml );\n        ResourceBundle bundle =\n            ResourceBundle.getBundle( \"checkstyle-report\", Locale.getDefault(), this.getClassLoader() );\n\n        CheckstyleReport mojo = (CheckstyleReport) lookupMojo( \"checkstyle\", pluginXmlFile );\n\n        assertNotNull( \"Mojo found.\", mojo );\n\n        mojo.execute();\n\n        File outputFile = (File) getVariableValueFromObject( mojo, \"outputFile\" );\n        assertNotNull( \"Test output file\", outputFile );\n        assertTrue( \"Test output file exists\", outputFile.exists() );\n\n        String cacheFile = (String) getVariableValueFromObject( mojo, \"cacheFile\" );\n        if ( cacheFile != null )\n        {\n            assertTrue( \"Test cache file exists\", new File( cacheFile ).exists() );\n        }\n\n        MavenReport reportMojo = (MavenReport) mojo;\n        File outputDir = reportMojo.getReportOutputDirectory();\n\n        Boolean rss = (Boolean) getVariableValueFromObject( mojo, \"enableRSS\" );\n        if ( rss.booleanValue() )\n        {\n            File rssFile = new File( outputDir, \"checkstyle.rss\" );\n            assertTrue( \"Test rss file exists\", rssFile.exists() );\n        }\n\n        File useFile = (File) getVariableValueFromObject( mojo, \"useFile\" );\n        if ( useFile != null )\n        {\n            assertTrue( \"Test useFile exists\", useFile.exists() );\n        }\n\n        String filename = reportMojo.getOutputName() + \".html\";\n        File outputHtml = new File( outputDir, filename );\n\n        renderer( mojo, outputHtml );\n\n        assertTrue( outputHtml.getAbsolutePath() + \" not generated!\", outputHtml.exists() );\n\n        assertTrue( outputHtml.getAbsolutePath() + \" is empty!\", outputHtml.length() > 0 );\n\n        String htmlString = FileUtils.fileRead( outputHtml );\n\n        boolean searchHeaderFound =\n            ( htmlString.indexOf( \"<h2>\" + bundle.getString( \"report.checkstyle.rules\" ) + \"<\/h2>\" ) > 0 );\n        Boolean rules = (Boolean) getVariableValueFromObject( mojo, \"enableRulesSummary\" );\n        if ( rules.booleanValue() )\n        {\n            assertTrue( \"Test for Rules Summary\", searchHeaderFound );\n        }\n        else\n        {\n            assertFalse( \"Test for Rules Summary\", searchHeaderFound );\n        }\n\n        searchHeaderFound =\n            ( htmlString.indexOf( \"<h2>\" + bundle.getString( \"report.checkstyle.summary\" ) + \"<\/h2>\" ) > 0 );\n        Boolean severity = (Boolean) getVariableValueFromObject( mojo, \"enableSeveritySummary\" );\n        if ( severity.booleanValue() )\n        {\n            assertTrue( \"Test for Severity Summary\", searchHeaderFound );\n        }\n        else\n        {\n            assertFalse( \"Test for Severity Summary\", searchHeaderFound );\n        }\n\n        searchHeaderFound =\n            ( htmlString.indexOf( \"<h2>\" + bundle.getString( \"report.checkstyle.files\" ) + \"<\/h2>\" ) > 0 );\n        Boolean files = (Boolean) getVariableValueFromObject( mojo, \"enableFilesSummary\" );\n        if ( files.booleanValue() )\n        {\n            assertTrue( \"Test for Files Summary\", searchHeaderFound );\n        }\n        else\n        {\n            assertFalse( \"Test for Files Summary\", searchHeaderFound );\n        }\n\n        return outputHtml;\n    }","commit_id":"b1e25673ef4ba3804a184525b6c1497d3bff2c31","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see junit.framework.TestCase#tearDown()\n     */\n    protected void tearDown()\n        throws Exception\n    {\n        super.tearDown();\n    }","id":91577,"modified_method":"/**\n     * @see junit.framework.TestCase#tearDown()\n     */\n    protected void tearDown()\n        throws Exception\n    {\n        super.tearDown();\n\n        Locale.setDefault( oldLocale );\n        oldLocale = null;\n    }","commit_id":"b1e25673ef4ba3804a184525b6c1497d3bff2c31","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see junit.framework.TestCase#setUp()\n     */\n    protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n    }","id":91578,"modified_method":"/**\n     * @see junit.framework.TestCase#setUp()\n     */\n    protected void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        oldLocale = Locale.getDefault();\n        Locale.setDefault( Locale.ENGLISH );\n    }","commit_id":"b1e25673ef4ba3804a184525b6c1497d3bff2c31","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testNoSource()\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(), \"src/test/plugin-configs/no-source-plugin-config.xml\" );\n\n        Mojo mojo = lookupMojo( \"checkstyle\", pluginXmlFile );\n        assertNotNull( \"Mojo found.\", mojo );\n        mojo.execute();\n\n        File outputFile = (File) getVariableValueFromObject( mojo, \"outputFile\" );\n\n        assertNotNull( \"Test output file\", outputFile );\n        //if multiples executions without clean, this fail, because the \n        // output file is not erased.\n        //assertFalse( \"Test output file exists\", outputFile.exists() );\n    }","id":91579,"modified_method":"public void testNoSource()\n        throws Exception\n    {\n        File pluginXmlFile = new File( getBasedir(), \"src/test/plugin-configs/no-source-plugin-config.xml\" );\n\n        CheckstyleReport mojo = (CheckstyleReport) lookupMojo( \"checkstyle\", pluginXmlFile );\n        assertNotNull( \"Mojo found.\", mojo );\n        mojo.execute();\n\n        File outputFile = (File) getVariableValueFromObject( mojo, \"outputFile\" );\n\n        renderer( mojo, outputFile );\n\n        assertTrue( outputFile.getAbsolutePath() + \" not generated!\", outputFile.exists() );\n\n        assertTrue( outputFile.getAbsolutePath() + \" is empty!\", outputFile.length() > 0 );\n    }","commit_id":"b1e25673ef4ba3804a184525b6c1497d3bff2c31","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Override\n    public void addNotify() {\n        Log.debug(\"ADDNOTIFY \" + this + \"; thread=\" + mAnnotateThread);\n        mAnnotateThread.setPriority(Thread.NORM_PRIORITY);\n        super.addNotify();\n    }","id":91580,"modified_method":"@Override\n    public void addNotify() {\n        if (DEBUG.Enabled) Log.debug(\"ADDNOTIFY \" + this + \"; thread=\" + mAnnotateThread);\n        mAnnotateThread.setPriority(Thread.NORM_PRIORITY);\n        super.addNotify();\n    }","commit_id":"1ad3187fd6ef3c1928d1df1710320fe900abcead","url":"https://github.com/VUE/VUE"},{"original_method":"private void runAnnotate() {\n        //annotateForMap(mActiveMap);\n        mAddNewRowsButton.setEnabled(false);\n        mAddNewRowsButton.setLabel(\"Comparing to \" + mActiveMap.getLabel() + \"...\");\n        mApplyChangesButton.setEnabled(false);\n        Log.debug(\"WAKING ANNOTATION THREAD \" + mAnnotateThread + \"; pri=\" + mAnnotateThread.getPriority());\n        synchronized (mAnnotateThread) {\n            mAnnotateThread.notify();\n        }\n        Log.debug(\"NOTIFIED ANNOTATION THREAD\");\n    }","id":91581,"modified_method":"private void runAnnotate() {\n        //annotateForMap(mActiveMap);\n        GUI.invokeOnEDT(new Runnable() { public void run() {\n            mAddNewRowsButton.setEnabled(false);\n            mAddNewRowsButton.setLabel(\"Comparing to \" + mActiveMap.getLabel() + \"...\");\n            mApplyChangesButton.setEnabled(false);\n        }});\n        //Log.info(\"WAKING \" + mAnnotateThread, new Throwable(\"HERE\"));\n        if (DEBUG.Enabled) Log.debug(\"WAKING ANNOTATION THREAD \" + mAnnotateThread + \"; pri=\" + mAnnotateThread.getPriority());\n        mAnnotateThread.setPriority(Thread.NORM_PRIORITY);\n        synchronized (mAnnotateThread) {\n            mAnnotateThread.notify();\n        }\n        if (DEBUG.Enabled) Log.debug(\"NOTIFIED ANNOTATION THREAD\");\n    }","commit_id":"1ad3187fd6ef3c1928d1df1710320fe900abcead","url":"https://github.com/VUE/VUE"},{"original_method":"private boolean annotateForMap(final LWMap map)\n    {\n        if (DEBUG.Enabled) Log.debug(\"ANNOTATING against \" + map);\n        \n        DataAction.annotateForMap(mSchema, map);\n\n        if (map != null) {\n            final String annot = map.getLabel();\n            for (DataNode n : mRootNode.getChildren()) {\n                if (Thread.interrupted()) return true;\n                n.annotate(map);\n                if (!n.isLeaf())\n                    for (DataNode cn : n.getChildren()) {\n                        if (Thread.interrupted()) return true;\n                        cn.annotate(map);\n                    }\n            }\n        }\n\n        int newRowCount = 0;\n        int changedRowCount = 0;\n        for (DataNode n : mAllRowsNode.getChildren()) {\n            if (!n.isMapPresent())\n                newRowCount++;\n            if (n.isContextChanged())\n                changedRowCount++;\n        }\n\n        Log.debug(\"annotateForMap: newRows \" + newRowCount + \"; changedRows \" + changedRowCount);\n\n        if (newRowCount > 0) {\n            mAddNewRowsButton.setLabel(String.format(\"Add %d new records to Map\", newRowCount));\n            //mAddNewRowsButton.setIcon(NewToMapIcon);\n            mAddNewRowsButton.setEnabled(true);\n        } else {\n            //mAddNewRowsButton.setIcon(null);\n            mAddNewRowsButton.setLabel(\"All Records are represented on Map\");\n            mAddNewRowsButton.setEnabled(false);\n        }\n        if (changedRowCount > 0) {\n            mApplyChangesButton.setLabel(String.format(\"Update %d records on Map\", changedRowCount));\n            mApplyChangesButton.setEnabled(true);\n        } else {\n            mApplyChangesButton.setLabel(\"No Changed Records\");\n            mApplyChangesButton.setEnabled(false);\n        }\n\n        // TODO: don't bother with refresh if annotations didn't change at all\n        GUI.invokeAfterAWT(new Runnable() { public void run() {\n            refreshAll();\n        }});\n\n        return false;\n    }","id":91582,"modified_method":"private boolean annotateForMap(final LWMap map)\n    {\n        if (DEBUG.Enabled) Log.debug(\"ANNOTATING against \" + map);\n        \n        DataAction.annotateForMap(mSchema, map);\n\n        if (map != null) {\n            final String annot = map.getLabel();\n            for (DataNode n : mRootNode.getChildren()) {\n                if (Thread.interrupted()) return true;\n                n.annotate(map);\n                if (!n.isLeaf())\n                    for (DataNode cn : n.getChildren()) {\n                        if (Thread.interrupted()) return true;\n                        cn.annotate(map);\n                    }\n            }\n        }\n\n        int _newRowCount = 0;\n        int _changedRowCount = 0;\n        for (DataNode n : mAllRowsNode.getChildren()) {\n            if (!n.isMapPresent())\n                _newRowCount++;\n            if (n.isContextChanged())\n                _changedRowCount++;\n        }\n\n        final int newRowCount = _newRowCount;\n        final int changedRowCount = _changedRowCount;\n        \n        if (DEBUG.Enabled) Log.debug(\"annotateForMap: newRows \" + newRowCount + \"; changedRows \" + changedRowCount);\n\n        GUI.invokeOnEDT(new Runnable() { public void run() {\n            \n            if (newRowCount > 0) {\n                mAddNewRowsButton.setLabel(String.format(\"Add %d new records to Map\", newRowCount));\n                //mAddNewRowsButton.setIcon(NewToMapIcon);\n                mAddNewRowsButton.setEnabled(true);\n            } else {\n                //mAddNewRowsButton.setIcon(null);\n                mAddNewRowsButton.setLabel(\"All Records are represented on Map\");\n                mAddNewRowsButton.setEnabled(false);\n            }\n            if (changedRowCount > 0) {\n                mApplyChangesButton.setLabel(String.format(\"Update %d records on Map\", changedRowCount));\n                mApplyChangesButton.setEnabled(true);\n            } else {\n                mApplyChangesButton.setLabel(\"No Changed Records\");\n                mApplyChangesButton.setEnabled(false);\n            }\n\n            // TODO: don't bother with refresh if annotations didn't change at all\n            refreshAll();\n        }});\n\n        return false;\n    }","commit_id":"1ad3187fd6ef3c1928d1df1710320fe900abcead","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n    public void removeNotify() {\n        Log.debug(\"REMOVENOTIFY \" + this);\n        mAnnotateThread.setPriority(Thread.MIN_PRIORITY);\n        super.removeNotify();\n    }","id":91583,"modified_method":"@Override\n    public void removeNotify() {\n        if (DEBUG.Enabled) Log.debug(\"REMOVENOTIFY \" + this + \"; thread=\" + mAnnotateThread);\n        if (mAnnotateThread != null)\n            mAnnotateThread.setPriority(Thread.MIN_PRIORITY);\n        super.removeNotify();\n    }","commit_id":"1ad3187fd6ef3c1928d1df1710320fe900abcead","url":"https://github.com/VUE/VUE"},{"original_method":"private static JComponent buildControllerUI(final DataTree tree)\n    {\n        final Schema schema = tree.mSchema;\n        final JPanel wrap = new JPanel(new BorderLayout());\n        final JPanel toolbar = new JPanel();\n        toolbar.setOpaque(true);\n        toolbar.setBackground(Color.white);\n        //toolbar.setLayout(new BoxLayout(toolbar, BoxLayout.X_AXIS));\n        toolbar.setLayout(new BorderLayout());\n        //p.add(new JLabel(s.getSource().toString()), BorderLayout.NORTH);\n\n        //addNew.setBorderPainted(false);\n        tree.mAddNewRowsButton.setOpaque(false);\n        tree.mApplyChangesButton.setOpaque(false);\n        tree.mAddNewRowsButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    tree.addNewRowsToMap();\n                }\n            });\n        tree.mApplyChangesButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    tree.applyChangesToMap();\n                }\n            });\n\n        tree.getSelectionModel().setSelectionMode(TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);\n\n        tree.setBorder(GUI.makeSpace(3,0,0,0));\n\n            \n        JLabel dataSourceLabel = null;\n            \n        String imagePath = schema.getSingletonValue(\"rss.channel.image.url\");\n        if (imagePath == null)\n            imagePath = schema.getSingletonValue(\"rdf:RDF.image.url\");\n        if (imagePath != null) {\n            URL imageURL = Resource.makeURL(imagePath);\n            if (imageURL != null) {\n                dataSourceLabel = new JLabel(new ImageIcon(imageURL));\n                dataSourceLabel.setBorder(GUI.makeSpace(2,2,1,0));\n            }\n            //addNew.setIcon(new ImageIcon(imageURL));\n            //addNew.setLabel(imageURL);\n        }\n\n//         JComboBox keyBox = new JComboBox(schema.getPossibleKeyFieldNames());\n//         keyBox.setOpaque(false);\n//         keyBox.setSelectedItem(schema.getKeyField().getName());\n//         keyBox.addItemListener(new ItemListener() {\n//         \tpublic void itemStateChanged(ItemEvent e) {\n//                     if (e.getStateChange() == ItemEvent.SELECTED) {\n//                         String newKey = (String) e.getItem();\n//                         //Log.debug(\"KEY FIELD SELECTED: \" + newKey);\n//                         schema.setKeyField(newKey);\n//                         tree.refreshRoot();\n//                     }\n//         \t}\n//             });\n//         toolbar.add(keyBox, BorderLayout.WEST);\n//         toolbar.add(addNew, BorderLayout.EAST);\n        \n        toolbar.add(tree.mAddNewRowsButton, BorderLayout.NORTH);\n        toolbar.add(tree.mApplyChangesButton, BorderLayout.SOUTH);\n\n        if (dataSourceLabel != null)\n            wrap.add(dataSourceLabel, BorderLayout.SOUTH);\n            \n//         if (dataSourceLabel == null) {\n//             //                 dataSourceLabel = new JLabel(schema.getName());\n//             //                 dataSourceLabel.setFont(tufts.vue.VueConstants.SmallFont);\n//             //                 dataSourceLabel.setBorder(GUI.makeSpace(0,2,0,0));\n//             //                 toolbar.add(dataSourceLabel, BorderLayout.WEST);\n//             //                 toolbar.add(addNew, BorderLayout.EAST);\n//             toolbar.add(addNew, BorderLayout.CENTER);\n//         } else {\n//             toolbar.add(dataSourceLabel, BorderLayout.WEST);\n//             toolbar.add(addNew, BorderLayout.EAST);\n//         }\n            \n        toolbar.setBorder(new MatteBorder(0,0,1,0, Color.gray));\n            \n        wrap.add(toolbar, BorderLayout.NORTH);\n        // todo: if save entire schema with map, include date of creation (last refresh before save)\n        wrap.add(tree, BorderLayout.CENTER);\n        return wrap;\n    }","id":91584,"modified_method":"private static JComponent buildControllerUI(final DataTree tree)\n    {\n        final Schema schema = tree.mSchema;\n        final JPanel wrap = new JPanel(new BorderLayout()) {\n                @Override public void firePropertyChange(String property, boolean oldVal, boolean newVal) {\n                    if (tufts.vue.gui.GUI.FINALIZE.equals(property)) {\n                        if (DEBUG.Enabled) Log.debug(\"firePropertyChange: \" + property);\n                        tree.destroy();\n                    } else {\n                        super.firePropertyChange(property, oldVal, newVal);\n                    }\n                }\n            };\n\n                \n        final JPanel toolbar = new JPanel();\n        toolbar.setOpaque(true);\n        toolbar.setBackground(Color.white);\n        //toolbar.setLayout(new BoxLayout(toolbar, BoxLayout.X_AXIS));\n        toolbar.setLayout(new BorderLayout());\n        //p.add(new JLabel(s.getSource().toString()), BorderLayout.NORTH);\n\n        //addNew.setBorderPainted(false);\n        tree.mAddNewRowsButton.setOpaque(false);\n        tree.mApplyChangesButton.setOpaque(false);\n        tree.mAddNewRowsButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    tree.addNewRowsToMap();\n                }\n            });\n        tree.mApplyChangesButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    tree.applyChangesToMap();\n                }\n            });\n\n        tree.getSelectionModel().setSelectionMode(TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);\n\n        tree.setBorder(GUI.makeSpace(3,0,0,0));\n\n            \n        JLabel dataSourceLabel = null;\n            \n        String imagePath = schema.getSingletonValue(\"rss.channel.image.url\");\n        if (imagePath == null)\n            imagePath = schema.getSingletonValue(\"rdf:RDF.image.url\");\n        if (imagePath != null) {\n            URL imageURL = Resource.makeURL(imagePath);\n            if (imageURL != null) {\n                dataSourceLabel = new JLabel(new ImageIcon(imageURL));\n                dataSourceLabel.setBorder(GUI.makeSpace(2,2,1,0));\n            }\n            //addNew.setIcon(new ImageIcon(imageURL));\n            //addNew.setLabel(imageURL);\n        }\n\n//         JComboBox keyBox = new JComboBox(schema.getPossibleKeyFieldNames());\n//         keyBox.setOpaque(false);\n//         keyBox.setSelectedItem(schema.getKeyField().getName());\n//         keyBox.addItemListener(new ItemListener() {\n//         \tpublic void itemStateChanged(ItemEvent e) {\n//                     if (e.getStateChange() == ItemEvent.SELECTED) {\n//                         String newKey = (String) e.getItem();\n//                         //Log.debug(\"KEY FIELD SELECTED: \" + newKey);\n//                         schema.setKeyField(newKey);\n//                         tree.refreshRoot();\n//                     }\n//         \t}\n//             });\n//         toolbar.add(keyBox, BorderLayout.WEST);\n//         toolbar.add(addNew, BorderLayout.EAST);\n        \n        toolbar.add(tree.mAddNewRowsButton, BorderLayout.NORTH);\n        toolbar.add(tree.mApplyChangesButton, BorderLayout.SOUTH);\n\n        if (dataSourceLabel != null)\n            wrap.add(dataSourceLabel, BorderLayout.SOUTH);\n            \n//         if (dataSourceLabel == null) {\n//             //                 dataSourceLabel = new JLabel(schema.getName());\n//             //                 dataSourceLabel.setFont(tufts.vue.VueConstants.SmallFont);\n//             //                 dataSourceLabel.setBorder(GUI.makeSpace(0,2,0,0));\n//             //                 toolbar.add(dataSourceLabel, BorderLayout.WEST);\n//             //                 toolbar.add(addNew, BorderLayout.EAST);\n//             toolbar.add(addNew, BorderLayout.CENTER);\n//         } else {\n//             toolbar.add(dataSourceLabel, BorderLayout.WEST);\n//             toolbar.add(addNew, BorderLayout.EAST);\n//         }\n            \n        toolbar.setBorder(new MatteBorder(0,0,1,0, Color.gray));\n            \n        wrap.add(toolbar, BorderLayout.NORTH);\n        // todo: if save entire schema with map, include date of creation (last refresh before save)\n        wrap.add(tree, BorderLayout.CENTER);\n        return wrap;\n    }","commit_id":"1ad3187fd6ef3c1928d1df1710320fe900abcead","url":"https://github.com/VUE/VUE"},{"original_method":"private DataTree(final Schema schema) {\n\n        mSchema = schema;\n\n        setCellRenderer(new DataRenderer());\n        //setSelectionModel(null);\n\n        setModel(mTreeModel = new DefaultTreeModel(buildTree(schema), false));\n\n        mAnnotateThread = new Thread(\"Annotate: \" + schema.getName()) {\n                { setPriority(NORM_PRIORITY); }\n                public void run() {\n                    synchronized (this) {\n                    while (true) {\n                        try {\n                            Log.debug(\"annotation thread sleeping\");\n                            wait();\n                        } catch (InterruptedException e) {\n                            Log.error(\"interrupted \" + schema, e);\n                        }\n                        Log.debug(\"annotation thread woke, running....\");\n                        boolean interrupted = annotateForMap(mActiveMap);\n                        if (interrupted)\n                            Log.debug(\"annotation aborted\");\n                        else\n                            Log.debug(\"annotation completed\");\n                    }\n                    }\n                }\n            };\n\n        setRowHeight(0);\n        setRootVisible(false);\n        setShowsRootHandles(true);\n        \n        java.awt.dnd.DragSource.getDefaultDragSource()\n            .createDefaultDragGestureRecognizer\n            (this,\n             java.awt.dnd.DnDConstants.ACTION_COPY |\n             java.awt.dnd.DnDConstants.ACTION_MOVE |\n             java.awt.dnd.DnDConstants.ACTION_LINK,\n             this);\n\n        addMouseListener(new ClickHandler());\n\n        addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {\n                public void valueChanged(javax.swing.event.TreeSelectionEvent e) {\n                    //final TreePath[] paths = e.getPaths();\n                    final TreePath[] paths = getSelectionModel().getSelectionPaths();\n\n                    if (DEBUG.Enabled) Log.debug(\"valueChanged: isAddedPath=\" + e.isAddedPath() + \"; PATHS:\");\n                    if (DEBUG.Enabled) Util.dumpArray(paths);\n                    //if (DEBUG.Enabled) Log.debug(\"OLD LeadPath: \" + e.getOldLeadSelectionPath());\n                    //if (DEBUG.Enabled) Log.debug(\"NEW LeadPath: \" + e.getNewLeadSelectionPath());\n\n                    // TODO: change from checking getPaths to model.getSelectionPaths & ignoring isAddedPath\n//                     if (!e.isAddedPath() || e.getPath().getLastPathComponent() == null)\n//                         return;\n\n                    final DataNode treeNode = (DataNode) e.getPath().getLastPathComponent();\n                    if (treeNode instanceof RowNode) {\n                        VUE.setActive(tufts.vue.MetaMap.class,\n                                      DataTree.this,\n                                      treeNode.getRow().getData());\n                    }\n                    else if (treeNode instanceof ValueNode && treeNode.getField().isPossibleKeyField()) {\n                        DataRow row = mSchema.findRow(treeNode.getField(), treeNode.getValue());\n                        VUE.setActive(tufts.vue.MetaMap.class,\n                                      DataTree.this,\n                                      row.getData());\n                    }\n                    //                         else if (treeNode.hasStyle()) {\n                    //                             final tufts.vue.LWSelection selection = VUE.getSelection();\n                    //                             selection.setSource(DataTree.this);\n                    //                             // prevents from ever drawing through on map:\n                    //                             selection.setSelectionSourceFocal(null);\n                    //                             selection.setTo(treeNode.getStyle());\n                    //                         }\n                    else {\n\n                        // TODO: not a very efficient way to do multi-term searches:\n                        // we search all nodes each time for each node, and we\n                        // have no control over AND v.s. OR -- we should of course\n                        // auto OR terms in the same Field (AND would always be false),\n                        // but likewise auto-AND terms across fields, narrowing the selection.\n                        // Still need to figure out how to get discontiguous tree selection.\n\n                        boolean addToSelection = false;\n                        DataNode node = null;\n                        for (TreePath path : paths) {\n                            node = (DataNode) path.getLastPathComponent();\n                            searchMapForMatchingNodes(node, addToSelection);\n                            addToSelection = true;\n                        }\n                        if (paths.length == 1)\n                            mSelectedSearchNode = node;\n                        else\n                            mSelectedSearchNode = null;\n                            \n                    }\n                        \n                    //                         else if (treeNode instanceof ValueNode) {\n                    //                             if (treeNode.getField().isPossibleKeyField()) {\n                    //                                 DataRow row = mSchema.findRow(treeNode.getField(), treeNode.getValue());\n                    //                                 VUE.setActive(tufts.vue.MetaMap.class,\n                    //                                               DataTree.this,\n                    //                                               row.getData());\n                    //                             } else {\n                    //                                 selectMapForNode(treeNode, false);\n                    //                             }\n                    //                         }\n                    //VUE.setActive(LWComponent.class, this, node.styleNode);\n                }\n            });\n\n        mAnnotateThread.start();\n        \n    }","id":91585,"modified_method":"private DataTree(final Schema schema) {\n\n        mSchema = schema;\n\n        setCellRenderer(new DataRenderer());\n        //setSelectionModel(null);\n\n        setModel(mTreeModel = new DefaultTreeModel(buildTree(schema), false));\n\n        final int ac = AnnotationThreadCount++;\n\n        mAnnotateThread = new Thread(String.format(\"Annotate%d: %s\", ac, schema.getName())) {\n                { setPriority(MAX_PRIORITY); }\n                public synchronized void run() {\n                    while (true) {\n                        try {\n                            // must be careful: if we get a notify before the 1st time\n                            // we go to sleep, we'll never wake up!  So we start this\n                            // thread at high priority, and kick it off immediately,\n                            // because as soon as the DataTree is done constructing,\n                            // we're going to get notified the first time -- still\n                            // theoretically risky but should work.\n                            \n                            if (DEBUG.Enabled) Log.debug(\"annotation thread sleeping, pri=\" + getPriority());\n                            wait();\n                        } catch (InterruptedException e) {\n                            Log.error(\"interrupted; exiting; \" + schema);\n                            return;\n                        }\n                        if (DEBUG.Enabled) Log.debug(\"annotation thread woke, pri=\" + getPriority() + \"; running...\");\n                        final boolean interrupted = annotateForMap(mActiveMap);\n                        if (DEBUG.Enabled) {\n                            if (interrupted)\n                                Log.debug(\"annotation aborted\");\n                            else\n                                Log.debug(\"annotation completed\");\n                        }\n                    }\n                }\n            };\n\n        if (DEBUG.Enabled) Log.debug(\"STARTING \" + mAnnotateThread + \"; (tree constructing)\");\n        mAnnotateThread.start();\n        \n        setRowHeight(0);\n        setRootVisible(false);\n        setShowsRootHandles(true);\n        \n        java.awt.dnd.DragSource.getDefaultDragSource()\n            .createDefaultDragGestureRecognizer\n            (this,\n             java.awt.dnd.DnDConstants.ACTION_COPY |\n             java.awt.dnd.DnDConstants.ACTION_MOVE |\n             java.awt.dnd.DnDConstants.ACTION_LINK,\n             this);\n\n        addMouseListener(new ClickHandler());\n\n        addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {\n                public void valueChanged(javax.swing.event.TreeSelectionEvent e) {\n                    //final TreePath[] paths = e.getPaths();\n                    final TreePath[] paths = getSelectionModel().getSelectionPaths();\n\n                    if (DEBUG.Enabled) Log.debug(\"valueChanged: isAddedPath=\" + e.isAddedPath() + \"; PATHS:\");\n                    if (DEBUG.Enabled) Util.dumpArray(paths);\n                    //if (DEBUG.Enabled) Log.debug(\"OLD LeadPath: \" + e.getOldLeadSelectionPath());\n                    //if (DEBUG.Enabled) Log.debug(\"NEW LeadPath: \" + e.getNewLeadSelectionPath());\n\n                    // TODO: change from checking getPaths to model.getSelectionPaths & ignoring isAddedPath\n//                     if (!e.isAddedPath() || e.getPath().getLastPathComponent() == null)\n//                         return;\n\n                    final DataNode treeNode = (DataNode) e.getPath().getLastPathComponent();\n                    if (treeNode instanceof RowNode) {\n                        VUE.setActive(tufts.vue.MetaMap.class,\n                                      DataTree.this,\n                                      treeNode.getRow().getData());\n                    }\n                    else if (treeNode instanceof ValueNode && treeNode.getField().isPossibleKeyField()) {\n                        DataRow row = mSchema.findRow(treeNode.getField(), treeNode.getValue());\n                        VUE.setActive(tufts.vue.MetaMap.class,\n                                      DataTree.this,\n                                      row.getData());\n                    }\n                    //                         else if (treeNode.hasStyle()) {\n                    //                             final tufts.vue.LWSelection selection = VUE.getSelection();\n                    //                             selection.setSource(DataTree.this);\n                    //                             // prevents from ever drawing through on map:\n                    //                             selection.setSelectionSourceFocal(null);\n                    //                             selection.setTo(treeNode.getStyle());\n                    //                         }\n                    else {\n\n                        // TODO: not a very efficient way to do multi-term searches:\n                        // we search all nodes each time for each node, and we\n                        // have no control over AND v.s. OR -- we should of course\n                        // auto OR terms in the same Field (AND would always be false),\n                        // but likewise auto-AND terms across fields, narrowing the selection.\n                        // Still need to figure out how to get discontiguous tree selection.\n\n                        boolean addToSelection = false;\n                        DataNode node = null;\n                        for (TreePath path : paths) {\n                            node = (DataNode) path.getLastPathComponent();\n                            searchMapForMatchingNodes(node, addToSelection);\n                            addToSelection = true;\n                        }\n                        if (paths.length == 1)\n                            mSelectedSearchNode = node;\n                        else\n                            mSelectedSearchNode = null;\n                            \n                    }\n                        \n                    //                         else if (treeNode instanceof ValueNode) {\n                    //                             if (treeNode.getField().isPossibleKeyField()) {\n                    //                                 DataRow row = mSchema.findRow(treeNode.getField(), treeNode.getValue());\n                    //                                 VUE.setActive(tufts.vue.MetaMap.class,\n                    //                                               DataTree.this,\n                    //                                               row.getData());\n                    //                             } else {\n                    //                                 selectMapForNode(treeNode, false);\n                    //                             }\n                    //                         }\n                    //VUE.setActive(LWComponent.class, this, node.styleNode);\n                }\n            });\n\n    }","commit_id":"1ad3187fd6ef3c1928d1df1710320fe900abcead","url":"https://github.com/VUE/VUE"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows DataflowAnalysisException, CFGBuilderException {\n\t\t\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"    Analyzing method \" + classContext.getJavaClass().getClassName() + \".\" + method.getName());\n\t\t}\n\t\t\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\t\n\t\tBugAccumulator accumulator = new BugAccumulator(bugReporter);\n\t\tDataflow<BitSet, LiveLocalStoreAnalysis> llsaDataflow =\n\t\t\tclassContext.getLiveLocalStoreDataflow(method);\n\t\t\n\t\tint numLocals = method.getCode().getMaxLocals();\n\t\tint [] localStoreCount = new int[numLocals];\n\t\tint [] localLoadCount = new int[numLocals];\n\t\tint [] localIncrementCount = new int[numLocals];\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tBitSet liveStoreSetAtEntry = llsaDataflow.getAnalysis().getResultFact(cfg.getEntry());\n\t\tBitSet complainedAbout = new BitSet();\n\t\t\n\t\t// Get number of locals that are parameters.\n\t\tint localsThatAreParameters = PreorderVisitor.getNumberArguments(method.getSignature());\n\t\tif (!method.isStatic()) localsThatAreParameters++;\n\t\t\n\t\t// Scan method to determine number of loads, stores, and increments\n\t\t// of local variables.\n\t\tcountLocalStoresLoadsAndIncrements(\n\t\t\t\tlocalStoreCount, localLoadCount, localIncrementCount, cfg);\n\t\t\n\t\t// Scan method for\n\t\t// - dead stores\n\t\t// - stores to parameters that are dead upon entry to the method\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext(); ) {\n\t\t\tLocation location = i.next();\n\t\t\t\n\t\t\tBugInstance pendingBugReportAboutOverwrittenParameter = null;\n\t\t\ttry {\n\t\t\tWarningPropertySet propertySet = new WarningPropertySet();\n\t\t\t// Skip any instruction which is not a store\n\t\t\tif (!isStore(location))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// Heuristic: exception handler blocks often contain\n\t\t\t// dead stores generated by the compiler.\n\t\t\tif (location.getBasicBlock().isExceptionHandler())\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.EXCEPTION_HANDLER);\n\t\t\t\n\t\t\tIndexedInstruction ins = (IndexedInstruction) location.getHandle().getInstruction();\n\t\t\t\n\t\t\t\n\t\t\tLocalVariableAnnotation lvAnnotation \n\t\t\t= LocalVariableAnnotation.getLocalVariableAnnotation(method, location, ins);\t\t\t\n\t\t\t\n\t\t\tif (EXCLUDED_LOCALS.contains(lvAnnotation.getName())) continue;\n\t\t\tpropertySet.setProperty(DeadLocalStoreProperty.LOCAL_NAME, lvAnnotation.getName());\n\t\t\t\n\t\t\tint local = ins.getIndex();\n\t\t\t// Is this a store to a parameter which was dead on entry to the method?\n\t\t\tboolean parameterThatIsDeadAtEntry = local < localsThatAreParameters\n\t\t\t\t&& !llsaDataflow.getAnalysis().isStoreAlive(liveStoreSetAtEntry, local);\n\t\t\tif (parameterThatIsDeadAtEntry && !complainedAbout.get(local)) {\n\t\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t// TODO: add warning properties?\n\t\t\t\tpendingBugReportAboutOverwrittenParameter = new BugInstance(this, \"IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(methodGen, javaClass.getSourceFileName())\n\t\t\t\t\t.add(lvAnnotation)\n\t\t\t\t\t.addSourceLine(classContext, methodGen, javaClass.getSourceFileName(), location.getHandle());\n\t\t\t\tcomplainedAbout.set(local);\n\t\t\t}\n\t\t\t\n\t\t\tboolean storeOfNull = false;\n\t\t\tInstructionHandle prevInsHandle = location.getHandle().getPrev();\n\t\t\tif (prevInsHandle != null) {\n\t\t\t\tInstruction prevIns = prevInsHandle.getInstruction();\n\t\t\t\tif (prevIns instanceof LDC || prevIns instanceof ConstantPushInstruction)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ( prevIns instanceof ACONST_NULL) {\n\t\t\t\t\tstoreOfNull = true;\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.STORE_OF_NULL);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\t// Get live stores at this instruction.\n\t\t\t// Note that the analysis also computes which stores were\n\t\t\t// killed by a subsequent unconditional store.\n\t\t\tBitSet liveStoreSet = llsaDataflow.getAnalysis().getFactAtLocation(location);\n\t\t\t\n\t\t\t// Is store alive?\n\t\t\tif (llsaDataflow.getAnalysis().isStoreAlive(liveStoreSet, local))\n\t\t\t\tcontinue;\n\t\t\t// Store is dead\n\t\t\t\n\t\t\t// Ignore assignments that were killed by a subsequent assignment.\n\t\t\tboolean killedBySubsequentStore = llsaDataflow.getAnalysis().killedByStore(liveStoreSet, local);\n\t\t\tif (killedBySubsequentStore)\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.KILLED_BY_SUBSEQUENT_STORE);\n\t\t\t\n\t\t\t// Ignore dead assignments of null and 0.\n\t\t\t// These often indicate defensive programming.\n\t\t\tInstructionHandle prev = location.getBasicBlock().getPredecessorOf(location.getHandle());\n\t\t\tint prevOpCode = -1;\n\n\t\t\tif (prev != null\n\t\t\t\t\t&& defensiveConstantValueOpcodes.get(prev.getInstruction().getOpcode())) {\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEFENSIVE_CONSTANT_OPCODE);\n\t\t\t\tprevOpCode = prev.getInstruction().getOpcode();\n\t\t\t\t}\n\n\t\t\tif (prev != null && prev.getInstruction() instanceof GETFIELD) {\n\t\t\t\tInstructionHandle prev2 = prev.getPrev();\n\n\t\t\t\tif (prev2 != null\n                                && prev2.getInstruction() instanceof ALOAD)\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.CACHING_VALUE);\n\t\t\t}\n\n\t\t\t\n\t\t\tif (ins instanceof IINC) {\n\t\t\t\t// special handling of IINC\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEAD_INCREMENT);\n\t\t\t\tif (localIncrementCount[local] == 1) {\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SINGLE_DEAD_INCREMENT);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if (ins instanceof ASTORE && prev != null) { \n\t\t\t\t// Look for objects created but never used\n\t\t\t\t\n\t\t\t\tInstruction prevIns = prev.getInstruction();\n\t\t\t\tif ((prevIns instanceof INVOKESPECIAL &&\n\t\t\t\t\t\t((INVOKESPECIAL)prevIns).getMethodName(methodGen.getConstantPool()).equals(\"<init>\"))\n\t\t\t\t\t\t|| prevIns instanceof ANEWARRAY\n\t\t\t\t\t\t|| prevIns instanceof NEWARRAY\n\t\t\t\t\t\t|| prevIns instanceof MULTIANEWARRAY) {\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEAD_OBJECT_STORE);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if (!killedBySubsequentStore\n\t\t\t\t    && localStoreCount[local] == 2 && localLoadCount[local] > 0) {\n\t\t\t\t// TODO: why is this significant?\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.TWO_STORES_MULTIPLE_LOADS);\n\t\t\t\t\n\t\t\t} else if (!parameterThatIsDeadAtEntry && localStoreCount[local] == 1) {\n\t\t\t\t// TODO: why is this significant?\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SINGLE_STORE);\n\t\t\t\t\n\t\t\t} else if (!parameterThatIsDeadAtEntry && localLoadCount[local] == 0) {\n\t\t\t\t// TODO: why is this significant?\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.NO_LOADS);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif (parameterThatIsDeadAtEntry) {\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.PARAM_DEAD_ON_ENTRY);\n\t\t\t\tpendingBugReportAboutOverwrittenParameter.setPriority(Detector.HIGH_PRIORITY);\n\t\t\t}\n\n\t\t\tif (localStoreCount[local] > 3) \n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.MANY_STORES);\n\t\t\tint priority = propertySet.computePriority(NORMAL_PRIORITY);\n\t\t\tif (priority <= Detector.EXP_PRIORITY) {\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t// Report the warning\t\t\t\t\n\t\t\t\tBugInstance bugInstance = new BugInstance(this, storeOfNull ? \"DLS_DEAD_LOCAL_STORE_OF_NULL\" : \"DLS_DEAD_LOCAL_STORE\", priority)\n\t\t\t\t\t.addClassAndMethod(methodGen, javaClass.getSourceFileName())\n\t\t\t\t\t.add(lvAnnotation);\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t\t// If in relaxed reporting mode, encode heuristic information.\n\t\t\t\tif (FindBugsAnalysisFeatures.isRelaxedMode()) {\n\t\t\t\t\t// Add general-purpose warning properties\n\t\t\t\t\tWarningPropertyUtil.addPropertiesForLocation(\n\t\t\t\t\t\t\tpropertySet,\n\t\t\t\t\t\t\tclassContext,\n\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\tlocation);\n\t\t\t\t\t\n\t\t\t\t\t// Turn all warning properties into BugProperties\n\t\t\t\t\tpropertySet.decorateBugInstance(bugInstance);\n\t\t\t\t}\n\t\t\t\tSourceLineAnnotation sourceLineAnnotation =\n\t\t\t\t\tSourceLineAnnotation.fromVisitedInstruction(classContext, methodGen, javaClass.getSourceFileName(), \n\t\t\t\t\t\t\tlocation.getHandle());\n\t\t\t\t\n\n\t\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\n\t\t\t\t\tjavaClass.getSourceFileName() + \" : \" +\n\t\t\t\t\t\tmethodGen.getName());\n\t\t\t\tSystem.out.println(\"priority: \" + priority);\n\t\t\t\tSystem.out.println(\"Reporting \" + bugInstance);\n\t\t\t\tSystem.out.println(propertySet);\n\t\t\t\t}\n\t\t\t\taccumulator.accumulateBug(bugInstance, sourceLineAnnotation);\n\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (pendingBugReportAboutOverwrittenParameter  != null) \n\t\t\t\t\tbugReporter.reportBug(pendingBugReportAboutOverwrittenParameter);\n\t\t\t}\n\t\t}\n\t\taccumulator.reportAccumulatedBugs();\n\t}","id":91586,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows DataflowAnalysisException, CFGBuilderException {\n\t\t\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"    Analyzing method \" + classContext.getJavaClass().getClassName() + \".\" + method.getName());\n\t\t}\n\t\t\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\t\n\t\tBugAccumulator accumulator = new BugAccumulator(bugReporter);\n\t\tDataflow<BitSet, LiveLocalStoreAnalysis> llsaDataflow =\n\t\t\tclassContext.getLiveLocalStoreDataflow(method);\n\t\t\n\t\tint numLocals = method.getCode().getMaxLocals();\n\t\tint [] localStoreCount = new int[numLocals];\n\t\tint [] localLoadCount = new int[numLocals];\n\t\tint [] localIncrementCount = new int[numLocals];\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tBitSet liveStoreSetAtEntry = llsaDataflow.getAnalysis().getResultFact(cfg.getEntry());\n\t\tBitSet complainedAbout = new BitSet();\n\t\t\n\t\t// Get number of locals that are parameters.\n\t\tint localsThatAreParameters = PreorderVisitor.getNumberArguments(method.getSignature());\n\t\tif (!method.isStatic()) localsThatAreParameters++;\n\t\t\n\t\t// Scan method to determine number of loads, stores, and increments\n\t\t// of local variables.\n\t\tcountLocalStoresLoadsAndIncrements(\n\t\t\t\tlocalStoreCount, localLoadCount, localIncrementCount, cfg);\n\t\tBugInstance pendingBugReportAboutOverwrittenParameter = null;\n\t\ttry {\n\t\n\t\t// Scan method for\n\t\t// - dead stores\n\t\t// - stores to parameters that are dead upon entry to the method\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext(); ) {\n\t\t\tLocation location = i.next();\n\t\t\t\n\t\t\tWarningPropertySet propertySet = new WarningPropertySet();\n\t\t\t// Skip any instruction which is not a store\n\t\t\tif (!isStore(location))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// Heuristic: exception handler blocks often contain\n\t\t\t// dead stores generated by the compiler.\n\t\t\tif (location.getBasicBlock().isExceptionHandler())\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.EXCEPTION_HANDLER);\n\t\t\t\n\t\t\tIndexedInstruction ins = (IndexedInstruction) location.getHandle().getInstruction();\n\t\t\t\n\t\t\t\n\t\t\tLocalVariableAnnotation lvAnnotation \n\t\t\t= LocalVariableAnnotation.getLocalVariableAnnotation(method, location, ins);\t\t\t\n\t\t\t\n\t\t\tif (EXCLUDED_LOCALS.contains(lvAnnotation.getName())) continue;\n\t\t\tpropertySet.setProperty(DeadLocalStoreProperty.LOCAL_NAME, lvAnnotation.getName());\n\t\t\t\n\t\t\tint local = ins.getIndex();\n\t\t\t// Is this a store to a parameter which was dead on entry to the method?\n\t\t\tboolean parameterThatIsDeadAtEntry = local < localsThatAreParameters\n\t\t\t\t&& !llsaDataflow.getAnalysis().isStoreAlive(liveStoreSetAtEntry, local);\n\t\t\tif (parameterThatIsDeadAtEntry && !complainedAbout.get(local)) {\n\t\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t// TODO: add warning properties?\n\t\t\t\tif (pendingBugReportAboutOverwrittenParameter != null)\n\t\t\t\t\tbugReporter.reportBug(pendingBugReportAboutOverwrittenParameter);\n\t\t\t\tpendingBugReportAboutOverwrittenParameter = new BugInstance(this, \"IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(methodGen, javaClass.getSourceFileName())\n\t\t\t\t\t.add(lvAnnotation)\n\t\t\t\t\t.addSourceLine(classContext, methodGen, javaClass.getSourceFileName(), location.getHandle());\n\t\t\t\tcomplainedAbout.set(local);\n\t\t\t}\n\t\t\t\n\t\t\tboolean storeOfNull = false;\n\t\t\tInstructionHandle prevInsHandle = location.getHandle().getPrev();\n\t\t\tif (prevInsHandle != null) {\n\t\t\t\tInstruction prevIns = prevInsHandle.getInstruction();\n\t\t\t\tif (prevIns instanceof LDC || prevIns instanceof ConstantPushInstruction)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ( prevIns instanceof ACONST_NULL) {\n\t\t\t\t\tstoreOfNull = true;\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.STORE_OF_NULL);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\t// Get live stores at this instruction.\n\t\t\t// Note that the analysis also computes which stores were\n\t\t\t// killed by a subsequent unconditional store.\n\t\t\tBitSet liveStoreSet = llsaDataflow.getAnalysis().getFactAtLocation(location);\n\t\t\t\n\t\t\t// Is store alive?\n\t\t\tif (llsaDataflow.getAnalysis().isStoreAlive(liveStoreSet, local))\n\t\t\t\tcontinue;\n\t\t\t// Store is dead\n\t\t\t\n\t\t\t// Ignore assignments that were killed by a subsequent assignment.\n\t\t\tboolean killedBySubsequentStore = llsaDataflow.getAnalysis().killedByStore(liveStoreSet, local);\n\t\t\tif (killedBySubsequentStore)\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.KILLED_BY_SUBSEQUENT_STORE);\n\t\t\t\n\t\t\t// Ignore dead assignments of null and 0.\n\t\t\t// These often indicate defensive programming.\n\t\t\tInstructionHandle prev = location.getBasicBlock().getPredecessorOf(location.getHandle());\n\t\t\tint prevOpCode = -1;\n\n\t\t\tif (prev != null\n\t\t\t\t\t&& defensiveConstantValueOpcodes.get(prev.getInstruction().getOpcode())) {\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEFENSIVE_CONSTANT_OPCODE);\n\t\t\t\tprevOpCode = prev.getInstruction().getOpcode();\n\t\t\t\t}\n\n\t\t\tif (prev != null && prev.getInstruction() instanceof GETFIELD) {\n\t\t\t\tInstructionHandle prev2 = prev.getPrev();\n\n\t\t\t\tif (prev2 != null\n                                && prev2.getInstruction() instanceof ALOAD)\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.CACHING_VALUE);\n\t\t\t}\n\n\t\t\t\n\t\t\tif (ins instanceof IINC) {\n\t\t\t\t// special handling of IINC\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEAD_INCREMENT);\n\t\t\t\tif (localIncrementCount[local] == 1) {\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SINGLE_DEAD_INCREMENT);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if (ins instanceof ASTORE && prev != null) { \n\t\t\t\t// Look for objects created but never used\n\t\t\t\t\n\t\t\t\tInstruction prevIns = prev.getInstruction();\n\t\t\t\tif ((prevIns instanceof INVOKESPECIAL &&\n\t\t\t\t\t\t((INVOKESPECIAL)prevIns).getMethodName(methodGen.getConstantPool()).equals(\"<init>\"))\n\t\t\t\t\t\t|| prevIns instanceof ANEWARRAY\n\t\t\t\t\t\t|| prevIns instanceof NEWARRAY\n\t\t\t\t\t\t|| prevIns instanceof MULTIANEWARRAY) {\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEAD_OBJECT_STORE);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if (!killedBySubsequentStore\n\t\t\t\t    && localStoreCount[local] == 2 && localLoadCount[local] > 0) {\n\t\t\t\t// TODO: why is this significant?\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.TWO_STORES_MULTIPLE_LOADS);\n\t\t\t\t\n\t\t\t} else if (!parameterThatIsDeadAtEntry && localStoreCount[local] == 1) {\n\t\t\t\t// TODO: why is this significant?\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SINGLE_STORE);\n\t\t\t\t\n\t\t\t} else if (!parameterThatIsDeadAtEntry && localLoadCount[local] == 0) {\n\t\t\t\t// TODO: why is this significant?\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.NO_LOADS);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif (parameterThatIsDeadAtEntry) {\n\t\t\t\t\n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.PARAM_DEAD_ON_ENTRY);\n\t\t\t\tif (pendingBugReportAboutOverwrittenParameter == null)\n\t\t\t\t\tSystem.out.println(\"huh\");\n\t\t\t\telse \n\t\t\t\t\tpendingBugReportAboutOverwrittenParameter.setPriority(Detector.HIGH_PRIORITY);\n\t\t\t}\n\n\t\t\tif (localStoreCount[local] > 3) \n\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.MANY_STORES);\n\t\t\tint priority = propertySet.computePriority(NORMAL_PRIORITY);\n\t\t\tif (priority <= Detector.EXP_PRIORITY) {\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t// Report the warning\t\t\t\t\n\t\t\t\tBugInstance bugInstance = new BugInstance(this, storeOfNull ? \"DLS_DEAD_LOCAL_STORE_OF_NULL\" : \"DLS_DEAD_LOCAL_STORE\", priority)\n\t\t\t\t\t.addClassAndMethod(methodGen, javaClass.getSourceFileName())\n\t\t\t\t\t.add(lvAnnotation);\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t\t// If in relaxed reporting mode, encode heuristic information.\n\t\t\t\tif (FindBugsAnalysisFeatures.isRelaxedMode()) {\n\t\t\t\t\t// Add general-purpose warning properties\n\t\t\t\t\tWarningPropertyUtil.addPropertiesForLocation(\n\t\t\t\t\t\t\tpropertySet,\n\t\t\t\t\t\t\tclassContext,\n\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\tlocation);\n\t\t\t\t\t\n\t\t\t\t\t// Turn all warning properties into BugProperties\n\t\t\t\t\tpropertySet.decorateBugInstance(bugInstance);\n\t\t\t\t}\n\t\t\t\tSourceLineAnnotation sourceLineAnnotation =\n\t\t\t\t\tSourceLineAnnotation.fromVisitedInstruction(classContext, methodGen, javaClass.getSourceFileName(), \n\t\t\t\t\t\t\tlocation.getHandle());\n\t\t\t\t\n\n\t\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\n\t\t\t\t\tjavaClass.getSourceFileName() + \" : \" +\n\t\t\t\t\t\tmethodGen.getName());\n\t\t\t\tSystem.out.println(\"priority: \" + priority);\n\t\t\t\tSystem.out.println(\"Reporting \" + bugInstance);\n\t\t\t\tSystem.out.println(propertySet);\n\t\t\t\t}\n\t\t\t\taccumulator.accumulateBug(bugInstance, sourceLineAnnotation);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t} finally {\n\t\t\tif (pendingBugReportAboutOverwrittenParameter  != null) \n\t\t\t\tbugReporter.reportBug(pendingBugReportAboutOverwrittenParameter);\n\t\t}\n\t\taccumulator.reportAccumulatedBugs();\n\t}","commit_id":"25c47f85dbd919f2001c79e94857c41741f6503e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )\n    {\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( \"Looking up lifecyle mappings for packaging \" + packaging + \" from \" +\n                Thread.currentThread().getContextClassLoader() );\n        }\n\n        LifecycleMapping lifecycleMappingForPackaging = lifecycleMappings.get( packaging );\n\n        if ( lifecycleMappingForPackaging == null )\n        {\n            return null;\n        }\n\n        Map<Plugin, Plugin> plugins = new LinkedHashMap<Plugin, Plugin>();\n\n        for ( Lifecycle lifecycle : defaultLifeCycles.getLifeCycles() )\n        {\n            org.apache.maven.lifecycle.mapping.Lifecycle lifecycleConfiguration =\n                lifecycleMappingForPackaging.getLifecycles().get( lifecycle.getId() );\n\n            Map<String, String> phaseToGoalMapping = null;\n\n            if ( lifecycleConfiguration != null )\n            {\n                phaseToGoalMapping = lifecycleConfiguration.getPhases();\n            }\n            else if ( lifecycle.getDefaultPhases() != null )\n            {\n                phaseToGoalMapping = lifecycle.getDefaultPhases();\n            }\n\n            if ( phaseToGoalMapping != null )\n            {\n                // These are of the form:\n                //\n                // compile -> org.apache.maven.plugins:maven-compiler-plugin:compile[,gid:aid:goal,...]\n                //\n                for ( Map.Entry<String, String> goalsForLifecyclePhase : phaseToGoalMapping.entrySet() )\n                {\n                    String phase = goalsForLifecyclePhase.getKey();\n                    String goals = goalsForLifecyclePhase.getValue();\n                    if ( goals != null )\n                    {\n                        parseLifecyclePhaseDefinitions( plugins, phase, goals );\n                    }\n                }\n            }\n        }\n\n        return plugins.keySet();\n    }","id":91587,"modified_method":"public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )\n    {\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( \"Looking up lifecyle mappings for packaging \" + packaging + \" from \" +\n                Thread.currentThread().getContextClassLoader() );\n        }\n\n        LifecycleMapping lifecycleMappingForPackaging = lifecycleMappings.get( packaging );\n\n        if ( lifecycleMappingForPackaging == null )\n        {\n            return null;\n        }\n\n        Map<Plugin, Plugin> plugins = new LinkedHashMap<Plugin, Plugin>();\n\n        for ( Lifecycle lifecycle : getOrderedLifecycles() )\n        {\n            org.apache.maven.lifecycle.mapping.Lifecycle lifecycleConfiguration =\n                lifecycleMappingForPackaging.getLifecycles().get( lifecycle.getId() );\n\n            Map<String, String> phaseToGoalMapping = null;\n\n            if ( lifecycleConfiguration != null )\n            {\n                phaseToGoalMapping = lifecycleConfiguration.getPhases();\n            }\n            else if ( lifecycle.getDefaultPhases() != null )\n            {\n                phaseToGoalMapping = lifecycle.getDefaultPhases();\n            }\n\n            if ( phaseToGoalMapping != null )\n            {\n                // These are of the form:\n                //\n                // compile -> org.apache.maven.plugins:maven-compiler-plugin:compile[,gid:aid:goal,...]\n                //\n                for ( Map.Entry<String, String> goalsForLifecyclePhase : phaseToGoalMapping.entrySet() )\n                {\n                    String phase = goalsForLifecyclePhase.getKey();\n                    String goals = goalsForLifecyclePhase.getValue();\n                    if ( goals != null )\n                    {\n                        parseLifecyclePhaseDefinitions( plugins, phase, goals );\n                    }\n                }\n            }\n        }\n\n        return plugins.keySet();\n    }","commit_id":"f288907e3340f051d0194295e2492bed10d1d85b","url":"https://github.com/apache/maven"},{"original_method":"private void parseLifecyclePhaseDefinitions( Map<Plugin, Plugin> plugins, String phase, String goals )\n    {\n        String[] mojos = StringUtils.split( goals, \",\" );\n\n        for ( int i = 0; i < mojos.length; i++ )\n        {\n            // either <groupId>:<artifactId>:<goal> or <groupId>:<artifactId>:<version>:<goal>\n            String goal = mojos[i].trim();\n            String[] p = StringUtils.split( goal, \":\" );\n\n            PluginExecution execution = new PluginExecution();\n            execution.setId( \"default-\" + p[p.length - 1] );\n            execution.setPhase( phase );\n            execution.setPriority( i - mojos.length );\n            execution.getGoals().add( p[p.length - 1] );\n\n            Plugin plugin = new Plugin();\n            plugin.setGroupId( p[0] );\n            plugin.setArtifactId( p[1] );\n            if ( p.length >= 4 )\n            {\n                plugin.setVersion( p[2] );\n            }\n\n            Plugin existing = plugins.get( plugin );\n            if ( existing != null )\n            {\n                if ( existing.getVersion() == null )\n                {\n                    existing.setVersion( plugin.getVersion() );\n                }\n                plugin = existing;\n            }\n            else\n            {\n                plugins.put( plugin, plugin );\n            }\n\n            plugin.getExecutions().add( execution );\n        }\n    }","id":91588,"modified_method":"private void parseLifecyclePhaseDefinitions( Map<Plugin, Plugin> plugins, String phase, String goals )\n    {\n        String[] mojos = StringUtils.split( goals, \",\" );\n\n        for ( int i = 0; i < mojos.length; i++ )\n        {\n            GoalSpec gs = parseGoalSpec( mojos[i].trim() );\n\n            if ( gs == null )\n            {\n                logger.warn( \"Ignored invalid goal specification '\" + mojos[i] + \"' from lifecycle mapping for phase \"\n                    + phase );\n                continue;\n            }\n\n            Plugin plugin = new Plugin();\n            plugin.setGroupId( gs.groupId );\n            plugin.setArtifactId( gs.artifactId );\n            plugin.setVersion( gs.version );\n\n            Plugin existing = plugins.get( plugin );\n            if ( existing != null )\n            {\n                if ( existing.getVersion() == null )\n                {\n                    existing.setVersion( plugin.getVersion() );\n                }\n                plugin = existing;\n            }\n            else\n            {\n                plugins.put( plugin, plugin );\n            }\n\n            PluginExecution execution = new PluginExecution();\n            execution.setId( getExecutionId( plugin, gs.goal ) );\n            execution.setPhase( phase );\n            execution.setPriority( i - mojos.length );\n            execution.getGoals().add( gs.goal );\n\n            plugin.getExecutions().add( execution );\n        }\n    }","commit_id":"f288907e3340f051d0194295e2492bed10d1d85b","url":"https://github.com/apache/maven"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Layout layout)\n\t\tthrows Exception {\n\n\t\tlong groupId = portletDataContext.getGroupId();\n\t\tlong userId = portletDataContext.getUserId(layout.getUserUuid());\n\n\t\tElement layoutElement =\n\t\t\tportletDataContext.getImportDataStagedModelElement(layout);\n\n\t\tString layoutUuid = GetterUtil.getString(\n\t\t\tlayoutElement.attributeValue(\"layout-uuid\"));\n\n\t\tlong layoutId = GetterUtil.getInteger(\n\t\t\tlayoutElement.attributeValue(\"layout-id\"));\n\n\t\tlong oldLayoutId = layoutId;\n\n\t\tboolean privateLayout = portletDataContext.isPrivateLayout();\n\n\t\tString action = layoutElement.attributeValue(Constants.ACTION);\n\n\t\tif (action.equals(Constants.DELETE)) {\n\t\t\tLayout deletingLayout =\n\t\t\t\tLayoutLocalServiceUtil.fetchLayoutByUuidAndGroupId(\n\t\t\t\t\tlayoutUuid, groupId, privateLayout);\n\n\t\t\tLayoutLocalServiceUtil.deleteLayout(\n\t\t\t\tdeletingLayout, false,\n\t\t\t\tServiceContextThreadLocal.getServiceContext());\n\n\t\t\treturn;\n\t\t}\n\n\t\tMap<Long, Layout> layouts =\n\t\t\t(Map<Long, Layout>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tLayout.class + \".layout\");\n\n\t\tLayout existingLayout = null;\n\t\tLayout importedLayout = null;\n\n\t\tString friendlyURL = layout.getFriendlyURL();\n\n\t\tString layoutsImportMode = MapUtil.getString(\n\t\t\tportletDataContext.getParameterMap(),\n\t\t\tPortletDataHandlerKeys.LAYOUTS_IMPORT_MODE,\n\t\t\tPortletDataHandlerKeys.LAYOUTS_IMPORT_MODE_MERGE_BY_LAYOUT_UUID);\n\n\t\tif (layoutsImportMode.equals(\n\t\t\t\tPortletDataHandlerKeys.LAYOUTS_IMPORT_MODE_ADD_AS_NEW)) {\n\n\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\tgroupId, privateLayout);\n\t\t\tfriendlyURL = StringPool.SLASH + layoutId;\n\t\t}\n\t\telse if (layoutsImportMode.equals(\n\t\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\t\tLAYOUTS_IMPORT_MODE_MERGE_BY_LAYOUT_NAME)) {\n\n\t\t\tLocale locale = LocaleUtil.getSiteDefault();\n\n\t\t\tString localizedName = layout.getName(locale);\n\n\t\t\tList<Layout> previousLayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\tgroupId, privateLayout);\n\n\t\t\tfor (Layout curLayout : previousLayouts) {\n\t\t\t\tif (localizedName.equals(curLayout.getName(locale)) ||\n\t\t\t\t\tfriendlyURL.equals(curLayout.getFriendlyURL())) {\n\n\t\t\t\t\texistingLayout = curLayout;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (existingLayout == null) {\n\t\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\t\tgroupId, privateLayout);\n\t\t\t}\n\t\t}\n\t\telse if (layoutsImportMode.equals(\n\t\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\t\tLAYOUTS_IMPORT_MODE_CREATED_FROM_PROTOTYPE)) {\n\n\t\t\texistingLayout = LayoutLocalServiceUtil.fetchLayoutByUuidAndGroupId(\n\t\t\t\tlayout.getUuid(), groupId, privateLayout);\n\n\t\t\tif (SitesUtil.isLayoutModifiedSinceLastMerge(existingLayout)) {\n\t\t\t\tlayouts.put(oldLayoutId, existingLayout);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tLayoutFriendlyURL layoutFriendlyURL =\n\t\t\t\tLayoutFriendlyURLLocalServiceUtil.fetchFirstLayoutFriendlyURL(\n\t\t\t\t\tgroupId, privateLayout, friendlyURL);\n\n\t\t\tif ((layoutFriendlyURL != null) && (existingLayout == null)) {\n\t\t\t\tLayout mergeFailFriendlyURLLayout =\n\t\t\t\t\tLayoutLocalServiceUtil.getLayout(\n\t\t\t\t\t\tlayoutFriendlyURL.getPlid());\n\n\t\t\t\tSitesUtil.addMergeFailFriendlyURLLayout(\n\t\t\t\t\tmergeFailFriendlyURLLayout);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// The default behaviour of import mode is\n\t\t\t// PortletDataHandlerKeys.LAYOUTS_IMPORT_MODE_MERGE_BY_LAYOUT_UUID\n\n\t\t\texistingLayout = LayoutLocalServiceUtil.fetchLayoutByUuidAndGroupId(\n\t\t\t\tlayout.getUuid(), groupId, privateLayout);\n\n\t\t\tif (existingLayout == null) {\n\t\t\t\texistingLayout =\n\t\t\t\t\tLayoutLocalServiceUtil.fetchLayoutByFriendlyURL(\n\t\t\t\t\t\tgroupId, privateLayout, friendlyURL);\n\t\t\t}\n\n\t\t\tif (existingLayout == null) {\n\t\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\t\tgroupId, privateLayout);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringBundler sb = new StringBundler(7);\n\n\t\t\tsb.append(\"Layout with {groupId=\");\n\t\t\tsb.append(groupId);\n\t\t\tsb.append(\",privateLayout=\");\n\t\t\tsb.append(privateLayout);\n\t\t\tsb.append(\",layoutId=\");\n\t\t\tsb.append(layoutId);\n\n\t\t\tif (existingLayout == null) {\n\t\t\t\tsb.append(\"} does not exist\");\n\n\t\t\t\t_log.debug(sb.toString());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\"} exists\");\n\n\t\t\t\t_log.debug(sb.toString());\n\t\t\t}\n\t\t}\n\n\t\tif (existingLayout == null) {\n\t\t\tlong plid = CounterLocalServiceUtil.increment();\n\n\t\t\timportedLayout = LayoutLocalServiceUtil.createLayout(plid);\n\n\t\t\tif (layoutsImportMode.equals(\n\t\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\t\tLAYOUTS_IMPORT_MODE_CREATED_FROM_PROTOTYPE)) {\n\n\t\t\t\timportedLayout.setSourcePrototypeLayoutUuid(layout.getUuid());\n\n\t\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\t\tgroupId, privateLayout);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedLayout.setCreateDate(layout.getCreateDate());\n\t\t\t\timportedLayout.setModifiedDate(layout.getModifiedDate());\n\t\t\t\timportedLayout.setLayoutPrototypeUuid(\n\t\t\t\t\tlayout.getLayoutPrototypeUuid());\n\t\t\t\timportedLayout.setLayoutPrototypeLinkEnabled(\n\t\t\t\t\tlayout.isLayoutPrototypeLinkEnabled());\n\t\t\t\timportedLayout.setSourcePrototypeLayoutUuid(\n\t\t\t\t\tlayout.getSourcePrototypeLayoutUuid());\n\t\t\t}\n\n\t\t\timportedLayout.setUuid(layout.getUuid());\n\t\t\timportedLayout.setGroupId(groupId);\n\t\t\timportedLayout.setUserId(userId);\n\t\t\timportedLayout.setPrivateLayout(privateLayout);\n\t\t\timportedLayout.setLayoutId(layoutId);\n\n\t\t\tinitNewLayoutPermissions(\n\t\t\t\tportletDataContext.getCompanyId(), groupId, userId, layout,\n\t\t\t\timportedLayout, privateLayout);\n\n\t\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\tgroupId, privateLayout);\n\n\t\t\timportedLayout.setLayoutSet(layoutSet);\n\t\t}\n\t\telse {\n\t\t\timportedLayout = existingLayout;\n\t\t}\n\n\t\tportletDataContext.setPlid(importedLayout.getPlid());\n\t\tportletDataContext.setOldPlid(layout.getPlid());\n\n\t\tlong parentLayoutId = layout.getParentLayoutId();\n\n\t\tString parentLayoutUuid = GetterUtil.getString(\n\t\t\tlayoutElement.attributeValue(\"parent-layout-uuid\"));\n\n\t\tElement parentLayoutElement =\n\t\t\tportletDataContext.getReferenceDataElement(\n\t\t\t\tlayout, Layout.class, layout.getGroupId(), parentLayoutUuid);\n\n\t\tif ((parentLayoutId != LayoutConstants.DEFAULT_PARENT_LAYOUT_ID) &&\n\t\t\t(parentLayoutElement != null)) {\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, parentLayoutElement);\n\n\t\t\tLayout importedParentLayout = layouts.get(parentLayoutId);\n\n\t\t\tparentLayoutId = importedParentLayout.getLayoutId();\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\tsb.append(\"Importing layout with layout id \");\n\t\t\tsb.append(layoutId);\n\t\t\tsb.append(\" and parent layout id \");\n\t\t\tsb.append(parentLayoutId);\n\n\t\t\t_log.debug(sb.toString());\n\t\t}\n\n\t\timportedLayout.setCompanyId(portletDataContext.getCompanyId());\n\t\timportedLayout.setParentLayoutId(parentLayoutId);\n\t\timportedLayout.setName(layout.getName());\n\t\timportedLayout.setTitle(layout.getTitle());\n\t\timportedLayout.setDescription(layout.getDescription());\n\t\timportedLayout.setKeywords(layout.getKeywords());\n\t\timportedLayout.setRobots(layout.getRobots());\n\t\timportedLayout.setType(layout.getType());\n\n\t\tString portletsMergeMode = MapUtil.getString(\n\t\t\tportletDataContext.getParameterMap(),\n\t\t\tPortletDataHandlerKeys.PORTLETS_MERGE_MODE,\n\t\t\tPortletDataHandlerKeys.PORTLETS_MERGE_MODE_REPLACE);\n\n\t\tif (layout.isTypeArticle()) {\n\t\t\timportJournalArticle(portletDataContext, layout);\n\n\t\t\tupdateTypeSettings(importedLayout, layout);\n\t\t}\n\t\telse if (layout.isTypePortlet() &&\n\t\t\t\t Validator.isNotNull(layout.getTypeSettings()) &&\n\t\t\t\t !portletsMergeMode.equals(\n\t\t\t\t\t PortletDataHandlerKeys.PORTLETS_MERGE_MODE_REPLACE)) {\n\n\t\t\tmergePortlets(\n\t\t\t\timportedLayout, layout.getTypeSettings(), portletsMergeMode);\n\t\t}\n\t\telse if (layout.isTypeLinkToLayout()) {\n\t\t\timportLinkedLayout(\n\t\t\t\tportletDataContext, layout, importedLayout, layoutElement,\n\t\t\t\tlayouts);\n\t\t}\n\t\telse {\n\t\t\tupdateTypeSettings(importedLayout, layout);\n\t\t}\n\n\t\timportedLayout.setHidden(layout.isHidden());\n\t\timportedLayout.setFriendlyURL(\n\t\t\tgetUniqueFriendlyURL(\n\t\t\t\tportletDataContext, importedLayout, friendlyURL));\n\n\t\tif (layout.getIconImageId() > 0) {\n\t\t\timportLayoutIconImage(\n\t\t\t\tportletDataContext, importedLayout, layoutElement);\n\t\t}\n\t\telse if (importedLayout.getIconImageId() > 0) {\n\t\t\tImageLocalServiceUtil.deleteImage(importedLayout.getIconImageId());\n\t\t}\n\n\t\tint priority = _layoutLocalServiceHelper.getNextPriority(\n\t\t\tgroupId, privateLayout, parentLayoutId, null, -1);\n\n\t\timportedLayout.setPriority(priority);\n\t\timportedLayout.setLayoutPrototypeUuid(layout.getLayoutPrototypeUuid());\n\t\timportedLayout.setLayoutPrototypeLinkEnabled(\n\t\t\tlayout.isLayoutPrototypeLinkEnabled());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tlayout);\n\n\t\timportedLayout.setExpandoBridgeAttributes(serviceContext);\n\n\t\tStagingUtil.updateLastImportSettings(\n\t\t\tlayoutElement, importedLayout, portletDataContext);\n\n\t\tfixImportTypeSettings(importedLayout);\n\n\t\timportTheme(portletDataContext, layout, importedLayout);\n\n\t\tLayoutLocalServiceUtil.updateLayout(importedLayout);\n\n\t\tLayoutSetLocalServiceUtil.updatePageCount(groupId, privateLayout);\n\n\t\tMap<Long, Long> layoutPlids =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tLayout.class);\n\n\t\tlayoutPlids.put(layout.getPlid(), importedLayout.getPlid());\n\n\t\tlayouts.put(oldLayoutId, importedLayout);\n\n\t\timportAssets(portletDataContext, layout, importedLayout);\n\n\t\timportLayoutFriendlyURLs(portletDataContext, layout);\n\n\t\tportletDataContext.importClassedModel(layout, importedLayout);\n\t}","id":91589,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Layout layout)\n\t\tthrows Exception {\n\n\t\tlong groupId = portletDataContext.getGroupId();\n\t\tlong userId = portletDataContext.getUserId(layout.getUserUuid());\n\n\t\tElement layoutElement =\n\t\t\tportletDataContext.getImportDataStagedModelElement(layout);\n\n\t\tString layoutUuid = GetterUtil.getString(\n\t\t\tlayoutElement.attributeValue(\"layout-uuid\"));\n\n\t\tlong layoutId = GetterUtil.getInteger(\n\t\t\tlayoutElement.attributeValue(\"layout-id\"));\n\n\t\tlong oldLayoutId = layoutId;\n\n\t\tboolean privateLayout = portletDataContext.isPrivateLayout();\n\n\t\tString action = layoutElement.attributeValue(Constants.ACTION);\n\n\t\tif (action.equals(Constants.DELETE)) {\n\t\t\tLayout deletingLayout =\n\t\t\t\tLayoutLocalServiceUtil.fetchLayoutByUuidAndGroupId(\n\t\t\t\t\tlayoutUuid, groupId, privateLayout);\n\n\t\t\tLayoutLocalServiceUtil.deleteLayout(\n\t\t\t\tdeletingLayout, false,\n\t\t\t\tServiceContextThreadLocal.getServiceContext());\n\n\t\t\treturn;\n\t\t}\n\n\t\tMap<Long, Layout> layouts =\n\t\t\t(Map<Long, Layout>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tLayout.class + \".layout\");\n\n\t\tLayout existingLayout = null;\n\t\tLayout importedLayout = null;\n\n\t\tString friendlyURL = layout.getFriendlyURL();\n\n\t\tString layoutsImportMode = MapUtil.getString(\n\t\t\tportletDataContext.getParameterMap(),\n\t\t\tPortletDataHandlerKeys.LAYOUTS_IMPORT_MODE,\n\t\t\tPortletDataHandlerKeys.LAYOUTS_IMPORT_MODE_MERGE_BY_LAYOUT_UUID);\n\n\t\tif (layoutsImportMode.equals(\n\t\t\t\tPortletDataHandlerKeys.LAYOUTS_IMPORT_MODE_ADD_AS_NEW)) {\n\n\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\tgroupId, privateLayout);\n\t\t\tfriendlyURL = StringPool.SLASH + layoutId;\n\t\t}\n\t\telse if (layoutsImportMode.equals(\n\t\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\t\tLAYOUTS_IMPORT_MODE_MERGE_BY_LAYOUT_NAME)) {\n\n\t\t\tLocale locale = LocaleUtil.getSiteDefault();\n\n\t\t\tString localizedName = layout.getName(locale);\n\n\t\t\tList<Layout> previousLayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\tgroupId, privateLayout);\n\n\t\t\tfor (Layout curLayout : previousLayouts) {\n\t\t\t\tif (localizedName.equals(curLayout.getName(locale)) ||\n\t\t\t\t\tfriendlyURL.equals(curLayout.getFriendlyURL())) {\n\n\t\t\t\t\texistingLayout = curLayout;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (existingLayout == null) {\n\t\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\t\tgroupId, privateLayout);\n\t\t\t}\n\t\t}\n\t\telse if (layoutsImportMode.equals(\n\t\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\t\tLAYOUTS_IMPORT_MODE_CREATED_FROM_PROTOTYPE)) {\n\n\t\t\texistingLayout = LayoutLocalServiceUtil.fetchLayoutByUuidAndGroupId(\n\t\t\t\tlayout.getUuid(), groupId, privateLayout);\n\n\t\t\tif (SitesUtil.isLayoutModifiedSinceLastMerge(existingLayout)) {\n\t\t\t\tlayouts.put(oldLayoutId, existingLayout);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tLayoutFriendlyURL layoutFriendlyURL =\n\t\t\t\tLayoutFriendlyURLLocalServiceUtil.fetchFirstLayoutFriendlyURL(\n\t\t\t\t\tgroupId, privateLayout, friendlyURL);\n\n\t\t\tif ((layoutFriendlyURL != null) && (existingLayout == null)) {\n\t\t\t\tLayout mergeFailFriendlyURLLayout =\n\t\t\t\t\tLayoutLocalServiceUtil.getLayout(\n\t\t\t\t\t\tlayoutFriendlyURL.getPlid());\n\n\t\t\t\tSitesUtil.addMergeFailFriendlyURLLayout(\n\t\t\t\t\tmergeFailFriendlyURLLayout);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// The default behaviour of import mode is\n\t\t\t// PortletDataHandlerKeys.LAYOUTS_IMPORT_MODE_MERGE_BY_LAYOUT_UUID\n\n\t\t\texistingLayout = LayoutLocalServiceUtil.fetchLayoutByUuidAndGroupId(\n\t\t\t\tlayout.getUuid(), groupId, privateLayout);\n\n\t\t\tif (existingLayout == null) {\n\t\t\t\texistingLayout =\n\t\t\t\t\tLayoutLocalServiceUtil.fetchLayoutByFriendlyURL(\n\t\t\t\t\t\tgroupId, privateLayout, friendlyURL);\n\t\t\t}\n\n\t\t\tif (existingLayout == null) {\n\t\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\t\tgroupId, privateLayout);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringBundler sb = new StringBundler(7);\n\n\t\t\tsb.append(\"Layout with {groupId=\");\n\t\t\tsb.append(groupId);\n\t\t\tsb.append(\",privateLayout=\");\n\t\t\tsb.append(privateLayout);\n\t\t\tsb.append(\",layoutId=\");\n\t\t\tsb.append(layoutId);\n\n\t\t\tif (existingLayout == null) {\n\t\t\t\tsb.append(\"} does not exist\");\n\n\t\t\t\t_log.debug(sb.toString());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\"} exists\");\n\n\t\t\t\t_log.debug(sb.toString());\n\t\t\t}\n\t\t}\n\n\t\tif (existingLayout == null) {\n\t\t\tlong plid = CounterLocalServiceUtil.increment();\n\n\t\t\timportedLayout = LayoutLocalServiceUtil.createLayout(plid);\n\n\t\t\tif (layoutsImportMode.equals(\n\t\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\t\tLAYOUTS_IMPORT_MODE_CREATED_FROM_PROTOTYPE)) {\n\n\t\t\t\timportedLayout.setSourcePrototypeLayoutUuid(layout.getUuid());\n\n\t\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\t\tgroupId, privateLayout);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedLayout.setCreateDate(layout.getCreateDate());\n\t\t\t\timportedLayout.setModifiedDate(layout.getModifiedDate());\n\t\t\t\timportedLayout.setLayoutPrototypeUuid(\n\t\t\t\t\tlayout.getLayoutPrototypeUuid());\n\t\t\t\timportedLayout.setLayoutPrototypeLinkEnabled(\n\t\t\t\t\tlayout.isLayoutPrototypeLinkEnabled());\n\t\t\t\timportedLayout.setSourcePrototypeLayoutUuid(\n\t\t\t\t\tlayout.getSourcePrototypeLayoutUuid());\n\t\t\t}\n\n\t\t\timportedLayout.setUuid(layout.getUuid());\n\t\t\timportedLayout.setGroupId(groupId);\n\t\t\timportedLayout.setUserId(userId);\n\t\t\timportedLayout.setPrivateLayout(privateLayout);\n\t\t\timportedLayout.setLayoutId(layoutId);\n\n\t\t\tinitNewLayoutPermissions(\n\t\t\t\tportletDataContext.getCompanyId(), groupId, userId, layout,\n\t\t\t\timportedLayout, privateLayout);\n\n\t\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\tgroupId, privateLayout);\n\n\t\t\timportedLayout.setLayoutSet(layoutSet);\n\t\t}\n\t\telse {\n\t\t\timportedLayout = existingLayout;\n\t\t}\n\n\t\tportletDataContext.setPlid(importedLayout.getPlid());\n\t\tportletDataContext.setOldPlid(layout.getPlid());\n\n\t\tlong parentLayoutId = layout.getParentLayoutId();\n\n\t\tString parentLayoutUuid = GetterUtil.getString(\n\t\t\tlayoutElement.attributeValue(\"parent-layout-uuid\"));\n\n\t\tElement parentLayoutElement =\n\t\t\tportletDataContext.getReferenceDataElement(\n\t\t\t\tlayout, Layout.class, layout.getGroupId(), parentLayoutUuid);\n\n\t\tif ((parentLayoutId != LayoutConstants.DEFAULT_PARENT_LAYOUT_ID) &&\n\t\t\t(parentLayoutElement != null)) {\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, parentLayoutElement);\n\n\t\t\tLayout importedParentLayout = layouts.get(parentLayoutId);\n\n\t\t\tparentLayoutId = importedParentLayout.getLayoutId();\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\tsb.append(\"Importing layout with layout id \");\n\t\t\tsb.append(layoutId);\n\t\t\tsb.append(\" and parent layout id \");\n\t\t\tsb.append(parentLayoutId);\n\n\t\t\t_log.debug(sb.toString());\n\t\t}\n\n\t\timportedLayout.setCompanyId(portletDataContext.getCompanyId());\n\t\timportedLayout.setParentLayoutId(parentLayoutId);\n\t\timportedLayout.setName(layout.getName());\n\t\timportedLayout.setTitle(layout.getTitle());\n\t\timportedLayout.setDescription(layout.getDescription());\n\t\timportedLayout.setKeywords(layout.getKeywords());\n\t\timportedLayout.setRobots(layout.getRobots());\n\t\timportedLayout.setType(layout.getType());\n\n\t\tString portletsMergeMode = MapUtil.getString(\n\t\t\tportletDataContext.getParameterMap(),\n\t\t\tPortletDataHandlerKeys.PORTLETS_MERGE_MODE,\n\t\t\tPortletDataHandlerKeys.PORTLETS_MERGE_MODE_REPLACE);\n\n\t\tif (layout.isTypeArticle()) {\n\t\t\timportJournalArticle(portletDataContext, layout);\n\n\t\t\tupdateTypeSettings(importedLayout, layout);\n\t\t}\n\t\telse if (layout.isTypePortlet() &&\n\t\t\t\t Validator.isNotNull(layout.getTypeSettings()) &&\n\t\t\t\t !portletsMergeMode.equals(\n\t\t\t\t\t PortletDataHandlerKeys.PORTLETS_MERGE_MODE_REPLACE)) {\n\n\t\t\tmergePortlets(\n\t\t\t\timportedLayout, layout.getTypeSettings(), portletsMergeMode);\n\t\t}\n\t\telse if (layout.isTypeLinkToLayout()) {\n\t\t\timportLinkedLayout(\n\t\t\t\tportletDataContext, layout, importedLayout, layoutElement,\n\t\t\t\tlayouts);\n\t\t}\n\t\telse {\n\t\t\tupdateTypeSettings(importedLayout, layout);\n\t\t}\n\n\t\timportedLayout.setHidden(layout.isHidden());\n\t\timportedLayout.setFriendlyURL(\n\t\t\tgetUniqueFriendlyURL(\n\t\t\t\tportletDataContext, importedLayout, friendlyURL));\n\n\t\tif (layout.getIconImageId() > 0) {\n\t\t\timportLayoutIconImage(\n\t\t\t\tportletDataContext, importedLayout, layoutElement);\n\t\t}\n\t\telse if (importedLayout.getIconImageId() > 0) {\n\t\t\tImageLocalServiceUtil.deleteImage(importedLayout.getIconImageId());\n\t\t}\n\n\t\tif (existingLayout == null) {\n\t\t\tint priority = _layoutLocalServiceHelper.getNextPriority(\n\t\t\t\tgroupId, privateLayout, parentLayoutId, null, -1);\n\n\t\t\timportedLayout.setPriority(priority);\n\t\t}\n\n\t\timportedLayout.setLayoutPrototypeUuid(layout.getLayoutPrototypeUuid());\n\t\timportedLayout.setLayoutPrototypeLinkEnabled(\n\t\t\tlayout.isLayoutPrototypeLinkEnabled());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tlayout);\n\n\t\timportedLayout.setExpandoBridgeAttributes(serviceContext);\n\n\t\tStagingUtil.updateLastImportSettings(\n\t\t\tlayoutElement, importedLayout, portletDataContext);\n\n\t\tfixImportTypeSettings(importedLayout);\n\n\t\timportTheme(portletDataContext, layout, importedLayout);\n\n\t\tLayoutLocalServiceUtil.updateLayout(importedLayout);\n\n\t\tLayoutSetLocalServiceUtil.updatePageCount(groupId, privateLayout);\n\n\t\tMap<Long, Long> layoutPlids =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tLayout.class);\n\n\t\tlayoutPlids.put(layout.getPlid(), importedLayout.getPlid());\n\n\t\tlayouts.put(oldLayoutId, importedLayout);\n\n\t\timportAssets(portletDataContext, layout, importedLayout);\n\n\t\timportLayoutFriendlyURLs(portletDataContext, layout);\n\n\t\tportletDataContext.importClassedModel(layout, importedLayout);\n\t}","commit_id":"e977fcc253c937515b0cf3544ef10e4215a68357","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Bean\n\tpublic ThreadPoolTaskExecutor brokerChannelExecutor() {\n\t\tTaskExecutorRegistration r = getBrokerRegistry().getBrokerChannelRegistration().getTaskExecutorRegistration();\n\t\tThreadPoolTaskExecutor executor = (r != null) ? r.getTaskExecutor() : new ThreadPoolTaskExecutor();\n\t\texecutor.setThreadNamePrefix(\"brokerChannel-\");\n\t\treturn executor;\n\t}","id":91590,"modified_method":"@Bean\n\tpublic ThreadPoolTaskExecutor brokerChannelExecutor() {\n\t\tChannelRegistration reg = getBrokerRegistry().getBrokerChannelRegistration();\n\t\tThreadPoolTaskExecutor executor;\n\t\tif (reg.hasTaskExecutor()) {\n\t\t\texecutor = reg.taskExecutor().getTaskExecutor();\n\t\t}\n\t\telse {\n\t\t\t// Should never be used\n\t\t\texecutor = new ThreadPoolTaskExecutor();\n\t\t\texecutor.setCorePoolSize(0);\n\t\t\texecutor.setMaxPoolSize(1);\n\t\t\texecutor.setQueueCapacity(0);\n\t\t}\n\t\texecutor.setThreadNamePrefix(\"brokerChannel-\");\n\t\treturn executor;\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Bean\n\tpublic AbstractSubscribableChannel brokerChannel() {\n\t\tChannelRegistration r = getBrokerRegistry().getBrokerChannelRegistration();\n\t\tExecutorSubscribableChannel channel;\n\t\tif (r.hasTaskExecutor()) {\n\t\t\tchannel = new ExecutorSubscribableChannel(); // synchronous by default\n\t\t}\n\t\telse {\n\t\t\tchannel = new ExecutorSubscribableChannel(brokerChannelExecutor());\n\t\t}\n\t\tif (r.hasInterceptors()) {\n\t\t\tchannel.setInterceptors(r.getInterceptors());\n\t\t}\n\t\treturn channel;\n\t}","id":91591,"modified_method":"@Bean\n\tpublic AbstractSubscribableChannel brokerChannel() {\n\t\tChannelRegistration reg = getBrokerRegistry().getBrokerChannelRegistration();\n\t\tExecutorSubscribableChannel channel = reg.hasTaskExecutor() ?\n\t\t\t\tnew ExecutorSubscribableChannel(brokerChannelExecutor()) : new ExecutorSubscribableChannel();\n\t\tchannel.setInterceptors(reg.getInterceptors());\n\t\treturn channel;\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Bean\n\tpublic ThreadPoolTaskExecutor clientOutboundChannelExecutor() {\n\t\tTaskExecutorRegistration r = getClientOutboundChannelRegistration().getTaskExecutorRegistration();\n\t\tThreadPoolTaskExecutor executor = (r != null) ? r.getTaskExecutor() : new ThreadPoolTaskExecutor();\n\t\texecutor.setThreadNamePrefix(\"clientOutboundChannel-\");\n\t\treturn executor;\n\t}","id":91592,"modified_method":"@Bean\n\tpublic ThreadPoolTaskExecutor clientOutboundChannelExecutor() {\n\t\tTaskExecutorRegistration reg = getClientOutboundChannelRegistration().getOrCreateTaskExecRegistration();\n\t\tThreadPoolTaskExecutor executor = reg.getTaskExecutor();\n\t\texecutor.setThreadNamePrefix(\"clientOutboundChannel-\");\n\t\treturn executor;\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Bean\n\tpublic AbstractSubscribableChannel clientInboundChannel() {\n\t\tExecutorSubscribableChannel channel = new ExecutorSubscribableChannel(clientInboundChannelExecutor());\n\t\tChannelRegistration r = getClientInboundChannelRegistration();\n\t\tif (r.hasInterceptors()) {\n\t\t\tchannel.setInterceptors(r.getInterceptors());\n\t\t}\n\t\treturn channel;\n\t}","id":91593,"modified_method":"@Bean\n\tpublic AbstractSubscribableChannel clientInboundChannel() {\n\t\tExecutorSubscribableChannel channel = new ExecutorSubscribableChannel(clientInboundChannelExecutor());\n\t\tChannelRegistration reg = getClientInboundChannelRegistration();\n\t\tchannel.setInterceptors(reg.getInterceptors());\n\t\treturn channel;\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Bean\n\tpublic AbstractSubscribableChannel clientOutboundChannel() {\n\t\tExecutorSubscribableChannel channel = new ExecutorSubscribableChannel(clientOutboundChannelExecutor());\n\t\tChannelRegistration r = getClientOutboundChannelRegistration();\n\t\tif (r.hasInterceptors()) {\n\t\t\tchannel.setInterceptors(r.getInterceptors());\n\t\t}\n\t\treturn channel;\n\t}","id":91594,"modified_method":"@Bean\n\tpublic AbstractSubscribableChannel clientOutboundChannel() {\n\t\tExecutorSubscribableChannel channel = new ExecutorSubscribableChannel(clientOutboundChannelExecutor());\n\t\tChannelRegistration reg = getClientOutboundChannelRegistration();\n\t\tchannel.setInterceptors(reg.getInterceptors());\n\t\treturn channel;\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Bean\n\tpublic ThreadPoolTaskExecutor clientInboundChannelExecutor() {\n\t\tTaskExecutorRegistration r = getClientInboundChannelRegistration().getTaskExecutorRegistration();\n\t\tThreadPoolTaskExecutor executor = (r != null) ? r.getTaskExecutor() : new ThreadPoolTaskExecutor();\n\t\texecutor.setThreadNamePrefix(\"clientInboundChannel-\");\n\t\treturn executor;\n\t}","id":91595,"modified_method":"@Bean\n\tpublic ThreadPoolTaskExecutor clientInboundChannelExecutor() {\n\t\tTaskExecutorRegistration reg = getClientInboundChannelRegistration().getOrCreateTaskExecRegistration();\n\t\tThreadPoolTaskExecutor executor = reg.getTaskExecutor();\n\t\texecutor.setThreadNamePrefix(\"clientInboundChannel-\");\n\t\treturn executor;\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected TaskExecutorRegistration getTaskExecutorRegistration() {\n\t\treturn this.taskExecutorRegistration;\n\t}","id":91596,"modified_method":"protected TaskExecutorRegistration getTaskExecRegistration() {\n\t\treturn this.registration;\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected boolean hasTaskExecutor() {\n\t\treturn (this.taskExecutorRegistration != null);\n\t}","id":91597,"modified_method":"protected boolean hasTaskExecutor() {\n\t\treturn (this.registration != null);\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Configure properties of the ThreadPoolTaskExecutor backing the message channel.\n\t */\n\tpublic TaskExecutorRegistration taskExecutor() {\n\t\tthis.taskExecutorRegistration = new TaskExecutorRegistration();\n\t\treturn this.taskExecutorRegistration;\n\t}","id":91598,"modified_method":"/**\n\t * Configure the thread pool backing this message channel.\n\t */\n\tpublic TaskExecutorRegistration taskExecutor() {\n\t\tif (this.registration == null) {\n\t\t\tthis.registration = new TaskExecutorRegistration();\n\t\t}\n\t\treturn this.registration;\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private RuntimeBeanReference getMessageChannel(String channelName, Element channelElement,\n\t\t\tParserContext parserCxt, Object source) {\n\n\t\tRootBeanDefinition executorDef = null;\n\n\t\tif (channelElement != null) {\n\t\t\tElement executor = DomUtils.getChildElementByTagName(channelElement, \"executor\");\n\t\t\tif (executor != null) {\n\t\t\t\texecutorDef = new RootBeanDefinition(ThreadPoolTaskExecutor.class);\n\t\t\t\tString attrValue = executor.getAttribute(\"core-pool-size\");\n\t\t\t\tif (!StringUtils.isEmpty(attrValue)) {\n\t\t\t\t\texecutorDef.getPropertyValues().add(\"corePoolSize\", attrValue);\n\t\t\t\t}\n\t\t\t\tattrValue = executor.getAttribute(\"max-pool-size\");\n\t\t\t\tif (!StringUtils.isEmpty(attrValue)) {\n\t\t\t\t\texecutorDef.getPropertyValues().add(\"maxPoolSize\", attrValue);\n\t\t\t\t}\n\t\t\t\tattrValue = executor.getAttribute(\"keep-alive-seconds\");\n\t\t\t\tif (!StringUtils.isEmpty(attrValue)) {\n\t\t\t\t\texecutorDef.getPropertyValues().add(\"keepAliveSeconds\", attrValue);\n\t\t\t\t}\n\t\t\t\tattrValue = executor.getAttribute(\"queue-capacity\");\n\t\t\t\tif (!StringUtils.isEmpty(attrValue)) {\n\t\t\t\t\texecutorDef.getPropertyValues().add(\"queueCapacity\", attrValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!channelName.equals(\"brokerChannel\")) {\n\t\t\texecutorDef = new RootBeanDefinition(ThreadPoolTaskExecutor.class);\n\t\t}\n\n\t\tConstructorArgumentValues values = new ConstructorArgumentValues();\n\t\tif (executorDef != null) {\n\t\t\texecutorDef.getPropertyValues().add(\"threadNamePrefix\", channelName + \"-\");\n\t\t\tString executorName = channelName + \"Executor\";\n\t\t\tregisterBeanDefByName(executorName, executorDef, parserCxt, source);\n\t\t\tvalues.addIndexedArgumentValue(0, new RuntimeBeanReference(executorName));\n\t\t}\n\n\t\tRootBeanDefinition channelDef = new RootBeanDefinition(ExecutorSubscribableChannel.class, values, null);\n\n\t\tif (channelElement != null) {\n\t\t\tElement interceptorsElement = DomUtils.getChildElementByTagName(channelElement, \"interceptors\");\n\t\t\tManagedList<?> interceptorList = WebSocketNamespaceUtils.parseBeanSubElements(interceptorsElement, parserCxt);\n\t\t\tchannelDef.getPropertyValues().add(\"interceptors\", interceptorList);\n\t\t}\n\n\t\tregisterBeanDefByName(channelName, channelDef, parserCxt, source);\n\t\treturn new RuntimeBeanReference(channelName);\n\t}","id":91599,"modified_method":"private RuntimeBeanReference getMessageChannel(String channelName, Element channelElement,\n\t\t\tParserContext parserCxt, Object source) {\n\n\t\tRootBeanDefinition executorDef = null;\n\n\t\tif (channelElement != null) {\n\t\t\tElement executor = DomUtils.getChildElementByTagName(channelElement, \"executor\");\n\t\t\tif (executor != null) {\n\t\t\t\texecutorDef = new RootBeanDefinition(ThreadPoolTaskExecutor.class);\n\t\t\t\tString attrValue = executor.getAttribute(\"core-pool-size\");\n\t\t\t\tif (!StringUtils.isEmpty(attrValue)) {\n\t\t\t\t\texecutorDef.getPropertyValues().add(\"corePoolSize\", attrValue);\n\t\t\t\t}\n\t\t\t\tattrValue = executor.getAttribute(\"max-pool-size\");\n\t\t\t\tif (!StringUtils.isEmpty(attrValue)) {\n\t\t\t\t\texecutorDef.getPropertyValues().add(\"maxPoolSize\", attrValue);\n\t\t\t\t}\n\t\t\t\tattrValue = executor.getAttribute(\"keep-alive-seconds\");\n\t\t\t\tif (!StringUtils.isEmpty(attrValue)) {\n\t\t\t\t\texecutorDef.getPropertyValues().add(\"keepAliveSeconds\", attrValue);\n\t\t\t\t}\n\t\t\t\tattrValue = executor.getAttribute(\"queue-capacity\");\n\t\t\t\tif (!StringUtils.isEmpty(attrValue)) {\n\t\t\t\t\texecutorDef.getPropertyValues().add(\"queueCapacity\", attrValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!channelName.equals(\"brokerChannel\")) {\n\t\t\texecutorDef = new RootBeanDefinition(ThreadPoolTaskExecutor.class);\n\t\t\texecutorDef.getPropertyValues().add(\"corePoolSize\", Runtime.getRuntime().availableProcessors() * 2);\n\t\t\texecutorDef.getPropertyValues().add(\"maxPoolSize\", Integer.MAX_VALUE);\n\t\t\texecutorDef.getPropertyValues().add(\"queueCapacity\", Integer.MAX_VALUE);\n\t\t}\n\n\t\tConstructorArgumentValues values = new ConstructorArgumentValues();\n\t\tif (executorDef != null) {\n\t\t\texecutorDef.getPropertyValues().add(\"threadNamePrefix\", channelName + \"-\");\n\t\t\tString executorName = channelName + \"Executor\";\n\t\t\tregisterBeanDefByName(executorName, executorDef, parserCxt, source);\n\t\t\tvalues.addIndexedArgumentValue(0, new RuntimeBeanReference(executorName));\n\t\t}\n\n\t\tRootBeanDefinition channelDef = new RootBeanDefinition(ExecutorSubscribableChannel.class, values, null);\n\n\t\tif (channelElement != null) {\n\t\t\tElement interceptorsElement = DomUtils.getChildElementByTagName(channelElement, \"interceptors\");\n\t\t\tManagedList<?> interceptorList = WebSocketNamespaceUtils.parseBeanSubElements(interceptorsElement, parserCxt);\n\t\t\tchannelDef.getPropertyValues().add(\"interceptors\", interceptorList);\n\t\t}\n\n\t\tregisterBeanDefByName(channelName, channelDef, parserCxt, source);\n\t\treturn new RuntimeBeanReference(channelName);\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void simpleBroker() {\n\t\tloadBeanDefinitions(\"websocket-config-broker-simple.xml\");\n\n\t\tHandlerMapping hm = this.appContext.getBean(HandlerMapping.class);\n\t\tassertNotNull(hm);\n\t\tassertThat(hm, Matchers.instanceOf(SimpleUrlHandlerMapping.class));\n\n\t\tSimpleUrlHandlerMapping suhm = (SimpleUrlHandlerMapping) hm;\n\t\tassertThat(suhm.getUrlMap().keySet(), Matchers.hasSize(4));\n\t\tassertThat(suhm.getUrlMap().values(), Matchers.hasSize(4));\n\n\t\tHttpRequestHandler httpRequestHandler = (HttpRequestHandler) suhm.getUrlMap().get(\"/foo\");\n\t\tassertNotNull(httpRequestHandler);\n\t\tassertThat(httpRequestHandler, Matchers.instanceOf(WebSocketHttpRequestHandler.class));\n\n\t\tWebSocketHttpRequestHandler wsHttpRequestHandler = (WebSocketHttpRequestHandler) httpRequestHandler;\n\t\tWebSocketHandler wsHandler = unwrapWebSocketHandler(wsHttpRequestHandler.getWebSocketHandler());\n\t\tassertNotNull(wsHandler);\n\t\tassertThat(wsHandler, Matchers.instanceOf(SubProtocolWebSocketHandler.class));\n\n\t\tSubProtocolWebSocketHandler subProtocolWsHandler = (SubProtocolWebSocketHandler) wsHandler;\n\t\tassertEquals(Arrays.asList(\"v10.stomp\", \"v11.stomp\", \"v12.stomp\"), subProtocolWsHandler.getSubProtocols());\n\n\t\tStompSubProtocolHandler stompHandler =\n\t\t\t\t(StompSubProtocolHandler) subProtocolWsHandler.getProtocolHandlerMap().get(\"v12.stomp\");\n\t\tassertNotNull(stompHandler);\n\n\t\thttpRequestHandler = (HttpRequestHandler) suhm.getUrlMap().get(\"/test/**\");\n\t\tassertNotNull(httpRequestHandler);\n\t\tassertThat(httpRequestHandler, Matchers.instanceOf(SockJsHttpRequestHandler.class));\n\n\t\tSockJsHttpRequestHandler sockJsHttpRequestHandler = (SockJsHttpRequestHandler) httpRequestHandler;\n\t\twsHandler = unwrapWebSocketHandler(sockJsHttpRequestHandler.getWebSocketHandler());\n\t\tassertNotNull(wsHandler);\n\t\tassertThat(wsHandler, Matchers.instanceOf(SubProtocolWebSocketHandler.class));\n\t\tassertNotNull(sockJsHttpRequestHandler.getSockJsService());\n\n\t\tUserSessionRegistry userSessionRegistry = this.appContext.getBean(UserSessionRegistry.class);\n\t\tassertNotNull(userSessionRegistry);\n\n\t\tUserDestinationResolver userDestResolver = this.appContext.getBean(UserDestinationResolver.class);\n\t\tassertNotNull(userDestResolver);\n\t\tassertThat(userDestResolver, Matchers.instanceOf(DefaultUserDestinationResolver.class));\n\t\tDefaultUserDestinationResolver defaultUserDestResolver = (DefaultUserDestinationResolver) userDestResolver;\n\t\tassertEquals(\"/personal/\", defaultUserDestResolver.getDestinationPrefix());\n\t\tassertSame(stompHandler.getUserSessionRegistry(), defaultUserDestResolver.getUserSessionRegistry());\n\n\t\tUserDestinationMessageHandler userDestHandler = this.appContext.getBean(UserDestinationMessageHandler.class);\n\t\tassertNotNull(userDestHandler);\n\n\t\tSimpleBrokerMessageHandler brokerMessageHandler = this.appContext.getBean(SimpleBrokerMessageHandler.class);\n\t\tassertNotNull(brokerMessageHandler);\n\t\tassertEquals(Arrays.asList(\"/topic\", \"/queue\"),\n\t\t\t\tnew ArrayList<String>(brokerMessageHandler.getDestinationPrefixes()));\n\n\t\tList<Class<? extends MessageHandler>> subscriberTypes =\n\t\t\t\tArrays.<Class<? extends MessageHandler>>asList(SimpAnnotationMethodMessageHandler.class,\n\t\t\t\t\t\tUserDestinationMessageHandler.class, SimpleBrokerMessageHandler.class);\n\t\ttestChannel(\"clientInboundChannel\", subscriberTypes, 0);\n\t\ttestExecutor(\"clientInboundChannel\", 1, Integer.MAX_VALUE, 60);\n\n\t\tsubscriberTypes = Arrays.<Class<? extends MessageHandler>>asList(SubProtocolWebSocketHandler.class);\n\t\ttestChannel(\"clientOutboundChannel\", subscriberTypes, 0);\n\t\ttestExecutor(\"clientOutboundChannel\", 1, Integer.MAX_VALUE, 60);\n\n\t\tsubscriberTypes = Arrays.<Class<? extends MessageHandler>>asList(\n\t\t\t\tSimpleBrokerMessageHandler.class, UserDestinationMessageHandler.class);\n\t\ttestChannel(\"brokerChannel\", subscriberTypes, 0);\n\t\ttry {\n\t\t\tthis.appContext.getBean(\"brokerChannelExecutor\", ThreadPoolTaskExecutor.class);\n\t\t\tfail(\"expected exception\");\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// expected\n\t\t}\n\t}","id":91600,"modified_method":"@Test\n\tpublic void simpleBroker() {\n\t\tloadBeanDefinitions(\"websocket-config-broker-simple.xml\");\n\n\t\tHandlerMapping hm = this.appContext.getBean(HandlerMapping.class);\n\t\tassertNotNull(hm);\n\t\tassertThat(hm, Matchers.instanceOf(SimpleUrlHandlerMapping.class));\n\n\t\tSimpleUrlHandlerMapping suhm = (SimpleUrlHandlerMapping) hm;\n\t\tassertThat(suhm.getUrlMap().keySet(), Matchers.hasSize(4));\n\t\tassertThat(suhm.getUrlMap().values(), Matchers.hasSize(4));\n\n\t\tHttpRequestHandler httpRequestHandler = (HttpRequestHandler) suhm.getUrlMap().get(\"/foo\");\n\t\tassertNotNull(httpRequestHandler);\n\t\tassertThat(httpRequestHandler, Matchers.instanceOf(WebSocketHttpRequestHandler.class));\n\n\t\tWebSocketHttpRequestHandler wsHttpRequestHandler = (WebSocketHttpRequestHandler) httpRequestHandler;\n\t\tWebSocketHandler wsHandler = unwrapWebSocketHandler(wsHttpRequestHandler.getWebSocketHandler());\n\t\tassertNotNull(wsHandler);\n\t\tassertThat(wsHandler, Matchers.instanceOf(SubProtocolWebSocketHandler.class));\n\n\t\tSubProtocolWebSocketHandler subProtocolWsHandler = (SubProtocolWebSocketHandler) wsHandler;\n\t\tassertEquals(Arrays.asList(\"v10.stomp\", \"v11.stomp\", \"v12.stomp\"), subProtocolWsHandler.getSubProtocols());\n\n\t\tStompSubProtocolHandler stompHandler =\n\t\t\t\t(StompSubProtocolHandler) subProtocolWsHandler.getProtocolHandlerMap().get(\"v12.stomp\");\n\t\tassertNotNull(stompHandler);\n\n\t\thttpRequestHandler = (HttpRequestHandler) suhm.getUrlMap().get(\"/test/**\");\n\t\tassertNotNull(httpRequestHandler);\n\t\tassertThat(httpRequestHandler, Matchers.instanceOf(SockJsHttpRequestHandler.class));\n\n\t\tSockJsHttpRequestHandler sockJsHttpRequestHandler = (SockJsHttpRequestHandler) httpRequestHandler;\n\t\twsHandler = unwrapWebSocketHandler(sockJsHttpRequestHandler.getWebSocketHandler());\n\t\tassertNotNull(wsHandler);\n\t\tassertThat(wsHandler, Matchers.instanceOf(SubProtocolWebSocketHandler.class));\n\t\tassertNotNull(sockJsHttpRequestHandler.getSockJsService());\n\n\t\tUserSessionRegistry userSessionRegistry = this.appContext.getBean(UserSessionRegistry.class);\n\t\tassertNotNull(userSessionRegistry);\n\n\t\tUserDestinationResolver userDestResolver = this.appContext.getBean(UserDestinationResolver.class);\n\t\tassertNotNull(userDestResolver);\n\t\tassertThat(userDestResolver, Matchers.instanceOf(DefaultUserDestinationResolver.class));\n\t\tDefaultUserDestinationResolver defaultUserDestResolver = (DefaultUserDestinationResolver) userDestResolver;\n\t\tassertEquals(\"/personal/\", defaultUserDestResolver.getDestinationPrefix());\n\t\tassertSame(stompHandler.getUserSessionRegistry(), defaultUserDestResolver.getUserSessionRegistry());\n\n\t\tUserDestinationMessageHandler userDestHandler = this.appContext.getBean(UserDestinationMessageHandler.class);\n\t\tassertNotNull(userDestHandler);\n\n\t\tSimpleBrokerMessageHandler brokerMessageHandler = this.appContext.getBean(SimpleBrokerMessageHandler.class);\n\t\tassertNotNull(brokerMessageHandler);\n\t\tassertEquals(Arrays.asList(\"/topic\", \"/queue\"),\n\t\t\t\tnew ArrayList<String>(brokerMessageHandler.getDestinationPrefixes()));\n\n\t\tList<Class<? extends MessageHandler>> subscriberTypes =\n\t\t\t\tArrays.<Class<? extends MessageHandler>>asList(SimpAnnotationMethodMessageHandler.class,\n\t\t\t\t\t\tUserDestinationMessageHandler.class, SimpleBrokerMessageHandler.class);\n\t\ttestChannel(\"clientInboundChannel\", subscriberTypes, 0);\n\t\ttestExecutor(\"clientInboundChannel\", Runtime.getRuntime().availableProcessors() * 2, Integer.MAX_VALUE, 60);\n\n\t\tsubscriberTypes = Arrays.<Class<? extends MessageHandler>>asList(SubProtocolWebSocketHandler.class);\n\t\ttestChannel(\"clientOutboundChannel\", subscriberTypes, 0);\n\t\ttestExecutor(\"clientOutboundChannel\", Runtime.getRuntime().availableProcessors() * 2, Integer.MAX_VALUE, 60);\n\n\t\tsubscriberTypes = Arrays.<Class<? extends MessageHandler>>asList(\n\t\t\t\tSimpleBrokerMessageHandler.class, UserDestinationMessageHandler.class);\n\t\ttestChannel(\"brokerChannel\", subscriberTypes, 0);\n\t\ttry {\n\t\t\tthis.appContext.getBean(\"brokerChannelExecutor\", ThreadPoolTaskExecutor.class);\n\t\t\tfail(\"expected exception\");\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// expected\n\t\t}\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void stompBrokerRelay() {\n\t\tloadBeanDefinitions(\"websocket-config-broker-relay.xml\");\n\n\t\tHandlerMapping hm = this.appContext.getBean(HandlerMapping.class);\n\t\tassertNotNull(hm);\n\t\tassertThat(hm, Matchers.instanceOf(SimpleUrlHandlerMapping.class));\n\n\t\tSimpleUrlHandlerMapping suhm = (SimpleUrlHandlerMapping) hm;\n\t\tassertThat(suhm.getUrlMap().keySet(), Matchers.hasSize(1));\n\t\tassertThat(suhm.getUrlMap().values(), Matchers.hasSize(1));\n\t\tassertEquals(2, suhm.getOrder());\n\n\t\tHttpRequestHandler httpRequestHandler = (HttpRequestHandler) suhm.getUrlMap().get(\"/foo/**\");\n\t\tassertNotNull(httpRequestHandler);\n\t\tassertThat(httpRequestHandler, Matchers.instanceOf(SockJsHttpRequestHandler.class));\n\t\tSockJsHttpRequestHandler sockJsHttpRequestHandler = (SockJsHttpRequestHandler) httpRequestHandler;\n\t\tWebSocketHandler wsHandler = unwrapWebSocketHandler(sockJsHttpRequestHandler.getWebSocketHandler());\n\t\tassertNotNull(wsHandler);\n\t\tassertThat(wsHandler, Matchers.instanceOf(SubProtocolWebSocketHandler.class));\n\t\tassertNotNull(sockJsHttpRequestHandler.getSockJsService());\n\n\t\tUserDestinationResolver userDestResolver = this.appContext.getBean(UserDestinationResolver.class);\n\t\tassertNotNull(userDestResolver);\n\t\tassertThat(userDestResolver, Matchers.instanceOf(DefaultUserDestinationResolver.class));\n\t\tDefaultUserDestinationResolver defaultUserDestResolver = (DefaultUserDestinationResolver) userDestResolver;\n\t\tassertEquals(\"/user/\", defaultUserDestResolver.getDestinationPrefix());\n\n\t\tStompBrokerRelayMessageHandler messageBroker = this.appContext.getBean(StompBrokerRelayMessageHandler.class);\n\t\tassertNotNull(messageBroker);\n\t\tassertEquals(\"clientlogin\", messageBroker.getClientLogin());\n\t\tassertEquals(\"clientpass\", messageBroker.getClientPasscode());\n\t\tassertEquals(\"syslogin\", messageBroker.getSystemLogin());\n\t\tassertEquals(\"syspass\", messageBroker.getSystemPasscode());\n\t\tassertEquals(\"relayhost\", messageBroker.getRelayHost());\n\t\tassertEquals(1234, messageBroker.getRelayPort());\n\t\tassertEquals(\"spring.io\", messageBroker.getVirtualHost());\n\t\tassertEquals(5000, messageBroker.getSystemHeartbeatReceiveInterval());\n\t\tassertEquals(5000, messageBroker.getSystemHeartbeatSendInterval());\n\t\tassertThat(messageBroker.getDestinationPrefixes(), Matchers.containsInAnyOrder(\"/topic\",\"/queue\"));\n\n\t\tList<Class<? extends MessageHandler>> subscriberTypes =\n\t\t\t\tArrays.<Class<? extends MessageHandler>>asList(SimpAnnotationMethodMessageHandler.class,\n\t\t\t\t\t\tUserDestinationMessageHandler.class, StompBrokerRelayMessageHandler.class);\n\t\ttestChannel(\"clientInboundChannel\", subscriberTypes, 0);\n\t\ttestExecutor(\"clientInboundChannel\", 1, Integer.MAX_VALUE, 60);\n\n\t\tsubscriberTypes = Arrays.<Class<? extends MessageHandler>>asList(SubProtocolWebSocketHandler.class);\n\t\ttestChannel(\"clientOutboundChannel\", subscriberTypes, 0);\n\t\ttestExecutor(\"clientOutboundChannel\", 1, Integer.MAX_VALUE, 60);\n\n\t\tsubscriberTypes = Arrays.<Class<? extends MessageHandler>>asList(\n\t\t\t\tStompBrokerRelayMessageHandler.class, UserDestinationMessageHandler.class);\n\t\ttestChannel(\"brokerChannel\", subscriberTypes, 0);\n\t\ttry {\n\t\t\tthis.appContext.getBean(\"brokerChannelExecutor\", ThreadPoolTaskExecutor.class);\n\t\t\tfail(\"expected exception\");\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// expected\n\t\t}\n\t}","id":91601,"modified_method":"@Test\n\tpublic void stompBrokerRelay() {\n\t\tloadBeanDefinitions(\"websocket-config-broker-relay.xml\");\n\n\t\tHandlerMapping hm = this.appContext.getBean(HandlerMapping.class);\n\t\tassertNotNull(hm);\n\t\tassertThat(hm, Matchers.instanceOf(SimpleUrlHandlerMapping.class));\n\n\t\tSimpleUrlHandlerMapping suhm = (SimpleUrlHandlerMapping) hm;\n\t\tassertThat(suhm.getUrlMap().keySet(), Matchers.hasSize(1));\n\t\tassertThat(suhm.getUrlMap().values(), Matchers.hasSize(1));\n\t\tassertEquals(2, suhm.getOrder());\n\n\t\tHttpRequestHandler httpRequestHandler = (HttpRequestHandler) suhm.getUrlMap().get(\"/foo/**\");\n\t\tassertNotNull(httpRequestHandler);\n\t\tassertThat(httpRequestHandler, Matchers.instanceOf(SockJsHttpRequestHandler.class));\n\t\tSockJsHttpRequestHandler sockJsHttpRequestHandler = (SockJsHttpRequestHandler) httpRequestHandler;\n\t\tWebSocketHandler wsHandler = unwrapWebSocketHandler(sockJsHttpRequestHandler.getWebSocketHandler());\n\t\tassertNotNull(wsHandler);\n\t\tassertThat(wsHandler, Matchers.instanceOf(SubProtocolWebSocketHandler.class));\n\t\tassertNotNull(sockJsHttpRequestHandler.getSockJsService());\n\n\t\tUserDestinationResolver userDestResolver = this.appContext.getBean(UserDestinationResolver.class);\n\t\tassertNotNull(userDestResolver);\n\t\tassertThat(userDestResolver, Matchers.instanceOf(DefaultUserDestinationResolver.class));\n\t\tDefaultUserDestinationResolver defaultUserDestResolver = (DefaultUserDestinationResolver) userDestResolver;\n\t\tassertEquals(\"/user/\", defaultUserDestResolver.getDestinationPrefix());\n\n\t\tStompBrokerRelayMessageHandler messageBroker = this.appContext.getBean(StompBrokerRelayMessageHandler.class);\n\t\tassertNotNull(messageBroker);\n\t\tassertEquals(\"clientlogin\", messageBroker.getClientLogin());\n\t\tassertEquals(\"clientpass\", messageBroker.getClientPasscode());\n\t\tassertEquals(\"syslogin\", messageBroker.getSystemLogin());\n\t\tassertEquals(\"syspass\", messageBroker.getSystemPasscode());\n\t\tassertEquals(\"relayhost\", messageBroker.getRelayHost());\n\t\tassertEquals(1234, messageBroker.getRelayPort());\n\t\tassertEquals(\"spring.io\", messageBroker.getVirtualHost());\n\t\tassertEquals(5000, messageBroker.getSystemHeartbeatReceiveInterval());\n\t\tassertEquals(5000, messageBroker.getSystemHeartbeatSendInterval());\n\t\tassertThat(messageBroker.getDestinationPrefixes(), Matchers.containsInAnyOrder(\"/topic\",\"/queue\"));\n\n\t\tList<Class<? extends MessageHandler>> subscriberTypes =\n\t\t\t\tArrays.<Class<? extends MessageHandler>>asList(SimpAnnotationMethodMessageHandler.class,\n\t\t\t\t\t\tUserDestinationMessageHandler.class, StompBrokerRelayMessageHandler.class);\n\t\ttestChannel(\"clientInboundChannel\", subscriberTypes, 0);\n\t\ttestExecutor(\"clientInboundChannel\", Runtime.getRuntime().availableProcessors() * 2, Integer.MAX_VALUE, 60);\n\n\t\tsubscriberTypes = Arrays.<Class<? extends MessageHandler>>asList(SubProtocolWebSocketHandler.class);\n\t\ttestChannel(\"clientOutboundChannel\", subscriberTypes, 0);\n\t\ttestExecutor(\"clientOutboundChannel\", Runtime.getRuntime().availableProcessors() * 2, Integer.MAX_VALUE, 60);\n\n\t\tsubscriberTypes = Arrays.<Class<? extends MessageHandler>>asList(\n\t\t\t\tStompBrokerRelayMessageHandler.class, UserDestinationMessageHandler.class);\n\t\ttestChannel(\"brokerChannel\", subscriberTypes, 0);\n\t\ttry {\n\t\t\tthis.appContext.getBean(\"brokerChannelExecutor\", ThreadPoolTaskExecutor.class);\n\t\t\tfail(\"expected exception\");\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// expected\n\t\t}\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void brokerChannel() {\n\t\tTestChannel channel = this.simpleContext.getBean(\"brokerChannel\", TestChannel.class);\n\t\tSet<MessageHandler> handlers = channel.getSubscribers();\n\n\t\tassertEquals(2, handlers.size());\n\t\tassertTrue(handlers.contains(simpleContext.getBean(UserDestinationMessageHandler.class)));\n\t\tassertTrue(handlers.contains(simpleContext.getBean(SimpleBrokerMessageHandler.class)));\n\t}","id":91602,"modified_method":"@Test\n\tpublic void brokerChannel() {\n\t\tTestChannel channel = this.simpleBrokerContext.getBean(\"brokerChannel\", TestChannel.class);\n\t\tSet<MessageHandler> handlers = channel.getSubscribers();\n\n\t\tassertEquals(2, handlers.size());\n\t\tassertTrue(handlers.contains(simpleBrokerContext.getBean(UserDestinationMessageHandler.class)));\n\t\tassertTrue(handlers.contains(simpleBrokerContext.getBean(SimpleBrokerMessageHandler.class)));\n\n\t\tassertNull(channel.getExecutor());\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void clientInboundChannel() {\n\n\t\tTestChannel channel = this.simpleContext.getBean(\"clientInboundChannel\", TestChannel.class);\n\t\tSet<MessageHandler> handlers = channel.getSubscribers();\n\n\t\tassertEquals(3, handlers.size());\n\t\tassertTrue(handlers.contains(simpleContext.getBean(SimpAnnotationMethodMessageHandler.class)));\n\t\tassertTrue(handlers.contains(simpleContext.getBean(UserDestinationMessageHandler.class)));\n\t\tassertTrue(handlers.contains(simpleContext.getBean(SimpleBrokerMessageHandler.class)));\n\t}","id":91603,"modified_method":"@Test\n\tpublic void clientInboundChannel() {\n\n\t\tTestChannel channel = this.simpleBrokerContext.getBean(\"clientInboundChannel\", TestChannel.class);\n\t\tSet<MessageHandler> handlers = channel.getSubscribers();\n\n\t\tassertEquals(3, handlers.size());\n\t\tassertTrue(handlers.contains(simpleBrokerContext.getBean(SimpAnnotationMethodMessageHandler.class)));\n\t\tassertTrue(handlers.contains(simpleBrokerContext.getBean(UserDestinationMessageHandler.class)));\n\t\tassertTrue(handlers.contains(simpleBrokerContext.getBean(SimpleBrokerMessageHandler.class)));\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setupOnce() {\n\n\t\tthis.simpleContext = new AnnotationConfigApplicationContext();\n\t\tthis.simpleContext.register(SimpleConfig.class);\n\t\tthis.simpleContext.refresh();\n\n\t\tthis.brokerRelayContext = new AnnotationConfigApplicationContext();\n\t\tthis.brokerRelayContext.register(BrokerRelayConfig.class);\n\t\tthis.brokerRelayContext.refresh();\n\n\t\tthis.customChannelContext = new AnnotationConfigApplicationContext();\n\t\tthis.customChannelContext.register(CustomChannelConfig.class);\n\t\tthis.customChannelContext.refresh();\n\t}","id":91604,"modified_method":"@Before\n\tpublic void setupOnce() {\n\n\t\tthis.simpleBrokerContext = new AnnotationConfigApplicationContext();\n\t\tthis.simpleBrokerContext.register(SimpleBrokerConfig.class);\n\t\tthis.simpleBrokerContext.refresh();\n\n\t\tthis.brokerRelayContext = new AnnotationConfigApplicationContext();\n\t\tthis.brokerRelayContext.register(BrokerRelayConfig.class);\n\t\tthis.brokerRelayContext.refresh();\n\n\t\tthis.defaultContext = new AnnotationConfigApplicationContext();\n\t\tthis.defaultContext.register(DefaultConfig.class);\n\t\tthis.defaultContext.refresh();\n\n\t\tthis.customChannelContext = new AnnotationConfigApplicationContext();\n\t\tthis.customChannelContext.register(CustomChannelConfig.class);\n\t\tthis.customChannelContext.refresh();\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void clientOutboundChannelUsedBySimpleBroker() {\n\t\tTestChannel channel = this.simpleContext.getBean(\"clientOutboundChannel\", TestChannel.class);\n\t\tSimpleBrokerMessageHandler broker = this.simpleContext.getBean(SimpleBrokerMessageHandler.class);\n\n\t\tStompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.SUBSCRIBE);\n\t\theaders.setSessionId(\"sess1\");\n\t\theaders.setSubscriptionId(\"subs1\");\n\t\theaders.setDestination(\"/foo\");\n\t\tMessage<?> message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();\n\n\t\t// subscribe\n\t\tbroker.handleMessage(message);\n\n\t\theaders = StompHeaderAccessor.create(StompCommand.SEND);\n\t\theaders.setSessionId(\"sess1\");\n\t\theaders.setDestination(\"/foo\");\n\t\tmessage = MessageBuilder.withPayload(\"bar\".getBytes()).setHeaders(headers).build();\n\n\t\t// message\n\t\tbroker.handleMessage(message);\n\n\t\tmessage = channel.messages.get(0);\n\t\theaders = StompHeaderAccessor.wrap(message);\n\n\t\tassertEquals(SimpMessageType.MESSAGE, headers.getMessageType());\n\t\tassertEquals(\"/foo\", headers.getDestination());\n\t\tassertEquals(\"bar\", new String((byte[]) message.getPayload()));\n\t}","id":91605,"modified_method":"@Test\n\tpublic void clientOutboundChannelUsedBySimpleBroker() {\n\t\tTestChannel channel = this.simpleBrokerContext.getBean(\"clientOutboundChannel\", TestChannel.class);\n\t\tSimpleBrokerMessageHandler broker = this.simpleBrokerContext.getBean(SimpleBrokerMessageHandler.class);\n\n\t\tStompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.SUBSCRIBE);\n\t\theaders.setSessionId(\"sess1\");\n\t\theaders.setSubscriptionId(\"subs1\");\n\t\theaders.setDestination(\"/foo\");\n\t\tMessage<?> message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();\n\n\t\t// subscribe\n\t\tbroker.handleMessage(message);\n\n\t\theaders = StompHeaderAccessor.create(StompCommand.SEND);\n\t\theaders.setSessionId(\"sess1\");\n\t\theaders.setDestination(\"/foo\");\n\t\tmessage = MessageBuilder.withPayload(\"bar\".getBytes()).setHeaders(headers).build();\n\n\t\t// message\n\t\tbroker.handleMessage(message);\n\n\t\tmessage = channel.messages.get(0);\n\t\theaders = StompHeaderAccessor.wrap(message);\n\n\t\tassertEquals(SimpMessageType.MESSAGE, headers.getMessageType());\n\t\tassertEquals(\"/foo\", headers.getDestination());\n\t\tassertEquals(\"bar\", new String((byte[]) message.getPayload()));\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void brokerChannelUsedByAnnotatedMethod() {\n\t\tTestChannel channel = this.simpleContext.getBean(\"brokerChannel\", TestChannel.class);\n\t\tSimpAnnotationMethodMessageHandler messageHandler = this.simpleContext.getBean(SimpAnnotationMethodMessageHandler.class);\n\n\t\tStompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.SEND);\n\t\theaders.setDestination(\"/foo\");\n\t\tMessage<?> message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();\n\n\t\tmessageHandler.handleMessage(message);\n\n\t\tmessage = channel.messages.get(0);\n\t\theaders = StompHeaderAccessor.wrap(message);\n\n\t\tassertEquals(SimpMessageType.MESSAGE, headers.getMessageType());\n\t\tassertEquals(\"/bar\", headers.getDestination());\n\t\tassertEquals(\"\\\"bar\\\"\", new String((byte[]) message.getPayload()));\n\t}","id":91606,"modified_method":"@Test\n\tpublic void brokerChannelUsedByAnnotatedMethod() {\n\t\tTestChannel channel = this.simpleBrokerContext.getBean(\"brokerChannel\", TestChannel.class);\n\t\tSimpAnnotationMethodMessageHandler messageHandler =\n\t\t\t\tthis.simpleBrokerContext.getBean(SimpAnnotationMethodMessageHandler.class);\n\n\t\tStompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.SEND);\n\t\theaders.setDestination(\"/foo\");\n\t\tMessage<?> message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();\n\n\t\tmessageHandler.handleMessage(message);\n\n\t\tmessage = channel.messages.get(0);\n\t\theaders = StompHeaderAccessor.wrap(message);\n\n\t\tassertEquals(SimpMessageType.MESSAGE, headers.getMessageType());\n\t\tassertEquals(\"/bar\", headers.getDestination());\n\t\tassertEquals(\"\\\"bar\\\"\", new String((byte[]) message.getPayload()));\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void simpValidatorInjected() {\n\t\tSimpAnnotationMethodMessageHandler messageHandler =\n\t\t\t\tthis.simpleContext.getBean(SimpAnnotationMethodMessageHandler.class);\n\n\t\tassertThat(messageHandler.getValidator(), Matchers.notNullValue(Validator.class));\n\t}","id":91607,"modified_method":"@Test\n\tpublic void simpValidatorInjected() {\n\t\tSimpAnnotationMethodMessageHandler messageHandler =\n\t\t\t\tthis.simpleBrokerContext.getBean(SimpAnnotationMethodMessageHandler.class);\n\n\t\tassertThat(messageHandler.getValidator(), Matchers.notNullValue(Validator.class));\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void clientOutboundChannelUsedByAnnotatedMethod() {\n\t\tTestChannel channel = this.simpleContext.getBean(\"clientOutboundChannel\", TestChannel.class);\n\t\tSimpAnnotationMethodMessageHandler messageHandler = this.simpleContext.getBean(SimpAnnotationMethodMessageHandler.class);\n\n\t\tStompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.SUBSCRIBE);\n\t\theaders.setSessionId(\"sess1\");\n\t\theaders.setSubscriptionId(\"subs1\");\n\t\theaders.setDestination(\"/foo\");\n\t\tMessage<?> message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();\n\n\t\tmessageHandler.handleMessage(message);\n\n\t\tmessage = channel.messages.get(0);\n\t\theaders = StompHeaderAccessor.wrap(message);\n\n\t\tassertEquals(SimpMessageType.MESSAGE, headers.getMessageType());\n\t\tassertEquals(\"/foo\", headers.getDestination());\n\t\tassertEquals(\"\\\"bar\\\"\", new String((byte[]) message.getPayload()));\n\t}","id":91608,"modified_method":"@Test\n\tpublic void clientOutboundChannelUsedByAnnotatedMethod() {\n\t\tTestChannel channel = this.simpleBrokerContext.getBean(\"clientOutboundChannel\", TestChannel.class);\n\t\tSimpAnnotationMethodMessageHandler messageHandler = this.simpleBrokerContext.getBean(SimpAnnotationMethodMessageHandler.class);\n\n\t\tStompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.SUBSCRIBE);\n\t\theaders.setSessionId(\"sess1\");\n\t\theaders.setSubscriptionId(\"subs1\");\n\t\theaders.setDestination(\"/foo\");\n\t\tMessage<?> message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();\n\n\t\tmessageHandler.handleMessage(message);\n\n\t\tmessage = channel.messages.get(0);\n\t\theaders = StompHeaderAccessor.wrap(message);\n\n\t\tassertEquals(SimpMessageType.MESSAGE, headers.getMessageType());\n\t\tassertEquals(\"/foo\", headers.getDestination());\n\t\tassertEquals(\"\\\"bar\\\"\", new String((byte[]) message.getPayload()));\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void brokerChannelUsedByUserDestinationMessageHandler() {\n\t\tTestChannel channel = this.simpleContext.getBean(\"brokerChannel\", TestChannel.class);\n\t\tUserDestinationMessageHandler messageHandler = this.simpleContext.getBean(UserDestinationMessageHandler.class);\n\n\t\tthis.simpleContext.getBean(UserSessionRegistry.class).registerSessionId(\"joe\", \"s1\");\n\n\t\tStompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.SEND);\n\t\theaders.setDestination(\"/user/joe/foo\");\n\t\tMessage<?> message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();\n\n\t\tmessageHandler.handleMessage(message);\n\n\t\tmessage = channel.messages.get(0);\n\t\theaders = StompHeaderAccessor.wrap(message);\n\n\t\tassertEquals(SimpMessageType.MESSAGE, headers.getMessageType());\n\t\tassertEquals(\"/foo-users1\", headers.getDestination());\n\t}","id":91609,"modified_method":"@Test\n\tpublic void brokerChannelUsedByUserDestinationMessageHandler() {\n\t\tTestChannel channel = this.simpleBrokerContext.getBean(\"brokerChannel\", TestChannel.class);\n\t\tUserDestinationMessageHandler messageHandler = this.simpleBrokerContext.getBean(UserDestinationMessageHandler.class);\n\n\t\tthis.simpleBrokerContext.getBean(UserSessionRegistry.class).registerSessionId(\"joe\", \"s1\");\n\n\t\tStompHeaderAccessor headers = StompHeaderAccessor.create(StompCommand.SEND);\n\t\theaders.setDestination(\"/user/joe/foo\");\n\t\tMessage<?> message = MessageBuilder.withPayload(new byte[0]).setHeaders(headers).build();\n\n\t\tmessageHandler.handleMessage(message);\n\n\t\tmessage = channel.messages.get(0);\n\t\theaders = StompHeaderAccessor.wrap(message);\n\n\t\tassertEquals(SimpMessageType.MESSAGE, headers.getMessageType());\n\t\tassertEquals(\"/foo-users1\", headers.getDestination());\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Set the ThreadPoolExecutor's core pool size.\n\t * Default is 1.\n\t */\n\tpublic TaskExecutorRegistration corePoolSize(int corePoolSize) {\n\t\tthis.corePoolSize = corePoolSize;\n\t\treturn this;\n\t}","id":91610,"modified_method":"/**\n\t * Set the core pool size of the ThreadPoolExecutor.\n\t *\n\t * <p><strong>NOTE:<\/strong> the core pool size is effectively the max pool size\n\t * when an unbounded {@link #queueCapacity(int) queueCapacity} is configured\n\t * (the default). This is essentially the \"Unbounded queues\" strategy as explained\n\t * in {@link java.util.concurrent.ThreadPoolExecutor ThreadPoolExecutor}. When\n\t * this strategy is used, the {@link #maxPoolSize(int) maxPoolSize} is ignored.\n\t *\n\t * <p>By default this is set to twice the value of\n\t * {@link Runtime#availableProcessors()}. In an an application where tasks do not\n\t * block frequently, the number should be closer to or equal to the number of\n\t * available CPUs/cores.\n\t */\n\tpublic TaskExecutorRegistration corePoolSize(int corePoolSize) {\n\t\tthis.corePoolSize = corePoolSize;\n\t\treturn this;\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Set the capacity for the ThreadPoolExecutor's BlockingQueue.\n\t * Default is {@code Integer.MAX_VALUE}.\n\t * <p>Any positive value will lead to a LinkedBlockingQueue instance;\n\t * any other value will lead to a SynchronousQueue instance.\n\t * @see java.util.concurrent.LinkedBlockingQueue\n\t * @see java.util.concurrent.SynchronousQueue\n\t */\n\tpublic TaskExecutorRegistration queueCapacity(int queueCapacity) {\n\t\tthis.queueCapacity = queueCapacity;\n\t\treturn this;\n\t}","id":91611,"modified_method":"/**\n\t * Set the queue capacity for the ThreadPoolExecutor.\n\t *\n\t * <p><strong>NOTE:<\/strong> when an unbounded\n\t * {@link #queueCapacity(int) queueCapacity} is configured (the default) the\n\t * core pool size is effectively the max pool size. This is essentially the\n\t * \"Unbounded queues\" strategy as explained in\n\t * {@link java.util.concurrent.ThreadPoolExecutor ThreadPoolExecutor}. When\n\t * this strategy is used, the {@link #maxPoolSize(int) maxPoolSize} is ignored.\n\t *\n\t * <p>By default this is set to {@code Integer.MAX_VALUE}.\n\t */\n\tpublic TaskExecutorRegistration queueCapacity(int queueCapacity) {\n\t\tthis.queueCapacity = queueCapacity;\n\t\treturn this;\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Set the ThreadPoolExecutor's maximum pool size.\n\t * Default is {@code Integer.MAX_VALUE}.\n\t */\n\tpublic TaskExecutorRegistration maxPoolSize(int maxPoolSize) {\n\t\tthis.maxPoolSize = maxPoolSize;\n\t\treturn this;\n\t}","id":91612,"modified_method":"/**\n\t * Set the max pool size of the ThreadPoolExecutor.\n\t *\n\t * <p><strong>NOTE:<\/strong> when an unbounded\n\t * {@link #queueCapacity(int) queueCapacity} is configured (the default), the\n\t * max pool size is effectively ignored. See the \"Unbounded queues\" strategy\n\t * in {@link java.util.concurrent.ThreadPoolExecutor ThreadPoolExecutor} for\n\t * more details.\n\t *\n\t * <p>By default this is set to {@code Integer.MAX_VALUE}.\n\t */\n\tpublic TaskExecutorRegistration maxPoolSize(int maxPoolSize) {\n\t\tthis.maxPoolSize = maxPoolSize;\n\t\treturn this;\n\t}","commit_id":"10af128e9654d346a3f6ca6a2d3201e9b409e2a1","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        settingsMenu = new javax.swing.JPopupMenu();\n        regExCheckboxMenuItem = new javax.swing.JCheckBoxMenuItem();\n        wholewordCheckboxMenuItem = new javax.swing.JCheckBoxMenuItem();\n        listsMenu = new javax.swing.JPopupMenu();\n        searchMenu = new javax.swing.JPopupMenu();\n        listsButton = new javax.swing.JButton();\n        searchDropButton = new javax.swing.JButton();\n\n        regExCheckboxMenuItem.setText(org.openide.util.NbBundle.getMessage(KeywordSearchPanel.class, \"KeywordSearchPanel.regExCheckboxMenuItem.text\")); // NOI18N\n        settingsMenu.add(regExCheckboxMenuItem);\n\n        wholewordCheckboxMenuItem.setText(org.openide.util.NbBundle.getMessage(KeywordSearchPanel.class, \"KeywordSearchPanel.wholewordCheckboxMenuItem.text\")); // NOI18N\n        settingsMenu.add(wholewordCheckboxMenuItem);\n\n        setOpaque(false);\n\n        listsButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/keywordsearch/watchbutton-icon.png\"))); // NOI18N\n        listsButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchPanel.class, \"ListBundleName\")); // NOI18N\n        listsButton.setBorderPainted(false);\n        listsButton.setContentAreaFilled(false);\n        listsButton.setEnabled(false);\n        listsButton.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/keywordsearch/watchbutton-icon-rollover.png\"))); // NOI18N\n        listsButton.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/keywordsearch/watchbutton-icon-pressed.png\"))); // NOI18N\n        listsButton.addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mousePressed(java.awt.event.MouseEvent evt) {\n                listsButtonMousePressed(evt);\n            }\n        });\n        listsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                listsButtonActionPerformed(evt);\n            }\n        });\n\n        searchDropButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/keywordsearch/dropdown-icon.png\"))); // NOI18N\n        searchDropButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchPanel.class, \"KeywordSearchPanel.searchDropButton.text\")); // NOI18N\n        searchDropButton.setBorderPainted(false);\n        searchDropButton.setContentAreaFilled(false);\n        searchDropButton.setMaximumSize(new java.awt.Dimension(77, 27));\n        searchDropButton.setMinimumSize(new java.awt.Dimension(77, 27));\n        searchDropButton.setPreferredSize(new java.awt.Dimension(77, 27));\n        searchDropButton.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/keywordsearch/dropdown-icon-rollover.png\"))); // NOI18N\n        searchDropButton.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/keywordsearch/dropdown-icon-pressed.png\"))); // NOI18N\n        searchDropButton.addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mousePressed(java.awt.event.MouseEvent evt) {\n                searchDropButtonMousePressed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(listsButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(searchDropButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addGap(0, 0, Short.MAX_VALUE)\n                .addComponent(listsButton))\n            .addComponent(searchDropButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n        );\n    }","id":91613,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        settingsMenu = new javax.swing.JPopupMenu();\n        regExCheckboxMenuItem = new javax.swing.JCheckBoxMenuItem();\n        wholewordCheckboxMenuItem = new javax.swing.JCheckBoxMenuItem();\n        listsMenu = new javax.swing.JPopupMenu();\n        searchMenu = new javax.swing.JPopupMenu();\n        listsButton = new javax.swing.JButton();\n        searchDropButton = new javax.swing.JButton();\n\n        regExCheckboxMenuItem.setText(org.openide.util.NbBundle.getMessage(KeywordSearchPanel.class, \"KeywordSearchPanel.regExCheckboxMenuItem.text\")); // NOI18N\n        settingsMenu.add(regExCheckboxMenuItem);\n\n        wholewordCheckboxMenuItem.setText(org.openide.util.NbBundle.getMessage(KeywordSearchPanel.class, \"KeywordSearchPanel.wholewordCheckboxMenuItem.text\")); // NOI18N\n        settingsMenu.add(wholewordCheckboxMenuItem);\n\n        setOpaque(false);\n\n        listsButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/keywordsearch/watchbutton-icon.png\"))); // NOI18N\n        listsButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchPanel.class, \"ListBundleName\")); // NOI18N\n        listsButton.setBorderPainted(false);\n        listsButton.setContentAreaFilled(false);\n        listsButton.setEnabled(false);\n        listsButton.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/keywordsearch/watchbutton-icon-rollover.png\"))); // NOI18N\n        listsButton.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/keywordsearch/watchbutton-icon-pressed.png\"))); // NOI18N\n        listsButton.addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mousePressed(java.awt.event.MouseEvent evt) {\n                listsButtonMousePressed(evt);\n            }\n        });\n        listsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                listsButtonActionPerformed(evt);\n            }\n        });\n\n        searchDropButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/keywordsearch/searchbutton-icon.png\"))); // NOI18N\n        searchDropButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchPanel.class, \"KeywordSearchPanel.searchDropButton.text\")); // NOI18N\n        searchDropButton.setBorderPainted(false);\n        searchDropButton.setContentAreaFilled(false);\n        searchDropButton.setEnabled(false);\n        searchDropButton.setMaximumSize(new java.awt.Dimension(118, 27));\n        searchDropButton.setMinimumSize(new java.awt.Dimension(118, 27));\n        searchDropButton.setPreferredSize(new java.awt.Dimension(118, 27));\n        searchDropButton.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/keywordsearch/searchbutton-icon-rollover.png\"))); // NOI18N\n        searchDropButton.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/keywordsearch/searchbutton-icon-pressed.png\"))); // NOI18N\n        searchDropButton.addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mousePressed(java.awt.event.MouseEvent evt) {\n                searchDropButtonMousePressed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(listsButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(searchDropButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addGap(0, 0, Short.MAX_VALUE)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                    .addComponent(listsButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(searchDropButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))\n        );\n    }","commit_id":"d65a6c058c5e354b00483725dc6454141cc6ccdd","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** {@inheritDoc } */\n    void store() {\n        ImageGalleryPreferences.setEnabledByDefault(enabledByDefaultBox.isSelected());\n        ImageGalleryController.getDefault().setListeningEnabled(enabledForCaseBox.isSelected());\n        if (Case.isCaseOpen()) {\n            new PerCaseProperties(Case.getCurrentCase()).setConfigSetting(ImageGalleryModule.getModuleName(), PerCaseProperties.ENABLED, Boolean.toString(enabledForCaseBox.isSelected()));\n        }\n        ImageGalleryPreferences.setGroupCategorizationWarningDisabled(groupCategorizationWarningBox.isSelected());\n    }","id":91614,"modified_method":"void store() {\n        ImageGalleryPreferences.setEnabledByDefault(enabledByDefaultBox.isSelected());\n        ImageGalleryController.getDefault().setListeningEnabled(enabledForCaseBox.isSelected());\n        if (Case.isCaseOpen()) {\n            new PerCaseProperties(Case.getCurrentCase()).setConfigSetting(ImageGalleryModule.getModuleName(), PerCaseProperties.ENABLED, Boolean.toString(enabledForCaseBox.isSelected()));\n        }\n        ImageGalleryPreferences.setGroupCategorizationWarningDisabled(groupCategorizationWarningBox.isSelected());\n    }","commit_id":"4bc7a5dd305e204cca9387791b566b411a464b68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        enabledByDefaultBox = new javax.swing.JCheckBox();\n        enabledForCaseBox = new javax.swing.JCheckBox();\n        descriptionLabel = new javax.swing.JLabel();\n        furtherDescriptionArea = new javax.swing.JTextArea();\n        infoIconLabel = new javax.swing.JLabel();\n        unavailableDuringInjestLabel = new javax.swing.JLabel();\n        jSeparator1 = new javax.swing.JSeparator();\n        groupCategorizationWarningBox = new javax.swing.JCheckBox();\n\n        setFont(getFont().deriveFont(getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        enabledByDefaultBox.setFont(enabledByDefaultBox.getFont().deriveFont(enabledByDefaultBox.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(enabledByDefaultBox, org.openide.util.NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.enabledByDefaultBox.text\")); // NOI18N\n        enabledByDefaultBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                enabledByDefaultBoxActionPerformed(evt);\n            }\n        });\n\n        enabledForCaseBox.setFont(enabledForCaseBox.getFont().deriveFont(enabledForCaseBox.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(enabledForCaseBox, org.openide.util.NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.enabledForCaseBox.text\")); // NOI18N\n        enabledForCaseBox.setToolTipText(NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.enabledForCaseBox.toolTipText\")); // NOI18N\n        enabledForCaseBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                enabledForCaseBoxActionPerformed(evt);\n            }\n        });\n\n        descriptionLabel.setFont(descriptionLabel.getFont().deriveFont(descriptionLabel.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(descriptionLabel, org.openide.util.NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.descriptionLabel.text\")); // NOI18N\n\n        furtherDescriptionArea.setBackground(new java.awt.Color(240, 240, 240));\n        furtherDescriptionArea.setColumns(20);\n        furtherDescriptionArea.setFont(furtherDescriptionArea.getFont().deriveFont(furtherDescriptionArea.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        furtherDescriptionArea.setLineWrap(true);\n        furtherDescriptionArea.setRows(5);\n        furtherDescriptionArea.setText(NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.furtherDescriptionArea.text\")); // NOI18N\n        furtherDescriptionArea.setWrapStyleWord(true);\n        furtherDescriptionArea.setPreferredSize(new java.awt.Dimension(378, 74));\n\n        infoIconLabel.setFont(infoIconLabel.getFont().deriveFont(infoIconLabel.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        infoIconLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/imagegallery/images/info-icon-16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(infoIconLabel, NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.infoIconLabel.text\")); // NOI18N\n\n        unavailableDuringInjestLabel.setFont(unavailableDuringInjestLabel.getFont().deriveFont(unavailableDuringInjestLabel.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        unavailableDuringInjestLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/imagegallery/images/warning16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(unavailableDuringInjestLabel, NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.unavailableDuringInjestLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(groupCategorizationWarningBox, NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.groupCategorizationWarningBox.text\")); // NOI18N\n        groupCategorizationWarningBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                groupCategorizationWarningBoxActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(21, 21, 21)\n                                .addComponent(unavailableDuringInjestLabel))\n                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                                .addComponent(enabledByDefaultBox)\n                                .addComponent(enabledForCaseBox)\n                                .addComponent(descriptionLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addGroup(layout.createSequentialGroup()\n                                    .addGap(21, 21, 21)\n                                    .addComponent(infoIconLabel)\n                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                    .addComponent(furtherDescriptionArea, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))\n                            .addComponent(groupCategorizationWarningBox))\n                        .addContainerGap(46, Short.MAX_VALUE))\n                    .addComponent(jSeparator1, javax.swing.GroupLayout.Alignment.TRAILING)))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(descriptionLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(enabledByDefaultBox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(enabledForCaseBox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(unavailableDuringInjestLabel)\n                .addGap(18, 18, 18)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(infoIconLabel)\n                    .addComponent(furtherDescriptionArea, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addGap(18, 18, 18)\n                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(groupCategorizationWarningBox)\n                .addContainerGap())\n        );\n    }","id":91615,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        enabledByDefaultBox = new javax.swing.JCheckBox();\n        enabledForCaseBox = new javax.swing.JCheckBox();\n        descriptionLabel = new javax.swing.JLabel();\n        furtherDescriptionArea = new javax.swing.JTextArea();\n        infoIconLabel = new javax.swing.JLabel();\n        unavailableDuringInjestLabel = new javax.swing.JLabel();\n        jSeparator1 = new javax.swing.JSeparator();\n        groupCategorizationWarningBox = new javax.swing.JCheckBox();\n\n        setFont(getFont().deriveFont(getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n\n        enabledByDefaultBox.setFont(enabledByDefaultBox.getFont().deriveFont(enabledByDefaultBox.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(enabledByDefaultBox, org.openide.util.NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.enabledByDefaultBox.text\")); // NOI18N\n        enabledByDefaultBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                enabledByDefaultBoxActionPerformed(evt);\n            }\n        });\n\n        enabledForCaseBox.setFont(enabledForCaseBox.getFont().deriveFont(enabledForCaseBox.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(enabledForCaseBox, org.openide.util.NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.enabledForCaseBox.text\")); // NOI18N\n        enabledForCaseBox.setToolTipText(NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.enabledForCaseBox.toolTipText\")); // NOI18N\n        enabledForCaseBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                enabledForCaseBoxActionPerformed(evt);\n            }\n        });\n\n        descriptionLabel.setFont(descriptionLabel.getFont().deriveFont(descriptionLabel.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        org.openide.awt.Mnemonics.setLocalizedText(descriptionLabel, org.openide.util.NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.descriptionLabel.text\")); // NOI18N\n\n        furtherDescriptionArea.setBackground(new java.awt.Color(240, 240, 240));\n        furtherDescriptionArea.setColumns(20);\n        furtherDescriptionArea.setFont(furtherDescriptionArea.getFont().deriveFont(furtherDescriptionArea.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        furtherDescriptionArea.setLineWrap(true);\n        furtherDescriptionArea.setRows(5);\n        furtherDescriptionArea.setText(NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.furtherDescriptionArea.text\")); // NOI18N\n        furtherDescriptionArea.setWrapStyleWord(true);\n        furtherDescriptionArea.setPreferredSize(new java.awt.Dimension(378, 74));\n\n        infoIconLabel.setFont(infoIconLabel.getFont().deriveFont(infoIconLabel.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        infoIconLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/imagegallery/images/info-icon-16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(infoIconLabel, NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.infoIconLabel.text\")); // NOI18N\n\n        unavailableDuringInjestLabel.setFont(unavailableDuringInjestLabel.getFont().deriveFont(unavailableDuringInjestLabel.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        unavailableDuringInjestLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/imagegallery/images/warning16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(unavailableDuringInjestLabel, NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.unavailableDuringInjestLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(groupCategorizationWarningBox, NbBundle.getMessage(ImageGalleryOptionsPanel.class, \"ImageGalleryOptionsPanel.groupCategorizationWarningBox.text\")); // NOI18N\n        groupCategorizationWarningBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                groupCategorizationWarningBoxActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(21, 21, 21)\n                                .addComponent(unavailableDuringInjestLabel))\n                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                                .addComponent(enabledByDefaultBox)\n                                .addComponent(enabledForCaseBox)\n                                .addComponent(descriptionLabel, javax.swing.GroupLayout.Alignment.TRAILING)\n                                .addGroup(layout.createSequentialGroup()\n                                    .addGap(21, 21, 21)\n                                    .addComponent(infoIconLabel)\n                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                    .addComponent(furtherDescriptionArea, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))\n                            .addComponent(groupCategorizationWarningBox))\n                        .addGap(0, 36, Short.MAX_VALUE))\n                    .addComponent(jSeparator1))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(descriptionLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(enabledByDefaultBox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(enabledForCaseBox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(unavailableDuringInjestLabel)\n                .addGap(18, 18, 18)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(infoIconLabel)\n                    .addComponent(furtherDescriptionArea, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addGap(18, 18, 18)\n                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(groupCategorizationWarningBox)\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n    }","commit_id":"4bc7a5dd305e204cca9387791b566b411a464b68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** {@inheritDoc} */\n    void load() {\n        enabledByDefaultBox.setSelected(ImageGalleryPreferences.isEnabledByDefault());\n        if (Case.isCaseOpen() && IngestManager.getInstance().isIngestRunning() == false) {\n            enabledForCaseBox.setEnabled(true);\n            enabledForCaseBox.setSelected(ImageGalleryModule.isEnabledforCase(Case.getCurrentCase()));\n        } else {\n            enabledForCaseBox.setEnabled(false);\n            enabledForCaseBox.setSelected(enabledByDefaultBox.isSelected());\n        }\n        groupCategorizationWarningBox.setSelected(ImageGalleryPreferences.isGroupCategorizationWarningDisabled());\n    }","id":91616,"modified_method":"void load() {\n        enabledByDefaultBox.setSelected(ImageGalleryPreferences.isEnabledByDefault());\n        if (Case.isCaseOpen() && IngestManager.getInstance().isIngestRunning() == false) {\n            enabledForCaseBox.setEnabled(true);\n            enabledForCaseBox.setSelected(ImageGalleryModule.isEnabledforCase(Case.getCurrentCase()));\n        } else {\n            enabledForCaseBox.setEnabled(false);\n            enabledForCaseBox.setSelected(enabledByDefaultBox.isSelected());\n        }\n        groupCategorizationWarningBox.setSelected(ImageGalleryPreferences.isGroupCategorizationWarningDisabled());\n    }","commit_id":"4bc7a5dd305e204cca9387791b566b411a464b68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public static boolean isGroupCategorizationWarningDisabled() {\n        final boolean aBoolean = preferences.getBoolean(GROUP_CATEGORIZATION_WARNING_DISABLED, false);\n        return aBoolean;\n    }","id":91617,"modified_method":"/**\n     * Return whether the warning about overwriting categories when acting on an\n     * entire group is disabled.\n     *\n     * @return true if the warning is disabled.\n     */\n    public static boolean isGroupCategorizationWarningDisabled() {\n        final boolean aBoolean = preferences.getBoolean(GROUP_CATEGORIZATION_WARNING_DISABLED, false);\n        return aBoolean;\n    }","commit_id":"4bc7a5dd305e204cca9387791b566b411a464b68","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\r\n    public void loadPlugins() {\r\n        logger.info(\"Loading plugins...\");\r\n        pm = PluginManagerFactory.createPluginManager();\r\n        pm.addPluginsFrom(new File(PLUGINS_DIRECTORY).toURI());\r\n        this.cardPlugin = new CardPluginImpl();\r\n        this.counterPlugin = pm.getPlugin(CounterPlugin.class);\r\n        this.themePlugin = pm.getPlugin(ThemePlugin.class);\r\n        logger.info(\"Done.\");\r\n    }","id":91618,"modified_method":"@Override\r\n    public void loadPlugins() {\r\n        logger.info(\"Loading plugins...\");\r\n        pm = PluginManagerFactory.createPluginManager();\r\n        pm.addPluginsFrom(new File(PLUGINS_DIRECTORY).toURI());\r\n        this.cardPlugin = new CardPluginImpl();\r\n        this.counterPlugin = pm.getPlugin(CounterPlugin.class);\r\n        //this.themePlugin = pm.getPlugin(ThemePlugin.class);\r\n        this.themePlugin = new ThemePluginImpl();\r\n        logger.info(\"Done.\");\r\n    }","commit_id":"fab2759579276909b534de603feb01f50d326d37","url":"https://github.com/magefree/mage"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jTabbedPane1 = new javax.swing.JTabbedPane();\n        jPanel1 = new javax.swing.JPanel();\n        jPanel3 = new javax.swing.JPanel();\n        showToolTipsInAnyZone = new javax.swing.JCheckBox();\n        displayBigCardsInHand = new javax.swing.JCheckBox();\n        jPanel7 = new javax.swing.JPanel();\n        nonLandPermanentsInOnePile = new javax.swing.JCheckBox();\n        jPanel2 = new javax.swing.JPanel();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        jLabel3 = new javax.swing.JLabel();\n        jLabel4 = new javax.swing.JLabel();\n        jLabel5 = new javax.swing.JLabel();\n        jLabel6 = new javax.swing.JLabel();\n        jLabel7 = new javax.swing.JLabel();\n        jLabel8 = new javax.swing.JLabel();\n        jLabel9 = new javax.swing.JLabel();\n        jLabel10 = new javax.swing.JLabel();\n        checkBoxUpkeepYou = new javax.swing.JCheckBox();\n        checkBoxDrawYou = new javax.swing.JCheckBox();\n        checkBoxMainYou = new javax.swing.JCheckBox();\n        checkBoxBeforeCYou = new javax.swing.JCheckBox();\n        checkBoxEndOfCYou = new javax.swing.JCheckBox();\n        checkBoxMain2You = new javax.swing.JCheckBox();\n        checkBoxEndTurnYou = new javax.swing.JCheckBox();\n        checkBoxUpkeepOthers = new javax.swing.JCheckBox();\n        checkBoxDrawOthers = new javax.swing.JCheckBox();\n        checkBoxMainOthers = new javax.swing.JCheckBox();\n        checkBoxBeforeCOthers = new javax.swing.JCheckBox();\n        checkBoxEndOfCOthers = new javax.swing.JCheckBox();\n        checkBoxMain2Others = new javax.swing.JCheckBox();\n        checkBoxEndTurnOthers = new javax.swing.JCheckBox();\n        jPanel4 = new javax.swing.JPanel();\n        jPanel5 = new javax.swing.JPanel();\n        useDefaultImageFolder = new javax.swing.JCheckBox();\n        imageFolderPath = new javax.swing.JTextField();\n        browseButton = new javax.swing.JButton();\n        checkForNewImages = new javax.swing.JCheckBox();\n        saveToZipFiles = new javax.swing.JCheckBox();\n        jPanel23 = new javax.swing.JPanel();\n        useDefaultBackground = new javax.swing.JCheckBox();\n        BackgroundImagePath = new javax.swing.JTextField();\n        BackgroundBrowseButton = new javax.swing.JButton();\n        BattlefieldImagePath = new javax.swing.JTextField();\n        BattlefieldBrowseButton = new javax.swing.JButton();\n        useDefaultBattleImage = new javax.swing.JCheckBox();\n        useRandomBattleImage = new javax.swing.JCheckBox();\n        jLabel14 = new javax.swing.JLabel();\n        jLabel15 = new javax.swing.JLabel();\n        jPanel22 = new javax.swing.JPanel();\n        jEnableSounds = new javax.swing.JCheckBox();\n        jEnableMusics = new javax.swing.JCheckBox();\n        jPanel6 = new javax.swing.JPanel();\n        lblProxyType = new javax.swing.JLabel();\n        cbProxyType = new javax.swing.JComboBox();\n        pnlProxySettings = new javax.swing.JPanel();\n        pnlProxy = new javax.swing.JPanel();\n        lblProxyServer = new javax.swing.JLabel();\n        txtProxyServer = new javax.swing.JTextField();\n        lblProxyPort = new javax.swing.JLabel();\n        txtProxyPort = new javax.swing.JTextField();\n        lblProxyUserName = new javax.swing.JLabel();\n        txtProxyUserName = new javax.swing.JTextField();\n        lblProxyPassword = new javax.swing.JLabel();\n        txtPasswordField = new javax.swing.JPasswordField();\n        rememberPswd = new javax.swing.JCheckBox();\n        jLabel11 = new javax.swing.JLabel();\n        jPanel8 = new javax.swing.JPanel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        jPanel9 = new javax.swing.JPanel();\n        jPanel10 = new javax.swing.JPanel();\n        jPanel13 = new javax.swing.JPanel();\n        jPanel11 = new javax.swing.JPanel();\n        jLabel12 = new javax.swing.JLabel();\n        jPanel12 = new javax.swing.JPanel();\n        jPanel14 = new javax.swing.JPanel();\n        jPanel15 = new javax.swing.JPanel();\n        jLabel13 = new javax.swing.JLabel();\n        jPanel16 = new javax.swing.JPanel();\n        jPanel17 = new javax.swing.JPanel();\n        jPanel18 = new javax.swing.JPanel();\n        jPanel19 = new javax.swing.JPanel();\n        jPanel20 = new javax.swing.JPanel();\n        jPanel21 = new javax.swing.JPanel();\n        saveButton = new javax.swing.JButton();\n        exitButton = new javax.swing.JButton();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);\n        setTitle(\"Preferences\");\n\n        jPanel3.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), \"Hand\"));\n\n        showToolTipsInAnyZone.setSelected(true);\n        showToolTipsInAnyZone.setText(\"Show tooltips\");\n        showToolTipsInAnyZone.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                showToolTipsInAnyZoneActionPerformed(evt);\n            }\n        });\n\n        displayBigCardsInHand.setText(\"Use big images (for high resolution screens)\");\n        displayBigCardsInHand.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                displayBigCardsInHandActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);\n        jPanel3.setLayout(jPanel3Layout);\n        jPanel3Layout.setHorizontalGroup(\n            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel3Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(showToolTipsInAnyZone)\n                    .addComponent(displayBigCardsInHand))\n                .addContainerGap(166, Short.MAX_VALUE))\n        );\n        jPanel3Layout.setVerticalGroup(\n            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel3Layout.createSequentialGroup()\n                .addComponent(showToolTipsInAnyZone)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(displayBigCardsInHand)\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n\n        jPanel7.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), \"Battlefield\"));\n\n        nonLandPermanentsInOnePile.setSelected(true);\n        nonLandPermanentsInOnePile.setLabel(\"Put non-land permanents in one pile\");\n        nonLandPermanentsInOnePile.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                nonLandPermanentsInOnePileActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);\n        jPanel7.setLayout(jPanel7Layout);\n        jPanel7Layout.setHorizontalGroup(\n            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel7Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(nonLandPermanentsInOnePile)\n                .addContainerGap(204, Short.MAX_VALUE))\n        );\n        jPanel7Layout.setVerticalGroup(\n            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel7Layout.createSequentialGroup()\n                .addComponent(nonLandPermanentsInOnePile)\n                .addContainerGap(30, Short.MAX_VALUE))\n        );\n\n        nonLandPermanentsInOnePile.getAccessibleContext().setAccessibleName(\"nonLandPermanentsInOnePile\");\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jPanel7, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(jPanel3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap(194, Short.MAX_VALUE))\n        );\n\n        jTabbedPane1.addTab(\"Main\", jPanel1);\n\n        jLabel1.setText(\"Choose phases MAGE will stop on:\");\n\n        jLabel2.setText(\"Upkeep:\");\n\n        jLabel3.setText(\"Draw:\");\n\n        jLabel4.setText(\"Main:\");\n\n        jLabel5.setText(\"Before combat:\");\n\n        jLabel6.setText(\"End of combat:\");\n\n        jLabel7.setText(\"Main 2:\");\n\n        jLabel8.setText(\"End of turn:\");\n\n        jLabel9.setText(\"Your turn\");\n\n        jLabel10.setText(\"Opponent(s) turn\");\n\n        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);\n        jPanel2.setLayout(jPanel2Layout);\n        jPanel2Layout.setHorizontalGroup(\n            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel2Layout.createSequentialGroup()\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addGap(20, 20, 20)\n                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(jPanel2Layout.createSequentialGroup()\n                                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(jLabel2)\n                                    .addComponent(jLabel5)\n                                    .addComponent(jLabel6)\n                                    .addComponent(jLabel7)\n                                    .addComponent(jLabel8))\n                                .addGap(77, 77, 77)\n                                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(jPanel2Layout.createSequentialGroup()\n                                        .addGap(2, 2, 2)\n                                        .addComponent(jLabel9)\n                                        .addGap(32, 32, 32)\n                                        .addComponent(jLabel10))\n                                    .addGroup(jPanel2Layout.createSequentialGroup()\n                                        .addGap(13, 13, 13)\n                                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                                            .addComponent(checkBoxDrawYou)\n                                            .addComponent(checkBoxUpkeepYou)\n                                            .addComponent(checkBoxMainYou)\n                                            .addComponent(checkBoxBeforeCYou)\n                                            .addComponent(checkBoxEndOfCYou)\n                                            .addComponent(checkBoxMain2You)\n                                            .addComponent(checkBoxEndTurnYou))\n                                        .addGap(78, 78, 78)\n                                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                                            .addComponent(checkBoxUpkeepOthers)\n                                            .addComponent(checkBoxBeforeCOthers)\n                                            .addComponent(checkBoxMainOthers)\n                                            .addComponent(checkBoxEndOfCOthers)\n                                            .addComponent(checkBoxDrawOthers)\n                                            .addComponent(checkBoxMain2Others)\n                                            .addComponent(checkBoxEndTurnOthers)))))\n                            .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                                .addComponent(jLabel4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                .addComponent(jLabel3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(jLabel1)))\n                .addContainerGap(105, Short.MAX_VALUE))\n        );\n        jPanel2Layout.setVerticalGroup(\n            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel2Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addComponent(jLabel10)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(checkBoxUpkeepOthers))\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addGroup(jPanel2Layout.createSequentialGroup()\n                                .addComponent(jLabel1)\n                                .addGap(20, 20, 20))\n                            .addComponent(jLabel9))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addComponent(checkBoxUpkeepYou)\n                            .addComponent(jLabel2))))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jLabel3)\n                    .addComponent(checkBoxDrawYou)\n                    .addComponent(checkBoxDrawOthers))\n                .addGap(4, 4, 4)\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jLabel4)\n                    .addComponent(checkBoxMainYou)\n                    .addComponent(checkBoxMainOthers))\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jLabel5, javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addComponent(checkBoxBeforeCYou, javax.swing.GroupLayout.Alignment.TRAILING)))\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addGap(6, 6, 6)\n                        .addComponent(checkBoxBeforeCOthers)))\n                .addGap(7, 7, 7)\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jLabel6)\n                    .addComponent(checkBoxEndOfCYou)\n                    .addComponent(checkBoxEndOfCOthers))\n                .addGap(9, 9, 9)\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jLabel7)\n                    .addComponent(checkBoxMain2You)\n                    .addComponent(checkBoxMain2Others))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(checkBoxEndTurnYou)\n                    .addComponent(jLabel8)\n                    .addComponent(checkBoxEndTurnOthers))\n                .addContainerGap(126, Short.MAX_VALUE))\n        );\n\n        jTabbedPane1.addTab(\"Phases\", jPanel2);\n\n        jPanel5.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), \"Card images location:\"));\n\n        useDefaultImageFolder.setText(\"use default\");\n        useDefaultImageFolder.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                useDefaultImageFolderActionPerformed(evt);\n            }\n        });\n\n        browseButton.setText(\"Browse...\");\n        browseButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseButtonActionPerformed(evt);\n            }\n        });\n\n        checkForNewImages.setText(\"check for new images on startup\");\n        checkForNewImages.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                checkForNewImagesActionPerformed(evt);\n            }\n        });\n\n        saveToZipFiles.setText(\"store in zip files\");\n        saveToZipFiles.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveToZipFilesActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);\n        jPanel5.setLayout(jPanel5Layout);\n        jPanel5Layout.setHorizontalGroup(\n            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel5Layout.createSequentialGroup()\n                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel5Layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(useDefaultImageFolder))\n                    .addGroup(jPanel5Layout.createSequentialGroup()\n                        .addGap(19, 19, 19)\n                        .addComponent(imageFolderPath, javax.swing.GroupLayout.PREFERRED_SIZE, 284, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(browseButton))\n                    .addGroup(jPanel5Layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(checkForNewImages))\n                    .addGroup(jPanel5Layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(saveToZipFiles)))\n                .addContainerGap(15, Short.MAX_VALUE))\n        );\n        jPanel5Layout.setVerticalGroup(\n            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel5Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(useDefaultImageFolder)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(imageFolderPath, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(browseButton))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(checkForNewImages)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(saveToZipFiles)\n                .addContainerGap(22, Short.MAX_VALUE))\n        );\n\n        jPanel23.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), \"Background images setting:\"));\n\n        useDefaultBackground.setText(\"use default image\");\n        useDefaultBackground.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                useDefaultBackgroundActionPerformed(evt);\n            }\n        });\n\n        BackgroundImagePath.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                BackgroundImagePathActionPerformed(evt);\n            }\n        });\n\n        BackgroundBrowseButton.setText(\"Browse...\");\n        BackgroundBrowseButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                BackgroundBrowseButtonActionPerformed(evt);\n            }\n        });\n\n        BattlefieldImagePath.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                BattlefieldImagePathActionPerformed(evt);\n            }\n        });\n\n        BattlefieldBrowseButton.setText(\"Browse...\");\n        BattlefieldBrowseButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                BattlefieldBrowseButtonActionPerformed(evt);\n            }\n        });\n\n        useDefaultBattleImage.setText(\"default battlefield image\");\n        useDefaultBattleImage.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                useDefaultBattleImageActionPerformed(evt);\n            }\n        });\n\n        useRandomBattleImage.setText(\"random battlefield image\");\n        useRandomBattleImage.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                useRandomBattleImageActionPerformed(evt);\n            }\n        });\n\n        jLabel14.setText(\"Background:\");\n\n        jLabel15.setText(\"Battlefield:\");\n\n        javax.swing.GroupLayout jPanel23Layout = new javax.swing.GroupLayout(jPanel23);\n        jPanel23.setLayout(jPanel23Layout);\n        jPanel23Layout.setHorizontalGroup(\n            jPanel23Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel23Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel23Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel23Layout.createSequentialGroup()\n                        .addComponent(useDefaultBackground)\n                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel23Layout.createSequentialGroup()\n                        .addGroup(jPanel23Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addGroup(jPanel23Layout.createSequentialGroup()\n                                .addGap(0, 0, Short.MAX_VALUE)\n                                .addComponent(jLabel14)\n                                .addGap(18, 18, 18)\n                                .addComponent(BackgroundImagePath, javax.swing.GroupLayout.PREFERRED_SIZE, 210, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(BackgroundBrowseButton))\n                            .addGroup(jPanel23Layout.createSequentialGroup()\n                                .addComponent(jLabel15)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                .addComponent(BattlefieldImagePath, javax.swing.GroupLayout.PREFERRED_SIZE, 212, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(BattlefieldBrowseButton)))\n                        .addGap(18, 18, 18))\n                    .addGroup(jPanel23Layout.createSequentialGroup()\n                        .addGroup(jPanel23Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(useDefaultBattleImage)\n                            .addComponent(useRandomBattleImage))\n                        .addGap(0, 0, Short.MAX_VALUE))))\n        );\n        jPanel23Layout.setVerticalGroup(\n            jPanel23Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel23Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(useDefaultBackground)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(jPanel23Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(BackgroundImagePath, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(BackgroundBrowseButton)\n                    .addComponent(jLabel14))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(useDefaultBattleImage)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(useRandomBattleImage)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 9, Short.MAX_VALUE)\n                .addGroup(jPanel23Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(BattlefieldImagePath, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(BattlefieldBrowseButton)\n                    .addComponent(jLabel15))\n                .addContainerGap())\n        );\n\n        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);\n        jPanel4.setLayout(jPanel4Layout);\n        jPanel4Layout.setHorizontalGroup(\n            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jPanel23, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        jPanel4Layout.setVerticalGroup(\n            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel4Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jPanel5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jPanel23, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addContainerGap())\n        );\n\n        jTabbedPane1.addTab(\"Images\", jPanel4);\n\n        jEnableSounds.setText(\"enable sounds\");\n        jEnableSounds.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jEnableSoundsActionPerformed(evt);\n            }\n        });\n\n        jEnableMusics.setText(\"enable BGM\");\n        jEnableMusics.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jEnableMusicsActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout jPanel22Layout = new javax.swing.GroupLayout(jPanel22);\n        jPanel22.setLayout(jPanel22Layout);\n        jPanel22Layout.setHorizontalGroup(\n            jPanel22Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel22Layout.createSequentialGroup()\n                .addGap(19, 19, 19)\n                .addGroup(jPanel22Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jEnableSounds)\n                    .addComponent(jEnableMusics))\n                .addContainerGap(325, Short.MAX_VALUE))\n        );\n        jPanel22Layout.setVerticalGroup(\n            jPanel22Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel22Layout.createSequentialGroup()\n                .addGap(24, 24, 24)\n                .addComponent(jEnableSounds)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jEnableMusics)\n                .addContainerGap(296, Short.MAX_VALUE))\n        );\n\n        jTabbedPane1.addTab(\"Sounds\", jPanel22);\n\n        lblProxyType.setText(\"Proxy:\");\n\n        cbProxyType.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                cbProxyTypeActionPerformed(evt);\n            }\n        });\n\n        pnlProxySettings.setBorder(javax.swing.BorderFactory.createEtchedBorder());\n\n        lblProxyServer.setText(\"Server:\");\n\n        lblProxyPort.setText(\"Port:\");\n\n        txtProxyPort.addKeyListener(new java.awt.event.KeyAdapter() {\n            public void keyTyped(java.awt.event.KeyEvent evt) {\n                txtProxyPortkeyTyped(evt);\n            }\n        });\n\n        lblProxyUserName.setText(\"User Name:\");\n\n        lblProxyPassword.setText(\"Password:\");\n\n        txtPasswordField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                txtPasswordFieldActionPerformed(evt);\n            }\n        });\n\n        rememberPswd.setText(\"Remember Password\");\n        rememberPswd.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                rememberPswdActionPerformed(evt);\n            }\n        });\n\n        jLabel11.setFont(new java.awt.Font(\"Tahoma\", 2, 10)); // NOI18N\n        jLabel11.setText(\"Note: password won't be encrypted!\");\n\n        javax.swing.GroupLayout pnlProxyLayout = new javax.swing.GroupLayout(pnlProxy);\n        pnlProxy.setLayout(pnlProxyLayout);\n        pnlProxyLayout.setHorizontalGroup(\n            pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(pnlProxyLayout.createSequentialGroup()\n                .addGap(29, 29, 29)\n                .addComponent(rememberPswd)\n                .addGap(18, 18, 18)\n                .addComponent(jLabel11)\n                .addGap(34, 34, 34))\n            .addGroup(pnlProxyLayout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(lblProxyPort)\n                    .addComponent(lblProxyPassword)\n                    .addComponent(lblProxyServer)\n                    .addComponent(lblProxyUserName))\n                .addGap(19, 19, 19)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(txtProxyPort, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                        .addComponent(txtPasswordField, javax.swing.GroupLayout.Alignment.LEADING)\n                        .addComponent(txtProxyUserName, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 148, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addComponent(txtProxyServer, javax.swing.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        pnlProxyLayout.setVerticalGroup(\n            pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(pnlProxyLayout.createSequentialGroup()\n                .addGap(6, 6, 6)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(txtProxyServer, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblProxyServer))\n                .addGap(8, 8, 8)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblProxyPort)\n                    .addComponent(txtProxyPort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(txtProxyUserName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblProxyUserName))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(txtPasswordField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblProxyPassword))\n                .addGap(18, 18, 18)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(rememberPswd)\n                    .addComponent(jLabel11))\n                .addContainerGap(25, Short.MAX_VALUE))\n        );\n\n        javax.swing.GroupLayout pnlProxySettingsLayout = new javax.swing.GroupLayout(pnlProxySettings);\n        pnlProxySettings.setLayout(pnlProxySettingsLayout);\n        pnlProxySettingsLayout.setHorizontalGroup(\n            pnlProxySettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(pnlProxySettingsLayout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(pnlProxy, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addContainerGap())\n        );\n        pnlProxySettingsLayout.setVerticalGroup(\n            pnlProxySettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(pnlProxySettingsLayout.createSequentialGroup()\n                .addComponent(pnlProxy, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addContainerGap())\n        );\n\n        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);\n        jPanel6.setLayout(jPanel6Layout);\n        jPanel6Layout.setHorizontalGroup(\n            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel6Layout.createSequentialGroup()\n                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel6Layout.createSequentialGroup()\n                        .addGap(40, 40, 40)\n                        .addComponent(lblProxyType)\n                        .addGap(18, 18, 18)\n                        .addComponent(cbProxyType, javax.swing.GroupLayout.PREFERRED_SIZE, 126, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(jPanel6Layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(pnlProxySettings, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))\n                .addContainerGap())\n        );\n        jPanel6Layout.setVerticalGroup(\n            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel6Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblProxyType)\n                    .addComponent(cbProxyType, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(pnlProxySettings, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap(142, Short.MAX_VALUE))\n        );\n\n        pnlProxySettings.getAccessibleContext().setAccessibleDescription(\"\");\n\n        jTabbedPane1.addTab(\"Connection\", jPanel6);\n\n        jPanel10.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel10Layout = new javax.swing.GroupLayout(jPanel10);\n        jPanel10.setLayout(jPanel10Layout);\n        jPanel10Layout.setHorizontalGroup(\n            jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel10Layout.setVerticalGroup(\n            jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel13.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel13Layout = new javax.swing.GroupLayout(jPanel13);\n        jPanel13.setLayout(jPanel13Layout);\n        jPanel13Layout.setHorizontalGroup(\n            jPanel13Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel13Layout.setVerticalGroup(\n            jPanel13Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel11.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel11Layout = new javax.swing.GroupLayout(jPanel11);\n        jPanel11.setLayout(jPanel11Layout);\n        jPanel11Layout.setHorizontalGroup(\n            jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel11Layout.setVerticalGroup(\n            jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jLabel12.setFont(new java.awt.Font(\"Tahoma\", 1, 11)); // NOI18N\n        jLabel12.setText(\"Choose your avatar:\");\n\n        jPanel12.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel12Layout = new javax.swing.GroupLayout(jPanel12);\n        jPanel12.setLayout(jPanel12Layout);\n        jPanel12Layout.setHorizontalGroup(\n            jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel12Layout.setVerticalGroup(\n            jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel14.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel14Layout = new javax.swing.GroupLayout(jPanel14);\n        jPanel14.setLayout(jPanel14Layout);\n        jPanel14Layout.setHorizontalGroup(\n            jPanel14Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel14Layout.setVerticalGroup(\n            jPanel14Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel15.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel15Layout = new javax.swing.GroupLayout(jPanel15);\n        jPanel15.setLayout(jPanel15Layout);\n        jPanel15Layout.setHorizontalGroup(\n            jPanel15Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel15Layout.setVerticalGroup(\n            jPanel15Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jLabel13.setFont(new java.awt.Font(\"Tahoma\", 1, 11)); // NOI18N\n        jLabel13.setText(\"New avatars:\");\n\n        jPanel16.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel16Layout = new javax.swing.GroupLayout(jPanel16);\n        jPanel16.setLayout(jPanel16Layout);\n        jPanel16Layout.setHorizontalGroup(\n            jPanel16Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel16Layout.setVerticalGroup(\n            jPanel16Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel17.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel17Layout = new javax.swing.GroupLayout(jPanel17);\n        jPanel17.setLayout(jPanel17Layout);\n        jPanel17Layout.setHorizontalGroup(\n            jPanel17Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel17Layout.setVerticalGroup(\n            jPanel17Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel18.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel18Layout = new javax.swing.GroupLayout(jPanel18);\n        jPanel18.setLayout(jPanel18Layout);\n        jPanel18Layout.setHorizontalGroup(\n            jPanel18Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel18Layout.setVerticalGroup(\n            jPanel18Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel19.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel19Layout = new javax.swing.GroupLayout(jPanel19);\n        jPanel19.setLayout(jPanel19Layout);\n        jPanel19Layout.setHorizontalGroup(\n            jPanel19Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel19Layout.setVerticalGroup(\n            jPanel19Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel20.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel20Layout = new javax.swing.GroupLayout(jPanel20);\n        jPanel20.setLayout(jPanel20Layout);\n        jPanel20Layout.setHorizontalGroup(\n            jPanel20Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel20Layout.setVerticalGroup(\n            jPanel20Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel21.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel21Layout = new javax.swing.GroupLayout(jPanel21);\n        jPanel21.setLayout(jPanel21Layout);\n        jPanel21Layout.setHorizontalGroup(\n            jPanel21Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel21Layout.setVerticalGroup(\n            jPanel21Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        javax.swing.GroupLayout jPanel9Layout = new javax.swing.GroupLayout(jPanel9);\n        jPanel9.setLayout(jPanel9Layout);\n        jPanel9Layout.setHorizontalGroup(\n            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel9Layout.createSequentialGroup()\n                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel9Layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(jLabel12))\n                    .addGroup(jPanel9Layout.createSequentialGroup()\n                        .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(jPanel9Layout.createSequentialGroup()\n                                .addGap(30, 30, 30)\n                                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                                    .addComponent(jPanel12, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addComponent(jPanel10, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addComponent(jPanel19, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addGap(33, 33, 33)\n                                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(jPanel13, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addComponent(jPanel14, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addComponent(jPanel20, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                            .addGroup(jPanel9Layout.createSequentialGroup()\n                                .addContainerGap()\n                                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(jPanel9Layout.createSequentialGroup()\n                                        .addGap(20, 20, 20)\n                                        .addComponent(jPanel16, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                        .addGap(33, 33, 33)\n                                        .addComponent(jPanel17, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                    .addComponent(jLabel13))))\n                        .addGap(32, 32, 32)\n                        .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jPanel18, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(jPanel21, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(jPanel15, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(jPanel11, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))\n                .addContainerGap(29, Short.MAX_VALUE))\n        );\n        jPanel9Layout.setVerticalGroup(\n            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel9Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jLabel12)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jPanel11, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jPanel13, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jPanel10, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addGap(26, 26, 26)\n                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jPanel15, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jPanel12, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jPanel14, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addGap(23, 23, 23)\n                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jPanel19, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jPanel20, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jPanel21, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addGap(18, 18, 18)\n                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(jPanel9Layout.createSequentialGroup()\n                        .addComponent(jLabel13)\n                        .addGap(18, 18, 18)\n                        .addComponent(jPanel16, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addComponent(jPanel17, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jPanel18, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addGap(25, 25, 25))\n        );\n\n        jScrollPane1.setViewportView(jPanel9);\n\n        javax.swing.GroupLayout jPanel8Layout = new javax.swing.GroupLayout(jPanel8);\n        jPanel8.setLayout(jPanel8Layout);\n        jPanel8Layout.setHorizontalGroup(\n            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 439, Short.MAX_VALUE)\n        );\n        jPanel8Layout.setVerticalGroup(\n            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 366, Short.MAX_VALUE)\n        );\n\n        jTabbedPane1.addTab(\"Avatars\", jPanel8);\n\n        saveButton.setLabel(\"Save\");\n        saveButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveButtonActionPerformed(evt);\n            }\n        });\n\n        exitButton.setLabel(\"Exit\");\n        exitButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                exitButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jTabbedPane1)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(saveButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(exitButton, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jTabbedPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 394, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(exitButton)\n                    .addComponent(saveButton))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n\n        pack();\n    }","id":91619,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jTabbedPane1 = new javax.swing.JTabbedPane();\n        jPanel1 = new javax.swing.JPanel();\n        jPanel3 = new javax.swing.JPanel();\n        showToolTipsInAnyZone = new javax.swing.JCheckBox();\n        displayBigCardsInHand = new javax.swing.JCheckBox();\n        jPanel7 = new javax.swing.JPanel();\n        nonLandPermanentsInOnePile = new javax.swing.JCheckBox();\n        jPanel2 = new javax.swing.JPanel();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        jLabel3 = new javax.swing.JLabel();\n        jLabel4 = new javax.swing.JLabel();\n        jLabel5 = new javax.swing.JLabel();\n        jLabel6 = new javax.swing.JLabel();\n        jLabel7 = new javax.swing.JLabel();\n        jLabel8 = new javax.swing.JLabel();\n        jLabel9 = new javax.swing.JLabel();\n        jLabel10 = new javax.swing.JLabel();\n        checkBoxUpkeepYou = new javax.swing.JCheckBox();\n        checkBoxDrawYou = new javax.swing.JCheckBox();\n        checkBoxMainYou = new javax.swing.JCheckBox();\n        checkBoxBeforeCYou = new javax.swing.JCheckBox();\n        checkBoxEndOfCYou = new javax.swing.JCheckBox();\n        checkBoxMain2You = new javax.swing.JCheckBox();\n        checkBoxEndTurnYou = new javax.swing.JCheckBox();\n        checkBoxUpkeepOthers = new javax.swing.JCheckBox();\n        checkBoxDrawOthers = new javax.swing.JCheckBox();\n        checkBoxMainOthers = new javax.swing.JCheckBox();\n        checkBoxBeforeCOthers = new javax.swing.JCheckBox();\n        checkBoxEndOfCOthers = new javax.swing.JCheckBox();\n        checkBoxMain2Others = new javax.swing.JCheckBox();\n        checkBoxEndTurnOthers = new javax.swing.JCheckBox();\n        jPanel4 = new javax.swing.JPanel();\n        jPanel5 = new javax.swing.JPanel();\n        useDefaultImageFolder = new javax.swing.JCheckBox();\n        imageFolderPath = new javax.swing.JTextField();\n        browseButton = new javax.swing.JButton();\n        checkForNewImages = new javax.swing.JCheckBox();\n        saveToZipFiles = new javax.swing.JCheckBox();\n        jPanel23 = new javax.swing.JPanel();\n        useDefaultBackground = new javax.swing.JCheckBox();\n        BackgroundImagePath = new javax.swing.JTextField();\n        BackgroundBrowseButton = new javax.swing.JButton();\n        BattlefieldImagePath = new javax.swing.JTextField();\n        BattlefieldBrowseButton = new javax.swing.JButton();\n        useDefaultBattleImage = new javax.swing.JCheckBox();\n        useRandomBattleImage = new javax.swing.JCheckBox();\n        jLabel14 = new javax.swing.JLabel();\n        jLabel15 = new javax.swing.JLabel();\n        jPanel22 = new javax.swing.JPanel();\n        jEnableSounds = new javax.swing.JCheckBox();\n        jEnableMusics = new javax.swing.JCheckBox();\n        jPanel6 = new javax.swing.JPanel();\n        lblProxyType = new javax.swing.JLabel();\n        cbProxyType = new javax.swing.JComboBox();\n        pnlProxySettings = new javax.swing.JPanel();\n        pnlProxy = new javax.swing.JPanel();\n        lblProxyServer = new javax.swing.JLabel();\n        txtProxyServer = new javax.swing.JTextField();\n        lblProxyPort = new javax.swing.JLabel();\n        txtProxyPort = new javax.swing.JTextField();\n        lblProxyUserName = new javax.swing.JLabel();\n        txtProxyUserName = new javax.swing.JTextField();\n        lblProxyPassword = new javax.swing.JLabel();\n        txtPasswordField = new javax.swing.JPasswordField();\n        rememberPswd = new javax.swing.JCheckBox();\n        jLabel11 = new javax.swing.JLabel();\n        jPanel8 = new javax.swing.JPanel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        jPanel9 = new javax.swing.JPanel();\n        jPanel10 = new javax.swing.JPanel();\n        jPanel13 = new javax.swing.JPanel();\n        jPanel11 = new javax.swing.JPanel();\n        jLabel12 = new javax.swing.JLabel();\n        jPanel12 = new javax.swing.JPanel();\n        jPanel14 = new javax.swing.JPanel();\n        jPanel15 = new javax.swing.JPanel();\n        jLabel13 = new javax.swing.JLabel();\n        jPanel16 = new javax.swing.JPanel();\n        jPanel17 = new javax.swing.JPanel();\n        jPanel18 = new javax.swing.JPanel();\n        jPanel19 = new javax.swing.JPanel();\n        jPanel20 = new javax.swing.JPanel();\n        jPanel21 = new javax.swing.JPanel();\n        saveButton = new javax.swing.JButton();\n        exitButton = new javax.swing.JButton();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);\n        setTitle(\"Preferences\");\n\n        jPanel3.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), \"Hand\"));\n\n        showToolTipsInAnyZone.setSelected(true);\n        showToolTipsInAnyZone.setText(\"Show tooltips\");\n        showToolTipsInAnyZone.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                showToolTipsInAnyZoneActionPerformed(evt);\n            }\n        });\n\n        displayBigCardsInHand.setText(\"Use big images (for high resolution screens)\");\n        displayBigCardsInHand.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                displayBigCardsInHandActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);\n        jPanel3.setLayout(jPanel3Layout);\n        jPanel3Layout.setHorizontalGroup(\n            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel3Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(showToolTipsInAnyZone)\n                    .addComponent(displayBigCardsInHand))\n                .addContainerGap(164, Short.MAX_VALUE))\n        );\n        jPanel3Layout.setVerticalGroup(\n            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel3Layout.createSequentialGroup()\n                .addComponent(showToolTipsInAnyZone)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(displayBigCardsInHand)\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n\n        jPanel7.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), \"Battlefield\"));\n\n        nonLandPermanentsInOnePile.setSelected(true);\n        nonLandPermanentsInOnePile.setLabel(\"Put non-land permanents in one pile\");\n        nonLandPermanentsInOnePile.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                nonLandPermanentsInOnePileActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);\n        jPanel7.setLayout(jPanel7Layout);\n        jPanel7Layout.setHorizontalGroup(\n            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel7Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(nonLandPermanentsInOnePile)\n                .addContainerGap(202, Short.MAX_VALUE))\n        );\n        jPanel7Layout.setVerticalGroup(\n            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel7Layout.createSequentialGroup()\n                .addComponent(nonLandPermanentsInOnePile)\n                .addContainerGap(30, Short.MAX_VALUE))\n        );\n\n        nonLandPermanentsInOnePile.getAccessibleContext().setAccessibleName(\"nonLandPermanentsInOnePile\");\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jPanel7, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(jPanel3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap(230, Short.MAX_VALUE))\n        );\n\n        jTabbedPane1.addTab(\"Main\", jPanel1);\n\n        jLabel1.setText(\"Choose phases MAGE will stop on:\");\n\n        jLabel2.setText(\"Upkeep:\");\n\n        jLabel3.setText(\"Draw:\");\n\n        jLabel4.setText(\"Main:\");\n\n        jLabel5.setText(\"Before combat:\");\n\n        jLabel6.setText(\"End of combat:\");\n\n        jLabel7.setText(\"Main 2:\");\n\n        jLabel8.setText(\"End of turn:\");\n\n        jLabel9.setText(\"Your turn\");\n\n        jLabel10.setText(\"Opponent(s) turn\");\n\n        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);\n        jPanel2.setLayout(jPanel2Layout);\n        jPanel2Layout.setHorizontalGroup(\n            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel2Layout.createSequentialGroup()\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addGap(20, 20, 20)\n                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(jPanel2Layout.createSequentialGroup()\n                                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(jLabel2)\n                                    .addComponent(jLabel5)\n                                    .addComponent(jLabel6)\n                                    .addComponent(jLabel7)\n                                    .addComponent(jLabel8))\n                                .addGap(77, 77, 77)\n                                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(jPanel2Layout.createSequentialGroup()\n                                        .addGap(2, 2, 2)\n                                        .addComponent(jLabel9)\n                                        .addGap(32, 32, 32)\n                                        .addComponent(jLabel10))\n                                    .addGroup(jPanel2Layout.createSequentialGroup()\n                                        .addGap(13, 13, 13)\n                                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                                            .addComponent(checkBoxDrawYou)\n                                            .addComponent(checkBoxUpkeepYou)\n                                            .addComponent(checkBoxMainYou)\n                                            .addComponent(checkBoxBeforeCYou)\n                                            .addComponent(checkBoxEndOfCYou)\n                                            .addComponent(checkBoxMain2You)\n                                            .addComponent(checkBoxEndTurnYou))\n                                        .addGap(78, 78, 78)\n                                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                                            .addComponent(checkBoxUpkeepOthers)\n                                            .addComponent(checkBoxBeforeCOthers)\n                                            .addComponent(checkBoxMainOthers)\n                                            .addComponent(checkBoxEndOfCOthers)\n                                            .addComponent(checkBoxDrawOthers)\n                                            .addComponent(checkBoxMain2Others)\n                                            .addComponent(checkBoxEndTurnOthers)))))\n                            .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                                .addComponent(jLabel4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                .addComponent(jLabel3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(jLabel1)))\n                .addContainerGap(103, Short.MAX_VALUE))\n        );\n        jPanel2Layout.setVerticalGroup(\n            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel2Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addComponent(jLabel10)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(checkBoxUpkeepOthers))\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addGroup(jPanel2Layout.createSequentialGroup()\n                                .addComponent(jLabel1)\n                                .addGap(20, 20, 20))\n                            .addComponent(jLabel9))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addComponent(checkBoxUpkeepYou)\n                            .addComponent(jLabel2))))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jLabel3)\n                    .addComponent(checkBoxDrawYou)\n                    .addComponent(checkBoxDrawOthers))\n                .addGap(4, 4, 4)\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jLabel4)\n                    .addComponent(checkBoxMainYou)\n                    .addComponent(checkBoxMainOthers))\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jLabel5, javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addComponent(checkBoxBeforeCYou, javax.swing.GroupLayout.Alignment.TRAILING)))\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addGap(6, 6, 6)\n                        .addComponent(checkBoxBeforeCOthers)))\n                .addGap(7, 7, 7)\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jLabel6)\n                    .addComponent(checkBoxEndOfCYou)\n                    .addComponent(checkBoxEndOfCOthers))\n                .addGap(9, 9, 9)\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jLabel7)\n                    .addComponent(checkBoxMain2You)\n                    .addComponent(checkBoxMain2Others))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(checkBoxEndTurnYou)\n                    .addComponent(jLabel8)\n                    .addComponent(checkBoxEndTurnOthers))\n                .addContainerGap(162, Short.MAX_VALUE))\n        );\n\n        jTabbedPane1.addTab(\"Phases\", jPanel2);\n\n        jPanel5.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), \"Card images location:\"));\n\n        useDefaultImageFolder.setText(\"use default\");\n        useDefaultImageFolder.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                useDefaultImageFolderActionPerformed(evt);\n            }\n        });\n\n        browseButton.setText(\"Browse...\");\n        browseButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseButtonActionPerformed(evt);\n            }\n        });\n\n        checkForNewImages.setText(\"check for new images on startup\");\n        checkForNewImages.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                checkForNewImagesActionPerformed(evt);\n            }\n        });\n\n        saveToZipFiles.setText(\"store in zip files\");\n        saveToZipFiles.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveToZipFilesActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);\n        jPanel5.setLayout(jPanel5Layout);\n        jPanel5Layout.setHorizontalGroup(\n            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel5Layout.createSequentialGroup()\n                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel5Layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(useDefaultImageFolder))\n                    .addGroup(jPanel5Layout.createSequentialGroup()\n                        .addGap(19, 19, 19)\n                        .addComponent(imageFolderPath, javax.swing.GroupLayout.PREFERRED_SIZE, 284, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(browseButton))\n                    .addGroup(jPanel5Layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(checkForNewImages))\n                    .addGroup(jPanel5Layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(saveToZipFiles)))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n        jPanel5Layout.setVerticalGroup(\n            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel5Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(useDefaultImageFolder)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(imageFolderPath, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(browseButton))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(checkForNewImages)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(saveToZipFiles)\n                .addContainerGap(22, Short.MAX_VALUE))\n        );\n\n        jPanel23.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), \"Background images setting:\"));\n\n        useDefaultBackground.setText(\"use default image\");\n        useDefaultBackground.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                useDefaultBackgroundActionPerformed(evt);\n            }\n        });\n\n        BackgroundImagePath.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                BackgroundImagePathActionPerformed(evt);\n            }\n        });\n\n        BackgroundBrowseButton.setText(\"Browse...\");\n        BackgroundBrowseButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                BackgroundBrowseButtonActionPerformed(evt);\n            }\n        });\n\n        BattlefieldImagePath.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                BattlefieldImagePathActionPerformed(evt);\n            }\n        });\n\n        BattlefieldBrowseButton.setText(\"Browse...\");\n        BattlefieldBrowseButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                BattlefieldBrowseButtonActionPerformed(evt);\n            }\n        });\n\n        useDefaultBattleImage.setText(\"default battlefield image\");\n        useDefaultBattleImage.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                useDefaultBattleImageActionPerformed(evt);\n            }\n        });\n\n        useRandomBattleImage.setText(\"random battlefield image\");\n        useRandomBattleImage.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                useRandomBattleImageActionPerformed(evt);\n            }\n        });\n\n        jLabel14.setText(\"Background:\");\n\n        jLabel15.setText(\"Battlefield:\");\n\n        javax.swing.GroupLayout jPanel23Layout = new javax.swing.GroupLayout(jPanel23);\n        jPanel23.setLayout(jPanel23Layout);\n        jPanel23Layout.setHorizontalGroup(\n            jPanel23Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel23Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel23Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel23Layout.createSequentialGroup()\n                        .addComponent(useDefaultBackground)\n                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel23Layout.createSequentialGroup()\n                        .addGroup(jPanel23Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addGroup(jPanel23Layout.createSequentialGroup()\n                                .addGap(0, 0, Short.MAX_VALUE)\n                                .addComponent(jLabel14)\n                                .addGap(18, 18, 18)\n                                .addComponent(BackgroundImagePath, javax.swing.GroupLayout.PREFERRED_SIZE, 210, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(BackgroundBrowseButton))\n                            .addGroup(jPanel23Layout.createSequentialGroup()\n                                .addComponent(jLabel15)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                .addComponent(BattlefieldImagePath, javax.swing.GroupLayout.PREFERRED_SIZE, 212, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(BattlefieldBrowseButton)))\n                        .addGap(18, 18, 18))\n                    .addGroup(jPanel23Layout.createSequentialGroup()\n                        .addGroup(jPanel23Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(useDefaultBattleImage)\n                            .addComponent(useRandomBattleImage))\n                        .addGap(0, 0, Short.MAX_VALUE))))\n        );\n        jPanel23Layout.setVerticalGroup(\n            jPanel23Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel23Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(useDefaultBackground)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(jPanel23Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(BackgroundImagePath, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(BackgroundBrowseButton)\n                    .addComponent(jLabel14))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(useDefaultBattleImage)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(useRandomBattleImage)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(jPanel23Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(BattlefieldImagePath, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(BattlefieldBrowseButton)\n                    .addComponent(jLabel15))\n                .addContainerGap(21, Short.MAX_VALUE))\n        );\n\n        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);\n        jPanel4.setLayout(jPanel4Layout);\n        jPanel4Layout.setHorizontalGroup(\n            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jPanel23, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        jPanel4Layout.setVerticalGroup(\n            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel4Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jPanel5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jPanel23, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap(39, Short.MAX_VALUE))\n        );\n\n        jTabbedPane1.addTab(\"Images\", jPanel4);\n\n        jEnableSounds.setText(\"enable sounds\");\n        jEnableSounds.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jEnableSoundsActionPerformed(evt);\n            }\n        });\n\n        jEnableMusics.setText(\"enable BGM\");\n        jEnableMusics.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jEnableMusicsActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout jPanel22Layout = new javax.swing.GroupLayout(jPanel22);\n        jPanel22.setLayout(jPanel22Layout);\n        jPanel22Layout.setHorizontalGroup(\n            jPanel22Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel22Layout.createSequentialGroup()\n                .addGap(19, 19, 19)\n                .addGroup(jPanel22Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jEnableSounds)\n                    .addComponent(jEnableMusics))\n                .addContainerGap(323, Short.MAX_VALUE))\n        );\n        jPanel22Layout.setVerticalGroup(\n            jPanel22Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel22Layout.createSequentialGroup()\n                .addGap(24, 24, 24)\n                .addComponent(jEnableSounds)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jEnableMusics)\n                .addContainerGap(332, Short.MAX_VALUE))\n        );\n\n        jTabbedPane1.addTab(\"Sounds\", jPanel22);\n\n        lblProxyType.setText(\"Proxy:\");\n\n        cbProxyType.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                cbProxyTypeActionPerformed(evt);\n            }\n        });\n\n        pnlProxySettings.setBorder(javax.swing.BorderFactory.createEtchedBorder());\n\n        lblProxyServer.setText(\"Server:\");\n\n        lblProxyPort.setText(\"Port:\");\n\n        txtProxyPort.addKeyListener(new java.awt.event.KeyAdapter() {\n            public void keyTyped(java.awt.event.KeyEvent evt) {\n                txtProxyPortkeyTyped(evt);\n            }\n        });\n\n        lblProxyUserName.setText(\"User Name:\");\n\n        lblProxyPassword.setText(\"Password:\");\n\n        txtPasswordField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                txtPasswordFieldActionPerformed(evt);\n            }\n        });\n\n        rememberPswd.setText(\"Remember Password\");\n        rememberPswd.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                rememberPswdActionPerformed(evt);\n            }\n        });\n\n        jLabel11.setFont(new java.awt.Font(\"Tahoma\", 2, 10)); // NOI18N\n        jLabel11.setText(\"Note: password won't be encrypted!\");\n\n        javax.swing.GroupLayout pnlProxyLayout = new javax.swing.GroupLayout(pnlProxy);\n        pnlProxy.setLayout(pnlProxyLayout);\n        pnlProxyLayout.setHorizontalGroup(\n            pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(pnlProxyLayout.createSequentialGroup()\n                .addGap(29, 29, 29)\n                .addComponent(rememberPswd)\n                .addGap(18, 18, 18)\n                .addComponent(jLabel11)\n                .addGap(34, 34, 34))\n            .addGroup(pnlProxyLayout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(lblProxyPort)\n                    .addComponent(lblProxyPassword)\n                    .addComponent(lblProxyServer)\n                    .addComponent(lblProxyUserName))\n                .addGap(19, 19, 19)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(txtProxyPort, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                        .addComponent(txtPasswordField, javax.swing.GroupLayout.Alignment.LEADING)\n                        .addComponent(txtProxyUserName, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 148, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addComponent(txtProxyServer, javax.swing.GroupLayout.DEFAULT_SIZE, 298, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        pnlProxyLayout.setVerticalGroup(\n            pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(pnlProxyLayout.createSequentialGroup()\n                .addGap(6, 6, 6)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(txtProxyServer, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblProxyServer))\n                .addGap(8, 8, 8)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblProxyPort)\n                    .addComponent(txtProxyPort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(txtProxyUserName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblProxyUserName))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(txtPasswordField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblProxyPassword))\n                .addGap(18, 18, 18)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(rememberPswd)\n                    .addComponent(jLabel11))\n                .addContainerGap(25, Short.MAX_VALUE))\n        );\n\n        javax.swing.GroupLayout pnlProxySettingsLayout = new javax.swing.GroupLayout(pnlProxySettings);\n        pnlProxySettings.setLayout(pnlProxySettingsLayout);\n        pnlProxySettingsLayout.setHorizontalGroup(\n            pnlProxySettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(pnlProxySettingsLayout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(pnlProxy, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addContainerGap())\n        );\n        pnlProxySettingsLayout.setVerticalGroup(\n            pnlProxySettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(pnlProxySettingsLayout.createSequentialGroup()\n                .addComponent(pnlProxy, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addContainerGap())\n        );\n\n        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);\n        jPanel6.setLayout(jPanel6Layout);\n        jPanel6Layout.setHorizontalGroup(\n            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel6Layout.createSequentialGroup()\n                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel6Layout.createSequentialGroup()\n                        .addGap(40, 40, 40)\n                        .addComponent(lblProxyType)\n                        .addGap(18, 18, 18)\n                        .addComponent(cbProxyType, javax.swing.GroupLayout.PREFERRED_SIZE, 126, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(jPanel6Layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(pnlProxySettings, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))\n                .addContainerGap())\n        );\n        jPanel6Layout.setVerticalGroup(\n            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel6Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblProxyType)\n                    .addComponent(cbProxyType, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(pnlProxySettings, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap(178, Short.MAX_VALUE))\n        );\n\n        pnlProxySettings.getAccessibleContext().setAccessibleDescription(\"\");\n\n        jTabbedPane1.addTab(\"Connection\", jPanel6);\n\n        jPanel10.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel10Layout = new javax.swing.GroupLayout(jPanel10);\n        jPanel10.setLayout(jPanel10Layout);\n        jPanel10Layout.setHorizontalGroup(\n            jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel10Layout.setVerticalGroup(\n            jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel13.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel13Layout = new javax.swing.GroupLayout(jPanel13);\n        jPanel13.setLayout(jPanel13Layout);\n        jPanel13Layout.setHorizontalGroup(\n            jPanel13Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel13Layout.setVerticalGroup(\n            jPanel13Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel11.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel11Layout = new javax.swing.GroupLayout(jPanel11);\n        jPanel11.setLayout(jPanel11Layout);\n        jPanel11Layout.setHorizontalGroup(\n            jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel11Layout.setVerticalGroup(\n            jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jLabel12.setFont(new java.awt.Font(\"Tahoma\", 1, 11)); // NOI18N\n        jLabel12.setText(\"Choose your avatar:\");\n\n        jPanel12.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel12Layout = new javax.swing.GroupLayout(jPanel12);\n        jPanel12.setLayout(jPanel12Layout);\n        jPanel12Layout.setHorizontalGroup(\n            jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel12Layout.setVerticalGroup(\n            jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel14.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel14Layout = new javax.swing.GroupLayout(jPanel14);\n        jPanel14.setLayout(jPanel14Layout);\n        jPanel14Layout.setHorizontalGroup(\n            jPanel14Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel14Layout.setVerticalGroup(\n            jPanel14Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel15.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel15Layout = new javax.swing.GroupLayout(jPanel15);\n        jPanel15.setLayout(jPanel15Layout);\n        jPanel15Layout.setHorizontalGroup(\n            jPanel15Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel15Layout.setVerticalGroup(\n            jPanel15Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jLabel13.setFont(new java.awt.Font(\"Tahoma\", 1, 11)); // NOI18N\n        jLabel13.setText(\"New avatars:\");\n\n        jPanel16.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel16Layout = new javax.swing.GroupLayout(jPanel16);\n        jPanel16.setLayout(jPanel16Layout);\n        jPanel16Layout.setHorizontalGroup(\n            jPanel16Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel16Layout.setVerticalGroup(\n            jPanel16Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel17.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel17Layout = new javax.swing.GroupLayout(jPanel17);\n        jPanel17.setLayout(jPanel17Layout);\n        jPanel17Layout.setHorizontalGroup(\n            jPanel17Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel17Layout.setVerticalGroup(\n            jPanel17Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel18.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel18Layout = new javax.swing.GroupLayout(jPanel18);\n        jPanel18.setLayout(jPanel18Layout);\n        jPanel18Layout.setHorizontalGroup(\n            jPanel18Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel18Layout.setVerticalGroup(\n            jPanel18Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel19.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel19Layout = new javax.swing.GroupLayout(jPanel19);\n        jPanel19.setLayout(jPanel19Layout);\n        jPanel19Layout.setHorizontalGroup(\n            jPanel19Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel19Layout.setVerticalGroup(\n            jPanel19Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel20.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel20Layout = new javax.swing.GroupLayout(jPanel20);\n        jPanel20.setLayout(jPanel20Layout);\n        jPanel20Layout.setHorizontalGroup(\n            jPanel20Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel20Layout.setVerticalGroup(\n            jPanel20Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        jPanel21.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(204, 204, 204), 1, true));\n\n        javax.swing.GroupLayout jPanel21Layout = new javax.swing.GroupLayout(jPanel21);\n        jPanel21.setLayout(jPanel21Layout);\n        jPanel21Layout.setHorizontalGroup(\n            jPanel21Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n        jPanel21Layout.setVerticalGroup(\n            jPanel21Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 100, Short.MAX_VALUE)\n        );\n\n        javax.swing.GroupLayout jPanel9Layout = new javax.swing.GroupLayout(jPanel9);\n        jPanel9.setLayout(jPanel9Layout);\n        jPanel9Layout.setHorizontalGroup(\n            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel9Layout.createSequentialGroup()\n                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel9Layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(jLabel12))\n                    .addGroup(jPanel9Layout.createSequentialGroup()\n                        .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(jPanel9Layout.createSequentialGroup()\n                                .addGap(30, 30, 30)\n                                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                                    .addComponent(jPanel12, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addComponent(jPanel10, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addComponent(jPanel19, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addGap(33, 33, 33)\n                                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(jPanel13, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addComponent(jPanel14, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                    .addComponent(jPanel20, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                            .addGroup(jPanel9Layout.createSequentialGroup()\n                                .addContainerGap()\n                                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(jPanel9Layout.createSequentialGroup()\n                                        .addGap(20, 20, 20)\n                                        .addComponent(jPanel16, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                        .addGap(33, 33, 33)\n                                        .addComponent(jPanel17, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                    .addComponent(jLabel13))))\n                        .addGap(32, 32, 32)\n                        .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jPanel18, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(jPanel21, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(jPanel15, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(jPanel11, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))\n                .addContainerGap(29, Short.MAX_VALUE))\n        );\n        jPanel9Layout.setVerticalGroup(\n            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel9Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jLabel12)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jPanel11, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jPanel13, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jPanel10, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addGap(26, 26, 26)\n                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jPanel15, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jPanel12, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jPanel14, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addGap(23, 23, 23)\n                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(jPanel19, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jPanel20, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jPanel21, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addGap(18, 18, 18)\n                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(jPanel9Layout.createSequentialGroup()\n                        .addComponent(jLabel13)\n                        .addGap(18, 18, 18)\n                        .addComponent(jPanel16, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addComponent(jPanel17, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jPanel18, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addGap(25, 25, 25))\n        );\n\n        jScrollPane1.setViewportView(jPanel9);\n\n        javax.swing.GroupLayout jPanel8Layout = new javax.swing.GroupLayout(jPanel8);\n        jPanel8.setLayout(jPanel8Layout);\n        jPanel8Layout.setHorizontalGroup(\n            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 437, Short.MAX_VALUE)\n        );\n        jPanel8Layout.setVerticalGroup(\n            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 402, Short.MAX_VALUE)\n        );\n\n        jTabbedPane1.addTab(\"Avatars\", jPanel8);\n\n        saveButton.setLabel(\"Save\");\n        saveButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveButtonActionPerformed(evt);\n            }\n        });\n\n        exitButton.setLabel(\"Exit\");\n        exitButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                exitButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jTabbedPane1)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(saveButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(exitButton, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jTabbedPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 430, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(exitButton)\n                    .addComponent(saveButton))\n                .addContainerGap(18, Short.MAX_VALUE))\n        );\n\n        pack();\n    }","commit_id":"fab2759579276909b534de603feb01f50d326d37","url":"https://github.com/magefree/mage"},{"original_method":"private void saveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveButtonActionPerformed\n        Preferences prefs = MageFrame.getPreferences();\n\n        // main\n        save(prefs, dialog.showToolTipsInAnyZone, KEY_SHOW_TOOLTIPS_ANY_ZONE, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        save(prefs, dialog.displayBigCardsInHand, KEY_HAND_USE_BIG_CARDS, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        save(prefs, dialog.nonLandPermanentsInOnePile, KEY_PERMANENTS_IN_ONE_PILE, \"true\", \"false\", UPDATE_CACHE_POLICY);\n\n        // Phases\n        save(prefs, dialog.checkBoxUpkeepYou, UPKEEP_YOU);\n        save(prefs, dialog.checkBoxDrawYou, DRAW_YOU);\n        save(prefs, dialog.checkBoxMainYou, MAIN_YOU);\n        save(prefs, dialog.checkBoxBeforeCYou, BEFORE_COMBAT_YOU);\n        save(prefs, dialog.checkBoxEndOfCYou, END_OF_COMBAT_YOU);\n        save(prefs, dialog.checkBoxMain2You, MAIN_2_YOU);\n        save(prefs, dialog.checkBoxEndTurnYou, END_OF_TURN_YOU);\n\n        save(prefs, dialog.checkBoxUpkeepOthers, UPKEEP_OTHERS);\n        save(prefs, dialog.checkBoxDrawOthers, DRAW_OTHERS);\n        save(prefs, dialog.checkBoxMainOthers, MAIN_OTHERS);\n        save(prefs, dialog.checkBoxBeforeCOthers, BEFORE_COMBAT_OTHERS);\n        save(prefs, dialog.checkBoxEndOfCOthers, END_OF_COMBAT_OTHERS);\n        save(prefs, dialog.checkBoxMain2Others, MAIN_2_OTHERS);\n        save(prefs, dialog.checkBoxEndTurnOthers, END_OF_TURN_OTHERS);\n\n        // images\n        save(prefs, dialog.useDefaultImageFolder, KEY_CARD_IMAGES_USE_DEFAULT, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        saveImagesPath(prefs);\n        save(prefs, dialog.checkForNewImages, KEY_CARD_IMAGES_CHECK, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        save(prefs, dialog.saveToZipFiles, KEY_CARD_IMAGES_SAVE_TO_ZIP, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        \n        save(prefs, dialog.useDefaultBackground, KEY_BACKGROUND_IMAGE_DEFAULT, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        save(prefs, dialog.useDefaultBattleImage, KEY_BATTLEFIELD_IMAGE_RANDOM, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        save(prefs, dialog.useRandomBattleImage, KEY_BATTLEFIELD_IMAGE_DEFAULT, \"true\", \"false\", UPDATE_CACHE_POLICY);\n\n        // sounds\n        save(prefs, dialog.jEnableSounds, KEY_SOUNDS_ON, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        save(prefs, dialog.jEnableMusics, KEY_MUSICS_ON, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        // connection\n        save(prefs, dialog.cbProxyType, KEY_PROXY_TYPE);\n        save(prefs, dialog.txtProxyServer, KEY_PROXY_ADDRESS);\n        save(prefs, dialog.txtProxyPort, KEY_PROXY_PORT);\n        save(prefs, dialog.txtProxyUserName, KEY_PROXY_USERNAME);\n        save(prefs, dialog.rememberPswd, KEY_PROXY_REMEMBER, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        if (dialog.rememberPswd.isSelected()) {\n            char[] input = txtPasswordField.getPassword();\n            prefs.put(KEY_PROXY_PSWD, new String(input));\n        }\n\n        // Avatar\n        if (availableAvatars.contains(selectedId)) {\n            prefs.put(KEY_AVATAR, String.valueOf(selectedId));\n            updateCache(KEY_AVATAR, String.valueOf(selectedId));\n        }\n\n        try {\n            prefs.flush();\n        } catch (BackingStoreException ex) {\n            ex.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error: couldn't save preferences. Please try once again.\");\n        }\n\n        dialog.setVisible(false);\n    }","id":91620,"modified_method":"private void saveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveButtonActionPerformed\n        Preferences prefs = MageFrame.getPreferences();\n\n        // main\n        save(prefs, dialog.showToolTipsInAnyZone, KEY_SHOW_TOOLTIPS_ANY_ZONE, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        save(prefs, dialog.displayBigCardsInHand, KEY_HAND_USE_BIG_CARDS, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        save(prefs, dialog.nonLandPermanentsInOnePile, KEY_PERMANENTS_IN_ONE_PILE, \"true\", \"false\", UPDATE_CACHE_POLICY);\n\n        // Phases\n        save(prefs, dialog.checkBoxUpkeepYou, UPKEEP_YOU);\n        save(prefs, dialog.checkBoxDrawYou, DRAW_YOU);\n        save(prefs, dialog.checkBoxMainYou, MAIN_YOU);\n        save(prefs, dialog.checkBoxBeforeCYou, BEFORE_COMBAT_YOU);\n        save(prefs, dialog.checkBoxEndOfCYou, END_OF_COMBAT_YOU);\n        save(prefs, dialog.checkBoxMain2You, MAIN_2_YOU);\n        save(prefs, dialog.checkBoxEndTurnYou, END_OF_TURN_YOU);\n\n        save(prefs, dialog.checkBoxUpkeepOthers, UPKEEP_OTHERS);\n        save(prefs, dialog.checkBoxDrawOthers, DRAW_OTHERS);\n        save(prefs, dialog.checkBoxMainOthers, MAIN_OTHERS);\n        save(prefs, dialog.checkBoxBeforeCOthers, BEFORE_COMBAT_OTHERS);\n        save(prefs, dialog.checkBoxEndOfCOthers, END_OF_COMBAT_OTHERS);\n        save(prefs, dialog.checkBoxMain2Others, MAIN_2_OTHERS);\n        save(prefs, dialog.checkBoxEndTurnOthers, END_OF_TURN_OTHERS);\n\n        // images\n        save(prefs, dialog.useDefaultImageFolder, KEY_CARD_IMAGES_USE_DEFAULT, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        saveImagesPath(prefs);\n        save(prefs, dialog.checkForNewImages, KEY_CARD_IMAGES_CHECK, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        save(prefs, dialog.saveToZipFiles, KEY_CARD_IMAGES_SAVE_TO_ZIP, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        \n        save(prefs, dialog.useDefaultBackground, KEY_BACKGROUND_IMAGE_DEFAULT, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        save(prefs, dialog.useDefaultBattleImage, KEY_BATTLEFIELD_IMAGE_DEFAULT, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        save(prefs, dialog.useRandomBattleImage, KEY_BATTLEFIELD_IMAGE_RANDOM, \"true\", \"false\", UPDATE_CACHE_POLICY);\n\n        // sounds\n        save(prefs, dialog.jEnableSounds, KEY_SOUNDS_ON, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        save(prefs, dialog.jEnableMusics, KEY_MUSICS_ON, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        // connection\n        save(prefs, dialog.cbProxyType, KEY_PROXY_TYPE);\n        save(prefs, dialog.txtProxyServer, KEY_PROXY_ADDRESS);\n        save(prefs, dialog.txtProxyPort, KEY_PROXY_PORT);\n        save(prefs, dialog.txtProxyUserName, KEY_PROXY_USERNAME);\n        save(prefs, dialog.rememberPswd, KEY_PROXY_REMEMBER, \"true\", \"false\", UPDATE_CACHE_POLICY);\n        if (dialog.rememberPswd.isSelected()) {\n            char[] input = txtPasswordField.getPassword();\n            prefs.put(KEY_PROXY_PSWD, new String(input));\n        }\n\n        // Avatar\n        if (availableAvatars.contains(selectedId)) {\n            prefs.put(KEY_AVATAR, String.valueOf(selectedId));\n            updateCache(KEY_AVATAR, String.valueOf(selectedId));\n        }\n\n        try {\n            prefs.flush();\n        } catch (BackingStoreException ex) {\n            ex.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Error: couldn't save preferences. Please try once again.\");\n        }\n\n        dialog.setVisible(false);\n    }","commit_id":"fab2759579276909b534de603feb01f50d326d37","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n        public String getDescription() {\n            if(extend.equals(\".png\") || extend.equals(\".jpg\")) \n                return \"Image File(*.png, *.bmp)\";\n            if(extend.equals(\".jpg\") || extend.equals(\".jpg\")) \n                return \"JEGP file(*.jpg,*.jepg)\";\n            return \"\";\n        }","id":91621,"modified_method":"@Override\n        public String getDescription() {\n            if(extend.equals(\".png\") || extend.equals(\".bmp\")) \n                return \"Image File(*.png, *.bmp)\";\n            if(extend.equals(\".jpg\") || extend.equals(\".jpg\")) \n                return \"JEGP file(*.jpg,*.jepg)\";\n            return \"\";\n        }","commit_id":"fab2759579276909b534de603feb01f50d326d37","url":"https://github.com/magefree/mage"},{"original_method":"/**\n     * Initializes the content.<p>\n     *\n     * @param resUtil the resource util\n     * @param iconPath the resource icon\n     * @param state the resource state\n     */\n    public void initContent(CmsResourceUtil resUtil, String iconPath, CmsResourceState state) {\n\n        String content = \"<img src=\\\"\" + iconPath + \"\\\" />\";\n\n        if (resUtil != null) {\n            String lockIcon;\n            switch (resUtil.getLockState()) {\n                case 1:\n                    lockIcon = OpenCmsTheme.LOCK_OTHER;\n                    break;\n\n                case 2:\n                    lockIcon = OpenCmsTheme.LOCK_SHARED;\n                    break;\n                case 3:\n                    lockIcon = OpenCmsTheme.LOCK_USER;\n                    break;\n                default:\n                    lockIcon = null;\n            }\n            if (lockIcon != null) {\n                content += getOverlaySpan(\n                    lockIcon,\n                    CmsVaadinUtils.getMessageText(\n                        Messages.GUI_EXPLORER_LIST_ACTION_LOCK_NAME_2,\n                        resUtil.getLockedByName(),\n                        resUtil.getLockedInProjectName()));\n            }\n        }\n        if (state != null) {\n\n            String title = resUtil != null\n            ? CmsVaadinUtils.getMessageText(org.opencms.workplace.commons.Messages.GUI_LABEL_USER_LAST_MODIFIED_0)\n                + \" \"\n                + resUtil.getUserLastModified()\n            : null;\n            if (state.isChanged() || state.isDeleted()) {\n                content += getOverlaySpan(OpenCmsTheme.STATE_CHANGED, title);\n            } else if (state.isNew()) {\n                content += getOverlaySpan(OpenCmsTheme.STATE_NEW, title);\n            }\n        }\n        if ((resUtil != null) && (resUtil.getLinkType() == 1)) {\n            content += getOverlaySpan(OpenCmsTheme.SIBLING, null);\n        }\n        setValue(content);\n    }","id":91622,"modified_method":"/**\n     * Initializes the content.<p>\n     *\n     * @param resUtil the resource util\n     * @param iconPath the resource icon\n     * @param state the resource state\n     */\n    public void initContent(CmsResourceUtil resUtil, String iconPath, CmsResourceState state) {\n\n        String content = \"<img src=\\\"\" + iconPath + \"\\\" />\";\n\n        if (resUtil != null) {\n            String lockIcon;\n            String message = null;\n            if (resUtil.getLock().getSystemLock().isPublish()) {\n                lockIcon = OpenCmsTheme.LOCK_PUBLISH;\n                message = CmsVaadinUtils.getMessageText(org.opencms.workplace.explorer.Messages.GUI_PUBLISH_TOOLTIP_0);\n            } else {\n                switch (resUtil.getLockState()) {\n                    case 1:\n                        lockIcon = OpenCmsTheme.LOCK_OTHER;\n                        break;\n\n                    case 2:\n                        lockIcon = OpenCmsTheme.LOCK_SHARED;\n                        break;\n                    case 3:\n                        lockIcon = OpenCmsTheme.LOCK_USER;\n                        break;\n                    default:\n                        lockIcon = null;\n                }\n                if (lockIcon != null) {\n                    message = CmsVaadinUtils.getMessageText(\n                        Messages.GUI_EXPLORER_LIST_ACTION_LOCK_NAME_2,\n                        resUtil.getLockedByName(),\n                        resUtil.getLockedInProjectName());\n                }\n            }\n            if (lockIcon != null) {\n                content += getOverlaySpan(lockIcon, message);\n            }\n        }\n        if (state != null) {\n\n            String title = resUtil != null\n            ? CmsVaadinUtils.getMessageText(org.opencms.workplace.commons.Messages.GUI_LABEL_USER_LAST_MODIFIED_0)\n                + \" \"\n                + resUtil.getUserLastModified()\n            : null;\n            if (state.isChanged() || state.isDeleted()) {\n                content += getOverlaySpan(OpenCmsTheme.STATE_CHANGED, title);\n            } else if (state.isNew()) {\n                content += getOverlaySpan(OpenCmsTheme.STATE_NEW, title);\n            }\n        }\n        if ((resUtil != null) && (resUtil.getLinkType() == 1)) {\n            content += getOverlaySpan(OpenCmsTheme.SIBLING, null);\n        }\n        setValue(content);\n    }","commit_id":"a490ad1d6549720d458a98e0b4c1535da785c0c2","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes the locale comparison view.<p>\n     *\n     * @param id the structure id of the currrent sitemap root entry.<p>\n     *\n     * @throws CmsException if something goes wrong\n     */\n    public void initialize(CmsUUID id) throws CmsException {\n\n        removeAllComponents();\n        CmsObject cms = A_CmsUI.getCmsObject();\n        CmsResource res = cms.readResource(id);\n        m_currentRoot = res;\n        CmsSite site = OpenCms.getSiteManager().getSiteForRootPath(res.getRootPath());\n\n        Locale rootLocale = OpenCms.getLocaleManager().getDefaultLocale(cms, res);\n        m_rootLocale = rootLocale;\n        Locale mainLocale = site.getMainTranslationLocale(null);\n        List<Locale> secondaryLocales = site.getSecondaryTranslationLocales();\n\n        List<Locale> possibleLocaleSelections = getMainLocaleSelectOptions(cms, res, mainLocale, secondaryLocales);\n        m_rootLocaleSelector = new ComboBox();\n        m_rootLocaleSelector.setNullSelectionAllowed(false);\n        for (Locale selectableLocale : possibleLocaleSelections) {\n            m_rootLocaleSelector.addItem(selectableLocale);\n            m_rootLocaleSelector.setItemCaption(\n                selectableLocale,\n                selectableLocale.getDisplayLanguage(A_CmsUI.get().getLocale()));\n        }\n        m_rootLocaleSelector.setValue(m_rootLocale);\n        m_rootLocaleSelector.addValueChangeListener(new ValueChangeListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            @SuppressWarnings(\"synthetic-access\")\n            public void valueChange(ValueChangeEvent event) {\n\n                if (!m_handlingLocaleChange) {\n                    m_handlingLocaleChange = true;\n                    try {\n                        Locale newLocale = (Locale)(event.getProperty().getValue());\n                        switchToLocale(newLocale);\n                    } catch (Exception e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n                    } finally {\n                        m_handlingLocaleChange = false;\n                    }\n                }\n            }\n        });\n\n        m_comparisonLocaleSelector = new ComboBox();\n        m_comparisonLocaleSelector.setNullSelectionAllowed(false);\n\n        List<Locale> comparisonLocales = getComparisonLocales();\n        Locale firstComparisonLocale = null;\n        for (Locale comparisonLocale : comparisonLocales) {\n            m_comparisonLocaleSelector.addItem(comparisonLocale);\n            m_comparisonLocaleSelector.setItemCaption(\n                comparisonLocale,\n                comparisonLocale.getDisplayLanguage(A_CmsUI.get().getLocale()));\n            if ((firstComparisonLocale == null) && !comparisonLocale.equals(m_rootLocale)) {\n                firstComparisonLocale = comparisonLocale;\n            }\n        }\n        m_comparisonLocale = firstComparisonLocale;\n        m_comparisonLocaleSelector.setValue(firstComparisonLocale);\n\n        m_comparisonLocaleSelector.addValueChangeListener(new ValueChangeListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            @SuppressWarnings(\"synthetic-access\")\n            public void valueChange(ValueChangeEvent event) {\n\n                if (!m_handlingLocaleChange) {\n                    m_handlingLocaleChange = true;\n                    try {\n                        Locale locale = (Locale)(event.getProperty().getValue());\n                        if (m_rootLocale.equals(locale)) {\n                            Locale oldComparisonLocale = m_comparisonLocale;\n                            if (getLocaleGroup().getResourcesByLocale().keySet().contains(oldComparisonLocale)) {\n                                m_comparisonLocale = locale;\n                                switchToLocale(oldComparisonLocale);\n                                updateLocaleWidgets();\n                            } else {\n                                Notification.show(CmsVaadinUtils.getMessageText(\n                                    Messages.GUI_LOCALECOMPARE_CANNOT_SWITCH_COMPARISON_LOCALE_0));\n                                m_comparisonLocaleSelector.setValue(oldComparisonLocale);\n                            }\n                        } else {\n                            m_comparisonLocale = locale;\n                            updateLocaleWidgets();\n                            initTree(m_currentRoot);\n                        }\n\n                    } catch (Exception e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n                    } finally {\n                        m_handlingLocaleChange = false;\n                    }\n                }\n            }\n        });\n\n        CssLayout localeSelectors = new CssLayout();\n        localeSelectors.addStyleName(OpenCmsTheme.SITEMAP_LOCALE_BAR);\n\n        m_rootLocaleSelector.setCaption(CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_MAIN_LOCALE_0));\n        m_comparisonLocaleSelector.setCaption(\n            CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_COMPARISON_LOCALE_0));\n\n        localeSelectors.setWidth(\"100%\");\n        localeSelectors.addComponent(m_rootLocaleSelector);\n        localeSelectors.addComponent(m_comparisonLocaleSelector);\n        // localeSelectors.setComponentAlignment(wrapper2, Alignment.MIDDLE_RIGHT);\n\n        setSpacing(true);\n        addComponent(localeSelectors);\n        addComponent(m_treeContainer);\n        m_treeContainer.setWidth(\"100%\");\n        initTree(res);\n    }","id":91623,"modified_method":"/**\n     * Initializes the locale comparison view.<p>\n     *\n     * @param id the structure id of the currrent sitemap root entry.<p>\n     *\n     * @throws CmsException if something goes wrong\n     */\n    public void initialize(CmsUUID id) throws CmsException {\n\n        removeAllComponents();\n        CmsObject cms = A_CmsUI.getCmsObject();\n        CmsResource res = cms.readResource(id);\n        m_currentRoot = res;\n        CmsSite site = OpenCms.getSiteManager().getSiteForRootPath(res.getRootPath());\n\n        Locale rootLocale = OpenCms.getLocaleManager().getDefaultLocale(cms, res);\n        m_rootLocale = rootLocale;\n        Locale mainLocale = site.getMainTranslationLocale(null);\n        List<Locale> secondaryLocales = site.getSecondaryTranslationLocales();\n\n        List<Locale> possibleLocaleSelections = getMainLocaleSelectOptions(cms, res, mainLocale, secondaryLocales);\n        m_rootLocaleSelector = new ComboBox();\n        m_rootLocaleSelector.setNullSelectionAllowed(false);\n        for (Locale selectableLocale : possibleLocaleSelections) {\n            m_rootLocaleSelector.addItem(selectableLocale);\n            String localeOptionSuffix = \"\";\n            if (selectableLocale.equals(mainLocale)) {\n                localeOptionSuffix = \" [*]\";\n            }\n            m_rootLocaleSelector.setItemCaption(\n                selectableLocale,\n                selectableLocale.getDisplayLanguage(A_CmsUI.get().getLocale()) + localeOptionSuffix);\n        }\n        m_rootLocaleSelector.setValue(m_rootLocale);\n        m_rootLocaleSelector.addValueChangeListener(new ValueChangeListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            @SuppressWarnings(\"synthetic-access\")\n            public void valueChange(ValueChangeEvent event) {\n\n                if (!m_handlingLocaleChange) {\n                    m_handlingLocaleChange = true;\n                    try {\n                        Locale newLocale = (Locale)(event.getProperty().getValue());\n                        switchToLocale(newLocale);\n                    } catch (Exception e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n                    } finally {\n                        m_handlingLocaleChange = false;\n                    }\n                }\n            }\n        });\n\n        m_comparisonLocaleSelector = new ComboBox();\n        m_comparisonLocaleSelector.setNullSelectionAllowed(false);\n\n        List<Locale> comparisonLocales = getComparisonLocales();\n        Locale firstComparisonLocale = null;\n        for (Locale comparisonLocale : comparisonLocales) {\n            m_comparisonLocaleSelector.addItem(comparisonLocale);\n            String localeOptionSuffix = \"\";\n            if (comparisonLocale.equals(mainLocale)) {\n                localeOptionSuffix = \" [*]\";\n            }\n\n            m_comparisonLocaleSelector.setItemCaption(\n                comparisonLocale,\n                comparisonLocale.getDisplayLanguage(A_CmsUI.get().getLocale()) + localeOptionSuffix);\n            if ((firstComparisonLocale == null) && !comparisonLocale.equals(m_rootLocale)) {\n                firstComparisonLocale = comparisonLocale;\n            }\n        }\n        m_comparisonLocale = firstComparisonLocale;\n        m_comparisonLocaleSelector.setValue(firstComparisonLocale);\n\n        m_comparisonLocaleSelector.addValueChangeListener(new ValueChangeListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            @SuppressWarnings(\"synthetic-access\")\n            public void valueChange(ValueChangeEvent event) {\n\n                if (!m_handlingLocaleChange) {\n                    m_handlingLocaleChange = true;\n                    try {\n                        Locale locale = (Locale)(event.getProperty().getValue());\n                        if (m_rootLocale.equals(locale)) {\n                            Locale oldComparisonLocale = m_comparisonLocale;\n                            if (getLocaleGroup().getResourcesByLocale().keySet().contains(oldComparisonLocale)) {\n                                m_comparisonLocale = locale;\n                                switchToLocale(oldComparisonLocale);\n                                updateLocaleWidgets();\n                            } else {\n                                Notification.show(CmsVaadinUtils.getMessageText(\n                                    Messages.GUI_LOCALECOMPARE_CANNOT_SWITCH_COMPARISON_LOCALE_0));\n                                m_comparisonLocaleSelector.setValue(oldComparisonLocale);\n                            }\n                        } else {\n                            m_comparisonLocale = locale;\n                            updateLocaleWidgets();\n                            initTree(m_currentRoot);\n                        }\n\n                    } catch (Exception e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n                    } finally {\n                        m_handlingLocaleChange = false;\n                    }\n                }\n            }\n        });\n\n        CssLayout localeSelectors = new CssLayout();\n        localeSelectors.addStyleName(OpenCmsTheme.SITEMAP_LOCALE_BAR);\n\n        m_rootLocaleSelector.setCaption(CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_MAIN_LOCALE_0));\n        m_comparisonLocaleSelector.setCaption(\n            CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_COMPARISON_LOCALE_0));\n\n        localeSelectors.setWidth(\"100%\");\n        localeSelectors.addComponent(m_rootLocaleSelector);\n        localeSelectors.addComponent(m_comparisonLocaleSelector);\n        // localeSelectors.setComponentAlignment(wrapper2, Alignment.MIDDLE_RIGHT);\n\n        setSpacing(true);\n        addComponent(localeSelectors);\n        addComponent(m_treeContainer);\n        m_treeContainer.setWidth(\"100%\");\n        initTree(res);\n    }","commit_id":"ae9b6dd5634aaffb91a506aadc3fbe2a51249890","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Checks if the two resources are linkable as locale variants and returns an appropriate status<p>\n     *\n     *  This is the case if exactly one of the resources represents a locale group, the locale of the other resource\n     *  is not already present in the locale group, and if some other permission / validity checks are passed.\n     *\n     * @param cms the CMS context\n     * @param firstResource a resource\n     * @param secondResource a resource\n     *\n     * @return the result of the linkability check\n     */\n    public Status checkLinkable(CmsObject cms, CmsResource firstResource, CmsResource secondResource) {\n\n        try {\n            CmsResource firstResourceCorrected = getDefaultFileOrSelf(firstResource);\n            CmsResource secondResourceCorrected = getDefaultFileOrSelf(secondResource);\n            if ((firstResourceCorrected == null) || (secondResourceCorrected == null)) {\n                return Status.other;\n            }\n            Locale locale1 = OpenCms.getLocaleManager().getDefaultLocale(m_cms, firstResourceCorrected);\n            Locale locale2 = OpenCms.getLocaleManager().getDefaultLocale(m_cms, secondResourceCorrected);\n            if (locale1.equals(locale2)) {\n                return Status.other;\n            }\n\n            Locale mainLocale1 = getMainLocale(firstResourceCorrected.getRootPath());\n            Locale mainLocale2 = getMainLocale(secondResourceCorrected.getRootPath());\n            if ((mainLocale1 == null) || !(mainLocale1.equals(mainLocale2))) {\n                return Status.other;\n            }\n\n            CmsLocaleGroupService groupService = cms.getLocaleGroupService();\n            CmsLocaleGroup group1 = groupService.readLocaleGroup(firstResourceCorrected);\n            Set<Locale> locales1 = group1.getLocales();\n            CmsLocaleGroup group2 = groupService.readLocaleGroup(secondResourceCorrected);\n            Set<Locale> locales2 = group2.getLocales();\n            if (!(Sets.intersection(locales1, locales2).isEmpty())) {\n                return Status.other;\n            }\n\n            List<CmsResource> secondaryResources = Lists.newArrayList();\n            secondaryResources.addAll(group1.getSecondaryResources());\n            secondaryResources.add(group1.getPrimaryResource());\n            secondaryResources.addAll(group2.getSecondaryResources());\n            secondaryResources.add(group2.getPrimaryResource());\n            for (CmsResource secondaryRes : secondaryResources) {\n\n                if (!cms.hasPermissions(\n                    secondaryRes,\n                    CmsPermissionSet.ACCESS_WRITE,\n                    false,\n                    CmsResourceFilter.IGNORE_EXPIRATION)) {\n                    return Status.other;\n                }\n                CmsLock lock = cms.getLock(secondaryRes);\n                if (!lock.isUnlocked() && lock.getUserId().equals(cms.getRequestContext().getCurrentUser().getId())) {\n                    return Status.other;\n                }\n            }\n\n            if (group1.isMarkedNoTranslation(group2.getLocales())\n                || group2.isMarkedNoTranslation(group1.getLocales())) {\n                return Status.notranslation;\n\n            }\n            int numberOfRealGroups = (group1.isRealGroupOrPotentialGroupHead() ? 1 : 0)\n                + (group2.isRealGroupOrPotentialGroupHead() ? 1 : 0);\n            if (numberOfRealGroups != 1) {\n                return Status.other;\n            }\n\n            if (group2.getPrimaryResource().getStructureId().equals(group1.getPrimaryResource().getStructureId())) {\n                return Status.alreadyLinked;\n            }\n        } catch (Exception e) {\n            LOG.error(e.getLocalizedMessage(), e);\n            return Status.other;\n\n        }\n\n        return Status.linkable;\n    }","id":91624,"modified_method":"/**\n     * Checks if the two resources are linkable as locale variants and returns an appropriate status<p>\n     *\n     *  This is the case if exactly one of the resources represents a locale group, the locale of the other resource\n     *  is not already present in the locale group, and if some other permission / validity checks are passed.\n     *\n     * @param cms the CMS context\n     * @param firstResource a resource\n     * @param secondResource a resource\n     *\n     * @return the result of the linkability check\n     */\n    public Status checkLinkable(CmsObject cms, CmsResource firstResource, CmsResource secondResource) {\n\n        try {\n            CmsResource firstResourceCorrected = getDefaultFileOrSelf(firstResource);\n            CmsResource secondResourceCorrected = getDefaultFileOrSelf(secondResource);\n            if ((firstResourceCorrected == null) || (secondResourceCorrected == null)) {\n                return Status.other;\n            }\n            Locale locale1 = OpenCms.getLocaleManager().getDefaultLocale(m_cms, firstResourceCorrected);\n            Locale locale2 = OpenCms.getLocaleManager().getDefaultLocale(m_cms, secondResourceCorrected);\n            if (locale1.equals(locale2)) {\n                return Status.other;\n            }\n\n            Locale mainLocale1 = getMainLocale(firstResourceCorrected.getRootPath());\n            Locale mainLocale2 = getMainLocale(secondResourceCorrected.getRootPath());\n            if ((mainLocale1 == null) || !(mainLocale1.equals(mainLocale2))) {\n                return Status.other;\n            }\n\n            CmsLocaleGroupService groupService = cms.getLocaleGroupService();\n            CmsLocaleGroup group1 = groupService.readLocaleGroup(firstResourceCorrected);\n            Set<Locale> locales1 = group1.getLocales();\n            CmsLocaleGroup group2 = groupService.readLocaleGroup(secondResourceCorrected);\n            Set<Locale> locales2 = group2.getLocales();\n            if (!(Sets.intersection(locales1, locales2).isEmpty())) {\n                return Status.alreadyLinked;\n            }\n\n            List<CmsResource> secondaryResources = Lists.newArrayList();\n            secondaryResources.addAll(group1.getSecondaryResources());\n            secondaryResources.add(group1.getPrimaryResource());\n            secondaryResources.addAll(group2.getSecondaryResources());\n            secondaryResources.add(group2.getPrimaryResource());\n            for (CmsResource secondaryRes : secondaryResources) {\n\n                if (!cms.hasPermissions(\n                    secondaryRes,\n                    CmsPermissionSet.ACCESS_WRITE,\n                    false,\n                    CmsResourceFilter.IGNORE_EXPIRATION)) {\n                    return Status.other;\n                }\n                CmsLock lock = cms.getLock(secondaryRes);\n                if (!lock.isUnlocked() && lock.getUserId().equals(cms.getRequestContext().getCurrentUser().getId())) {\n                    return Status.other;\n                }\n            }\n\n            if (group1.isMarkedNoTranslation(group2.getLocales())\n                || group2.isMarkedNoTranslation(group1.getLocales())) {\n                return Status.notranslation;\n\n            }\n            int numberOfRealGroups = (group1.isRealGroupOrPotentialGroupHead() ? 1 : 0)\n                + (group2.isRealGroupOrPotentialGroupHead() ? 1 : 0);\n            if (numberOfRealGroups != 1) {\n                return Status.other;\n            }\n\n            if (group2.getPrimaryResource().getStructureId().equals(group1.getPrimaryResource().getStructureId())) {\n                return Status.alreadyLinked;\n            }\n        } catch (Exception e) {\n            LOG.error(e.getLocalizedMessage(), e);\n            return Status.other;\n\n        }\n\n        return Status.linkable;\n    }","commit_id":"ae9b6dd5634aaffb91a506aadc3fbe2a51249890","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes and displays the type list for the given view.<p>\n     *\n     * @param view the element view\n     * @param useDefault true if we should use the default location for resource creation\n     */\n    public void init(CmsElementView view, boolean useDefault) {\n\n        m_currentView = view;\n        if (!view.getId().equals(m_viewSelector.getValue())) {\n            m_viewSelector.setValue(view.getId());\n        }\n        m_typeContainer.removeAllComponents();\n\n        List<CmsResourceTypeBean> typeBeans = m_typeHelper.getPrecomputedTypes(view);\n        if (view.getId().equals(ID_VIEW_ALL)) {\n            typeBeans = m_allTypes;\n        }\n\n        if (typeBeans == null) {\n\n            LOG.warn(\"precomputed type list is null: \" + view.getTitle(A_CmsUI.getCmsObject(), Locale.ENGLISH));\n            return;\n        }\n        for (CmsResourceTypeBean type : typeBeans) {\n            final String typeName = type.getType();\n            String title = typeName;\n            String subtitle = getSubtitle(type, useDefault);\n            CmsExplorerTypeSettings explorerType = OpenCms.getWorkplaceManager().getExplorerTypeSetting(typeName);\n            String iconUri = explorerType.getBigIconIfAvailable();\n            title = CmsVaadinUtils.getMessageText(explorerType.getKey());\n            CmsResourceInfo info = new CmsResourceInfo(\n                title,\n                subtitle,\n                CmsWorkplace.getResourceUri(\"filetypes/\" + iconUri));\n            info.setData(type);\n            m_typeContainer.addComponent(info);\n            info.getButtonLabel().setContentMode(ContentMode.HTML);\n            String labelClass = getLabelClass();\n            info.getButtonLabel().setValue(\"<span class='\" + labelClass + \"'>\");\n            info.getButtonLabel().addStyleName(OpenCmsTheme.RESINFO_HIDDEN_ICON);\n        }\n    }","id":91625,"modified_method":"/**\n     * Initializes and displays the type list for the given view.<p>\n     *\n     * @param view the element view\n     * @param useDefault true if we should use the default location for resource creation\n     */\n    public void init(CmsElementView view, boolean useDefault) {\n\n        m_currentView = view;\n        if (!view.getId().equals(m_viewSelector.getValue())) {\n            m_viewSelector.setValue(view.getId());\n        }\n        m_typeContainer.removeAllComponents();\n\n        List<CmsResourceTypeBean> typeBeans = m_typeHelper.getPrecomputedTypes(view);\n        if (view.getId().equals(ID_VIEW_ALL)) {\n            typeBeans = m_allTypes;\n        }\n\n        if (typeBeans == null) {\n\n            LOG.warn(\"precomputed type list is null: \" + view.getTitle(A_CmsUI.getCmsObject(), Locale.ENGLISH));\n            return;\n        }\n        for (CmsResourceTypeBean type : typeBeans) {\n            final String typeName = type.getType();\n            String title = typeName;\n            String subtitle = getSubtitle(type, useDefault);\n            CmsExplorerTypeSettings explorerType = OpenCms.getWorkplaceManager().getExplorerTypeSetting(typeName);\n            String iconUri = explorerType.getBigIconIfAvailable();\n            title = CmsVaadinUtils.getMessageText(explorerType.getKey());\n            CmsResourceInfo info = new CmsResourceInfo(\n                title,\n                subtitle,\n                CmsWorkplace.getResourceUri(\"filetypes/\" + iconUri));\n            info.setData(type);\n            m_typeContainer.addComponent(info);\n            //            info.getButtonLabel().setContentMode(ContentMode.HTML);\n            //            String labelClass = getLabelClass();\n            //            info.getButtonLabel().setValue(\"<span class='\" + labelClass + \"'>\");\n            //            info.getButtonLabel().addStyleName(OpenCmsTheme.RESINFO_HIDDEN_ICON);\n        }\n    }","commit_id":"ae9b6dd5634aaffb91a506aadc3fbe2a51249890","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Replaces the button component.<p>\n     *\n     * @param button the new button component\n     */\n    public void setButton(Component button) {\n\n        Component oldComponent = getComponent(\"buttonContainer\");\n        replaceComponent(oldComponent, button);\n    }","id":91626,"modified_method":"/**\n     * Replaces the button component.<p>\n     *\n     * @param button the new button component\n     */\n    public void setButtonWidget(Component button) {\n\n        addComponent(button, BUTTON_CONTAINER);\n    }","commit_id":"ae9b6dd5634aaffb91a506aadc3fbe2a51249890","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the button label.<p>\n     *\n     * @return the button label\n     */\n    public Label getButtonLabel() {\n\n        return m_buttonLabel;\n    }","id":91627,"modified_method":"/**\n     * Gets the button label.<p>\n     *\n     * @return the button label\n     */\n    public Component getButtonWidget() {\n\n        return getComponent(\"buttonContainer\");\n    }","commit_id":"ae9b6dd5634aaffb91a506aadc3fbe2a51249890","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a sitemap tree node widget from a tree node bean.<p>\n     *\n     * @param entry the tree node bean\n     * @return the tree node widget\n     */\n    public CmsSitemapTreeNode createNode(final CmsSitemapTreeNodeData entry) {\n\n        final CmsSitemapTreeNode node = new CmsSitemapTreeNode();\n        node.addLayoutClickListener(new LayoutClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            @SuppressWarnings(\"synthetic-access\")\n            public void layoutClick(LayoutClickEvent event) {\n\n                Component currentComponent = event.getClickedComponent();\n                if (currentComponent != null) {\n                    boolean linked = false;\n                    do {\n                        currentComponent = currentComponent.getParent();\n                        if ((currentComponent != null)\n                            && \"linked\".equals(((AbstractComponent)currentComponent).getData())) {\n                            linked = true;\n                            System.out.println(\"linked -> true\");\n                        }\n                        if (event.getClickedComponent() instanceof CmsResourceIcon) {\n                            if (currentComponent == node) {\n                                openTargetPage((CmsSitemapTreeNodeData)(node.getData()), linked);\n                            } else if (currentComponent instanceof CmsSitemapTreeNode) {\n                                break;\n                            }\n                        }\n                    } while (currentComponent != null);\n                }\n\n            }\n\n        });\n        String icon = CmsSitemapTreeContainer.getSitemapResourceIcon(A_CmsUI.getCmsObject(), entry.getResource());\n        CmsResourceInfo info = new CmsResourceInfo(\n            entry.getClientEntry().getTitle(),\n            entry.getClientEntry().getSitePath(),\n            icon);\n        info = CmsResourceInfo.createSitemapResourceInfo(\n            entry.getResource(),\n            OpenCms.getSiteManager().getSiteForRootPath(m_localeContext.getRoot().getRootPath()));\n        info.getResourceIcon().addStyleName(OpenCmsTheme.POINTER);\n\n        if (entry.getClientEntry().isHiddenNavigationEntry()) {\n            info.addStyleName(OpenCmsTheme.RESOURCE_INFO_WEAK);\n        }\n        final MenuBar menu = new MenuBar();\n        if (entry.isMarkedNoTranslation(m_localeContext.getComparisonLocale())) {\n            final MenuItem mark = menu.addItem(\"\", null);\n            mark.setDescription(CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_DONT_TRANSLATE_0));\n            mark.setIcon(FontAwesome.BAN);\n            mark.setStyleName(\"o-sitemap-notranslation\");\n        }\n        final MenuItem main = menu.addItem(\"\", null);\n        main.setIcon(FontOpenCms.CONTEXT_MENU);\n        info.setButton(menu);\n        main.setCommand(new Command() {\n\n            /** Serial version id. */\n            private static final long serialVersionUID = 1L;\n\n            @SuppressWarnings(\"synthetic-access\")\n            public void menuSelected(MenuItem selectedItem) {\n\n                m_menu.removeAllItems();\n                if (!entry.isLinked()) {\n                    addLinkItem(entry, node);\n                }\n                if (m_localeContext.getRootLocale().equals(A_CmsUI.getCmsObject().getLocaleGroupService().getMainLocale(\n                    m_localeContext.getRoot().getRootPath()))) {\n                    try {\n                        CmsResource primary = A_CmsUI.getCmsObject().readResource(\n                            entry.getClientEntry().getId(),\n                            CmsResourceFilter.IGNORE_EXPIRATION);\n                        if (primary.isFolder()) {\n                            CmsResource defaultFile = A_CmsUI.getCmsObject().readDefaultFile(\n                                primary,\n                                CmsResourceFilter.IGNORE_EXPIRATION);\n                            if (defaultFile != null) {\n                                primary = defaultFile;\n                            }\n                        }\n                        final CmsResource primaryFinal = primary;\n                        addMarkItems(entry, node, primaryFinal);\n                    } catch (CmsException e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n                    }\n\n                }\n\n                if (entry.isLinked()) {\n                    try {\n\n                        CmsResource primary = A_CmsUI.getCmsObject().readResource(\n                            entry.getClientEntry().getId(),\n                            CmsResourceFilter.IGNORE_EXPIRATION);\n                        if (primary.isFolder()) {\n                            CmsResource defaultFile = A_CmsUI.getCmsObject().readDefaultFile(\n                                primary,\n                                CmsResourceFilter.IGNORE_EXPIRATION);\n                            if (defaultFile != null) {\n                                primary = defaultFile;\n                            }\n                        }\n                        CmsLocaleGroupService groupService = A_CmsUI.getCmsObject().getLocaleGroupService();\n                        Locale mainLocale = groupService.getMainLocale(m_localeContext.getRoot().getRootPath());\n                        int mainLocaleCount = 0;\n                        for (Locale testLocale : Arrays.asList(\n                            m_localeContext.getRootLocale(),\n                            m_localeContext.getComparisonLocale())) {\n                            mainLocaleCount += mainLocale.equals(testLocale) ? 1 : 0;\n                        }\n                        if (mainLocaleCount == 1) {\n                            addUnlinkItem(entry, node);\n                        }\n                        CmsLocaleGroup localeGroup = groupService.readLocaleGroup(primary);\n                        if (localeGroup.isRealGroup()) {\n                            ContextMenuItem show = m_menu.addItem(\n                                CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_SHOW_LOCALE_0));\n                            Map<Locale, CmsResource> resourcesByLocale = localeGroup.getResourcesByLocale();\n                            String mySiteRoot = A_CmsUI.getCmsObject().getRequestContext().getSiteRoot();\n                            int realSubitemCount = 0;\n                            for (Map.Entry<Locale, CmsResource> localeGroupEntry : resourcesByLocale.entrySet()) {\n                                final Locale locale = localeGroupEntry.getKey();\n                                final CmsResource resource = localeGroupEntry.getValue();\n                                final boolean sameSite = mySiteRoot.equals(\n                                    OpenCms.getSiteManager().getSiteRoot(resource.getRootPath()));\n\n                                String localeName = locale.getDisplayLanguage(A_CmsUI.get().getLocale());\n                                ContextMenuItem showLanguage = show.addItem(localeName);\n                                if (!sameSite) {\n                                    showLanguage.addStyleName(\"o-show-locale-disabled\");\n                                }\n                                showLanguage.addItemClickListener(new ContextMenuItemClickListener() {\n\n                                    public void contextMenuItemClicked(ContextMenuItemClickEvent event) {\n\n                                        if (sameSite) {\n                                            CmsObject cms = A_CmsUI.getCmsObject();\n                                            String link = OpenCms.getLinkManager().substituteLink(cms, resource);\n                                            A_CmsUI.get().getPage().setLocation(link);\n                                        } else {\n                                            String message = CmsVaadinUtils.getMessageText(\n                                                Messages.GUI_LOCALECOMPARE_SHOW_WRONGSITE_1,\n                                                resource.getRootPath());\n\n                                            Notification.show(message, Type.ERROR_MESSAGE);\n                                        }\n                                    }\n                                });\n                                realSubitemCount += 1;\n\n                            }\n                            if (realSubitemCount == 0) {\n                                m_menu.removeItem(show);\n                            }\n                        }\n                    } catch (Exception e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n                    }\n                }\n\n                m_menu.open(menu);\n            }\n\n        });\n\n        menu.addStyleName(\"borderless o-toolbar-button o-resourceinfo-toolbar\");\n        if (entry.isLinked()) {\n            CmsSite site = OpenCms.getSiteManager().getSiteForRootPath(m_localeContext.getRoot().getRootPath());\n            CmsResourceInfo linkedInfo = CmsResourceInfo.createSitemapResourceInfo(entry.getLinkedResource(), site);\n            if (entry.isDirectLink()) {\n                linkedInfo.addStyleName(OpenCmsTheme.RESOURCE_INFO_DIRECTLINK);\n            }\n            HorizontalLayout row = new HorizontalLayout();\n            row.addComponent(info);\n            row.addComponent(linkedInfo);\n            row.setExpandRatio(info, 1.0f);\n            row.setExpandRatio(linkedInfo, 1.0f);\n            row.setWidth(\"100%\");\n            node.setContent(row);\n            linkedInfo.setData(\"linked\");\n            linkedInfo.getResourceIcon().addStyleName(OpenCmsTheme.POINTER);\n        } else {\n            node.setContent(info);\n        }\n\n        if (entry.hasNoChildren()) {\n            node.setOpen(true);\n            node.setOpenerVisible(false);\n        }\n        node.setData(entry);\n        return node;\n\n    }","id":91628,"modified_method":"/**\n     * Creates a sitemap tree node widget from a tree node bean.<p>\n     *\n     * @param entry the tree node bean\n     * @return the tree node widget\n     */\n    public CmsSitemapTreeNode createNode(final CmsSitemapTreeNodeData entry) {\n\n        final CmsSitemapTreeNode node = new CmsSitemapTreeNode();\n        node.addLayoutClickListener(new LayoutClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            @SuppressWarnings(\"synthetic-access\")\n            public void layoutClick(LayoutClickEvent event) {\n\n                Component currentComponent = event.getClickedComponent();\n                if (currentComponent != null) {\n                    boolean linked = false;\n                    do {\n                        currentComponent = currentComponent.getParent();\n                        if ((currentComponent != null)\n                            && \"linked\".equals(((AbstractComponent)currentComponent).getData())) {\n                            linked = true;\n                        }\n                        if (event.getClickedComponent() instanceof CmsResourceIcon) {\n                            if (currentComponent == node) {\n                                openTargetPage((CmsSitemapTreeNodeData)(node.getData()), linked);\n                            } else if (currentComponent instanceof CmsSitemapTreeNode) {\n                                break;\n                            }\n                        }\n                    } while (currentComponent != null);\n                }\n\n            }\n\n        });\n        String icon = CmsSitemapTreeContainer.getSitemapResourceIcon(A_CmsUI.getCmsObject(), entry.getResource());\n        CmsResourceInfo info = new CmsResourceInfo(\n            entry.getClientEntry().getTitle(),\n            entry.getClientEntry().getSitePath(),\n            icon);\n        info = CmsResourceInfo.createSitemapResourceInfo(\n            entry.getResource(),\n            OpenCms.getSiteManager().getSiteForRootPath(m_localeContext.getRoot().getRootPath()));\n        info.getResourceIcon().addStyleName(OpenCmsTheme.POINTER);\n        info.getResourceIcon().setDescription(CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_OPEN_PAGE_0));\n\n        if (entry.getClientEntry().isHiddenNavigationEntry()) {\n            info.addStyleName(OpenCmsTheme.RESOURCE_INFO_WEAK);\n        }\n        final MenuBar menu = new MenuBar();\n        boolean noTranslation = false;\n        noTranslation = entry.isMarkedNoTranslation(m_localeContext.getComparisonLocale());\n\n        final MenuItem main = menu.addItem(\"\", null);\n        main.setIcon(FontOpenCms.CONTEXT_MENU);\n        CssLayout rightSide = new CssLayout();\n        info.setButtonWidget(rightSide);\n        rightSide.addComponent(menu);\n        main.setCommand(new Command() {\n\n            /** Serial version id. */\n            private static final long serialVersionUID = 1L;\n\n            @SuppressWarnings(\"synthetic-access\")\n            public void menuSelected(MenuItem selectedItem) {\n\n                m_menu.removeAllItems();\n                if (!entry.isLinked()) {\n                    addLinkItem(entry, node);\n                }\n                if (m_localeContext.getRootLocale().equals(A_CmsUI.getCmsObject().getLocaleGroupService().getMainLocale(\n                    m_localeContext.getRoot().getRootPath()))) {\n                    try {\n                        CmsResource primary = A_CmsUI.getCmsObject().readResource(\n                            entry.getClientEntry().getId(),\n                            CmsResourceFilter.IGNORE_EXPIRATION);\n                        if (primary.isFolder()) {\n                            CmsResource defaultFile = A_CmsUI.getCmsObject().readDefaultFile(\n                                primary,\n                                CmsResourceFilter.IGNORE_EXPIRATION);\n                            if (defaultFile != null) {\n                                primary = defaultFile;\n                            }\n                        }\n                        final CmsResource primaryFinal = primary;\n                        addMarkItems(entry, node, primaryFinal);\n                    } catch (CmsException e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n                    }\n\n                }\n\n                if (entry.isLinked()) {\n                    try {\n\n                        CmsResource primary = A_CmsUI.getCmsObject().readResource(\n                            entry.getClientEntry().getId(),\n                            CmsResourceFilter.IGNORE_EXPIRATION);\n                        if (primary.isFolder()) {\n                            CmsResource defaultFile = A_CmsUI.getCmsObject().readDefaultFile(\n                                primary,\n                                CmsResourceFilter.IGNORE_EXPIRATION);\n                            if (defaultFile != null) {\n                                primary = defaultFile;\n                            }\n                        }\n                        CmsLocaleGroupService groupService = A_CmsUI.getCmsObject().getLocaleGroupService();\n                        Locale mainLocale = groupService.getMainLocale(m_localeContext.getRoot().getRootPath());\n                        int mainLocaleCount = 0;\n                        for (Locale testLocale : Arrays.asList(\n                            m_localeContext.getRootLocale(),\n                            m_localeContext.getComparisonLocale())) {\n                            mainLocaleCount += mainLocale.equals(testLocale) ? 1 : 0;\n                        }\n                        if (mainLocaleCount == 1) {\n                            addUnlinkItem(entry, node);\n                        }\n                        CmsLocaleGroup localeGroup = groupService.readLocaleGroup(primary);\n                        if (localeGroup.isRealGroup()) {\n                            ContextMenuItem show = m_menu.addItem(\n                                CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_SHOW_LOCALE_0));\n                            Map<Locale, CmsResource> resourcesByLocale = localeGroup.getResourcesByLocale();\n                            String mySiteRoot = A_CmsUI.getCmsObject().getRequestContext().getSiteRoot();\n                            int realSubitemCount = 0;\n                            for (Map.Entry<Locale, CmsResource> localeGroupEntry : resourcesByLocale.entrySet()) {\n                                final Locale locale = localeGroupEntry.getKey();\n                                final CmsResource resource = localeGroupEntry.getValue();\n                                final boolean sameSite = mySiteRoot.equals(\n                                    OpenCms.getSiteManager().getSiteRoot(resource.getRootPath()));\n\n                                String localeName = locale.getDisplayLanguage(A_CmsUI.get().getLocale());\n                                ContextMenuItem showLanguage = show.addItem(localeName);\n                                if (!sameSite) {\n                                    showLanguage.addStyleName(\"o-show-locale-disabled\");\n                                }\n                                showLanguage.addItemClickListener(new ContextMenuItemClickListener() {\n\n                                    public void contextMenuItemClicked(ContextMenuItemClickEvent event) {\n\n                                        if (sameSite) {\n                                            CmsObject cms = A_CmsUI.getCmsObject();\n                                            String link = OpenCms.getLinkManager().substituteLink(cms, resource);\n                                            A_CmsUI.get().getPage().setLocation(link);\n                                        } else {\n                                            String message = CmsVaadinUtils.getMessageText(\n                                                Messages.GUI_LOCALECOMPARE_SHOW_WRONGSITE_1,\n                                                resource.getRootPath());\n\n                                            Notification.show(message, Type.ERROR_MESSAGE);\n                                        }\n                                    }\n                                });\n                                realSubitemCount += 1;\n\n                            }\n                            if (realSubitemCount == 0) {\n                                m_menu.removeItem(show);\n                            }\n                        }\n                    } catch (Exception e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n                    }\n                }\n\n                m_menu.open(menu);\n            }\n\n        });\n\n        menu.addStyleName(\"borderless o-toolbar-button o-resourceinfo-toolbar\");\n        if (entry.isLinked()) {\n            CmsSite site = OpenCms.getSiteManager().getSiteForRootPath(m_localeContext.getRoot().getRootPath());\n            CmsResourceInfo linkedInfo = CmsResourceInfo.createSitemapResourceInfo(entry.getLinkedResource(), site);\n            if (entry.isDirectLink()) {\n                linkedInfo.addStyleName(OpenCmsTheme.RESOURCE_INFO_DIRECTLINK);\n            }\n            rightSide.addComponent(linkedInfo, 0);\n            linkedInfo.setWidth(RHS_WIDTH + \"px\");\n            node.setContent(info);\n            linkedInfo.setData(\"linked\");\n            linkedInfo.getResourceIcon().setDescription(\n                CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_OPEN_PAGE_0));\n            linkedInfo.getResourceIcon().addStyleName(OpenCmsTheme.POINTER);\n        } else {\n            if (noTranslation) {\n                Label noTranslationLabel = createNoTranslationLabel();\n                rightSide.addComponent(noTranslationLabel, 0);\n            }\n            node.setContent(info);\n        }\n\n        if (entry.hasNoChildren()) {\n            node.setOpen(true);\n            node.setOpenerVisible(false);\n        }\n        node.setData(entry);\n        return node;\n\n    }","commit_id":"ae9b6dd5634aaffb91a506aadc3fbe2a51249890","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds context menu items.<p>\n     *\n     * @param entry the tree node bean\n     * @param node the tree node widget\n     * @param fileToModify the file which the context menu items should actually operate on\n     */\n    private void addMarkItems(\n        final CmsSitemapTreeNodeData entry,\n        final CmsSitemapTreeNode node,\n        final CmsResource fileToModify) {\n\n        if (!entry.isMarkedNoTranslation(m_localeContext.getComparisonLocale())) {\n            ContextMenuItem markPage = m_menu.addItem(\n                CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_ADD_DONT_TRANSLATE_0));\n            markPage.addItemClickListener(new ContextMenuItemClickListener() {\n\n                @SuppressWarnings(\"synthetic-access\")\n                public void contextMenuItemClicked(ContextMenuItemClickEvent event) {\n\n                    CmsResource fileToModify2 = fileToModify;\n                    if (fileToModify2.isFolder()) {\n                        try {\n                            fileToModify2 = A_CmsUI.getCmsObject().readDefaultFile(\n                                fileToModify2,\n                                CmsResourceFilter.IGNORE_EXPIRATION);\n                        } catch (CmsException e) {\n                            LOG.error(e.getLocalizedMessage(), e);\n                        }\n                    }\n\n                    CmsObject cms = A_CmsUI.getCmsObject();\n                    CmsLockActionRecord actionRecord = null;\n                    try {\n                        actionRecord = CmsLockUtil.ensureLock(cms, fileToModify2);\n                        m_localeContext.getComparisonLocale().toString();\n                        CmsProperty prop = cms.readPropertyObject(\n                            fileToModify2,\n                            CmsPropertyDefinition.PROPERTY_LOCALE_NOTRANSLATION,\n                            false);\n                        String propValue = prop.getValue();\n                        if (propValue == null) {\n                            propValue = \"\"; // make getLocales not return null\n                        }\n                        List<Locale> currentLocales = CmsLocaleManager.getLocales(propValue);\n                        if (!currentLocales.contains(m_localeContext.getComparisonLocale())) {\n                            currentLocales.add(m_localeContext.getComparisonLocale());\n                            String newPropValue = Joiner.on(\",\").join(currentLocales);\n                            CmsProperty newProp = new CmsProperty(\n                                CmsPropertyDefinition.PROPERTY_LOCALE_NOTRANSLATION,\n                                newPropValue,\n                                null);\n                            cms.writePropertyObjects(fileToModify2, Arrays.asList(newProp));\n                            DialogContext dialogContext = new DialogContext(\n                                A_CmsUI.getCmsObject().readResource(\n                                    entry.getClientEntry().getId(),\n                                    CmsResourceFilter.IGNORE_EXPIRATION),\n                                node);\n                            dialogContext.finish(Arrays.asList(fileToModify2.getStructureId()));\n\n                        }\n\n                    } catch (CmsException e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n\n                    } finally {\n                        if ((actionRecord != null) && (actionRecord.getChange() == LockChange.locked)) {\n                            try {\n                                cms.unlockResource(fileToModify2);\n                            } catch (CmsException e) {\n                                LOG.error(e.getLocalizedMessage(), e);\n                                CmsErrorDialog.showErrorDialog(e);\n                            }\n                        }\n                    }\n\n                }\n\n            });\n        } else {\n            ContextMenuItem unmarkPage = m_menu.addItem(\n                CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_REMOVE_DONT_TRANSLATE_0));\n            unmarkPage.addItemClickListener(new ContextMenuItemClickListener() {\n\n                @SuppressWarnings(\"synthetic-access\")\n                public void contextMenuItemClicked(ContextMenuItemClickEvent event) {\n\n                    CmsResource fileToModify2 = fileToModify;\n                    if (fileToModify2.isFolder()) {\n                        try {\n                            fileToModify2 = A_CmsUI.getCmsObject().readDefaultFile(\n                                fileToModify2,\n                                CmsResourceFilter.IGNORE_EXPIRATION);\n                        } catch (CmsException e) {\n                            LOG.error(e.getLocalizedMessage(), e);\n                        }\n                    }\n\n                    CmsObject cms = A_CmsUI.getCmsObject();\n                    CmsLockActionRecord actionRecord = null;\n                    try {\n                        actionRecord = CmsLockUtil.ensureLock(cms, fileToModify2);\n                        m_localeContext.getComparisonLocale().toString();\n                        CmsProperty prop = cms.readPropertyObject(\n                            fileToModify2,\n                            CmsPropertyDefinition.PROPERTY_LOCALE_NOTRANSLATION,\n                            false);\n                        String propValue = prop.getValue();\n                        if (propValue == null) {\n                            propValue = \"\"; // make getLocales not return null\n                        }\n                        List<Locale> currentLocales = CmsLocaleManager.getLocales(propValue);\n                        if (currentLocales.contains(m_localeContext.getComparisonLocale())) {\n                            currentLocales.remove(m_localeContext.getComparisonLocale());\n                            String newPropValue = Joiner.on(\",\").join(currentLocales);\n                            CmsProperty newProp = new CmsProperty(\n                                CmsPropertyDefinition.PROPERTY_LOCALE_NOTRANSLATION,\n                                newPropValue,\n                                null);\n                            cms.writePropertyObjects(fileToModify, Arrays.asList(newProp));\n                            DialogContext dialogContext = new DialogContext(\n                                A_CmsUI.getCmsObject().readResource(\n                                    entry.getClientEntry().getId(),\n                                    CmsResourceFilter.IGNORE_EXPIRATION),\n                                node);\n                            dialogContext.finish(Arrays.asList(fileToModify2.getStructureId()));\n                        }\n\n                    } catch (CmsException e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n\n                    } finally {\n                        if ((actionRecord != null) && (actionRecord.getChange() == LockChange.locked)) {\n                            try {\n                                cms.unlockResource(fileToModify2);\n                            } catch (CmsException e) {\n                                LOG.error(e.getLocalizedMessage(), e);\n                                CmsErrorDialog.showErrorDialog(e);\n                            }\n                        }\n                    }\n\n                }\n\n            });\n        }\n    }","id":91629,"modified_method":"/**\n     * Adds context menu items.<p>\n     *\n     * @param entry the tree node bean\n     * @param node the tree node widget\n     * @param fileToModify the file which the context menu items should actually operate on\n     */\n    private void addMarkItems(\n        final CmsSitemapTreeNodeData entry,\n        final CmsSitemapTreeNode node,\n        final CmsResource fileToModify) {\n\n        if (!entry.isMarkedNoTranslation(m_localeContext.getComparisonLocale())) {\n            if (!entry.isLinked()) {\n                ContextMenuItem markPage = m_menu.addItem(\n                    CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_ADD_DONT_TRANSLATE_0));\n                markPage.addItemClickListener(new ContextMenuItemClickListener() {\n\n                    @SuppressWarnings(\"synthetic-access\")\n                    public void contextMenuItemClicked(ContextMenuItemClickEvent event) {\n\n                        CmsResource fileToModify2 = fileToModify;\n                        if (fileToModify2.isFolder()) {\n                            try {\n                                fileToModify2 = A_CmsUI.getCmsObject().readDefaultFile(\n                                    fileToModify2,\n                                    CmsResourceFilter.IGNORE_EXPIRATION);\n                            } catch (CmsException e) {\n                                LOG.error(e.getLocalizedMessage(), e);\n                            }\n                        }\n\n                        CmsObject cms = A_CmsUI.getCmsObject();\n                        CmsLockActionRecord actionRecord = null;\n                        try {\n                            actionRecord = CmsLockUtil.ensureLock(cms, fileToModify2);\n                            m_localeContext.getComparisonLocale().toString();\n                            CmsProperty prop = cms.readPropertyObject(\n                                fileToModify2,\n                                CmsPropertyDefinition.PROPERTY_LOCALE_NOTRANSLATION,\n                                false);\n                            String propValue = prop.getValue();\n                            if (propValue == null) {\n                                propValue = \"\"; // make getLocales not return null\n                            }\n                            List<Locale> currentLocales = CmsLocaleManager.getLocales(propValue);\n                            if (!currentLocales.contains(m_localeContext.getComparisonLocale())) {\n                                currentLocales.add(m_localeContext.getComparisonLocale());\n                                String newPropValue = Joiner.on(\",\").join(currentLocales);\n                                CmsProperty newProp = new CmsProperty(\n                                    CmsPropertyDefinition.PROPERTY_LOCALE_NOTRANSLATION,\n                                    newPropValue,\n                                    null);\n                                cms.writePropertyObjects(fileToModify2, Arrays.asList(newProp));\n                                DialogContext dialogContext = new DialogContext(\n                                    A_CmsUI.getCmsObject().readResource(\n                                        entry.getClientEntry().getId(),\n                                        CmsResourceFilter.IGNORE_EXPIRATION),\n                                    node);\n                                dialogContext.finish(Arrays.asList(fileToModify2.getStructureId()));\n\n                            }\n\n                        } catch (CmsException e) {\n                            LOG.error(e.getLocalizedMessage(), e);\n                            CmsErrorDialog.showErrorDialog(e);\n\n                        } finally {\n                            if ((actionRecord != null) && (actionRecord.getChange() == LockChange.locked)) {\n                                try {\n                                    cms.unlockResource(fileToModify2);\n                                } catch (CmsException e) {\n                                    LOG.error(e.getLocalizedMessage(), e);\n                                    CmsErrorDialog.showErrorDialog(e);\n                                }\n                            }\n                        }\n\n                    }\n\n                });\n            }\n        } else {\n            ContextMenuItem unmarkPage = m_menu.addItem(\n                CmsVaadinUtils.getMessageText(Messages.GUI_LOCALECOMPARE_REMOVE_DONT_TRANSLATE_0));\n            unmarkPage.addItemClickListener(new ContextMenuItemClickListener() {\n\n                @SuppressWarnings(\"synthetic-access\")\n                public void contextMenuItemClicked(ContextMenuItemClickEvent event) {\n\n                    CmsResource fileToModify2 = fileToModify;\n                    if (fileToModify2.isFolder()) {\n                        try {\n                            fileToModify2 = A_CmsUI.getCmsObject().readDefaultFile(\n                                fileToModify2,\n                                CmsResourceFilter.IGNORE_EXPIRATION);\n                        } catch (CmsException e) {\n                            LOG.error(e.getLocalizedMessage(), e);\n                        }\n                    }\n\n                    CmsObject cms = A_CmsUI.getCmsObject();\n                    CmsLockActionRecord actionRecord = null;\n                    try {\n                        actionRecord = CmsLockUtil.ensureLock(cms, fileToModify2);\n                        m_localeContext.getComparisonLocale().toString();\n                        CmsProperty prop = cms.readPropertyObject(\n                            fileToModify2,\n                            CmsPropertyDefinition.PROPERTY_LOCALE_NOTRANSLATION,\n                            false);\n                        String propValue = prop.getValue();\n                        if (propValue == null) {\n                            propValue = \"\"; // make getLocales not return null\n                        }\n                        List<Locale> currentLocales = CmsLocaleManager.getLocales(propValue);\n                        if (currentLocales.contains(m_localeContext.getComparisonLocale())) {\n                            currentLocales.remove(m_localeContext.getComparisonLocale());\n                            String newPropValue = Joiner.on(\",\").join(currentLocales);\n                            CmsProperty newProp = new CmsProperty(\n                                CmsPropertyDefinition.PROPERTY_LOCALE_NOTRANSLATION,\n                                newPropValue,\n                                null);\n                            cms.writePropertyObjects(fileToModify, Arrays.asList(newProp));\n                            DialogContext dialogContext = new DialogContext(\n                                A_CmsUI.getCmsObject().readResource(\n                                    entry.getClientEntry().getId(),\n                                    CmsResourceFilter.IGNORE_EXPIRATION),\n                                node);\n                            dialogContext.finish(Arrays.asList(fileToModify2.getStructureId()));\n                        }\n\n                    } catch (CmsException e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                        CmsErrorDialog.showErrorDialog(e);\n\n                    } finally {\n                        if ((actionRecord != null) && (actionRecord.getChange() == LockChange.locked)) {\n                            try {\n                                cms.unlockResource(fileToModify2);\n                            } catch (CmsException e) {\n                                LOG.error(e.getLocalizedMessage(), e);\n                                CmsErrorDialog.showErrorDialog(e);\n                            }\n                        }\n                    }\n\n                }\n\n            });\n        }\n    }","commit_id":"ae9b6dd5634aaffb91a506aadc3fbe2a51249890","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the node data for children of a given node.<p>\n     *\n     * @param nodeData the node whose children to get\n     * @return the children\n     */\n    public List<CmsSitemapTreeNodeData> getChildren(CmsSitemapTreeNodeData nodeData) {\n\n        CmsClientSitemapEntry entry = nodeData.getClientEntry();\n\n        List<CmsSitemapTreeNodeData> result = Lists.newArrayList();\n\n        try {\n            CmsVfsSitemapService svc = getSitemapService();\n            CmsClientSitemapEntry ent = svc.getChildren(m_root.getRootPath(), entry.getId(), 1);\n            for (CmsClientSitemapEntry subEnt : ent.getSubEntries()) {\n                if (subEnt.isInNavigation() && (subEnt.getDefaultFileId() != null)) {\n                    try {\n                        CmsUUID idToRead = subEnt.getId();\n                        if (subEnt.getDefaultFileId() != null) {\n                            idToRead = subEnt.getDefaultFileId();\n                        }\n                        Locale l1 = OpenCms.getLocaleManager().getDefaultLocale(\n                            svc.getCmsObject(),\n                            svc.getCmsObject().readResource(idToRead));\n                        Locale l2 = OpenCms.getLocaleManager().getDefaultLocale(\n                            svc.getCmsObject(),\n                            svc.getCmsObject().readResource(ent.getId(), CmsResourceFilter.IGNORE_EXPIRATION));\n                        if (!l1.equals(l2)) {\n                            continue;\n                        }\n                    } catch (Exception e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                    }\n\n                    CmsSitemapTreeNodeData data = new CmsSitemapTreeNodeData(\n                        m_localeContext.getRootLocale(),\n                        m_localeContext.getComparisonLocale());\n                    if (m_foldersWithNoChildFolders.contains(subEnt.getId())) {\n                        data.setHasNoChildren(true);\n                    }\n                    data.setClientEntry(subEnt);\n                    try {\n                        data.initialize(m_cms);\n                        result.add(data);\n                    } catch (Exception e) {\n                        LOG.error(e.getLocalizedMessage());\n                    }\n                }\n            }\n        } catch (CmsException e) {\n            LOG.error(e.getLocalizedMessage(), e);\n        } catch (CmsRpcException e) {\n            LOG.error(e.getLocalizedMessage(), e);\n\n        }\n        return result;\n    }","id":91630,"modified_method":"/**\n     * Gets the node data for children of a given node.<p>\n     *\n     * @param nodeData the node whose children to get\n     * @return the children\n     */\n    public List<CmsSitemapTreeNodeData> getChildren(CmsSitemapTreeNodeData nodeData) {\n\n        CmsClientSitemapEntry entry = nodeData.getClientEntry();\n\n        List<CmsSitemapTreeNodeData> result = Lists.newArrayList();\n\n        try {\n            CmsVfsSitemapService svc = getSitemapService();\n            CmsClientSitemapEntry ent = svc.getChildren(m_root.getRootPath(), entry.getId(), 1);\n            for (CmsClientSitemapEntry subEnt : ent.getSubEntries()) {\n                if (subEnt.isInNavigation()\n                    && ((subEnt.getDefaultFileId() != null) || subEnt.isNavigationLevelType())) {\n                    try {\n                        CmsUUID idToRead = subEnt.getId();\n                        if (subEnt.getDefaultFileId() != null) {\n                            idToRead = subEnt.getDefaultFileId();\n                        }\n                        Locale l1 = OpenCms.getLocaleManager().getDefaultLocale(\n                            svc.getCmsObject(),\n                            svc.getCmsObject().readResource(idToRead));\n                        Locale l2 = OpenCms.getLocaleManager().getDefaultLocale(\n                            svc.getCmsObject(),\n                            svc.getCmsObject().readResource(ent.getId(), CmsResourceFilter.IGNORE_EXPIRATION));\n                        if (!l1.equals(l2)) {\n                            continue;\n                        }\n                    } catch (Exception e) {\n                        LOG.error(e.getLocalizedMessage(), e);\n                    }\n\n                    CmsSitemapTreeNodeData data = new CmsSitemapTreeNodeData(\n                        m_localeContext.getRootLocale(),\n                        m_localeContext.getComparisonLocale());\n                    if (m_foldersWithNoChildFolders.contains(subEnt.getId())) {\n                        data.setHasNoChildren(true);\n                    }\n                    data.setClientEntry(subEnt);\n                    try {\n                        data.initialize(m_cms);\n                        result.add(data);\n                    } catch (Exception e) {\n                        LOG.error(e.getLocalizedMessage());\n                    }\n                }\n            }\n        } catch (CmsException e) {\n            LOG.error(e.getLocalizedMessage(), e);\n        } catch (CmsRpcException e) {\n            LOG.error(e.getLocalizedMessage(), e);\n\n        }\n        return result;\n    }","commit_id":"ae9b6dd5634aaffb91a506aadc3fbe2a51249890","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a new instance.<p>\n     *\n     * @param cms the CMS context\n     * @param root the root resource of the tree\n     * @param context the locale context\n     */\n    public CmsSitemapTreeDataProvider(CmsObject cms, CmsResource root, I_CmsLocaleCompareContext context) {\n        m_root = root;\n        m_localeContext = context;\n        try {\n            m_cms = OpenCms.initCmsObject(cms);\n            List<CmsResource> folders = m_cms.readResources(\n                root,\n                CmsResourceFilter.IGNORE_EXPIRATION.addRequireFolder(),\n                true);\n            Collections.sort(folders, new Comparator<CmsResource>() {\n\n                public int compare(CmsResource arg0, CmsResource arg1) {\n\n                    return arg0.getRootPath().compareTo(arg1.getRootPath());\n                }\n            });\n            CmsResource lastFolder = null;\n            Set<CmsUUID> foldersWithNoChildFolders = Sets.newHashSet();\n            for (CmsResource folder : folders) {\n                if ((lastFolder != null)\n                    && !(CmsStringUtil.isPrefixPath(lastFolder.getRootPath(), folder.getRootPath()))) {\n                    foldersWithNoChildFolders.add(lastFolder.getStructureId());\n\n                }\n                lastFolder = folder;\n            }\n            m_foldersWithNoChildFolders = foldersWithNoChildFolders;\n        } catch (CmsException e) {\n            LOG.error(e.getLocalizedMessage(), e);\n        }\n    }","id":91631,"modified_method":"/**\n     * Creates a new instance.<p>\n     *\n     * @param cms the CMS context\n     * @param root the root resource of the tree\n     * @param context the locale context\n     */\n    public CmsSitemapTreeDataProvider(CmsObject cms, CmsResource root, I_CmsLocaleCompareContext context) {\n        m_root = root;\n        m_localeContext = context;\n        try {\n            m_cms = OpenCms.initCmsObject(cms);\n            List<CmsResource> folders = m_cms.readResources(\n                root,\n                CmsResourceFilter.IGNORE_EXPIRATION.addRequireFolder(),\n                true);\n            Collections.sort(folders, new Comparator<CmsResource>() {\n\n                public int compare(CmsResource arg0, CmsResource arg1) {\n\n                    return arg0.getRootPath().compareTo(arg1.getRootPath());\n                }\n            });\n            CmsResource lastFolder = null;\n            Set<CmsUUID> foldersWithNoChildFolders = Sets.newHashSet();\n\n            folders.add(null); // add null as a dummy value so that in the loop below, lastFolder takes all real folders as values\n            for (CmsResource folder : folders) {\n                if ((folder == null)\n                    || ((lastFolder != null)\n                        && !(CmsStringUtil.isPrefixPath(lastFolder.getRootPath(), folder.getRootPath())))) {\n                    foldersWithNoChildFolders.add(lastFolder.getStructureId());\n\n                }\n                lastFolder = folder;\n            }\n            m_foldersWithNoChildFolders = foldersWithNoChildFolders;\n        } catch (CmsException e) {\n            LOG.error(e.getLocalizedMessage(), e);\n        }\n    }","commit_id":"ae9b6dd5634aaffb91a506aadc3fbe2a51249890","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ui.A_CmsUI#init(com.vaadin.server.VaadinRequest)\n     */\n    @Override\n    protected void init(VaadinRequest request) {\n\n        super.init(request);\n        final I_CmsDialogContext context = new CmsEmbeddedDialogContext(Collections.<CmsResource> emptyList());\n        try {\n            OpenCms.getRoleManager().checkRole(getCmsObject(), CmsRole.ELEMENT_AUTHOR);\n\n            try {\n                Component dialog = getDialog(request, context);\n                String title;\n                if (dialog instanceof I_CmsHasTitle) {\n                    title = ((I_CmsHasTitle)dialog).getTitle(getLocale());\n                } else {\n                    title = CmsVaadinUtils.getMessageText(org.opencms.ui.dialogs.Messages.GUI_DIALOG_0);\n                }\n                context.start(title, dialog);\n            } catch (Throwable e) {\n                CmsErrorDialog.showErrorDialog(\"Could not instantiate requested dialog\", e, new Runnable() {\n\n                    public void run() {\n\n                        context.finish(null);\n                    }\n                });\n            }\n        } catch (CmsRoleViolationException ex) {\n            CmsErrorDialog.showErrorDialog(\n                CmsVaadinUtils.getMessageText(Messages.GUI_WORKPLACE_ACCESS_DENIED_TITLE_0),\n                ex,\n                new Runnable() {\n\n                    public void run() {\n\n                        context.finish(null);\n\n                    }\n                });\n        }\n    }","id":91632,"modified_method":"/**\n     * @see org.opencms.ui.A_CmsUI#init(com.vaadin.server.VaadinRequest)\n     */\n    @Override\n    protected void init(VaadinRequest request) {\n\n        super.init(request);\n        final I_CmsDialogContext context = new CmsEmbeddedDialogContext(Collections.<CmsResource> emptyList());\n        Throwable t = null;\n        String errorMessage = null;\n        try {\n            OpenCms.getRoleManager().checkRole(getCmsObject(), CmsRole.ELEMENT_AUTHOR);\n\n            try {\n                Component dialog = getDialog(request, context);\n                if (dialog != null) {\n                    String title;\n                    if (dialog instanceof I_CmsHasTitle) {\n                        title = ((I_CmsHasTitle)dialog).getTitle(getLocale());\n                    } else {\n                        title = CmsVaadinUtils.getMessageText(org.opencms.ui.dialogs.Messages.GUI_DIALOG_0);\n                    }\n                    context.start(title, dialog);\n                } else {\n                    errorMessage = CmsVaadinUtils.getMessageText(\n                        org.opencms.ui.dialogs.Messages.ERR_DIALOG_NOT_AVAILABLE_1,\n                        request.getPathInfo());\n                }\n            } catch (Throwable e) {\n                t = e;\n                errorMessage = CmsVaadinUtils.getMessageText(\n                    org.opencms.ui.dialogs.Messages.ERR_DAILOG_INSTANTIATION_FAILED_1,\n                    request.getPathInfo());\n            }\n        } catch (CmsRoleViolationException ex) {\n            t = ex;\n            errorMessage = CmsVaadinUtils.getMessageText(Messages.GUI_WORKPLACE_ACCESS_DENIED_TITLE_0);\n        }\n        if (errorMessage != null) {\n            CmsErrorDialog.showErrorDialog(errorMessage, t, new Runnable() {\n\n                public void run() {\n\n                    context.finish(null);\n\n                }\n            });\n        }\n    }","commit_id":"c5104c98bdbd3127c88ea3d2442f907d3da32bec","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@NotNull\n    public Map<String, SNodeDescriptor> map(final FileContent inputData) {\n      final Map<String, SNodeDescriptor> result = new HashMap<String, SNodeDescriptor>();\n      ModelAccess.instance().runIndexing(new Runnable() {\n        public void run() {\n          try {\n            SModel model = inputData.getUserData(PARSED_MODEL);\n\n            if (model == null) {\n              model = ModelPersistence.readModel(inputData.getContentAsText());\n              if (model != null) {\n                model.setLoading(true);\n              }\n              inputData.putUserData(PARSED_MODEL, model);\n            }\n\n            if (model == null) return;\n\n            List<SNode> nodes = getNodesToIterate(model);\n            for (final SNode node : nodes) {\n              String persistentName = node.getPersistentProperty(INamedConcept.NAME);\n              String nodeName = (persistentName == null) ? \"null\" : persistentName;\n              String conceptFqName = node.getConceptFqName();\n              SModelReference modelRef = model.getSModelReference();\n              int number = nodes.indexOf(node);\n              SNodeDescriptor value = SNodeDescriptor.fromModelReference(nodeName, conceptFqName, modelRef, number);\n              result.put(\"\" + result.size(), value);\n            }\n          } catch (JDOMException e) {\n            handleException(e, inputData);\n          } catch (IOException e) {\n            handleException(e, inputData);\n          }\n        }\n      });\n      return result;\n    }","id":91633,"modified_method":"@Override\n    protected List<SNodeDescriptor> computeValue(@NotNull final FileContent inputData) {\n      final List<SNodeDescriptor> descriptors = new ArrayList<SNodeDescriptor>();\n      ModelAccess.instance().runIndexing(new Runnable() {\n        public void run() {\n          try {\n            SModel model = inputData.getUserData(PARSED_MODEL);\n\n            if (model == null) {\n              model = ModelPersistence.readModel(inputData.getContentAsText());\n              if (model != null) {\n                model.setLoading(true);\n              }\n              inputData.putUserData(PARSED_MODEL, model);\n            }\n\n            if (model == null) return;\n\n            List<SNode> nodes = getNodesToIterate(model);\n            for (final SNode node : nodes) {\n              String persistentName = node.getPersistentProperty(INamedConcept.NAME);\n              String nodeName = (persistentName == null) ? \"null\" : persistentName;\n              String conceptFqName = node.getConceptFqName();\n              SModelReference modelRef = model.getSModelReference();\n              int number = nodes.indexOf(node);\n              SNodeDescriptor value = SNodeDescriptor.fromModelReference(nodeName, conceptFqName, modelRef, number);\n              descriptors.add(value);\n            }\n          } catch (JDOMException e) {\n            handleException(e, inputData);\n          } catch (IOException e) {\n            handleException(e, inputData);\n          }\n        }\n      });\n      return descriptors;\n    }","commit_id":"337ad5fcc7734264a2f8a34d09f58a3bfbf6da87","url":"https://github.com/JetBrains/MPS"},{"original_method":"public int getVersion() {\n    return 4;\n  }","id":91634,"modified_method":"public int getVersion() {\n    return 5;\n  }","commit_id":"337ad5fcc7734264a2f8a34d09f58a3bfbf6da87","url":"https://github.com/JetBrains/MPS"},{"original_method":"public DataIndexer<String, SNodeDescriptor, FileContent> getIndexer() {\n    return myIndexer;\n  }","id":91635,"modified_method":"@Override\n  public SingleEntryIndexer<List<SNodeDescriptor>> getIndexer() {\n    return myIndexer;\n  }","commit_id":"337ad5fcc7734264a2f8a34d09f58a3bfbf6da87","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public DataExternalizer<SNodeDescriptor> getValueExternalizer() {\n    return new EnumeratorSNodeDescriptor();\n  }","id":91636,"modified_method":"@Override\n  public DataExternalizer<List<SNodeDescriptor>> getValueExternalizer() {\n    return myValueExternalizer;\n  }","commit_id":"337ad5fcc7734264a2f8a34d09f58a3bfbf6da87","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNodeDescriptor[] find(final IScope scope) {\n    final Set<SNodeDescriptor> keys = new HashSet<SNodeDescriptor>();\n    final Set<SModelReference> hasToLoad = new HashSet<SModelReference>();\n    final Set<SModelReference> changedModels = new HashSet<SModelReference>();\n\n    for (SModelDescriptor sm : SModelRepository.getInstance().getChangedModels()) {\n      if (scope instanceof GlobalScope || scope.getModelDescriptors().contains(sm)) {\n        changedModels.add(sm.getSModelReference());\n      }\n    }\n\n    final ID<String, SNodeDescriptor> indexName = myIndex.getName();\n    final ModelConstraintsManager cm = ModelConstraintsManager.getInstance();\n    final FileBasedIndex fileBasedIndex = FileBasedIndex.getInstance();\n\n    fileBasedIndex.processAllValues(indexName, new AllValuesProcessor<SNodeDescriptor>() {\n      @Override\n      public void process(int inputId, SNodeDescriptor s) {\n        if (scope.getModelDescriptor(s.getModelReference()) == null) return;\n\n        if (changedModels.contains(s.getModelReference()) || cm.hasGetter(s.getConceptFqName(), INamedConcept.NAME)) {\n          hasToLoad.add(s.getModelReference());\n        } else {\n          keys.add(s);\n        }\n      }\n    }, getIdeaProject());\n\n    for (SModelReference ref : hasToLoad) {\n      SModelDescriptor sm = scope.getModelDescriptor(ref);\n      if (sm == null) continue;\n      List<SNode> nodes = myIndex.getNodesToIterate(sm.getSModel());\n\n      for (SNode root : nodes) {\n        int number = nodes.indexOf(root);\n        String nodeName = (root.getName() == null) ? \"null\" : root.getName();\n        SNodeDescriptor nodeDescriptor = SNodeDescriptor.fromModelReference(\n          nodeName, root.getConceptFqName(), root.getModel().getSModelReference(), number);\n        if (!keys.contains(nodeDescriptor)) {\n          keys.add(nodeDescriptor);\n        }\n      }\n    }\n\n    addJavaStubs(keys, scope);\n\n    return keys.toArray(new SNodeDescriptor[keys.size()]);\n  }","id":91637,"modified_method":"public SNodeDescriptor[] find(final IScope scope) {\n    final Set<SNodeDescriptor> keys = new HashSet<SNodeDescriptor>();\n\n    final ID<Integer, List<SNodeDescriptor>> indexName = myIndex.getName();\n    final ModelConstraintsManager cm = ModelConstraintsManager.getInstance();\n    final FileBasedIndex fileBasedIndex = FileBasedIndex.getInstance();\n\n\n    Set<SModelDescriptor> findDirectly = new HashSet<SModelDescriptor>();\n\n    for (SModelDescriptor sm : scope.getModelDescriptors()) {\n      if (!SModelStereotype.isUserModel(sm)) continue;\n\n      if (sm.isInitialized()) {\n        findDirectly.add(sm);\n        continue;\n      }\n\n      IFile modelFile = sm.getModelFile();\n      assert modelFile != null;\n      VirtualFile vf = modelFile.toVirtualFile();\n      int fileId = FileBasedIndex.getFileId(vf);\n\n      List<List<SNodeDescriptor>> descriptors = fileBasedIndex.getValues(indexName, fileId, GlobalSearchScope.fileScope(getIdeaProject(), vf));\n\n      if (!descriptors.isEmpty()) {\n        boolean needToLoad = false;\n        for (SNodeDescriptor snd : descriptors.get(0)) {\n          if (cm.hasGetter(snd.getConceptFqName(), INamedConcept.NAME)) {\n            needToLoad = true;\n            break;\n          }\n        }\n\n        if (needToLoad) {\n          findDirectly.add(sm);\n        } else {\n          keys.addAll(descriptors.get(0));\n        }\n      }\n    }\n\n    for (SModelDescriptor sm : findDirectly) {\n      List<SNode> nodes = myIndex.getNodesToIterate(sm.getSModel());\n\n      for (SNode root : nodes) {\n        int number = nodes.indexOf(root);\n        String nodeName = (root.getName() == null) ? \"null\" : root.getName();\n        SNodeDescriptor nodeDescriptor = SNodeDescriptor.fromModelReference(\n          nodeName, root.getConceptFqName(), root.getModel().getSModelReference(), number);\n        if (!keys.contains(nodeDescriptor)) {\n          keys.add(nodeDescriptor);\n        }\n      }\n    }\n\n    addJavaStubs(keys, scope);\n\n    return keys.toArray(new SNodeDescriptor[keys.size()]);\n  }","commit_id":"337ad5fcc7734264a2f8a34d09f58a3bfbf6da87","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ID<String, SNodeDescriptor> getName() {\n    return NAME;\n  }","id":91638,"modified_method":"public ID<Integer, List<SNodeDescriptor>> getName() {\n    return NAME;\n  }","commit_id":"337ad5fcc7734264a2f8a34d09f58a3bfbf6da87","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ID<String, SNodeDescriptor> getName() {\n    return NAME;\n  }","id":91639,"modified_method":"public ID<Integer, List<SNodeDescriptor>> getName() {\n    return NAME;\n  }","commit_id":"337ad5fcc7734264a2f8a34d09f58a3bfbf6da87","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void markOldStubs() {\n    Set<StubPath> newStubs = new HashSet<StubPath>();\n    for (AbstractModule module : getAllModules()) {\n      List<StubPath> moduleStubs = module.areJavaStubsEnabled() ? module.getAllStubPaths() : module.getStubPaths();\n      newStubs.addAll(moduleStubs);\n    }\n\n    List<StubPath> stubPathList = computeNotChangedStubPaths(myLoadedStubPaths.getAllStubPaths(),newStubs);\n\n    for (SModelDescriptor sm : SModelRepository.getInstance().getModelDescriptors()) {\n      if (!SModelStereotype.isStubModelStereotype(sm.getStereotype())) continue;\n      \n      BaseStubModelDescriptor baseDescriptor = (BaseStubModelDescriptor) sm;\n      if (notChanged(stubPathList, baseDescriptor)) continue;\n\n      baseDescriptor.markReload();\n    }\n  }","id":91640,"modified_method":"private void markOldStubs() {\n    if (myFirstReload) {\n      myFirstReload = false;\n      List<SModelDescriptor> models = SModelRepository.getInstance().getModelDescriptors();\n      for (SModelDescriptor m : new ArrayList<SModelDescriptor>(models)) {\n        if (!(m instanceof BaseStubModelDescriptor)) continue;\n        ((BaseStubModelDescriptor) m).markReload();\n      }\n    } else {\n      for (IModule m : MPSModuleRepository.getInstance().getAllModules()) {\n        //todo get rid of casting\n        markOldStubModels((AbstractModule) m);\n      }\n    }\n  }","commit_id":"911028cd6061b13721ca11684e0f362f6307273b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean notChanged(List<StubPath> notChangedStubPaths, BaseStubModelDescriptor sm) {\n    BaseStubModelDescriptor baseDescriptor = (BaseStubModelDescriptor) sm;\n\n    for (StubPath s : baseDescriptor.getPaths()) {\n      if (!notChangedStubPaths.contains(s)) return false;\n    }\n\n    return true;\n  }","id":91641,"modified_method":"private boolean notChanged(List<StubPath> notChangedStubPaths, SModelDescriptor sm) {\n    if (!(sm instanceof BaseStubModelDescriptor)) return false;\n    BaseStubModelDescriptor baseDescriptor = (BaseStubModelDescriptor) sm;\n\n    for (StubPath s : baseDescriptor.getPaths()) {\n      if (!notChangedStubPaths.contains(s)) return false;\n    }\n\n    return true;\n  }","commit_id":"911028cd6061b13721ca11684e0f362f6307273b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void reload() {\n    loadNewStubSolutions();\n\n    markOldStubs();\n    SModelRepository.getInstance().refreshModels();\n\n    for (AbstractModule m : getAllModules()) {\n      disposeAllStubManagers();\n      releaseOldStubs(m);\n    }\n\n    CleanupManager.getInstance().cleanup();\n    MPSModuleRepository.getInstance().invalidateCaches();\n\n    for (AbstractModule m : getAllModules()) {\n      loadNewStubs(m);\n    }\n\n    markNewStubs();\n  }","id":91642,"modified_method":"public void reload() {\n    loadNewStubSolutions();\n\n    markOldStubs();\n    SModelRepository.getInstance().refreshModels();\n\n    for (AbstractModule m: getAllModules()){\n      disposeAllStubManagers();\n      releaseOldStubs(((AbstractModule) m));\n    }\n\n    CleanupManager.getInstance().cleanup();\n    MPSModuleRepository.getInstance().invalidateCaches();\n\n    for (IModule m : getAllModules()) {\n      loadNewStubs(((AbstractModule) m));\n    }\n\n    markNewStubs();\n  }","commit_id":"911028cd6061b13721ca11684e0f362f6307273b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private List<StubPath> computeNotChangedStubPaths(Collection<StubPath> oldStubs,Collection<StubPath> newStubs) {\n    /*\n      We have to update stub path in the following cases:\n      * a new path which didn't existed\n      * an old path which does not exist any more\n      * timestamp for this path has changed (stubs change)\n      * model root manager for the path has changed (manager change leading to stubs change)\n    */\n\n    //we do not touch models whose loaded status, files and manager were not changed\n    List<StubPath> notChangedStubPaths = new ArrayList<StubPath>();\n\n    //todo make time linear [due to stubs list size this is not very significant]\n    for (StubPath os : oldStubs) {\n      for (StubPath ns : newStubs) {\n        if (os.equals(ns)) {\n          if (os.isFresh()) {\n            notChangedStubPaths.add(ns);\n          }\n        }\n      }\n    }\n    return notChangedStubPaths;\n  }","id":91643,"modified_method":"private List<StubPath> computeNotChangedStubPaths(AbstractModule module) {\n    /*\n      We have to update stub path in the following cases:\n      * a new path which didn't existed\n      * an old path which does not exist any more\n      * timestamp for this path has changed (stubs change)\n      * model root manager for the path has changed (manager change leading to stubs change)\n    */\n\n    //we do not touch models whose loaded status, files and manager were not changed\n    List<StubPath> notChangedStubPaths = new ArrayList<StubPath>();\n\n    List<StubPath> newStubs = module.areJavaStubsEnabled() ? module.getAllStubPaths() : module.getStubPaths();\n\n    //todo make time linear [due to stubs list size this is not very significant]\n    for (StubPath os : myLoadedStubPaths.get(module.getModuleId())) {\n      for (StubPath ns : newStubs) {\n        if (os.equals(ns)) {\n          if (os.isFresh()) {\n            notChangedStubPaths.add(ns);\n          }\n        }\n      }\n    }\n    return notChangedStubPaths;\n  }","commit_id":"911028cd6061b13721ca11684e0f362f6307273b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<StubPath> getAllStubPaths() {\n      Set<StubPath> result = new HashSet<StubPath>();\n      for (List<StubPath> lsp : values()) {\n        result.addAll(lsp);\n      }\n      return result;\n    }","id":91644,"modified_method":"public List<StubPath> getAllStubPaths() {\n      List<StubPath> result = new ArrayList<StubPath>();\n      for (List<StubPath> lsp : values()) {\n        result.addAll(lsp);\n      }\n      return result;\n    }","commit_id":"911028cd6061b13721ca11684e0f362f6307273b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean notChanged(List<StubPath> notChangedStubPaths, SModelDescriptor sm) {\n    if (!(sm instanceof BaseStubModelDescriptor)) return false;\n    BaseStubModelDescriptor baseDescriptor = (BaseStubModelDescriptor) sm;\n\n    for (StubPath s : baseDescriptor.getPaths()) {\n      if (!notChangedStubPaths.contains(s)) return false;\n    }\n\n    return true;\n  }","id":91645,"modified_method":"private boolean notChanged(List<StubPath> notChangedStubPaths, BaseStubModelDescriptor sm) {\n    BaseStubModelDescriptor baseDescriptor = (BaseStubModelDescriptor) sm;\n\n    for (StubPath s : baseDescriptor.getPaths()) {\n      if (!notChangedStubPaths.contains(s)) return false;\n    }\n\n    return true;\n  }","commit_id":"f206b1f84c0dcdcdf121bd36925eca9abde7d651","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<StubPath> getAllStubPaths() {\n      List<StubPath> result = new ArrayList<StubPath>();\n      for (List<StubPath> lsp : values()) {\n        result.addAll(lsp);\n      }\n      return result;\n    }","id":91646,"modified_method":"public Set<StubPath> getAllStubPaths() {\n      Set<StubPath> result = new HashSet<StubPath>();\n      for (List<StubPath> lsp : values()) {\n        result.addAll(lsp);\n      }\n      return result;\n    }","commit_id":"f206b1f84c0dcdcdf121bd36925eca9abde7d651","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void reload() {\n    loadNewStubSolutions();\n\n    markOldStubs();\n    SModelRepository.getInstance().refreshModels();\n\n    for (AbstractModule m: getAllModules()){\n      disposeAllStubManagers();\n      releaseOldStubs(((AbstractModule) m));\n    }\n\n    CleanupManager.getInstance().cleanup();\n    MPSModuleRepository.getInstance().invalidateCaches();\n\n    for (IModule m : getAllModules()) {\n      loadNewStubs(((AbstractModule) m));\n    }\n\n    markNewStubs();\n  }","id":91647,"modified_method":"public void reload() {\n    loadNewStubSolutions();\n\n    markOldStubs();\n    SModelRepository.getInstance().refreshModels();\n\n    for (AbstractModule m : getAllModules()) {\n      disposeAllStubManagers();\n      releaseOldStubs(m);\n    }\n\n    CleanupManager.getInstance().cleanup();\n    MPSModuleRepository.getInstance().invalidateCaches();\n\n    for (AbstractModule m : getAllModules()) {\n      loadNewStubs(m);\n    }\n\n    markNewStubs();\n  }","commit_id":"f206b1f84c0dcdcdf121bd36925eca9abde7d651","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void markOldStubs() {\n    if (myFirstReload) {\n      myFirstReload = false;\n      List<SModelDescriptor> models = SModelRepository.getInstance().getModelDescriptors();\n      for (SModelDescriptor m : new ArrayList<SModelDescriptor>(models)) {\n        if (!(m instanceof BaseStubModelDescriptor)) continue;\n        ((BaseStubModelDescriptor) m).markReload();\n      }\n    } else {\n      for (IModule m : MPSModuleRepository.getInstance().getAllModules()) {\n        //todo get rid of casting\n        markOldStubModels((AbstractModule) m);\n      }\n    }\n  }","id":91648,"modified_method":"private void markOldStubs() {\n    Set<StubPath> newStubs = new HashSet<StubPath>();\n    for (AbstractModule module : getAllModules()) {\n      List<StubPath> moduleStubs = module.areJavaStubsEnabled() ? module.getAllStubPaths() : module.getStubPaths();\n      newStubs.addAll(moduleStubs);\n    }\n\n    List<StubPath> stubPathList = computeNotChangedStubPaths(myLoadedStubPaths.getAllStubPaths(),newStubs);\n\n    for (SModelDescriptor sm : SModelRepository.getInstance().getModelDescriptors()) {\n      if (!SModelStereotype.isStubModelStereotype(sm.getStereotype())) continue;\n      \n      BaseStubModelDescriptor baseDescriptor = (BaseStubModelDescriptor) sm;\n      if (notChanged(stubPathList, baseDescriptor)) continue;\n\n      baseDescriptor.markReload();\n    }\n  }","commit_id":"f206b1f84c0dcdcdf121bd36925eca9abde7d651","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void markOldStubModels(AbstractModule module) {\n    List<StubPath> stubPathList = computeNotChangedStubPaths(module);\n    for (SModelDescriptor sm : SModelRepository.getInstance().getModelDescriptors(module)) {\n      if (!SModelStereotype.isStubModelStereotype(sm.getStereotype())) continue;\n      if (notChanged(stubPathList, sm)) continue;\n\n      assert sm instanceof BaseStubModelDescriptor : sm.getClass().getName();\n      ((BaseStubModelDescriptor) sm).markReload();\n    }\n  }","id":91649,"modified_method":"private List<StubPath> computeNotChangedStubPaths(Collection<StubPath> oldStubs,Collection<StubPath> newStubs) {\n    /*\n      We have to update stub path in the following cases:\n      * a new path which didn't existed\n      * an old path which does not exist any more\n      * timestamp for this path has changed (stubs change)\n      * model root manager for the path has changed (manager change leading to stubs change)\n    */\n\n    //we do not touch models whose loaded status, files and manager were not changed\n    List<StubPath> notChangedStubPaths = new ArrayList<StubPath>();\n\n    //todo make time linear [due to stubs list size this is not very significant]\n    for (StubPath os : oldStubs) {\n      for (StubPath ns : newStubs) {\n        if (os.equals(ns)) {\n          if (os.isFresh()) {\n            notChangedStubPaths.add(ns);\n          }\n        }\n      }\n    }\n    return notChangedStubPaths;\n  }","commit_id":"f206b1f84c0dcdcdf121bd36925eca9abde7d651","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Path calculateArchive( String database, Path to )\n    {\n        Path archive;\n        if ( Files.exists( to ) && Files.isDirectory( to ) )\n        {\n            archive = to.resolve( database + \".dump\" );\n        }\n        else\n        {\n            archive = to;\n        }\n        return archive;\n    }","id":91650,"modified_method":"private Path calculateArchive( String database, Path to )\n    {\n        return Files.isDirectory( to ) ? to.resolve( database + \".dump\" ) : to;\n    }","commit_id":"fa83d4000530334c50dcd9a378c4a68c1c72a26a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldRespectTheStoreLock() throws IOException, IncorrectUsage\n    {\n        Path databaseDirectory = homeDir.resolve( \"data/databases/foo.db\" );\n        Files.createDirectories( databaseDirectory );\n        new StoreLocker( new DefaultFileSystemAbstraction() ).checkLock( databaseDirectory.toFile() );\n\n        try\n        {\n            execute( \"foo.db\" );\n            fail( \"expected exception\" );\n        }\n        catch ( CommandFailed e )\n        {\n            assertThat( e.getMessage(), equalTo( \"the database is in use -- stop Neo4j and try again\" ) );\n        }\n    }","id":91651,"modified_method":"@Test\n    public void shouldRespectTheStoreLock() throws IOException, IncorrectUsage\n    {\n        Path databaseDirectory = homeDir.resolve( \"data/databases/foo.db\" );\n        Files.createDirectories( databaseDirectory );\n        StoreLocker storeLocker = new StoreLocker( new DefaultFileSystemAbstraction() );\n        storeLocker.checkLock( databaseDirectory.toFile() );\n\n        try\n        {\n            execute( \"foo.db\" );\n            fail( \"expected exception\" );\n        }\n        catch ( CommandFailed e )\n        {\n            assertThat( e.getMessage(), equalTo( \"the database is in use -- stop Neo4j and try again\" ) );\n        }\n        finally\n        {\n            storeLocker.release();\n        }\n    }","commit_id":"fa83d4000530334c50dcd9a378c4a68c1c72a26a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldReportAHelpfulErrorIfWeDontHaveWritePermissionsForLock()\n            throws IOException, IncorrectUsage\n    {\n        Path databaseDirectory = homeDir.resolve( \"data/databases/foo.db\" );\n        Files.createDirectories( databaseDirectory );\n        new StoreLocker( new DefaultFileSystemAbstraction() ).checkLock( databaseDirectory.toFile() );\n        Path lockFile = databaseDirectory.resolve( StoreLocker.STORE_LOCK_FILENAME );\n\n        try ( Closeable ignored = withPermissions( lockFile, emptySet() ) )\n        {\n            execute( \"foo.db\" );\n            fail( \"expected exception\" );\n        }\n        catch ( CommandFailed e )\n        {\n            assertThat( e.getMessage(), equalTo( \"you do not have permission to dump the database -- is Neo4j \" +\n                    \"running as a different user?\" ) );\n        }\n    }","id":91652,"modified_method":"@Test\n    public void shouldReportAHelpfulErrorIfWeDontHaveWritePermissionsForLock()\n            throws IOException, IncorrectUsage\n    {\n        assumeFalse( \"We haven't found a way to reliably tests permissions on Windows\", SystemUtils.IS_OS_WINDOWS );\n\n        Path databaseDirectory = homeDir.resolve( \"data/databases/foo.db\" );\n        Files.createDirectories( databaseDirectory );\n        StoreLocker storeLocker = new StoreLocker( new DefaultFileSystemAbstraction() );\n        storeLocker.checkLock( databaseDirectory.toFile() );\n\n        try ( Closeable ignored =\n                      withPermissions( databaseDirectory.resolve( StoreLocker.STORE_LOCK_FILENAME ), emptySet() ) )\n        {\n            execute( \"foo.db\" );\n            fail( \"expected exception\" );\n        }\n        catch ( CommandFailed e )\n        {\n            assertThat( e.getMessage(), equalTo( \"you do not have permission to dump the database -- is Neo4j \" +\n                    \"running as a different user?\" ) );\n        }\n        finally\n        {\n            storeLocker.release();\n        }\n    }","commit_id":"fa83d4000530334c50dcd9a378c4a68c1c72a26a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldReleaseTheStoreLockEvenIfThereIsAnError() throws IOException, IncorrectUsage\n    {\n        doThrow( IOException.class ).when( dumper ).dump( any(), any() );\n        Path databaseDirectory = homeDir.resolve( \"data/databases/foo.db\" );\n        Files.createDirectories( databaseDirectory );\n\n        try\n        {\n            execute( \"foo.db\" );\n        }\n        catch ( CommandFailed ignored )\n        {\n        }\n\n        new StoreLocker( new DefaultFileSystemAbstraction() ).checkLock( databaseDirectory.toFile() );\n    }","id":91653,"modified_method":"@Test\n    public void shouldReleaseTheStoreLockEvenIfThereIsAnError() throws IOException, IncorrectUsage\n    {\n        doThrow( IOException.class ).when( dumper ).dump( any(), any() );\n        Path databaseDirectory = homeDir.resolve( \"data/databases/foo.db\" );\n        Files.createDirectories( databaseDirectory );\n\n        try\n        {\n            execute( \"foo.db\" );\n        }\n        catch ( CommandFailed ignored )\n        {\n        }\n\n        assertCanLockStore( databaseDirectory );\n    }","commit_id":"fa83d4000530334c50dcd9a378c4a68c1c72a26a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldCalculateTheDatabaseDirectoryFromConfig() throws IOException, CommandFailed, IncorrectUsage\n    {\n        Path dataDir = testDirectory.directory( \"some-other-path\" ).toPath();\n        Path databaseDir = dataDir.resolve( \"databases/foo.db\" );\n        Files.createDirectories( databaseDir );\n        Files.write( configDir.resolve( \"neo4j.conf\" ), asList( format( \"%s=%s\", data_directory.name(), dataDir ) ) );\n\n        execute( \"foo.db\" );\n        verify( dumper ).dump( eq( databaseDir ), any() );\n    }","id":91654,"modified_method":"@Test\n    public void shouldCalculateTheDatabaseDirectoryFromConfig() throws IOException, CommandFailed, IncorrectUsage\n    {\n        Path dataDir = testDirectory.directory( \"some-other-path\" ).toPath();\n        Path databaseDir = dataDir.resolve( \"databases/foo.db\" );\n        Files.createDirectories( databaseDir );\n        Files.write( configDir.resolve( \"neo4j.conf\" ),\n                asList( format( \"%s=%s\", data_directory.name(), dataDir.toString().replace( '\\\\', '/' ) ) ) );\n\n        execute( \"foo.db\" );\n        verify( dumper ).dump( eq( databaseDir ), any() );\n    }","commit_id":"fa83d4000530334c50dcd9a378c4a68c1c72a26a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldReleaseTheStoreLockAfterDumping() throws IOException, IncorrectUsage, CommandFailed\n    {\n        Path databaseDirectory = homeDir.resolve( \"data/databases/foo.db\" );\n        Files.createDirectories( databaseDirectory );\n\n        execute( \"foo.db\" );\n        new StoreLocker( new DefaultFileSystemAbstraction() ).checkLock( databaseDirectory.toFile() );\n    }","id":91655,"modified_method":"@Test\n    public void shouldReleaseTheStoreLockAfterDumping() throws IOException, IncorrectUsage, CommandFailed\n    {\n        Path databaseDirectory = homeDir.resolve( \"data/databases/foo.db\" );\n        Files.createDirectories( databaseDirectory );\n\n        execute( \"foo.db\" );\n        assertCanLockStore( databaseDirectory );\n    }","commit_id":"fa83d4000530334c50dcd9a378c4a68c1c72a26a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldGiveAClearErrorMessageIfTheArchivesParentDirectoryIsNotWritable() throws IOException\n    {\n        Path directory = testDirectory.directory( \"a-directory\" ).toPath();\n        Path archive = testDirectory.file( \"subdir/the-archive.dump\" ).toPath();\n        Files.createDirectories( archive.getParent() );\n        try ( Closeable ignored = TestUtils.withPermissions( archive.getParent(), emptySet() ) )\n        {\n            new Dumper().dump( directory, archive );\n            fail( \"Expected an exception\" );\n        }\n        catch ( AccessDeniedException e )\n        {\n            assertEquals( archive.getParent().toString(), e.getMessage() );\n        }\n    }","id":91656,"modified_method":"@Test\n    public void shouldGiveAClearErrorMessageIfTheArchivesParentDirectoryIsNotWritable() throws IOException\n    {\n        assumeFalse( \"We haven't found a way to reliably tests permissions on Windows\", SystemUtils.IS_OS_WINDOWS );\n\n        Path directory = testDirectory.directory( \"a-directory\" ).toPath();\n        Path archive = testDirectory.file( \"subdir/the-archive.dump\" ).toPath();\n        Files.createDirectories( archive.getParent() );\n        try ( Closeable ignored = TestUtils.withPermissions( archive.getParent(), emptySet() ) )\n        {\n            new Dumper().dump( directory, archive );\n            fail( \"Expected an exception\" );\n        }\n        catch ( AccessDeniedException e )\n        {\n            assertEquals( archive.getParent().toString(), e.getMessage() );\n        }\n    }","commit_id":"fa83d4000530334c50dcd9a378c4a68c1c72a26a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void checkLock( Path databaseDirectory ) throws CommandFailed\n    {\n        try\n        {\n            new StoreLocker( new DefaultFileSystemAbstraction() ).checkLock( databaseDirectory.toFile() );\n        }\n        catch ( StoreLockException e )\n        {\n            throw new CommandFailed( \"the database is in use -- stop Neo4j and try again\", e );\n        }\n    }","id":91657,"modified_method":"private void checkLock( Path databaseDirectory ) throws CommandFailed\n    {\n        try\n        {\n            StoreLocker storeLocker = new StoreLocker( new DefaultFileSystemAbstraction() );\n            storeLocker.checkLock( databaseDirectory.toFile() );\n            storeLocker.release();\n        }\n        catch ( StoreLockException e )\n        {\n            throw new CommandFailed( \"the database is in use -- stop Neo4j and try again\", e );\n        }\n        catch ( IOException e )\n        {\n            wrapIOException( e );\n        }\n    }","commit_id":"fa83d4000530334c50dcd9a378c4a68c1c72a26a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldCalculateTheDatabaseDirectoryFromConfig()\n            throws IOException, CommandFailed, IncorrectUsage, IncorrectFormat\n    {\n        Files.write( configDir.resolve( \"neo4j.conf\" ), asList( data_directory.name() + \"=/some/data/dir\" ) );\n        execute( \"foo.db\" );\n        verify( loader ).load( any(), eq( Paths.get( \"/some/data/dir/databases/foo.db\" ) ) );\n    }","id":91658,"modified_method":"@Test\n    public void shouldCalculateTheDatabaseDirectoryFromConfig()\n            throws IOException, CommandFailed, IncorrectUsage, IncorrectFormat\n    {\n        Path dataDir = testDirectory.directory( \"some-other-path\" ).toPath();\n        Path databaseDir = dataDir.resolve( \"databases/foo.db\" );\n        Files.createDirectories( databaseDir );\n        Files.write( configDir.resolve( \"neo4j.conf\" ),\n                asList( format( \"%s=%s\", data_directory.name(), dataDir.toString().replace( '\\\\', '/' ) ) ) );\n\n        execute( \"foo.db\" );\n        verify( loader ).load( any(), eq( databaseDir ) );\n    }","commit_id":"fa83d4000530334c50dcd9a378c4a68c1c72a26a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static ArchiveInputStream openArchiveIn( Path archive ) throws IOException, IncorrectFormat\n    {\n        InputStream input = Files.newInputStream( archive );\n        GzipCompressorInputStream compressor;\n        try\n        {\n            compressor = new GzipCompressorInputStream( input );\n        }\n        catch ( IOException e )\n        {\n            throw new IncorrectFormat( archive, e );\n        }\n        return new TarArchiveInputStream( compressor );\n    }","id":91659,"modified_method":"private static ArchiveInputStream openArchiveIn( Path archive ) throws IOException, IncorrectFormat\n    {\n        InputStream input = Files.newInputStream( archive );\n        GzipCompressorInputStream compressor;\n        try\n        {\n            compressor = new GzipCompressorInputStream( input );\n        }\n        catch ( IOException e )\n        {\n            input.close();\n            throw new IncorrectFormat( archive, e );\n        }\n        return new TarArchiveInputStream( compressor );\n    }","commit_id":"fa83d4000530334c50dcd9a378c4a68c1c72a26a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldGiveAClearErrorMessageIfTheDestinationsParentDirectoryIsNotWritable()\n            throws IOException, IncorrectFormat\n    {\n        Path archive = testDirectory.file( \"the-archive.dump\" ).toPath();\n        Path destination = testDirectory.directory( \"subdir/the-destination\" ).toPath();\n        Files.createDirectories( destination.getParent() );\n        try ( Closeable ignored = withPermissions( destination.getParent(), emptySet() ) )\n        {\n            new Loader().load( archive, destination );\n            fail( \"Expected an exception\" );\n        }\n        catch ( AccessDeniedException e )\n        {\n            assertEquals( destination.getParent().toString(), e.getMessage() );\n        }\n    }","id":91660,"modified_method":"@Test\n    public void shouldGiveAClearErrorMessageIfTheDestinationsParentDirectoryIsNotWritable()\n            throws IOException, IncorrectFormat\n    {\n        assumeFalse( \"We haven't found a way to reliably tests permissions on Windows\", SystemUtils.IS_OS_WINDOWS );\n\n        Path archive = testDirectory.file( \"the-archive.dump\" ).toPath();\n        Path destination = testDirectory.directory( \"subdir/the-destination\" ).toPath();\n        Files.createDirectories( destination.getParent() );\n        try ( Closeable ignored = withPermissions( destination.getParent(), emptySet() ) )\n        {\n            new Loader().load( archive, destination );\n            fail( \"Expected an exception\" );\n        }\n        catch ( AccessDeniedException e )\n        {\n            assertEquals( destination.getParent().toString(), e.getMessage() );\n        }\n    }","commit_id":"fa83d4000530334c50dcd9a378c4a68c1c72a26a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void populateRequestParameters(HttpServletRequest request, HttpMessage message) throws Exception {\n        super.populateRequestParameters(request, message);\n\n        String path = request.getPathInfo();\n        if (path == null) {\n            return;\n        }\n\n        // in the endpoint the user may have defined rest {} placeholders\n        // so we need to map those placeholders with data from the incoming request context path\n\n        JettyHttpEndpoint endpoint = (JettyHttpEndpoint) message.getExchange().getFromEndpoint();\n        String consumerPath = endpoint.getPath();\n\n        String[] paths = path.split(\"/\");\n        String[] consumerPaths = consumerPath.split(\"/\");\n\n        for (int i = 0; i < consumerPaths.length; i++) {\n            if (paths.length < i) {\n                break;\n            }\n            String p1 = consumerPaths[i];\n            if (p1.startsWith(\"{\") && p1.endsWith(\"}\")) {\n                String key = p1.substring(1, p1.length() - 1);\n                String value = paths[i];\n                if (value != null) {\n                    message.setHeader(key, value);\n                }\n            }\n        }\n    }","id":91661,"modified_method":"@Override\n    protected void populateRequestParameters(HttpServletRequest request, HttpMessage message) throws Exception {\n        super.populateRequestParameters(request, message);\n\n        String path = request.getPathInfo();\n        if (path == null) {\n            return;\n        }\n\n        // in the endpoint the user may have defined rest {} placeholders\n        // so we need to map those placeholders with data from the incoming request context path\n\n        JettyHttpEndpoint endpoint = (JettyHttpEndpoint) message.getExchange().getFromEndpoint();\n        String consumerPath = endpoint.getPath();\n\n        if (useRestMatching(consumerPath)) {\n\n            // split using single char / is optimized in the jdk\n            String[] paths = path.split(\"/\");\n            String[] consumerPaths = consumerPath.split(\"/\");\n\n            for (int i = 0; i < consumerPaths.length; i++) {\n                if (paths.length < i) {\n                    break;\n                }\n                String p1 = consumerPaths[i];\n                if (p1.startsWith(\"{\") && p1.endsWith(\"}\")) {\n                    String key = p1.substring(1, p1.length() - 1);\n                    String value = paths[i];\n                    if (value != null) {\n                        message.setHeader(key, value);\n                    }\n                }\n            }\n        }\n    }","commit_id":"c5098c1df62e54ca7e7b5482f2f609ff7181e81f","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public HttpConsumer resolve(HttpServletRequest request, Map<String, HttpConsumer> consumers) {\n        HttpConsumer answer = super.resolve(request, consumers);\n\n        if (answer == null) {\n\n            String path = request.getPathInfo();\n            if (path == null) {\n                return null;\n            }\n\n            for (String key : consumers.keySet()) {\n                String consumerPath = normalizePath(key);\n                String requestPath = normalizePath(path);\n                if (matchPaths(requestPath, consumerPath)) {\n                    answer = consumers.get(key);\n                    break;\n                }\n            }\n        }\n\n        return answer;\n    }","id":91662,"modified_method":"@Override\n    public HttpConsumer resolve(HttpServletRequest request, Map<String, HttpConsumer> consumers) {\n        String path = request.getPathInfo();\n        if (path == null) {\n            return null;\n        }\n\n        for (String key : consumers.keySet()) {\n            if (useRestMatching(key) && matchRestPath(path, key)) {\n                return consumers.get(key);\n            }\n        }\n\n        // fallback to default\n        return super.resolve(request, consumers);\n    }","commit_id":"c5098c1df62e54ca7e7b5482f2f609ff7181e81f","url":"https://github.com/apache/camel"},{"original_method":"private boolean matchPaths(String requestPath, String consumerPath) {\n        String[] requestPaths = requestPath.split(\"/\");\n        String[] consumerPaths = consumerPath.split(\"/\");\n\n        // must be same length\n        if (requestPaths.length != consumerPaths.length) {\n            return false;\n        }\n\n        for (int i = 0; i < requestPaths.length; i++) {\n            String p1 = requestPaths[i];\n            String p2 = consumerPaths[i];\n\n            if (p2.equals(\"*\")) {\n                // always matches\n                continue;\n            }\n\n            if (!p1.equals(p2)) {\n                return false;\n            }\n        }\n\n        // assume matching\n        return true;\n    }","id":91663,"modified_method":"/**\n     * Matches the given request path with the configured consumer path\n     *\n     * @param requestPath   the request path\n     * @param consumerPath  the consumer path which may use { } tokens\n     * @return <tt>true<\/tt> if matched, <tt>false<\/tt> otherwise\n     */\n    public boolean matchRestPath(String requestPath, String consumerPath) {\n        // remove starting/ending slashes\n        if (requestPath.startsWith(\"/\")) {\n            requestPath = requestPath.substring(1);\n        }\n        if (requestPath.endsWith(\"/\")) {\n            requestPath = requestPath.substring(0, requestPath.length() - 1);\n        }\n        // remove starting/ending slashes\n        if (consumerPath.startsWith(\"/\")) {\n            consumerPath = consumerPath.substring(1);\n        }\n        if (consumerPath.endsWith(\"/\")) {\n            consumerPath = consumerPath.substring(0, consumerPath.length() - 1);\n        }\n\n        // split using single char / is optimized in the jdk\n        String[] requestPaths = requestPath.split(\"/\");\n        String[] consumerPaths = consumerPath.split(\"/\");\n\n        // must be same number of path's\n        if (requestPaths.length != consumerPaths.length) {\n            return false;\n        }\n\n        for (int i = 0; i < requestPaths.length; i++) {\n            String p1 = requestPaths[i];\n            String p2 = consumerPaths[i];\n\n            if (p2.startsWith(\"{\") && p2.endsWith(\"}\")) {\n                // always matches\n                continue;\n            }\n\n            if (!p1.equals(p2)) {\n                return false;\n            }\n        }\n\n        // assume matching\n        return true;\n    }","commit_id":"c5098c1df62e54ca7e7b5482f2f609ff7181e81f","url":"https://github.com/apache/camel"},{"original_method":"public SNode resolve(String name) {\n      SNode res = null;\n\n      SNode typeVar = MapSequence.fromMap(myTypeVars).get(name);\n\n      if ((typeVar == null)) {\n        if (myParent != null) {\n          res = myParent.resolve(name);\n        }\n      } else {\n        SNode typeVarRef = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", null);\n        SReference ref = new StaticReference(\"typeVariableDeclaration\", typeVarRef, typeVar);\n        typeVarRef.addReference(ref);\n        res = typeVarRef;\n      }\n\n      return res;\n    }","id":91664,"modified_method":"public SNode resolve(String name) {\n      SNode typeVar = MapSequence.fromMap(myTypeVars).get(name);\n\n      if ((typeVar == null)) {\n        return (myParent == null ?\n          null :\n          myParent.resolve(name)\n        );\n      } else {\n        SNode typeVarRef = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", null);\n        SReference ref = new StaticReference(\"typeVariableDeclaration\", typeVarRef, typeVar);\n        typeVarRef.addReference(ref);\n        return typeVarRef;\n      }\n    }","commit_id":"720b8504cbd8162cb0686c91c06e8a9f1ca63e6d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private PortalCache<Serializable, Serializable> _getPortalCache(\n\t\tClass<?> clazz, boolean createIfAbsent) {\n\n\t\tString className = clazz.getName();\n\n\t\tPortalCache<Serializable, Serializable> portalCache = _portalCaches.get(\n\t\t\tclassName);\n\n\t\tif ((portalCache == null) && createIfAbsent) {\n\t\t\tString groupKey = _GROUP_KEY_PREFIX.concat(className);\n\n\t\t\tportalCache =\n\t\t\t\t(PortalCache<Serializable, Serializable>)_multiVMPool.getCache(\n\t\t\t\t\tgroupKey, PropsValues.VALUE_OBJECT_ENTITY_BLOCKING_CACHE);\n\n\t\t\tif (PropsValues.VALUE_OBJECT_MVCC_ENTITY_CACHE_ENABLED &&\n\t\t\t\tMVCCModel.class.isAssignableFrom(clazz)) {\n\n\t\t\t\tportalCache =\n\t\t\t\t\t(PortalCache<Serializable, Serializable>)\n\t\t\t\t\t\tMVCCPortalCacheFactory.createMVCCEhcachePortalCache(\n\t\t\t\t\t\t\tportalCache);\n\t\t\t}\n\n\t\t\tPortalCache<Serializable, Serializable> previousPortalCache =\n\t\t\t\t_portalCaches.putIfAbsent(className, portalCache);\n\n\t\t\tif (previousPortalCache != null) {\n\t\t\t\tportalCache = previousPortalCache;\n\t\t\t}\n\t\t}\n\n\t\treturn portalCache;\n\t}","id":91665,"modified_method":"private PortalCache<Serializable, Serializable> _getPortalCache(\n\t\tClass<?> clazz, boolean createIfAbsent) {\n\n\t\tString className = clazz.getName();\n\n\t\tPortalCache<Serializable, Serializable> portalCache = _portalCaches.get(\n\t\t\tclassName);\n\n\t\tif ((portalCache == null) && createIfAbsent) {\n\t\t\tString groupKey = _GROUP_KEY_PREFIX.concat(className);\n\n\t\t\tportalCache = MultiVMPoolUtil.getCache(\n\t\t\t\tgroupKey, PropsValues.VALUE_OBJECT_ENTITY_BLOCKING_CACHE);\n\n\t\t\tif (PropsValues.VALUE_OBJECT_MVCC_ENTITY_CACHE_ENABLED &&\n\t\t\t\tMVCCModel.class.isAssignableFrom(clazz)) {\n\n\t\t\t\tportalCache =\n\t\t\t\t\t(PortalCache<Serializable, Serializable>)\n\t\t\t\t\t\tMVCCPortalCacheFactory.createMVCCEhcachePortalCache(\n\t\t\t\t\t\t\tportalCache);\n\t\t\t}\n\n\t\t\tPortalCache<Serializable, Serializable> previousPortalCache =\n\t\t\t\t_portalCaches.putIfAbsent(className, portalCache);\n\n\t\t\tif (previousPortalCache != null) {\n\t\t\t\tportalCache = previousPortalCache;\n\t\t\t}\n\t\t}\n\n\t\treturn portalCache;\n\t}","commit_id":"a23e190af5e4924a3779ac32b1975d4fc0c51686","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void afterPropertiesSet() {\n\t\tCacheRegistryUtil.register(this);\n\t}","id":91666,"modified_method":"public void afterPropertiesSet() {\n\t\tCacheRegistryUtil.register(this);\n\n\t\tPortalCacheManager<? extends Serializable, ? extends Serializable>\n\t\t\tportalCacheManager = MultiVMPoolUtil.getCacheManager();\n\n\t\tportalCacheManager.registerCacheManagerListener(this);\n\t}","commit_id":"a23e190af5e4924a3779ac32b1975d4fc0c51686","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void removeCache(String className) {\n\t\t_portalCaches.remove(className);\n\n\t\tString groupKey = _GROUP_KEY_PREFIX.concat(className);\n\n\t\t_multiVMPool.removeCache(groupKey);\n\t}","id":91667,"modified_method":"@Override\n\tpublic void removeCache(String className) {\n\t\t_portalCaches.remove(className);\n\n\t\tString groupKey = _GROUP_KEY_PREFIX.concat(className);\n\n\t\tMultiVMPoolUtil.removeCache(groupKey);\n\t}","commit_id":"a23e190af5e4924a3779ac32b1975d4fc0c51686","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void removeCache(String className) {\n\t\t_portalCaches.remove(className);\n\n\t\tString groupKey = _GROUP_KEY_PREFIX.concat(className);\n\n\t\t_multiVMPool.removeCache(groupKey);\n\t}","id":91668,"modified_method":"@Override\n\tpublic void removeCache(String className) {\n\t\t_portalCaches.remove(className);\n\n\t\tString groupKey = _GROUP_KEY_PREFIX.concat(className);\n\n\t\tMultiVMPoolUtil.removeCache(groupKey);\n\t}","commit_id":"a23e190af5e4924a3779ac32b1975d4fc0c51686","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void afterPropertiesSet() {\n\t\tCacheRegistryUtil.register(this);\n\t}","id":91669,"modified_method":"public void afterPropertiesSet() {\n\t\tCacheRegistryUtil.register(this);\n\n\t\tPortalCacheManager<? extends Serializable, ? extends Serializable>\n\t\t\tportalCacheManager = MultiVMPoolUtil.getCacheManager();\n\n\t\tportalCacheManager.registerCacheManagerListener(this);\n\t}","commit_id":"a23e190af5e4924a3779ac32b1975d4fc0c51686","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private PortalCache<Serializable, Serializable> _getPortalCache(\n\t\tString className, boolean createIfAbsent) {\n\n\t\tPortalCache<Serializable, Serializable> portalCache = _portalCaches.get(\n\t\t\tclassName);\n\n\t\tif ((portalCache == null) && createIfAbsent) {\n\t\t\tString groupKey = _GROUP_KEY_PREFIX.concat(className);\n\n\t\t\tportalCache =\n\t\t\t\t(PortalCache<Serializable, Serializable>)_multiVMPool.getCache(\n\t\t\t\t\tgroupKey, PropsValues.VALUE_OBJECT_FINDER_BLOCKING_CACHE);\n\n\t\t\tPortalCache<Serializable, Serializable> previousPortalCache =\n\t\t\t\t_portalCaches.putIfAbsent(className, portalCache);\n\n\t\t\tif (previousPortalCache != null) {\n\t\t\t\tportalCache = previousPortalCache;\n\t\t\t}\n\t\t}\n\n\t\treturn portalCache;\n\t}","id":91670,"modified_method":"private PortalCache<Serializable, Serializable> _getPortalCache(\n\t\tString className, boolean createIfAbsent) {\n\n\t\tPortalCache<Serializable, Serializable> portalCache = _portalCaches.get(\n\t\t\tclassName);\n\n\t\tif ((portalCache == null) && createIfAbsent) {\n\t\t\tString groupKey = _GROUP_KEY_PREFIX.concat(className);\n\n\t\t\tportalCache = MultiVMPoolUtil.getCache(\n\t\t\t\tgroupKey, PropsValues.VALUE_OBJECT_FINDER_BLOCKING_CACHE);\n\n\t\t\tPortalCache<Serializable, Serializable> previousPortalCache =\n\t\t\t\t_portalCaches.putIfAbsent(className, portalCache);\n\n\t\t\tif (previousPortalCache != null) {\n\t\t\t\tportalCache = previousPortalCache;\n\t\t\t}\n\t\t}\n\n\t\treturn portalCache;\n\t}","commit_id":"a23e190af5e4924a3779ac32b1975d4fc0c51686","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void afterPropertiesSet() {\n\t\t_portalCache = (PortalCache<String, Object>)_singleVMPool.getCache(\n\t\t\t_CACHE_NAME);\n\t}","id":91671,"modified_method":"public void afterPropertiesSet() {\n\t\t_portalCache = SingleVMPoolUtil.getCache(_CACHE_NAME);\n\t}","commit_id":"a23e190af5e4924a3779ac32b1975d4fc0c51686","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void afterPropertiesSet() {\n\t\t_portalCache = (PortalCache<Long, String>)_multiVMPool.getCache(\n\t\t\t_CACHE_NAME);\n\t}","id":91672,"modified_method":"public void afterPropertiesSet() {\n\t\t_portalCache = MultiVMPoolUtil.getCache(_CACHE_NAME);\n\t}","commit_id":"a23e190af5e4924a3779ac32b1975d4fc0c51686","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  @CheckForNull\n  public Date getLastSynchronization(Map<String, String> params) {\n    SearchRequestBuilder request = client.prepareSearch(this.getIndexName())\n      .setTypes(this.getIndexType())\n      .setQuery(QueryBuilders.filteredQuery(\n        QueryBuilders.matchAllQuery(),\n        getLastSynchronizationBuilder(params)\n      ))\n      .setSize(0)\n      .addAggregation(AggregationBuilders.max(\"latest\")\n        .field(BaseNormalizer.UPDATED_AT_FIELD));\n\n    SearchResponse response = request.get();\n\n    Max max = response.getAggregations().get(\"latest\");\n    if (max.getValue() > 0) {\n      Date date = new DateTime(Double.valueOf(max.getValue()).longValue()).toDate();\n      LOG.debug(\"Index {}:{} has last update of {}\", this.getIndexName(), this.getIndexType(), date);\n      return date;\n    } else {\n      LOG.debug(\"Index {}:{} has no last update date\", this.getIndexName(), this.getIndexType());\n      return null;\n    }\n  }","id":91673,"modified_method":"@Override\n  @CheckForNull\n  public Date getLastSynchronization(Map<String, String> params) {\n    SearchRequestBuilder request = client.prepareSearch(this.getIndexName())\n      .setTypes(this.getIndexType())\n      .setQuery(QueryBuilders.filteredQuery(\n        QueryBuilders.matchAllQuery(),\n        getLastSynchronizationBuilder(params)\n        ))\n      .setSize(0)\n      .addAggregation(AggregationBuilders.max(\"latest\")\n        .field(BaseNormalizer.UPDATED_AT_FIELD));\n\n    SearchResponse response = request.get();\n\n    Max max = response.getAggregations().get(\"latest\");\n    if (max.getValue() > 0) {\n      Date date = new DateTime((long) max.getValue()).toDate();\n      LOG.debug(\"Index {}:{} has last update of {}\", this.getIndexName(), this.getIndexType(), date);\n      return date;\n    } else {\n      LOG.debug(\"Index {}:{} has no last update date\", this.getIndexName(), this.getIndexType());\n      return null;\n    }\n  }","commit_id":"069ea95835b904dcef634c90b4c059ba45183c87","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public Iterator<DOMAIN> scroll(final String scrollId) {\n    return new Iterator<DOMAIN>() {\n\n      private final Queue<SearchHit> hits = new ArrayDeque<SearchHit>();\n\n      private void fillQueue() {\n        try {\n          SearchScrollRequestBuilder esRequest = client.prepareSearchScroll(scrollId)\n            .setScroll(TimeValue.timeValueMinutes(3));\n          Collections.addAll(hits, esRequest.get().getHits().getHits());\n        } catch (Exception e) {\n          throw new IllegalStateException(\"Error while filling in the scroll buffer\", e);\n        }\n      }\n\n      @Override\n      public boolean hasNext() {\n        if (hits.isEmpty()) {\n          fillQueue();\n        }\n        return !hits.isEmpty();\n      }\n\n      @Override\n      public DOMAIN next() {\n        if (hits.isEmpty()) {\n          fillQueue();\n        }\n        return toDoc(hits.poll().getSource());\n      }\n\n      @Override\n      public void remove() {\n        throw new IllegalStateException(\"Cannot remove item from scroll Iterable!!!\" +\n          \" Use Service or DAO classes instead\");\n      }\n    };\n  }","id":91674,"modified_method":"@Override\n  public Iterator<DOMAIN> scroll(final String scrollId) {\n    return new Iterator<DOMAIN>() {\n\n      private final Queue<SearchHit> hits = new ArrayDeque<SearchHit>();\n\n      private void fillQueue() {\n        try {\n          SearchScrollRequestBuilder esRequest = client.prepareSearchScroll(scrollId)\n            .setScroll(TimeValue.timeValueMinutes(3));\n          Collections.addAll(hits, esRequest.get().getHits().getHits());\n        } catch (Exception e) {\n          throw new IllegalStateException(\"Error while filling in the scroll buffer\", e);\n        }\n      }\n\n      @Override\n      public boolean hasNext() {\n        if (hits.isEmpty()) {\n          fillQueue();\n        }\n        return !hits.isEmpty();\n      }\n\n      @Override\n      public DOMAIN next() {\n        if (!hasNext()) {\n          throw new NoSuchElementException();\n        }\n        return toDoc(hits.poll().getSource());\n      }\n\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException(\"Cannot remove item from scroll\");\n      }\n    };\n  }","commit_id":"069ea95835b904dcef634c90b4c059ba45183c87","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static Result getMessage(double nbSeconds, double nbMinutes, double nbHours, double nbDays, double nbYears) {\n    if (nbSeconds < 45) {\n      return message(\"seconds\");\n    } else if (nbSeconds < 90) {\n      return message(\"minute\");\n    } else if (nbMinutes < 45) {\n      return message(\"minutes\", Math.round(nbMinutes));\n    } else if (nbMinutes < 90) {\n      return message(\"hour\");\n    } else if (nbHours < 24) {\n      return message(\"hours\", Math.round(nbHours));\n    } else if (nbHours < 48) {\n      return message(\"day\");\n    } else if (nbDays < 30) {\n      return message(\"days\", Double.valueOf(Math.floor(nbDays)).longValue());\n    } else if (nbDays < 60) {\n      return message( \"month\");\n    } else if (nbDays < 365) {\n      return message(\"months\", Double.valueOf(Math.floor(nbDays / 30)).longValue());\n    } else if (nbYears < 2) {\n      return message(\"year\");\n    }\n    return message(\"years\", Double.valueOf(Math.floor(nbYears)).longValue());\n  }","id":91675,"modified_method":"private static Result getMessage(double nbSeconds, double nbMinutes, double nbHours, double nbDays, double nbYears) {\n    if (nbSeconds < 45) {\n      return message(\"seconds\");\n    } else if (nbSeconds < 90) {\n      return message(\"minute\");\n    } else if (nbMinutes < 45) {\n      return message(\"minutes\", Math.round(nbMinutes));\n    } else if (nbMinutes < 90) {\n      return message(\"hour\");\n    } else if (nbHours < 24) {\n      return message(\"hours\", Math.round(nbHours));\n    } else if (nbHours < 48) {\n      return message(\"day\");\n    } else if (nbDays < 30) {\n      return message(\"days\", (long)(Math.floor(nbDays)));\n    } else if (nbDays < 60) {\n      return message( \"month\");\n    } else if (nbDays < 365) {\n      return message(\"months\", (long)(Math.floor(nbDays / 30)));\n    } else if (nbYears < 2) {\n      return message(\"year\");\n    }\n    return message(\"years\", (long)(Math.floor(nbYears)));\n  }","commit_id":"069ea95835b904dcef634c90b4c059ba45183c87","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Used in profiles_controller.rb\n   */\n  public QProfileActivityResult search(Map<String, Object> params) {\n    QProfileActivityQuery query = new QProfileActivityQuery();\n    QueryContext queryContext = new QueryContext().setMaxLimit();\n    List<String> profileKeys = RubyUtils.toStrings(params.get(\"profileKeys\"));\n    if (profileKeys != null) {\n      query.setQprofileKeys(profileKeys);\n    }\n    Date since = RubyUtils.toDate(params.get(\"since\"));\n    if (since != null) {\n      query.setSince(since);\n    }\n    Date to = RubyUtils.toDate(params.get(\"to\"));\n    if (to != null) {\n      query.setTo(to);\n    }\n    Integer page = RubyUtils.toInteger(params.get(\"p\"));\n    int pageIndex = page != null ? page : 1;\n    queryContext.setPage(pageIndex, 50);\n\n    Result<QProfileActivity> result = service.searchActivities(query, queryContext);\n    return new QProfileActivityResult(result.getHits(), Paging.create(queryContext.getLimit(), pageIndex, Long.valueOf(result.getTotal()).intValue()));\n  }","id":91676,"modified_method":"/**\n   * Used in profiles_controller.rb\n   */\n  public QProfileActivityResult search(Map<String, Object> params) {\n    QProfileActivityQuery query = new QProfileActivityQuery();\n    QueryContext queryContext = new QueryContext().setMaxLimit();\n    List<String> profileKeys = RubyUtils.toStrings(params.get(\"profileKeys\"));\n    if (profileKeys != null) {\n      query.setQprofileKeys(profileKeys);\n    }\n    Date since = RubyUtils.toDate(params.get(\"since\"));\n    if (since != null) {\n      query.setSince(since);\n    }\n    Date to = RubyUtils.toDate(params.get(\"to\"));\n    if (to != null) {\n      query.setTo(to);\n    }\n    Integer page = RubyUtils.toInteger(params.get(\"p\"));\n    int pageIndex = page != null ? page : 1;\n    queryContext.setPage(pageIndex, 50);\n\n    Result<QProfileActivity> result = service.searchActivities(query, queryContext);\n    return new QProfileActivityResult(result.getHits(), Paging.create(queryContext.getLimit(), pageIndex, (int) result.getTotal()));\n  }","commit_id":"069ea95835b904dcef634c90b4c059ba45183c87","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n\t * Add default NullnessAnnotations to given INullnessAnnotationDatabase.\n\t * \n\t * @param database an INullnessAnnotationDatabase\n\t */\n\tpublic static void addDefaultNullnessAnnotations(INullnessAnnotationDatabase database) {\n\t\tif (AnnotationDatabase.IGNORE_BUILTIN_ANNOTATIONS) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean missingClassWarningsSuppressed = AnalysisContext.currentAnalysisContext().setMissingClassWarningsSuppressed(true);\n\t\t\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.METHOD, \"java.lang.String\", NullnessAnnotation.NONNULL);\n\t\tdatabase.addFieldAnnotation(\"java.lang.System\", \"out\", \"Ljava/io/PrintStream;\", true, NullnessAnnotation.NONNULL);\n\t\tdatabase.addFieldAnnotation(\"java.lang.System\", \"err\", \"Ljava/io/PrintStream;\", true, NullnessAnnotation.NONNULL);\n\t\tdatabase.addFieldAnnotation(\"java.lang.System\", \"in\", \"Ljava/io/InputStream;\", true, NullnessAnnotation.NONNULL);\n\n\t\tdatabase.addMethodAnnotation(\"java.lang.ref.ReferenceQueue\", \"poll\", \"()Ljava/lang/ref/Reference;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.ref.Reference\", \"get\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Class\", \"newInstance\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Class\", \"forName\", \"(Ljava/lang/String;)Ljava/lang/Class;\", true, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.reflect.Method\", \"getParameterTypes\", \"()[Ljava/lang/Class;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Object\", \"clone\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Object\", \"toString\", \"()Ljava/lang/String;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Object\", \"getClass\", \"()Ljava/lang/Class;\", false, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Object\", \"equals\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Arrays\", \"asList\", \"([Ljava/lang/Object;)Ljava/util/List;\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Integer\", \"<init>\", \"(Ljava/lang/String;)V\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Integer\", \"parseInt\", \"(Ljava/lang/String;I)I\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Integer\", \"parseInt\", \"(Ljava/lang/String;)I\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.nio.channels.SocketChannel\", \"open\", \"()Ljava/nio/channels/SocketChannel;\", true,  NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodAnnotation(\"java.sql.Statement\", \"executeQuery\", \"(Ljava/lang/String;)Ljava/sql/ResultSet;\", false,  NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.sql.PreparedStatement\", \"executeQuery\", \"()Ljava/sql/ResultSet;\", false,  NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.sql.Connection\", \"prepareStatement\", \"(Ljava/lang/String;)Ljava/sql/PreparedStatement;\", false,  NullnessAnnotation.NONNULL);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.METHOD, \"java.sql.DatabaseMetaData\", NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getConnection\", \"()Ljava/sql/Connection;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getAttributes\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getColumns\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getSuperTables\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getSuperTypes\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getTimeDateFunctions\", \"()Ljava/lang/String;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getTypeInfo\", \"()Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getURL\", \"()Ljava/lang/String;\", false, NullnessAnnotation.NULLABLE);\n\t\t\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.package-info\", NullnessAnnotation.NONNULL);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.CopyOnWriteArrayList\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.CopyOnWriteArraySet\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentLinkedQueue$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.Exchanger\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.FutureTask\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.LinkedBlockingQueue$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$WaitQueue\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ThreadPoolExecutor$Worker\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.AbstractExecutorService\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$ConcurrentSkipListSubMap\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$HeadIndex\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\t\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$Index\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$SubMap\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListSet$ConcurrentSkipListSubSet\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.LinkedBlockingDeque$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$TransferQueue\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$TransferQueue$QNode\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$TransferStack\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$Transferer\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentMap\", \"containsKey\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentMap\", \"containsValue\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentMap\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentMap\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 1, NullnessAnnotation.NONNULL);\n\t\t\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.FutureTask\", \"<init>\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.Executors\", \"callable\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Callable;\", true, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"addWorker\", \"(Ljava/lang/Runnable;Z)Z\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentHashMap$Segment\", \"remove\", \"(Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;\", false, 2, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.CyclicBarrier\", \"<init>\", \"(ILjava/lang/Runnable;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.Executors$RunnableAdapter\", \"<init>\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentSkipListMap\", \"doRemove\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\t\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinPool\", \"casBarrierStack\",\n\t\t        \"(Ljava/util/concurrent/ForkJoinPool$WaitQueueNode;Ljava/util/concurrent/ForkJoinPool$WaitQueueNode;)Z\", false,\n\t\t        0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinPool\", \"casBarrierStack\",\n\t\t        \"(Ljava/util/concurrent/ForkJoinPool$WaitQueueNode;Ljava/util/concurrent/ForkJoinPool$WaitQueueNode;)Z\", false,\n\t\t        1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinPool\", \"casSpareStack\",\n\t\t        \"(Ljava/util/concurrent/ForkJoinPool$WaitQueueNode;Ljava/util/concurrent/ForkJoinPool$WaitQueueNode;)Z\", false,\n\t\t        1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinTask\", \"adapt\",\n\t\t        \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/ForkJoinTask;\", true, 1,\n\t\t        NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinTask\", \"awaitDone\",\n\t\t        \"(Ljava/util/concurrent/ForkJoinWorkerThread;J)I\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinTask\", \"awaitDone\",\n\t\t        \"(Ljava/util/concurrent/ForkJoinWorkerThread;Z)I\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinTask$AdaptedRunnable\", \"<init>\",\n\t\t        \"(Ljava/lang/Runnable;Ljava/lang/Object;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinWorkerThread\", \"onTermination\",\n\t\t        \"(Ljava/lang/Throwable;)V\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinWorkerThread\", \"setSlot\",\n\t\t        \"([Ljava/util/concurrent/ForkJoinTask;ILjava/util/concurrent/ForkJoinTask;)V\", true, 2,\n\t\t        NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.LinkedTransferQueue\", \"casCleanMe\",\n\t\t        \"(Ljava/util/concurrent/LinkedTransferQueue$Node;Ljava/util/concurrent/LinkedTransferQueue$Node;)Z\", false, 0,\n\t\t        NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.LinkedTransferQueue\", \"casCleanMe\",\n\t\t        \"(Ljava/util/concurrent/LinkedTransferQueue$Node;Ljava/util/concurrent/LinkedTransferQueue$Node;)Z\", false, 1,\n\t\t        NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.LinkedTransferQueue\", \"casHead\",\n\t\t        \"(Ljava/util/concurrent/LinkedTransferQueue$Node;Ljava/util/concurrent/LinkedTransferQueue$Node;)Z\", false, 0,\n\t\t        NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.LinkedTransferQueue\", \"xfer\",\n\t\t        \"(Ljava/lang/Object;ZIJ)Ljava/lang/Object;\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.LinkedTransferQueue$Itr\", \"advance\",\n\t\t        \"(Ljava/util/concurrent/LinkedTransferQueue$Node;)V\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.LinkedTransferQueue$Node\", \"casItem\",\n\t\t        \"(Ljava/lang/Object;Ljava/lang/Object;)Z\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.LinkedTransferQueue$Node\", \"casNext\",\n\t\t        \"(Ljava/util/concurrent/LinkedTransferQueue$Node;Ljava/util/concurrent/LinkedTransferQueue$Node;)Z\", false, 0,\n\t\t        NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.Phaser\", \"<init>\", \"(Ljava/util/concurrent/Phaser;)V\",\n\t\t        false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.Phaser\", \"<init>\", \"(Ljava/util/concurrent/Phaser;I)V\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif (ICSE10_NULLNESS_PAPER) {\n\t\tdatabase.addMethodAnnotation(\"java.util.HashMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.Hashtable\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.SortedMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.TreeMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\t}\n\t\t\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentMap\", \"putIfAbsent\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentMap\", \"replace\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentHashMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentHashMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentHashMap\", \"putIfAbsent\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\n\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReadWriteLock\", \"readLock\", \"()Ljava/util/concurrent/locks/Lock;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReadWriteLock\", \"writeLock\", \"()Ljava/util/concurrent/locks/Lock;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReentrantReadWriteLock\", \"readLock\", \"()Ljava/util/concurrent/locks/ReentrantReadWriteLock$ReadLock;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReentrantReadWriteLock\", \"writeLock\", \"()Ljava/util/concurrent/locks/ReentrantReadWriteLock$WriteLock;\", false, NullnessAnnotation.NONNULL);\n\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ExecutorService\", \"submit\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.AbstractExecutorService\", \"submit\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ExecutorCompletionService\", \"submit\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.AbstractExecutorServiceNullnessAnnotationDatabase\", \"newTaskFor\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ExecutorCompletionService\", \"newTaskFor\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/RunnableFuture;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"addIfUnderCorePoolSize\", \"(Ljava/lang/Runnable;)Z\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"addThread\", \"(Ljava/lang/Runnable;)Ljava/lang/Thread;\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"afterExecute\", \"(Ljava/lang/Runnable;Ljava/lang/Throwable;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\n\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"containsKey\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"containsKey\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedSet\", \"add\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedSet\", \"remove\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedSet\", \"contains\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"containsKey\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"containsValue\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"contains\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 1, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"javax.swing.UIDefaults\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Properties\", \"getProperty\", \"(Ljava/lang/String;)Ljava/lang/String;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Properties\", \"setProperty\", \"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\", false, 1, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Properties\", \"setProperty\", \"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\", false, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"org.w3c.dom.Element\", \"setAttribute\", \"(Ljava/lang/String;Ljava/lang/String;)V\", false, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.text.DateFormat\", \"parse\", \"(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/util/Date;\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.text.DateFormat\", \"parse\", \"(Ljava/lang/String;)Ljava/util/Date;\", true, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\t\n\t\t\n\n\n\t\t// addMethodAnnotation(\"java.util.Queue\", \"poll\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.io.BufferedReader\", \"readLine\", \"()Ljava/lang/String;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tAnalysisContext.currentAnalysisContext().setMissingClassWarningsSuppressed(missingClassWarningsSuppressed);\n\t\t\n\t}","id":91677,"modified_method":"/**\n\t * Add default NullnessAnnotations to given INullnessAnnotationDatabase.\n\t * \n\t * @param database an INullnessAnnotationDatabase\n\t */\n\tpublic static void addDefaultNullnessAnnotations(INullnessAnnotationDatabase database) {\n\t\tif (AnnotationDatabase.IGNORE_BUILTIN_ANNOTATIONS) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean missingClassWarningsSuppressed = AnalysisContext.currentAnalysisContext().setMissingClassWarningsSuppressed(true);\n\t\t\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.METHOD, \"java.lang.String\", NullnessAnnotation.NONNULL);\n\t\tdatabase.addFieldAnnotation(\"java.lang.System\", \"out\", \"Ljava/io/PrintStream;\", true, NullnessAnnotation.NONNULL);\n\t\tdatabase.addFieldAnnotation(\"java.lang.System\", \"err\", \"Ljava/io/PrintStream;\", true, NullnessAnnotation.NONNULL);\n\t\tdatabase.addFieldAnnotation(\"java.lang.System\", \"in\", \"Ljava/io/InputStream;\", true, NullnessAnnotation.NONNULL);\n\n\t\tdatabase.addMethodAnnotation(\"java.lang.ref.ReferenceQueue\", \"poll\", \"()Ljava/lang/ref/Reference;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.ref.Reference\", \"get\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Class\", \"newInstance\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Class\", \"forName\", \"(Ljava/lang/String;)Ljava/lang/Class;\", true, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.reflect.Method\", \"getParameterTypes\", \"()[Ljava/lang/Class;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Object\", \"clone\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Object\", \"toString\", \"()Ljava/lang/String;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Object\", \"getClass\", \"()Ljava/lang/Class;\", false, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Object\", \"equals\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Arrays\", \"asList\", \"([Ljava/lang/Object;)Ljava/util/List;\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Integer\", \"<init>\", \"(Ljava/lang/String;)V\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Integer\", \"parseInt\", \"(Ljava/lang/String;I)I\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Integer\", \"parseInt\", \"(Ljava/lang/String;)I\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.nio.channels.SocketChannel\", \"open\", \"()Ljava/nio/channels/SocketChannel;\", true,  NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodAnnotation(\"java.sql.Statement\", \"executeQuery\", \"(Ljava/lang/String;)Ljava/sql/ResultSet;\", false,  NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.sql.PreparedStatement\", \"executeQuery\", \"()Ljava/sql/ResultSet;\", false,  NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.sql.Connection\", \"prepareStatement\", \"(Ljava/lang/String;)Ljava/sql/PreparedStatement;\", false,  NullnessAnnotation.NONNULL);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.METHOD, \"java.sql.DatabaseMetaData\", NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getConnection\", \"()Ljava/sql/Connection;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getAttributes\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getColumns\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getSuperTables\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getSuperTypes\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getTimeDateFunctions\", \"()Ljava/lang/String;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getTypeInfo\", \"()Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getURL\", \"()Ljava/lang/String;\", false, NullnessAnnotation.NULLABLE);\n\t\t\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.package-info\", NullnessAnnotation.NONNULL);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.CopyOnWriteArrayList\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.CopyOnWriteArraySet\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentLinkedQueue$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.Exchanger\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.FutureTask\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.LinkedBlockingQueue$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$WaitQueue\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ThreadPoolExecutor$Worker\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.AbstractExecutorService\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$ConcurrentSkipListSubMap\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$HeadIndex\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\t\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$Index\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$SubMap\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListSet$ConcurrentSkipListSubSet\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.LinkedBlockingDeque$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$TransferQueue\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$TransferQueue$QNode\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$TransferStack\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$Transferer\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentMap\", \"containsKey\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentMap\", \"containsValue\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentMap\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentMap\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 1, NullnessAnnotation.NONNULL);\n\t\t\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.FutureTask\", \"<init>\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.Executors\", \"callable\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Callable;\", true, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"addWorker\", \"(Ljava/lang/Runnable;Z)Z\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentHashMap$Segment\", \"remove\", \"(Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;\", false, 2, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.CyclicBarrier\", \"<init>\", \"(ILjava/lang/Runnable;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.Executors$RunnableAdapter\", \"<init>\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentSkipListMap\", \"doRemove\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\t\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinPool\", \"casBarrierStack\",\n\t\t        \"(Ljava/util/concurrent/ForkJoinPool$WaitQueueNode;Ljava/util/concurrent/ForkJoinPool$WaitQueueNode;)Z\", false,\n\t\t        0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinPool\", \"casBarrierStack\",\n\t\t        \"(Ljava/util/concurrent/ForkJoinPool$WaitQueueNode;Ljava/util/concurrent/ForkJoinPool$WaitQueueNode;)Z\", false,\n\t\t        1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinPool\", \"casSpareStack\",\n\t\t        \"(Ljava/util/concurrent/ForkJoinPool$WaitQueueNode;Ljava/util/concurrent/ForkJoinPool$WaitQueueNode;)Z\", false,\n\t\t        1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinTask\", \"adapt\",\n\t\t        \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/ForkJoinTask;\", true, 1,\n\t\t        NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinTask\", \"awaitDone\",\n\t\t        \"(Ljava/util/concurrent/ForkJoinWorkerThread;J)I\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinTask\", \"awaitDone\",\n\t\t        \"(Ljava/util/concurrent/ForkJoinWorkerThread;Z)I\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinTask$AdaptedRunnable\", \"<init>\",\n\t\t        \"(Ljava/lang/Runnable;Ljava/lang/Object;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinWorkerThread\", \"onTermination\",\n\t\t        \"(Ljava/lang/Throwable;)V\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ForkJoinWorkerThread\", \"setSlot\",\n\t\t        \"([Ljava/util/concurrent/ForkJoinTask;ILjava/util/concurrent/ForkJoinTask;)V\", true, 2,\n\t\t        NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.LinkedTransferQueue\", \"casCleanMe\",\n\t\t        \"(Ljava/util/concurrent/LinkedTransferQueue$Node;Ljava/util/concurrent/LinkedTransferQueue$Node;)Z\", false, 0,\n\t\t        NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.LinkedTransferQueue\", \"casCleanMe\",\n\t\t        \"(Ljava/util/concurrent/LinkedTransferQueue$Node;Ljava/util/concurrent/LinkedTransferQueue$Node;)Z\", false, 1,\n\t\t        NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.LinkedTransferQueue\", \"casHead\",\n\t\t        \"(Ljava/util/concurrent/LinkedTransferQueue$Node;Ljava/util/concurrent/LinkedTransferQueue$Node;)Z\", false, 0,\n\t\t        NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.LinkedTransferQueue\", \"xfer\",\n\t\t        \"(Ljava/lang/Object;ZIJ)Ljava/lang/Object;\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.LinkedTransferQueue$Itr\", \"advance\",\n\t\t        \"(Ljava/util/concurrent/LinkedTransferQueue$Node;)V\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.LinkedTransferQueue$Node\", \"casItem\",\n\t\t        \"(Ljava/lang/Object;Ljava/lang/Object;)Z\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.LinkedTransferQueue$Node\", \"casNext\",\n\t\t        \"(Ljava/util/concurrent/LinkedTransferQueue$Node;Ljava/util/concurrent/LinkedTransferQueue$Node;)Z\", false, 0,\n\t\t        NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.Phaser\", \"<init>\", \"(Ljava/util/concurrent/Phaser;)V\",\n\t\t        false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.Phaser\", \"<init>\", \"(Ljava/util/concurrent/Phaser;I)V\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif (ICSE10_NULLNESS_PAPER) {\n\t\tdatabase.addMethodAnnotation(\"java.util.HashMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.Hashtable\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.SortedMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.TreeMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\t}\n\t\t\n\t\tif (false) {\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentMap\", \"putIfAbsent\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentMap\", \"replace\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentHashMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentHashMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentHashMap\", \"putIfAbsent\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\t}\n\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReadWriteLock\", \"readLock\", \"()Ljava/util/concurrent/locks/Lock;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReadWriteLock\", \"writeLock\", \"()Ljava/util/concurrent/locks/Lock;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReentrantReadWriteLock\", \"readLock\", \"()Ljava/util/concurrent/locks/ReentrantReadWriteLock$ReadLock;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReentrantReadWriteLock\", \"writeLock\", \"()Ljava/util/concurrent/locks/ReentrantReadWriteLock$WriteLock;\", false, NullnessAnnotation.NONNULL);\n\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ExecutorService\", \"submit\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.AbstractExecutorService\", \"submit\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ExecutorCompletionService\", \"submit\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.AbstractExecutorServiceNullnessAnnotationDatabase\", \"newTaskFor\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ExecutorCompletionService\", \"newTaskFor\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/RunnableFuture;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"addIfUnderCorePoolSize\", \"(Ljava/lang/Runnable;)Z\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"addThread\", \"(Ljava/lang/Runnable;)Ljava/lang/Thread;\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"afterExecute\", \"(Ljava/lang/Runnable;Ljava/lang/Throwable;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\n\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"containsKey\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"containsKey\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedSet\", \"add\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedSet\", \"remove\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedSet\", \"contains\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"containsKey\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"containsValue\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"contains\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 1, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"javax.swing.UIDefaults\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Properties\", \"getProperty\", \"(Ljava/lang/String;)Ljava/lang/String;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Properties\", \"setProperty\", \"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\", false, 1, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Properties\", \"setProperty\", \"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\", false, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"org.w3c.dom.Element\", \"setAttribute\", \"(Ljava/lang/String;Ljava/lang/String;)V\", false, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.text.DateFormat\", \"parse\", \"(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/util/Date;\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.text.DateFormat\", \"parse\", \"(Ljava/lang/String;)Ljava/util/Date;\", true, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\t\n\t\t\n\n\n\t\t// addMethodAnnotation(\"java.util.Queue\", \"poll\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.io.BufferedReader\", \"readLine\", \"()Ljava/lang/String;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tAnalysisContext.currentAnalysisContext().setMissingClassWarningsSuppressed(missingClassWarningsSuppressed);\n\t\t\n\t}","commit_id":"7ac666458da17a86d1a3ddc3fa4e6fbd9cda2ca4","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void checkEqualsComparison(Location location, JavaClass jclass, Method method, MethodGen methodGen,\n            ConstantPoolGen cpg, TypeDataflow typeDataflow) throws DataflowAnalysisException {\n\n        InstructionHandle handle = location.getHandle();\n        InstructionHandle next = handle.getNext();\n        if (next != null && next.getInstruction() instanceof INVOKESTATIC) {\n            INVOKESTATIC is = (INVOKESTATIC) next.getInstruction();\n            if (is.getMethodName(cpg).equals(\"assertFalse\")) {\n                return;\n            }\n        }\n        String sourceFile = jclass.getSourceFileName(); \n\n        TypeFrame frame = typeDataflow.getFactAtLocation(location);\n        if (frame.getStackDepth() < 2) {\n            throw new DataflowAnalysisException(\"Stack underflow\", methodGen, handle);\n        }\n\n        int numSlots = frame.getNumSlots();\n        Type lhsType_ = frame.getValue(numSlots - 2);\n        Type rhsType_ = frame.getValue(numSlots - 1);\n\n        // Ignore top and bottom values\n        if (lhsType_.getType() == T_TOP || lhsType_.getType() == T_BOTTOM || rhsType_.getType() == T_TOP\n                || rhsType_.getType() == T_BOTTOM) {\n            return;\n        }\n        InvokeInstruction inv = (InvokeInstruction) handle.getInstruction();\n        MethodAnnotation calledMethodAnnotation = getMethodCalledAnnotation(cpg, inv);\n        boolean looksLikeTestCase = TestCaseDetector.likelyTestCase(XFactory.createXMethod(methodGen));\n        int priorityModifier = 0;\n        if (looksLikeTestCase) {\n            priorityModifier = 2;\n        }\n\n        if (rhsType_.getType() == T_NULL) {\n            // A literal null value was passed directly to equals().\n            if (!looksLikeTestCase) {\n\n                try {\n                    IsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n                    IsNullValueFrame isNullFrame = isNullDataflow.getFactAtLocation(location);\n                    BugAnnotation a = BugInstance.getSourceForTopStackValue(classContext, method, location);\n                    int priority = NORMAL_PRIORITY;\n                    if (a instanceof FieldAnnotation && ((FieldAnnotation) a).isStatic())\n                        priority = LOW_PRIORITY;\n                    if (isNullFrame.isValid() && isNullFrame.getTopValue().isDefinitelyNull())\n                        bugAccumulator.accumulateBug(\n                                new BugInstance(this, \"EC_NULL_ARG\", priority).addClassAndMethod(methodGen, sourceFile),\n                                SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                        location.getHandle()));\n                } catch (CFGBuilderException e) {\n                    AnalysisContext.logError(\"Error getting null value analysis\", e);\n                }\n\n            }\n            return;\n        } else if (lhsType_.getType() == T_NULL) {\n            // Hmm...in this case, equals() is being invoked on\n            // a literal null value. This is really the\n            // purview of FindNullDeref. So, we'll just do nothing.\n            return;\n        } else if (!(lhsType_ instanceof ReferenceType) || !(rhsType_ instanceof ReferenceType)) {\n            bugReporter.logError(\"equals() used to compare non-object type(s) \" + lhsType_ + \" and \" + rhsType_ + \" in \"\n                    + SignatureConverter.convertMethodSignature(methodGen) + \" at \" + location.getHandle());\n            return;\n        }\n        IncompatibleTypes result = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_);\n\n        if (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType) {\n            String pattern = \"EC_BAD_ARRAY_COMPARE\";\n            IncompatibleTypes result2 = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_, true);\n            if (result2.getPriority() <= Priorities.NORMAL_PRIORITY)\n                pattern = \"EC_INCOMPATIBLE_ARRAY_COMPARE\";\n            bugAccumulator.accumulateBug(new BugInstance(this, pattern, NORMAL_PRIORITY).addClassAndMethod(methodGen, sourceFile)\n                    .addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        }\n\n        if (result == IncompatibleTypes.SEEMS_OK) return;\n\n        if (result.getPriority() >= Priorities.LOW_PRIORITY) {\n            comparedForEqualityInThisMethod.add(lhsType_.getSignature());\n            comparedForEqualityInThisMethod.add(rhsType_.getSignature());\n        }\n        if (result.getPriority() > Priorities.LOW_PRIORITY)\n            return;\n\n         if (result == IncompatibleTypes.ARRAY_AND_NON_ARRAY || result == IncompatibleTypes.ARRAY_AND_OBJECT) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, new HashSet<XMethod>());\n            if (allOk)\n                priorityModifier += 2;\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.INCOMPATIBLE_CLASSES) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean core = lhsSig.startsWith(\"Ljava\") && rhsSig.startsWith(\"Ljava\");\n            if (core) {\n                looksLikeTestCase = false;\n                priorityModifier = 0;\n            }\n            if (!looksLikeTestCase) {\n                Set<XMethod> targets = new HashSet<XMethod>();\n                boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, targets);\n                if (allOk)\n                    priorityModifier += 2;\n                bugAccumulator.accumulateBug(\n                        new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n                                .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                                .addSomeSourceForTopTwoStackValues(classContext, method, location).addEqualsMethodUsed(targets)\n                                .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                        SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                location.getHandle()));\n            }\n        } else if (result == IncompatibleTypes.UNRELATED_CLASS_AND_INTERFACE\n                || result == IncompatibleTypes.UNRELATED_FINAL_CLASS_AND_INTERFACE) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_CLASS_AND_INTERFACE\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature()))\n                            .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.UNRELATED_INTERFACES) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_INTERFACES\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature()))\n                            .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result != IncompatibleTypes.UNCHECKED && result.getPriority() <= Priorities.LOW_PRIORITY) {\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        }\n\n    }","id":91678,"modified_method":"private void checkEqualsComparison(Location location, JavaClass jclass, Method method, MethodGen methodGen,\n            ConstantPoolGen cpg, TypeDataflow typeDataflow) throws DataflowAnalysisException {\n\n        InstructionHandle handle = location.getHandle();\n        InstructionHandle next = handle.getNext();\n        if (next != null && next.getInstruction() instanceof INVOKESTATIC) {\n            INVOKESTATIC is = (INVOKESTATIC) next.getInstruction();\n            if (is.getMethodName(cpg).equals(\"assertFalse\")) {\n                return;\n            }\n        }\n        String sourceFile = jclass.getSourceFileName(); \n\n        TypeFrame frame = typeDataflow.getFactAtLocation(location);\n        if (frame.getStackDepth() < 2) {\n            throw new DataflowAnalysisException(\"Stack underflow\", methodGen, handle);\n        }\n\n        int numSlots = frame.getNumSlots();\n        Type lhsType_ = frame.getValue(numSlots - 2);\n        Type rhsType_ = frame.getValue(numSlots - 1);\n\n        // Ignore top and bottom values\n        if (lhsType_.getType() == T_TOP || lhsType_.getType() == T_BOTTOM || rhsType_.getType() == T_TOP\n                || rhsType_.getType() == T_BOTTOM) {\n            return;\n        }\n        InvokeInstruction inv = (InvokeInstruction) handle.getInstruction();\n        MethodAnnotation calledMethodAnnotation = getMethodCalledAnnotation(cpg, inv);\n        boolean looksLikeTestCase = TestCaseDetector.likelyTestCase(XFactory.createXMethod(methodGen));\n        int priorityModifier = 0;\n        if (looksLikeTestCase) {\n            priorityModifier = 2;\n        }\n\n        if (rhsType_.getType() == T_NULL) {\n            // A literal null value was passed directly to equals().\n            if (!looksLikeTestCase) {\n\n                try {\n                    IsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n                    IsNullValueFrame isNullFrame = isNullDataflow.getFactAtLocation(location);\n                    BugAnnotation a = BugInstance.getSourceForTopStackValue(classContext, method, location);\n                    int priority = NORMAL_PRIORITY;\n                    if (a instanceof FieldAnnotation && ((FieldAnnotation) a).isStatic())\n                        priority = LOW_PRIORITY;\n                    if (isNullFrame.isValid() && isNullFrame.getTopValue().isDefinitelyNull())\n                        bugAccumulator.accumulateBug(\n                                new BugInstance(this, \"EC_NULL_ARG\", priority).addClassAndMethod(methodGen, sourceFile),\n                                SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                        location.getHandle()));\n                } catch (CFGBuilderException e) {\n                    AnalysisContext.logError(\"Error getting null value analysis\", e);\n                }\n\n            }\n            return;\n        } else if (lhsType_.getType() == T_NULL) {\n            // Hmm...in this case, equals() is being invoked on\n            // a literal null value. This is really the\n            // purview of FindNullDeref. So, we'll just do nothing.\n            return;\n        } else if (!(lhsType_ instanceof ReferenceType) || !(rhsType_ instanceof ReferenceType)) {\n            bugReporter.logError(\"equals() used to compare non-object type(s) \" + lhsType_ + \" and \" + rhsType_ + \" in \"\n                    + SignatureConverter.convertMethodSignature(methodGen) + \" at \" + location.getHandle());\n            return;\n        }\n        IncompatibleTypes result = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_);\n\n        if (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType) {\n            String pattern = \"EC_BAD_ARRAY_COMPARE\";\n            IncompatibleTypes result2 = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_, true);\n            if (result2.getPriority() <= Priorities.NORMAL_PRIORITY)\n                pattern = \"EC_INCOMPATIBLE_ARRAY_COMPARE\";\n            bugAccumulator.accumulateBug(new BugInstance(this, pattern, NORMAL_PRIORITY).addClassAndMethod(methodGen, sourceFile)\n                    .addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        }\n\n        if (result == IncompatibleTypes.SEEMS_OK) return;\n\n        if (result.getPriority() >= Priorities.LOW_PRIORITY) {\n            comparedForEqualityInThisMethod.add(lhsType_.getSignature());\n            comparedForEqualityInThisMethod.add(rhsType_.getSignature());\n        }\n        if (result.getPriority() > Priorities.LOW_PRIORITY)\n            return;\n\n         if (result == IncompatibleTypes.ARRAY_AND_NON_ARRAY || result == IncompatibleTypes.ARRAY_AND_OBJECT) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, new HashSet<XMethod>());\n            if (allOk)\n                priorityModifier += 2;\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.INCOMPATIBLE_CLASSES) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean core = lhsSig.startsWith(\"Ljava\") && rhsSig.startsWith(\"Ljava\");\n            if (core) {\n                looksLikeTestCase = false;\n                priorityModifier = 0;\n            }\n            if (!looksLikeTestCase) {\n                Set<XMethod> targets = new HashSet<XMethod>();\n                boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, targets);\n                if (allOk)\n                    priorityModifier += 2;\n                bugAccumulator.accumulateBug(\n                        new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n                                .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                                .addSomeSourceForTopTwoStackValues(classContext, method, location).addEqualsMethodUsed(targets)\n                                .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                        SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                location.getHandle()));\n            }\n        } else if (result == IncompatibleTypes.UNRELATED_CLASS_AND_INTERFACE\n                || result == IncompatibleTypes.UNRELATED_FINAL_CLASS_AND_INTERFACE) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_CLASS_AND_INTERFACE\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature()))\n                            .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.UNRELATED_INTERFACES) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_INTERFACES\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature()))\n                            .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result != IncompatibleTypes.UNCHECKED && result.getPriority() <= Priorities.LOW_PRIORITY) {\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        }\n\n    }","commit_id":"def065fd753d57e79b1f82b7c874818862f5c5c1","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"protected void copyFile(SyncFile sourceSyncFile, SyncFile targetSyncFile)\n\t\tthrows Exception {\n\n\t\tif (_logger.isDebugEnabled()) {\n\t\t\t_logger.debug(\n\t\t\t\t\"Copying file {} to {}\",\n\t\t\t\tsourceSyncFile.getFilePathName(),\n\t\t\t\ttargetSyncFile.getFilePathName());\n\t\t}\n\n\t\tPath tempFilePath = FileUtil.getTempFilePath(targetSyncFile);\n\n\t\tFiles.copy(\n\t\t\tPaths.get(sourceSyncFile.getFilePathName()), tempFilePath,\n\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\n\t\tFileKeyUtil.writeFileKey(\n\t\t\ttempFilePath, String.valueOf(targetSyncFile.getSyncFileId()),\n\t\t\tfalse);\n\n\t\tWatcher watcher = WatcherRegistry.getWatcher(getSyncAccountId());\n\n\t\tList<String> downloadedFilePathNames =\n\t\t\twatcher.getDownloadedFilePathNames();\n\n\t\tdownloadedFilePathNames.add(targetSyncFile.getFilePathName());\n\n\t\tFiles.move(\n\t\t\ttempFilePath, Paths.get(targetSyncFile.getFilePathName()),\n\t\t\tStandardCopyOption.ATOMIC_MOVE,\n\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\n\t\ttargetSyncFile.setState(SyncFile.STATE_SYNCED);\n\t\ttargetSyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADED_NEW);\n\n\t\tSyncFileService.update(targetSyncFile);\n\t}","id":91679,"modified_method":"protected void copyFile(SyncFile sourceSyncFile, SyncFile targetSyncFile)\n\t\tthrows Exception {\n\n\t\tif (_logger.isDebugEnabled()) {\n\t\t\t_logger.debug(\n\t\t\t\t\"Copying file {} to {}\",\n\t\t\t\tsourceSyncFile.getFilePathName(),\n\t\t\t\ttargetSyncFile.getFilePathName());\n\t\t}\n\n\t\tPath tempFilePath = FileUtil.getTempFilePath(targetSyncFile);\n\n\t\tFiles.copy(\n\t\t\tPaths.get(sourceSyncFile.getFilePathName()), tempFilePath,\n\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\n\t\tFileKeyUtil.writeFileKey(\n\t\t\ttempFilePath, String.valueOf(targetSyncFile.getSyncFileId()),\n\t\t\tfalse);\n\n\t\tWatcher watcher = WatcherRegistry.getWatcher(getSyncAccountId());\n\n\t\tList<String> downloadedFilePathNames =\n\t\t\twatcher.getDownloadedFilePathNames();\n\n\t\tdownloadedFilePathNames.add(targetSyncFile.getFilePathName());\n\n\t\tFiles.move(\n\t\t\ttempFilePath, Paths.get(targetSyncFile.getFilePathName()),\n\t\t\tStandardCopyOption.ATOMIC_MOVE,\n\t\t\tStandardCopyOption.REPLACE_EXISTING);\n\n\t\ttargetSyncFile.setState(SyncFile.STATE_SYNCED);\n\n\t\tif (GetterUtil.getBoolean(\n\t\t\t\ttargetSyncFile.getLocalExtraSettingValue(\"restoreEvent\"))) {\n\n\t\t\ttargetSyncFile.unsetLocalExtraSetting(\"restoreEvent\");\n\n\t\t\ttargetSyncFile.setUiEvent(SyncFile.UI_EVENT_RESTORED_REMOTE);\n\t\t}\n\t\telse {\n\t\t\ttargetSyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADED_NEW);\n\t\t}\n\n\t\tSyncFileService.update(targetSyncFile);\n\t}","commit_id":"a833490b9668e3a999097e2dbcfbf73a24a7e9d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateFile(\n\t\t\tSyncFile sourceSyncFile, SyncFile targetSyncFile,\n\t\t\tString filePathName)\n\t\tthrows Exception {\n\n\t\tString sourceVersion = sourceSyncFile.getVersion();\n\t\tlong sourceVersionId = sourceSyncFile.getVersionId();\n\n\t\tboolean filePathChanged = processFilePathChange(\n\t\t\tsourceSyncFile, targetSyncFile);\n\n\t\tsourceSyncFile.setChangeLog(targetSyncFile.getChangeLog());\n\t\tsourceSyncFile.setChecksum(targetSyncFile.getChecksum());\n\t\tsourceSyncFile.setDescription(targetSyncFile.getDescription());\n\t\tsourceSyncFile.setExtension(targetSyncFile.getExtension());\n\t\tsourceSyncFile.setExtraSettings(targetSyncFile.getExtraSettings());\n\t\tsourceSyncFile.setLockExpirationDate(\n\t\t\ttargetSyncFile.getLockExpirationDate());\n\t\tsourceSyncFile.setLockUserId(targetSyncFile.getLockUserId());\n\t\tsourceSyncFile.setLockUserName(targetSyncFile.getLockUserName());\n\t\tsourceSyncFile.setModifiedTime(targetSyncFile.getModifiedTime());\n\t\tsourceSyncFile.setSize(targetSyncFile.getSize());\n\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_UPDATED_REMOTE);\n\t\tsourceSyncFile.setVersion(targetSyncFile.getVersion());\n\t\tsourceSyncFile.setVersionId(targetSyncFile.getVersionId());\n\n\t\tSyncFileService.update(sourceSyncFile);\n\n\t\tPath filePath = Paths.get(targetSyncFile.getFilePathName());\n\n\t\tif (filePathChanged && !Files.exists(filePath)) {\n\t\t\tif (targetSyncFile.isFolder()) {\n\t\t\t\tPath targetFilePath = Paths.get(filePathName);\n\n\t\t\t\tFiles.createDirectories(targetFilePath);\n\n\t\t\t\tsourceSyncFile.setState(SyncFile.STATE_SYNCED);\n\n\t\t\t\tSyncFileService.update(sourceSyncFile);\n\n\t\t\t\tFileKeyUtil.writeFileKey(\n\t\t\t\t\ttargetFilePath,\n\t\t\t\t\tString.valueOf(sourceSyncFile.getSyncFileId()), false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdownloadFile(sourceSyncFile, null, 0, false);\n\t\t\t}\n\t\t}\n\t\telse if (targetSyncFile.isFile() &&\n\t\t\t\t FileUtil.isModified(targetSyncFile, filePath)) {\n\n\t\t\tdownloadFile(\n\t\t\t\tsourceSyncFile, sourceVersion, sourceVersionId,\n\t\t\t\t!IODeltaUtil.isIgnoredFilePatchingExtension(targetSyncFile));\n\t\t}\n\t\telse {\n\t\t\tsourceSyncFile.setState(SyncFile.STATE_SYNCED);\n\n\t\t\tSyncFileService.update(sourceSyncFile);\n\t\t}\n\t}","id":91680,"modified_method":"protected void updateFile(\n\t\t\tSyncFile sourceSyncFile, SyncFile targetSyncFile,\n\t\t\tString filePathName)\n\t\tthrows Exception {\n\n\t\tString sourceVersion = sourceSyncFile.getVersion();\n\t\tlong sourceVersionId = sourceSyncFile.getVersionId();\n\n\t\tboolean filePathChanged = processFilePathChange(\n\t\t\tsourceSyncFile, targetSyncFile);\n\n\t\tsourceSyncFile.setChangeLog(targetSyncFile.getChangeLog());\n\t\tsourceSyncFile.setChecksum(targetSyncFile.getChecksum());\n\t\tsourceSyncFile.setDescription(targetSyncFile.getDescription());\n\t\tsourceSyncFile.setExtension(targetSyncFile.getExtension());\n\t\tsourceSyncFile.setExtraSettings(targetSyncFile.getExtraSettings());\n\t\tsourceSyncFile.setLockExpirationDate(\n\t\t\ttargetSyncFile.getLockExpirationDate());\n\t\tsourceSyncFile.setLockUserId(targetSyncFile.getLockUserId());\n\t\tsourceSyncFile.setLockUserName(targetSyncFile.getLockUserName());\n\t\tsourceSyncFile.setModifiedTime(targetSyncFile.getModifiedTime());\n\t\tsourceSyncFile.setSize(targetSyncFile.getSize());\n\t\tsourceSyncFile.setVersion(targetSyncFile.getVersion());\n\t\tsourceSyncFile.setVersionId(targetSyncFile.getVersionId());\n\n\t\tSyncFileService.update(sourceSyncFile);\n\n\t\tPath filePath = Paths.get(targetSyncFile.getFilePathName());\n\n\t\tif (filePathChanged && !Files.exists(filePath)) {\n\t\t\tif (targetSyncFile.isFolder()) {\n\t\t\t\tPath targetFilePath = Paths.get(filePathName);\n\n\t\t\t\tFiles.createDirectories(targetFilePath);\n\n\t\t\t\tsourceSyncFile.setState(SyncFile.STATE_SYNCED);\n\t\t\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_UPDATED_REMOTE);\n\n\t\t\t\tSyncFileService.update(sourceSyncFile);\n\n\t\t\t\tFileKeyUtil.writeFileKey(\n\t\t\t\t\ttargetFilePath,\n\t\t\t\t\tString.valueOf(sourceSyncFile.getSyncFileId()), false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdownloadFile(sourceSyncFile, null, 0, false);\n\t\t\t}\n\t\t}\n\t\telse if (targetSyncFile.isFile() &&\n\t\t\t\t FileUtil.isModified(targetSyncFile, filePath)) {\n\n\t\t\tdownloadFile(\n\t\t\t\tsourceSyncFile, sourceVersion, sourceVersionId,\n\t\t\t\t!IODeltaUtil.isIgnoredFilePatchingExtension(targetSyncFile));\n\t\t}\n\t\telse {\n\t\t\tsourceSyncFile.setState(SyncFile.STATE_SYNCED);\n\t\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_RENAMED_REMOTE);\n\n\t\t\tSyncFileService.update(sourceSyncFile);\n\t\t}\n\t}","commit_id":"53c3720339ae1720797c5559d64fc724f8aa20e8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addFile(SyncFile syncFile, String filePathName)\n\t\tthrows Exception {\n\n\t\tPath filePath = Paths.get(filePathName);\n\n\t\tif (Files.exists(filePath) &&\n\t\t\t(syncFile.isFolder() || !FileUtil.isModified(syncFile, filePath))) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tsyncFile.setFilePathName(filePathName);\n\t\tsyncFile.setSyncAccountId(getSyncAccountId());\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_ADDED_REMOTE);\n\n\t\tif (syncFile.isFolder()) {\n\t\t\tFiles.createDirectories(filePath);\n\n\t\t\tsyncFile.setState(SyncFile.STATE_SYNCED);\n\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tFileKeyUtil.writeFileKey(\n\t\t\t\tfilePath, String.valueOf(syncFile.getSyncFileId()), false);\n\t\t}\n\t\telse {\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tdownloadFile(syncFile, null, 0, false);\n\t\t}\n\t}","id":91681,"modified_method":"protected void addFile(SyncFile syncFile, String filePathName)\n\t\tthrows Exception {\n\n\t\tPath filePath = Paths.get(filePathName);\n\n\t\tif (Files.exists(filePath) &&\n\t\t\t(syncFile.isFolder() || !FileUtil.isModified(syncFile, filePath))) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tsyncFile.setFilePathName(filePathName);\n\t\tsyncFile.setSyncAccountId(getSyncAccountId());\n\n\t\tif (syncFile.isFolder()) {\n\t\t\tFiles.createDirectories(filePath);\n\n\t\t\tsyncFile.setState(SyncFile.STATE_SYNCED);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_ADDED_REMOTE);\n\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tFileKeyUtil.writeFileKey(\n\t\t\t\tfilePath, String.valueOf(syncFile.getSyncFileId()), false);\n\t\t}\n\t\telse {\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADING);\n\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tdownloadFile(syncFile, null, 0, false);\n\t\t}\n\t}","commit_id":"29a55743f5bee24ded4e10bddd71ea1e1fa233d2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void processResponse(String response) throws Exception {\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\n\t\tSyncDLObjectUpdate syncDLObjectUpdate = objectMapper.readValue(\n\t\t\tresponse, new TypeReference<SyncDLObjectUpdate>() {});\n\n\t\tfor (SyncFile syncFile : syncDLObjectUpdate.getSyncDLObjects()) {\n\t\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\tsyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\t\tsyncFile.getParentFolderId());\n\n\t\t\tString filePathName = null;\n\n\t\t\tif (parentSyncFile != null) {\n\t\t\t\tfilePathName = FilePathNameUtil.getFilePathName(\n\t\t\t\t\tparentSyncFile.getFilePathName(), syncFile.getName());\n\t\t\t}\n\n\t\t\tString event = syncFile.getEvent();\n\n\t\t\tif (event.equals(SyncFile.EVENT_ADD) ||\n\t\t\t\tevent.equals(SyncFile.EVENT_GET) ||\n\t\t\t\tevent.equals(SyncFile.EVENT_RESTORE)) {\n\n\t\t\t\taddFile(syncFile, filePathName);\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_DELETE)) {\n\t\t\t\tsyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\t\tsyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\t\t\tsyncFile.getTypePK());\n\n\t\t\t\tsyncFile.setState(SyncFile.STATE_DELETED);\n\t\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DELETED_REMOTE);\n\n\t\t\t\tSyncFileService.update(syncFile);\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_MOVE)) {\n\t\t\t\tmoveFile(syncFile, filePathName);\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_TRASH)) {\n\t\t\t\tdeleteFile(syncFile);\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_UPDATE)) {\n\t\t\t\tupdateFile(syncFile);\n\t\t\t}\n\t\t}\n\n\t\tSyncSite syncSite = SyncSiteService.fetchSyncSite(\n\t\t\t(Long)getParameterValue(\"repositoryId\"), getSyncAccountId());\n\n\t\tsyncSite.setLastRemoteSyncTime(syncDLObjectUpdate.getLastAccessTime());\n\n\t\tSyncSiteService.update(syncSite);\n\t}","id":91682,"modified_method":"@Override\n\tprotected void processResponse(String response) throws Exception {\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\n\t\tSyncDLObjectUpdate syncDLObjectUpdate = objectMapper.readValue(\n\t\t\tresponse, new TypeReference<SyncDLObjectUpdate>() {});\n\n\t\tfor (SyncFile syncFile : syncDLObjectUpdate.getSyncDLObjects()) {\n\t\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\tsyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\t\tsyncFile.getParentFolderId());\n\n\t\t\tString filePathName = null;\n\n\t\t\tif (parentSyncFile != null) {\n\t\t\t\tfilePathName = FilePathNameUtil.getFilePathName(\n\t\t\t\t\tparentSyncFile.getFilePathName(), syncFile.getName());\n\t\t\t}\n\n\t\t\tString event = syncFile.getEvent();\n\n\t\t\tif (event.equals(SyncFile.EVENT_ADD) ||\n\t\t\t\tevent.equals(SyncFile.EVENT_GET) ||\n\t\t\t\tevent.equals(SyncFile.EVENT_RESTORE)) {\n\n\t\t\t\taddFile(syncFile, filePathName);\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_DELETE)) {\n\t\t\t\tdeleteFile(syncFile, false);\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_MOVE)) {\n\t\t\t\tmoveFile(syncFile, filePathName);\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_TRASH)) {\n\t\t\t\tdeleteFile(syncFile, true);\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_UPDATE)) {\n\t\t\t\tupdateFile(syncFile);\n\t\t\t}\n\t\t}\n\n\t\tSyncSite syncSite = SyncSiteService.fetchSyncSite(\n\t\t\t(Long)getParameterValue(\"repositoryId\"), getSyncAccountId());\n\n\t\tsyncSite.setLastRemoteSyncTime(syncDLObjectUpdate.getLastAccessTime());\n\n\t\tSyncSiteService.update(syncSite);\n\t}","commit_id":"c92accda97ca1724390391ba2a7ae430c8ec0c86","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void deleteFile(SyncFile targetSyncFile) throws Exception {\n\t\tSyncFile sourceSyncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\ttargetSyncFile.getTypePK());\n\n\t\tif (sourceSyncFile == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_TRASHED_REMOTE);\n\n\t\tFiles.deleteIfExists(Paths.get(sourceSyncFile.getFilePathName()));\n\n\t\tSyncFileService.deleteSyncFile(sourceSyncFile);\n\t}","id":91683,"modified_method":"protected void deleteFile(SyncFile targetSyncFile, boolean trashed)\n\t\tthrows Exception {\n\n\t\tSyncFile sourceSyncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\ttargetSyncFile.getTypePK());\n\n\t\tif (sourceSyncFile == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (trashed) {\n\t\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_TRASHED_REMOTE);\n\t\t}\n\t\telse {\n\t\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_DELETED_REMOTE);\n\t\t}\n\n\t\tFiles.deleteIfExists(Paths.get(sourceSyncFile.getFilePathName()));\n\n\t\tSyncFileService.deleteSyncFile(sourceSyncFile);\n\t}","commit_id":"c92accda97ca1724390391ba2a7ae430c8ec0c86","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static SyncFile deleteFolderSyncFile(\n\t\t\tlong syncAccountId, SyncFile syncFile)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DELETED_LOCAL);\n\n\t\tdeleteSyncFile(syncFile);\n\n\t\t// Remote sync file\n\n\t\tif (syncFile.getState() == SyncFile.STATE_DELETED) {\n\t\t\treturn syncFile;\n\t\t}\n\n\t\tMap<String, Object> parameters = new HashMap<String, Object>();\n\n\t\tparameters.put(\"folderId\", syncFile.getTypePK());\n\n\t\tMoveFolderToTrashEvent moveFolderToTrashEvent =\n\t\t\tnew MoveFolderToTrashEvent(syncAccountId, parameters);\n\n\t\tmoveFolderToTrashEvent.run();\n\n\t\treturn syncFile;\n\t}","id":91684,"modified_method":"public static SyncFile deleteFolderSyncFile(\n\t\t\tlong syncAccountId, SyncFile syncFile)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DELETED_LOCAL);\n\n\t\tdeleteSyncFile(syncFile);\n\n\t\t// Remote sync file\n\n\t\tMap<String, Object> parameters = new HashMap<String, Object>();\n\n\t\tparameters.put(\"folderId\", syncFile.getTypePK());\n\n\t\tMoveFolderToTrashEvent moveFolderToTrashEvent =\n\t\t\tnew MoveFolderToTrashEvent(syncAccountId, parameters);\n\n\t\tmoveFolderToTrashEvent.run();\n\n\t\treturn syncFile;\n\t}","commit_id":"c92accda97ca1724390391ba2a7ae430c8ec0c86","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static SyncFile deleteFileSyncFile(\n\t\t\tlong syncAccountId, SyncFile syncFile)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DELETED_LOCAL);\n\n\t\tdeleteSyncFile(syncFile);\n\n\t\t// Remote sync file\n\n\t\tif (syncFile.getState() == SyncFile.STATE_DELETED) {\n\t\t\treturn syncFile;\n\t\t}\n\n\t\tMap<String, Object> parameters = new HashMap<String, Object>();\n\n\t\tparameters.put(\"fileEntryId\", syncFile.getTypePK());\n\n\t\tMoveFileEntryToTrashEvent moveFileEntryToTrashEvent =\n\t\t\tnew MoveFileEntryToTrashEvent(syncAccountId, parameters);\n\n\t\tmoveFileEntryToTrashEvent.run();\n\n\t\treturn syncFile;\n\t}","id":91685,"modified_method":"public static SyncFile deleteFileSyncFile(\n\t\t\tlong syncAccountId, SyncFile syncFile)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DELETED_LOCAL);\n\n\t\tdeleteSyncFile(syncFile);\n\n\t\t// Remote sync file\n\n\t\tMap<String, Object> parameters = new HashMap<String, Object>();\n\n\t\tparameters.put(\"fileEntryId\", syncFile.getTypePK());\n\n\t\tMoveFileEntryToTrashEvent moveFileEntryToTrashEvent =\n\t\t\tnew MoveFileEntryToTrashEvent(syncAccountId, parameters);\n\n\t\tmoveFileEntryToTrashEvent.run();\n\n\t\treturn syncFile;\n\t}","commit_id":"c92accda97ca1724390391ba2a7ae430c8ec0c86","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected Calendar getRecurrenceCal(\n\t\tCalendar cal, Calendar tzICal, CalEvent event) {\n\n\t\tCalendar eventCal = CalendarFactoryUtil.getCalendar();\n\t\teventCal.setTime(event.getStartDate());\n\n\t\tCalendar recurrenceCal = (Calendar)tzICal.clone();\n\t\trecurrenceCal.set(\n\t\t\tCalendar.HOUR_OF_DAY, eventCal.get(Calendar.HOUR_OF_DAY));\n\t\trecurrenceCal.set(\n\t\t\tCalendar.MINUTE, eventCal.get(Calendar.MINUTE));\n\t\trecurrenceCal.set(Calendar.SECOND, 0);\n\t\trecurrenceCal.set(Calendar.MILLISECOND, 0);\n\n\t\tif (event.isTimeZoneSensitive()) {\n\t\t\tint gmtDate = eventCal.get(Calendar.DATE);\n\t\t\tlong gmtMills = eventCal.getTimeInMillis();\n\n\t\t\teventCal.setTimeZone(cal.getTimeZone());\n\n\t\t\tint tziDate = eventCal.get(Calendar.DATE);\n\t\t\tlong tziMills = Time.getDate(eventCal).getTime();\n\n\t\t\tif (gmtDate != tziDate) {\n\t\t\t\tint diffDate = 0;\n\n\t\t\t\tif (gmtMills > tziMills) {\n\t\t\t\t\tdiffDate = (int)Math.ceil(\n\t\t\t\t\t\t(double)(gmtMills - tziMills) / Time.DAY);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdiffDate = (int)Math.floor(\n\t\t\t\t\t\t(double)(gmtMills - tziMills) / Time.DAY);\n\t\t\t\t}\n\n\t\t\t\trecurrenceCal.add(Calendar.DATE, diffDate);\n\t\t\t}\n\t\t}\n\n\t\treturn recurrenceCal;\n\t}","id":91686,"modified_method":"protected Calendar getRecurrenceCal(\n\t\tCalendar cal, Calendar tzICal, CalEvent event) {\n\n\t\tCalendar eventCal = CalendarFactoryUtil.getCalendar(\n\t\t\tTimeZoneUtil.getTimeZone(StringPool.UTC));\n\t\teventCal.setTime(event.getStartDate());\n\n\t\tCalendar recurrenceCal = (Calendar)tzICal.clone();\n\t\trecurrenceCal.set(\n\t\t\tCalendar.HOUR_OF_DAY, eventCal.get(Calendar.HOUR_OF_DAY));\n\t\trecurrenceCal.set(\n\t\t\tCalendar.MINUTE, eventCal.get(Calendar.MINUTE));\n\t\trecurrenceCal.set(Calendar.SECOND, 0);\n\t\trecurrenceCal.set(Calendar.MILLISECOND, 0);\n\n\t\tif (event.isTimeZoneSensitive()) {\n\t\t\tint gmtDate = eventCal.get(Calendar.DATE);\n\t\t\tlong gmtMills = eventCal.getTimeInMillis();\n\n\t\t\teventCal.setTimeZone(cal.getTimeZone());\n\n\t\t\tint tziDate = eventCal.get(Calendar.DATE);\n\t\t\tlong tziMills = Time.getDate(eventCal).getTime();\n\n\t\t\tif (gmtDate != tziDate) {\n\t\t\t\tint diffDate = 0;\n\n\t\t\t\tif (gmtMills > tziMills) {\n\t\t\t\t\tdiffDate = (int)Math.ceil(\n\t\t\t\t\t\t(double)(gmtMills - tziMills) / Time.DAY);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdiffDate = (int)Math.floor(\n\t\t\t\t\t\t(double)(gmtMills - tziMills) / Time.DAY);\n\t\t\t\t}\n\n\t\t\t\trecurrenceCal.add(Calendar.DATE, diffDate);\n\t\t\t}\n\t\t}\n\n\t\treturn recurrenceCal;\n\t}","commit_id":"aad7e504d9633ab851bd4aaa0d0dcb9d1e437ac6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<CalEvent> getRepeatingEvents(\n\t\t\tlong groupId, Calendar cal, String[] types)\n\t\tthrows SystemException {\n\n\t\tMap<String, List<CalEvent>> eventsPool =\n\t\t\tCalEventLocalUtil.getEventsPool(groupId);\n\n\t\tString key = \"recurrence\".concat(CalUtil.toString(null, types));\n\n\t\tList<CalEvent> events = eventsPool.get(key);\n\n\t\tif (events == null) {\n\t\t\tif (types != null) {\n\t\t\t\tevents = calEventPersistence.findByG_T_R(groupId, types, true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tevents = calEventPersistence.findByG_R(groupId, true);\n\t\t\t}\n\n\t\t\tevents = new UnmodifiableList<CalEvent>(events);\n\n\t\t\teventsPool.put(key, events);\n\t\t}\n\n\t\tif (cal != null) {\n\n\t\t\t// Time zone insensitive\n\n\t\t\tCalendar tzICal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tcal.get(Calendar.YEAR), cal.get(Calendar.MONTH),\n\t\t\t\tcal.get(Calendar.DATE));\n\n\t\t\tIterator<CalEvent> itr = events.iterator();\n\n\t\t\tList<CalEvent> repeatingEvents = new ArrayList<CalEvent>();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tCalEvent event = itr.next();\n\n\t\t\t\tTZSRecurrence recurrence = event.getRecurrenceObj();\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// LEP-3468\n\n\t\t\t\t\tif ((recurrence.getFrequency() !=\n\t\t\t\t\t\t\tRecurrence.NO_RECURRENCE) &&\n\t\t\t\t\t\t(recurrence.getInterval() <= 0)) {\n\n\t\t\t\t\t\trecurrence.setInterval(1);\n\n\t\t\t\t\t\tevent.setRecurrenceObj(recurrence);\n\n\t\t\t\t\t\tevent = calEventPersistence.update(event, false);\n\n\t\t\t\t\t\trecurrence = event.getRecurrenceObj();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (recurrence.isInRecurrence(\n\t\t\t\t\t\t\tgetRecurrenceCal(cal, tzICal, event))) {\n\n\t\t\t\t\t\trepeatingEvents.add(event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_log.error(e, e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tevents = new UnmodifiableList<CalEvent>(repeatingEvents);\n\t\t}\n\n\t\treturn events;\n\t}","id":91687,"modified_method":"public List<CalEvent> getRepeatingEvents(\n\t\t\tlong groupId, Calendar cal, String[] types)\n\t\tthrows SystemException {\n\n\t\tMap<String, List<CalEvent>> eventsPool =\n\t\t\tCalEventLocalUtil.getEventsPool(groupId);\n\n\t\tString key = \"recurrence\".concat(CalUtil.toString(null, types));\n\n\t\tList<CalEvent> events = eventsPool.get(key);\n\n\t\tif (events == null) {\n\t\t\tif (types != null) {\n\t\t\t\tevents = calEventPersistence.findByG_T_R(groupId, types, true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tevents = calEventPersistence.findByG_R(groupId, true);\n\t\t\t}\n\n\t\t\tevents = new UnmodifiableList<CalEvent>(events);\n\n\t\t\teventsPool.put(key, events);\n\t\t}\n\n\t\tif (cal != null) {\n\n\t\t\t// Time zone insensitive\n\n\t\t\tCalendar tzICal = CalendarFactoryUtil.getCalendar(\n\t\t\t\t\tTimeZoneUtil.getTimeZone(StringPool.UTC));\n\n\t\t\ttzICal.set(\n\t\t\t\tcal.get(Calendar.YEAR), cal.get(Calendar.MONTH),\n\t\t\t\tcal.get(Calendar.DATE));\n\n\t\t\tIterator<CalEvent> itr = events.iterator();\n\n\t\t\tList<CalEvent> repeatingEvents = new ArrayList<CalEvent>();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tCalEvent event = itr.next();\n\n\t\t\t\tTZSRecurrence recurrence = event.getRecurrenceObj();\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// LEP-3468\n\n\t\t\t\t\tif ((recurrence.getFrequency() !=\n\t\t\t\t\t\t\tRecurrence.NO_RECURRENCE) &&\n\t\t\t\t\t\t(recurrence.getInterval() <= 0)) {\n\n\t\t\t\t\t\trecurrence.setInterval(1);\n\n\t\t\t\t\t\tevent.setRecurrenceObj(recurrence);\n\n\t\t\t\t\t\tevent = calEventPersistence.update(event, false);\n\n\t\t\t\t\t\trecurrence = event.getRecurrenceObj();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (recurrence.isInRecurrence(\n\t\t\t\t\t\t\tgetRecurrenceCal(cal, tzICal, event))) {\n\n\t\t\t\t\t\trepeatingEvents.add(event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_log.error(e, e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tevents = new UnmodifiableList<CalEvent>(repeatingEvents);\n\t\t}\n\n\t\treturn events;\n\t}","commit_id":"aad7e504d9633ab851bd4aaa0d0dcb9d1e437ac6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void checkEvents() throws PortalException, SystemException {\n\t\tList<CalEvent> events = calEventFinder.findByFutureReminders();\n\n\t\tfor (CalEvent event : events) {\n\t\t\tUser user = userPersistence.fetchByPrimaryKey(event.getUserId());\n\n\t\t\tif (user == null) {\n\t\t\t\tdeleteEvent(event);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tCalendar now = CalendarFactoryUtil.getCalendar(\n\t\t\t\tuser.getTimeZone(), user.getLocale());\n\n\t\t\tif (!event.isTimeZoneSensitive()) {\n\t\t\t\tCalendar temp = CalendarFactoryUtil.getCalendar();\n\n\t\t\t\ttemp.setTime(Time.getDate(now));\n\n\t\t\t\tnow = temp;\n\t\t\t}\n\n\t\t\tCalendar startDate = null;\n\n\t\t\tif (event.isTimeZoneSensitive()) {\n\t\t\t\tstartDate = CalendarFactoryUtil.getCalendar(\n\t\t\t\t\tuser.getTimeZone(), user.getLocale());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstartDate = CalendarFactoryUtil.getCalendar();\n\t\t\t}\n\n\t\t\tif (event.isRepeating()) {\n\t\t\t\tdouble daysToCheck = Math.ceil(\n\t\t\t\t\tCalEventConstants.REMINDERS[\n\t\t\t\t\t\tCalEventConstants.REMINDERS.length - 1] /\n\t\t\t\t\tTime.DAY);\n\n\t\t\t\tCalendar cal = (Calendar)now.clone();\n\n\t\t\t\tfor (int i = 0; i <= daysToCheck; i++) {\n\t\t\t\t\tRecurrence recurrence = event.getRecurrenceObj();\n\n\t\t\t\t\tCalendar tzICal = CalendarFactoryUtil.getCalendar(\n\t\t\t\t\t\tcal.get(Calendar.YEAR), cal.get(Calendar.MONTH),\n\t\t\t\t\t\tcal.get(Calendar.DATE));\n\n\t\t\t\t\tCalendar recurrenceCal = getRecurrenceCal(\n\t\t\t\t\t\tcal, tzICal, event);\n\n\t\t\t\t\tif (recurrence.isInRecurrence(recurrenceCal)) {\n\t\t\t\t\t\tremindUser(event, user, recurrenceCal, now);\n\t\t\t\t\t}\n\n\t\t\t\t\tcal.add(Calendar.DAY_OF_YEAR, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstartDate.setTime(event.getStartDate());\n\n\t\t\t\tremindUser(event, user, startDate, now);\n\t\t\t}\n\t\t}\n\t}","id":91688,"modified_method":"public void checkEvents() throws PortalException, SystemException {\n\t\tList<CalEvent> events = calEventFinder.findByFutureReminders();\n\n\t\tfor (CalEvent event : events) {\n\t\t\tUser user = userPersistence.fetchByPrimaryKey(event.getUserId());\n\n\t\t\tif (user == null) {\n\t\t\t\tdeleteEvent(event);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tCalendar now = CalendarFactoryUtil.getCalendar(\n\t\t\t\tuser.getTimeZone(), user.getLocale());\n\n\t\t\tif (!event.isTimeZoneSensitive()) {\n\t\t\t\tCalendar temp = CalendarFactoryUtil.getCalendar();\n\n\t\t\t\ttemp.setTime(Time.getDate(now));\n\n\t\t\t\tnow = temp;\n\t\t\t}\n\n\t\t\tCalendar startDate = null;\n\n\t\t\tif (event.isTimeZoneSensitive()) {\n\t\t\t\tstartDate = CalendarFactoryUtil.getCalendar(\n\t\t\t\t\tuser.getTimeZone(), user.getLocale());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstartDate = CalendarFactoryUtil.getCalendar();\n\t\t\t}\n\n\t\t\tif (event.isRepeating()) {\n\t\t\t\tdouble daysToCheck = Math.ceil(\n\t\t\t\t\tCalEventConstants.REMINDERS[\n\t\t\t\t\t\tCalEventConstants.REMINDERS.length - 1] /\n\t\t\t\t\tTime.DAY);\n\n\t\t\t\tCalendar cal = (Calendar)now.clone();\n\n\t\t\t\tfor (int i = 0; i <= daysToCheck; i++) {\n\t\t\t\t\tRecurrence recurrence = event.getRecurrenceObj();\n\n\t\t\t\t\tCalendar tzICal = CalendarFactoryUtil.getCalendar(\n\t\t\t\t\t\t\tTimeZoneUtil.getTimeZone(StringPool.UTC));\n\n\t\t\t\t\ttzICal.set(\n\t\t\t\t\t\tcal.get(Calendar.YEAR), cal.get(Calendar.MONTH),\n\t\t\t\t\t\tcal.get(Calendar.DATE));\n\n\t\t\t\t\tCalendar recurrenceCal = getRecurrenceCal(\n\t\t\t\t\t\tcal, tzICal, event);\n\n\t\t\t\t\tif (recurrence.isInRecurrence(recurrenceCal)) {\n\t\t\t\t\t\tremindUser(event, user, recurrenceCal, now);\n\t\t\t\t\t}\n\n\t\t\t\t\tcal.add(Calendar.DAY_OF_YEAR, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstartDate.setTime(event.getStartDate());\n\n\t\t\t\tremindUser(event, user, startDate, now);\n\t\t\t}\n\t\t}\n\t}","commit_id":"aad7e504d9633ab851bd4aaa0d0dcb9d1e437ac6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<CalEvent> getEvents(long groupId, Calendar cal, String[] types)\n\t\tthrows SystemException {\n\n\t\tif (types != null) {\n\t\t\ttypes = ArrayUtil.distinct(types);\n\n\t\t\tArrays.sort(types);\n\t\t}\n\n\t\tMap<String, List<CalEvent>> eventsPool =\n\t\t\tCalEventLocalUtil.getEventsPool(groupId);\n\n\t\tString key = CalUtil.toString(cal, types);\n\n\t\tList<CalEvent> events = eventsPool.get(key);\n\n\t\tif (events == null) {\n\n\t\t\t// Time zone sensitive\n\n\t\t\tList<CalEvent> events1 = calEventFinder.findByG_SD_T(\n\t\t\t\tgroupId, CalendarUtil.getGTDate(cal),\n\t\t\t\tCalendarUtil.getLTDate(cal), true, types);\n\n\t\t\t// Time zone insensitive\n\n\t\t\tCalendar tzICal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tTimeZoneUtil.getDefault());\n\n\t\t\ttzICal.set(\n\t\t\t\tcal.get(Calendar.YEAR), cal.get(Calendar.MONTH),\n\t\t\t\tcal.get(Calendar.DATE));\n\n\t\t\tList<CalEvent> events2 = calEventFinder.findByG_SD_T(\n\t\t\t\tgroupId, CalendarUtil.getGTDate(tzICal),\n\t\t\t\tCalendarUtil.getLTDate(tzICal), false, types);\n\n\t\t\t// Create new list\n\n\t\t\tevents = new ArrayList<CalEvent>();\n\n\t\t\tevents.addAll(events1);\n\t\t\tevents.addAll(events2);\n\n\t\t\t// Add repeating events\n\n\t\t\tevents.addAll(getRepeatingEvents(groupId, cal, types));\n\n\t\t\tevents = new UnmodifiableList<CalEvent>(events);\n\n\t\t\teventsPool.put(key, events);\n\t\t}\n\n\t\treturn events;\n\t}","id":91689,"modified_method":"public List<CalEvent> getEvents(long groupId, Calendar cal, String[] types)\n\t\tthrows SystemException {\n\n\t\tif (types != null) {\n\t\t\ttypes = ArrayUtil.distinct(types);\n\n\t\t\tArrays.sort(types);\n\t\t}\n\n\t\tMap<String, List<CalEvent>> eventsPool =\n\t\t\tCalEventLocalUtil.getEventsPool(groupId);\n\n\t\tString key = CalUtil.toString(cal, types);\n\n\t\tList<CalEvent> events = eventsPool.get(key);\n\n\t\tif (events == null) {\n\n\t\t\t// Time zone sensitive\n\n\t\t\tList<CalEvent> events1 = calEventFinder.findByG_SD_T(\n\t\t\t\tgroupId, CalendarUtil.getGTDate(cal),\n\t\t\t\tCalendarUtil.getLTDate(cal), true, types);\n\n\t\t\t// Time zone insensitive\n\n\t\t\tCalendar tzICal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tTimeZoneUtil.getTimeZone(StringPool.UTC));\n\n\t\t\ttzICal.set(\n\t\t\t\tcal.get(Calendar.YEAR), cal.get(Calendar.MONTH),\n\t\t\t\tcal.get(Calendar.DATE));\n\n\t\t\tList<CalEvent> events2 = calEventFinder.findByG_SD_T(\n\t\t\t\tgroupId, CalendarUtil.getGTDate(tzICal),\n\t\t\t\tCalendarUtil.getLTDate(tzICal), false, types);\n\n\t\t\t// Create new list\n\n\t\t\tevents = new ArrayList<CalEvent>();\n\n\t\t\tevents.addAll(events1);\n\t\t\tevents.addAll(events2);\n\n\t\t\t// Add repeating events\n\n\t\t\tevents.addAll(getRepeatingEvents(groupId, cal, types));\n\n\t\t\tevents = new UnmodifiableList<CalEvent>(events);\n\n\t\t\teventsPool.put(key, events);\n\t\t}\n\n\t\treturn events;\n\t}","commit_id":"aad7e504d9633ab851bd4aaa0d0dcb9d1e437ac6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<CalEvent> getEvents(long groupId, Calendar cal, String[] types)\n\t\tthrows SystemException {\n\n\t\tif (types != null) {\n\t\t\ttypes = ArrayUtil.distinct(types);\n\n\t\t\tArrays.sort(types);\n\t\t}\n\n\t\tMap<String, List<CalEvent>> eventsPool =\n\t\t\tCalEventLocalUtil.getEventsPool(groupId);\n\n\t\tString key = CalUtil.toString(cal, types);\n\n\t\tList<CalEvent> events = eventsPool.get(key);\n\n\t\tif (events == null) {\n\n\t\t\t// Time zone sensitive\n\n\t\t\tList<CalEvent> events1 = calEventFinder.findByG_SD_T(\n\t\t\t\tgroupId, CalendarUtil.getGTDate(cal),\n\t\t\t\tCalendarUtil.getLTDate(cal), true, types);\n\n\t\t\t// Time zone insensitive\n\n\t\t\tCalendar tzICal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tcal.get(Calendar.YEAR), cal.get(Calendar.MONTH),\n\t\t\t\tcal.get(Calendar.DATE));\n\n\t\t\tList<CalEvent> events2 = calEventFinder.findByG_SD_T(\n\t\t\t\tgroupId, CalendarUtil.getGTDate(tzICal),\n\t\t\t\tCalendarUtil.getLTDate(tzICal), false, types);\n\n\t\t\t// Create new list\n\n\t\t\tevents = new ArrayList<CalEvent>();\n\n\t\t\tevents.addAll(events1);\n\t\t\tevents.addAll(events2);\n\n\t\t\t// Add repeating events\n\n\t\t\tevents.addAll(getRepeatingEvents(groupId, cal, types));\n\n\t\t\tevents = new UnmodifiableList<CalEvent>(events);\n\n\t\t\teventsPool.put(key, events);\n\t\t}\n\n\t\treturn events;\n\t}","id":91690,"modified_method":"public List<CalEvent> getEvents(long groupId, Calendar cal, String[] types)\n\t\tthrows SystemException {\n\n\t\tif (types != null) {\n\t\t\ttypes = ArrayUtil.distinct(types);\n\n\t\t\tArrays.sort(types);\n\t\t}\n\n\t\tMap<String, List<CalEvent>> eventsPool =\n\t\t\tCalEventLocalUtil.getEventsPool(groupId);\n\n\t\tString key = CalUtil.toString(cal, types);\n\n\t\tList<CalEvent> events = eventsPool.get(key);\n\n\t\tif (events == null) {\n\n\t\t\t// Time zone sensitive\n\n\t\t\tList<CalEvent> events1 = calEventFinder.findByG_SD_T(\n\t\t\t\tgroupId, CalendarUtil.getGTDate(cal),\n\t\t\t\tCalendarUtil.getLTDate(cal), true, types);\n\n\t\t\t// Time zone insensitive\n\n\t\t\tCalendar tzICal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tTimeZoneUtil.getDefault());\n\n\t\t\ttzICal.set(cal.get(Calendar.YEAR), cal.get(Calendar.MONTH),\n\t\t\t\tcal.get(Calendar.DATE));\n\n\t\t\tList<CalEvent> events2 = calEventFinder.findByG_SD_T(\n\t\t\t\tgroupId, CalendarUtil.getGTDate(tzICal),\n\t\t\t\tCalendarUtil.getLTDate(tzICal), false, types);\n\n\t\t\t// Create new list\n\n\t\t\tevents = new ArrayList<CalEvent>();\n\n\t\t\tevents.addAll(events1);\n\t\t\tevents.addAll(events2);\n\n\t\t\t// Add repeating events\n\n\t\t\tevents.addAll(getRepeatingEvents(groupId, cal, types));\n\n\t\t\tevents = new UnmodifiableList<CalEvent>(events);\n\n\t\t\teventsPool.put(key, events);\n\t\t}\n\n\t\treturn events;\n\t}","commit_id":"17e4a6f3c44c6fcdc25a65e539b36fb02806e0b0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doProcessCommand(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse)\n\t\tthrows Exception {\n\n\t\tlong workflowTaskId = ParamUtil.getLong(\n\t\t\tportletRequest, WorkflowTaskConstants.WORKFLOW_TASK_ID);\n\n\t\tlong assigneeUserId = ParamUtil.getLong(\n\t\t\tportletRequest, WorkflowTaskConstants.ASSIGNEE_USER_ID);\n\n\t\tString comment = ParamUtil.getString(\n\t\t\tportletRequest, WorkflowTaskConstants.COMMENT);\n\n\t\tWorkflowTaskManagerUtil.assignWorkflowTaskToUser(\n\t\t\tgetCompanyId(portletRequest), getUserId(portletRequest),\n\t\t\tworkflowTaskId, assigneeUserId, comment, null, null);\n\n\t\tsuper.doProcessCommand(portletRequest, portletResponse);\n\t}","id":91691,"modified_method":"@Override\n\tprotected void doProcessCommand(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong workflowTaskId = ParamUtil.getLong(\n\t\t\tportletRequest, \"workflowTaskId\");\n\n\t\tlong assigneeUserId = ParamUtil.getLong(\n\t\t\tportletRequest, \"assigneeUserId\");\n\t\tString comment = ParamUtil.getString(portletRequest, \"comment\");\n\n\t\tWorkflowTaskManagerUtil.assignWorkflowTaskToUser(\n\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\tworkflowTaskId, assigneeUserId, comment, null, null);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doProcessCommand(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse)\n\t\tthrows Exception {\n\n\t\tlong workflowTaskId = ParamUtil.getLong(\n\t\t\tportletRequest, WorkflowTaskConstants.WORKFLOW_TASK_ID);\n\n\t\tString transitionName = ParamUtil.getString(\n\t\t\tportletRequest, WorkflowTaskConstants.TRANSITION_NAME);\n\n\t\tString comment = ParamUtil.getString(\n\t\t\tportletRequest, WorkflowTaskConstants.COMMENT);\n\n\t\tWorkflowTaskManagerUtil.completeWorkflowTask(\n\t\t\tgetCompanyId(portletRequest), getUserId(portletRequest),\n\t\t\tworkflowTaskId, transitionName, comment, null);\n\n\t\tsuper.doProcessCommand(portletRequest, portletResponse);\n\t}","id":91692,"modified_method":"@Override\n\tprotected void doProcessCommand(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong workflowTaskId = ParamUtil.getLong(\n\t\t\tportletRequest, \"workflowTaskId\");\n\n\t\tString transitionName = ParamUtil.getString(\n\t\t\tportletRequest, \"transitionName\");\n\t\tString comment = ParamUtil.getString(portletRequest, \"comment\");\n\n\t\tWorkflowTaskManagerUtil.completeWorkflowTask(\n\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\tworkflowTaskId, transitionName, comment, null);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tsuper.processAction(actionRequest, actionResponse);\n\n\t\tString actionName = ParamUtil.getString(\n\t\t\tactionRequest, ActionRequest.ACTION_NAME);\n\n\t\tif (StringUtil.equalsIgnoreCase(\n\t\t\t\tactionName, WorkflowTaskConstants.DISCUSSION_ACTION)) {\n\n\t\t\thideDefaultSuccessMessage(actionRequest);\n\t\t}\n\t}","id":91693,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tsuper.processAction(actionRequest, actionResponse);\n\n\t\tString actionName = ParamUtil.getString(\n\t\t\tactionRequest, ActionRequest.ACTION_NAME);\n\n\t\tif (StringUtil.equalsIgnoreCase(actionName, \"invokeTaglibDiscussion\")) {\n\t\t\thideDefaultSuccessMessage(actionRequest);\n\t\t}\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void setWorkflowTaskRenderRequestAttribute(\n\t\t\tRenderRequest renderRequest)\n\t\tthrows PortalException {\n\n\t\tlong workflowTaskId = ParamUtil.getLong(\n\t\t\trenderRequest, WorkflowTaskConstants.WORKFLOW_TASK_ID);\n\n\t\tif (workflowTaskId > 0) {\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)renderRequest.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tWorkflowTask workflowTask = WorkflowTaskManagerUtil.getWorkflowTask(\n\t\t\t\tthemeDisplay.getCompanyId(), workflowTaskId);\n\n\t\t\trenderRequest.setAttribute(WebKeys.WORKFLOW_TASK, workflowTask);\n\t\t}\n\t}","id":91694,"modified_method":"protected void setWorkflowTaskRenderRequestAttribute(\n\t\t\tRenderRequest renderRequest)\n\t\tthrows PortalException {\n\n\t\tlong workflowTaskId = ParamUtil.getLong(\n\t\t\trenderRequest, \"workflowTaskId\");\n\n\t\tif (workflowTaskId > 0) {\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)renderRequest.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tWorkflowTask workflowTask = WorkflowTaskManagerUtil.getWorkflowTask(\n\t\t\t\tthemeDisplay.getCompanyId(), workflowTaskId);\n\n\t\t\trenderRequest.setAttribute(WebKeys.WORKFLOW_TASK, workflowTask);\n\t\t}\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doProcessCommand(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse)\n\t\tthrows Exception {\n\n\t\tlong workflowTaskId = ParamUtil.getLong(\n\t\t\tportletRequest, WorkflowTaskConstants.WORKFLOW_TASK_ID);\n\n\t\tString comment = ParamUtil.getString(\n\t\t\tportletRequest, WorkflowTaskConstants.COMMENT);\n\n\t\tint dueDateMonth = ParamUtil.getInteger(\n\t\t\tportletRequest, WorkflowTaskConstants.DUE_DATE_MONTH);\n\n\t\tint dueDateDay = ParamUtil.getInteger(\n\t\t\tportletRequest, WorkflowTaskConstants.DUE_DATE_DAY);\n\n\t\tint dueDateYear = ParamUtil.getInteger(\n\t\t\tportletRequest, WorkflowTaskConstants.DUE_DATE_YEAR);\n\n\t\tint dueDateHour = ParamUtil.getInteger(\n\t\t\tportletRequest, WorkflowTaskConstants.DUE_DATE_HOUR);\n\n\t\tint dueDateMinute = ParamUtil.getInteger(\n\t\t\tportletRequest, WorkflowTaskConstants.DUE_DATE_MINUTE);\n\n\t\tint dueDateAmPm = ParamUtil.getInteger(\n\t\t\tportletRequest, WorkflowTaskConstants.DUE_DATE_AM_PM);\n\n\t\tif (dueDateAmPm == Calendar.PM) {\n\t\t\tdueDateHour += 12;\n\t\t}\n\n\t\tDate dueDate = PortalUtil.getDate(\n\t\t\tdueDateMonth, dueDateDay, dueDateYear, dueDateHour, dueDateMinute,\n\t\t\tWorkflowTaskDueDateException.class);\n\n\t\tWorkflowTaskManagerUtil.updateDueDate(\n\t\t\tgetCompanyId(portletRequest), getUserId(portletRequest),\n\t\t\tworkflowTaskId, comment, dueDate);\n\n\t\tsuper.doProcessCommand(portletRequest, portletResponse);\n\t}","id":91695,"modified_method":"@Override\n\tprotected void doProcessCommand(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong workflowTaskId = ParamUtil.getLong(\n\t\t\tportletRequest, \"workflowTaskId\");\n\n\t\tString comment = ParamUtil.getString(portletRequest, \"comment\");\n\n\t\tint dueDateMonth = ParamUtil.getInteger(portletRequest, \"dueDateMonth\");\n\t\tint dueDateDay = ParamUtil.getInteger(portletRequest, \"dueDateDay\");\n\t\tint dueDateYear = ParamUtil.getInteger(portletRequest, \"dueDateYear\");\n\t\tint dueDateHour = ParamUtil.getInteger(portletRequest, \"dueDateHour\");\n\t\tint dueDateMinute = ParamUtil.getInteger(\n\t\t\tportletRequest, \"dueDateMinute\");\n\t\tint dueDateAmPm = ParamUtil.getInteger(portletRequest, \"dueDateAmPm\");\n\n\t\tif (dueDateAmPm == Calendar.PM) {\n\t\t\tdueDateHour += 12;\n\t\t}\n\n\t\tDate dueDate = PortalUtil.getDate(\n\t\t\tdueDateMonth, dueDateDay, dueDateYear, dueDateHour, dueDateMinute,\n\t\t\tWorkflowTaskDueDateException.class);\n\n\t\tWorkflowTaskManagerUtil.updateDueDate(\n\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\tworkflowTaskId, comment, dueDate);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doProcessCommand(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse)\n\t\tthrows Exception {\n\n\t\tString redirect = ParamUtil.getString(\n\t\t\tportletRequest, WorkflowTaskConstants.REDIRECT);\n\n\t\tString closeRedirect = ParamUtil.getString(\n\t\t\tportletRequest, WorkflowTaskConstants.CLOSE_REDIRECT);\n\n\t\tif (Validator.isNotNull(closeRedirect)) {\n\t\t\tredirect = HttpUtil.setParameter(\n\t\t\t\tredirect, WorkflowTaskConstants.CLOSE_REDIRECT, closeRedirect);\n\n\t\t\tSessionMessages.add(\n\t\t\t\tportletRequest, PortalUtil.getPortletId(portletRequest) +\n\t\t\t\t\tSessionMessages.KEY_SUFFIX_CLOSE_REDIRECT, closeRedirect);\n\t\t}\n\n\t\tportletRequest.setAttribute(WebKeys.REDIRECT, redirect);\n\t}","id":91696,"modified_method":"protected abstract void doProcessCommand(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse)\n\t\tthrows Exception;","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PortletURL getPortletURL() {\n\t\treturn PortletURLUtil.getCurrent(_renderRequest, _renderResponse);\n\t}","id":91697,"modified_method":"public PortletURL getPortletURL() {\n\t\tPortletURL portletURL = _renderResponse.createRenderURL();\n\n\t\tportletURL.setParameter(\"tabs1\", getSelectedTab());\n\n\t\treturn portletURL;\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public WorkflowTask getWorkflowTask() {\n\t\tResultRow row = (ResultRow)_renderRequest.getAttribute(\n\t\t\tWebKeys.SEARCH_CONTAINER_RESULT_ROW);\n\n\t\tWorkflowTask workflowTask = null;\n\n\t\tif (Validator.isNotNull(row)) {\n\t\t\tworkflowTask = (WorkflowTask)row.getParameter(\n\t\t\t\tWorkflowTaskConstants.WORKFLOW_TASK);\n\t\t}\n\t\telse {\n\t\t\tworkflowTask = (WorkflowTask)_renderRequest.getAttribute(\n\t\t\t\tWebKeys.WORKFLOW_TASK);\n\t\t}\n\n\t\treturn workflowTask;\n\t}","id":91698,"modified_method":"public WorkflowTask getWorkflowTask() {\n\t\tResultRow row = (ResultRow)_renderRequest.getAttribute(\n\t\t\tWebKeys.SEARCH_CONTAINER_RESULT_ROW);\n\n\t\tif (Validator.isNotNull(row)) {\n\t\t\treturn (WorkflowTask)row.getParameter(\"workflowTask\");\n\t\t}\n\t\telse {\n\t\t\treturn (WorkflowTask)_renderRequest.getAttribute(\n\t\t\t\tWebKeys.WORKFLOW_TASK);\n\t\t}\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isCompletedTab() {\n\t\treturn WorkflowTaskConstants.COMPLETED.equals(getSelectedTab());\n\t}","id":91699,"modified_method":"public boolean isCompletedTabSelected() {\n\t\tString selectedTab = getSelectedTab();\n\n\t\tif (selectedTab.equals(\"completed\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean hasEditPortletURL(WorkflowTask workflowTask)\n\t\tthrows PortalException {\n\n\t\treturn Validator.isNotNull(getEditPortletURL(workflowTask));\n\t}","id":91700,"modified_method":"public boolean hasEditPortletURL(WorkflowTask workflowTask)\n\t\tthrows PortalException {\n\n\t\tPortletURL editPortletURL = getEditPortletURL(workflowTask);\n\n\t\tif (editPortletURL != null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public AssetRendererFactory getAssetRendererFactoryFromRequest() {\n\n\t\tString type = ParamUtil.getString(\n\t\t\t_workflowTaskRequestHelper.getRequest(), \"type\");\n\n\t\treturn AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByType(\n\t\t\ttype);\n\t}","id":91701,"modified_method":"public AssetRendererFactory getAssetRendererFactory() {\n\t\tString type = ParamUtil.getString(_renderRequest, \"type\");\n\n\t\treturn AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByType(\n\t\t\ttype);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getNameForAssignedToSingleUser(WorkflowTask workflowTask) {\n\t\treturn PortalUtil.getUserName(\n\t\t\tworkflowTask.getAssigneeUserId(), StringPool.BLANK);\n\t}","id":91702,"modified_method":"public String getWorkflowTaskAssigneeUserName(WorkflowTask workflowTask) {\n\t\treturn PortalUtil.getUserName(\n\t\t\tworkflowTask.getAssigneeUserId(), StringPool.BLANK);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getState(WorkflowTask workflowTask) throws PortalException {\n\t\tlong companyId = getWorkflowCompanyId(workflowTask);\n\t\tlong groupId = getWorkflowGroupId(workflowTask);\n\t\tString className = getWorkflowContextEntryClassName(workflowTask);\n\t\tlong classPK = getWorkflowContextEntryClassPK(workflowTask);\n\n\t\treturn LanguageUtil.get(\n\t\t\t_workflowTaskRequestHelper.getRequest(),\n\t\t\tHtmlUtil.escape(\n\t\t\t\tWorkflowInstanceLinkLocalServiceUtil.getState(\n\t\t\t\t\tcompanyId, groupId, className, classPK)));\n\t}","id":91703,"modified_method":"public String getState(WorkflowTask workflowTask) throws PortalException {\n\t\tlong companyId = getWorkflowCompanyId(workflowTask);\n\t\tlong groupId = getWorkflowGroupId(workflowTask);\n\t\tString className = getWorkflowContextEntryClassName(workflowTask);\n\t\tlong classPK = getWorkflowContextEntryClassPK(workflowTask);\n\n\t\tString state = WorkflowInstanceLinkLocalServiceUtil.getState(\n\t\t\tcompanyId, groupId, className, classPK);\n\n\t\treturn LanguageUtil.get(_workflowTaskRequestHelper.getRequest(), state);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getActorName(WorkflowLog workflowLog) throws PortalException {\n\t\tif (workflowLog.getRoleId() != 0) {\n\t\t\tif (!_roleMap.containsKey(workflowLog.getRoleId())) {\n\t\t\t\tRole curRole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tworkflowLog.getRoleId());\n\t\t\t\t_roleMap.put(workflowLog.getRoleId(), curRole);\n\t\t\t}\n\n\t\t\treturn _roleMap.get(workflowLog.getRoleId()).getDescriptiveName();\n\t\t}\n\t\telse if (workflowLog.getUserId() != 0) {\n\t\t\tif (!_userMap.containsKey(workflowLog.getUserId())) {\n\t\t\t\tUser curUser = UserLocalServiceUtil.getUser(\n\t\t\t\t\tworkflowLog.getUserId());\n\t\t\t\t_userMap.put(workflowLog.getUserId(), curUser);\n\t\t\t}\n\n\t\t\treturn _userMap.get(workflowLog.getUserId()).getFullName();\n\t\t}\n\n\t\treturn null;\n\t}","id":91704,"modified_method":"protected String getActorName(WorkflowLog workflowLog)\n\t\tthrows PortalException {\n\n\t\tif (workflowLog.getRoleId() != 0) {\n\t\t\tRole role = getRole(workflowLog.getRoleId());\n\n\t\t\treturn role.getDescriptiveName();\n\t\t}\n\t\telse if (workflowLog.getUserId() != 0) {\n\t\t\tUser user = getUser(workflowLog.getUserId());\n\n\t\t\treturn user.getFullName();\n\t\t}\n\n\t\treturn StringPool.BLANK;\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getTaglibEditURL(WorkflowTask workflowTask)\n\t\tthrows PortalException, PortletException {\n\n\t\tPortletURL editPortletURL = getEditPortletURL(workflowTask);\n\n\t\teditPortletURL.setWindowState(LiferayWindowState.POP_UP);\n\t\teditPortletURL.setPortletMode(PortletMode.VIEW);\n\n\t\tString editPortletURLString = editPortletURL.toString();\n\n\t\tAssetRenderer assetRenderer = getAssetRenderer(workflowTask);\n\n\t\teditPortletURLString = HttpUtil.addParameter(\n\t\t\teditPortletURLString, WorkflowTaskConstants.DO_AS_GROUP_ID,\n\t\t\tassetRenderer.getGroupId());\n\n\t\teditPortletURLString = HttpUtil.addParameter(\n\t\t\teditPortletURLString, WorkflowTaskConstants.REFERER_PLID,\n\t\t\t_workflowTaskRequestHelper.getThemeDisplay().getPlid());\n\n\t\treturn \"javascript:Liferay.Util.openWindow({id: '\" +\n\t\t\t_renderResponse.getNamespace() +\n\t\t\t\"editAsset', title: '\" +\n\t\t\tHtmlUtil.escapeJS(\n\t\t\t\tLanguageUtil.format(\n\t\t\t\t\t_workflowTaskRequestHelper.getRequest(),\n\t\t\t\t\tWorkflowTaskConstants.EDIT_X,\n\t\t\t\t\tHtmlUtil.escape(\n\t\t\t\t\t\tassetRenderer.getTitle(\n\t\t\t\t\t\t\t_workflowTaskRequestHelper.getLocale())),\n\t\t\t\t\t\t\tfalse)) + \"', uri:'\" +\n\t\t\t\t\t\t\tHtmlUtil.escapeJS(editPortletURLString) + \"'});\";\n\t}","id":91705,"modified_method":"public String getTaglibEditURL(WorkflowTask workflowTask)\n\t\tthrows PortalException, PortletException {\n\n\t\tStringBundler sb = new StringBundler(7);\n\n\t\tsb.append(\"javascript:Liferay.Util.openWindow({id: '\");\n\t\tsb.append(_renderResponse.getNamespace());\n\t\tsb.append(\"editAsset', title: '\");\n\n\t\tAssetRenderer assetRenderer = getAssetRenderer(workflowTask);\n\n\t\tString assetTitle = HtmlUtil.escape(\n\t\t\tassetRenderer.getTitle(_workflowTaskRequestHelper.getLocale()));\n\n\t\tsb.append(\n\t\t\tLanguageUtil.format(\n\t\t\t\t_workflowTaskRequestHelper.getRequest(), \"edit-x\", assetTitle));\n\t\tsb.append(\"', uri:'\");\n\n\t\tPortletURL editPortletURL = getEditPortletURL(workflowTask);\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t_workflowTaskRequestHelper.getThemeDisplay();\n\n\t\teditPortletURL.setParameter(\n\t\t\t\"doAsGroupId\", String.valueOf(assetRenderer.getGroupId()));\n\t\teditPortletURL.setParameter(\n\t\t\t\"refererPlid\", String.valueOf(themeDisplay.getPlid()));\n\n\t\teditPortletURL.setPortletMode(PortletMode.VIEW);\n\t\teditPortletURL.setWindowState(LiferayWindowState.POP_UP);\n\n\t\tsb.append(HtmlUtil.escapeJS(editPortletURL.toString()));\n\t\tsb.append(\"'});\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<WorkflowHandler<?>> getWorkflowHandlersOfSearchableAssets() {\n\t\tList<WorkflowHandler<?>> workflowHandlersOfSearchableAssets =\n\t\t\tnew ArrayList<>();\n\n\t\tList<WorkflowHandler<?>> workflowHandlers =\n\t\t\tWorkflowHandlerRegistryUtil.getWorkflowHandlers();\n\n\t\tfor (WorkflowHandler<?> workflowHandler : workflowHandlers) {\n\t\t\tif (workflowHandler.isAssetTypeSearchable()) {\n\t\t\t\tworkflowHandlersOfSearchableAssets.add(workflowHandler);\n\t\t\t}\n\t\t}\n\n\t\treturn workflowHandlersOfSearchableAssets;\n\t}","id":91706,"modified_method":"public List<WorkflowHandler<?>> getSearchableAssetsWorkflowHandlers() {\n\t\tList<WorkflowHandler<?>> searchableAssetsWorkflowHandlers =\n\t\t\tnew ArrayList<>();\n\n\t\tList<WorkflowHandler<?>> workflowHandlers =\n\t\t\tWorkflowHandlerRegistryUtil.getWorkflowHandlers();\n\n\t\tfor (WorkflowHandler<?> workflowHandler : workflowHandlers) {\n\t\t\tif (workflowHandler.isAssetTypeSearchable()) {\n\t\t\t\tsearchableAssetsWorkflowHandlers.add(workflowHandler);\n\t\t\t}\n\t\t}\n\n\t\treturn searchableAssetsWorkflowHandlers;\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected WorkflowTaskSearch searchTasksAssignedToMe(boolean completedTasks)\n\t\tthrows PortalException {\n\n\t\tint total = 0;\n\t\tList<WorkflowTask> results = null;\n\n\t\tString curParam = SearchContainer.DEFAULT_CUR_PARAM;\n\n\t\tif (!completedTasks) {\n\t\t\tcurParam = WorkflowTaskConstants.DEFAULT_CUR_PARAM1;\n\t\t}\n\n\t\tString[] assetTypes = WorkflowHandlerUtil.getSearchableAssetTypes();\n\n\t\tWorkflowTaskSearch searchContainer = new WorkflowTaskSearch(\n\t\t\t_renderRequest, curParam, getPortletURL());\n\n\t\tWorkflowTaskDisplayTerms searchTerms =\n\t\t\t(WorkflowTaskDisplayTerms)searchContainer.getDisplayTerms();\n\n\t\tif (searchTerms.isAdvancedSearch()) {\n\t\t\ttotal = WorkflowTaskManagerUtil.searchCount(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(), searchTerms.getName(),\n\t\t\t\tsearchTerms.getType(), null, null, null, false, false,\n\t\t\t\tsearchTerms.isAndOperator());\n\n\t\t\tsearchContainer.setTotal(total);\n\n\t\t\tresults = WorkflowTaskManagerUtil.search(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(), searchTerms.getName(),\n\t\t\t\tsearchTerms.getType(), null, null, null, completedTasks, false,\n\t\t\t\tsearchTerms.isAndOperator(), searchContainer.getStart(),\n\t\t\t\tsearchContainer.getEnd(),\n\t\t\t\tsearchContainer.getOrderByComparator());\n\t\t}\n\t\telse {\n\t\t\ttotal = WorkflowTaskManagerUtil.searchCount(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(),\n\t\t\t\tsearchTerms.getKeywords(), assetTypes, completedTasks, false);\n\n\t\t\tsearchContainer.setTotal(total);\n\n\t\t\tresults = WorkflowTaskManagerUtil.search(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(),\n\t\t\t\tsearchTerms.getKeywords(), assetTypes, completedTasks, false,\n\t\t\t\tsearchContainer.getStart(), searchContainer.getEnd(),\n\t\t\t\tsearchContainer.getOrderByComparator());\n\t\t}\n\n\t\tsearchContainer.setTotal(total);\n\t\tsearchContainer.setResults(results);\n\n\t\tvalidateSearchTerms(searchContainer);\n\n\t\tif (completedTasks) {\n\t\t\tsearchContainer.setEmptyResultsMessage(\n\t\t\t\tWorkflowTaskConstants.THERE_ARE_NO_COMPLETED_TASKS);\n\t\t}\n\t\telse {\n\t\t\tsearchContainer.setEmptyResultsMessage(\n\t\tWorkflowTaskConstants.THERE_ARE_NO_PENDING_TASKS_ASSIGNED_TO_YOU);\n\t\t}\n\n\t\treturn searchContainer;\n\t}","id":91707,"modified_method":"protected WorkflowTaskSearch searchTasksAssignedToMe(boolean completedTasks)\n\t\tthrows PortalException {\n\n\t\tint total = 0;\n\t\tList<WorkflowTask> results = null;\n\n\t\tString curParam = SearchContainer.DEFAULT_CUR_PARAM;\n\n\t\tif (!completedTasks) {\n\t\t\tcurParam = \"cur1\";\n\t\t}\n\n\t\tString[] assetTypes = WorkflowHandlerUtil.getSearchableAssetTypes();\n\n\t\tWorkflowTaskSearch searchContainer = new WorkflowTaskSearch(\n\t\t\t_renderRequest, curParam, getPortletURL());\n\n\t\tWorkflowTaskDisplayTerms searchTerms =\n\t\t\t(WorkflowTaskDisplayTerms)searchContainer.getDisplayTerms();\n\n\t\tif (searchTerms.isAdvancedSearch()) {\n\t\t\ttotal = WorkflowTaskManagerUtil.searchCount(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(), searchTerms.getName(),\n\t\t\t\tsearchTerms.getType(), null, null, null, false, false,\n\t\t\t\tsearchTerms.isAndOperator());\n\n\t\t\tsearchContainer.setTotal(total);\n\n\t\t\tresults = WorkflowTaskManagerUtil.search(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(), searchTerms.getName(),\n\t\t\t\tsearchTerms.getType(), null, null, null, completedTasks, false,\n\t\t\t\tsearchTerms.isAndOperator(), searchContainer.getStart(),\n\t\t\t\tsearchContainer.getEnd(),\n\t\t\t\tsearchContainer.getOrderByComparator());\n\t\t}\n\t\telse {\n\t\t\ttotal = WorkflowTaskManagerUtil.searchCount(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(),\n\t\t\t\tsearchTerms.getKeywords(), assetTypes, completedTasks, false);\n\n\t\t\tsearchContainer.setTotal(total);\n\n\t\t\tresults = WorkflowTaskManagerUtil.search(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(),\n\t\t\t\tsearchTerms.getKeywords(), assetTypes, completedTasks, false,\n\t\t\t\tsearchContainer.getStart(), searchContainer.getEnd(),\n\t\t\t\tsearchContainer.getOrderByComparator());\n\t\t}\n\n\t\tsearchContainer.setTotal(total);\n\t\tsearchContainer.setResults(results);\n\n\t\tsetUserSearchContainerEmptyResultsMessage(\n\t\t\tsearchContainer, completedTasks);\n\n\t\treturn searchContainer;\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isPendingTab() {\n\t\treturn WorkflowTaskConstants.PENDING.equals(getSelectedTab());\n\t}","id":91708,"modified_method":"public boolean isPendingTabSelected() {\n\t\tString selectedTab = getSelectedTab();\n\n\t\tif (selectedTab.equals(\"pending\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getCurrentURL() {\n\t\treturn getPortletURL().toString();\n\t}","id":91709,"modified_method":"public String getCurrentURL() {\n\t\tPortletURL portletURL = PortletURLUtil.getCurrent(\n\t\t\t_renderRequest, _renderResponse);\n\n\t\treturn portletURL.toString();\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object getTaskInitiallyAssignedMessageArguments(\n\t\t\tWorkflowLog workflowLog)\n\t\tthrows PortalException {\n\n\t\tString actorName = getActorName(workflowLog);\n\t\treturn HtmlUtil.escape(actorName);\n\t}","id":91710,"modified_method":"public String getTaskInitiallyAssignedMessageArguments(\n\t\t\tWorkflowLog workflowLog)\n\t\tthrows PortalException {\n\n\t\tString actorName = getActorName(workflowLog);\n\n\t\treturn HtmlUtil.escape(actorName);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public WorkflowTaskDisplayContext(\n\t\tRenderRequest renderRequest, RenderResponse renderResponse) {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)renderRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tthis._dateFormatDateTime = FastDateFormatFactoryUtil.getDateTime(\n\t\t\tthemeDisplay.getLocale(), themeDisplay.getTimeZone());\n\n\t\tthis._renderResponse = renderResponse;\n\t\tthis._renderRequest = renderRequest;\n\n\t\tthis._workflowTaskRequestHelper = new WorkflowTaskRequestHelper(\n\t\t\trenderRequest);\n\n\t\tthis._roleMap = new HashMap<>();\n\t\tthis._userMap = new HashMap<>();\n\t}","id":91711,"modified_method":"public WorkflowTaskDisplayContext(\n\t\tRenderRequest renderRequest, RenderResponse renderResponse) {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)renderRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t_dateFormatDateTime = FastDateFormatFactoryUtil.getDateTime(\n\t\t\tthemeDisplay.getLocale(), themeDisplay.getTimeZone());\n\n\t\t_renderRequest = renderRequest;\n\t\t_renderResponse = renderResponse;\n\n\t\t_workflowTaskRequestHelper = new WorkflowTaskRequestHelper(\n\t\t\trenderRequest);\n\n\t\t_roleMap = new HashMap<>();\n\t\t_userMap = new HashMap<>();\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean hasViewDiffsPortletURL(WorkflowTask workflowTask)\n\t\tthrows PortalException {\n\n\t\treturn Validator.isNotNull(getURLViewDiffs(workflowTask));\n\t}","id":91712,"modified_method":"public boolean hasViewDiffsPortletURL(WorkflowTask workflowTask)\n\t\tthrows PortalException {\n\n\t\tPortletURL viewDiffsPortletURL = getViewDiffsPortletURL(workflowTask);\n\n\t\tif (viewDiffsPortletURL != null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getAssignedTheTaskMessageKey(WorkflowLog workflowLog)\n\t\tthrows PortalException {\n\n\t\tUser curUser = _userMap.get(workflowLog.getUserId());\n\t\treturn curUser.isMale() ?\n\t\t\tWorkflowTaskConstants.X_ASSIGNED_THE_TASK_TO_HIMSELF :\n\t\t\t\tWorkflowTaskConstants.X_ASSIGNED_THE_TASK_TO_HERSELF;\n\t}","id":91713,"modified_method":"public String getAssignedTheTaskMessageKey(WorkflowLog workflowLog)\n\t\tthrows PortalException {\n\n\t\tUser curUser = _userMap.get(workflowLog.getUserId());\n\n\t\tif (curUser.isMale()) {\n\t\t\treturn \"x-assigned-the-task-to-himself\";\n\t\t}\n\t\telse {\n\t\t\treturn \"x-assigned-the-task-to-herself\";\n\t\t}\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getWorkflowTaskRandomId() {\n\t\tString randomId = StringPool.BLANK;\n\n\t\tResultRow row = (ResultRow)_renderRequest.getAttribute(\n\t\t\tWebKeys.SEARCH_CONTAINER_RESULT_ROW);\n\n\t\tif (Validator.isNotNull(row)) {\n\t\t\trandomId = StringUtil.randomId();\n\t\t}\n\n\t\treturn randomId;\n\t}","id":91714,"modified_method":"public String getWorkflowTaskRandomId() {\n\t\tString randomId = StringPool.BLANK;\n\n\t\tResultRow row = (ResultRow)_renderRequest.getAttribute(\n\t\t\tWebKeys.SEARCH_CONTAINER_RESULT_ROW);\n\n\t\tif (row != null) {\n\t\t\trandomId = StringUtil.randomId();\n\t\t}\n\n\t\treturn randomId;\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String[] getMetadataFields() {\n\t\treturn new String[] {\n\t\t\tWorkflowTaskConstants.AUTHOR, WorkflowTaskConstants.CATEGORIES,\n\t\t\tWorkflowTaskConstants.TAGS\n\t\t};\n\t}","id":91715,"modified_method":"public String[] getMetadataFields() {\n\t\treturn new String[] {\"author\", \"categories\", \"tags\"};\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getPreviewOfTitle(WorkflowTask workflowTask)\n\t\tthrows PortalException {\n\n\t\tString className = getWorkflowContextEntryClassName(workflowTask);\n\n\t\treturn LanguageUtil.format(\n\t\t\t_workflowTaskRequestHelper.getRequest(),\n\t\t\tWorkflowTaskConstants.PREVIEW_OF_X,\n\t\t\tResourceActionsUtil.getModelResource(\n\t\t\t\t_workflowTaskRequestHelper.getLocale(), className), false);\n\t}","id":91716,"modified_method":"public String getPreviewOfTitle(WorkflowTask workflowTask)\n\t\tthrows PortalException {\n\n\t\tString className = getWorkflowContextEntryClassName(workflowTask);\n\n\t\tString modelResource = ResourceActionsUtil.getModelResource(\n\t\t\t_workflowTaskRequestHelper.getLocale(), className);\n\n\t\treturn LanguageUtil.format(\n\t\t\t_workflowTaskRequestHelper.getRequest(), \"preview-of-x\",\n\t\t\tmodelResource, false);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getLastActivityDate(WorkflowTask workflowTask)\n\t\tthrows PortalException {\n\n\t\tWorkflowLog workflowLog = getWorkflowLog(workflowTask);\n\n\t\tif (workflowLog == null) {\n\t\t\treturn LanguageUtil.get(\n\t\t\t\t_workflowTaskRequestHelper.getRequest(),\n\t\t\t\tWorkflowTaskConstants.NEVER);\n\t\t}\n\t\telse {\n\t\t\treturn _dateFormatDateTime.format(workflowLog.getCreateDate());\n\t\t}\n\t}","id":91717,"modified_method":"public String getLastActivityDate(WorkflowTask workflowTask)\n\t\tthrows PortalException {\n\n\t\tWorkflowLog workflowLog = getWorkflowLog(workflowTask);\n\n\t\tif (workflowLog == null) {\n\t\t\treturn LanguageUtil.get(\n\t\t\t\t_workflowTaskRequestHelper.getRequest(), \"never\");\n\t\t}\n\t\telse {\n\t\t\treturn _dateFormatDateTime.format(workflowLog.getCreateDate());\n\t\t}\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public WorkflowTaskSearch getPendingTasksAssignedToMyRoles()\n\t\tthrows PortalException {\n\n\t\tint total = 0;\n\t\tList<WorkflowTask> results = null;\n\n\t\tString[] assetTypes = WorkflowHandlerUtil.getSearchableAssetTypes();\n\n\t\tWorkflowTaskSearch searchContainer = new WorkflowTaskSearch(\n\t\t\t_renderRequest, WorkflowTaskConstants.DEFAULT_CUR_PARAM2,\n\t\t\tgetPortletURL());\n\n\t\tWorkflowTaskDisplayTerms searchTerms =\n\t\t\t(WorkflowTaskDisplayTerms)searchContainer.getDisplayTerms();\n\n\t\tif (searchTerms.isAdvancedSearch()) {\n\t\t\ttotal = WorkflowTaskManagerUtil.searchCount(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(), searchTerms.getName(),\n\t\t\t\tsearchTerms.getType(), null, null, null, false, true,\n\t\t\t\tsearchTerms.isAndOperator());\n\n\t\t\tsearchContainer.setTotal(total);\n\n\t\t\tresults = WorkflowTaskManagerUtil.search(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(), searchTerms.getName(),\n\t\t\t\tsearchTerms.getType(), null, null, null, false, true,\n\t\t\t\tsearchTerms.isAndOperator(), searchContainer.getStart(),\n\t\t\t\tsearchContainer.getEnd(),\n\t\t\t\tsearchContainer.getOrderByComparator());\n\t\t}\n\t\telse {\n\t\t\ttotal = WorkflowTaskManagerUtil.searchCount(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(),\n\t\t\t\tsearchTerms.getKeywords(), assetTypes, false, true);\n\n\t\t\tsearchContainer.setTotal(total);\n\n\t\t\tresults = WorkflowTaskManagerUtil.search(\n\t\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t\t_workflowTaskRequestHelper.getUserId(),\n\t\t\t\tsearchTerms.getKeywords(), assetTypes, false, true,\n\t\t\t\tsearchContainer.getStart(), searchContainer.getEnd(),\n\t\t\t\tsearchContainer.getOrderByComparator());\n\t\t}\n\n\t\tsearchContainer.setTotal(total);\n\t\tsearchContainer.setResults(results);\n\n\t\tvalidateSearchTerms(searchContainer);\n\n\t\tsearchContainer.setEmptyResultsMessage(\n\tWorkflowTaskConstants.THERE_ARE_NO_PENDING_TASKS_ASSIGNED_TO_YOUR_ROLES);\n\n\t\treturn searchContainer;\n\t}","id":91718,"modified_method":"public WorkflowTaskSearch getPendingTasksAssignedToMyRoles()\n\t\tthrows PortalException {\n\n\t\tint total = 0;\n\n\t\tList<WorkflowTask> results = null;\n\n\t\tString[] assetTypes = WorkflowHandlerUtil.getSearchableAssetTypes();\n\n\t\tWorkflowTaskSearch searchContainer = new WorkflowTaskSearch(\n\t\t\t_renderRequest, \"cur2\", getPortletURL());\n\n\t\tWorkflowTaskDisplayTerms searchTerms =\n\t\t\t(WorkflowTaskDisplayTerms)searchContainer.getDisplayTerms();\n\n\t\tif (searchTerms.isAdvancedSearch()) {\n\t\t\ttotal = WorkflowTaskManagerUtil.searchCount(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(), searchTerms.getName(),\n\t\t\t\tsearchTerms.getType(), null, null, null, false, true,\n\t\t\t\tsearchTerms.isAndOperator());\n\n\t\t\tresults = WorkflowTaskManagerUtil.search(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(), searchTerms.getName(),\n\t\t\t\tsearchTerms.getType(), null, null, null, false, true,\n\t\t\t\tsearchTerms.isAndOperator(), searchContainer.getStart(),\n\t\t\t\tsearchContainer.getEnd(),\n\t\t\t\tsearchContainer.getOrderByComparator());\n\t\t}\n\t\telse {\n\t\t\ttotal = WorkflowTaskManagerUtil.searchCount(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(),\n\t\t\t\tsearchTerms.getKeywords(), assetTypes, false, true);\n\n\t\t\tresults = WorkflowTaskManagerUtil.search(\n\t\t\t\t_workflowTaskRequestHelper.getCompanyId(),\n\t\t\t\t_workflowTaskRequestHelper.getUserId(),\n\t\t\t\tsearchTerms.getKeywords(), assetTypes, false, true,\n\t\t\t\tsearchContainer.getStart(), searchContainer.getEnd(),\n\t\t\t\tsearchContainer.getOrderByComparator());\n\t\t}\n\n\t\tsearchContainer.setTotal(total);\n\t\tsearchContainer.setResults(results);\n\n\t\tsetRolesSearchContainerEmptyResultsMessage(searchContainer);\n\n\t\treturn searchContainer;\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getTaglibViewDiffsURL(WorkflowTask workflowTask)\n\t\tthrows PortalException, PortletException {\n\n\t\tPortletURL viewDiffsPortletURL = getURLViewDiffs(workflowTask);\n\n\t\tviewDiffsPortletURL.setParameter(\n\t\t\tWorkflowTaskConstants.REDIRECT, getCurrentURL());\n\t\tviewDiffsPortletURL.setParameter(\n\t\t\tWorkflowTaskConstants.HIDE_CONTROLS, Boolean.TRUE.toString());\n\t\tviewDiffsPortletURL.setWindowState(LiferayWindowState.POP_UP);\n\t\tviewDiffsPortletURL.setPortletMode(PortletMode.VIEW);\n\n\t\treturn \"javascript:Liferay.Util.openWindow({id: '\" +\n\t\t\t_renderResponse.getNamespace() + \"viewDiffs', title: '\" +\n\t\t\tHtmlUtil.escapeJS(\n\t\t\t\tLanguageUtil.get(\n\t\t\t\t\t_workflowTaskRequestHelper.getRequest(),\n\t\t\t\t\tWorkflowTaskConstants.DIFFS)) +\n\t\t\t\t\t\"', uri:'\" + HtmlUtil.escapeJS(\n\t\t\t\t\t\tviewDiffsPortletURL.toString()) + \"'});\";\n\t}","id":91719,"modified_method":"public String getTaglibViewDiffsURL(WorkflowTask workflowTask)\n\t\tthrows PortalException, PortletException {\n\n\t\tStringBundler sb = new StringBundler(7);\n\n\t\tsb.append(\"javascript:Liferay.Util.openWindow({id: '\");\n\t\tsb.append(_renderResponse.getNamespace());\n\t\tsb.append(\"viewDiffs', title: '\");\n\n\t\tString title = LanguageUtil.get(\n\t\t\t_workflowTaskRequestHelper.getRequest(), \"diffs\");\n\n\t\tsb.append(HtmlUtil.escapeJS(title));\n\t\tsb.append(\"', uri:'\");\n\n\t\tPortletURL viewDiffsPortletURL = getViewDiffsPortletURL(workflowTask);\n\n\t\tviewDiffsPortletURL.setParameter(\"redirect\", getCurrentURL());\n\t\tviewDiffsPortletURL.setParameter(\n\t\t\t\"hideControls\", Boolean.TRUE.toString());\n\t\tviewDiffsPortletURL.setWindowState(LiferayWindowState.POP_UP);\n\t\tviewDiffsPortletURL.setPortletMode(PortletMode.VIEW);\n\n\t\tsb.append(HtmlUtil.escapeJS(viewDiffsPortletURL.toString()));\n\t\tsb.append(\"'});\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public AssetRenderer getAssetRendererFromRequest() throws PortalException {\n\t\tlong assetEntryVersionId = ParamUtil.getLong(\n\t\t\t_workflowTaskRequestHelper.getRequest(), \"assetEntryVersionId\");\n\n\t\treturn getAssetRendererFactoryFromRequest().getAssetRenderer(\n\t\t\tassetEntryVersionId, AssetRendererFactory.TYPE_LATEST);\n\t}","id":91720,"modified_method":"public AssetRenderer getAssetRendererFromRequest() throws PortalException {\n\t\tlong assetEntryVersionId = ParamUtil.getLong(\n\t\t\t_workflowTaskRequestHelper.getRequest(), \"assetEntryVersionId\");\n\n\t\tAssetRendererFactory assetRendererFactory = getAssetRendererFactory();\n\n\t\treturn assetRendererFactory.getAssetRenderer(\n\t\t\tassetEntryVersionId, AssetRendererFactory.TYPE_LATEST);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PortletURL getURLViewDiffs(WorkflowTask workflowTask)\n\t\tthrows PortalException {\n\n\t\tWorkflowHandler<?> workflowHandler = getWorkflowHandler(workflowTask);\n\n\t\tlong classPK = getWorkflowContextEntryClassPK(workflowTask);\n\n\t\treturn workflowHandler.getURLViewDiffs(\n\t\t\tclassPK, (LiferayPortletRequest)_renderRequest,\n\t\t\t(LiferayPortletResponse)_renderResponse);\n\t}","id":91721,"modified_method":"public PortletURL getViewDiffsPortletURL(WorkflowTask workflowTask)\n\t\tthrows PortalException {\n\n\t\tWorkflowHandler<?> workflowHandler = getWorkflowHandler(workflowTask);\n\n\t\tlong classPK = getWorkflowContextEntryClassPK(workflowTask);\n\n\t\treturn workflowHandler.getURLViewDiffs(\n\t\t\tclassPK, (LiferayPortletRequest)_renderRequest,\n\t\t\t(LiferayPortletResponse)_renderResponse);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getSelectedTab() {\n\t\treturn ParamUtil.getString(\n\t\t\t_renderRequest, WorkflowTaskConstants.TABS1,\n\t\t\tWorkflowTaskConstants.PENDING);\n\t}","id":91722,"modified_method":"public String getSelectedTab() {\n\t\treturn ParamUtil.getString(_renderRequest, \"tabs1\", \"pending\");\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getDueDate(WorkflowTask workflowTask) {\n\t\tif (workflowTask.getDueDate() == null) {\n\t\t\treturn LanguageUtil.get(\n\t\t\t\t_workflowTaskRequestHelper.getRequest(),\n\t\t\t\tWorkflowTaskConstants.NEVER);\n\t\t}\n\t\telse {\n\t\t\treturn _dateFormatDateTime.format(workflowTask.getDueDate());\n\t\t}\n\t}","id":91723,"modified_method":"public String getDueDate(WorkflowTask workflowTask) {\n\t\tif (workflowTask.getDueDate() == null) {\n\t\t\treturn LanguageUtil.get(\n\t\t\t\t_workflowTaskRequestHelper.getRequest(), \"never\");\n\t\t}\n\t\telse {\n\t\t\treturn _dateFormatDateTime.format(workflowTask.getDueDate());\n\t\t}\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public AssetEntry getAssetEntryFromRequest() throws PortalException {\n\t\tlong assetEntryId = ParamUtil.getLong(\n\t\t\t_workflowTaskRequestHelper.getRequest(), \"assetEntryId\");\n\n\t\tAssetRendererFactory assetRendererFactory =\n\t\t\tgetAssetRendererFactoryFromRequest();\n\n\t\treturn assetRendererFactory.getAssetEntry(assetEntryId);\n\t}","id":91724,"modified_method":"public AssetEntry getAssetEntryFromRequest() throws PortalException {\n\t\tlong assetEntryId = ParamUtil.getLong(_renderRequest, \"assetEntryId\");\n\n\t\tAssetRendererFactory assetRendererFactory = getAssetRendererFactory();\n\n\t\treturn assetRendererFactory.getAssetEntry(assetEntryId);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getTransitionMessage(String transitionName) {\n\t\tString message = WorkflowTaskConstants.PROCEED;\n\n\t\tif (Validator.isNotNull(transitionName)) {\n\t\t\tmessage = HtmlUtil.escape(transitionName);\n\t\t}\n\n\t\treturn message;\n\t}","id":91725,"modified_method":"public String getTransitionMessage(String transitionName) {\n\t\tif (Validator.isNull(transitionName)) {\n\t\t\treturn \"proceed\";\n\t\t}\n\n\t\treturn HtmlUtil.escape(transitionName);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public WorkflowTaskDisplayTerms getDisplayTerms() {\n\t\treturn new WorkflowTaskDisplayTerms(_renderRequest);\n\t}","id":91726,"modified_method":"public WorkflowTaskDisplayTerms getWorkflowTaskDisplayTerms() {\n\t\treturn new WorkflowTaskDisplayTerms(_renderRequest);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object getPreviousAssigneeMessageArguments(WorkflowLog workflowLog) {\n\t\treturn HtmlUtil.escape(\n\t\t\tPortalUtil.getUserName(\n\t\t\t\tworkflowLog.getPreviousUserId(), StringPool.BLANK));\n\t}","id":91727,"modified_method":"public String getPreviousAssigneeMessageArguments(WorkflowLog workflowLog) {\n\t\tString userName = PortalUtil.getUserName(\n\t\t\tworkflowLog.getPreviousUserId(), StringPool.BLANK);\n\n\t\treturn HtmlUtil.escape(userName);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public WorkflowTaskDisplayTerms(PortletRequest portletRequest) {\n\t\tsuper(portletRequest);\n\n\t\tname = ParamUtil.getString(portletRequest, WorkflowTaskConstants.NAME);\n\t\ttype = ParamUtil.getString(portletRequest, WorkflowTaskConstants.TYPE);\n\t}","id":91728,"modified_method":"public WorkflowTaskDisplayTerms(PortletRequest portletRequest) {\n\t\tsuper(portletRequest);\n\n\t\tname = ParamUtil.getString(portletRequest, \"name\");\n\t\ttype = ParamUtil.getString(portletRequest, \"type\");\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public WorkflowTaskSearch(\n\t\tPortletRequest portletRequest, String curParam,\n\t\tPortletURL iteratorURL) {\n\n\t\tsuper(\n\t\t\tportletRequest, new WorkflowTaskDisplayTerms(portletRequest),\n\t\t\tnew WorkflowTaskDisplayTerms(portletRequest), curParam,\n\t\t\tDEFAULT_DELTA, iteratorURL, headerNames, null);\n\n\t\tWorkflowTaskDisplayTerms displayTerms =\n\t\t\t(WorkflowTaskDisplayTerms)getDisplayTerms();\n\n\t\titeratorURL.setParameter(\n\t\t\tWorkflowTaskConstants.NAME, displayTerms.getName());\n\t\titeratorURL.setParameter(\n\t\t\tWorkflowTaskConstants.TYPE, displayTerms.getType());\n\n\t\tString orderByCol = ParamUtil.getString(\n\t\t\tportletRequest, WorkflowTaskConstants.ORDER_BY_COL);\n\n\t\tString orderByType = ParamUtil.getString(\n\t\t\tportletRequest, WorkflowTaskConstants.ORDER_BY_TYPE);\n\n\t\tOrderByComparator<WorkflowTask> orderByComparator =\n\t\t\tgetOrderByComparator(orderByCol, orderByType);\n\n\t\tsetOrderableHeaders(orderableHeaders);\n\t\tsetOrderByCol(orderByCol);\n\t\tsetOrderByType(orderByType);\n\t\tsetOrderByComparator(orderByComparator);\n\t}","id":91729,"modified_method":"public WorkflowTaskSearch(\n\t\tPortletRequest portletRequest, String curParam,\n\t\tPortletURL iteratorURL) {\n\n\t\tsuper(\n\t\t\tportletRequest, new WorkflowTaskDisplayTerms(portletRequest),\n\t\t\tnew WorkflowTaskDisplayTerms(portletRequest), curParam,\n\t\t\tDEFAULT_DELTA, iteratorURL, headerNames, null);\n\n\t\tWorkflowTaskDisplayTerms displayTerms =\n\t\t\t(WorkflowTaskDisplayTerms)getDisplayTerms();\n\n\t\titeratorURL.setParameter(\"name\", displayTerms.getName());\n\t\titeratorURL.setParameter(\"type\", displayTerms.getType());\n\n\t\tString orderByCol = ParamUtil.getString(portletRequest, \"orderByCol\");\n\t\tString orderByType = ParamUtil.getString(portletRequest, \"orderByType\");\n\n\t\tOrderByComparator<WorkflowTask> orderByComparator =\n\t\t\tgetOrderByComparator(orderByCol, orderByType);\n\n\t\tsetOrderableHeaders(orderableHeaders);\n\t\tsetOrderByCol(orderByCol);\n\t\tsetOrderByType(orderByType);\n\t\tsetOrderByComparator(orderByComparator);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected OrderByComparator<WorkflowTask> getOrderByComparator(\n\t\tString orderByCol, String orderByType) {\n\n\t\tboolean orderByAsc = false;\n\n\t\tif (orderByType.equals(WorkflowTaskConstants.ASC)) {\n\t\t\torderByAsc = true;\n\t\t}\n\n\t\tOrderByComparator<WorkflowTask> orderByComparator = null;\n\n\t\tif (orderByCol.equals(WorkflowTaskConstants.NAME)) {\n\t\t\torderByComparator =\n\t\t\t\tWorkflowComparatorFactoryUtil.getTaskNameComparator(orderByAsc);\n\t\t}\n\t\telse {\n\t\t\torderByComparator =\n\t\t\t\tWorkflowComparatorFactoryUtil.getTaskDueDateComparator(\n\t\t\t\t\torderByAsc);\n\t\t}\n\n\t\treturn orderByComparator;\n\t}","id":91730,"modified_method":"protected OrderByComparator<WorkflowTask> getOrderByComparator(\n\t\tString orderByCol, String orderByType) {\n\n\t\tboolean orderByAsc = false;\n\n\t\tif (orderByType.equals(\"asc\")) {\n\t\t\torderByAsc = true;\n\t\t}\n\n\t\tOrderByComparator<WorkflowTask> orderByComparator = null;\n\n\t\tif (orderByCol.equals(\"name\")) {\n\t\t\torderByComparator =\n\t\t\t\tWorkflowComparatorFactoryUtil.getTaskNameComparator(orderByAsc);\n\t\t}\n\t\telse {\n\t\t\torderByComparator =\n\t\t\t\tWorkflowComparatorFactoryUtil.getTaskDueDateComparator(\n\t\t\t\t\torderByAsc);\n\t\t}\n\n\t\treturn orderByComparator;\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected String getBody(\n\t\t\tUserNotificationEvent userNotificationEvent,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\tuserNotificationEvent.getPayload());\n\n\t\tlong workflowTaskId = jsonObject.getLong(\n\t\t\tWorkflowTaskConstants.WORKFLOW_TASK_ID);\n\n\t\tWorkflowTask workflowTask = WorkflowTaskManagerUtil.fetchWorkflowTask(\n\t\t\tserviceContext.getCompanyId(), workflowTaskId);\n\n\t\tif (Validator.isNull(workflowTask)) {\n\t\t\tUserNotificationEventLocalServiceUtil.deleteUserNotificationEvent(\n\t\t\t\tuserNotificationEvent.getUserNotificationEventId());\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn HtmlUtil.escape(\n\t\t\tjsonObject.getString(WorkflowTaskConstants.NOTIFICATION_MESSAGE));\n\t}","id":91731,"modified_method":"@Override\n\tprotected String getBody(\n\t\t\tUserNotificationEvent userNotificationEvent,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\tuserNotificationEvent.getPayload());\n\n\t\tlong workflowTaskId = jsonObject.getLong(\"workflowTaskId\");\n\n\t\tWorkflowTask workflowTask = WorkflowTaskManagerUtil.fetchWorkflowTask(\n\t\t\tserviceContext.getCompanyId(), workflowTaskId);\n\n\t\tif (workflowTask == null) {\n\t\t\tUserNotificationEventLocalServiceUtil.deleteUserNotificationEvent(\n\t\t\t\tuserNotificationEvent.getUserNotificationEventId());\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn HtmlUtil.escape(jsonObject.getString(\"notificationMessage\"));\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected String getLink(\n\t\t\tUserNotificationEvent userNotificationEvent,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\tuserNotificationEvent.getPayload());\n\n\t\tString entryClassName = jsonObject.getString(\n\t\t\tWorkflowTaskConstants.ENTRY_CLASS_NAME);\n\n\t\tWorkflowHandler<?> workflowHandler =\n\t\t\tWorkflowHandlerRegistryUtil.getWorkflowHandler(entryClassName);\n\n\t\tif (Validator.isNull(workflowHandler)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlong workflowTaskId = jsonObject.getLong(\n\t\t\tWorkflowTaskConstants.WORKFLOW_TASK_ID);\n\n\t\treturn workflowHandler.getURLEditWorkflowTask(\n\t\t\tworkflowTaskId, serviceContext);\n\t}","id":91732,"modified_method":"@Override\n\tprotected String getLink(\n\t\t\tUserNotificationEvent userNotificationEvent,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\tuserNotificationEvent.getPayload());\n\n\t\tString entryClassName = jsonObject.getString(\"entryClassName\");\n\n\t\tWorkflowHandler<?> workflowHandler =\n\t\t\tWorkflowHandlerRegistryUtil.getWorkflowHandler(entryClassName);\n\n\t\tif (workflowHandler == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlong workflowTaskId = jsonObject.getLong(\"workflowTaskId\");\n\n\t\treturn workflowHandler.getURLEditWorkflowTask(\n\t\t\tworkflowTaskId, serviceContext);\n\t}","commit_id":"770acbb69ef1369cf6ba494f3c2d9cf9d9fff8f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getBaseAddress(Message m) {\n        try {\n            String endpointAddress = getEndpointAddress(m);\n            return new URL(endpointAddress).getPath();\n        } catch (MalformedURLException ex) {\n            return (String)m.get(Message.BASE_PATH);\n        }\n    }","id":91733,"modified_method":"public static String getBaseAddress(Message m) {\n        String endpointAddress = getEndpointAddress(m);\n        try {\n            return new URL(endpointAddress).getPath();\n        } catch (MalformedURLException ex) {\n            return endpointAddress == null ? \"/\" : endpointAddress;\n        }\n    }","commit_id":"d92b29548cb3de1b553c15255abd18b6b3f433b0","url":"https://github.com/apache/cxf"},{"original_method":"public static String getPathToMatch(Message m, boolean addSlash) {\n        String requestAddress = (String)m.get(Message.REQUEST_URI);\n        String baseAddress = getBaseAddress(m);\n        return getPathToMatch(requestAddress, baseAddress, addSlash);\n    }","id":91734,"modified_method":"public static String getPathToMatch(Message m, boolean addSlash) {\n        String requestAddress = getProtocolHeader(m, Message.REQUEST_URI, \"/\");\n        String baseAddress = getBaseAddress(m);\n        return getPathToMatch(requestAddress, baseAddress, addSlash);\n    }","commit_id":"d92b29548cb3de1b553c15255abd18b6b3f433b0","url":"https://github.com/apache/cxf"},{"original_method":"private void setMessageProperties(Message message, OperationResourceInfo ori, \n                                      MultivaluedMap<String, String> values,\n                                      int numberOfResources) {\n        message.getExchange().put(OperationResourceInfo.class, ori);\n        message.put(URITemplate.TEMPLATE_PARAMETERS, values);\n        \n        String plainOperationName = ori.getMethodToInvoke().getName();\n        if (numberOfResources > 1) {\n            plainOperationName = ori.getClassResourceInfo().getServiceClass().getSimpleName()\n                + \"#\" + plainOperationName;\n        }\n        message.getExchange().put(\"org.apache.cxf.resource.operation.name\", plainOperationName);    \n    }","id":91735,"modified_method":"private void setMessageProperties(Message message, OperationResourceInfo ori, \n                                      MultivaluedMap<String, String> values,\n                                      int numberOfResources) {\n        message.getExchange().put(OperationResourceInfo.class, ori);\n        message.put(URITemplate.TEMPLATE_PARAMETERS, values);\n        \n        String plainOperationName = ori.getMethodToInvoke().getName();\n        if (numberOfResources > 1) {\n            plainOperationName = ori.getClassResourceInfo().getServiceClass().getSimpleName()\n                + \"#\" + plainOperationName;\n        }\n        message.getExchange().put(\"org.apache.cxf.resource.operation.name\", plainOperationName);\n        \n        message.getExchange().setOneWay(\n            MessageUtils.isTrue(HttpUtils.getProtocolHeader(message, Message.ONE_WAY_MESSAGE, null)));\n    }","commit_id":"d92b29548cb3de1b553c15255abd18b6b3f433b0","url":"https://github.com/apache/cxf"},{"original_method":"private void processRequest(Message message) {\n        \n        if (message.getExchange().get(OperationResourceInfo.class) != null) {\n            // it's a suspended invocation;\n            return;\n        }\n        \n        RequestPreprocessor rp = ProviderFactory.getInstance(message).getRequestPreprocessor();\n        if (rp != null) {\n            rp.preprocess(message, new UriInfoImpl(message, null));\n            if (message.getExchange().get(Response.class) != null) {\n                return;\n            }\n        }\n        \n        String requestContentType = (String)message.get(Message.CONTENT_TYPE);\n        if (requestContentType == null) {\n            requestContentType = \"*/*\";\n        }\n        \n        String rawPath = HttpUtils.getPathToMatch(message, true);\n        \n        //1. Matching target resource class\n        Service service = message.getExchange().get(Service.class);\n        List<ClassResourceInfo> resources = ((JAXRSServiceImpl)service).getClassResourceInfos();\n\n        String acceptTypes = (String)message.get(Message.ACCEPT_CONTENT_TYPE);\n        if (acceptTypes == null) {\n            acceptTypes = \"*/*\";\n            message.put(Message.ACCEPT_CONTENT_TYPE, acceptTypes);\n        }\n        List<MediaType> acceptContentTypes = JAXRSUtils.sortMediaTypes(acceptTypes);\n        message.getExchange().put(Message.ACCEPT_CONTENT_TYPE, acceptContentTypes);\n\n        MultivaluedMap<String, String> values = new MetadataMap<String, String>();\n        ClassResourceInfo resource = JAXRSUtils.selectResourceClass(resources, \n                                          rawPath, \n                                          values,\n                                          message);\n        if (resource == null) {\n            org.apache.cxf.common.i18n.Message errorMsg = \n                new org.apache.cxf.common.i18n.Message(\"NO_ROOT_EXC\", \n                                                   BUNDLE, \n                                                   rawPath);\n            LOG.warning(errorMsg.toString());\n\n            throw new WebApplicationException(Response.Status.NOT_FOUND);\n        }\n\n        message.getExchange().put(JAXRSUtils.ROOT_RESOURCE_CLASS, resource);\n\n        String httpMethod = (String)message.get(Message.HTTP_REQUEST_METHOD);\n        OperationResourceInfo ori = null;     \n        \n        boolean operChecked = false;\n        List<ProviderInfo<RequestHandler>> shs = ProviderFactory.getInstance(message).getRequestHandlers();\n        for (ProviderInfo<RequestHandler> sh : shs) {\n            String newAcceptTypes = (String)message.get(Message.ACCEPT_CONTENT_TYPE);\n            if (!acceptTypes.equals(newAcceptTypes) || (ori == null && !operChecked)) {\n                acceptTypes = newAcceptTypes;\n                acceptContentTypes = JAXRSUtils.sortMediaTypes(newAcceptTypes);\n                message.getExchange().put(Message.ACCEPT_CONTENT_TYPE, acceptContentTypes);\n                if (ori != null) {\n                    values = new MetadataMap<String, String>();\n                    resource = JAXRSUtils.selectResourceClass(resources, \n                                                              rawPath, \n                                                              values,\n                                                              message);\n                }\n                try {                \n                    ori = JAXRSUtils.findTargetMethod(resource, \n                        message, httpMethod, values, \n                        requestContentType, acceptContentTypes, false);\n                    setMessageProperties(message, ori, values, resources.size());\n                } catch (WebApplicationException ex) {\n                    operChecked = true;\n                }\n                \n            }\n            InjectionUtils.injectContextFields(sh.getProvider(), sh, message);\n            InjectionUtils.injectContextFields(sh.getProvider(), sh, message);\n            Response response = sh.getProvider().handleRequest(message, resource);\n            if (response != null) {\n                message.getExchange().put(Response.class, response);\n                return;\n            }\n        }\n        \n        String newAcceptTypes = (String)message.get(Message.ACCEPT_CONTENT_TYPE);\n        if (!acceptTypes.equals(newAcceptTypes) || ori == null) {\n            acceptTypes = newAcceptTypes;\n            acceptContentTypes = JAXRSUtils.sortMediaTypes(acceptTypes);\n            message.getExchange().put(Message.ACCEPT_CONTENT_TYPE, acceptContentTypes);\n            if (ori != null) {\n                values = new MetadataMap<String, String>();\n                resource = JAXRSUtils.selectResourceClass(resources, \n                                                          rawPath, \n                                                          values,\n                                                          message);\n            }\n            try {                \n                ori = JAXRSUtils.findTargetMethod(resource, message, \n                                            httpMethod, values, requestContentType, acceptContentTypes, true);\n                setMessageProperties(message, ori, values, resources.size());\n            } catch (WebApplicationException ex) {\n                if (ex.getResponse() != null && ex.getResponse().getStatus() == 405 \n                    && \"OPTIONS\".equalsIgnoreCase(httpMethod)) {\n                    Response response = JAXRSUtils.createResponseBuilder(resource, 200, true).build();\n                    message.getExchange().put(Response.class, response);\n                    return;\n                } else {\n                    throw ex;\n                }\n            }\n        }\n\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.fine(\"Request path is: \" + rawPath);\n            LOG.fine(\"Request HTTP method is: \" + httpMethod);\n            LOG.fine(\"Request contentType is: \" + requestContentType);\n            LOG.fine(\"Accept contentType is: \" + acceptTypes);\n\n            LOG.fine(\"Found operation: \" + ori.getMethodToInvoke().getName());\n        }\n        setMessageProperties(message, ori, values, resources.size());  \n      \n        //Process parameters\n        List<Object> params = JAXRSUtils.processParameters(ori, values, message);\n        message.setContent(List.class, params);\n    }","id":91736,"modified_method":"private void processRequest(Message message) {\n        \n        if (message.getExchange().get(OperationResourceInfo.class) != null) {\n            // it's a suspended invocation;\n            return;\n        }\n        \n        RequestPreprocessor rp = ProviderFactory.getInstance(message).getRequestPreprocessor();\n        if (rp != null) {\n            rp.preprocess(message, new UriInfoImpl(message, null));\n            if (message.getExchange().get(Response.class) != null) {\n                return;\n            }\n        }\n        \n        String requestContentType = (String)message.get(Message.CONTENT_TYPE);\n        if (requestContentType == null) {\n            requestContentType = \"*/*\";\n        }\n        \n        String rawPath = HttpUtils.getPathToMatch(message, true);\n        \n        //1. Matching target resource class\n        Service service = message.getExchange().get(Service.class);\n        List<ClassResourceInfo> resources = ((JAXRSServiceImpl)service).getClassResourceInfos();\n\n        String acceptTypes = HttpUtils.getProtocolHeader(message, Message.ACCEPT_CONTENT_TYPE, null);\n        if (acceptTypes == null) {\n            acceptTypes = \"*/*\";\n            message.put(Message.ACCEPT_CONTENT_TYPE, acceptTypes);\n        }\n        List<MediaType> acceptContentTypes = JAXRSUtils.sortMediaTypes(acceptTypes);\n        message.getExchange().put(Message.ACCEPT_CONTENT_TYPE, acceptContentTypes);\n\n        MultivaluedMap<String, String> values = new MetadataMap<String, String>();\n        ClassResourceInfo resource = JAXRSUtils.selectResourceClass(resources, \n                                          rawPath, \n                                          values,\n                                          message);\n        if (resource == null) {\n            org.apache.cxf.common.i18n.Message errorMsg = \n                new org.apache.cxf.common.i18n.Message(\"NO_ROOT_EXC\", \n                                                   BUNDLE, \n                                                   rawPath);\n            LOG.warning(errorMsg.toString());\n\n            throw new WebApplicationException(Response.Status.NOT_FOUND);\n        }\n\n        message.getExchange().put(JAXRSUtils.ROOT_RESOURCE_CLASS, resource);\n\n        String httpMethod = HttpUtils.getProtocolHeader(message, Message.HTTP_REQUEST_METHOD, \"POST\");\n        OperationResourceInfo ori = null;     \n        \n        boolean operChecked = false;\n        List<ProviderInfo<RequestHandler>> shs = ProviderFactory.getInstance(message).getRequestHandlers();\n        for (ProviderInfo<RequestHandler> sh : shs) {\n            String newAcceptTypes = HttpUtils.getProtocolHeader(message, Message.ACCEPT_CONTENT_TYPE, \"*/*\");\n            if (!acceptTypes.equals(newAcceptTypes) || (ori == null && !operChecked)) {\n                acceptTypes = newAcceptTypes;\n                acceptContentTypes = JAXRSUtils.sortMediaTypes(newAcceptTypes);\n                message.getExchange().put(Message.ACCEPT_CONTENT_TYPE, acceptContentTypes);\n                if (ori != null) {\n                    values = new MetadataMap<String, String>();\n                    resource = JAXRSUtils.selectResourceClass(resources, \n                                                              rawPath, \n                                                              values,\n                                                              message);\n                }\n                try {                \n                    ori = JAXRSUtils.findTargetMethod(resource, \n                        message, httpMethod, values, \n                        requestContentType, acceptContentTypes, false);\n                    setMessageProperties(message, ori, values, resources.size());\n                } catch (WebApplicationException ex) {\n                    operChecked = true;\n                }\n                \n            }\n            InjectionUtils.injectContextFields(sh.getProvider(), sh, message);\n            InjectionUtils.injectContextFields(sh.getProvider(), sh, message);\n            Response response = sh.getProvider().handleRequest(message, resource);\n            if (response != null) {\n                message.getExchange().put(Response.class, response);\n                return;\n            }\n        }\n        \n        String newAcceptTypes = (String)message.get(Message.ACCEPT_CONTENT_TYPE);\n        if (!acceptTypes.equals(newAcceptTypes) || ori == null) {\n            acceptTypes = newAcceptTypes;\n            acceptContentTypes = JAXRSUtils.sortMediaTypes(acceptTypes);\n            message.getExchange().put(Message.ACCEPT_CONTENT_TYPE, acceptContentTypes);\n            if (ori != null) {\n                values = new MetadataMap<String, String>();\n                resource = JAXRSUtils.selectResourceClass(resources, \n                                                          rawPath, \n                                                          values,\n                                                          message);\n            }\n            try {                \n                ori = JAXRSUtils.findTargetMethod(resource, message, \n                                            httpMethod, values, requestContentType, acceptContentTypes, true);\n                setMessageProperties(message, ori, values, resources.size());\n            } catch (WebApplicationException ex) {\n                if (ex.getResponse() != null && ex.getResponse().getStatus() == 405 \n                    && \"OPTIONS\".equalsIgnoreCase(httpMethod)) {\n                    Response response = JAXRSUtils.createResponseBuilder(resource, 200, true).build();\n                    message.getExchange().put(Response.class, response);\n                    return;\n                } else {\n                    throw ex;\n                }\n            }\n        }\n\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.fine(\"Request path is: \" + rawPath);\n            LOG.fine(\"Request HTTP method is: \" + httpMethod);\n            LOG.fine(\"Request contentType is: \" + requestContentType);\n            LOG.fine(\"Accept contentType is: \" + acceptTypes);\n\n            LOG.fine(\"Found operation: \" + ori.getMethodToInvoke().getName());\n        }\n        setMessageProperties(message, ori, values, resources.size());  \n      \n        //Process parameters\n        List<Object> params = JAXRSUtils.processParameters(ori, values, message);\n        message.setContent(List.class, params);\n    }","commit_id":"d92b29548cb3de1b553c15255abd18b6b3f433b0","url":"https://github.com/apache/cxf"},{"original_method":"public static List<HighlightInfo> collectHighlighInfos(final PsiFile file, final Editor editor) {\n    List<HighlightInfo> result = new ArrayList<HighlightInfo>();\n    Document document = editor.getDocument();\n    GeneralHighlightingPass action1 = new GeneralHighlightingPass(file.getProject(), file, document, 0, file.getTextLength(), true);\n    action1.doCollectInformation(new MockProgressIndicator());\n    result.addAll(action1.getHighlights());\n\n    PostHighlightingPass action2 = new PostHighlightingPass(file.getProject(), file, editor, 0, file.getTextLength());\n    action2.doCollectInformation(new MockProgressIndicator());\n    result.addAll(action2.getHighlights());\n\n    LocalInspectionsPass inspectionsPass = new LocalInspectionsPass(file, document, 0, file.getTextLength());\n    inspectionsPass.doCollectInformation(new MockProgressIndicator());\n    result.addAll(inspectionsPass.getHighlights());\n    return result;\n  }","id":91737,"modified_method":"public static List<HighlightInfo> collectHighlighInfos(final PsiFile file, final Editor editor) {\n    List<HighlightInfo> result = new ArrayList<HighlightInfo>();\n    Document document = editor.getDocument();\n    GeneralHighlightingPass action1 = new GeneralHighlightingPass(file.getProject(), file, document, 0, file.getTextLength(), true);\n    action1.doCollectInformation(new MockProgressIndicator());\n    result.addAll(action1.getHighlights());\n\n    PostHighlightingPassFactory phpFactory = file.getProject().getComponent(PostHighlightingPassFactory.class);\n    if (phpFactory != null) {\n      PostHighlightingPass action2 = new PostHighlightingPass(file.getProject(), file, editor, 0, file.getTextLength());\n      action2.doCollectInformation(new MockProgressIndicator());\n      result.addAll(action2.getHighlights());\n    }\n\n    LocalInspectionsPass inspectionsPass = new LocalInspectionsPass(file, document, 0, file.getTextLength());\n    inspectionsPass.doCollectInformation(new MockProgressIndicator());\n    result.addAll(inspectionsPass.getHighlights());\n    return result;\n  }","commit_id":"08fd22aeb2db96373f51a4a39b7f5466fb88fcab","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Collection<HighlightInfo> checkHighlighting(final ExpectedHighlightingData data) {\n    PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n    ((PsiFileImpl)myFile).calcTreeElement(); //to load text\n\n    //to initialize caches\n    myPsiManager.getCacheManager().getFilesWithWord(\"XXX\", UsageSearchContext.IN_COMMENTS, GlobalSearchScope.allScope(myProject), true);\n    VirtualFileFilter javaFilesFilter = new VirtualFileFilter() {\n      public boolean accept(VirtualFile file) {\n        FileType fileType = FileTypeManager.getInstance().getFileTypeByFile(file);\n        return (fileType == StdFileTypes.JAVA || fileType == StdFileTypes.CLASS) && !file.getName().equals(\"package-info.java\");\n      }\n    };\n    getJavaFacade().setAssertOnFileLoadingFilter(javaFilesFilter); // check repository work\n\n    Collection<HighlightInfo> infos = doHighlighting();\n\n    getJavaFacade().setAssertOnFileLoadingFilter(VirtualFileFilter.NONE);\n\n    data.checkResult(infos, myEditor.getDocument().getText());\n\n    return infos;\n  }","id":91738,"modified_method":"protected Collection<HighlightInfo> checkHighlighting(final ExpectedHighlightingData data) {\n    PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n    ((PsiFileImpl)myFile).calcTreeElement(); //to load text\n\n    //to initialize caches\n    myPsiManager.getCacheManager().getFilesWithWord(\"XXX\", UsageSearchContext.IN_COMMENTS, GlobalSearchScope.allScope(myProject), true);\n    VirtualFileFilter javaFilesFilter = new VirtualFileFilter() {\n      public boolean accept(VirtualFile file) {\n        FileType fileType = FileTypeManager.getInstance().getFileTypeByFile(file);\n        return (fileType == StdFileTypes.JAVA || fileType == StdFileTypes.CLASS) && !file.getName().equals(\"package-info.java\");\n      }\n    };\n    final JavaPsiFacadeEx facade = getJavaFacade();\n    if (facade != null) {\n      facade.setAssertOnFileLoadingFilter(javaFilesFilter); // check repository work\n    }\n\n    Collection<HighlightInfo> infos = doHighlighting();\n\n    if (facade != null) {\n      facade.setAssertOnFileLoadingFilter(VirtualFileFilter.NONE);\n    }\n\n    data.checkResult(infos, myEditor.getDocument().getText());\n\n    return infos;\n  }","commit_id":"08fd22aeb2db96373f51a4a39b7f5466fb88fcab","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void runTool(final InspectionTool tool,\n                              final AnalysisScope scope,\n                              final GlobalInspectionContextImpl globalContext,\n                              final InspectionManagerEx inspectionManager) {\n    tool.initialize(globalContext);\n    ((RefManagerImpl)globalContext.getRefManager()).initializeAnnotators();\n    if (tool.isGraphNeeded()){\n      ((RefManagerImpl)tool.getRefManager()).findAllDeclarations();\n    }\n\n    tool.runInspection(scope, inspectionManager);\n\n    tool.queryExternalUsagesRequests(inspectionManager);\n\n    do {\n      ((GlobalJavaInspectionContextImpl)globalContext.getExtension(GlobalJavaInspectionContextImpl.CONTEXT)).processSearchRequests(globalContext);\n    } while (tool.queryExternalUsagesRequests(inspectionManager));\n  }","id":91739,"modified_method":"private static void runTool(final InspectionTool tool,\n                              final AnalysisScope scope,\n                              final GlobalInspectionContextImpl globalContext,\n                              final InspectionManagerEx inspectionManager) {\n    tool.initialize(globalContext);\n    ((RefManagerImpl)globalContext.getRefManager()).initializeAnnotators();\n    if (tool.isGraphNeeded()){\n      ((RefManagerImpl)tool.getRefManager()).findAllDeclarations();\n    }\n\n    tool.runInspection(scope, inspectionManager);\n\n    tool.queryExternalUsagesRequests(inspectionManager);\n\n    final GlobalJavaInspectionContextImpl javaInspectionContext =\n        (GlobalJavaInspectionContextImpl)globalContext.getExtension(GlobalJavaInspectionContextImpl.CONTEXT);\n    if (javaInspectionContext != null) {\n      do {\n        javaInspectionContext.processSearchRequests(globalContext);\n      } while (tool.queryExternalUsagesRequests(inspectionManager));\n    }\n  }","commit_id":"08fd22aeb2db96373f51a4a39b7f5466fb88fcab","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<HighlightInfo> runMainPasses(@NotNull PsiFile psiFile,\n                                           @NotNull Document document,\n                                           @NotNull final ProgressIndicator progress) {\n    GeneralHighlightingPass action1 = new GeneralHighlightingPass(myProject, psiFile, document, 0, psiFile.getTextLength(), true);\n    action1.doCollectInformation(progress);\n\n    List<HighlightInfo> result = new ArrayList<HighlightInfo>();\n    result.addAll(action1.getHighlights());\n\n    LocalInspectionsPass action3 = new LocalInspectionsPass(psiFile, document, 0,\n                                                            psiFile.getTextLength(), LocalInspectionsPass.EMPTY_PRIORITY_RANGE, true);\n    action3.doCollectInformation(progress);\n\n    result.addAll(action3.getInfos());\n\n    return result;\n  }","id":91740,"modified_method":"public List<HighlightInfo> runMainPasses(@NotNull PsiFile psiFile,\n                                           @NotNull Document document,\n                                           @NotNull final ProgressIndicator progress) {\n    GeneralHighlightingPass action1 = new GeneralHighlightingPass(myProject, psiFile, document, 0, psiFile.getTextLength(), true);\n    action1.doCollectInformation(progress);\n\n    List<HighlightInfo> result = new ArrayList<HighlightInfo>();\n    result.addAll(action1.getHighlights());\n\n    final VirtualFile virtualFile = psiFile.getVirtualFile();\n    if (virtualFile != null && !virtualFile.getFileType().isBinary()) {\n      LocalInspectionsPass action3 = new LocalInspectionsPass(psiFile, document, 0,\n                                                              psiFile.getTextLength(), LocalInspectionsPass.EMPTY_PRIORITY_RANGE, true);\n      action3.doCollectInformation(progress);\n\n      result.addAll(action3.getInfos());\n    }\n\n    return result;\n  }","commit_id":"6e64727a4150940ddcc031199f376a6b1cb445eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HighlightUsagesHandlerBase createHighlightUsagesHandler(final Editor editor, final PsiFile file) {\n    int offset = TargetElementUtilBase.adjustOffset(editor.getDocument(), editor.getCaretModel().getOffset());\n    final PsiElement target = file.findElementAt(offset);\n    final PsiAnnotation annotation = PsiTreeUtil.getParentOfType(target, PsiAnnotation.class);\n    if (annotation != null && Comparing.strEqual(SuppressWarnings.class.getName(), annotation.getQualifiedName())) {\n      return new HighlightSuppressedWarningsHandler(editor, file, annotation, PsiTreeUtil.getParentOfType(target, PsiLiteralExpression.class));\n    }\n    return null;\n  }","id":91741,"modified_method":"public HighlightUsagesHandlerBase createHighlightUsagesHandler(final Editor editor, final PsiFile file) {\n    int offset = TargetElementUtilBase.adjustOffset(editor.getDocument(), editor.getCaretModel().getOffset());\n    final PsiElement target = file.findElementAt(offset);\n    final PsiAnnotation annotation = PsiTreeUtil.getParentOfType(target, PsiAnnotation.class);\n    if (annotation != null && Comparing.strEqual(SuppressWarnings.class.getName(), annotation.getQualifiedName())) {\n      final VirtualFile virtualFile = file.getVirtualFile();\n      if (virtualFile != null && !virtualFile.getFileType().isBinary()) {\n        return new HighlightSuppressedWarningsHandler(editor, file, annotation, PsiTreeUtil.getParentOfType(target, PsiLiteralExpression.class));\n      }\n    }\n    return null;\n  }","commit_id":"6e64727a4150940ddcc031199f376a6b1cb445eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Collection<HighlightInfo> doHighlighting() {\n    PsiDocumentManager.getInstance(getProject()).commitAllDocuments();\n\n    Document document = getEditor().getDocument();\n    if (doFolding()) {\n      final CodeFoldingPassFactory factory = getProject().getComponent(CodeFoldingPassFactory.class);\n      final TextEditorHighlightingPass highlightingPass = factory.createHighlightingPass(myFile, myEditor);\n      highlightingPass.collectInformation(new MockProgressIndicator());\n      highlightingPass.doApplyInformationToEditor();\n    }\n\n    GeneralHighlightingPass action1 = new GeneralHighlightingPass(getProject(), getFile(), document, 0, getFile().getTextLength(), true);\n    action1.collectInformation(new MockProgressIndicator());\n    action1.applyInformationToEditor();\n    Collection<HighlightInfo> highlights1 = action1.getHighlights();\n\n    PostHighlightingPass action2 = new PostHighlightingPass(getProject(), getFile(), getEditor(), 0, getFile().getTextLength());\n    action2.doCollectInformation(new MockProgressIndicator());\n    Collection<HighlightInfo> highlights2 = action2.getHighlights();\n\n    LocalInspectionsPass action3 = new LocalInspectionsPass(getFile(), document, 0, getFile().getTextLength());\n    action3.doCollectInformation(new MockProgressIndicator());\n    Collection<HighlightInfo> highlights3 = action3.getHighlights();\n\n    HashSet<HighlightInfo> result = new HashSet<HighlightInfo>(highlights1);\n    result.addAll(highlights2);\n    result.addAll(highlights3);\n    return result;\n  }","id":91742,"modified_method":"protected Collection<HighlightInfo> doHighlighting() {\n    PsiDocumentManager.getInstance(getProject()).commitAllDocuments();\n\n    Document document = getEditor().getDocument();\n    if (doFolding()) {\n      final CodeFoldingPassFactory factory = getProject().getComponent(CodeFoldingPassFactory.class);\n      final TextEditorHighlightingPass highlightingPass = factory.createHighlightingPass(myFile, myEditor);\n      highlightingPass.collectInformation(new MockProgressIndicator());\n      highlightingPass.doApplyInformationToEditor();\n    }\n\n    GeneralHighlightingPass action1 = new GeneralHighlightingPass(getProject(), getFile(), document, 0, getFile().getTextLength(), true);\n    action1.collectInformation(new MockProgressIndicator());\n    action1.applyInformationToEditor();\n    Collection<HighlightInfo> highlights1 = action1.getHighlights();\n\n    Collection<HighlightInfo> highlights2;\n    PostHighlightingPassFactory phpFactory = getProject().getComponent(PostHighlightingPassFactory.class);\n    if (phpFactory != null) {\n      PostHighlightingPass action2 = new PostHighlightingPass(getProject(), getFile(), getEditor(), 0, getFile().getTextLength());\n      action2.doCollectInformation(new MockProgressIndicator());\n       highlights2 = action2.getHighlights();\n    }\n    else {\n      highlights2 = Collections.emptyList();\n    }\n\n    LocalInspectionsPass action3 = new LocalInspectionsPass(getFile(), document, 0, getFile().getTextLength());\n    action3.doCollectInformation(new MockProgressIndicator());\n    Collection<HighlightInfo> highlights3 = action3.getHighlights();\n\n    HashSet<HighlightInfo> result = new HashSet<HighlightInfo>(highlights1);\n    result.addAll(highlights2);\n    result.addAll(highlights3);\n    return result;\n  }","commit_id":"cc66d091cd82cc801fbb681ab6cd927eaa2d6e33","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setProperty( String key, Object value )\n    {\n        if ( key == null || value == null )\n        {\n            throw new IllegalArgumentException( \"Null parameter, \" + \"key=\" + \n                key + \", \" + \"value=\" + value );\n        }\n        nodeManager.acquireLock( this, LockType.WRITE );\n        boolean success = false;\n        try\n        {\n            if ( cowTxId == null )\n            {\n                setupCowTx();\n            }\n            ensureFullProperties();\n            ArrayMap<Integer,Property> addMap = nodeManager\n                .getCowPropertyAddMap( this, true );\n            ArrayMap<Integer,Property> skipMap = nodeManager\n                .getCowPropertyRemoveMap( this );\n            PropertyIndex index = null;\n            Property property = null;\n            for ( PropertyIndex cachedIndex : nodeManager.index( key ) )\n            {\n                if ( skipMap != null )\n                {\n                    skipMap.remove( cachedIndex.getKeyId() );\n                }\n                index = cachedIndex;\n                property = addMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    break;\n                }\n                property = propertyMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    break;\n                }\n            }\n            if ( property == null && !nodeManager.hasAllPropertyIndexes() )\n            {\n                for ( int keyId : addMap.keySet() )\n                {\n                    if ( !nodeManager.hasIndexFor( keyId ) )\n                    {\n                        PropertyIndex indexToCheck = nodeManager\n                            .getIndexFor( keyId );\n                        if ( indexToCheck.getKey().equals( key ) )\n                        {\n                            if ( skipMap != null )\n                            {\n                                skipMap.remove( indexToCheck.getKeyId() );\n                            }\n                            index = indexToCheck;\n                            property = addMap.get( indexToCheck.getKeyId() );\n                            if ( property != null )\n                            {\n                                break;\n                            }\n                        }\n                    }\n                }\n                if ( property == null )\n                {\n                    for ( int keyId : propertyMap.keySet() )\n                    {\n                        if ( !nodeManager.hasIndexFor( keyId ) )\n                        {\n                            PropertyIndex indexToCheck = nodeManager\n                                .getIndexFor( keyId );\n                            if ( indexToCheck.getKey().equals( key ) )\n                            {\n                                if ( skipMap != null )\n                                {\n                                    skipMap.remove( indexToCheck.getKeyId() );\n                                }\n                                index = indexToCheck;\n                                property = propertyMap.get( indexToCheck\n                                    .getKeyId() );\n                                if ( property != null )\n                                {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if ( index == null )\n            {\n                index = nodeManager.createPropertyIndex( key );\n            }\n            if ( property != null )\n            {\n                int propertyId = property.getId();\n                changeProperty( propertyId, value );\n                property.setNewValue( value );\n            }\n            else\n            {\n                int propertyId = addProperty( index, value );\n                property = new Property( propertyId, value );\n            }\n            addMap.put( index.getKeyId(), property );\n            success = true;\n        }\n        finally\n        {\n            nodeManager.releaseLock( this, LockType.WRITE );\n            if ( !success )\n            {\n                setRollbackOnly();\n            }\n        }\n    }","id":91743,"modified_method":"public void setProperty( String key, Object value )\n    {\n        if ( key == null || value == null )\n        {\n            throw new IllegalArgumentException( \"Null parameter, \" + \"key=\" + \n                key + \", \" + \"value=\" + value );\n        }\n        nodeManager.acquireLock( this, LockType.WRITE );\n        boolean success = false;\n        try\n        {\n            // if ( cowTxId == null )\n            // {\n                setupCowTx();\n            // }\n            ensureFullProperties();\n            ArrayMap<Integer,Property> addMap = \n                nodeManager.getCowPropertyAddMap( this, true );\n            ArrayMap<Integer,Property> skipMap = \n                nodeManager.getCowPropertyRemoveMap( this );\n            PropertyIndex index = null;\n            Property property = null;\n            for ( PropertyIndex cachedIndex : nodeManager.index( key ) )\n            {\n                if ( skipMap != null )\n                {\n                    skipMap.remove( cachedIndex.getKeyId() );\n                }\n                index = cachedIndex;\n                property = addMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    break;\n                }\n                property = propertyMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    break;\n                }\n            }\n            if ( property == null && !nodeManager.hasAllPropertyIndexes() )\n            {\n                for ( int keyId : addMap.keySet() )\n                {\n                    if ( !nodeManager.hasIndexFor( keyId ) )\n                    {\n                        PropertyIndex indexToCheck = nodeManager\n                            .getIndexFor( keyId );\n                        if ( indexToCheck.getKey().equals( key ) )\n                        {\n                            if ( skipMap != null )\n                            {\n                                skipMap.remove( indexToCheck.getKeyId() );\n                            }\n                            index = indexToCheck;\n                            property = addMap.get( indexToCheck.getKeyId() );\n                            if ( property != null )\n                            {\n                                break;\n                            }\n                        }\n                    }\n                }\n                if ( property == null )\n                {\n                    for ( int keyId : propertyMap.keySet() )\n                    {\n                        if ( !nodeManager.hasIndexFor( keyId ) )\n                        {\n                            PropertyIndex indexToCheck = nodeManager\n                                .getIndexFor( keyId );\n                            if ( indexToCheck.getKey().equals( key ) )\n                            {\n                                if ( skipMap != null )\n                                {\n                                    skipMap.remove( indexToCheck.getKeyId() );\n                                }\n                                index = indexToCheck;\n                                property = propertyMap.get( indexToCheck\n                                    .getKeyId() );\n                                if ( property != null )\n                                {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if ( index == null )\n            {\n                index = nodeManager.createPropertyIndex( key );\n            }\n            if ( property != null )\n            {\n                int propertyId = property.getId();\n                changeProperty( propertyId, value );\n                property.setNewValue( value );\n            }\n            else\n            {\n                int propertyId = addProperty( index, value );\n                property = new Property( propertyId, value );\n            }\n            addMap.put( index.getKeyId(), property );\n            success = true;\n        }\n        finally\n        {\n            nodeManager.releaseLock( this, LockType.WRITE );\n            if ( !success )\n            {\n                setRollbackOnly();\n            }\n        }\n    }","commit_id":"e2c937b60d6983f03fcf298d0f35e506bbebbe67","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Object removeProperty( String key )\n    {\n        if ( key == null )\n        {\n            throw new IllegalArgumentException( \"Null parameter.\" );\n        }\n        nodeManager.acquireLock( this, LockType.WRITE );\n        boolean success = false;\n        try\n        {\n            if ( cowTxId == null )\n            {\n                setupCowTx();\n            }\n            ensureFullProperties();\n            Property property = null;\n            ArrayMap<Integer,Property> addMap = nodeManager\n                .getCowPropertyAddMap( this );\n            ArrayMap<Integer,Property> removeMap = nodeManager\n                .getCowPropertyRemoveMap( this, true );\n            for ( PropertyIndex cachedIndex : nodeManager.index( key ) )\n            {\n                if ( addMap != null )\n                {\n                    property = addMap.remove( cachedIndex.getKeyId() );\n                    if ( property != null )\n                    {\n                        removeMap.put( cachedIndex.getKeyId(), property );\n                        break;\n                    }\n                }\n                property = propertyMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    removeMap.put( cachedIndex.getKeyId(), property );\n                    break;\n                }\n            }\n            if ( property == null && !nodeManager.hasAllPropertyIndexes() )\n            {\n                if ( addMap != null )\n                {\n                    for ( int keyId : addMap.keySet() )\n                    {\n                        if ( !nodeManager.hasIndexFor( keyId ) )\n                        {\n                            PropertyIndex indexToCheck = nodeManager\n                                .getIndexFor( keyId );\n                            if ( indexToCheck.getKey().equals( key ) )\n                            {\n                                property = addMap.remove( indexToCheck\n                                    .getKeyId() );\n                                if ( property != null )\n                                {\n                                    removeMap.put( indexToCheck.getKeyId(),\n                                        property );\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if ( property == null )\n                    {\n                        for ( int keyId : propertyMap.keySet() )\n                        {\n                            if ( !nodeManager.hasIndexFor( keyId ) )\n                            {\n                                PropertyIndex indexToCheck = nodeManager\n                                    .getIndexFor( keyId );\n                                if ( indexToCheck.getKey().equals( key ) )\n                                {\n                                    property = propertyMap.get( indexToCheck\n                                        .getKeyId() );\n                                    if ( property != null )\n                                    {\n                                        removeMap.put( indexToCheck.getKeyId(),\n                                            property );\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if ( property == null )\n            {\n                success = true;\n                return null;\n            }\n            removeProperty( property.getId() );\n            success = true;\n            return getPropertyValue( property );\n        }\n        finally\n        {\n            nodeManager.releaseLock( this, LockType.WRITE );\n            if ( !success )\n            {\n                setRollbackOnly();\n            }\n        }\n    }","id":91744,"modified_method":"public Object removeProperty( String key )\n    {\n        if ( key == null )\n        {\n            throw new IllegalArgumentException( \"Null parameter.\" );\n        }\n        nodeManager.acquireLock( this, LockType.WRITE );\n        boolean success = false;\n        try\n        {\n            // if ( cowTxId == null )\n            // {\n                setupCowTx();\n            // }\n            ensureFullProperties();\n            Property property = null;\n            ArrayMap<Integer,Property> addMap = \n                nodeManager.getCowPropertyAddMap( this );\n            ArrayMap<Integer,Property> removeMap =\n                nodeManager.getCowPropertyRemoveMap( this, true );\n            for ( PropertyIndex cachedIndex : nodeManager.index( key ) )\n            {\n                if ( addMap != null )\n                {\n                    property = addMap.remove( cachedIndex.getKeyId() );\n                    if ( property != null )\n                    {\n                        removeMap.put( cachedIndex.getKeyId(), property );\n                        break;\n                    }\n                }\n                property = propertyMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    removeMap.put( cachedIndex.getKeyId(), property );\n                    break;\n                }\n            }\n            if ( property == null && !nodeManager.hasAllPropertyIndexes() )\n            {\n                if ( addMap != null )\n                {\n                    for ( int keyId : addMap.keySet() )\n                    {\n                        if ( !nodeManager.hasIndexFor( keyId ) )\n                        {\n                            PropertyIndex indexToCheck = nodeManager\n                                .getIndexFor( keyId );\n                            if ( indexToCheck.getKey().equals( key ) )\n                            {\n                                property = addMap.remove( indexToCheck\n                                    .getKeyId() );\n                                if ( property != null )\n                                {\n                                    removeMap.put( indexToCheck.getKeyId(),\n                                        property );\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if ( property == null )\n                    {\n                        for ( int keyId : propertyMap.keySet() )\n                        {\n                            if ( !nodeManager.hasIndexFor( keyId ) )\n                            {\n                                PropertyIndex indexToCheck = nodeManager\n                                    .getIndexFor( keyId );\n                                if ( indexToCheck.getKey().equals( key ) )\n                                {\n                                    property = propertyMap.get( indexToCheck\n                                        .getKeyId() );\n                                    if ( property != null )\n                                    {\n                                        removeMap.put( indexToCheck.getKeyId(),\n                                            property );\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if ( property == null )\n            {\n                success = true;\n                return null;\n            }\n            removeProperty( property.getId() );\n            success = true;\n            return getPropertyValue( property );\n        }\n        finally\n        {\n            nodeManager.releaseLock( this, LockType.WRITE );\n            if ( !success )\n            {\n                setRollbackOnly();\n            }\n        }\n    }","commit_id":"e2c937b60d6983f03fcf298d0f35e506bbebbe67","url":"https://github.com/neo4j/neo4j"},{"original_method":"void removeRelationship( RelationshipType type, int relId )\n    {\n        if ( getCowTxId() == null )\n        {\n            setupCowTx();\n        }\n        ArrayIntSet addedSet = nodeManager.getCowRelationshipAddMap( this, \n            type.name() );\n        if ( addedSet != null )\n        {\n            addedSet.remove( relId );\n        }\n        ArrayIntSet relationshipSet = nodeManager.getCowRelationshipRemoveMap(\n            this, type.name(), true );\n        relationshipSet.add( relId );\n    }","id":91745,"modified_method":"void removeRelationship( RelationshipType type, int relId )\n    {\n        // if ( getCowTxId() == null )\n        // {\n            setupCowTx();\n        // }\n        ArrayIntSet addedSet = nodeManager.getCowRelationshipAddMap( this, \n            type.name() );\n        if ( addedSet != null )\n        {\n            addedSet.remove( relId );\n        }\n        ArrayIntSet relationshipSet = nodeManager.getCowRelationshipRemoveMap(\n            this, type.name(), true );\n        relationshipSet.add( relId );\n    }","commit_id":"e2c937b60d6983f03fcf298d0f35e506bbebbe67","url":"https://github.com/neo4j/neo4j"},{"original_method":"void addRelationship( RelationshipType type, int relId )\n    {\n        if ( getCowTxId() == null )\n        {\n            setupCowTx();\n        }\n        ArrayIntSet relationshipSet = nodeManager.getCowRelationshipAddMap(\n            this, type.name(), true );\n        relationshipSet.add( relId );\n    }","id":91746,"modified_method":"void addRelationship( RelationshipType type, int relId )\n    {\n        // if ( getCowTxId() == null )\n        // {\n            setupCowTx();\n        // }\n        ArrayIntSet relationshipSet = nodeManager.getCowRelationshipAddMap(\n            this, type.name(), true );\n        relationshipSet.add( relId );\n    }","commit_id":"e2c937b60d6983f03fcf298d0f35e506bbebbe67","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void setProperty( String key, Object value )\n    {\n        if ( key == null || value == null )\n        {\n            throw new IllegalArgumentException( \"Null parameter, \" + \"key=\" + \n                key + \", \" + \"value=\" + value );\n        }\n        nodeManager.acquireLock( this, LockType.WRITE );\n        boolean success = false;\n        try\n        {\n            if ( cowTxId == null )\n            {\n                setupCowTx();\n            }\n            ensureFullProperties();\n            ArrayMap<Integer,Property> addMap = nodeManager\n                .getCowPropertyAddMap( this, true );\n            ArrayMap<Integer,Property> skipMap = nodeManager\n                .getCowPropertyRemoveMap( this );\n            PropertyIndex index = null;\n            Property property = null;\n            for ( PropertyIndex cachedIndex : nodeManager.index( key ) )\n            {\n                if ( skipMap != null )\n                {\n                    skipMap.remove( cachedIndex.getKeyId() );\n                }\n                index = cachedIndex;\n                property = addMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    break;\n                }\n                property = propertyMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    break;\n                }\n            }\n            if ( property == null && !nodeManager.hasAllPropertyIndexes() )\n            {\n                for ( int keyId : addMap.keySet() )\n                {\n                    if ( !nodeManager.hasIndexFor( keyId ) )\n                    {\n                        PropertyIndex indexToCheck = nodeManager\n                            .getIndexFor( keyId );\n                        if ( indexToCheck.getKey().equals( key ) )\n                        {\n                            if ( skipMap != null )\n                            {\n                                skipMap.remove( indexToCheck.getKeyId() );\n                            }\n                            index = indexToCheck;\n                            property = addMap.get( indexToCheck.getKeyId() );\n                            if ( property != null )\n                            {\n                                break;\n                            }\n                        }\n                    }\n                }\n                if ( property == null )\n                {\n                    for ( int keyId : propertyMap.keySet() )\n                    {\n                        if ( !nodeManager.hasIndexFor( keyId ) )\n                        {\n                            PropertyIndex indexToCheck = nodeManager\n                                .getIndexFor( keyId );\n                            if ( indexToCheck.getKey().equals( key ) )\n                            {\n                                if ( skipMap != null )\n                                {\n                                    skipMap.remove( indexToCheck.getKeyId() );\n                                }\n                                index = indexToCheck;\n                                property = propertyMap.get( indexToCheck\n                                    .getKeyId() );\n                                if ( property != null )\n                                {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if ( index == null )\n            {\n                index = nodeManager.createPropertyIndex( key );\n            }\n            if ( property != null )\n            {\n                int propertyId = property.getId();\n                changeProperty( propertyId, value );\n                property.setNewValue( value );\n            }\n            else\n            {\n                int propertyId = addProperty( index, value );\n                property = new Property( propertyId, value );\n            }\n            addMap.put( index.getKeyId(), property );\n            success = true;\n        }\n        finally\n        {\n            nodeManager.releaseLock( this, LockType.WRITE );\n            if ( !success )\n            {\n                setRollbackOnly();\n            }\n        }\n    }","id":91747,"modified_method":"public void setProperty( String key, Object value )\n    {\n        if ( key == null || value == null )\n        {\n            throw new IllegalArgumentException( \"Null parameter, \" + \"key=\" + \n                key + \", \" + \"value=\" + value );\n        }\n        nodeManager.acquireLock( this, LockType.WRITE );\n        boolean success = false;\n        try\n        {\n            // if ( cowTxId == null )\n            // {\n                setupCowTx();\n            // }\n            ensureFullProperties();\n            ArrayMap<Integer,Property> addMap = \n                nodeManager.getCowPropertyAddMap( this, true );\n            ArrayMap<Integer,Property> skipMap = \n                nodeManager.getCowPropertyRemoveMap( this );\n            PropertyIndex index = null;\n            Property property = null;\n            for ( PropertyIndex cachedIndex : nodeManager.index( key ) )\n            {\n                if ( skipMap != null )\n                {\n                    skipMap.remove( cachedIndex.getKeyId() );\n                }\n                index = cachedIndex;\n                property = addMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    break;\n                }\n                property = propertyMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    break;\n                }\n            }\n            if ( property == null && !nodeManager.hasAllPropertyIndexes() )\n            {\n                for ( int keyId : addMap.keySet() )\n                {\n                    if ( !nodeManager.hasIndexFor( keyId ) )\n                    {\n                        PropertyIndex indexToCheck = nodeManager\n                            .getIndexFor( keyId );\n                        if ( indexToCheck.getKey().equals( key ) )\n                        {\n                            if ( skipMap != null )\n                            {\n                                skipMap.remove( indexToCheck.getKeyId() );\n                            }\n                            index = indexToCheck;\n                            property = addMap.get( indexToCheck.getKeyId() );\n                            if ( property != null )\n                            {\n                                break;\n                            }\n                        }\n                    }\n                }\n                if ( property == null )\n                {\n                    for ( int keyId : propertyMap.keySet() )\n                    {\n                        if ( !nodeManager.hasIndexFor( keyId ) )\n                        {\n                            PropertyIndex indexToCheck = nodeManager\n                                .getIndexFor( keyId );\n                            if ( indexToCheck.getKey().equals( key ) )\n                            {\n                                if ( skipMap != null )\n                                {\n                                    skipMap.remove( indexToCheck.getKeyId() );\n                                }\n                                index = indexToCheck;\n                                property = propertyMap.get( indexToCheck\n                                    .getKeyId() );\n                                if ( property != null )\n                                {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if ( index == null )\n            {\n                index = nodeManager.createPropertyIndex( key );\n            }\n            if ( property != null )\n            {\n                int propertyId = property.getId();\n                changeProperty( propertyId, value );\n                property.setNewValue( value );\n            }\n            else\n            {\n                int propertyId = addProperty( index, value );\n                property = new Property( propertyId, value );\n            }\n            addMap.put( index.getKeyId(), property );\n            success = true;\n        }\n        finally\n        {\n            nodeManager.releaseLock( this, LockType.WRITE );\n            if ( !success )\n            {\n                setRollbackOnly();\n            }\n        }\n    }","commit_id":"9626748b689a622f69e67280e65a4d0560f1d489","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Object removeProperty( String key )\n    {\n        if ( key == null )\n        {\n            throw new IllegalArgumentException( \"Null parameter.\" );\n        }\n        nodeManager.acquireLock( this, LockType.WRITE );\n        boolean success = false;\n        try\n        {\n            if ( cowTxId == null )\n            {\n                setupCowTx();\n            }\n            ensureFullProperties();\n            Property property = null;\n            ArrayMap<Integer,Property> addMap = nodeManager\n                .getCowPropertyAddMap( this );\n            ArrayMap<Integer,Property> removeMap = nodeManager\n                .getCowPropertyRemoveMap( this, true );\n            for ( PropertyIndex cachedIndex : nodeManager.index( key ) )\n            {\n                if ( addMap != null )\n                {\n                    property = addMap.remove( cachedIndex.getKeyId() );\n                    if ( property != null )\n                    {\n                        removeMap.put( cachedIndex.getKeyId(), property );\n                        break;\n                    }\n                }\n                property = propertyMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    removeMap.put( cachedIndex.getKeyId(), property );\n                    break;\n                }\n            }\n            if ( property == null && !nodeManager.hasAllPropertyIndexes() )\n            {\n                if ( addMap != null )\n                {\n                    for ( int keyId : addMap.keySet() )\n                    {\n                        if ( !nodeManager.hasIndexFor( keyId ) )\n                        {\n                            PropertyIndex indexToCheck = nodeManager\n                                .getIndexFor( keyId );\n                            if ( indexToCheck.getKey().equals( key ) )\n                            {\n                                property = addMap.remove( indexToCheck\n                                    .getKeyId() );\n                                if ( property != null )\n                                {\n                                    removeMap.put( indexToCheck.getKeyId(),\n                                        property );\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if ( property == null )\n                    {\n                        for ( int keyId : propertyMap.keySet() )\n                        {\n                            if ( !nodeManager.hasIndexFor( keyId ) )\n                            {\n                                PropertyIndex indexToCheck = nodeManager\n                                    .getIndexFor( keyId );\n                                if ( indexToCheck.getKey().equals( key ) )\n                                {\n                                    property = propertyMap.get( indexToCheck\n                                        .getKeyId() );\n                                    if ( property != null )\n                                    {\n                                        removeMap.put( indexToCheck.getKeyId(),\n                                            property );\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if ( property == null )\n            {\n                success = true;\n                return null;\n            }\n            removeProperty( property.getId() );\n            success = true;\n            return getPropertyValue( property );\n        }\n        finally\n        {\n            nodeManager.releaseLock( this, LockType.WRITE );\n            if ( !success )\n            {\n                setRollbackOnly();\n            }\n        }\n    }","id":91748,"modified_method":"public Object removeProperty( String key )\n    {\n        if ( key == null )\n        {\n            throw new IllegalArgumentException( \"Null parameter.\" );\n        }\n        nodeManager.acquireLock( this, LockType.WRITE );\n        boolean success = false;\n        try\n        {\n            // if ( cowTxId == null )\n            // {\n                setupCowTx();\n            // }\n            ensureFullProperties();\n            Property property = null;\n            ArrayMap<Integer,Property> addMap = \n                nodeManager.getCowPropertyAddMap( this );\n            ArrayMap<Integer,Property> removeMap =\n                nodeManager.getCowPropertyRemoveMap( this, true );\n            for ( PropertyIndex cachedIndex : nodeManager.index( key ) )\n            {\n                if ( addMap != null )\n                {\n                    property = addMap.remove( cachedIndex.getKeyId() );\n                    if ( property != null )\n                    {\n                        removeMap.put( cachedIndex.getKeyId(), property );\n                        break;\n                    }\n                }\n                property = propertyMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    removeMap.put( cachedIndex.getKeyId(), property );\n                    break;\n                }\n            }\n            if ( property == null && !nodeManager.hasAllPropertyIndexes() )\n            {\n                if ( addMap != null )\n                {\n                    for ( int keyId : addMap.keySet() )\n                    {\n                        if ( !nodeManager.hasIndexFor( keyId ) )\n                        {\n                            PropertyIndex indexToCheck = nodeManager\n                                .getIndexFor( keyId );\n                            if ( indexToCheck.getKey().equals( key ) )\n                            {\n                                property = addMap.remove( indexToCheck\n                                    .getKeyId() );\n                                if ( property != null )\n                                {\n                                    removeMap.put( indexToCheck.getKeyId(),\n                                        property );\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if ( property == null )\n                    {\n                        for ( int keyId : propertyMap.keySet() )\n                        {\n                            if ( !nodeManager.hasIndexFor( keyId ) )\n                            {\n                                PropertyIndex indexToCheck = nodeManager\n                                    .getIndexFor( keyId );\n                                if ( indexToCheck.getKey().equals( key ) )\n                                {\n                                    property = propertyMap.get( indexToCheck\n                                        .getKeyId() );\n                                    if ( property != null )\n                                    {\n                                        removeMap.put( indexToCheck.getKeyId(),\n                                            property );\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if ( property == null )\n            {\n                success = true;\n                return null;\n            }\n            removeProperty( property.getId() );\n            success = true;\n            return getPropertyValue( property );\n        }\n        finally\n        {\n            nodeManager.releaseLock( this, LockType.WRITE );\n            if ( !success )\n            {\n                setRollbackOnly();\n            }\n        }\n    }","commit_id":"9626748b689a622f69e67280e65a4d0560f1d489","url":"https://github.com/neo4j/neo4j"},{"original_method":"void removeRelationship( RelationshipType type, int relId )\n    {\n        if ( getCowTxId() == null )\n        {\n            setupCowTx();\n        }\n        ArrayIntSet addedSet = nodeManager.getCowRelationshipAddMap( this, \n            type.name() );\n        if ( addedSet != null )\n        {\n            addedSet.remove( relId );\n        }\n        ArrayIntSet relationshipSet = nodeManager.getCowRelationshipRemoveMap(\n            this, type.name(), true );\n        relationshipSet.add( relId );\n    }","id":91749,"modified_method":"void removeRelationship( RelationshipType type, int relId )\n    {\n        // if ( getCowTxId() == null )\n        // {\n            setupCowTx();\n        // }\n        ArrayIntSet addedSet = nodeManager.getCowRelationshipAddMap( this, \n            type.name() );\n        if ( addedSet != null )\n        {\n            addedSet.remove( relId );\n        }\n        ArrayIntSet relationshipSet = nodeManager.getCowRelationshipRemoveMap(\n            this, type.name(), true );\n        relationshipSet.add( relId );\n    }","commit_id":"9626748b689a622f69e67280e65a4d0560f1d489","url":"https://github.com/neo4j/neo4j"},{"original_method":"void addRelationship( RelationshipType type, int relId )\n    {\n        if ( getCowTxId() == null )\n        {\n            setupCowTx();\n        }\n        ArrayIntSet relationshipSet = nodeManager.getCowRelationshipAddMap(\n            this, type.name(), true );\n        relationshipSet.add( relId );\n    }","id":91750,"modified_method":"void addRelationship( RelationshipType type, int relId )\n    {\n        // if ( getCowTxId() == null )\n        // {\n            setupCowTx();\n        // }\n        ArrayIntSet relationshipSet = nodeManager.getCowRelationshipAddMap(\n            this, type.name(), true );\n        relationshipSet.add( relId );\n    }","commit_id":"9626748b689a622f69e67280e65a4d0560f1d489","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Object removeProperty( String key )\n    {\n        if ( key == null )\n        {\n            throw new IllegalArgumentException( \"Null parameter.\" );\n        }\n        nodeManager.acquireLock( this, LockType.WRITE );\n        boolean success = false;\n        try\n        {\n            if ( cowTxId == null )\n            {\n                setupCowTx();\n            }\n            ensureFullProperties();\n            Property property = null;\n            ArrayMap<Integer,Property> addMap = nodeManager\n                .getCowPropertyAddMap( this );\n            ArrayMap<Integer,Property> removeMap = nodeManager\n                .getCowPropertyRemoveMap( this, true );\n            for ( PropertyIndex cachedIndex : nodeManager.index( key ) )\n            {\n                if ( addMap != null )\n                {\n                    property = addMap.remove( cachedIndex.getKeyId() );\n                    if ( property != null )\n                    {\n                        removeMap.put( cachedIndex.getKeyId(), property );\n                        break;\n                    }\n                }\n                property = propertyMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    removeMap.put( cachedIndex.getKeyId(), property );\n                    break;\n                }\n            }\n            if ( property == null && !nodeManager.hasAllPropertyIndexes() )\n            {\n                if ( addMap != null )\n                {\n                    for ( int keyId : addMap.keySet() )\n                    {\n                        if ( !nodeManager.hasIndexFor( keyId ) )\n                        {\n                            PropertyIndex indexToCheck = nodeManager\n                                .getIndexFor( keyId );\n                            if ( indexToCheck.getKey().equals( key ) )\n                            {\n                                property = addMap.remove( indexToCheck\n                                    .getKeyId() );\n                                if ( property != null )\n                                {\n                                    removeMap.put( indexToCheck.getKeyId(),\n                                        property );\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if ( property == null )\n                    {\n                        for ( int keyId : propertyMap.keySet() )\n                        {\n                            if ( !nodeManager.hasIndexFor( keyId ) )\n                            {\n                                PropertyIndex indexToCheck = nodeManager\n                                    .getIndexFor( keyId );\n                                if ( indexToCheck.getKey().equals( key ) )\n                                {\n                                    property = propertyMap.get( indexToCheck\n                                        .getKeyId() );\n                                    if ( property != null )\n                                    {\n                                        removeMap.put( indexToCheck.getKeyId(),\n                                            property );\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if ( property == null )\n            {\n                success = true;\n                return null;\n            }\n            removeProperty( property.getId() );\n            success = true;\n            return getPropertyValue( property );\n        }\n        finally\n        {\n            nodeManager.releaseLock( this, LockType.WRITE );\n            if ( !success )\n            {\n                setRollbackOnly();\n            }\n        }\n    }","id":91751,"modified_method":"public Object removeProperty( String key )\n    {\n        if ( key == null )\n        {\n            throw new IllegalArgumentException( \"Null parameter.\" );\n        }\n        nodeManager.acquireLock( this, LockType.WRITE );\n        boolean success = false;\n        try\n        {\n            // if ( cowTxId == null )\n            // {\n                setupCowTx();\n            // }\n            ensureFullProperties();\n            Property property = null;\n            ArrayMap<Integer,Property> addMap = \n                nodeManager.getCowPropertyAddMap( this );\n            ArrayMap<Integer,Property> removeMap =\n                nodeManager.getCowPropertyRemoveMap( this, true );\n            for ( PropertyIndex cachedIndex : nodeManager.index( key ) )\n            {\n                if ( addMap != null )\n                {\n                    property = addMap.remove( cachedIndex.getKeyId() );\n                    if ( property != null )\n                    {\n                        removeMap.put( cachedIndex.getKeyId(), property );\n                        break;\n                    }\n                }\n                property = propertyMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    removeMap.put( cachedIndex.getKeyId(), property );\n                    break;\n                }\n            }\n            if ( property == null && !nodeManager.hasAllPropertyIndexes() )\n            {\n                if ( addMap != null )\n                {\n                    for ( int keyId : addMap.keySet() )\n                    {\n                        if ( !nodeManager.hasIndexFor( keyId ) )\n                        {\n                            PropertyIndex indexToCheck = nodeManager\n                                .getIndexFor( keyId );\n                            if ( indexToCheck.getKey().equals( key ) )\n                            {\n                                property = addMap.remove( indexToCheck\n                                    .getKeyId() );\n                                if ( property != null )\n                                {\n                                    removeMap.put( indexToCheck.getKeyId(),\n                                        property );\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if ( property == null )\n                    {\n                        for ( int keyId : propertyMap.keySet() )\n                        {\n                            if ( !nodeManager.hasIndexFor( keyId ) )\n                            {\n                                PropertyIndex indexToCheck = nodeManager\n                                    .getIndexFor( keyId );\n                                if ( indexToCheck.getKey().equals( key ) )\n                                {\n                                    property = propertyMap.get( indexToCheck\n                                        .getKeyId() );\n                                    if ( property != null )\n                                    {\n                                        removeMap.put( indexToCheck.getKeyId(),\n                                            property );\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if ( property == null )\n            {\n                success = true;\n                return null;\n            }\n            removeProperty( property.getId() );\n            success = true;\n            return getPropertyValue( property );\n        }\n        finally\n        {\n            nodeManager.releaseLock( this, LockType.WRITE );\n            if ( !success )\n            {\n                setRollbackOnly();\n            }\n        }\n    }","commit_id":"8792b73d9085b59b8c8b45aa833fc1d14f5d1a15","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void setProperty( String key, Object value )\n    {\n        if ( key == null || value == null )\n        {\n            throw new IllegalArgumentException( \"Null parameter, \" + \"key=\" + \n                key + \", \" + \"value=\" + value );\n        }\n        nodeManager.acquireLock( this, LockType.WRITE );\n        boolean success = false;\n        try\n        {\n            if ( cowTxId == null )\n            {\n                setupCowTx();\n            }\n            ensureFullProperties();\n            ArrayMap<Integer,Property> addMap = nodeManager\n                .getCowPropertyAddMap( this, true );\n            ArrayMap<Integer,Property> skipMap = nodeManager\n                .getCowPropertyRemoveMap( this );\n            PropertyIndex index = null;\n            Property property = null;\n            for ( PropertyIndex cachedIndex : nodeManager.index( key ) )\n            {\n                if ( skipMap != null )\n                {\n                    skipMap.remove( cachedIndex.getKeyId() );\n                }\n                index = cachedIndex;\n                property = addMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    break;\n                }\n                property = propertyMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    break;\n                }\n            }\n            if ( property == null && !nodeManager.hasAllPropertyIndexes() )\n            {\n                for ( int keyId : addMap.keySet() )\n                {\n                    if ( !nodeManager.hasIndexFor( keyId ) )\n                    {\n                        PropertyIndex indexToCheck = nodeManager\n                            .getIndexFor( keyId );\n                        if ( indexToCheck.getKey().equals( key ) )\n                        {\n                            if ( skipMap != null )\n                            {\n                                skipMap.remove( indexToCheck.getKeyId() );\n                            }\n                            index = indexToCheck;\n                            property = addMap.get( indexToCheck.getKeyId() );\n                            if ( property != null )\n                            {\n                                break;\n                            }\n                        }\n                    }\n                }\n                if ( property == null )\n                {\n                    for ( int keyId : propertyMap.keySet() )\n                    {\n                        if ( !nodeManager.hasIndexFor( keyId ) )\n                        {\n                            PropertyIndex indexToCheck = nodeManager\n                                .getIndexFor( keyId );\n                            if ( indexToCheck.getKey().equals( key ) )\n                            {\n                                if ( skipMap != null )\n                                {\n                                    skipMap.remove( indexToCheck.getKeyId() );\n                                }\n                                index = indexToCheck;\n                                property = propertyMap.get( indexToCheck\n                                    .getKeyId() );\n                                if ( property != null )\n                                {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if ( index == null )\n            {\n                index = nodeManager.createPropertyIndex( key );\n            }\n            if ( property != null )\n            {\n                int propertyId = property.getId();\n                changeProperty( propertyId, value );\n                property.setNewValue( value );\n            }\n            else\n            {\n                int propertyId = addProperty( index, value );\n                property = new Property( propertyId, value );\n            }\n            addMap.put( index.getKeyId(), property );\n            success = true;\n        }\n        finally\n        {\n            nodeManager.releaseLock( this, LockType.WRITE );\n            if ( !success )\n            {\n                setRollbackOnly();\n            }\n        }\n    }","id":91752,"modified_method":"public void setProperty( String key, Object value )\n    {\n        if ( key == null || value == null )\n        {\n            throw new IllegalArgumentException( \"Null parameter, \" + \"key=\" + \n                key + \", \" + \"value=\" + value );\n        }\n        nodeManager.acquireLock( this, LockType.WRITE );\n        boolean success = false;\n        try\n        {\n            // if ( cowTxId == null )\n            // {\n                setupCowTx();\n            // }\n            ensureFullProperties();\n            ArrayMap<Integer,Property> addMap = \n                nodeManager.getCowPropertyAddMap( this, true );\n            ArrayMap<Integer,Property> skipMap = \n                nodeManager.getCowPropertyRemoveMap( this );\n            PropertyIndex index = null;\n            Property property = null;\n            for ( PropertyIndex cachedIndex : nodeManager.index( key ) )\n            {\n                if ( skipMap != null )\n                {\n                    skipMap.remove( cachedIndex.getKeyId() );\n                }\n                index = cachedIndex;\n                property = addMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    break;\n                }\n                property = propertyMap.get( cachedIndex.getKeyId() );\n                if ( property != null )\n                {\n                    break;\n                }\n            }\n            if ( property == null && !nodeManager.hasAllPropertyIndexes() )\n            {\n                for ( int keyId : addMap.keySet() )\n                {\n                    if ( !nodeManager.hasIndexFor( keyId ) )\n                    {\n                        PropertyIndex indexToCheck = nodeManager\n                            .getIndexFor( keyId );\n                        if ( indexToCheck.getKey().equals( key ) )\n                        {\n                            if ( skipMap != null )\n                            {\n                                skipMap.remove( indexToCheck.getKeyId() );\n                            }\n                            index = indexToCheck;\n                            property = addMap.get( indexToCheck.getKeyId() );\n                            if ( property != null )\n                            {\n                                break;\n                            }\n                        }\n                    }\n                }\n                if ( property == null )\n                {\n                    for ( int keyId : propertyMap.keySet() )\n                    {\n                        if ( !nodeManager.hasIndexFor( keyId ) )\n                        {\n                            PropertyIndex indexToCheck = nodeManager\n                                .getIndexFor( keyId );\n                            if ( indexToCheck.getKey().equals( key ) )\n                            {\n                                if ( skipMap != null )\n                                {\n                                    skipMap.remove( indexToCheck.getKeyId() );\n                                }\n                                index = indexToCheck;\n                                property = propertyMap.get( indexToCheck\n                                    .getKeyId() );\n                                if ( property != null )\n                                {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if ( index == null )\n            {\n                index = nodeManager.createPropertyIndex( key );\n            }\n            if ( property != null )\n            {\n                int propertyId = property.getId();\n                changeProperty( propertyId, value );\n                property.setNewValue( value );\n            }\n            else\n            {\n                int propertyId = addProperty( index, value );\n                property = new Property( propertyId, value );\n            }\n            addMap.put( index.getKeyId(), property );\n            success = true;\n        }\n        finally\n        {\n            nodeManager.releaseLock( this, LockType.WRITE );\n            if ( !success )\n            {\n                setRollbackOnly();\n            }\n        }\n    }","commit_id":"8792b73d9085b59b8c8b45aa833fc1d14f5d1a15","url":"https://github.com/neo4j/neo4j"},{"original_method":"void removeRelationship( RelationshipType type, int relId )\n    {\n        if ( getCowTxId() == null )\n        {\n            setupCowTx();\n        }\n        ArrayIntSet addedSet = nodeManager.getCowRelationshipAddMap( this, \n            type.name() );\n        if ( addedSet != null )\n        {\n            addedSet.remove( relId );\n        }\n        ArrayIntSet relationshipSet = nodeManager.getCowRelationshipRemoveMap(\n            this, type.name(), true );\n        relationshipSet.add( relId );\n    }","id":91753,"modified_method":"void removeRelationship( RelationshipType type, int relId )\n    {\n        // if ( getCowTxId() == null )\n        // {\n            setupCowTx();\n        // }\n        ArrayIntSet addedSet = nodeManager.getCowRelationshipAddMap( this, \n            type.name() );\n        if ( addedSet != null )\n        {\n            addedSet.remove( relId );\n        }\n        ArrayIntSet relationshipSet = nodeManager.getCowRelationshipRemoveMap(\n            this, type.name(), true );\n        relationshipSet.add( relId );\n    }","commit_id":"8792b73d9085b59b8c8b45aa833fc1d14f5d1a15","url":"https://github.com/neo4j/neo4j"},{"original_method":"void addRelationship( RelationshipType type, int relId )\n    {\n        if ( getCowTxId() == null )\n        {\n            setupCowTx();\n        }\n        ArrayIntSet relationshipSet = nodeManager.getCowRelationshipAddMap(\n            this, type.name(), true );\n        relationshipSet.add( relId );\n    }","id":91754,"modified_method":"void addRelationship( RelationshipType type, int relId )\n    {\n        // if ( getCowTxId() == null )\n        // {\n            setupCowTx();\n        // }\n        ArrayIntSet relationshipSet = nodeManager.getCowRelationshipAddMap(\n            this, type.name(), true );\n        relationshipSet.add( relId );\n    }","commit_id":"8792b73d9085b59b8c8b45aa833fc1d14f5d1a15","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Validate a Timestamp\n     * @param includeTimestamp whether a Timestamp must be included or not\n     * @param transportBinding whether the Transport binding is in use or not\n     * @param signedResults the signed results list\n     * @param message the Message object\n     * @return whether the Timestamp policy is valid or not\n     */\n    protected boolean validateTimestamp(\n        boolean includeTimestamp,\n        boolean transportBinding,\n        List<WSSecurityEngineResult> results,\n        List<WSSecurityEngineResult> signedResults,\n        Message message\n    ) {\n        List<WSSecurityEngineResult> timestampResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.TS, timestampResults);\n        \n        // Check whether we received a timestamp and compare it to the policy\n        if (includeTimestamp && timestampResults.size() != 1) {\n            return false;\n        } else if (!includeTimestamp) {\n            if (timestampResults.isEmpty()) {\n                return true;\n            }\n            return false;\n        }\n        \n        // At this point we received a (required) Timestamp. Now check that it is integrity protected.\n        if (transportBinding) {\n            return true;\n        } else if (!signedResults.isEmpty()) {\n            Timestamp timestamp = \n                (Timestamp)timestampResults.get(0).get(WSSecurityEngineResult.TAG_TIMESTAMP);\n            for (WSSecurityEngineResult signedResult : signedResults) {\n                List<WSDataRef> dataRefs = \n                    CastUtils.cast((List<?>)signedResult.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n                for (WSDataRef dataRef : dataRefs) {\n                    if (timestamp.getElement() == dataRef.getProtectedElement()) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }","id":91755,"modified_method":"/**\n     * Validate a Timestamp\n     * @param includeTimestamp whether a Timestamp must be included or not\n     * @param transportBinding whether the Transport binding is in use or not\n     * @param signedResults the signed results list\n     * @param message the Message object\n     * @return whether the Timestamp policy is valid or not\n     */\n    protected boolean validateTimestamp(\n        boolean includeTimestamp,\n        boolean transportBinding,\n        List<WSSecurityEngineResult> results,\n        List<WSSecurityEngineResult> signedResults,\n        Message message\n    ) {\n        List<WSSecurityEngineResult> timestampResults = \n            WSS4JUtils.fetchAllActionResults(results, WSConstants.TS);\n        \n        // Check whether we received a timestamp and compare it to the policy\n        if (includeTimestamp && timestampResults.size() != 1) {\n            return false;\n        } else if (!includeTimestamp) {\n            if (timestampResults.isEmpty()) {\n                return true;\n            }\n            return false;\n        }\n        \n        // At this point we received a (required) Timestamp. Now check that it is integrity protected.\n        if (transportBinding) {\n            return true;\n        } else if (!signedResults.isEmpty()) {\n            Timestamp timestamp = \n                (Timestamp)timestampResults.get(0).get(WSSecurityEngineResult.TAG_TIMESTAMP);\n            for (WSSecurityEngineResult signedResult : signedResults) {\n                List<WSDataRef> dataRefs = \n                    CastUtils.cast((List<?>)signedResult.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n                for (WSDataRef dataRef : dataRefs) {\n                    if (timestamp.getElement() == dataRef.getProtectedElement()) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }","commit_id":"01e1972a7dd13c8cfbef73126a9e9f5d7f6a26fb","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Check the supporting token coverage\n     */\n    private boolean checkSupportingTokenCoverage(\n        AssertionInfoMap aim,\n        SoapMessage msg,\n        List<WSSecurityEngineResult> results, \n        List<WSSecurityEngineResult> signedResults,\n        List<WSSecurityEngineResult> encryptedResults,\n        boolean utWithCallbacks\n    ) {\n        List<WSSecurityEngineResult> utResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.UT, utResults);\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.UT_NOPASSWORD, utResults);\n        \n        List<WSSecurityEngineResult> samlResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.ST_SIGNED, samlResults);\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.ST_UNSIGNED, samlResults);\n        \n        // Store the timestamp element\n        WSSecurityEngineResult tsResult = WSSecurityUtil.fetchActionResult(results, WSConstants.TS);\n        Element timestamp = null;\n        if (tsResult != null) {\n            Timestamp ts = (Timestamp)tsResult.get(WSSecurityEngineResult.TAG_TIMESTAMP);\n            timestamp = ts.getElement();\n        }\n        \n        boolean check = true;\n        \n        SupportingTokenPolicyValidator validator = new ConcreteSupportingTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n        \n        validator = new SignedTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n\n        validator = new EndorsingTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n\n        validator = new SignedEndorsingTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n\n        validator = new SignedEncryptedTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n\n        validator = new EncryptedTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n\n        validator = new EndorsingEncryptedTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n\n        validator = new SignedEndorsingEncryptedTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n        \n        return check;\n    }","id":91756,"modified_method":"/**\n     * Check the supporting token coverage\n     */\n    private boolean checkSupportingTokenCoverage(\n        AssertionInfoMap aim,\n        SoapMessage msg,\n        List<WSSecurityEngineResult> results, \n        List<WSSecurityEngineResult> signedResults,\n        List<WSSecurityEngineResult> encryptedResults,\n        boolean utWithCallbacks\n    ) {\n        final List<Integer> utActions = new ArrayList<Integer>(2);\n        utActions.add(WSConstants.UT);\n        utActions.add(WSConstants.UT_NOPASSWORD);\n        List<WSSecurityEngineResult> utResults = \n            WSS4JUtils.fetchAllActionResults(results, utActions);\n        \n        final List<Integer> samlActions = new ArrayList<Integer>(2);\n        samlActions.add(WSConstants.ST_SIGNED);\n        samlActions.add(WSConstants.ST_UNSIGNED);\n        List<WSSecurityEngineResult> samlResults = \n            WSS4JUtils.fetchAllActionResults(results, samlActions);\n        \n        // Store the timestamp element\n        WSSecurityEngineResult tsResult = WSSecurityUtil.fetchActionResult(results, WSConstants.TS);\n        Element timestamp = null;\n        if (tsResult != null) {\n            Timestamp ts = (Timestamp)tsResult.get(WSSecurityEngineResult.TAG_TIMESTAMP);\n            timestamp = ts.getElement();\n        }\n        \n        boolean check = true;\n        \n        SupportingTokenPolicyValidator validator = new ConcreteSupportingTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n        \n        validator = new SignedTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n\n        validator = new EndorsingTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n\n        validator = new SignedEndorsingTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n\n        validator = new SignedEncryptedTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n\n        validator = new EncryptedTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n\n        validator = new EndorsingEncryptedTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n\n        validator = new SignedEndorsingEncryptedTokenPolicyValidator();\n        validator.setUsernameTokenResults(utResults, utWithCallbacks);\n        validator.setSAMLTokenResults(samlResults);\n        validator.setTimestampElement(timestamp);\n        check &= validator.validatePolicy(aim, msg, results, signedResults, encryptedResults);\n        \n        return check;\n    }","commit_id":"01e1972a7dd13c8cfbef73126a9e9f5d7f6a26fb","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected void doResults(\n        SoapMessage msg, \n        String actor,\n        Element soapHeader,\n        Element soapBody,\n        List<WSSecurityEngineResult> results, \n        boolean utWithCallbacks\n    ) throws SOAPException, XMLStreamException, WSSecurityException {\n        AssertionInfoMap aim = msg.get(AssertionInfoMap.class);\n        Collection<WSDataRef> signed = new HashSet<WSDataRef>();\n        Collection<WSDataRef> encrypted = new HashSet<WSDataRef>();\n        \n        //\n        // Pre-fetch various results\n        //\n        List<WSSecurityEngineResult> signedResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.SIGN, signedResults);\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.UT_SIGN, signedResults);\n        for (WSSecurityEngineResult result : signedResults) {\n            List<WSDataRef> sl = \n                CastUtils.cast((List<?>)result.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n            if (sl != null) {\n                for (WSDataRef r : sl) {\n                    signed.add(r);\n                }\n            }\n        }\n        \n        List<WSSecurityEngineResult> encryptResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.ENCR, encryptResults);\n        for (WSSecurityEngineResult result : encryptResults) {\n            List<WSDataRef> sl = \n                CastUtils.cast((List<?>)result.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n            if (sl != null) {\n                for (WSDataRef r : sl) {\n                    encrypted.add(r);\n                }\n            }\n        }\n        \n        //\n        // Check policies\n        //\n        if (!checkSignedEncryptedCoverage(aim, msg, soapHeader, soapBody, signed, encrypted)) {\n            LOG.fine(\"Incoming request failed signed-encrypted policy validation\");\n        }\n        \n        if (!checkTokenCoverage(aim, msg, soapBody, results, signedResults)) {\n            LOG.fine(\"Incoming request failed token policy validation\");\n        }\n        \n        if (!checkBindingCoverage(aim, msg, soapBody, results, signedResults, encryptResults)) {\n            LOG.fine(\"Incoming request failed binding policy validation\");\n        }\n\n        if (!checkSupportingTokenCoverage(aim, msg, results, signedResults, \n            encryptResults, utWithCallbacks)) {\n            LOG.fine(\"Incoming request failed supporting token policy validation\");\n        }\n        \n        // relatively irrelevant stuff from a verification standpoint\n        assertPolicy(aim, SP12Constants.WSS10);\n        assertPolicy(aim, SP12Constants.TRUST_13);\n        assertPolicy(aim, SP11Constants.TRUST_10);\n        \n        super.doResults(msg, actor, soapHeader, soapBody, results, utWithCallbacks);\n    }","id":91757,"modified_method":"@Override\n    protected void doResults(\n        SoapMessage msg, \n        String actor,\n        Element soapHeader,\n        Element soapBody,\n        List<WSSecurityEngineResult> results, \n        boolean utWithCallbacks\n    ) throws SOAPException, XMLStreamException, WSSecurityException {\n        AssertionInfoMap aim = msg.get(AssertionInfoMap.class);\n        Collection<WSDataRef> signed = new HashSet<WSDataRef>();\n        Collection<WSDataRef> encrypted = new HashSet<WSDataRef>();\n        \n        //\n        // Pre-fetch various results\n        //\n        final List<Integer> actions = new ArrayList<Integer>(2);\n        actions.add(WSConstants.SIGN);\n        actions.add(WSConstants.UT_SIGN);\n        List<WSSecurityEngineResult> signedResults = \n            WSS4JUtils.fetchAllActionResults(results, actions);\n        for (WSSecurityEngineResult result : signedResults) {\n            List<WSDataRef> sl = \n                CastUtils.cast((List<?>)result.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n            if (sl != null) {\n                for (WSDataRef r : sl) {\n                    signed.add(r);\n                }\n            }\n        }\n        \n        List<WSSecurityEngineResult> encryptResults = \n            WSS4JUtils.fetchAllActionResults(results, WSConstants.ENCR);\n        for (WSSecurityEngineResult result : encryptResults) {\n            List<WSDataRef> sl = \n                CastUtils.cast((List<?>)result.get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n            if (sl != null) {\n                for (WSDataRef r : sl) {\n                    encrypted.add(r);\n                }\n            }\n        }\n        \n        //\n        // Check policies\n        //\n        if (!checkSignedEncryptedCoverage(aim, msg, soapHeader, soapBody, signed, encrypted)) {\n            LOG.fine(\"Incoming request failed signed-encrypted policy validation\");\n        }\n        \n        if (!checkTokenCoverage(aim, msg, soapBody, results, signedResults)) {\n            LOG.fine(\"Incoming request failed token policy validation\");\n        }\n        \n        if (!checkBindingCoverage(aim, msg, soapBody, results, signedResults, encryptResults)) {\n            LOG.fine(\"Incoming request failed binding policy validation\");\n        }\n\n        if (!checkSupportingTokenCoverage(aim, msg, results, signedResults, \n            encryptResults, utWithCallbacks)) {\n            LOG.fine(\"Incoming request failed supporting token policy validation\");\n        }\n        \n        // relatively irrelevant stuff from a verification standpoint\n        assertPolicy(aim, SP12Constants.WSS10);\n        assertPolicy(aim, SP12Constants.TRUST_13);\n        assertPolicy(aim, SP11Constants.TRUST_10);\n        \n        super.doResults(msg, actor, soapHeader, soapBody, results, utWithCallbacks);\n    }","commit_id":"01e1972a7dd13c8cfbef73126a9e9f5d7f6a26fb","url":"https://github.com/apache/cxf"},{"original_method":"public boolean validatePolicy(\n        AssertionInfoMap aim,\n        Message message,\n        Element soapBody,\n        List<WSSecurityEngineResult> results,\n        List<WSSecurityEngineResult> signedResults\n    ) {\n        Collection<AssertionInfo> ais = aim.get(SP12Constants.SAML_TOKEN);\n        if (ais == null || ais.isEmpty()) {\n            return true;\n        }\n        \n        body = soapBody;\n        signed = signedResults;\n        \n        List<WSSecurityEngineResult> samlResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.ST_SIGNED, samlResults);\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.ST_UNSIGNED, samlResults);\n        \n        for (AssertionInfo ai : ais) {\n            SamlToken samlToken = (SamlToken)ai.getAssertion();\n            ai.setAsserted(true);\n\n            if (!isTokenRequired(samlToken, message)) {\n                continue;\n            }\n\n            if (samlResults.isEmpty()) {\n                ai.setNotAsserted(\n                    \"The received token does not match the token inclusion requirement\"\n                );\n                continue;\n            }\n            \n            // All of the received SAML Assertions must conform to the policy\n            for (WSSecurityEngineResult result : samlResults) {\n                AssertionWrapper assertionWrapper = \n                    (AssertionWrapper)result.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n                \n                if (!checkVersion(samlToken, assertionWrapper)) {\n                    ai.setNotAsserted(\"Wrong SAML Version\");\n                    continue;\n                }\n                TLSSessionInfo tlsInfo = message.get(TLSSessionInfo.class);\n                Certificate[] tlsCerts = null;\n                if (tlsInfo != null) {\n                    tlsCerts = tlsInfo.getPeerCertificates();\n                }\n                if (!checkHolderOfKey(assertionWrapper, signedResults, tlsCerts)) {\n                    ai.setNotAsserted(\"Assertion fails holder-of-key requirements\");\n                    continue;\n                }\n                if (!SAMLUtils.checkSenderVouches(assertionWrapper, tlsCerts, body, signed)) {\n                    ai.setNotAsserted(\"Assertion fails sender-vouches requirements\");\n                    continue;\n                }\n                /*\n                    if (!checkIssuerName(samlToken, assertionWrapper)) {\n                        ai.setNotAsserted(\"Wrong IssuerName\");\n                    }\n                 */\n            }\n        }\n        \n        return true;\n    }","id":91758,"modified_method":"public boolean validatePolicy(\n        AssertionInfoMap aim,\n        Message message,\n        Element soapBody,\n        List<WSSecurityEngineResult> results,\n        List<WSSecurityEngineResult> signedResults\n    ) {\n        Collection<AssertionInfo> ais = aim.get(SP12Constants.SAML_TOKEN);\n        if (ais == null || ais.isEmpty()) {\n            return true;\n        }\n        \n        body = soapBody;\n        signed = signedResults;\n        \n        final List<Integer> actions = new ArrayList<Integer>(2);\n        actions.add(WSConstants.ST_SIGNED);\n        actions.add(WSConstants.ST_UNSIGNED);\n        List<WSSecurityEngineResult> samlResults = \n            WSS4JUtils.fetchAllActionResults(results, actions);\n        \n        for (AssertionInfo ai : ais) {\n            SamlToken samlToken = (SamlToken)ai.getAssertion();\n            ai.setAsserted(true);\n\n            if (!isTokenRequired(samlToken, message)) {\n                continue;\n            }\n\n            if (samlResults.isEmpty()) {\n                ai.setNotAsserted(\n                    \"The received token does not match the token inclusion requirement\"\n                );\n                continue;\n            }\n            \n            // All of the received SAML Assertions must conform to the policy\n            for (WSSecurityEngineResult result : samlResults) {\n                AssertionWrapper assertionWrapper = \n                    (AssertionWrapper)result.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n                \n                if (!checkVersion(samlToken, assertionWrapper)) {\n                    ai.setNotAsserted(\"Wrong SAML Version\");\n                    continue;\n                }\n                TLSSessionInfo tlsInfo = message.get(TLSSessionInfo.class);\n                Certificate[] tlsCerts = null;\n                if (tlsInfo != null) {\n                    tlsCerts = tlsInfo.getPeerCertificates();\n                }\n                if (!checkHolderOfKey(assertionWrapper, signedResults, tlsCerts)) {\n                    ai.setNotAsserted(\"Assertion fails holder-of-key requirements\");\n                    continue;\n                }\n                if (!SAMLUtils.checkSenderVouches(assertionWrapper, tlsCerts, body, signed)) {\n                    ai.setNotAsserted(\"Assertion fails sender-vouches requirements\");\n                    continue;\n                }\n                /*\n                    if (!checkIssuerName(samlToken, assertionWrapper)) {\n                        ai.setNotAsserted(\"Wrong IssuerName\");\n                    }\n                 */\n            }\n        }\n        \n        return true;\n    }","commit_id":"01e1972a7dd13c8cfbef73126a9e9f5d7f6a26fb","url":"https://github.com/apache/cxf"},{"original_method":"public boolean validatePolicy(\n        AssertionInfoMap aim,\n        Message message,\n        Element soapBody,\n        List<WSSecurityEngineResult> results,\n        List<WSSecurityEngineResult> signedResults\n    ) {\n        Collection<AssertionInfo> ais = aim.get(SP12Constants.SECURITY_CONTEXT_TOKEN);\n        if (ais == null || ais.isEmpty()) {\n            return true;\n        }\n\n        List<WSSecurityEngineResult> sctResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.SCT, sctResults);\n\n        for (AssertionInfo ai : ais) {\n            SecurityContextToken sctPolicy = (SecurityContextToken)ai.getAssertion();\n            ai.setAsserted(true);\n\n            if (!isTokenRequired(sctPolicy, message)) {\n                continue;\n            }\n\n            if (sctResults.isEmpty()) {\n                ai.setNotAsserted(\n                    \"The received token does not match the token inclusion requirement\"\n                );\n                continue;\n            }\n        }\n        return true;\n    }","id":91759,"modified_method":"public boolean validatePolicy(\n        AssertionInfoMap aim,\n        Message message,\n        Element soapBody,\n        List<WSSecurityEngineResult> results,\n        List<WSSecurityEngineResult> signedResults\n    ) {\n        Collection<AssertionInfo> ais = aim.get(SP12Constants.SECURITY_CONTEXT_TOKEN);\n        if (ais == null || ais.isEmpty()) {\n            return true;\n        }\n\n        List<WSSecurityEngineResult> sctResults = \n            WSS4JUtils.fetchAllActionResults(results, WSConstants.SCT);\n\n        for (AssertionInfo ai : ais) {\n            SecurityContextToken sctPolicy = (SecurityContextToken)ai.getAssertion();\n            ai.setAsserted(true);\n\n            if (!isTokenRequired(sctPolicy, message)) {\n                continue;\n            }\n\n            if (sctResults.isEmpty()) {\n                ai.setNotAsserted(\n                    \"The received token does not match the token inclusion requirement\"\n                );\n                continue;\n            }\n        }\n        return true;\n    }","commit_id":"01e1972a7dd13c8cfbef73126a9e9f5d7f6a26fb","url":"https://github.com/apache/cxf"},{"original_method":"public boolean validatePolicy(\n        AssertionInfoMap aim,\n        Message message,\n        Element soapBody,\n        List<WSSecurityEngineResult> results,\n        List<WSSecurityEngineResult> signedResults\n    ) {\n        Collection<AssertionInfo> ais = aim.get(SP12Constants.USERNAME_TOKEN);\n        if (ais == null || ais.isEmpty()) {\n            return true;\n        }\n        \n        List<WSSecurityEngineResult> utResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.UT, utResults);\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.UT_NOPASSWORD, utResults);\n        \n        for (AssertionInfo ai : ais) {\n            org.apache.cxf.ws.security.policy.model.UsernameToken usernameTokenPolicy = \n                (org.apache.cxf.ws.security.policy.model.UsernameToken)ai.getAssertion();\n            ai.setAsserted(true);\n\n            if (!isTokenRequired(usernameTokenPolicy, message)) {\n                continue;\n            }\n\n            if (utResults.isEmpty()) {\n                ai.setNotAsserted(\n                    \"The received token does not match the token inclusion requirement\"\n                );\n                continue;\n            }\n\n            if (!checkTokens(usernameTokenPolicy, ai, utResults)) {\n                continue;\n            }\n        }\n        return true;\n    }","id":91760,"modified_method":"public boolean validatePolicy(\n        AssertionInfoMap aim,\n        Message message,\n        Element soapBody,\n        List<WSSecurityEngineResult> results,\n        List<WSSecurityEngineResult> signedResults\n    ) {\n        Collection<AssertionInfo> ais = aim.get(SP12Constants.USERNAME_TOKEN);\n        if (ais == null || ais.isEmpty()) {\n            return true;\n        }\n        \n        final List<Integer> actions = new ArrayList<Integer>(2);\n        actions.add(WSConstants.UT);\n        actions.add(WSConstants.UT_NOPASSWORD);\n        List<WSSecurityEngineResult> utResults = \n            WSS4JUtils.fetchAllActionResults(results, actions);\n        \n        for (AssertionInfo ai : ais) {\n            org.apache.cxf.ws.security.policy.model.UsernameToken usernameTokenPolicy = \n                (org.apache.cxf.ws.security.policy.model.UsernameToken)ai.getAssertion();\n            ai.setAsserted(true);\n\n            if (!isTokenRequired(usernameTokenPolicy, message)) {\n                continue;\n            }\n\n            if (utResults.isEmpty()) {\n                ai.setNotAsserted(\n                    \"The received token does not match the token inclusion requirement\"\n                );\n                continue;\n            }\n\n            if (!checkTokens(usernameTokenPolicy, ai, utResults)) {\n                continue;\n            }\n        }\n        return true;\n    }","commit_id":"01e1972a7dd13c8cfbef73126a9e9f5d7f6a26fb","url":"https://github.com/apache/cxf"},{"original_method":"public boolean validatePolicy(\n        AssertionInfoMap aim,\n        Message message,\n        Element soapBody,\n        List<WSSecurityEngineResult> results,\n        List<WSSecurityEngineResult> signedResults\n    ) {\n        Collection<AssertionInfo> ais = aim.get(SP12Constants.WSS11);\n        if (ais == null || ais.isEmpty()) {\n            return true;\n        }\n        \n        List<WSSecurityEngineResult> scResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.SC, scResults);\n        \n        for (AssertionInfo ai : ais) {\n            Wss11 wss11 = (Wss11)ai.getAssertion();\n            ai.setAsserted(true);\n\n            if (!MessageUtils.isRequestor(message)) {\n                continue;\n            }\n            \n            if ((wss11.isRequireSignatureConfirmation() && scResults.isEmpty())\n                || (!wss11.isRequireSignatureConfirmation() && !scResults.isEmpty())) {\n                ai.setNotAsserted(\n                    \"Signature Confirmation policy validation failed\"\n                );\n                continue;\n            }\n        }\n        return true;\n    }","id":91761,"modified_method":"public boolean validatePolicy(\n        AssertionInfoMap aim,\n        Message message,\n        Element soapBody,\n        List<WSSecurityEngineResult> results,\n        List<WSSecurityEngineResult> signedResults\n    ) {\n        Collection<AssertionInfo> ais = aim.get(SP12Constants.WSS11);\n        if (ais == null || ais.isEmpty()) {\n            return true;\n        }\n        \n        List<WSSecurityEngineResult> scResults =\n            WSS4JUtils.fetchAllActionResults(results, WSConstants.SC);\n        \n        for (AssertionInfo ai : ais) {\n            Wss11 wss11 = (Wss11)ai.getAssertion();\n            ai.setAsserted(true);\n\n            if (!MessageUtils.isRequestor(message)) {\n                continue;\n            }\n            \n            if ((wss11.isRequireSignatureConfirmation() && scResults.isEmpty())\n                || (!wss11.isRequireSignatureConfirmation() && !scResults.isEmpty())) {\n                ai.setNotAsserted(\n                    \"Signature Confirmation policy validation failed\"\n                );\n                continue;\n            }\n        }\n        return true;\n    }","commit_id":"01e1972a7dd13c8cfbef73126a9e9f5d7f6a26fb","url":"https://github.com/apache/cxf"},{"original_method":"private void storeTimestamp(\n        SoapMessage msg, RequestData reqData, List<WSSecurityEngineResult> wsResult\n    ) throws WSSecurityException {\n        // Extract the timestamp action result from the action list\n        List<WSSecurityEngineResult> timestampResults = new ArrayList<WSSecurityEngineResult>();\n        timestampResults = \n            WSSecurityUtil.fetchAllActionResults(wsResult, WSConstants.TS, timestampResults);\n\n        if (!timestampResults.isEmpty()) {\n            msg.put(TIMESTAMP_RESULT, timestampResults.get(timestampResults.size() - 1));\n        }\n    }","id":91762,"modified_method":"private void storeTimestamp(\n        SoapMessage msg, RequestData reqData, List<WSSecurityEngineResult> wsResult\n    ) throws WSSecurityException {\n        // Extract the timestamp action result from the action list\n        List<WSSecurityEngineResult> timestampResults = \n            WSS4JUtils.fetchAllActionResults(wsResult, WSConstants.TS);\n\n        if (!timestampResults.isEmpty()) {\n            msg.put(TIMESTAMP_RESULT, timestampResults.get(timestampResults.size() - 1));\n        }\n    }","commit_id":"01e1972a7dd13c8cfbef73126a9e9f5d7f6a26fb","url":"https://github.com/apache/cxf"},{"original_method":"private void storeSignature(\n        SoapMessage msg, RequestData reqData, List<WSSecurityEngineResult> wsResult\n    ) throws WSSecurityException {\n        // Extract the signature action result from the action list\n        List<WSSecurityEngineResult> signatureResults = new ArrayList<WSSecurityEngineResult>();\n        signatureResults = \n            WSSecurityUtil.fetchAllActionResults(wsResult, WSConstants.SIGN, signatureResults);\n\n        // Store the last signature result\n        if (!signatureResults.isEmpty()) {\n            msg.put(SIGNATURE_RESULT, signatureResults.get(signatureResults.size() - 1));\n        }\n    }","id":91763,"modified_method":"private void storeSignature(\n        SoapMessage msg, RequestData reqData, List<WSSecurityEngineResult> wsResult\n    ) throws WSSecurityException {\n        // Extract the signature action result from the action list\n        List<WSSecurityEngineResult> signatureResults = \n            WSS4JUtils.fetchAllActionResults(wsResult, WSConstants.SIGN);\n\n        // Store the last signature result\n        if (!signatureResults.isEmpty()) {\n            msg.put(SIGNATURE_RESULT, signatureResults.get(signatureResults.size() - 1));\n        }\n    }","commit_id":"01e1972a7dd13c8cfbef73126a9e9f5d7f6a26fb","url":"https://github.com/apache/cxf"},{"original_method":"public boolean validatePolicy(\n        AssertionInfoMap aim,\n        Message message,\n        Element soapBody,\n        List<WSSecurityEngineResult> results,\n        List<WSSecurityEngineResult> signedResults\n    ) {\n        Collection<AssertionInfo> ais = aim.get(SP12Constants.X509_TOKEN);\n        if (ais == null || ais.isEmpty()) {\n            return true;\n        }\n        \n        List<WSSecurityEngineResult> bstResults = new ArrayList<WSSecurityEngineResult>();\n        WSSecurityUtil.fetchAllActionResults(results, WSConstants.BST, bstResults);\n        \n        for (AssertionInfo ai : ais) {\n            X509Token x509TokenPolicy = (X509Token)ai.getAssertion();\n            ai.setAsserted(true);\n\n            if (!isTokenRequired(x509TokenPolicy, message)) {\n                continue;\n            }\n\n            if (bstResults.isEmpty()) {\n                ai.setNotAsserted(\n                    \"The received token does not match the token inclusion requirement\"\n                );\n                continue;\n            }\n\n            if (!checkTokenType(x509TokenPolicy.getTokenVersionAndType(), bstResults)) {\n                ai.setNotAsserted(\"An incorrect X.509 Token Type is detected\");\n                continue;\n            }\n        }\n        return true;\n    }","id":91764,"modified_method":"public boolean validatePolicy(\n        AssertionInfoMap aim,\n        Message message,\n        Element soapBody,\n        List<WSSecurityEngineResult> results,\n        List<WSSecurityEngineResult> signedResults\n    ) {\n        Collection<AssertionInfo> ais = aim.get(SP12Constants.X509_TOKEN);\n        if (ais == null || ais.isEmpty()) {\n            return true;\n        }\n        \n        List<WSSecurityEngineResult> bstResults = \n            WSS4JUtils.fetchAllActionResults(results, WSConstants.BST);\n        \n        for (AssertionInfo ai : ais) {\n            X509Token x509TokenPolicy = (X509Token)ai.getAssertion();\n            ai.setAsserted(true);\n\n            if (!isTokenRequired(x509TokenPolicy, message)) {\n                continue;\n            }\n\n            if (bstResults.isEmpty()) {\n                ai.setNotAsserted(\n                    \"The received token does not match the token inclusion requirement\"\n                );\n                continue;\n            }\n\n            if (!checkTokenType(x509TokenPolicy.getTokenVersionAndType(), bstResults)) {\n                ai.setNotAsserted(\"An incorrect X.509 Token Type is detected\");\n                continue;\n            }\n        }\n        return true;\n    }","commit_id":"01e1972a7dd13c8cfbef73126a9e9f5d7f6a26fb","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Checks that the WSS4J results refer to the required signed/encrypted\n     * elements as defined by the XPath expressions in {@link #xPaths}.\n     * \n     * @param message\n     *            the SOAP message containing the signature\n     * \n     * @throws SoapFault\n     *             if there is an error evaluating an XPath or an element is not\n     *             covered by the required cryptographic operation\n     */\n    public void handleMessage(SoapMessage message) throws Fault {\n        final Collection<WSDataRef> signed = new HashSet<WSDataRef>();\n        final Collection<WSDataRef> encrypted = new HashSet<WSDataRef>();\n        \n        List<WSHandlerResult> results = CastUtils.cast(\n                (List<?>) message.get(WSHandlerConstants.RECV_RESULTS));\n        \n        for (final WSHandlerResult wshr : results) {\n            final List<WSSecurityEngineResult> wsSecurityEngineSignResults = \n                new Vector<WSSecurityEngineResult>();\n            final List<WSSecurityEngineResult> wsSecurityEngineEncResults = \n                new Vector<WSSecurityEngineResult>();\n            \n            WSSecurityUtil.fetchAllActionResults(wshr.getResults(),\n                    WSConstants.SIGN, wsSecurityEngineSignResults);\n            \n            WSSecurityUtil.fetchAllActionResults(wshr.getResults(),\n                    WSConstants.ENCR, wsSecurityEngineEncResults);\n            \n            for (WSSecurityEngineResult wser : wsSecurityEngineSignResults) {\n            \n                List<WSDataRef> sl = CastUtils.cast((List<?>) wser\n                        .get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n                if (sl != null) {\n                    if (sl.size() == 1\n                        && sl.get(0).getName().equals(new QName(WSConstants.SIG_NS, WSConstants.SIG_LN))) {\n                        //endorsing the signature so don't include\n                        break;\n                    }\n                    \n                    for (WSDataRef r : sl) {\n                        signed.add(r);\n                    }\n                }\n            }\n            \n            for (WSSecurityEngineResult wser : wsSecurityEngineEncResults) {\n                List<WSDataRef> el = CastUtils.cast((List<?>) wser\n                        .get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n\n                if (el != null) {\n                    for (WSDataRef r : el) {\n                        encrypted.add(r);\n                    }\n                }\n            }\n        }\n        \n        CryptoCoverageUtil.reconcileEncryptedSignedRefs(signed, encrypted);\n        \n        if (this.xPaths != null && !this.xPaths.isEmpty()) {\n            // XPathFactory and XPath are not thread-safe so we must recreate them\n            // each request.\n            final XPathFactory factory = XPathFactory.newInstance();\n            final XPath xpath = factory.newXPath();\n            \n            if (this.prefixMap != null) {\n                xpath.setNamespaceContext(new MapNamespaceContext(this.prefixMap));\n            }\n            \n            for (XPathExpression xPathExpression : this.xPaths) {\n                Collection<WSDataRef> refsToCheck = null;\n                \n                switch (xPathExpression.getType()) {\n                case SIGNED:\n                    refsToCheck = signed;\n                    break;\n                case ENCRYPTED:\n                    refsToCheck = encrypted;\n                    break;\n                default:\n                    throw new IllegalStateException(\"Unexpected crypto type: \" \n                            + xPathExpression.getType());\n                }\n                        \n                try {\n                    SOAPMessage saajDoc = message.getContent(SOAPMessage.class);\n                    Element documentElement = null;\n                    if (saajDoc != null && saajDoc.getSOAPPart() != null) {\n                        documentElement = saajDoc.getSOAPPart().getEnvelope();\n                    }\n                    \n                    CryptoCoverageUtil.checkCoverage(\n                            documentElement,\n                            refsToCheck,\n                            xpath, \n                            Arrays.asList(xPathExpression.getXPath()),\n                            xPathExpression.getType(),\n                            xPathExpression.getScope());\n                } catch (WSSecurityException e) {\n                    throw new SoapFault(\"No \" + xPathExpression.getType()\n                            + \" element found matching XPath \"\n                            + xPathExpression.getXPath(), Fault.FAULT_CODE_CLIENT);\n                } catch (SOAPException e) {\n                    throw new SoapFault(\"No \" + xPathExpression.getType()\n                            + \" element found matching XPath \"\n                            + xPathExpression.getXPath(), Fault.FAULT_CODE_CLIENT);\n                }\n            }\n        }\n    }","id":91765,"modified_method":"/**\n     * Checks that the WSS4J results refer to the required signed/encrypted\n     * elements as defined by the XPath expressions in {@link #xPaths}.\n     * \n     * @param message\n     *            the SOAP message containing the signature\n     * \n     * @throws SoapFault\n     *             if there is an error evaluating an XPath or an element is not\n     *             covered by the required cryptographic operation\n     */\n    public void handleMessage(SoapMessage message) throws Fault {\n        final Collection<WSDataRef> signed = new HashSet<WSDataRef>();\n        final Collection<WSDataRef> encrypted = new HashSet<WSDataRef>();\n        \n        List<WSHandlerResult> results = CastUtils.cast(\n                (List<?>) message.get(WSHandlerConstants.RECV_RESULTS));\n        \n        for (final WSHandlerResult wshr : results) {\n            final List<WSSecurityEngineResult> wsSecurityEngineSignResults = \n                WSS4JUtils.fetchAllActionResults(wshr.getResults(), WSConstants.SIGN);\n            \n            final List<WSSecurityEngineResult> wsSecurityEngineEncResults = \n                WSS4JUtils.fetchAllActionResults(wshr.getResults(), WSConstants.ENCR);\n            \n            for (WSSecurityEngineResult wser : wsSecurityEngineSignResults) {\n            \n                List<WSDataRef> sl = CastUtils.cast((List<?>) wser\n                        .get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n                if (sl != null) {\n                    if (sl.size() == 1\n                        && sl.get(0).getName().equals(new QName(WSConstants.SIG_NS, WSConstants.SIG_LN))) {\n                        //endorsing the signature so don't include\n                        break;\n                    }\n                    \n                    for (WSDataRef r : sl) {\n                        signed.add(r);\n                    }\n                }\n            }\n            \n            for (WSSecurityEngineResult wser : wsSecurityEngineEncResults) {\n                List<WSDataRef> el = CastUtils.cast((List<?>) wser\n                        .get(WSSecurityEngineResult.TAG_DATA_REF_URIS));\n\n                if (el != null) {\n                    for (WSDataRef r : el) {\n                        encrypted.add(r);\n                    }\n                }\n            }\n        }\n        \n        CryptoCoverageUtil.reconcileEncryptedSignedRefs(signed, encrypted);\n        \n        if (this.xPaths != null && !this.xPaths.isEmpty()) {\n            // XPathFactory and XPath are not thread-safe so we must recreate them\n            // each request.\n            final XPathFactory factory = XPathFactory.newInstance();\n            final XPath xpath = factory.newXPath();\n            \n            if (this.prefixMap != null) {\n                xpath.setNamespaceContext(new MapNamespaceContext(this.prefixMap));\n            }\n            \n            for (XPathExpression xPathExpression : this.xPaths) {\n                Collection<WSDataRef> refsToCheck = null;\n                \n                switch (xPathExpression.getType()) {\n                case SIGNED:\n                    refsToCheck = signed;\n                    break;\n                case ENCRYPTED:\n                    refsToCheck = encrypted;\n                    break;\n                default:\n                    throw new IllegalStateException(\"Unexpected crypto type: \" \n                            + xPathExpression.getType());\n                }\n                        \n                try {\n                    SOAPMessage saajDoc = message.getContent(SOAPMessage.class);\n                    Element documentElement = null;\n                    if (saajDoc != null && saajDoc.getSOAPPart() != null) {\n                        documentElement = saajDoc.getSOAPPart().getEnvelope();\n                    }\n                    \n                    CryptoCoverageUtil.checkCoverage(\n                            documentElement,\n                            refsToCheck,\n                            xpath, \n                            Arrays.asList(xPathExpression.getXPath()),\n                            xPathExpression.getType(),\n                            xPathExpression.getScope());\n                } catch (WSSecurityException e) {\n                    throw new SoapFault(\"No \" + xPathExpression.getType()\n                            + \" element found matching XPath \"\n                            + xPathExpression.getXPath(), Fault.FAULT_CODE_CLIENT);\n                } catch (SOAPException e) {\n                    throw new SoapFault(\"No \" + xPathExpression.getType()\n                            + \" element found matching XPath \"\n                            + xPathExpression.getXPath(), Fault.FAULT_CODE_CLIENT);\n                }\n            }\n        }\n    }","commit_id":"7aae8785c3d1b444b8602aba860ffbd0ad6d648a","url":"https://github.com/apache/cxf"},{"original_method":"private void parseHandlerResults(\n            WSHandlerResult rResult,\n            Message message,\n            AssertionInfoMap aim\n        ) {\n            List<WSSecurityEngineResult> signedResults = new ArrayList<WSSecurityEngineResult>();\n            WSSecurityUtil.fetchAllActionResults(\n                rResult.getResults(), WSConstants.SIGN, signedResults\n            );\n            \n            IssuedTokenPolicyValidator issuedValidator = \n                new IssuedTokenPolicyValidator(signedResults, message);\n            Collection<AssertionInfo> issuedAis = aim.get(SP12Constants.ISSUED_TOKEN);\n\n            for (AssertionWrapper assertionWrapper : findSamlTokenResults(rResult.getResults())) {\n                boolean valid = issuedValidator.validatePolicy(issuedAis, assertionWrapper);\n                if (valid) {\n                    SecurityToken token = createSecurityToken(assertionWrapper);\n                    getTokenStore(message).add(token);\n                    message.getExchange().remove(SecurityConstants.TOKEN);\n                    message.getExchange().put(SecurityConstants.TOKEN_ID, token.getId());\n                    return;\n                }\n            }\n            for (BinarySecurity binarySecurityToken : findBinarySecurityTokenResults(rResult.getResults())) {\n                boolean valid = issuedValidator.validatePolicy(issuedAis, binarySecurityToken);\n                if (valid) {\n                    SecurityToken token = createSecurityToken(binarySecurityToken);\n                    getTokenStore(message).add(token);\n                    message.getExchange().remove(SecurityConstants.TOKEN);\n                    message.getExchange().put(SecurityConstants.TOKEN_ID, token.getId());\n                    return;\n                }\n            }\n        }","id":91766,"modified_method":"private void parseHandlerResults(\n            WSHandlerResult rResult,\n            Message message,\n            AssertionInfoMap aim\n        ) {\n            List<WSSecurityEngineResult> signedResults = \n                WSS4JUtils.fetchAllActionResults(rResult.getResults(), WSConstants.SIGN);\n            \n            IssuedTokenPolicyValidator issuedValidator = \n                new IssuedTokenPolicyValidator(signedResults, message);\n            Collection<AssertionInfo> issuedAis = aim.get(SP12Constants.ISSUED_TOKEN);\n\n            for (AssertionWrapper assertionWrapper : findSamlTokenResults(rResult.getResults())) {\n                boolean valid = issuedValidator.validatePolicy(issuedAis, assertionWrapper);\n                if (valid) {\n                    SecurityToken token = createSecurityToken(assertionWrapper);\n                    getTokenStore(message).add(token);\n                    message.getExchange().remove(SecurityConstants.TOKEN);\n                    message.getExchange().put(SecurityConstants.TOKEN_ID, token.getId());\n                    return;\n                }\n            }\n            for (BinarySecurity binarySecurityToken : findBinarySecurityTokenResults(rResult.getResults())) {\n                boolean valid = issuedValidator.validatePolicy(issuedAis, binarySecurityToken);\n                if (valid) {\n                    SecurityToken token = createSecurityToken(binarySecurityToken);\n                    getTokenStore(message).add(token);\n                    message.getExchange().remove(SecurityConstants.TOKEN);\n                    message.getExchange().put(SecurityConstants.TOKEN_ID, token.getId());\n                    return;\n                }\n            }\n        }","commit_id":"7aae8785c3d1b444b8602aba860ffbd0ad6d648a","url":"https://github.com/apache/cxf"},{"original_method":"private static boolean processInjectedFile(PsiElement element, final TextOccurenceProcessor processor, final StringSearcher searcher) {\n    PsiLanguageInjectionHost injectionHost = InjectedLanguageUtil.findInjectionHost(element);\n    if (injectionHost == null) return true;\n    List<Pair<PsiElement,TextRange>> list = injectionHost.getInjectedPsi();\n    if (list == null) return true;\n    for (Pair<PsiElement, TextRange> pair : list) {\n      PsiElement injected = pair.getFirst();\n      if (!processElementsContainingWordInElement(processor, injected, searcher)) return false;\n    }\n    return true;\n  }","id":91767,"modified_method":"private static Boolean processInjectedFile(PsiElement element, final TextOccurenceProcessor processor, final StringSearcher searcher) {\n    PsiLanguageInjectionHost injectionHost = InjectedLanguageUtil.findInjectionHost(element);\n    if (injectionHost == null) return null;\n    List<Pair<PsiElement,TextRange>> list = injectionHost.getInjectedPsi();\n    if (list == null) return null;\n    for (Pair<PsiElement, TextRange> pair : list) {\n      PsiElement injected = pair.getFirst();\n      if (!processElementsContainingWordInElement(processor, injected, searcher)) return Boolean.FALSE;\n    }\n    return Boolean.TRUE;\n  }","commit_id":"50c9f38f599abf653aa4b317b8b6574d817d17c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean processElementsContainingWordInElement(TextOccurenceProcessor processor,\n                                                               PsiElement scope,\n                                                               StringSearcher searcher) {\n    ProgressManager.getInstance().checkCanceled();\n    char[] buffer = scope.textToCharArray();\n    int startOffset = 0;\n    int endOffset = buffer.length;\n    final int patternLength = searcher.getPatternLength();\n\n    final int scopeStartOffset = scope.getTextRange().getStartOffset();\n    final ASTNode scopeNode = scope.getNode();\n    do {\n      int i = searchWord(buffer, startOffset, endOffset, searcher);\n      if (i >= 0) {\n        if (scopeNode != null) {\n          LeafElement leafNode = (LeafElement)scopeNode.findLeafElementAt(i);\n          if (leafNode == null) return true;\n          int start = i - leafNode.getStartOffset() + scopeStartOffset;\n          LOG.assertTrue(start >= 0);\n          boolean contains = leafNode.getTextLength() - start >= patternLength;\n          if (contains && !processor.execute(leafNode.getPsi(), start)) return false;\n          if (!processInjectedFile(leafNode.getPsi(), processor, searcher)) return false;\n          TreeElement prev = leafNode;\n          CompositeElement run = leafNode.getTreeParent();\n          while (run != null) {\n            start += prev.getStartOffsetInParent();\n            contains |= run.getTextLength() - start >= patternLength;  //do not compute if already contains\n            if (contains && !processor.execute(run.getPsi(), start)) return false;\n            if (!processInjectedFile(run.getPsi(), processor, searcher)) return false;\n            prev = run;\n            if (run == scopeNode) break;\n            run = run.getTreeParent();\n          }\n          assert run == scopeNode;\n        }\n        else {\n          PsiElement leafElement;\n          if (scope instanceof PsiFile) {\n            leafElement = ((PsiFile)scope).getViewProvider().findElementAt(i, scope.getLanguage());\n          }\n          else {\n            leafElement = scope.findElementAt(i);\n          }\n          if (leafElement == null) return true;\n          int start = i - leafElement.getTextRange().getStartOffset() + scopeStartOffset;\n          if (start < 0) {\n            LOG.assertTrue(start >= 0, \"i=\" + i + \" scopeStartOffset=\" + scopeStartOffset + \" leafElement=\" + leafElement.toString() + \" \" +\n                                       leafElement.getTextRange().getStartOffset() + \" scope=\" + scope.toString());\n          }\n          boolean contains = leafElement.getTextLength() - start >= patternLength;\n          if (contains && !processor.execute(leafElement, start)) return false;\n          if (!processInjectedFile(leafElement, processor, searcher)) return false;\n          PsiElement prev = leafElement;\n          PsiElement run = leafElement.getParent();\n          while (run != null) {\n            start += prev.getStartOffsetInParent();\n            contains |= run.getTextLength() - start >= patternLength;  //do not compute if already contains\n            if (contains && !processor.execute(run, start)) return false;\n            if (!processInjectedFile(run, processor, searcher)) return false;\n            prev = run;\n            if (run == scope) break;\n            run = run.getParent();\n          }\n          assert run == scope;\n        }\n\n        startOffset = i + 1;\n      } else {\n        return true;\n      }\n    }\n    while (startOffset < endOffset);\n\n    return true;\n  }","id":91768,"modified_method":"public static boolean processElementsContainingWordInElement(TextOccurenceProcessor processor,\n                                                               PsiElement scope,\n                                                               StringSearcher searcher) {\n    ProgressManager.getInstance().checkCanceled();\n    char[] buffer = scope.textToCharArray();\n    int startOffset = 0;\n    int endOffset = buffer.length;\n    final int patternLength = searcher.getPatternLength();\n\n    final int scopeStartOffset = scope.getTextRange().getStartOffset();\n    final ASTNode scopeNode = scope.getNode();\n    do {\n      int i = searchWord(buffer, startOffset, endOffset, searcher);\n      if (i >= 0) {\n        if (scopeNode != null) {\n          LeafElement leafNode = (LeafElement)scopeNode.findLeafElementAt(i);\n          if (leafNode == null) return true;\n          int start = i - leafNode.getStartOffset() + scopeStartOffset;\n          LOG.assertTrue(start >= 0);\n          boolean contains = leafNode.getTextLength() - start >= patternLength;\n          if (contains && !processor.execute(leafNode.getPsi(), start)) return false;\n          Boolean result = processInjectedFile(leafNode.getPsi(), processor, searcher);\n          if (result != null && !result.booleanValue()) return false;\n          boolean injectedFound = result != null;\n          TreeElement prev = leafNode;\n          CompositeElement run = leafNode.getTreeParent();\n          while (run != null) {\n            start += prev.getStartOffsetInParent();\n            contains |= run.getTextLength() - start >= patternLength;  //do not compute if already contains\n            if (contains && !processor.execute(run.getPsi(), start)) return false;\n            if (!injectedFound) {\n              result = processInjectedFile(run.getPsi(), processor, searcher);\n              if (result != null && !result.booleanValue()) return false;\n              injectedFound = result != null;\n            }\n            prev = run;\n            if (run == scopeNode) break;\n            run = run.getTreeParent();\n          }\n          assert run == scopeNode;\n        }\n        else {\n          PsiElement leafElement;\n          if (scope instanceof PsiFile) {\n            leafElement = ((PsiFile)scope).getViewProvider().findElementAt(i, scope.getLanguage());\n          }\n          else {\n            leafElement = scope.findElementAt(i);\n          }\n          if (leafElement == null) return true;\n          int start = i - leafElement.getTextRange().getStartOffset() + scopeStartOffset;\n          if (start < 0) {\n            LOG.assertTrue(start >= 0, \"i=\" + i + \" scopeStartOffset=\" + scopeStartOffset + \" leafElement=\" + leafElement.toString() + \" \" +\n                                       leafElement.getTextRange().getStartOffset() + \" scope=\" + scope.toString());\n          }\n          boolean contains = leafElement.getTextLength() - start >= patternLength;\n          if (contains && !processor.execute(leafElement, start)) return false;\n          Boolean result = processInjectedFile(leafElement, processor, searcher);\n          if (result != null && !result.booleanValue()) return false;\n          boolean injectedFound = result != null;\n          PsiElement prev = leafElement;\n          PsiElement run = leafElement.getParent();\n          while (run != null) {\n            start += prev.getStartOffsetInParent();\n            contains |= run.getTextLength() - start >= patternLength;  //do not compute if already contains\n            if (contains && !processor.execute(run, start)) return false;\n            if (!injectedFound) {\n              result = processInjectedFile(run, processor, searcher);\n              if (result != null && !result.booleanValue()) return false;\n              injectedFound = result != null;\n            }\n            prev = run;\n            if (run == scope) break;\n            run = run.getParent();\n          }\n          assert run == scope;\n        }\n\n        startOffset = i + 1;\n      } else {\n        return true;\n      }\n    }\n    while (startOffset < endOffset);\n\n    return true;\n  }","commit_id":"50c9f38f599abf653aa4b317b8b6574d817d17c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void fireEvictCache() {\n        if (canEvict.compareAndSet(true, false)) {\n            try {\n                context.getExecutionService().execute(new Runnable() {\n                    public void run() {\n                        try {\n                            TreeSet<NearCacheRecord> records = new TreeSet<NearCacheRecord>(selectedComparator);\n                            records.addAll(cache.values());\n                            int evictSize = cache.size() * EVICTION_PERCENTAGE / HUNDRED_PERCENTAGE;\n                            int i = 0;\n                            for (NearCacheRecord record : records) {\n                                cache.remove(record.getKey());\n                                if (++i > evictSize) {\n                                    break;\n                                }\n                            }\n                        } finally {\n                            canEvict.set(true);\n                        }\n                    }\n                });\n            } catch (RejectedExecutionException e) {\n                canEvict.set(true);\n            } catch (Exception e) {\n                throw ExceptionUtil.rethrow(e);\n            }\n        }\n    }","id":91769,"modified_method":"private void fireEvictCache() {\n        if (canEvict.compareAndSet(true, false)) {\n            try {\n                final ClientExecutionService executionService = context.getExecutionService();\n                executionService.execute(new Runnable() {\n                    public void run() {\n                        try {\n                            TreeSet<NearCacheRecord> records = new TreeSet<NearCacheRecord>(selectedComparator);\n                            records.addAll(cache.values());\n                            int evictSize = cache.size() * EVICTION_PERCENTAGE / HUNDRED_PERCENTAGE;\n                            int i = 0;\n                            for (NearCacheRecord record : records) {\n                                cache.remove(record.getKey());\n                                if (++i > evictSize) {\n                                    break;\n                                }\n                            }\n                        } finally {\n                            canEvict.set(true);\n                        }\n                        if (cache.size() >= maxSize && canEvict.compareAndSet(true, false)) {\n                            executionService.execute(this);\n                        }\n                    }\n                });\n            } catch (RejectedExecutionException e) {\n                canEvict.set(true);\n            } catch (Exception e) {\n                throw ExceptionUtil.rethrow(e);\n            }\n        }\n    }","commit_id":"d1bd14be6b91346f304f9d5ae7f7405630fe0365","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidationWithLFU() throws Exception {\n        final String mapName = randomMapName(NEAR_CACHE_LFU_WITH_MAX_SIZE);\n        final IMap map = client.getMap(mapName);\n\n        final int mapSize = MAX_CACHE_SIZE * 2;\n\n        populateNearCache(map, mapSize);\n\n        final NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                assertTrue(MAX_CACHE_SIZE > stats.getOwnedEntryCount());\n            }\n        });\n    }","id":91770,"modified_method":"@Test\n    public void testNearCacheInvalidationWithLFU() throws Exception {\n        final String mapName = randomMapName(NEAR_CACHE_LFU_WITH_MAX_SIZE);\n        final IMap map = client.getMap(mapName);\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                final NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n                assertTrue(MAX_CACHE_SIZE > stats.getOwnedEntryCount());\n            }\n        });\n    }","commit_id":"d1bd14be6b91346f304f9d5ae7f7405630fe0365","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@BeforeClass\n    public static void setup() throws Exception {\n        h1 = Hazelcast.newHazelcastInstance();\n        h2 = Hazelcast.newHazelcastInstance();\n\n        ClientConfig clientConfig = new ClientConfig();\n\n        NearCacheConfig basicConfigNoInvalidation = new NearCacheConfig();\n        basicConfigNoInvalidation.setInMemoryFormat(InMemoryFormat.OBJECT);\n        basicConfigNoInvalidation.setName(NEAR_CACHE_WITH_NO_INVALIDATION + \"*\");\n        basicConfigNoInvalidation.setInvalidateOnChange(false);\n        clientConfig.addNearCacheConfig(basicConfigNoInvalidation);\n\n        NearCacheConfig maxSizeConfig = new NearCacheConfig();\n        maxSizeConfig.setMaxSize(MAX_CACHE_SIZE);\n        maxSizeConfig.setInvalidateOnChange(false);\n        maxSizeConfig.setName(NEAR_CACHE_WITH_MAX_SIZE + \"*\");\n        clientConfig.addNearCacheConfig(maxSizeConfig);\n\n        NearCacheConfig ttlConfig = new NearCacheConfig();\n        ttlConfig.setName(NEAR_CACHE_WITH_TTL + \"*\");\n        ttlConfig.setInvalidateOnChange(false);\n        ttlConfig.setTimeToLiveSeconds(MAX_TTL_SECONDS);\n        clientConfig.addNearCacheConfig(ttlConfig);\n\n        NearCacheConfig idleConfig = new NearCacheConfig();\n        idleConfig.setName(NEAR_CACHE_WITH_IDLE + \"*\");\n        idleConfig.setInvalidateOnChange(false);\n        idleConfig.setMaxIdleSeconds(MAX_IDLE_SECONDS);\n        clientConfig.addNearCacheConfig(idleConfig);\n\n\n        NearCacheConfig longIdleConfig = new NearCacheConfig();\n        idleConfig.setName(NEAR_CACHE_WITH_LONG_MAX_IDLE_TIME + \"*\");\n        idleConfig.setInvalidateOnChange(true);\n        idleConfig.setMaxIdleSeconds(LONG_MAX_IDLE_SECONDS);\n        clientConfig.addNearCacheConfig(longIdleConfig);\n\n        NearCacheConfig invalidateConfig = new NearCacheConfig();\n        invalidateConfig.setName(NEAR_CACHE_WITH_INVALIDATION + \"*\");\n        invalidateConfig.setInvalidateOnChange(true);\n        clientConfig.addNearCacheConfig(invalidateConfig);\n\n        NearCacheConfig lfuMaxSizeConfig = new NearCacheConfig();\n        lfuMaxSizeConfig.setName(NEAR_CACHE_LFU_WITH_MAX_SIZE + \"*\");\n        lfuMaxSizeConfig.setInvalidateOnChange(true);\n        lfuMaxSizeConfig.setMaxSize(MAX_CACHE_SIZE);\n        lfuMaxSizeConfig.setEvictionPolicy(\"LFU\");\n        clientConfig.addNearCacheConfig(lfuMaxSizeConfig);\n\n        client = HazelcastClient.newHazelcastClient(clientConfig);\n    }","id":91771,"modified_method":"@BeforeClass\n    public static void setup() throws Exception {\n        h1 = Hazelcast.newHazelcastInstance();\n        h2 = Hazelcast.newHazelcastInstance();\n\n        ClientConfig clientConfig = new ClientConfig();\n\n        NearCacheConfig basicConfigNoInvalidation = new NearCacheConfig();\n        basicConfigNoInvalidation.setInMemoryFormat(InMemoryFormat.OBJECT);\n        basicConfigNoInvalidation.setName(NEAR_CACHE_WITH_NO_INVALIDATION + \"*\");\n        basicConfigNoInvalidation.setInvalidateOnChange(false);\n        clientConfig.addNearCacheConfig(basicConfigNoInvalidation);\n\n        NearCacheConfig maxSizeConfig = new NearCacheConfig();\n        maxSizeConfig.setMaxSize(MAX_CACHE_SIZE);\n        maxSizeConfig.setInvalidateOnChange(false);\n        maxSizeConfig.setName(NEAR_CACHE_WITH_MAX_SIZE + \"*\");\n        clientConfig.addNearCacheConfig(maxSizeConfig);\n\n        NearCacheConfig ttlConfig = new NearCacheConfig();\n        ttlConfig.setName(NEAR_CACHE_WITH_TTL + \"*\");\n        ttlConfig.setInvalidateOnChange(false);\n        ttlConfig.setTimeToLiveSeconds(MAX_TTL_SECONDS);\n        clientConfig.addNearCacheConfig(ttlConfig);\n\n        NearCacheConfig idleConfig = new NearCacheConfig();\n        idleConfig.setName(NEAR_CACHE_WITH_IDLE + \"*\");\n        idleConfig.setInvalidateOnChange(false);\n        idleConfig.setMaxIdleSeconds(MAX_IDLE_SECONDS);\n        clientConfig.addNearCacheConfig(idleConfig);\n\n\n        NearCacheConfig longIdleConfig = new NearCacheConfig();\n        idleConfig.setName(NEAR_CACHE_WITH_LONG_MAX_IDLE_TIME + \"*\");\n        idleConfig.setInvalidateOnChange(true);\n        idleConfig.setMaxIdleSeconds(LONG_MAX_IDLE_SECONDS);\n        clientConfig.addNearCacheConfig(longIdleConfig);\n\n        NearCacheConfig invalidateConfig = new NearCacheConfig();\n        invalidateConfig.setName(NEAR_CACHE_WITH_INVALIDATION + \"*\");\n        invalidateConfig.setInvalidateOnChange(true);\n        clientConfig.addNearCacheConfig(invalidateConfig);\n\n        NearCacheConfig lfuMaxSizeConfig = new NearCacheConfig();\n        lfuMaxSizeConfig.setName(NEAR_CACHE_LFU_WITH_MAX_SIZE + \"*\");\n        lfuMaxSizeConfig.setInvalidateOnChange(true);\n        lfuMaxSizeConfig.setMaxSize(MAX_CACHE_SIZE);\n        lfuMaxSizeConfig.setEvictionPolicy(\"LFU\");\n        clientConfig.addNearCacheConfig(lfuMaxSizeConfig);\n\n        NearCacheConfig lruMaxSizeConfig = new NearCacheConfig();\n        lruMaxSizeConfig.setName(NEAR_CACHE_LRU_WITH_MAX_SIZE + \"*\");\n        lruMaxSizeConfig.setInvalidateOnChange(true);\n        lruMaxSizeConfig.setMaxSize(MAX_CACHE_SIZE);\n        lruMaxSizeConfig.setEvictionPolicy(\"LRU\");\n        clientConfig.addNearCacheConfig(lruMaxSizeConfig);\n\n\n        NearCacheConfig randomMaxSizeConfig = new NearCacheConfig();\n        randomMaxSizeConfig.setName(NEAR_CACHE_RANDOM_WITH_MAX_SIZE + \"*\");\n        randomMaxSizeConfig.setInvalidateOnChange(true);\n        randomMaxSizeConfig.setMaxSize(MAX_CACHE_SIZE);\n        randomMaxSizeConfig.setEvictionPolicy(\"RANDOM\");\n        clientConfig.addNearCacheConfig(randomMaxSizeConfig);\n\n        NearCacheConfig noneMaxSizeConfig = new NearCacheConfig();\n        noneMaxSizeConfig.setName(NEAR_CACHE_NONE_WITH_MAX_SIZE + \"*\");\n        noneMaxSizeConfig.setInvalidateOnChange(true);\n        noneMaxSizeConfig.setMaxSize(MAX_CACHE_SIZE);\n        noneMaxSizeConfig.setEvictionPolicy(\"NONE\");\n        clientConfig.addNearCacheConfig(noneMaxSizeConfig);\n\n        client = HazelcastClient.newHazelcastClient(clientConfig);\n    }","commit_id":"d1bd14be6b91346f304f9d5ae7f7405630fe0365","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void fireTtlCleanup() {\n        if (Clock.currentTimeMillis() < (lastCleanup + CLEANUP_INTERVAL)) {\n            return;\n        }\n\n        if (canCleanUp.compareAndSet(true, false)) {\n            try {\n                nodeEngine.getExecutionService().execute(\"hz:near-cache\", new Runnable() {\n                    public void run() {\n                        try {\n                            lastCleanup = Clock.currentTimeMillis();\n                            for (Map.Entry<Data, NearCacheRecord> entry : cache.entrySet()) {\n                                if (entry.getValue().isExpired(maxIdleMillis, timeToLiveMillis)) {\n                                    final Data key = entry.getKey();\n                                    final NearCacheRecord record = cache.remove(key);\n                                    //if a mapping exists.\n                                    if (record != null) {\n                                        updateSizeEstimator(-calculateCost(record));\n                                    }\n                                }\n                            }\n                        } finally {\n                            canCleanUp.set(true);\n                        }\n                    }\n                });\n            } catch (RejectedExecutionException e) {\n                canCleanUp.set(true);\n            } catch (Exception e) {\n                throw ExceptionUtil.rethrow(e);\n            }\n        }\n    }","id":91772,"modified_method":"private void fireTtlCleanup() {\n        if (Clock.currentTimeMillis() < (lastCleanup + CLEANUP_INTERVAL)) {\n            return;\n        }\n\n        if (canCleanUp.compareAndSet(true, false)) {\n            try {\n                nodeEngine.getExecutionService().execute(NEAR_CACHE_EXECUTOR_NAME, new Runnable() {\n                    public void run() {\n                        try {\n                            lastCleanup = Clock.currentTimeMillis();\n                            for (Map.Entry<Data, NearCacheRecord> entry : cache.entrySet()) {\n                                if (entry.getValue().isExpired(maxIdleMillis, timeToLiveMillis)) {\n                                    final Data key = entry.getKey();\n                                    final NearCacheRecord record = cache.remove(key);\n                                    //if a mapping exists.\n                                    if (record != null) {\n                                        updateSizeEstimator(-calculateCost(record));\n                                    }\n                                }\n                            }\n                        } finally {\n                            canCleanUp.set(true);\n                        }\n                    }\n                });\n            } catch (RejectedExecutionException e) {\n                canCleanUp.set(true);\n            } catch (Exception e) {\n                throw ExceptionUtil.rethrow(e);\n            }\n        }\n    }","commit_id":"d1bd14be6b91346f304f9d5ae7f7405630fe0365","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void fireEvictCache() {\n        if (canEvict.compareAndSet(true, false)) {\n            try {\n                nodeEngine.getExecutionService().execute(\"hz:near-cache\", new Runnable() {\n                    public void run() {\n                        try {\n                            TreeSet<NearCacheRecord> records = new TreeSet<NearCacheRecord>(selectedComparator);\n                            records.addAll(cache.values());\n                            int evictSize = cache.size() * EVICTION_PERCENTAGE / HUNDRED_PERCENT;\n                            int i = 0;\n                            for (NearCacheRecord record : records) {\n                                cache.remove(record.getKey());\n                                updateSizeEstimator(-calculateCost(record));\n                                if (++i > evictSize) {\n                                    break;\n                                }\n                            }\n                        } finally {\n                            canEvict.set(true);\n                        }\n                    }\n                });\n            } catch (RejectedExecutionException e) {\n                canEvict.set(true);\n            } catch (Exception e) {\n                throw ExceptionUtil.rethrow(e);\n            }\n        }\n    }","id":91773,"modified_method":"private void fireEvictCache() {\n        if (canEvict.compareAndSet(true, false)) {\n            try {\n                final ExecutionService executionService = nodeEngine.getExecutionService();\n                executionService.execute(NEAR_CACHE_EXECUTOR_NAME, new Runnable() {\n                    public void run() {\n                        try {\n                            TreeSet<NearCacheRecord> records = new TreeSet<NearCacheRecord>(selectedComparator);\n                            records.addAll(cache.values());\n                            int evictSize = cache.size() * EVICTION_PERCENTAGE / HUNDRED_PERCENT;\n                            int i = 0;\n                            for (NearCacheRecord record : records) {\n                                cache.remove(record.getKey());\n                                updateSizeEstimator(-calculateCost(record));\n                                if (++i > evictSize) {\n                                    break;\n                                }\n                            }\n                        } finally {\n                            canEvict.set(true);\n                        }\n\n                        if (cache.size() >= maxSize && canEvict.compareAndSet(true, false)) {\n                            executionService.execute(NEAR_CACHE_EXECUTOR_NAME, this);\n                        }\n                    }\n                });\n            } catch (RejectedExecutionException e) {\n                canEvict.set(true);\n            } catch (Exception e) {\n                throw ExceptionUtil.rethrow(e);\n            }\n        }\n    }","commit_id":"d1bd14be6b91346f304f9d5ae7f7405630fe0365","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Near-cache has its own eviction/expiration mechanism,\n     * eviction/expiration on IMap should not force any near-cache eviction/expiration.\n     * Except a direct call to {@link com.hazelcast.core.IMap#evict(Object)}\n     * and {@link com.hazelcast.core.IMap#evictAll()}, those direct calls also evicts near-caches.\n     */\n    @Test\n    public void testNearCacheEntriesNotExpired_afterIMapExpiration() throws Exception {\n        final String mapName = randomMapName();\n        final Config config = createNearCachedMapConfig(mapName);\n        final HazelcastInstance instance = createHazelcastInstance(config);\n        final IMap<Integer, Integer> map = instance.getMap(mapName);\n        final int mapSize = 3;\n        final CountDownLatch latch = new CountDownLatch(mapSize);\n\n        addListener(map, latch);\n        populateMapWithExpirableEnties(map, mapSize);\n        populateNearCache(map, mapSize);\n\n        waitUntilEvictionEventsReceived(latch);\n        assertNearCacheSize(mapSize, mapName, map);\n    }","id":91774,"modified_method":"/**\n     * Near-cache has its own eviction/expiration mechanism,\n     * eviction/expiration on IMap should not force any near-cache eviction/expiration.\n     * Except a direct call to {@link com.hazelcast.core.IMap#evict(Object)}\n     * and {@link com.hazelcast.core.IMap#evictAll()}, those direct calls also evicts near-caches.\n     */\n    @Test\n    public void testNearCacheEntriesNotExpired_afterIMapExpiration() throws Exception {\n        final String mapName = randomMapName();\n        final Config config = createNearCachedMapConfig(mapName);\n        final HazelcastInstance instance = createHazelcastInstance(config);\n        final IMap<Integer, Integer> map = instance.getMap(mapName);\n        final int mapSize = 3;\n        final CountDownLatch latch = new CountDownLatch(mapSize);\n\n        addListener(map, latch);\n        populateMapWithExpirableEntries(map, mapSize, 3, TimeUnit.SECONDS);\n        pullEntriesToNearCache(map, mapSize);\n\n        waitUntilEvictionEventsReceived(latch);\n        assertNearCacheSize(mapSize, mapName, map);\n    }","commit_id":"d1bd14be6b91346f304f9d5ae7f7405630fe0365","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void populateNearCache(IMap<Integer, Integer> map, int mapSize) {\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n        }\n    }","id":91775,"modified_method":"private void populateMap(IMap<Integer, Integer> map, int mapSize) {\n        for (int i = 0; i < mapSize; i++) {\n            map.put(i, i);\n        }\n    }","commit_id":"d1bd14be6b91346f304f9d5ae7f7405630fe0365","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void populateMapWithExpirableEnties(IMap<Integer, Integer> map, int mapSize) {\n        for (int i = 0; i < mapSize; i++) {\n            map.put(i, i, 3, TimeUnit.SECONDS);\n        }\n    }","id":91776,"modified_method":"private void populateMapWithExpirableEntries(IMap<Integer, Integer> map, int mapSize, long ttl, TimeUnit timeunit) {\n        for (int i = 0; i < mapSize; i++) {\n            map.put(i, i, ttl, timeunit);\n        }\n    }","commit_id":"d1bd14be6b91346f304f9d5ae7f7405630fe0365","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidationWithLFU() throws Exception {\n        int mapSize = 2000;\n        final int maxSize = 1000;\n        String mapName = randomMapName();\n\n        Config config = new Config();\n        final NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        nearCacheConfig.setCacheLocalEntries(true);\n        nearCacheConfig.setEvictionPolicy(\"LFU\");\n        nearCacheConfig.setMaxSize(maxSize);\n        config.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);\n\n        HazelcastInstance instance1 = createHazelcastInstance(config);\n\n        IMap<Integer, Integer> map = instance1.getMap(mapName);\n\n        populateNearCache(map, mapSize);\n\n        final NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                assertTrue(maxSize > stats.getOwnedEntryCount());\n            }\n        });\n    }","id":91777,"modified_method":"@Test\n    public void testNearCacheInvalidation_WithLFU_whenMaxSizeExceeded() throws Exception {\n        int mapSize = 2000;\n        final int maxSize = 1000;\n        final IMap map = getMapConfiguredWithMaxSizeAndPolicy(\"LFU\", maxSize);\n\n        populateMap(map, mapSize);\n        pullEntriesToNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n                assertTrue(maxSize > stats.getOwnedEntryCount());\n            }\n        });\n    }","commit_id":"d1bd14be6b91346f304f9d5ae7f7405630fe0365","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void fireEvictCache() {\n        if (canEvict.compareAndSet(true, false)) {\n            try {\n                context.getExecutionService().execute(new Runnable() {\n                    public void run() {\n                        try {\n                            TreeSet<CacheRecord<K>> records = new TreeSet<CacheRecord<K>>(selectedComparator);\n                            records.addAll(cache.values());\n                            int evictSize = cache.size() * EVICTION_PERCENTAGE / HUNDRED_PERCENTAGE;\n                            int i = 0;\n                            for (CacheRecord<K> record : records) {\n                                cache.remove(record.key);\n                                if (++i > evictSize) {\n                                    break;\n                                }\n                            }\n                        } finally {\n                            canEvict.set(true);\n                        }\n                    }\n                });\n            } catch (RejectedExecutionException e) {\n                canEvict.set(true);\n            } catch (Exception e) {\n                throw ExceptionUtil.rethrow(e);\n            }\n        }\n    }","id":91778,"modified_method":"private void fireEvictCache() {\n        if (canEvict.compareAndSet(true, false)) {\n            try {\n                final ClientExecutionService executionService = context.getExecutionService();\n                executionService.execute(new Runnable() {\n                    public void run() {\n                        try {\n                            TreeSet<CacheRecord<K>> records = new TreeSet<CacheRecord<K>>(selectedComparator);\n                            records.addAll(cache.values());\n                            int evictSize = cache.size() * EVICTION_PERCENTAGE / HUNDRED_PERCENTAGE;\n                            int i = 0;\n                            for (CacheRecord<K> record : records) {\n                                cache.remove(record.key);\n                                if (++i > evictSize) {\n                                    break;\n                                }\n                            }\n                        } finally {\n                            canEvict.set(true);\n                        }\n                        if (cache.size() >= maxSize && canEvict.compareAndSet(true, false)) {\n                            executionService.execute(this);\n                        }\n                    }\n                });\n            } catch (RejectedExecutionException e) {\n                canEvict.set(true);\n            } catch (Exception e) {\n                throw ExceptionUtil.rethrow(e);\n            }\n        }\n    }","commit_id":"d9c3dcf32e462e2da208b7ef24b3298e6826a0a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@BeforeClass\n    public static void setup() throws Exception {\n        h1 = Hazelcast.newHazelcastInstance();\n        h2 = Hazelcast.newHazelcastInstance();\n\n        ClientConfig clientConfig = new ClientConfig();\n\n        NearCacheConfig basicConfigNoInvalidation = new NearCacheConfig();\n        basicConfigNoInvalidation.setInMemoryFormat(InMemoryFormat.OBJECT);\n        basicConfigNoInvalidation.setName(NEAR_CACHE_WITH_NO_INVALIDATION + \"*\");\n        basicConfigNoInvalidation.setInvalidateOnChange(false);\n        clientConfig.addNearCacheConfig(basicConfigNoInvalidation);\n\n        NearCacheConfig maxSizeConfig = new NearCacheConfig();\n        maxSizeConfig.setMaxSize(MAX_CACHE_SIZE);\n        maxSizeConfig.setInvalidateOnChange(false);\n        maxSizeConfig.setName(NEAR_CACHE_WITH_MAX_SIZE + \"*\");\n        clientConfig.addNearCacheConfig(maxSizeConfig);\n\n        NearCacheConfig ttlConfig = new NearCacheConfig();\n        ttlConfig.setName(NEAR_CACHE_WITH_TTL + \"*\");\n        ttlConfig.setInvalidateOnChange(false);\n        ttlConfig.setTimeToLiveSeconds(MAX_TTL_SECONDS);\n        clientConfig.addNearCacheConfig(ttlConfig);\n\n        NearCacheConfig idleConfig = new NearCacheConfig();\n        idleConfig.setName(NEAR_CACHE_WITH_IDLE + \"*\");\n        idleConfig.setInvalidateOnChange(false);\n        idleConfig.setMaxIdleSeconds(MAX_IDLE_SECONDS);\n        clientConfig.addNearCacheConfig(idleConfig);\n\n\n        NearCacheConfig longIdleConfig = new NearCacheConfig();\n        idleConfig.setName(NEAR_CACHE_WITH_LONG_MAX_IDLE_TIME + \"*\");\n        idleConfig.setInvalidateOnChange(true);\n        idleConfig.setMaxIdleSeconds(LONG_MAX_IDLE_SECONDS);\n        clientConfig.addNearCacheConfig(longIdleConfig);\n\n        NearCacheConfig invalidateConfig = new NearCacheConfig();\n        invalidateConfig.setName(NEAR_CACHE_WITH_INVALIDATION + \"*\");\n        invalidateConfig.setInvalidateOnChange(true);\n        clientConfig.addNearCacheConfig(invalidateConfig);\n\n        NearCacheConfig lfuMaxSizeConfig = new NearCacheConfig();\n        lfuMaxSizeConfig.setName(NEAR_CACHE_LFU_WITH_MAX_SIZE + \"*\");\n        lfuMaxSizeConfig.setInvalidateOnChange(true);\n        lfuMaxSizeConfig.setMaxSize(MAX_CACHE_SIZE);\n        lfuMaxSizeConfig.setEvictionPolicy(\"LFU\");\n        clientConfig.addNearCacheConfig(lfuMaxSizeConfig);\n\n        client = HazelcastClient.newHazelcastClient(clientConfig);\n    }","id":91779,"modified_method":"@BeforeClass\n    public static void setup() throws Exception {\n        h1 = Hazelcast.newHazelcastInstance();\n        h2 = Hazelcast.newHazelcastInstance();\n\n        ClientConfig clientConfig = new ClientConfig();\n\n        NearCacheConfig basicConfigNoInvalidation = new NearCacheConfig();\n        basicConfigNoInvalidation.setInMemoryFormat(InMemoryFormat.OBJECT);\n        basicConfigNoInvalidation.setName(NEAR_CACHE_WITH_NO_INVALIDATION + \"*\");\n        basicConfigNoInvalidation.setInvalidateOnChange(false);\n        clientConfig.addNearCacheConfig(basicConfigNoInvalidation);\n\n        NearCacheConfig maxSizeConfig = new NearCacheConfig();\n        maxSizeConfig.setMaxSize(MAX_CACHE_SIZE);\n        maxSizeConfig.setInvalidateOnChange(false);\n        maxSizeConfig.setName(NEAR_CACHE_WITH_MAX_SIZE + \"*\");\n        clientConfig.addNearCacheConfig(maxSizeConfig);\n\n        NearCacheConfig ttlConfig = new NearCacheConfig();\n        ttlConfig.setName(NEAR_CACHE_WITH_TTL + \"*\");\n        ttlConfig.setInvalidateOnChange(false);\n        ttlConfig.setTimeToLiveSeconds(MAX_TTL_SECONDS);\n        clientConfig.addNearCacheConfig(ttlConfig);\n\n        NearCacheConfig idleConfig = new NearCacheConfig();\n        idleConfig.setName(NEAR_CACHE_WITH_IDLE + \"*\");\n        idleConfig.setInvalidateOnChange(false);\n        idleConfig.setMaxIdleSeconds(MAX_IDLE_SECONDS);\n        clientConfig.addNearCacheConfig(idleConfig);\n\n\n        NearCacheConfig longIdleConfig = new NearCacheConfig();\n        idleConfig.setName(NEAR_CACHE_WITH_LONG_MAX_IDLE_TIME + \"*\");\n        idleConfig.setInvalidateOnChange(true);\n        idleConfig.setMaxIdleSeconds(LONG_MAX_IDLE_SECONDS);\n        clientConfig.addNearCacheConfig(longIdleConfig);\n\n        NearCacheConfig invalidateConfig = new NearCacheConfig();\n        invalidateConfig.setName(NEAR_CACHE_WITH_INVALIDATION + \"*\");\n        invalidateConfig.setInvalidateOnChange(true);\n        clientConfig.addNearCacheConfig(invalidateConfig);\n\n        NearCacheConfig lfuMaxSizeConfig = new NearCacheConfig();\n        lfuMaxSizeConfig.setName(NEAR_CACHE_LFU_WITH_MAX_SIZE + \"*\");\n        lfuMaxSizeConfig.setInvalidateOnChange(true);\n        lfuMaxSizeConfig.setMaxSize(MAX_CACHE_SIZE);\n        lfuMaxSizeConfig.setEvictionPolicy(\"LFU\");\n        clientConfig.addNearCacheConfig(lfuMaxSizeConfig);\n\n        NearCacheConfig lruMaxSizeConfig = new NearCacheConfig();\n        lruMaxSizeConfig.setName(NEAR_CACHE_LRU_WITH_MAX_SIZE + \"*\");\n        lruMaxSizeConfig.setInvalidateOnChange(true);\n        lruMaxSizeConfig.setMaxSize(MAX_CACHE_SIZE);\n        lruMaxSizeConfig.setEvictionPolicy(\"LRU\");\n        clientConfig.addNearCacheConfig(lruMaxSizeConfig);\n\n\n        NearCacheConfig randomMaxSizeConfig = new NearCacheConfig();\n        randomMaxSizeConfig.setName(NEAR_CACHE_RANDOM_WITH_MAX_SIZE + \"*\");\n        randomMaxSizeConfig.setInvalidateOnChange(true);\n        randomMaxSizeConfig.setMaxSize(MAX_CACHE_SIZE);\n        randomMaxSizeConfig.setEvictionPolicy(\"RANDOM\");\n        clientConfig.addNearCacheConfig(randomMaxSizeConfig);\n\n        NearCacheConfig noneMaxSizeConfig = new NearCacheConfig();\n        noneMaxSizeConfig.setName(NEAR_CACHE_NONE_WITH_MAX_SIZE + \"*\");\n        noneMaxSizeConfig.setInvalidateOnChange(true);\n        noneMaxSizeConfig.setMaxSize(MAX_CACHE_SIZE);\n        noneMaxSizeConfig.setEvictionPolicy(\"NONE\");\n        clientConfig.addNearCacheConfig(noneMaxSizeConfig);\n\n        client = HazelcastClient.newHazelcastClient(clientConfig);\n    }","commit_id":"d9c3dcf32e462e2da208b7ef24b3298e6826a0a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidationWithLFU() throws Exception {\n        final String mapName = randomMapName(NEAR_CACHE_LFU_WITH_MAX_SIZE);\n        final IMap map = client.getMap(mapName);\n\n        final int mapSize = MAX_CACHE_SIZE * 2;\n\n        populateNearCache(map, mapSize);\n\n        final NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                assertTrue(MAX_CACHE_SIZE > stats.getOwnedEntryCount());\n            }\n        });\n    }","id":91780,"modified_method":"@Test\n    public void testNearCacheInvalidationWithLFU() throws Exception {\n        final String mapName = randomMapName(NEAR_CACHE_LFU_WITH_MAX_SIZE);\n        final IMap map = client.getMap(mapName);\n\n        int mapSize = MAX_CACHE_SIZE * 2;\n\n        populateNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                final NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n                assertTrue(MAX_CACHE_SIZE > stats.getOwnedEntryCount());\n            }\n        });\n    }","commit_id":"d9c3dcf32e462e2da208b7ef24b3298e6826a0a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void fireTtlCleanup() {\n        if (Clock.currentTimeMillis() < (lastCleanup + CLEANUP_INTERVAL)) {\n            return;\n        }\n\n        if (canCleanUp.compareAndSet(true, false)) {\n            try {\n                nodeEngine.getExecutionService().execute(\"hz:near-cache\", new Runnable() {\n                    public void run() {\n                        try {\n                            lastCleanup = Clock.currentTimeMillis();\n                            for (Map.Entry<Data, CacheRecord> entry : cache.entrySet()) {\n                                if (entry.getValue().expired()) {\n                                    final Data key = entry.getKey();\n                                    final CacheRecord record = cache.remove(key);\n                                    //if a mapping exists.\n                                    if (record != null) {\n                                        updateSizeEstimator(-calculateCost(record));\n                                    }\n                                }\n                            }\n                        } finally {\n                            canCleanUp.set(true);\n                        }\n                    }\n                });\n            } catch (RejectedExecutionException e) {\n                canCleanUp.set(true);\n            } catch (Exception e) {\n                throw ExceptionUtil.rethrow(e);\n            }\n        }\n    }","id":91781,"modified_method":"private void fireTtlCleanup() {\n        if (Clock.currentTimeMillis() < (lastCleanup + CLEANUP_INTERVAL)) {\n            return;\n        }\n\n        if (canCleanUp.compareAndSet(true, false)) {\n            try {\n                nodeEngine.getExecutionService().execute(NEAR_CACHE_EXECUTOR_NAME, new Runnable() {\n                    public void run() {\n                        try {\n                            lastCleanup = Clock.currentTimeMillis();\n                            for (Map.Entry<Data, CacheRecord> entry : cache.entrySet()) {\n                                if (entry.getValue().expired()) {\n                                    final Data key = entry.getKey();\n                                    final CacheRecord record = cache.remove(key);\n                                    //if a mapping exists.\n                                    if (record != null) {\n                                        updateSizeEstimator(-calculateCost(record));\n                                    }\n                                }\n                            }\n                        } finally {\n                            canCleanUp.set(true);\n                        }\n                    }\n                });\n            } catch (RejectedExecutionException e) {\n                canCleanUp.set(true);\n            } catch (Exception e) {\n                throw ExceptionUtil.rethrow(e);\n            }\n        }\n    }","commit_id":"d9c3dcf32e462e2da208b7ef24b3298e6826a0a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void fireEvictCache() {\n        if (canEvict.compareAndSet(true, false)) {\n            try {\n                nodeEngine.getExecutionService().execute(\"hz:near-cache\", new Runnable() {\n                    public void run() {\n                        try {\n                            TreeSet<CacheRecord> records = new TreeSet<CacheRecord>(selectedComparator);\n                            records.addAll(cache.values());\n                            int evictSize = cache.size() * EVICTION_PERCENTAGE / HUNDRED_PERCENT;\n                            int i = 0;\n                            for (CacheRecord record : records) {\n                                cache.remove(record.key);\n                                updateSizeEstimator(-calculateCost(record));\n                                if (++i > evictSize) {\n                                    break;\n                                }\n                            }\n                        } finally {\n                            canEvict.set(true);\n                        }\n                    }\n                });\n            } catch (RejectedExecutionException e) {\n                canEvict.set(true);\n            } catch (Exception e) {\n                throw ExceptionUtil.rethrow(e);\n            }\n        }\n    }","id":91782,"modified_method":"private void fireEvictCache() {\n        if (canEvict.compareAndSet(true, false)) {\n            try {\n                final ExecutionService executionService = nodeEngine.getExecutionService();\n                executionService.execute(NEAR_CACHE_EXECUTOR_NAME, new Runnable() {\n                    public void run() {\n                        try {\n                            TreeSet<CacheRecord> records = new TreeSet<CacheRecord>(selectedComparator);\n                            records.addAll(cache.values());\n                            int evictSize = cache.size() * EVICTION_PERCENTAGE / HUNDRED_PERCENT;\n                            int i = 0;\n                            for (CacheRecord record : records) {\n                                cache.remove(record.key);\n                                updateSizeEstimator(-calculateCost(record));\n                                if (++i > evictSize) {\n                                    break;\n                                }\n                            }\n                        } finally {\n                            canEvict.set(true);\n                        }\n\n                        if (cache.size() >= maxSize && canEvict.compareAndSet(true, false)) {\n                            executionService.execute(NEAR_CACHE_EXECUTOR_NAME, this);\n                        }\n                    }\n                });\n            } catch (RejectedExecutionException e) {\n                canEvict.set(true);\n            } catch (Exception e) {\n                throw ExceptionUtil.rethrow(e);\n            }\n        }\n    }","commit_id":"d9c3dcf32e462e2da208b7ef24b3298e6826a0a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void populateMapWithExpirableEnties(IMap<Integer, Integer> map, int mapSize) {\n        for (int i = 0; i < mapSize; i++) {\n            map.put(i, i, 3, TimeUnit.SECONDS);\n        }\n    }","id":91783,"modified_method":"private void populateMapWithExpirableEntries(IMap<Integer, Integer> map, int mapSize, long ttl, TimeUnit timeunit) {\n        for (int i = 0; i < mapSize; i++) {\n            map.put(i, i, ttl, timeunit);\n        }\n    }","commit_id":"d9c3dcf32e462e2da208b7ef24b3298e6826a0a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheInvalidationWithLFU() throws Exception {\n        int mapSize = 2000;\n        final int maxSize = 1000;\n        String mapName = randomMapName();\n\n        Config config = new Config();\n        final NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        nearCacheConfig.setCacheLocalEntries(true);\n        nearCacheConfig.setEvictionPolicy(\"LFU\");\n        nearCacheConfig.setMaxSize(maxSize);\n        config.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);\n\n        HazelcastInstance instance1 = createHazelcastInstance(config);\n\n        IMap<Integer, Integer> map = instance1.getMap(mapName);\n\n        populateNearCache(map, mapSize);\n\n        final NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                assertTrue(maxSize > stats.getOwnedEntryCount());\n            }\n        });\n    }","id":91784,"modified_method":"@Test\n    public void testNearCacheInvalidation_WithLFU_whenMaxSizeExceeded() throws Exception {\n        int mapSize = 2000;\n        final int maxSize = 1000;\n        final IMap map = getMapConfiguredWithMaxSizeAndPolicy(\"LFU\", maxSize);\n\n        populateMap(map, mapSize);\n        pullEntriesToNearCache(map, mapSize);\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n                assertTrue(maxSize > stats.getOwnedEntryCount());\n            }\n        });\n    }","commit_id":"d9c3dcf32e462e2da208b7ef24b3298e6826a0a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void populateNearCache(IMap<Integer, Integer> map, int mapSize) {\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n        }\n    }","id":91785,"modified_method":"private void populateMap(IMap<Integer, Integer> map, int mapSize) {\n        for (int i = 0; i < mapSize; i++) {\n            map.put(i, i);\n        }\n    }","commit_id":"d9c3dcf32e462e2da208b7ef24b3298e6826a0a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Near-cache has its own eviction/expiration mechanism,\n     * eviction/expiration on IMap should not force any near-cache eviction/expiration.\n     * Except a direct call to {@link com.hazelcast.core.IMap#evict(Object)}\n     * and {@link com.hazelcast.core.IMap#evictAll()}, those direct calls also evicts near-caches.\n     */\n    @Test\n    public void testNearCacheEntriesNotExpired_afterIMapExpiration() throws Exception {\n        final String mapName = randomMapName();\n        final Config config = createNearCachedMapConfig(mapName);\n        final HazelcastInstance instance = createHazelcastInstance(config);\n        final IMap<Integer, Integer> map = instance.getMap(mapName);\n        final int mapSize = 3;\n        final CountDownLatch latch = new CountDownLatch(mapSize);\n\n        addListener(map, latch);\n        populateMapWithExpirableEnties(map, mapSize);\n        populateNearCache(map, mapSize);\n\n        waitUntilEvictionEventsReceived(latch);\n        assertNearCacheSize(mapSize, mapName, map);\n    }","id":91786,"modified_method":"/**\n     * Near-cache has its own eviction/expiration mechanism,\n     * eviction/expiration on IMap should not force any near-cache eviction/expiration.\n     * Except a direct call to {@link com.hazelcast.core.IMap#evict(Object)}\n     * and {@link com.hazelcast.core.IMap#evictAll()}, those direct calls also evicts near-caches.\n     */\n    @Test\n    public void testNearCacheEntriesNotExpired_afterIMapExpiration() throws Exception {\n        final String mapName = randomMapName();\n        final Config config = createNearCachedMapConfig(mapName);\n        final HazelcastInstance instance = createHazelcastInstance(config);\n        final IMap<Integer, Integer> map = instance.getMap(mapName);\n        final int mapSize = 3;\n        final CountDownLatch latch = new CountDownLatch(mapSize);\n\n        addListener(map, latch);\n        populateMapWithExpirableEntries(map, mapSize, 3, TimeUnit.SECONDS);\n        pullEntriesToNearCache(map, mapSize);\n\n        waitUntilEvictionEventsReceived(latch);\n        assertNearCacheSize(mapSize, mapName, map);\n    }","commit_id":"d9c3dcf32e462e2da208b7ef24b3298e6826a0a6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Restore the old classloader\n     */\n    public void restoreClassLoader() {\n        Thread.currentThread().setContextClassLoader(origContextClassloader);\n        if (origClassPath != null) {\n            System.setProperty(\"java.class.path\", origClassPath);\n        }\n\n        Map<Object, Object> newProps = new HashMap<Object, Object>(System.getProperties());\n        for (Object o : newProps.keySet()) {\n            if (!origProps.containsKey(o)) {\n                System.clearProperty(o.toString());\n            }\n        }\n        System.getProperties().putAll(origProps);\n        origContextClassloader = null; // don't hold a reference.\n    }","id":91787,"modified_method":"/**\n     * Restore the old classloader\n     */\n    public void restoreClassLoader() {\n        if (origContextClassloader != null) {\n            Thread.currentThread().setContextClassLoader(origContextClassloader);\n            origContextClassloader = null; // don't hold a reference.\n        }\n        if (origClassPath != null) {\n            System.setProperty(\"java.class.path\", origClassPath);\n        }\n\n        if (origProps != null) {\n            Map<Object, Object> newProps = new HashMap<Object, Object>(System.getProperties());\n            for (Object o : newProps.keySet()) {\n                if (!origProps.containsKey(o)) {\n                    System.clearProperty(o.toString());\n                }\n            }\n            System.getProperties().putAll(origProps);\n        }\n    }","commit_id":"b656ec8541676eac37b024291afdd2b8cee627cf","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Restore the old classloader\n     */\n    public void restoreClassLoader() {\n        Thread.currentThread().setContextClassLoader(origContextClassloader);\n        if (origClassPath != null) {\n            System.setProperty(\"java.class.path\", origClassPath);\n        }\n\n        Map<Object, Object> newProps = new HashMap<Object, Object>(System.getProperties());\n        for (Object o : newProps.keySet()) {\n            if (!origProps.containsKey(o)) {\n                System.clearProperty(o.toString());\n            }\n        }\n        System.getProperties().putAll(origProps);\n        origContextClassloader = null; // don't hold a reference.\n    }","id":91788,"modified_method":"/**\n     * Restore the old classloader\n     */\n    public void restoreClassLoader() {\n        if (origContextClassloader != null) {\n            Thread.currentThread().setContextClassLoader(origContextClassloader);\n            origContextClassloader = null; // don't hold a reference.\n        }\n        if (origClassPath != null) {\n            System.setProperty(\"java.class.path\", origClassPath);\n        }\n\n        if (origProps != null) {\n            Map<Object, Object> newProps = new HashMap<Object, Object>(System.getProperties());\n            for (Object o : newProps.keySet()) {\n                if (!origProps.containsKey(o)) {\n                    System.clearProperty(o.toString());\n                }\n            }\n            System.getProperties().putAll(origProps);\n        }\n    }","commit_id":"b656ec8541676eac37b024291afdd2b8cee627cf","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Restore the old classloader\n     */\n    public void restoreClassLoader() {\n        Thread.currentThread().setContextClassLoader(origContextClassloader);\n        if (origClassPath != null) {\n            System.setProperty(\"java.class.path\", origClassPath);\n        }\n\n        Map<Object, Object> newProps = new HashMap<Object, Object>(System.getProperties());\n        for (Object o : newProps.keySet()) {\n            if (!origProps.containsKey(o)) {\n                System.clearProperty(o.toString());\n            }\n        }\n        System.getProperties().putAll(origProps);\n        origContextClassloader = null; // don't hold a reference.\n    }","id":91789,"modified_method":"/**\n     * Restore the old classloader\n     */\n    public void restoreClassLoader() {\n        if (origContextClassloader != null) {\n            Thread.currentThread().setContextClassLoader(origContextClassloader);\n            origContextClassloader = null; // don't hold a reference.\n        }\n        if (origClassPath != null) {\n            System.setProperty(\"java.class.path\", origClassPath);\n        }\n\n        if (origProps != null) {\n            Map<Object, Object> newProps = new HashMap<Object, Object>(System.getProperties());\n            for (Object o : newProps.keySet()) {\n                if (!origProps.containsKey(o)) {\n                    System.clearProperty(o.toString());\n                }\n            }\n            System.getProperties().putAll(origProps);\n        }\n    }","commit_id":"b656ec8541676eac37b024291afdd2b8cee627cf","url":"https://github.com/apache/cxf"},{"original_method":"public void setGrailsApplication(GrailsApplication application) {\n\t\tthis.grailsApplication = application;\n\t\t\n\t\tGrailsDomainClass[] existingDomainClasses = this.grailsApplication.getGrailsDomainClasses();\n\t\tfor(int i = 0; i < existingDomainClasses.length;i++) {\n\t\t\t\taddDomainClass(existingDomainClasses[i]);\n\t\t}\t\t\n\t}","id":91790,"modified_method":"public void setGrailsApplication(GrailsApplication application) {\n\t\tthis.grailsApplication = application;\n\t\tif(this.grailsApplication != null) {\n\t\t\tGrailsDomainClass[] existingDomainClasses = this.grailsApplication.getGrailsDomainClasses();\n\t\t\tfor(int i = 0; i < existingDomainClasses.length;i++) {\n\t\t\t\taddDomainClass(existingDomainClasses[i]);\n\t\t\t}\t\t\n\t\t}\n\t}","commit_id":"030c16cc639301c677f8b83cb90d5da8d0d20652","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t *  Overrides the default behaviour to including binding of Grails\n\t *  domain classes\n\t */\n\tprotected void secondPassCompile() throws MappingException {\n\t\tif (configLocked) {\n\t\t\treturn;\n\t\t}\t\t\n\t\t// set the class loader to load Groovy classes\n\t\tThread.currentThread().setContextClassLoader( this.grailsApplication.getClassLoader() );\n\t\t// do Grails class configuration\n\t\tfor(Iterator i = this.domainClasses.iterator();i.hasNext();) {\n\t\t\tGrailsDomainClass domainClass = (GrailsDomainClass)i.next();\n\t\t\t\n\t\t\tGrailsDomainBinder.bindClass(domainClass, super.createMappings());\n\t\t}\n\t\t\n\t\t// call super\n\t\tsuper.secondPassCompile();\n\t\tthis.configLocked = true;\n\t}","id":91791,"modified_method":"/**\n\t *  Overrides the default behaviour to including binding of Grails\n\t *  domain classes\n\t */\n\tprotected void secondPassCompile() throws MappingException {\n\t\tif (configLocked) {\n\t\t\treturn;\n\t\t}\t\t\n\t\t// set the class loader to load Groovy classes\n\t\tif(this.grailsApplication != null)\n\t\t\tThread.currentThread().setContextClassLoader( this.grailsApplication.getClassLoader() );\n\t\t// do Grails class configuration\n\t\tfor(Iterator i = this.domainClasses.iterator();i.hasNext();) {\n\t\t\tGrailsDomainClass domainClass = (GrailsDomainClass)i.next();\n\t\t\t\n\t\t\tGrailsDomainBinder.bindClass(domainClass, super.createMappings());\n\t\t}\n\t\t\n\t\t// call super\n\t\tsuper.secondPassCompile();\n\t\tthis.configLocked = true;\n\t}","commit_id":"030c16cc639301c677f8b83cb90d5da8d0d20652","url":"https://github.com/grails/grails-core"},{"original_method":"public Object locate(String name) throws BeanLocatorException {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Locating \" + name);\n\t\t}\n\n\t\treturn _applicationContext.getBean(name);\n\t}","id":91792,"modified_method":"public Object locate(String name) throws BeanLocatorException {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Locating \" + name);\n\t\t}\n\n\t\tif (name.endsWith(VELOCITY_SUFFIX)) {\n\t\t\tString originalName = name.substring(\n\t\t\t\t0, name.length() - VELOCITY_SUFFIX.length());\n\n\t\t\tObject bean = _velocityBeans.get(originalName);\n\n\t\t\tif (bean == null) {\n\t\t\t\tbean = _applicationContext.getBean(originalName);\n\n\t\t\t\tbean = Proxy.newProxyInstance(\n\t\t\t\t\t_classLoader, bean.getClass().getInterfaces(),\n\t\t\t\t\tnew VelocityBeanHandler(bean, _classLoader));\n\n\t\t\t\t_velocityBeans.put(originalName, bean);\n\t\t\t}\n\n\t\t\treturn bean;\n\t\t}\n\t\telse {\n\t\t\treturn _applicationContext.getBean(name);\n\t\t}\n\t}","commit_id":"c548d83f08bd4b130bae5263e33fe5af0b3d829c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object invoke(Object proxy, Method method, Object[] args)\n\t\tthrows Throwable {\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\ttry {\n\t\t\tcurrentThread.setContextClassLoader(_classLoader);\n\n\t\t\treturn method.invoke(_bean, args);\n\t\t}\n\t\tcatch (InvocationTargetException ite) {\n\t\t\tthrow ite.getTargetException();\n\t\t}\n\t\tfinally {\n\t\t\tcurrentThread.setContextClassLoader(contextClassLoader);\n\t\t}\n\t}","id":91793,"modified_method":"public Object invoke(Object proxy, Method method, Object[] args)\n\t\tthrows Throwable {\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\ttry {\n\t\t\tif ((_classLoader != null) &&\n\t\t\t\t(contextClassLoader != _classLoader)) {\n\n\t\t\t\tcurrentThread.setContextClassLoader(_classLoader);\n\t\t\t}\n\n\t\t\treturn method.invoke(_bean, args);\n\t\t}\n\t\tcatch (InvocationTargetException ite) {\n\t\t\tthrow ite.getTargetException();\n\t\t}\n\t\tfinally {\n\t\t\tif ((_classLoader != null) &&\n\t\t\t\t(contextClassLoader != _classLoader)) {\n\n\t\t\t\tcurrentThread.setContextClassLoader(contextClassLoader);\n\t\t\t}\n\t\t}\n\t}","commit_id":"c548d83f08bd4b130bae5263e33fe5af0b3d829c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object findService(String servletContextName, String serviceName) {\n\t\tif (serviceName.endsWith(_SERVICE)) {\n\t\t\tserviceName += _VELOCITY;\n\t\t}\n\n\t\tObject obj = null;\n\n\t\ttry {\n\t\t\tobj = PortletBeanLocatorUtil.locate(\n\t\t\t\tservletContextName, serviceName);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e);\n\t\t}\n\n\t\treturn obj;\n\t}","id":91794,"modified_method":"public Object findService(String servletContextName, String serviceName) {\n\t\tObject bean = null;\n\n\t\ttry {\n\t\t\tbean = PortletBeanLocatorUtil.locate(\n\t\t\t\tservletContextName, _getServiceName(serviceName));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn bean;\n\t}","commit_id":"c548d83f08bd4b130bae5263e33fe5af0b3d829c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object findService(String serviceName) {\n\t\tif (serviceName.endsWith(_SERVICE)) {\n\t\t\tserviceName += _VELOCITY;\n\t\t}\n\n\t\tObject obj = null;\n\n\t\ttry {\n\t\t\tobj = PortalBeanLocatorUtil.locate(serviceName);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e);\n\t\t}\n\n\t\treturn obj;\n\t}","id":91795,"modified_method":"public Object findService(String serviceName) {\n\t\tObject bean = null;\n\n\t\ttry {\n\t\t\tbean = PortalBeanLocatorUtil.locate(_getServiceName(serviceName));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn bean;\n\t}","commit_id":"c548d83f08bd4b130bae5263e33fe5af0b3d829c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object findUtil(String utilName) {\n\t\tif (utilName.endsWith(_UTIL)) {\n\t\t\tutilName += _VELOCITY;\n\t\t}\n\n\t\treturn PortalBeanLocatorUtil.locate(utilName);\n\t}","id":91796,"modified_method":"public Object findUtil(String utilName) {\n\t\tObject bean = null;\n\n\t\ttry {\n\t\t\tbean = PortalBeanLocatorUtil.locate(_getUtilName(utilName));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn bean;\n\t}","commit_id":"c548d83f08bd4b130bae5263e33fe5af0b3d829c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object findUtil(\n\t\tString servletContextName, String utilName) {\n\n\t\tif (utilName.endsWith(_UTIL)) {\n\t\t\tutilName += _VELOCITY;\n\t\t}\n\n\t\treturn PortletBeanLocatorUtil.locate(servletContextName, utilName);\n\t}","id":91797,"modified_method":"public Object findUtil(\n\t\tString servletContextName, String utilName) {\n\n\t\tObject bean = null;\n\n\t\ttry {\n\t\t\tbean = PortletBeanLocatorUtil.locate(\n\t\t\t\tservletContextName, _getUtilName(utilName));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn bean;\n\t}","commit_id":"c548d83f08bd4b130bae5263e33fe5af0b3d829c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static HazelcastInstanceProxy constructHazelcastInstance(Config config, String instanceName, NodeContext nodeContext) {\n        final ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n\n        HazelcastInstanceProxy proxy;\n        try {\n            Thread.currentThread().setContextClassLoader(HazelcastInstanceFactory.class.getClassLoader());\n\n            final HazelcastInstanceImpl hazelcastInstance = new HazelcastInstanceImpl(instanceName, config, nodeContext);\n            OutOfMemoryErrorDispatcher.register(hazelcastInstance);\n            proxy = new HazelcastInstanceProxy(hazelcastInstance);\n            final Node node = hazelcastInstance.node;\n            final Iterator<Member> iter = node.getClusterService().getMembers().iterator();\n            final boolean firstMember = (iter.hasNext() && iter.next().localMember());\n            final int initialWaitSeconds = node.groupProperties.INITIAL_WAIT_SECONDS.getInteger();\n            if (initialWaitSeconds > 0) {\n                hazelcastInstance.logger.info(\"Waiting \" + initialWaitSeconds + \" seconds before completing HazelcastInstance startup...\");\n                try {\n                    Thread.sleep(initialWaitSeconds * 1000);\n                    if (firstMember) {\n                        node.partitionService.firstArrangement();\n                    } else {\n                        Thread.sleep(4 * 1000);\n                    }\n                } catch (InterruptedException ignored) {\n                }\n            }\n            final int initialMinClusterSize = node.groupProperties.INITIAL_MIN_CLUSTER_SIZE.getInteger();\n            while (node.getClusterService().getSize() < initialMinClusterSize) {\n                try {\n                    hazelcastInstance.logger.info(\"HazelcastInstance waiting for cluster size of \" + initialMinClusterSize);\n                    //noinspection BusyWait\n                    Thread.sleep(1000);\n                } catch (InterruptedException ignored) {\n                }\n            }\n            if (initialMinClusterSize > 1) {\n                if (firstMember) {\n                    node.partitionService.firstArrangement();\n                } else {\n                    Thread.sleep(3 * 1000);\n                }\n                hazelcastInstance.logger.info(\"HazelcastInstance starting after waiting for cluster size of \"\n                        + initialMinClusterSize);\n            }\n            hazelcastInstance.lifecycleService.fireLifecycleEvent(STARTED);\n        } catch (Throwable t) {\n            throw ExceptionUtil.rethrow(t);\n        } finally {\n            Thread.currentThread().setContextClassLoader(tccl);\n        }\n        return proxy;\n    }","id":91798,"modified_method":"private static HazelcastInstanceProxy constructHazelcastInstance(Config config, String instanceName, NodeContext nodeContext) {\n        final ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n\n        HazelcastInstanceProxy proxy;\n        try {\n            if (tccl == null) {\n                Thread.currentThread().setContextClassLoader(HazelcastInstanceFactory.class.getClassLoader());\n            }\n            final HazelcastInstanceImpl hazelcastInstance = new HazelcastInstanceImpl(instanceName, config, nodeContext);\n            OutOfMemoryErrorDispatcher.register(hazelcastInstance);\n            proxy = new HazelcastInstanceProxy(hazelcastInstance);\n            final Node node = hazelcastInstance.node;\n            final Iterator<Member> iter = node.getClusterService().getMembers().iterator();\n            final boolean firstMember = (iter.hasNext() && iter.next().localMember());\n            final int initialWaitSeconds = node.groupProperties.INITIAL_WAIT_SECONDS.getInteger();\n            if (initialWaitSeconds > 0) {\n                hazelcastInstance.logger.info(\"Waiting \" + initialWaitSeconds + \" seconds before completing HazelcastInstance startup...\");\n                try {\n                    Thread.sleep(initialWaitSeconds * 1000);\n                    if (firstMember) {\n                        node.partitionService.firstArrangement();\n                    } else {\n                        Thread.sleep(4 * 1000);\n                    }\n                } catch (InterruptedException ignored) {\n                }\n            }\n            final int initialMinClusterSize = node.groupProperties.INITIAL_MIN_CLUSTER_SIZE.getInteger();\n            while (node.getClusterService().getSize() < initialMinClusterSize) {\n                try {\n                    hazelcastInstance.logger.info(\"HazelcastInstance waiting for cluster size of \" + initialMinClusterSize);\n                    //noinspection BusyWait\n                    Thread.sleep(1000);\n                } catch (InterruptedException ignored) {\n                }\n            }\n            if (initialMinClusterSize > 1) {\n                if (firstMember) {\n                    node.partitionService.firstArrangement();\n                } else {\n                    Thread.sleep(3 * 1000);\n                }\n                hazelcastInstance.logger.info(\"HazelcastInstance starting after waiting for cluster size of \"\n                        + initialMinClusterSize);\n            }\n            hazelcastInstance.lifecycleService.fireLifecycleEvent(STARTED);\n        } catch (Throwable t) {\n            throw ExceptionUtil.rethrow(t);\n        } finally {\n            Thread.currentThread().setContextClassLoader(tccl);\n        }\n        return proxy;\n    }","commit_id":"4d125f2da0d9e38de25b327506cb3c1820d622d3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n         * Run pool maintenance.  Evict objects qualifying for eviction and then\n         * ensure that the minimum number of idle instances are available.\n         * Since the Timer that invokes Evictors is shared for all Pools but\n         * pools may exist in different class loaders, the Evictor ensures that\n         * any actions taken are under the class loader of the factory\n         * associated with the pool.\n         */\n        @Override\n        public void run() {\n            ClassLoader savedClassLoader =\n                    Thread.currentThread().getContextClassLoader();\n            try {\n                // Set the class loader for the factory\n                ClassLoader cl = factoryClassLoader.get();\n                if (cl == null) {\n                    // The pool has been dereferenced and the class loader GC'd.\n                    // Cancel this timer so the pool can be GC'd as well.\n                    cancel();\n                    return;\n                }\n                Thread.currentThread().setContextClassLoader(cl);\n\n                // Evict from the pool\n                try {\n                    evict();\n                } catch(Exception e) {\n                    swallowException(e);\n                } catch(OutOfMemoryError oome) {\n                    // Log problem but give evictor thread a chance to continue\n                    // in case error is recoverable\n                    oome.printStackTrace(System.err);\n                }\n                // Re-create idle instances.\n                try {\n                    ensureMinIdle();\n                } catch (Exception e) {\n                    swallowException(e);\n                }\n            } finally {\n                // Restore the previous CCL\n                Thread.currentThread().setContextClassLoader(savedClassLoader);\n            }\n        }","id":91799,"modified_method":"/**\n         * Run pool maintenance.  Evict objects qualifying for eviction and then\n         * ensure that the minimum number of idle instances are available.\n         * Since the Timer that invokes Evictors is shared for all Pools but\n         * pools may exist in different class loaders, the Evictor ensures that\n         * any actions taken are under the class loader of the factory\n         * associated with the pool.\n         */\n        @Override\n        public void run() {\n            ClassLoader savedClassLoader =\n                    Thread.currentThread().getContextClassLoader();\n            try {\n                if (factoryClassLoader != null) {\n                    // Set the class loader for the factory\n                    ClassLoader cl = factoryClassLoader.get();\n                    if (cl == null) {\n                        // The pool has been dereferenced and the class loader\n                        // GC'd. Cancel this timer so the pool can be GC'd as\n                        // well.\n                        cancel();\n                        return;\n                    }\n                    Thread.currentThread().setContextClassLoader(cl);\n                }\n\n                // Evict from the pool\n                try {\n                    evict();\n                } catch(Exception e) {\n                    swallowException(e);\n                } catch(OutOfMemoryError oome) {\n                    // Log problem but give evictor thread a chance to continue\n                    // in case error is recoverable\n                    oome.printStackTrace(System.err);\n                }\n                // Re-create idle instances.\n                try {\n                    ensureMinIdle();\n                } catch (Exception e) {\n                    swallowException(e);\n                }\n            } finally {\n                // Restore the previous CCL\n                Thread.currentThread().setContextClassLoader(savedClassLoader);\n            }\n        }","commit_id":"9ab36a5f1d13e8d774df40ca64fc046d75e0ea72","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Handles JMX registration (if required) and the initialization required for\n     * monitoring.\n     *\n     * @param config        Pool configuration\n     * @param jmxNameBase   The default base JMX name for the new pool unless\n     *                      overridden by the config\n     * @param jmxNamePrefix Prefix to be used for JMX name for the new pool\n     */\n    public BaseGenericObjectPool(BaseObjectPoolConfig config,\n            String jmxNameBase, String jmxNamePrefix) {\n        if (config.getJmxEnabled()) {\n            this.oname = jmxRegister(config, jmxNameBase, jmxNamePrefix);\n        } else {\n            this.oname = null;\n        }\n\n        // Populate the creation stack trace\n        this.creationStackTrace = getStackTrace(new Exception());\n\n        // save the current CCL to be used later by the evictor Thread\n        factoryClassLoader =\n                new WeakReference<>(Thread.currentThread().getContextClassLoader());\n        fairness = config.getFairness();\n    }","id":91800,"modified_method":"/**\n     * Handles JMX registration (if required) and the initialization required for\n     * monitoring.\n     *\n     * @param config        Pool configuration\n     * @param jmxNameBase   The default base JMX name for the new pool unless\n     *                      overridden by the config\n     * @param jmxNamePrefix Prefix to be used for JMX name for the new pool\n     */\n    public BaseGenericObjectPool(BaseObjectPoolConfig config,\n            String jmxNameBase, String jmxNamePrefix) {\n        if (config.getJmxEnabled()) {\n            this.oname = jmxRegister(config, jmxNameBase, jmxNamePrefix);\n        } else {\n            this.oname = null;\n        }\n\n        // Populate the creation stack trace\n        this.creationStackTrace = getStackTrace(new Exception());\n\n        // save the current TCCL (if any) to be used later by the evictor Thread\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        if (cl == null) {\n            factoryClassLoader = null;\n        } else {\n            factoryClassLoader = new WeakReference<>(cl);\n        }\n\n        fairness = config.getFairness();\n    }","commit_id":"9ab36a5f1d13e8d774df40ca64fc046d75e0ea72","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n\t\tpublic void dependenciesFulfilled() {\n\t\t\tClassLoader operatingClassLoader = getOperatingClassloader();\n\n\t\t\tif (SPIUtil.isSPI()) {\n\t\t\t\tSPI spi = SPIUtil.getSPI();\n\n\t\t\t\ttry {\n\t\t\t\t\tRegistrationReference registrationReference =\n\t\t\t\t\t\tspi.getRegistrationReference();\n\n\t\t\t\t\tIntrabandRPCUtil.execute(\n\t\t\t\t\t\tregistrationReference,\n\t\t\t\t\t\tnew DestinationConfigurationProcessCallable(\n\t\t\t\t\t\t\t_destinationName));\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\t\t\tsb.append(\"Unable to install \");\n\t\t\t\t\tsb.append(\n\t\t\t\t\t\tDestinationConfigurationProcessCallable.class.\n\t\t\t\t\t\t\tgetName());\n\t\t\t\t\tsb.append(\" on MPI for \");\n\t\t\t\t\tsb.append(_destinationName);\n\n\t\t\t\t\t_log.error(sb.toString(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tMap<String, Object> properties = new HashMap<>();\n\n\t\t\tproperties.put(\"destination.name\", _destinationName);\n\t\t\tproperties.put(\n\t\t\t\t\"message.listener.operating.class.loader\",\n\t\t\t\toperatingClassLoader);\n\n\t\t\tfor (MessageListener messageListener : _messageListeners) {\n\t\t\t\t_messageListenerServiceRegistrar.registerService(\n\t\t\t\t\tMessageListener.class, messageListener, properties);\n\t\t\t}\n\t\t}","id":91801,"modified_method":"@Override\n\t\tpublic void dependenciesFulfilled() {\n\t\t\tClassLoader operatingClassLoader = getOperatingClassloader();\n\n\t\t\tif (SPIUtil.isSPI()) {\n\t\t\t\tSPI spi = SPIUtil.getSPI();\n\n\t\t\t\ttry {\n\t\t\t\t\tRegistrationReference registrationReference =\n\t\t\t\t\t\tspi.getRegistrationReference();\n\n\t\t\t\t\tIntrabandRPCUtil.execute(\n\t\t\t\t\t\tregistrationReference,\n\t\t\t\t\t\tnew DestinationConfigurationProcessCallable(\n\t\t\t\t\t\t\t_destinationName));\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\t\t\tsb.append(\"Unable to install \");\n\t\t\t\t\tsb.append(\n\t\t\t\t\t\tDestinationConfigurationProcessCallable.class.\n\t\t\t\t\t\t\tgetName());\n\t\t\t\t\tsb.append(\" on MPI for \");\n\t\t\t\t\tsb.append(_destinationName);\n\n\t\t\t\t\t_log.error(sb.toString(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tMap<String, Object> properties = new HashMap<>();\n\n\t\t\tproperties.put(\"destination.name\", _destinationName);\n\t\t\tproperties.put(\n\t\t\t\tMessageListener.MESSAGE_LISTENER_OPERATING_CLASS_LOADER,\n\t\t\t\toperatingClassLoader);\n\n\t\t\tfor (MessageListener messageListener : _messageListeners) {\n\t\t\t\t_messageListenerServiceRegistrar.registerService(\n\t\t\t\t\tMessageListener.class, messageListener, properties);\n\t\t\t}\n\t\t}","commit_id":"196f8b5acbaac5f6853934cb71652eba2a162bfd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Reference(\n\t\tcardinality = ReferenceCardinality.MULTIPLE,\n\t\tpolicy = ReferencePolicy.DYNAMIC,\n\t\tpolicyOption = ReferencePolicyOption.GREEDY,\n\t\ttarget = \"(destination.name=*)\", unbind = \"unregisterMessageListener\"\n\t)\n\tprotected synchronized void registerMessageListener(\n\t\tMessageListener messageListener, Map<String, Object> properties) {\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\ttry {\n\t\t\tClassLoader operatingClassLoader = (ClassLoader)properties.get(\n\t\t\t\t\"message.listener.operating.class.loader\");\n\n\t\t\tcurrentThread.setContextClassLoader(operatingClassLoader);\n\n\t\t\tString destinationName = MapUtil.getString(\n\t\t\t\tproperties, \"destination.name\");\n\n\t\t\tregisterMessageListener(destinationName, messageListener);\n\t\t}\n\t\tfinally {\n\t\t\tcurrentThread.setContextClassLoader(contextClassLoader);\n\t\t}\n\t}","id":91802,"modified_method":"@Reference(\n\t\tcardinality = ReferenceCardinality.MULTIPLE,\n\t\tpolicy = ReferencePolicy.DYNAMIC,\n\t\tpolicyOption = ReferencePolicyOption.GREEDY,\n\t\ttarget = \"(destination.name=*)\", unbind = \"unregisterMessageListener\"\n\t)\n\tprotected synchronized void registerMessageListener(\n\t\tMessageListener messageListener, Map<String, Object> properties) {\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\ttry {\n\t\t\tClassLoader operatingClassLoader = (ClassLoader)properties.get(\n\t\t\t\tMessageListener.MESSAGE_LISTENER_OPERATING_CLASS_LOADER);\n\n\t\t\tif (operatingClassLoader != null) {\n\t\t\t\tcurrentThread.setContextClassLoader(operatingClassLoader);\n\t\t\t}\n\n\t\t\tString destinationName = MapUtil.getString(\n\t\t\t\tproperties, \"destination.name\");\n\n\t\t\tregisterMessageListener(destinationName, messageListener);\n\t\t}\n\t\tfinally {\n\t\t\tcurrentThread.setContextClassLoader(contextClassLoader);\n\t\t}\n\t}","commit_id":"196f8b5acbaac5f6853934cb71652eba2a162bfd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void receive(Message message) throws MessageListenerException {\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\tcurrentThread.setContextClassLoader(_classLoader);\n\n\t\ttry {\n\t\t\t_messageListener.receive(message);\n\t\t}\n\t\tfinally {\n\t\t\tcurrentThread.setContextClassLoader(contextClassLoader);\n\t\t}\n\t}","id":91803,"modified_method":"@Override\n\tpublic void receive(Message message) throws MessageListenerException {\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\tif (_classLoader != null) {\n\t\t\tcurrentThread.setContextClassLoader(_classLoader);\n\t\t}\n\n\t\ttry {\n\t\t\t_messageListener.receive(message);\n\t\t}\n\t\tfinally {\n\t\t\tif (_classLoader != null) {\n\t\t\t\tcurrentThread.setContextClassLoader(contextClassLoader);\n\t\t\t}\n\t\t}\n\t}","commit_id":"196f8b5acbaac5f6853934cb71652eba2a162bfd","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void start(StartContext context) throws StartException {\n        final ServiceController<?> controller = context.getController();\n        final ServiceContainer serviceContainer = controller.getServiceContainer();\n\n        final DeploymentUnitContextImpl deploymentUnitContext = this.deploymentUnitContext;\n\n        // Create batch for these items\n        final BatchBuilder batchBuilder = serviceContainer.batchBuilder();\n        //  Add batch level dependency for this deployment\n        batchBuilder.addDependency(controller.getName());\n\n        // Construct an item context\n        final DeploymentItemContext deploymentItemContext = new DeploymentItemContextImpl(module, batchBuilder);\n\n        final ClassLoader currentCl = getContextClassLoader();\n        setContextClassLoader(module.getClassLoader());\n        try {\n            DeploymentModuleLoaderSelector.CURRENT_MODULE_LOADER.set(module.getModuleLoader());\n            try {\n                // Process all the deployment items with the item context\n                final Collection<DeploymentItem> deploymentItems = deploymentUnitContext.getDeploymentItems();\n                for(DeploymentItem deploymentItem : deploymentItems) {\n                    deploymentItem.install(deploymentItemContext);\n                }\n            } finally {\n                DeploymentModuleLoaderSelector.CURRENT_MODULE_LOADER.set(null);\n            }\n        } finally {\n            setContextClassLoader(currentCl);\n        }\n\n        // Install the batch\n        try {\n            batchBuilder.install();\n        } catch(ServiceRegistryException e) {\n            throw new StartException(\"Failed to install deployment batch for \" + deploymentUnitContext.getName(), e);\n        }\n    }","id":91804,"modified_method":"@Override\n    public void start(StartContext context) throws StartException {\n        final ServiceController<?> controller = context.getController();\n        final ServiceContainer serviceContainer = controller.getServiceContainer();\n\n        final DeploymentUnitContextImpl deploymentUnitContext = this.deploymentUnitContext;\n\n        // Create batch for these items\n        final BatchBuilder batchBuilder = serviceContainer.batchBuilder();\n        if(deploymentListener != null)\n            batchBuilder.addListener(deploymentListener);\n        \n        //  Add batch level dependency for this deployment\n        batchBuilder.addDependency(controller.getName());\n\n        final ClassLoader currentCl = getContextClassLoader();\n        if(module != null) {\n            setContextClassLoader(module.getClassLoader());\n            DeploymentModuleLoaderSelector.CURRENT_MODULE_LOADER.set(module.getModuleLoader());\n        }\n        try {\n            try {\n                // Process all the deployment items with the item context\n                final Collection<DeploymentItem> deploymentItems = deploymentUnitContext.getDeploymentItems();\n                for(DeploymentItem deploymentItem : deploymentItems) {\n                    // Create a sub-batch to disable individual items from installing the batch or polluting other items service deps/listeners\n                    final BatchBuilder subBatchBuilder = batchBuilder.subBatchBuilder();\n                    // Construct an item context\n                    final DeploymentItemContext deploymentItemContext = new DeploymentItemContextImpl(module, subBatchBuilder);\n                    deploymentItem.install(deploymentItemContext);\n                }\n            } finally {\n                DeploymentModuleLoaderSelector.CURRENT_MODULE_LOADER.set(null);\n            }\n        } finally {\n            setContextClassLoader(currentCl);\n        }\n\n        // Install the batch\n        try {\n            batchBuilder.install();\n        } catch(ServiceRegistryException e) {\n            throw new StartException(\"Failed to install deployment batch for \" + deploymentUnitContext.getName(), e);\n        }\n    }","commit_id":"251b76086b98b5a62072d68dacabfb9e99e123bf","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Before\n    public void setupDeploymentManager() throws Exception {\n        serviceContainer = ServiceContainer.Factory.create();\n        final ServiceName chainServiceName = ServiceName.JBOSS.append(\"deployment\", \"chain\");\n        final ServiceName moduleLoaderServiceName = ServiceName.JBOSS.append(\"deployment\", \"module\", \"loader\");\n\n        deploymentManager = new DeploymentManager(serviceContainer) {\n            @Override\n            protected ServiceName determineDeploymentChain() {\n                return chainServiceName;\n            }\n\n            @Override\n            protected ServiceName determineDeploymentModuleLoader() {\n                return moduleLoaderServiceName;\n            }\n        };\n\n        final BatchBuilder batchBuilder = serviceContainer.batchBuilder();\n        batchBuilder.addService(chainServiceName, new PassthroughService(deploymentChain));\n        batchBuilder.addService(moduleLoaderServiceName, new PassthroughService(deploymentModuleLoader));\n        batchBuilder.install();\n    }","id":91805,"modified_method":"@Before\n    public void setupDeploymentManager() throws Exception {\n        serviceContainer = ServiceContainer.Factory.create();\n        final ServiceName chainServiceName = ServiceName.JBOSS.append(\"deployment\", \"chain\");\n        final ServiceName moduleLoaderServiceName = ServiceName.JBOSS.append(\"deployment\", \"module\", \"loader\");\n\n        deploymentManager = new DeploymentManagerImpl(serviceContainer) {\n            @Override\n            protected ServiceName determineDeploymentChain() {\n                return chainServiceName;\n            }\n\n            @Override\n            protected ServiceName determineDeploymentModuleLoader() {\n                return moduleLoaderServiceName;\n            }\n        };\n\n        final BatchBuilder batchBuilder = serviceContainer.batchBuilder();\n        batchBuilder.addService(chainServiceName, new PassthroughService(deploymentChain));\n        batchBuilder.addService(moduleLoaderServiceName, new PassthroughService(deploymentModuleLoader));\n        batchBuilder.install();\n    }","commit_id":"251b76086b98b5a62072d68dacabfb9e99e123bf","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(StartContext context) throws StartException {\n        if(deploymentRoot == null) throw new StartException(\"DeploymentService requires a deployment root to start\");\n        if(deploymentChain == null) throw new StartException(\"DeploymentService requires a deployment chain to start\");\n        if(deploymentModuleLoader == null) throw new StartException(\"DeploymentService requires a deployment deployment ModuleLoader to start\");\n\n        final ServiceController<?> serviceController = context.getController();\n        final ServiceName deploymentServiceName = serviceController.getName();\n        final String deploymentPath = deploymentRoot.getPathName();\n        \n        // Create the deployment unit context\n        final DeploymentUnitContextImpl deploymentUnitContext = new DeploymentUnitContextImpl(deploymentName);\n        attachVirtualFile(deploymentUnitContext, deploymentRoot);\n\n        // Execute the deployment chain\n        final DeploymentChain deploymentChain = this.deploymentChain;\n        logger.debugf(\"Deployment processor starting with chain: %s\", deploymentChain);\n        try {\n            deploymentChain.processDeployment(deploymentUnitContext);\n        } catch(DeploymentUnitProcessingException e) {\n            throw new StartException(\"Failed to process deployment chain.\", e);\n        }\n        \n        // Setup batch for the next phases of deployment\n        final ServiceContainer serviceContainer = serviceController.getServiceContainer();\n        final BatchBuilder batchBuilder = serviceContainer.batchBuilder();\n\n        // Add batch level dependency on this service\n        //batchBuilder.addDependency(deploymentServiceName);\n\n        // Setup deployment module service\n        final ServiceName moduleServiceName = DeploymentModuleService.SERVICE_NAME.append(deploymentPath);\n        DeploymentModuleService deploymentModuleService = null;\n        final ModuleConfig moduleConfig = deploymentUnitContext.getAttachment(ModuleConfig.ATTACHMENT_KEY);\n        if(moduleConfig != null) {\n            deploymentModuleService = new DeploymentModuleService(deploymentModuleLoader, moduleConfig);\n            final BatchServiceBuilder<?> moduleServiceBuilder = batchBuilder.addService(moduleServiceName, deploymentModuleService);\n            for(ModuleConfig.Dependency dependency : moduleConfig.getDependencies()) {\n                // TODO determine whether the dependency comes from the deployment module loader and if so add a service dep\n            }\n        }\n        \n        // Setup deployment item processor service\n        final ServiceName deploymentItemProcessorName = DeploymentItemProcessor.SERVICE_NAME.append(deploymentPath);\n        final DeploymentItemProcessor deploymentItemProcessor = new DeploymentItemProcessor(deploymentUnitContext);\n        final BatchServiceBuilder<?> itemProcessorServiceBuilder = batchBuilder.addService(deploymentItemProcessorName, deploymentItemProcessor);\n        if(deploymentModuleService != null) {\n            itemProcessorServiceBuilder.addDependency(moduleServiceName).toMethod(DeploymentItemProcessor.DEPLOYMENT_MODULE_SETTER, Collections.singletonList(deploymentModuleService));\n        }\n\n        // Install the batch\n        try {\n            batchBuilder.install();\n        } catch(ServiceRegistryException e) {\n            throw new StartException(\"Failed to install deployment phase batch for \" + deploymentName, e);\n        }\n    }","id":91806,"modified_method":"@Override\n    public void start(StartContext context) throws StartException {\n        if(deploymentRoot == null) throw new StartException(\"DeploymentService requires a deployment root to start\");\n        if(deploymentChain == null) throw new StartException(\"DeploymentService requires a deployment chain to start\");\n        if(deploymentModuleLoader == null) throw new StartException(\"DeploymentService requires a deployment deployment ModuleLoader to start\");\n\n        final ServiceController<?> serviceController = context.getController();\n        final ServiceName deploymentServiceName = serviceController.getName();\n        final String deploymentPath = deploymentRoot.getPathName();\n        \n        // Create the deployment unit context\n        final DeploymentUnitContextImpl deploymentUnitContext = new DeploymentUnitContextImpl(deploymentName);\n        attachVirtualFile(deploymentUnitContext, deploymentRoot);\n\n        // Execute the deployment chain\n        final DeploymentChain deploymentChain = this.deploymentChain;\n        logger.debugf(\"Deployment processor starting with chain: %s\", deploymentChain);\n        try {\n            deploymentChain.processDeployment(deploymentUnitContext);\n        } catch(DeploymentUnitProcessingException e) {\n            throw new StartException(\"Failed to process deployment chain.\", e);\n        }\n        \n        // Setup batch for the next phases of deployment\n        final ServiceContainer serviceContainer = serviceController.getServiceContainer();\n        final BatchBuilder batchBuilder = serviceContainer.batchBuilder();\n        if(deploymentListener != null)\n            batchBuilder.addListener(deploymentListener);\n\n        // Add batch level dependency on this service\n        batchBuilder.addDependency(deploymentServiceName);\n\n        // Setup deployment module service\n        final ServiceName moduleServiceName = DeploymentModuleService.SERVICE_NAME.append(deploymentPath);\n        DeploymentModuleService deploymentModuleService = null;\n        final ModuleConfig moduleConfig = deploymentUnitContext.getAttachment(ModuleConfig.ATTACHMENT_KEY);\n        if(moduleConfig != null) {\n            deploymentModuleService = new DeploymentModuleService(deploymentModuleLoader, moduleConfig);\n            final BatchServiceBuilder<?> moduleServiceBuilder = batchBuilder.addService(moduleServiceName, deploymentModuleService);\n            for(ModuleConfig.Dependency dependency : moduleConfig.getDependencies()) {\n                // TODO determine whether the dependency comes from the deployment module loader and if so add a service dep\n            }\n        }\n        \n        // Setup deployment item processor service\n        final ServiceName deploymentItemProcessorName = DeploymentItemProcessor.SERVICE_NAME.append(deploymentPath);\n        final DeploymentItemProcessor deploymentItemProcessor = new DeploymentItemProcessor(deploymentUnitContext);\n        deploymentItemProcessor.setDeploymentListener(deploymentListener);\n        final BatchServiceBuilder<?> itemProcessorServiceBuilder = batchBuilder.addService(deploymentItemProcessorName, deploymentItemProcessor);\n        if(deploymentModuleService != null) {\n            itemProcessorServiceBuilder.addDependency(moduleServiceName).toMethod(DeploymentItemProcessor.DEPLOYMENT_MODULE_SETTER, Collections.singletonList(deploymentModuleService));\n        }\n\n        // Install the batch\n        try {\n            batchBuilder.install();\n        } catch(ServiceRegistryException e) {\n            throw new StartException(\"Failed to install deployment phase batch for \" + deploymentName, e);\n        }\n    }","commit_id":"251b76086b98b5a62072d68dacabfb9e99e123bf","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void processDeployment(DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n        addDependency(context, new ModuleConfig.Dependency(ModuleIdentifier.SYSTEM, true, false, false));\n        if(includeTestModule) {\n            addDependency(context, new ModuleConfig.Dependency(TEST_MODULE_IDENTIFIER, true, false, false));\n        }\n    }","id":91807,"modified_method":"@Override\n    public void processDeployment(DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n        addDependency(context, new ModuleConfig.Dependency(ModuleIdentifier.SYSTEM, true, false, false));\n    }","commit_id":"251b76086b98b5a62072d68dacabfb9e99e123bf","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void install(BatchBuilder batchBuilder) {\n        System.out.println(\"Here\");\n    }","id":91808,"modified_method":"@Override\n    public void install(BatchBuilder batchBuilder) {\n        batchBuilder.addService(TEST_SERVICE_NAME, Service.NULL);\n    }","commit_id":"251b76086b98b5a62072d68dacabfb9e99e123bf","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static HazelcastInstance newHazelcastInstance(Config config, String instanceName, NodeContext nodeContext) {\n        final ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n\n        if (instanceName == null || instanceName.trim().length() == 0) {\n            instanceName = createInstanceName(config);\n        }\n        HazelcastInstanceProxy proxy;\n        try {\n            Thread.currentThread().setContextClassLoader(HazelcastInstanceFactory.class.getClassLoader());\n\n            final HazelcastInstanceImpl hazelcastInstance = new HazelcastInstanceImpl(instanceName, config, nodeContext);\n            OutOfMemoryErrorDispatcher.register(hazelcastInstance);\n            proxy = new HazelcastInstanceProxy(hazelcastInstance);\n            final Node node = hazelcastInstance.node;\n            final Iterator<Member> iter = node.getClusterService().getMembers().iterator();\n            final boolean firstMember = (iter.hasNext() && iter.next().localMember());\n            final int initialWaitSeconds = node.groupProperties.INITIAL_WAIT_SECONDS.getInteger();\n            if (initialWaitSeconds > 0) {\n                hazelcastInstance.logger.info(\"Waiting \" + initialWaitSeconds + \" seconds before completing HazelcastInstance startup...\");\n                try {\n                    Thread.sleep(initialWaitSeconds * 1000);\n                    if (firstMember) {\n                        node.partitionService.firstArrangement();\n                    } else {\n                        Thread.sleep(4 * 1000);\n                    }\n                } catch (InterruptedException ignored) {\n                }\n            }\n            final int initialMinClusterSize = node.groupProperties.INITIAL_MIN_CLUSTER_SIZE.getInteger();\n            while (node.getClusterService().getSize() < initialMinClusterSize) {\n                try {\n                    hazelcastInstance.logger.info(\"HazelcastInstance waiting for cluster size of \" + initialMinClusterSize);\n                    //noinspection BusyWait\n                    Thread.sleep(1000);\n                } catch (InterruptedException ignored) {\n                }\n            }\n            if (initialMinClusterSize > 1) {\n                if (firstMember) {\n                    node.partitionService.firstArrangement();\n                } else {\n                    Thread.sleep(3 * 1000);\n                }\n                hazelcastInstance.logger.info(\"HazelcastInstance starting after waiting for cluster size of \"\n                        + initialMinClusterSize);\n            }\n            INSTANCE_MAP.put(instanceName, proxy);\n            hazelcastInstance.lifecycleService.fireLifecycleEvent(STARTED);\n        } catch (Throwable t) {\n            throw ExceptionUtil.rethrow(t);\n        } finally {\n            Thread.currentThread().setContextClassLoader(tccl);\n        }\n        return proxy;\n    }","id":91809,"modified_method":"public static HazelcastInstance newHazelcastInstance(Config config, String instanceName, NodeContext nodeContext) {\n        final ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n\n        if (instanceName == null || instanceName.trim().length() == 0) {\n            instanceName = createInstanceName(config);\n        }\n        HazelcastInstanceProxy proxy;\n        try {\n            if (tccl == null) {\n                Thread.currentThread().setContextClassLoader(HazelcastInstanceFactory.class.getClassLoader());\n            }\n            final HazelcastInstanceImpl hazelcastInstance = new HazelcastInstanceImpl(instanceName, config, nodeContext);\n            OutOfMemoryErrorDispatcher.register(hazelcastInstance);\n            proxy = new HazelcastInstanceProxy(hazelcastInstance);\n            final Node node = hazelcastInstance.node;\n            final Iterator<Member> iter = node.getClusterService().getMembers().iterator();\n            final boolean firstMember = (iter.hasNext() && iter.next().localMember());\n            final int initialWaitSeconds = node.groupProperties.INITIAL_WAIT_SECONDS.getInteger();\n            if (initialWaitSeconds > 0) {\n                hazelcastInstance.logger.info(\"Waiting \" + initialWaitSeconds + \" seconds before completing HazelcastInstance startup...\");\n                try {\n                    Thread.sleep(initialWaitSeconds * 1000);\n                    if (firstMember) {\n                        node.partitionService.firstArrangement();\n                    } else {\n                        Thread.sleep(4 * 1000);\n                    }\n                } catch (InterruptedException ignored) {\n                }\n            }\n            final int initialMinClusterSize = node.groupProperties.INITIAL_MIN_CLUSTER_SIZE.getInteger();\n            while (node.getClusterService().getSize() < initialMinClusterSize) {\n                try {\n                    hazelcastInstance.logger.info(\"HazelcastInstance waiting for cluster size of \" + initialMinClusterSize);\n                    //noinspection BusyWait\n                    Thread.sleep(1000);\n                } catch (InterruptedException ignored) {\n                }\n            }\n            if (initialMinClusterSize > 1) {\n                if (firstMember) {\n                    node.partitionService.firstArrangement();\n                } else {\n                    Thread.sleep(3 * 1000);\n                }\n                hazelcastInstance.logger.info(\"HazelcastInstance starting after waiting for cluster size of \"\n                        + initialMinClusterSize);\n            }\n            INSTANCE_MAP.put(instanceName, proxy);\n            hazelcastInstance.lifecycleService.fireLifecycleEvent(STARTED);\n        } catch (Throwable t) {\n            throw ExceptionUtil.rethrow(t);\n        } finally {\n            Thread.currentThread().setContextClassLoader(tccl);\n        }\n        return proxy;\n    }","commit_id":"c08871296fc059dbda1f0290e8a934db9c5f1f62","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private boolean isExcludedFromAnnotationProcessing(VirtualFile file, CompileContext context) {\n    final Module module = context.getModuleByFile(file);\n    if (module != null) {\n      if (!myConfig.isAnnotationProcessingEnabled(module)) {\n        return true;\n      }\n      final String path = CompilerPaths.getAnnotationProcessorsGenerationPath(module);\n      final VirtualFile generationDir = LocalFileSystem.getInstance().findFileByPath(path);\n      if (VfsUtil.isAncestor(generationDir, file, false)) {\n        return true;\n      }\n    }\n    return myConfig.isExcludedFromCompilation(file);\n  }","id":91810,"modified_method":"private boolean isExcludedFromAnnotationProcessing(VirtualFile file, CompileContext context) {\n    final Module module = context.getModuleByFile(file);\n    if (module != null) {\n      if (!myConfig.isAnnotationProcessingEnabled(module)) {\n        return true;\n      }\n      final String path = CompilerPaths.getAnnotationProcessorsGenerationPath(module);\n      final VirtualFile generationDir = path != null? LocalFileSystem.getInstance().findFileByPath(path) : null;\n      if (generationDir != null && VfsUtil.isAncestor(generationDir, file, false)) {\n        return true;\n      }\n    }\n    return myConfig.isExcludedFromCompilation(file);\n  }","commit_id":"944a7bedea61c6ec20b242b55a1d716b22d6572c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isGenerated(VirtualFile file) {\n    if (myGeneratedSources.contains(FileBasedIndex.getFileId(file))) {\n      return true;\n    }\n    for (final VirtualFile root : myRootToModuleMap.keySet()) {\n      if (VfsUtil.isAncestor(root, file, false)) {\n        return true;\n      }\n    }\n    final Module module = getModuleByFile(file);\n    if (module != null) {\n      final String procGenRoot = CompilerPaths.getAnnotationProcessorsGenerationPath(module);\n      if (VfsUtil.isAncestor(new File(procGenRoot), new File(file.getPath()), true)) {\n        return true;\n      }\n    }\n    return false;\n  }","id":91811,"modified_method":"public boolean isGenerated(VirtualFile file) {\n    if (myGeneratedSources.contains(FileBasedIndex.getFileId(file))) {\n      return true;\n    }\n    for (final VirtualFile root : myRootToModuleMap.keySet()) {\n      if (VfsUtil.isAncestor(root, file, false)) {\n        return true;\n      }\n    }\n    final Module module = getModuleByFile(file);\n    if (module != null) {\n      final String procGenRoot = CompilerPaths.getAnnotationProcessorsGenerationPath(module);\n      if (procGenRoot != null && VfsUtil.isAncestor(new File(procGenRoot), new File(file.getPath()), true)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"944a7bedea61c6ec20b242b55a1d716b22d6572c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    protected VirtualFile getInitialFile() {\n      String directoryName = getComponentText();\n      if (directoryName.length() == 0) return null;\n      return LocalFileSystem.getInstance().findFileByPath(directoryName.replace(File.separatorChar, '/'));\n    }","id":91812,"modified_method":"@Nullable\n    protected VirtualFile getInitialFile() {\n      String directoryName = getComponentText();\n      if (directoryName.length() == 0) return null;\n      directoryName = directoryName.replace(File.separatorChar, '/');\n      VirtualFile path = LocalFileSystem.getInstance().findFileByPath(directoryName);\n      while (path == null && directoryName.length() > 0) {\n        int pos = directoryName.lastIndexOf('/');\n        if (pos <= 0) break;\n        directoryName = directoryName.substring(0, pos-1);\n        path = LocalFileSystem.getInstance().findFileByPath(directoryName);\n      }\n      return path;\n    }","commit_id":"13dcb93ec44171a179cce5e83b2849d83a3ee95e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public VirtualFile refreshAndFindFileByPath(String path) {\n    ApplicationManager.getApplication().assertWriteAccessAllowed();\n    return findFileByPath(path, true, true);\n  }","id":91813,"modified_method":"public VirtualFile refreshAndFindFileByPath(String path) {\n    ApplicationManager.getApplication().assertWriteAccessAllowed();\n    final VirtualFile file = findFileByPath(path, true, true);\n    if (file == null){\n      String canonicalPath = getCanonicalPath(new File(path.replace('/', File.separatorChar)));\n      if (canonicalPath == null) return null;\n      String path1 = canonicalPath.replace(File.separatorChar, '/');\n      if (!path.equals(path1)){\n        return findFileByPath(path1, true, true);\n      }\n    }\n    return file;\n  }","commit_id":"4cf8d471541595690afdf8d3b17e9e67abead071","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Frightcrawler(UUID ownerId) {\r\n        super(ownerId, 138, \"Frightcrawler\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{B}\");\r\n        this.expansionSetCode = \"ODY\";\r\n        this.subtype.add(\"Horror\");\r\n\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // Fear\r\n        this.addAbility(FearAbility.getInstance());\r\n        // Threshold - As long as seven or more cards are in your graveyard, Frightcrawler gets +2/+2 and can't block.\r\n        Ability thresholdAbility = new SimpleStaticAbility(\r\n                Zone.BATTLEFIELD,\r\n                new ConditionalContinousEffect(\r\n                    new BoostSourceEffect(2, 2, Duration.WhileOnBattlefield),\r\n                    new CardsInControllerGraveCondition(7),\r\n                    \"<br/><br/><i>Threshold<\/i> - If seven or more cards are in your graveyard, {this} gets +2/+2 \"\r\n                ));\r\n            thresholdAbility.addEffect(\r\n                new ConditionalContinousEffect(\r\n                    new CantBlockSourceEffect(Duration.WhileOnBattlefield),\r\n                    new CardsInControllerGraveCondition(7),\r\n                    \"and can't block.\"));\r\n        this.addAbility(thresholdAbility);\r\n    }","id":91814,"modified_method":"public Frightcrawler(UUID ownerId) {\r\n        super(ownerId, 138, \"Frightcrawler\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{B}\");\r\n        this.expansionSetCode = \"ODY\";\r\n        this.subtype.add(\"Horror\");\r\n\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // Fear\r\n        this.addAbility(FearAbility.getInstance());\r\n        // Threshold - As long as seven or more cards are in your graveyard, Frightcrawler gets +2/+2 and can't block.\r\n        Ability thresholdAbility = new SimpleStaticAbility(\r\n                Zone.BATTLEFIELD,\r\n                new ConditionalContinousEffect(\r\n                    new BoostSourceEffect(2, 2, Duration.WhileOnBattlefield),\r\n                    new CardsInControllerGraveCondition(7),\r\n                    \"<i>Threshold<\/i> - If seven or more cards are in your graveyard, {this} gets +2/+2 \"\r\n                ));\r\n            thresholdAbility.addEffect(\r\n                new ConditionalContinousEffect(\r\n                    new CantBlockSourceEffect(Duration.WhileOnBattlefield),\r\n                    new CardsInControllerGraveCondition(7),\r\n                    \"and can't block.\"));\r\n        this.addAbility(thresholdAbility);\r\n    }","commit_id":"c80e9739af7114aa7b5526492fda368b2ace0a76","url":"https://github.com/magefree/mage"},{"original_method":"public MysticCrusader(UUID ownerId) {\r\n        super(ownerId, 33, \"Mystic Crusader\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{1}{W}{W}\");\r\n        this.expansionSetCode = \"ODY\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Nomad\");\r\n        this.subtype.add(\"Mystic\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // Protection from black and from red\r\n        this.addAbility(new ProtectionAbility(filter));\r\n        // Threshold - As long as seven or more cards are in your graveyard, Mystic Crusader gets +1/+1 and has flying.\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinousEffect(\r\n                                                                    new BoostSourceEffect(1, 1, Duration.WhileOnBattlefield), new CardsInControllerGraveCondition(7), \"<i>Threshold<\/i> - As long as seven or more cards are in your graveyard, {this} gets +1/+1\"));\r\n        ability.addEffect(new ConditionalContinousEffect(new GainAbilitySourceEffect(FlyingAbility.getInstance()), new CardsInControllerGraveCondition(7), \" and has flying\"));\r\n        this.addAbility(ability);\r\n    }","id":91815,"modified_method":"public MysticCrusader(UUID ownerId) {\r\n        super(ownerId, 33, \"Mystic Crusader\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{1}{W}{W}\");\r\n        this.expansionSetCode = \"ODY\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Nomad\");\r\n        this.subtype.add(\"Mystic\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // Protection from black and from red\r\n        this.addAbility(new ProtectionAbility(filter));\r\n        // Threshold - As long as seven or more cards are in your graveyard, Mystic Crusader gets +1/+1 and has flying.\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinousEffect(\r\n                                                                    new BoostSourceEffect(1, 1, Duration.WhileOnBattlefield), new CardsInControllerGraveCondition(7), \"<i>Threshold<\/i> - As long as seven or more cards are in your graveyard, {this} gets +1/+1\"));\r\n        ability.addEffect(new ConditionalContinousEffect(new GainAbilitySourceEffect(FlyingAbility.getInstance()), new CardsInControllerGraveCondition(7), \"and has flying\"));\r\n        this.addAbility(ability);\r\n    }","commit_id":"c80e9739af7114aa7b5526492fda368b2ace0a76","url":"https://github.com/magefree/mage"},{"original_method":"public MysticPenitent(UUID ownerId) {\r\n        super(ownerId, 34, \"Mystic Penitent\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{W}\");\r\n        this.expansionSetCode = \"ODY\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Nomad\");\r\n        this.subtype.add(\"Mystic\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // Vigilance\r\n        this.addAbility(VigilanceAbility.getInstance());\r\n        // Threshold - As long as seven or more cards are in your graveyard, Mystic Penitent gets +1/+1 and has flying.\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinousEffect(\r\n                                                                    new BoostSourceEffect(1, 1, Duration.WhileOnBattlefield), new CardsInControllerGraveCondition(7), \"<i>Threshold<\/i> - As long as seven or more cards are in your graveyard, {this} gets +1/+1\"));\r\n        ability.addEffect(new ConditionalContinousEffect(new GainAbilitySourceEffect(FlyingAbility.getInstance()), new CardsInControllerGraveCondition(7), \" and has flying\"));\r\n        this.addAbility(ability);\r\n    }","id":91816,"modified_method":"public MysticPenitent(UUID ownerId) {\r\n        super(ownerId, 34, \"Mystic Penitent\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{W}\");\r\n        this.expansionSetCode = \"ODY\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Nomad\");\r\n        this.subtype.add(\"Mystic\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // Vigilance\r\n        this.addAbility(VigilanceAbility.getInstance());\r\n        // Threshold - As long as seven or more cards are in your graveyard, Mystic Penitent gets +1/+1 and has flying.\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinousEffect(\r\n                                                                    new BoostSourceEffect(1, 1, Duration.WhileOnBattlefield), new CardsInControllerGraveCondition(7), \"<i>Threshold<\/i> - As long as seven or more cards are in your graveyard, {this} gets +1/+1\"));\r\n        ability.addEffect(new ConditionalContinousEffect(new GainAbilitySourceEffect(FlyingAbility.getInstance()), new CardsInControllerGraveCondition(7), \"and has flying\"));\r\n        this.addAbility(ability);\r\n    }","commit_id":"c80e9739af7114aa7b5526492fda368b2ace0a76","url":"https://github.com/magefree/mage"},{"original_method":"public MysticZealot(UUID ownerId) {\r\n        super(ownerId, 36, \"Mystic Zealot\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{3}{W}\");\r\n        this.expansionSetCode = \"ODY\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Nomad\");\r\n        this.subtype.add(\"Mystic\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(4);\r\n\r\n        // Threshold - As long as seven or more cards are in your graveyard, Mystic Zealot gets +1/+1 and has flying.\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinousEffect(\r\n                                                                    new BoostSourceEffect(1, 1, Duration.WhileOnBattlefield), new CardsInControllerGraveCondition(7), \"<i>Threshold<\/i> - As long as seven or more cards are in your graveyard, {this} gets +1/+1\"));\r\n        ability.addEffect(new ConditionalContinousEffect(new GainAbilitySourceEffect(FlyingAbility.getInstance()), new CardsInControllerGraveCondition(7), \" and has flying\"));\r\n        this.addAbility(ability);\r\n    }","id":91817,"modified_method":"public MysticZealot(UUID ownerId) {\r\n        super(ownerId, 36, \"Mystic Zealot\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{3}{W}\");\r\n        this.expansionSetCode = \"ODY\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Nomad\");\r\n        this.subtype.add(\"Mystic\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(4);\r\n\r\n        // Threshold - As long as seven or more cards are in your graveyard, Mystic Zealot gets +1/+1 and has flying.\r\n        Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinousEffect(\r\n                                                                    new BoostSourceEffect(1, 1, Duration.WhileOnBattlefield), new CardsInControllerGraveCondition(7), \"<i>Threshold<\/i> - As long as seven or more cards are in your graveyard, {this} gets +1/+1\"));\r\n        ability.addEffect(new ConditionalContinousEffect(new GainAbilitySourceEffect(FlyingAbility.getInstance()), new CardsInControllerGraveCondition(7), \"and has flying\"));\r\n        this.addAbility(ability);\r\n    }","commit_id":"c80e9739af7114aa7b5526492fda368b2ace0a76","url":"https://github.com/magefree/mage"},{"original_method":"public PatrolHound(UUID ownerId) {\r\n        super(ownerId, 38, \"Patrol Hound\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{W}\");\r\n        this.expansionSetCode = \"ODY\";\r\n        this.subtype.add(\"Hound\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // Discard a card: Patrol Hound gains first strike until end of turn.\r\n        this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FirstStrikeAbility.getInstance()), new DiscardCardCost()));\r\n    }","id":91818,"modified_method":"public PatrolHound(UUID ownerId) {\r\n        super(ownerId, 38, \"Patrol Hound\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{W}\");\r\n        this.expansionSetCode = \"ODY\";\r\n        this.subtype.add(\"Hound\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // Discard a card: Patrol Hound gains first strike until end of turn.\r\n        this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn), new DiscardCardCost()));\r\n    }","commit_id":"c80e9739af7114aa7b5526492fda368b2ace0a76","url":"https://github.com/magefree/mage"},{"original_method":"public TapTargetCost(TargetControlledPermanent target) {\n        this.target = target;\n        this.text = \"Tap \" + target.getMaxNumberOfTargets() + \" \" + target.getTargetName();\n    }","id":91819,"modified_method":"public TapTargetCost(TargetControlledPermanent target) {\n        this.target = target;\n        this.text = \n            new StringBuilder(\"Tap \")\n                .append(target.getTargetName().startsWith(\"a \") || target.getTargetName().startsWith(\"an \") ? \"\":target.getMaxNumberOfTargets())\n                .append(\" \")\n                .append(target.getTargetName()).toString();\n    }","commit_id":"c80e9739af7114aa7b5526492fda368b2ace0a76","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean applies(Permanent permanent, Ability source, Game game) {\n        Permanent creature = game.getPermanent(source.getFirstTarget());\n        if (creature != null && creature.getId().equals(permanent.getId())) {\n            return true;\n        }\n        return false;\n    }","id":91820,"modified_method":"@Override\n    public boolean applies(Permanent permanent, Ability source, Game game) {\n        if (this.getTargetPointer().getTargets(game, source).contains(permanent.getId())) {\n            return true;\n        }\n        return false;\n    }","commit_id":"e269a63e04c6eb568807240896df4813ccd52268","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public String getText(Mode mode) {\n        if (this.duration == Duration.EndOfTurn)\n            return \"Target \" + mode.getTargets().get(0).getTargetName() + \" attacks this turn if able\";\n        else\n            return \"Target \" + mode.getTargets().get(0).getTargetName() + \" attacks each turn if able\";\n    }","id":91821,"modified_method":"@Override\n    public String getText(Mode mode) {\n        if (this.duration == Duration.EndOfTurn) {\n            return new StringBuilder(\"Target \").append(mode.getTargets().get(0).getTargetName()).append(\" attacks this turn if able\").toString();\n        }\n        else {\n            return new StringBuilder(\"Target \").append(mode.getTargets().get(0).getTargetName()).append(\" attacks each turn if able\").toString();\n        }\n    }","commit_id":"e269a63e04c6eb568807240896df4813ccd52268","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        for (Permanent creature : game.getBattlefield().getAllActivePermanents(filter, game)) {\r\n            AttacksIfAbleTargetEffect effect = new AttacksIfAbleTargetEffect(Duration.EndOfTurn);\r\n            effect.setTargetPointer(new FixedTarget(creature.getId()));\r\n            game.addEffect(effect, source);\r\n        }\r\n        return true;\r\n    }","id":91822,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        for (Permanent creature : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {\r\n            AttacksIfAbleTargetEffect effect = new AttacksIfAbleTargetEffect(Duration.EndOfTurn);\r\n            effect.setTargetPointer(new FixedTarget(creature.getId()));\r\n            game.addEffect(effect, source);\r\n        }\r\n        return true;\r\n    }","commit_id":"e269a63e04c6eb568807240896df4813ccd52268","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    protected Object reduce(Map<Integer, Object> map) {\n        int totalAffectedEntries = 0;\n        for (Object affectedEntries : map.values()) {\n            totalAffectedEntries += (Integer) affectedEntries;\n        }\n        final MapService service = getService();\n        final Address thisAddress = service.getNodeEngine().getThisAddress();\n        service.publishMapEvent(thisAddress, name, EntryEventType.CLEAR_ALL, totalAffectedEntries);\n        return null;\n    }","id":91823,"modified_method":"@Override\n    protected Object reduce(Map<Integer, Object> map) {\n        int totalAffectedEntries = 0;\n        for (Object affectedEntries : map.values()) {\n            totalAffectedEntries += (Integer) affectedEntries;\n        }\n        final MapService service = getService();\n        final Address thisAddress = service.getNodeEngine().getThisAddress();\n        if (totalAffectedEntries > 0) {\n            service.publishMapEvent(thisAddress, name, EntryEventType.CLEAR_ALL, totalAffectedEntries);\n        }\n        return null;\n    }","commit_id":"0bbafb80d0cb88322554c8437568b4c87f604291","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    protected Object reduce(Map<Integer, Object> map) {\n        int total = 0;\n        MapService mapService = getService();\n        for (Object result : map.values()) {\n            Integer size = (Integer) mapService.toObject(result);\n            total += size;\n        }\n        final MapService service = getService();\n        final Address thisAddress = service.getNodeEngine().getThisAddress();\n        service.publishMapEvent(thisAddress, name, EntryEventType.EVICT_ALL, total);\n        return total;\n    }","id":91824,"modified_method":"@Override\n    protected Object reduce(Map<Integer, Object> map) {\n        int total = 0;\n        MapService mapService = getService();\n        for (Object result : map.values()) {\n            Integer size = (Integer) mapService.toObject(result);\n            total += size;\n        }\n        final MapService service = getService();\n        final Address thisAddress = service.getNodeEngine().getThisAddress();\n        if (total > 0) {\n            service.publishMapEvent(thisAddress, name, EntryEventType.EVICT_ALL, total);\n        }\n        return total;\n    }","commit_id":"0bbafb80d0cb88322554c8437568b4c87f604291","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected void evictAllInternal() {\n        try {\n            clearNearCache();\n            final Operation operation = new EvictAllOperation(name);\n            final NodeEngine nodeEngine = getNodeEngine();\n            final Map<Integer, Object> resultMap\n                    = nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,\n                    new BinaryOperationFactory(operation, nodeEngine));\n\n            int numberOfAffectedEntries = 0;\n            for (Object o : resultMap.values()) {\n                numberOfAffectedEntries += (Integer) o;\n            }\n            publishMapEvent(numberOfAffectedEntries, EntryEventType.EVICT_ALL);\n        } catch (Throwable t) {\n            throw ExceptionUtil.rethrow(t);\n        }\n    }","id":91825,"modified_method":"protected void evictAllInternal() {\n        try {\n            clearNearCache();\n            final Operation operation = new EvictAllOperation(name);\n            final NodeEngine nodeEngine = getNodeEngine();\n            final Map<Integer, Object> resultMap\n                    = nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,\n                    new BinaryOperationFactory(operation, nodeEngine));\n\n            int numberOfAffectedEntries = 0;\n            for (Object o : resultMap.values()) {\n                numberOfAffectedEntries += (Integer) o;\n            }\n            if(numberOfAffectedEntries > 0 ){\n                publishMapEvent(numberOfAffectedEntries, EntryEventType.EVICT_ALL);\n            }\n        } catch (Throwable t) {\n            throw ExceptionUtil.rethrow(t);\n        }\n    }","commit_id":"6567532c6ad654bb3789453e70e3931593a9aba9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void clearInternal() {\n        final String mapName = name;\n        final NodeEngine nodeEngine = getNodeEngine();\n        try {\n            ClearOperation clearOperation = new ClearOperation(mapName);\n            clearOperation.setServiceName(SERVICE_NAME);\n            final Map<Integer, Object> resultMap = nodeEngine.getOperationService()\n                    .invokeOnAllPartitions(SERVICE_NAME, new BinaryOperationFactory(clearOperation, nodeEngine));\n\n            int numberOfAffectedEntries = 0;\n            for (Object o : resultMap.values()) {\n                numberOfAffectedEntries += (Integer) o;\n            }\n            publishMapEvent(numberOfAffectedEntries, EntryEventType.CLEAR_ALL);\n        } catch (Throwable t) {\n            throw ExceptionUtil.rethrow(t);\n        }\n    }","id":91826,"modified_method":"public void clearInternal() {\n        final String mapName = name;\n        final NodeEngine nodeEngine = getNodeEngine();\n        try {\n            ClearOperation clearOperation = new ClearOperation(mapName);\n            clearOperation.setServiceName(SERVICE_NAME);\n            final Map<Integer, Object> resultMap = nodeEngine.getOperationService()\n                    .invokeOnAllPartitions(SERVICE_NAME, new BinaryOperationFactory(clearOperation, nodeEngine));\n\n            int numberOfAffectedEntries = 0;\n            for (Object o : resultMap.values()) {\n                numberOfAffectedEntries += (Integer) o;\n            }\n            if(numberOfAffectedEntries > 0 ){\n                publishMapEvent(numberOfAffectedEntries, EntryEventType.CLEAR_ALL);\n            }\n        } catch (Throwable t) {\n            throw ExceptionUtil.rethrow(t);\n        }\n    }","commit_id":"6567532c6ad654bb3789453e70e3931593a9aba9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    void write(MethodWriter writer) {\n        writer.writeDebugInfo(location);\n        if (defInterface && captured.type.sort == Definition.Sort.DEF) {\n            // dynamic interface, dynamic implementation\n            writer.push(\"D\" + type + \".\" + call + \",1\");\n            writer.loadLocal(captured.slot);\n        } else if (defInterface) {\n            // dynamic interface, typed implementation\n            writer.push(\"S\" + captured.type.name + \".\" + call + \",1\");\n            writer.loadLocal(captured.slot);\n        } else if (ref == null) {\n            // typed interface, dynamic implementation\n            writer.loadLocal(captured.slot);\n            String descriptor = Type.getMethodType(expected.type, captured.type.type).getDescriptor();\n            writer.invokeDynamic(call, descriptor, DEF_BOOTSTRAP_HANDLE, (Object)DefBootstrap.REFERENCE, expected.name);\n        } else {\n            // typed interface, typed implementation\n            writer.loadLocal(captured.slot);\n            // convert MethodTypes to asm Type for the constant pool.\n            String invokedType = ref.invokedType.toMethodDescriptorString();\n            Type samMethodType = Type.getMethodType(ref.samMethodType.toMethodDescriptorString());\n            Type interfaceType = Type.getMethodType(ref.interfaceMethodType.toMethodDescriptorString());\n            if (ref.needsBridges()) {\n                writer.invokeDynamic(ref.invokedName, \n                                     invokedType, \n                                     LAMBDA_BOOTSTRAP_HANDLE, \n                                     samMethodType, \n                                     ref.implMethodASM, \n                                     samMethodType, \n                                     LambdaMetafactory.FLAG_BRIDGES, \n                                     1, \n                                     interfaceType);\n            } else {\n                writer.invokeDynamic(ref.invokedName, \n                                     invokedType, \n                                     LAMBDA_BOOTSTRAP_HANDLE, \n                                     samMethodType, \n                                     ref.implMethodASM, \n                                     samMethodType, \n                                     0);\n            }\n        }\n    }","id":91827,"modified_method":"@Override\n    void write(MethodWriter writer) {\n        writer.writeDebugInfo(location);\n        if (defInterface && captured.type.sort == Definition.Sort.DEF) {\n            // dynamic interface, dynamic implementation\n            writer.push(\"D\" + type + \".\" + call + \",1\");\n            writer.visitVarInsn(captured.type.type.getOpcode(Opcodes.ILOAD), captured.slot);\n        } else if (defInterface) {\n            // dynamic interface, typed implementation\n            writer.push(\"S\" + captured.type.name + \".\" + call + \",1\");\n            writer.visitVarInsn(captured.type.type.getOpcode(Opcodes.ILOAD), captured.slot);\n        } else if (ref == null) {\n            // typed interface, dynamic implementation\n            writer.visitVarInsn(captured.type.type.getOpcode(Opcodes.ILOAD), captured.slot);\n            String descriptor = Type.getMethodType(expected.type, captured.type.type).getDescriptor();\n            writer.invokeDynamic(call, descriptor, DEF_BOOTSTRAP_HANDLE, (Object)DefBootstrap.REFERENCE, expected.name);\n        } else {\n            // typed interface, typed implementation\n            writer.visitVarInsn(captured.type.type.getOpcode(Opcodes.ILOAD), captured.slot);\n            // convert MethodTypes to asm Type for the constant pool.\n            String invokedType = ref.invokedType.toMethodDescriptorString();\n            Type samMethodType = Type.getMethodType(ref.samMethodType.toMethodDescriptorString());\n            Type interfaceType = Type.getMethodType(ref.interfaceMethodType.toMethodDescriptorString());\n            if (ref.needsBridges()) {\n                writer.invokeDynamic(ref.invokedName, \n                                     invokedType, \n                                     LAMBDA_BOOTSTRAP_HANDLE, \n                                     samMethodType, \n                                     ref.implMethodASM, \n                                     samMethodType, \n                                     LambdaMetafactory.FLAG_BRIDGES, \n                                     1, \n                                     interfaceType);\n            } else {\n                writer.invokeDynamic(ref.invokedName, \n                                     invokedType, \n                                     LAMBDA_BOOTSTRAP_HANDLE, \n                                     samMethodType, \n                                     ref.implMethodASM, \n                                     samMethodType, \n                                     0);\n            }\n        }\n    }","commit_id":"16d17351f77ccae519a7f0263201056179e39d97","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     *\n     * @param title\n     * @param message\n     */\n    public void showDialog(String title, String message, AsyncCallback cb) {\n        MessageDialog messageDialog = new MessageDialog(getWysiwyg(), title, Dialog.BUTTON_NEXT);\n        if (cb!=null)\n        messageDialog.setAsyncCallback(cb);\n        messageDialog.setMessage(message, new String[0]);\n\n    }","id":91828,"modified_method":"/**\n     *\n     * @param title\n     * @param message\n     */\n    public void showDialog(String title, String message, AsyncCallback cb) {\n        try {\n            MessageDialog messageDialog = new MessageDialog(getWysiwyg(), title, Dialog.BUTTON_CANCEL);\n            if (cb!=null)\n                messageDialog.setAsyncCallback(cb);\n            messageDialog.setMessage(message, new String[0]);\n            messageDialog.show();\n        } catch (Throwable e) {\n            debugMessage(\"Error displaying failed \" + e.getMessage());\n            cb.onFailure(e);\n        }\n\n    }","commit_id":"c8eefc8b06938d1733e6a638deeb630f9781b6ca","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public synchronized void onSync()\n    {\n        if (syncInProgress) {\n            return;\n        }\n        syncInProgress = true;\n\n        // Compute our revision\n        syncedRevision = null;\n        if (version!=0) {\n\n            if (sendCursor)\n                insertCursor(getTextArea().getDocument());\n            syncedContent = getTextArea().getHTML();\n            if (sendCursor)\n                removeCursor(getTextArea().getDocument());\n            if ((version>0) && !initialContent.equals(syncedContent)) {\n                try {\n                    syncedRevision =\n                            Diff.diff(ToString.stringToArray(initialContent), ToString.stringToArray(syncedContent));\n                } catch (DifferentiationFailedException e) {\n                    showError(e, null);\n                }\n            }\n        } else {\n            syncedContent = \"\";\n        }\n\n        // Commit our revision and, at the same time, checkout the latest revision\n        // If we send -1 then we ask the server to reset it's content to the page content\n        boolean syncReset = ((version==0)&&(getConfig().getParameter(\"syncReset\", \"0\").equals(\"1\")));\n        WysiwygService.Singleton.getInstance().syncEditorContent(syncedRevision, pageName, version, syncReset, this);\n    }","id":91829,"modified_method":"public synchronized void onSync()\n    {\n        if (syncInProgress) {\n            debugMessage(\"Cannot sync because sync is in progress\");\n            return;\n        }\n        syncInProgress = true;\n\n        try {\n            // Compute our revision\n            syncedRevision = null;\n            if (version!=0) {\n\n                if (sendCursor)\n                    insertCursor(getTextArea().getDocument());\n                syncedContent = (version==0) ? \"\" : getTextArea().getHTML();\n                if (sendCursor)\n                    removeCursor(getTextArea().getDocument());\n                if ((version>0) && !initialContent.equals(syncedContent)) {\n                    try {\n                        syncedRevision =\n                                Diff.diff(ToString.stringToArray(initialContent), ToString.stringToArray(syncedContent));\n                    } catch (DifferentiationFailedException e) {\n                        showErrorAndResetSync(e);\n                    }\n                }\n            } else {\n                syncedContent = \"\";\n            }\n\n            // Commit our revision and, at the same time, checkout the latest revision\n            // If we send -1 then we ask the server to reset it's content to the page content\n            boolean syncReset = ((version==0)&&(getConfig().getParameter(\"syncReset\", \"0\").equals(\"1\")));\n            WysiwygService.Singleton.getInstance().syncEditorContent(syncedRevision, pageName, version, syncReset, this);\n        } catch (Throwable th) {\n            debugMessage(\"error in onSync \");\n            showErrorAndResetSync(th);\n        }\n    }","commit_id":"c8eefc8b06938d1733e6a638deeb630f9781b6ca","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void showError(Throwable caught, AsyncCallback cb) {\n        if (caught instanceof XWikiGWTException) {\n            XWikiGWTException exp = ((XWikiGWTException)caught);\n            if (exp.getCode()== 9002) {\n                // This is a login error\n                showDialog(getWysiwyg().getTranslation(\"appname\"), getWysiwyg().getTranslation(\"login_first\"), cb);\n            }\n            else if (exp.getCode()== 9001) {\n                // This is a right error\n                showDialog(getWysiwyg().getTranslation(\"appname\"), getWysiwyg().getTranslation(\"missing_rights\"), cb);\n            } else\n                showError(\"\" + exp.getCode(), exp.getFullMessage(), cb);\n        }\n        else {\n            if (caught!=null)\n                caught.printStackTrace();\n            showError(\"\", (caught==null) ? \"\" : caught.toString(), cb);\n        }\n    }","id":91830,"modified_method":"public void showError(Throwable caught, AsyncCallback cb) {\n        debugMessage(\"Error should be shown \" + caught.getMessage());\n        if (caught instanceof XWikiGWTException) {\n            debugMessage(\"Error is XWikiGWTException\");\n            XWikiGWTException exp = ((XWikiGWTException)caught);\n            if (exp.getCode()== 9002) {\n                // This is a login error\n                showDialog(getWysiwyg().getTranslation(\"appname\"), getWysiwyg().getTranslation(\"login_first\"), cb);\n            }\n            else if (exp.getCode()== 9001) {\n                // This is a right error\n                showDialog(getWysiwyg().getTranslation(\"appname\"), getWysiwyg().getTranslation(\"missing_rights\"), cb);\n            } else\n                showError(\"\" + exp.getCode(), exp.getFullMessage(), cb);\n        }\n        else {\n            debugMessage(\"Error is not XWikiGWTException\");\n            if (caught!=null)\n                caught.printStackTrace();\n            debugMessage(\"Error is: \" + caught.toString());\n            showError(\"\", (caught==null) ? \"\" : caught.toString(), cb);\n        }\n    }","commit_id":"c8eefc8b06938d1733e6a638deeb630f9781b6ca","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, RichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, RichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        // init the plugin id\n        id = Math.abs(Random.nextInt());\n\n        pageName = config.getParameter(\"syncPage\");\n        if (pageName == null) {\n            return;\n        }\n\n        sync = new PushButton(Images.INSTANCE.sync().createImage(), this);\n        sync.setTitle(Strings.INSTANCE.sync());\n\n        toolBarExtension.addFeature(\"sync\", sync);\n        getUIExtensionList().add(toolBarExtension);\n\n        initialContent = getTextArea().getHTML();\n        if (initialContent == null) {\n            initialContent = \"\";\n        }\n\n        timer = new Timer();\n        timer.addTimerListener(this);\n        timer.scheduleRepeating(wysiwyg.getParamAsInt(\"sync_delay\", DEFAULT_SYNC_DELAY));\n    }","id":91831,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, RichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, RichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        // init the plugin id\n        id = Math.abs(Random.nextInt());\n\n        pageName = config.getParameter(\"syncPage\");\n        if (pageName == null) {\n            return;\n        }\n\n        sync = new PushButton(Images.INSTANCE.sync().createImage(), this);\n        sync.setTitle(Strings.INSTANCE.sync());\n\n        toolBarExtension.addFeature(\"sync\", sync);\n        getUIExtensionList().add(toolBarExtension);\n\n        initialContent = (version==0) ? \"\" : getTextArea().getHTML();\n        if (initialContent == null) {\n            initialContent = \"\";\n        }\n\n        timer = new Timer();\n        timer.addTimerListener(this);\n        timer.scheduleRepeating(wysiwyg.getParamAsInt(\"sync_delay\", DEFAULT_SYNC_DELAY));\n    }","commit_id":"c8eefc8b06938d1733e6a638deeb630f9781b6ca","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AsyncCallback#onFailure(Throwable)\n     */\n    public synchronized void onFailure(Throwable caught)\n    {\n        getWysiwyg().showError(caught);\n   }","id":91832,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AsyncCallback#onFailure(Throwable)\n     */\n    public synchronized void onFailure(Throwable caught)\n    {\n        showErrorAndResetSync(caught);\n    }","commit_id":"c8eefc8b06938d1733e6a638deeb630f9781b6ca","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void showError(String code, String text, AsyncCallback cb) {\n        String[] args = new String[1];\n        args[0] = code;\n        String message = getWysiwyg().getTranslation(\"errorwithcode\", args) + \"\\r\\n\\r\\n\" + text;\n        showDialog(getWysiwyg().getTranslation(\"appname\"), message, cb);\n    }","id":91833,"modified_method":"public void showError(String code, String text, AsyncCallback cb) {\n        String[] args = new String[1];\n        args[0] = code;\n        debugMessage(\"Error ready to display\");\n        String message = getWysiwyg().getTranslation(\"errorwithcode\", args) + \"\\r\\n\\r\\n\" + text;\n        debugMessage(\"Error displaying: \" + message);\n        showDialog(getWysiwyg().getTranslation(\"appname\"), message, cb);\n    }","commit_id":"c8eefc8b06938d1733e6a638deeb630f9781b6ca","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void insertCursor(Document doc) {\n        try {\n            int color = id - 10 * (int) Math.floor(id / 10);\n            // insertCursor(element, id, color);\n            SpanElement cursorNode = doc.createSpanElement();\n            cursorNode.setId(\"cursor-\" + id);\n            cursorNode.setClassName(\"cursor cursor-\" + color);\n            cursorNode.setAttribute(\"style\", \"background-color: #\" + color + \";\");\n            Range range = doc.getSelection().getRangeAt(0);\n            try {\n                if (range!=null) {\n                    if (range.getStartContainer().equals(doc)\n                            &&range.getEndContainer().equals(doc)\n                            &&range.getStartOffset()==0\n                            &&range.getEndOffset()==0) {\n                        debugMessage(\"Cursor at start.. let's not handle it\");\n                    } else {\n                        debugMessage(\"Start container: \" + range.getStartContainer());\n                        debugMessage(\"Start offset: \" + range.getStartOffset());\n                        debugMessage(\"End container: \" + range.getEndContainer());\n                        debugMessage(\"End offset: \" + range.getEndOffset());\n                        range.surroundContents(cursorNode);\n                        debugMessage(\"surrounding range ok\");\n                    }\n                }\n            } catch (Exception e) {\n                try {\n                    debugMessage(\"Exception: \" + e.getMessage());\n                    debugMessage(\"error surrounding range\");\n                    if (range!=null) {\n                        debugMessage(\"Start container: \" + range.getStartContainer());\n                        debugMessage(\"Start offset: \" + range.getStartOffset());\n                        debugMessage(\"End container: \" + range.getEndContainer());\n                        debugMessage(\"End offset: \" + range.getEndOffset());\n                        try {\n                            debugMessage(\"Range content: \" + range.cloneContents().getInnerHTML());\n                        } catch (Exception e3) {\n                        }\n                    }\n                    Selection selection = doc.getSelection();\n                    if (selection!=null) {\n                        debugMessage(\"Selection range count: \" + selection.getRangeCount());\n                    }\n                } catch (Exception e2) {\n                    debugMessage(\"Exception: \" + e2.getMessage());\n                }\n            }\n\n        } catch (Exception e) {\n            debugMessage(\"Uncaught exception in insertCursor: \" + e.getMessage());\n        }\n\n    }","id":91834,"modified_method":"private void insertCursor(Document doc) {\n        try {\n            int color = id - 10 * (int) Math.floor(id / 10);\n            // insertCursor(element, id, color);\n            SpanElement cursorNode = doc.createSpanElement();\n            cursorNode.setId(\"cursor-\" + id);\n            cursorNode.setClassName(\"cursor cursor-\" + color);\n            cursorNode.setAttribute(\"style\", \"background-color: #\" + color + \";\");\n            Range range = doc.getSelection().getRangeAt(0);\n            try {\n                if (range!=null) {\n                    if (range.getStartContainer().equals(doc)\n                            &&range.getEndContainer().equals(doc)\n                            &&range.getStartOffset()==0\n                            &&range.getEndOffset()==0) {\n                        debugMessage(\"Cursor at start.. let's not handle it\");\n                    } else {\n                        debugMessage(\"Start container: \" + range.getStartContainer());\n                        debugMessage(\"Start offset: \" + range.getStartOffset());\n                        debugMessage(\"End container: \" + range.getEndContainer());\n                        debugMessage(\"End offset: \" + range.getEndOffset());\n                        range.surroundContents(cursorNode);\n                        debugMessage(\"surrounding range ok\");\n                    }\n                }\n            } catch (Exception e) {\n                try {\n                    debugMessage(\"error surrounding range\");\n                    debugMessage(\"Exception: \" + e.getMessage());\n                    e.printStackTrace();\n                    debugMessage(e.toString());\n                    if (range!=null) {\n                        debugMessage(\"Start container: \" + range.getStartContainer());\n                        debugMessage(\"Start offset: \" + range.getStartOffset());\n                        debugMessage(\"End container: \" + range.getEndContainer());\n                        debugMessage(\"End offset: \" + range.getEndOffset());\n                        try {\n                            debugMessage(\"Range content: \" + range.cloneContents().getInnerHTML());\n                        } catch (Exception e3) {\n                        }\n                    }\n                    Selection selection = doc.getSelection();\n                    if (selection!=null) {\n                        debugMessage(\"Selection range count: \" + selection.getRangeCount());\n                    }\n                } catch (Exception e2) {\n                    debugMessage(\"Exception: \" + e2.getMessage());\n                }\n            }\n\n        } catch (Exception e) {\n            debugMessage(\"Uncaught exception in insertCursor: \" + e.getMessage());\n        }\n\n    }","commit_id":"c8eefc8b06938d1733e6a638deeb630f9781b6ca","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AsyncCallback#onSuccess(Object)\n     */\n    public synchronized void onSuccess(SyncResult result)\n    {\n        // If result is null we have nothing to do\n        if (result == null) {\n            syncInProgress = false;\n            return;\n        }\n\n        SyncResult syncResult = result;\n        Revision newRevision = syncResult.getRevision();\n\n        try {\n            if (newRevision != null) {\n                // We don't have the latest version\n                // We need to take local changes that might have occured\n                if (maintainCursor && (version!=0))\n                 insertCursor(getTextArea().getDocument());\n                String localContent = getTextArea().getHTML();\n\n                String newHTMLContent =\n                    ToString.arrayToString(newRevision.patch(ToString.stringToArray(initialContent)));\n                String futureInitialContent = newHTMLContent;\n\n                if ((version!=0) && !localContent.equals(initialContent)) {\n                    try {\n                        // we need to rework the path to take into account the local content\n                        Revision localRevision = Diff.diff(ToString.stringToArray(initialContent), ToString.stringToArray(localContent));\n                        Revision localRevision2 = SyncTools.relocateRevision(localRevision, newRevision);\n                        newHTMLContent =\n                                ToString.arrayToString(localRevision2.patch(ToString.stringToArray(newHTMLContent)));\n                    } catch (Exception e) {\n                        debugMessage(\"Exception while applying local revision: \" + e.getMessage());\n                    }\n                }\n                initialContent = futureInitialContent;\n\n                // TODO improve by working on an cloned Document that is updated in one call in the textarea\n                setHTML(newHTMLContent);\n\n                // we should have retrieved the cursor so we need to remove it\n                if ((maintainCursor||sendCursor)&& (version!=0))\n                 removeCursor(getTextArea().getDocument());\n            } else {\n                // We have the latest version\n                initialContent = syncedContent;\n            }\n            version = syncResult.getVersion();\n            // normal ending let's reset the syncInProgress\n            syncInProgress = false;\n        } catch (Throwable e) {\n           showError(e, new AsyncCallback() {\n            public void onFailure(Throwable throwable) {\n                syncInProgress = false;\n            }\n\n            public void onSuccess(Object o) {\n                syncInProgress = false;\n            }\n           });\n        }\n    }","id":91835,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AsyncCallback#onSuccess(Object)\n     */\n    public synchronized void onSuccess(SyncResult result)\n    {\n        debugMessage(\"received result from server\");\n\n        // If result is null we have nothing to do\n        if (result == null) {\n            syncInProgress = false;\n            return;\n        }\n\n        SyncResult syncResult = result;\n        Revision newRevision = syncResult.getRevision();\n\n        try {\n            if (newRevision != null) {\n                // We don't have the latest version\n                // We need to take local changes that might have occured\n                if (maintainCursor && (version!=0))\n                 insertCursor(getTextArea().getDocument());\n                String localContent = (version==0) ? \"\" : getTextArea().getHTML();\n\n                String newHTMLContent = \"\";\n                try {\n                    newHTMLContent =\n                            ToString.arrayToString(newRevision.patch(ToString.stringToArray(initialContent)));\n                } catch (Exception e) {\n                    debugMessage(\"Exception while patching initial content: \" + e.getMessage());\n                    debugMessage(\"Initial content was: \" + initialContent);\n                    showErrorAndResetSync(e);\n                }\n                // this corresponds to the HTML that is the one known by the server\n                String futureInitialContent = newHTMLContent;\n\n                // we need to compute local changes, including the cursor\n                if ((version!=0) && !localContent.equals(initialContent)) {\n                    try {\n                        // we need to rework the path to take into account the local content\n                        Revision localRevision = Diff.diff(ToString.stringToArray(initialContent), ToString.stringToArray(localContent));\n                        Revision localRevision2 = SyncTools.relocateRevision(localRevision, newRevision);\n                        newHTMLContent =\n                                ToString.arrayToString(localRevision2.patch(ToString.stringToArray(newHTMLContent)));\n                    } catch (Exception e) {\n                        debugMessage(\"Exception while applying local revision: \" + e.getMessage());\n                    }\n                }\n                initialContent = futureInitialContent;\n\n                // TODO improve by working on an cloned Document that is updated in one call in the textarea\n                setHTML(newHTMLContent);\n\n                // we should have retrieved the cursor so we need to remove it\n                if ((maintainCursor||sendCursor)&& (version!=0))\n                 removeCursor(getTextArea().getDocument());\n            } else {\n                // We have the latest version\n                initialContent = syncedContent;\n            }\n            version = syncResult.getVersion();\n            // normal ending let's reset the syncInProgress\n            syncInProgress = false;\n        } catch (Throwable e) {\n            showErrorAndResetSync(e);\n        }\n    }","commit_id":"c8eefc8b06938d1733e6a638deeb630f9781b6ca","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void handleInsert(\n      CompletionContext context,\n      int startOffset,\n      LookupData data,\n      LookupItem item,\n      boolean signatureSelected,\n      char completionChar) {\n    //context.shiftOffsets(item.getLookupString().length() - data.prefix.length() - (context.selectionEndOffset - context.startOffset));\n\n    if (context.getOffsetMap().getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET) != context.getSelectionEndOffset()){\n      if (!CompletionUtil.isOverwrite(item, completionChar)){\n        final int lparenthOffset = -1;\n        context.getOffsetMap().addOffset(JavaCompletionUtil.LPAREN_OFFSET, lparenthOffset, true);\n        final int rparenthOffset = -1;\n        context.getOffsetMap().addOffset(JavaCompletionUtil.RPAREN_OFFSET, rparenthOffset, true);\n        final int argListEndOffset = -1;\n        context.getOffsetMap().addOffset(JavaCompletionUtil.ARG_LIST_END_OFFSET, argListEndOffset, true);\n      }\n      else{\n        context.editor.getDocument().deleteString(context.getSelectionEndOffset(),\n                                                  context.getOffsetMap().getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET));\n      }\n    }\n  }","id":91836,"modified_method":"public void handleInsert(\n      CompletionContext context,\n      int startOffset,\n      LookupData data,\n      LookupItem item,\n      boolean signatureSelected,\n      char completionChar) {\n    //context.shiftOffsets(item.getLookupString().length() - data.prefix.length() - (context.selectionEndOffset - context.startOffset));\n\n    final int idEndOffset = context.getOffsetMap().getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET);\n    if (idEndOffset != context.getSelectionEndOffset()){\n      if (!CompletionUtil.isOverwrite(item, completionChar)){\n        context.getOffsetMap().removeOffset(JavaCompletionUtil.LPAREN_OFFSET);\n        context.getOffsetMap().removeOffset(JavaCompletionUtil.RPAREN_OFFSET);\n        context.getOffsetMap().removeOffset(JavaCompletionUtil.ARG_LIST_END_OFFSET);\n      }\n      else{\n        context.editor.getDocument().deleteString(context.getSelectionEndOffset(), idEndOffset);\n      }\n    }\n  }","commit_id":"8e003e8740b934659a650022bd181e26445cf4e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param key key\n   * @return offset An offset registered earlier with this key.\n   * -1 if offset wasn't registered or became invalidated due to document changes\n   */\n  public int getOffset(Key key) {\n    final RangeMarker marker = myMap.get(key);\n    if (marker == null) return -1;\n    if (!marker.isValid()) {\n      removeOffset(key);\n      return -1;\n    }\n\n    final int endOffset = marker.getEndOffset();\n    if (marker.getStartOffset() != endOffset) {\n      addOffset(key, endOffset, true);\n    }\n    return endOffset;\n  }","id":91837,"modified_method":"/**\n   * @param key key\n   * @return offset An offset registered earlier with this key.\n   * -1 if offset wasn't registered or became invalidated due to document changes\n   */\n  public int getOffset(OffsetKey key) {\n    final RangeMarker marker = myMap.get(key);\n    if (marker == null) return -1;\n    if (!marker.isValid()) {\n      removeOffset(key);\n      return -1;\n    }\n\n    final int endOffset = marker.getEndOffset();\n    if (marker.getStartOffset() != endOffset) {\n      addOffset(key, endOffset, true);\n    }\n    return endOffset;\n  }","commit_id":"8e003e8740b934659a650022bd181e26445cf4e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Register key-offset binding. Offset will change together with {@link Document} editing operations\n   * unless an operation replaces completely the offset vicinity.\n   * @param key\n   * @param offset\n   * @param moveableToRight whether the offset should move right when a string is inserted directly into\n   * this offset position\n   */\n  public void addOffset(Key key, int offset, boolean moveableToRight) {\n    if (offset < 0) {\n      removeOffset(key);\n      return;\n    }\n\n    final RangeMarker marker = myDocument.createRangeMarker(offset, offset);\n    marker.setGreedyToRight(moveableToRight);\n    myMap.put(key, marker);\n  }","id":91838,"modified_method":"/**\n   * Register key-offset binding. Offset will change together with {@link Document} editing operations\n   * unless an operation replaces completely the offset vicinity.\n   * @param key\n   * @param offset\n   * @param moveableToRight whether the offset should move right when a string is inserted directly into\n   * this offset position\n   */\n  public void addOffset(OffsetKey key, int offset, boolean moveableToRight) {\n    if (offset < 0) {\n      removeOffset(key);\n      return;\n    }\n\n    final RangeMarker marker = myDocument.createRangeMarker(offset, offset);\n    marker.setGreedyToRight(moveableToRight);\n    myMap.put(key, marker);\n  }","commit_id":"8e003e8740b934659a650022bd181e26445cf4e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void removeOffset(Key key) {\n    myMap.remove(key);\n  }","id":91839,"modified_method":"public void removeOffset(OffsetKey key) {\n    myMap.remove(key);\n  }","commit_id":"8e003e8740b934659a650022bd181e26445cf4e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getPresentableName(VirtualFile vFile) {\n      final String presentableName = vFile.getPresentableName();\n      if (myElementPresentation == null || Comparing.strEqual(presentableName, myElementPresentation + \".\" + vFile.getExtension())) {\n        return presentableName;\n      }\n      return presentableName + \" (\" + myElementPresentation + \")\";\n    }","id":91840,"modified_method":"public String getPresentableName(VirtualFile vFile) {\n      final String presentableName = vFile.getPresentableName();\n      if (myElementPresentation == null) {\n        return presentableName;\n      }\n\n      if (UISettings.getInstance().HIDE_KNOWN_EXTENSION_IN_TABS) {\n        if (Comparing.strEqual(presentableName, myElementPresentation)) {\n          return presentableName;\n        }\n      } else if (Comparing.strEqual(presentableName, myElementPresentation + \".\" + vFile.getExtension())){\n        return presentableName;\n      }\n\n      return presentableName + \" (\" + myElementPresentation + \")\";\n    }","commit_id":"58dfed50d9951f1b9c7ec4d6e81edec56d6de585","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void annotateExternally(final PsiModifierListOwner listOwner,\n                                         final String annotationFQName,\n                                         @Nullable final XmlFile xmlFile,\n                                         final PsiFile codeUsageFile) {\n    if (xmlFile == null) return;\n    try {\n      final XmlDocument document = xmlFile.getDocument();\n      if (document != null) {\n        final XmlTag rootTag = document.getRootTag();\n        final String externalName = getNormalizedExternalName(listOwner);\n        if (rootTag != null) {\n          for (XmlTag tag : rootTag.getSubTags()) {\n            if (Comparing.strEqual(tag.getAttributeValue(\"name\"), externalName)) {\n              tag.add(XmlElementFactory.getInstance(xmlFile.getProject()).createTagFromText(\"<annotation name=\\'\" + annotationFQName + \"\\'/>\"));\n              return;\n            }\n          }\n          @NonNls final String text =\n            \"<item name=\\'\" + externalName + \"\\'>\\n\" + \"  <annotation name=\\'\" + annotationFQName + \"\\'/>\\n\" + \"<\/item>\";\n          rootTag.add(XmlElementFactory.getInstance(xmlFile.getProject()).createTagFromText(text));\n        }\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    finally {\n      if (codeUsageFile.getVirtualFile().isInLocalFileSystem()) {\n        UndoUtil.markPsiFileForUndo(codeUsageFile);\n      }\n    }\n  }","id":91841,"modified_method":"private static void annotateExternally(final PsiModifierListOwner listOwner,\n                                         final String annotationFQName,\n                                         @Nullable final XmlFile xmlFile,\n                                         final PsiFile codeUsageFile) {\n    if (xmlFile == null) return;\n    try {\n      final XmlDocument document = xmlFile.getDocument();\n      if (document != null) {\n        final XmlTag rootTag = document.getRootTag();\n        final String externalName = PsiFormatUtil.getExternalName(listOwner, false);\n        if (rootTag != null) {\n          for (XmlTag tag : rootTag.getSubTags()) {\n            if (Comparing.strEqual(tag.getAttributeValue(\"name\"), externalName)) {\n              tag.add(XmlElementFactory.getInstance(xmlFile.getProject()).createTagFromText(\"<annotation name=\\'\" + annotationFQName + \"\\'/>\"));\n              return;\n            }\n          }\n          @NonNls final String text =\n            \"<item name=\\'\" + externalName + \"\\'>\\n\" + \"  <annotation name=\\'\" + annotationFQName + \"\\'/>\\n\" + \"<\/item>\";\n          rootTag.add(XmlElementFactory.getInstance(xmlFile.getProject()).createTagFromText(text));\n        }\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    finally {\n      if (codeUsageFile.getVirtualFile().isInLocalFileSystem()) {\n        UndoUtil.markPsiFileForUndo(codeUsageFile);\n      }\n    }\n  }","commit_id":"e259b0c3f051a82a1d65709c6072648e048c4209","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean deannotate(final PsiModifierListOwner listOwner, final String annotationFQN) {\n    final List<XmlFile> files = findExternalAnnotationsFile(listOwner);\n    if (files != null) {\n      for (XmlFile file : files) {\n        if (file.isValid()) {\n          final XmlDocument document = file.getDocument();\n          if (document != null) {\n            final XmlTag rootTag = document.getRootTag();\n            if (rootTag != null) {\n              final String externalName = getNormalizedExternalName(listOwner);\n              for (final XmlTag tag : rootTag.getSubTags()) {\n                final String className = tag.getAttributeValue(\"name\");\n                if (Comparing.strEqual(className, externalName)) {\n                  for (XmlTag annotationTag : tag.getSubTags()) {\n                    if (Comparing.strEqual(annotationTag.getAttributeValue(\"name\"), annotationFQN)) {\n                      if (ReadonlyStatusHandler.getInstance(file.getProject())\n                        .ensureFilesWritable(file.getVirtualFile()).hasReadonlyFiles()) {\n                        return false;\n                      }\n                      try {\n                        annotationTag.delete();\n                        if (tag.getSubTags().length == 0) {\n                          tag.delete();\n                        }\n                      }\n                      catch (IncorrectOperationException e) {\n                        LOG.error(e);\n                      }\n                      return true;\n                    }\n                  }\n                  return false;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }","id":91842,"modified_method":"public boolean deannotate(final PsiModifierListOwner listOwner, final String annotationFQN) {\n    final List<XmlFile> files = findExternalAnnotationsFile(listOwner);\n    if (files != null) {\n      for (XmlFile file : files) {\n        if (file.isValid()) {\n          final XmlDocument document = file.getDocument();\n          if (document != null) {\n            final XmlTag rootTag = document.getRootTag();\n            if (rootTag != null) {\n              final String externalName = PsiFormatUtil.getExternalName(listOwner, false);\n              final String oldExternalName = getNormalizedExternalName(listOwner);\n              for (final XmlTag tag : rootTag.getSubTags()) {\n                final String className = tag.getAttributeValue(\"name\");\n                if (Comparing.strEqual(className, externalName) || Comparing.strEqual(className, oldExternalName)) {\n                  for (XmlTag annotationTag : tag.getSubTags()) {\n                    if (Comparing.strEqual(annotationTag.getAttributeValue(\"name\"), annotationFQN)) {\n                      if (ReadonlyStatusHandler.getInstance(file.getProject())\n                        .ensureFilesWritable(file.getVirtualFile()).hasReadonlyFiles()) {\n                        return false;\n                      }\n                      try {\n                        annotationTag.delete();\n                        if (tag.getSubTags().length == 0) {\n                          tag.delete();\n                        }\n                      }\n                      catch (IncorrectOperationException e) {\n                        LOG.error(e);\n                      }\n                      return true;\n                    }\n                  }\n                  return false;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }","commit_id":"e259b0c3f051a82a1d65709c6072648e048c4209","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Map<String, PsiAnnotation> collectExternalAnnotations(final PsiModifierListOwner listOwner) {\n    final Map<String, PsiAnnotation> result = new HashMap<String, PsiAnnotation>();\n    final List<XmlFile> files = findExternalAnnotationsFile(listOwner);\n    if (files != null) {\n      for (XmlFile file : files) {\n        if (file.isValid()) {\n          final XmlDocument document = file.getDocument();\n          if (document != null) {\n            final XmlTag rootTag = document.getRootTag();\n            if (rootTag != null) {\n              final String externalName = getNormalizedExternalName(listOwner);\n              for (final XmlTag tag : rootTag.getSubTags()) {\n                final String className = tag.getAttributeValue(\"name\");\n                if (Comparing.strEqual(className, externalName)) {\n                  for (XmlTag annotationTag : tag.getSubTags()) {\n                    final String annotationFQN = annotationTag.getAttributeValue(\"name\");\n                    final StringBuilder buf = new StringBuilder();\n                    for (XmlTag annotationaParameter : annotationTag.getSubTags()) {\n                      buf.append(\",\").append(annotationaParameter.getAttributeValue(\"name\")).append(\"=\")\n                        .append(annotationaParameter.getAttributeValue(\"value\"));\n                    }\n                    final String annotationText =\n                      \"@\" + annotationFQN + (buf.length() > 0 ? \"(\" + StringUtil.trimStart(buf.toString(), \",\") + \")\" : \"\");\n                    try {\n                      result.put(annotationFQN,\n                                 JavaPsiFacade.getInstance(listOwner.getProject()).getElementFactory().createAnnotationFromText(\n                                   annotationText, null));\n                    }\n                    catch (IncorrectOperationException e) {\n                      LOG.error(e);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }","id":91843,"modified_method":"private Map<String, PsiAnnotation> collectExternalAnnotations(final PsiModifierListOwner listOwner) {\n    final Map<String, PsiAnnotation> result = new HashMap<String, PsiAnnotation>();\n    final List<XmlFile> files = findExternalAnnotationsFile(listOwner);\n    if (files != null) {\n      for (XmlFile file : files) {\n        if (file.isValid()) {\n          final XmlDocument document = file.getDocument();\n          if (document != null) {\n            final XmlTag rootTag = document.getRootTag();\n            if (rootTag != null) {\n              final String externalName = PsiFormatUtil.getExternalName(listOwner, false);\n              final String oldExternalName = getNormalizedExternalName(listOwner);\n              for (final XmlTag tag : rootTag.getSubTags()) {\n                final String className = tag.getAttributeValue(\"name\");\n                if (Comparing.strEqual(className, externalName) || Comparing.strEqual(className, oldExternalName)) {\n                  for (XmlTag annotationTag : tag.getSubTags()) {\n                    final String annotationFQN = annotationTag.getAttributeValue(\"name\");\n                    final StringBuilder buf = new StringBuilder();\n                    for (XmlTag annotationaParameter : annotationTag.getSubTags()) {\n                      buf.append(\",\").append(annotationaParameter.getAttributeValue(\"name\")).append(\"=\")\n                        .append(annotationaParameter.getAttributeValue(\"value\"));\n                    }\n                    final String annotationText =\n                      \"@\" + annotationFQN + (buf.length() > 0 ? \"(\" + StringUtil.trimStart(buf.toString(), \",\") + \")\" : \"\");\n                    try {\n                      result.put(annotationFQN,\n                                 JavaPsiFacade.getInstance(listOwner.getProject()).getElementFactory().createAnnotationFromText(\n                                   annotationText, null));\n                    }\n                    catch (IncorrectOperationException e) {\n                      LOG.error(e);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }","commit_id":"e259b0c3f051a82a1d65709c6072648e048c4209","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static String getExternalName(PsiModifierListOwner owner) {\n    final StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      if (owner instanceof PsiClass) {\n        ClassUtil.formatClassName((PsiClass)owner, builder);\n        return builder.toString();\n      }\n      final PsiClass psiClass = PsiTreeUtil.getParentOfType(owner, PsiClass.class, false);\n      assert psiClass != null;\n      ClassUtil.formatClassName(psiClass, builder);\n      if (owner instanceof PsiMethod) {\n        return builder.toString() + \" \" + formatMethod((PsiMethod)owner, PsiSubstitutor.EMPTY,\n                                                       SHOW_NAME | SHOW_FQ_NAME | SHOW_TYPE | SHOW_PARAMETERS | SHOW_FQ_CLASS_NAMES,\n                                                       SHOW_NAME | SHOW_TYPE | SHOW_FQ_CLASS_NAMES);\n      }\n      else if (owner instanceof PsiField) {\n        return builder.toString() + \" \" + ((PsiField)owner).getName();\n      }\n      else if (owner instanceof PsiParameter) {\n        final PsiMethod psiMethod = PsiTreeUtil.getParentOfType(owner, PsiMethod.class);\n        if (psiMethod != null) {\n          return builder.toString() + \" \" + formatMethod(psiMethod, PsiSubstitutor.EMPTY,\n                                                         SHOW_NAME | SHOW_FQ_NAME | SHOW_TYPE | SHOW_PARAMETERS | SHOW_FQ_CLASS_NAMES,\n                                                         SHOW_NAME | SHOW_TYPE | SHOW_FQ_CLASS_NAMES) + \" \" + formatVariable(\n            (PsiVariable)owner, SHOW_NAME, PsiSubstitutor.EMPTY);\n        }\n      }\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n    return null;\n  }","id":91844,"modified_method":"@Nullable\n  public static String getExternalName(PsiModifierListOwner owner) {\n    return getExternalName(owner, true);\n  }","commit_id":"e259b0c3f051a82a1d65709c6072648e048c4209","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean eq_9lx3n0_a0a0a0a1a0a0b0e0h(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","id":91845,"modified_method":"private static boolean eq_9lx3n0_a0a0a0a1a0a0b0j0h(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","commit_id":"db6786744d4973928b85d7c4e26329e8c1f69185","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(EditorContext editorContext) {\n    final String cellId = editorContext.getSelectedCell().getCellId();\n    SNode nodeToSelect = CommentUtil.commentOut(myNode);\n    editorContext.flushEvents();\n    boolean canRestore = false;\n    if (cellId != null) {\n      EditorCell newNodeCell = editorContext.getEditorComponent().findNodeCell(myNode);\n      if (newNodeCell != null) {\n        EditorCell cellToSelect = CellFinderUtil.findChildByCondition(newNodeCell, new Condition<EditorCell>() {\n          public boolean met(EditorCell cell) {\n            return eq_9lx3n0_a0a0a0a1a0a0b0e0h(cell.getCellId(), cellId);\n          }\n        }, true, true);\n        if (cellToSelect != null) {\n          editorContext.getSelectionManager().setSelection(cellToSelect);\n          canRestore = true;\n        }\n      }\n    }\n    if (!(canRestore)) {\n      SelectionUtil.selectCell(editorContext, nodeToSelect, SelectionManager.LAST_EDITABLE_CELL);\n    }\n  }","id":91846,"modified_method":"public void execute(EditorContext editorContext) {\n    EditorCell selectedCell = editorContext.getSelectedCell();\n    if (selectedCell == null) {\n      return;\n    }\n    final String cellId = selectedCell.getCellId();\n    SNode actualSelectedNode = selectedCell.getSNode();\n    boolean isLabel = selectedCell instanceof EditorCell_Label;\n    int startPosition = (isLabel ? ((EditorCell_Label) selectedCell).getSelectionStart() : -1);\n    int endPosition = (isLabel ? ((EditorCell_Label) selectedCell).getSelectionEnd() : -1);\n    SNode nodeToSelect = CommentUtil.commentOut(myNode);\n    editorContext.flushEvents();\n    if (cellId != null) {\n      EditorCell newNodeCell = editorContext.getEditorComponent().findNodeCell(actualSelectedNode);\n      if (newNodeCell != null) {\n        EditorCell cellToSelect = CellFinderUtil.findChildByCondition(newNodeCell, new Condition<EditorCell>() {\n          public boolean met(EditorCell cell) {\n            return eq_9lx3n0_a0a0a0a1a0a0b0j0h(cell.getCellId(), cellId);\n          }\n        }, true, true);\n        if (cellToSelect != null) {\n          if (isLabel) {\n            editorContext.getSelectionManager().setSelection(actualSelectedNode, cellId, startPosition, endPosition);\n          } else {\n            editorContext.getSelectionManager().setSelection(actualSelectedNode, cellId);\n          }\n\n          return;\n        }\n      }\n    }\n    SelectionUtil.selectCell(editorContext, nodeToSelect, SelectionManager.LAST_EDITABLE_CELL);\n  }","commit_id":"db6786744d4973928b85d7c4e26329e8c1f69185","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_juwut9_a0a0a0a1a0a0b0e0g(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","id":91847,"modified_method":"private static boolean eq_juwut9_a0a0a0a1a0a0b0j0g(Object a, Object b) {\n    return (a != null ? a.equals(b) : a == b);\n  }","commit_id":"db6786744d4973928b85d7c4e26329e8c1f69185","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(EditorContext editorContext) {\n    final String cellId = editorContext.getSelectedCell().getCellId();\n    SNode uncommentedNode = CommentUtil.uncomment(myNode);\n    editorContext.flushEvents();\n    boolean canRestore = false;\n    if (cellId != null) {\n      EditorCell newNodeCell = editorContext.getEditorComponent().findNodeCell(uncommentedNode);\n      if (newNodeCell != null) {\n        EditorCell cellToSelect = CellFinderUtil.findChildByCondition(newNodeCell, new Condition<EditorCell>() {\n          public boolean met(EditorCell cell) {\n            return eq_juwut9_a0a0a0a1a0a0b0e0g(cell.getCellId(), cellId);\n          }\n        }, true, true);\n        if (cellToSelect != null) {\n          editorContext.getSelectionManager().setSelection(cellToSelect);\n          canRestore = true;\n        }\n      }\n    }\n    if (!(canRestore)) {\n      SelectionUtil.selectCell(editorContext, uncommentedNode, SelectionManager.LAST_EDITABLE_CELL);\n    }\n  }","id":91848,"modified_method":"public void execute(EditorContext editorContext) {\n    EditorCell selectedCell = editorContext.getSelectedCell();\n    if (selectedCell == null) {\n      return;\n    }\n    final String cellId = selectedCell.getCellId();\n    SNode actualSelectedNode = selectedCell.getSNode();\n    boolean isLabel = selectedCell instanceof EditorCell_Label;\n    int startPosition = (isLabel ? ((EditorCell_Label) selectedCell).getSelectionStart() : -1);\n    int endPosition = (isLabel ? ((EditorCell_Label) selectedCell).getSelectionEnd() : -1);\n    SNode uncommentedNode = CommentUtil.uncomment(myNode);\n    editorContext.flushEvents();\n    if (cellId != null) {\n      EditorCell newNodeCell = editorContext.getEditorComponent().findNodeCell(actualSelectedNode);\n      if (newNodeCell != null) {\n        EditorCell cellToSelect = CellFinderUtil.findChildByCondition(newNodeCell, new Condition<EditorCell>() {\n          public boolean met(EditorCell cell) {\n            return eq_juwut9_a0a0a0a1a0a0b0j0g(cell.getCellId(), cellId);\n          }\n        }, true, true);\n        if (cellToSelect != null) {\n          if (isLabel) {\n            editorContext.getSelectionManager().setSelection(actualSelectedNode, cellId, startPosition, endPosition);\n          } else {\n            editorContext.getSelectionManager().setSelection(actualSelectedNode, cellId);\n          }\n          return;\n        }\n      }\n    }\n    SelectionUtil.selectCell(editorContext, uncommentedNode, SelectionManager.LAST_EDITABLE_CELL);\n  }","commit_id":"db6786744d4973928b85d7c4e26329e8c1f69185","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Comment_Action() {\n    super(\"Comment Out\", \"\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(false);\n  }","id":91849,"modified_method":"public Comment_Action() {\n    super(\"Comment Out\", \"\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n  }","commit_id":"db6786744d4973928b85d7c4e26329e8c1f69185","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public EditorCell createEditorCell(jetbrains.mps.openapi.editor.EditorContext editorContext, SNode node) {\n    editorContext.getCellFactory().pushCellContext();\n    editorContext.getCellFactory().removeCellContextHints(EditorCellFactoryImpl.BASE_COMMENT_HINT);\n    EditorCell mainCell = myEditor.createEditorCell(editorContext, node);\n    editorContext.getCellFactory().popCellContext();\n    EditorCell_Collection result = jetbrains.mps.nodeEditor.cells.EditorCell_Collection.createIndent2(editorContext, node);\n    result.setBig(true);\n    result.getStyle().putAll(StyleRegistry.getInstance().getStyle(\"LINE_COMMENT\"), 1);\n    result.addEditorCell(createCommentConstantCell(editorContext, node, true));\n    result.addEditorCell(mainCell);\n    result.addEditorCell(createCommentConstantCell(editorContext, node, false));\n    return result;\n  }","id":91850,"modified_method":"@Override\n  public EditorCell createEditorCell(jetbrains.mps.openapi.editor.EditorContext editorContext, SNode node) {\n    editorContext.getCellFactory().pushCellContext();\n    editorContext.getCellFactory().removeCellContextHints(EditorCellFactoryImpl.BASE_COMMENT_HINT);\n    EditorCell mainCell = myEditor.createEditorCell(editorContext, node);\n    editorContext.getCellFactory().popCellContext();\n    EditorCell_Collection result = jetbrains.mps.nodeEditor.cells.EditorCell_Collection.createIndent2(editorContext, node);\n    result.setBig(true);\n    result.getStyle().putAll(StyleRegistry.getInstance().getStyle(\"LINE_COMMENT\"), 1);\n    result.addEditorCell(createCommentConstantCell(editorContext, node, true));\n    result.addEditorCell(mainCell);\n    result.addEditorCell(createCommentConstantCell(editorContext, node, false));\n    result.setCellId(\"main_comment_collection\");\n    return result;\n  }","commit_id":"db6786744d4973928b85d7c4e26329e8c1f69185","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell_Constant createCommentConstantCell(jetbrains.mps.openapi.editor.EditorContext editorContext, SNode node, boolean left) {\n    EditorCell_Constant cell = new EditorCell_Constant(editorContext, node, left ? \"/*\" : \"*/\", false);\n    StyleImpl style = new StyleImpl();\n    style.set(left ? StyleAttributes.PUNCTUATION_RIGHT : StyleAttributes.PUNCTUATION_LEFT, 0, true);\n    cell.getStyle().putAll(style, 0);\n    return cell;\n  }","id":91851,"modified_method":"private EditorCell_Constant createCommentConstantCell(jetbrains.mps.openapi.editor.EditorContext editorContext, SNode node, boolean left) {\n    EditorCell_Constant cell = new EditorCell_Constant(editorContext, node, left ? \"/*\" : \"*/\", false);\n    StyleImpl style = new StyleImpl();\n    style.set(left ? StyleAttributes.PUNCTUATION_RIGHT : StyleAttributes.PUNCTUATION_LEFT, 0, true);\n    cell.getStyle().putAll(style, 0);\n    cell.setCellId(left ? \"left_comment_constant\" : \"right_comment_constant\");\n    return cell;\n  }","commit_id":"db6786744d4973928b85d7c4e26329e8c1f69185","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Create an Action Chain.\n     *\n     * @param sk Session key (token)\n     * @param chainLabel Label of the action chain\n     * @return 1 on success\n     *\n     * @xmlrpc.doc Create an Action Chain.\n     * @xmlrpc.param #param_desc(\"string\", \"sessionKey\", \"Session token, issued at login\")\n     * @xmlrpc.param #param_desc(\"string\", \"chainLabel\", \"Label of the chain\")\n     * @xmlrpc.returntype #return_int_success()\n     */\n    public int createActionChain(String sk, String chainLabel) {\n        if (StringUtil.nullOrValue(sk) == null) {\n            throw new XmlRpcException(\"Session key is empty.\");\n        }\n        else if (StringUtil.nullOrValue(chainLabel) == null) {\n            throw new XmlRpcException(\"Action Chain label is empty.\");\n        }\n\n        ActionChainFactory.createActionChain(chainLabel,\n                                             ActionChainHandler.getLoggedInUser(sk));\n        return BaseHandler.VALID;\n    }","id":91852,"modified_method":"/**\n     * Create an Action Chain.\n     *\n     * @param sk Session key (token)\n     * @param chainLabel Label of the action chain\n     * @return 1 on success\n     *\n     * @xmlrpc.doc Create an Action Chain.\n     * @xmlrpc.param #param_desc(\"string\", \"sessionKey\", \"Session token, issued at login\")\n     * @xmlrpc.param #param_desc(\"string\", \"chainLabel\", \"Label of the chain\")\n     * @xmlrpc.returntype int actionId - The action id of the scheduled action\n     */\n    public Integer createActionChain(String sk, String chainLabel) {\n        if (StringUtil.nullOrValue(sk) == null) {\n            throw new InvalidParameterException(\"Session key is empty.\");\n        }\n        else if (StringUtil.nullOrValue(chainLabel) == null) {\n            throw new InvalidParameterException(\"Action Chain label is empty.\");\n        }\n\n        return ActionChainFactory.createActionChain(chainLabel,\n                                                    ActionChainHandler.getLoggedInUser(sk))\n                .getId().intValue();\n    }","commit_id":"3fa02a4738099c778c23a8c3fe41ffb2ed1dc47a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Adds an action to upgrade installed packages on the system.\n     *\n     * @param sk Session key (token)\n     * @param serverId System ID\n     * @param packages List of packages\n     * @param chainLabel Label of the action chain\n     * @return True or false in XML-RPC representation (1 or 0 respectively)\n     *\n     * @xmlrpc.doc Adds an action to upgrade installed packages on the system.\n     * @xmlrpc.param #param_desc(\"string\", \"sessionKey\", \"Session token, issued at login\")\n     * @xmlrpc.param #param_desc(\"int\", \"serverId\", \"System ID\")\n     * @xmlrpc.param #array_single(\"int\", \"packageId\")\n     * @xmlrpc.param #param_desc(\"string\", \"chainLabel\", \"Label of the chain\")\n     * @xmlrpc.returntype #int\n     */\n    public int addPackageUpgrade(String sk,\n                                 Integer serverId,\n                                 List<Integer> packages,\n                                 String chainLabel) {\n        Collector c = new Collector(sk, serverId, chainLabel);\n        List<Map<String, Long>> selectedPackages = this.acUtil.resolvePackages(\n                packages, c.getUser());\n        if (!selectedPackages.isEmpty()) {\n            return this.bool(ActionChainManager.schedulePackageUpgrade(\n                    c.getUser(), c.getServer(), selectedPackages,\n                                                new Date(), c.getChain()) != null);\n        }\n\n        return BaseHandler.INVALID;\n    }","id":91853,"modified_method":"/**\n     * Adds an action to upgrade installed packages on the system.\n     *\n     * @param sk Session key (token)\n     * @param serverId System ID\n     * @param packages List of packages\n     * @param chainLabel Label of the action chain\n     * @return True or false in XML-RPC representation (1 or 0 respectively)\n     *\n     * @xmlrpc.doc Adds an action to upgrade installed packages on the system.\n     * @xmlrpc.param #param_desc(\"string\", \"sessionKey\", \"Session token, issued at login\")\n     * @xmlrpc.param #param_desc(\"int\", \"serverId\", \"System ID\")\n     * @xmlrpc.param #array_single(\"int\", \"packageId\")\n     * @xmlrpc.param #param_desc(\"string\", \"chainLabel\", \"Label of the chain\")\n     * @xmlrpc.returntype #int\n     */\n    public int addPackageUpgrade(String sk,\n                                 Integer serverId,\n                                 List<Integer> packages,\n                                 String chainLabel) {\n        Collector c = new Collector(sk, serverId, chainLabel);\n        List<Map<String, Long>> selectedPackages = this.acUtil.resolvePackages(\n                packages, c.getUser());\n        if (!selectedPackages.isEmpty()) {\n            return ActionChainManager.schedulePackageUpgrade(\n                    c.getUser(), c.getServer(), selectedPackages,\n                    new Date(), c.getChain()).getId().intValue();\n        }\n\n        throw new InvalidPackageException(\"Packages were not found.\");\n    }","commit_id":"3fa02a4738099c778c23a8c3fe41ffb2ed1dc47a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Remove Action Chains by label.\n     *\n     * @param chainLabels List of action labels.\n     * @return State of the action result. Negative is false.\n     *         Positive: number of successfully deleted entries.\n     *\n     * @xmlrpc.doc Remove action chains by label.\n     * @xmlrpc.param #array_single(\"string\", \"chainLabels\")\n     * @xmlrpc.returntype #int\n     */\n    public int removeChains(List<String> chainLabels) {\n        if (chainLabels.isEmpty()) {\n            return BaseHandler.INVALID;\n        }\n\n        int d = 0;\n        for (String chainName : chainLabels) {\n            ActionChain chain = ActionChainFactory.getActionChain(chainName);\n            if (chain != null) {\n                ActionChainFactory.delete(chain);\n                d++;\n            }\n        }\n\n        return d > 0 ? d : BaseHandler.INVALID;\n    }","id":91854,"modified_method":"/**\n     * Remove Action Chains by label.\n     *\n     * @param chainLabels List of action labels.\n     * @return State of the action result. Negative is false.\n     *         Positive: number of successfully deleted entries.\n     *\n     * @xmlrpc.doc Remove action chains by label.\n     * @xmlrpc.param #array_single(\"string\", \"chainLabels\")\n     * @xmlrpc.returntype #return_int_success()\n     */\n    public Integer removeChains(List<String> chainLabels) {\n        if (chainLabels.isEmpty()) {\n            throw new InvalidParameterException(\"No chain labels has been passed!\");\n        }\n\n        for (String chainName : chainLabels) {\n            ActionChain chain = ActionChainFactory.getActionChain(chainName);\n            if (chain != null) {\n                ActionChainFactory.delete(chain);\n            }\n            else {\n                throw new NoSuchActionException(\n                        String.format(\"Action Chain '%s' was not found.\", chainName));\n            }\n        }\n\n        return BaseHandler.VALID;\n    }","commit_id":"3fa02a4738099c778c23a8c3fe41ffb2ed1dc47a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Add a remote command as a script.\n     *\n     * @param sk Session key (token)\n     * @param serverId System ID\n     * @param chainLabel Label of the action chain.\n     * @param uid User ID on the remote system.\n     * @param scriptBody Base64 encoded script.\n     * @param gid Group ID on the remote system.\n     * @param timeout Timeout\n     * @return True or false in XML-RPC representation (1 or 0 respectively)\n     *\n     * @xmlrpc.doc Add a remote command as a script.\n     *             NOTE: The script body must be Base64 encoded!\n     *\n     * @xmlrpc.param #param_desc(\"string\", \"sessionKey\", \"Session token, issued at login\")\n     * @xmlrpc.param #param_desc(\"int\", \"serverId\", \"System ID\")\n     * @xmlrpc.param #param_desc(\"string\", \"chainLabel\", \"Label of the chain\")\n     * @xmlrpc.param #param_desc(\"string\", \"uid\", \"User ID on the particular system\")\n     * @xmlrpc.param #param_desc(\"string\", \"gid\", \"Group ID on the particular system\")\n     * @xmlrpc.param #param_desc(\"int\", \"timeout\", \"Timeout cannot exceed 1200 seconds\")\n     * @xmlrpc.param #param_desc(\"string\", \"scriptBodyBase64\", \"Base64 encoded script body\")\n     * @xmlrpc.returntype #int\n     */\n    public int addRemoteCommand(String sk,\n                                Integer serverId,\n                                String chainLabel,\n                                String uid,\n                                String gid,\n                                Integer timeout,\n                                String scriptBody) {\n        if (StringUtil.nullOrValue(scriptBody) == null) {\n            return BaseHandler.INVALID;\n        }\n\n        Collector c = new Collector(sk, serverId, chainLabel);\n\n        List<Long> systems = new ArrayList<Long>();\n        systems.add((long) serverId);\n\n        if (timeout > 1200) {\n            timeout = 1200;\n        }\n\n        if (timeout < 1) {\n            timeout = 120;\n        }\n\n        ScriptActionDetails script = ActionManager.createScript(uid, gid, (long) timeout,\n            new String(DatatypeConverter.parseBase64Binary(scriptBody)));\n\n        Date date = new Date();\n\n        return this.bool(ActionChainManager.scheduleScriptRuns(\n                             c.getUser(), systems,\n                             String.format(\"Remote Script at %s\",\n                                           SimpleDateFormat.getDateInstance(\n                                                   SimpleDateFormat.MEDIUM).format(date)),\n                             script, date, c.getChain()) != null);\n    }","id":91855,"modified_method":"/**\n     * Add a remote command as a script.\n     *\n     * @param sk Session key (token)\n     * @param serverId System ID\n     * @param chainLabel Label of the action chain.\n     * @param uid User ID on the remote system.\n     * @param scriptBody Base64 encoded script.\n     * @param gid Group ID on the remote system.\n     * @param timeout Timeout\n     * @return True or false in XML-RPC representation (1 or 0 respectively)\n     *\n     * @xmlrpc.doc Add a remote command as a script.\n     *             NOTE: The script body must be Base64 encoded!\n     *\n     * @xmlrpc.param #param_desc(\"string\", \"sessionKey\", \"Session token, issued at login\")\n     * @xmlrpc.param #param_desc(\"int\", \"serverId\", \"System ID\")\n     * @xmlrpc.param #param_desc(\"string\", \"chainLabel\", \"Label of the chain\")\n     * @xmlrpc.param #param_desc(\"string\", \"uid\", \"User ID on the particular system\")\n     * @xmlrpc.param #param_desc(\"string\", \"gid\", \"Group ID on the particular system\")\n     * @xmlrpc.param #param_desc(\"int\", \"timeout\", \"Timeout cannot exceed 1200 seconds\")\n     * @xmlrpc.param #param_desc(\"string\", \"scriptBodyBase64\", \"Base64 encoded script body\")\n     * @xmlrpc.returntype int actionId - The id of the action or throw an exception\n     */\n    public Integer addRemoteCommand(String sk,\n                                Integer serverId,\n                                String chainLabel,\n                                String uid,\n                                String gid,\n                                Integer timeout,\n                                String scriptBody) {\n        if (StringUtil.nullOrValue(scriptBody) == null) {\n            throw new InvalidParameterException(\"Script body is empty.\");\n        }\n\n        Collector c = new Collector(sk, serverId, chainLabel);\n\n        List<Long> systems = new ArrayList<Long>();\n        systems.add((long) serverId);\n\n        if (timeout > ActionChainHandler.MAX_TIMEOUT) {\n            timeout = ActionChainHandler.MAX_TIMEOUT;\n        }\n\n        if (timeout < ActionChainHandler.MIN_TIMEOUT) {\n            timeout = ActionChainHandler.MIN_TIMEOUT;\n        }\n\n        ScriptActionDetails script = ActionManager.createScript(uid, gid, (long) timeout,\n            new String(DatatypeConverter.parseBase64Binary(scriptBody)));\n\n        Date date = new Date();\n\n        return ActionChainManager.scheduleScriptRuns(\n                             c.getUser(), systems,\n                             String.format(\"Remote Script at %s\",\n                                           SimpleDateFormat.getDateInstance(\n                                                   SimpleDateFormat.MEDIUM).format(date)),\n                             script, date, c.getChain())\n                .iterator().next().getId().intValue();\n    }","commit_id":"3fa02a4738099c778c23a8c3fe41ffb2ed1dc47a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Schedule package installation to an Action Chain.\n     *\n     * @param sk Session key (token)\n     * @param serverId System ID.\n     * @param packages List of packages.\n     * @param chainLabel Label of the Action Chain.\n     * @return True or false in XML-RPC representation: 1 or 0 respectively.\n     *\n     * @xmlrpc.doc Schedule package installation to an Action Chain.\n     * @xmlrpc.param #param_desc(\"string\", \"sessionKey\", \"Session token, issued at login\")\n     * @xmlrpc.param #param_desc(\"int\", \"serverId\", \"System ID\")\n     * @xmlrpc.param #array_single(\"int\", \"Package ID\")\n     * @xmlrpc.param #param(\"string\", \"chainLabel\")\n     * @xmlrpc.returntype #int\n     */\n    public int addPackageInstall(String sk,\n                                 Integer serverId,\n                                 List<Integer> packages,\n                                 String chainLabel) {\n        Collector c = new Collector(sk, serverId, chainLabel);\n        List<Map<String, Long>> selectedPackages = this.acUtil.resolvePackages(\n                packages, c.getUser());\n        if (!selectedPackages.isEmpty()) {\n            return this.bool(ActionChainManager.schedulePackageInstall(\n                    c.getUser(), c.getServer(), selectedPackages,\n                                                new Date(), c.getChain()) != null);\n        }\n\n        return BaseHandler.INVALID;\n    }","id":91856,"modified_method":"/**\n     * Schedule package installation to an Action Chain.\n     *\n     * @param sk Session key (token)\n     * @param serverId System ID.\n     * @param packages List of packages.\n     * @param chainLabel Label of the Action Chain.\n     * @return True or false in XML-RPC representation: 1 or 0 respectively.\n     *\n     * @xmlrpc.doc Schedule package installation to an Action Chain.\n     * @xmlrpc.param #param_desc(\"string\", \"sessionKey\", \"Session token, issued at login\")\n     * @xmlrpc.param #param_desc(\"int\", \"serverId\", \"System ID\")\n     * @xmlrpc.param #array_single(\"int\", \"Package ID\")\n     * @xmlrpc.param #param(\"string\", \"chainLabel\")\n     * @xmlrpc.returntype #return_int_success()\n     */\n    public Integer addPackageInstall(String sk,\n                                 Integer serverId,\n                                 List<Integer> packages,\n                                 String chainLabel) {\n        Collector c = new Collector(sk, serverId, chainLabel);\n        List<Map<String, Long>> selectedPackages = this.acUtil.resolvePackages(\n                packages, c.getUser());\n        if (!selectedPackages.isEmpty()) {\n            return ActionChainManager.schedulePackageInstall(\n                    c.getUser(), c.getServer(), selectedPackages,\n                    new Date(), c.getChain()).getId().intValue();\n        }\n\n        throw new InvalidPackageException(\"Packages were not found\");\n    }","commit_id":"3fa02a4738099c778c23a8c3fe41ffb2ed1dc47a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Adds an action to verify installed packages on the system.\n     *\n     * @param sk Session key (token)\n     * @param serverId System ID\n     * @param packages List of packages\n     * @param chainLabel Label of the action chain\n     * @return True or false in XML-RPC representation (1 or 0 respectively)\n     *\n     * @xmlrpc.doc Adds an action to verify installed packages on the system.\n     * @xmlrpc.param #param_desc(\"string\", \"sessionKey\", \"Session token, issued at login\")\n     * @xmlrpc.param #param_desc(\"int\", \"serverId\", \"System ID\")\n     * @xmlrpc.param #array_single(\"int\", \"packageId\")\n     * @xmlrpc.param #param_desc(\"string\", \"chainLabel\", \"Label of the chain\")\n     * @xmlrpc.returntype #int\n     */\n    public int addPackageVerify(String sk,\n                                Integer serverId,\n                                List<Integer> packages,\n                                String chainLabel) {\n        Collector c = new Collector(sk, serverId, chainLabel);\n        List<Map<String, Long>> selectedPackages = this.acUtil.selectPackages(\n                PackageManager.systemPackageList(c.getServer().getId(), null), packages);\n        if (!selectedPackages.isEmpty()) {\n            return this.bool(ActionChainManager.schedulePackageVerify(\n                    c.getUser(), c.getServer(), selectedPackages,\n                                                new Date(), c.getChain()) != null);\n        }\n\n        return BaseHandler.INVALID;\n    }","id":91857,"modified_method":"/**\n     * Adds an action to verify installed packages on the system.\n     *\n     * @param sk Session key (token)\n     * @param serverId System ID\n     * @param packages List of packages\n     * @param chainLabel Label of the action chain\n     * @return True or false in XML-RPC representation (1 or 0 respectively)\n     *\n     * @xmlrpc.doc Adds an action to verify installed packages on the system.\n     * @xmlrpc.param #param_desc(\"string\", \"sessionKey\", \"Session token, issued at login\")\n     * @xmlrpc.param #param_desc(\"int\", \"serverId\", \"System ID\")\n     * @xmlrpc.param #array_single(\"int\", \"packageId\")\n     * @xmlrpc.param #param_desc(\"string\", \"chainLabel\", \"Label of the chain\")\n     * @xmlrpc.returntype #return_int_success()\n     */\n    public Integer addPackageVerify(String sk,\n                                Integer serverId,\n                                List<Integer> packages,\n                                String chainLabel) {\n        Collector c = new Collector(sk, serverId, chainLabel);\n        List<Map<String, Long>> selectedPackages = this.acUtil.selectPackages(\n                PackageManager.systemPackageList(c.getServer().getId(), null), packages);\n        if (!selectedPackages.isEmpty()) {\n            return ActionChainManager.schedulePackageVerify(\n                    c.getUser(), c.getServer(), selectedPackages,\n                    new Date(), c.getChain()).getId().intValue();\n        }\n\n        throw new InvalidPackageException(\"Packages were not found.\");\n    }","commit_id":"3fa02a4738099c778c23a8c3fe41ffb2ed1dc47a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Schedule system reboot.\n     *\n     * @param sk Session key (token)\n     * @param serverId Server ID.\n     * @param chainLabel Label of the action chain\n     * @return list of action ids, exception thrown otherwise\n     *\n     * @xmlrpc.doc Schedule system reboot.\n     * @xmlrpc.param #param_desc(\"string\", \"sessionKey\", \"Session token, issued at login\")\n     * @xmlrpc.param #param(\"int\", \"serverId\")\n     * @xmlrpc.param #param_desc(\"string\", \"chainLabel\", \"Label of the chain\")\n     * @xmlrpc.returntype #int\n     */\n    public int addSystemReboot(String sk, Integer serverId, String chainLabel) {\n        Collector c = new Collector(sk, serverId, chainLabel);\n        return this.bool(ActionChainManager.scheduleRebootAction(\n                c.getUser(), c.getServer(), new Date(), c.getChain()) != null);\n    }","id":91858,"modified_method":"/**\n     * Schedule system reboot.\n     *\n     * @param sk Session key (token)\n     * @param serverId Server ID.\n     * @param chainLabel Label of the action chain\n     * @return list of action ids, exception thrown otherwise\n     *\n     * @xmlrpc.doc Schedule system reboot.\n     * @xmlrpc.param #param_desc(\"string\", \"sessionKey\", \"Session token, issued at login\")\n     * @xmlrpc.param #param(\"int\", \"serverId\")\n     * @xmlrpc.param #param_desc(\"string\", \"chainLabel\", \"Label of the chain\")\n     * @xmlrpc.returntype int actionId - The action id of the scheduled action\n     */\n    public Integer addSystemReboot(String sk, Integer serverId, String chainLabel) {\n        Collector c = new Collector(sk, serverId, chainLabel);\n        return ActionChainManager.scheduleRebootAction(\n                c.getUser(), c.getServer(),\n                new Date(), c.getChain()).getId().intValue();\n    }","commit_id":"3fa02a4738099c778c23a8c3fe41ffb2ed1dc47a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Adds an action to remove installed packages on the system.\n     *\n     * @param sk Session key (token)\n     * @param serverId System ID\n     * @param packages List of packages\n     * @param chainLabel Label of the action chain\n     * @return list of action ids, exception thrown otherwise\n     *\n     * @xmlrpc.doc Adds an action to remove installed packages on the system.\n     * @xmlrpc.param #param_desc(\"string\", \"sessionKey\", \"Session token, issued at login\")\n     * @xmlrpc.param #param_desc(\"int\", \"serverId\", \"System ID\")\n     * @xmlrpc.param\n     *    #array()\n     *       #struct(\"packages\")\n     *          #prop_desc(\"string\", \"label\", \"Package label\")\n     *          #prop_desc(\"string\", \"version\", \"Package version\")\n     *       #struct_end()\n     *    #array_end()\n     * @xmlrpc.param #param_desc(\"string\", \"chainLabel\", \"Label of the chain\")\n     * @xmlrpc.returntype #int\n     */\n    public int addPackageRemoval(String sk,\n                                 Integer serverId,\n                                 List<Map<String, String>> packages,\n                                 String chainLabel) {\n        Collector c = new Collector(sk, serverId, chainLabel);\n        List<Map<String, Long>> selectedPackages = this.acUtil.selectPackages(\n                SystemManager.installedPackages(c.getServer().getId(), true), packages, c);\n        if (!selectedPackages.isEmpty()) {\n            return this.bool(ActionChainManager.schedulePackageRemoval(\n                    c.getUser(), c.getServer(), selectedPackages,\n                                                new Date(), c.getChain()) != null);\n        }\n\n        return BaseHandler.INVALID;\n    }","id":91859,"modified_method":"/**\n     * Adds an action to remove installed packages on the system.\n     *\n     * @param sk Session key (token)\n     * @param serverId System ID\n     * @param packages List of packages\n     * @param chainLabel Label of the action chain\n     * @return list of action ids, exception thrown otherwise\n     *\n     * @xmlrpc.doc Adds an action to remove installed packages on the system.\n     * @xmlrpc.param #param_desc(\"string\", \"sessionKey\", \"Session token, issued at login\")\n     * @xmlrpc.param #param_desc(\"int\", \"serverId\", \"System ID\")\n     * @xmlrpc.param\n     *    #array()\n     *       #struct(\"packages\")\n     *          #prop_desc(\"string\", \"label\", \"Package label\")\n     *          #prop_desc(\"string\", \"version\", \"Package version\")\n     *       #struct_end()\n     *    #array_end()\n     * @xmlrpc.param #param_desc(\"string\", \"chainLabel\", \"Label of the chain\")\n     * @xmlrpc.returntype int actionId - The action id of the scheduled action\n     */\n    public Integer addPackageRemoval(String sk,\n                                 Integer serverId,\n                                 List<Map<String, String>> packages,\n                                 String chainLabel) {\n        Collector c = new Collector(sk, serverId, chainLabel);\n        List<Map<String, Long>> selectedPackages = this.acUtil.selectPackages(\n                SystemManager.installedPackages(c.getServer().getId(), true), packages, c);\n        if (!selectedPackages.isEmpty()) {\n            return ActionChainManager.schedulePackageRemoval(\n                    c.getUser(), c.getServer(), selectedPackages,\n                    new Date(), c.getChain()).getId().intValue();\n        }\n\n        throw new InvalidPackageException(\n                String.format(\"No such packages has been found on the system %s.\",\n                              serverId)\n        );\n    }","commit_id":"3fa02a4738099c778c23a8c3fe41ffb2ed1dc47a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Remove actions from an Action Chain.\n     *\n     * @param chainLabel The label of the Action Chain.\n     * @param actionNames List of action names.\n     * @return State of the action result. Negative is false.\n     *         Positive: number of successfully deleted entries.\n     *\n     * @xmlrpc.doc Remove actions from an Action Chain.\n     * @xmlrpc.param #param_desc(\"string\", \"chainLabel\", \"Label of the chain\")\n     * @xmlrpc.param #array_single(\"string\", \"actionName\")\n     * @xmlrpc.returntype #int\n     */\n    public int removeActions(String chainLabel,\n                             List<String> actionNames) {\n        if (StringUtil.nullOrValue(chainLabel) == null || actionNames.isEmpty()) {\n            return BaseHandler.INVALID;\n        }\n\n        int d = 0;\n        ActionChain chain = ActionChainFactory.getActionChain(chainLabel);\n        if (chain != null && !chain.getEntries().isEmpty()) {\n            List<ActionChainEntry> entriesToDelete = new ArrayList<ActionChainEntry>();\n            for (ActionChainEntry entry : chain.getEntries()) {\n                for (String actionName : actionNames) {\n                    if (entry.getAction().getName().equals(actionName)) {\n                        entriesToDelete.add(entry);\n                    }\n                }\n            }\n\n            if (!entriesToDelete.isEmpty()) {\n                for (ActionChainEntry entry : entriesToDelete) {\n                    d += chain.getEntries().remove(entry) ? 1 : 0;\n                }\n            }\n        }\n\n        return d > 0 ? d : this.bool(Boolean.FALSE);\n    }","id":91860,"modified_method":"/**\n     * Remove actions from an Action Chain.\n     *\n     * @param chainLabel The label of the Action Chain.\n     * @param actionNames List of action names.\n     * @return State of the action result. Negative is false.\n     *         Positive: number of successfully deleted entries.\n     *\n     * @xmlrpc.doc Remove actions from an Action Chain.\n     * @xmlrpc.param #param_desc(\"string\", \"chainLabel\", \"Label of the chain\")\n     * @xmlrpc.param #array_single(\"string\", \"actionName\")\n     * @xmlrpc.returntype #return_int_success()\n     */\n    // XXX: add user!!!\n    public Integer removeActions(String chainLabel,\n                                 List<String> actionNames) {\n        if (StringUtil.nullOrValue(chainLabel) == null) {\n            throw new InvalidParameterException(\"Action Chain label is empty.\");\n        }\n        else if (actionNames.isEmpty()) {\n            throw new InvalidParameterException(\"Session key is empty.\");\n        }\n\n        ActionChain chain = ActionChainFactory.getActionChain(chainLabel);\n        if (chain == null) {\n            throw new NoSuchActionException(\n                    String.format(\"Action Chain '%s' was not found.\", chainLabel));\n        }\n        else if (chain.getEntries().isEmpty()) {\n            throw new NoSuchActionException(\n                    String.format(\"Action Chain '%s' has no scheduled entries.\",\n                                  chainLabel));\n        }\n\n        List<ActionChainEntry> entriesToDelete = new ArrayList<ActionChainEntry>();\n        for (ActionChainEntry entry : chain.getEntries()) {\n            for (String actionName : actionNames) {\n                if (entry.getAction().getName().equals(actionName)) {\n                    entriesToDelete.add(entry);\n                }\n            }\n        }\n\n        if (entriesToDelete.isEmpty()) {\n            throw new NoSuchActionException(\n                    String.format(\"Action Chain '%s' has no such \"\n                            + \"requested scheduled entries.\", chainLabel));\n        }\n\n        for (ActionChainEntry entry : entriesToDelete) {\n            chain.getEntries().remove(entry);\n        }\n\n        return BaseHandler.VALID;\n    }","commit_id":"3fa02a4738099c778c23a8c3fe41ffb2ed1dc47a","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public Iterable<Person> getPersonsFromMeTo( Person otherPerson,\n                                                int maxDepth )\n    {\n        // use graph algo to calculate a shortest path\n        PathFinder<Path> finder = GraphAlgoFactory.shortestPath(\n                Traversal.expanderForTypes( FRIEND, Direction.BOTH ), maxDepth );\n\n        Path path = finder.findSinglePath( underlyingNode,\n                otherPerson.getUnderlyingNode() );\n        return new IterableWrapper<Person, Node>( path.nodes() )\n        {\n            @Override\n            protected Person underlyingObjectToObject( Node node )\n            {\n                return new Person( node );\n            }\n        };\n    }","id":91861,"modified_method":"public Iterable<Person> getShortestPathTo( Person otherPerson,\n                                               int maxDepth )\n    {\n        // use graph algo to calculate a shortest path\n        PathFinder<Path> finder = GraphAlgoFactory.shortestPath(\n                Traversal.expanderForTypes( FRIEND, Direction.BOTH ), maxDepth );\n\n        Path path = finder.findSinglePath( underlyingNode,\n                otherPerson.getUnderlyingNode() );\n        return createPersonsFromNodes( path );\n    }","commit_id":"41ad2e5caa8a5a4702091eb397571f0a69755192","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean equals( Object o )\n    {\n        if ( o instanceof Person )\n        {\n            return underlyingNode.equals( ( (Person)o ).getUnderlyingNode() );\n        }\n        return false;\n    }","id":91862,"modified_method":"@Override\n    public boolean equals( Object o )\n    {\n        return o instanceof Person &&\n                underlyingNode.equals( ( (Person)o ).getUnderlyingNode() );\n    }","commit_id":"41ad2e5caa8a5a4702091eb397571f0a69755192","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Iterable<Person> getFriendsByDepth( int depth )\n    {\n        // return all my friends and their friends using new traversal API\n        TraversalDescription travDesc = Traversal.description()\n                .breadthFirst()\n                .relationships( FRIEND )\n                .uniqueness( Uniqueness.NODE_GLOBAL )\n                .prune( Traversal.pruneAfterDepth( depth ) )\n                .filter( Traversal.returnAllButStartNode() );\n\n        return new IterableWrapper<Person, Path>(\n                travDesc.traverse( underlyingNode ) )\n        {\n            @Override\n            protected Person underlyingObjectToObject( Path path )\n            {\n                return new Person( path.endNode() );\n            }\n        };\n    }","id":91863,"modified_method":"private Iterable<Person> getFriendsByDepth( int depth )\n    {\n        // return all my friends and their friends using new traversal API\n        TraversalDescription travDesc = Traversal.description()\n                .breadthFirst()\n                .relationships( FRIEND )\n                .uniqueness( Uniqueness.NODE_GLOBAL )\n                .prune( Traversal.pruneAfterDepth( depth ) )\n                .filter( Traversal.returnAllButStartNode() );\n\n        return createPersonsFromPath( travDesc.traverse( underlyingNode ) );\n    }","commit_id":"41ad2e5caa8a5a4702091eb397571f0a69755192","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph();\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getPersonsFromMeTo( endMan, 4 );\n        assertPathIs( path, start, middleMan1, middleMan2, endMan );\n    }","id":91864,"modified_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph();\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getShortestPathTo( endMan, 4 );\n        assertPathIs( path, start, middleMan1, middleMan2, endMan );\n    }","commit_id":"41ad2e5caa8a5a4702091eb397571f0a69755192","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Iterable<Person> getPersonsFromMeTo( Person otherPerson,\n                                                int maxDepth )\n    {\n        // use graph algo to calculate a shortest path\n        PathFinder<Path> finder = GraphAlgoFactory.shortestPath(\n                Traversal.expanderForTypes( FRIEND, Direction.BOTH ), maxDepth );\n\n        Path path = finder.findSinglePath( underlyingNode,\n                otherPerson.getUnderlyingNode() );\n        return new IterableWrapper<Person, Node>( path.nodes() )\n        {\n            @Override\n            protected Person underlyingObjectToObject( Node node )\n            {\n                return new Person( node );\n            }\n        };\n    }","id":91865,"modified_method":"public Iterable<Person> getShortestPathTo( Person otherPerson,\n                                               int maxDepth )\n    {\n        // use graph algo to calculate a shortest path\n        PathFinder<Path> finder = GraphAlgoFactory.shortestPath(\n                Traversal.expanderForTypes( FRIEND, Direction.BOTH ), maxDepth );\n\n        Path path = finder.findSinglePath( underlyingNode,\n                otherPerson.getUnderlyingNode() );\n        return createPersonsFromNodes( path );\n    }","commit_id":"c1510e513a696ef5995535a75ce46d886047e0d8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean equals( Object o )\n    {\n        if ( o instanceof Person )\n        {\n            return underlyingNode.equals( ( (Person)o ).getUnderlyingNode() );\n        }\n        return false;\n    }","id":91866,"modified_method":"@Override\n    public boolean equals( Object o )\n    {\n        return o instanceof Person &&\n                underlyingNode.equals( ( (Person)o ).getUnderlyingNode() );\n    }","commit_id":"c1510e513a696ef5995535a75ce46d886047e0d8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Iterable<Person> getFriendsByDepth( int depth )\n    {\n        // return all my friends and their friends using new traversal API\n        TraversalDescription travDesc = Traversal.description()\n                .breadthFirst()\n                .relationships( FRIEND )\n                .uniqueness( Uniqueness.NODE_GLOBAL )\n                .prune( Traversal.pruneAfterDepth( depth ) )\n                .filter( Traversal.returnAllButStartNode() );\n\n        return new IterableWrapper<Person, Path>(\n                travDesc.traverse( underlyingNode ) )\n        {\n            @Override\n            protected Person underlyingObjectToObject( Path path )\n            {\n                return new Person( path.endNode() );\n            }\n        };\n    }","id":91867,"modified_method":"private Iterable<Person> getFriendsByDepth( int depth )\n    {\n        // return all my friends and their friends using new traversal API\n        TraversalDescription travDesc = Traversal.description()\n                .breadthFirst()\n                .relationships( FRIEND )\n                .uniqueness( Uniqueness.NODE_GLOBAL )\n                .prune( Traversal.pruneAfterDepth( depth ) )\n                .filter( Traversal.returnAllButStartNode() );\n\n        return createPersonsFromPath( travDesc.traverse( underlyingNode ) );\n    }","commit_id":"c1510e513a696ef5995535a75ce46d886047e0d8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph();\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getPersonsFromMeTo( endMan, 4 );\n        assertPathIs( path, start, middleMan1, middleMan2, endMan );\n    }","id":91868,"modified_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph();\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getShortestPathTo( endMan, 4 );\n        assertPathIs( path, start, middleMan1, middleMan2, endMan );\n    }","commit_id":"c1510e513a696ef5995535a75ce46d886047e0d8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Iterable<Person> getFriendsByDepth( int depth )\n    {\n        // return all my friends and their friends using new traversal API\n        TraversalDescription travDesc = Traversal.description()\n                .breadthFirst()\n                .relationships( FRIEND )\n                .uniqueness( Uniqueness.NODE_GLOBAL )\n                .prune( Traversal.pruneAfterDepth( depth ) )\n                .filter( Traversal.returnAllButStartNode() );\n\n        return new IterableWrapper<Person, Path>(\n                travDesc.traverse( underlyingNode ) )\n        {\n            @Override\n            protected Person underlyingObjectToObject( Path path )\n            {\n                return new Person( path.endNode() );\n            }\n        };\n    }","id":91869,"modified_method":"private Iterable<Person> getFriendsByDepth( int depth )\n    {\n        // return all my friends and their friends using new traversal API\n        TraversalDescription travDesc = Traversal.description()\n                .breadthFirst()\n                .relationships( FRIEND )\n                .uniqueness( Uniqueness.NODE_GLOBAL )\n                .prune( Traversal.pruneAfterDepth( depth ) )\n                .filter( Traversal.returnAllButStartNode() );\n\n        return createPersonsFromPath( travDesc.traverse( underlyingNode ) );\n    }","commit_id":"9560890b212fd74e063f028e88744f59780f842e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Iterable<Person> getPersonsFromMeTo( Person otherPerson,\n                                                int maxDepth )\n    {\n        // use graph algo to calculate a shortest path\n        PathFinder<Path> finder = GraphAlgoFactory.shortestPath(\n                Traversal.expanderForTypes( FRIEND, Direction.BOTH ), maxDepth );\n\n        Path path = finder.findSinglePath( underlyingNode,\n                otherPerson.getUnderlyingNode() );\n        return new IterableWrapper<Person, Node>( path.nodes() )\n        {\n            @Override\n            protected Person underlyingObjectToObject( Node node )\n            {\n                return new Person( node );\n            }\n        };\n    }","id":91870,"modified_method":"public Iterable<Person> getShortestPathTo( Person otherPerson,\n                                               int maxDepth )\n    {\n        // use graph algo to calculate a shortest path\n        PathFinder<Path> finder = GraphAlgoFactory.shortestPath(\n                Traversal.expanderForTypes( FRIEND, Direction.BOTH ), maxDepth );\n\n        Path path = finder.findSinglePath( underlyingNode,\n                otherPerson.getUnderlyingNode() );\n        return createPersonsFromNodes( path );\n    }","commit_id":"9560890b212fd74e063f028e88744f59780f842e","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean equals( Object o )\n    {\n        if ( o instanceof Person )\n        {\n            return underlyingNode.equals( ( (Person)o ).getUnderlyingNode() );\n        }\n        return false;\n    }","id":91871,"modified_method":"@Override\n    public boolean equals( Object o )\n    {\n        return o instanceof Person &&\n                underlyingNode.equals( ( (Person)o ).getUnderlyingNode() );\n    }","commit_id":"9560890b212fd74e063f028e88744f59780f842e","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph();\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getPersonsFromMeTo( endMan, 4 );\n        assertPathIs( path, start, middleMan1, middleMan2, endMan );\n    }","id":91872,"modified_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph();\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getShortestPathTo( endMan, 4 );\n        assertPathIs( path, start, middleMan1, middleMan2, endMan );\n    }","commit_id":"9560890b212fd74e063f028e88744f59780f842e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Iterable<Person> getPersonsFromMeTo( Person otherPerson,\n                                                int maxDepth )\n    {\n        // use graph algo to calculate a shortest path\n        PathFinder<Path> finder = GraphAlgoFactory.shortestPath(\n                Traversal.expanderForTypes( FRIEND, Direction.BOTH ), maxDepth );\n\n        Path path = finder.findSinglePath( underlyingNode,\n                otherPerson.getUnderlyingNode() );\n        return new IterableWrapper<Person, Node>( path.nodes() )\n        {\n            @Override\n            protected Person underlyingObjectToObject( Node node )\n            {\n                return new Person( node );\n            }\n        };\n    }","id":91873,"modified_method":"public Iterable<Person> getShortestPathTo( Person otherPerson,\n                                               int maxDepth )\n    {\n        // use graph algo to calculate a shortest path\n        PathFinder<Path> finder = GraphAlgoFactory.shortestPath(\n                Traversal.expanderForTypes( FRIEND, Direction.BOTH ), maxDepth );\n\n        Path path = finder.findSinglePath( underlyingNode,\n                otherPerson.getUnderlyingNode() );\n        return createPersonsFromNodes( path );\n    }","commit_id":"52ac4995e07cb9d7d956020a6946f1ef0cedf63c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Iterable<Person> getFriendsByDepth( int depth )\n    {\n        // return all my friends and their friends using new traversal API\n        TraversalDescription travDesc = Traversal.description()\n                .breadthFirst()\n                .relationships( FRIEND )\n                .uniqueness( Uniqueness.NODE_GLOBAL )\n                .prune( Traversal.pruneAfterDepth( depth ) )\n                .filter( Traversal.returnAllButStartNode() );\n\n        return new IterableWrapper<Person, Path>(\n                travDesc.traverse( underlyingNode ) )\n        {\n            @Override\n            protected Person underlyingObjectToObject( Path path )\n            {\n                return new Person( path.endNode() );\n            }\n        };\n    }","id":91874,"modified_method":"private Iterable<Person> getFriendsByDepth( int depth )\n    {\n        // return all my friends and their friends using new traversal API\n        TraversalDescription travDesc = Traversal.description()\n                .breadthFirst()\n                .relationships( FRIEND )\n                .uniqueness( Uniqueness.NODE_GLOBAL )\n                .prune( Traversal.pruneAfterDepth( depth ) )\n                .filter( Traversal.returnAllButStartNode() );\n\n        return createPersonsFromPath( travDesc.traverse( underlyingNode ) );\n    }","commit_id":"52ac4995e07cb9d7d956020a6946f1ef0cedf63c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean equals( Object o )\n    {\n        if ( o instanceof Person )\n        {\n            return underlyingNode.equals( ( (Person)o ).getUnderlyingNode() );\n        }\n        return false;\n    }","id":91875,"modified_method":"@Override\n    public boolean equals( Object o )\n    {\n        return o instanceof Person &&\n                underlyingNode.equals( ( (Person)o ).getUnderlyingNode() );\n    }","commit_id":"52ac4995e07cb9d7d956020a6946f1ef0cedf63c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph();\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getPersonsFromMeTo( endMan, 4 );\n        assertPathIs( path, start, middleMan1, middleMan2, endMan );\n    }","id":91876,"modified_method":"@Test\n    public void getPathBetweenFriends() throws Exception\n    {\n        deleteSocialGraph();\n        Person start = personRepository.createPerson( \"start\" );\n        Person middleMan1 = personRepository.createPerson( \"middle1\" );\n        Person middleMan2 = personRepository.createPerson( \"middle2\" );\n        Person endMan = personRepository.createPerson( \"endMan\" );\n\n        // Start -> middleMan1 -> middleMan2 -> endMan\n\n        start.addFriend( middleMan1 );\n        middleMan1.addFriend( middleMan2 );\n        middleMan2.addFriend( endMan );\n\n        Iterable<Person> path = start.getShortestPathTo( endMan, 4 );\n        assertPathIs( path, start, middleMan1, middleMan2, endMan );\n    }","commit_id":"52ac4995e07cb9d7d956020a6946f1ef0cedf63c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void doRefactoring() {\n    SPropertyOperations.set(this.myDeclaration, \"name\", SPropertyOperations.getString(this.myParameters.getDeclaration(), \"name\"));\n    if (this.myParameters.isReturnValueChanged()) {\n      SLinkOperations.setTarget(this.myDeclaration, \"returnType\", SNodeOperations.copyNode(SLinkOperations.getTarget(this.myParameters.getDeclaration(), \"returnType\", true)), true);\n    }\n    if (SNodeOperations.isInstanceOf(this.myDeclaration, \"jetbrains.mps.baseLanguage.structure.IVisible\")) {\n      if (this.myParameters.isVisibilityChanged()) {\n        SLinkOperations.setTarget(SNodeOperations.cast(this.myDeclaration, \"jetbrains.mps.baseLanguage.structure.IVisible\"), \"visibility\", SLinkOperations.getTarget(SNodeOperations.cast(this.myParameters.getDeclaration(), \"jetbrains.mps.baseLanguage.structure.IVisible\"), \"visibility\", true), true);\n      }\n    }\n    this.changeParameters();\n    SLinkOperations.removeAllChildren(this.myDeclaration, \"throwsItem\");\n    for (SNode throwItem : ListSequence.fromList(SLinkOperations.getTargets(this.myParameters.getDeclaration(), \"throwsItem\", true))) {\n      ListSequence.fromList(SLinkOperations.getTargets(this.myDeclaration, \"throwsItem\", true)).addElement(SNodeOperations.copyNode(throwItem));\n    }\n    for (SNode node : ListSequence.fromList(this.myUssages)) {\n      MethodCallAdapter call = new MethodCallAdapter(node);\n      List<SNode> oldArgs = call.getMethodArguments();\n      call.removeArguments();\n      for (SNode parameter : ListSequence.fromList(SLinkOperations.getTargets(this.myParameters.getDeclaration(), \"parameter\", true))) {\n        int index = ListSequence.fromList(this.myParameters.getIdList()).indexOf(parameter.getId());\n        if (index == -1) {\n          call.addArgument(SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.NullLiteral\", null));\n        } else {\n          call.addArgument(ListSequence.fromList(oldArgs).getElement(index));\n        }\n      }\n    }\n  }","id":91877,"modified_method":"public void doRefactoring() {\n    SPropertyOperations.set(this.myDeclaration, \"name\", SPropertyOperations.getString(this.myParameters.getDeclaration(), \"name\"));\n    if (this.myParameters.isReturnValueChanged()) {\n      SLinkOperations.setTarget(this.myDeclaration, \"returnType\", SNodeOperations.copyNode(SLinkOperations.getTarget(this.myParameters.getDeclaration(), \"returnType\", true)), true);\n    }\n    if (SNodeOperations.isInstanceOf(this.myDeclaration, \"jetbrains.mps.baseLanguage.structure.IVisible\")) {\n      if (this.myParameters.isVisibilityChanged()) {\n        SLinkOperations.setTarget(SNodeOperations.cast(this.myDeclaration, \"jetbrains.mps.baseLanguage.structure.IVisible\"), \"visibility\", SLinkOperations.getTarget(SNodeOperations.cast(this.myParameters.getDeclaration(), \"jetbrains.mps.baseLanguage.structure.IVisible\"), \"visibility\", true), true);\n      }\n    }\n    this.changeParameters();\n    ListSequence.fromList(SLinkOperations.getTargets(this.myDeclaration, \"throwsItem\", true)).clear();\n    for (SNode throwItem : ListSequence.fromList(SLinkOperations.getTargets(this.myParameters.getDeclaration(), \"throwsItem\", true))) {\n      ListSequence.fromList(SLinkOperations.getTargets(this.myDeclaration, \"throwsItem\", true)).addElement(SNodeOperations.copyNode(throwItem));\n    }\n    for (SNode node : ListSequence.fromList(this.myUssages)) {\n      MethodCallAdapter call = new MethodCallAdapter(node);\n      List<SNode> oldArgs = call.getMethodArguments();\n      call.removeArguments();\n      for (SNode parameter : ListSequence.fromList(SLinkOperations.getTargets(this.myParameters.getDeclaration(), \"parameter\", true))) {\n        int index = ListSequence.fromList(this.myParameters.getIdList()).indexOf(parameter.getId());\n        if (index == -1) {\n          call.addArgument(SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.NullLiteral\", null));\n        } else {\n          call.addArgument(ListSequence.fromList(oldArgs).getElement(index));\n        }\n      }\n    }\n  }","commit_id":"f2d54117684ee8dc45c94334c17899c1d33c18ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void changeParameters() {\n    List<SNode> oldParams = SLinkOperations.getTargets(this.myDeclaration, \"parameter\", true);\n    SLinkOperations.removeAllChildren(this.myDeclaration, \"parameter\");\n    for (SNode parameter : ListSequence.fromList(SLinkOperations.getTargets(this.myParameters.getDeclaration(), \"parameter\", true))) {\n      int index = ListSequence.fromList(this.myParameters.getIdList()).indexOf(parameter.getId());\n      if (index == -1) {\n        ListSequence.fromList(SLinkOperations.getTargets(this.myDeclaration, \"parameter\", true)).addElement(SNodeOperations.copyNode(parameter));\n      } else {\n        ListSequence.fromList(SLinkOperations.getTargets(this.myDeclaration, \"parameter\", true)).addElement(ListSequence.fromList(oldParams).getElement(index));\n        SNode newParam = ListSequence.fromList(SLinkOperations.getTargets(this.myDeclaration, \"parameter\", true)).last();\n        SPropertyOperations.set(newParam, \"name\", SPropertyOperations.getString(parameter, \"name\"));\n        SLinkOperations.setTarget(newParam, \"type\", SLinkOperations.getTarget(parameter, \"type\", true), true);\n      }\n    }\n  }","id":91878,"modified_method":"private void changeParameters() {\n    List<SNode> oldParams = SLinkOperations.getTargets(this.myDeclaration, \"parameter\", true);\n    ListSequence.fromList(SLinkOperations.getTargets(this.myDeclaration, \"parameter\", true)).clear();\n    for (SNode parameter : ListSequence.fromList(SLinkOperations.getTargets(this.myParameters.getDeclaration(), \"parameter\", true))) {\n      int index = ListSequence.fromList(this.myParameters.getIdList()).indexOf(parameter.getId());\n      if (index == -1) {\n        ListSequence.fromList(SLinkOperations.getTargets(this.myDeclaration, \"parameter\", true)).addElement(SNodeOperations.copyNode(parameter));\n      } else {\n        ListSequence.fromList(SLinkOperations.getTargets(this.myDeclaration, \"parameter\", true)).addElement(ListSequence.fromList(oldParams).getElement(index));\n        SNode newParam = ListSequence.fromList(SLinkOperations.getTargets(this.myDeclaration, \"parameter\", true)).last();\n        SPropertyOperations.set(newParam, \"name\", SPropertyOperations.getString(parameter, \"name\"));\n        SLinkOperations.setTarget(newParam, \"type\", SLinkOperations.getTarget(parameter, \"type\", true), true);\n      }\n    }\n  }","commit_id":"f2d54117684ee8dc45c94334c17899c1d33c18ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    // Invert condition \n    SNode condition = SLinkOperations.getTarget(node, \"condition\", true);\n    if ((condition != null)) {\n      if (SNodeOperations.isInstanceOf(condition, \"jetbrains.mps.baseLanguage.structure.NotExpression\")) {\n        condition = SLinkOperations.getTarget(SNodeOperations.cast(condition, \"jetbrains.mps.baseLanguage.structure.NotExpression\"), \"expression\", true);\n      } else {\n        SNode newCondition = null;\n        if (SNodeOperations.isInstanceOf(condition, \"jetbrains.mps.baseLanguage.structure.EqualsExpression\")) {\n          newCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.NotEqualsExpression\", null);\n        } else\n        if (SNodeOperations.isInstanceOf(condition, \"jetbrains.mps.baseLanguage.structure.NotEqualsExpression\")) {\n          newCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.EqualsExpression\", null);\n        } else\n        if (SNodeOperations.isInstanceOf(condition, \"jetbrains.mps.baseLanguage.structure.GreaterThanExpression\")) {\n          newCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.LessThanOrEqualsExpression\", null);\n        } else\n        if (SNodeOperations.isInstanceOf(condition, \"jetbrains.mps.baseLanguage.structure.GreaterThanOrEqualsExpression\")) {\n          newCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.LessThanExpression\", null);\n        } else\n        if (SNodeOperations.isInstanceOf(condition, \"jetbrains.mps.baseLanguage.structure.LessThanExpression\")) {\n          newCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.GreaterThanOrEqualsExpression\", null);\n        } else\n        if (SNodeOperations.isInstanceOf(condition, \"jetbrains.mps.baseLanguage.structure.LessThanOrEqualsExpression\")) {\n          newCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.GreaterThanExpression\", null);\n        }\n        if (newCondition != null) {\n          SLinkOperations.setTarget(newCondition, \"leftExpression\", SLinkOperations.getTarget(SNodeOperations.cast(condition, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"leftExpression\", true), true);\n          SLinkOperations.setTarget(newCondition, \"rightExpression\", SLinkOperations.getTarget(SNodeOperations.cast(condition, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"rightExpression\", true), true);\n          condition = newCondition;\n        } else {\n          SNode notExpression = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.NotExpression\", null);\n          SLinkOperations.setTarget(notExpression, \"expression\", condition, true);\n          condition = notExpression;\n        }\n      }\n      SLinkOperations.setTarget(node, \"condition\", condition, true);\n    }\n    // Flip ifTrue and ifFalse \n    SNode ifTrue = SLinkOperations.getTarget(node, \"ifTrue\", true);\n    SNode ifFalse = SLinkOperations.getTarget(node, \"ifFalseStatement\", true);\n    SNode newIfTrue;\n    SNode newIfFalse;\n    // Set new ifFalse \n    if (SLinkOperations.getCount(ifTrue, \"statement\") == 0) {\n      newIfFalse = null;\n    } else\n    if (SLinkOperations.getCount(ifTrue, \"statement\") == 1 && SNodeOperations.isInstanceOf(ListSequence.fromList(SLinkOperations.getTargets(ifTrue, \"statement\", true)).first(), \"jetbrains.mps.baseLanguage.structure.IfStatement\")) {\n      newIfFalse = ListSequence.fromList(SLinkOperations.getTargets(ifTrue, \"statement\", true)).first();\n    } else {\n      newIfFalse = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.BlockStatement\", null);\n      SLinkOperations.setTarget(SNodeOperations.cast(newIfFalse, \"jetbrains.mps.baseLanguage.structure.BlockStatement\"), \"statements\", ifTrue, true);\n    }\n    // Set new ifTrue \n    if (SNodeOperations.isInstanceOf(ifFalse, \"jetbrains.mps.baseLanguage.structure.BlockStatement\")) {\n      newIfTrue = SLinkOperations.getTarget(SNodeOperations.cast(ifFalse, \"jetbrains.mps.baseLanguage.structure.BlockStatement\"), \"statements\", true);\n    } else {\n      newIfTrue = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.StatementList\", null);\n      if (ifFalse != null) {\n        ListSequence.fromList(SLinkOperations.getTargets(newIfTrue, \"statement\", true)).addElement(ifFalse);\n      }\n    }\n    SLinkOperations.setTarget(node, \"ifTrue\", newIfTrue, true);\n    SLinkOperations.setTarget(node, \"ifFalseStatement\", newIfFalse, true);\n  }","id":91879,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    // Invert condition \n    SNode condition = SLinkOperations.getTarget(node, \"condition\", true);\n    if ((condition != null)) {\n      if (SNodeOperations.isInstanceOf(condition, \"jetbrains.mps.baseLanguage.structure.NotExpression\")) {\n        condition = SLinkOperations.getTarget(SNodeOperations.cast(condition, \"jetbrains.mps.baseLanguage.structure.NotExpression\"), \"expression\", true);\n      } else {\n        SNode newCondition = null;\n        if (SNodeOperations.isInstanceOf(condition, \"jetbrains.mps.baseLanguage.structure.EqualsExpression\")) {\n          newCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.NotEqualsExpression\", null);\n        } else\n        if (SNodeOperations.isInstanceOf(condition, \"jetbrains.mps.baseLanguage.structure.NotEqualsExpression\")) {\n          newCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.EqualsExpression\", null);\n        } else\n        if (SNodeOperations.isInstanceOf(condition, \"jetbrains.mps.baseLanguage.structure.GreaterThanExpression\")) {\n          newCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.LessThanOrEqualsExpression\", null);\n        } else\n        if (SNodeOperations.isInstanceOf(condition, \"jetbrains.mps.baseLanguage.structure.GreaterThanOrEqualsExpression\")) {\n          newCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.LessThanExpression\", null);\n        } else\n        if (SNodeOperations.isInstanceOf(condition, \"jetbrains.mps.baseLanguage.structure.LessThanExpression\")) {\n          newCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.GreaterThanOrEqualsExpression\", null);\n        } else\n        if (SNodeOperations.isInstanceOf(condition, \"jetbrains.mps.baseLanguage.structure.LessThanOrEqualsExpression\")) {\n          newCondition = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.GreaterThanExpression\", null);\n        }\n        if (newCondition != null) {\n          SLinkOperations.setTarget(newCondition, \"leftExpression\", SLinkOperations.getTarget(SNodeOperations.cast(condition, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"leftExpression\", true), true);\n          SLinkOperations.setTarget(newCondition, \"rightExpression\", SLinkOperations.getTarget(SNodeOperations.cast(condition, \"jetbrains.mps.baseLanguage.structure.BinaryOperation\"), \"rightExpression\", true), true);\n          condition = newCondition;\n        } else {\n          SNode notExpression = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.NotExpression\", null);\n          SLinkOperations.setTarget(notExpression, \"expression\", condition, true);\n          condition = notExpression;\n        }\n      }\n      SLinkOperations.setTarget(node, \"condition\", condition, true);\n    }\n    // Flip ifTrue and ifFalse \n    SNode ifTrue = SLinkOperations.getTarget(node, \"ifTrue\", true);\n    SNode ifFalse = SLinkOperations.getTarget(node, \"ifFalseStatement\", true);\n    SNode newIfTrue;\n    SNode newIfFalse;\n    // Set new ifFalse \n    if (ListSequence.fromList(SLinkOperations.getTargets(ifTrue, \"statement\", true)).count() == 0) {\n      newIfFalse = null;\n    } else\n    if (ListSequence.fromList(SLinkOperations.getTargets(ifTrue, \"statement\", true)).count() == 1 && SNodeOperations.isInstanceOf(ListSequence.fromList(SLinkOperations.getTargets(ifTrue, \"statement\", true)).first(), \"jetbrains.mps.baseLanguage.structure.IfStatement\")) {\n      newIfFalse = ListSequence.fromList(SLinkOperations.getTargets(ifTrue, \"statement\", true)).first();\n    } else {\n      newIfFalse = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.BlockStatement\", null);\n      SLinkOperations.setTarget(SNodeOperations.cast(newIfFalse, \"jetbrains.mps.baseLanguage.structure.BlockStatement\"), \"statements\", ifTrue, true);\n    }\n    // Set new ifTrue \n    if (SNodeOperations.isInstanceOf(ifFalse, \"jetbrains.mps.baseLanguage.structure.BlockStatement\")) {\n      newIfTrue = SLinkOperations.getTarget(SNodeOperations.cast(ifFalse, \"jetbrains.mps.baseLanguage.structure.BlockStatement\"), \"statements\", true);\n    } else {\n      newIfTrue = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.StatementList\", null);\n      if (ifFalse != null) {\n        ListSequence.fromList(SLinkOperations.getTargets(newIfTrue, \"statement\", true)).addElement(ifFalse);\n      }\n    }\n    SLinkOperations.setTarget(node, \"ifTrue\", newIfTrue, true);\n    SLinkOperations.setTarget(node, \"ifFalseStatement\", newIfFalse, true);\n  }","commit_id":"f2d54117684ee8dc45c94334c17899c1d33c18ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void removeArguments() {\n    if (SNodeOperations.isInstanceOf(this.myMethodCall, \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n      SLinkOperations.removeAllChildren(SNodeOperations.cast(this.myMethodCall, \"jetbrains.mps.baseLanguage.structure.IMethodCall\"), \"actualArgument\");\n    }\n    if (SNodeOperations.isInstanceOf(this.myMethodCall, \"jetbrains.mps.baseLanguage.classifiers.structure.DefaultClassifierMethodCallOperation\")) {\n      SLinkOperations.removeAllChildren(SNodeOperations.cast(this.myMethodCall, \"jetbrains.mps.baseLanguage.classifiers.structure.DefaultClassifierMethodCallOperation\"), \"actualArgument\");\n    }\n  }","id":91880,"modified_method":"public void removeArguments() {\n    if (SNodeOperations.isInstanceOf(this.myMethodCall, \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n      ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(this.myMethodCall, \"jetbrains.mps.baseLanguage.structure.IMethodCall\"), \"actualArgument\", true)).clear();\n    }\n    if (SNodeOperations.isInstanceOf(this.myMethodCall, \"jetbrains.mps.baseLanguage.classifiers.structure.DefaultClassifierMethodCallOperation\")) {\n      ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(this.myMethodCall, \"jetbrains.mps.baseLanguage.classifiers.structure.DefaultClassifierMethodCallOperation\"), \"actualArgument\", true)).clear();\n    }\n  }","commit_id":"f2d54117684ee8dc45c94334c17899c1d33c18ad","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void configure() {\n    try {\n      setName(\"AppWithMapReduceUsingFile\");\n      setDescription(\"Application with MapReduce job using file as dataset\");\n      createDataset(inputDataset, \"fileSet\", FileSetProperties.builder()\n        .setInputFormat(TextInputFormat.class)\n        .setOutputFormat(TextOutputFormat.class).build());\n      if (!outputDataset.equals(inputDataset)) {\n        createDataset(outputDataset, \"fileSet\", FileSetProperties.builder()\n          .setBasePath(\"/foo/my-file-output\")\n          .setInputFormat(TextInputFormat.class)\n          .setOutputFormat(TextOutputFormat.class).build());\n      }\n      addMapReduce(new ComputeSum());\n    } catch (Throwable t) {\n      throw Throwables.propagate(t);\n    }\n  }","id":91881,"modified_method":"@Override\n  public void configure() {\n    try {\n      setName(\"AppWithMapReduceUsingFile\");\n      setDescription(\"Application with MapReduce job using file as dataset\");\n      createDataset(inputDataset, \"fileSet\", FileSetProperties.builder()\n        .setInputFormat(TextInputFormat.class)\n        .setOutputFormat(TextOutputFormat.class)\n        .setOutputProperty(TextOutputFormat.SEPERATOR, \":\")\n        .build());\n      if (!outputDataset.equals(inputDataset)) {\n        createDataset(outputDataset, \"fileSet\", FileSetProperties.builder()\n          .setBasePath(\"/foo/my-file-output\")\n          .setInputFormat(TextInputFormat.class)\n          .setOutputFormat(TextOutputFormat.class)\n          .setOutputProperty(TextOutputFormat.SEPERATOR, \":\")\n          .build());\n      }\n      addMapReduce(new ComputeSum());\n    } catch (Throwable t) {\n      throw Throwables.propagate(t);\n    }\n  }","commit_id":"d941e1193a1f471ea43bf45afb06f9f262c59277","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configure() {\n    setName(\"FileSetExample\");\n    setDescription(\"Application with a MapReduce that uses a FileSet dataset\");\n    createDataset(\"lines\", FileSet.class, FileSetProperties.builder()\n      .setBasePath(\"example/data/lines\")\n      .setInputFormat(TextInputFormat.class)\n      .setOutputFormat(TextOutputFormat.class).build());\n    createDataset(\"counts\", FileSet.class, FileSetProperties.builder()\n      .setInputFormat(TextInputFormat.class)\n      .setOutputFormat(TextOutputFormat.class).build());\n    addService(new FileSetService());\n    addMapReduce(new WordCount());\n  }","id":91882,"modified_method":"@Override\n  public void configure() {\n    setName(\"FileSetExample\");\n    setDescription(\"Application with a MapReduce that uses a FileSet dataset\");\n    createDataset(\"lines\", FileSet.class, FileSetProperties.builder()\n      .setBasePath(\"example/data/lines\")\n      .setInputFormat(TextInputFormat.class)\n      .setOutputFormat(TextOutputFormat.class)\n      .build());\n    createDataset(\"counts\", FileSet.class, FileSetProperties.builder()\n      .setInputFormat(TextInputFormat.class)\n      .setOutputFormat(TextOutputFormat.class)\n      .setOutputProperty(TextOutputFormat.SEPERATOR, \":\")\n      .build());\n    addService(new FileSetService());\n    addMapReduce(new WordCount());\n  }","commit_id":"d941e1193a1f471ea43bf45afb06f9f262c59277","url":"https://github.com/caskdata/cdap"},{"original_method":"private void testMapreduceWithFile(String inputDatasetName, String inputPaths,\n                                     String outputDatasetName, String outputPath) throws Exception {\n\n    // hack to use different datasets at each invocation of this test\n    System.setProperty(\"INPUT_DATASET_NAME\", inputDatasetName);\n    System.setProperty(\"OUTPUT_DATASET_NAME\", outputDatasetName);\n\n    final ApplicationWithPrograms app =\n      AppFabricTestHelper.deployApplicationWithManager(AppWithMapReduceUsingFileSet.class, TEMP_FOLDER_SUPPLIER);\n\n    Map<String, String> inputArgs = Maps.newHashMap();\n    Map<String, String> outputArgs = Maps.newHashMap();\n    FileSetArguments.setInputPaths(inputArgs, inputPaths);\n    FileSetArguments.setOutputPath(outputArgs, outputPath);\n\n    // write a handful of numbers to a file; compute their sum, too.\n    final long[] values = { 15L, 17L, 7L, 3L };\n    final FileSet input = datasetInstantiator.getDataset(inputDatasetName, inputArgs);\n    long sum = 0L, count = 1;\n    for (Location inputLocation : input.getInputLocations()) {\n      final PrintWriter writer = new PrintWriter(inputLocation.getOutputStream());\n      for (long value : values) {\n        value *= count;\n        writer.println(value);\n        sum += value;\n      }\n      writer.close();\n      count++;\n    }\n\n    Map<String, String> runtimeArguments = Maps.newHashMap();\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, inputDatasetName, inputArgs));\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, outputDatasetName, outputArgs));\n    runProgram(app, AppWithMapReduceUsingFileSet.ComputeSum.class, new BasicArguments(runtimeArguments));\n\n    // output location in file system is a directory that contains a part file, a _SUCCESS file, and checksums\n    // (.<filename>.crc) for these files. Find the actual part file. Its name begins with \"part\". In this case,\n    // there should be only one part file (with this small data, we have a single reducer).\n    final FileSet results = datasetInstantiator.getDataset(outputDatasetName, outputArgs);\n    Location resultLocation = results.getOutputLocation();\n    if (resultLocation.isDirectory()) {\n      for (Location child : resultLocation.list()) {\n        if (!child.isDirectory() && child.getName().startsWith(\"part\")) {\n          resultLocation = child;\n          break;\n        }\n      }\n    }\n    Assert.assertFalse(resultLocation.isDirectory());\n\n    // read output and verify result\n    String line = CharStreams.readFirstLine(\n      CharStreams.newReaderSupplier(\n        Locations.newInputSupplier(resultLocation), Charsets.UTF_8));\n    Assert.assertNotNull(line);\n    String[] fields = line.split(\"\\t\");\n    Assert.assertEquals(2, fields.length);\n    Assert.assertEquals(AppWithMapReduceUsingFileSet.FileMapper.ONLY_KEY, fields[0]);\n    Assert.assertEquals(sum, Long.parseLong(fields[1]));\n  }","id":91883,"modified_method":"private void testMapreduceWithFile(String inputDatasetName, String inputPaths,\n                                     String outputDatasetName, String outputPath) throws Exception {\n\n    // hack to use different datasets at each invocation of this test\n    System.setProperty(\"INPUT_DATASET_NAME\", inputDatasetName);\n    System.setProperty(\"OUTPUT_DATASET_NAME\", outputDatasetName);\n\n    final ApplicationWithPrograms app =\n      AppFabricTestHelper.deployApplicationWithManager(AppWithMapReduceUsingFileSet.class, TEMP_FOLDER_SUPPLIER);\n\n    Map<String, String> inputArgs = Maps.newHashMap();\n    Map<String, String> outputArgs = Maps.newHashMap();\n    FileSetArguments.setInputPaths(inputArgs, inputPaths);\n    FileSetArguments.setOutputPath(outputArgs, outputPath);\n\n    // write a handful of numbers to a file; compute their sum, too.\n    final long[] values = { 15L, 17L, 7L, 3L };\n    final FileSet input = datasetInstantiator.getDataset(inputDatasetName, inputArgs);\n    long sum = 0L, count = 1;\n    for (Location inputLocation : input.getInputLocations()) {\n      final PrintWriter writer = new PrintWriter(inputLocation.getOutputStream());\n      for (long value : values) {\n        value *= count;\n        writer.println(value);\n        sum += value;\n      }\n      writer.close();\n      count++;\n    }\n\n    Map<String, String> runtimeArguments = Maps.newHashMap();\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, inputDatasetName, inputArgs));\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, outputDatasetName, outputArgs));\n    runProgram(app, AppWithMapReduceUsingFileSet.ComputeSum.class, new BasicArguments(runtimeArguments));\n\n    // output location in file system is a directory that contains a part file, a _SUCCESS file, and checksums\n    // (.<filename>.crc) for these files. Find the actual part file. Its name begins with \"part\". In this case,\n    // there should be only one part file (with this small data, we have a single reducer).\n    final FileSet results = datasetInstantiator.getDataset(outputDatasetName, outputArgs);\n    Location resultLocation = results.getOutputLocation();\n    if (resultLocation.isDirectory()) {\n      for (Location child : resultLocation.list()) {\n        if (!child.isDirectory() && child.getName().startsWith(\"part\")) {\n          resultLocation = child;\n          break;\n        }\n      }\n    }\n    Assert.assertFalse(resultLocation.isDirectory());\n\n    // read output and verify result\n    String line = CharStreams.readFirstLine(\n      CharStreams.newReaderSupplier(\n        Locations.newInputSupplier(resultLocation), Charsets.UTF_8));\n    Assert.assertNotNull(line);\n    String[] fields = line.split(\":\");\n    Assert.assertEquals(2, fields.length);\n    Assert.assertEquals(AppWithMapReduceUsingFileSet.FileMapper.ONLY_KEY, fields[0]);\n    Assert.assertEquals(sum, Long.parseLong(fields[1]));\n  }","commit_id":"d941e1193a1f471ea43bf45afb06f9f262c59277","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public Object clone() throws CloneNotSupportedException {\n      AntSettings_Configuration.MyState state = new AntSettings_Configuration.MyState();\n      state.myUseOtherAntLocation = myUseOtherAntLocation;\n      state.myOtherAntLocation = myOtherAntLocation;\n      return state;\n    }","id":91884,"modified_method":"@Override\n    public Object clone() throws CloneNotSupportedException {\n      AntSettings_Configuration.MyState state = new AntSettings_Configuration.MyState();\n      state.myUseOtherAntLocation = myUseOtherAntLocation;\n      state.myOtherAntLocation = myOtherAntLocation;\n      state.myAntOptions = myAntOptions;\n      return state;\n    }","commit_id":"3a5d68e748a1c559872c6f145d3df235cc864a13","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public JPanel createEditor() {\n    JPanel panel = new JPanel(new GridBagLayout());\n\n    myUseAlternativeAnt = new JCheckBox(\"Use alternative Ant location\");\n    panel.add(myUseAlternativeAnt, LayoutUtil.createLabelConstraints(0));\n    myAlternativeAnt = new FieldWithPathChooseDialog();\n    panel.add(myAlternativeAnt, LayoutUtil.createFieldConstraints(1));\n\n    return panel;\n  }","id":91885,"modified_method":"@NotNull\n  public JPanel createEditor() {\n    JPanel panel = new JPanel(new GridBagLayout());\n\n    myUseAlternativeAnt = new JCheckBox(\"Use alternative Ant location:\");\n    panel.add(myUseAlternativeAnt, LayoutUtil.createLabelConstraints(0));\n    myAlternativeAnt = new FieldWithPathChooseDialog();\n    panel.add(myAlternativeAnt, LayoutUtil.createFieldConstraints(1));\n    panel.add(new JLabel(\"Ant options:\"), LayoutUtil.createLabelConstraints(2));\n    myAntOptions = new RawLineEditorComponent();\n    myAntOptions.setDialogCaption(\"Ant Options\");\n    panel.add(myAntOptions, LayoutUtil.createPanelConstraints(3));\n\n    return panel;\n  }","commit_id":"3a5d68e748a1c559872c6f145d3df235cc864a13","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void resetEditorFrom(final AntSettings_Configuration configuration) {\n    myUseAlternativeAnt.setSelected(configuration.getUseOtherAntLocation());\n    myAlternativeAnt.setText(configuration.getOtherAntLocation());\n  }","id":91886,"modified_method":"public void resetEditorFrom(final AntSettings_Configuration configuration) {\n    myUseAlternativeAnt.setSelected(configuration.getUseOtherAntLocation());\n    myAlternativeAnt.setText(configuration.getOtherAntLocation());\n    myAntOptions.setText(configuration.getAntOptions());\n  }","commit_id":"3a5d68e748a1c559872c6f145d3df235cc864a13","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyEditorTo(final AntSettings_Configuration configuration) throws ConfigurationException {\n    configuration.setUseOtherAntLocation(myUseAlternativeAnt.isSelected());\n    configuration.setOtherAntLocation(myAlternativeAnt.getText());\n  }","id":91887,"modified_method":"public void applyEditorTo(final AntSettings_Configuration configuration) throws ConfigurationException {\n    configuration.setUseOtherAntLocation(myUseAlternativeAnt.isSelected());\n    configuration.setOtherAntLocation(myAlternativeAnt.getText());\n    configuration.setAntOptions(myAntOptions.getText());\n  }","commit_id":"3a5d68e748a1c559872c6f145d3df235cc864a13","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ProcessHandler createProcess(SNode project) throws ExecutionException {\n    return new Ant_Command().setAntLocation(myAntLocation).createProcess(Ant_Command.getGeneratedFileName(project));\n  }","id":91888,"modified_method":"public ProcessHandler createProcess(SNode project) throws ExecutionException {\n    return new Ant_Command().setAntLocation(myAntLocation).setOptions(myOptions).createProcess(Ant_Command.getGeneratedFileName(project));\n  }","commit_id":"3a5d68e748a1c559872c6f145d3df235cc864a13","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ProcessHandler createProcess(String antFilePath) throws ExecutionException {\n    return new Java_Command().setClassPath(Ant_Command.getAntClassPath(myAntLocation)).setProgramParameter(\"-Djava.home=\" + Java_Command.getJdkHome() + \" -Dant.home=\" + myAntLocation + \" \" + IterableUtils.join(Sequence.fromIterable(Ant_Command.getMacroValues()), \" \") + \" \" + \"-f \" + antFilePath).createProcess(\"org.apache.tools.ant.launch.Launcher\");\n  }","id":91889,"modified_method":"public ProcessHandler createProcess(String antFilePath) throws ExecutionException {\n    return new Java_Command().setClassPath(Ant_Command.getAntClassPath(myAntLocation)).setProgramParameter(\"-Djava.home=\" + Java_Command.getJdkHome() + \" -Dant.home=\" + myAntLocation + \" \" + IterableUtils.join(Sequence.fromIterable(Ant_Command.getMacroValues()), \" \") + \" \" + ((StringUtils.isNotEmpty(myOptions) ?\n      myOptions + \" \" :\n      \"\"\n    )) + \"-f \" + antFilePath).createProcess(\"org.apache.tools.ant.launch.Launcher\");\n  }","commit_id":"3a5d68e748a1c559872c6f145d3df235cc864a13","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public ExecutionResult execute(Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {\n    Project project = myEnvironment.getProject();\n    {\n      ProcessHandler _processHandler = new Ant_Command().setAntLocation((myRunConfiguration.getSettings().getUseOtherAntLocation() ?\n        myRunConfiguration.getSettings().getOtherAntLocation() :\n        null\n      )).createProcess(myRunConfiguration.getNode().getNode());\n      final ConsoleViewImpl _consoleView = new ConsoleViewImpl(project, false);\n      _processHandler.addProcessListener(new ConsoleProcessListener(_consoleView));\n      return new DefaultExecutionResult(_processHandler, new DefaultExecutionConsole(_consoleView.getComponent(), new _FunctionTypes._void_P0_E0() {\n        public void invoke() {\n          _consoleView.dispose();\n        }\n      }));\n    }\n  }","id":91890,"modified_method":"@Nullable\n  public ExecutionResult execute(Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {\n    Project project = myEnvironment.getProject();\n    {\n      ProcessHandler _processHandler = new Ant_Command().setAntLocation((myRunConfiguration.getSettings().getUseOtherAntLocation() ?\n        myRunConfiguration.getSettings().getOtherAntLocation() :\n        null\n      )).setOptions(myRunConfiguration.getSettings().getAntOptions()).createProcess(myRunConfiguration.getNode().getNode());\n      final ConsoleViewImpl _consoleView = new ConsoleViewImpl(project, false);\n      _processHandler.addProcessListener(new ConsoleProcessListener(_consoleView));\n      return new DefaultExecutionResult(_processHandler, new DefaultExecutionConsole(_consoleView.getComponent(), new _FunctionTypes._void_P0_E0() {\n        public void invoke() {\n          _consoleView.dispose();\n        }\n      }));\n    }\n  }","commit_id":"3a5d68e748a1c559872c6f145d3df235cc864a13","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public ExecutionResult execute(Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {\n    Project project = myEnvironment.getProject();\n    final SNode configuration = myRunConfiguration.getConfiguration();\n    final SNode layout = SNodeOperations.cast(myRunConfiguration.getNode().getNode(), \"jetbrains.mps.build.packaging.structure.Layout\");\n\n    if (configuration == null) {\n      throw new ExecutionException(\"Configuration not selected.\");\n    }\n\n    final Wrappers._boolean isMPSBuildIncluded = new Wrappers._boolean();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SNode mpsbuild = ListSequence.fromList(SNodeOperations.getDescendants(layout, \"jetbrains.mps.build.custommps.structure.MPSBuild\", false, new String[]{})).first();\n        if ((mpsbuild == null)) {\n          mpsbuild = ListSequence.fromList(SNodeOperations.getDescendants(layout, \"jetbrains.mps.build.custommps.structure.MPSDistribution\", false, new String[]{})).first();\n        }\n        isMPSBuildIncluded.value = AbstractProjectComponent_Behavior.call_included_1213877333807(mpsbuild, configuration);\n      }\n    });\n\n    File file = new File(GenerateBuildUtil.getGeneratedFilePath(configuration));\n    // if MPSBuild was included into this configuration we should run different build file \n    if (isMPSBuildIncluded.value) {\n      String path = file.getAbsolutePath();\n      String suffix = \".xml\";\n      file = new File(path.substring(0, path.length() - suffix.length()) + DistribConfiguration_Behavior.getSuffix_1240229578757() + suffix);\n    }\n\n    {\n      ProcessHandler _processHandler = new Ant_Command().setAntLocation((myRunConfiguration.getSettings().getUseOtherAntLocation() ?\n        myRunConfiguration.getSettings().getOtherAntLocation() :\n        null\n      )).createProcess(file.getAbsolutePath());\n      final ConsoleViewImpl _consoleView = new ConsoleViewImpl(project, false);\n      _processHandler.addProcessListener(new ConsoleProcessListener(_consoleView));\n      return new DefaultExecutionResult(_processHandler, new DefaultExecutionConsole(_consoleView.getComponent(), new _FunctionTypes._void_P0_E0() {\n        public void invoke() {\n          _consoleView.dispose();\n        }\n      }));\n    }\n  }","id":91891,"modified_method":"@Nullable\n  public ExecutionResult execute(Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {\n    Project project = myEnvironment.getProject();\n    final SNode configuration = myRunConfiguration.getConfiguration();\n    final SNode layout = SNodeOperations.cast(myRunConfiguration.getNode().getNode(), \"jetbrains.mps.build.packaging.structure.Layout\");\n\n    if (configuration == null) {\n      throw new ExecutionException(\"Configuration not selected.\");\n    }\n\n    final Wrappers._boolean isMPSBuildIncluded = new Wrappers._boolean();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SNode mpsbuild = ListSequence.fromList(SNodeOperations.getDescendants(layout, \"jetbrains.mps.build.custommps.structure.MPSBuild\", false, new String[]{})).first();\n        if ((mpsbuild == null)) {\n          mpsbuild = ListSequence.fromList(SNodeOperations.getDescendants(layout, \"jetbrains.mps.build.custommps.structure.MPSDistribution\", false, new String[]{})).first();\n        }\n        isMPSBuildIncluded.value = AbstractProjectComponent_Behavior.call_included_1213877333807(mpsbuild, configuration);\n      }\n    });\n\n    File file = new File(GenerateBuildUtil.getGeneratedFilePath(configuration));\n    // if MPSBuild was included into this configuration we should run different build file \n    if (isMPSBuildIncluded.value) {\n      String path = file.getAbsolutePath();\n      String suffix = \".xml\";\n      file = new File(path.substring(0, path.length() - suffix.length()) + DistribConfiguration_Behavior.getSuffix_1240229578757() + suffix);\n    }\n\n    {\n      ProcessHandler _processHandler = new Ant_Command().setAntLocation((myRunConfiguration.getSettings().getUseOtherAntLocation() ?\n        myRunConfiguration.getSettings().getOtherAntLocation() :\n        null\n      )).setOptions(myRunConfiguration.getSettings().getAntOptions()).createProcess(file.getAbsolutePath());\n      final ConsoleViewImpl _consoleView = new ConsoleViewImpl(project, false);\n      _processHandler.addProcessListener(new ConsoleProcessListener(_consoleView));\n      return new DefaultExecutionResult(_processHandler, new DefaultExecutionConsole(_consoleView.getComponent(), new _FunctionTypes._void_P0_E0() {\n        public void invoke() {\n          _consoleView.dispose();\n        }\n      }));\n    }\n  }","commit_id":"3a5d68e748a1c559872c6f145d3df235cc864a13","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public ExecutionResult execute(Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {\n    Project project = myEnvironment.getProject();\n    {\n      ProcessHandler _processHandler = new Ant_Command().setAntLocation((myRunConfiguration.getSettings().getUseOtherAntLocation() ?\n        myRunConfiguration.getSettings().getOtherAntLocation() :\n        null\n      )).createProcess(GenerateBuildUtil.getGeneratedFilePath(myRunConfiguration.getConfiguration()));\n      final ConsoleViewImpl _consoleView = new ConsoleViewImpl(project, false);\n      _processHandler.addProcessListener(new ConsoleProcessListener(_consoleView));\n      return new DefaultExecutionResult(_processHandler, new DefaultExecutionConsole(_consoleView.getComponent(), new _FunctionTypes._void_P0_E0() {\n        public void invoke() {\n          _consoleView.dispose();\n        }\n      }));\n    }\n  }","id":91892,"modified_method":"@Nullable\n  public ExecutionResult execute(Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {\n    Project project = myEnvironment.getProject();\n    {\n      ProcessHandler _processHandler = new Ant_Command().setAntLocation((myRunConfiguration.getSettings().getUseOtherAntLocation() ?\n        myRunConfiguration.getSettings().getOtherAntLocation() :\n        null\n      )).setOptions(myRunConfiguration.getSettings().getAntOptions()).createProcess(GenerateBuildUtil.getGeneratedFilePath(myRunConfiguration.getConfiguration()));\n      final ConsoleViewImpl _consoleView = new ConsoleViewImpl(project, false);\n      _processHandler.addProcessListener(new ConsoleProcessListener(_consoleView));\n      return new DefaultExecutionResult(_processHandler, new DefaultExecutionConsole(_consoleView.getComponent(), new _FunctionTypes._void_P0_E0() {\n        public void invoke() {\n          _consoleView.dispose();\n        }\n      }));\n    }\n  }","commit_id":"3a5d68e748a1c559872c6f145d3df235cc864a13","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setConnectionFactory(NIOServerCnxn.Factory connectionFactory) {\n        this.connectionFactory = connectionFactory;\n    }","id":91893,"modified_method":"public void setConnectionFactory(NIOServerCnxnFactory connectionFactory) {\n        this.connectionFactory = connectionFactory;\n    }","commit_id":"4c2d1b5a63e7e7ab0295b7e5f46f79fa6269870a","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void afterPropertiesSet() throws Exception {\n        FileTxnSnapLog ftxn = new FileTxnSnapLog(getDataLogDir(), getDataDir());\n        zooKeeperServer.setTxnLogFactory(ftxn);\n        zooKeeperServer.setTickTime(getTickTime());\n        zooKeeperServer.setMinSessionTimeout(getMinSessionTimeout());\n        zooKeeperServer.setMaxSessionTimeout(getMaxSessionTimeout());\n        connectionFactory = new NIOServerCnxn.Factory(getClientPortAddress(), getMaxClientConnections());\n        connectionFactory.startup(zooKeeperServer);\n    }","id":91894,"modified_method":"public void afterPropertiesSet() throws Exception {\n        FileTxnSnapLog ftxn = new FileTxnSnapLog(getDataLogDir(), getDataDir());\n        zooKeeperServer.setTxnLogFactory(ftxn);\n        zooKeeperServer.setTickTime(getTickTime());\n        zooKeeperServer.setMinSessionTimeout(getMinSessionTimeout());\n        zooKeeperServer.setMaxSessionTimeout(getMaxSessionTimeout());\n        connectionFactory = new NIOServerCnxnFactory();\n        connectionFactory.configure(getClientPortAddress(), getMaxClientConnections());\n        connectionFactory.startup(zooKeeperServer);\n    }","commit_id":"4c2d1b5a63e7e7ab0295b7e5f46f79fa6269870a","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void onDisconnected() {\n        connected = false;\n        try {\n            unregisterDomains();\n        } catch (ServiceException e) {\n            logger.trace(\"Mbean server is no longer available\", e);\n        } catch (Exception e) {\n            logger.warn(\"An error occured during disconnecting to zookeeper\", e);\n        }\n    }","id":91895,"modified_method":"public void onDisconnected() {\n        connected = false;\n    }","commit_id":"0d17af89900c7728b3f202d7147c5313a81e2d91","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void onConnected() {\n        try {\n            connected = true;\n            String name = System.getProperty(\"karaf.name\");\n            String nodeAlive = AGENT_ALIVE.getPath(name);\n            Stat stat = zooKeeper.exists(nodeAlive);\n            if (stat != null) {\n                if (stat.getEphemeralOwner() != zooKeeper.getSessionId()) {\n                    zooKeeper.delete(nodeAlive);\n                    zooKeeper.createWithParents(nodeAlive, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n                }\n            } else {\n                zooKeeper.createWithParents(nodeAlive, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n            }\n\n            String domainsNode = AGENT_DOMAINS.getPath(name);\n            stat = zooKeeper.exists(domainsNode);\n            if (stat != null) {\n                zooKeeper.deleteWithChildren(domainsNode);\n            }\n\n            String jmxUrl = getJmxUrl();\n            if (jmxUrl != null) {\n                zooKeeper.createOrSetWithParents(AGENT_JMX.getPath(name), getJmxUrl(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n            String sshUrl = getSshUrl();\n            if (sshUrl != null) {\n                zooKeeper.createOrSetWithParents(AGENT_SSH.getPath(name), getSshUrl(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n            zooKeeper.createOrSetWithParents(AGENT_IP.getPath(name), getLocalHostAddress(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n\n            String version = System.getProperty(\"fabric.version\", \"base\");\n            String profiles = System.getProperty(\"fabric.profiles\");\n\n            if (profiles != null) {\n                String versionNode = CONFIG_AGENT.getPath(name);\n                String profileNode = CONFIG_VERSIONS_AGENT.getPath(version, name);\n\n                if (zooKeeper.exists(versionNode) == null) {\n                    zooKeeper.createOrSetWithParents(versionNode, version, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n                }\n                if (zooKeeper.exists(profileNode) == null) {\n                    zooKeeper.createOrSetWithParents(profileNode, profiles, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n                }\n            }\n            registerDomains();\n        } catch (Exception e) {\n            // TODO\n            e.printStackTrace();\n        }\n    }","id":91896,"modified_method":"public void onConnected() {\n        try {\n            connected = true;\n            String name = System.getProperty(\"karaf.name\");\n            String nodeAlive = AGENT_ALIVE.getPath(name);\n            Stat stat = zooKeeper.exists(nodeAlive);\n            if (stat != null) {\n                if (stat.getEphemeralOwner() != zooKeeper.getSessionId()) {\n                    zooKeeper.delete(nodeAlive);\n                    zooKeeper.createWithParents(nodeAlive, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n                }\n            } else {\n                zooKeeper.createWithParents(nodeAlive, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n            }\n\n            String domainsNode = AGENT_DOMAINS.getPath(name);\n            stat = zooKeeper.exists(domainsNode);\n            if (stat != null) {\n                zooKeeper.deleteWithChildren(domainsNode);\n            }\n\n            String jmxUrl = getJmxUrl();\n            if (jmxUrl != null) {\n                zooKeeper.createOrSetWithParents(AGENT_JMX.getPath(name), getJmxUrl(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n            String sshUrl = getSshUrl();\n            if (sshUrl != null) {\n                zooKeeper.createOrSetWithParents(AGENT_SSH.getPath(name), getSshUrl(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n            zooKeeper.createOrSetWithParents(AGENT_IP.getPath(name), getLocalHostAddress(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n\n            String version = System.getProperty(\"fabric.version\", \"base\");\n            String profiles = System.getProperty(\"fabric.profiles\");\n\n            if (profiles != null) {\n                String versionNode = CONFIG_AGENT.getPath(name);\n                String profileNode = CONFIG_VERSIONS_AGENT.getPath(version, name);\n\n                if (zooKeeper.exists(versionNode) == null) {\n                    zooKeeper.createOrSetWithParents(versionNode, version, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n                }\n                if (zooKeeper.exists(profileNode) == null) {\n                    zooKeeper.createOrSetWithParents(profileNode, profiles, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n                }\n            }\n            registerDomains();\n        } catch (Exception e) {\n            logger.warn(\"Error updating Fabric Agent informations\", e);\n        }\n    }","commit_id":"0d17af89900c7728b3f202d7147c5313a81e2d91","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void unregisterMBeanServer(ServiceReference ref) {\n        try {\n            mbeanServer.removeNotificationListener(new ObjectName(\"JMImplementation:type=MBeanServerDelegate\"), this);\n            unregisterDomains();\n        } catch (Exception e) {\n            logger.warn(\"An error occured during mbean server unregistration\");\n        }\n        mbeanServer = null;\n        bundleContext.ungetService(ref);\n    }","id":91897,"modified_method":"public void unregisterMBeanServer(ServiceReference ref) {\n        try {\n            mbeanServer.removeNotificationListener(new ObjectName(\"JMImplementation:type=MBeanServerDelegate\"), this);\n            unregisterDomains();\n        } catch (Exception e) {\n            logger.warn(\"An error occured during mbean server unregistration\", e);\n        }\n        mbeanServer = null;\n        bundleContext.ungetService(ref);\n    }","commit_id":"0d17af89900c7728b3f202d7147c5313a81e2d91","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void registerMBeanServer(ServiceReference ref) {\n        try {\n            String name = System.getProperty(\"karaf.name\");\n            mbeanServer = (MBeanServer) bundleContext.getService(ref);\n            mbeanServer.addNotificationListener(new ObjectName(\"JMImplementation:type=MBeanServerDelegate\"), this, null, name);\n            registerDomains();\n        } catch (Exception e) {\n            logger.warn(\"An error occured during mbean server registration\");\n        }\n    }","id":91898,"modified_method":"public void registerMBeanServer(ServiceReference ref) {\n        try {\n            String name = System.getProperty(\"karaf.name\");\n            mbeanServer = (MBeanServer) bundleContext.getService(ref);\n            mbeanServer.addNotificationListener(new ObjectName(\"JMImplementation:type=MBeanServerDelegate\"), this, null, name);\n            registerDomains();\n        } catch (Exception e) {\n            logger.warn(\"An error occured during mbean server registration\", e);\n        }\n    }","commit_id":"0d17af89900c7728b3f202d7147c5313a81e2d91","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void onDisconnected() {\n        if (clientRegistration != null) {\n            clientRegistration.unregister();\n        }\n        if (handlerRegistration != null) {\n            handlerRegistration.unregister();\n        }\n    }","id":91899,"modified_method":"public synchronized void onDisconnected() {\n        if (clientRegistration != null) {\n            try {\n                clientRegistration.unregister();\n            } catch (Exception e) {\n                logger.warn(\"An error occured during service unregistration\", e);\n            } finally {\n                clientRegistration = null;\n            }\n        }\n        if (handlerRegistration != null) {\n            try {\n                handlerRegistration.unregister();\n            } catch (Exception e) {\n                logger.warn(\"An error occured during service unregistration\", e);\n            } finally {\n                handlerRegistration = null;\n            }\n        }\n    }","commit_id":"0d17af89900c7728b3f202d7147c5313a81e2d91","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public synchronized void updated(String pid, Dictionary properties) throws ConfigurationException {\n        try {\n            deleted(pid);\n            Properties props = new Properties();\n            for (Enumeration ek = properties.keys(); ek.hasMoreElements();) {\n                Object key = ek.nextElement();\n                Object val = properties.get(key);\n                props.put(key.toString(), val != null ? val.toString() : \"\");\n            }\n\n            // Create myid file\n            String serverId = props.getProperty(\"server.id\");\n            if (serverId != null) {\n                props.remove(\"server.id\");\n                File myId = new File(props.getProperty(\"dataDir\"), \"myid\");\n                if (myId.exists()) {\n                    myId.delete();\n                }\n                myId.getParentFile().mkdirs();\n                FileOutputStream fos = new FileOutputStream(myId);\n                try {\n                    fos.write((serverId + \"\\n\").getBytes());\n                } finally {\n                    fos.close();\n                }\n            }\n\n            // Load properties\n            QuorumPeerConfig config = new QuorumPeerConfig();\n            config.parseProperties(props);\n            if (!config.getServers().isEmpty()) {\n                NIOServerCnxn.Factory cnxnFactory =\n                        new NIOServerCnxn.Factory(config.getClientPortAddress(),\n                                config.getMaxClientCnxns());\n\n                QuorumPeer quorumPeer = new QuorumPeer();\n                quorumPeer.setClientPortAddress(config.getClientPortAddress());\n                quorumPeer.setTxnFactory(new FileTxnSnapLog(\n                        new File(config.getDataLogDir()),\n                        new File(config.getDataDir())));\n                quorumPeer.setQuorumPeers(config.getServers());\n                quorumPeer.setElectionType(config.getElectionAlg());\n                quorumPeer.setMyid(config.getServerId());\n                quorumPeer.setTickTime(config.getTickTime());\n                quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());\n                quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());\n                quorumPeer.setInitLimit(config.getInitLimit());\n                quorumPeer.setSyncLimit(config.getSyncLimit());\n                quorumPeer.setQuorumVerifier(config.getQuorumVerifier());\n                quorumPeer.setCnxnFactory(cnxnFactory);\n                quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));\n                quorumPeer.setLearnerType(config.getPeerType());\n\n                try {\n                    debug(\"Starting quorum peer \\\"%s\\\" on address %s\", quorumPeer.getMyid(), config.getClientPortAddress());\n                    quorumPeer.start();\n                    debug(\"Started quorum peer \\\"%s\\\"\", quorumPeer.getMyid());\n                } catch (Exception e) {\n                    LOG.warn(String.format(\"Failed to start quorum peer \\\"%s\\\", reason : \", quorumPeer.getMyid(), e));\n                    quorumPeer.shutdown();\n                    throw e;\n                }\n\n                servers.put(pid, quorumPeer);\n                services.put(pid, bundleContext.registerService(QuorumStats.Provider.class.getName(), quorumPeer, properties));\n            } else {\n                ServerConfig cfg = new ServerConfig();\n                cfg.readFrom(config);\n\n                ZooKeeperServer zkServer = new ZooKeeperServer();\n                FileTxnSnapLog ftxn = new FileTxnSnapLog(new\n                        File(cfg.getDataLogDir()), new File(cfg.getDataDir()));\n                zkServer.setTxnLogFactory(ftxn);\n                zkServer.setTickTime(cfg.getTickTime());\n                zkServer.setMinSessionTimeout(cfg.getMinSessionTimeout());\n                zkServer.setMaxSessionTimeout(cfg.getMaxSessionTimeout());\n                NIOServerCnxn.Factory cnxnFactory = new NIOServerCnxn.Factory(cfg.getClientPortAddress(),\n                        cfg.getMaxClientCnxns());\n\n                try {\n                    debug(\"Starting ZooKeeper server on address %s\", config.getClientPortAddress());\n                    cnxnFactory.startup(zkServer);\n                    LOG.debug(\"Started ZooKeeper server\");\n                } catch (Exception e) {\n                    LOG.warn(String.format(\"Failed to start ZooKeeper server, reason : %s\", e));\n                    cnxnFactory.shutdown();\n                    throw e;\n                }\n\n                servers.put(pid, cnxnFactory);\n                services.put(pid, bundleContext.registerService(ServerStats.Provider.class.getName(), zkServer, properties));\n            }\n        } catch (Exception e) {\n            throw (ConfigurationException) new ConfigurationException(null, \"Unable to parse ZooKeeper configuration: \" + e.getMessage()).initCause(e);\n        }\n    }","id":91900,"modified_method":"public synchronized void updated(String pid, Dictionary properties) throws ConfigurationException {\n        try {\n            deleted(pid);\n            Properties props = new Properties();\n            for (Enumeration ek = properties.keys(); ek.hasMoreElements();) {\n                Object key = ek.nextElement();\n                Object val = properties.get(key);\n                props.put(key.toString(), val != null ? val.toString() : \"\");\n            }\n\n            // Create myid file\n            String serverId = props.getProperty(\"server.id\");\n            if (serverId != null) {\n                props.remove(\"server.id\");\n                File myId = new File(props.getProperty(\"dataDir\"), \"myid\");\n                if (myId.exists()) {\n                    myId.delete();\n                }\n                myId.getParentFile().mkdirs();\n                FileOutputStream fos = new FileOutputStream(myId);\n                try {\n                    fos.write((serverId + \"\\n\").getBytes());\n                } finally {\n                    fos.close();\n                }\n            }\n\n            // Load properties\n            QuorumPeerConfig config = new QuorumPeerConfig();\n            config.parseProperties(props);\n            if (!config.getServers().isEmpty()) {\n                NIOServerCnxnFactory cnxnFactory = new NIOServerCnxnFactory();\n                cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns());\n\n                QuorumPeer quorumPeer = new QuorumPeer();\n                quorumPeer.setClientPortAddress(config.getClientPortAddress());\n                quorumPeer.setTxnFactory(new FileTxnSnapLog(\n                        new File(config.getDataLogDir()),\n                        new File(config.getDataDir())));\n                quorumPeer.setQuorumPeers(config.getServers());\n                quorumPeer.setElectionType(config.getElectionAlg());\n                quorumPeer.setMyid(config.getServerId());\n                quorumPeer.setTickTime(config.getTickTime());\n                quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());\n                quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());\n                quorumPeer.setInitLimit(config.getInitLimit());\n                quorumPeer.setSyncLimit(config.getSyncLimit());\n                quorumPeer.setQuorumVerifier(config.getQuorumVerifier());\n                quorumPeer.setCnxnFactory(cnxnFactory);\n                quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));\n                quorumPeer.setLearnerType(config.getPeerType());\n\n                try {\n                    debug(\"Starting quorum peer \\\"%s\\\" on address %s\", quorumPeer.getMyid(), config.getClientPortAddress());\n                    quorumPeer.start();\n                    debug(\"Started quorum peer \\\"%s\\\"\", quorumPeer.getMyid());\n                } catch (Exception e) {\n                    LOG.warn(String.format(\"Failed to start quorum peer \\\"%s\\\", reason : \", quorumPeer.getMyid(), e));\n                    quorumPeer.shutdown();\n                    throw e;\n                }\n\n                servers.put(pid, quorumPeer);\n                services.put(pid, bundleContext.registerService(QuorumStats.Provider.class.getName(), quorumPeer, properties));\n            } else {\n                ServerConfig cfg = new ServerConfig();\n                cfg.readFrom(config);\n\n                ZooKeeperServer zkServer = new ZooKeeperServer();\n                FileTxnSnapLog ftxn = new FileTxnSnapLog(new\n                        File(cfg.getDataLogDir()), new File(cfg.getDataDir()));\n                zkServer.setTxnLogFactory(ftxn);\n                zkServer.setTickTime(cfg.getTickTime());\n                zkServer.setMinSessionTimeout(cfg.getMinSessionTimeout());\n                zkServer.setMaxSessionTimeout(cfg.getMaxSessionTimeout());\n                NIOServerCnxnFactory cnxnFactory = new NIOServerCnxnFactory();\n                cnxnFactory.configure(cfg.getClientPortAddress(), cfg.getMaxClientCnxns());\n\n                try {\n                    debug(\"Starting ZooKeeper server on address %s\", config.getClientPortAddress());\n                    cnxnFactory.startup(zkServer);\n                    LOG.debug(\"Started ZooKeeper server\");\n                } catch (Exception e) {\n                    LOG.warn(String.format(\"Failed to start ZooKeeper server, reason : %s\", e));\n                    cnxnFactory.shutdown();\n                    throw e;\n                }\n\n                servers.put(pid, cnxnFactory);\n                services.put(pid, bundleContext.registerService(ServerStats.Provider.class.getName(), zkServer, properties));\n            }\n        } catch (Exception e) {\n            throw (ConfigurationException) new ConfigurationException(null, \"Unable to parse ZooKeeper configuration: \" + e.getMessage()).initCause(e);\n        }\n    }","commit_id":"0d17af89900c7728b3f202d7147c5313a81e2d91","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public synchronized void deleted(String pid) {\n        debug(\"Shutting down ZK server %s\", pid);\n        Object obj = servers.remove(pid);\n        ServiceRegistration reg = services.remove(pid);\n        if (reg != null) {\n            try {\n                reg.unregister();\n            } catch (Throwable t) {\n                debug(\"Caught and am ignoring exception %s while unregistering %s\", t, pid);\n                // ignore\n            }\n        }\n        try {\n            if (obj instanceof QuorumPeer) {\n                ((QuorumPeer) obj).shutdown();\n            } else if (obj instanceof NIOServerCnxn.Factory) {\n                ((NIOServerCnxn.Factory) obj).shutdown();\n            }\n        } catch (Throwable t) {\n            debug(\"Caught and am ignoring exception %s while shutting down ZK server %s\", t, obj);\n            // ignore\n        }\n    }","id":91901,"modified_method":"public synchronized void deleted(String pid) {\n        debug(\"Shutting down ZK server %s\", pid);\n        Object obj = servers.remove(pid);\n        ServiceRegistration reg = services.remove(pid);\n        try {\n            if (obj instanceof QuorumPeer) {\n                ((QuorumPeer) obj).shutdown();\n                ((QuorumPeer) obj).join();\n            } else if (obj instanceof NIOServerCnxnFactory) {\n                ((NIOServerCnxnFactory) obj).shutdown();\n                ((NIOServerCnxnFactory) obj).join();\n            }\n        } catch (Throwable t) {\n            debug(\"Caught and am ignoring exception %s while shutting down ZK server %s\", t, obj);\n            // ignore\n        }\n        if (reg != null) {\n            try {\n                reg.unregister();\n            } catch (Throwable t) {\n                debug(\"Caught and am ignoring exception %s while unregistering %s\", t, pid);\n                // ignore\n            }\n        }\n    }","commit_id":"0d17af89900c7728b3f202d7147c5313a81e2d91","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void createLocalServer(int port) {\n        ZKClient client = null;\n        try {\n            String karafName = System.getProperty(\"karaf.name\");\n            Configuration config = configurationAdmin.createFactoryConfiguration(\"org.fusesource.fabric.zookeeper.server\");\n            Properties properties = new Properties();\n            properties.put(\"tickTime\",  \"2000\");\n            properties.put(\"initLimit\", \"10\");\n            properties.put(\"syncLimit\", \"5\");\n            properties.put(\"dataDir\", \"data/zookeeper/0000\");\n            properties.put(\"clientPort\", Integer.toString(port));\n            properties.put(\"fabric.zookeeper.pid\", \"org.fusesource.fabric.zookeeper.server-0000\");\n            config.setBundleLocation(null);\n            config.update(properties);\n            config = configurationAdmin.getConfiguration(\"org.fusesource.fabric.zookeeper\");\n            properties = new Properties();\n            String connectionUrl = getLocalHostAddress() + \":\" + Integer.toString(port);\n            String mavenProxyUrl = \"http://\"+getLocalHostAddress() + \":\" + 8040;\n            properties.put(\"zookeeper.url\", connectionUrl);\n            config.setBundleLocation(null);\n            config.update(properties);\n\n            client = new ZKClient(connectionUrl, Timespan.ONE_MINUTE, null);\n            client.start();\n            client.waitForStart(new Timespan(5, Timespan.TimeUnit.SECOND));\n\n            String defaultProfile = ZkPath.CONFIG_VERSIONS_PROFILE.getPath(version, \"default\");\n            setConfigProperty(client, defaultProfile + \"/org.fusesource.fabric.zookeeper.properties\", \"zookeeper.url\", \"${zk:\" + karafName + \"/ip}:\" + Integer.toString(port));\n\n            String profileNode = ZkPath.CONFIG_VERSIONS_PROFILE.getPath(version, \"zk-server-0000\") + \"/org.fusesource.fabric.zookeeper.server-0000.properties\";\n            Properties p = new Properties();\n            p.put(\"tickTime\", \"2000\");\n            p.put(\"initLimit\", \"10\");\n            p.put(\"syncLimit\", \"5\");\n            p.put(\"dataDir\", \"data/zookeeper/0000\");\n\n            ZooKeeperUtils.set(client, profileNode, toString(p));\n\n            ZooKeeperUtils.set(client, ZkPath.CONFIG_VERSIONS_PROFILE.getPath(version, \"zk-server-0000-1\"), \"zk-server-0000\");\n            profileNode = ZkPath.CONFIG_VERSIONS_PROFILE.getPath(version, \"zk-server-0000-1\") + \"/org.fusesource.fabric.zookeeper.server-0000.properties\";\n            p = new Properties();\n            p.put(\"clientPort\", \"2181\");\n            ZooKeeperUtils.set(client, profileNode, toString(p));\n\n            ZooKeeperUtils.set(client, \"/fabric/configs/versions/\" + version + \"/general/zookeeper-cluster\", \"0000\");\n            ZooKeeperUtils.set(client, \"/fabric/configs/versions/\" + version + \"/general/zookeeper-cluster/0000\", karafName);\n\n            p = getProperties(client, defaultProfile + \"/org.fusesource.fabric.agent.properties\", new Properties());\n            p.put(\"org.ops4j.pax.url.mvn.defaultRepositories\", \"file:${karaf.home}/${karaf.default.repository}@snapshots\");\n            p.put(\"org.ops4j.pax.url.mvn.repositories\", \"http://repo1.maven.org/maven2,http://repo.fusesource.com/nexus/content/repositories/releases,http://scala-tools.org/repo-releases\");\n            p.put(\"repository.fabric\", \"mvn:org.fusesource.fabric/fuse-fabric/1.1-SNAPSHOT/xml/features\");\n            p.put(\"feature.karaf\", \"karaf\");\n            p.put(\"feature.fabric-agent\", \"fabric-agent\");\n            p.put(\"feature.fabric-core\", \"fabric-core\");\n            p.put(\"feature.fabric-jaas\", \"fabric-jaas\");\n            p.put(\"framework\", \"mvn:org.apache.felix/org.apache.felix.framework/3.0.9-fuse-00-10\");\n\n            ZooKeeperUtils.set(client, defaultProfile + \"/org.fusesource.fabric.agent.properties\", toString(p));\n\n            ZooKeeperUtils.createDefault(client, ZkPath.CONFIG_AGENT.getPath(karafName), version);\n            ZooKeeperUtils.createDefault(client, ZkPath.CONFIG_VERSIONS_AGENT.getPath(version, karafName), \"default zk-server-0000-1\");\n\n            // add auth\n            ZooKeeperUtils.createDefault(client, defaultProfile + \"/org.fusesource.fabric.jaas/encryption.enabled\", \"${zk:/fabric/authentication/encryption.enabled}\");\n            ZooKeeperUtils.createDefault(client, \"fabric/authentication/encryption.enabled\", \"true\");\n            ZooKeeperUtils.createDefault(client, \"fabric/authentication/domain\", \"zookeeper\");\n            ZooKeeperUtils.createDefault(client, \"/fabric/authentication/users\", \"admin={CRYPT}21232f297a57a5a743894a0e4a801fc3{CRYPT},admin\\nsystem={CRYPT}1d0258c2440a8d19e716292b231e3190{CRYPT},admin\");\n\n            ZooKeeperUtils.createDefault(client,ZkPath.CONFIGS_MAVEN_REPO.getPath(),mavenProxyUrl);\n\n            Bundle bundle = null;\n            for (Bundle b : bundleContext.getBundles()) {\n                if (b.getSymbolicName() != null && b.getSymbolicName().equals(\"org.fusesource.fabric.fabric-configadmin\")) {\n                    if (b.getVersion().getMajor() == 1 && b.getVersion().getMinor() == 1 && b.getVersion().getMicro() == 0) {\n                        bundle = b;\n                        break;\n                    }\n                }\n            }\n            if (bundle == null) {\n                bundle = bundleContext.installBundle(\"mvn:org.fusesource.fabric/fabric-configadmin/1.1-SNAPSHOT\");\n            }\n            if (bundle.getState() == Bundle.ACTIVE) {\n                bundle.stop();\n            }\n            bundle.start();\n        } catch (Exception e) {\n\n            throw new FabricException(\"Unable to create zookeeper server configuration\", e);\n        } finally {\n            if (client != null) {\n                client.destroy();\n            }\n        }\n    }","id":91902,"modified_method":"public void createLocalServer(int port) {\n        ZKClient client = null;\n        try {\n            String karafName = System.getProperty(\"karaf.name\");\n            Configuration config = configurationAdmin.getConfiguration(\"org.fusesource.fabric.zookeeper\");\n            Properties properties = new Properties();\n            String connectionUrl = getLocalHostAddress() + \":\" + Integer.toString(port);\n            String mavenProxyUrl = \"http://\"+getLocalHostAddress() + \":\" + 8040;\n            properties.put(\"zookeeper.url\", connectionUrl);\n            config.setBundleLocation(null);\n            config.update(properties);\n            config = configurationAdmin.createFactoryConfiguration(\"org.fusesource.fabric.zookeeper.server\");\n            properties = new Properties();\n            properties.put(\"tickTime\",  \"2000\");\n            properties.put(\"initLimit\", \"10\");\n            properties.put(\"syncLimit\", \"5\");\n            properties.put(\"dataDir\", \"data/zookeeper/0000\");\n            properties.put(\"clientPort\", Integer.toString(port));\n            properties.put(\"fabric.zookeeper.pid\", \"org.fusesource.fabric.zookeeper.server-0000\");\n            config.setBundleLocation(null);\n            config.update(properties);\n\n            client = new ZKClient(connectionUrl, Timespan.ONE_MINUTE, null);\n            client.start();\n            client.waitForStart(new Timespan(5, Timespan.TimeUnit.SECOND));\n\n            String defaultProfile = ZkPath.CONFIG_VERSIONS_PROFILE.getPath(version, \"default\");\n            setConfigProperty(client, defaultProfile + \"/org.fusesource.fabric.zookeeper.properties\", \"zookeeper.url\", \"${zk:\" + karafName + \"/ip}:\" + Integer.toString(port));\n\n            String profileNode = ZkPath.CONFIG_VERSIONS_PROFILE.getPath(version, \"zk-server-0000\") + \"/org.fusesource.fabric.zookeeper.server-0000.properties\";\n            Properties p = new Properties();\n            p.put(\"tickTime\", \"2000\");\n            p.put(\"initLimit\", \"10\");\n            p.put(\"syncLimit\", \"5\");\n            p.put(\"dataDir\", \"data/zookeeper/0000\");\n\n            ZooKeeperUtils.set(client, profileNode, toString(p));\n\n            ZooKeeperUtils.set(client, ZkPath.CONFIG_VERSIONS_PROFILE.getPath(version, \"zk-server-0000-1\"), \"zk-server-0000\");\n            profileNode = ZkPath.CONFIG_VERSIONS_PROFILE.getPath(version, \"zk-server-0000-1\") + \"/org.fusesource.fabric.zookeeper.server-0000.properties\";\n            p = new Properties();\n            p.put(\"clientPort\", \"2181\");\n            ZooKeeperUtils.set(client, profileNode, toString(p));\n\n            ZooKeeperUtils.set(client, \"/fabric/configs/versions/\" + version + \"/general/zookeeper-cluster\", \"0000\");\n            ZooKeeperUtils.set(client, \"/fabric/configs/versions/\" + version + \"/general/zookeeper-cluster/0000\", karafName);\n\n            p = getProperties(client, defaultProfile + \"/org.fusesource.fabric.agent.properties\", new Properties());\n            p.put(\"org.ops4j.pax.url.mvn.defaultRepositories\", \"file:${karaf.home}/${karaf.default.repository}@snapshots\");\n            p.put(\"org.ops4j.pax.url.mvn.repositories\", \"http://repo1.maven.org/maven2,http://repo.fusesource.com/nexus/content/repositories/releases,http://scala-tools.org/repo-releases\");\n            p.put(\"repository.fabric\", \"mvn:org.fusesource.fabric/fuse-fabric/1.1-SNAPSHOT/xml/features\");\n            p.put(\"feature.karaf\", \"karaf\");\n            p.put(\"feature.fabric-agent\", \"fabric-agent\");\n            p.put(\"feature.fabric-core\", \"fabric-core\");\n            p.put(\"feature.fabric-jaas\", \"fabric-jaas\");\n            p.put(\"framework\", \"mvn:org.apache.felix/org.apache.felix.framework/3.0.9-fuse-00-10\");\n\n            ZooKeeperUtils.set(client, defaultProfile + \"/org.fusesource.fabric.agent.properties\", toString(p));\n\n            ZooKeeperUtils.createDefault(client, ZkPath.CONFIG_AGENT.getPath(karafName), version);\n            ZooKeeperUtils.createDefault(client, ZkPath.CONFIG_VERSIONS_AGENT.getPath(version, karafName), \"default zk-server-0000-1\");\n\n            // add auth\n            ZooKeeperUtils.createDefault(client, defaultProfile + \"/org.fusesource.fabric.jaas/encryption.enabled\", \"${zk:/fabric/authentication/encryption.enabled}\");\n            ZooKeeperUtils.createDefault(client, \"fabric/authentication/encryption.enabled\", \"true\");\n            ZooKeeperUtils.createDefault(client, \"fabric/authentication/domain\", \"zookeeper\");\n            ZooKeeperUtils.createDefault(client, \"/fabric/authentication/users\", \"admin={CRYPT}21232f297a57a5a743894a0e4a801fc3{CRYPT},admin\\nsystem={CRYPT}1d0258c2440a8d19e716292b231e3190{CRYPT},admin\");\n\n            ZooKeeperUtils.createDefault(client,ZkPath.CONFIGS_MAVEN_REPO.getPath(),mavenProxyUrl);\n\n            Bundle bundle = null;\n            for (Bundle b : bundleContext.getBundles()) {\n                if (b.getSymbolicName() != null && b.getSymbolicName().equals(\"org.fusesource.fabric.fabric-configadmin\")) {\n                    if (b.getVersion().getMajor() == 1 && b.getVersion().getMinor() == 1 && b.getVersion().getMicro() == 0) {\n                        bundle = b;\n                        break;\n                    }\n                }\n            }\n            if (bundle == null) {\n                bundle = bundleContext.installBundle(\"mvn:org.fusesource.fabric/fabric-configadmin/1.1-SNAPSHOT\");\n            }\n            if (bundle.getState() == Bundle.ACTIVE) {\n                bundle.stop();\n            }\n            bundle.start();\n        } catch (Exception e) {\n\n            throw new FabricException(\"Unable to create zookeeper server configuration\", e);\n        } finally {\n            if (client != null) {\n                client.destroy();\n            }\n        }\n    }","commit_id":"0d17af89900c7728b3f202d7147c5313a81e2d91","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void clean() {\n        try {\n            Configuration[] configs = configurationAdmin.listConfigurations(\"(|(service.factoryPid=org.fusesource.fabric.zookeeper.server)(service.pid=org.fusesource.fabric.zookeeper))\");\n            if (configs != null) {\n                for (Configuration config : configs) {\n                    config.delete();\n                }\n            }\n            File zkDir = new File(\"data/zookeeper\");\n            if (zkDir.isDirectory()) {\n                File newZkDir = new File(\"data/zookeeper.\" + System.currentTimeMillis());\n                if (!zkDir.renameTo(newZkDir)) {\n                    newZkDir = zkDir;\n                }\n                delete(newZkDir);\n            }\n        } catch (Exception e) {\n            throw new FabricException(\"Unable to delete zookeeper configuration\", e);\n        }\n    }","id":91903,"modified_method":"public void clean() {\n        try {\n            for (;;) {\n                Configuration[] configs = configurationAdmin.listConfigurations(\"(|(service.factoryPid=org.fusesource.fabric.zookeeper.server)(service.pid=org.fusesource.fabric.zookeeper))\");\n                if (configs != null && configs.length > 0) {\n                    for (Configuration config : configs) {\n                        config.delete();\n                    }\n                    Thread.sleep(100);\n                } else {\n                    break;\n                }\n            }\n            File zkDir = new File(\"data/zookeeper\");\n            if (zkDir.isDirectory()) {\n                File newZkDir = new File(\"data/zookeeper.\" + System.currentTimeMillis());\n                if (!zkDir.renameTo(newZkDir)) {\n                    newZkDir = zkDir;\n                }\n                delete(newZkDir);\n            }\n        } catch (Exception e) {\n            throw new FabricException(\"Unable to delete zookeeper configuration\", e);\n        }\n    }","commit_id":"0d17af89900c7728b3f202d7147c5313a81e2d91","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void run() {\n            byte[] buffer = new byte[MAX_PACKET_SIZE];\n            ByteCollector bc = new ByteCollector();\n            boolean keepHandling = true;\n            int packetsHandled = 0;\n            try {\n                //              try {\n                while (keepHandling) {\n                    keepHandling = handleNextPacket(bc, buffer);\n                    packetsHandled++;\n                }\n                if ((bc.getCurrentSize() > 0) && (packetsHandled > 1)) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(getPrefix() + \"We lost some data queued up due to a network send error (input stream: \" \n                                  + in.hashCode() + \"; \"\n                                  + \"queue size: \" + bc.getCurrentSize() + \")\");\n                }\n                synchronized (flagLock) {\n                    closed2 = true;\n                }\n                boolean sc;\n                synchronized (flagLock) {\n                    sc = sendClose;\n                } // FIXME: Race here?\n                if (sc) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(getPrefix() + \"Sending close packet: (we started? \" + outgoing + \") after reading \" + _bytesRead + \" and writing \" + _bytesWritten);\n                    byte[] packet = I2PSocketManager.makePacket(getMask(0x02), remoteID, new byte[0]);\n                    boolean sent = manager.getSession().sendMessage(remote, packet);\n                    if (!sent) {\n                        if (_log.shouldLog(Log.WARN))\n                            _log.warn(getPrefix() + \"Error sending close packet to peer\");\n                        errorOccurred();\n                    }\n                }\n                manager.removeSocket(I2PSocketImpl.this);\n            } catch (InterruptedIOException ex) {\n                _log.error(getPrefix() + \"BUG! read() operations should not timeout!\", ex);\n            } catch (IOException ex) {\n                // WHOEVER removes this event on inconsistent\n                // state before fixing the inconsistent state (a\n                // reference on the socket in the socket manager\n                // etc.) will get hanged by me personally -- mihi\n                _log.error(getPrefix() + \"Error running - **INCONSISTENT STATE!!!**\", ex);\n            } catch (I2PException ex) {\n                _log.error(getPrefix() + \"Error running - **INCONSISTENT STATE!!!**\", ex);\n            }\n        }","id":91904,"modified_method":"public void run() {\n            byte[] buffer = new byte[MAX_PACKET_SIZE];\n            ByteCollector bc = new ByteCollector();\n            boolean keepHandling = true;\n            int packetsHandled = 0;\n            try {\n                //              try {\n                while (keepHandling) {\n                    keepHandling = handleNextPacket(bc, buffer);\n                    packetsHandled++;\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(getPrefix() + \":\" + Thread.currentThread().getName() \n                                   + \"Packets handled: \" + packetsHandled);\n                }\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(getPrefix() + \":\" + Thread.currentThread().getName() \n                               + \"After handling packets, we're done.  Packets handled: \" + packetsHandled);\n                \n                if ((bc.getCurrentSize() > 0) && (packetsHandled > 1)) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(getPrefix() + \"We lost some data queued up due to a network send error (input stream: \" \n                                  + in.hashCode() + \"; \"\n                                  + \"queue size: \" + bc.getCurrentSize() + \")\");\n                }\n                synchronized (flagLock) {\n                    closed2 = true;\n                }\n                boolean sc;\n                synchronized (flagLock) {\n                    sc = sendClose;\n                } // FIXME: Race here?\n                if (sc) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(getPrefix() + \":\" + Thread.currentThread().getName() \n                                  + \"Sending close packet: (we started? \" + outgoing \n                                  + \") after reading \" + _bytesRead + \" and writing \" + _bytesWritten);\n                    byte[] packet = I2PSocketManager.makePacket(getMask(0x02), remoteID, new byte[0]);\n                    boolean sent = manager.getSession().sendMessage(remote, packet);\n                    if (!sent) {\n                        if (_log.shouldLog(Log.WARN))\n                            _log.warn(getPrefix() + \":\" + Thread.currentThread().getName() \n                                      + \"Error sending close packet to peer\");\n                        errorOccurred();\n                    }\n                }\n                manager.removeSocket(I2PSocketImpl.this);\n                internalClose();\n            } catch (InterruptedIOException ex) {\n                _log.error(getPrefix() + \"BUG! read() operations should not timeout!\", ex);\n            } catch (IOException ex) {\n                // WHOEVER removes this event on inconsistent\n                // state before fixing the inconsistent state (a\n                // reference on the socket in the socket manager\n                // etc.) will get hanged by me personally -- mihi\n                _log.error(getPrefix() + \"Error running - **INCONSISTENT STATE!!!**\", ex);\n            } catch (I2PException ex) {\n                _log.error(getPrefix() + \"Error running - **INCONSISTENT STATE!!!**\", ex);\n            }\n        }","commit_id":"e5d66f46c6116fa725f7b11c0aa5cab07f8dbeec","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n         * Add the data to the queue\n         *\n         * @param allowBlock if true, we will block if the buffer and the socket options\n         *                   say so, otherwise we simply take the data regardless.\n         * @throws InterruptedIOException if the queue's buffer is full, the socket has\n         *                                a write timeout, and that timeout is exceeded\n         * @throws IOException if the connection was closed while queueing up the data\n         */\n        public void queueData(byte[] data, int off, int len, boolean allowBlock) throws InterruptedIOException, IOException {\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(getStreamPrefix() + \"Insert \" + len + \" bytes into queue: \" + hashCode());\n            Clock clock = I2PAppContext.getGlobalContext().clock();\n            long endAfter = clock.now() + _options.getWriteTimeout();\n            synchronized (bc) {\n                if (allowBlock) {\n                    if (_options.getMaxBufferSize() > 0) {\n                        while (bc.getCurrentSize() > _options.getMaxBufferSize()) {\n                            if (_log.shouldLog(Log.DEBUG))\n                                _log.debug(getStreamPrefix() + \"Buffer size exceeded: pending \" \n                                           + bc.getCurrentSize() + \" limit \" + _options.getMaxBufferSize());\n                            if (_options.getWriteTimeout() > 0) {\n                                long timeLeft = endAfter - clock.now();\n                                if (timeLeft <= 0) {\n                                    long waited = _options.getWriteTimeout() - timeLeft;\n                                    throw new InterruptedIOException(getStreamPrefix() + \"Waited too long (\" \n                                                                     + waited + \"ms) to write \" \n                                                                     + len + \" with a buffer at \" + bc.getCurrentSize());\n                                }\n                            }\n                            if (inStreamClosed)\n                                throw new IOException(getStreamPrefix() + \"Stream closed while writing\");\n                            if (_closedOn > 0)\n                                throw new IOException(getStreamPrefix() + \"I2PSocket closed while writing\");\n                            try {\n                                bc.wait(1000);\n                            } catch (InterruptedException ie) {}\n                        }\n                    }\n                }\n                bc.append(data, off, len);\n            }\n            synchronized (I2PInputStream.this) {\n                I2PInputStream.this.notifyAll();\n            }\n        }","id":91905,"modified_method":"/**\n         * Add the data to the queue\n         *\n         * @param allowBlock if true, we will block if the buffer and the socket options\n         *                   say so, otherwise we simply take the data regardless.\n         * @throws InterruptedIOException if the queue's buffer is full, the socket has\n         *                                a write timeout, and that timeout is exceeded\n         * @throws IOException if the connection was closed while queueing up the data\n         */\n        public void queueData(byte[] data, int off, int len, boolean allowBlock) throws InterruptedIOException, IOException {\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(getStreamPrefix() + \"Insert \" + len + \" bytes into queue: \" + hashCode());\n            Clock clock = I2PAppContext.getGlobalContext().clock();\n            long endAfter = clock.now() + _options.getWriteTimeout();\n            synchronized (bc) {\n                if (allowBlock) {\n                    if (_options.getMaxBufferSize() > 0) {\n                        while (bc.getCurrentSize() > _options.getMaxBufferSize()) {\n                            if (_log.shouldLog(Log.DEBUG))\n                                _log.debug(getStreamPrefix() + \"Buffer size exceeded: pending \" \n                                           + bc.getCurrentSize() + \" limit \" + _options.getMaxBufferSize());\n                            if (_options.getWriteTimeout() > 0) {\n                                long timeLeft = endAfter - clock.now();\n                                if (timeLeft <= 0) {\n                                    long waited = _options.getWriteTimeout() - timeLeft;\n                                    throw new InterruptedIOException(getStreamPrefix() + \"Waited too long (\" \n                                                                     + waited + \"ms) to write \" \n                                                                     + len + \" with a buffer at \" + bc.getCurrentSize());\n                                }\n                            }\n                            if (inStreamClosed)\n                                throw new IOException(getStreamPrefix() + \"Stream closed while writing\");\n                            if (_closedOn > 0)\n                                throw new IOException(getStreamPrefix() + \"I2PSocket closed while writing\");\n                            try {\n                                bc.wait(1000);\n                            } catch (InterruptedException ie) {}\n                        }\n                    }\n                }\n                bc.append(data, off, len);\n            }\n            synchronized (I2PInputStream.this) {\n                I2PInputStream.this.notifyAll();\n            }\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(getStreamPrefix() + \"After insert \" + len + \" bytes into queue: \" + hashCode());\n        }","commit_id":"e5d66f46c6116fa725f7b11c0aa5cab07f8dbeec","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void close() throws IOException {\n            super.close();\n            notifyClosed();\n            synchronized (bc) {\n                inStreamClosed = true;\n                bc.notifyAll();\n            }\n        }","id":91906,"modified_method":"public void close() throws IOException {\n            super.close();\n            notifyClosed();\n            synchronized (bc) {\n                inStreamClosed = true;\n                bc.notifyAll();\n            }\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(getStreamPrefix() + \"After close\");\n        }","commit_id":"e5d66f46c6116fa725f7b11c0aa5cab07f8dbeec","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n         * Pump some more data\n         *\n         * @return true if we should keep on handling, false otherwise\n         */\n        private boolean handleNextPacket(ByteCollector bc, byte buffer[]) \n                                         throws IOException, I2PSessionException {\n            int len = in.read(buffer);\n            int bcsize = bc.getCurrentSize();\n            if (len != -1) {\n                bc.append(buffer, len);\n            } else if (bcsize == 0) {\n                // nothing left in the buffer, and read(..) got EOF (-1).\n                // the bart the\n                return false;\n            }\n            if ((bcsize < MAX_PACKET_SIZE) && (in.available() == 0)) {\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(getPrefix() + \"Runner Point d: \" + hashCode());\n\n                try {\n                    Thread.sleep(PACKET_DELAY);\n                } catch (InterruptedException e) {\n                    _log.warn(\"wtf\", e);\n                }\n            }\n            if ((bcsize >= MAX_PACKET_SIZE) || (in.available() == 0)) {\n                byte[] data = bc.startToByteArray(MAX_PACKET_SIZE);\n                if (data.length > 0) {\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(getPrefix() + \"Message size is: \" + data.length);\n                    boolean sent = sendBlock(data);\n                    if (!sent) {\n                        if (_log.shouldLog(Log.WARN))\n                            _log.warn(getPrefix() + \"Error sending message to peer.  Killing socket runner\");\n                        errorOccurred();\n                        return false;\n                    } else {\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(getPrefix() + \"Message sent to peer\");\n                    }\n                }\n            }\n            return true;\n        }","id":91907,"modified_method":"/**\n         * Pump some more data\n         *\n         * @return true if we should keep on handling, false otherwise\n         */\n        private boolean handleNextPacket(ByteCollector bc, byte buffer[]) \n                                         throws IOException, I2PSessionException {\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(getPrefix() + \":\" + Thread.currentThread().getName() + \"handleNextPacket\");\n            int len = in.read(buffer);\n            int bcsize = 0;\n            synchronized (bc) {\n                bcsize = bc.getCurrentSize();\n            }\n\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(getPrefix() + \":\" + Thread.currentThread().getName() + \"handleNextPacket len=\" + len + \" bcsize=\" + bcsize);\n\n            if (len != -1) {\n                synchronized (bc) {\n                    bc.append(buffer, len);\n                }\n            } else if (bcsize == 0) {\n                // nothing left in the buffer, and read(..) got EOF (-1).\n                // the bart the\n                return false;\n            }\n            if ((bcsize < MAX_PACKET_SIZE) && (in.available() == 0)) {\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(getPrefix() + \":\" + Thread.currentThread().getName() + \"Runner Point d: \" + hashCode());\n\n                try {\n                    Thread.sleep(PACKET_DELAY);\n                } catch (InterruptedException e) {\n                    _log.warn(\"wtf\", e);\n                }\n            }\n            if ((bcsize >= MAX_PACKET_SIZE) || (in.available() == 0)) {\n                byte data[] = null;\n                synchronized (bc) {\n                    data = bc.startToByteArray(MAX_PACKET_SIZE);\n                }\n                if (data.length > 0) {\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(getPrefix() + \":\" + Thread.currentThread().getName() + \"Message size is: \" + data.length);\n                    boolean sent = sendBlock(data);\n                    if (!sent) {\n                        if (_log.shouldLog(Log.WARN))\n                            _log.warn(getPrefix() + \":\" + Thread.currentThread().getName() + \"Error sending message to peer.  Killing socket runner\");\n                        errorOccurred();\n                        return false;\n                    } else {\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(getPrefix() + \":\" + Thread.currentThread().getName() + \"Message sent to peer\");\n                    }\n                }\n            }\n            return true;\n        }","commit_id":"e5d66f46c6116fa725f7b11c0aa5cab07f8dbeec","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public int read(byte[] b, int off, int len) throws IOException {\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(getStreamPrefix() + \"Read called for \" + len + \" bytes (avail=\" \n                           + bc.getCurrentSize() + \"): \" + this.hashCode());\n            if (len == 0) return 0;\n            long dieAfter = System.currentTimeMillis() + readTimeout;\n            byte[] read = null;\n            synchronized (bc) {\n                read = bc.startToByteArray(len);\n                bc.notifyAll();\n            }\n            boolean timedOut = false;\n\n            while (read.length == 0) {\n                synchronized (flagLock) {\n                    if (closed) {\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(getStreamPrefix() + \"Closed is set after reading \" \n                                       + _bytesRead + \" and writing \" + _bytesWritten \n                                       + \", so closing stream: \" + hashCode());\n                        return -1;\n                    }\n                }\n                try {\n                    synchronized (I2PSocketImpl.I2PInputStream.this) {\n                        if (readTimeout >= 0) {\n                            wait(readTimeout);\n                        } else {\n                            wait();\n                        }\n                    }\n                } catch (InterruptedException ex) {}\n\n                if ((readTimeout >= 0)\n                    && (System.currentTimeMillis() >= dieAfter)) {\n                    throw new InterruptedIOException(getStreamPrefix() + \"Timeout reading from I2PSocket (\" \n                                                     + readTimeout + \" msecs)\");\n                }\n\n                synchronized (bc) {\n                    read = bc.startToByteArray(len);\n                    bc.notifyAll();\n                }\n            }\n            if (read.length > len) throw new RuntimeException(\"BUG\");\n            System.arraycopy(read, 0, b, off, read.length);\n\n            if (_log.shouldLog(Log.DEBUG)) {\n                _log.debug(getStreamPrefix() + \"Read from I2PInputStream \" + hashCode() + \" returned \" \n                           + read.length + \" bytes\");\n            }\n            //if (_log.shouldLog(Log.DEBUG)) {\n            //  _log.debug(\"Read from I2PInputStream \" + this.hashCode()\n            //             + \" returned \"+read.length+\" bytes:\\n\"\n            //             + HexDump.dump(read));\n            //}\n            return read.length;\n        }","id":91908,"modified_method":"public int read(byte[] b, int off, int len) throws IOException {\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(getStreamPrefix() + \"Read called for \" + len + \" bytes (avail=\" \n                           + bc.getCurrentSize() + \"): \" + this.hashCode());\n            if (len == 0) return 0;\n            long dieAfter = System.currentTimeMillis() + readTimeout;\n            byte[] read = null;\n            synchronized (bc) {\n                read = bc.startToByteArray(len);\n                bc.notifyAll();\n            }\n            boolean timedOut = false;\n\n            while ( (read.length == 0) && (!inStreamClosed) ) {\n                synchronized (flagLock) {\n                    if (closed) {\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(getStreamPrefix() + \"Closed is set after reading \" \n                                       + _bytesRead + \" and writing \" + _bytesWritten \n                                       + \", so closing stream: \" + hashCode());\n                        return -1;\n                    }\n                }\n                try {\n                    synchronized (I2PSocketImpl.I2PInputStream.this) {\n                        if (readTimeout >= 0) {\n                            wait(readTimeout);\n                        } else {\n                            wait();\n                        }\n                    }\n                } catch (InterruptedException ex) {}\n\n                if ((readTimeout >= 0)\n                    && (System.currentTimeMillis() >= dieAfter)) {\n                    throw new InterruptedIOException(getStreamPrefix() + \"Timeout reading from I2PSocket (\" \n                                                     + readTimeout + \" msecs)\");\n                }\n\n                synchronized (bc) {\n                    read = bc.startToByteArray(len);\n                    bc.notifyAll();\n                }\n            }\n            if (read.length > len) throw new RuntimeException(\"BUG\");\n            if ( (inStreamClosed) && ( (read == null) || (read.length <= 0) ) )\n                return -1;\n            \n            System.arraycopy(read, 0, b, off, read.length);\n\n            if (_log.shouldLog(Log.DEBUG)) {\n                _log.debug(getStreamPrefix() + \"Read from I2PInputStream \" + hashCode() + \" returned \" \n                           + read.length + \" bytes\");\n            }\n            //if (_log.shouldLog(Log.DEBUG)) {\n            //  _log.debug(\"Read from I2PInputStream \" + this.hashCode()\n            //             + \" returned \"+read.length+\" bytes:\\n\"\n            //             + HexDump.dump(read));\n            //}\n            return read.length;\n        }","commit_id":"e5d66f46c6116fa725f7b11c0aa5cab07f8dbeec","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void rewriteProject()\n        throws MojoExecutionException\n    {\n        File projectFile = new File( project.getBasedir(), project.getArtifactId() + \".ipr\" );\n        try\n        {\n            Reader reader;\n            if ( projectFile.exists() )\n            {\n                reader = new FileReader( projectFile );\n            }\n            else\n            {\n                reader = new InputStreamReader( getClass().getResourceAsStream( \"/templates/default/project.xml\" ) );\n            }\n\n            Xpp3Dom module;\n            try\n            {\n                module = Xpp3DomBuilder.build( reader );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n\n            // Set the jdk name if set\n            if ( jdkName != null )\n            {\n                setJdkName( module );\n            }\n            else\n            {\n                getLog().warn( \"jdkName is not set, you will have to set the JDK to use in IDEA.\" );\n            }\n\n            Xpp3Dom component = findComponent( module, \"ProjectModuleManager\" );\n            Xpp3Dom modules = findElement( component, \"modules\" );\n\n            if ( project.getCollectedProjects().size() > 0 )\n            {\n                removeOldElements( modules, \"module\" );\n\n                for ( Iterator i = project.getCollectedProjects().iterator(); i.hasNext(); )\n                {\n                    MavenProject p = (MavenProject) i.next();\n\n                    Xpp3Dom m = createElement( modules, \"module\" );\n                    String modulePath = new File( p.getBasedir(), p.getArtifactId() + \".iml\" ).getAbsolutePath();\n                    m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n                }\n            }\n            else\n            {\n                Xpp3Dom m = createElement( modules, \"module\" );\n                String modulePath = new File( project.getBasedir(),\n                                              project.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n            }\n\n            FileWriter writer = new FileWriter( projectFile );\n            try\n            {\n                Xpp3DomWriter.write( writer, module );\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n    }","id":91909,"modified_method":"private void rewriteProject()\n        throws MojoExecutionException\n    {\n        File projectFile = new File( project.getBasedir(), project.getArtifactId() + \".ipr\" );\n        try\n        {\n            Reader reader;\n            if ( projectFile.exists() )\n            {\n                reader = new FileReader( projectFile );\n            }\n            else\n            {\n                reader = new InputStreamReader( getClass().getResourceAsStream( \"/templates/default/project.xml\" ) );\n            }\n\n            Xpp3Dom module;\n            try\n            {\n                module = Xpp3DomBuilder.build( reader );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n\n            // Set the jdk name if set\n            if ( jdkName != null )\n            {\n                setJdkName( module, jdkName );\n            }\n            else\n            {\n                String javaVersion = System.getProperty( \"java.version\" );\n                String defaultJdkName = \"java version \" + javaVersion;\n                getLog().info( \"jdkName is not set, using[\" + defaultJdkName + \"] as default.\" );\n                setJdkName( module, defaultJdkName );\n            }\n\n            Xpp3Dom component = findComponent( module, \"ProjectModuleManager\" );\n            Xpp3Dom modules = findElement( component, \"modules\" );\n\n            if ( project.getCollectedProjects().size() > 0 )\n            {\n                removeOldElements( modules, \"module\" );\n\n                for ( Iterator i = project.getCollectedProjects().iterator(); i.hasNext(); )\n                {\n                    MavenProject p = (MavenProject) i.next();\n\n                    Xpp3Dom m = createElement( modules, \"module\" );\n                    String modulePath = new File( p.getBasedir(), p.getArtifactId() + \".iml\" ).getAbsolutePath();\n                    m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n                }\n            }\n            else\n            {\n                Xpp3Dom m = createElement( modules, \"module\" );\n                String modulePath = new File( project.getBasedir(),\n                                              project.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n            }\n\n            FileWriter writer = new FileWriter( projectFile );\n            try\n            {\n                Xpp3DomWriter.write( writer, module );\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n    }","commit_id":"54d740b70b0e60b9730f802a4acd60792b6408bc","url":"https://github.com/apache/maven"},{"original_method":"private void setJdkName( Xpp3Dom content )\n    {\n        Xpp3Dom component = findComponent( content, \"ProjectRootManager\" );\n        component.setAttribute( \"project-jdk-name\", jdkName );\n    }","id":91910,"modified_method":"private void setJdkName( Xpp3Dom content, String jdkName )\n    {\n        Xpp3Dom component = findComponent( content, \"ProjectRootManager\" );\n        component.setAttribute( \"project-jdk-name\", jdkName );\n    }","commit_id":"54d740b70b0e60b9730f802a4acd60792b6408bc","url":"https://github.com/apache/maven"},{"original_method":"private void rewriteProject()\n        throws MojoExecutionException\n    {\n        File projectFile = new File( project.getBasedir(), project.getArtifactId() + \".ipr\" );\n        try\n        {\n            Reader reader;\n            if ( projectFile.exists() )\n            {\n                reader = new FileReader( projectFile );\n            }\n            else\n            {\n                reader = new InputStreamReader( getClass().getResourceAsStream( \"/templates/default/project.xml\" ) );\n            }\n\n            Xpp3Dom module;\n            try\n            {\n                module = Xpp3DomBuilder.build( reader );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n\n            // Set the jdk name if set\n            if ( jdkName != null )\n            {\n                setJdkName( module );\n            }\n            else\n            {\n                getLog().warn( \"jdkName is not set, you will have to set the JDK to use in IDEA.\" );\n            }\n\n            Xpp3Dom component = findComponent( module, \"ProjectModuleManager\" );\n            Xpp3Dom modules = findElement( component, \"modules\" );\n\n            if ( project.getCollectedProjects().size() > 0 )\n            {\n                removeOldElements( modules, \"module\" );\n\n                for ( Iterator i = project.getCollectedProjects().iterator(); i.hasNext(); )\n                {\n                    MavenProject p = (MavenProject) i.next();\n\n                    Xpp3Dom m = createElement( modules, \"module\" );\n                    String modulePath = new File( p.getBasedir(), p.getArtifactId() + \".iml\" ).getAbsolutePath();\n                    m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n                }\n            }\n            else\n            {\n                Xpp3Dom m = createElement( modules, \"module\" );\n                String modulePath = new File( project.getBasedir(),\n                                              project.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n            }\n\n            FileWriter writer = new FileWriter( projectFile );\n            try\n            {\n                Xpp3DomWriter.write( writer, module );\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n    }","id":91911,"modified_method":"private void rewriteProject()\n        throws MojoExecutionException\n    {\n        File projectFile = new File( project.getBasedir(), project.getArtifactId() + \".ipr\" );\n        try\n        {\n            Reader reader;\n            if ( projectFile.exists() )\n            {\n                reader = new FileReader( projectFile );\n            }\n            else\n            {\n                reader = new InputStreamReader( getClass().getResourceAsStream( \"/templates/default/project.xml\" ) );\n            }\n\n            Xpp3Dom module;\n            try\n            {\n                module = Xpp3DomBuilder.build( reader );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n\n            // Set the jdk name if set\n            if ( jdkName != null )\n            {\n                setJdkName( module, jdkName );\n            }\n            else\n            {\n                String javaVersion = System.getProperty( \"java.version\" );\n                String defaultJdkName = \"java version \" + javaVersion;\n                getLog().info( \"jdkName is not set, using[\" + defaultJdkName + \"] as default.\" );\n                setJdkName( module, defaultJdkName );\n            }\n\n            Xpp3Dom component = findComponent( module, \"ProjectModuleManager\" );\n            Xpp3Dom modules = findElement( component, \"modules\" );\n\n            if ( project.getCollectedProjects().size() > 0 )\n            {\n                removeOldElements( modules, \"module\" );\n\n                for ( Iterator i = project.getCollectedProjects().iterator(); i.hasNext(); )\n                {\n                    MavenProject p = (MavenProject) i.next();\n\n                    Xpp3Dom m = createElement( modules, \"module\" );\n                    String modulePath = new File( p.getBasedir(), p.getArtifactId() + \".iml\" ).getAbsolutePath();\n                    m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n                }\n            }\n            else\n            {\n                Xpp3Dom m = createElement( modules, \"module\" );\n                String modulePath = new File( project.getBasedir(),\n                                              project.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n            }\n\n            FileWriter writer = new FileWriter( projectFile );\n            try\n            {\n                Xpp3DomWriter.write( writer, module );\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n    }","commit_id":"a8155538886f1df41a7e5afdfe10e5370852910f","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void setJdkName( Xpp3Dom content )\n    {\n        Xpp3Dom component = findComponent( content, \"ProjectRootManager\" );\n        component.setAttribute( \"project-jdk-name\", jdkName );\n    }","id":91912,"modified_method":"private void setJdkName( Xpp3Dom content, String jdkName )\n    {\n        Xpp3Dom component = findComponent( content, \"ProjectRootManager\" );\n        component.setAttribute( \"project-jdk-name\", jdkName );\n    }","commit_id":"a8155538886f1df41a7e5afdfe10e5370852910f","url":"https://github.com/apache/maven-plugins"},{"original_method":"static void replaceFile(File updatedFile, VirtualFile replacedJarFile) {\n        try {\n            String localPath = com.intellij.util.PathUtil.getLocalPath(replacedJarFile);\n            assert localPath != null;\n\n            File libraryJarPath = new File(localPath);\n\n            if (FileUtil.filesEqual(updatedFile, libraryJarPath)) {\n                throw new IllegalArgumentException(\"Shouldn't be called for updating same file: \" + updatedFile);\n            }\n\n            FileUtil.copy(updatedFile, libraryJarPath);\n\n            VirtualFile localFile = JarFileSystem.getInstance().getLocalVirtualFileFor(replacedJarFile);\n            if (localFile != null) {\n                localFile.refresh(false, true);\n            }\n        }\n        catch (IOException e) {\n            throw new AssertionError(e);\n        }\n    }","id":91913,"modified_method":"static void replaceFile(File updatedFile, VirtualFile replacedJarFile) {\n        try {\n            VirtualFile replacedFile = getLocalFile(replacedJarFile);\n\n            String localPath = getLocalPath(replacedFile);\n            assert localPath != null : \"Should be called for replacing valid root file: \" + replacedJarFile;\n\n            File libraryJarPath = new File(localPath);\n\n            if (FileUtil.filesEqual(updatedFile, libraryJarPath)) {\n                throw new IllegalArgumentException(\"Shouldn't be called for updating same file: \" + updatedFile);\n            }\n\n            FileUtil.copy(updatedFile, libraryJarPath);\n            replacedFile.refresh(false, true);\n        }\n        catch (IOException e) {\n            throw new AssertionError(e);\n        }\n    }","commit_id":"fb4a205277088eeb9b31e17cd42fb108c822b7ac","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static Collection<VirtualFile> getLibraryRootsWithAbiIncompatibleKotlinClasses(@NotNull Project project) {\n        ID<Integer,Void> id = KotlinAbiVersionIndex.INSTANCE.getName();\n        Collection<Integer> abiVersions = FileBasedIndex.getInstance().getAllKeys(id, project);\n        Set<Integer> badAbiVersions = Sets.newHashSet(Collections2.filter(abiVersions, new Predicate<Integer>() {\n            @Override\n            public boolean apply(Integer abiVersion) {\n                return !AbiVersionUtil.isAbiVersionCompatible(abiVersion);\n            }\n        }));\n        final Collection<VirtualFile> badRoots = Sets.newHashSet();\n        final ProjectFileIndex fileIndex = ProjectFileIndex.SERVICE.getInstance(project);\n        FileBasedIndex.getInstance().getFilesWithKey(\n                id,\n                badAbiVersions,\n                new Processor<VirtualFile>() {\n                    @Override\n                    public boolean process(VirtualFile file) {\n                        assert file != null;\n                        if (!file.isValid()) return true;\n                        VirtualFile root = fileIndex.getClassRootForFile(file);\n                        if (root != null) {\n                            VirtualFile jarFile = JarFileSystem.getInstance().getVirtualFileForJar(root);\n                            badRoots.add(jarFile != null ? jarFile : root);\n                        }\n                        else {\n                            badRoots.add(file);\n                        }\n                        return true;\n                    }\n                },\n                ProjectScope.getLibrariesScope(project)\n        );\n\n        return badRoots;\n    }","id":91914,"modified_method":"@NotNull\n    public static Collection<VirtualFile> getLibraryRootsWithAbiIncompatibleKotlinClasses(@NotNull Project project) {\n        ID<Integer,Void> id = KotlinAbiVersionIndex.INSTANCE.getName();\n        Collection<Integer> abiVersions = FileBasedIndex.getInstance().getAllKeys(id, project);\n        Set<Integer> badAbiVersions = Sets.newHashSet(Collections2.filter(abiVersions, new Predicate<Integer>() {\n            @Override\n            public boolean apply(Integer abiVersion) {\n                return !AbiVersionUtil.isAbiVersionCompatible(abiVersion);\n            }\n        }));\n        Set<VirtualFile> badRoots = Sets.newHashSet();\n        ProjectFileIndex fileIndex = ProjectFileIndex.SERVICE.getInstance(project);\n\n        for (Integer version : badAbiVersions) {\n            Collection<VirtualFile> indexedFiles = FileBasedIndex.getInstance().getContainingFiles(id, version, ProjectScope.getLibrariesScope(project));\n\n            for (VirtualFile indexedFile : indexedFiles) {\n                VirtualFile libraryRoot = fileIndex.getClassRootForFile(indexedFile);\n                assert libraryRoot != null : \"Only library roots were requested, \" +\n                                             \"and only class files should be indexed with KotlinAbiVersionIndex key. \" +\n                                             \"File: \" + libraryRoot;\n                badRoots.add(getLocalFile(libraryRoot));\n            }\n        }\n\n        return badRoots;\n    }","commit_id":"fb4a205277088eeb9b31e17cd42fb108c822b7ac","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public VirtualFile getOutput() {\n        assert output != null;\n        return output;\n    }","id":91915,"modified_method":"@NotNull\n    public File getOutput() {\n        assert output != null;\n        return output;\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public CompilerEnvironment(@Nullable File home, @Nullable VirtualFile output) {\n        this.kotlinHome = home;\n        this.output = output;\n    }","id":91916,"modified_method":"public CompilerEnvironment(@Nullable File home, @Nullable File output) {\n        this.kotlinHome = home;\n        this.output = output;\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static CompilerEnvironment getEnvironmentFor(@NotNull CompileContext compileContext, @NotNull Module module, boolean tests) {\n        VirtualFile mainOutput = compileContext.getModuleOutputDirectory(module);\n        final VirtualFile outputDir = tests ? compileContext.getModuleOutputDirectoryForTests(module) : mainOutput;\n        File kotlinHome = PathUtil.getDefaultCompilerPath();\n        return new CompilerEnvironment(kotlinHome, outputDir);\n    }","id":91917,"modified_method":"@NotNull\n    public static CompilerEnvironment getEnvironmentFor(boolean tests, File mainOutput, File outputDirectoryForTests) {\n        final File outputDir = tests ? outputDirectoryForTests : mainOutput;\n        File kotlinHome = PathUtil.getDefaultCompilerPath();\n        return new CompilerEnvironment(kotlinHome, outputDir);\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (tags.size() == 1) {\n                // We're directly inside the root tag: <MESSAGES>\n                return;\n            }\n            String qNameLowerCase = qName.toLowerCase();\n            CompilerMessageCategory category = CATEGORIES.get(qNameLowerCase);\n            if (category == null) {\n                compileContext.addMessage(ERROR, \"Unknown compiler message tag: \" + qName, null, -1, -1);\n                category = INFORMATION;\n            }\n            String text = message.toString();\n\n            if (\"exception\".equals(qNameLowerCase)) {\n                LOG.error(text);\n            }\n\n            if (category == STATISTICS) {\n                compileContext.getProgressIndicator().setText(text);\n                collector.learn(text);\n            }\n            else {\n                compileContext.addMessage(category, text, path, line, column);\n            }\n            tags.pop();\n        }","id":91918,"modified_method":"@Override\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (tags.size() == 1) {\n                // We're directly inside the root tag: <MESSAGES>\n                return;\n            }\n            String qNameLowerCase = qName.toLowerCase();\n            CompilerMessageSeverity category = CATEGORIES.get(qNameLowerCase);\n            if (category == null) {\n                messageCollector.report(ERROR, \"Unknown compiler message tag: \" + qName, NO_LOCATION);\n                category = INFO;\n            }\n            String text = message.toString();\n\n            if (\"exception\".equals(qNameLowerCase)) {\n                LOG.error(text);\n            }\n\n            if (category == LOGGING) {\n                collector.learn(text);\n            }\n            else {\n                messageCollector.report(category, text, CompilerMessageLocation.create(path, line, column));\n            }\n            tags.pop();\n        }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void outputCompilerMessagesAndHandleExitCode(@NotNull CompileContext context,\n            @NotNull OutputItemsCollector collector,\n            @NotNull Function1<PrintStream, Integer> compilerRun) {\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        PrintStream out = new PrintStream(outputStream);\n\n        int exitCode = compilerRun.invoke(out);\n\n        BufferedReader reader = new BufferedReader(new StringReader(outputStream.toString()));\n        parseCompilerMessagesFromReader(context, reader, collector);\n        handleProcessTermination(exitCode, context);\n    }","id":91919,"modified_method":"public static void outputCompilerMessagesAndHandleExitCode(@NotNull MessageCollector messageCollector,\n            @NotNull OutputItemsCollector outputItemsCollector,\n            @NotNull Function1<PrintStream, Integer> compilerRun) {\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        PrintStream out = new PrintStream(outputStream);\n\n        int exitCode = compilerRun.invoke(out);\n\n        BufferedReader reader = new BufferedReader(new StringReader(outputStream.toString()));\n        parseCompilerMessagesFromReader(messageCollector, reader, outputItemsCollector);\n        handleProcessTermination(exitCode, messageCollector);\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void parseCompilerMessagesFromReader(CompileContext compileContext, final Reader reader, OutputItemsCollector collector) {\n        // Sometimes the compiler can't output valid XML\n        // Example: error in command line arguments passed to the compiler\n        // having no -tags key (arguments are not parsed), the compiler doesn't know\n        // if it should put any tags in the output, so it will simply print the usage\n        // and the SAX parser will break.\n        // In this case, we want to read everything from this stream\n        // and report it as an IDE error.\n        final StringBuilder stringBuilder = new StringBuilder();\n        //noinspection IOResourceOpenedButNotSafelyClosed\n        Reader wrappingReader = new Reader() {\n\n            @Override\n            public int read(char[] cbuf, int off, int len) throws IOException {\n                int read = reader.read(cbuf, off, len);\n                stringBuilder.append(cbuf, off, len);\n                return read;\n            }\n\n            @Override\n            public void close() throws IOException {\n                // Do nothing:\n                // If the SAX parser sees a syntax error, it throws an exception\n                // and calls close() on the reader.\n                // We prevent hte reader from being closed here, and close it later,\n                // when all the text is read from it\n            }\n        };\n        try {\n            SAXParserFactory factory = SAXParserFactory.newInstance();\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(new InputSource(wrappingReader), new CompilerOutputSAXHandler(compileContext, collector));\n        }\n        catch (Throwable e) {\n\n            // Load all the text into the stringBuilder\n            try {\n                // This will not close the reader (see the wrapper above)\n                FileUtil.loadTextAndClose(wrappingReader);\n            }\n            catch (IOException ioException) {\n                LOG.error(ioException);\n            }\n            String message = stringBuilder.toString();\n            LOG.error(message);\n            LOG.error(e);\n            compileContext.addMessage(ERROR, message, null, -1, -1);\n        }\n        finally {\n            try {\n                reader.close();\n            }\n            catch (IOException e) {\n                LOG.error(e);\n            }\n        }\n    }","id":91920,"modified_method":"public static void parseCompilerMessagesFromReader(MessageCollector messageCollector, final Reader reader, OutputItemsCollector collector) {\n        // Sometimes the compiler can't output valid XML\n        // Example: error in command line arguments passed to the compiler\n        // having no -tags key (arguments are not parsed), the compiler doesn't know\n        // if it should put any tags in the output, so it will simply print the usage\n        // and the SAX parser will break.\n        // In this case, we want to read everything from this stream\n        // and report it as an IDE error.\n        final StringBuilder stringBuilder = new StringBuilder();\n        //noinspection IOResourceOpenedButNotSafelyClosed\n        Reader wrappingReader = new Reader() {\n\n            @Override\n            public int read(char[] cbuf, int off, int len) throws IOException {\n                int read = reader.read(cbuf, off, len);\n                stringBuilder.append(cbuf, off, len);\n                return read;\n            }\n\n            @Override\n            public void close() throws IOException {\n                // Do nothing:\n                // If the SAX parser sees a syntax error, it throws an exception\n                // and calls close() on the reader.\n                // We prevent hte reader from being closed here, and close it later,\n                // when all the text is read from it\n            }\n        };\n        try {\n            SAXParserFactory factory = SAXParserFactory.newInstance();\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(new InputSource(wrappingReader), new CompilerOutputSAXHandler(messageCollector, collector));\n        }\n        catch (Throwable e) {\n\n            // Load all the text into the stringBuilder\n            try {\n                // This will not close the reader (see the wrapper above)\n                FileUtil.loadTextAndClose(wrappingReader);\n            }\n            catch (IOException ioException) {\n                LOG.error(ioException);\n            }\n            String message = stringBuilder.toString();\n            LOG.error(message);\n            LOG.error(e);\n            messageCollector.report(ERROR, message, NO_LOCATION);\n        }\n        finally {\n            try {\n                reader.close();\n            }\n            catch (IOException e) {\n                LOG.error(e);\n            }\n        }\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static Object invokeExecMethod(CompilerEnvironment environment,\n            PrintStream out,\n            CompileContext context, String[] arguments, String name) throws Exception {\n        URLClassLoader loader = getOrCreateClassLoader(environment.getKotlinHome(), context);\n        Class<?> kompiler = Class.forName(name, true, loader);\n        Method exec = kompiler.getMethod(\"exec\", PrintStream.class, String[].class);\n        return exec.invoke(kompiler.newInstance(), out, arguments);\n    }","id":91921,"modified_method":"public static Object invokeExecMethod(CompilerEnvironment environment,\n            PrintStream out,\n            MessageCollector messageCollector, String[] arguments, String name) throws Exception {\n        URLClassLoader loader = getOrCreateClassLoader(environment.getKotlinHome(), messageCollector);\n        Class<?> kompiler = Class.forName(name, true, loader);\n        Method exec = kompiler.getMethod(\"exec\", PrintStream.class, String[].class);\n        return exec.invoke(kompiler.newInstance(), out, arguments);\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static List<File> kompilerClasspath(File kotlinHome, CompileContext context) {\n        File libs = new File(kotlinHome, \"lib\");\n\n        if (!libs.exists() || libs.isFile()) {\n            context.addMessage(ERROR, \"Broken compiler at '\" + libs.getAbsolutePath() + \"'. Make sure plugin is properly installed\", \"\", -1,\n                               -1);\n            return Collections.emptyList();\n        }\n\n        ArrayList<File> answer = new ArrayList<File>();\n        answer.add(new File(libs, \"kotlin-compiler.jar\"));\n        return answer;\n    }","id":91922,"modified_method":"public static List<File> kompilerClasspath(File kotlinHome, MessageCollector messageCollector) {\n        File libs = new File(kotlinHome, \"lib\");\n\n        if (!libs.exists() || libs.isFile()) {\n            messageCollector.report(ERROR, \"Broken compiler at '\" + libs.getAbsolutePath() + \"'. Make sure plugin is properly installed\", NO_LOCATION);\n            return Collections.emptyList();\n        }\n\n        ArrayList<File> answer = new ArrayList<File>();\n        answer.add(new File(libs, \"kotlin-compiler.jar\"));\n        return answer;\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n        public void characters(char[] ch, int start, int length) throws SAXException {\n            if (tags.size() == 1) {\n                // We're directly inside the root tag: <MESSAGES>\n                String message = new String(ch, start, length);\n                if (!message.trim().isEmpty()) {\n                    compileContext.addMessage(ERROR, \"Unhandled compiler output: \" + message, null, -1, -1);\n                }\n            }\n            else {\n                message.append(ch, start, length);\n            }\n        }","id":91923,"modified_method":"@Override\n        public void characters(char[] ch, int start, int length) throws SAXException {\n            if (tags.size() == 1) {\n                // We're directly inside the root tag: <MESSAGES>\n                String message = new String(ch, start, length);\n                if (!message.trim().isEmpty()) {\n                    messageCollector.report(ERROR, \"Unhandled compiler output: \" + message, NO_LOCATION);\n                }\n            }\n            else {\n                message.append(ch, start, length);\n            }\n        }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public CompilerOutputSAXHandler(CompileContext compileContext, OutputItemsCollector collector) {\n            this.compileContext = compileContext;\n            this.collector = collector;\n        }","id":91924,"modified_method":"public CompilerOutputSAXHandler(MessageCollector messageCollector, OutputItemsCollector collector) {\n            this.messageCollector = messageCollector;\n            this.collector = collector;\n        }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static URLClassLoader getOrCreateClassLoader(File kotlinHome, CompileContext context) {\n        URLClassLoader answer = ourClassLoaderRef.get();\n        if (answer == null) {\n            answer = createClassloader(kotlinHome, context);\n            ourClassLoaderRef = new SoftReference<URLClassLoader>(answer);\n        }\n        return answer;\n    }","id":91925,"modified_method":"public static URLClassLoader getOrCreateClassLoader(File kotlinHome, MessageCollector messageCollector) {\n        URLClassLoader answer = ourClassLoaderRef.get();\n        if (answer == null) {\n            answer = createClassloader(kotlinHome, messageCollector);\n            ourClassLoaderRef = new SoftReference<URLClassLoader>(answer);\n        }\n        return answer;\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static URLClassLoader createClassloader(File kotlinHome, CompileContext context) {\n        List<File> jars = kompilerClasspath(kotlinHome, context);\n        URL[] urls = new URL[jars.size()];\n        for (int i = 0; i < urls.length; i++) {\n            try {\n                urls[i] = jars.get(i).toURI().toURL();\n            }\n            catch (MalformedURLException e) {\n                throw new RuntimeException(e); // Checked exceptions are great! I love them, and I love brilliant library designers too!\n            }\n        }\n        return new URLClassLoader(urls, null);\n    }","id":91926,"modified_method":"private static URLClassLoader createClassloader(File kotlinHome, MessageCollector messageCollector) {\n        List<File> jars = kompilerClasspath(kotlinHome, messageCollector);\n        URL[] urls = new URL[jars.size()];\n        for (int i = 0; i < urls.length; i++) {\n            try {\n                urls[i] = jars.get(i).toURI().toURL();\n            }\n            catch (MalformedURLException e) {\n                throw new RuntimeException(e); // Checked exceptions are great! I love them, and I love brilliant library designers too!\n            }\n        }\n        return new URLClassLoader(urls, null);\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"static void handleProcessTermination(int exitCode, CompileContext compileContext) {\n        if (exitCode != 0 && exitCode != 1) {\n            compileContext.addMessage(ERROR, \"Compiler terminated with exit code: \" + exitCode, \"\", -1, -1);\n        }\n    }","id":91927,"modified_method":"static void handleProcessTermination(int exitCode, MessageCollector messageCollector) {\n        if (exitCode != 0 && exitCode != 1) {\n            messageCollector.report(ERROR, \"Compiler terminated with exit code: \" + exitCode, NO_LOCATION);\n        }\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static File tryToWriteScriptFile(\n            CompileContext compileContext,\n            Chunk<Module> moduleChunk,\n            List<VirtualFile> files,\n            Module module,\n            boolean tests, VirtualFile mainOutput, VirtualFile outputDir\n    ) {\n        ArrayList<String> sourceFilePaths = ContainerUtil.newArrayList(paths(files));\n        ModuleChunk chunk = new ModuleChunk((CompileContextEx)compileContext, moduleChunk, Collections.<Module, List<VirtualFile>>emptyMap());\n        String moduleName = moduleChunk.getNodes().iterator().next().getName();\n        String outputDirectoryForTests = path(compileContext.getModuleOutputDirectoryForTests(module));\n        String moduleOutputDirectory = path(compileContext.getModuleOutputDirectory(module));\n\n        // Filter the output we are writing to\n        Set<String> outputDirectoriesToFilter = ContainerUtil.newHashSet(outputDirectoryForTests);\n        if (!tests) {\n            outputDirectoriesToFilter.add(moduleOutputDirectory);\n        }\n        CharSequence script = KotlinModuleScriptGenerator.generateModuleScript(\n                moduleName,\n                getDependencyProvider(chunk, tests, mainOutput),\n                sourceFilePaths,\n                tests,\n                outputDirectoriesToFilter\n        );\n\n        File scriptFile = new File(path(outputDir), \"script.kts\");\n        try {\n            FileUtil.writeToFile(scriptFile, script.toString());\n        }\n        catch (IOException e) {\n            compileContext.addMessage(CompilerMessageCategory.ERROR, \"[Internal Error] Cannot write script to \" + scriptFile.getAbsolutePath(), \"\", -1, -1);\n            return null;\n        }\n        return scriptFile;\n    }","id":91928,"modified_method":"public static File tryToWriteScriptFile(\n            CompileContext compileContext,\n            Chunk<Module> moduleChunk,\n            List<VirtualFile> files,\n            Module module,\n            boolean tests, VirtualFile mainOutput, File outputDir\n    ) {\n        ArrayList<String> sourceFilePaths = ContainerUtil.newArrayList(paths(files));\n        ModuleChunk chunk = new ModuleChunk((CompileContextEx)compileContext, moduleChunk, Collections.<Module, List<VirtualFile>>emptyMap());\n        String moduleName = moduleChunk.getNodes().iterator().next().getName();\n        String outputDirectoryForTests = path(compileContext.getModuleOutputDirectoryForTests(module));\n        String moduleOutputDirectory = path(compileContext.getModuleOutputDirectory(module));\n\n        // Filter the output we are writing to\n        Set<String> outputDirectoriesToFilter = ContainerUtil.newHashSet(outputDirectoryForTests);\n        if (!tests) {\n            outputDirectoriesToFilter.add(moduleOutputDirectory);\n        }\n        CharSequence script = KotlinModuleScriptGenerator.generateModuleScript(\n                moduleName,\n                getDependencyProvider(chunk, tests, mainOutput),\n                sourceFilePaths,\n                tests,\n                outputDirectoriesToFilter\n        );\n\n        File scriptFile = new File(outputDir, \"script.kts\");\n        try {\n            FileUtil.writeToFile(scriptFile, script.toString());\n        }\n        catch (IOException e) {\n            compileContext.addMessage(CompilerMessageCategory.ERROR, \"[Internal Error] Cannot write script to \" + scriptFile.getAbsolutePath(), \"\", -1, -1);\n            return null;\n        }\n        return scriptFile;\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void runCompiler(CompileContext compileContext,\n            CompilerEnvironment environment,\n            File scriptFile,\n            CompilerUtils.OutputItemsCollectorImpl collector) {\n        if (RUN_OUT_OF_PROCESS) {\n            runOutOfProcess(compileContext, collector, environment, scriptFile);\n        }\n        else {\n            runInProcess(compileContext, collector, environment, scriptFile);\n        }\n    }","id":91929,"modified_method":"private static void runCompiler(\n            MessageCollector messageCollector,\n            CompilerEnvironment environment,\n            File scriptFile,\n            CompilerUtils.OutputItemsCollectorImpl collector\n    ) {\n        runCompiler(messageCollector, environment, scriptFile, collector, RUN_OUT_OF_PROCESS);\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static String[] commandLineArguments(VirtualFile outputDir, File scriptFile) {\n        return new String[]{\n                \"-module\", scriptFile.getAbsolutePath(),\n                \"-output\", path(outputDir),\n                \"-tags\", \"-verbose\", \"-version\",\n                \"-noStdlib\", \"-noJdkAnnotations\", \"-noJdk\"};\n    }","id":91930,"modified_method":"private static String[] commandLineArguments(File outputDir, File scriptFile) {\n        return new String[]{\n                \"-module\", scriptFile.getAbsolutePath(),\n                \"-output\", outputDir.getPath(),\n                \"-tags\", \"-verbose\", \"-version\",\n                \"-noStdlib\", \"-noJdkAnnotations\", \"-noJdk\"};\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void runInProcess(final CompileContext compileContext,\n            OutputItemsCollector collector,\n            final CompilerEnvironment environment,\n            final File scriptFile) {\n        CompilerUtils.outputCompilerMessagesAndHandleExitCode(compileContext, collector, new Function1<PrintStream, Integer>() {\n            @Override\n            public Integer invoke(PrintStream stream) {\n                return execInProcess(environment, scriptFile, stream, compileContext);\n            }\n        });\n    }","id":91931,"modified_method":"private static void runInProcess(final MessageCollector messageCollector,\n            OutputItemsCollector collector,\n            final CompilerEnvironment environment,\n            final File scriptFile) {\n        CompilerUtils.outputCompilerMessagesAndHandleExitCode(messageCollector, collector, new Function1<PrintStream, Integer>() {\n            @Override\n            public Integer invoke(PrintStream stream) {\n                return execInProcess(environment, scriptFile, stream, messageCollector);\n            }\n        });\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void runOutOfProcess(final CompileContext compileContext,\n            final OutputItemsCollector collector,\n            CompilerEnvironment environment,\n            File scriptFile) {\n        final SimpleJavaParameters params = new SimpleJavaParameters();\n        params.setJdk(new SimpleJavaSdkType().createJdk(\"tmp\", SystemProperties.getJavaHome()));\n        params.setMainClass(\"org.jetbrains.jet.cli.jvm.K2JVMCompiler\");\n\n        for (String arg : commandLineArguments(environment.getOutput(), scriptFile)) {\n            params.getProgramParametersList().add(arg);\n        }\n\n        for (File jar : CompilerUtils.kompilerClasspath(environment.getKotlinHome(), compileContext)) {\n            params.getClassPath().add(jar);\n        }\n\n        params.getVMParametersList().addParametersString(\"-Djava.awt.headless=true -Xmx512m\");\n        //        params.getVMParametersList().addParametersString(\"-agentlib:yjpagent=sampling\");\n\n        Sdk sdk = params.getJdk();\n\n        final GeneralCommandLine commandLine = JdkUtil.setupJVMCommandLine(\n                ((JavaSdkType)sdk.getSdkType()).getVMExecutablePath(sdk), params, false);\n\n        compileContext.addMessage(INFORMATION, \"Invoking out-of-process compiler with arguments: \" + commandLine, \"\", -1, -1);\n\n        try {\n            final Process process = commandLine.createProcess();\n\n            ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n                @Override\n                public void run() {\n                    CompilerUtils\n                            .parseCompilerMessagesFromReader(compileContext, new InputStreamReader(process.getInputStream()), collector);\n                }\n            });\n\n            ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        FileUtil.loadBytes(process.getErrorStream());\n                    }\n                    catch (IOException e) {\n                        // Don't care\n                    }\n                }\n            });\n\n            int exitCode = process.waitFor();\n            CompilerUtils.handleProcessTermination(exitCode, compileContext);\n        }\n        catch (Exception e) {\n            compileContext.addMessage(ERROR, \"[Internal Error] \" + e.getLocalizedMessage(), \"\", -1, -1);\n            return;\n        }\n    }","id":91932,"modified_method":"private static void runOutOfProcess(\n            final MessageCollector messageCollector,\n            final OutputItemsCollector itemCollector,\n            CompilerEnvironment environment,\n            File scriptFile\n    ) {\n        final SimpleJavaParameters params = new SimpleJavaParameters();\n        params.setJdk(new SimpleJavaSdkType().createJdk(\"tmp\", SystemProperties.getJavaHome()));\n        params.setMainClass(\"org.jetbrains.jet.cli.jvm.K2JVMCompiler\");\n\n        for (String arg : commandLineArguments(environment.getOutput(), scriptFile)) {\n            params.getProgramParametersList().add(arg);\n        }\n\n        for (File jar : CompilerUtils.kompilerClasspath(environment.getKotlinHome(), messageCollector)) {\n            params.getClassPath().add(jar);\n        }\n\n        params.getVMParametersList().addParametersString(\"-Djava.awt.headless=true -Xmx512m\");\n        //        params.getVMParametersList().addParametersString(\"-agentlib:yjpagent=sampling\");\n\n        Sdk sdk = params.getJdk();\n\n        final GeneralCommandLine commandLine = JdkUtil.setupJVMCommandLine(\n                ((JavaSdkType)sdk.getSdkType()).getVMExecutablePath(sdk), params, false);\n\n        messageCollector.report(CompilerMessageSeverity.INFO,\n                                \"Invoking out-of-process compiler with arguments: \" + commandLine,\n                                CompilerMessageLocation.NO_LOCATION);\n\n        try {\n            final Process process = commandLine.createProcess();\n\n            ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n                @Override\n                public void run() {\n                    CompilerUtils\n                            .parseCompilerMessagesFromReader(messageCollector, new InputStreamReader(process.getInputStream()), itemCollector);\n                }\n            });\n\n            ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        FileUtil.loadBytes(process.getErrorStream());\n                    }\n                    catch (IOException e) {\n                        // Don't care\n                    }\n                }\n            });\n\n            int exitCode = process.waitFor();\n            CompilerUtils.handleProcessTermination(exitCode, messageCollector);\n        }\n        catch (Exception e) {\n            messageCollector.report(CompilerMessageSeverity.ERROR,\n                                    \"[Internal Error] \" + e.getLocalizedMessage(),\n                                    CompilerMessageLocation.NO_LOCATION);\n            return;\n        }\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void doCompile(CompileContext compileContext,\n            Chunk<Module> moduleChunk,\n            List<VirtualFile> files,\n            Module module,\n            OutputSink outputSink,\n            boolean tests) {\n        if (files.isEmpty()) return;\n\n        CompilerEnvironment environment = CompilerEnvironment.getEnvironmentFor(compileContext, module, tests);\n        if (!environment.success()) {\n            environment.reportErrorsTo(compileContext);\n            return;\n        }\n\n        File scriptFile = tryToWriteScriptFile(compileContext, moduleChunk, files, module, tests,\n                                               compileContext.getModuleOutputDirectory(module),\n                                               environment.getOutput());\n\n        if (scriptFile == null) return;\n\n        CompilerUtils.OutputItemsCollectorImpl collector = new CompilerUtils.OutputItemsCollectorImpl(environment.getOutput().getPath());\n        runCompiler(compileContext, environment, scriptFile, collector);\n        outputSink.add(environment.getOutput().getPath(), collector.getOutputs(), collector.getSources().toArray(VirtualFile.EMPTY_ARRAY));\n    }","id":91933,"modified_method":"private void doCompile(\n            final CompileContext compileContext,\n            Chunk<Module> moduleChunk,\n            List<VirtualFile> files,\n            Module module,\n            OutputSink outputSink,\n            boolean tests) {\n        if (files.isEmpty()) return;\n\n        MessageCollector messageCollector = new MessageCollectorAdapter(compileContext);\n\n        CompilerEnvironment environment = CompilerUtils.getEnvironmentFor(compileContext, module, tests);\n        if (!environment.success()) {\n            environment.reportErrorsTo(messageCollector);\n            return;\n        }\n\n        File scriptFile = tryToWriteScriptFile(compileContext, moduleChunk, files, module, tests,\n                                               compileContext.getModuleOutputDirectory(module),\n                                               environment.getOutput());\n\n        if (scriptFile == null) return;\n\n        CompilerUtils.OutputItemsCollectorImpl collector = new CompilerUtils.OutputItemsCollectorImpl(environment.getOutput().getPath());\n        runCompiler(messageCollector, environment, scriptFile, collector);\n        outputSink.add(environment.getOutput().getPath(), collector.getOutputs(), collector.getSources().toArray(VirtualFile.EMPTY_ARRAY));\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static int execInProcess(CompilerEnvironment environment, File scriptFile, PrintStream out, CompileContext context) {\n        try {\n            String compilerClassName = \"org.jetbrains.jet.cli.jvm.K2JVMCompiler\";\n            String[] arguments = commandLineArguments(environment.getOutput(), scriptFile);\n            context.addMessage(INFORMATION, \"Using kotlinHome=\" + environment.getKotlinHome(), \"\", -1, -1);\n            context.addMessage(INFORMATION,\n                               \"Invoking in-process compiler \" + compilerClassName + \" with arguments \" + Arrays.asList(arguments), \"\", -1,\n                               -1);\n            Object rc = CompilerUtils.invokeExecMethod(environment, out, context, arguments, compilerClassName);\n            // exec() returns a K2JVMCompiler.ExitCode object, that class is not accessible here,\n            // so we take it's contents through reflection\n            return CompilerUtils.getReturnCodeFromObject(rc);\n        }\n        catch (Throwable e) {\n            CompilerUtils.LOG.error(e);\n            return -1;\n        }\n    }","id":91934,"modified_method":"private static int execInProcess(CompilerEnvironment environment, File scriptFile, PrintStream out, MessageCollector messageCollector) {\n        try {\n            String compilerClassName = \"org.jetbrains.jet.cli.jvm.K2JVMCompiler\";\n            String[] arguments = commandLineArguments(environment.getOutput(), scriptFile);\n            messageCollector.report(CompilerMessageSeverity.INFO,\n                                    \"Using kotlinHome=\" + environment.getKotlinHome(),\n                                    CompilerMessageLocation.NO_LOCATION);\n            messageCollector.report(CompilerMessageSeverity.INFO,\n                               \"Invoking in-process compiler \" + compilerClassName + \" with arguments \" + Arrays.asList(arguments),\n                               CompilerMessageLocation.NO_LOCATION);\n            Object rc = CompilerUtils.invokeExecMethod(environment, out, messageCollector, arguments, compilerClassName);\n            // exec() returns a K2JVMCompiler.ExitCode object, that class is not accessible here,\n            // so we take it's contents through reflection\n            return CompilerUtils.getReturnCodeFromObject(rc);\n        }\n        catch (Throwable e) {\n            CompilerUtils.LOG.error(e);\n            return -1;\n        }\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void compile(final CompileContext context, Chunk<Module> moduleChunk, final VirtualFile[] files, OutputSink sink) {\n        if (files.length == 0) {\n            return;\n        }\n\n        Module module = getModule(context, moduleChunk);\n        if (module == null) {\n            return;\n        }\n\n        CompilerEnvironment environment = CompilerEnvironment.getEnvironmentFor(context, module, /*tests = */ false);\n        if (!environment.success()) {\n            environment.reportErrorsTo(context);\n            return;\n        }\n\n        doCompile(context, sink, module, environment);\n    }","id":91935,"modified_method":"@Override\n    public void compile(final CompileContext context, Chunk<Module> moduleChunk, final VirtualFile[] files, OutputSink sink) {\n        if (files.length == 0) {\n            return;\n        }\n\n        Module module = getModule(context, moduleChunk);\n        if (module == null) {\n            return;\n        }\n\n        MessageCollector messageCollector = new MessageCollectorAdapter(context);\n\n        CompilerEnvironment environment = CompilerUtils.getEnvironmentFor(context, module, /*tests = */ false);\n        if (!environment.success()) {\n            environment.reportErrorsTo(messageCollector);\n            return;\n        }\n\n        doCompile(messageCollector, sink, module, environment);\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private static Integer doExec(@NotNull CompileContext context, @NotNull CompilerEnvironment environment, @NotNull PrintStream out,\n            @NotNull Module module) throws Exception {\n        VirtualFile outDir = context.getModuleOutputDirectory(module);\n        String outFile = outDir == null ? null : outDir.getPath() + \"/\" + module.getName() + \".js\";\n        String[] commandLineArgs = constructArguments(module, outFile);\n        Object rc = invokeExecMethod(environment, out, context, commandLineArgs, \"org.jetbrains.jet.cli.js.K2JSCompiler\");\n\n        if (outDir != null && !ApplicationManager.getApplication().isUnitTestMode()) {\n            outDir.refresh(false, true);\n        }\n        return CompilerUtils.getReturnCodeFromObject(rc);\n    }","id":91936,"modified_method":"@NotNull\n    private static Integer doExec(@NotNull MessageCollector messageCollector, @NotNull CompilerEnvironment environment, @NotNull PrintStream out,\n            @NotNull Module module) throws Exception {\n        File outDir = environment.getOutput();\n        String outFile = outDir.getPath() + \"/\" + module.getName() + \".js\";\n        String[] commandLineArgs = constructArguments(module, outFile);\n        Object rc = invokeExecMethod(environment, out, messageCollector, commandLineArgs, \"org.jetbrains.jet.cli.js.K2JSCompiler\");\n\n        if (!ApplicationManager.getApplication().isUnitTestMode()) {\n            VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByIoFile(outDir);\n            assert virtualFile != null : \"Virtual file not found for module output: \" + outDir;\n            virtualFile.refresh(false, true);\n        }\n        return CompilerUtils.getReturnCodeFromObject(rc);\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void doCompile(@NotNull final CompileContext context, @NotNull OutputSink sink, @NotNull final Module module,\n            @NotNull final CompilerEnvironment environment) {\n        CompilerUtils.OutputItemsCollectorImpl collector = new CompilerUtils.OutputItemsCollectorImpl(environment.getOutput().getPath());\n        outputCompilerMessagesAndHandleExitCode(context, collector, new Function1<PrintStream, Integer>() {\n            @Override\n            public Integer invoke(PrintStream stream) {\n                return execInProcess(context, environment, stream, module);\n            }\n        });\n        sink.add(environment.getOutput().getPath(), collector.getOutputs(), collector.getSources().toArray(VirtualFile.EMPTY_ARRAY));\n    }","id":91937,"modified_method":"private static void doCompile(@NotNull final MessageCollector messageCollector, @NotNull OutputSink sink, @NotNull final Module module,\n            @NotNull final CompilerEnvironment environment) {\n        CompilerUtils.OutputItemsCollectorImpl collector = new CompilerUtils.OutputItemsCollectorImpl(environment.getOutput().getPath());\n        outputCompilerMessagesAndHandleExitCode(messageCollector, collector, new Function1<PrintStream, Integer>() {\n            @Override\n            public Integer invoke(PrintStream stream) {\n                return execInProcess(messageCollector, environment, stream, module);\n            }\n        });\n        sink.add(environment.getOutput().getPath(), collector.getOutputs(), collector.getSources().toArray(VirtualFile.EMPTY_ARRAY));\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private static Integer execInProcess(@NotNull CompileContext context,\n            @NotNull CompilerEnvironment environment, @NotNull PrintStream out, @NotNull Module module) {\n        try {\n            return doExec(context, environment, out, module);\n        }\n        catch (Throwable e) {\n            context.addMessage(CompilerMessageCategory.ERROR, \"Exception while executing compiler:\\n\" + e.getMessage(), null, -1, -1);\n        }\n        return -1;\n    }","id":91938,"modified_method":"@NotNull\n    private static Integer execInProcess(@NotNull MessageCollector messageCollector,\n            @NotNull CompilerEnvironment environment, @NotNull PrintStream out, @NotNull Module module) {\n        try {\n            return doExec(messageCollector, environment, out, module);\n        }\n        catch (Throwable e) {\n            messageCollector.report(CompilerMessageSeverity.ERROR,\n                                    \"Exception while executing compiler:\\n\" + e.getMessage(),\n                                    CompilerMessageLocation.NO_LOCATION);\n        }\n        return -1;\n    }","commit_id":"4926dd7189791d57dc00e1faeb2a4ebd86acddcf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public ModuleManagerComponent(Project project, ProgressManager progressManager, MessageBus bus) {\r\n    super(project, bus);\r\n    myConnection = bus.connect(project);\r\n    myProgressManager = progressManager;\r\n    myConnection.setDefaultHandler(new MessageHandler() {\r\n      @Override\r\n      public void handle(Method event, Object... params) {\r\n        cleanCachedStuff();\r\n      }\r\n    });\r\n\r\n    myConnection.subscribe(ProjectTopics.PROJECT_ROOTS);\r\n    myConnection.subscribe(ProjectLifecycleListener.TOPIC, new ProjectLifecycleListener.Adapter() {\r\n      @Override\r\n      public void projectComponentsInitialized(final Project project) {\r\n        long start = System.currentTimeMillis();\r\n        loadModules(myModuleModel);\r\n        LOG.info(myModuleModel.getModules().length + \" modules loaded in \" + (System.currentTimeMillis() - start) + \" ms\");\r\n      }\r\n    });\r\n\r\n  }","id":91939,"modified_method":"public ModuleManagerComponent(Project project, ProgressManager progressManager, MessageBus bus) {\n    super(project, bus);\n    myConnection = bus.connect(project);\n    myProgressManager = progressManager;\n    myConnection.setDefaultHandler(new MessageHandler() {\n      @Override\n      public void handle(Method event, Object... params) {\n        cleanCachedStuff();\n      }\n    });\n\n    myConnection.subscribe(ProjectTopics.PROJECT_ROOTS);\n    myConnection.subscribe(ProjectLifecycleListener.TOPIC, new ProjectLifecycleListener.Adapter() {\n      @Override\n      public void projectComponentsInitialized(final Project project) {\n        long t = System.currentTimeMillis();\n        loadModules(myModuleModel);\n        t = System.currentTimeMillis() - t;\n        LOG.info(myModuleModel.getModules().length + \" module(s) loaded in \" + t + \" ms\");\n      }\n    });\n\n  }","commit_id":"8b9ceef6ba99e2acc0bcab03e8ad4284fa6ba727","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String resolveShortWindowsName(String filePath) {\r\n      try {\r\n        filePath = FileUtil.resolveShortWindowsName(filePath);\r\n      }\r\n      catch (IOException ignored) {\r\n      }\r\n      return filePath;\r\n    }","id":91940,"modified_method":"private String resolveShortWindowsName(String filePath) {\n      try {\n        return FileUtil.resolveShortWindowsName(filePath);\n      }\n      catch (IOException ignored) {\n        return filePath;\n      }\n    }","commit_id":"8b9ceef6ba99e2acc0bcab03e8ad4284fa6ba727","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Module loadModuleInternal(String filePath, @Nullable ProgressIndicator progressIndicator) throws ModuleWithNameAlreadyExists,\r\n                                                              IOException, StateStorageException {\r\n\r\n      final VirtualFile moduleFile = StandardFileSystems.local().findFileByPath(filePath);\r\n      if (moduleFile == null) {\r\n        throw new IOException(ProjectBundle.message(\"module.file.does.not.exist.error\", filePath));\r\n      }\r\n\r\n      filePath = resolveShortWindowsName(filePath);\r\n      final String name = moduleFile.getName();\r\n      if (progressIndicator != null) {\r\n        progressIndicator.setText2(FileUtil.getNameWithoutExtension(name));\r\n      }\r\n\r\n      if (name.endsWith(IML_EXTENSION)) {\r\n        final String moduleName = name.substring(0, name.length() - 4);\r\n        for (Module module : myPathToModule.values()) {\r\n          if (module.getName().equals(moduleName)) {\r\n            throw new ModuleWithNameAlreadyExists(ProjectBundle.message(\"module.already.exists.error\", moduleName), moduleName);\r\n          }\r\n        }\r\n      }\r\n      if (!moduleFile.exists()) {\r\n        throw new IOException(ProjectBundle.message(\"module.file.does.not.exist.error\", moduleFile.getPath()));\r\n      }\r\n      ModuleEx module = getModuleByFilePath(filePath);\r\n      if (module == null) {\r\n        final VirtualFile moduleVFile = StandardFileSystems.local().refreshAndFindFileByPath(FileUtil.toSystemIndependentName(filePath));\r\n        if (moduleVFile != null) {\r\n          moduleVFile.refresh(false, false);\r\n        }\r\n        module = createAndLoadModule(filePath);\r\n        module.loadModuleComponents();\r\n        initModule(module);\r\n      }\r\n      return module;\r\n    }","id":91941,"modified_method":"private Module loadModuleInternal(String filePath, @Nullable ProgressIndicator progressIndicator)\n      throws ModuleWithNameAlreadyExists, IOException, StateStorageException {\n\n      final VirtualFile moduleFile = StandardFileSystems.local().findFileByPath(resolveShortWindowsName(filePath));\n      if (moduleFile == null || !moduleFile.exists()) {\n        throw new IOException(ProjectBundle.message(\"module.file.does.not.exist.error\", filePath));\n      }\n\n      final String name = moduleFile.getName();\n      if (progressIndicator != null) {\n        progressIndicator.setText2(FileUtil.getNameWithoutExtension(name));\n      }\n\n      if (name.endsWith(IML_EXTENSION)) {\n        final String moduleName = name.substring(0, name.length() - 4);\n        for (Module module : myPathToModule.values()) {\n          if (module.getName().equals(moduleName)) {\n            throw new ModuleWithNameAlreadyExists(ProjectBundle.message(\"module.already.exists.error\", moduleName), moduleName);\n          }\n        }\n      }\n\n      ModuleEx module = getModuleByFilePath(moduleFile.getPath());\n      if (module == null) {\n        moduleFile.refresh(false, false);\n        module = createAndLoadModule(moduleFile.getPath());\n        module.loadModuleComponents();\n        initModule(module);\n      }\n      return module;\n    }","commit_id":"8b9ceef6ba99e2acc0bcab03e8ad4284fa6ba727","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\r\n    private ModuleEx getModuleByFilePath(String filePath) {\r\n      final Collection<Module> modules = myPathToModule.values();\r\n      for (Module module : modules) {\r\n        if (filePath.equals(module.getModuleFilePath())) {\r\n          return (ModuleEx)module;\r\n        }\r\n      }\r\n      return null;\r\n    }","id":91942,"modified_method":"@Nullable\n    private ModuleEx getModuleByFilePath(String filePath) {\n      final Collection<Module> modules = myPathToModule.values();\n      for (Module module : modules) {\n        if (FileUtil.pathsEqual(filePath, module.getModuleFilePath())) {\n          return (ModuleEx)module;\n        }\n      }\n      return null;\n    }","commit_id":"8b9ceef6ba99e2acc0bcab03e8ad4284fa6ba727","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public synchronized void paint(Graphics g2d, JComponent c) {\n    Graphics2D g = (Graphics2D)g2d;\n    AbstractButton b = (AbstractButton) c;\n    ButtonModel model = b.getModel();\n\n    Dimension size = c.getSize();\n    Font f = c.getFont();\n    g.setFont(f);\n    FontMetrics fm = SwingUtilities2.getFontMetrics(c, g, f);\n\n    Rectangle viewRect = new Rectangle(size);\n    Rectangle iconRect = new Rectangle();\n    Rectangle textRect = new Rectangle();\n\n    Insets i = c.getInsets();\n    viewRect.x += i.left;\n    viewRect.y += i.top;\n    viewRect.width -= (i.right + viewRect.x);\n    viewRect.height -= (i.bottom + viewRect.y);\n\n\n    String text = SwingUtilities.layoutCompoundLabel(\n      c, fm, b.getText(), getDefaultIcon(),\n      b.getVerticalAlignment(), b.getHorizontalAlignment(),\n      b.getVerticalTextPosition(), b.getHorizontalTextPosition(),\n      viewRect, iconRect, textRect, b.getIconTextGap());\n\n    // fill background\n    if(c.isOpaque()) {\n      g.setColor(b.getBackground());\n      g.fillRect(0,0, size.width, size.height);\n    }\n\n\n    // Paint the radio button\n    final int x = iconRect.x + 2;\n    final int y = iconRect.y + 2;\n    final int w = iconRect.width - 4;\n    final int h = iconRect.height - 4;\n\n    g.translate(x, y);\n\n    //setup AA for lines\n    final GraphicsConfig config = GraphicsUtil.setupAAPainting(g);\n    g.setPaint(\n      UIUtil.getGradientPaint(0, 0, ColorUtil.shift(c.getBackground(), 1.5), 0, c.getHeight(), ColorUtil.shift(c.getBackground(), 1.2)));\n    g.fillOval(0, 1, w - 1, h - 1);\n\n    if (b.hasFocus()) {\n      int sysOffX = SystemInfo.isMac ? 0 : 1;\n      int sysOffY = SystemInfo.isMac ? 0 : -1;\n      DarculaUIUtil.paintFocusOval(g, x-6  + sysOffX, y-3 + sysOffY, w-2, h-2);\n    } else {\n      g.setPaint(UIUtil.getGradientPaint(w / 2, 1, Gray._160.withAlpha(90), w / 2, h, Gray._100.withAlpha(90)));\n      g.drawOval(0, 2, w - 1, h - 1);\n\n      g.setPaint(Gray._40.withAlpha(200));\n      g.drawOval(0, 1, w - 1, h - 1);\n    }\n\n    if (b.isSelected()) {\n      g.setColor(b.isEnabled() ? Gray._30 : Gray._60);\n      g.fillOval(w/2 - 3, h/2 - 1, 5, 5);\n      g.setColor(b.isEnabled() ? Gray._170 : Gray._120);\n      g.fillOval(w/2 - 3, h/2 - 2, 5, 5);\n    }\n    config.restore();\n    g.translate(-x, -y);\n\n    // Draw the Text\n    if(text != null) {\n      View v = (View) c.getClientProperty(BasicHTML.propertyKey);\n      if (v != null) {\n        v.paint(g, textRect);\n      } else {\n        int mnemIndex = b.getDisplayedMnemonicIndex();\n        if(model.isEnabled()) {\n          // *** paint the text normally\n          g.setColor(b.getForeground());\n        } else {\n          // *** paint the text disabled\n          g.setColor(getDisabledTextColor());\n        }\n        SwingUtilities2.drawStringUnderlineCharAt(c, g, text,\n                                                  mnemIndex, textRect.x, textRect.y + fm.getAscent());\n      }\n    }\n  }","id":91943,"modified_method":"@Override\n  public synchronized void paint(Graphics g2d, JComponent c) {\n    Graphics2D g = (Graphics2D)g2d;\n    AbstractButton b = (AbstractButton) c;\n    ButtonModel model = b.getModel();\n\n    Dimension size = c.getSize();\n    Font f = c.getFont();\n    g.setFont(f);\n    FontMetrics fm = SwingUtilities2.getFontMetrics(c, g, f);\n\n    Rectangle viewRect = new Rectangle(size);\n    Rectangle iconRect = new Rectangle();\n    Rectangle textRect = new Rectangle();\n\n    Insets i = c.getInsets();\n    viewRect.x += i.left;\n    viewRect.y += i.top;\n    viewRect.width -= (i.right + viewRect.x);\n    viewRect.height -= (i.bottom + viewRect.y);\n\n\n    String text = SwingUtilities.layoutCompoundLabel(\n      c, fm, b.getText(), getDefaultIcon(),\n      b.getVerticalAlignment(), b.getHorizontalAlignment(),\n      b.getVerticalTextPosition(), b.getHorizontalTextPosition(),\n      viewRect, iconRect, textRect, b.getIconTextGap());\n\n    // fill background\n    if(c.isOpaque()) {\n      g.setColor(b.getBackground());\n      g.fillRect(0,0, size.width, size.height);\n    }\n\n    int rad = 5;\n\n    // Paint the radio button\n    final int x = iconRect.x + (rad-1)/2;\n    final int y = iconRect.y + (rad-1)/2;\n    final int w = iconRect.width - (rad + 5) / 2;\n    final int h = iconRect.height - (rad + 5) / 2;\n\n    g.translate(x, y);\n\n    //setup AA for lines\n    final GraphicsConfig config = GraphicsUtil.setupAAPainting(g);\n    g.setPaint(\n      UIUtil.getGradientPaint(0, 0, ColorUtil.shift(c.getBackground(), 1.5), 0, c.getHeight(), ColorUtil.shift(c.getBackground(), 1.2)));\n    g.fillOval(0, 1, w - 1, h - 1);\n\n    if (b.hasFocus()) {\n      int sysOffX = SystemInfo.isMac ? 0 : 1;\n      int sysOffY = SystemInfo.isMac ? 0 : -1;\n      DarculaUIUtil.paintFocusOval(g, x-rad - 1  + sysOffX, y- (rad + 1)/2 + sysOffY, w-2, h-2);\n    } else {\n      g.setPaint(UIUtil.getGradientPaint(w / 2, 1, Gray._160.withAlpha(90), w / 2, h, Gray._100.withAlpha(90)));\n      g.drawOval(0, 2, w - 1, h - 1);\n\n      g.setPaint(Gray._40.withAlpha(200));\n      g.drawOval(0, 1, w - 1, h - 1);\n    }\n\n    if (b.isSelected()) {\n      final boolean enabled = b.isEnabled();\n      g.setColor(UIManager.getColor(enabled ? \"RadioButton.darcula.selectionEnabledShadowColor\" : \"RadioButton.darcula.selectionDisabledShadowColor\"));// ? Gray._30 : Gray._60);\n      g.fillOval(w/2 - rad/2, h/2 , rad, rad);\n      g.setColor(UIManager.getColor(enabled ? \"RadioButton.darcula.selectionEnabledColor\" : \"RadioButton.darcula.selectionDisabledColor\")); //Gray._170 : Gray._120);\n      g.fillOval(w/2 - rad/2, h/2 - 1, rad, rad);\n    }\n    config.restore();\n    g.translate(-x, -y);\n\n    // Draw the Text\n    if(text != null) {\n      View v = (View) c.getClientProperty(BasicHTML.propertyKey);\n      if (v != null) {\n        v.paint(g, textRect);\n      } else {\n        int mnemIndex = b.getDisplayedMnemonicIndex();\n        if(model.isEnabled()) {\n          // *** paint the text normally\n          g.setColor(b.getForeground());\n        } else {\n          // *** paint the text disabled\n          g.setColor(getDisabledTextColor());\n        }\n        SwingUtilities2.drawStringUnderlineCharAt(c, g, text,\n                                                  mnemIndex, textRect.x, textRect.y + fm.getAscent());\n      }\n    }\n  }","commit_id":"ddb84d5f179b78e5832a0e4dc55dd93da982f278","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n   * Called if the user changes the item level displayed in the plot. If a new\r\n   * item was selected the plot data is recalculated.\r\n   * @param newItem item selected by the user\r\n   * @return true if a new item was selected and the plot data has been \r\n   * recalculated\r\n   */\r\n  boolean setItem(final String newItem) {\r\n    if(newItem == null) return false;\r\n    final byte[] b = Token.token(newItem);\r\n    if(Token.eq(b, item)) return false;\r\n    item = b;\r\n    refreshCoordinates();\r\n    return true;\r\n  }","id":91944,"modified_method":"/**\r\n   * Called if the user changes the item level displayed in the plot. If a new\r\n   * item was selected the plot data is recalculated.\r\n   * @param newItem item selected by the user\r\n   * @return true if a new item was selected and the plot data has been \r\n   * recalculated\r\n   */\r\n  boolean setItem(final String newItem) {\r\n    if(newItem == null) return false;\r\n    final byte[] b = Token.token(newItem);\r\n    if(Token.eq(b, item)) return false;\r\n    item = b;\r\n    refreshItems();\r\n    xAxis.refreshAxis();\r\n    yAxis.refreshAxis();\r\n    return true;\r\n  }","commit_id":"cf0fec6be29b70e5fddd6dcf50464f6b9b42b21b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Default Constructor.\r\n   */\r\n  public ScatterData() {\r\n    size = 0;\r\n    attrX = Token.token(\"\");\r\n    attrY = Token.token(\"\");\r\n    item = Token.token(\"\");\r\n  }","id":91945,"modified_method":"/**\r\n   * Default Constructor.\r\n   */\r\n  public ScatterData() {\r\n    xAxis = new ScatterAxis(this);\r\n    yAxis = new ScatterAxis(this);\r\n    size = 0;\r\n    item = Token.token(\"\");\r\n  }","commit_id":"cf0fec6be29b70e5fddd6dcf50464f6b9b42b21b","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  protected void refreshInit() {\r\n    final Data data = GUI.context.data();\r\n    if(data != null) {\r\n      if(!GUIProp.showscatter) return;\r\n      \r\n      viewDimension = Integer.MAX_VALUE;\r\n      scatterData = new ScatterData();\r\n      final String[] keys = scatterData.getStatKeys();\r\n      xCombo.setModel(new DefaultComboBoxModel(keys));\r\n      yCombo.setModel(new DefaultComboBoxModel(keys));\r\n      xCombo.setSelectedIndex(-1);\r\n      yCombo.setSelectedIndex(-1);\r\n      final byte[][] tmpItems = data.tags.keys();\r\n      final String[] items = new String[tmpItems.length];\r\n      for(int i = 0; i < items.length; i++) {\r\n        items[i] = Token.string(tmpItems[i]);\r\n      }\r\n      itemCombo.setModel(new DefaultComboBoxModel(items));\r\n      itemCombo.setSelectedIndex(-1);\r\n      plotChanged = true;\r\n      repaint();\r\n    }\r\n  }","id":91946,"modified_method":"@Override\r\n  protected void refreshInit() {\r\n    final Data data = GUI.context.data();\r\n    if(data != null) {\r\n      if(!GUIProp.showscatter) return;\r\n      \r\n      viewDimension = Integer.MAX_VALUE;\r\n      scatterData = new ScatterData();\r\n      final String[] keys = scatterData.getStatKeys();\r\n      xCombo.setModel(new DefaultComboBoxModel(keys));\r\n      yCombo.setModel(new DefaultComboBoxModel(keys));\r\n      final byte[][] tmpItems = data.tags.keys();\r\n      final String[] items = new String[tmpItems.length];\r\n      for(int i = 0; i < items.length; i++) {\r\n        items[i] = Token.string(tmpItems[i]);\r\n      }\r\n      itemCombo.setModel(new DefaultComboBoxModel(items));\r\n      itemCombo.setSelectedIndex(0);\r\n      xCombo.setSelectedIndex(0);\r\n      yCombo.setSelectedIndex(0);\r\n      plotChanged = true;\r\n      repaint();\r\n    }\r\n  }","commit_id":"cf0fec6be29b70e5fddd6dcf50464f6b9b42b21b","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void paintComponent(final Graphics g) {\r\n    super.paintComponent(g);\r\n    final int w = getWidth();\r\n    final int h = getHeight();\r\n    if(w + h != viewDimension) {\r\n      viewDimension = w + h;\r\n      plotChanged = true;\r\n    }\r\n    drawBox(g);\r\n    if(scatterData.size == 0) return;\r\n    if(plotImg == null || plotChanged)\r\n      plotImg = createPlotImage();\r\n    g.drawImage(plotImg, 0, 0, this);\r\n\r\n    if(focusedItem != -1)\r\n    drawItem(g, scatterData.x[focusedItem], scatterData.y[focusedItem], true);\r\n    plotChanged = false;\r\n  }","id":91947,"modified_method":"@Override\r\n  public void paintComponent(final Graphics g) {\r\n    super.paintComponent(g);\r\n    final int w = getWidth();\r\n    final int h = getHeight();\r\n    if(w + h != viewDimension) {\r\n      viewDimension = w + h;\r\n      plotChanged = true;\r\n    }\r\n    drawBox(g);\r\n    if(scatterData.size == 0) return;\r\n    if(plotImg == null || plotChanged)\r\n      plotImg = createPlotImage();\r\n    g.drawImage(plotImg, 0, 0, this);\r\n\r\n    if(focusedItem != -1)\r\n    drawItem(g, scatterData.xAxis.co[focusedItem], \r\n        scatterData.yAxis.co[focusedItem], true);\r\n    plotChanged = false;\r\n  }","commit_id":"cf0fec6be29b70e5fddd6dcf50464f6b9b42b21b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Default Constructor.\r\n   * @param hlp help text\r\n   */\r\n  public ScatterView(final byte[] hlp) {\r\n    super(hlp);\r\n    setLayout(new BorderLayout());\r\n    setBorder(5, 5, 5, 5);\r\n    final Box box = new Box(BoxLayout.X_AXIS);\r\n    xCombo = new BaseXCombo();\r\n    xCombo.addActionListener(new ActionListener() {\r\n      public void actionPerformed(final ActionEvent e) {\r\n        if(scatterData.setXaxis((String) xCombo.getSelectedItem())) {\r\n          plotChanged = true;\r\n          repaint();\r\n        }\r\n      }\r\n    });\r\n    yCombo = new BaseXCombo();\r\n    yCombo.addActionListener(new ActionListener() {\r\n      public void actionPerformed(final ActionEvent e) {\r\n        if(scatterData.setYaxis((String) yCombo.getSelectedItem())) {\r\n          plotChanged = true;\r\n          repaint();\r\n        }\r\n      }\r\n    });\r\n    itemCombo = new BaseXCombo();\r\n    itemCombo.addActionListener(new ActionListener() {\r\n      public void actionPerformed(final ActionEvent e) {\r\n        if(scatterData.setItem((String) itemCombo.getSelectedItem()))\r\n          plotChanged = true;\r\n          repaint();\r\n      }\r\n    });\r\n    box.add(new JLabel(\"X\"));\r\n    box.add(Box.createHorizontalStrut(3));\r\n    box.add(xCombo);\r\n    box.add(Box.createHorizontalStrut(10));\r\n    box.add(new JLabel(\"Y\"));\r\n    box.add(Box.createHorizontalStrut(3));\r\n    box.add(yCombo);\r\n    box.add(Box.createHorizontalStrut(10));\r\n    box.add(new JLabel(\"Item\"));\r\n    box.add(Box.createHorizontalStrut(3));\r\n    box.add(itemCombo);\r\n    box.add(Box.createHorizontalGlue());\r\n    add(box, BorderLayout.NORTH);\r\n    \r\n    itemImg = createItemImage(false);\r\n    itemFocusedImg = createItemImage(true);\r\n  }","id":91948,"modified_method":"/**\r\n   * Default Constructor.\r\n   * @param hlp help text\r\n   */\r\n  public ScatterView(final byte[] hlp) {\r\n    super(hlp);\r\n    setLayout(new BorderLayout());\r\n    setBorder(5, 5, 5, 5);\r\n    final Box box = new Box(BoxLayout.X_AXIS);\r\n    xCombo = new BaseXCombo();\r\n    xCombo.addActionListener(new ActionListener() {\r\n      public void actionPerformed(final ActionEvent e) {\r\n        if(scatterData.xAxis.setAxis((String) xCombo.getSelectedItem())) {\r\n          plotChanged = true;\r\n          repaint();\r\n        }\r\n      }\r\n    });\r\n    yCombo = new BaseXCombo();\r\n    yCombo.addActionListener(new ActionListener() {\r\n      public void actionPerformed(final ActionEvent e) {\r\n        if(scatterData.yAxis.setAxis((String) yCombo.getSelectedItem())) {\r\n          plotChanged = true;\r\n          repaint();\r\n        }\r\n      }\r\n    });\r\n    itemCombo = new BaseXCombo();\r\n    itemCombo.addActionListener(new ActionListener() {\r\n      public void actionPerformed(final ActionEvent e) {\r\n        if(scatterData.setItem((String) itemCombo.getSelectedItem()))\r\n          plotChanged = true;\r\n          repaint();\r\n      }\r\n    });\r\n    box.add(new JLabel(\"X\"));\r\n    box.add(Box.createHorizontalStrut(3));\r\n    box.add(xCombo);\r\n    box.add(Box.createHorizontalStrut(10));\r\n    box.add(new JLabel(\"Y\"));\r\n    box.add(Box.createHorizontalStrut(3));\r\n    box.add(yCombo);\r\n    box.add(Box.createHorizontalStrut(10));\r\n    box.add(new JLabel(\"Item\"));\r\n    box.add(Box.createHorizontalStrut(3));\r\n    box.add(itemCombo);\r\n    box.add(Box.createHorizontalGlue());\r\n    add(box, BorderLayout.NORTH);\r\n    \r\n    itemImg = createItemImage(false);\r\n    itemFocusedImg = createItemImage(true);\r\n  }","commit_id":"cf0fec6be29b70e5fddd6dcf50464f6b9b42b21b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Draws a box for the plot. Temporary, will be replaced by a grid.\r\n   * @param g graphics reference\r\n   */\r\n  private void drawBox(final Graphics g) {\r\n    final int width = getWidth();\r\n    final int height = getHeight();\r\n    g.setColor(GUIConstants.color1);\r\n    g.drawLine(XMARGIN, height - YMARGIN, width - XMARGIN, height - YMARGIN);\r\n    g.drawLine(XMARGIN, YMARGIN, XMARGIN, height - YMARGIN);\r\n    g.drawLine(XMARGIN, YMARGIN, width - XMARGIN, YMARGIN);\r\n    g.drawLine(width - XMARGIN, YMARGIN, width - XMARGIN, height - YMARGIN);\r\n    g.drawLine(width / 2, YMARGIN, width / 2, height - YMARGIN);\r\n    g.drawLine(XMARGIN, height / 2, width - XMARGIN, height / 2);\r\n  }","id":91949,"modified_method":"/**\r\n   * Draws a box for the plot. Temporary, will be replaced by a grid.\r\n   * @param g graphics reference\r\n   */\r\n  private void drawBox(final Graphics g) {\r\n    final int width = getWidth();\r\n    final int height = getHeight();\r\n    g.setColor(GUIConstants.color6);\r\n    g.drawLine(XMARGIN, height - YMARGIN, width - XMARGIN, height - YMARGIN);\r\n    g.drawLine(XMARGIN, YMARGIN, XMARGIN, height - YMARGIN);\r\n    g.drawLine(XMARGIN, YMARGIN, width - XMARGIN, YMARGIN);\r\n    g.drawLine(width - XMARGIN, YMARGIN, width - XMARGIN, height - YMARGIN);\r\n    g.drawLine(width / 2, YMARGIN, width / 2, height - YMARGIN);\r\n    g.drawLine(XMARGIN, height / 2, width - XMARGIN, height / 2);\r\n  }","commit_id":"cf0fec6be29b70e5fddd6dcf50464f6b9b42b21b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Creates a buffered image for items.\r\n   * @param focusedImage create image of focused item if true\r\n   * @return item image\r\n   */\r\n  private BufferedImage createItemImage(final boolean focusedImage) {\r\n    final BufferedImage img = focusedImage ? new BufferedImage(\r\n        18, 18, Transparency.TRANSLUCENT) : new BufferedImage(\r\n            10, 10, Transparency.TRANSLUCENT);\r\n    final Graphics g = img.getGraphics();\r\n    Graphics2D g2d = (Graphics2D) g;\r\n    g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, \r\n        RenderingHints.VALUE_ANTIALIAS_ON);\r\n    if(focusedImage) {\r\n      g.setColor(GUIConstants.colormark1);\r\n      g.fillOval(0, 0, 18, 18);\r\n      g.setColor(GUIConstants.color6);\r\n      g.fillOval(3, 3, 12, 12);\r\n    } else {\r\n//      g.setColor(GUIConstants.color6);\r\n      g.setColor(new Color(50, 60, 130, 150));\r\n      g.fillOval(0, 0, 10, 10);\r\n    }\r\n    return img;\r\n  }","id":91950,"modified_method":"/**\r\n   * Creates a buffered image for items.\r\n   * @param focusedImage create image of focused item if true\r\n   * @return item image\r\n   */\r\n  private BufferedImage createItemImage(final boolean focusedImage) {\r\n    final BufferedImage img = focusedImage ? new BufferedImage(\r\n        18, 18, Transparency.TRANSLUCENT) : new BufferedImage(\r\n            10, 10, Transparency.TRANSLUCENT);\r\n    final Graphics g = img.getGraphics();\r\n    Graphics2D g2d = (Graphics2D) g;\r\n    g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, \r\n        RenderingHints.VALUE_ANTIALIAS_ON);\r\n    if(focusedImage) {\r\n      g.setColor(Color.black);\r\n      g.fillOval(4, 4, 10, 10);\r\n      g.setColor(new Color(180, 80, 80, 200));\r\n      g.fillOval(0, 0, 18, 18);\r\n    } else {\r\n//      g.setColor(GUIConstants.color6);\r\n      g.setColor(new Color(50, 60, 130, 150));\r\n      g.fillOval(0, 0, 10, 10);\r\n    }\r\n    return img;\r\n  }","commit_id":"cf0fec6be29b70e5fddd6dcf50464f6b9b42b21b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Locates the nearest item to the mouse pointer. \r\n   * @return item focused\r\n   */\r\n  private boolean focus() {\r\n    int dist = Integer.MAX_VALUE;\r\n    int currFocusedItem = -1;\r\n    for(int i = 0; i < scatterData.size; i++) {\r\n      final int x = calcCoordinate(true, scatterData.x[i]);\r\n      final int y = calcCoordinate(false, scatterData.y[i]);\r\n      // item middle is reference for distance calculation instead of upper\r\n      // left corner -> +5\r\n      final int distX = Math.abs(mouseX - x - 5);\r\n      final int distY = Math.abs(mouseY - y - 5);\r\n      if(distX <= FOCUSOFFSET && distY <= FOCUSOFFSET) {\r\n        final int currDist = distX * distY;\r\n        if(currDist < dist) {\r\n          dist = currDist;\r\n          currFocusedItem = i;\r\n        }\r\n      }\r\n    }\r\n    if(focusedItem != currFocusedItem) {\r\n      focusedItem = currFocusedItem;\r\n      if(focusedItem != -1)\r\n        notifyFocus(scatterData.pres[focusedItem], this);\r\n      return true;\r\n    }\r\n    return false;\r\n  }","id":91951,"modified_method":"/**\r\n   * Locates the nearest item to the mouse pointer. \r\n   * @return item focused\r\n   */\r\n  private boolean focus() {\r\n    int dist = Integer.MAX_VALUE;\r\n    int currFocusedItem = -1;\r\n    for(int i = 0; i < scatterData.size; i++) {\r\n      final int x = calcCoordinate(true, scatterData.xAxis.co[i]);\r\n      final int y = calcCoordinate(false, scatterData.yAxis.co[i]);\r\n      // item middle is reference for distance calculation instead of upper\r\n      // left corner -> +5\r\n      final int distX = Math.abs(mouseX - x - 5);\r\n      final int distY = Math.abs(mouseY - y - 5);\r\n      if(distX <= FOCUSOFFSET && distY <= FOCUSOFFSET) {\r\n        final int currDist = distX * distY;\r\n        if(currDist < dist) {\r\n          dist = currDist;\r\n          currFocusedItem = i;\r\n        }\r\n      }\r\n    }\r\n    if(focusedItem != currFocusedItem) {\r\n      focusedItem = currFocusedItem;\r\n      if(focusedItem != -1)\r\n        notifyFocus(scatterData.pres[focusedItem], this);\r\n      return true;\r\n    }\r\n    return false;\r\n  }","commit_id":"cf0fec6be29b70e5fddd6dcf50464f6b9b42b21b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Precalculates the plot and returns the result as buffered image.\r\n   * @return buffered plot image\r\n   */\r\n  private BufferedImage createPlotImage() {\r\n    final BufferedImage img = new BufferedImage(getWidth(), getHeight(), \r\n        Transparency.BITMASK);\r\n    final Graphics g = img.getGraphics();\r\n    Graphics2D g2d = (Graphics2D) g;\r\n    g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, \r\n        RenderingHints.VALUE_ANTIALIAS_ON);\r\n    if(scatterData.size == 0)\r\n      return img;\r\n    g.setColor(GUIConstants.color6);\r\n    for(int i = 0; i < scatterData.size; i++) {\r\n      drawItem(g, scatterData.x[i], scatterData.y[i], false);\r\n    }\r\n    return img;\r\n  }","id":91952,"modified_method":"/**\r\n   * Precalculates the plot and returns the result as buffered image.\r\n   * @return buffered plot image\r\n   */\r\n  private BufferedImage createPlotImage() {\r\n    final BufferedImage img = new BufferedImage(getWidth(), getHeight(), \r\n        Transparency.BITMASK);\r\n    final Graphics g = img.getGraphics();\r\n    Graphics2D g2d = (Graphics2D) g;\r\n    g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, \r\n        RenderingHints.VALUE_ANTIALIAS_ON);\r\n    if(scatterData.size == 0)\r\n      return img;\r\n    g.setColor(GUIConstants.color6);\r\n    for(int i = 0; i < scatterData.size; i++) {\r\n      drawItem(g, scatterData.xAxis.co[i], scatterData.yAxis.co[i], false);\r\n    }\r\n    return img;\r\n  }","commit_id":"cf0fec6be29b70e5fddd6dcf50464f6b9b42b21b","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Refreshes item list and coordinates if the selection has changed. So far\r\n   * only numerical data is considered for plotting.\r\n   */\r\n  void refreshAxis() {\r\n    if(attr == null || attr.length == 0) return;\r\n\r\n    final Data data = GUI.context.data();\r\n    final StatsKey key = isTag ? data.tags.stat(data.tags.id(attr)) :\r\n      data.atts.stat(data.atts.id(attr));\r\n    numeric = key.kind == Kind.INT || key.kind == Kind.DBL;\r\n    if(numeric) {\r\n      numType = key.kind == Kind.INT ? TYPEINT : TYPEDBL;\r\n      min = key.min;\r\n      max = key.max;\r\n    } else {\r\n      cats = key.cats.keys();\r\n      final String[] tmpCats = new String[cats.length];\r\n      for(int i = 0; i < tmpCats.length; i++) {\r\n        tmpCats[i] = Token.string(cats[i]);\r\n      }\r\n      Arrays.sort(tmpCats);\r\n      for(int i = 0; i < tmpCats.length; i++) {\r\n        cats[i] = Token.token(tmpCats[i]);\r\n      }\r\n      nrCats = cats.length;\r\n//      nrCaptions = nrCats;\r\n    }\r\n\r\n    final int[] items = scatterData.pres;\r\n    co = new double[items.length];\r\n    for(int i = 0; i < items.length; i++) {\r\n      int p = items[i];\r\n      final int limit = p + data.size(p, Data.ELEM);\r\n      double currentValue = -1;\r\n      p++;\r\n      while(p < limit) {\r\n        final int kind = data.kind(p);\r\n        if(kind == Data.ELEM) {\r\n          final byte[] currName = data.tag(p);\r\n          if((Token.eq(attr, currName)) && isTag) {\r\n            final int attSize = data.attSize(p, kind);\r\n            final byte[] value = data.text(p + attSize);\r\n            currentValue = calcPosition(value);\r\n            break;\r\n          }\r\n        } else if(kind == Data.ATTR) {\r\n          final byte[] currName = data.attName(p);\r\n          if((Token.eq(attr, currName)) && !isTag) {\r\n            final byte[] value = data.attValue(p);\r\n            currentValue = calcPosition(value);\r\n            break;\r\n          }\r\n        }\r\n        p++;\r\n      }\r\n      co[i] = currentValue;\r\n    }\r\n  }","id":91953,"modified_method":"/**\r\n   * Refreshes item list and coordinates if the selection has changed. So far\r\n   * only numerical data is considered for plotting.\r\n   */\r\n  void refreshAxis() {\r\n    if(attr == null || attr.length == 0) return;\r\n\r\n    final Data data = GUI.context.data();\r\n    final StatsKey key = isTag ? data.tags.stat(data.tags.id(attr)) :\r\n      data.atts.stat(data.atts.id(attr));\r\n    numeric = key.kind == Kind.INT || key.kind == Kind.DBL;\r\n    if(numeric) {\r\n      numType = key.kind == Kind.INT ? TYPEINT : TYPEDBL;\r\n      min = key.min;\r\n      max = key.max;\r\n    } else {\r\n      cats = key.cats.keys();\r\n      final String[] tmpCats = new String[cats.length];\r\n      for(int i = 0; i < tmpCats.length; i++) {\r\n        tmpCats[i] = Token.string(cats[i]);\r\n      }\r\n      Arrays.sort(tmpCats);\r\n      for(int i = 0; i < tmpCats.length; i++) {\r\n        cats[i] = Token.token(tmpCats[i]);\r\n      }\r\n      nrCats = cats.length;\r\n//      nrCaptions = nrCats;\r\n    }\r\n\r\n    final int[] items = scatterData.pres;\r\n    co = new double[items.length];\r\n    vals = new byte[items.length][];\r\n    for(int i = 0; i < items.length; i++) {\r\n      int p = items[i];\r\n      final int limit = p + data.size(p, Data.ELEM);\r\n//      double currentValue = -1;\r\n      byte[] value = {};\r\n      p++;\r\n      while(p < limit) {\r\n        final int kind = data.kind(p);\r\n        if(kind == Data.ELEM) {\r\n          final byte[] currName = data.tag(p);\r\n          if((Token.eq(attr, currName)) && isTag) {\r\n            final int attSize = data.attSize(p, kind);\r\n            value = data.text(p + attSize);\r\n//            currentValue = calcPosition(value);\r\n            break;\r\n          }\r\n        } else if(kind == Data.ATTR) {\r\n          final byte[] currName = data.attName(p);\r\n          if((Token.eq(attr, currName)) && !isTag) {\r\n            value = data.attValue(p);\r\n//            currentValue = calcPosition(value);\r\n            break;\r\n          }\r\n        }\r\n        p++;\r\n      }\r\n//      co[i] = currentValue;\r\n      vals[i] = value;\r\n    }\r\n    \r\n    calcExtremeValues();\r\n    for(int i = 0; i < vals.length; i++) {\r\n      final byte[] val = vals[i];\r\n      if(val.length > 0) {\r\n        co[i] = calcPosition(val);\r\n      }\r\n    }\r\n  }","commit_id":"53178191f31f2f2502f6bbdd701e14ef93d58366","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Creates a buffered image for items.\r\n   * @param focusedImage create image of focused item if true\r\n   * @param marked create image of marked item\r\n   * @return item image\r\n   */\r\n  private BufferedImage createItemImage(final boolean focusedImage, \r\n      final boolean marked) {\r\n    final BufferedImage img = focusedImage ? new BufferedImage(\r\n        ITEMSIZEFOCUSED, ITEMSIZEFOCUSED, Transparency.TRANSLUCENT) : \r\n          new BufferedImage(ITEMSIZE, ITEMSIZE, Transparency.TRANSLUCENT);\r\n    final Graphics g = img.getGraphics();\r\n    final Graphics2D g2d = (Graphics2D) g;\r\n    g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, \r\n        RenderingHints.VALUE_ANTIALIAS_ON);\r\n    if(focusedImage) {\r\n      g.setColor(Color.black);\r\n      final int diff = (ITEMSIZEFOCUSED - ITEMSIZE) / 2;\r\n      g.fillOval(diff, diff, ITEMSIZE, ITEMSIZE);\r\n      g.setColor(new Color(180, 80, 80, 200));\r\n      g.fillOval(0, 0, ITEMSIZEFOCUSED, ITEMSIZEFOCUSED);\r\n    } else {\r\n      g.setColor(new Color(50, 60, 130, 150));\r\n      Color c = new Color(GUIConstants.colormark1.getRed(),\r\n          GUIConstants.colormark1.getGreen(), GUIConstants.colormark1.getBlue(),\r\n          150);\r\n      if(marked)\r\n//        g.setColor(GUIConstants.colormark1);\r\n        g.setColor(c);\r\n      g.fillOval(0, 0, ITEMSIZE, ITEMSIZE);\r\n    }\r\n    return img;\r\n  }","id":91954,"modified_method":"/**\r\n   * Creates a buffered image for items.\r\n   * @param focusedImage create image of focused item if true\r\n   * @param marked create image of marked item\r\n   * @return item image\r\n   */\r\n  private BufferedImage createItemImage(final boolean focusedImage, \r\n      final boolean marked) {\r\n    final BufferedImage img = focusedImage ? new BufferedImage(\r\n        ITEMSIZEFOCUSED, ITEMSIZEFOCUSED, Transparency.TRANSLUCENT) : \r\n          new BufferedImage(ITEMSIZE, ITEMSIZE, Transparency.TRANSLUCENT);\r\n    final Graphics g = img.getGraphics();\r\n    final Graphics2D g2d = (Graphics2D) g;\r\n    g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, \r\n        RenderingHints.VALUE_ANTIALIAS_ON);\r\n    if(focusedImage) {\r\n      g.setColor(new Color(80, 80, 255, 255));\r\n      g.fillOval(0, 0, ITEMSIZEFOCUSED, ITEMSIZEFOCUSED);\r\n      g.setColor(new Color(0, 0, 255, 255));\r\n      final int diff = (ITEMSIZEFOCUSED - ITEMSIZE) / 2;\r\n      g.fillOval(diff, diff, ITEMSIZE, ITEMSIZE);\r\n    } else {\r\n      g.setColor(new Color(50, 60, 130, 150));\r\n      Color c = new Color(GUIConstants.colormark1.getRed(),\r\n          GUIConstants.colormark1.getGreen(), GUIConstants.colormark1.getBlue(),\r\n          150);\r\n      if(marked)\r\n//        g.setColor(GUIConstants.colormark1);\r\n        g.setColor(c);\r\n      g.fillOval(0, 0, ITEMSIZE, ITEMSIZE);\r\n    }\r\n    return img;\r\n  }","commit_id":"53178191f31f2f2502f6bbdd701e14ef93d58366","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n    public StreamProperties deserialize(JsonElement json, Type typeOfT,\n                                        JsonDeserializationContext context) throws JsonParseException {\n      JsonObject jsonObj = json.getAsJsonObject();\n      String name = jsonObj.getAsJsonPrimitive(\"name\").getAsString();\n      Long ttl = jsonObj.has(\"ttl\") ? TimeUnit.SECONDS.toMillis(jsonObj.get(\"ttl\").getAsLong()) : null;\n      FormatSpecification format = null;\n      if (jsonObj.has(\"format\")) {\n        format = context.deserialize(jsonObj.get(\"format\"), FormatSpecification.class);\n      }\n      Integer threshold = jsonObj.has(\"threshold\") ? jsonObj.get(\"threshold\").getAsInt() : null;\n      return new StreamProperties(name, ttl, format, threshold);\n    }","id":91955,"modified_method":"@Override\n    public StreamProperties deserialize(JsonElement json, Type typeOfT,\n                                        JsonDeserializationContext context) throws JsonParseException {\n      JsonObject jsonObj = json.getAsJsonObject();\n      String name = jsonObj.has(\"name\") ? jsonObj.getAsJsonPrimitive(\"name\").getAsString() : null;\n      Long ttl = jsonObj.has(\"ttl\") ? TimeUnit.SECONDS.toMillis(jsonObj.get(\"ttl\").getAsLong()) : null;\n      FormatSpecification format = null;\n      if (jsonObj.has(\"format\")) {\n        format = context.deserialize(jsonObj.get(\"format\"), FormatSpecification.class);\n      }\n      Integer threshold = jsonObj.has(\"threshold\") ? jsonObj.get(\"threshold\").getAsInt() : null;\n      return new StreamProperties(name, ttl, format, threshold);\n    }","commit_id":"68c7e5449cb341d13a3b9e473a70d64a58a27268","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String createSliderApp(JsonObject json) throws IOException,\n      YarnException, InterruptedException {\n    if (json.has(\"name\") && json.has(\"typeConfigs\")\n        && json.has(\"resources\") && json.has(\"typeName\")) {\n      final String appType = json.get(\"typeName\").getAsString();\n      final String appName = json.get(\"name\").getAsString();\n      final String queueName = json.get(\"queue\").getAsString();\n      JsonObject configs = json.get(\"typeConfigs\").getAsJsonObject();\n      JsonObject resourcesObj = json.get(\"resources\").getAsJsonObject();\n      JsonArray componentsArray = resourcesObj.get(\"components\").getAsJsonArray();\n      String appsCreateFolderPath = getAppsCreateFolderPath();\n      File appsCreateFolder = new File(appsCreateFolderPath);\n      if (!appsCreateFolder.exists()) {\n        appsCreateFolder.mkdirs();\n      }\n      int appCount;\n      synchronized (createAppCounter) {\n        if (createAppCounter < 0) {\n          // Not initialized\n          createAppCounter = 0;\n          String[] apps = appsCreateFolder.list();\n          for (String app : apps) {\n            try {\n              int count = Integer.parseInt(app);\n              if (count > createAppCounter) {\n                createAppCounter = count;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        appCount = ++createAppCounter;\n      }\n      File appCreateFolder = new File(appsCreateFolder,\n          Integer.toString(appCount));\n      appCreateFolder.mkdirs();\n      File appConfigJsonFile = new File(appCreateFolder, \"appConfig.json\");\n      File resourcesJsonFile = new File(appCreateFolder, \"resources.json\");\n      saveAppConfigs(configs, componentsArray, appConfigJsonFile);\n      saveAppResources(resourcesObj, resourcesJsonFile);\n\n      final ActionCreateArgs createArgs = new ActionCreateArgs();\n      createArgs.template = appConfigJsonFile;\n      createArgs.resources = resourcesJsonFile;\n      if (queueName != null && queueName.trim().length() > 0) {\n        createArgs.queue = queueName;\n      }\n\n      final ActionInstallPackageArgs installArgs = new ActionInstallPackageArgs();\n      SliderAppType sliderAppType = getSliderAppType(appType, null);\n      String localAppPackageFileName = sliderAppType.getTypePackageFileName();\n      installArgs.name = appType;\n      installArgs.packageURI = getAppsFolderPath() + \"/\" + localAppPackageFileName;\n      installArgs.replacePkg = true;\n\n      return invokeSliderClientRunnable(new SliderClientContextRunnable<String>() {\n        @Override\n        public String run(SliderClient sliderClient) throws YarnException, IOException, InterruptedException {\n          sliderClient.actionInstallPkg(installArgs);\n          sliderClient.actionCreate(appName, createArgs);\n          ApplicationId applicationId = sliderClient.applicationId;\n          if (applicationId != null) {\n            return getApplicationIdString(applicationId);\n          }\n          return null;\n        }\n      });\n    }\n    return null;\n  }","id":91956,"modified_method":"@Override\n  public String createSliderApp(JsonObject json) throws IOException,\n      YarnException, InterruptedException {\n    if (json.has(\"name\") && json.has(\"typeConfigs\")\n        && json.has(\"resources\") && json.has(\"typeName\")) {\n      final String appType = json.get(\"typeName\").getAsString();\n      final String appName = json.get(\"name\").getAsString();\n      final String queueName = json.has(\"queue\") ? json.get(\"queue\").getAsString() : null;\n      JsonObject configs = json.get(\"typeConfigs\").getAsJsonObject();\n      JsonObject resourcesObj = json.get(\"resources\").getAsJsonObject();\n      JsonArray componentsArray = resourcesObj.get(\"components\").getAsJsonArray();\n      String appsCreateFolderPath = getAppsCreateFolderPath();\n      File appsCreateFolder = new File(appsCreateFolderPath);\n      if (!appsCreateFolder.exists()) {\n        appsCreateFolder.mkdirs();\n      }\n      int appCount;\n      synchronized (createAppCounter) {\n        if (createAppCounter < 0) {\n          // Not initialized\n          createAppCounter = 0;\n          String[] apps = appsCreateFolder.list();\n          for (String app : apps) {\n            try {\n              int count = Integer.parseInt(app);\n              if (count > createAppCounter) {\n                createAppCounter = count;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        appCount = ++createAppCounter;\n      }\n      File appCreateFolder = new File(appsCreateFolder,\n          Integer.toString(appCount));\n      appCreateFolder.mkdirs();\n      File appConfigJsonFile = new File(appCreateFolder, \"appConfig.json\");\n      File resourcesJsonFile = new File(appCreateFolder, \"resources.json\");\n      saveAppConfigs(configs, componentsArray, appConfigJsonFile);\n      saveAppResources(resourcesObj, resourcesJsonFile);\n\n      final ActionCreateArgs createArgs = new ActionCreateArgs();\n      createArgs.template = appConfigJsonFile;\n      createArgs.resources = resourcesJsonFile;\n      if (queueName != null && queueName.trim().length() > 0) {\n        createArgs.queue = queueName;\n      }\n\n      final ActionInstallPackageArgs installArgs = new ActionInstallPackageArgs();\n      SliderAppType sliderAppType = getSliderAppType(appType, null);\n      String localAppPackageFileName = sliderAppType.getTypePackageFileName();\n      installArgs.name = appType;\n      installArgs.packageURI = getAppsFolderPath() + \"/\" + localAppPackageFileName;\n      installArgs.replacePkg = true;\n\n      return invokeSliderClientRunnable(new SliderClientContextRunnable<String>() {\n        @Override\n        public String run(SliderClient sliderClient) throws YarnException, IOException, InterruptedException {\n          sliderClient.actionInstallPkg(installArgs);\n          sliderClient.actionCreate(appName, createArgs);\n          ApplicationId applicationId = sliderClient.applicationId;\n          if (applicationId != null) {\n            return getApplicationIdString(applicationId);\n          }\n          return null;\n        }\n      });\n    }\n    return null;\n  }","commit_id":"9170a41eac4fb13266b7b4b07a5c2a08e23f9c92","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public JsonElement serialize(ApplicationSpecification src, Type typeOfSrc, JsonSerializationContext context) {\n    JsonObject jsonObj = new JsonObject();\n\n    jsonObj.add(\"name\", new JsonPrimitive(src.getName()));\n    jsonObj.add(\"version\", new JsonPrimitive(src.getVersion()));\n    jsonObj.add(\"description\", new JsonPrimitive(src.getDescription()));\n    jsonObj.add(\"streams\", serializeMap(src.getStreams(), context, StreamSpecification.class));\n    jsonObj.add(\"datasetModules\", serializeMap(src.getDatasetModules(), context, String.class));\n    jsonObj.add(\"datasetInstances\", serializeMap(src.getDatasets(), context, DatasetCreationSpec.class));\n    jsonObj.add(\"flows\", serializeMap(src.getFlows(), context, FlowSpecification.class));\n    jsonObj.add(\"procedures\", serializeMap(src.getProcedures(), context, ProcedureSpecification.class));\n    jsonObj.add(\"mapReduces\", serializeMap(src.getMapReduce(), context, MapReduceSpecification.class));\n    jsonObj.add(\"sparks\", serializeMap(src.getSpark(), context, SparkSpecification.class));\n    jsonObj.add(\"workflows\", serializeMap(src.getWorkflows(), context, WorkflowSpecification.class));\n    jsonObj.add(\"services\", serializeMap(src.getServices(), context, ServiceSpecification.class));\n    jsonObj.add(\"schedules\", serializeMap(src.getSchedules(), context, ScheduleSpecification.class));\n    jsonObj.add(\"workers\", serializeMap(src.getWorkers(), context, WorkerSpecification.class));\n\n    return jsonObj;\n  }","id":91957,"modified_method":"@Override\n  public JsonElement serialize(ApplicationSpecification src, Type typeOfSrc, JsonSerializationContext context) {\n    JsonObject jsonObj = new JsonObject();\n\n    jsonObj.add(\"name\", new JsonPrimitive(src.getName()));\n    if (src.getVersion() != null) {\n      jsonObj.add(\"version\", new JsonPrimitive(src.getVersion()));\n    }\n    jsonObj.add(\"description\", new JsonPrimitive(src.getDescription()));\n    jsonObj.add(\"streams\", serializeMap(src.getStreams(), context, StreamSpecification.class));\n    jsonObj.add(\"datasetModules\", serializeMap(src.getDatasetModules(), context, String.class));\n    jsonObj.add(\"datasetInstances\", serializeMap(src.getDatasets(), context, DatasetCreationSpec.class));\n    jsonObj.add(\"flows\", serializeMap(src.getFlows(), context, FlowSpecification.class));\n    jsonObj.add(\"procedures\", serializeMap(src.getProcedures(), context, ProcedureSpecification.class));\n    jsonObj.add(\"mapReduces\", serializeMap(src.getMapReduce(), context, MapReduceSpecification.class));\n    jsonObj.add(\"sparks\", serializeMap(src.getSpark(), context, SparkSpecification.class));\n    jsonObj.add(\"workflows\", serializeMap(src.getWorkflows(), context, WorkflowSpecification.class));\n    jsonObj.add(\"services\", serializeMap(src.getServices(), context, ServiceSpecification.class));\n    jsonObj.add(\"schedules\", serializeMap(src.getSchedules(), context, ScheduleSpecification.class));\n    jsonObj.add(\"workers\", serializeMap(src.getWorkers(), context, WorkerSpecification.class));\n\n    return jsonObj;\n  }","commit_id":"7fc0c29352f0b7332831b79ce85383d801f0a116","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n    throws JsonParseException {\n    JsonObject jsonObj = json.getAsJsonObject();\n\n    String name = jsonObj.get(\"name\").getAsString();\n    String version = jsonObj.get(\"version\").getAsString();\n    String description = jsonObj.get(\"description\").getAsString();\n\n    Map<String, StreamSpecification> streams = deserializeMap(jsonObj.get(\"streams\"),\n                                                              context, StreamSpecification.class);\n    Map<String, String> datasetModules = deserializeMap(jsonObj.get(\"datasetModules\"), context, String.class);\n    Map<String, DatasetCreationSpec> datasetInstances = deserializeMap(jsonObj.get(\"datasetInstances\"),\n                                                                       context,\n                                                                       DatasetCreationSpec.class);\n    Map<String, FlowSpecification> flows = deserializeMap(jsonObj.get(\"flows\"),\n                                                          context, FlowSpecification.class);\n    Map<String, ProcedureSpecification> procedures = deserializeMap(jsonObj.get(\"procedures\"),\n                                                                    context, ProcedureSpecification.class);\n    Map<String, MapReduceSpecification> mapReduces = deserializeMap(jsonObj.get(\"mapReduces\"),\n                                                                    context, MapReduceSpecification.class);\n    Map<String, SparkSpecification> sparks = deserializeMap(jsonObj.get(\"sparks\"),\n                                                            context, SparkSpecification.class);\n    Map<String, WorkflowSpecification> workflows = deserializeMap(jsonObj.get(\"workflows\"),\n                                                                  context, WorkflowSpecification.class);\n\n    Map<String, ServiceSpecification> services = deserializeMap(jsonObj.get(\"services\"),\n                                                                context, ServiceSpecification.class);\n\n    Map<String, ScheduleSpecification> schedules = deserializeMap(jsonObj.get(\"schedules\"),\n                                                                context, ScheduleSpecification.class);\n\n    Map<String, WorkerSpecification> workers = deserializeMap(jsonObj.get(\"workers\"), context,\n                                                              WorkerSpecification.class);\n\n    return new DefaultApplicationSpecification(name, version, description, streams,\n                                               datasetModules, datasetInstances,\n                                               flows, procedures, mapReduces, sparks,\n                                               workflows, services, schedules, workers);\n  }","id":91958,"modified_method":"@Override\n  public ApplicationSpecification deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n    throws JsonParseException {\n    JsonObject jsonObj = json.getAsJsonObject();\n\n    String name = jsonObj.get(\"name\").getAsString();\n\n    String version = null;\n    if (jsonObj.has(\"version\")) {\n      version = jsonObj.get(\"version\").getAsString();\n    }\n    String description = jsonObj.get(\"description\").getAsString();\n\n    Map<String, StreamSpecification> streams = deserializeMap(jsonObj.get(\"streams\"),\n                                                              context, StreamSpecification.class);\n    Map<String, String> datasetModules = deserializeMap(jsonObj.get(\"datasetModules\"), context, String.class);\n    Map<String, DatasetCreationSpec> datasetInstances = deserializeMap(jsonObj.get(\"datasetInstances\"),\n                                                                       context,\n                                                                       DatasetCreationSpec.class);\n    Map<String, FlowSpecification> flows = deserializeMap(jsonObj.get(\"flows\"),\n                                                          context, FlowSpecification.class);\n    Map<String, ProcedureSpecification> procedures = deserializeMap(jsonObj.get(\"procedures\"),\n                                                                    context, ProcedureSpecification.class);\n    Map<String, MapReduceSpecification> mapReduces = deserializeMap(jsonObj.get(\"mapReduces\"),\n                                                                    context, MapReduceSpecification.class);\n    Map<String, SparkSpecification> sparks = deserializeMap(jsonObj.get(\"sparks\"),\n                                                            context, SparkSpecification.class);\n    Map<String, WorkflowSpecification> workflows = deserializeMap(jsonObj.get(\"workflows\"),\n                                                                  context, WorkflowSpecification.class);\n\n    Map<String, ServiceSpecification> services = deserializeMap(jsonObj.get(\"services\"),\n                                                                context, ServiceSpecification.class);\n\n    Map<String, ScheduleSpecification> schedules = deserializeMap(jsonObj.get(\"schedules\"),\n                                                                context, ScheduleSpecification.class);\n\n    Map<String, WorkerSpecification> workers = deserializeMap(jsonObj.get(\"workers\"), context,\n                                                              WorkerSpecification.class);\n\n    return new DefaultApplicationSpecification(name, version, description, streams,\n                                               datasetModules, datasetInstances,\n                                               flows, procedures, mapReduces, sparks,\n                                               workflows, services, schedules, workers);\n  }","commit_id":"7fc0c29352f0b7332831b79ce85383d801f0a116","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n    public void testStopNonExistingContainer() throws Exception {\n        containers(\"cNon1\");\n\n        expect(this.fabricService.getContainer(\"cNon1\")).andThrow(\n            new FabricException(\"Container 'cNon1' does not exist\"));\n\n        replay(this.fabricService, this.commandSession);\n        try {\n            this.stop.execute(this.commandSession);\n            fail(\"Should throw FabricException\");\n        } catch (FabricException e) {\n        }\n        verify(this.fabricService);\n    }","id":91959,"modified_method":"@Test\n    public void testStopNonExistingContainer() throws Exception {\n        containers(\"cNon1\");\n\n        expect(this.fabricService.adapt(CuratorFramework.class)).andReturn(this.curatorFramework).anyTimes();\n        expect(this.fabricService.getContainers()).andReturn(new Container[0]);\n\n        replay(this.fabricService, this.commandSession);\n        try {\n            this.stop.execute(this.commandSession);\n            fail(\"Should throw FabricException\");\n        } catch (IllegalArgumentException e) {\n        }\n        verify(this.fabricService);\n    }","commit_id":"406101e52e5bb65ff3621080b19fdcf027f720ba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testStopSomeMatchingContainers() throws Exception {\n        containers(\"c1\", \"c2\");\n\n        ContainerImpl c1 = newContainer(\"c1\");\n        expect(this.fabricService.getContainer(\"c1\")).andReturn(c1);\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1 }).once();\n        this.fabricService.stopContainer(c1, false);\n        expect(this.fabricService.getContainer(\"c2\")).andThrow(new FabricException(\"Container 'c2' does not exist\"));\n\n        replay(this.fabricService, this.commandSession);\n        try {\n            this.stop.execute(this.commandSession);\n            fail(\"Should throw FabricException\");\n        } catch (FabricException e) {\n            assertThat(e.getMessage().contains(\"'c2'\"), is(true));\n        }\n        verify(this.fabricService);\n    }","id":91960,"modified_method":"@Test\n    public void testStopSomeMatchingContainers() throws Exception {\n        containers(\"c1\", \"c2\");\n\n        ContainerImpl c1 = newContainer(\"c1\");\n        expect(this.fabricService.adapt(CuratorFramework.class)).andReturn(this.curatorFramework);\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1 }).once();\n        this.fabricService.stopContainer(c1, false);\n        expect(this.fabricService.adapt(CuratorFramework.class)).andReturn(this.curatorFramework);\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1 }).once();\n\n        replay(this.fabricService, this.commandSession);\n        try {\n            this.stop.execute(this.commandSession);\n            fail(\"Should throw FabricException\");\n        } catch (IllegalArgumentException e) {\n            assertThat(e.getMessage().contains(\" c2 \"), is(true));\n        }\n        verify(this.fabricService);\n    }","commit_id":"406101e52e5bb65ff3621080b19fdcf027f720ba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testStopAllMatchingContainers() throws Exception {\n        // should preserve order\n        containers(\"c1\", \"c3\", \"c2\");\n\n        ContainerImpl c1 = newContainer(\"c1\");\n        ContainerImpl c2 = newContainer(\"c2\");\n        ContainerImpl c3 = newContainer(\"c3\");\n        expect(this.fabricService.getContainer(\"c1\")).andReturn(c1);\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1, c3, c2 });\n        this.fabricService.stopContainer(c1, false);\n        expect(this.fabricService.getContainer(\"c3\")).andReturn(c3);\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1, c3, c2 });\n        this.fabricService.stopContainer(c3, false);\n        expect(this.fabricService.getContainer(\"c2\")).andReturn(c2);\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1, c3, c2 });\n        this.fabricService.stopContainer(c2, false);\n\n        replay(this.fabricService, this.commandSession);\n        this.stop.execute(this.commandSession);\n        verify(this.fabricService);\n    }","id":91961,"modified_method":"@Test\n    public void testStopAllMatchingContainers() throws Exception {\n        // should preserve order\n        containers(\"c1\", \"c3\", \"c2\");\n\n        ContainerImpl c1 = newContainer(\"c1\");\n        ContainerImpl c2 = newContainer(\"c2\");\n        ContainerImpl c3 = newContainer(\"c3\");\n        expect(this.fabricService.adapt(CuratorFramework.class)).andReturn(this.curatorFramework).anyTimes();\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1, c3, c2 });\n        this.fabricService.stopContainer(c1, false);\n        expect(this.fabricService.adapt(CuratorFramework.class)).andReturn(this.curatorFramework).anyTimes();\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1, c3, c2 });\n        this.fabricService.stopContainer(c3, false);\n        expect(this.fabricService.adapt(CuratorFramework.class)).andReturn(this.curatorFramework).anyTimes();\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1, c3, c2 });\n        this.fabricService.stopContainer(c2, false);\n\n        replay(this.fabricService, this.commandSession);\n        this.stop.execute(this.commandSession);\n        verify(this.fabricService);\n    }","commit_id":"406101e52e5bb65ff3621080b19fdcf027f720ba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testStopGlobMatchingContainers() throws Exception {\n        // should stop c2 once\n        // should not touch d1\n        containers(\"c*\", \"c2\");\n\n        ContainerImpl c1 = newContainer(\"c1\");\n        ContainerImpl c2 = newContainer(\"c2\");\n        ContainerImpl c3 = newContainer(\"c3\");\n        ContainerImpl d1 = newContainer(\"d1\");\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1, c3, c2, d1 });\n        expect(this.fabricService.getContainer(\"c1\")).andReturn(c1);\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1, c3, c2, d1 });\n        this.fabricService.stopContainer(c1, false);\n        expect(this.fabricService.getContainer(\"c3\")).andReturn(c3);\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1, c3, c2, d1 });\n        this.fabricService.stopContainer(c3, false);\n        expect(this.fabricService.getContainer(\"c2\")).andReturn(c2);\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1, c3, c2, d1 });\n        this.fabricService.stopContainer(c2, false);\n\n        replay(this.fabricService, this.commandSession);\n        this.stop.execute(this.commandSession);\n        verify(this.fabricService);\n\n        String result = new String(this.result.toByteArray());\n        assertThat(result.contains(\"Container 'c1' stopped successfully.\"), is(true));\n        assertThat(result.contains(\"Container 'c2' stopped successfully.\"), is(true));\n        assertThat(result.contains(\"Container 'c3' stopped successfully.\"), is(true));\n    }","id":91962,"modified_method":"@Test\n    public void testStopGlobMatchingContainers() throws Exception {\n        // should stop c2 once\n        // should not touch d1\n        containers(\"c*\", \"c2\");\n\n        ContainerImpl c1 = newContainer(\"c1\");\n        ContainerImpl c2 = newContainer(\"c2\");\n        ContainerImpl c3 = newContainer(\"c3\");\n        ContainerImpl d1 = newContainer(\"d1\");\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1, c3, c2, d1 }).once();\n        expect(this.fabricService.adapt(CuratorFramework.class)).andReturn(this.curatorFramework);\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1, c3, c2, d1 }).once();\n        this.fabricService.stopContainer(c1, false);\n        expect(this.fabricService.adapt(CuratorFramework.class)).andReturn(this.curatorFramework);\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1, c3, c2, d1 }).once();\n        this.fabricService.stopContainer(c3, false);\n        expect(this.fabricService.adapt(CuratorFramework.class)).andReturn(this.curatorFramework);\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1, c3, c2, d1 }).once();\n        this.fabricService.stopContainer(c2, false);\n\n        replay(this.fabricService, this.commandSession);\n        this.stop.execute(this.commandSession);\n        verify(this.fabricService);\n\n        String result = new String(this.result.toByteArray());\n        assertThat(result.contains(\"Container 'c1' stopped successfully.\"), is(true));\n        assertThat(result.contains(\"Container 'c2' stopped successfully.\"), is(true));\n        assertThat(result.contains(\"Container 'c3' stopped successfully.\"), is(true));\n    }","commit_id":"406101e52e5bb65ff3621080b19fdcf027f720ba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testStopNoMatchingContainers() throws Exception {\n        containers(\"c1\", \"c2\");\n\n        expect(this.fabricService.getContainer(\"c1\")).andThrow(new FabricException(\"Container 'c1' does not exist\"));\n\n        replay(this.fabricService, this.commandSession);\n        try {\n            this.stop.execute(this.commandSession);\n            fail(\"Should throw FabricException\");\n        } catch (FabricException e) {\n        }\n        verify(this.fabricService);\n    }","id":91963,"modified_method":"@Test\n    public void testStopNoMatchingContainers() throws Exception {\n        containers(\"c1\", \"c2\");\n\n        expect(this.fabricService.adapt(CuratorFramework.class)).andReturn(this.curatorFramework);\n        expect(this.fabricService.getContainers()).andReturn(new Container[0]).once();\n\n        replay(this.fabricService, this.commandSession);\n        try {\n            this.stop.execute(this.commandSession);\n            fail(\"Should throw FabricException\");\n        } catch (IllegalArgumentException e) {\n        }\n        verify(this.fabricService);\n    }","commit_id":"406101e52e5bb65ff3621080b19fdcf027f720ba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testStopSingleContainer() throws Exception {\n        containers(\"c1\");\n\n        ContainerImpl c1 = newContainer(\"c1\");\n        expect(this.fabricService.getContainer(\"c1\")).andReturn(c1);\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1 });\n        this.fabricService.stopContainer(c1, false);\n\n        replay(this.fabricService, this.commandSession);\n        this.stop.execute(this.commandSession);\n        verify(this.fabricService);\n    }","id":91964,"modified_method":"@Test\n    public void testStopSingleContainer() throws Exception {\n        containers(\"c1\");\n\n        ContainerImpl c1 = newContainer(\"c1\");\n        expect(this.fabricService.adapt(CuratorFramework.class)).andReturn(this.curatorFramework).anyTimes();\n        expect(this.fabricService.getContainers()).andReturn(new Container[] { c1 });\n        this.fabricService.stopContainer(c1, false);\n\n        replay(this.fabricService, this.commandSession);\n        this.stop.execute(this.commandSession);\n        verify(this.fabricService);\n    }","commit_id":"406101e52e5bb65ff3621080b19fdcf027f720ba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Before\n    public void init() throws Exception {\n        this.fabricService = createStrictMock(FabricService.class);\n        this.commandSession = createMock(CommandSession.class);\n        this.stop = new ContainerStopAction(fabricService);\n        this.result = new ByteArrayOutputStream();\n        expect(this.commandSession.getConsole()).andReturn(new PrintStream(result)).anyTimes();\n\n        // Attempt to avoid the call to curator\n        //Field forceField = ContainerLifecycleAction.class.getDeclaredField(\"force\");\n        //ReflectionHelper.setField(forceField, stop, true);\n    }","id":91965,"modified_method":"@Before\n    public void init() throws Exception {\n        this.fabricService = createStrictMock(FabricService.class);\n        this.commandSession = createMock(CommandSession.class);\n        this.stop = new ContainerStopAction(fabricService);\n        this.result = new ByteArrayOutputStream();\n        expect(this.commandSession.getConsole()).andReturn(new PrintStream(result)).anyTimes();\n\n        this.curatorFramework = createMock(CuratorFramework.class);\n    }","commit_id":"406101e52e5bb65ff3621080b19fdcf027f720ba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Dispatches the given <tt>KeyEvent<\/tt>.\n     * @param e the <tt>KeyEvent<\/tt> to dispatch\n     * @return <tt>true<\/tt> if the KeyboardFocusManager should take no\n     * further action with regard to the KeyEvent; <tt>false<\/tt>\n     * otherwise\n     */\n    public boolean dispatchKeyEvent(KeyEvent e)\n    {\n        Component focusOwner = keyManager.getFocusOwner();\n\n        // If this window is not the focus window  or if the event is not\n        // of type PRESSED we have nothing more to do here.\n        // Also don't re-dispatch any events if the menu is active.\n        if (!contactListContainer.isFocused()\n            || (e.getID() != KeyEvent.KEY_PRESSED\n                && e.getID() != KeyEvent.KEY_TYPED)\n            || (GuiActivator.getUIService()\n                    .getSingleWindowContainer() != null)\n                && GuiActivator.getUIService()\n                    .getSingleWindowContainer().containsFocus()\n            || (focusOwner != null\n                && !searchField.isFocusOwner()\n                && focusOwner instanceof JTextComponent)\n            || contactListContainer.isMenuSelected())\n            return false;\n\n        // Ctrl-Enter || Cmd-Enter typed when this window is the focused\n        // window.\n        //\n        // Tried to make this with key bindings first, but has a problem\n        // with enter key binding. When the popup menu containing call\n        // contacts was opened the default keyboard manager was prioritizing\n        // the window ENTER key, which will open a chat and we wanted that\n        // the enter starts a call with the selected contact from the menu.\n        // This is why we need to do it here and to check if the\n        // permanent focus owner is equal to the focus owner, which is not\n        // the case when a popup menu is opened.\n        if (e.getKeyCode() == KeyEvent.VK_ENTER\n            && (e.isControlDown() || e.isMetaDown()))\n        {\n            contactListContainer.ctrlEnterKeyTyped();\n            return false;\n        }\n        else if (e.getKeyCode() == KeyEvent.VK_ENTER\n            && keyManager.getFocusOwner()\n            .equals(keyManager.getPermanentFocusOwner()))\n        {\n            contactListContainer.enterKeyTyped();\n            return false;\n        }\n\n        // If the search field is the focus owner.\n        if (searchField.isFocusOwner()\n            && (e.getKeyCode() == KeyEvent.VK_UP\n                || e.getKeyCode() == KeyEvent.VK_DOWN\n                || e.getKeyCode() == KeyEvent.VK_PAGE_UP\n                || e.getKeyCode() == KeyEvent.VK_PAGE_DOWN))\n        {\n            contactList.selectFirstContact();\n            contactList.getComponent().requestFocus();\n            return false;\n        }\n\n        // If the contact list is the focus owner.\n        if (contactList.getComponent().isFocusOwner()\n            && e.getKeyCode() == KeyEvent.VK_ESCAPE)\n        {\n            // Removes all current selections.\n            contactList.removeSelection();\n\n            if (searchField.getText() != null)\n            {\n                searchField.requestFocus();\n            }\n            return false;\n        }\n\n        UIGroup selectedGroup = contactList.getSelectedGroup();\n\n        // No matter who is the focus owner.\n        if (e.getKeyChar() == KeyEvent.CHAR_UNDEFINED\n            || e.getKeyCode() == KeyEvent.VK_ENTER\n            || e.getKeyCode() == KeyEvent.VK_DELETE\n            || e.getKeyCode() == KeyEvent.VK_BACK_SPACE\n            || e.getKeyCode() == KeyEvent.VK_TAB\n            || e.getKeyChar() == '\\t'\n            || e.getKeyCode() == KeyEvent.VK_SPACE\n            || (selectedGroup != null\n                && (e.getKeyChar() == '+'\n                    || e.getKeyChar() == '-')))\n        {\n            return false;\n        }\n\n        boolean singleWindowRule\n            = GuiActivator.getUIService().getSingleWindowContainer() == null\n                || contactList.getComponent().isFocusOwner();\n\n        if (!searchField.isFocusOwner()\n            && keyManager.getFocusOwner() != null\n            && singleWindowRule\n            && keyManager.getFocusOwner()\n                .equals(keyManager.getPermanentFocusOwner()))\n        {\n            // Request the focus in the search field if a letter is typed.\n            searchField.requestFocusInWindow();\n\n            // We re-dispatch the event to search field.\n            keyManager.redispatchEvent(searchField, e);\n\n            // We don't want to dispatch further this event.\n            return true;\n        }\n        return false;\n    }","id":91966,"modified_method":"/**\n     * Dispatches the given <tt>KeyEvent<\/tt>.\n     * @param e the <tt>KeyEvent<\/tt> to dispatch\n     * @return <tt>true<\/tt> if the KeyboardFocusManager should take no\n     * further action with regard to the KeyEvent; <tt>false<\/tt>\n     * otherwise\n     */\n    public boolean dispatchKeyEvent(KeyEvent e)\n    {\n        // If this window is not the focus window or if the event is not of type\n        // PRESSED, we have nothing more to do here. Also don't re-dispatch any\n        // events if the menu is active.\n        if (!contactListContainer.isFocused())\n            return false;\n\n        int id = e.getID();\n\n        if (id != KeyEvent.KEY_PRESSED && id != KeyEvent.KEY_TYPED)\n            return false;\n\n        SingleWindowContainer singleWindowContainer\n            = GuiActivator.getUIService().getSingleWindowContainer();\n\n        if ((singleWindowContainer != null)\n                && singleWindowContainer.containsFocusOwner())\n            return false;\n\n        Component focusOwner = keyManager.getFocusOwner();\n\n        if (focusOwner != null\n                && !searchField.isFocusOwner()\n                && focusOwner instanceof JTextComponent)\n            return false;\n        if (contactListContainer.isMenuSelected())\n            return false;\n\n        // Ctrl-Enter || Cmd-Enter typed when this window is the focused\n        // window.\n        //\n        // Tried to make this with key bindings first, but has a problem\n        // with enter key binding. When the popup menu containing call\n        // contacts was opened the default keyboard manager was prioritizing\n        // the window ENTER key, which will open a chat and we wanted that\n        // the enter starts a call with the selected contact from the menu.\n        // This is why we need to do it here and to check if the\n        // permanent focus owner is equal to the focus owner, which is not\n        // the case when a popup menu is opened.\n        int keyCode = e.getKeyCode();\n\n        if (keyCode == KeyEvent.VK_ENTER\n                && (e.isControlDown() || e.isMetaDown()))\n        {\n            contactListContainer.ctrlEnterKeyTyped();\n            return false;\n        }\n        else if (keyCode == KeyEvent.VK_ENTER\n                && focusOwner.equals(keyManager.getPermanentFocusOwner()))\n        {\n            contactListContainer.enterKeyTyped();\n            return false;\n        }\n\n        // If the search field is the focus owner.\n        if (searchField.isFocusOwner()\n                && (keyCode == KeyEvent.VK_UP\n                        || keyCode == KeyEvent.VK_DOWN\n                        || keyCode == KeyEvent.VK_PAGE_UP\n                        || keyCode == KeyEvent.VK_PAGE_DOWN))\n        {\n            contactList.selectFirstContact();\n            contactList.getComponent().requestFocus();\n            return false;\n        }\n\n        // If the contact list is the focus owner.\n        if (contactList.getComponent().isFocusOwner()\n                && keyCode == KeyEvent.VK_ESCAPE)\n        {\n            // Removes all current selections.\n            contactList.removeSelection();\n\n            if (searchField.getText() != null)\n                searchField.requestFocus();\n\n            return false;\n        }\n\n        char keyChar = e.getKeyChar();\n        UIGroup selectedGroup = contactList.getSelectedGroup();\n\n        // No matter who is the focus owner.\n        if (keyChar == KeyEvent.CHAR_UNDEFINED\n                || keyCode == KeyEvent.VK_ENTER\n                || keyCode == KeyEvent.VK_DELETE\n                || keyCode == KeyEvent.VK_BACK_SPACE\n                || keyCode == KeyEvent.VK_TAB\n                || e.getKeyChar() == '\\t'\n                || keyCode == KeyEvent.VK_SPACE\n                || (selectedGroup != null\n                        && (keyChar == '+' || keyChar == '-')))\n        {\n            return false;\n        }\n\n        boolean singleWindowRule\n            = singleWindowContainer == null\n                || contactList.getComponent().isFocusOwner();\n\n        if (!searchField.isFocusOwner()\n                && focusOwner != null\n                && singleWindowRule\n                && focusOwner.equals(keyManager.getPermanentFocusOwner()))\n        {\n            // Request the focus in the search field if a letter is typed.\n            searchField.requestFocusInWindow();\n            // We re-dispatch the event to search field.\n            keyManager.redispatchEvent(searchField, e);\n            // We don't want to dispatch further this event.\n            return true;\n        }\n\n        return false;\n    }","commit_id":"c98876d03cb00ca6efae66585907387ca95ca671","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns this panel that has been configured to display the meta contact\n     * and meta contact group cells.\n     *\n     * @param tree the source tree\n     * @param value the tree node\n     * @param selected indicates if the node is selected\n     * @param expanded indicates if the node is expanded\n     * @param leaf indicates if the node is a leaf\n     * @param row indicates the row number of the node\n     * @param hasFocus indicates if the node has the focus\n     * @return this panel\n     */\n    public Component getTreeCellRendererComponent(JTree tree, Object value,\n        boolean selected, boolean expanded, boolean leaf, int row,\n        boolean hasFocus)\n    {\n        this.treeContactList = (TreeContactList) tree;\n        this.row = row;\n        this.isSelected = selected;\n        this.treeNode = (TreeNode) value;\n\n        rightLabel.setIcon(null);\n\n        DefaultTreeContactList contactList = (DefaultTreeContactList) tree;\n\n        setBorder();\n        addLabels(1);\n\n        // Set background color.\n        if (contactList instanceof TreeContactList)\n        {\n            ContactListFilter filter\n                = ((TreeContactList) contactList).getCurrentFilter();\n\n            if (filter != null\n                && filter.equals(TreeContactList.historyFilter)\n                && value instanceof ContactNode\n                && row%2 == 0)\n            {\n                setBackground(Constants.CALL_HISTORY_EVEN_ROW_COLOR);\n            }\n            else\n            {\n                setBackground(Color.WHITE);\n            }\n        }\n\n        // clear icon if any (mobile indicator)\n        nameLabel.setIcon(null);\n\n        // Make appropriate adjustments for contact nodes and group nodes.\n        if (value instanceof ContactNode)\n        {\n            UIContactImpl contact\n                = ((ContactNode) value).getContactDescriptor();\n\n            if((contact.getDescriptor() instanceof SourceContact) &&\n                GuiActivator.getMUCService().isMUCSourceContact((SourceContact)contact.getDescriptor()))\n            {\n                setBackground(Constants.CHAT_ROOM_ROW_COLOR);\n            }\n            String displayName = contact.getDisplayName();\n\n            if ((displayName == null\n                || displayName.trim().length() < 1)\n                && !(contact instanceof ShowMoreContact))\n            {\n                displayName = GuiActivator.getResources()\n                    .getI18NString(\"service.gui.UNKNOWN\");\n            }\n\n            nameLabel.setText(displayName);\n\n            if(statusIcon != null\n                && contactList.isContactActive(contact)\n                && statusIcon instanceof ImageIcon)\n                ((ImageIcon) statusIcon).setImage(msgReceivedImage);\n            else\n                statusIcon = contact.getStatusIcon();\n\n            statusLabel.setIcon(statusIcon);\n\n            /*\n             * FIXME A hard-coded absolute font size is surely not appropriate\n             * because it is completely oblivious of the default system font\n             * size. A JLabel will very likely use the closest to the default\n             * system font (size) so there is no reason to specify any font size\n             * here, let alone a hard-coded absolute one. Anyway, use a\n             * hard-coded absolute font size but at least do not fall bellow the\n             * default system font size.\n             */\n            Font nameLabelFont = nameLabel.getFont();\n\n            nameLabel.setFont(\n                    nameLabelFont.deriveFont(\n                            Font.PLAIN,\n                            Math.max(nameLabelFont.getSize2D(), 13f)));\n\n            if (contactForegroundColor != null)\n                nameLabel.setForeground(contactForegroundColor);\n\n            // Initializes status message components if the given meta contact\n            // contains a status message.\n            initDisplayDetails(contact.getDisplayDetails());\n\n            // Checks and set mobile indicator\n            if (contact.getDescriptor() instanceof MetaContact\n                && isMobile((MetaContact)contact.getDescriptor()))\n            {\n                nameLabel.setIcon(\n                        new ImageIcon(\n                                ImageLoader.getImage(\n                                        ImageLoader\n                                            .CONTACT_LIST_MOBILE_INDICATOR)));\n                nameLabel.setHorizontalTextPosition(SwingConstants.LEFT);\n            }\n\n            if (treeContactList.isContactButtonsVisible())\n                initButtonsPanel(contact);\n\n            int avatarWidth, avatarHeight;\n\n            if (isSelected && treeContactList.isContactButtonsVisible())\n            {\n                avatarWidth = EXTENDED_AVATAR_WIDTH;\n                avatarHeight = EXTENDED_AVATAR_HEIGHT;\n            }\n            else\n            {\n                avatarWidth = AVATAR_WIDTH;\n                avatarHeight = AVATAR_HEIGHT;\n            }\n\n            Icon avatar\n                = contact.getScaledAvatar(\n                        isSelected,\n                        avatarWidth, avatarHeight);\n\n            if (avatar != null)\n                rightLabel.setIcon(avatar);\n\n            if (contact instanceof ShowMoreContact)\n            {\n                rightLabel.setFont(rightLabel.getFont().deriveFont(12f));\n                rightLabel.setForeground(Color.GRAY);\n                rightLabel.setText((String)contact.getDescriptor());\n            }\n            else\n            {\n                rightLabel.setFont(rightLabel.getFont().deriveFont(9f));\n                rightLabel.setText(\"\");\n            }\n\n            setToolTipText(contact.getDescriptor().toString());\n        }\n        else if (value instanceof GroupNode)\n        {\n            UIGroupImpl groupItem\n                = ((GroupNode) value).getGroupDescriptor();\n\n            /*\n             * FIXME A hard-coded absolute font size is surely not appropriate\n             * because it is completely oblivious of the default system font\n             * size. A JLabel will very likely use the closest to the default\n             * system font (size) so there is no reason to specify any font size\n             * here, let alone a hard-coded absolute one. Anyway, use a\n             * hard-coded absolute font size but at least do not fall bellow the\n             * default system font size.\n             */\n            Font nameLabelFont = nameLabel.getFont();\n\n            nameLabel.setFont(\n                    nameLabelFont.deriveFont(\n                            Font.BOLD,\n                            Math.max(nameLabelFont.getSize2D(), 13f)));\n            nameLabel.setText(groupItem.getDisplayName());\n\n            if (groupForegroundColor != null)\n                nameLabel.setForeground(groupForegroundColor);\n\n            remove(displayDetailsLabel);\n            remove(callButton);\n            remove(callVideoButton);\n            remove(desktopSharingButton);\n            remove(chatButton);\n            remove(addContactButton);\n            remove(webButton);\n\n            clearCustomActionButtons();\n\n            statusIcon = expanded\n                                ? openedGroupIcon\n                                : closedGroupIcon;\n\n            if(groupItem != treeContactList.getRootUIGroup())\n            {\n                statusLabel.setIcon(\n                        expanded\n                            ? openedGroupIcon\n                            : closedGroupIcon);\n            }\n            else\n            {\n                statusLabel.setIcon(null);\n            }\n\n            // We have no photo icon for groups.\n            rightLabel.setIcon(null);\n            rightLabel.setText(\"\");\n\n            int groupItemCountChildContacts = groupItem.countChildContacts();\n\n            if (groupItemCountChildContacts >= 0)\n            {\n                rightLabel.setFont(rightLabel.getFont().deriveFont(9f));\n                rightLabel.setForeground(Color.BLACK);\n                rightLabel.setText(\n                        groupItem.countOnlineChildContacts() + \"/\"\n                            + groupItemCountChildContacts);\n            }\n\n            initDisplayDetails(groupItem.getDisplayDetails());\n            initButtonsPanel(groupItem);\n\n            Object groupItemDescriptor = groupItem.getDescriptor();\n\n            setToolTipText(\n                    (groupItemDescriptor != null)\n                        ? groupItemDescriptor.toString()\n                        : groupItem.getDisplayName());\n        }\n\n        return this;\n    }","id":91967,"modified_method":"/**\n     * Returns this panel that has been configured to display the meta contact\n     * and meta contact group cells.\n     *\n     * @param tree the source tree\n     * @param value the tree node\n     * @param selected indicates if the node is selected\n     * @param expanded indicates if the node is expanded\n     * @param leaf indicates if the node is a leaf\n     * @param row indicates the row number of the node\n     * @param hasFocus indicates if the node has the focus\n     * @return this panel\n     */\n    public Component getTreeCellRendererComponent(JTree tree, Object value,\n        boolean selected, boolean expanded, boolean leaf, int row,\n        boolean hasFocus)\n    {\n        this.treeContactList = (TreeContactList) tree;\n        this.row = row;\n        this.isSelected = selected;\n        this.treeNode = (TreeNode) value;\n\n        rightLabel.setIcon(null);\n\n        DefaultTreeContactList contactList = (DefaultTreeContactList) tree;\n\n        setBorder();\n        addLabels(1);\n\n        // Set background color.\n        if (contactList instanceof TreeContactList)\n        {\n            ContactListFilter filter\n                = ((TreeContactList) contactList).getCurrentFilter();\n\n            if (filter != null\n                && filter.equals(TreeContactList.historyFilter)\n                && value instanceof ContactNode\n                && row%2 == 0)\n            {\n                setBackground(Constants.CALL_HISTORY_EVEN_ROW_COLOR);\n            }\n            else\n            {\n                setBackground(Color.WHITE);\n            }\n        }\n\n        // clear icon if any (mobile indicator)\n        nameLabel.setIcon(null);\n\n        // Make appropriate adjustments for contact nodes and group nodes.\n        if (value instanceof ContactNode)\n        {\n            UIContactImpl contact\n                = ((ContactNode) value).getContactDescriptor();\n\n            if((contact.getDescriptor() instanceof SourceContact) &&\n                GuiActivator.getMUCService().isMUCSourceContact((SourceContact)contact.getDescriptor()))\n            {\n                setBackground(Constants.CHAT_ROOM_ROW_COLOR);\n            }\n            String displayName = contact.getDisplayName();\n\n            if ((displayName == null\n                || displayName.trim().length() < 1)\n                && !(contact instanceof ShowMoreContact))\n            {\n                displayName = GuiActivator.getResources()\n                    .getI18NString(\"service.gui.UNKNOWN\");\n            }\n\n            nameLabel.setText(displayName);\n\n            if(statusIcon != null\n                && contactList.isContactActive(contact)\n                && statusIcon instanceof ImageIcon)\n                ((ImageIcon) statusIcon).setImage(msgReceivedImage);\n            else\n                statusIcon = contact.getStatusIcon();\n\n            statusLabel.setIcon(statusIcon);\n\n            /*\n             * FIXME A hard-coded absolute font size is surely not appropriate\n             * because it is completely oblivious of the default system font\n             * size. A JLabel will very likely use the closest to the default\n             * system font (size) so there is no reason to specify any font size\n             * here, let alone a hard-coded absolute one. Anyway, use a\n             * hard-coded absolute font size but at least do not fall bellow the\n             * default system font size. On second thought, we are pretty sure\n             * that we are using the default system font on Windows and it makes\n             * no sense whatsoever to change its size.\n             */\n            Font nameLabelFont = nameLabel.getFont();\n\n            nameLabel.setFont(\n                    nameLabelFont.deriveFont(\n                            Font.PLAIN,\n                            Math.max(\n                                    nameLabelFont.getSize2D(),\n                                    OSUtils.IS_WINDOWS ? 0F : 13F)));\n\n            if (contactForegroundColor != null)\n                nameLabel.setForeground(contactForegroundColor);\n\n            // Initializes status message components if the given meta contact\n            // contains a status message.\n            initDisplayDetails(contact.getDisplayDetails());\n\n            // Checks and set mobile indicator\n            if (contact.getDescriptor() instanceof MetaContact\n                && isMobile((MetaContact)contact.getDescriptor()))\n            {\n                nameLabel.setIcon(\n                        new ImageIcon(\n                                ImageLoader.getImage(\n                                        ImageLoader\n                                            .CONTACT_LIST_MOBILE_INDICATOR)));\n                nameLabel.setHorizontalTextPosition(SwingConstants.LEFT);\n            }\n\n            if (treeContactList.isContactButtonsVisible())\n                initButtonsPanel(contact);\n\n            int avatarWidth, avatarHeight;\n\n            if (isSelected && treeContactList.isContactButtonsVisible())\n            {\n                avatarWidth = EXTENDED_AVATAR_WIDTH;\n                avatarHeight = EXTENDED_AVATAR_HEIGHT;\n            }\n            else\n            {\n                avatarWidth = AVATAR_WIDTH;\n                avatarHeight = AVATAR_HEIGHT;\n            }\n\n            Icon avatar\n                = contact.getScaledAvatar(\n                        isSelected,\n                        avatarWidth, avatarHeight);\n\n            if (avatar != null)\n                rightLabel.setIcon(avatar);\n\n            if (contact instanceof ShowMoreContact)\n            {\n                rightLabel.setFont(rightLabel.getFont().deriveFont(12f));\n                rightLabel.setForeground(Color.GRAY);\n                rightLabel.setText((String)contact.getDescriptor());\n            }\n            else\n            {\n                rightLabel.setFont(rightLabel.getFont().deriveFont(9f));\n                rightLabel.setText(\"\");\n            }\n\n            setToolTipText(contact.getDescriptor().toString());\n        }\n        else if (value instanceof GroupNode)\n        {\n            UIGroupImpl groupItem\n                = ((GroupNode) value).getGroupDescriptor();\n\n            /*\n             * FIXME A hard-coded absolute font size is surely not appropriate\n             * because it is completely oblivious of the default system font\n             * size. A JLabel will very likely use the closest to the default\n             * system font (size) so there is no reason to specify any font size\n             * here, let alone a hard-coded absolute one. Anyway, use a\n             * hard-coded absolute font size but at least do not fall bellow the\n             * default system font size. On second thought, we are pretty sure\n             * that we are using the default system font on Windows and it makes\n             * no sense whatsoever to change its size.\n             */\n            Font nameLabelFont = nameLabel.getFont();\n\n            nameLabel.setFont(\n                    nameLabelFont.deriveFont(\n                            Font.BOLD,\n                            Math.max(\n                                    nameLabelFont.getSize2D(),\n                                    OSUtils.IS_WINDOWS ? 0F : 13F)));\n            nameLabel.setText(groupItem.getDisplayName());\n\n            if (groupForegroundColor != null)\n                nameLabel.setForeground(groupForegroundColor);\n\n            remove(displayDetailsLabel);\n            remove(callButton);\n            remove(callVideoButton);\n            remove(desktopSharingButton);\n            remove(chatButton);\n            remove(addContactButton);\n            remove(webButton);\n\n            clearCustomActionButtons();\n\n            statusIcon = expanded\n                                ? openedGroupIcon\n                                : closedGroupIcon;\n\n            if(groupItem != treeContactList.getRootUIGroup())\n            {\n                statusLabel.setIcon(\n                        expanded\n                            ? openedGroupIcon\n                            : closedGroupIcon);\n            }\n            else\n            {\n                statusLabel.setIcon(null);\n            }\n\n            // We have no photo icon for groups.\n            rightLabel.setIcon(null);\n            rightLabel.setText(\"\");\n\n            int groupItemCountChildContacts = groupItem.countChildContacts();\n\n            if (groupItemCountChildContacts >= 0)\n            {\n                rightLabel.setFont(rightLabel.getFont().deriveFont(9f));\n                rightLabel.setForeground(Color.BLACK);\n                rightLabel.setText(\n                        groupItem.countOnlineChildContacts() + \"/\"\n                            + groupItemCountChildContacts);\n            }\n\n            initDisplayDetails(groupItem.getDisplayDetails());\n            initButtonsPanel(groupItem);\n\n            Object groupItemDescriptor = groupItem.getDescriptor();\n\n            setToolTipText(\n                    (groupItemDescriptor != null)\n                        ? groupItemDescriptor.toString()\n                        : groupItem.getDisplayName());\n        }\n\n        return this;\n    }","commit_id":"c98876d03cb00ca6efae66585907387ca95ca671","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Indicates if one of the contained components is currently the owner of\n     * the keyboard focus.\n     *\n     * @return <tt>true<\/tt> to indicate that a component contained in this\n     * container currently owns the keyboard focus, <tt>false<\/tt> - otherwise\n     */\n    public boolean containsFocus()\n    {\n        ChatPanel chat = getCurrentChat();\n\n        return\n            (chat != null)\n                && chat.getChatWritePanel().getEditorPane().isFocusOwner();\n    }","id":91968,"modified_method":"/**\n     * Indicates if one of the contained components is currently the owner of\n     * the keyboard focus.\n     *\n     * @return <tt>true<\/tt> to indicate that a component contained in this\n     * container currently owns the keyboard focus, <tt>false<\/tt> - otherwise\n     */\n    public boolean containsFocusOwner()\n    {\n        ChatPanel chat = getCurrentChat();\n\n        return\n            (chat != null)\n                && chat.getChatWritePanel().getEditorPane().isFocusOwner();\n    }","commit_id":"c98876d03cb00ca6efae66585907387ca95ca671","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void _restoreFocus() {\n    final List<FocusTrackback> stack = getCleanStack();\n\n    if (!stack.contains(this)) return;\n\n    Component toFocus = queryToFocus(stack, this);\n\n    if (toFocus != null) {\n      final Component ownerBySwing = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();\n      if (ownerBySwing != null) {\n        final Window ownerBySwingWindow = SwingUtilities.getWindowAncestor(ownerBySwing);\n        if (ownerBySwingWindow != null && ownerBySwingWindow == SwingUtilities.getWindowAncestor(toFocus)) {\n          toFocus = ownerBySwing;\n        }\n      }\n      toFocus.requestFocus();\n    }\n\n    stack.remove(this);\n    dispose();\n  }","id":91969,"modified_method":"private void _restoreFocus() {\n    final List<FocusTrackback> stack = getCleanStack();\n\n    if (!stack.contains(this)) return;\n\n    Component toFocus = queryToFocus(stack, this);\n\n    if (toFocus != null) {\n      final Component ownerBySwing = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();\n      if (ownerBySwing != null) {\n        final Window ownerBySwingWindow = SwingUtilities.getWindowAncestor(ownerBySwing);\n        if (ownerBySwingWindow != null && ownerBySwingWindow == SwingUtilities.getWindowAncestor(toFocus)) {\n          toFocus = ownerBySwing;\n        }\n      }\n\n      if (myParentWindow != null) {\n        final Window to = toFocus instanceof Window ? (Window) toFocus : SwingUtilities.getWindowAncestor(toFocus);\n        if (to == myParentWindow) {  // IDEADEV-34537\n          toFocus.requestFocus();\n        }\n      } else {\n        toFocus.requestFocus();\n      }\n    }\n\n    stack.remove(this);\n    dispose();\n  }","commit_id":"e85a13f93ec8652babd23f3ead33644b024147b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JComponent getComponent() {\n    if (myComponent == null) {\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          tryToInitComponent();\n        }\n      });\n      Project project = MPSDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext());\n      ToolWindowManager.getInstance(project).getFocusManager().requestFocus(myComponent, false);\n    }\n\n    if (myComponent == null) return null;\n\n    return myComponent.getExternalComponent();\n  }","id":91970,"modified_method":"public JComponent getComponent() {\n    if (myComponent == null) {\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          tryToInitComponent();\n        }\n      });\n\n      if (myComponent!=null){\n        Project project = MPSDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext());\n        ToolWindowManager.getInstance(project).getFocusManager().requestFocus(myComponent, false);\n      }\n    }\n\n    if (myComponent == null) return null;\n\n    return myComponent.getExternalComponent();\n  }","commit_id":"d27b1c985846db885e0dda3c8942b4ad8c58cc79","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n\tpublic void execute() throws BuildException {\n\t\tif (_property == null) {\n\t\t\tthrow new BuildException(\n\t\t\t\t\"Property attribute is required\", getLocation());\n\t\t}\n\n\t\tif (_path == null) {\n\t\t\tthrow new BuildException(\n\t\t\t\t\"Path attribute is required\", getLocation());\n\t\t}\n\n\t\tif (_gitDir == null) {\n\t\t\tProject currentProject = getProject();\n\n\t\t\t_gitDir = currentProject.getBaseDir();\n\t\t}\n\n\t\tFileRepositoryBuilder fileRepositoryBuilder =\n\t\t\tnew FileRepositoryBuilder();\n\n\t\tfileRepositoryBuilder.readEnvironment();\n\n\t\tfileRepositoryBuilder.findGitDir(_gitDir);\n\n\t\tString relativePath = PathUtil.toRelativePath(\n\t\t\tfileRepositoryBuilder.getGitDir(), _path);\n\n\t\ttry {\n\t\t\tRepository repository = fileRepositoryBuilder.build();\n\n\t\t\tRevWalk revWalk = new RevWalk(repository);\n\n\t\t\tRevCommit headRevCommit = revWalk.lookupCommit(\n\t\t\t\trepository.resolve(Constants.HEAD));\n\n\t\t\trevWalk.markStart(headRevCommit);\n\t\t\trevWalk.setRevFilter(MaxCountRevFilter.create(2));\n\t\t\trevWalk.setTreeFilter(\n\t\t\t\tAndTreeFilter.create(\n\t\t\t\t\tPathFilter.create(relativePath), TreeFilter.ANY_DIFF\n\t\t\t\t));\n\n\t\t\tIterator<RevCommit> iterator = revWalk.iterator();\n\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tRevCommit revCommit = iterator.next();\n\n\t\t\t\tTreeWalk treeWalk = new TreeWalk(repository);\n\n\t\t\t\ttreeWalk.addTree(revCommit.getTree());\n\t\t\t\ttreeWalk.setRecursive(true);\n\t\t\t\ttreeWalk.setFilter(\n\t\t\t\t\tAndTreeFilter.create(\n\t\t\t\t\t\tPathFilter.create(relativePath + \"/\" + _ignoreFileName),\n\t\t\t\t\t\tTreeFilter.ANY_DIFF));\n\n\t\t\t\tif (!treeWalk.next()) {\n\t\t\t\t\tProject currentProject = getProject();\n\n\t\t\t\t\tcurrentProject.setNewProperty(_property, revCommit.name());\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trevWalk.dispose();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new BuildException(\n\t\t\t\t\"Unable to get head hash for path \" + _path, e);\n\t\t}\n\t}","id":91971,"modified_method":"@Override\n\tpublic void execute() throws BuildException {\n\t\tif (_property == null) {\n\t\t\tthrow new BuildException(\n\t\t\t\t\"Property attribute is required\", getLocation());\n\t\t}\n\n\t\tif (_path == null) {\n\t\t\tthrow new BuildException(\n\t\t\t\t\"Path attribute is required\", getLocation());\n\t\t}\n\n\t\tif (_gitDir == null) {\n\t\t\tProject currentProject = getProject();\n\n\t\t\t_gitDir = currentProject.getBaseDir();\n\t\t}\n\n\t\tFileRepositoryBuilder fileRepositoryBuilder =\n\t\t\tnew FileRepositoryBuilder();\n\n\t\tfileRepositoryBuilder.readEnvironment();\n\n\t\tfileRepositoryBuilder.findGitDir(_gitDir);\n\n\t\tString relativePath = PathUtil.toRelativePath(\n\t\t\tfileRepositoryBuilder.getGitDir(), _path);\n\n\t\ttry {\n\t\t\tRepository repository = fileRepositoryBuilder.build();\n\n\t\t\tRevWalk revWalk = new RevWalk(repository);\n\n\t\t\tRevCommit headRevCommit = revWalk.lookupCommit(\n\t\t\t\trepository.resolve(Constants.HEAD));\n\n\t\t\trevWalk.markStart(headRevCommit);\n\t\t\trevWalk.setRevFilter(MaxCountRevFilter.create(2));\n\t\t\trevWalk.setTreeFilter(\n\t\t\t\tAndTreeFilter.create(\n\t\t\t\t\tPathFilter.create(relativePath), TreeFilter.ANY_DIFF\n\t\t\t\t));\n\n\t\t\tIterator<RevCommit> iterator = revWalk.iterator();\n\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tRevCommit revCommit = iterator.next();\n\n\t\t\t\tTreeWalk treeWalk = new TreeWalk(repository);\n\n\t\t\t\ttreeWalk.addTree(revCommit.getTree());\n\t\t\t\ttreeWalk.setRecursive(true);\n\n\t\t\t\tif (_ignoreFileName != null) {\n\t\t\t\t\ttreeWalk.setFilter(\n\t\t\t\t\t\tAndTreeFilter.create(\n\t\t\t\t\t\t\tPathFilter.create(\n\t\t\t\t\t\t\t\trelativePath + \"/\" + _ignoreFileName),\n\t\t\t\t\t\t\tTreeFilter.ANY_DIFF));\n\t\t\t\t}\n\n\t\t\t\tif (!treeWalk.next()) {\n\t\t\t\t\tProject currentProject = getProject();\n\n\t\t\t\t\tcurrentProject.setNewProperty(_property, revCommit.name());\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trevWalk.dispose();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new BuildException(\n\t\t\t\t\"Unable to get head hash for path \" + _path, e);\n\t\t}\n\t}","commit_id":"e402af207a54fc639d8a4fcf454f20dc295b710c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public RegionScanner preScannerOpen(ObserverContext<RegionCoprocessorEnvironment> e, Scan scan, RegionScanner s)\n    throws IOException {\n    byte[] consumerConfigAttr = scan.getAttribute(ATTR_CONSUMER_CONFIG);\n    byte[] txAttr = scan.getAttribute(ATTR_TX);\n    byte[] queueName = scan.getAttribute(ATTR_QUEUE_NAME);\n    if (consumerConfigAttr == null || txAttr == null || queueName == null) {\n      return super.preScannerOpen(e, scan, s);\n    }\n\n    ConsumerConfig consumerConfig = bytesToConsumerConfig(consumerConfigAttr);\n    Transaction tx = bytesToTx(txAttr);\n    Filter dequeueFilter = new DequeueFilter(queueName, consumerConfig, tx);\n\n    Filter existing = scan.getFilter();\n    Filter combined = new FilterList(FilterList.Operator.MUST_PASS_ALL, existing, dequeueFilter);\n    scan.setFilter(combined);\n\n    return super.preScannerOpen(e, scan, s);\n  }","id":91972,"modified_method":"@Override\n  public RegionScanner preScannerOpen(ObserverContext<RegionCoprocessorEnvironment> e, Scan scan, RegionScanner s)\n    throws IOException {\n    ConsumerConfig consumerConfig = DequeueScanAttributes.getConsumerConfig(scan);\n    Transaction tx = DequeueScanAttributes.getTx(scan);\n    byte[] queueName = DequeueScanAttributes.getQueueName(scan);\n\n    if (consumerConfig == null || tx == null || queueName == null) {\n      return super.preScannerOpen(e, scan, s);\n    }\n\n    Filter dequeueFilter = new DequeueFilter(queueName, consumerConfig, tx);\n\n    Filter existing = scan.getFilter();\n    if (existing != null) {\n      Filter combined = new FilterList(FilterList.Operator.MUST_PASS_ALL, existing, dequeueFilter);\n      scan.setFilter(combined);\n    } else {\n      scan.setFilter(dequeueFilter);\n    }\n\n    return super.preScannerOpen(e, scan, s);\n  }","commit_id":"b2dccea2bb5fedc66cbfbbc26b06b9df2f9ae351","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected QueueScanner getScanner(byte[] startRow, byte[] stopRow, int numRows) throws IOException {\n    // Scan the table for queue entries.\n    Scan scan = new Scan();\n    scan.setCaching(numRows);\n    scan.setStartRow(startRow);\n    scan.setStopRow(stopRow);\n    scan.addColumn(QueueEntryRow.COLUMN_FAMILY, QueueEntryRow.DATA_COLUMN);\n    scan.addColumn(QueueEntryRow.COLUMN_FAMILY, QueueEntryRow.META_COLUMN);\n    scan.addColumn(QueueEntryRow.COLUMN_FAMILY, stateColumnName);\n    scan.setFilter(createFilter());\n    scan.setMaxVersions(1);\n\n    DequeueScanObserver.setAttributes(scan, getQueueName(), getConfig(), transaction);\n\n    ResultScanner scanner = hTable.getScanner(scan);\n    return new HBaseQueueScanner(scanner, numRows);\n  }","id":91973,"modified_method":"@Override\n  protected QueueScanner getScanner(byte[] startRow, byte[] stopRow, int numRows) throws IOException {\n    // Scan the table for queue entries.\n    Scan scan = new Scan();\n    scan.setCaching(numRows);\n    scan.setStartRow(startRow);\n    scan.setStopRow(stopRow);\n    scan.addColumn(QueueEntryRow.COLUMN_FAMILY, QueueEntryRow.DATA_COLUMN);\n    scan.addColumn(QueueEntryRow.COLUMN_FAMILY, QueueEntryRow.META_COLUMN);\n    scan.addColumn(QueueEntryRow.COLUMN_FAMILY, stateColumnName);\n    scan.setFilter(createFilter());\n    scan.setMaxVersions(1);\n\n    DequeueScanAttributes.set(scan, getQueueName());\n    DequeueScanAttributes.set(scan, getConfig());\n    DequeueScanAttributes.set(scan, transaction);\n\n    ResultScanner scanner = hTable.getScanner(scan);\n    return new HBaseQueueScanner(scanner, numRows);\n  }","commit_id":"b2dccea2bb5fedc66cbfbbc26b06b9df2f9ae351","url":"https://github.com/caskdata/cdap"},{"original_method":"public void stop () {\n\t\tif (!running) return;\n\t\trunning = false;\n\t\tGdx.graphics = graphics;\n\t\tlistener.pause();\n\t\tlistener.dispose();\n\t}","id":91974,"modified_method":"public void stop () {\n\t\tif (!running) return;\n\t\trunning = false;\n\t\tsetGlobals();\n\t\tlistener.pause();\n\t\tlistener.dispose();\n\t}","commit_id":"c8f90216809b1760b5d2513b80576887fa1cb98c","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void render () {\n\t\tGdx.graphics = graphics;\n\t\tGdx.input = input;\n\t\tcanvas.setCursor(null);\n\t\tgraphics.updateTime();\n\t\tsynchronized (runnables) {\n\t\t\tfor (int i = 0; i < runnables.size(); i++) {\n\t\t\t\ttry {\n\t\t\t\t\trunnables.get(i).run();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tt.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\trunnables.clear();\n\t\t}\n\t\tinput.update();\n\n\t\tint width = Math.max(1, graphics.getWidth());\n\t\tint height = Math.max(1, graphics.getHeight());\n\t\tif (lastWidth != width || lastHeight != height) {\n\t\t\tlastWidth = width;\n\t\t\tlastHeight = height;\n\t\t\tGdx.gl.glViewport(0, 0, lastWidth, lastHeight);\n\t\t\tresize(width, height);\n\t\t\tlistener.resize(width, height);\n\t\t}\n\t\tinput.processEvents();\n\t\tlistener.render();\n\t\tif (audio != null) {\n\t\t\taudio.update();\n\t\t}\n\t}","id":91975,"modified_method":"private void render () {\n\t\tsetGlobals();\n\t\tcanvas.setCursor(null);\n\t\tgraphics.updateTime();\n\t\tsynchronized (runnables) {\n\t\t\tfor (int i = 0; i < runnables.size(); i++) {\n\t\t\t\ttry {\n\t\t\t\t\trunnables.get(i).run();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tt.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\trunnables.clear();\n\t\t}\n\t\tinput.update();\n\n\t\tint width = Math.max(1, graphics.getWidth());\n\t\tint height = Math.max(1, graphics.getHeight());\n\t\tif (lastWidth != width || lastHeight != height) {\n\t\t\tlastWidth = width;\n\t\t\tlastHeight = height;\n\t\t\tGdx.gl.glViewport(0, 0, lastWidth, lastHeight);\n\t\t\tresize(width, height);\n\t\t\tlistener.resize(width, height);\n\t\t}\n\t\tinput.processEvents();\n\t\tlistener.render();\n\t\tif (audio != null) {\n\t\t\taudio.update();\n\t\t}\n\t}","commit_id":"c8f90216809b1760b5d2513b80576887fa1cb98c","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void exit () {\n\t\tpostRunnable(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run () {\n\t\t\t\tGdx.graphics = graphics;\n\t\t\t\tLwjglAWTCanvas.this.listener.pause();\n\t\t\t\tLwjglAWTCanvas.this.listener.dispose();\n\t\t\t\tSystem.exit(-1);\n\t\t\t}\n\t\t});\n\t}","id":91976,"modified_method":"@Override\n\tpublic void exit () {\n\t\tpostRunnable(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run () {\n\t\t\t\tsetGlobals();\n\t\t\t\tLwjglAWTCanvas.this.listener.pause();\n\t\t\t\tLwjglAWTCanvas.this.listener.dispose();\n\t\t\t\tSystem.exit(-1);\n\t\t\t}\n\t\t});\n\t}","commit_id":"c8f90216809b1760b5d2513b80576887fa1cb98c","url":"https://github.com/libgdx/libgdx"},{"original_method":"void start () {\n\t\ttry {\n\t\t\tGdx.graphics = graphics;\n\t\t\tgraphics.initiateGLInstances();\n\t\t\tlistener.create();\n\t\t\tlastWidth = Math.max(1, graphics.getWidth());\n\t\t\tlastHeight = Math.max(1, graphics.getHeight());\n\t\t\tlistener.resize(lastWidth, lastHeight);\n\t\t} catch (Exception ex) {\n\t\t\tstopped();\n\t\t\tthrow new GdxRuntimeException(ex);\n\t\t}\n\t}","id":91977,"modified_method":"void start () {\n\t\ttry {\n\t\t\tsetGlobals();\n\t\t\tgraphics.initiateGLInstances();\n\t\t\tlistener.create();\n\t\t\tlastWidth = Math.max(1, graphics.getWidth());\n\t\t\tlastHeight = Math.max(1, graphics.getHeight());\n\t\t\tlistener.resize(lastWidth, lastHeight);\n\t\t} catch (Exception ex) {\n\t\t\tstopped();\n\t\t\tthrow new GdxRuntimeException(ex);\n\t\t}\n\t}","commit_id":"c8f90216809b1760b5d2513b80576887fa1cb98c","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\t\tpublic void create () {\r\n\t\t\tmesh = ModelLoaderOld.loadObj(Gdx.files.internal(\"data/cube.obj\").read());\r\n\t\t\tGdx.app.log(\"ObjTest\", \"obj bounds: \" + mesh.calculateBoundingBox());\r\n\t\t\ttexture = new Texture(Gdx.files.internal(\"data/badlogic.jpg\"), true);\r\n\t\t\ttexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\r\n\t\t\tcam = new PerspectiveCamera(45, 4, 4);\r\n\t\t\tcam.position.set(3, 3, 3);\r\n\t\t\tcam.direction.set(-1, -1, -1);\r\n\t\t\tGdx.input.setInputProcessor(this);\r\n\t\t}","id":91978,"modified_method":"@Override\r\n\t\tpublic void create () {\r\n\t\t\tif(mesh == null) {\r\n\t\t\t\tmesh = ModelLoaderOld.loadObj(Gdx.files.internal(\"data/cube.obj\").read());\r\n\t\t\t\tGdx.app.log(\"ObjTest\", \"obj bounds: \" + mesh.calculateBoundingBox());\r\n\t\t\t\ttexture = new Texture(Gdx.files.internal(\"data/badlogic.jpg\"), true);\r\n\t\t\t\ttexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\t\t\t}\r\n\r\n\t\t\tcam = new PerspectiveCamera(45, 4, 4);\r\n\t\t\tcam.position.set(3, 3, 3);\r\n\t\t\tcam.direction.set(-1, -1, -1);\r\n\t\t\tGdx.input.setInputProcessor(this);\r\n\t\t}","commit_id":"c8f90216809b1760b5d2513b80576887fa1cb98c","url":"https://github.com/libgdx/libgdx"},{"original_method":"private ColumnDefinition(ByteBuffer name, AbstractType<?> validator, IndexType index_type, Map<String, String> index_options, String index_name, Integer componentIndex, Type type)\n    {\n        assert name != null && validator != null;\n        this.name = name;\n        this.index_name = index_name;\n        this.validator = validator;\n        this.componentIndex = componentIndex;\n        this.setIndexType(index_type, index_options);\n        this.type = type;\n    }","id":91979,"modified_method":"@VisibleForTesting\n    public ColumnDefinition(ByteBuffer name, AbstractType<?> validator, IndexType index_type, Map<String, String> index_options, String index_name, Integer componentIndex, Type type)\n    {\n        assert name != null && validator != null;\n        this.name = name;\n        this.index_name = index_name;\n        this.validator = validator;\n        this.componentIndex = componentIndex;\n        this.setIndexType(index_type, index_options);\n        this.type = type;\n    }","commit_id":"6afbed371c0d12a15a969e4f52ba670998bab282","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n        public void truncate(long truncatedAt)\n        {\n        }","id":91980,"modified_method":"@Override\n        public void truncateBlocking(long truncatedAt)\n        {\n        }","commit_id":"6afbed371c0d12a15a969e4f52ba670998bab282","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n        public void index(ByteBuffer rowKey)\n        {\n            QueryFilter filter = QueryFilter.getIdentityFilter(DatabaseDescriptor.getPartitioner().decorateKey(rowKey),\n                                                               new QueryPath(baseCfs.getColumnFamilyName()));\n            LAST_INDEXED_ROW = baseCfs.getColumnFamily(filter);\n        }","id":91981,"modified_method":"@Override\n        public void index(ByteBuffer rowKey)\n        {\n            QueryFilter filter = QueryFilter.getIdentityFilter(DatabaseDescriptor.getPartitioner().decorateKey(rowKey),\n                                                               baseCfs.getColumnFamilyName());\n            LAST_INDEXED_ROW = baseCfs.getColumnFamily(filter);\n        }","commit_id":"6afbed371c0d12a15a969e4f52ba670998bab282","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testIndexInsertAndUpdate() throws IOException\n    {\n        // create a row then test that the configured index instance was able to read the row\n        RowMutation rm;\n        rm = new RowMutation(\"PerRowSecondaryIndex\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"indexed\")), ByteBufferUtil.bytes(\"foo\"), 1);\n        rm.apply();\n\n        ColumnFamily indexedRow = TestIndex.LAST_INDEXED_ROW;\n        assertNotNull(indexedRow);\n        assertEquals(ByteBufferUtil.bytes(\"foo\"), indexedRow.getColumn(ByteBufferUtil.bytes(\"indexed\")).value());\n\n        // update the row and verify what was indexed\n        rm = new RowMutation(\"PerRowSecondaryIndex\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"indexed\")), ByteBufferUtil.bytes(\"bar\"), 2);\n        rm.apply();\n\n        indexedRow = TestIndex.LAST_INDEXED_ROW;\n        assertNotNull(indexedRow);\n        assertEquals(ByteBufferUtil.bytes(\"bar\"), indexedRow.getColumn(ByteBufferUtil.bytes(\"indexed\")).value());\n    }","id":91982,"modified_method":"@Test\n    public void testIndexInsertAndUpdate() throws IOException\n    {\n        // create a row then test that the configured index instance was able to read the row\n        RowMutation rm;\n        rm = new RowMutation(\"PerRowSecondaryIndex\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(\"Indexed1\", ByteBufferUtil.bytes(\"indexed\"), ByteBufferUtil.bytes(\"foo\"), 1);\n        rm.apply();\n\n        ColumnFamily indexedRow = TestIndex.LAST_INDEXED_ROW;\n        assertNotNull(indexedRow);\n        assertEquals(ByteBufferUtil.bytes(\"foo\"), indexedRow.getColumn(ByteBufferUtil.bytes(\"indexed\")).value());\n\n        // update the row and verify what was indexed\n        rm = new RowMutation(\"PerRowSecondaryIndex\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(\"Indexed1\", ByteBufferUtil.bytes(\"indexed\"), ByteBufferUtil.bytes(\"bar\"), 2);\n        rm.apply();\n\n        indexedRow = TestIndex.LAST_INDEXED_ROW;\n        assertNotNull(indexedRow);\n        assertEquals(ByteBufferUtil.bytes(\"bar\"), indexedRow.getColumn(ByteBufferUtil.bytes(\"indexed\")).value());\n    }","commit_id":"6afbed371c0d12a15a969e4f52ba670998bab282","url":"https://github.com/apache/cassandra"},{"original_method":"private static CFMetaData perRowIndexedCFMD(String ksName, String cfName, boolean withOldCfIds)\n    {\n        final Map<String, String> indexOptions = Collections.singletonMap(\n                                                      SecondaryIndex.CUSTOM_INDEX_OPTION_NAME,\n                                                      PerRowSecondaryIndexTest.TestIndex.class.getName());\n        return standardCFMD(ksName, cfName, withOldCfIds)\n                .keyValidator(AsciiType.instance)\n                .columnMetadata(new HashMap<ByteBuffer, ColumnDefinition>()\n                {{\n                        ByteBuffer cName = ByteBuffer.wrap(\"indexed\".getBytes(Charsets.UTF_8));\n                        put(cName, new ColumnDefinition(cName,\n                                AsciiType.instance,\n                                IndexType.CUSTOM,\n                                indexOptions,\n                                ByteBufferUtil.bytesToHex(cName),\n                                null));\n                    }});\n    }","id":91983,"modified_method":"private static CFMetaData perRowIndexedCFMD(String ksName, String cfName, boolean withOldCfIds)\n    {\n        final Map<String, String> indexOptions = Collections.singletonMap(\n                                                      SecondaryIndex.CUSTOM_INDEX_OPTION_NAME,\n                                                      PerRowSecondaryIndexTest.TestIndex.class.getName());\n        return standardCFMD(ksName, cfName, withOldCfIds)\n                .keyValidator(AsciiType.instance)\n                .columnMetadata(new HashMap<ByteBuffer, ColumnDefinition>()\n                {{\n                        ByteBuffer cName = ByteBuffer.wrap(\"indexed\".getBytes(Charsets.UTF_8));\n                        put(cName, new ColumnDefinition(cName,\n                                AsciiType.instance,\n                                IndexType.CUSTOM,\n                                indexOptions,\n                                ByteBufferUtil.bytesToHex(cName),\n                                null, ColumnDefinition.Type.REGULAR));\n                    }});\n    }","commit_id":"6afbed371c0d12a15a969e4f52ba670998bab282","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testRowDelete() throws IOException\n    {\n        // issue a row level delete and test that the configured index instance was notified to update\n        RowMutation rm;\n        rm = new RowMutation(\"PerRowSecondaryIndex\", ByteBufferUtil.bytes(\"k3\"));\n        rm.delete(new QueryPath(\"Indexed1\"), 1);\n        rm.apply();\n\n        ColumnFamily indexedRow = TestIndex.LAST_INDEXED_ROW;\n        assertNotNull(indexedRow);\n        for (IColumn column : indexedRow.getSortedColumns())\n        {\n            assertTrue(column.isMarkedForDelete());\n        }\n        assertTrue(Arrays.equals(\"k3\".getBytes(), TestIndex.LAST_INDEXED_KEY.array()));\n    }","id":91984,"modified_method":"@Test\n    public void testRowDelete() throws IOException\n    {\n        // issue a row level delete and test that the configured index instance was notified to update\n        RowMutation rm;\n        rm = new RowMutation(\"PerRowSecondaryIndex\", ByteBufferUtil.bytes(\"k3\"));\n        rm.delete(\"Indexed1\", 1);\n        rm.apply();\n\n        ColumnFamily indexedRow = TestIndex.LAST_INDEXED_ROW;\n        assertNotNull(indexedRow);\n        for (Column column : indexedRow.getSortedColumns())\n        {\n            assertTrue(column.isMarkedForDelete());\n        }\n        assertTrue(Arrays.equals(\"k3\".getBytes(), TestIndex.LAST_INDEXED_KEY.array()));\n    }","commit_id":"162675983c0a41edd29220e6cbc061f04830142b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testColumnDelete() throws IOException\n    {\n        // issue a column delete and test that the configured index instance was notified to update\n        RowMutation rm;\n        rm = new RowMutation(\"PerRowSecondaryIndex\", ByteBufferUtil.bytes(\"k2\"));\n        rm.delete(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"indexed\")), 1);\n        rm.apply();\n\n        ColumnFamily indexedRow = TestIndex.LAST_INDEXED_ROW;\n        assertNotNull(indexedRow);\n\n        for (IColumn column : indexedRow.getSortedColumns())\n        {\n            assertTrue(column.isMarkedForDelete());\n        }\n        assertTrue(Arrays.equals(\"k2\".getBytes(), TestIndex.LAST_INDEXED_KEY.array()));\n    }","id":91985,"modified_method":"@Test\n    public void testColumnDelete() throws IOException\n    {\n        // issue a column delete and test that the configured index instance was notified to update\n        RowMutation rm;\n        rm = new RowMutation(\"PerRowSecondaryIndex\", ByteBufferUtil.bytes(\"k2\"));\n        rm.delete(\"Indexed1\", ByteBufferUtil.bytes(\"indexed\"), 1);\n        rm.apply();\n\n        ColumnFamily indexedRow = TestIndex.LAST_INDEXED_ROW;\n        assertNotNull(indexedRow);\n\n        for (Column column : indexedRow.getSortedColumns())\n        {\n            assertTrue(column.isMarkedForDelete());\n        }\n        assertTrue(Arrays.equals(\"k2\".getBytes(), TestIndex.LAST_INDEXED_KEY.array()));\n    }","commit_id":"162675983c0a41edd29220e6cbc061f04830142b","url":"https://github.com/apache/cassandra"},{"original_method":"public void update(Column oldColumn, Column column)\n        {\n            for (SecondaryIndex index : indexFor(column.name()))\n            {\n                ((PerColumnSecondaryIndex) index).delete(key.key, oldColumn);\n                if (!column.isMarkedForDelete())\n                    ((PerColumnSecondaryIndex) index).insert(key.key, column);\n            }\n        }","id":91986,"modified_method":"public void update(Column oldColumn, Column column)\n        {\n            for (SecondaryIndex index : indexFor(column.name()))\n            {\n                if (index instanceof PerColumnSecondaryIndex)\n                {\n                    ((PerColumnSecondaryIndex) index).delete(key.key, oldColumn);\n                    if (!column.isMarkedForDelete())\n                        ((PerColumnSecondaryIndex) index).insert(key.key, column);\n                }\n            }\n        }","commit_id":"162675983c0a41edd29220e6cbc061f04830142b","url":"https://github.com/apache/cassandra"},{"original_method":"public void configure(FlowSpecifier specifier) {\n    specifier.name(\"CountAndFilterWords\");\n    specifier.email(\"me@continuuity.com\");\n    specifier.application(\"End2End\");\n    specifier.stream(\"text\");\n    specifier.flowlet(\"source\", StreamSource.class, 1);\n    specifier.flowlet(\"split-words\", Tokenizer.class, 1);\n    specifier.flowlet(\"upper-filter\", UpperCaseFilter.class, 1);\n    specifier.flowlet(\"count-all\", CountByField.class, 1);\n    specifier.flowlet(\"count-upper\", CountByField.class, 1);\n    specifier.input(\"text\", \"source\");\n    specifier.connection(\"source\", \"split-words\");\n    specifier.connection(\"split-words\", \"count-all\");\n    specifier.connection(\"split-words\", \"upper-filter\");\n    specifier.connection(\"upper-filter\", \"count-upper\");\n  }","id":91987,"modified_method":"public void configure(FlowSpecifier specifier) {\n    specifier.name(\"CountAndFilterWords\");\n    specifier.email(\"me@continuuity.com\");\n    specifier.application(\"End2End\");\n    specifier.stream(\"text\");\n    specifier.dataset(Common.counterTableName);\n    specifier.flowlet(\"source\", StreamSource.class, 1);\n    specifier.flowlet(\"split-words\", Tokenizer.class, 1);\n    specifier.flowlet(\"upper-filter\", UpperCaseFilter.class, 1);\n    specifier.flowlet(\"count-all\", CountByField.class, 1);\n    specifier.flowlet(\"count-upper\", CountByField.class, 1);\n    specifier.input(\"text\", \"source\");\n    specifier.connection(\"source\", \"split-words\");\n    specifier.connection(\"split-words\", \"count-all\");\n    specifier.connection(\"split-words\", \"upper-filter\");\n    specifier.connection(\"upper-filter\", \"count-upper\");\n  }","commit_id":"257a9f736f1996b4a9311e619cd910f02df2bc79","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void process(Tuple tuple, TupleContext tupleContext, OutputCollector outputCollector) {\n    if (Common.debug)\n      System.out.println(this.getClass().getSimpleName() + \": Received tuple \" + tuple);\n\n    String token = tuple.get(\"word\");\n    if (token == null) return;\n    String field = tuple.get(\"field\");\n    if (field != null) token = field + \":\" + token;\n\n    if (Common.debug)\n      System.out.println(this.getClass().getSimpleName() + \": Emitting Increment for \" + token);\n    outputCollector.add(new Increment(token.getBytes(), 1));\n  }","id":91988,"modified_method":"@Override\n  public void process(Tuple tuple, TupleContext tupleContext, OutputCollector outputCollector) {\n    if (Common.debug) {\n      System.out.println(this.getClass().getSimpleName() + \": Received tuple \" + tuple);\n    }\n\n    String token = tuple.get(\"word\");\n    if (token == null) return;\n    String field = tuple.get(\"field\");\n    if (field != null) token = field + \":\" + token;\n\n    if (Common.debug) {\n      System.out.println(this.getClass().getSimpleName() + \": Incrementing for \" + token);\n    }\n    this.counters.stage(new KeyValueTable.IncrementKey(token.getBytes()));\n  }","commit_id":"257a9f736f1996b4a9311e619cd910f02df2bc79","url":"https://github.com/caskdata/cdap"},{"original_method":"public void configure(FlowSpecifier specifier) {\n    specifier.name(\"CountCounts\");\n    specifier.email(\"andreas@continuuity.com\");\n    specifier.application(\"Examples\");\n    specifier.flowlet(\"source\", StreamSource.class, 1);\n    specifier.flowlet(\"count\", WordCounter.class, 1);\n    specifier.flowlet(\"tick\", Incrementer.class, 1);\n    specifier.input(\"text\", \"source\");\n    specifier.connection(\"source\", \"count\");\n    specifier.connection(\"count\", \"tick\");\n  }","id":91989,"modified_method":"public void configure(FlowSpecifier specifier) {\n    specifier.name(\"CountCounts\");\n    specifier.email(\"andreas@continuuity.com\");\n    specifier.stream(\"text\");\n    specifier.dataset(Common.tableName);\n    specifier.application(\"Examples\");\n    specifier.flowlet(\"source\", StreamSource.class, 1);\n    specifier.flowlet(\"count\", WordCounter.class, 1);\n    specifier.flowlet(\"tick\", Incrementer.class, 1);\n    specifier.input(\"text\", \"source\");\n    specifier.connection(\"source\", \"count\");\n    specifier.connection(\"count\", \"tick\");\n  }","commit_id":"257a9f736f1996b4a9311e619cd910f02df2bc79","url":"https://github.com/caskdata/cdap"},{"original_method":"public void configure(FlowSpecifier specifier) {\n    specifier.name(\"CountRandom\");\n    specifier.email(\"me@continuuity.com\");\n    specifier.application(\"CountRandom\");\n    specifier.flowlet(\"gen\", RandomSource.class, 1);\n    specifier.flowlet(\"split\", NumberSplitter.class, 1);\n    specifier.flowlet(\"count\", NumberCounter.class, 1);\n    specifier.connection(\"gen\", \"split\");\n    specifier.connection(\"split\", \"count\");\n  }","id":91990,"modified_method":"public void configure(FlowSpecifier specifier) {\n    specifier.name(\"CountRandom\");\n    specifier.email(\"me@continuuity.com\");\n    specifier.dataset(\"counters\");\n    specifier.application(\"CountRandom\");\n    specifier.flowlet(\"gen\", RandomSource.class, 1);\n    specifier.flowlet(\"split\", NumberSplitter.class, 1);\n    specifier.flowlet(\"count\", NumberCounter.class, 1);\n    specifier.connection(\"gen\", \"split\");\n    specifier.connection(\"split\", \"count\");\n  }","commit_id":"257a9f736f1996b4a9311e619cd910f02df2bc79","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void process(Tuple tuple, TupleContext tupleContext, OutputCollector outputCollector) {\n    if (Common.debug)\n      System.out.println(this.getClass().getSimpleName() + \": Received tuple \" + tuple);\n\n    Integer count = tuple.get(\"count\");\n    if (count == null) return;\n    String key = Integer.toString(count);\n\n    if (Common.debug)\n      System.out.println(this.getClass().getSimpleName() + \": Emitting \" +\n          \"Increment for \" + key);\n\n    // emit an increment for the number of words in this document\n    Increment increment = new Increment(key.getBytes(), 1);\n    outputCollector.add(increment);\n\n    if (Common.count) {\n      // emit an increment for the total number of documents counted\n      increment = new Increment(keyTotal, 1);\n      outputCollector.add(increment);\n    }\n  }","id":91991,"modified_method":"@Override\n  public void process(Tuple tuple, TupleContext tupleContext, OutputCollector outputCollector) {\n    if (Common.debug) {\n      System.out.println(this.getClass().getSimpleName() + \": Received tuple \" + tuple);\n    }\n    Integer count = tuple.get(\"count\");\n    if (count == null) {\n      return;\n    }\n    String key = Integer.toString(count);\n\n    if (Common.debug) {\n      System.out.println(this.getClass().getSimpleName() + \": Emitting \" +\n          \"Increment for \" + key);\n    }\n    // emit an increment for the number of words in this document\n    this.counters.increment(key);\n\n    if (Common.count) {\n      // emit an increment for the total number of documents counted\n      this.counters.increment(keyTotal);\n    }\n  }","commit_id":"257a9f736f1996b4a9311e619cd910f02df2bc79","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.builder()\n      .addFlow(CountAndFilterWords.class)\n      .addStream(new Stream(\"text\"))\n      .create();\n  }","id":91992,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.builder()\n      .addFlow(CountAndFilterWords.class)\n      .addStream(new Stream(\"text\"))\n      .addDataSet(new KeyValueTable(Common.counterTableName))\n      .create();\n  }","commit_id":"257a9f736f1996b4a9311e619cd910f02df2bc79","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.builder()\n      .addFlow(CountCounts.class)\n      .addStream(new Stream(\"test\"))\n      .create();\n  }","id":91993,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.builder()\n      .addFlow(CountCounts.class)\n      .addQuery(CountQuery.class)\n      .addStream(new Stream(\"text\"))\n      .addDataSet(new CounterTable(Common.tableName))\n      .create();\n  }","commit_id":"257a9f736f1996b4a9311e619cd910f02df2bc79","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void process(Tuple tuple, TupleContext tupleContext, OutputCollector outputCollector) {\n\n    if (Common.debug)\n      System.out.println(this.getClass().getSimpleName() + \": Received tuple \" + tuple);\n\n    byte[] body = tuple.get(\"body\");\n    String text = body == null ? null :new String(body);\n\n    Tuple output = new TupleBuilder().\n        set(\"text\", text).\n        create();\n\n    if (Common.debug)\n      System.out.println(this.getClass().getSimpleName() + \": Emitting tuple \" + output);\n\n    outputCollector.add(output);\n\n    if (Common.count) {\n      // emit an increment for the total number of documents ingested\n      Increment increment = new Increment(keyTotal, 1);\n      outputCollector.add(increment);\n    }\n  }","id":91994,"modified_method":"@Override\n  public void process(Tuple tuple, TupleContext tupleContext, OutputCollector outputCollector) {\n\n    if (Common.debug) {\n      System.out.println(this.getClass().getSimpleName() + \": Received tuple \" + tuple);\n    }\n    byte[] body = tuple.get(\"body\");\n    String text = body == null ? null :new String(body);\n\n    Tuple output = new TupleBuilder().\n        set(\"text\", text).\n        create();\n\n    if (Common.debug) {\n      System.out.println(this.getClass().getSimpleName() + \": Emitting tuple \" + output);\n    }\n    outputCollector.add(output);\n\n    if (Common.count) {\n      // emit an increment for the total number of documents ingested\n      this.counters.increment(keyTotal);\n    }\n  }","commit_id":"257a9f736f1996b4a9311e619cd910f02df2bc79","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.builder()\n      .setApplicationName(\"SimpleWriteAndReadDemo\")\n      .addFlow(SimpleWriteAndRead.class)\n      .addStream(new Stream(\"text\"))\n      .create();\n  }","id":91995,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.builder()\n      .setApplicationName(\"SimpleWriteAndReadDemo\")\n      .addFlow(SimpleWriteAndRead.class)\n      .addStream(new Stream(\"text\"))\n      .addDataSet(new KeyValueTable(Common.tableName))\n      .create();\n  }","commit_id":"71c5380f890b24e7025e886c2d8e310ec2bbde6c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void process(Tuple tuple, TupleContext tupleContext,\n                      OutputCollector outputCollector) {\n    if (Common.debug)\n      System.out.println(this.getClass().getSimpleName() +\n          \": Received tuple \" + tuple);\n\n    // perform inline read of key\n    byte [] key = tuple.get(\"key\");\n    ReadKey read = new ReadKey(key);\n    DataFabric fabric =\n      getFlowletContext().getDataFabric();\n    try {\n      OperationResult<byte []> value = fabric.read(read);\n\n      if (Common.debug) {\n        if (value.isEmpty()) {\n          System.out.println(this.getClass().getSimpleName() +\n              \": No value read for key (\" + new String(key) + \")\");\n        } else {\n          System.out.println(this.getClass().getSimpleName() +\n              \": Read value (\" + new String(value.getValue()) +\n              \") for key (\" + new String(key) + \")\");\n        }\n      }\n    } catch (OperationException e) {\n      System.err.println(this.getClass().getSimpleName() + \":  Error \" +\n          \"reading value for key (\" + new String(key) + \"): \" + e.getMessage());\n    }\n  }","id":91996,"modified_method":"@Override\n  public void process(Tuple tuple, TupleContext tupleContext,\n                      OutputCollector outputCollector) {\n    if (Common.debug)\n      System.out.println(this.getClass().getSimpleName() +\n          \": Received tuple \" + tuple);\n\n    // perform inline read of key\n    byte [] key = tuple.get(\"key\");\n    try {\n      byte [] value = this.kvTable.read(key);\n\n      if (Common.debug) {\n        if (value == null) {\n          System.out.println(this.getClass().getSimpleName() +\n              \": No value read for key (\" + new String(key) + \")\");\n        } else {\n          System.out.println(this.getClass().getSimpleName() +\n              \": Read value (\" + new String(value) +\n              \") for key (\" + new String(key) + \")\");\n        }\n      }\n    } catch (OperationException e) {\n      System.err.println(this.getClass().getSimpleName() + \":  Error \" +\n          \"reading value for key (\" + new String(key) + \"): \" + e.getMessage());\n    }\n  }","commit_id":"71c5380f890b24e7025e886c2d8e310ec2bbde6c","url":"https://github.com/caskdata/cdap"},{"original_method":"public void configure(FlowSpecifier specifier) {\n    specifier.name(\"SimpleWriteAndRead\");\n    specifier.email(\"me@continuuity.com\");\n    specifier.application(\"End2End\");\n    specifier.stream(\"text\");\n    specifier.flowlet(\"source\", StreamSource.class, 1);\n    specifier.flowlet(\"writer\", WriterFlowlet.class, 1);\n    specifier.flowlet(\"reader\", ReaderFlowlet.class, 1);\n    specifier.input(\"text\", \"source\");\n    specifier.connection(\"source\", \"writer\");\n    specifier.connection(\"writer\", \"reader\");\n  }","id":91997,"modified_method":"public void configure(FlowSpecifier specifier) {\n    specifier.name(\"SimpleWriteAndRead\");\n    specifier.email(\"me@continuuity.com\");\n    specifier.application(\"End2End\");\n    specifier.stream(\"text\");\n    specifier.dataset(Common.tableName);\n    specifier.flowlet(\"source\", StreamSource.class, 1);\n    specifier.flowlet(\"writer\", WriterFlowlet.class, 1);\n    specifier.flowlet(\"reader\", ReaderFlowlet.class, 1);\n    specifier.input(\"text\", \"source\");\n    specifier.connection(\"source\", \"writer\");\n    specifier.connection(\"writer\", \"reader\");\n  }","commit_id":"71c5380f890b24e7025e886c2d8e310ec2bbde6c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void process(Tuple tuple, TupleContext tupleContext,\n                      OutputCollector outputCollector) {\n    if (Common.debug)\n      System.out.println(this.getClass().getSimpleName() +\n          \": Received tuple \" + tuple);\n\n    // text should be in the form: key=value\n    String text = tuple.get(\"text\");\n    String [] params = text.split(\"=\");\n    if (params.length != 2) return;\n    byte [] key = params[0].getBytes();\n    byte [] value = params[1].getBytes();\n    Write write = new Write(key, value);\n    outputCollector.add(write);\n    Tuple outputTuple = new TupleBuilder().\n          set(\"key\", key).\n          create();\n    outputCollector.add(outputTuple);\n  }","id":91998,"modified_method":"@Override\n  public void process(Tuple tuple, TupleContext tupleContext,\n                      OutputCollector outputCollector) {\n    if (Common.debug)\n      System.out.println(this.getClass().getSimpleName() +\n          \": Received tuple \" + tuple);\n\n    // text should be in the form: key=value\n    String text = tuple.get(\"text\");\n    String [] params = text.split(\"=\");\n    if (params.length != 2) return;\n    byte [] key = params[0].getBytes();\n    byte [] value = params[1].getBytes();\n\n    this.kvTable.stage(new KeyValueTable.WriteKey(key, value));\n\n    Tuple outputTuple = new TupleBuilder().\n          set(\"key\", key).\n          create();\n    outputCollector.add(outputTuple);\n  }","commit_id":"71c5380f890b24e7025e886c2d8e310ec2bbde6c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void process(Tuple tuple, TupleContext tupleContext, OutputCollector outputCollector) {\n    if (Common.debug)\n      System.out.println(this.getClass().getSimpleName() + \": Received tuple \" + tuple);\n\n    String token = tuple.get(\"word\");\n    if (token == null) return;\n    String field = tuple.get(\"field\");\n    if (field != null) token = field + \":\" + token;\n\n    if (Common.debug)\n      System.out.println(this.getClass().getSimpleName() + \": Emitting Increment for \" + token);\n    outputCollector.add(new Increment(token.getBytes(), 1));\n  }","id":91999,"modified_method":"@Override\n  public void process(Tuple tuple, TupleContext tupleContext, OutputCollector outputCollector) {\n    if (Common.debug) {\n      System.out.println(this.getClass().getSimpleName() + \": Received tuple \" + tuple);\n    }\n    String token = tuple.get(\"word\");\n    if (token == null) {\n      return;\n    }\n    String field = tuple.get(\"field\");\n    if (field != null) {\n      token = field + \":\" + token;\n    }\n\n    if (Common.debug) {\n       System.out.println(this.getClass().getSimpleName() + \": Emitting Increment for \" + token);\n    }\n    this.counters.stage(new KeyValueTable.IncrementKey(token.getBytes(), 1));\n  }","commit_id":"dcdf5a8ead645a78313126535eaf6fa35d5c42ea","url":"https://github.com/caskdata/cdap"}]